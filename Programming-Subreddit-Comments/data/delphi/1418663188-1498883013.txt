Curious, what precipitated the move to Delphi for the codebase?
might just save the logic and rewrite everything
My favorite Delphi built program back in the day was XNews which was a very basic but very easy to use Usenet reader. 
Some of this information isn't accurate. According to some of the original people who worked on Skype, only the Windows UI of Skype is written in Delphi. The core of Skype is and always has been written in portable C/C++. Also, it's hard to call almost anything other than Skype on this list "famous". 
Looks like this ebook, and every other Pakt Publishing ebook, is on sale online for $5 through January 6th, 2015. Good time to grab a copy! https://www.packtpub.com/application-development/delphi-cookbook 
It is clear that the look and feel isn't fully native, but the code itself is run natively. This is a key benefit for app shops who want to strike a balance of development costs per platform and delivering a product. Embarcadero isn't alone in this arena, there are html, unity, and more solutions as well, all mimicking the UI. These products are for those who want to push a product out the door quickly. And those vendors target that market. embarcadero is right on the money, using a strongly typed fast language compiled to native code. As for the shots at RAD development, he should look to winforms, which does the exact same thing. His arguments should not be at firemonkey, but at RAD in general. Tbh I stopped reading past that point, many of his arguments are directed at firemonkey and embarcadero when it actually applies to a much wider set of development styles and solutions. Sounds like he has a grudge. 
Agreed. It's not an unusual approach at all. And they've managed to do it rather well. I remember this article when it was first posted, almost two years ago now. I wish it would just go away, or the author would post a more reasonable followup. The article doesn't help anyone. The poster has also deleted their account, which is odd... post something negative and vanish?
There are various perspectives from which one can look at the matter. Sebastian's view is the one from the software engineer aiming at developing more complex solutions and those who have to make a living from software development as a business. That's the view of a 'Calvinist' to Delphi. The tragedy of this model is that applying computer science in order to enable others would weaken the own business. If someone does really sell a good application via the app-store and wants to make money that way the vendors today simply provide what does make sense from their perspective. The moment someone simply does not need to make a living from apps the point will be - is the result satisfactory to me.
There are occasional oddities, such as using anonymous methods from C++ (a Delphi language construct for which there isn't a direct translation in C++, although I think this has either improved in XE7 or is on the table to be improved in XE8, I can't remember.) However, for the vast majority of stuff - and writing components definitely falls into this - there aren't many or any difficulties at all. You just write in C++. Components specifically have some macros and special definitions to allow compatibility, eg message methods. I spent eight years (until early this year) working in C++ Builder and can answer any questions you have :) It's not as nice an IDE for C++ as VS is, because its in-IDE language support (eg for code completion) is not as good. However, the 64-bit compiler is great, and C++ Builder cannot be beaten for UI work through the VCL - nothing MS has comes close. Nor is there any equivalent to FMX. If you already have XE5, try that, but be aware that XE6+ is widely regarded as a much better and more stable IDE - it was a release where they focused on quality not features. If you're coming from (say) C++Builder 6, then try XE5 since the difference is amazing. But if you can, upgrade to XE7. Note that XE8 is coming out soon too so buy the maintenance agreement too, then you'll get a year's worth of updates.
Interesting! Seems I've found the right ear :) I do have C++ Builder XE5 currently as I'm primarily a C++ guy. But my concern is really with potential impedance mismatch in the use of libraries, controls and the like. It seems from the documentation, etc. that the native language for the VCL is Delphi. This is all only an issue because I'm a server side developer who's hit upon an idea for a native gui rich project. So I want to get going as fast as I reasonably can. I know I'm going to have to customize controls and I'd like to ship for a mobile platform or two (though that's far from critical) AND I'll be dealing with a hopefully database agnostic back-end. I've always had a warm spot for Object Pascal since I cut my teeth on the Borland tools in the 80s and 90s, from Turbo Pascal 1.0 through 5.5 and Turbo C through C++ 4.5 and the initial couple versions of C++ Builder and Delphi. So I think I can really come at it clean and be productive pretty quickly, though it's probably been the better part of a decade since I've opened a file and seen ":=" :). I'd certainly love to be able to get RAD studio pro with a maintenance contract. But this is off hours stuff and I'm just not anywhere near that flush. As it is, the Pro upgrade with the FireDac and the mobile kit is more than I should be spending given my personal economic climate. Sounds like at the very least I should wait until XE8 (depending on what constitutes 'soon' ;).) Maybe what I'll do is pull down the XE7 demo just to get a taste. 
You're welcome! By the way, if you can then join the [Delphi](https://plus.google.com/communities/103113685381486591754) and [C++ Builder](https://plus.google.com/communities/118315259185736124693) groups in Google+. The Delphi one is more active, of course, but both have a much bigger number of active members than reddit or the Embarcadero newsgroups. If you have a general VCL / component (ie not C++ specific) question posting in the Delphi group is fine. You can use Delphi code in C++ Builder, although since I have RAD Studio I'm not sure of the specifics when you have only CB installed. But in theory if you add a .pas file to a CB project, it will compile and link, and you just include the header (unitname.hpp) in your C++ projects. If you go that route, you could for example write your custom components in Delphi, or mix Delphi and C++ code. XE8: Embarcadero has been on a six-month release cycle for a couple of years now, although in practice it's turned out to be [5/7/5/7 months](http://delphi.wikia.com/wiki/Delphi_Release_Dates) :) But I would expect XE8 in March or April. Getting Maintenance is always a good idea and if you really want to get started, I'd buy XE7 now, upgrade to XE8 in March, and then because Maintenance runs for a year get XE9 for free in September :)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Delphi Release Dates**](https://delphi.wikia.com/wiki/Delphi%20Release%20Dates): [](#sfw) --- &gt; &gt;* This is the date the product was announced. It may not be the actual "release" date (i.e. when it was released to manufacturing). ^Interesting: [^Delphi](https://delphi.wikia.com/wiki/delphi) ^| [^Delphi ^for ^PHP](https://delphi.wikia.com/wiki/delphi for php) ^| [^Delphi ^8](https://delphi.wikia.com/wiki/delphi 8) ^| [^Delphi ^7](https://delphi.wikia.com/wiki/delphi 7) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikiabot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cnham32) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikiabot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cnham32)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikiabot/wiki/index) ^| [^Source](https://github.com/Timidger/autowikiabot-py) ^(Please note this bot is in testing. Any help would be greatly appreciated, even if it is just a bug report! Please checkout the) [^source ^code](https://github.com/Timidger/autowikiabot-py) ^(to submit bugs)
Delphi progressing very well up the list.
Who is BigChimp? Did he contribute to the VIC-20 in some way?
Sorry to hear you've had quite enough of VMs, interpreters and common runtime environments; they seem to be the future. But if you want fast code, Delphi might not be the best choice. It's still using a million-line single-pass compiler written in ancient C with no comments (!!!). There's work to convert the compiler to LLVM, but they've been talking about that for two years now. In the meantime, Java and C# score better than Delphi on SciMark and Java beats Delphi on Tiger Hash. On a very small benchmark I did Delphi's compiler couldn't even be bothered converting division by ten to bit-shifting operations. The result was that the Delphi code ran 3x slower than C and FreePascal was much closer to C. What was really funny was that I wrote the benchmark in Python too and using Cython which can translate parts of Python to C or C++ even the Python benchmark was 3x faster than Delphi. :-( Worse, consider TinyC, a C compiler designed to fit (along with an OS) on a floppy disk! It naturally has little room for optimizations, so I believe it has only three; one of those is changing division to bit-shifting operations. Even TinyC can outperform Delphi in some benchmarks. :-( And good luck if you believe that Microsoft, and only Microsoft, tools are persnickety. I've got a long list of Delphi issues. Delphi has closures - but you can't use the enclosed variable in a for loop because of "optimization". You can't use a 64-bit integer in a for loop in 64-bit Delphi because of presumably the same "optimization". Sets are limited to 256 items of a contiguous nature, including integers only between the range of 0..255. This limitation exists since Turbo Pascal and is because rather than being a set it's really implemented as a binary array. It's not part of ISO Pascal. Enumerations have their issues, including not being able to get values if you're assigning custom values to the enums. Presumably this will never be fixed because of "backward compatibility" (to what I have no idea). Worse, let's say you have enums you assign the values 1, 3 and 6 to and the name of the enum type is "Size". x := Size(5) would be considered valid code and compile! Apparently they use binary arrays with enums too. If your enum type is SomeEnum = (e1, e2, e3=1) then e1=0 but both e2 and e3 equal 1. You can't iterate through enums either. There are lots of other issues associated with RTTI, generics, etc. That's not getting into compiler memory issues, IDE issues, etc. Heck, there are third party products just to get around a lot of the issues with the IDE. Embarcadero's products aren't going to be a panacea from niggling issues and bizarre design decisions. It's not going to give you any faster code either. C++ Builder is using LLVM now and Delphi, which will eventually, is using a noncompetitive and outdated compiler right now. 
&gt;And going with this theme of longevity what if in 1 or 2 years &gt;Delphi/C++ &gt;builder is no longer around? What if they pack it in? Honestly, we're already well into needing to ask questions like that. Major publishers stopped publishing Delphi books after 2005, we have no more magazines, no physical conferences in the U.S. anymore, no online courses, no official package manager, Pascal stopped being used on AP CS exams after 98 or 99, the jobs are long gone in most parts of the world, EMBT got taken private in the first place because it was, in the worlds of The Motley Fool, "a struggling database tools vendor", and there's no sign they're getting any traction with AppMethod. Microsoft already rules the commercial development tool world on Windows, but as Borland predicted there isn't much of a market for commercial development tools anymore. The fact they just released a Pro-level VS for free for 1-5 developer companies reflects to what degree open source has put pressure on them. Since EMBT jumped into mobile Xamarin has gained a lead in cross-platform mobile tool development. Proprietary languages like Delphi are a complete anachronism today. And there's simply no source for new developers; kids today pop in their Ubuntu disk and download all the dev tools and languages they want for free. Heck I just put together a home/development PC for Christmas and it's got 100% free and/or open source software on there, including the OS. There wasn't a language around I couldn't get an open source compiler/interpreter/VM for. An Enterprise-grade RDBMS like PostgreSQL, DVCS like Mercurial, reporting - BIRT, and more data mining, analysis, machine learning and mathematical software than I can name and I now have a better suite of data-crunching and development software than I received when I worked at the HQ of a billion-dollar U.S. retailer! That the software was all free is just amazing. Anyway, I guess I agree with you but I think we're really well into the twilight of commercial languages and development tools and there's no sign EMBT can bring in any new blood or is willing/able to put the money into building a world-class team that can compete with the best (often cheaper) tools that are leading the pack today.
Compared to [Tiobe](http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html), where C is #1, and Delphi is 20
Castalia looks interesting. I would kill for robust re-factoring in Delphi. After using Visual Studio, Delphi is in the dark ages. **Declaring Methods** - Visual Studio: http://i.imgur.com/PtyejmE.png **Ctrl+.**, **Enter**. And it automatically knows the parameter types, return type, and gives the parameters names - Delphi: http://i.imgur.com/VfMwLXI.png If the capability is there, they hide it well. **Adding a member** - Visual Studio: http://i.imgur.com/kngy6BO.png **Ctrl+.**, **Enter**. A statically typed language in a statically typed compiler can determine types statically. - Delphi: http://i.imgur.com/JOS9kCo.png Thank you Ralph. **Adding an item to the uses clause** - Visual Studio: http://i.imgur.com/YbFJeKh.png **Ctrl+.**, **Enter**. - Delphi: http://i.imgur.com/ksDTJe1.png Right-click, mouse move, click, mouse move, click, click, click. **Inspecting variables** - Visual Studio: http://i.imgur.com/l31nqMU.png Code completion, and the killer app of Visual Studio: able to see strings formatted with their CRLFs - Delphi: http://i.imgur.com/3LuXEWv.png No way to view the string nicely (esp. for long SQL statements, HTML, xml, markdown, or text) And the Visual Studio equivalent of the *"Evaluate Modify"* dialog is useful in that it lets you drill into a *list* of objects, and then into the properties of the object. All in one dialog. Delphi has no way to do the same; but does have functionality that approaches it spread over: - Evaluate/Modify - Watch - Debug Inspector - *hover* inspect The Visual Studio team stood back and tried to provide an elegant interface. It's almost as though the Delphi developers haven't done any hands-on research of competing products. And while you're at it, Bor...Impr....Cod....Embarcadero, if you could: - fix the backlog of VCL bugs - fix the IDE crashes - remove the six-second security check launch delay that would be great.
&gt; fix the backlog of VCL bugs &gt; fix the IDE crashes if I thought they were going to seriously think about doing this, I'd seriously think about renewing my SA subscription again (etc). As it is, I stopped at XE3 after about a decade of doing the annual-pony-up. 
&gt;compiling the code in Freepascal/Lazarus on Windows does produce a DLL, but it crashes the game Are the calling conventions the same? Does the DLL access structures that end up with different sizes / data types even when the source is the same? Also try asking the FreePascal/Lazarus devs directly. &gt;The DLL also is triple the size of the pre-compiled one distributed as a sample Disable debugging features, iirc the FP/Lazarus FAQ mentions it.
Try asking on either Stack Overflow (where people will ask you for much more information than you have included here) or the Delphi Developers Google+ group: https://plus.google.com/communities/103113685381486591754 Both have far more people than the Delphi reddit. That said, F1's comment below is worth reading / replying to. I'll add a question, Does the DLL use any unusual types (eg strings, for example, which are compiler-managed?) If so, you'll need to use Delphi rather than FPC to compile it. It would be useful to see the DLL's exported functions - can you add them to the post please? If you ask on SO or G+, please include them there too.
Can you explain how the new software maintenance is different from the software assurance that I just renewed?
It is live: https://www.reddit.com/r/delphi/comments/2vft14/we_are_developer_evangelists_for_embarcadero/
I bought an ELM 327 OBDII (Clone) device with bluetooth and tried to get it to work with Delphi XE7. One problem is I can't pull the truck in the house to work on it and range is limited. I understand from the Demos about Bluetooth Classic &amp; LE, but I heard something about 3 &amp; 4 on today's webinar. Do you have any recommendations for Delphi resources / examples connecting to the bluetooth devices? This device should react to commands similar to the old Hayes AT commands used in old 1200/2400/9600/14400/56000 baud modem days.
Do you know of a museum I can donate this to? http://i.imgur.com/0TDkcfE.jpg
A little feedback on Delphi Week. Please remind us to save the logs before turning off. I lost my questions :-( 
It's common practice that after a new major Delphi release a developer is asked to upgrade latest Delphi Version to get bug fixes. Bugs are typically not applied to prior Delphi versions at that point. It appears that there is a change to this policy with the announcement of the [Update Subscription](http://www.embarcadero.com/products/rad-studio/update-subscription) **I really like this!** But, I have questions on the execution of this. When bugs are fixed in the new version, how are bugs chosen to be back ported to prior versions? or in other words... How is a bug determined to be critical so it will be back ported? What is the mechanism (if any) is there for customers request for a bug fix to be back ported? 
Good suggestion. If there is enough interest we can probably do that.
The current plan is command-line Linux support only for now. Who knows what the future will hold.
More [Update Subscription](http://www.embarcadero.com/products/rad-studio/update-subscription) Questions. How does a customer get notified of new updates and hot fixes? Is there mailing list we can subscribe too? How does a customer get early beta access? Where does a customer go to get access to the exclusive content? 
Sweet!
Remember to save the logs!
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**OBD-II PIDs**](https://en.wikipedia.org/wiki/OBD-II%20PIDs): [](#sfw) --- &gt; &gt;__OBD-II PIDs__ ([On-board diagnostics](https://en.wikipedia.org/wiki/On-board_diagnostics) __Parameter IDs__) are codes used to request data from a vehicle, used as a diagnostic tool. &gt;[SAE](https://en.wikipedia.org/wiki/SAE_International) standard J/1979 defines many PIDs, but manufacturers also define many more PIDs specific to their vehicles. All light duty vehicles (i.e. less than 8,500 pounds) sold in [North America](https://en.wikipedia.org/wiki/North_America) since 1996, as well as medium duty vehicles (i.e. 8,500-14,000 pounds) beginning in 2005, and heavy duty vehicles (i.e. greater than 14,000 pounds) beginning in 2010, [*[citation needed](https://en.wikipedia.org/wiki/Wikipedia:Citation_needed)*] are required to support OBD-II diagnostics, using a standardized [data link connector](https://en.wikipedia.org/wiki/Data_link_connector_(automotive\)), and a subset of the SAE J/1979 defined PIDs (or SAE J/1939 as applicable for medium/heavy duty vehicles), primarily for state mandated [emissions](https://en.wikipedia.org/wiki/Vehicle_emissions_control) [inspections](https://en.wikipedia.org/wiki/Vehicle_inspection). &gt;Typically, an [automotive technician](https://en.wikipedia.org/wiki/Auto_mechanic) will use PIDs with a [scan tool](https://en.wikipedia.org/wiki/Scan_tool_(automotive\)) connected to the vehicle's OBD-II connector. &gt; &gt;* The technician enters the PID &gt;* The scan tool sends it to the vehicle's [controller–area network](https://en.wikipedia.org/wiki/Controller%E2%80%93area_network) (CAN)-bus, VPW, PWM, ISO, [KWP](https://en.wikipedia.org/wiki/Key_Word_Protocol). (After 2008, CAN only) &gt;* A device on the bus recognizes the PID as one it is responsible for, and reports the value for that PID to the bus &gt;* The scan tool reads the response, and displays it to the technician &gt; --- ^Interesting: [^Malfunction ^indicator ^lamp](https://en.wikipedia.org/wiki/Malfunction_indicator_lamp) ^| [^OBDuino](https://en.wikipedia.org/wiki/OBDuino) ^| [^On-board ^diagnostics](https://en.wikipedia.org/wiki/On-board_diagnostics) ^| [^CAN ^bus](https://en.wikipedia.org/wiki/CAN_bus) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cohaia6) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cohaia6)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Unicode is fundamentally part of the way things work in Delphi now. You can still deal with ANSI Strings, but the default strings will be UNICODE now. I've worked at companies that outsourced some of the upgrade process to get everything upgraded to UNICODE. Here are [some resources to help](http://www.embarcadero.com/rad-in-action/migration-upgrade-center). 
That sounds like something [InfoPower FirePower from Woll2Woll](http://www.woll2woll.com/woll2woll-firepower-4.0.html) would work great for what you are trying to do. TMS has some similar and [useful components](http://www.tmssoftware.com/site/tmsfmxpack.asp) as well.
Just to clarify, there will be updates to XE7 even after XE8 is released? In the past there hasn't been updates to a prior version to even update too, let alone have access to it. For instance, I found a bug in Anydac for delphi 2007 that was also present in XE5. But the fix was only applied to the XE7 release. I had to manually apply the code changes to the older versions. Is this going to be different going forward if you have maintenance.
I too have some 2007 and even D7 code. A bigger issue for us is/was 3rd party components that have long since went away. We were using a middle ware data component and lockbox for encryption. Those were slow be updated and lockbox went away until recently. It took a year but I finally built our own middle-ware data component using Tadmemtable and datasnap ( since it has encryption and compression). It is a long road and we still aren't using it in production but there is a light at the end of the tunnel.
Jim, do you know if Delphi 7 boxes are still available for purchase? Keen to see its class diagrams hanging on the wall :) A refresh for newer Delphi versions would be great too.
There are at least 2 Delphi developers in Tulsa Oklahoma. If you are ever passing through, stop in and say hi.
I can't talk about future releases, sorry.
In what way? We still offer [Delphi Starter edition](https://www.embarcadero.com/products/delphi/starter). The upgrade price is [$165 USD online](https://store.embarcadero.com/542/catalog/product.s4246/language.en/currency.USD/?id=OhIKFBRuIz) or $217 new user. I'm actually really enjoying this AMAA. Wasn't sure what sort of questions to expect.
From the [Update Subscription](https://www.embarcadero.com/products/rad-studio/update-subscription) page: &gt;**Ongoing Maintenance and Hot-ixes for Previous Versions** &gt; In the middle of a development cycle on an older IDE version? The RAD Studio team will now continue to release critical updates and hotfixes for up to two (2) years and three (3) major versions, improving your investment and enabling you to upgrade to the latest version on your schedule. All maintenance updates and hotfixes will only be available to users on an active Subscription and cannot be downloaded or purchased separately. Versions currently under Ongoing maintenance include XE7, XE6, and XE5 versions. Active subscribers will also have immediate access to beta hotfixes, providing the most timely access to critical fixes. All fixes, updates and hotfixes are purely at Embarcadero's discretion. So which updates and hotfixes to be backported is at Embarcadero's discretion, and a lot of that will come down to the technical limitations, but the plan is to make them available on earlier versions, so yes, after XE8 is released, you may get bug fixes on XE7. 
When are you next visiting the UK?
Here is a PDF of that diagram. http://delphi.org/downloads/Delphi7_Vcl.pdf Maybe you can find a print on demand poster place. The Delphi 7 boxes are not available for purchase.
&gt; How does a customer get notified of new updates and hot fixes? Is there mailing list we can subscribe too? There isn't currently a mechanism besides the IDE Update notification. Maybe a good suggestion for the future. &gt; How does a customer get early beta access? Where does a customer go to get access to the exclusive content? I talked to a few people and they are not clear on how this is going to happen yet. The person with the final answer wasn't available. 
I started coding in Turbo Pascal in 1984. Coded in 3.1a through 7.0 up until about 1995. Switched to Delphi 2 and made a great living in Delphi up until about 2008 when I found myself laid off in an industry with young devs saying "What is Delphi?". I still code a lot of my own projects in Delphi, but I don't make my living in it. Delphi is pretty much dead here in Utah (a tech rich place) except for a few holdouts - and all they want is to do is move on to C#, etc. It's a shame. Sorry I don't have a question for you - I just don't see Delphi as being very relevant and I wonder how Embarcadero will ever change that. So many mistakes were made in the last 15 years, so much time lost - everyone moved on. How can Embarcadero change and become a leader again?
You should only donate something that is of no use anymore.
There's always FreePascal / Lazarus...
Earlier, when buying a licensce, I could download older versions like D7, D2007 and newer. Do this still apply?
When Delphi also support Linux servers for Datasnap and alike, I would believe things would change. I also until recently was met with questions why use Delphi. Nobody except you in the world use that technology Transfer to Java.* But then Java started to be cracked and Delphi came with new platforms, so no noone of them ask about that anymore.
Following up on another post. Can you talk about how Delphi is doing. Is development usage up since adding the multiform support. 
&gt; I started coding in Turbo Pascal in 1984. Coded in 3.1a through 7.0 up until about 1995. Switched to Delphi 2 and made a great living in Delphi up until about 2008 when I found myself laid off in an industry with young devs saying "What is Delphi?". I still code a lot of my own projects in Delphi, but I don't make my living in it. I think I found my resume doppelganger...
Yes it does. http://www.embarcadero.com/products/delphi/previous-versions
We have Delphi developers active in Utah. I don't believe it is dead anywhere. As I was saying up above, we are seeing a lot of growth as of late with existing users moving forward, new users coming to Delphi and previous users coming back. 
It seems, that the IDE is still having som .NET internals. When do we get rid of that? When do we get an IDE running on OSX?
I think that it would be great, if Embarcadero started up some open source projects. Here are two suggestions: 1) Image library like Picasa or Lightroom, but of course much better 2) Db based ERP system: Handle Vendors, Customers, Orders, Purchase orders, Business logics, Finance etc, showing good practice in making large systems.
It might be helpful for you to phrase your question with enough specifics for someone to be able to answer. Examples here: http://www.catb.org/esr/faqs/smart-questions.html#beprecise
I'm out of the loop with Delphi in the marketplace 7 years. Last time I was coding in it we were doing cloud based VCL applications using web services. Now I have no idea what they are doing with it. Every company I've been with since 2008 has done all web based application. I hate web based apps, seriously, slow, clunky, 1 thing at a time... Give me the good old days of VCL... :)
I agree with Jamiei. Be specific, otherwise you're just trolling.
I'll do that, but it is easier to do if reminded like DavidI do :-)
Good to see! Perhaps have a note of that twice a year on FB in appropriate group. Seem like most is not aware of it when debats get heated about new versions.
I use php for web applications, also to communicate with my VCL apps using jedi tJvhtmldecoder which make fast and small pages that could contain checks if it is my program that talk to the web or a webbrowser using a encoded signature that server generate when contacting first time sent as a cookie. If incorrect, the browser is sent to the main page of the server and I get a note about who did that :-D
We are doing our part to keep Delphi alive... and are in need of a few more developers. Our problem is that Delphi developers are often older, more established in their careers and community and convincing them to uproot the family for a job in Mississippi is very difficult. I think Embarcadero could do much more to help. The first thing they need to do is to help match Delphi developers to the companies using Delphi. Make the introductions. Trumpet the successes. Advertise the job openings. Get people excited about the opportunities out there. Secondly they need to do whatever possible to foster an atmosphere of Delphi passion in the high schools, colleges, in young independent developers and in those otherwise just starting out. Like I said, the Delphi developer base is getting much older. That means that before you know it, the base will start dying off, literally. I don't see the young minds coming into Delphi as much as older and more experienced developers just getting older and more experienced. Embarcadero should be hosting Pascal hackathons at High Schools and Colleges around the country (or world). Prizes should be something worth getting, but every attendee should get a free copy of Delphi. They should be weekend lock-ins to give enough time to result in complete (or at least functional) proof of concept products, components, libraries, etc. Companies that use Delphi as their main development tool could sponsor the event and use as a hiring opportunity. And who knows, one or two of the products that result could become real products themselves or bought out by those sponsors for their own portfolios. I can say that what Embarcadero is doing now is great from a technology perspective. But it has a long way to go from a community perspective. Oh and if anyone wants to send us a resume, visit us at http://idealss.com/careers. We will entertain the idea of remote workers in the USA if you are an outstanding developer and legal to work in the USA without a visa.
Appmethod is has a lower entry point with the subscription model per platform. We have a lot of advertising and efforts targeted at new developers. I speak at a lot of industry conferences as well as smaller (non-Delphi) developer groups. Always get a lot of excitement. 
Do I get them too?
Visit http://cc.embarcadero.com/reg/delphi and download them.
Are you still developing apps for your Google Glass (since google is suspending the product)?
Ok, looks like I've overlooked the Castalia download - found it now, thanks. What about the EMS licences?
All your presentations on #DelphiWeek and SkillSprints contain a lot of links to further information to Delphi and RAD Studio. Is there something like a "www.embarcadero.com/.../all-links" page already? If not - couldn't you set one up? Possibly containing national sites?
Not sure about Delphi Week, but I do know that all Skill Sprints are listed on this page: http://www.embarcadero.com/landing-pages/skill-sprints 
Thanks for the answer :) I learned about that one in the online sessions. But there have been 5-10 other links the last days. Ok - I know about them now - but I think it would be a great thing to have a central point of information für Delphi. Actually I registered to Twitter and some other platforms for #DelphiWeek. I just can't tell all member of our user group to join xx platforms to gather information. 
So - long term supporters of the product are "unfortunate"? :(
We are saving all of the logs for all of the sessions. So, I will create some blog posts with links. We also capture all of the Q&amp;A logs for the skill sprints - most of the presenters have resource link slides at the end. Many of these also have a URL to a blog post of links :)
If you are on the latest release of our products you can find most of the goodies on your registered user downloads area. If there is something that you can't find in your download area - let me know and I will see what I can do. davidi@embarcadero.com
That's correct - it's not just about how long you have used Delphi, it is also about your investment in Delphi for now and into the future. I am always happy to see everyone coming to our live events, online events, CodeRage(s), #DelphiWeek - that's cool. Then when I look to see what version(s) of Delphi they own, some of you (and you know who you are) do not own every release, or even recent releases. Some developers tell me they are waiting for a feature before moving off an old, pre-embarcadero version. Some are waiting for other reasons. They sometimes tell me that others will purchase releases so that we will use that money to build the features they want. When I look at a developer who tells me that XE7 is too expensive, yet they have been using an older Delphi version for the last 10 years and have received all of the business benefits of that version for so many years. Maybe we should have also charged an annual fee for use of the runtime and deployment?
Yes, Google made a statement that the current apps should continue to work on the next generation of Google Glass that they are planning. It isn't so much that they suspended the product as they are working on a new model.
This is part of what is changing with the new subscription program. The idea is that people on Upgrade Subscription will get special offers beyond the usual sales promos. 
A free Delphi Starter Edition would be a great way to get more public attention for the language and could only benefit you in the long run. Just limit the usage to private projects only, like Visual Studio does.
We are working on the 64-bit compiler for iOS first. You can request to join the beta test at http://community.embarcadero.com/index.php/blogs/entry/if-you-are-doing-ios-development-join-the-beta-to-get-access-to-the-64-bit-toolchain 
I look forward to the Internet support where I can make a closed application that other voluntary people in the organisation can't change my scripts so they quit working. But, they of course can still delete the executable to sabotage the service :-( 
Sorry, iOS is currently of no interest for me. Customers ask for MacOSX-Version of our application, but as we need to link with 64 bit code on the mac side, a 64 bit compiler is needed. The Mac world is nearly completely migrated to 64 bit so Delphi's Mac support is a bit limited that way.
Does the Delphi compiler strip out unused use file includes and unused segments of the used ones from the resultant application to reduce its size? I'm assuming not, and if not, is there a functional reason such an optimization shouldn't be done? I figure it would take time to do and could be limited to production builds but the compiler is the tool that knows all of the dependencies.
You can get Diego's TI Sensor Tag demo code on Code Central http://cc.embarcadero.com/item/30132
With Delphi FM it's possible to intercept incoming sms like the following Java sample? public void onReceive(Context context, Intent intent) { Bundle bundle = intent.getExtras(); SmsMessage[] msgs = null; String str = ""; if (bundle != null) { //---retrieve the SMS message received--- Object[] pdus = (Object[]) bundle.get("pdus"); msgs = new SmsMessage[pdus.length]; for (int i=0; i&lt;msgs.length; i++){ msgs[i] = SmsMessage.createFromPdu((byte[])pdus[i]); str += "SMS from " + msgs[i].getOriginatingAddress(); str += " :"; str += msgs[i].getMessageBody().toString(); str += "\n"; } //---display the new SMS message--- Toast.makeText(context, str, Toast.LENGTH_SHORT).show(); } }
Something like this: http://delphi-android.blogspot.dk/2013/10/how-to-fetch-sms-messages-from-android.html
I have already seen this post, but this code read the sms from inbox sms (in this case the notification of the incoming sms is shown). I need to intercept it before it is written in inbox sms so the notification isn't shown (like the Java code I have posted before). My problem is that I don't know how to transform then TJObject in (Object[] pdus = (Object[]) bundle.get("pdus")) in an array of bytes (msgs = new SmsMessage[pdus.length]; for (int i=0; i&lt;msgs.length; i++){ msgs[i] = SmsMessage.createFromPdu((byte[])pdus[i]))
&gt; - The reason the button can be pressed multiple times is that the enabled is set back to true after the task is started and not And not...after the task completes? And the second iteration: if Assigned(ListBox1) then Is there any situation in which `ListBox1` would not be assigned? I assume the idea is to set: procedure TForm5.FormDestroy(Sender: TObject); begin ListBox1 := nil; Task.Cancel; end; Which is, oh my god, so painful. I really don't want to have to try to convince the `Task` code to work correctly against the UI thread. I just want it to work. The other painful thing is: TThread.Queue(...); I've done enough multi-threaded programming to know that multihreaded programming is ***hard***, not easy to get right, and always a crap-shoot if it's going to crash. I suppose the ideal solution would be: procedure TForm5.Button1Click(Sender: TObject); async; begin Button1.Enabled := False; await SlowProc; Button1.Enabled := True; end; function TForm5.SlowProc: ITask; async; begin await TTask.Delay(10000); // simulate long process Listbox1.Items.Add('10 Seconds'); end; And then compiler magic that returns you to the GUI thread whenever you're done awaiting. Which is functionally identical to: procedure TForm5.Button1Click(Sender: TObject); var task: ITask; begin Button1.Enabled := False; t := SlowProc; task.Wait; Button1.Enabled := True; end; function TForm5.SlowProc: ITask; var task: ITask; begin task := TTask.Delay(10000); // simulate long process task.Wait; Listbox1.Items.Add('10 Seconds'); end; Except that the context is automatically brought back to where i was after the `.Wait`. C'mon Delphi guys!
thx a lot.
Have you any news? Regards
Can we have a list of ios and android applications that has been created by firemonkey?
Here is a few from the list: Digifort Mobile Client - https://play.google.com/store/apps/details?id=com.Digifort.MobileClient Gem Genie - https://play.google.com/store/apps/details?id=com.embarcadero.GemGenie Bug Smasher - https://play.google.com/store/apps/details?id=com.embarcadero.bugsmasheren Flappy Wallet - https://play.google.com/store/apps/details?id=com.embarcadero.flappywallet Fmx Time - https://play.google.com/store/apps/details?id=com.thierrylaborde.FmxTime Fmx Rubik's Cube - https://play.google.com/store/apps/details?id=com.thierrylaborde.FmxRubiksCube Drug Guard - https://play.google.com/store/apps/details?id=com.embarcadero.drugGuard Antibiotics Guard - https://play.google.com/store/apps/details?id=com.medical.effect.AntibioticsGuard Pasto Blend - https://play.google.com/store/apps/details?id=com.embarcadero.PastoBlend iWDPro - https://play.google.com/store/apps/details?id=com.embarcadero.iWDpro KuzSTU - https://play.google.com/store/apps/details?id=com.embarcadero.KuzSTU dbCalc - https://play.google.com/store/apps/details?id=com.embarcadero.dBCalc dbDelta - https://play.google.com/store/apps/details?id=com.embarcadero.dBDelta Slot - https://play.google.com/store/apps/details?id=com.embarcadero.slot Konverter - https://play.google.com/store/apps/details?id=com.embarcadero.konverter FileViewer - https://play.google.com/store/apps/details?id=com.embarcadero.FileViewer DNC Remote - https://play.google.com/store/apps/details?id=com.embarcadero.dncremote Cone Calc - https://play.google.com/store/apps/details?id=com.ilogic.conecalc True Position - https://play.google.com/store/apps/details?id=com.ilogic.truepos Darts for Android - https://play.google.com/store/apps/details?id=com.embarcadero.Androiddarts Manger Halal - https://play.google.com/store/apps/details?id=com.embarcadero.HalalProducts Bulas Teuto - https://play.google.com/store/apps/details?id=com.embarcadero.BulasTeuto Free Drawing - https://play.google.com/store/apps/details?id=eu.andreamagni.FreeDrawing Buzios 360 - https://play.google.com/store/apps/details?id=com.embarcadero.Buzios360 Multiplication tables trainer - https://play.google.com/store/apps/details?id=com.embarcadero.MultiTabL Sabbe Mobile - https://play.google.com/store/apps/details?id=com.embarcadero.SabbeMobile iCPS - https://play.google.com/store/apps/details?id=com.embarcadero.iCPS Kids App Touch Puzzle - https://play.google.com/store/apps/details?id=com.embarcadero.ForKids Cooky Spanish - https://play.google.com/store/apps/details?id=com.embarcadero.CookySpanish Cálculo Revisional - https://play.google.com/store/apps/details?id=com.embarcadero.CalculusFinanciamento Teles Terminal - https://play.google.com/store/apps/details?id=com.embarcadero.Terminal Lotto Previsioni - https://play.google.com/store/apps/details?id=com.marijsoft.LottoPrev MP3 Player - https://play.google.com/store/apps/details?id=com.MarijSoft.mp3player Televideo Rai - https://play.google.com/store/apps/details?id=com.marijsoft.MTelevideo Video Player - https://play.google.com/store/apps/details?id=com.MarijSoft.videoplayer Lotto Metodo - https://play.google.com/store/apps/details?id=com.marijsoft.diecilotto Router List Client - https://play.google.com/store/apps/details?id=com.marijsoft.routerdbdsnap Lotto Rapido - https://play.google.com/store/apps/details?id=com.MarijSoft.LottoRapido Router List Password - https://play.google.com/store/apps/details?id=com.marijsoft.RouterList MarijLotto Gold - https://play.google.com/store/apps/details?id=com.marijsoft.ambosecco Einheitenumrechner Lüftung - https://play.google.com/store/apps/details?id=com.embarcadero.ConvertUI Inventory Plus Mobile - https://play.google.com/store/apps/details?id=com.embarcadero.InventoryPlus Bacchiglione Free - https://play.google.com/store/apps/details?id=com.marijsoft.bacchiglione Bacchiglohttps://play.google.com/store/apps/details?id=com.marijsoft.bacchiglionepro Vinci Super Enalotto - https://play.google.com/store/apps/details?id=com.marijsoft.VSEnalotto News alternativa - https://play.google.com/store/apps/details?id=com.marijsoft.CorrectNews StopWatch with Average Feature - https://play.google.com/store/apps/details?id=com.embarcadero.Stop_Watch Ben Komik Fikra - https://play.google.com/store/apps/details?id=com.embarcadero.FikraBul Doutor Teuto - https://play.google.com/store/apps/details?id=com.embarcadero.DoutorTeuto Daily Alarm Clock - https://play.google.com/store/apps/details?id=com.embarcadero.Clock Dual Display Calculator - https://play.google.com/store/apps/details?id=com.embarcadero.Calculatrice Agenda Test WebService - https://play.google.com/store/apps/details?id=com.embarcadero.TestServerMobile SicNet Produtos - https://play.google.com/store/apps/details?id=com.embarcadero.Produtos lolSounds - https://play.google.com/store/apps/details?id=com.embarcadero.lolSounds Bayan ozel - https://play.google.com/store/apps/details?id=com.embarcadero.BayanOzel GSM remote control - https://play.google.com/store/apps/details?id=com.embarcadero.gas1 JiaZiZeRi - https://play.google.com/store/apps/details?id=com.embarcadero.JiaZiZeRi YiXianQiMenChuanRenPro - https://play.google.com/store/apps/details?id=com.embarcadero.YiXianQiMenChuanRenPro YXZhuGeShenShu - https://play.google.com/store/apps/details?id=com.embarcadero.YXZhuGeShenShu Photo Show - https://play.google.com/store/apps/details?id=com.embarcadero.PhotoShow Photo Snap - https://play.google.com/store/apps/details?id=com.embarcadero.PhotoSnap Quick Quotes - https://play.google.com/store/apps/details?id=com.embarcadero.QuickQuotes Info Man - https://play.google.com/store/apps/details?id=com.embarcadero.InfoMan Euro Millions - https://play.google.com/store/apps/details?id=com.embarcadero.GeneratorEuroMillions cAdd - https://play.google.com/store/apps/details?id=com.embarcadero.exo2 Handball Shot Analyse Small - https://play.google.com/store/apps/details?id=com.embarcadero.THSASmall Handball Shot Analyse prof - https://play.google.com/store/apps/details?id=com.embarcadero.THSAEXtremeProf CHM Password Manager - https://play.google.com/store/apps/details?id=com.embarcadero.CHM FlashBright FlashLight - https://play.google.com/store/apps/details?id=com.embarcadero.FlashLite LedWerk ClientApp - https://play.google.com/store/apps/details?id=com.embarcadero.ClientApp E-Étterem - https://play.google.com/store/apps/details?id=com.embarcadero.E_Etterem BMS Note - https://play.google.com/store/apps/details?id=com.embarcadero.bmsnote Cálculo Cível Judicial - https://play.google.com/store/apps/details?id=com.embarcadero.Calculus Gome - https://play.google.com/store/apps/details?id=com.embarcadero.Gome schlossbauer Info App - https://play.google.com/store/apps/details?id=com.embarcadero.schlossbauerinfoapp Me Ajuda - https://play.google.com/store/apps/details?id=com.embarcadero.MeAjuda Photos - https://play.google.com/store/apps/details?id=com.embarcadero.Photos Trainer Race Area Analyzer - https://play.google.com/store/apps/details?id=com.embarcadero.Trainer The Solent Race Area Analyzer - https://play.google.com/store/apps/details?id=com.embarcadero.TheSolent Weymouth Race Area Analyzer - https://play.google.com/store/apps/details?id=com.embarcadero.Weymouth La Rochelle Race Area Analyzer - https://play.google.com/store/apps/details?id=com.embarcadero.LaRochelle GW-IRIS Celador - https://play.google.com/store/apps/details?id=com.embarcadero.gwCel GENET - https://play.google.com/store/apps/details?id=com.embarcadero.GENET EDMUR Mobile - https://play.google.com/store/apps/details?id=com.embarcadero.EdmurMobile Mediclinic - https://play.google.com/store/apps/details?id=com.embarcadero.mediclinic IBAN Calculator Pro - https://play.google.com/store/apps/details?id=com.embarcadero.IBAN_Rechner Easy Light - https://play.google.com/store/apps/details?id=com.embarcadero.EasyLight Sale App - https://play.google.com/store/apps/details?id=com.embarcadero.SaleApp Contador de Joinhas - https://play.google.com/store/apps/details?id=com.embarcadero.ContadorDeJoinhas Faith Software Browser - https://play.google.com/store/apps/details?id=com.embarcadero.FatihSoftwareBrowser Quick Flashlight - https://play.google.com/store/apps/details?id=com.embarcadero.FlashLight Pasto Deco - https://play.google.com/store/apps/details?id=com.embarcadero.PastoDecoNew HOSxP Mobile - https://play.google.com/store/apps/details?id=com.bms.BMSAndroidApp ER Image Uploder For HOSxP - https://play.google.com/store/apps/details?id=com.embarcadero.ERIMG2HOSxP YDS - https://play.google.com/store/apps/details?id=com.embarcadero.YDS Ruya Tabirleri - https://play.google.com/store/apps/details?id=com.embarcadero.RuyaTabirleri Elka 2014 - https://play.google.com/store/apps/details?id=com.embarcadero.Elka_2014_free Service app demo - https://play.google.com/store/apps/details?id=com.embarcadero.ServiceApp RAD Feed - https://play.google.com/store/apps/details?id=com.wiltonsoftware.RADfeed Lazy Shaker - https://play.google.com/store/apps/details?id=com.tdelphiblog.LazyShaker Dog Said Meow - https://play.google.com/store/apps/details?id=info.lazyproject.dog_said_meow
I'm sorry, I've been laid up ill all week. I've not had a chance to look into it. You could try posting it on Community.Embarcadero.com or StackOverflow.com. sorry I couldn't work on it for you. 
I've seen some 3rd parties create Object Pascal language definitions, but there is no effort to create a OP standard. There are pros and cons to standards. It was decided that the benefits didn't out way the costs. Delphi's Object Pascal is a single sourced language, so it is defined with the release. The clones just copy what they want and change what they want. There is a lot of variety as a result in the clone implementations. If we defined a standard, would the clone implementations that added new language features have to remove those features? That has no benefit. 
&gt; If we defined a standard, would the clone implementations that added new language features have to remove those features? That has no benefit. You'd have to work with the Object Pascal compiler development community to reach an agreed standard. The benefit would be a common standard to develop libraries against which would help to grow the Object Pascal code base. More libraries to choose from makes Object Pascal a more attractive choice for developers.
I'm sorry I have not had a chance to try the code yet. I still hope too. Didn't plan on being in bed sick all week. 
:) I hope now you are well
I've looked into that list, but most of these apps looks and performance are very questionable. My recommendation for you to have the best apps out there to be presented on your website, this will show how feature-rich, stable, performing your apps are.
Ah, ok. I just saw the Qualcomm Snapdragon being used for OnePlus One: https://oneplus.net/one#features Which offer a variety of different processors: https://www.qualcomm.com/products/snapdragon/processors
Yep I managed to root my phone so the drivers must have been installed properly. I did also try reinstalling them but no progress there either. Thanks for the link, I'll check it out in the morning and report back. 
This will be some nice weekend reading! I'm no where near an advanced coder so I'm wondering, would the techniques in these posts be applicable (with some reworking) to Lazarus/Free Pascal?
Firebird 3 api is the new OO c++ based api Old api (c based bindings) will work as before , so from the end user point of view there are no changes : ibx will work as before
I'm *so* stealing this!
You want the demo to be downloadable or you want a BaaS server you can download?
Yes, client examples that are downloadable would be great! Thanks.
All the BaaS tutorials on one page. http://blogs.embarcadero.com/sarinadupont/category/baas-tutorials/
Note: It doesn't support multiple platforms currently. Probably because of the 0/1 based string issue.
Yeah, no.
Ok, first off, they'd never replace the language. Your best case scenario would be an additional product with Nim as it's basis. &gt; Nim compiles to C (and the first versions were actually written in Object Pascal!), so calling existing Pascal code isn't out of the question. This would kill one of the basic features of Delphi (at least for Windows): fast compiles. Adding (at least) one extra step in the compile process would add a fairly large amount of compile time. I would not be surprised to find the long term goal of Embarcadero WRT development languages is to push everything to Clang (as the compiler).
Forget about that. Delphi is 'DB' combined with GUI. The concept of the IDE is limited to the C/S not considering the advantage when it does come to GUI development. Agreed - the ECO System is amazing again today. Also object orientation does not allow to go beyond what was achieved with CASE tools producing generated C (procedural code). You need a systemic perspective on the server side. Python or JVM. To a certain degree we could call those approaches a Smalltalk legacy. C/S and OO failed to ship appropriate results in the context of a system in the 90s and 2k. VS/.net tried to offer multi tiered development in the IDE and never really stated to gain traction while the result provided worked somehow sufficient. Still fairly used considering it's potential. The problem is not that Object Pascal would be old fashioned. The server side is very appealing to developers. There have been several reasons why the shift happened. Money flow from the desktop to the server side and those developers who provided the GUI received the support tickets for example and many more. The web services have been the step after of the creative destruction required after the procedural approach as well as as the pure object oriented approaches combined with C/S failed to succeed in the 90s. Why? An application does become very unstable the moment the RPC does fail. An IDE is an application too. Web applications do not fail in that sense because the GUI is rendered on the server where the business logic does reside. The moment you separate the business logic from the GUI the IDE is no longer required. Even if you implement the server side using an IDE, that does not mean that the IDE was required. You are correct. A modern Delphi would be a total different animal than the existing combination. Tools that serve a different purpose are different. In the current case the return of the shell as a result of the web evolution deeply influenced the acceptance of more common less comfortable development. As you mentioned putting abstraction into the language solves an issue and does not increase the complexity at the tool level. So the 'shell' remains. A more comfortable editor is usually enough. You can always bypass the weakness of an IDE in code but not the other way around. There is no need for EMB to ship another language, since those other languages do exist.
&gt; instead of max function line count, a good metric is the number of statements Agree :)
A while back there was some talk of an official certification by Embarcadero. I don't know if they still do it. Edit: Here is a link - http://www.embarcadero.com/certification I would probably cook something up myself. Preferably something that require use of the Spring4d framework, to make sure they know that.
Try BrainBench. They have a Delphi 6 test that's under their older tests. I've recently taken it for a Delphi gig. It's more than adequate. The only downside is that it doesn't cover newer language fundamentals like Generics and Anonymous Functions, and still covers older Windows stuff like ActiveX. But it's good and kind of challenging. http://www.brainbench.com/
There's a bit more than just mobile features added: http://www.embarcadero.com/products/delphi/whats-new And I wouldn't hold your breath waiting for Linux.
Nice to see some improvements in the IDE. Yea, we aren't holding our breath, but I don't mind flogging the dead horse every now and then as a reminder that people still want this.
Wanted: Package manager demo video. Edit: https://www.youtube.com/watch?v=gDwNmmrr6TA
There's also a new community thingie they started with "AppMethod" to try to cater to the younger crowd, but it seems almost no one uses it: http://community.embarcadero.com/index.php/forum 
Is this a real, open source, third party package repository with API, or is it some type of Embarcadero software store?
A lot of those features come from buying Castalia, and the rest are really playing catch-up with things that are already standard everywhere else (such as package management, a hash library, etc.) I thought Linux was (vaguely) on the roadmap? On the other hand they were talking up the new LLVM compiler for a year and then they said it "wasn't quite ready" for the last version, which would normally mean it would be in the next one. Well... not here either and I don't even see anything on the (cryptic) roadmap that seems to suggest it's coming in 2015 either. Targeting mobile was a good idea - no entrenched competition at the time, unlike Microsoft (and open source) on the desktop. But no Xamarin has gained a major lead over everyone else. I'm beginning to fear we're going to see a repeat of Delphi.NET - EMBT's always going to a step behind but contine to throw needed resources into a losing battle. On the other hand, they're completely dead now for personal use and small 1-5 developer shops, which was the remaining niche, thanks to open source on one hand and Microsoft Visual Studio Community Edition on the other. The lack of serious, specific roadmaps, extended support, a significant ecosystem, single vendor, etc. makes it a non-starter for big enterprises on the other hand. And now they're raising prices. I don't know where they're going to look for a niche now. This could be the start of a long, slow death spiral as raising prices leads to fewer uses leads to rising prices, etc. 
&gt;Nice to see some improvements in the IDE. They had to buy another product to get those. &gt;Yea, we aren't holding our breath, but I don't mind flogging the dead horse &gt;every now and then as a reminder that people still want this. Didn't the 2015 road map suggest it's coming? But then, they talked about a new desktop compiler that never showed up and doesn't seem on the roadmap any more either. Honestly, they just don't have the manpower to support an IDE, two languages, multiple compilers, two frameworks, a database, etc. They don't have the users, either, as they have to keep raising prices and now a support subscription is mandatory if you want any updates at all! I gave up waiting for the new compiler or Linux support and am happily not only running code on, but writing code on, Linux right now courtesy of the open source version of one of JetBrain's IDEs written in Java. I got a whole new computer system at the end of the year for half of what it would have cost to buy a new copy of Delphi. :-) Is FreePascal an option for you in regards to targeting Linux?
Yuck! If they were doing this right they'd have started by buying Torry.net and completely overhauling it, then adding an API to allow anyone to push/pull packages to it programmatically or via the browser, automatically upload on commits to a version control system, etc. 
&gt; Honestly, they just don't have the manpower to support an IDE, two languages, multiple compilers, two frameworks, a database, etc. And still you see them waste all their time on toy features like google glass support.. Like wtf??!
From the looks of it this shouldn't be the case. Is this the exact code you run, without omissions? Why on the second picture the second call is marked as the one yet to be executed, but the Result is already False - isn't that the result of the first call? What is the length of lpBuffer? What's in nSize just before the second call?
Hmm. (Paint antics are actually pretty cool)) How's lpBuffer defined? What if you switch the call order? (First try nSize, then Length(lpBuffer)*SizeOf(WideChar).) Can you also print BytesWritten after each call? Edit: I have just tried this code here on XE3 (use in empty console app): http://pastebin.com/Wnmj6yvs It shows TRUE, TRUE.
Thanks, I hadn't thought of that. The last time I looked there it seemed a little quiet but I think it must have been an off day because that group is definitely thriving. Thanks again!
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Parkinson's law of triviality**](https://en.wikipedia.org/wiki/Parkinson%27s%20law%20of%20triviality): [](#sfw) --- &gt;__Parkinson's law of triviality__, also known as __bikeshedding__, __bike-shed effect__, or __the bicycle-shed example__, is [C. Northcote Parkinson](https://en.wikipedia.org/wiki/C._Northcote_Parkinson)'s 1957 argument that organisations give disproportionate weight to trivial issues. Parkinson observed and illustrated that a committee whose job is to approve plans for a [nuclear power plant](https://en.wikipedia.org/wiki/Nuclear_power_plant) spent the majority of its time with pointless discussions on relatively trivial and unimportant but easy-to-grasp issues, such as what materials to use for the staff bike-shed, while neglecting the less-trivial proposed design of the nuclear power plant itself, which is far more important but also a far more difficult and complex task to criticise constructively. &gt;==== &gt;[**Image**](https://i.imgur.com/6RTwfdE.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:Station_Oudegem_-_Foto_3_\(2009\).png) - *A bike-shed.* --- ^Interesting: [^Parkinson's ^law](https://en.wikipedia.org/wiki/Parkinson%27s_law) ^| [^C. ^Northcote ^Parkinson](https://en.wikipedia.org/wiki/C._Northcote_Parkinson) ^| [^Poul-Henning ^Kamp](https://en.wikipedia.org/wiki/Poul-Henning_Kamp) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cqdyfzh) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cqdyfzh)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
 $xorsum ^= ($last = hash_hmac($algorithm, $last, $password, true)); is the same as $last = hash_hmac($algorithm, $last, $password, true); $xorsum = $xorsum ^ $last; The assignment operator "=" is ":=" in Delphi, and the XOR operator "\^" is "xor". Hope that helps.
Yay just in time for XE8! ;-)
I didn't see any compiler enhancements (e.g. variable hoisting). But I did see that you will have to pay for bug fixes (i.e. Update packs). This is good news!
&gt; the comment section is full of biased Delphi devs. Otherwise know as customers. Apparently happy ones. &gt; Delphi is dead So people keep saying. But that doesn't seem to be the case. &gt; there wont be new projects Except for all of the new projects actually being written year after year. And a wider user base. And consistently increased Delphi revenue. You get the idea...
Check out the Google+ group. People do this, just none of them are young enough to be in Reddit. A DLL is a DLL regardless of the implementing language. AnsiChar is supported in xe.
Good spot. Alongside os/2 warp and CompuServe books though.. 
For Windows and strings use WideString type. It is same as BSTR and allocation/free is managed by the OS. Should be perfectly shared across all modules in process. Delphi uses SysAllocStringLen, SysFreeString and other internally for WideString.
You have got a working application written on the .Net platform and you want to port it to Delphi? Wow.. talk about brain dead..
Seriously. I have no idea what Emb is doing anymore. If only they could compete with fpc/Lazarus and *win*.
Is this old Windows Help format issue under Windows 7 and newer? If yes, you need winhelp.exe.
That's what I'm thinking as well. Delphi 7 uses the old .hlp format which isn't supported anymore out of the box. * [WinHlp for Windows 7](https://www.microsoft.com/en-us/download/details.aspx?id=91) * [WinHlp for Windows 8](https://www.microsoft.com/en-us/download/details.aspx?id=35449) * [WinHlp for Windows 8.1](https://www.microsoft.com/en-us/download/details.aspx?id=40899)
Maybe because you only want to pay one software developer instead of five programmers?
.. and you'll never find that "one developer", because no one wants to stake their career on a dev-tool from the 90s.
You do realize that most programming languages and software development tools used today have roots in the 90s or before right?
Look at the numbers. Delphi jobs don't exist, because the market for it completely crashed in 2008. The language's height was 1998 to 2002. Now it's purely legacy support and Emb is trying to keep it going by developing tools to allow shops with legacy developers to leverage their talent to develop for non Windows platforms. However, FMX and Emb insistence on reinventing the wheel with their own Ux has proved it can't support the vast ecosystem of devices and has been relegated to internal products where the hardware can be controlled... and made sure FMX works correctly. I know. But don't get mad. Just take a look at modern development and ask yourself if you really think you can get another job in Delphi and continue your career. Shouldn't be hard if all you care about is supporting a pizza delivery, tv-ad or freight-trucking software written 20 years ago.. a literal example and the only availability in the Seattle market.
The enterprise app market will be worth $58 billion in 2016 and the fastest way to build multi platform enterprise applications is Delphi. If having a "job" and a "career" working for the man is your thing then by all means use one of the hipster "job" languages. If you want to make money use Delphi to build enterprise apps because the market is exploding.
I disagree. You could build a multiplatform tool like Navicat using these components. Manage databases directly from your mobile devices.
Depends on what you want to build. If you want to build Enterprise apps yes. If you want to build consumer apps maybe. If you want to build 2D games maybe. Don't just settle on one tool and only use that tool. Evaluate each project and pick the right tool accordingly.
Which city are you talking about? Job offers for Delphi are highly dependent on the location. But the more tool and languages you know, the better. You may be surprise how Delphi is productive, especially in comparison with other mainstream solutions. For a freelance developper, Delphi is just great: you have all you need at hand. For mobile apps, I usually not use Delphi FMX, but rather SmartMobileStudio + PhoneGap. So it targets more platforms, and you are not required to publish the app in the iOS/Android stores: just publish the HTML5 file is enough for most applications, with a nice touch and feel. For the server side, I developed and use http://mormot.net which is very productive, once you are used to its ORM/SOA approach.
I'm From New Delhi, India. We're usually not hired to do anything but software testing and other repetitive tasks unless I join a startup or something for shit pay. And what If I want to develop Native apps? Ive even tried Livecode, but I found the whole Write-like-a-human-readable-language concept too much of a hassle to learn and write programs in. 
Video lessons for learning Object Pascal and Delphi 7 (which applies to Lazarus and FPC too): https://www.youtube.com/playlist?list=PLZZqoiUyRBsTJeh6jRhcfZyc7-5ZY-JfL
And after using it continuously, and nearly exclusively, for 17 years i'm trying to find a way out of it. - [The compiler is twitchy](https://plus.google.com/107032218922460039706/posts/M1yi1HpKwUY) - The IDE is crashy - The [framework library is [buggy](http://stackoverflow.com/questions/29906723/delphi-xe8-bug-in-tlistt-need-workaround) ([buggy](http://stackoverflow.com/questions/29394970/tpanel-does-not-autosize-when-containing-a-tpanel)) - The tools are [expensive](https://www.visualstudio.com/en-us/products/visual-studio-community-vs.aspx) It's a good thing for Embarcardero that Delphi is the best option for native Windows application development.
You and me both brother. Been using it since the mid 90s with my own software products. Have made ok money and had tons of free time. This year, I decided I was too isolated and worked to get a job outside of my own stuff. The market is terrible for Delphi. It just doesn't exist. In Seattle, there are three places that hire for it.. a pizza place (in Vancouver, Canada), trucking company and a tv advertisement company. All of which feel like old business from the 90s. Still running fat apps on the desktop with a Windows server in the closet for MSsql. It screams Cobol. My new gig has nothing to do with the desktop and everyone is under 32 y/o. Most have never heard of Delphi and Pascal was never something taught in school for them. Delphi failed to evolve. Now they just try to leverage existing dev shops that maybe be moving to mobile device aka Enterprise Mobile development. 
I started with Delphi when it first came out, and it was a real game changer for me. Lots of power and functionality at the time, it was amazing. Somewhere along the way, though, roughly after D3, I moved on for a while... And eventually, the company changing up finally killed it for me. I never created DB products with it, but I did make a lot of cool things and I still think it's a great idea in general... decreased to nonexistent market demand notwithstanding. Unfortunately it's felt mismanaged and misunderstood for a really long time now--by companies and developers alike, and most critically, by its own company leadership as well--and probably won't ever recover from that. More than a bit of a shame, imo.
That's very nice! Love those turorials. We once implemented a Mini-Modula interpreter in fashion of recursive descent parser at university.
Can I access C++ libraries (via C interface) with Delphi on Android like I can on Windows?
Or you can hire me XD
Cool, will check later, but I always want to make a 3D interface. Oye, hablas castellano ?
interesting, upvoted
&gt;This seems crazy compared to the 500+ Delphi jobs I used to see posted &gt;in 2007. That was 8 years ago! &gt; I can't help thinking there's another site where they're all hiding. Surely &gt;Delphi hasn't hit that much of a dead end Why are Delphi users so perpetually in denial? Check out Dice.com. You'll generally find about 35 Delphi jobs across the entire United States (after you toss out the Delphi auto group, Delphi consulting firm, Delphi hotel management software, etc.). Where in the world do you run into Pascal today that you would imagine that Delphi jobs are hiding somewhere? &gt; especially with the Lazarus project making pretty good headway. Good headway to... what? The world has Java, C++, C#, Python, Ruby, Go, Rust, Haskell, D, etc., all for free. Pascal's last year for being used to teach AP Computer Science courses was 1998 or 1999. You've had an entire *generation* now who have never seen a line of Pascal code. Meanwhile Delphi developers continue to get older and some either retire or move to new technology to remain relevant/put food on the table. And as icing on the cake, Microsoft just made a "community" edition of Visual Studio with features equivalent to the Enterprise version of Delphi (profilers, etc.) and that includes C++, C#, Asp.net/Javascript/TypeScript, F# and Python for free for 1-5 developers and profits under one million dollars. In short, the micro-developer niche, the last remaining niche Delphi had any traction in. Meanwhile, Embarcadero RAISED PRICES in response and made "software assurance" mandatory to receive ANY UPDATES AT ALL (we're talking bug fixes here). Buying a new copy Delphi Pro, throwing in the client/server pack (otherwise you need a way to access non-local databases), adding in the software assurance, comes out to about $2147 USD! How in the WORLD can you recruit new developers when that's the minimum realistic entry cost? That's without taking 3rd party components into account, as Delphi is probably the last language on earth where everyone wants to charge $60-$300 for a library rather than releasing it for free on github. When I priced Delphi for a new project I was going to be working on, to do an apples-to-apples comparison I had to add in matrix math, machine learning, statistics libraries with source (total $1500!), hundreds more for a 64-bit profiler, documentation generator, ORM, HTML parsing, etc. to the point the total reached almost $5000! In the end I went with a more-powerful stack that was 100% open source. That's the world Delphi is competing in today. Look at this website that tracks repositories of open source packages for various languages: http://www.modulecounts.com/ I examined Delphi's Torry.net for a two-week period. There were 40 packages added/updated, but when you tossed out the updates and the commercial demos, you were left with only 8 new free or open source uploads over two weeks. That's less than one a day. Python had 685 additions during the same time period! As you can see from this site, other languages are often adding dozens a day. Python added about the same number of packages in 2014, one year, as Torry.net has collected in its entire existence! (and much of those are actually outdated or commercial demos). It's not just the library ecosystem that stinks. There hasn't been a commercial Delphi book published in 10 years now and maybe 4 or 5 self-published ones. Meanwhile, popular languages have dozens published per year. There are no free online courses, no magazines, most countries have no physical conventions, no user groups, etc. 3rd party software doesn't produce Delphi components, APIs aren't distributed with Delphi wrappers anymore, etc. In 2014 Delphi ranked *44th* in new projects on Github. Compared to mainstream languages, Delphi's ecosystem is practically non-existent. So, looking at all that, I just have to shake my head in disbelief with Delphi True Believers really believe Delphi is a significant player in the programming language market or that it's going to come back Any Day Now. Honestly, it's a complete dead end and Embarcadero is just milking the few tens of thousands who are left (most just maintaining legacy software) until they made back their investment. Once we all leave or retire, Delphi joins Forth, COBOL and others at the Old Language Retirement Home. No one's going to take our place and EMBT certainly isn't lifting a finger to bring in new users. Edit: Look at the total subscribers in this group:664. Now look at something like /r/Python: 99,255! Reddit users skew young. This should tell you all you need to know about the future of Delphi.
VS is simply awesome. I've been using Delphi ever since Delphi 7 was released but have finally decided to move to VS permanently. I've already migrated almost all of my Delphi Projects to C#, the only exception being one that is simply too large to migrate. Thanks to that project I'll be keeping my hand in Delphi but all of my future development will be in VS/C#.
I'd have thought C# and C++ were good career moves. Certainly from what I've seen of the market for developers. Rarely do I see jobs posted asking for Delphi developers. Xamarin is higher than Object Pascal. Really?
There's no need to learn through the versions. They are just bug fixes and improvements to FMX. Some new language features are introduced through the version path, but there's no need to suffer through their bugs.
Because the documentation seemed too small for it to include everything. Facebook graph integration, and Google logins for example. 
What documentation are you looking at? The [XE7 documentation](http://docwiki.embarcadero.com/RADStudio/XE7/en/Main_Page) as a whole is **huge**. The link I gave is just the front page, which has a small index. Once you delve into the library reference though... What in particular do you want to learn?
Imho. Documentation in the software has been lacking since the transition of v7 to v8/2010. The online documentation is there, but much of it is generated from Doc Blocks in the code. Googling will get you far, along with the Google+ group that's very active.
Lets say that I want to make a tinder clone. I don't know how to integrate the facebook graph API. In fact I want to make something a little more than just a tinder clone. I want to add as many social networks and Online accounts as possible.
Do a Google search for "docwiki whatever you want to know". Sometimes you have to do "delphi docwiki whatever you want to know". Google has a better search of the DocWiki than the Docwiki does.
Did I miss the ability to even build Windows 8 applications with Delphi?
I'd be willing to fork over more multiple thousands of dollars **if**it were a quality product. But the product itself is buggy, crash prone, and is a poor IDE. In the area of editing, refactoring, debugging, inspecting variables: it's hopeless. Daily crashes, resetting of project properties, search that suddenly doesn't find anything. What I wouldn't give for a formatted string viewer, as well as TList/nested object viewer. Then there are the decade old bugs in the VCL itself, that require months of manual repair. There's the lack of innovation in the compiler. Vectorization and loop unrolling using SSE/SSE2/AVX. Even [variable hosting](http://www.compileroptimizations.com/category/hoisting.htm) it doesn't do. And finally it's the new critical bugs that appear. I wouldn't mind standing by Delphi, but only if Embarcadero stood by their own product. Embarcadero should care about quality. It really bothers me every time I see a video touting a new feature widget you can use with FireMonkey on iOS. The developers are spending so much time of things that are not terribly important. I realize writing your own widget library from scratch was a fun diversion. But I really need you to do the mundane thing of fixing all the old bugs in all the existing code. And I want you to stand by your product. I want you to do what your competitor does with their development environment: support it. Microsoft supports their product for five years. I bought Delphi, and it went out-of-support before I have even been able to ship anything on it. 9 months of fixing Delphi bugs and we're almost ready to ship. Meanwhile two newer versions of Delphi have shipped, each with the same old bugs, and new bugs. And all of them unsupported. tldr: I'd be willing to stand by Delphi if Embarcadero is willing to do the same.
Kudos -- excellent summary. I've never felt the need to upgrade from my Delphi 2007 but just for kicks I thought I'd take a look at XE8. I was *shocked* to discover that almost all of the bugs that aggravated me about 2007 were still there in XE8! It seems the only thing that the XE releases have brought to the table is mobile support, but I do my Android development in Android Studio and I have no interest in Apple so XE8 is utterly useless to me. And this was right after I completed a new project using VS 2013/C#. The difference couldn't be more stark. My hope (and it's a long shot, I know) is that when Embarcadero's cow finally dries up that someone (Microsoft?) writes a Delphi plug-in for Visual Studio so I can continue to support my last Delphi project. It's been a long ride Delphi, but it's time to move on.
So does the individual Appmethod plan at £20/month inlcude Object Pascal? How does it differ from Delphi?
Yes, in the £20/month (or $25/m) plan (which has to be paid yearly) you get C++ and Object Pascal for one platform (Android, IOS, OSX, or Windows). Firemonkey only. No VCL. Appmethod w/ C++ only for Android is free. So £240/year per platform. All 4 platforms would be £960/year.
Absolutely. We finally got around to getting our project ported to XE3 (started this year, took us this long to get all of our customers to upgrade). It bothers me to no end how little EMB cares about their 2-3 year old products. 
You can install the preview edition of Architect on a virtual machine that regularly switches IP, like an Amazon EC2 instance and reregister it repeatedly with a new throwaway email address to get a free Delphi forever.
Its all about the .io domains now maaan.
Thanks man. It will help. Too bad that Delphi 6 simply don't ignore {$REGION}.
Why bother? If you can have high-quality, very well-supported, popular tools for free, why screw around with VMs and IPs and managing a slew of e-mail addresses?
Don't forget to ask the customer to imagine what happens when the user is not an administrator.
I've written a Delphi app that auto-updates itself (via an updater.exe program), but found that it needs Administrative privileges under Windows 7 or higher. How do other programs do it while not getting UAC prompts?
It's ok that Delphi and lastly C++ Builder are still alive and kicking. But when I see names like "TTMSFMXAnotherGreatComponent" they float away like background noise - IMHOYMMVUNeedNamespaces. 
This is actually really really helpful!
I know some companies that still actively maintains VCL app but wonder if anyone is building commercial mobile apps with Delphi XE?
Don't store any data in areas that aren't writable by the user. (i.e. Don't use Program Files or HKLM) Use the [AppData](http://windows.microsoft.com/en-au/windows-8/what-appdata-folder) folders. Check out how Google does it with Chrome for example. 
You make a lot of good points. However, C#with WPF still has a poor tree control something that Qt and others, like Delphi have fixed for years. I've tried Xamarin. If I want to develop in windows and have it automatically compile on mac i need the expensive business version. Xamarin doesn't support windows apps? I've tried Qt - hit a problem with that due to it's messages being strings and processed as such. It added a latency. That's gone now but still needs the special compiler to support slots and signals. C++ still requires forward declarations. What it doesn't have is circular references which Delphi still has. C# is so much better in that respect. Everywhere I go everyone uses windows for developing software. Rarely do I see cross development done on Linux or mac.
Guys, you must release a free Delphi Starter Edition just like MS does. Otherwise you are dead without mass of fresh young blood. Paid educational licenses are NOT an option, you know it. Tame your appetite in the present to live in the future. Regards. (Coding in Delphi since 2001. Love it.)
Do you have plans to use emerging WebAssembly technology in your future products?
The Answers section on community.embarcadero.com has answers from Embarcadero employees. StackOverflow can be rough if you don't have a well formatted question but has good Delphi answers. UpWork.com can get you paid help. The Google+ Delphi groups have many experts with lots of technical answers. There is also a pretty big Facebook group where you can get good answers as well. Here's the G+ link: https://plus.google.com/communities/103113685381486591754
Google Delphi Developers group. 
Hi, Look into Delphi mailing lists. I work in a company that actively uses Delphi, and some of our senior devs sometimes post on them.
http://stackoverflow.com/questions/tagged/delphi
We actually do offer a lot of free educational licenses to schools all over the world. 
It isn't on the roadmap currently. 
Thank you for reply! I really hope these activities would help your company to take a bigger part of market in the future. But MS with their free Visual Studio Express and Visual Studio Community looks more preferable for an unbiased independent developer. Anyone can legally download VS and start to use it for creating own projects. No one trial version distribution can compete with such a way of creepy propagation (except of pirating but we arn't talking about it, I guess). Regards!
Nope. TMS is a good vendor but I haven't used those particular components.
Fair enough. That's not too expensive. I may just dive in and give them a shot, or see if they have a trial of some kind. I've got a lot of background work to do before I'm ready to plug those UI elements in anyway :) 
http://wiki.lazarus.freepascal.org/fphttpclient
This will handle REST and Facebook's authentication?
What are you using for version control?
SVN gets mentioned on the website, project pages etc.
SVN, for its simplicity. I got lucky to register to free 2Gb CloudForge SVN plan before it became priced.
Thank you! :-) 
I recently decided to try XE8 -- I've been using D2007 since it came out. I was completely stunned to discover that not only have most of the really irritating IDE bugs I've had to live with in D2007 not been fixed but new ones have been introduced. "High fix rate" indeed.
I'm too poor to afford a copy of Delphi XE8. could someone please provide me a soft copy? I'd be eternally grateful. :)
You're kidding, right? With Delphi's manual memory management, obsessive typing, ancient single-pass architecture that requires forward declarations, declaring methods outside of object definitions, putting all the variables and constants in their little sections, etc., lack of 3rd party libraries, lack of documentation, lack of educational materials, etc. you think one Delphi programmer can replace 5 C# developers? This is why people make jokes about Delphi programmers. We sound as wild-eyed crazy as Richard Stallman, if not more so. 
&gt;and the fastest way to build multi platform enterprise applications is Delphi. Why Delphi, vs. all of the other cross-platform options out there? &gt;If having a "job" and a "career" working for the man is your thing When the only response we have to the complete lack of Delphi jobs is "jobs are for losers", we've lost. That's it. It's over. &gt; then by all means use one of the hipster "job" languages. I assume "hipster 'job' languages" include C#, C++ and Java, the Holy Trinity of enterprise development? Maybe PHP, Perl, Python, Ruby, Javascript - all of those crazy hipster languages? &gt; If you want to make money use Delphi to build enterprise apps because the &gt;market is exploding. 1) Someone looking to target the enterprise is showing remarkably poor judgement if they're choosing a single source vendor. That's before we consider that the vendor is privately held because its stock value had declined so much that its institutional investors demanded the CEO find a buyer before they lost any more of their investment; the company has in the past had 10% across-the-board pay cuts to avoid layoffs; its current CEO, who joined the company via acquisition, was sued for millions of dollars soon after for cheating another company - EMBT doesn't even seem to have taken the time to file a response denying the claims before settling out of court; has attempted stealth changes in its EULA e.g. the Pro SKU/database debacle; and has a clause in its current EULA which prohibits someone from using Delphi to make any product that competes with anything Embarcadero sells, which means anyone using Delphi is one acquisition away from having their codebase rendered moot. 2) Someone looking to target the Enterprise would be showing remarkably poor judgement choosing a product so poorly aimed at the Enterprise market that a) its roadmaps are nothing more than vague suggestions, b) apparently rolls dice to determine release dates since even its product manager has no idea what day a new version will ship on, c) has had a laughable 8 month support window, that d) is now said to be longer - again, unspecified with no contractual obligation, but users now need to pay for any updates at all, including bug fixes. Any of those discount a product from being used in Enterprise in the companies I've worked in, with or for. 3) Someone targeting the Enterprise would be showing remarkably poor judgement choosing an unpopular language because such a language will have a weak or nonexistent ecosystem. As OnStartups, a website naturally targeted to startups (which you're advocating users become), wrote: &gt; I would define an ecosystem (in this context) as all the resources that &gt;surround a core language and platform. This includes developers that know &gt;and understand the technology, book authors that write about it, library &gt;developers that create reusable code for others, trainers that help people get &gt;up to speed, and tools companies that offer add-ons to make developing on &gt;the platform more efficient. I cannot stress enough the importance of having &gt;a vibrant, growing and sustainable ecosystem for a programming language. &gt;If you’re a startup, chances are that if you’re building a sufficiently &gt;sophisticated application, you’ll be needing one or more of these resources &gt;to create your application. Further, unless you are “building to flip”... you’ll &gt;need to support your application for years to come. In fact, your margins will &gt;likely get higher over time as you have to write less and less code to meet &gt;new market needs. As such, if the ecosystem surrounding your chosen &gt;language/platform declines significantly or dies, you are at a severe &gt;disadvantage....Thought [sic] it’s difficult to predict which ecosystems will &gt;endure and which ones won’t, we have enough history now to at least have &gt;a sense for some patterns. Ecosystems that rely on a single company are &gt;vulnerable. Hence the slow decline of so many custom development &gt;languages (Easel, PowerBuilder, Delphi, etc.) [Note: I have nothing against &gt;any of those languages, and I’m sure there’s a large pool of successful &gt;Delphi programmers still out there, but I will continue to maintain that the &gt;ecosystem for these languages is likely on a decline – of varying degrees of &gt;severity]. Of course, C# is also, for the most part, dependent on Microsoft. &gt;(Despite the language itself now being released to the ECMA). But, &gt;Microsoft seems to be a special case. Given their volume of resources and &gt;conviction around the importance of strong development platforms for their &gt;operating systems, it is unlikely that C# and ..Net will fail to maintain a &gt;vibrant ecosystem around them. Evidence is already there in terms of the &gt;number of developers, books and third-party vendors creating technology on &gt;this platform. Python has the power of a strong and vibrant open source &gt;community. So, it does not face the same vulnerability of a single company &gt;“owner”. This is a good thing. Given the scale of use of Python already, it is &gt;unlikely that in the next several years we’re going to see a sharp decline in &gt;the vibrancy of the community. Another reason that ecosystems decline is &gt;that the language was really good at a special kind of application and there &gt;is a technical shift that causes that kind of application to be less relevant. &gt;For example, PowerBuilder was an immensely popular platform for creating &gt;client/server applications. But, when the shift to the web happened, there &gt;wasn’t enough advantage anymore and other languages took over. That’s &gt;why I like general purpose languages (C++, C#, Python, etc.). They’re more &gt;likely to endure when the inevitable shifts in the technology landscape &gt;happen. In short, ecosystems are important and should influence where you &gt;place your bets. With a vibrant ecosystem, I can look at a particular function and ask myself how long it would take to write it and what my time is worth vs. what a commercial library would cost (and of course, also look at open source options if possible). If it's cheaper to buy, I can simply buy the library. Even if it's not cheaper but time is critical this can be done to meet a deadline. Now, a language like Delphi with a dying ecosystem (many 3rd parties gone, went from 34 to 39 to 44th in new projects on Github over 3 years, etc.) and essentially no FFI (Foreign Function Interface for utilizing non-Delphi code), it's often the case that there simply isn't a 3rd party option. That means the Delphi developer has to code that portion themselves while the C# or C++ or Ruby developer can use an "off-the-shelf" library and get a leg up on development time/cost. I'll stop there but using a commercial language at all shows poor judgement since proprietary languages are an anachronism that barely exists any more. Dev tools are the area where open source can succeed the most - written by developers for developers. Surveys show 80% of developers are using open source tools to write code today, and some fields such as big data have NO proprietary solutions at this time! The practice in much of enterprise development today for a new project is to first examine the open source offerings and choose open source components (if possible) around which to build the new software. Heck, even EMBT has used FPC and now leverages LLVM rather than write its own compilers from scratch! Welcome to the new world. 
I've never seen a job ad in my life looking for a C#-to-Delphi migration developer. Being close to Wall Street, I've seen vast amounts the other way though. It seems all the Delphi code is out there by this time and now they're even porting old Java code to C#. I don't know about brain dead but that /u/fmxexpress imagines, without any evidence, that there's a great migration from C# to Delphi going on... I don't know what to say, other than this is why people laugh when the subject of Delphi comes up. :-( Come to think of it, David I. once deflected a remark I wrote about people leaving the language by suggesting that "people leave Delphi for C#; people leave C# for Delphi..." and that in response "we just keep doing what we're doing", which I take to mean "our actions and plans have no correlation to anything that occurs in objective external reality". :-( Marco Cantu once also snapped at me in a reply to a comment on his blog that he believes that Delphi has had far more impact on the business world than Python ever has. Note that the site you're reading this on right now was written in Python. :-) At least before Google bought it YouTube was 100% Python; the original BitTorrent client was/is Python, DropBox is Python, the backend of Instagram, which sold for $1 billion dollars, is Python, some of Google's original search code was Python, the Mercurial DVCS is Python... it is used at CERN and Fermilab, both major open source cloud stacks are coded in Python, etc. I've been thinking of making a "S**t Delphi users say" Twitter account for stuff just like this post. ;-) 
So go use Python. I prefer PHP which runs 80% of the web.
Tortise has probably been the source of a lot of material for Raymond Chen.
Don't forget to create an assembly manifest for your COM dll, so you don't have to register the `.dll` **Chapman.ComClassExample.manifest**: &lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt; &lt;assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0"&gt; &lt;assemblyIdentity type="win32" name="Chapman.ComClassExample" processorArchitecture="x86" version="1.0.0.0" /&gt; &lt;clrClass clsid="{8E595F83-0FE9-4AD2-8F16-2025901BE019}" progid="ComClass.ComClassExample" threadingModel="Both" name="ComClass.ComClassExample"&gt; &lt;/clrClass&gt; &lt;/assembly&gt; Then in your Delphi executable's manifest, declare that you have a dependency on your newly created `Chapman.ComClassExample` assembly: **TestCom.exe.manifest**: &lt;?xml version="1.0" encoding="utf-8" standalone="yes"?&gt; &lt;assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1"&gt; &lt;assemblyIdentity type="win32" name="Project1.exe" version="1.0.0.0" /&gt; &lt;dependency&gt; &lt;dependentAssembly&gt; &lt;assemblyIdentity type="win32" name="ComExample.ComClass" version="1.0.0.0" /&gt; &lt;/dependentAssembly&gt; &lt;/dependency&gt; &lt;/assembly&gt; Now nobody has to register any DLLs (thereby avoiding using a global solution to solve a local problem). 
Waiting on a torrent. Chop chop Russia!
@alcade: I will remind you that the same guy who wrote CrossTalk also wrote Indy library and the later was released as open source and since a long time it is an important part of Delphi itself. And I will also point that you are wrong about lots of assumptions here: Most free stuff out there, including Open Source Software are not free at all. Someone has to work to make it real. Sometimes this work is paid by his employer or other company behind it. Ask Arnaud, Eric Grange or Gabr if their libraries were developed/tested/documented/etc in their free time OR if they created it for their own job (thus being PAID for it) and THEN they released it as open source. There are TONS of companies out there that create libraries and solutions for developers and like ALL companies that I'm aware of, they seek PROFIT, thus they CHARGE for their products. You are probably one of those that believe that Visual Studio is FREE - and not paid by all MS customers when they buy Windows, Office, SQL Server, etc etc etc. Check DevExpress for instance: They are considered probably the best .NET UI component vendor and their component pack is MUCH MORE EXPENSIVE for .NET than for Delphi. Why don't you write DevExpress asking them to make their components Open Source too? ;-) 
http://www.embarcadero.com/products/delphi
I'm sure everyone will be upset I say this, but there are great cracked versions of Delphi available on the piratebay right now.
Will it find a happy home?
Or, just contribute to Free Pascal/Lazarus and refine and promote it.
This is part of the discussion the community needed to have at least seven years ago! Open source has completely changed the development world and the very idea of proprietary development tools is an anachronism now. Even MS has open sourced most of C#/.NET and Apple has announced they're open sourcing Swift by the end of the year and will actively seek outside code contributions! But everything at the official forum continues like it's the 1990's. Arnaud's Mormot framework got rejected from EMBT's package manager because it "competes" with them. There's a new open source package manager in development now. Again, the TeamB and MVPs should be using their influence to get everyone to agree not to contribute to the official package manager and support the community-run one instead. But their loyalty is to EMBT rather than the community. :-( We need a TeamU for users! There are **so** many issues like this where the community should discuss and make an organized decision on but we don't. We *knew* that the venture capitalists who owned EMBT were going to turn around and sell it some day but no one ever wanted to talk about a "plan B", and if you did, you were a troll. Now we don't know what's going to happen, no word from EMBT and some of the TeamB'ers are still saying "let's wait and see", by which point it could be too late. On the other side, Free Pascal needs to decide if it wants to be a Delphi 7 clone, a more modern Delphi clone, or go the Oxygene route and give us Pascal++ (a route already chosen by Nim, a language inspired by Pascal and Python). New features in FPC seem to have been stalled for a while. 
Anyone got examples of clever setup names? &gt;(from comments) Omitting a manifest means your process will execute virtualized. That has many serious consequences. The manifest was introduced nearly 15 years ago. We really ought to be able to deal with them by now. What does this mean?
Got to give us more. Where do you live? What does other programmers in your area make? Are you actually switching jobs, or are they just giving you more work? Are you a fulltime employee now?
You can do wonderful new apps, even with state-of-the-art architecture (SOA, DDD, ORM) in Delphi, with great advantages over Python, Java or C#. I do it for a living, using our http://mormot.net framework - far away from basic RAD. I used to develop C# WCF/WPF solutions for years, and I would never come back. We have now one new issue: the servers are so easy to set up (no huge runtime or VM, no DB to setup) that in my company there are server instances everywhere, for any test purpose imaginable. Classical .Net + Oracle servers setup was such a PITA that we were safe no one would enjoy testing. ;)
Anything is possible but why people should think this? Most of developers are buying from Embarcadero. Unfortunately, there are a lot of illegal using Delphi products. Maybe there will have some real results so people will think about it 
Danm, I'm brazilian with ~5 years experience and a salary like that would be a dream
Sounds great! We were always looking for split view in editor. Also I need to develop my apps on my MacBook Pro. (I don't like VMware) Hope it can help us for rapidly developing projects. Now we can say that Delphi still keeping title for great development and development environment tools! Awesome news! Thanks!
It could be - from what I've been able to learn of them they have a friendly, team-supporting culture for their developers and they seem to have friendly engagement and dialog with their customers. We've been used to a hostile approach for so long it would be wonderful if Idera changed the culture. On the other hand, it's quite possible they take a "hands off" approach and leave EMBT to continue to function on its own as an independent unit, and in that case I expect nothing would change. I'm fervently hoping Idera takes a peak inside, becomes appalled, and starts firing managers left and right. :-) Then they'd bring development back to the U.S., and actually engage Delphi customers and ask us what we want and give us a say in the product. David I. though (someone who I feel honestly needs to go) is claiming that they're going to try to get Pascal back into education. I don't know if that's his idea or their idea, but there's no way that could happen in 2015. Then again, when EMBT took over CodeGear David I. and Allen were talking about adding LINQ functionality and support for parallel programming right into the language, and they never did that either. It's really a mystery right now what will happen. My other fear is that David I. and Allen and Marco are meeting with Idera this week filling their heads with crazy ideas like getting back into schools. I desperately want a set of fresh eyes looking at Delphi right now.
As you said, the responsibilities would be Delphi as well as a slew of other IT roles. I am a web developer in my own time, and actually DO plan on starting my own business when I have the capital. I also intend on learning a more common language once I have a decent handle on Delphi. I'm looking at this as a chance to increase my income (read: speed up starting my own business) and nab some IT experience, even if it is an archaic language.
The executive team, not DavidI specifically, should bear collective responsibility for the culture of their company. Satya Nadella said recently (and I respect the dude a lot) that a CEO is a Curator of Culture. Embarcadero suffers from Cowboy culture, and I know a few senior guys there who should go, but DavidI is not one of them. I have some inside knowledge from people who have worked there. He advocates for Developer needs, and is a key reason why the executive team has invested into RAD Studio. 
Look into WideOrbit.com Yes. You can certainly get $80k as a Delphi developer. Just because it's very hard to find anyone that wants to stay using the language and they have millions invested in the codebase. In Seattle, I've seen roughly 3 jobs come and go in the market for Delphi developers. A pizza place in Canada, WideOrbit (always hiring good devs) in Lynwood (offices around the world) and a trucking company in Renton.
I don't have a copy of Windows handy, but the two code examples seem quite different. What about keybd_event(VK_MENU, $B8, 0, 0); //Alt Press keybd_event($6B, 0, KEYEVENTF_KEYUP, 0); keybd_event(Ord('2'), 0, KEYEVENTF_KEYUP, 0); keybd_event(Ord('4'), 0, KEYEVENTF_KEYUP, 0); keybd_event(Ord('B'), 0, KEYEVENTF_KEYUP, 0); keybd_event(Ord('6'), 0, KEYEVENTF_KEYUP, 0); keybd_event(VK_MENU, $B8, KEYEVENTF_KEYUP, 0); 
You are absolutely right. Unfortunately i think they just fell away when cleaning up the code before posting (when things dont work, my code tend to be all cluttered with all sorts of long shots, all sorts of cargo-cult programming)
Thanks! Unfortunately, this is not working.
F.Y.I i have tried implementing Alt-Tab (which works well) 
(*The following Works fine. Thanks to http://stackoverflow.com/users/505088/david-heffernan Will do a full Key-board Modification and post in D.I.Y *) unit Sender; interface uses windows; procedure SendAlt24B6; implementation procedure SendAlt24B6; var KeyInputs: array of TInput; procedure KeybdInput(VKey: Byte; Flags: DWORD); begin SetLength(KeyInputs, Length(KeyInputs)+1); KeyInputs[high(KeyInputs)].Itype := INPUT_KEYBOARD; with KeyInputs[high(KeyInputs)].ki do begin wVk := VKey; wScan := MapVirtualKey(wVk, 0); dwFlags := Flags; end; end; begin KeybdInput(VK_MENU, 0); KeybdInput($6B, 0); KeybdInput($6B, KEYEVENTF_KEYUP); KeybdInput(Ord('2'), 0); KeybdInput(Ord('2'),KEYEVENTF_KEYUP); KeybdInput(Ord('4'), 0); KeybdInput(Ord('4'),KEYEVENTF_KEYUP); KeybdInput(Ord('B'), 0); KeybdInput(Ord('B'),KEYEVENTF_KEYUP); KeybdInput(Ord('6'), 0); KeybdInput(Ord('6'),KEYEVENTF_KEYUP); KeybdInput(VK_MENU, KEYEVENTF_KEYUP); SendInput(Length(KeyInputs), KeyInputs[0], SizeOf(KeyInputs[0])); end; end. 
Yup. Get out while you still can.
Video tutorials created in South Africa for learning Delphi: https://www.youtube.com/watch?v=IKkRI1UyLEU&amp;list=PLZZqoiUyRBsTJeh6jRhcfZyc7-5ZY-JfL
That Marco Cantu Essential Pascal would be a good first thing to learn first. Install the Delphi 10 Seattle trial version first if your bosses haven't given you your delphi license yet. Then start to read the book, and pause whenever you like to try stuff inside the IDE. After you've read the book once, I would try to make some apps with the various VCL controls. If you've dropped a button on a form in Java (in say netbeans) or C# (with winforms), it's not much different in Delphi. While you are learning the stuff in the book just create Console (text) apps so you can just write stuff to the screen using WriteLn, and For loops, and everything you would have known how to do in Java. Figure out that F8 sets a breakpoint, and learn how to run your code in the debugger and step through it. After you're comfortable reading the syntax and writing little bits of code with Pascal, then you can move on to learning the VCL Controls, and I recommend leaving Firemonkey until you are fairly experienced with just Windows and VCL. I estimate that from C# or Java "some experience" to Delphi "same level as I was in java or C#" should be about a week or two for the sharpest cookies, and two or three weeks for anybody with a pulse. If you have questions,here on reddit is a better place for beginner questions, than Stackoverflow which is kind of not that friendly for "beginner" questions these days. Don't bother with OLD delphi versions, just get Delphi 10 Seattle Trial.
Bor...Imp...Cod...Emba...Ide... It's the long Palm death.
Also if you're trying to figure out what to get your kids to do with Delphi, ping me as I have some ideas. Delphi and Games/Graphics is a great way to get kids interested and engaged.
There really hasn't been too much news on what this acquisition will mean for Delphi (or C++ Builder)..so I'm not sure how much discussion, other than speculation, can be had at this point. David I. has just made general statements that Idera plans to be more focused on Delphi/C++ Builder than Embarcadero.
Thank you so much for the offer. Ever since I saw my first crack intro/demo back in 94 I have wanted to code something similar. I managed to find some tutorials by denthor of asphyxia, later I found out he is a fellow South African also from my home town of Durban! He started a company called Derivco which is THE IT Dev company to work for here in Durban. I crashed and burned with grasping assembly programming at the time but he did have some stuff in pascal. My first intro into programming was turtle graphics and I loved it. I have to be disciplined to set aside time for programming and get my hands dirty, get past this slump of thinking about programming and the what ifs. Sorry for rant.
I don't believe Delphi is an entry point for anything anymore. They are a legacy tool manufacturer that has extended their market by changing direction and developing FMX for cross-platform and phone development. If you want inexpensive and set on Pascal, there's Lazarus and FPC. If you are looking to do Desktop work, I'd echo looking at Visual C#. At least you could then get a job with that skill.
I would think C# is more akin to Java. Lazarus would be the spiritual successor to Delphi. Hopefully C# becomes more compatible cross-platform though now that it's open source.
While C# has similarities to Java, I think there are lot of similarities to Delphi - e.g. properties, delegates/events, virtual/override - it looks to me they have pulled in what they considered best ideas from both systems. I find producing "quick" Windows applications in Visual Studio feels more like producing similar Dephi apps than anything in Java does.
One difference is that Delphi produces native, stand alone applications.
Delphi is dead, it was killed by overpricing, and the desire of the owners to capitalise on it by releasing too many versions. It's upsetting as I love it, but as a tool it is a fringe dying product. The owners of Delphi don't realise a simple thing about language platforms. They only stay healthy if people are using it. People only use it if they can afford to, and that includes new developers. Most Delphi developers have moved to C# and Visual Studio. The support is better, the IDE is better the technology is more up to date, plus the base version is free. 
Uncheck libnative-activity.so from Project Deployment and enjoy! 
I can dig that. A lot of what we use today stems from the mid-90's RAD paradigm set by Delphi and VB. I've toyed with C# so I'm nowhere near an expert in it. I was always under the impression that MS looked at Java and said, 'Hey, we can do that with less suck.' I gotta say, I kinda hope C# eventually dethrones Java because Java is just plain bad. The overall idea is great (write once/run everywhere) but so much breaks anytime there's an update of any kind. I don't know if this has to do with the language or the programmers, but working mainly in tech support, it's a nightmare. Client updates their JRE? Boom, essential app broken or borked. Ugh.
In regards to being an "entry point" it depends on what one wishes to enter. As a cross-compiling mobile development tool, its price is on par with commercial tools from companies like Xamarin and Digia (Qt). For desktop, it's another story. Essentially every general purpose computer language today is now free and open source and/or standardized (ISO, ECMA, etc.). The minimum entry price for Delphi Pro (which now requires a subscription to receive any updates, including bug fixes) is $1440 USD plus tax if applicable. Even then some core functionality is going to have to be supplemented via commercial or occasionally open source libraries. Visual Studio now has a community edition that's available for free for 1-5 developers if the company has less than one million dollars in revenue and 200 PCs. You get a world-class IDE plus a "bare metal" language (C++), managed language (C#), Internet languages (ASP.NET/Javascript/Typescript), a functional language (F#) and a dynamically typed language (Python) in the box. People might not want to admit it, but this essentially eliminates the ability for Delphi to gain new (desktop) customers. The Delphi ecosystem tends to be stuck in a '90s mentality: there are fewer 3rd party vendors, but everyone (with a few heroic exceptions) tries to sell every component they write for $30-$300 rather than open sourcing it. This does the community no favors. When pricing options for a serious project I'm working on now with investors (it may or may not become a revenue generator), the price of Delphi plus everything else needed - profiler, logging, documentation, matrix math, machine learning, charting, HTML parsing, etc. - came out to almost $5000 USD! Even then, it wasn't on a par with some open source options with other languages. We were able to go for a completely open source software stack, spend $1100 on a completely new 8-core system (project can easily benefit from parallelization), still save thousands of dollars and end up with far more capable machine learning and data analysis libraries than were available for Delphi at any price (including one backed by DARPA!). There are niche cases where desktop development on Delphi may be cheaper or more capable, but in general open source has essentially eaten up the development market. Today it's all about ecosystem, ecosystem, ecosystem - systems development is often choosing the right open source libraries and then gluing them together and/or building on them. Delphi's small market share hurts it tremendously in that area. Gone are the days when products like Crystal Report shipped with Delphi components.
&gt; and the desire of the owners to capitalise on it by releasing too many versions I'm curious about this part of your statement. I'd contend that Delphi was hurt by falling behind other products rather than releasing new versions too quickly.
&gt; I was always under the impression that MS looked at Java and said, 'Hey, we &gt;can do that with less suck.' They did (originally) say that, but they hired the key Delphi developer to do it. :-) Naturally, he would incorporate some of his best ideas into any new language design. Nowadays C# has more of its own identity though as compared to being just "Java done right". 
Originally Delphi versions were over a year apart. When Embarcadero took over from XE4-10, that went to about 5-7 months apart. Each release was another huge upgrade fee ($1000s per license), and to many corporations and developers it appeared to be all about making money - especially when 5 monthly releases were poor upgrades. Take a look [**here**](http://delphi.wikia.com/wiki/Delphi_Release_Dates), and notice a pattern....
I'll agree that halving the release time without halving the cost of upgrades was a money-grabbing move. You were paying the same price for half the additional features unless you gambled with a subscription. Of course now you need a subscription. But the primary motivation was staying viable - because they were using custom skinned controls rather than the native platform controls for mobile FireMonkey, if a new mobile OS release came out they couldn't wait a year to upgrade to support it properly. The mobile space was moving too quickly to allow year-long update cycles to be viable. I did love how the first year after they switched to a 6-month cycle they issued a press release bragging about increased revenue compared to the prior year. :-) Of course if you have two releases in a year instead of one you're going to have more revenue! Sadly, some of the MVPs fell for it and were ecstatically praising the press release as proof that Delphi was coming back. :-( 
The people who make sport of declaring Delphi as being dead often have conflicting rationalisations.
The way I see it, absolutely anything will be better than the way Delphi is being handled currently. It's frankly cringe-worthily embarrassing at this point to watch the Embarcadero staff delusionally pretend like Delphi is some big relevant piece of software, even though LITERALLY EVERYONE EVERYWHERE knows the polar opposite to be true. Don't get me wrong, I love Delphi, but it is in DESPERATE need of some "new blood" who are willing to accept the fact that it is not 2001 anymore, and that the VAST majority of developers do not remotely care about it, if they've even heard of it.
Nothing anyone who is employed by Embarcadero says can be taken seriously. They are literally one step away from being a cult. Their self-perception of Delphi's importance is so far removed from reality that it's embarrassing.
Misleading, just like your MVP comments. I predict that Delphi will be here for years to come. I also predict that you will continue trolling Delphi forums and declaring it dead.
Increases as in they have 10,001 worldwide users instead of the previous year's 10,000. I sincerely doubt you would be so quick to defend their transparently amateurish business practices if they weren't giving you free copies of their ludicrously expensive software, in exchange for your blind sycophantry.
First, there are more than 10,000 users. Second, insinuations based on me being an MVP are cheap shots and are both incorrect and ignorant.
The IDE uses Visual J#, a long-dead MS language whose support ends at the end of this year. :-( I've heard that parts of it were written with Delphi.NET so internally they put work into keeping Delphi.NET going just for the IDE, which sounds like a ridiculous waste of resources. When you have problems with how Delphi is run or point out that it's been reduced to niche status today you get branded a "troll" or a hater by the "Embarcadero MVPs" and others, just a warning. On Google+ I published somewhat of an impromptu "manifesto" of what I'd change if I was Idera; I'll try to post it here soon. You probably have a lot of good ideas as well. In essence, one idea I've been expounding on lately is that we have the old "TeamB" and now the MVPs (who literally sign a contract with EMBT agreeing not to "disparage" the product or the company in exchange for getting their Delphi copies for free). What we don't have is a "TeamU" that stands up for the interest of the users! Other languages have nonprofit foundations or other structures to represent the users and also shape the language they use. What Delphi users desperately need (especially at this time) is to organize into a coherent community and present an open letter to Idera with our concerns. I know that Marco Cantu was at EMBT this week for meetings along with CodeRage and David I. was there too. I think Idera needs to hear from the community along with the "old guard" but right now there's no one to speak for us. If we organize, we can demand a "seat at the table". EMBT is too far out of touch to tell Idera what the users want. Something really needs to change or Delphi will keep bleeding users without replacing them until it's no longer profitable and then it'll just disappear, which would be a crying shame. We don't hate the tool; we hate the way it's been managed and the opportunities that have been squandered. Now there may be a chance if the community can find its voice to finally have some input in its development direction. EDIT: I remember when Interbase was touted as being "Windows 8 ready!" I'd heard MS claim that anything that ran on Win7 would run on Win8. I checked the (meager) changelog and indeed they hadn't done a single thing to make it "Windows 8 ready"; it was just marketing nonsense. :-( When the Heartbleed bug came out, their database "expert" Stephen Ball (whom I could write an essay on) proclaimed that Interbase was secure because it uses a much older copy of OpenSSL (!?!?!?). It took me 20 seconds to query that version and discover that has three unpatched vulnerabilities that were fixed in later versions! Both myself and Luigi Sandon independently posted comments explaining that using outdated versions of libraries is even less safe and by advertising the specific version they used he'd just revealed three ways to attack Interbase. Ball declined to publish either of our comments or redact what he wrote. :-( I can also tell you about the buffer overflow bug affecting most versions of Delphi that was revealed earlier this year. The security firm that found it e-mailed them... and e-mailed them.. and e-mailed them. Almost a month went by without a single reply! He finally contacted a government agency and a few days later they got back to him. EMBT took the vulnerability information AND PUBLISHED IT IN THE OPEN BUG TRACKER, INCLUDING THE SAMPLE CODE THAT DEMONSTRATED HOW TO EXPLOIT IT!!! Needless to say, the security firm was a bit miffed and asked the government agency how the heck to contact EMBT. Note that issues like this are normally reported and quietly fixed within 30 days and then the vulnerability is revealed after a patch has been made available. It was actually six weeks before someone at EMBT finally reached out to him! Weeks and weeks dragged by while EMBT kept claiming they were working on a fix; deadlines came and went. For several weeks they told him the delay was the extensive testing they were doing. They finally sent him a copy of their fix. Minutes later he has to e-mail back and tell them it doesn't work! :-( Meanwhile he offers to help arrange a way to contact devs before making the exploit public; EMBT says they'll handle it. They get the fix right this time and finally announce the vulnerability without ever contacting existing Delphi users first at all! Devs have to race to patch their code, assuming no one found the vulnerability in the bug tracker first. They don't even provide a patch for any other version than the latest! Everyone else is advised to go into the VCL source code and hand-fix the problem! As if a "diff" file would cost them money! More than 3 months have passed since the security company first tried to contact EMBT. Do you think you can trust EMBT with security? :-( 
I spoke about Delphi before I was an MVP and I purchased licenses after. Next conspiracy theory? Speaking of which, your anonymous account was created just for this conversation. Sock puppet maybe?
How is this any less of a cheap shot than you're accusing /u/Akira1364 of? 
That's just what my fortune cookie said last Friday. 
Someone created a new account just to trash Delphi. 
That doesn't look like it's "heavily pirated". Would you consider your search for pirated copies to be definitive?
The Pirate Bay is known to be the most popular torrent site, but there are obviously others and there are private trackers one needs to be a member of to perform searches (and obviously I don't belong to any of them). To gauge whether it's heavily pirated I believe one would have to track the torrent from the day it's first released. Just like buying the official version, I imagine the most activity is within the period right after release. I believe torrents can also report how often they've been completely downloaded if the server tracks it, but I'm not sure about that. Next Delphi release I might set up a web scraper to time how long after release it takes for a pirated version to appear and then keep track of the number of seeds. That would be interesting.
They created an account to say something, the same as anyone else did the first time they posted to Reddit. Even then, that's far from being a sock puppet. 
To start on delphi there's a less expensive way - http://www.appmethod.com/pricing a few hundred dollars per platform per year. I'm developing a Mac app on Delphi, by choice. I'm a c#/web developer by day and a long time delphi fan, VS appears better from a coding point of view, but when it comes to productivity Delphi still outshines it.
There is also the Delphi Starter edition. I think it's a little light on features, but I'm not the target audience, either. Academic pricing is available, which is cheaper, but has some licensing restrictions. I think you need to contact Embarcadero for details. * https://www.embarcadero.com/products/delphi/starter * http://www.embarcadero.com/products/delphi/starter-faq
Think of Appmethod as a subset of Rad Studio with different license terms. It's licensed per platform per year, which can be cheaper depending on your needs. These are not perpetual licenses and will stop working when the subscription expires. Rad Studio licenses, on the other hand, do not expire. It also does not include the VCL. Appmethod is exclusively FireMonkey. I'm not sure how they manage the different platforms or what kind of restrictions there are if you don't have one installed.
Nick Hodges always insists it works, but I too have checked torrent release dates and they're always within a week of the release. JetBrains' activation/DRM policy is much more friendly. You can have as many copies installed as you want so long as you don't use more than one at a time. All you need is your key to activate - no Internet connection. You can be at a friend's house, download your key from their website, and install a copy to show your friend if you want. It does check for multiple copies running, *but only on the same network*, not the Internet. There's no phoning home. If it finds another copy running, it lets you know and even offers to remotely close the extra copies for you! I know they scooped up some ex-Borland Europe employees; maybe that's why they seem to have a "like a book" policy for their IDEs. 
I doubt your insider actually worked for Embarcadero, so they wouldn't be an authority on anything. The press releases didn't mix anything. They all referred specifically to revenue, as clarified by Embarcadero. They also confirmed that they were seeing increased numbers of licenses, but the primary measure was revenue.
According to Embarcadero, there are more than 10,000 users. I suspect that they would know better than you. You keep repeating that I'm an MVP. Are you suggesting that this means that I'm lying? And what is your motivation for repeatedly spreading misinformation? 
&gt;According to Embarcadero, there are more than 10,000 users. I suspect that &gt;they would know better than you. I suspect they'd have more reason to misrepresent the number than anyone. And according to Embarcadero's Delphi Seattle press release, there are more than three million (!!!) users, which they upped from two million last year, which was originally one million users across all EMBT products, showing how the PR department just decided to go wild as time went on. VP Swindell also claimed 1.75 million in 2007 and then 2 million in 2008. &gt;You keep repeating that I'm an MVP. Are you suggesting that this means &gt;that I'm lying? You used the word "incorrect" with /u/Akira1364. I wanted to know if you actually weren't an MVP. As for being an MVP, it lessens someone's credibility since they now have a financial motive to not say anything negative. I won't name the MVP, but one made a blog post 2 years back that called FireMonkey the "perfect" mobile development solution. I pointed out that it wasn't perfect, just as Oxygene's solution isn't perfect, and listed some drawbacks the approaches have. My and others' posts along these lines were all deleted and when I inquired as to why the MVP insisted that comments like these be made on G+ instead and they didn't want their blog to become "*that* kind of website" and other remarks suggesting they didn't want to lose their MVP status. When they realized how bad the exchange looked, they deleted the whole comment thread. So when someone's an MVP it limits their ability to speak their mind (or permit others to do so, apparently). For what it's worth, I believe you genuinely mean everything you say about Embarcadero. &gt;And what is your motivation for repeatedly spreading misinformation? I don't spread misinformation. I tell the truth. On Delphi Island, though, any fact that doesn't fit the narrative gets called "misinformation". Meanwhile, Nick and Marco can suggest that Delphi may be bigger than C++ and Python respectively, and that's not misinformation. Michael Swindell can pull millions of users out of thin air and that's not misinformation either I guess. Rudy can suggest that Delphi is still used to develop new software by billion-dollar firms (which he can't name), but that's not misinformation. 
&gt;I doubt your insider actually worked for Embarcadero, so they wouldn't be an &gt;authority on anything. You doubt it only because it doesn't fit your narrative. Let's take a second to actually evaluate the information BEFORE reaching our conclusion, shall we? E.I. posted information that said Marco Cantu would be named the new product manager; Marco was eventually named product manager. This alone means that either E.I. works in EMBT or... EMBARCADERO INSIDER IS MARCO CANTU. :-) Disregarding that possibility, the only logical conclusion is that E.I. is who they say they are. So why do you have doubts about something that's a logical certainty? E.I. related that sales had plunged after a certain version of Delphi (I don't remember if this was the release after the FM 1.0 or the one that reintroduced it). I think he talked about catastrophic 50%+ drops to the point where they were talking about layoffs. What happened next? February rolled around - time for the annual EMBT PR "We're making lots of money!" press release. And guess what? There wasn't one! The only logical conclusion is that they had a slump in sales, just as E.I. claimed. Coincidence? Insider trading? Or E.I. is who they say they are? Case #3: E.I. posted a message saying that the last e-mail the team received from Nick before he was called into an office and fired was "Make sure you test this, since Embarcadero will ship shit." Nick said he didn't write that as he would never use "shit" in an e-mail. E.I. then said, ok, it was probably "crap". NICK DID NOT DENY THIS and only said that he was not told why he was fired so he doesn't know if his last e-mail caused his firing. Others than asked him if what E.I. wrote was correct, and again Nick wouldn't deny it. So how would E.I. know the substance of an e-mail Nick Hodges sent to the Delphi development team, much less that Nick sent an e-mail minutes before he was fired, without being on the Delphi development team? I rest my case - you doubt it because you either don't know anything about the saga of Embarcadero Insider and/or you don't want to believe it. &gt;The press releases didn't mix anything. They all referred specifically to &gt;revenue, as clarified by Embarcadero. They also confirmed that they were &gt;seeing increased numbers of licenses, but the primary measure was &gt;revenue. I won't rehash this as I explained it in detail at the time on the forum and on your blog. 
Delphi Pro + Mobile is a better deal if you need all 4 platforms and only Object Pascal. Otherwise Appmethod is probably cheaper. For me you really need Windows support for FMX to do quick testing. Personally I think Appmethod should always ship with the Windows platform. You have to tweak some Delphi components to install them in Appmethod because it has no VCL (this involves just commenting out the VCL units usually).
Thanks, VCL and Windows support aren't issues for me - I run delphi on a VM on a mac so just as easy to test on a mac as Windows. Eventually I might port to windows, but I can delay the purchase until then.
You can get 2007 easily, and it is very compatible with 2006. Just get something newer, and you get the old stuff back to 2007. For a while we used to have a mix of people on 2006 and 2007 working off the same codebase without issue. 2006 is not available due to some kind of licensing issue with 3rd parties.
Nice! 20 or so years ago I had a Matrox video card where I could just press a key to auto-magnify my screen by 2x, then 4x then back to 1x. It was so incredibly handy for pixel tweaking or zooming in when presenting to someone at the back of the room, etc., that I am surprised that feature is not in modern video cards today.
That reminds me... Delphi 2006 and Delphi 2007 were VERY compatible. They intentionally made D2007 a non-breaking release, so even the DCUs are compatible. * http://www.bobswart.nl/weblog/Blog.aspx?RootId=5:2010
It was a one-time thing. In general, it's best to buy components with source code.
Forgot to mention. There is at least one book available on the subject. * http://www.amazon.com/Cross-Platform-Development-Delphi-Firemonkey-Windows/dp/151176600X
&gt;and no, Delphi usage has not been in "steep decline". Source?
Reality wouldn't be press releases. And you yourself once insisted to me that TIOBE didn't mean anything. :-) TIOBE is partially based on total number of web pages. This is what we call a "lagging indicator", much as an average would be. Lagging indicators are slow to indicate trends. That said, sites like FMXExpress have bumped up the number of Delphi pages; unfortunately TIOBE doesn't measure whether anyone's actually visited those web pages. In a comparison of several "popularity of language" indicators, all were in relative agreement with each other (no more than one ranking place difference between major language) with the exception of TIOBE. TIOBE ranked older languages such as Visual Basic higher than the other indicators, which is probably due to its using page existence rather than page hits in its indicator. In short, the irony of the TIOBE-bashers is that TIOBE's methodology favors Delphi more than other language rankings. :-) PYPL (PopularitY of Programming Languages) Index is designed to use Google Trends data, which shows what people are searching for, precisely to remove the lagging bias of TIOBE. Reality would be a measurable observation, such as, say, subscribers to this subreddit, Github stats showing people creating new Delphi repos, etc. Redmonk uses a combination of Stack Overflow questions and Github repos in its index. Personally, I'd use questions/new repos in the given time period to remove any lag. Anyway, I've already enumerated more than half-a-dozen reality-based quantifiable measurements that falsify the hypothesis that there hasn't been a decline. Heck, I've even gotten Nick Hodges to insist that no one on the official forum believes the Embarcadero user figures (!!! no I don't know why he'd claim that either). He's also said that he believes Delphi has an order of magnitude less users than C (which is estimated to be about 1.9 million), yet the Delphi 10 Seattle press release decided to add another million and claim there are over three million Delphi users now. I guess you can argue with Nick then about the veracity of Embarcadero Press Releases. :-)
I understand that it's important to you to portray Delphi as dead or dying, though I'm not sure why. I'm afraid that just isn't the case, though. Good luck with your crusade.
&gt; TIOBE didn't mean anything I remember you quoting it a few times when you thought it supported your bias. 
Yes, I did insist it meant something - when you and Rudy were insisting it didn't mean anything. :-) It still does mean something. But as I explained more than two years ago, I think there are better measurements because TIOBE's lags behind. Also, be warned that TIOBE recently adjusted its ratings algorithm regarding outliers in September, which caused some ratings to change: http://www.i-programmer.info/news/98-languages/9046-tiobe-tweaks-algorithm-to-eliminate-noise.html
If you want truth and reality, rant about climate change. Your very long running grudge against Delphi and anyone who supports it is something else entirely.
Code editor for Windows and OSX very similar to Visual Studio Code. All Firemonkey. Open source. http://www.trolledge.com/
It's disheartening that we still need 3rd party fixpacks. And i didn't know they were still being created; the one i use chokes on startup: http://i.imgur.com/Mull6qG.png Guess it makes sense when it is *"unsupported"*.
Think of these as experimental branches, like they have in Linux. Over time, several of these fixes have been incorporated into the product.
Posted here: http://www.getlazarus.org/apps/cpugraph/
Worse candidate ever to this "challenge": DDD patterns and frameworks like our little mORMot. RAD is great for building UI at presentation layer, and a nightmare to maintain when it mixes UI and logic. Fast to write, hell to maintain... IMHO Delphi RAD advantage is to create client apps of a cleanly written server, which by itself would exclude RAD. Without the whole tool chain (client + server), pushing RAD as marketing would hardly make the plot, especially for SW decision makers...
&gt;So mems.size has a decimal value of 404 - hex **01 94** That's `01` for the high byte and `94` for the low byte. `01` appears first *because we start writing the highest digits first*. That's really the only reason. x86/x64 PCs are little-endian machines, so lower bytes are stored at lower addresses. A hex dump starts at lower addresses and proceeds to higher addresses. Therefore `94 01 00 00 00 00 00 00` is absolutely correct.
The Starter Edition is still too limiting, especially the revenue limit is kind of laughable. By the time you reach that limit, you basically have to pay out all of your Revenues to Embarcadero to upgrade to the Professional Edition. It also does not get rid of the massive amount of feature disparity between the Starter and Professional Edition. Some people simply cannot use Starter Edition, because it doesn't have what they need. That's a start contrast to Apple and Microsoft. Apple's tooling isn't industry-leading, but the entire thing is free for the taking. Microsoft Visual Studio "Community Edition" is almost the same as the Professional Edition and for a small start-up or independent developer, completely free. Another issue with Delphi has to do with the fact that it's Delphi. Documentation is poor and choices are extremely limited. Anyone college student looking into C/C++/C#/VB and even Objective-C or Swift can go plop down in a Barnes and Noble here and basically read for free with their laptop in front of them. The Tooling (Visual Studio, Xcode), Programming Languages (C, C++, Obj-C, C#, VB, Swift), and Libraries/Frameworks (.NET, e.g.) are all better documented than Delphi, VCL, FMX, RAD Studio, etc. It's pretty sad, that Swift 2 has more current, superior books available for it than Delphi does at this point - unless you want to buy Old Delphi Books and work out the differences on your own. And yes, their pricing is laughable - at least from a "build up your base" standpoint.
https://msdn.microsoft.com/en-us/vstudio/dotnetnative.aspx?f=255&amp;MSPPError=-2147217396 This is just not something to care about, especially with how Windows is being developed/updated these days. Both the Platform (Windows 10) and the Tooling (Visual Studio) is updated continuously. The chances of anyone on a decently modern Windows OS not being able to run your application due to not having .NET installed is just slim to none. Performance of .NET applications is not that big of a concern anymore. They have taken steps to weed out that concern.
The Chr function converts a number to a character, using the ASCII table. ie. the letter 'A' has an ASCII of 65. The letters are all in sequence so it makes it easy to treat letters as numbers and vice versa for manipulation. You'll need to use a few loops to build up each string of characters, randomizing each character as you go.
Knowing Embarcadero, another 470 bugs created as well.
&gt; If you want to ensure non duplication, use a TStringList with its Duplicate property set to dupIgnore. Not how I would go about it. All possible combinations can easily be created numerically. /u/AdigeWottah, do you know how our [positional number notation](https://en.wikipedia.org/wiki/Positional_notation) works? Do you know how to [count in binary](https://plus.maths.org/issue44/features/sangwin/binary_table.gif)? If not, you should start by learning that. What you have there are five places, and each place has only two possible values (X and Y) - that's nothing else but a five-digit binary number, written with X and Y instead of 0 and 1. How many possible combinations are there? The formula is "number of symbols (values per digit)" to the power of "number of digits (places)", i.e. in your case 2^5 = 32. Therefore, all you have to do is generate a sufficiently large random number (must cover all possibilities, i.e. in your case at least 32 - that is easy, just use the built-in Random function), and then convert that number to a string consisting of your desired symbols. I could post a short solution here, but I don't want to do your homework for you either. I hope I gave you some ideas, though.
I didn't say it wasn't a contender, it's just a bad contender, because the price of entry is too high. Xamarin is $25/mo for an Indie License, so your price comparison is way off base. Visual Studio Community Edition ships with Xamarin integrated into the installer (and IDE if you choose to install it) - so the base price for someone just getting started developing, even multi-platform/mobile with Visual Studio, is $0. It has been this way since Visual Studio 2013 [Community]. Developing with Visual Studio is significantly cheaper, and as long as the programming language itself isn't an issue to consider, Delphi practically isn't a contender - even if it literally is due simply to its existence in the market. As for Desktop and Universal Windows App development, there is .NET Native and of course the .NET Framework is bundled with Windows. With Windows' new rolling release cycle (similar to OS X), that is not an issue moving forwards. People won't be on XP forever. In a few years, the vast majority of PCs will be Windows 7 (vestigially in Enterprise corners) or Windows 10. Delphi documentation is terrible. You can barely find a book, physical or otherwise, on any recent release of this product. They may have improved their help files (they were terminally ill for quite a while), but that helps only a little. I know they are giving away Marco Cantu's Delphi Language book with new purchases, but that doesn't hold a candle to the books you can get on other development languages on the market these days.
I would want to do the work myself, either. :) Thanks for pushing me in the right direction.
Here are some links Searchable library documentation: http://docs.getlazarus.org/ Free Pascal 3.0 and Lazarus installers: http://www.getlazarus.org/setup/
Looks good. Downloaded it today.
No schools teach Pascal anymore. When I was in high school back in the late 90s the schools had just replaced Pascal with VB5 for CS1 and C++ (using Borland C++ 5) for CS2; then they added a Web Design Class that taught HTML. These days a lot of schools have dropped VB and have replaced it (and in many cases C++, as well) with languages like Python and Java; the latter of which [esp.] being similar to C#. So, someone interested in Programming that has or is taking the classes is likely to be more familiar off the bat with that style of Syntax than with Delphi - which basically makes it a larger learning curve. The fact that it's a managed language also allows it to shortcut where Delphi/C++ cannot, as well. Fortunately, because the Framework among .NET languages is identical, C# doesn't matter that much. Someone can learn Visual Basic and have a much easier time with much of the same advantages that C# and .NET have, including the 3rd party Libraries/Plug-Ins/Books/etc. Your alternative choice with VCL is C++, and I'm not sure you're willing to go down that path (never mind Visual C++ does .NET, anyways so there is still incentive to go that route over C++Builder given its interoperability with other .NET languages and ability to use the same Frameworks). Many 1-2 Man Shops disagree with you. More agree with the other .NET small shops that have ignored Delphi. Delphi's user base has gone DOWN over the years. I didn't say no one used Delphi, and I didn't say you were ALONE in your assessment. I just think it's more an exception to the norm. I don't agree that Delphi is the way to go over .NET. Again, Framework is not something to worry about these days. The language isn't a big deal. With intent, a dedicated "student" can learn whatever programming language they prefer as a first language. What overwhelms most people is the breadth and expansiveness of the frameworks and Libraries. That is a lot harder to memorize than syntax and design patterns, best practices, and IDE functionality. That is why I dislike the lack of writing for Delphi and VCL these days. I am not talking about the built-in IDE help. Delphi is a good product, but I don't think developer tools these days - outside of the enterprise - are a great commercial product. They're commodity. It's not 1990 anymore. No one wants to get into programming paying $300 for developer tools, when they can get the alternatives for free. Also, I don't think VCL is much better (if at all) than .NET and .NET distribution is simply not an issue unless the core of your user base is still on XP or Vista - both unsupported OSes outside of the enterprise. Not everyone is developing solutions that are contained in a single EXE file, Lol. Some projects are a bit bigger than that. And I still think Visual Studio is superior for mobile development, compared to RAD Studio. You are overemphasizing an issue that is largely irrelevant these days. Distributing the .NET framework was more of an issue back in the XP days. That is largely non-factor since Microsoft started distributing the Framework with Vista, and you can target a specific .NET version with Visual Studio to avoid having to worry about this. In fact, 2015 defaults to targeting 4.5 instead of 4.6, for that very reason. That is not an issue that developers should be wasting time worrying about these days. It is almost no issue at all.
It's not a minor complaint. Again, for Independent Developers and Small Shop $1,600-$2,100+ per license is not a small cost. Not at the price mobile apps are selling at, and when you consider most mobile apps aren't setting sales records. The price is a bad value proposition. The price is a big deal because you can do equivalent with tooling that costs a mere fraction of the cost of Delphi. You can get RemObjects for a perpetual license, up front, and do this with Visual Studio so I'm not sure what your point is. You were just trying to equalize things up thread by pointing out the recurring cost of Xamarin; now you're flipping it? Delphi/VCL experience is not worth much around these parts, and lots of companies don't want to touch it because it's fairly niche here and they don't want to be beholden to a small pool of developers to fix/maintain their code when you aren't around. Lastly, choice of programming language isn't the only reason why people choose Visual Studio. That IDE has a much bigger 3rd party Plug-In and Component Ecosystem than Delphi does, as well as having first class support for Microsoft's technologies on their platforms. Knowing how to use the IDE is almost as important as knowing the syntax of the programming language these days, considering how much is done with it (this goes for Delphi as well, except Visual Studio is like the Microsoft Excel of IDEs on Windows, if you catch my drift). The whole point of the discussion is whether it's worth it; not what you can use to learn it. I don't think it's worth the time to learn it, personally. You can do just as well, for less overall cost, using other developer tools. As I've said, the Syntax is not that big of a deal. I honestly don't think Object Pascal is that much more difficult to learn than Visual Basic 14. Most time, I feel, is spent learning the frameworks, design patterns, best practices... And yes, the tooling as well. Delphi is not worth $2K when Visual Studio can be had for free. That tool is irrelevant to anyone that isn't a fanboy of it (and every environment has those). It's like the more users they lose to other IDEs, the higher they raise their prices to compensate.
[CodinGame](https://www.codingame.com/start) is a website that teaches programming (mainly through creating video games) that is meant to get kids, teens, generally anyone, interested in programming.
 &amp;nbsp; Edit 2: Solved &amp;nbsp; Ok. The problem was because of Window's Scaling Virtualisation. The WinAPI calls all*lie* to you about their pixels. This is because that is the only way windows could scale old applications appropriately. I am really quite ranty that there were no additional api calls provided to get the RAW PIXEL values. &amp;nbsp; In order to solve this you have to set you application to DPI aware (using a manifest or SetProcessDPIawareness) - Doing this stops DPI virtualisation lying. Unfortunately it makes your application look like crap. I ended up creating a separate executable (that *is* dpi aware) to write the true screen resolution to the registry. My main application can then use the registry recorded resolution and the application's reported resolution to get the necessary ratios and then multiply out the false coordinates. &amp;nbsp; Almost a whole afternoon of googling did not produce an api call to retrieve either this ratio or the unmodified screen resolution. 
hey thank you for your reply. I haven't got around to test the code you have presented. instead I believe I got the hang of the VLC-player for delphi now. for windows I downloaded the test-project from here http://prog.olsztyn.pl/paslibvlc/ with the FreeBSD as title. then I moved the contents of the download in my tools directory of my delphi installation and double clicked on the .dpk file to compile and install the components. then I could just use the player-component. from here on out it's trial and error with the component. I will try to figure your code-example out once I have vacation. thank you again.
For those of us using Delphi, what's OmniPascal got for us? What's the tl/dr?
Does this integrate into the IDE? Does it switch between form and code? Can I configure project options? Or is this a Delphi syntax enabled editor, with code insight? It's never often ever that I don't myself writing just code. It's always code, save, build, code, build, form, build, run, code, build, run. But Borland certainly needs to learn about modern editors.
It's a code editor with capabilities to attach a build process. So you can use it for coding and building your projects. Search paths are stored separately in the editor's config files but this will change in the future so it will support dproj files. There is no form designer. The IDE is meant to be used side by side for UI and debugging purposes.
I was taking a look last night on my Surface. I didn't realize it was Visual Studio Code. I've been wondering if someone was going to write a language plugin for Visual Studio Shell; but then you have to have the entire syntax parser - and you start getting into what Chrome was. But it looks interesting enough that I'll install it at work. 
Your app is written in what version of Delphi?
ಠ_ಠ
I thought Embarcadero sold the company?
What on Earth are you doing that it takes you 18 months (!!!) to upgrade to a new version of the compiler? And what version are you coming from?
Yes, Embarcadero was sold to Idera. http://community.embarcadero.com/article/news/16201-customer-and-partner-welcome-from-idera Apparently the name Embarcadero is still being used and Delphi development continues (read: not shelved as Borland tried to do).
Or just install Lazarus and have a nice GUI version of 'Hello World'. I have the older B+ and while it took a little jiggery-pokery to get it running, it's Object Pascal running natively. 
&gt;Now for the $100,000 question... "is this going to be in a future release?". &gt;Well, &gt;your guess is as good as mine. If I had any say whatsoever, which given the &gt;current state of the company I don't, it would. He's getting really passive-aggressive with his comments about Idera, as if he wants to get fired rather than quit so he can collect unemployment. Meanwhile, he never said "boo" when Embarcadero treated its customers like crap, tried to change the Pro EULA to forbid database access, etc. I'm hoping this means Idera is cleaning house of the old guard and installing a new, customer-first regime with Delphi. The old guard are publicly throwing temper tantrums because for the first time in 20 years they're being told "no". 
WinForms, and WPF, are quite poor UI frameworks. WinForms has been equally abandoned as VCL, and is nearly as buggy as the VCL, but the VCL has slightly more capabilities, and vastly more 3rd party controls. WPF - creating applications with markup - is just awful.
Hello, Perhaps the following ESET Knowledgebase article will be of use: * ESET Knowledgebase #2843, "[*How do I create a firewall rule to allow/disallow use of a certain application in ESET Smart Security? (9.x)*](http://support.eset.com/kb2843/)" Regards, Aryeh Goretsky 
The VCL is still in active development, so I wouldn't describe it as "abandoned".
&gt;WinForms, and WPF, are quite poor UI frameworks. That's something of an extraordinary claim given how many people use them. You're going to need to elaborate on that. 
Periodically getting a small change to keep it usable doesn't really make it actively developed either. It would be madness for it to be in "active development". Why would you introduce every new feature twice? Now, since so much Delphi use today involves maintaining legacy applications, you can't abandon the VCL. They haven't abandoned dbExpress. Microsoft hasn't abandoned Win32. However, all three of these things are officially or unofficially in "maintenance mode". You'll get bug fixes and any code changes required to keep them going, but you're going to see new feature development centered on the newer de facto replacements (FMX, FireDAC, WinRT). With Delphi it's a little different since FMX doesn't have all the usability of VCL on the Windows platform yet, but generally this describes how things are going. 
&gt;Blend ships with Visual Studio, but the trend with XAML is away from RAD, &gt;which is where many Delphi developers are still stuck (overvaluing ease of &gt;use). Ironically the language itself today is anything but RAD. WPF is a very powerful framework, and modern designs like XAML and QML help keep a separation between UI and code which rarely exists in the Delphi world. In fact, I've heard Delphi/Visual Basic UI design be referred to negatively as "drag and drop programming", which went out of style when VB was discontinued. 
It doesn't sound like you've been keeping current. You should read some of those What's New links.
I avoid var and out parameters as much as possible. But sometimes it's relevant to the performance to use them and it's still readable. Example: function TDictionary&lt;TKey,TValue&gt;.TryGetValue(const Key: TKey; out Value: TValue): Boolean; You only have to lookup the value once to know a value is stored for the key and to work with it. procedure TTextFileCache.UpdateFileContent(const FileName, FileContent: string); var FileCacheItem: TFileCacheItem; begin // one lookup, no additional assignment check required if not Dictionary.TryGetValue(FileName, FileCacheItem) then begin FileCacheItem:= TFileCacheItem.Create(FileName); Dictionary.Add(FileName, FileCacheItem); end; FileCacheItem.Content := FileContent; end:
Delphi code can also be clean. Nick Hodges wrote two great books about the different pattern implementations for Delphi. You can buy both here: https://leanpub.com/b/codingindelphibundle Take a look also on the Spring4D sources (https://bitbucket.org/sglienke/spring4d) and a corresponding tutorial video about dependency injection (https://www.youtube.com/watch?v=8iB_ppvpjxM). Is that enough muse for you? 
Very cool! Looking forward to using this!
I dont know when, but it's in XE2 for sure.
Followed these lessons, worked great for me! I liked whatching them on https://www.youtube.com/html5 so I could speed up the parts that I was already familiar with. 
Nope, sorry. You can re-fold things like all methods from the context menu or with editor shortcuts, if that helps. http://docwiki.embarcadero.com/RADStudio/Seattle/en/Using_Code_Folding
Alright. Thanks anyway for the link, looks like a very helpful website
Are you sure about that? http://www.theguardian.com/technology/2014/sep/04/coding-school-computing-children-programming Microsoft and Google have been educating teachers, and Codeacademy is heavily involved in the new curriculum: http://www.wired.co.uk/news/archive/2014-12/22/coding-curriculum-a-look-back &gt;What has the first term of the new curriculum been like? &gt;I'm very happy with how this term has progressed so far. Our year 7 students &gt;have been using Scratch and learning how the internet works, and will be &gt;moving onto learning some HTML in the spring. Our Year 8s and 9s have &gt;been using JavaScript to control virtual bots, and then learning about logic &gt;gates and how CPUs work, as well as doing some opcode programming on &gt;the Little Man Computer. Everyone's also getting a Raspberry Pi. Here, wait, found it: http://www.pri.org/stories/2014-09-25/reading-math-and-javascript-coding-now-mandatory-english-schools &gt;All children between the ages of 5 and 16 in English public schools are now &gt;learning computer science — not just how to use software, but how to create &gt;it, too. Teenagers will have to master at least two programming languages: &gt;Java and Python. It wouldn't have made any sense for England to be using Delphi, as there are no Delphi textbooks nor any interactive online Delphi courses either. As far as I know, South Africa is the last country still using Delphi as an official part of their curriculum (with Java being the other option), and teachers were able to scuttle a proposal to only use Delphi. South Africa had to commission their own textbook, which was published in 2005.
It's in the AQA materials, so yeah, I'm pretty sure. 
(from the blog) As we have been developing UI VCL framework components since 1995 and FireMonkey framework components since 2011, we have recently been doing extensive research on approaches to create visual UI components that would simultanously support the VCL framework and the FireMonkey framework. As a result of this research, we came to the conclusion that the approach for VCL and FMX can also be easily applied to LCL, the component framework that comes with Lazarus. Doing so offers a number of advantages both for users of the components and the developers of the components. With respect to using the components, the user can seemingly exchange code between a VCL project and an FMX project as the interface and class name of the component is 100% identical. When porting from VCL to FMX or vice versa all code can be shared as-is. Just like you'd write the code in VCL Edit.Text := 'Hello world', you can in exactly the same way do this with a FireMonkey TEdit or LCL TEdit. As with the result of this approach, the UI components also become usable with the LCL framework in Lazarus, this means that writing Pascal based GUI apps with these components also becomes possible for additional operating systems supported by Lazarus/FPC, i.e. Linux and its variants like Raspbian. Also for the development of the components, there are a number of advantages. With a sufficiently abstract layer in place, the component developer can focus on the component UI look &amp; feel and behavior rather than with the particuliarities of each underlying framework. Support and maintance for highly complex components means managing a single code base as opposed to maintaining 3 code bases. This leads to faster development and support and ultimately to more stable code accross 3 frameworks. For the result achieved, we came up with the name FNC components, which stands for Framework Neutral Components. As a proof of concept, we have now released our first FNC component TTMSFNCChart that supports a mind boggling array of frameworks and operating systems: VCL Win32/Win64 from Windows XP to Windows 10, FMX Win32/Win64, MacOS-X, iOS, Android, LCL Win32/Win64, Mac OS-X, iOS, Android, numerous Linux variants including Raspbian. Oh, and there is an extra benefit, the component is not only usable from Delphi or FreePascal but also from C++Builder. The feature set of the TTMSFNCChart is more or less identical to our FMX chart that includes line,bar, XY-line, XY-scatter, area, stacked bar, stacked area, digital line, pie, spider and donut charts with highly customizable legends, X-axis, Y-axis etc... 
We multiple Datasnap services running on Windows 2008 as windows services since years, but we have less than 100 concurrent connections. its' running most of time without problems, also our clients are: Delphi &amp; PHP. Some of the services running as TCP/IP which we use Delphi clients withthem, other run as Http for PHP &amp; Delphi clients. You can deploy it as Windows application, windows services or as DLL for IIS &amp; Apache, we only use windows services for easy deployment. 
If the syntax/script changes to go from MacPorts to Brew aren't /too/ scary, I'd be happy to help do (or test) that for you. (I have an older Yosemite MacBook handy, that has neither Brew nor MacPorts on right now, and I plan to upgrade it to El Cap next week). I know very little about Brew other than as a user, but I imagine scripting it isn't going to be too different to MacPorts...? Well, a tentative offer of help is there, anyway :-) (edit: By the way, I will also give the Raspi update a test this weekend and report back).
If you can modify the script to give users the choice of homebrew or macports that would be great. I'd suggest testing for either first, and if found using whatever is installed, otherwise give them a choice.
Answer my own question. Install jcfidelazarus package from Package menu.
I never heard of this one. I will take a look. Thanks!
&gt; Surprise is, Delphi supports you very well in this Yeah, Object Pascal has very good OOP, actually, even more since Delphi 2009 with generics. &gt; Keep the form objects only for UI, all the rest in the right classes and it will turn out just great. I do this and it is definitely worth. My biggest difficult is decoupling the logic from SQL, which can be done with ORMs in other languages. &gt; For several years I transitioned to web programming I do web too, mostly with Rails and Go Lang. I find it more funny than desktop, but Delphi is still more productive for boilerplaty things like CRUDs. Thank you for sharing your thoughts!
This sparked some discussion over on Google+ (bless) about whether or not chasing a Mac-based toolchain is something we'd like them to do. https://plus.google.com/+MarcoCantu/posts/2SkVPNo9Ue6
That was a nicer video than i think I've seen from EMBT lately! Of course, Linux users shouldn't forget that FPC and Lazarus are probably in their distro's repository and they can use their package manager to install it.
This seems to be an issue where Borland/EMBT have always made the wrong move at the wrong time. Back circa 1999 Linux as as server OS was beginning to become popular in business. Delphi users wanted a tool where we could continue working on Windows, hit a button, and get a Linux version of our program for distribution. Instead, we got an IDE we had to run in Linux (and since it was the Windows IDE running through a Windows compatibility layer for Linux that was in its early stages, the experience was poor). We also had to use a new framework. Linux on the desktop was in a poor state at that time. I tried a commercial distro around that time and had 2D-only graphics support, no driver for my sound card, and I could read but not write to Windows partitions (and since Windows didn't and still won't read Linux partitions, it meant whatever you did in Linux stayed in Linux). On the other hand, Linux users didn't like Kylix because one had to include the closed source Kylix library with your program. Borland's answer was to statically link it in, but that resulted in needing to distribute a binary blob and static linking is frowned upon in Linux (defeats the benefits of package management). In short, Kylix was not what Windows users wanted nor what Linux users wanted. Windows users wanted a cross-compiler for server software and Linux desktop users didn't care much for producing Windows desktop software and they did not want their open source code to have closed source dependencies or binary blobs. Fast forward to today. The rise of mobile OSes broke the back of Windows lock-in; cross-platform is expected today. Both OS X and Linux are capable desktop operating systems (and Android/iOS are probably used by the average person more per day than any desktop OS). Stack Overflow's survey shows 20% of respondents run Linux desktop; obviously cross-platform dev tools that run natively in Linux is now desirable. What do we have now? An IDE that targets cross-platform, but only runs in Windows when a vast amount of code is being developed on Linux and conferences are a sea of MacBook Airs. They're talking about adding Linux support (server only, non-GUI) when Linux is now a fantastically capable desktop OS, especially for developers. When it was poor, we had a Delphi IDE for it. :-( It's almost comical. When I complained that no Mac user is ever going to buy Delphi to write Mac software, Dr. Rudy insisted they would because "Windows doesn't cost that much". He misses the point that it's not 1999 anymore. Today there are many fine, capable development tools for the Mac and no Mac user needs to buy a copy of Windows and use Parallels or a VM just to develop code for their Mac! It's even worse given the UI changes of the most recent Windows versions; an OS X user would be asked to put up with Metro on top of everything else. It's 2016 and the Delphi community is finally talking about the idea of a language not being inextricably bound to a single IDE, a single framework and a single operating system. That's progress, but it's a talk that needed to be had many years ago. 
I always suggest mORMot, you can check how active the development is here: https://github.com/synopse/mORMot/commits/master Check how active the user forum is here: http://synopse.info/forum/viewforum.php?id=2 mORMot is shipped with a bunch of samples to get you started: https://github.com/synopse/mORMot/tree/master/SQLite3/Samples And it's fully documented: http://synopse.info/files/html/Synopse%20mORMot%20Framework%20SAD%201.18.html (Though it's not written by a native English speaker)
I have really hated watching the shitshow Delphi has been since v4 or so. I used to love it so, so much. 
I've been a customer since Turbo Pascal 2.0 for CP/M. I thought that when CodeGear came to be that things were turning around and Delphi would rise above those drooling retard MBAs at Borland. Nope. The management at Embarcadero is going to ride Delphi into the ground and there's not a fucking thing we can do to stop them. I strongly suspect they'll blame us "cheap" users while their house collapses around them. I'll not spend another dime with a company that treats its customer base as victims to be squeezed for more protection money. 
The Linux packages are usually horrible out of date, both in terms of the compiler and the IDE. The version at getlazarus ships with a docked form designer, the new 3.0 compiler, an improved menu editor, better unicode string support. You'll get none of that in a current Linux distribution unless you build from sources, or you use the getlazarus bundles :).
I miss the big thick manuals from Borland. Doesn't make much sense now, but they were great to take to a lunch break or on the bus.
&gt; $900 for an upgrade That is just freaking insane. For any software program that's not enterprise stuff, and maybe not even that.
I'm not a Delphi guy, just an outsider looking in. This whole situation is extremely baffling. Why do you guys stick with this company? Why would you pay this much money when there are a ton of other perfectly good programming languages out there that have completely free compilers? 
Just another reminder of why I'm glad I moved to FreePascal (both personally and professionally) many moons ago.
I used to use TP as well. Probably started with...3? Can't remember anymore (been a long time now). Bought Delphi 1.0 sight unseen, loved it. I think it all really started to go to shit when Hejlsberg left for Microsoft. I'd like to say it had a good run--it deserved it, imo, at the time--but it feels like it just had a run that could have been so much better, still today. A shame.
Native Windows development. Including WinForms, WPF, Qt, and every widget library, you won't find a better platform for Windows application development. Which sort of works out, because nobody wants to run applications anymore.
I doubt that. Rethink. What shall they do? It's obvious that they are boiling frogs and you are the frog :). Delphi is no longer a mass product. Delphi was never cheap and in the meanwhile you get lot of good stuff with every release. Agreed. The moment you stop paying for a product you should stop using it. Honestly. If people don't pay for SA and expect a cheap upgrade after 5 years - what will all those think who carry the burden of financing the evolution. I have no problem with forcing people to pay for SA from that perspective. We will see if that approach works.
One proactive thing you could do is investigate the suitability of [Free Pascal](http://www.freepascal.org) and [Lazarus](http://www.lazarus-ide.org) for your development needs. More options for Object Pascal development is always a good thing.
Can't really argue with any of that :-) On the one hand, I'd love to see a first-class citizen Delphi IDE on the Mac. It would tick a lot of personal workflow boxes, and there is no better way to improve a product (FireMonkey) than to dogfood it on an important revenue stream. If Embarcadero were relying on FireMonkey to make Delphi's Mac (&amp; presumably also Windows) IDE, then FireMonkey itself would improve at a quicker rate. On the other hand, Embarcadero are already in the same school of charging* as Xamarin, and their engineering resources seem pretty stretched. Assuming that the Mac IDE idea is going to use existing resources, then that's even less work done on the bugs and 'refactor opportunities' within Delphi and in particular FireMonkey. So the Mac IDE is either going to put the price up further still (and it really won't stand any more, of that I'm quite sure) or it will further detract from what is already a bit of a mixed experience for the existing paying customers. I don't know which way they will bat - as you point out, historically they've often picked what turns out to be the wrong move so I could be optimistic here and say they'll make a choice and for once their luck will hold, or I could be pessimistic and say that whatever they choose to do, it will be the wrong thing. They can't win :-) *I don't have a problem with the concept of charging, I'm in a business too. But it is a lot of money and often you feel you're paying for upgrades just to get bug fixes (i.e., a working version of something you already thought you'd paid for), and sometimes the 'added value' features they add are a little half-baked (or, to be kind, they remain very 'v1.0'-like for the next few releases before finally becoming stable and usable).
We are paying about 900€ for C++ Builder Enterprise per Developer here. So I'm not shocked at all. For my personal Projects the whole IDE is just too buggy/slow and the VCL quite unwieldy. So I've switched to Qt and Qt Creator long ago. The main problem is, that once you need some support from E. you are mostly screwed. We wanted to move licenses from someone who quitted, which boiled down to a week long back and forth of E-Mails, which probably cost us more in developer time than a new license. This, and the bad state of the IDE (XE10 seems to have some serious speed issues here and the "new" help system really sucks) and being too dependent on the VCL finally brought us to switch to Visual Studio for future development. It's maybe not cheaper, but you can be sure that it's a solid IDE to place your bets on for the future. The VCL and the Library will be missed in the first months, but once we are more familiar with boost and other C++ Libraries we will be fine. The problem is also, that once you hire someone new, you have to spend more time to train him/her. Finding your way around the Delphi standard library and the quirks of the IDE takes it's time. It took me abount 2-3 Years to get mostly competent. Having bad documentation with too few examples doesn't make it easier. Especially if you have to google for a problem solution with the VCL, finding (usually not finding) Delphi code snippets and having to translate them to C+++ makes it harder to become really productive. I understand E's prices, they are not too high for professional use. If you can save one day per month due to the RAD nature of the whole thing, it's worth spending 1000€ or more. Because that day the developer can work on the next project and earn the company those 1000€ back. But you will not getting a larger user base with this. Working with C#, Visual Studio and the .NET Library is easier - more Books, more Google results more trained developers coming from the universities. And for private projects you get the whole IDE for free. Thats how you get more users, that how to not become an irrelevant platform in the 21st century.
Seems to make a convincing case for not charging $1000, and trying to build up the same sort of grass-roots following that Borland did in the 90s. 
I fit into 2 categories, ISV and Large. I do contract work as an ISV, and man, their licensing fees are just ridiculous. I certainly miss the days of low cost, trimmed editions of Delphi. We've been very seriously considering switching our work over to FPC/Lazarus, just because of the newly announced required support contracts. Enough is enough!
I agree, but Embarcadero doesn't seem interested in creating a broader base of Object Pascal usage at the moment. I'd say [Free Pascal](http://www.freepascal.org/) is the way forward for increased grass roots support for Object Pascal. Free Pascal is freely available, fairly compatible with Delphi, and improving year by year.
I'll give you the most honest answer you'll get. You have to understand the mind of the Delphi developer. First, your average Delphi developer doesn't look at other programming languages so they have no idea that there are other perfectly good programming languages out there. Second, the smaller something is, the more zealous its defenders become. Object Pascal has become somewhat of a cult as a result. You frequently encounter someone writing about their "loyalty" to Delphi. Nobody, on the other hand, has loyalty to C++ or Javascript. Third, most Delphi users, by virtue of being "loyal" and ignoring everything else, have not updated their internal knowledge since circa 1999. In their minds, Java is still "slow". Small EXE file sizes are crucial. Delphi is "the fastest development tool in the world", even though it's one of the last statically typed languages on Earth that hasn't implemented type inference. In fact, on the official Delphi forum one user dismissed type inference as "impossible" when I tried to explain it to him! "Native" code is vital. Web applications are still a "fad", as is functional programming, design patterns, and anything not already in Delphi. OS X and Linux aren't really important. Open source software is all buggy and crappy and people know that you get what you pay for so nobody is actually using or writing open source software - or as one prominent Delphi user wrote a year or two ago, "Why would I possibly give away my code for free?" Also, since Delphi is "easy" and "RAD", then that must mean that everything else is very hard or impossible to learn. Many Delphi developers, like Microsoft Access or Visual Basic developers, have no formal training or computer science degree. Years of marketing have convinced them to be afraid of anything else... on top of this they're almost all lifelong Windows users, so the idea of anything without a GUI is doubly intimidating. Generally, for a large subset of Delphi developers, if it doesn't exist as an icon in a tool palette they can drag onto a form, it doesn't exist. That's why even in 2016 people are STILL working to convince Delphi users of the benefits of distributed version control (and many don't even use version control at all!). Delphi didn't get version control support until very late, and even then it was Subversion. So most of those who are left in 2016 either don't know what their options are, are misinformed about their options, are intensely loyal to a product from a company they hate, or are hopelessly locked into the product - their job is supporting a 15-year-old Delphi codebase (most professional Delphi users are not producing new programs) and they don't have or don't think they have the time to ever port it to anything else. Oh, and of course, there's always simple inertia. It's hard and scary to step away from something you've been using for so long - and almost to a person those you find still using Delphi were using it from the very beginning (1995) or close to it. That helps produce a fear about switching to something new and having to "start all over" and not be an expert any more. There's more comfort being a big fish in a small pond. Actually I've been toying with the idea for about a year now of producing a blog whose main purpose would be to educate Delphi users about the options they do have and correct a lot of the misconceptions about Delphi. It's sorely needed. 
&gt;Including WinForms, WPF, Qt, and every widget library, you won't find a better &gt;platform for Windows application development. If that were the case, it would have a bigger user base, wouldn't it? What the heck can FireMonkey do that Qt can't? 
&gt;That WAS valid back in the days of Windows 2000 and XP Honestly, that's the last time a lot of Delphi users looked at other technologies. That .NET is awful and slow is one widespread myth in the community; the other is that Java is slow. You'll notice that not a single person will ever be able to show you HOW VCL or FMX is superior to .NET or Qt. I've been trying to get an answer like that since the end of 2012; even EMBT's marketing people and product managers can't give me specific examples of how their product is superior (and hence worth the premium price). 
&gt; I thought that when CodeGear came to be that things were turning around and &gt;Delphi would rise above those drooling retard MBAs at Borland. The problem is the people behind the product never changed from Borland to CodeGear to Embarcadero and (so far, although Alan Bauer keeps semi-suggesting he'll quit but hasn't yet) Idera. Unless Idera turns a fire hose on the product, gets rid of the "lifers" who literally have never held a job anywhere else than Borland and its descendants, and get some fresh eyes on the product, nothing will change. Every year a few more will leave for C# or similar, the price will rise, and incremental updates (catching up to things every other product had 4-5 years ago) will take place until it's no longer profitable, then it will be discontinued. And the people who caused it to die will wail the loudest, without realizing they're the ones who ruined a great product. &gt;...while their house collapses around them. They live in such denial, and so cut off from their own customers, that they honestly don't believe it's collapsing.
The native windows VCL is so good. There's no real replacement for it. I can crank out nice looking performant windows apps on it. For LOB apps with lots of data entry and reporting, theres nothing even close for me. I've looked at replacing Delphi with a web front end using something like Kendo, but it's just not a viable replacement for the types of apps i build.
Trust me, I'm about as tech agnostic as you get and i'm well informed of my other options for desktop LOB windows development. Nothing compares to Delphi for this niche. Please, do tell, what are my plethora of other options? m$ royally fucked up when they forced all Desktop development to .net I suppose QT could be an option. Thats about it 
It wouldn't be too bad if their multi platform kit was usable. It isn't so now I'm paying $900 for a windows desktop dev tool. I would love nothing better than to jettison Delphi, but WTH am I going to replace it with?
The key thing is 3rd party component support. If i can get a decent set of GUI controls, reporting, charting, and office exports i'd switch off Delphi in a heartbeat. The IDE is such shit anymore. I'd love to use FreePascal and emacs.
Provide me a rad UI for designing UI visually.
Yes. In modular languages the interface section describes those functions or procedure to be used. I personally prefer the separation of the interface from the implementation that way. It's another way of encapsulation. In C the header file does the job of the 'interface' and in Delphi/Object Pascal you can have a file similar to a header file with just an interface section (*.inc extension). A class for example also does provide encapsulation. In the past you did have the abstract data type or the abstract data structure. In case of an ADT the interface exported a POINTER (in Modula for example), an init routine allocated the 'record' and the functions in the interface section allowed to manipulate the data referenced by the POINTER. Think of trees, lists, .... MODULA did offer an definition module und an implementation module. This allow to define the pointer in a type safe fashion without knowing the record structure referenced. That's an explicit support for ADTs. In C#/.net and Java the class does offer the encapsulation as in any other object oriented languages. In Delphi and Object Pascal both classes and the module do provide the encapsulation and in the class you specify the 'visibility' via the access modifiers (private, public, protected, strict private ....) From that perspective the interface section contains the public functions and procedures. And you must import the module in the uses clause. In MODULA for example you imported every function separately.
You mean like Qt Creator? http://www.qt.io/ide/ 
I remember ordering Borland Pascal 7.0 at a job I had in 1995. After it was delivered, the company owner lugged the heavy box to my desk and said, "Your bowling ball's here!" :-)
I asked what FireMonkey could do that Qt couldn't. You answered "Provide me a rad UI for designing UI visually". I showed that Qt did indeed provide this. Why would it need to plug into the Delphi IDE?
It looks like it produces beautiful, modern UIs to me: https://youtu.be/-eg2TsHTWyw and another nice example: http://static.giantbomb.com/uploads/original/1/15606/1103643-z2.jpg 
Because that's the development language in using. Double click a button, and it brings you to the OnClick event handler.
Multi Monitor support in the IDE. Snicker. 
Have you tried it?
Not since XE which is the version I have. The help is so poor and the price of each new release so high that I have sworn off supporting their products.
Oh gawd no. I stopped giving Emb money 5 years ago. Multi Monitor support, like almost everything in Delphi, is a decade late and a dead industry ago.
So you're hanging out in this subreddit just to disparage a tool that you don't use?
XE was a pretty good release, but your information is well out of date.
I agree, the new help is quite good. 
I have experience using multi monitors since early 2000 under Delphi. It never supported it. I'm glad it "supports" it now after fucking literally a decade and a half.
It's $900 with upgrade + SA, which is simply a non-starter in 2016. That's more than the price of a NEW copy of Visual Studio!
Why is it a non-starter? The upgrade is only charged once when you upgrade. Annual subscription costs are less expensive than upgrades if you update more frequently than every two years. However, it looks like they might be going to a full subscription model, so that should make you very happy.
50%, not 84.
You are not making much sense... .NET compares favorably to Delphi in that niche. There are other "niches" where Delphi may compare favorably with .NET, but developing LoB apps is not an area where Delphi is stealing a victory, to be frank... You're sort of validating the point he's making. You're saying .NET is bad because it's .NET. You aren't giving any rational reason to consider it any worse than Delphi. The problem is, a lot of the "historical" reason to hate on .NET, simply no longer exist.
There is practically no perceptible performance difference between a Delphi Application and a .NET Windows Forms application (like Kinovea) on my PC. Microsoft Office, Sound Forge, AMD's Graphics Driver [Configuration] Utility, .NET will not replace C++ for Game development or device drivers, but it can completely replace Delphi for the types of applications you're referring to, and then some.
It's the other way around. People are looking for a replacement for MFC, and they have UWP/Qt/wxWidgets. Back in the 90s C++ was the dominant development language on Windows, by far. Additionally, Borland lost a large chunk of its Marketshare to Microsoft, because they couldn't release a Windows IDE that wasn't buggy as hell. Delphi always fought an uphill battle, because it's Pascal. A lot of people simply didn't want to develop in Pascal by the time 1995 rolled around, but it did well considering that - largely because it's Two-Way Tools were amazing and the VCL was well designed. When Microsoft moved to .NET it really disrupted Delphi because it changed the playing field. Even then, Performance and the RunTime were legit concerns with .NET. Time has largely fixed the performance issue - especially in regards to the LoB applications /u/mobiledevguy5554 is talking about; as if that was ever an issue... Run-Time has been fixed since Vista, when Microsoft made it a system component. It does tickle me that Delphi developers are now reaching back to XP to get at the one version of Windows with measurable marketshare that wasn't distributed with the framework pre-installed. Even on XP, it's hard to run a Business Desktop without the .NET Framework installed. It's likely installed well before your app touches its hard drive ;-)
The problem is that there are many programming language indexes and while they broadly agree on which languages are the biggest (Java, C, C++, JavaScript, Python are towards the top of each), they don't agree when it comes to Object Pascal. I'd have more confidence in Object Pascal's progress if I saw similar results in other indexes. Object Pascal doesn't feature in the top languages on [Trendy Skills](http://trendyskills.com/), [Black Duck's language use](https://www.blackducksoftware.com/resources/data/this-years-language-use), [PYPL](https://pypl.github.io/PYPL.html), or [RedMonk](http://redmonk.com/sogrady/2015/07/01/language-rankings-6-15/). Is there any index other than TIOBE which ranks Object Pascal in the top 10 languages?
You're completely out of touch with reality... And, playing the semantics game? Cute! No, "commercial software" is not a non-starter for hobbyists. The Average Selling Price of Commercial Software is dropping outside of the Enterprise Market. Why do you think so many companies are going to a Subscription Model? Because the Indies and Hobbyists often don't see a point in paying $500 for a Photo Editor when a $100 Photo Editor does a good enough job... The ASP of Developer Tools is the lowest it has ever been. Delphi and C++Builder are outliers to the current market and they have maintained their pricing despite the current market climate. This would have been like Microsoft raising the price of Microsoft Windows, instead of giving away the Windows 10 upgrades... Every platform basically distributes 1st party (high quality) developer tools for free these days, as well, which makes it harder to consider spending this type of money on an IDE/Compiler. The issue is hobbyists aren't going to spend $1,000+ on an IDE for a hobby, when you can get a full-blown commercial IDE from a competitor for half the price, or use their Community Edition which is 99% the same features and completely appropriate for you - for free. The supposed benefits of Delphi aren't worth that amount of money out of their pockets. You can sing the praises of "not having to worry about a Framework install" or "Native Code! YAAAAASSSSSSS!!!" all day long. It doesn't matter to those people. The Framework is pre-installed and they save $1k. That's rent money, food, clothes, a new Xbox, college tuition, transportation, insurance premiums, a new PC/laptop, cell phone bills, etc. Delphi's purported superiority over .NET isn't exactly a big deal when you tell them it's going to cost $11-2200 different (not in Delphi's favor). The hobbyists include students are are interested in development and want to learn. They include independent people who have other jobs and want to become proficient so they can develop their own custom solutions for their own use (they may never sell a piece of software, or develop a piece of software for anyone else... ever). They include people who want to contribute to Open Source Projects, or maybe do a little coding on the side for small businesses (and relatively small pay) while they're in college, or whatever. I developed my own app to track my training (periodization, etc.). There's no way in hell I'd have paid [at least, judging by the capabilities I used] $1620 + Tax for the privilege... The issue isn't that Delphi is a commercial product, it's that the price has risen out of the mainstream. The Enterprise Pricing is a huge issue for people who aren't in the position where they can truly justify that kind of expense on a developer tool, and if they go with an alternative tool, by the time they get to the point where they can justify it, they are usually content to keep using what they have always used (and have learned up until that point). This has a secondary effect of sort of hurting FreePascal/Lazarus as well. Many people don't care about them because the tooling is quite inferior to the commercial IDEs I mentioned (and other Free/OSS tooling like NetBeans and Eclipse) and due to Borland taking "ownership" of Pascal; any actions they took that decreased Delphi's mindshare indirectly affected other Pascal toolchains (free or otherwise). Delphi used to be a $399 Professional Edition. It's now a $1080 Professional Edition with 2x $540 Add-Ons. That is out of line even with Commercial IDEs on the market these days, for Windows and Mac Development (Visual Studio, Xcode, JetBrains, Eclipse/NetBeans, etc.). One can always argue that Delphi's supposed benefits are worth the huge price differential, and no matter how objective the opposite side is, it's simply impossible to argue a matter that's largely subjective... But you can't argue with money, especially in the corner of the market we're referring to specifically.
Rad Studio Enterprise SA is under $1000 per year. Well worth the cost for me. I can't speak for hobbyists, but if any dollar amount is too high, then that just leaves free tools. However, these are only free if my time is worth nothing, so the investment I make in development tools more than pays for itself.
&gt; I don't know who Joseph is He's the "non-starter" dude. He was the one I asked for clarification. As for the future of Object Pascal in general and Delphi in particular, people have been declaring it dead since it was first released. They've been pretty consistently wrong for over twenty years. And just because I like Delphi doesn't mean that I have a problem with other languages (except maybe VB) or even other Pascal tools. Have at it. It's not like I would hang out in those groups for the sole purpose of trashing the tools or their users at every opportunity. That's kind of a loser move. And no, I'm not talking about you.
I can do both. Trolling has become part of this discussion. Because of the (long winded) trolls. and I feel no need to apologise to them. And Delphi is a great tool that I have had a lot of success with and continues to be in active development. Open source is also great. I'm a big fan and use it where it makes sense to me. 
People ranting on comment boards are so thin skinned? Who knew?
Embarcadero said that they were going to back port at least some bug fixes to previous releases. They published some of these today. Scroll down to the bottom for a summary of the fixes that are included.
&gt; Is there any index other than TIOBE which ranks Object Pascal in the top 10 languages? http://code2015.herokuapp.com/ :) 
Appreciated - I'm hoping Seattle will also continue to get a little back-ported bug-fix love, once Berlin/Big Ben hits the streets. 
Fun with d2006
No. It was the price. Look at the context of the post I initially replied to. I'm aware of the thread title and OP, though. The roadmap should increase a piece drop. Better? 😅 The parent of this discussion is &gt; They forgot to mention, "Raise prices to ensure no new uptake among indie or hobbyist developers."
No one here was trolling. However, you've stooped to that level. Better to just not participate if you are that sensitive. 
Didn't you accuse people of lying? Stoop, indeed.
I'll take that as a "no".
Clearly you haven't read my messages very thoroughly. Or the rest of this thread, for that matter.
Second place not high enough?
You linked to a poll with low voting figures, not an index.
And there you go again. You seem unable to understand the problem. Too bad.
But nothing. Show me an index, not a poll.
Cause you were? You can try to flip it around all you want, those are the facts.
As I said, it's a "no".
Tiobe is probably the longest running one with the most consistent criteria. Whether it measures what people think it does is another story completely.
I believe you need to follow some of your own condescending advice before lecturing others.
Don't worry. You believe wrong, that's all.
Back atcha
Why don't you put your project output folder to equal bin so that binaries go in a subfolder and use the workspace environment variable that JENKINS sets up. So you write "copy %WORKSPACE%\bin\*.exe ..." instead of that giant mess you wrote?
[removed]
Reading the comments, too many redditors seem to prefer hypeness to "the best tool for the job". If I had the choice between "everyone uses it but it lacks certain advantages" and "I can work super-efficiently with it", my choice was clear. 
That's how discussions ultimately go with /u/bmcgee, unfortunately. If you point out problems with Delphi, you're the enemy, a "troll", and you must be vanquished. 
Look at Embarcadero's shopping site for details. Special offers may apply, but they are still usually about the same ratio between upgrade and SA prices.
Oh Joseph, there you go again...
I'll be looking at Linux servers not too long from now. Who knows, I might get hooked.
"Trolling has become part of this discussion. Because of the (long winded) trolls. and I feel no need to apologise to them." You're constantly talking about, and labeling people who don't share your views, trolls and declaring it your duty to stop them. You also posted on Jolyon Smith's blog that you "like to troll" "anti-Delphi" sites, ironically. That's how every discussion I've seen with you ends up, whether it's /u/clouddrover, me, Jolyon, etc. We all get called trolls. You didn't actually address the issues of barrier to entry that /u/clouddrover or /u/ianonguy raised, repeatedly bringing up the upgrade cost instead. Take a look at this page of Mason Wheeler's blog and scroll down to the end, where you'll see a post you made: http://tech.turbu-rpg.com/164/why-the-new-roadmap-wont-impress-anyone/comment-page-1#comments Again, rather than addressing the factual issue raised about the Delphi jobs market, you replied: "You seem to be having a bad day. Personally, I have a hard time taking rants and vitriol seriously. More so when posted anonymously." Always, always, always, when someone brings up a factual issue that would go against your belief system, you end up steering the discussion off the road into the personal. You start seeing trolls, rants and vitriol all over, which apparently negates anything anyone wrote, so you can then ignore it. :-( I remember another time you were knocking Jolyon for being a troll, and when David Heffernan showed up and agreed with him, you replied "David’s opinion has less of an agenda so is more useful and relevant." which again suggests that if you label people an "enemy" you can mentally disregard anything they say. Jolyon summed it up this way more than a year ago: "For whatever reason you project an agenda onto that opinion with apparently only one objective (an agenda, if you will ;)): to contrive a reason to dismiss the opinion. Not on the basis of any disagreement or counter argument on the points in the opinion, but simply because of who holds it. I find that both amusing and depressing." So it's not just me - many, many people end up feeling that way when we try to discuss issues with you. 
Actually, the 20-year-old web pages were taken into account when investigating the issue. The raw search engine results today reflect a far higher amount of results being related to Object Pascal than to Pascal. I also disagree that this screws FPC and Oxygene. The Object Pascal language has suffered in popularity, in my opinion unjustly. Promoting the language should benefit all of it's compilers, commercial or otherwise. 
After pressing break, it goes to the RG_Owner.ItemIndex:= Config.ReadInteger (Or whatever the first Ini read command is).
Whats might be happening is that the ini file does exist so its jumping straight to RG_Owner.ItemIndex:= Config.ReadInteger('Properties', 'Owner', 0); If it does that then Config.ReadInteger will throw an exception since you wont have created the ini file with Config:= TINIFile.Create
&gt;Case in point. &gt;Anyone who consistently hangs out in Delphi groups with the sole purpose of &gt;disparaging the product or its users is a troll. You are not capable of ascertaining my personal motivations; you're projecting them, just as Jolyon observed. I don't have a "sole purpose of disparaging the product". I have a purpose of IMPROVING the product. You also don't get to dictate what others contribute to a discussion. No one tells Nick he can't go on the forum for the sole purpose of glorifying the product, do they? I'll also bring up that I've repeatedly defended the creation of FireMonkey (if not the execution) and the wisdom of moving into the mobile market. I was also a vociferous defender of Marco's white paper floating the idea of immutable strings, memory management and other modern amenities on the desktop. In fact, in the EMBT forum, you'll find the unlikely alignment of myself teaming up with Nick Hodges to argue against Luigi Seldon. Nick even wrote one message praising my deconstruction of Luigi's arguments against Marco's proposals! Weather reports suggested a blizzard in Hell that day. :-) So when I read an argument that states that languages like Java made strings immutable for "no reason" and then announce that it took me two minutes to actually ask why the creators did it and find a white paper that lays out several benefits, Nick praises my "masterful takedown" and my defense of facts and reason over bombastic charges. If I similarly post facts to show that that they're aren't three million active Delphi users, I'm a troll whose sole purpose is "disparaging the product". I think it's clear people are just projecting their own biases onto me; I'm just after the truth, whether that means defending Marco or Luigi or factually disputing their claims. &gt; You just declared it dead. Again. And you feel this is some sort of personal attack and react emotionally, rather than either a) accepting it, or b) demonstrating that it's a factually wrong conclusion. &gt;Why would anyone listen to your opinions on the product? Because they're intelligent and well-informed. When I laid out my vision of what I'd do if I were Idera (and you can't fix/change things without pointing out what doesn't work/is broken now) no less than David Heffernan defended my post, saying it was the most interesting content on the Delphi Google Plus forum he'd read in some time and also defending the need for valid criticism to avoid an echo chamber. Arnaud's also defended the value of my critiques. If two of the most esteemed contributors to the Delphi community find my contributions valuable, I'm quite flattered and most be doing something right. It's also of interest that neither have chosen to become MVPs (along with the contractual restrictions on free speech that entails). The question to you is why would anyone want to create an echo chamber where we just tell ourselves how wonderful we are and how great everything is? How does that serve the product's interests? And I'll observe one last time that you didn't actually address any of the issues raised in the post you replied to, must less rebut them, which actually demonstrates my point. When you're confronted with a fact that you can't refute, you label the person who raised it a "troll" and declare that you can simply ignore anything they've said. And that's why people find it impossible to have an honest discussion with you. 
Who knows what motivates you to hang out in Delphi groups trashing the product, the company and its users for years at a time. Long, drawn out, gish-gollop style misinformation. Anyone constantly claiming that Delphi is dead isn't being insightful. They're trolling.
Trolls gonna troll...
What would be the benefit of using a closed source, commercial program like Icon Workshop rather than just using GIMP?
Super easy to use. Designed just for making icons. I like it a lot, so I recommend it. Maybe GIMP is better, I have not used GIMP in years.
Is GIMP better for creating icons than Icon Workshop?
So you're saying that 5 new VCL controls that could easily be pulled off in something as outdated as Delphi 7 with any number of third party solutions constitutes "Windows 10 Support"? Let's not forget the part where the IDE REQUIRES MSBuild 2013 to be installed in order to function properly (i.e. not the version of MSBuild that comes by default with any installation of Windows 10! Because it's three years old, you know.)
If you're interested in the details, you should sign up for the webinar and/or the white paper.
While out-of-the-box Lazarus might not be a truly "better" alternative to Delphi in the context of being a full-featured Object Pascal IDE with a RAD GUI Designer.... CodeTyphon IS. To an absurd extent. Hundreds and hundreds and hundreds and HUNDREDS of FREE, high-quality components out of the box (it takes like six 1920x1080 monitors worth of space to scroll across the entire palette horizontally), idiot-proof, TRUE multi-platform compilation to an insane number of platforms, and most importantly, an IDE that isn't a buggy, slow .NET 2.0 relic... and one that you can even optimize for your own architecture/processor, since the installer builds it from source! Imagine... auto-indent that actually always auto-indents, all the time, with no delay! A "find declaration" button that actually jumps immediately to the declaration, instead of giving you approximately ten million "COULD NOT RESOLVE UNIT NAME" errors... the list of advantages goes on and on.
I'm now convinced that you don't actually read posts before you respond to them. It's as though you just have a text file saved with various canned responses, that you copy and paste as necessary, even when they barely make sense. Does it really sound like I need a "webinar" (what an embarrassing word) or to read the whitepaper? I've been coding in Object Pascal with every conceivable iteration of Delphi for well over a decade. I know "what's what." 
My posts contained zero misinformation.
Everyone on Google +, including Arnaud Bouchez, is talking about performance problems with strings (Arnaud), stability issues with Lazarus (Kevin Powick), or bad Unicode support (Eric Grange). :-(
Right click on the name and select 'find declaration'.
&gt; I like pointers and managing my own memory Oh god, I don't. I wish everything in Delphi was reference counted. 
This will come in a future release of OmniPascal. Hopefully in the first half of 2016.
He made the right move. Too talented a programmer to go down with the rapidly sinking ship that is everything to do with Delphi's existence as a commercially-developed language/IDE. It's not really Idera's fault at all, either. Embarcadero was just as bad all on its own for years and years before anyone ever heard of Idera. *This is the sort of thing that happens when a company refuses to accept the reality of its true relevance in the tech landscape. No one should be remotely surprised if Embarcadero goes out of business in the near future. They brought it on themselves.*
Use [IncYear](http://docwiki.embarcadero.com/Libraries/en/System.DateUtils.IncYear) instead.
It's interesting to note that there's no date of this news anywhere on that site...
I feel like they are fighting on too many fronts. Too many half baked features to stay competitive, with an IDE thats too far behind for C++ to be really used professional. Getting clang and some svn integration was good, but the 10 version became quite slow for me. Dont know how this is for Delphi, as we really only use C++, and my coworkers are too dependent on the VCL to be really able to switch the IDE. But hey, we still use C++ Builder 5 for most of our main products. Partially even CB2007. Maybe its just the pain of missed chances to jump the whole train years ago.
In the IDE maybe. But thats of course no excuse not to do it anyways. I'm using vim as main editor anyways.
I've been on D2007 since it was released. I recently decided to take a look at a trial version of Seattle -- I figured it's been almost 10 years and it HAD to be better. Wrong. Immediately uninstalled and went back to 2007.
That is odd. The 2016 roadmap was released on Feb 8th.
I would submit that you should be scaling forms not based on the DPI setting, but on the pixel font size. - Segoe UI 9pt @ 96dpi ==&gt; 15px - Segoe UI 9pt @ 131dpi ==&gt; 21px - Segoe UI 13pt @ 96dpi ==&gt; 21px The virtue is that your forms will react both: - if the user changes their DPI setting - if the user changes their font setting In reality what you are trying to do is scale based on font size. The DPI setting is one way to alter the user's pixel font size. Rather than changing scale by the dpi values ChangeScale(newDpi, oldDpi) you change it based on font sizes: //TFont.Height is -pixels ChangeScale(newFont.Height, currentFont.Height); 
How exactly do you set the color of inidividual cells? With the OnDrawCell event? Anyway, a TStringGrid doesn't have a per-cell storage for color. But you can create that yourself, e.g. with a two-dimensional array.
That's.... interesting. Might not have been *my* first choice, but hey.
Those poor bastards.
Oh God. They tried this two (?) years ago. A professor began an online campaign about how horrible the idea was. Faculty from all over the country signed on to his petition. Someone in the South African education ministry put out a white paper about why they should standardize on Delphi and it was INSANE. It literally read like it copy/pasted several talking points straight from the EMBT forum! It said that Delphi was particularly popular in America and Western Europe! Of course, that's where it's the least popular today. It dismissed Java (the other language taught in SA schools) because "it's open source and support might not be available for it. JAVA. JAVA. As if Java was suddenly going to fall from grace and cease to be developed. Java, the language BACKED BY ORACLE. It was absolutely horrible. I don't know which idea was worse - that EMBT did nothing to help SA defend the decision, or the thought that they might have actually helped write this paper. In the end, South Africa backed down, prompting me to write "South Africa rose up to cast off two things into the sea: aparteid... and Delphi." Now here we are again. I'm convinced someone in SA is being bribed to continue to push this idea when the teachers are dead-set against it. Don't be surprised if in the next week or so you find out teachers were blindsided by this decision - I'm betting they kept the deliberation secret given the outrage the first time. They'll probably protest en masse again and South Africa will change its mind yet again. There wasn't even a textbook in existence for Delphi; SA had to pay to get someone to write one. From what a few students have posted here, it's an awful book but I haven't actually seen a copy... they could just have been bad students. :-) Stay tuned; once the you-know-what hits the fan things should get interesting. I'll see if I can dig up the original white paper and the articles of the guy who led the first protest against Delphi.
&gt;Compared with the original code, the new version using TModuleIndex &gt;conveys much more information about the parameters and result type. I completely disagree. It conveys less information. In the original format, I know it uses an integer. In the second version, I have to know what a TModuleIndex is.
The webinar was on Feb 24th. The blog post includes links to the replay and presentation slides. Enjoy.
You could speed it up a little by only checking all handle values x*4 since the lowest two bits of a window handle will always be 0: https://blogs.msdn.microsoft.com/oldnewthing/20050121-00/?p=36633/
&gt; Not all window handles were being passed to my callback. I noticed it with the volume icon in the system tray (win10 64bit) Have you considered that the reason could be that it's a child window? MSDN clearly states that "The EnumWindows function does not enumerate child windows, with the exception of a few top-level windows owned by the system that have the WS_CHILD style."
yes that was the problem - Really old code+idiocy - I did notice that my library had functions for enumming child windows as well but did not realise the implications.
thanks, are there any specific sources/links you would recommend?
The 2016 road map was released recently: - http://community.embarcadero.com/article/news/16211-embarcadero-rad-studio-2016-product-approach-and-roadmap I listed some ways to get information about Delphi and share your opinions and concerns with Embarcadero a while ago. I think the skill sprints and CodeRage sessions are especially useful: - https://forums.embarcadero.com/thread.jspa?messageID=673404&amp;tstart=0#673404 David I blogged recently about different places to get support and information: - http://community.embarcadero.com/blogs/entry/how-to-get-help-and-support-when-you-need-it-there-are-several-ways You can also groups on StackExchange, LinkedIn, Google+, FaceBook and even Reddit that offer support and interesting discussions.
Open Delphi inside Delphi and debug this error with the Delphi debugger. Don't know how? Google it.
Yeah. I've got 5 indie products that are written in Delphi, but the cost to rewrite is too high to warrant the benefit. After 15 years of Delphi, I moved on last year and got a job doing backend Web dev. But that wasn't until I tried to get a job using Delphi. There are only 2 in WA State, a freight moving company and Wide Orbit (an TV/Radio advertising company).... and a pizza company across the border in Canada. It's sad. It seems only older industries that invested heavily in VCL are still using it, because they have to.
`unit VCLThreadTimers;` `interface uses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms,vcl.stdctrls, Vcl.Dialogs,vcl.grids, vcl.extctrls,system.Diagnostics,System.Generics.Collections;` `Type` ` TThreadTimerEvent=Procedure(Sender:TObject) of Object;` ` ` TThreadTimer = Class Private Invalid:Boolean; FCountDown:Integer; FInterval:Integer; FCallback:TThreadTimerEvent; FEnabled:Boolean; FOwnerWindow:HWND; FTimerThreadObject:THandle; Procedure SetEnabled(e:boolean); Procedure SetInterval(i:integer); Procedure SetCallback(c:TThreadTimerEvent); Procedure Suicide; //Delete My Reference from the owner thread Public Property Enabled:Boolean Read FEnabled Write SetEnabled; Property Interval:Integer Read FInterval Write SetInterval; Property CallBack:TThreadTimerEvent Read FCallBack Write SetCallback; Procedure DecCountDown; Constructor Create(OwnerThread:THandle;OwnerWindow:HWND;EventProcedure:TThreadTimerEvent;ForInterval:Integer;SuspendAtCreate:Boolean);Virtual; end; TThreadTimers=Class(TThread) Private DelQueue:TThreadedQueue&lt;TObject&gt;; public Owner:HWND; Timers:TList; protected procedure Execute;override; Public Function AddTimer(OwnerThread:THandle;OwnerWindow:HWND;EventProcedure:TThreadTimerEvent;ForInterval:Integer;SuspendAtCreate:Boolean):TThreadTimer; Procedure DeleteTimer(Timer:TThreadTimer); Constructor Create(OwnerWindow:HWND); end; `implementation` `{ TThreadTimer }` `var` ` TimerCriticalSection: TRtlCriticalSection;` `constructor TThreadTimer.Create(OwnerThread: ` `THandle;OwnerWindow:HWND;EventProcedure: TThreadTimerEvent; ForInterval: Integer; SuspendAtCreate: Boolean);` `begin` ` self.FOwnerWindow:=OwnerWindow;` ` Self.FEnabled:=not SuspendAtCreate;` ` Self.Interval:=ForInterval;` ` Self.FCallback:=EventProcedure;` ` Self.FTimerThreadObject:=OwnerThread;` ` Self.FCountDown:=Interval;` `end;` procedure TThreadTimer.DecCountDown; var ptr:POinter; method:TMethod; pm:PMethod; begin if not Enabled then exit; if invalid then exit; self.FCountDown:=FCountDown -1; if FCountDown&gt;0 then Exit; if Assigned(self.FCallback) then begin Try if winapi.Windows.IsWindow(FOwnerWindow) then begin begin Method:=TMethod(FCallBack); PostMessage(Self.FOwnerWindow,WM_Timer,NativeUint(Method.Code),NativeInt(Method.Data)); end; end else Invalid:=True; except on exception do begin Invalid:=True end; end; end; FCountDown:=Interval; end; procedure TThreadTimer.SetCallback(c: TThreadTimerEvent); begin FCallBack:=C; end; procedure TThreadTimer.SetEnabled(e: boolean); begin FEnabled:=e; end; procedure TThreadTimer.SetInterval(i: integer); begin if i&gt;0 then FInterval:=i; if FInterval=0 then begin FInterval:=1; FEnabled:=False; end; end; procedure TThreadTimer.Suicide; begin // EnterCriticalSection(TimerCriticalSection); Invalid:=True; // LeaveCriticalSection(TimerCriticalSection); end; { TThreadTimers } function TThreadTimers.AddTimer(OwnerThread: THandle; OwnerWindow: HWND; EventProcedure: TThreadTimerEvent; ForInterval: Integer;SuspendAtCreate: Boolean): TThreadTimer; Var ttimer:TThreadTimer; begin if timers=nil then exit; ttimer:=TThreadTimer.Create(OwnerThread,OwnerWindow,EventProcedure,ForInterval,SuspendAtCreate); Self.Timers.Add(Ttimer); end; constructor TThreadTimers.Create(OwnerWindow: HWND); begin inherited Create(true); FreeOnTerminate:=True; Timers:=TList.Create; self.DelQueue:=TThreadedQueue&lt;TObject&gt;.Create(1024); Suspended:=false; end; procedure TThreadTimers.DeleteTimer(Timer: TThreadTimer); begin Delqueue.PushItem(Timer); end; procedure TThreadTimers.Execute; var msg:TMsg; i:integer; Data:TThreadTimer; StopWatch:TStopWatch; ms_Count:Integer; ms_Current:integer; begin StopWatch.Create; StopWatch.Start; ms_Count:=0; //self.Priority:=TThreadPriority.tpIdle; while not Terminated do begin ms_Current:=StopWatch.ElapsedMilliseconds; if ms_current&gt;=(Ms_Count+1) then begin ms_Count:=ms_Current; //EnterCriticalSection(TimerCriticalSection); data:=TThreadTimer(Delqueue.PopItem); while data&lt;&gt;nil do begin if Timers.IndexOf(data)&gt;=0 then begin data.Invalid:=True; end; data:=TThreadTimer(Delqueue.PopItem); end; // LeaveCriticalSection(TimerCriticalSection); if self.Timers.Count&gt;0 then for i:=0 to Timers.Count -1 do begin Data:=Timers[i]; if not Data.Invalid then data.DecCountDown; if Data.Invalid then begin Data.Free; Timers[i]:=NIL; end; end; Timers.Pack; end else Sleep(1); end; StopWatch.Stop; while timers.Count&gt;0 do begin TThreadTimer(Timers[0]).Free; Timers.Delete(0); end; self.DelQueue.Free; end; Initialization InitializeCriticalSection(TimerCriticalSection); finalization DeleteCriticalSection(TimerCriticalSection); end.`
I got it working as intended using tthreadList instead. I hate threads they really are a magical black box of pain :)
Alright. Length and summing up strings totally works. Thanks for the tips! Do you have any idea what a function would look like were I sent all the strings to that it splits them up automatically in different lines (without cutting any strings in half)?
What are the products?
`f` is a text file variable. `s` is the string buffer. You add all the strings to it until the next string to be added would increase the length beyond the limit. In line 3 the code checks with the help of a temporary variable if the limit would be broken. If that is the case (line 5) then the string is ***not*** added, instead the current buffer content is written to the file and the new string replaces the old buffer content. If the limit were not broken (line 8), the new string is added to the buffer. Since this was already done with `tmp`, it can be simply assigned to `s`.
That's not a direct link to a PDF, it requires me to register on a site I'll wont ever visit again...
That is the link provided by the author.
[removed]
Fuck that.. Just give the money !
Just as embarrassing as everything else involving the delphi "community"
Is it looking for fbclient.dll or gds32.dll? I'm not sure what components or connection method you are using but some of our stuff will look for one or the other.
Put FBClient in the same folder as your compiled .exe (assuming Windows) when you deploy your app. To make it work while developing place the file in Windows/SysWOW64 .
Hans Bohem [wrote a garbage collector for C/C++ around 1995](http://hboehm.info/gc/). It works as simply as being your replacement for - malloc - realloc - free It works by poking through everything allocation you make, and chase down things that looks like pointers to other objects. Pretty ingenious actually. &gt; The Boehm-Demers-Weiser conservative garbage collector can be used as a garbage collecting replacement for C malloc or C++ new. It allows you to allocate memory basically as you normally would, without explicitly deallocating memory that is no longer useful. The collector automatically recycles memory when it determines that it can no longer be otherwise accessed. A simple example of such a use is given [here](http://hboehm.info/gc/simple_example.html). [Barry Kelly wrote a Delphi wrapper around it](http://codecentral.embarcadero.com/Item/21646), which is basically just uses Delphi's global `SetMemoryManager` function, giving it the three required: `alloc`, `realloc`, and `free`: var newMM: TMemoryManager; begin newMM.GetMem := Boehm_GetMem; newMM.FreeMem := Boehm_FreeMem; newMM.ReallocMem := Boehm_ReallocMem; SetMemoryManager(newMM); I tried it once; the program managed to last quite a few seconds before crashing. - [GitHub: bdwgc](https://github.com/ivmai/bdwgc/) - Wikipedia: [Boehm garbage collector](https://en.wikipedia.org/wiki/Boehm_garbage_collector) - [Official web-site](http://www.hboehm.info/gc/) I suggest you start with that. 
Yes SQL Server does have a bulk insert command and it's certainly usable. (A sequence of insert statements would work, too.) Yet, the API seems to exist for a reason. .NET also exposes it in SqlBulkCopy class. Creating a suitable file, copying it to a path accessible from the server, and running the command might not always be the fastest option. Sometimes you might need the flexibility of bulk-inserting in-memory buffers, and doing so remotely from a client application.
The entire lazy way that beginner Delphi users get used to working (just put code in button) is indeed the opposite of clean code, it's a big ball of mud. But you can write clean code in any language. Starting to care is a good start. You can see what people do in java and C# and adapt to Delphi easily. is it hard to see when someone declares a class, declares a method, even if you don't know much about other languages? Not really hard. In fact, NOTHING in the book Clean Code is that hard to adapt to any language. Delphi has Interface types, but remember that "Interface" in the sense of the book (and in the general design community) is a more general term it doesn't mean you have to use a reference counted interface. Abstract base classes can serve the same role, and are more appropriate in Delphi in some cases. Get familiar with IoC containers, dependency injection, and the appropriate use of interfaces.
If it doesn't appear to be available then I'd contact their sales team. https://www.embarcadero.com/company/contact-sales
i cant get any sound on this vid? Bit hard to follow without a commentary.
thank you :)
I'm going to try this out. :)
[removed]
Stringlist would be much better suited most of the time if you simply want to write text into file. Memorystream would be handy as a buffer to keep nontext stream data, e.g loading email attachment, http response where u can save it to file latter on
Why use the extra memory keeping the data around in a TStringList *or* a TMemoryStream? Just write it out to disk right away with a TFileStream.
- TStringList: textual data - TMemoryStream: binary data - TFileStream: binary data; almost no RAM usage; ability to stop other programs from opening/changing the file while you're using it
Insert a space before adding the dot.
In my opinion, popup error messages should be avoided whenever possible, and instead modify the form to indicate which part of it has caused the error.
yes, it used to be optional though? Is there a continuing 1 year update price? it doesn't seem to be mentioned though? All I can see is an upgrade price.
Yes, it used to be optional. I don't know if the next year's pricing has changed, but that wasn't available through the online store anyway. I just get a renewal notice. You'll need to check with Embarcadero sales for that.
Thanks, they're making it harder and harder to buy or recommend it seems...especially given the entry price of competitors. It's an effective 50% increase in the upgrade price for me
Not only is Visual Studio free for up to 5 copies for small businesses and $500 otherwise, Xamarin (which Microsoft bought) is being open sourced and will be bundled with VS now. Jetbrains is offering subscriptions to a bundle of all of their IDEs. Business is $649 first year and gets as low as $389 for 3rd year onwards; per month cost is only $64.90. For individuals it's only $249 or $24.90 a month. With the subscription, if you pay for a full year you get to keep permanent copies of the products. There are also 50% discounts for start-ups. Digia is offering a startup/small business price that of (introductory offer) of $588 and $948 regularly. There's even a $99/month subscription model. This covers Windows, OS X, Linux, Android, iOS, Blackberry (and probably others). This is in addition to their LGPL licensed offering. Idera/Embarcadero is going to **have to** match these prices and offer similar pricing models for startups/small businesses. Delphi is already the underdog; you can't expect people to pay $2000+ upfront costs per copy when the most popular tools are costing less than half that and have attractive low per-month costs for small businesses and start-ups and free or close to it pricing for individuals. 
We've got some legacy software that during data entry will show pop-ups for warnings or questions as you move from field to field. It's worse because it's designed for the user to press Enter to move from one field to the next, which of course also dismisses the popups, or chooses the default option if it's a question. Terrible, terrible design.
I don't know what the US costs were for 10 Seattle, so I can't compare and I'm not sure if the AUD pricing is consistent. I'm glad I have a subscription, though. :)
&gt; I'm glad I have a subscription, though. :) there's no nya nya :-) (there is a %10 tax here - like the european VAT, and US companies do seem to enjoy gouging australians) 
If free tools do what you need, then they are great. Enjoy.
Digia had the same problem with their entry-level mobile development pricing and canceled it. They were more open about it though - they revealed only a few dozen people (!!!) took it. It seemed that the serious developers preferred the full-featured, full-priced version, and everyone else preferred free/open source solutions, but there was little demand for something in-between. That might have been the case with AppMethod too - commercial developers might prefer full Delphi Pro or Enterprise, and for everyone else even a small subscription fee is too much given the many useful free and open source tools out there to make an app. 
AppMethod was also stripped down though. An option to pay on a monthly basis for the full product would reduce the sticker shock. Digia canceled their AppMethod-like mobile development subscription offering, but they replaced it with a subscription model for their full product for businesses earning &lt;= $100K a year. JetBrains is also offering the option of monthly subscription pricing now. 
What you want is a stack trace, something Delphi doesn't offer built-in :-( but I believe third party components can provide.
Aside from no VCL, how was Appmethod stripped down?
I already use Rad Studio, so AppMethod wasn't interesting to me.
well I hope your right. The early change is encouraging. 
The problem is that sometimes you need to fix bugs in existing classes. And the original class designers thought it would be a good idea to keep things private rather than protected. So then we end up having to copy-paste the rtl into our own files for a tiny fix. I was looking at the Seattle VCL source code, and I see there's a few bugs that we'd have to re-re fix. If only the class designers made things protected rather than private.
Lazarus support is the best part!
Not that I know of. The closest thing might be to sort the results by scope (right click on code completion list), which shows identifiers for a descendant before the ancestor. docwiki.embarcadero.com/RADStudio/en/Code_Completion
As an addendum to this: It turns out that using delphi's 'Namespaces' and naming units logically to a structure with .(dot) separators is actually working out very well. The formal unit naming structure this method enforces is also providing unforseen benefits to code navigation. Examples : Game.Scene.Dialog.Base Game.Scene.Dialog.Base.Intro_0 ( .0 would have been nice here) Game.State Game.State.Player 
classic all the time. I think i'm even technically correct that the navy/yellow colour scheme is particularly gentle on the eyes compared to black/white ones.
&gt;It's not wrong :-) It's so wrong, it's practically immoral. :-) &gt;Perhaps an example... &gt;You've written a class which validates email addresses, lets say it's RFC &gt;2822/822 compliant. You then sell that class Selling code in 2016? This example is already hard to believe, but I shall soldier on.... &gt;, but the customer uses the '@' &gt;character as a placeholder in their database fields, so they want your &gt;validator to accept multiple '@' symbols. &gt;Well, if they've paid money for your product, you may modify it for them, or if &gt;they've bought source code they may modify it for themselves. &gt; &gt;Having done so, they may now encounter situations in which an '@' &gt;character makes it through your validator which never should have, &gt;introducing a bug. &gt;So you as the author of the original class, who has read the spec and written &gt;the class, know best how that class should work and be used. You know how you would use it for what you're offering it for. You don't know what someone wants to do with it in the future. You don't know what you don't know. You don't know that e-mail formats are never going to change, or that some new protocol appears to try to replace e-mail and someone wants to adapt your code to work with it. &gt;This is not a responsible attitude towards software design. It's not "responsible" to let people do with code whatever they want? This is the same attitude that results in phones having locked bootloaders. If I paid for the phone, it's my right to whatever I want to do with it, including taking the risk of breaking it. This goes against the whole concept of open source, which essentially dominates software today, the Unix design philosophy, etc. Some languages, such as Python, have no ability to make a method or attribute private at all! It's all convention; methods or attributes that began with an underscore are considered private and documented as such. If someone wants to call those methods themselves, they do so at their own risk. No one's freedom or innovation is curtailed. If you write a dBase reader as part of a class that parses ArcGIS' data format (which uses dBase as a container), you're going to make that method private. But if someone wants to use it to read a regular dBase file, why shouldn't they be able to call it? Sure it might blow up because it wasn't designed/tested on anything other than ArcGIS files, but the user knows this private method isn't supported. They take the risk. (This is a real-life example for me). It isn't "responsible" to place a roadblock in the way of users doing what they wish with the software (or hardware) you sold them. In the end, reflection will triumph; you've just resulted in annoying people and making your code brittle and inflexible. 
Why do you have words repeated? You might really need to watch Jack Diederich's (non-Delphi) talk, "Stop Writing Classes". :-) https://youtu.be/o9pEzgHorH0
I have a new mini-app for Minimizing windows (show desktop) only on the active monitor. The lack of ahotkey for this has been bugging me for a while, especially for programming where I like to have a web site open on monitor 2 whilst working on monitor 1. This lets me show Monitor 1's desktop whilst keeping the monitor 2 web page open. Downloading Gitdesktop (git link soon) but here is the sourceforge link if anyone is interested. The code should compile and run as it does not use any custom libraries. (binaries in the \binaries directory) https://sourceforge.net/projects/xlogprotection/files/MinimizeActiveMonitorWindows/ https://github.com/HelenFairgrieve/MinimizeActiveDesktop
Yeah, I'm in a similar situation, but still on XE6 (not that it's a bad version). "StrStartsWith" was just a little helper function I introduced for better readability. It is marked with the "inline" directive, meaning the compiler doesn't generate function calls, but copies the generated function code into each call site. Perfect for short functions like this one. But since you have XE8, you can ignore that and just use "cs.StartsWith", as shown in the commented-out part at the bottom. There've been some more cool features introduced since Delphi 7. Operator overloading, generics, anonymous methods, TParallel.For... have fun exploring. :)
A bit more competition more should help!
&gt; Further complicating matters is that CreateRemoteThread appears to have been depreciated and modern injection techniques use hooks (that appear to have only made the problem more complicated) Any source on that? I've been using DLL injection via CreateRemoteThread for years, and it's always been working great. The "bitness" must match, of course, i.e. you need a 32 bit program to inject a 32 bit DLL into a 32 bit target. My DLL template looks something like this: library mydll; uses System.SysUtils, Winapi.Windows; // for best interoperability, always use the stdcall calling convention for exported procs! procedure MyExportedProc1(Arg1, Arg2: Integer); stdcall; begin // ... end; var PreviousDLLProcEx: TDLLProcEx; procedure MyDllMainEx(Reason: Integer; Reserved: Pointer); begin case Reason of // dll was loaded, call your initialization stuff from here DLL_PROCESS_ATTACH: {...}; // dll was unloaded, call your clean-up stuff from here DLL_PROCESS_DETACH: {...}; end; // pass the event to the previous handler, if one exists if Assigned(PreviousDLLProcEx) then PreviousDLLProcEx(Reason, Reserved); end; { ... code ...} exports MyExportedProc1, etc; begin DisableThreadLibraryCalls(HInstance); PreviousDLLProcEx := DllProcEx; DllProcEx := @MyDllMainEx; DllProcEx(DLL_PROCESS_ATTACH, nil); end. Explanation: On certain events like the loading and unloading of a DLL, Windows calls the DLL's "entry point", dubbed [DllMain](https://msdn.microsoft.com/en-us/library/windows/desktop/ms682583%28v=vs.85%29.aspx). Delphi's runtime library (RTL) "hijacks" this, so you don't have to - but also cannot even if you want to - write your own, real DLL entry point. However, if you're interested in the DllMain notifications, you can use the global procedure variables DllProc or DllProcEx. The RTL's DllMain will call these when they are assigned, to forward the notifications. The above code shows how you can use this to set up your own "fake" DllMain. If your program uses multiple units and you want some or all of these units to handle the DLL events as well, you can simply duplicate the relevant code (a variable PreviousDLLProcEx, a procedure "MyDllMainEx", and in the unit's initialization block: PreviousDLLProcEx := DllProcEx; DllProcEx := @MyDllMainEx;) and each unit will pass on the event from one handler to the next. The "Reserved" parameter of DllMain/DLLProcEx would normally tell you on a DLL_PROCESS_ATTACH event whether the DLL was loaded "statically" (by Windows on program startup) or "dynamically" during runtime via "LoadLibrary" (nil for dynamic loads and non-nil for static loads). However, this piece of information is not accessible in Delphi programs without some nasty hacking. Because Delphi's RTL calls the main program block on DLL_PROCESS_ATTACH and does not supply this parameter (the program block has no arguments, after all). As you can see, I have to initiate the DLL_PROCESS_ATTACH notification for the "fake" DllMain myself, by calling it for the first time from the main program block (using Reserved = nil as fixed value in this example). [DisableThreadLibraryCalls](https://msdn.microsoft.com/en-us/library/windows/desktop/ms682579%28v=vs.85%29.aspx) prevents DllMain from being spammed with DLL_THREAD_ATTACH and DLL_THREAD_DETACH notifications, which for most projects I'm not interested in. It's good practice to do this unless you need the thread messages.
Thankyou !- Programming now. Will reply properly later
Nice work on this Marco and team. I make a lot of use of spring so this will help 
So what does that make now? **Ten** string types? I remember when Pascal used to be a much simpler, cleaner language. There's only so much you can retroactively bolt on before it makes a lot more sense to start with a clean sheet.
[List of libraries and components used to build 1Password](http://delphi.org/2016/06/1passwords-components/)
It's not "PR"; it's meeting minimal acceptable standards for 2016. Try giving this excuse to someone who looks at the product and sees how outdated and buggy the IDE is. "Time is better spent on things like LInux support." They'll answer, "I can get Visual Studio for cheaper, get Linux support AND a world-class IDE". Other products don't have to make the choice between features, bugs and standards, and hence is not an acceptable excuse to potential customers. Heck, I think the Delphi IDE is the only programming-oriented editor in existence that doesn't let users define their own key bindings. :-( How would you explain that to someone looking at Delphi for the first time? "That time is better spent on things like Linux support" will simply say to the person that the resources available to Embarcadero are so small that they can't add new features and keep existing ones maintained at the same time. MVP Warren Postma has said he's had conversations with EMBT developers off the record where he's been told that things like the code parsing for various IDE features need a complete rewrite and they want to do it but management won't authorize the time. :-( Think of it like a restaurant with old, fading, flaking paint and a rundown sign outside. You can say profits are better spent on hiring more wait staff or something, but potential customers will take one look at the building, make assumptions, and pass up going inside. The first impression made by Delphi is with the installer (which they have put some work into improving recently) and then the IDE itself. On the Google+ group the founder was talking about having to restart the IDE of the version his company uses 10-20 times a day. :-( Again, in 2016 that's simply not acceptable and anyone experiencing that is going to pass over the product no matter how good any other part of it is.
&gt; The world moved on to the Web, yes, it really did. The remaining Delphi users are, basically be definition, stuck in the 1990s where desktop apps reign supreme and all development is done on Windows. Also, all software is proprietary and people pay thousands of dollars for development tools and libraries. 
You know it. The end-game of vendor-lock. 
Once memory issues are resolved, what does a 64 bit IDE buy me? User defined key bindings would be cool, though. A much better use of their time.
ehh... Not worth a read for the example or the plug for their product.
Bad luck, you could probably get a refund? It is an interesting move though, I wish they would do the same with other products.
Nah, I'm not worried about it, just struck me as super weird. $50 for even the starter edition is a steal. I have a license for pro at work and it's nice to have it at home as well. I wish that there was a similar promo for Delphi, but it seems to me that Delphi is maybe a stronger seller for Embarcadero and maybe it makes less sense.
Is it really a steal when you can get Visual Studio for free now?
I'll point out that I wasn't simply talking about a 64-bit IDE, I was talking about (as I clearly stated) a *cross-platform* 64-bit IDE. (As in the same Linux support you're talking about... OSX is probably more important as an initial goal, though. And I mean the IDE RUNNING on those platforms natively, not just targeting them.) Unfortunately, this will probably never happen since the dev team made the insanely stupid decision to go nuts internally with the Delphi .NET stuff back in 2003 to the point where it's virtually impossible to move away from. Did they ACTUALLY believe that Microsoft was going to completely deprecate the Win32 api? Despite all the .NET bluster at the time, anyone who legitimately thought that was even a remote possibility is an idiot. "Galileo" was the beginning of the end, as far as I'm concerned. 
Nice work. But one needs to ask, why are we going back to the age old Delphi problem of not having prototypes for all the api?... Delphi/FMX missing routines that would be immediately avaliable in the OS's toolset. This is a problem when your vendor is always behind or the product is dropped. We experienced that before....
1a) always try to "register" with non-existant mail. if the site is dumb-enough, it won't require mail validation (this one is) OR: 1b) create an account for the sole purpose of gathering junk from "you must subscribe" sites. 2) Profit ;-)
well, it still isn't _DIRECT_ link to _PDF_ ...
$200. When will the Delphi community stop trying to commit suicide by attempting to make a living *from* Delphi rather than *with* Delphi? Worse, Wildfly - free and open source. The STOMP protocol? Open and unencumbered by patents. Their site even writes "Many developers have told us that they have managed to write a STOMP client in a couple of hours to in their particular language, runtime or platform into the STOMP network." Habari Client For Artimis? $200. They even state on the web page, "Habari Client for Artemis is a library for Delphi and Free Pascal which provides access to the ActiveMQ Artemis free open source message broker." I'm sure no profit is going back to the free and open source components that are providing most of the functionality in this combination. I've seen worse though, particularly on the mobile front. People are charging hundreds of dollars for products that are openly billed as wrappers to the free and open source FFMPEG or VLC libraries. On the one hand, Delphi is rendered economically uncompetitive by every developer charging $75 to $300 for every library they write as if it was 1995 and open source wasn't really a thing yet. On the other, you have component vendors trying to make a buck from building on top of open source code without giving anything back. We don't even have to get into pricing structure of Embarcadero itself. This situation kills Delphi for hobbyists, personal development and small business, the places it finds most of its use today. I guess on the other hand that because it costs so much people want to find a way to make that cost back, so the cycle continues. :-( 
[Link to Part 2](http://chapmanworld.com/2016/06/27/brutally-roll-your-own-backend-part-2/)
Well this is huge news. It seems Idera may not see the return in investing any more money into Delphi. :-(
People would then probably complain that it was too short.
It works...... Can't find any words for the shame. So I guess all I can say is: thank you! 
This coffin has so many nails already, what's one more? Edit: Although I've moved most of my development away from Delphi I still have one very large project that is simply too big and cumbersome to migrate to C#. So I'd like for Delphi to stick around. At this point the only hope of this happening is if Microsoft buys the Delphi development tools. And I don't give a crap about all the mobile and web stuff -- there are much better tools to do all that. I'd just like to see Microsoft obtain the basic Windows development IDE. The genius behind Delphi is also the genius behind C# at Microsoft so it would be a homecoming of sorts.
&gt; At this point the only hope of this happening is if Microsoft buys the Delphi &gt;development tools. It's hard to imagine Microsoft buying it when they've already open-sourced most of C# and bought and then open sourced Xamarin. I'm not sure what MS needs or would get out of acquiring the Delphi line. They already dominate on the Windows platform with C# and VS and Xamarin gives them the framework to target other platforms now. Apparently Idera is continuing with Delphi but wants to outsource R&amp;D and a lot of development; this can't be good for quality - and the product isn't known for quality in the first place. I still think they're never going to increase Delphi's market share; people just aren't going to go back to Pascal or even use a proprietary language anymore. They should go back to the drawing board and create a new from scratch Pascal-influenced language. Leave Delphi for those maintaining legacy apps (who don't want or need all the expensive mobile, IoT, etc. stuff) and market the new tool to younger developers and add all the latest gizmos, cloud, etc. stuff to that. That's the only way they're going to increase revenue. The Delphi market is simply going to continue to shrink little by little every year. They need new products for new customers to bring in the revenue.
&gt; I'm not sure what MS needs or would get out of acquiring the Delphi line. They would get very little to nothing out of this. This would, quite literally, be an act of kindness towards a community of developers most of whom are almost certainly also using Microsoft's development tools. They've shown they're open to helping developers like this when they added support for Ubuntu-based development to Windows 10. I know this isn't exactly the same thing (Microsoft has significant self-interest driving the Ubuntu support) and I know this is a long shot but one can only hope.
`Close` is just `Hide` though if the form is auto-generated, iirc.
[Link to part 3](http://chapmanworld.com/2016/06/29/brutally-roll-your-own-backend-part-3/) [Link to contents page](http://chapmanworld.com/brutally-roll-your-own-back-end-using-lamp/)
&gt; As we expand the use of IDERA’s R&amp;D Network (100s of developers around the world) we will accelerate the effort to deliver on this Roadmap. Read: "IDERA's R&amp;D Network" not "Embarcadero's R&amp;D". Meaning: The developers at IDERA are trying to get into the existing RAD Studio/C++ Builder source code and build up the experience that IDERA threw away in Spain. &gt; The development processes are different from what Embarcadero has used in the past (more structured outsourcing) and there is always room for improvement, ... Laying off a big chunk of the core developers from the Spain office is a great step towards "a different development process". But it's also a great step towards an even worse product quality. Throwing away experienced developers and their knowledge about the source code is not a great sign to your customers and shows how valued (experienced) developers are in your company. &gt; We are committed to growth! We are investing a lot in marketing to make sure that new developers are aware of our tools. Ah, thats why I was spammed with 3-4 mails per week until I unsubscribed. If you want growth, you should start providing Delphi RAD Studio and the C++ Builder for free, like the main competitor Microsoft with Visual Studio for C++/C#. And I assume "growth" means that the quality of the IDE is "grown" and not just the quantity of half developed beta status "features". The reason why companies like JetBrains get away with selling the IntelliJ IDE is the high quality of their tool. But - Oh wait - they are giving their "community" edition away for free too! If you want to spread use of Delphi or the C++ Builder, you should make it attractive for students and universities. Give the students a reason to invest their valued free time into an unpopular/dying?/dead? programming language or an unpopular IDE. You gain more popularity by free software/open source projects that are useful and popular. Get back to the roots of the RAD Studio/C++ Builder, the key value always was and will be the quick and easy setup of a graphical interface and connection to a database. This is the main value why companies and developers use this tool. Second comes the vast capabilities of the library that is provided. It's the "batteries included"-approach that already made Python (and before that Perl) popular and useful. If you don't have the resources, you should chop away the whole mobile stuff. Developing a native APP for Android/IOS/Win10 is already hard enough without "yet another IDE", I don't need another layer I have to fight against when I focus on such platforms. Companies are thinking twice before doing native APPs. It's often easier and cheaper to develop a web application using REST and SPAs with Angular/Ember/React/'whatever' which immediately is available on all platforms at once. This means, you should provide an easy way to setup a HTTP/REST server. This is where the future of the current trend aims at. EDIT: And before I forget: More important than any features or quality the IDE brings with it or the features of the library is documentation. Provide more examples sprinkled across your library API documentation to immediately show how it is to used. Improving the API docs by tripling the coverage would speed up development process quite a lot and limit the amount I have to hunt Google for code snippets of trivial functions.
People have been asking for this feature forever. :-( 
Brutally Roll Your Own Backend – Part 4
Why is it they can't afford to have developers on staff but they (and Embarcadero before them) can afford to spend all of this money buying up IP? If they'd pay for talented full-time Delphi developers at adequate levels, they wouldn't need to keep buying outside software to incorporate into the product.
The error is using Delphi in the first place.
 Shape1.visible := true; Shape2.visible := false; Application.ProcessMessages; Sleep(1000); Shape1.visible := false; shape2.visible := true;
Note that during that second, the form will appear "frozen" as no window messages get processed.
It's all about checking off product feature matrix items to them. They don't realize that eliminating a language's warts and making it safe and pleasant to use (and bug-free and stable and performant) would drive sales more than any "feature X" would. On the other hand, there's another part of Delphi with dangerous namespace collision possibilities and you can't avoid using it - specifically the "Uses" clause. Now, "Uses A, B" can let a function in B overwrite one from A without even generating a warning! The solution is that Delphi has it completely backwards. They have control for imports (those actually using the code), instead giving it to exports(the library author). That's the opposite of what makes sense and leads to many problems. For instance, look at this code: Uses Something, SomethingElse; Begin ReallyCoolProcedure; End. Where did ReallyCoolProcedure come from? Who knows? It's ambiguous from the code (code ambiguities are another problem spot with Delphi). Put the control with the USER of the libraries, and everything changes! Adopting from other languages that get it right, if you used Uses Something, SomethingElse; you'd **have to** specify the library when referring to the function: Something.ReallyCoolProcedure; But what if you don't want to type that all the time? Then we have *selective imports*. From Something Use ReallyCoolProcedure; Use SomethingElse; Now you can refer to ReallyCoolProcedure directly and it's still clear in your code where it came from; no ambiguity or potential for namespace collision. Also note that the library author isn't dictating what you bring into your program! What goes into your program is based on what you import, not what someone 10 years ago decided to export, whether you wanted it or not. What if both units have the same function? Then you allow renaming **on the import side**. The whole idea of renaming on the export side was crazy - you'd just use the name you wanted in the first place if you were the one writing the unit! From OldStatLib Import regression; From NewStatLib Import regression As NewRegression; Still no namespace collision, and still no ambiguity. 
where has that chart been all my life ? 
If Embarcadero added this feature, you would buy a new license?
A new license costs as much as I spent on my whole computer system, without adding FireDAC or anything else. Improving namespaces wouldn't be the most important item on my wish list. Since I work a lot with Linux now, Linux support would be much more important to me. 
&gt;Lots of armchair quarterbacks insist that they know exacytly what &gt;Embarcadero absolutely must do to boost sales, but if they aren't speaking &gt;for themselves, then that advice has to be taken with a grain of salt. My post had nothing to do with increasing sales, merely with pointing out one of the ambiguities in the language that can drive me crazy (functions that use var to return extra parameters is another one, which could be prevented if Delphi had tuples like Oxygene). Honestly, I think there's too much emphasis on what would increase sales. In a comment thread on his old blog, Allan Bauer was engaging me, Eric Grange, and a few others on ideas regarding the type system and Delphi. Allan mentioned some of his own, and then said something to the effect of "It should be understood that anything suggested here has to be demonstrated to management to increase sales before it would be approved". This overlooks the idea that simply making a language friendlier, easier to read, easier to learn, more expressive, or simply more enjoyable to use would increase user perceptions and recommendations and indirectly increase sales. With things now like "YAML" and "Internet Of Things" it feels like "buzzword bingo" to increase the check boxes in feature matrices. Then you look at what RemObjects is doing and you can see how much time they put into improving the language itself. They were able to add a host of modern features and conveniences - type inferences, tuples, generators/sequences, etc. - while still maintaining the feel of Pascal. I saw the new road map, but I was left slightly unsure whether the timeline was suggesting Linux would be done by the end of the year or released by the end of the year. 
Free version of [Delphi 10.1 Berlin Starter](https://www.embarcadero.com/products/delphi/starter/promotional-download) (available until Sept 9th) [Five days of online training](https://delphiaball.co.uk/2016/08/23/delphi-boot-camp/) (replays will be available) Electronic version of [Marco Cantu's Object Pascal Handbook](http://cc.embarcadero.com/item/30586), updated for Delphi 10.1 Berlin 
Don't forget the [Delphi Boot Camp](https://delphiaball.co.uk/2016/08/23/delphi-boot-camp/)
Perpetual license, but only available for free until Sept 9th.
&gt; Electronic version of Marco Cantu's Object Pascal Handbook, updated for Delphi 10.1 Berlin Got a download without login requirement?
Can someone tell me the limitations of this starter edition? What does "... limited commercial use license. Database components and drivers are not included." mean exactly? Basically: 1. Can I distribute my commercial application? 2. If I have my own database components can I use those? I don't want to go through the hassle off downloading a huge file if this thing is useless to me. Thanks.
Not that I know of.
Downloading is so hard. 
Time to Learn Pascal! It's a skill set that businesses have been begging to fill with high paying jobs working with brand new, cutting edge codebases.
Thank you. I agree with the suggestion that the starter edition should be offered free of charge. It would do wonders for Delphi.
This is a great move, I hope they make it a permanent offer.
Try to get a job with it.
Thanks.
this is fantastic. if you can't make the starter edition permanently free then sell it for the price of a computer game with unity and unreal integration. grow the delphi userbase !
It depends. Some features have changed or have been deprecated. It also depends on what third party components you are using. As for the ICS suite, V8 supports both Delphi 7 and 10.1 Berlin, so I assume it works the same in both versions. http://wiki.overbyte.be/wiki/index.php/ICS_Download If I had one piece of advice, resist the urge to change all of your strings to AnsiString. Except in rare cases, you can (and should) just treat strings like strings. Here are some other resources to get you started. Especially note Nick Hodges' answer: http://stackoverflow.com/questions/2746230/any-hints-for-those-that-want-to-upgrade-from-delphi-7-and-down-to-delphi-2010
They didn't make the recent C++ freebie a permanent offer so it's unlikely they're going to do it now, particularly for their primary product.
&gt; Except in rare cases, you can (and should) just treat strings like strings. See, even *we* can find things to agree on! :-) 
The source formatter is missing. Gexperts for 10.1 provides that tool among others.
As I wrote on Google Plus: &gt;I was just thinking, it's rather funny.... &gt; &gt;Back in 1999, Borland gave us a complete IDE to run in Linux to develop &gt;Linux GUI apps, even though Linux was virtually unusable on the desktop &gt;and we were all Windows developers who merely wanted to cross compile &gt;for Linux server apps from Windows. &gt; &gt;In 2016/7, when Linux is everywhere, Microsoft is paying Canonical to put &gt;the Bash shell in Windows and porting SQL Server to Linux, Stack Overflow &gt;says 20% of developers use Linux and I'm making this post from a Linux &gt;desktop, Embarcadero is giving us a Windows-only IDE that can only cross- &gt;compile for Linux server apps from Windows. &gt; &gt;Hmmm....
I use Kylix daily, via https://crosskylix.untergrund.net and it still work great to create server apps for Linux.
But Linux support for Delphi will be ARC-only. For me, this is a showstopper. I do not want to rewrite my existing server code due to this BREAKING CHANGE. Wrong technical decision to force ARC support.
http://www.lazarus-ide.org/
Run Away! Honestly keep it as d2007, that was a pretty decent version of the product before it went into lala land. The focus of the product is now mobile and eeking out as much cash as it can from businesses that still have a Delphi codebase. The VCL gets periodic updates, but only the kind of stuff you'll see tmssoftware.com produce for a modest cost. The latest language additions support generics, anonymous functions, RestApi lib and an interesting parallel task library. But Unicode is a rough transition, made in XE and help still doesn't work for shit. I would recommend devising a strategy to replace pieces of the code, over time, to another language. There heyday of Delphi is over 10 years ago and nearly everyone had moved on. It's those with an old code base that are left. But the job market is nonexistent and you'll have a damn hard time finding developers. Why am I still here? Golden handcuffs, I have an old codebase from the D5 days that I've migrated thru D7, 2007, 2010, Xe, Xe2 and finally stopped as it became obvious that I was spending more time working thru Delphi version issues and migration, than the code. In addition, I will never port it to mobile using FMX.. even if I did, i would loose the material UI for the target OS and it wouldn't look like a native app. Delphi is bad news... And very old. Engineer your way out of it.
It's hard to give advice without knowing more about the application, but I guess the first question would be whether you intend to leave it in Delphi 2007 or move to a modern version. A lot of the answers will change depending on the version you intend to use. If the project is in maintenance mode and will only receive limited fixes, then I recommend leaving it in 2007. If there are going to be significant changes, then I would consider moving it to the latest version and getting a subscription. Delphi 2007 was released almost ten years ago. There have been more releases since then than there were up to that point, and there have been a lot (A LOT!) of improvements, including database connectivity, operating system support, etc. Let us know which way you're leaning and I'll try to post some more complete answers and build on the already excellent response from liflo. If you're new to Delphi, you might want to sign up for Embarcadero's free [Boot Camp](https://delphiaball.co.uk/2016/08/23/delphi-boot-camp/). They also have a limited time promotion for a [free copy of Delphi Starter](https://www.embarcadero.com/br/products/delphi/starter/promotional-download). It's great for getting familiar with the latest version, but a little feature limited (I think) for production use.
I'm kinda with this guy. Make sure you factor into your modernization calculations that none of your developers know Delphi. If you need to do any significant development on this project, look to other options. Especially if the D2007 version uses many third party components. We have a project that we have been trying for years to modernize, but our vendors have disappeared and now we are rewriting huge sections of our application. Dying platform man. 
The idea is to modernize it so that we can put out new releases more easily. Right now only 1 or 2 persons know how to do this.
Yes, this helped a lot. Thank you very much.
That's it. It's a great forum. You'll get a much help from that forum where that are still using Delphi.
Static code analysis tools: Look at Peganza Pascal Analyzer and Code Healer. Advice: If you've never used Pascal before, find someone to teach you the basics. Pay them if necessary, but get help. 
1. Delphi supports these architectural patterns, but they are not enforced, so it's not unusual to see applications with business logic in form units. Hard, painful experience helps get developers out of this habit, but here are a couple of preventative tutorials from [Malcolm Groves](https://www.youtube.com/watch?v=Ci1HP8ZBJxk) and [Nick Hodges](https://www.youtube.com/watch?v=sGn3-CsCYYM). 2. [DUnit](http://docwiki.embarcadero.com/RADStudio/Seattle/en/DUnit_Overview) is very popular and has been the de facto standard for years, but it hasn't been updated in quite some time and is showing its age. [DUnitX](http://docwiki.embarcadero.com/RADStudio/XE8/en/DUnitX_Overview) (similar name, different implementation) is a newer and more modern library that takes advantage of newer Delphi features. Both ship with the product. If you are a fan of TDD, [TestInsight](http://delphisorcery.blogspot.ca/2015/02/testinsight-unit-testing-like-pro.html) works in the IDE and helps smooth out the work flow a lot. 3. Two-part answer - Part 1 -Delphi does not have an ORM built in, but there are third party libraries available. I don't use one, so I can't make a recommendation. Maybe someone can speak up with a suggestion. - Part 2 - Delphi's primary database technology is [FireDAC](docwiki.embarcadero.com/RADStudio/en/FireDAC), but there are [several options](http://docwiki.embarcadero.com/RADStudio/en/Developing_Database_Applications). In general, you need the Enterprise edition or the Professional edition with the database add-on for full database access. 4. A couple of people have already suggested [Pascal Analyzer (PAL)](http://www.peganza.com/products_pal.html) and [CodeHealer](http://www.codehealer.com/codehealer.php). I use and like them both. If I were to give a very broad description of how I use them differently, PAL is extremely thorough and excellent for maintaining the cleanliness of my code over time, where CodeHealer brutally points out code that will cause me problems without any regard for my feelings. Another option is [FixInsight](http://www.tmssoftware.com/site/fixinsight.asp) which was recently bought by TMS. The Delphi IDE has built in [Audits and Metrics](docwiki.embarcadero.com/RADStudio/en/Source_Code_Audits_and_Metrics), which can be useful, but are difficult to decipher and in desperate need of a UI overhaul. 5. By default, Delphi now uses [MSBuild](docwiki.embarcadero.com/RADStudio/en/MSBuild_Overview), so you can use any build system that supports MSBuild. MSBuild is easier to script than the command line compiler, so I have been creating simple DOS batch files for my builds. 6. There are no third party IDEs that fully support Delphi. I strongly recommend getting the latest version (currently 10.1 Berlin) along with a subscription. 7. See previous response - **Getting Started** 8. This is difficult to answer. I interpret "biggest differences" as the ones that I like the best, and even that's tough because so many features that have been added have just become a part of my regular usage and I don't think about what life was like before. For more stuff than you can shake a stick at, you could go to the official [What's New page](http://docwiki.embarcadero.com/RADStudio/en/What's_New) and check out what was new in each previous version (on the left), check out [David I's presentation](http://www.slideshare.net/embarcaderotechnet/delphi-innovations-from-delphi-1-through-delphi-xe5) (up to XE5) or check out this [curated list](http://stackoverflow.com/questions/8460037/list-of-delphi-language-features-and-version-in-which-they-were-introduced-depre) on SO. My list includes: * Generics, especially collections * DataSnap has been rewritten and improved a lot * Refactoring in the IDE, especially code formatting * Guidelines in the VCL designer * Many many VCL and RTL improvements and additions * And a bunch of stuff that I'm sure I'm forgetting 9. I think madexcept is very useful and a big help if an uncaught exception pops up in the field. 10. Delphi replaced its legacy memory manager with FastMM a long time ago. I couldn't tell you if the Nexus memory manager performs better or not. Edit: Formatting took several attempts
Lol, I actually did a double-take when I read the title above. Next riveting analysis by Delphi-Bar: Rolls Royce vs. Lada. And yes I'm a Delphi user (although I'm moving everything I can to VS).
&gt;Quick and easy to develop desktop applications.\ &gt; I prefer the form designer, because I find it easier to use. These two are opinions/assertions rather than facts. They need to be more specific for the reader - *why* is the form designer easier to use with Delphi? What makes it quicker or easier to develop desktop applications than with C#?
And then there's always this: [From Delphi 2007 to 10 Seattle: Easy!](https://www.youtube.com/watch?v=MsFAv2MnbEY)
"Object Pascal is a great language, kept mostly secret"
Arguably less secret with Embarcadero's latest marketing push and the sheer volume of recent training material available online. 1. [Delphi Boot Camp](http://community.embarcadero.com/blogs/entry/delphi-boot-camp) 2. [Embarcadero Youtube Channel](https://www.youtube.com/channel/UCMmsCQhkz-WlJ-IVBzPhbgA) (a few hundred videos) (more fun FireMonkey stuff) 3. [FMXExpress FireMonkey Resources](http://www.fmxexpress.com/) 4. [QuarkCube](https://www.youtube.com/user/QuarkCube) 
ok,i managed to get this working using a cube exported from blender as obj file and a 400x400 jpg.Color and lighting work..Problem is the bitmap does not show on the model. Also tried bmp and png with no luck. Am i missing something here?
The compile time is very fast, which is nice. But make extensive use of generics and it will throw "internal error" every once in a while. 
From the video: "The code includes functions, return values, and assignments. The kind of stuff that isn't optimized away"
Original blog post: http://community.embarcadero.com/blogs?view=entry&amp;id=8890
Pretty useless without seeing the code. Well, useless from a technical standpoint. It's a fairly decent sales tool.
Yup. I don't get anywhere near these speeds with two diff machines: - RAID0+1 SSD with Intel i970 and 24GB RAM (24 sec for 800k lines) - M.2 SSD with i7-6700HQ and 16 GB RAM (18 sec for 800k) I just don't buy 5sec for 1m lines of code... without detailing the code or the machine, I have to think this is a cherry-picked environment and code. I would love to get 5 sec compilation times, but that would be 5x faster than my machines now.
Tried a RAM disk?
In addition, the 32-bit compiler never got support for modern SIMD instructions and the 64-bit compiler never got optimized. Pick your poison. Either way, Delphi ends up benching at about half the speed of C++ and Java beats it on Sci-mark. The ancient single-pass compilation technique was developed for a time when, in Wirth's own words, "the memory of mainframes was measured in kilobytes". Single-pass precludes certain types of advanced optimizations. In today's world you have continuous integration, build servers, etc. anyway. I think Apple got it right when they designed Swift. Swift has a "playground" (interpreter) that lets you try code right away. Before shipping, you compile. Zero compile time before running tests combined with compiled performance in the final product. If EMBT were building us a Delphi for 2016 (I wish; Nick Hodges floated the idea of a "legacy mode" Delphi and a modern mode for adding backwards-incompatible new ideas back when CodeGear started up) I think this dual approach would be best. No trading runtime performance for shorter compilation times.
Delphi is powering a cloud of servers, in the company I work for, using mORMot. It generates huge amount of data, stored in local high performance databases, and gathered in CQRS in MongoDB servers. But far away from RAD! All DDD inclusive... 😀
I was wondering about Marco... then I just saw this.... http://community.embarcadero.com/blogs?view=entry&amp;id=8901 Is Marco staying too? I had wanted the old guard to go to get some fresh eyes and perspective, but so far they seem to have been firing the old guard and not replacing them. Now Nick is back, but I'm not clear what he's going to be doing. The problem with pushing the product into relevance is that proprietary programming languages in general ceased being relevant many years ago. An interview I read with the new Idera guy indicated they see interest among existing legacy users and academia but not among young/potential new users and don't plan to go chasing them. Personally I think they're wrong about the academic interest (where it's all about openness and open source nowadays). I've come to feel the best bet is maintaining a legacy Delphi for the majority of users who are maintaining apps, and creating a next-gen, backwards-incompatible, modern language to attract new users. In a sense, what Swift is to Objective-C, and modern the way Oxygene is. Nick Hodges had floated the idea of a legacy mode and modern mode for the Delphi compiler back in his Codegear days. I wonder what he still thinks of that idea.
And it does it's job pretty well as far as I know.
sorry - but is your insert key working? does this happen in notepad as well?
no its just on delphi im sure im doing somthing wrong 
check to see that insert mode is checked (on) in tools&gt;options&gt;editor options.
wut XD 
Check the third box from the right on the status bar at the bottom. Does it say "Overwrite"? Then hit the Insert key.
&gt;please HELP delphi being delphi again wat
You are testing different conditions. I would do this with two separate tests. One to confirm that equal values return True and another to confirm that unequal values return False. Maybe something like this: [Test] [TestCase('TestA','2,2')] [TestCase('TestB','3,3')] procedure NumbersAreEqual_EqualValues_ReturnsTrue(aValue1, aValue2: Integer); [TestCase('TestC','2,3')] [TestCase('TestD','3,4')] procedure NumbersAreEqual_NotEqualValues_ReturnsFalse(aValue1, aValue2: Integer); ... procedure NumbersAreEqual_EqualValues_ReturnsTrue(aValue1, aValue2: Integer); begin Assert.IsTrue(NumbersAreEqual(aValue1, aValue2)); end procedure NumbersAreEqual_NotEqualValues_ReturnsFalse(aValue1, aValue2: Integer); begin Assert.IsFalse(NumbersAreEqual(aValue1, aValue2)); end 
I (not a marketing guy) threw this video together in a day, as a bit of fun. I am flattered by those of you that made the mistake of thinking it was marketing output, especially those of you that thought it was some kind of answer to MS. Based on this feedback, I would really love to see the product of this concept run through a professional marketing team. Seems like it presses some of the right buttons. 
"ancient single pass technology"..."precludes optimisations" this is simply not true. It would be true if the single pass included the code generation phase, but in the case of Delphi it doesn't. It's the parser which requires a single pass because the language is efficient to parse, but it's parsing to an AST from which code is generated. At the AST, the same optimisation as any other compiler is possible, with the exception of optimisations that are only possible on bytecode at runtime. These exceptions are few and typically only required to deal with the fact that bytecode does not perform so well as native code inherently. Single pass parsers are no more "ancient" than any other kind of parser, they're just more efficient. 
Single pass doesn't use an AST. https://en.wikipedia.org/wiki/One-pass_compiler &gt;In computer programming, a one-pass compiler is a compiler that passes &gt;through the parts of each compilation unit only once, immediately translating &gt;each part into its final machine code. This is in contrast to a multi-pass &gt;compiler which converts the program into one or more intermediate &gt;representations in steps between source code and machine code, and which &gt;reprocesses the entire compilation unit in each sequential pass. &gt;...One-pass compilers are unable to generate as efficient programs as multi- &gt;pass compilers due to the limited scope of available information. Many &gt;effective compiler optimizations require multiple passes over a basic block, &gt;loop (especially nested loops), subroutine, or entire module. Some require &gt;passes over an entire program. I'm sticking with what I wrote. Single-pass compilers were designed to work with kilobytes of memory. That's not the norm today and they trade off optimizations, which is why the technique isn't used in modern compilers. If you don't think single-pass compilers are ancient, name a modern single-pass compiler. As you can see from the Wikipedia page, they have a host of drawbacks compared to modern multipass. 
One thing that might help is to imagine: &gt; What would you have done under Windows XP? If the user is a standard user, where did you place files then? The answers go back to the Windows 2000 Logo requirements: - Where to install the program: `CSIDL_PROGRAM_FILES` *(e.g. C:\Program Files)* - Where to place the start menu shortcut: `CSIDL_COMMON_PROGRAMS` *(e.g. C:\Documents and Settings\All Users\Start Menu\Programs)* The user logged out, got an administrator to login, and the administrator ran the installer. The installer, running *temporarily* as in administrator, installed: - the program in Program Files (where all users can run it, and it is protected from tampering) - the start menu shortcut where "all users" can see it Now the standard user logs back in, and runs the program. All is well. Preferences ---------------- Now imagine your software is called `mIRC`, and you want to store a list of the user's preferred servers. Where do you store the user's preferences? You absolutely do ***not*** store it in: C:\Program Files\mIRC\servers.ini Why not? - that is a common location; each user would override each other user's preferences - that location is protected; nobody's allowed to tamper with stuff in the Program Files folder You store the **per-user** application data in either: - `CSIDL_APPDATA` (e.g. C:\Documents and Settings\hodyoaten\Application Data) - `CSIDL_LOCAL_APPDATA` (e.g. C:\Documents and Settings\hodyoaten\\**Local Settings**\\Application Data) What is the difference between the two? Users can choose to have a *roaming user profile*. They can go from machine to machine in their domain and their application preferences will follow with them. Any data you write into `CSIDL_APPDATA` is uploaded to their central profile (during logoff). When they login to another machine, their **roaming** application data is downloaded from the central store onto the computer they are now using. You don't want to bulk up the `CSIDL_APPDATA` with huge files - only preferences and small things. Things like words added to their spell checker. Contact names. Bookmarks. Favorites. Cookies. The other application data folder, `CSIDL_LOCAL_APPDATA` is **non-roaming**. The contents of that folder stay on that computer. That's good for things like images, databases, thumbnail caches. Paths change -------------------- With all of this we're still on Windows 2000 and Windows XP. There's no need to discuss UAC, because UAC doesn't change any of these things: - the user is a standard user - they need to run your installer as an administrator - it installs into program files - per-user preferences are stored in the users own *application data* folder The only difference with Windows Vista is: - the paths resolved by `CSIDL_PROGRAMFILES`, `CSIDL_APPDATA`, `CSIDL_LOCAL_APPDATA` have changed - you can include an item in your application's assembly manifest that indicates it "**requireAdministrator**" - UAC is a convenience feature, that lets the user easily elevate to an administrator (rather than having to logout and have an administrator login) **Note**: MSI installer technology knows if an administrator is going to be required, and knows how to ask the user to run the installer as an administrator, or knows how to trigger a consent to elevate to an administrator (if UAC is available). Windows XP ----------- Ask yourself what you would have done under Windows 2000 or Windows XP. Then you'll have your answers. A lot of developers answer, in all seriousness: &gt; *"I don't support running my application as a standard user on Windows XP"* That developer fails. 
Reading these answers makes it clear that Windows really, really, *really* needs a package manager.
This article doesn't really teach - it doesn't tell the reader *why* they're doing any of these things. It's just "click here" and "paste this code". It should start with a description of what they're trying to build, then walk the reader through, explaining why they're doing what they're doing along the way.
thankyou !!!! - i was just implementing undo functionality and was experiencing a lot of problem that this will solve (specifically the operation being undone being recorded as another undo operation).
i have a remedial level question that all my googling has failed me. What unit has the declaration for itextdocument? I found this http://stackoverflow.com/questions/17937225/delphi-how-to-import-type-library-for-new-itextrange2-type-interfaces Is that really the way to declare it? It seems like a deployment nightmare.
I imported it once, and keep `tom_TLB.pas` in source control forever. Put on pastebin, becuse comment replies on reddit are limited. &gt; [`tom_TLB.pas`](http://pastebin.com/14jpBZHg)
LocalLow is for reduced permission applications, very few support this. IE/Edge for one does. It's separated from Local so that even if the website exploits the browser, it cannot affect the browsers running at normal permissions. There's no actual rule that "Roaming" means "small size". It's okay to put files of any size there so long as they belong there, just try to keep it lean. Real life Roaming folders are sometimes tens of gigabytes, and so long as you're working with a single PC, they don't roam anywhere so it doesn't matter. But then again, the user might decide to move Roaming\YourApp folder to Dropbox and put a junction into Roaming, to have your app's state synchronized between several PCs. It's nice if your app plays along with this. Plus, applications misuse these folders all the time, so be vary when deciding what to preserve/delete between reinstalls: 1. Some apps just put everything into Program Files. Since you can't write there without Administrator rights, Windows redirects writes to AppData\Local\VirtualStore. Even though this folder is "Local", it might have files you'd roam. 2. Some apps don't understand the difference and put everything into "Local" or everything into "Roaming". Google Earth puts "My Places" into "LocalLow" by default! Delete it and lose your places. 3. Some have noticed that you need Administrator rights to install to Program Files, and started installing themselves into "AppData\Local", so you might even find executable files there. It is permitted, I think, but I don't like this. 4. "Local" is not technically "discardable", it's just "data which makes sense only on this computer". "Roaming" is not technically "valuable", it's just "user data which can be shared between computers, reinstalls, different versions of your program". So there are cases when valuable stuff goes in "Local", when it is not logically shareable between PCs. For instance, let's say you've configured local include paths in Delphi (C:\Delphi\Libs\JCL;...). Where does Delphi store this information? Unless it's the registry (which it is), it should probably be in Local. It's not correct to store this in Roaming, as local paths will be different on other PCs. But if you're reinstalling Windows, you might still want to backup this to save yourself time on reconfiguring it.
Try it under Berlin, it is much faster. This shows Seattle vs. Berlin compile times. Berlin is 3x faster for code full of Generics. https://www.youtube.com/watch?v=kvuxeaMDmMc
did that actually help you? You seemed to be asking a beginners question. Love to help you further if you need it.
Not as much as I would like but when I get time I intend to explore that option out. Right now I have another solution. I'm not a beginning programmer but it has not been something I have kept up with. I started with Pascal on a TRS80 Model 3 in the late 80's but have not kept up with things as much as I would like to since I became a sysadmin. This is something for my own enjoyment rather than a job. 
case insensitive and using a tstringlist instead. var tsl:tstringlist; ts:string; myword:string; found:boolean; i:integer; begin tsl:=tstringlist.create; myword:=ansiuppercase(myword); tsl.loadfromfile('myfile.txt'); found:=false; if tsl.count&gt;0 then for i := 0 to tsl.count - 1 do begin ts:=ansiuppercase(tsl[i]); is pos(myword,ts)&gt;0 then found:=true; end; tsl.free; end;
So many thoughts. Writing a journaling system from scratch? Software with that amount of logging needs to be running on Linux, which has a tried and true, robust journaling system in place already. Of course, Windows today [has its own logging solution too](https://msdn.microsoft.com/en-us/library/windows/desktop/aa363652(v=vs.85\).aspx). On top of that, it needs to be using log rotation to automatically archive the logs on a periodic basis so you don't end up with a log file so big you can't open it. But if you do need to open something that big, use something more serious than Notepad in the first place (Notepad++, Sublime Text, etc.) This points out that logging needs to be part of the standard library of Delphi, just as it is with Java and other languages geared towards writing enterprise software. Heck, Java implements a logging framework for other loggers to plug into. :-) In Python, there are many 3rd party logging libraries but they all tend to use the low-level writing components of the standard library's logger so that even if different libraries in the project are using different loggers you still end up with one log file (while writing is stable and secure and designed to handle logging data from parallel processes). The way things are now in Delphi, what does one do if several of one's components implement logging via different libraries (of which Hexlog will be one more)? You'll end up with lots of different log files, and good luck synchronizing them all to get a clear picture of the state of the system. Lastly, if it's not included on the component palette many Delphi users won't use it (which is why version control and particularly DVCS came so late to the Delphi community). I hear EMBT may be including the logging library they bought in standard Delphi in the future. If they do, this will be a very good thing and bring some coherence to the Delphi logging situation. 
There was talk about doing this a few years ago, but the Old Guard freaked out about abandoning ANSI strings and having memory management. The last word from Allan Bauer was that now there were no plans for a new desktop compiler. :-( I put off working on a project for a long time because I thought a new desktop compiler was coming with memory management... which could lead to merging classes and "records with objects" (which is where they shoved all the neat features you need automatic memory management for) and like you I thought we could see a lot of improvements. I eventually couldn't wait any longer and went with something else and then the word came down that they're not considering a desktop compiler rewrite. That compiler is decades old and is over one million lines of old, **undocumented** C code. :-( They don't even have a language standard to work from, hence, in Barry Kelly's words, the ultimate standard is if it compiles it's valid Delphi (and he admitted to being surprised at some of the things that compile). The 32bit compiler never got support for modern SIMD instructions and the 64bit compiler never got the older compiler's optimizations, so you have to "pick your poison". Unifying the compilers by moving to LLVM on the desktop should be a no-brainer, but it seems like they don't want to put the time/money into doing it and they don't want the backlash from people who are still maintaining code from the Delphi 5-7 era. 
That was a Windows package management problem, not a C++ problem.
This. If you're going to compare Delphi and C# it's not enough to just talk about the languages as if they exist in a vacuum. You need to compare the complete package -- the language, the IDE, the frameworks, the company. And when you do this Delphi doesn't fare very well. Far from it. Look, I love and have been programming with Delphi for well over 25 years. But in its current state Delphi is a sad joke. It CAN become great again but only if Anders/Microsoft acquires it from the carpet-baggers and gives it the home and attention it desperately needs. And yeah, I know that'll never happen.
I completely agree with this.. I have 4 products that are written in Delphi and I've been maintaining the golden handcuffs since the late 90s. Since. The. Very. Beginning. Delphi has suffered from always trying to catch up with other players in the industry. The "asset" of Delphi has been bought/sold so many times that I can can't really tell you who owns it anymore. This has lead to mismanagement of the property and it's acceptance by developers is abysmal. This has caused jobs to dry up as leadership refuses to invest their codebase in the language. In addition, the past ten years has seen a shift away from proprietary languages. Which doesn't help Delphi, nor C#. IMHO, the Seattle market is begging for java developers. With most major players using java for the backend and most consumer phones being Android phones (87% marketshare vs iPhone as of 2016Q2). While I appreciate Delphi management pushing for more interaction with it's customers, I don't think they understand that it's not going to be an army of evangelists that can turn around decades of atrophy. Technological advancement is Delphi's only hope. While providing a more universally portable framework (FMX) has helped stem the tide (at the expense of losing material design), it'll take a lot more to convince leadership to invest in the language. I don't have a magical answer, but I can tell you that I've been concentrating on building my java/python/scala skills for the next decade.
Here's the Google+ group talking about this article: https://plus.google.com/115032677792043930563/posts/XzvRSCcVMPK
I am using the default MDI application in delphi XE8 so it does a lot of the leg work for me. this is my first time using these. Child := TMDIChild.Create(Application); Child.Caption := Name; This is in the tmainform.createMDIchild(application) This worked great!! Thanks!! 
It's still actively developed.
&gt; there used to be some awesome websites that provided collections of code libraries/packages/etc. Are those all gone now? The GetIt package manager ships with recent versions of Delphi and makes it easy to install/uninstall free and trial components and libraries. Awesome Delphi - https://github.com/Fr0sT-Brutal/awesome-delphi A curated list of awesome Delphi frameworks, libraries, resources, and shiny things. Inspired by awesome-... stuff. 
Someone is frozen in time. US Checks to buy a software ? Really ? 
They were indeed "offshoring" when Embarcadero took over. They let go of most of the US developers and moved production to Romania and Spain. Now they've even shut down the Spain office and EMBT had already wound down the Romanian one. Now it'll be handled by outside contractors. 
I installed the trial for the latest version of Delphi with the Win32 and Win64 options to check out Getit. I learned that if you had the Starter Edition installed it's apparently impossible to then install the trial, but that's another story.... ...anyway, unless I did something wrong, GetIt listed a total of 94 packages available for Windows. 2 libraries, 38 components, and 54 "Internet of Things". I wouldn't even consider GetIt a viable package manager at this point. In fact, after Marco wrote a nasty letter in which he criticized Arnaud Bouchez for writing a blog post about poor performance with Delphi's compiler and informed him they wouldn't put the Mormot framework in GetIt because it "competes with Embarcadero", the community started working on their own package manager, Delphinus: http://memnarch.bplaced.net/blog/2015/08/delphinus-packagemanager-for-delphi-xe-and-newer/ https://github.com/Memnarch/Delphinus http://memnarch.bplaced.net/blog/2016/01/delphinus-new-ui-and-no-external-ssl-libraries-anymore/ It's open source, works with many older versions of the Delphi, uses Github as a backend, is automated, and you don't have to have your software manually audited by Embarcadero. It's early days for this package manager too, but since Embarcadero always manages to generate ill will among the community, I believe Delphinius will become the community's package manager of choice. Arnaud Bouchez is hosting Mormot through it; GetIt lets me flush my toilet via the Internet. ;-) Torry, as old and outdated as it is, is still the largest collection of Delphi software in existence. 
&gt;I'm not surprised you don't like GetIt, but it works well as a convenient way to &gt;install and uninstall a bunch of different free libraries. I was after them to create a Delphi package manager about two years before they released GetIt. I agree that a convenient way to install free libraries is awesome and really a necessity today. What I don't like is that they seem to be confusing a package manager and a software store and won't allow anything that "competes" with their products. This is why they don't allow Mormot framework in Getit, because it competes with Datasnap. Mormot is a large and popular framework, and it would be nice to be able to install it from the IDE. Delphinus won't have these content restrictions, so if it catches on you really will be able to install all of your free libraries easily. Delphinus is also working on a command-line interface, which should be able to improve automation. With other languages with CLI package manager interfaces, you can just supply a "requirements.txt" file to the package manager and it can download all of the dependencies for a project in one go, which is great for setting up a new workstation. I might be wrong, but I didn't see that option in Getit. &gt;My only real complaint is that the open source software isn't always the very &gt;latest version. As far as I know, GetIt is still being processed manually :-(, which would slow down adding new or updated libraries. Since Delphinus is automatic and works from Github, it should also be able to update much quicker. 
Baby steps. But keep up your efforts to improve the product. 
Lazarus as an IDE where you *build* applications is good. However, as an IDE where you *debug* applications is terrible. It is worse than Delphi 2, probably Delphi 1 as well, that's a fact. Feels just like debugging a C++ application where everything is a pointer... try it and you will miss Delphi IDE *very badly* in less than 10 minutes.
&gt;"If what he says is true" means "outsourcing is not compatible with product &gt;coherency". Fair enough and I apologize for not understanding what you meant. &gt;Lots of products are developed like that. Paying independent contractors to add specific features? I don't think so. In fact, when VMware recently announced they would do it for one of their products, it was controversial enough to be covered in the IT press: http://www.theregister.co.uk/2016/01/27/vmware_fusion_and_workstation_development_team_fired/ &gt;BTW, you have some issue with developers from other countries. Have &gt;some "stolen" your job recently? I have a problem with firing experienced developers and basically having people bid per feature addition. When Embarcadero fired the U.S. developers with many years of experience, working under Anders, etc. and replaced them with Romanians, the code quality plummeted. I talked with one of the former Romanian developers. He said that EMBT was offering such low pay that the only people they could hire were those direct out of school. These people knew Java, not Delphi (which is why those going through the Firemonkey source code began to find Java-style Pascal). Those taking the job were only doing so to add one year of experience to their resumes and then planned to find a better job. As such, morale was low (as well as concern about code quality since no one planned on being around long enough to have to revisit the code they wrote). EMBT ended up halting Delphi work at the Romanian office (although I don't know where they moved it to before Idera's change). That's my problem. As another Delphi user put it, "When you pay peanuts, you get monkeys". This move is pure cost-cutting - and shutting down R&amp;D is a sign about how much they're willing to invest in the product. Delphi was only a small part of EMBT's portfolio before the acquisition - CodeGear was purchased for $30 million but EMBT was sold for $600 million. Idera was about the same size as EMBT before the acquisition, so now Delphi's contribution to the company is diluted to half what it was before. 
So instead of writing "The quality of the code suffered when they got rid of the U.S. developers and hired new Romanian and Spanish developers" you should write "The quality of the code suffered when they got rid of the experienced and expensive developers and hired unexperienced and cheap developers to replace them". The problem is not about *where* the developers come from in the first place! 90% of Delphi's good libraries are written by devs outside US.
I wanted this feature in the Delphi IDE for years...
Great
I would say it is quite the opposite. Devs from Eastern Europe are the best. As an example, take a look at google code jam results.
that could be really helpful. Thank you
good work for the year
Hi, you can try FilterControl from VCL package by DevExpress or TMS. https://www.devexpress.com/products/vcl/exquantumgrid/key_advancedfiltering.xml http://www.tmssoftware.com/site/advfilterpanel.asp
This is a question with a lot of cons and pros. The advantage of Delphi is it's price. You just have to pay 1000 bucks and you are in ( https://www.embarcadero.com/app-development-tools-store/delphi ). On top of that, you are guaranteed that Delphi is fit for the future. Instead of having experienced senior developers working at it, you will have junior devs from Bulgaria or India working on it. Pouring their whole heart into it. You will love it, each version with new funny bugs to find and report. It's going to be like easter! So much fun, so much excitement! And all the nice workarounds you can employ. Xamarin, you are not seriously going to choose something that is for free for OSS dev, small teams or students? And it's from Microsoft, that company is clearly going to be bankrupt in 2 years and dropping mobile development like a hot potato. Why choose something that sits on solid foundations of Visual Studio? Solid means stable. Stable in biology means dead. [/SARCASM] Seriously, following the news around Delphi, Embarcadero and Idera of the last months read like it's going to be even less vibrant for professional development in the future. If you want to invest into a dead end, go for it. If you want to gain more experience with technologies that seem to be more relevant in the future go for Xamarin or even Java/direct Android dev. You might even try to dive into web application development with Javascript and AngularJS, with a backend written in Java or C++. But Javascript would probably be huge bucket of worms to work through. However, it would be more future proof than Delphi. I love(d) Delphi and more exactly the C++ Builder for the VCL and other included Libraries (Indy). At work I will be stuck with it for the coming 5 to 10 years probably, using legacy versions for legacy applications. But until now, I have not had any version of C++ Builder that was fit for professional C++ development. Compiler bugs like we are still in 2002 around every corner. And I used many versions: C++ Builder 5, 2007, XE, XE5, XE7 and XE10. None had a compiler that could be compared with the contemporary version of GCC or MSVC. And then you take a look at the offerings of the development environments in the ring: GCC: Free, MSVC: Free (for non commercial) and C++ Builder or Delphi: pay up front 1000 bucks at least. The price is irrelevant if you use it commercially or professionally. But for hacking private projects, forget it. You see, I am very frustrated. I thought Embarcadero would fix things and probably lead the whole ecosystem to a new and bright future. Maybe with free versions for non-commercial use like Microsoft or Intellij do. But instead the product was sold to Idera. And Idera fired many developers and it seems like it's going to outsource the whole development to places where developers are cheaper.
No books or special "Developer Days" will recover the trust I lost into the whole ecosystem around C++ Builder in the last year. How about pushing for an open source development of the RAD Studio, Delphi and C++ Builder? Not that it would save it from tumbling into irrelevance in the coming decade...
10 years ago if you asked me I'd have said the only problem with Delphi was shrinking job market - now I am glad I moved on and realise how much Delphi had been stagnated and why that was bad. Though it pains me because Delphi was so much part of my life for so long , I'd be very wary of starting anything new in Dephi now - especially with things like [this thread](https://www.reddit.com/r/delphi/comments/597fgl/delphi_development_is_now_fully_outsourced/)
this comment &gt;I have to admit I hate xcode &amp; swift (when you can't get easily the n-th character in a string you know something is wrong) first, in Objective-C, you can do [StringVar characterAtIndex:0] &lt;- first character &gt;and I don't know anything about developing in java for android but I love scala &amp; java and Intellij is by far my most favorite IDE. you don't know anything about developing in java, but you love scala and java, how does that work?!!!
Yes, you are right, but swift is the new kid on the block, it is apple's response to C#, Java. They recommend to use swift for new development, don't they? But I guess you can always use objective-c, if you want to get carpal syndrome from typing so many square brackets. Joking aside, objective-c is objective-c and I don't like it. See this: http://stackoverflow.com/questions/24092884/get-nth-character-of-a-string-in-swift-programming-language I haven't done specifically mobile development for android in Java, but I've worked with Swing and I've done web development in Java (weblogic, tomcat and so on). In my comment I said "I haven't done development in Java **for android**".
TL;DW: Delphi can send UDP packets.
I challenge the assertion that Delphi and its ecosystem have gone stale, but if you're interested, you could check the latest [CodeRage](https://community.embarcadero.com/article/technical-articles/16433-coderage-xi-productivity-platforms-and-performance) and judge for yourself. It's just wrapping up. Some replays are already available and the rest will follow soon.
&gt;I challenge the assertion that Delphi and its ecosystem have gone stale How would you challenge this? You can look at the numbers yourself. http://modulecounts.com Even if we were to pretend that all of the files on Torry.net are open source and work with the most recent versions of Delphi (when in fact many are just commercial demos or date back to Delphi 5-7; I'm in the process of obtaining exact numbers), it's clear that other ecosystems have 6X, 10X or more open source libraries available. Let's visit Torry.net and count the number of **new, open source or free** libraries posted in the previous two months. I count one for the last 30 days and another one for the previous month, for a grand figure of 1/30 of an open source library added per day. :-( Meanwhile, Java, C#, Python and Node.JS average about 134, 57, 63 and 455 (!!!) per day. Python, for instance, adds more open source libraries in one year than Torry.net has amassed in all the years of its existence. I have a post saved that I wrote in November 2012 in which I record that Torry had over 10K libraries available and Python's package tracker had over 18K. Four years later, Torry has yet to break 11K while Python's tracker lists just over 93K packages! Nadia Kominich could not perform the (mental) gymnastics necessary to conclude that the Delphi ecosystem is not stale. ;-) Delphi's not present in big data, in virtualization, in deep learning, or any of the innovative, exciting areas of tech right now. People who want to work on cutting edge stuff do indeed find that the Delphi ecosystem is stale and lacking. Heck, after finally discovering distributed version control and REST they've now discovered YAML, which dates back to 2001. :-) If you're maintaining legacy applications or working within very narrow, traditional/old fashioned confines (very conventional Windows GUI desktop app) Delphi has its uses. If you're looking for database drivers for the newest, hottest databases, for machine learning, for inter-operating with things like Hadoop for big data, etc., you're just not going to find it. And what you do find often archaically has a large price tag associated with it that other languages don't encounter. For instance, Delphi may be the only language left on the planet where it's still considered normal/acceptable to pay for a database driver. The point is really driven home when one looks at the PostgreSQL's web page devoted to drivers. Out of all the drivers listed, the only commercial ones are for Delphi. :-( Boris Mitov wants $400 for his neural network package, containing a few simple, classic neural network types. If you want the source code, this adds an additional **$1000**. It's not like he's coding proprietary algorithms here; I coded most of these networks myself in Turbo Pascal for a college independent study project in 1994. Meanwhile, the rest of the world is working with Google's open source Tensorflow library to implement state-of-the-art "deep learning" networks that are an order of magnitude better than old-fashioned designs and power Google's self-driving car, among other cutting-edge AI projects, for free. It's like the whole world changed and Delphi developers haven't popped their heads up and realized you can't charge $1400 for a 1980s-era backpropagation neural network library (or virtually any library) anymore. &gt;but if you're interested, you could check the latest CodeRage and judge &gt;for yourself. Can they? I thought the last day was now reserved for those with active update subscriptions only (which I think is crazy for precisely your reason - viewing videos may entice people with older versions to upgrade). 
&gt; How would you challenge this? Well, for one thing, well known Delphi detractors are still dropping in to threads like this and writing very (very) long diatribes insisting that it must be dead. I disagree with your measures and encourage anyone who wants to see for themselves to [check it out](https://community.embarcadero.com/article/technical-articles/16433-coderage-xi-productivity-platforms-and-performance).
Search in the registry for Delphi? (Back up your hard drive before you do it, though.)
&gt;Well, for one thing, well known Delphi detractors are still dropping in to &gt;threads like this and writing very (very) long diatribes insisting that it must &gt;be dead. I'm disappointed. I put the effort into documenting/substantiating my point in the interest of serious discussion and I just got back a sarcastic answer. By the way, providing evidence and explanations for one's conclusion is not a diatribe. It's how one gets taken seriously and convinces others. It's how people know who's telling the truth and who's trying to bamboozle them. &gt;I disagree with your measures I guess I'm going to have to invoke [Hitchens' razor](https://en.wikipedia.org/wiki/Hitchens's_razor) here: "What can be asserted without evidence can be dismissed without evidence." When I finish my study of Torry's data I'll be sure to quote your response in my writeup regarding the state of the Delphi ecosystem. It's actually more substantial than anything Marco Cantu had to contribute. 
&gt; if tsl.count&gt;0 then for i := 0 to tsl.count - 1 do Not in my world. This one made me a little nauseous. 
One thing is sure: You spend more time on Delphi related sites and collecting data about Delphi current status than I spend on leisure and recreational activities. I can only conclude that Delphi is incredibly *important* to you, or you have a very boring life. Don't get me wrong, but the day you see me spending more than 1/2 hour on a, lets say, COBOL site, please send me to a psychiatrist.
&gt;Instead of whining about Delphi in Python groups We're here, in a Delphi group, where an Embarcadero MVP won't explain to Delphi users why he believes Delphi's ecosystem isn't trailing other major languages'. Same thing happened on Google+ with Marco Cantu, and in Febrruary on Marco's blog, where he told numerous commenters that he disagreed that Delphi's ecosystem was lagging behind but couldn't/wouldn't explain why. &gt;and insisting that Delphi &gt;must be dead You're really hung up on "Delphi is dead", aren't you? The topic was the ecosystem being stale per OP's statement (not mine). &gt; because it doesn't rank as high as other languages on open &gt;source repositories Expand. Are you saying that ecosystems don't matter, or that one language having a vast open source library ecosystem isn't a huge competitive advantage, or what exactly? We're also not talking about "as large"; we're talking about pales to insignificance. Over and over again (including in this subreddit) users will tell you about the lack of available libraries and the high cost of third party libraries compared to other languages. I didn't invent the topic, and no one affiliated with Embarcadero seems to have a response other than to tell customers they're mistaken. &gt; you could just try learning about what's going on with Delphi today. I know exactly what's going on with Delphi today. In fact, given I'm the only one who ever does the work to gather Delphi statistics from Stack Overflow, Github, etc., I'd say I know more about what's going on with Delphi today than a lot of other people. &gt;Here's the latest roadmap for your reference. What does the roadmap have to do with this discussion at all? We've all seen the roadmap. This discussion has to do with being able to readily use Delphi for modern functions such as big data, deep learning, financial trading, graph databases, etc. &gt;Failing that, when Ian Bicking decided that Python just wasn't doing it for &gt;him any more, he didn't spend years trolling Python groups taking shots at &gt;the language or its users. You're determined that everyone who disagrees with you go away, aren't you? That's exactly how the Borland Bubble gets formed. On Google I bumped into a reference to a discussion more than ten years ago on the Embarcadero forum in which people were drawing up a list of "people who should be banned from the forum". I remember back then Nick Hodges had invented a new way to defend Delphi - if someone complained about a showstopping bug, he'd tell them how dare they come onto the forum and insist that their bug takes precedence over everyone else's. When they'd protest that that wasn't what they were suggesting, he'd say that we all knew what they meant. Near the top of the proposed ban list was "People who insist that their bugs are more important than everyone else's". MVP's and TeamB'ers have been defending their precious Delphi by assaulting its users for quite some time. It's the zealot defenders who take potshots at users and at everything else (see the recent "C# users should shut up" blog post from Jon). It's you who take pot shots at me rather than actually admit the unadmittable... yeah, Delphi has a dearth of open source libraries, and that's the number one factor affecting language popularity nowadays and arguably why the top 10 languages haven't changed in a decade. Heh, Marco Cantu even had the hutzpah to go off on Google Plus on a Windows Phone article calling the author delusional about the popularity of Windows Phone, that it had no apps and that the number of apps were the only thing that counted. Sigh... then he too wouldn't defend his own comments from a few months prior claiming that Delphi's ecosystem wasn't lagging behind C#'s. For the record, Python has some quite critical voices, especially over the change in Unicode from Python 2 to 3. However, in the Python world, people don't have Stockholm Syndrome since they're in charge of the language; they don't have to live with bad design/management. Armin Ronacher points out problems often: http://lucumr.pocoo.org/2014/5/12/everything-about-unicode/ Not being delusional or cult-like or trying to fluff up a failing product, the powers that be listen to him and respect him.... &gt;Just for the record, there are some very good criticisms of Python 3 like &gt;Armin Ronacher’s. So if you want to read something negative about &gt;Python 3 go read that. But the thing about essays like that (and other good &gt;criticisms about Python 3) is that they have specific things to say about &gt;improving Python 3. http://sealedabstract.com/rants/python-3-is-fine/ &gt;Be like Ian. I'll be like Armin. You can try being like David Heffernan, Arnaud Bouchez, Eric Grange, and the other Delphi luminaries who have no problem acknowledging that Delphi doesn't have anywhere near the libraries of other major languages and that this hurts adoption. We can't fix problems we won't admit exist. I'm reminded right now of a bit from one of Larry Wall's keynotes: &gt; There are two kinds of joiners in the world. Think of it in terms of anthropology. There are the kinds of people who join a tribe, &gt;and kind of get sucked in, like a black hole. That's the last you hear from them, unless you happen to be in the black hole with &gt;them. And we need people like this in our tribes, if only to be cheerleaders. &gt; &gt;But the open source movement is energized by the other sort of joiner. This sort of person joins many tribes. These are the &gt;people who inhabit the intersections of the Venn diagrams. They believe in ANDs rather than ORs. They're a member of more &gt;than one subset, more than one tribe. The reason these people are important is, just like merchants who go between real tribes, &gt;they carry ideas from one intellectual tribe to another. I call these people ``glue people'', because they not only join themselves &gt;to a tribe, they join tribes together. Twenty years ago, you couldn't easily be a glue person, because our culture was not yet &gt;sufficiently accepting of diversity. It was also not accepting of information sharing.... &gt; &gt;Still and all, things have improved greatly, and the bridges across the gaps have gotten sturdier. Now people can send their &gt;memes across a wider chasms without getting crucified on one end of the bridge or the other. Larry's never been to Delphi Island, it would seem. The missionaries still get met by the cannibals on the shore.
I just moved away from delphi and seriously i dont want to go back to it. The idera/emb politics are always the same - the pricing is insane for such an outdated product (I dont talk about c++ builder - its a mistake). VCL bugs from version in 2000y still exists and the vcl is nothing special seriously. If you dont have any products that you must maintain dont waste your money. For mobile - just go native, products like from emb will always be one decade back.
The C++ Builder Starter Edition doesn't even support 64bit, refactoring, code formatter or FireDAC/dbexpress (see https://www.embarcadero.com/docs/rad-studio-berlin-feature-matrix.pdf ). What use is a totally boiled down version of the IDE to anyone? I may see why it might be unnecessary to provide VCL source code with the Starter edition due to "beginners" don't have no need for that. Compare that to the Visual Studio Community edition ( https://www.visualstudio.com/vs/compare/ ). It's has 1:1 the same features as the Professional edition, and only a few very high level specialized features are in the delta to the Enterprise edition. And then you have to realize, that there is no word about any "editions" when it comes to the library you have available when developing for windows. .NET comes with everything you might ever need for free. It's not competitive anymore to provide IDEs only for selling customers. Companies and proprietary users want support when they pay for the software. But companies are looking at cheaper alternatives too, and they are also seeing the benefits of open source software. The current state of RAD Studio does not in any case encourage the use of it for open source projects. Everyone stupid enough to buy the IDE for writing open source code with Delphi/C++ Builder/VCL in his free time is locked into the "why should I provide anything for free, especially my precious source code"-mentality of the last century. Opening up is the only way forward. When Microsoft changed it's course and is now totally on the road to a more open system I thought hell froze over. It seems like even a huge monolith like Microsoft is more agile. 
The Starter SKU does have fewer features than the Professional and Enterprise editions, but it is an excellent starting point, and it's currently free. As are some of the books and almost all of the online resources. I'm also a fan of tools from other vendors. No sense limiting your options. edit: most online resources are free
I'm not sure if you're being funny, but your reply to this "wall of text" is exactly the point of the writer.
No offense, but I've many conversations with you as well. They go about the same way.
The day you actually evaluate any data I present and find a legitimate problem you can claim "FUD". 
&gt;I'll take the heat for having very little patience for people who intentionally troll &gt;Delphi groups. Pointing out the truth to people who claim the opposite despite all available evidence is not "trolling". You've created a non-falsifiable reality for yourself in which anyone saying what you don't want to hear is a "troll". You once replied to me on Jolyon Duranko-Smith's blog, "You're a troll - what makes you think I have to reply to anything you say?" Jolyon then took you for task for the same thing - your illogical conclusion that you can ignore any point anyone makes whom you label a "troll". I could be Satan incarnate; that in no way affects the validity of an argument. It's a pure ad hominem fallacy. 
It's sad that Firemonkey never really took off. When I see the slow pace of folks using Xamarin I keep thinking, "Gees, if I were doing that in FireMonkey, I could do that X month job in Y weeks instead". I'm not 100% sure if that's because of slow programmers, or Xamarin, though, but I do know that FireMonkey can turn out good quality multiplatform applications extremely quickly.
 It's actually worse... the guy who created FireDAC is also leaving, and rumors have just been confirmed that the entire Russian Embarcadero site is also being shut down shortly (which is why these two are looking for new jobs). 
It´s funny how some people have a real problem with sarcasms. Even the obvious and clearly marked ones.
I was recently at a roadshow from embarcadero. They said when it comes to such rumors that unless it comes from embacadero it is not true and that whatever websites reported those rumors really damaged them. They also said the only branch getting closed is the one in spain. I only came for some answers regarding live bindings since they are nowhere to be found online, didn't get them though.
Delphi related rumours from Joseph (alcalde) should definitely be taken with a grain of salt, but Embarcadero (Idera) do have a disturbing trend of outsourcing their development.
What kind of live bindings answers were you looking for?
I have a generic list of dog-objects DogList&lt;TDog&gt; I load this list into a stringgrid and until this point, everything works fine. now whenever the user scrolls the list I want to fill a TDog-variable with the currently highligted object from the DogList and I can't figure out how to do that. do I get the data from the adapter? what property holds it? neither can I figure out how to get the events of the TDataGenerator to fire. and does the adapter call the constructor of the object when I say Adapter.add? I followed the malcolm groves examples, but there is only stuff related to objects inside of objects. The same goes for StackOverflow.
I'm afraid I don't have an answer for you. Have you posted a question to StackOverflow? If so, please post a link. I would be curious to see the answers.
Not yet.usually i only lurk and comment on reddit
&gt; unless it comes from embacadero it is not true That ship sailed when we had the Delphi PRO EULA change controversy. In that case, it was the denials from Embarcadero that weren't true. Both well-known Russian Embarcadero developers have put up blog or Linkedin notices that they're looking for new jobs at the same time, a representative of a third party company that used to be associated with Embarcadero said they'd been told from someone still there that the Russian site is being shut down, and then a Russian friend of the FireDAC creator confirmed that his friend had indeed told him the Russian site is shutting down but they're not supposed to talk about it yet. 
Delphi used to be great, but now it is over... Sorry about that. 
These are great! However, I have little hope (whoever now) owns Delphi will invest in the language. I think there's a reason we don't have nice stuff.
The reason is that Linux support is the priority. The list is good but saying that Delphi Object Pascal hasn't changed in the last 20 years is clearly wrong.
8 character wide tabs &gt; *
It said it had only changed around the edges, which is an accurate assessment IMHO. There are a list of modern features as long as my arm that we're lacking. 
&gt;Honestly. I can't see the point of Linux target. I love it. Hell. I loved it the &gt;first time. But we arent in the same world anymore. I'd agree but use in a different way. Back in the Kylix era, desktop Linux was almost impossible to use, every Delphi user was a pure Windows developer and they wanted to just push a button in the Windows IDE and cross-compile to Linux server code. Instead, we got a Linux IDE with a new framework. Linux users were more interested in getting good software on Linux at the time rather than writing more software for Windows, and the binary blob you had to include with Kylix programs was a big no-go in open source (as is the alternate solution of static linking). Now it's 2016. Stack Overflow's survey says that 20% of respondents do their coding on (as opposed to for) desktop Linux. Cross-platform is a requirement today. Valve is pushing developers to release Linux versions of everything. Hell, I'm even writing this on desktop Linux right now. :-) And now we're being offered a Windows-only IDE with an option to cross-compile to Linux server software. :-) Sigh. It's like they always zig when they should zag. Meanwhile, MICROSOFT (whose CEO proclaimed that they "love Linux") will be able to target desktop Linux before Delphi! Argh! &gt;Linux shackes love the zero costs for acquisition, not to mention cutting &gt;edge free dev tools. The existence of Visual Studio Community Edition suggests this doesn't just apply to Linux users. &gt;Lambdas, Generics and parallel is not something they pay for and they &gt;aren't impressed. No argument with that - everything Delphi fans brag about came to almost everything else 4-5 years before it hit Delphi. As noted, even MS will have Linux targeting support before Delphi, which is just wrong. &gt;The only people using Delphi are the people that have been using Delphi &gt;for 20 years. Something the management and some of the most vocal MVPs steadfastly refuse to admit (one MVP arguing this week on the forum that Delphi is "kicking ass" in the enterprise!). However, you're absolutely correct and it drives me crazy not knowing if the management knows this internally or they're deluding themselves. I think for most it's the former but for a few of the most public ones it's the latter. &gt; So I'm confused. Are the customers of these legacy apps, now saying &gt;they are moving their desktop to Linux and want it all retargeted? I doubt it; they're probably still using Windows XP. &gt;Or do the Delphi owners think this will get new customers to pay $1k/seat &gt;licenses? Possibly. The other thing is that critics like me point out things like Delphi being just about the last language on Earth that doesn't run on Linux. I think it's to try to avoid looking like it's outdated in the hope that somebody new will buy it. Another thing is that it keeps existing Delphi developers who see lots of Linux business cropping up from picking up a different tool to target that market. Even MVP Warren Postma has a new Linux/open source blog now in addition to his Delphi one and said it was because it seems that all of the cool things happening today are on Linux. They could be afraid they're going to start losing people because of Linux just as they lost people due to .NET, lack of Unicode, lack of a mobile solution, etc. They simply might not have a choice but to target Linux or stick out like a sore thumb and risk another exodus. 
Read more about this [decades old codegen bug here](http://stackoverflow.com/a/7640979/12597)
Devs have been deploying to Linux using free tools for decades. While it's nice that Delphi might someday join the party, at this point JS has had the educational market for a good 15 years. Developers don't learn Pascal anymore and they aren't taught it in schools. The industry is full of could-have-beens, despite technological reasons. Did us old timers ever really expect JS was anything but a toy in 2005? The world would always be C#, Pascal and Java... until it's not. We are in a post proprietary language world. Current and future development belongs to new languages and frameworks. While I think its great for shops to leverage their Delphi codebase and talent, these are dying resources and Delphi is not something mgrs will dedicate resources toward outside of legacy support. Sad. But true.
Switch to Lazarus (Free Pascal). EDIT: [No *really.*](http://newpascal.org/assets/modern_pascal_introduction.html)
Yes, I think Embarcadero is focusing too much on copy protection and it's inconveniencing legitimate users. The process should be much smoother and less intrusive. The "Embarcadero might go away" thing doesn't scare me, though. 
If you are sooooo concerned about this, create a Windows VM (Virtual Box is free and excellent) and install Delphi 10.1 on it. Create a backup copy and it will probably work forever. Seriously there are thousand of things in my life that worries me, but I have never wasted more than 2 seconds thinking about what to do if EMBT goes out of business. To be honest, I think is easier to MS to blow some technology that lots of people rely on today than your Delphi 10.1 stops working because there is no server to validate it... Really! 
&gt;Kent, I approved you comment even if I consider it more of a rant -- &gt;not against us for once. Marco has been on a hot streak in 2016 of not approving any comments he disagrees with, dismissing them as FUD or rants. Before he worked for Embarcadero, he prided himself on never censoring comments. It's a shame. I'm with /u/boulderdrop on this... my first reaction was "OMG Microsoft mentioned us! Squee!" Seriously, what does it say about your product if your product manager gets excited if a Microsoft account mentions it in a tweet? Unless you're a startup with three employees, this kind of reaction is downright embarrassing. 
You seem bitter. And maybe more than a little biased. I'm not sorry Marco doesn't approve your rants and conspiracy theories. It improves the discourse considerably. You could always try posting more reasonable (and less long winded) comments.
[\*triggered\*](http://i.imgur.com/avHnbUZ.gif)
.dll?
2 spaces. Always! :D
I'm curious, why don't you use node js as rest server to Delphi app ? It will run just fine in Linux
The OmniPascal plugin doesn't come with a debugger nor does it have a bridge to the Delphi debugger since there is no API available for it. So you need to debug inside the Delphi IDE. In case you are using FreePascal there is a way to attach GDB to Visual Studio Code using the Native Debug plugin: https://marketplace.visualstudio.com/items?itemName=webfreak.debug I tried it once (using a pretty early version) and I could get some breakpoints working but I wasn't able to watch variables. I didn't spend much time in investigating about it. Maybe someone else wants to play around with it.
It would be interesting to hear about performance if you try to export 10mln records
[Link to Part 2 of 3](https://blog.grijjy.com/2017/01/11/working-with-big-data-databases-in-delphi-cassandra-couchbase-and-mongodb-part-2-of-3/)
vkW, vkA, vkS and vkD respectively. These are defined in [System.UITypes](http://docwiki.embarcadero.com/Libraries/Berlin/en/System.UITypes).
Well now I feel dumb for not trying it without an underscore. Cheers!
CEF4Delphi is an open source project to embed Chromium-based browsers in applications made with Delphi. CEF4Delphi is based on DCEF3, made by Henri Gourvest. 
Does it work on FreePascal/Lazarus?
I haven't tested it on Lazarus but it's very probable that it will need some minor changes.
I'm glad that you like it. Remember that CEF4Delphi needs windows 7 or newer. Chromium dropped windows xp and vista compatibility months ago.
Man, I hope that job is a great one. It's tough to get *the next job* when spending your time in Pascal.
Cool
I don't know about XE11, but [Delphi 10.1 Berlin Starter edition is available for free right now](https://www.embarcadero.com/products/delphi/starter/promotional-download). They have also published free [Boot Camp](https://community.embarcadero.com/blogs/entry/delphi-boot-camp-september-2016-recap-replays-and-blog-posts) sessions and a [Learn to Program with Starter](https://community.embarcadero.com/blogs/entry/learn-to-program-with-starter) series of posts.
I see, great :)
For the sake of completeness, [C++Builder Starter](https://www.embarcadero.com/products/cbuilder/starter/promotional-download) is also free and has its own [boot camp](https://community.embarcadero.com/blogs?view=entry&amp;id=8715:c-boot-camp-complete-replay). Most of Shaun's videos will still be applicable. edit: *Shaun
Thanks. Will go over the code and try to use. New to Pascal so will likely take me a little bit to go over it and "digest it". Have always wanted to use Pascal so figured an open source pet project is a good start.
Sure man. I should note, these are routines to help read posix style parameters. Like the ones for wget: [c:\temp]wget --help GNU Wget 1.8.2, a non-interactive network retriever. Usage: wget [OPTION]... [URL]... .. .. -a, --append-output=FILE append messages to FILE. -d, --debug print debug output. In these two parameter types, you have a "parameter" (--append-output=FILE) and a "switch" (--debug) Example Usage: if (POSIX_CLI_GetParameter('append-output', sFile)) then writeln(format('sFile:[%s]', [sFile])); if (POSIX_CLI_GetSwitch('debug')) then bWeAreInDebugMode := TRUE; 
Was not planning on using Lazarus until I had to do GUI. Are there features, like parameter handling, that would help to use Lazarus even for a CLI program?
Lazarus is just an IDE, I use it for both CLI and GUI programs. Developing in FreePascal's textmode-based IDE or from the command line isn't my idea of fun. :p Install Lazarus, close the project that is created by default, select "Create a new project", choose "Console application". You get a screen where you can set the application name and title, and set several checkboxes, one of them captioned "Check options". You'll get a program that looks like this: program Project1; {$MODE ObjFPC} {$H+} uses {$IFDEF UNIX}{$IFDEF UseCThreads}cthreads,{$ENDIF}{$ENDIF} Classes, CustApp, SysUtils; type {TMyApplication} TMyApplication = class(TCustomApplication) protected procedure DoRun; override; public constructor Create(TheOwner : TComponent); override; destructor Destroy; override; procedure WriteHelp; virtual; end; {TMyApplication} procedure TMyApplication.DoRun; var ErrorMsg : String; begin // quick check parameters ErrorMsg := CheckOptions('h', 'help'); if (ErrorMsg &lt;&gt; '') then begin ShowException(Exception.Create(ErrorMsg)); Terminate; exit; end; // parse parameters if HasOption('h', 'help') then begin WriteHelp; Terminate; exit; end; {add your program here} // stop program loop Terminate; end; constructor TMyApplication.Create(TheOwner : TComponent); begin inherited Create(TheOwner); StopOnException := True; end; destructor TMyApplication.Destroy; begin inherited Destroy; end; procedure TMyApplication.WriteHelp; begin {add your help code here} writeln('Usage: ', ExeName, ' -h'); end; var Application : TMyApplication; begin Application := TMyApplication.Create(nil); Application.Title := 'My Application'; Application.Run; Application.Free; end.
I've reached a new milestone - or is it tombstone?. This is the first time I've ever searched an online job board and discovered that there is not a single Delphi job listed within *100 miles* of where I live. And that 100 mile radius includes New York City, my state capital, the largest city in my state, etc. In fact, if you check some job boards now (at least in the United States) only a small handful of states have *any* Delphi jobs listed. Right now Dice is only showing 57 Delphi jobs across the United States, and 10 of those are actually for the Delphi consulting firm and almost half appear to not be directly related to Delphi or involve the hotel management software also named Delphi. Meanwhile certain MVPs will continue to insist that the Delphi job market is roaring. :-( 
Trying the code, but getting a number of errors: parse-command-line.pas(5,61) Error: Identifier not found "StringReplace" parse-command-line.pas(9,7) Error: Identifier not found "rfReplaceAll" parse-command-line.pas(11,4) Error: Identifier not found "result" parse-command-line.pas(27,7) Error: Identifier not found "result" parse-command-line.pas(41,33) Error: Identifier not found "UpperCase" parse-command-line.pas(51,38) Error: Identifier not found "UpperCase" parse-command-line.pas(65,4) Error: Identifier not found "result" parse-command-line.pas(68,119) Fatal: Syntax error, ")" expected but "=" found Fatal: Compilation aborted &amp;nbsp; The entire program I am trying is like this: program parse_program; function POSIX_CLI_EscapeParameter(sParameter : AnsiString) : AnsiString; begin sParameter := {$IFDEF UNICODE}System.AnsiStrings.{$ENDIF}StringReplace( sParameter, AnsiString('"'), AnsiString('\"'), [rfReplaceAll] ); result := sParameter; end; function POSIX_CLI_GetParameter(sNeedleName : AnsiString; var sNeedleValue : AnsiString) : boolean; function _StripPrefix(sValue : AnsiString) : AnsiString; begin // *** 2014-05-07: This is LAME, but I need to strip the PREFIX from the NEEDLE as well // *** This is a result of making the PREFIX be one of two values and is checked against the ParamStr(x) // *** but I have legacy code that sends the PREXIX in for the Needle too (UACADMIN), so we are going to strip // *** it from the Needle too if (copy(sValue,1,2) = '--') then sValue := copy(sValue, 3, length(sValue)-2) else if (copy(sValue,1,1) = '-') then sValue := copy(sValue, 2, length(sValue)-1); result := sValue; end; var bResult : boolean; idx : integer; i : integer; sParamFullStr : AnsiString; sParamName : AnsiString; sParamValue : AnsiString; begin bResult := FALSE; sNeedleName := _StripPrefix(UpperCase(sNeedleName)); sNeedleValue := ''; for idx:=1 to ParamCount() do begin sParamFullStr := ParamStr(idx); i := pos('=', sParamFullStr); if (i &gt; 0) then begin sParamName := _StripPrefix(UpperCase(copy(sParamFullStr, 1, i-1))); sParamValue := copy(sParamFullStr, i+1, length(sParamFullStr)-1); if (sNeedleName = sParamName) then begin sNeedleValue := sParamValue; bResult := TRUE; BREAK; end; // *** if (sNeedleName = sParamName) then end; // *** if (i &gt; 0) then end; // *** for idx:=1 to ParamCount() do result := bResult; end; function POSIX_CLI_GetSwitch(sNeedleName : AnsiString; const sMatchAgainstThisStrInsteadOfLoopingParamStr : AnsiString='') : boolean; var bResult : boolean; idx : integer; sParamFullStr : AnsiString; begin bResult := FALSE; sNeedleName := UpperCase(sNeedleName); // *** 2014-05-07: I know this is retarded, but when I come back through to add switches that match the sister function above, I can apply the same str-logic if (sMatchAgainstThisStrInsteadOfLoopingParamStr &lt;&gt; '') then begin if (sNeedleName = sMatchAgainstThisStrInsteadOfLoopingParamStr) then bResult := TRUE; end else begin for idx:=1 to ParamCount() do begin sParamFullStr := UpperCase(ParamStr(idx)); if (sNeedleName = sParamFullStr) then begin bResult := TRUE; break; end; end; end; result := bResult; end; {---------- main ----------} begin if (POSIX_CLI_GetParameter('append-output', sFile)) then writeln(format('sFile:[%s]', [sFile])); if (POSIX_CLI_GetSwitch('debug')) then begin bWeAreInDebugMode := TRUE; writeln("We are in debug mode"); end; end.
Looks like you need a uses clause for those. I haven't used FPC in a long time. In Delphi it's sysutils for most of those. The error for result must be something odd too with FPC, look at the docs for returning values from functions. Maybe it's just replacing result with the function name.
Just leave out the -T. I don't remember what's the cause of this, but the warning about "did you forget -T" is one you can safely ignore. Also has nothing to do with Ubuntu. I see the same on Arch, and I even recompiled FPC from sources (I need to cross-compile to Windows). 
Ditto. Seattle has 1 (one) posting. It's a consulting firm. Honestly, I think the whole paradigm of desktop software is in it's twilight days. I know, going out on a limb. /s The market is not there for Pascal. Shoot, even in the web world, server side rendering (PHP) is falling fast. If you want to remain relevant, pickup JS, Scala, Python, even Java has lots of life still. Fucking JS is starting to become the language to rule them all, used in front and backed development. JS is taught in every college, kind of like Pascal 20 years ago. The only place you'll find a Pascal job, is working on a crusty legacy system with 20 years of dev in it. If you want to camp and sit there until you retire, that's great. But you'll never find another job using Delphi. Sticking with Delphi? That's cool. Cherish your obsolescence and don't rock the boat.
RE: return values. It's been a while, but I believe the original PASCAL specs used &lt;function_name&gt; := VALUE. I think Delphi extended it by using "result", which IMHO is much better when refactoring. I believe there's a FPC parameter to use the Delphi personality, like -sD or something. RE: Error: Identifier not found "sFile" The "sFile" is the result of not having a "var sFile : AnsiString" defined after the main::begin. Sorry, I didn't really make this compile-able for you, didn't realize you are just starting out. Out curiosity, what makes you want to do anything with Pascal? Honestly, I'm only here still because I have a bunch of stuff written over the past (literally) ~20 years that pays the bills. In Node.JS, you can make a webserver that returns information in just a couple lines of code. Pascal and native code is just so much more work, compared to modern paradigms that use run-times and big frameworks. Don't get me wrong, I love compiled binaries and hate run-times.. but I think GoLang is going to surpass anything Delphi could do in the backend. In Seattle, there's only one job using Delphi/Pascal. 
&gt; Out curiosity, what makes you want to do anything with Pascal? Honestly, I'm only here still because I have a bunch of stuff written over the past (literally) ~20 years that pays the bills. In Node.JS, you can make a webserver that returns information in just a couple lines of code. I am a Postgresql DBA/Sysadmin. Often use python for that work. Have a few, very low priority, tasks I need done and I find Pascal fun. Just something to play around. Ultimately will get something productive out of it, but just didn't want to do it on python. Also for my use case, small utilities to be called from shell scripts, been able to compile in one version of Linux and be able to deploy to others is nice. Also will test later cross compiling to FreeBSD. In short.. this is not related to anything that will make me money. Just something to learn for fun, but that will create small utilities that I will use at work. &amp;nbsp; As an example my first project is a shell script helper to control when alerts go out. Have lots of shell scripts in cron that check a condition; when there is an error an email go out. If check is in cron every minute.. or every few minutes that can quickly send lots of emails (specially if this is running from multiple machines). So I am creating a run_control utility to have things like: Don't run more than X times per hour.. or run X number of times and create a flag file that needs to be deleted before we can send notifications again. Fairly simple stuff. &amp;nbsp; [edit] Another benefit for my planned use case (small utilities) is not needing to worry about required libraries. In python I can be productive, but may end up having to use a number of libraries so have to deal with getting those libraries to the machines where the program will run. With pascal it will be just push the binary and call it a day...
Thanks. I am getting programs compiling, just that kept seeing that error. As /u/nicky1968a pointed out seems like a known issue in FreePascal. Seems one gets that error regardless.
&gt; In Seattle, there's only one job using Delphi/Pascal. That may be true, but one could always try to find a job remote. Saw another thread where multiple posters were literally asking for anyone that knew Delphi developers to contact them. So sure there may not be a lot, but there are. &amp;nbsp; I moved from NYC to Pittsburgh a few years ago. There were so few jobs on what I do, Postgreql and sysadmin for Ubuntu/FreeBSD, that it was actually easier to find work remotely.. eventually an ex co-worker got me a remote consulting referral and after 3.5 years the company (in NY) hired me. I am still in Pittsburgh.. So, sometimes there may not be a job where one is, but if one can find a company to work for remotely that needs one skill.. it is doable. Specially my impression is that companies that use Delphi seem to be pretty loyal to it. I did a little bit of Delphi years ago (pretty much forgotten the little I learned so may as well be starting from scratch). What I do recall is that I really enjoyed working on it.
 POSIX_CLI_GetSwitch(.., const sMatchAgainstThisStrInsteadOfLoopingParamStr) Sorry, that's a hack. You can pass an empty string to it, '' or just remove that argument and the if() in the code. It was a hack I made to support a legacy program that utilized that function.
It's called FPP = FreePascalPackage ... No just fun, there is no installer i think but you can include the necessary units you have downloaded from the internet. If there a any left ^^ ...
&gt; In python I can be productive, but may end up having to use a number of &gt;libraries so have to deal with getting those libraries to the machines where &gt;the program will run. With pascal it will be just push the binary and call it a &gt;day... As someone who is moving the opposite way from pascal to python :-), the flip side of that is that libraries simply don't exist to do what you want to do in pascal and then you have to write them yourself. 
22 years of Delphi and it's still rocky.
&gt; The other things I noticed is that most of the other tools that were popular &gt;back than, have long been forgotten. Delphi, on the other hand, is still &gt;popular. The Borland Bubble is stronger than ever. I think I'll submit this to /r/programming and see if they agree that Delphi is still popular.
Have you tried downloading it? That is one painful website to use. It says you can use one letter for your name, then throws you out claiming invalid name!
It's legacy. * The IDE still accvio's. * Refactor Find Unit fails more often than works. * FMX is broken - how do you add buttons to a toolbar with actions without text? * FMX is broken (2) - the toolbar looks different on Mac. VCL seems reliable but FMX? Going the way of Kylix? I can see Delphi has added helper classes, anonymous functions, tasks... but still, var stuck in the header of function/procedure? Everywhere I go people remember Delphi and ask the same question - isn't it dead yet? Look at the fansites, half of them have long gone or just stagnant. I've based my career on C# and C++ they're still going strong. Rarely do I see Delphi now. And if it is there, people want to move away from it.
&gt; var stuck in the header of function/procedure? Some people *like* it, y'know...
I've still got my copy stashed away somewhere. I remember it being about $90 at Electronics Boutique. Amazing software for the time. Blew VB3 right out of the water.
Yes. I used my EDN account. One click and I was downloading.
If you like that, you'll love [what they have added since](http://docwiki.embarcadero.com/RADStudio/Berlin/en/What's_New). I continue to use it every day.
And [others have popped up](https://plus.google.com/102570002721714768273/posts/XiWXMmeM9gW). In addition to the (now) free SKU, there is a lot of [free training](https://community.embarcadero.com/blogs/entry/delphi-boot-camp-september-2016-recap-replays-and-blog-posts). C# is a fine language. I feel no need to tear it down in order to enjoy (or profit from) Delphi.
If I could afford it, I'd buy it. :) For now, Lazarus fills the void. 
Speaking of [FireMonkey,](http://docwiki.embarcadero.com/RADStudio/Seattle/en/FireMonkey_Quick_Start_Guide_-_Tutorials_-_My_First_FireMonkey_Application), people are doing [some interesting things](https://community.embarcadero.com/blogs/entry/cool-apps-niagara-falls) in the real world. It's come a long way since it was first introduced. Embarcadero had a webinar [comparing the features of FireMonkey and the VCL](https://community.embarcadero.com/blogs/entry/firemonkey-vs-vcl). And I get a real kick out of the [videos put out by the Quark Cube guys](https://www.youtube.com/user/QuarkCube).
Here's the other presentation I was looking for that talks about new features that have been added and others that are in the works. [Modernize or Become Extinct](https://community.embarcadero.com/blogs/entry/modernize-or-become-extinct-webinar-replay)
I've got Delphi Starter and the C++ Builder Starter. They're still pulling the shenanigans of only allowing one or the other to be installed at the same time. It's not like someone is going to be developing anything super serious with the Starter Editions due to their limitations. They did the same thing with the old Turbo Explorer products as well. Seems a little silly.
I absolutely agree that Delphi is very popular with him (I'm a professional Delphi programmer and he spends more time in Delphi-related forums than I). In the old days he used to hang out with his dear friends Delphi haters, but now that that psycho has disappeared (?), he feels lonely.
Now I realized that Joseph answered EACH one of all new posts (not answers) in a 100+ thread (22 Years of Delphi and it Still Rocks). Man... this is pathetic, really. The guy spent hours and hours badmouthing Delphi... Joseph, tell me honestly: David I. did something very bad to you, didn't he?
Some YouTube resources: [Learn Delphi YouTube Channel](https://www.youtube.com/channel/UCFZxawRN6quppxog_L0LjNg) [Shaun Roselt's YouTube Channel](https://www.youtube.com/user/shaunroselt/featured) [Alister Christie's YouTube Channel](https://www.youtube.com/user/codegearguru) [QuarkCube](https://www.youtube.com/user/QuarkCube)
I am converting legacy code from COBOL to Delphi for my internship. 
\&gt;:(
Yes lol
Thank you, very helpful. 
Delphi is the development environment with text editors, debuggers, visual design tools, and the like. Object Pascal is the language of Delphi. Delphi's version of Object Pascal is Pascal, but very extended with extremely powerful object oriented capabilities, and a component architecture allowing for very powerful "Rapid Application Development" (or "RAD") capabilities. If your goal is to learn Delphi, then I would look for Delphi specific books and tutorials, and not books on ordinary Pascal. Vanilla Pascal, while useful, is the ancestor on which Object Pascal was built, but is only a subset of Object Pascal. So whatever books you get, in order to use your time most efficiently, I would make sure they are Delphi specific. [The Object Pascal Handbook by Marco Cantu](http://www.marcocantu.com/objectpascalhandbook/) is quite excellent. There is some kind of promotion (at least there *was* some kind of promotion) to get the PDF version of that book for free somehow through Embarcadero when you buy Delphi or something like that. It's also worth paying for directly. Note: Marco Cantu has a few books available for free download from his web site, so be sure to check those out. [For example](http://www.marcocantu.com/edelphi/default.htm). Explore around, as there may be more. Don't forget about the help screens and documentation that comes with Delphi. I'm not sure what all comes with it these days, but back in the Delphi 2 days, Delphi came with a set of books that were quite excellent. Maybe in the digital download world we live in today that is no longer the case(?) Some good websites to start learning from: * [Delphi Basics](http://www.delphibasics.co.uk/) - Some beginner tutorials, and great references * [delphi.about.com](http://delphi.about.com/) - Good spot to find tutorials on how to do various things * [Official Embarcadero Forums](https://forums.embarcadero.com) - This is a good spot to ask questions, that could use some beginner questions. 
That book is a good one for Delphi.
For me personally, it is a mix. My primary use for Delphi is maintaining a suite of legacy applications with an enormous codebase. However, if I need to do something quick, like a utility, I still generally prefer Delphi because it is so fast and easy. For giant projects from scratch, I'm using C#, mostly because they involve more than one developer (C# developers are easier to find), and may involve libraries and such that are easier to integrate in the C# realm due to its popularity. For the rest of the world, here is an interesting ranking. [It looks like Delphi is gaining back some ground.](http://www.tiobe.com/tiobe-index/)
Nice. I used Delphi briefly in high school 20 years ago when we learned Turbo Pascal, but never looked at it again. Also, those ratings are yet another reminder as to why I should probably stop avoiding JAVA.
&gt; It looks like Delphi is gaining back some ground. [If you put any stock in this kind of thing](http://glooscapsoftware.blogspot.ca/2017/02/delphi-programming-index.html). :)
Interesting. I'd love to know what they are using and how they came to the decision. I'm kind of a novice at web applications, but I have used DataSnap REST servers in a handful of projects that require an application server (multiple client applications) and also happen to have a web front end. It handles moderate web traffic pretty well. If I ever needed to scale up, I would probably have a third party web application handle the front end and make calls directly to my application server's API. Good luck.
*Shaun :)
Also have a look at this app, Delphi Programming Helper: https://developer.microsoft.com/en-us/dashboard/apps/9MTRD2PTBVCP
Whups, my bad.
There are many online tutorials, but nobody will be able to help deciding what to write your program about. Suggest you decide first on what you want the program to do and only then try to figure out how. Look for Delphi video tutorials to get you familiar with the environment and the language.
I've posted this a couple of times, but the [Delphi Boot Camp](https://community.embarcadero.com/blogs/entry/delphi-boot-camp) is a good starting point. Note that the [Delphi Starter edition](https://www.embarcadero.com/products/delphi/starter/promotional-download) is available at no cost. What course is this homework for?
Just tried it under Berlin 10.1 and it still took 6 minutes. I then installed Andy's IDE Fix pack and the compile time dropped to 50 seconds. It's amazing Embarcadero still hasn't integrated his speedups into the core IDE after all these years. 
this looks really cool, I'll look at it in detail once I get home from work.
Pascal has this weird rule that every line should be terminated by a semicolon UNLESS it's the last line in the procedure. It's been there as long as Pascal has been a language. I've always thought it weird.
In other languages, semicolons are statement terminators. In Pascal, they are statement separators, so they are not required for the last statement of most blocks.
you create a new Form with two panels, one left aligned, one client-aligned, on the left aligned you place a TTreeView and on the right one a TPageControl. the object inspector should allow you to customize the TTreeview and the checkboxes you have to add yourself. personally I'd add for each treeview menu-point a new class. either each class creates everything on the TPageControl or each class is just another Form which you design and call the create-function from the "Everything Options"-form. just remember that you have to set the Parent property whenever you create a visual-component at runtime and also set the Owner-Property so that the memory the components occupy is released after the form is destroyed. if you need any help just write me, as I can see that OOP in delphi may seem intimidating when one has little experience with it yet. otherwise google will give you tons of answers to practically everything delphi. I also often find myself posting questions on Stack Overflow and get responses in no time.
Thanks, excellent info from you and boulderdrop. I am really trying to learn the intricacies of ObjectPascal and I can kind of fumble my way around, but I can't seem to find any reference to help me learn proper coding. I've found a bunch of books on Delphi but 90% of them are geared toward RAD and dealing with the IDE. I can't seem to find any good videos either. If you have any suggestions on how to learn coding I'd really appreciate it... stuff like constructing proper object oriented code, etc. I know I can just jump in and write code, but I've done that (I've written tons of code) and I'm sure I have a mess of poor coding practices.. I'm not learning anything that way, and I am totally lost when it comes to building classes, inheritance, and so forth. This is one of those things that makes me want to bail on Delphi and go to Java or some other language where there's more complete ground-up learning resources.
&gt;and even the .net framework is built on top of delphi. The .net framework is not "built on top of Delphi". There's no Delphi code in .NET. 
both developed by the same person. with a lot of similarities. "on top of" here means more that Anders Hejlsberg took his knowledge and expanded it with the development of .net. probably copied a lot of his work over too.
[Embarcadero Quality Central](https://quality.embarcadero.com) might be what you are looking for. I have one issue where I get an exception error on exit, if I happen to use a particular 3rd party component. Otherwise, in my personal experience, Delphi has been quite stable. I use it every day with multiple complex and gigantic projects. I'm using Delphi 10 Seattle. Before that I was using XE8 and Delphi 2006. 
The downside of that site is: - it's behind a login well - you can't attach code or screenshots - they deleted all their decades old outstanding bug list when they moved to a new tool - it's where bugs reports go to die Bugs from Delphi 4 still present in Seattle. They're as bad as the Microsoft forums for closing unfixed bugs.
And several of us showed him why his charts were inaccurate so he deleted all of our posts, added a few disclaimers, and never remedied the charts. Principally he lumped in "duplicates", "can't reproduce" and "won't fix" in with legitimate bugs - and there were a LOT more of those than actual bugs. When you factor those out of his chart of bug closures the results are significantly different. 
&gt; and have revamped their academic program This was a good move that came way too late though. Now open source is huge in academia, so free software doesn't really mean what it used to. That's in addition to the fact that kids today are using tablets and MacBooks a lot more than Windows PCs, which is all Delphi will run on. Chromebooks even [outsold the MacBook last year](http://www.theverge.com/2016/5/19/11711714/chromebooks-outsold-macs-us-idc-figures), principally driven by academic sales. The entry level training on the other hand can still be effective.
&gt;Lots of goodies for people doing server side work. But a lot of it... well, is stuff that should have been in there in the first place, such as &gt;The Clang-enhanced Win32 and Win64 compilers support -O3, a strong &gt;optimization level which may double compiled code performance in some &gt;situations You mean it *didn't* support O3?!? You could download a free version of Clang that compiled faster than the expensive Embarcadero version? If that's accurate, I... I don't know what to say. &gt;Packages on iOS and Android, which are statically linked, are built with the &gt;correct .a extension instead of .so Again... I'm left speechless... why would you **brag** about this on your web page? I'd bury that in a release note file! Similarly with &gt;... the linker is now large address aware and has been modified for current &gt;linking usage patterns, which should solve all linking errors.... &gt;Exception handling memory leaks and odd behaviour has been reworked &gt;and significantly improved It's the same with Interbase 2017... absolutely nothing that wasn't in other databases (including free ones) 10 years ago, yet they want $7000 for a server version.
Disappointing to see Linux support only available in Enterprise! I was hoping Pro to get basic Linux support for building command line applications while Enterprise would get additional Linux support for database/server features. 
Troll posts are often removed. Don't take it personally.
http://wiki.freepascal.org/Lazarus_For_Delphi_Users http://www.freepascal.org/docs-html/prog/progap4.html#progse62.html ;)
Happy to see that you are still hanging out in Delphi forums. I don't use Interbase much, but I think you're painting a deceptive picture. Anyone who is interested in the actual [feature list](https://www.embarcadero.com/products/interbase/features) and [feature matrix](https://www.embarcadero.com/docs/interbase-feature-matrix-xe7.pdf) for themselves. If you want a database on all the platforms that Delphi now supports (Windows, Mac, iOS, Android and now Linux), your options are Interbase and SQLite. SQLite has some quirks, too. You aren't going to camp out on SQLite forums and trashing it at every opportunity, are you? Because that would just be weird. For embedded work, [IBLite](http://glooscapsoftware.blogspot.ca/2014/10/rad-studio-xe7-stealth-feature-iblite.html) is free on all platforms. I keep procrastinating, but I might have to give it a try.
Do you have a virus scanner running? Ours prevents me from running the license manager. I had to temporarily disable it.
You've never bet on a horse race, have you? :-) It doesn't matter how fast your horse is going except in relation to the other horses in a race. This move came too late to have the impact it could have had. Another example is Mr. Bauer talking about adding language-level parallel programming enhancements for over eight years (and the CEO also promising at the first Code Rage after EMBT acquired CodeGear). Had they actually delivered this in the time frame they suggested they would have anticipated Google Go by several years, opening up a significant niche where Delphi would have been demonstrably superior. Now even if they were to deliver this today, Go already has the mind share (and library share) and no one would really care. Advancing towards a goal that no longer matters isn't progress, e.g. finally adding OS/2 support. :-)
I understand Virtual machines, but it seems to me that Delphi could have bundled QEMU and a minimal Linux image, or a container, and done all of this in the background. It also had the option of deploying and configuring Cygwin. On top of that, LLVM according to its own documentation is designed for cross-compilation by default, so this shouldn't even be necessary. 
+1 to this, also worth noting is if OP is using Windows 10 Pro/Enterprise then Hyper-V is built in (just enable the feature).
Is there panels, that can be aligned top, bottom, left, right? Is there splitters, and a list-treeview? I've been waiting a decade and a half for people to invent a widget library for the browser. Asm.js helped get away from JavaScript. WebAssembly helped move towards fast libraries. Canvas helped move back to pixels. But the web still has no widget library. Even a grid with a header would be **something**
&gt; I've been waiting a decade and a half for people to invent a widget library &gt;for the browser. Pardon my ignorance, but aren't there many such libraries? http://webix.com/ https://jqueryui.com/ https://dojotoolkit.org/ http://www.jqwidgets.com/ 
Very interesting. I'll try this then. Thanks!
Linux target only available with Enterprise?
So far. There's a [QP report](https://quality.embarcadero.com/login.jsp?permissionViolation=true&amp;os_destination=%2Fbrowse%2FRSP-17195) that people can vote for. 
Thank you, kind stranger. I'll try it once I am back from the long Eastern weekend.
Single quotes, not double.
If you assign a string: Yes. But this seems to be FastReport which has its own syntax when used inside an edit control as a source.
Is that Ctrl+Shift+C? I know Ctrl+Space works inside of the type class declaration
This is a really bad idea; logging would be much better. 
This was incredibly detailed and helpful. Thank you for taking the time to write it and respect to you sir. Looks like Delphi is what I'm gonna be using.
I plan on soon making a whole video series where I will be promoting the free Starter Edition quite a lot.
Without feeling the need to beat up on any other development tools, I think Delphi is very worth while today. It has been and continues to be the primary tool that I use in software development and consulting. On top of a very productive and usable IDE and really fast build times (under-rated feature), the real killer features, imho, are the very clear and readable language syntax and the high degree of source code compatibility, not only between versions of the compiler, but for (mostly) single source projects across multiple platforms. In my experience, this makes Delphi projects very maintainable as they grow and evolve. If you decide to dig a little deeper, here are some [resources to get you started](http://glooscapsoftware.blogspot.ca/2017/04/getting-started-with-delphi.html).
I think you should make a research of work market to find it out. At my parts learning Delphi doesn't makes a lot of sense. New projects aren't started in Delphi novadays here and salaries aren't as good as in projects in other languages. UPD: It's actually pretty tough to find a job as Delphi programmer here.
Every day I work in Delphi I wish I wasn't.
Some of this may be the state of our projects specifically, but some grievances: - The basic design of the IDE encourages spaghetti code. It trains you to put all your logic into the form(view). There are recent pushes to encourage MVVM architectures, but the IDE itself doesn't appear to give you any help in this. - The component/library design is terrible. Libraries install into the IDE instead of living in the project, so they don't go with your source control and rebuilding your dev environment takes 3 days. - The first party components are terrible, so you will have to use a lot of 3rd party libraries, exacerbating the point above. - Now that you rely on 3rd party components, upgrading delphi becomes a larger nightmare because you have to buy new licenses for all your libraries. And because they don't live in the project, they live in the IDE you really do have to pay to upgrade them, even if there is no new functionality. - You have to use a lot more paid libraries. The Delphi community does not have nearly that same access to quality, documented open-source projects the way most languages do. - The 3rd party component documentation also tends to be pretty poor. - The community is much smaller than many other languages, so getting help is harder. Also, the help you do get often is very condescending. the most knowledgeable guys out there are delphi old hats that are not very helpful to people who are trying to get to know the system. - But again, the design of Delphi doesn't encourage good coding techniques. I spend a lot of time trying to figure out how to cleanly separate view, logic, and database layers, but when most of the useful components just have you hook a database field directly to a form input, it's really hard to do that. The problem also tends to propagate into 3rd party library hell. - And why the hell does a data-aware checkbox component fire it's onclick property when it's attached data changes, rather than only when it's clicked? As it is, it fires when you need to change the data programmatically, which fires its onclick event, which was only supposed to fire when the damn thing was clicked.
I guess that depends a lot on what he's building and what platforms he's targetting. I do a lot more work in web languages, php or python, that aren't really comparable to delphi. I've only used a little bit of C# in school, but it was enough I wish I could explore it more. 
This should be looked at closely. There isn't a market for Delphi in Seattle or the entire state either. It's all legacy development. The current updates are focused to leverage existing codebase with REST and mobile implementations. Great idea and a sound use of investment, but almost no one performs new development in Delphi. Pickup mean.js or python or golang or Scala or AWS certs.
Oh, and you don't need to use data aware controls (but if you do, put the datasets in a data module). You could always use [live binding](http://docwiki.embarcadero.com/RADStudio/en/LiveBindings_in_RAD_Studio). Edit: fixed link
How would you use live bindings to attach a control to an object property?
&gt; How would you use live bindings to attach a control to an object property? Not sure. I was suggesting an alternative to data aware controls which you mentioned in your comment.
FYI, you posted this as a top-level comment instead of as a reply to whomever you were trying to reply to.
Wide Orbit has been steadily reworking the product. They haven't had a Delphi position open in a while.
I've interviewed twice, got offered a job twice. Both times, I bailed due to new development going to C# (first time) and MVC (second time). They are siloed development and didn't really cross polinate. I wanted chances to do non Delphi sometimes. WO​ Traffic is Delphi based. But several new products aren't. There's also a push for growth NY. Their object framework for traffic is 30 levels deep and said it would take a year to get my head around it. It was also a lot of MS sqlserver tweaks and remote support for installs. It's legacy if there ever was one.
All new development or some projects?
What do you mean?
And here are some resources to help [get started with Delphi](http://glooscapsoftware.blogspot.ca/2017/04/getting-started-with-delphi.html). Including a couple of free online boot camp replays.
&gt;On top of a very productive and usable IDE Bruce, the Code Insight/intellisense/whatever has been broken for years and it's the only IDE on planet Earth that doesn't let you make your own key bindings. We have MVPs on Google Plus telling tales of how many times per week they had to shutdown/restart the IDE (before the memory fix, approximately 8 times a day!). We were the last IDE in existence to get Git support, and even then it's only partial. MS implemented full Git support first, and they make a commercial VCS. What are you comparing it to? What is less productive and unusable for you? &gt;and really fast build times (under-rated feature) Over-rated feature. In the modern world you have continuous integration, build farms, etc. It's a fast build because the compiler is notoriously single-pass and unoptimized. I can speed up slow build times with faster hardware. I can't speed up slow development time by upgrading humans. &gt; are the very clear and readable language syntax Compared to legacy C++, definitely. But nowadays many languages have begun to add modern readability features that Delphi itself is lacking. This article covers some of them: http://preshing.com/20141202/cpp-has-become-more-pythonic/ Delphi only has two of them, range-based for loops and (to some degree) parameter packs. I did some checking of other languages not covered by the article and it turns out that C#, Oxygene and D also offer every feature listed. &gt;and the high degree of source code compatibility, not only between &gt;versions of the compiler, but for (mostly) single source projects across &gt;multiple platforms. Delphi continues to lack some basic cross-platform functionality, such as spawning a process. This continues to be lacking in Windows-only VCL as well. You need to use IFDEFs and low-level OS-specific functions to do something as simple as launch a PDF in the default PDF viewer with FireMonkey. Again, either self-contained languages like Java or cross-platform frameworks like Qt offer better cross-platform functionality. Even Free Pascal has a set of four or five high-level functions for spawning processes across platforms. IMHO statements like these don't mean much without something to compare them to. The reality is EMBT is selling a buggy and feature-poor IDE (20+ years without an undo feature in the visual designer?!?) and a language that is very much behind the times (lack of type inference particularly; no new statically typed language released in the 21st century has omitted it and it's been available since the 1980s) at a very bespoke price. Functionality taken for granted in modern languages, such as documentation generation, logging, stack traces, etc. are omitted from the standard library and need to be accumulated via a hodge-podge of commercial and open source third party libraries. EMBT has a package manager with no web page (also something rather unique), also feature-poor, that has barely a hundred libraries, half being "Internet Of Things" drivers. The package manager is still curated by hand and excludes anything arbitrarily ruled to "compete" with EMBT products, including the popular Mormot framework. This makes it useless for dealing with package dependencies. How this makes it easy to maintain I have no idea. Half the Delphi developers out there seem to use VMs for each project because, as noted by OP, third-party libraries are installed in the IDE and the IDE is unstable and the language may change at any time for any reason. 
Wow. That's long. And has a certain amount of [exaggeration](https://www.reddit.com/r/programmingcirclejerk/comments/1xz0da/epic_delphi_rant/). Do you have any details on the IFDEF for launching PDFs and why you think it's bad?
I'm not sure how this reply actually has any relevance to anything I wrote. You'd think if something was "demonstrably not true" one could... well... demonstrate it. 
Ok, it's hot, it's Friday, maybe I'm missing something.... I replied to your post. The subject was the prevalence of Delphi in industry. The issue of the "boot camp" school phenomenon was brought up. You replied with a link to a general list of Delphi resources. That has nothing to do with Delphi in industry, how it's demonstrably untrue that companies are not developing new software with Delphi, or anything else. Sticking the term "boot camp" on a series of videos Embarcadero stuck on YouTube has nothing to do with the emerging trend of for-profit (physical) schools springing up to teach skills that are so hot they're guaranteeing a $50K-$100K job offer or they'll refund tuition or in one case let students attend for free in exchange for 10% of their new job's salary for one year. Is Embarcadero promising people jobs who watch their videos for five days?!? Can anyone get hired after watching Delphi videos for five days? If you have examples of *that*, then that's indeed amazing. Nothing on the Embarcadero page suggests either of these things though. Also, what question are you referring to? The post I just replied to didn't contain any question marks. &gt;And here are some resources to help get started with Delphi. &gt;Including a couple of free online boot camp replays. What question did I miss? 
Long again. Not to be confused with insightful. That first link doesn't link to anything. Your "two companies" statement remains silly.
&gt;Long again. Not to be confused with insightful. Someday I'll remember that we play a game like Lucy, Charlie Brown and the football, where I always think you're willing to have a meaningful dialog and then you snatch it away after I've wasted a lot of time. &gt;That first link doesn't link to anything. The link to the post or the link to Stephen Ball's blog which is the first link of that post? They both work for me. &gt;Your "two companies" statement remains silly. I consider myself humbled by your deep insights and intelligent, fact-based rebuttal. 
Did you respond again, Joseph? I see a notice for a new message, but Reddit shows nothing there, which only seems to happen for your messages.
So Delphi product development is ongoing and even growing? Nice.
It's an interesting juxtaposition... open hardware and closed software. 
Right back atcha. I also use Delphi (and other tools) every day. A lot of my projects are either new development or migrating existing Delphi projects to the latest version of the compiler as the next step towards continued development. Life is good. You seem to be bitter about your circumstances and take every opportunity to demonise Delphi. And I genuinely feel for you. My experience leaves me more optimistic, and I think my perspective is at least as valid as yours. And if you're of the impression that I never complain about Delphi or Embarcadero, you would be completely wrong. I just try to do it in places where it will have an impact. You buy the drinks, and I'll tell you some stories about it...
I don't suppose you'd be willing to tell us what this successful software is? I can't remember if you mentioned it before or not. If you would rather not, I won't give you grief over it. I don't necessarily release details on all of the projects I work on, either.
It's like some of the posts here have gotten out of sync; My permalinks work for me but not if I'm not logged in. The link you gave to one of your posts failed to show up for me the same way. I pasted my reply onto another site; hope this link to it works: https://markdownshare.com/view/a9c04137-9591-4fac-b847-3f75e303dabd
Are you sure that's what they are doing?
I'm not the only one calling you a troll, Joseph. All of the people deleting your troll posts on other forums are, too. So give it a rest with the victimhood. And I'm not sure the IFDEF thing is as terrible as you make it out to be. Maybe you could make a QP report.
Well, for an absolute beginner, it's still a pretty relevant book.
&gt;A significant piece of Disney's infrastructure uses Delphi. I'm not taking anything away from Mr. Konopka's work or his programming skill. But if we're looking for a major bragging right, I don't think it would be found in a kiosk at an amusement park. I have little doubt that Disney's Director of IT would be unfamiliar with Delphi. Disney isn't sponsoring CodeRage, is it? Walt Disney Animation Studios *have* sponsored PyCon. In fact, come to think of it, no one not hawking Delphi components has ever sponsored CodeRage. ;-( That's the kind of thing I'm looking for. In the past, PyCon has been able to get a physicist from CERN to talk about using Python in the hunt for the Higgs Boson, a scientist to talk about using Python to do genomic analysis in the hunt for a cure for cancer, a geologist to talk about a major energy company using Python to hunt for oil, the founders of Raspberry Pi to show up (and give everyone in attendance a Pi!), had a group of commercial humanoid robots from Aldebaran Robotics perform a dance number programmed via Python to open the convention, etc. Oh, and there was even a 15-foot autonomous blimp with Python AI! We haven't had that kind of fun since Jim McKeith taught us how to write Unreal Tournament Bots in Delphi back in the 1990s. Python even has a 34-page glossy brochure which features everything from CERN and an ESA Mars rover mission to One Laptop Per Child, aerospace and finance companies, to Lucasfilm and Industrial Light and Magic. So far all you've given me is a bunch of worn out freeware utilities from the 1990s like the launcher from PortableApps.com and an amusement park kiosk. We live in an era with self-driving cars(Tensorflow - C++ back end, Python front end), a space station (PostgreSQL) and high frequency trading. Python can point to Instagram, a company whose product was written with Python and which was bought for one billion dollars, YouTube (at least before Google bought it, all Python) and Reddit (Python and PostgreSQL). We've got Marco Cantu's blog page and the front end for WIndows Skype (which, while not Delphi's fault, is such an annoying UI it's even been mocked in Dilbert). We're in dire need of examples of mainstream commercial success. I'm reminded of the time the EMBT web page tried marketing FireMonkey and had to resort to highlighting a one-man company in Ukraine whose main product, a Windows 8 start button replacement, was free. Worse, they even stuck stock photos in place for the highlighted developers with no attention to ethnicities. That's how I discovered they were stock photos - I was less interested in the start button than in how a black man ended up with a Russian surname and living in Ukraine. A bit of Google Image search later and the sad truth was revealed. :-( Post-Borland Delphi marketing (Borland introduced Delphi with indoor fireworks!) has been a comedy of errors unfortunately. They don't seem any more willing to spend money on talented marketers than they are in spending money on talented developers. 
&gt; I'm not taking anything away from Mr. Konopka's work or his programming skill. Of course not... Just like you would never dismiss software that is still being developed and updated as "worn out freeware utilities from the 1990s". Or misrepresent Disney's EasyPass system as just "a kiosk". I'm happy to see Delphi still igniting such passion. Pace yourself, though. Lots more to come.
I swear we're all masochists. &gt;StrToNSStr(lURL).stringByAddingPercentEscapesUsingEncoding(NSASCIISt &gt;ringEncoding); Are you kidding me?!? We're getting into [Java territory](http://www.javafind.net/gate.jsp?q=/library/36/java6_full_apidocs/com/sun/java/swing/plaf/nimbus/InternalFrameInternalFrameTitlePaneInternalFrameTitlePaneMaximizeButtonPainter.html) with method names like that! And that's not even getting into the manual URL building and other nonsense. For thousands of dollars, this just isn't acceptable. The Firemonkey code Woll2Woll wrote to send an email with attachment is [ridiculously complex internally](https://github.com/roywoll/wwEmailWithAttachment_FMX/blob/master/wwEmailWithAttachment.pas). Here's Python sending email with attachment(s), and it doesn't cost anything: # Import smtplib for the actual sending function import smtplib # And imghdr to find the types of our images import imghdr # Here are the email package modules we'll need from email.message import EmailMessage # Create the container email message. msg = EmailMessage() msg['Subject'] = 'Our family reunion' # me == the sender's email address # family = the list of all recipients' email addresses msg['From'] = me msg['To'] = ', '.join(family) msg.preamble = 'Our family reunion' # Open the files in binary mode. Use imghdr to figure out the # MIME subtype for each specific image. for file in pngfiles: with open(file, 'rb') as fp: img_data = fp.read() msg.add_attachment(img_data, maintype='image', subtype=imghdr.what(None, img_data)) # Send the email via our own SMTP server. with smtplib.SMTP('localhost') as s: s.send_message(msg) Come on Embarcadero. You're competing against free Xamarin now and this is sending an Android email with attachment in Xamarin: var downloadsFolder = Android.OS.Environment.GetExternalStoragePublicDirectory(Android.OS.Environment.DirectoryDownloads); var filePath = Path.Combine(downloadsFolder.Path, "Demo.txt"); var createdFile = File.CreateText(filePath); await createdFile.WriteAsync("Hello World!"); await createdFile.FlushAsync(); var file = new Java.IO.File(filePath); file.SetReadable(true, false); var uri = Android.Net.Uri.FromFile(file); var email = new Intent(Intent.ActionSend); email.PutExtra(Intent.ExtraEmail, new[] { "tom@email.com" }); email.PutExtra(Intent.ExtraSubject, "Sample email with attachment"); email.PutExtra(Intent.ExtraStream, uri); email.SetType("message/rfc822"); this.StartActivity(Intent.CreateChooser(email, "Email")); 
Thanks, I'll chek the Spider Profiler out. As for 3 others, I think I've tried them and something was wrong with each of them
Create a conditional define for each build configuration. The default Debug and Release configurations each have one. Then you an use a simple function like this to get the name of the build configuration that was used. function GetConfigName: string; begin Result := 'unknown'; {$IFDEF DEBUG} Result := 'DEBUG'; {$ENDIF} {$IFDEF RELEASE} Result := 'RELEASE'; {$ENDIF} {$IFDEF MYCONFIG} Result := 'MY SPECIAL BUILD CONFIG'; {$ENDIF} end; 
Unfortunately no. I worked in Delphi from Delphi 1. I switched to iOS in 2013, and I wish I did that sooner. After the switch, I could not believe how good and easy life could be, in another stack. The cost of Delphi lets me buy one MacBook Pro per year, and get free dev tools, and much more. (I buy new Macs every other year though). Plethora of resources, from Apple, community that is 1000x larger than Delphi's. Job opportunities, from none to hiding from recruiters and rejecting offers. 
Thank you. 
Okay, I'll bite, what's wrong with that code performance-wise?
lol too bad the compiler doesn't even generate *SSE2* instructions, in 2017. Meanwhile FPC is fully capable of optimizing for Haswell...
Should have been an if/else or case statement, instead of checking the value of fState two entirely separate times
Or you could just open the EXE in Notepad++ and do a CTRL+F for the word "TForm". Or literally just the word "Delphi" if it's a command line application.
Just use Free Pascal and the Lazarus IDE instead. More advanced (in the ways that actually matter) than Delphi, NATIVELY cross-platform on a huge variety of targets, and 100% free.
Not being sarcastic at all. It's a legitimate technique.
lol Linux GUI support a "research area" that is "under consideration". Lazarus has been doing it perfectly for years and years without charging anyone any money. Therefore I can't think of any logical reason that Delphi, backed by an actual company and supported by its' multi-thousand dollar license fees shouldn't be able to do it easily. (Other than developer incompetence...)
In what ways is it more advanced?
Let me explain the "under consideration" nonsense. For over eight years "parallel programming features included in the language" was in the "future" section of the Delphi roadmap. It was mentioned from CodeGear times. At the first CodeRage after Embarcadero bought CodeGear, EMBT's CEO gave a little speech that included the promise of language-level parallel programming features in the future. Allan Bauer's only post here on Reddit was in defense of Delphi's generic system after it was criticized in /r/programming. He said that it should be understood that it was just the beginning, with LINQ-like functionality to follow, hopefully "sooner rather than later", as a step to language-level parallel programming features. Needless to say none of those things ever happened. After eight years when Marco yet again included it on the road map I and another Delphi user began openly laughing about it in comment sections of blogs dedicated to the road map. I posted quotes from Bauer, Intersimone, etc. going back eight years talking about this alleged feature that never materialized. Lo and behold the next release of Delphi included the basic parallel programming library even though it wasn't on the road map at all! Marco made a statement about "sometimes things are finished early" so they included it in that release. Of course, I'm convinced the real motivation for this feature was the fact that we ridiculed the "language-level parallel programming features" still being on the road map. I think that they never added that feature to the road map again proves it. The addition of "ARC on desktop" (Allan Bauer said right before he left that there were no plans to rewrite the desktop compiler), Linux GUI, etc. - in essence, all the things we *really* want but that require some work on their end - is just like the parallel programming nonsense of the last ten years. It's an empty promise to get people excited over a road map that otherwise doesn't interest them. They have no intention of delivering these things any more than they did language-level parallel programming. You can safely ignore it; it's a trick that is rather transparent by now. They have no intention of investing serious time into features that won't generate significant sales. The product is marketing-driven and they're looking for features to add to feature grids and press releases (even if they're half-baked and never finished or don't compare with similar features in other languages). 
I've already acquired a copy of Delphi 10.2 Architect, I'm just wondering how it stacks up against Lazarus. So far I like Delphi better, but am always interested in other perspectives. Thank you for your reply, it was informative and well constructed!
There is no DRM. Lots of cracked / pirated versions flowing around. So, there should be no problem with that.
Oh yes. One of the 'Delphi is dead' discussions. I have been missing those.
That has nothing to do with the question if learning in Delphi in 2017 is still worth the effort ;). You did jump on that specific train when dust had already settled on the Mac and iOS. Wondering what you had done 12 years ago ;). In order to get to know Delphi you simply download the free version and that's it. I do not even need to buy a Mac for doing so. No argument can be found ... I'd guess anyone who simply relies on one stack will argue similar. I tend to agree that one stack is enough. What is so great about writing other people's software? I just use Windows, develop the one or the other application and buy apps from the store for Smart Phones which makes my life also pretty complete in summary. Your priorities in life did change ;) Just a guess... No risk, just fun will not last forever. Objective-C is a lot bigger crap of a language as many people would expect. As we can see, languages don't matter anymore. Objective-C went away in the 90s and returned because there were hungry programmer stomachaches too feed. The German economy consultant's hourly rate dropped so that their business almost didn't pay anymore in the 80's and early 90's. SAP came und ABAP was nothing more than old language pretty similar to IBM Assembler with elements of COBOL. Who did jump on that train? Guess who? Not me, I was too young these days. The way you can no longer use Delphi is the same day you can throw away your Macs and the XCode. You always needed a good reason for using Delphi since Turbo Pascal has always been one of the most crippled languages ever invented and never did offer anything beyond a good compromise of the development environment and the most valuable features of the language itself. When we started functionality dominated the scene. Later content (Office 2000 templates, Web) moved into the focus and I do have the impression that the idea does matter a lot more.
I programmed a TLinker-Object with the goal to seperate my Object's logic and my GUI. it accesses the published properties of an object over their getters and setters and holds a copy of their property-values so you can "cancel" any changes you made prior to an apply. all I have to do is instantiate a TLinker-Object and add a completely different Object to its LinkObject property. If you want I can send you the two .pas-files I created. There are some limitations though: - it only goes one layer deep, meaning the ".-notation" is not implemented. it also currently throws an error when an object has a TPicture property. - the components on a form have to follow a naming convention: xxx_ComponentProperty_TYourObject_ObjectProperty it uses RTTI, I tried not using it but then I got errors with read-only properties.
delphi is really so dead - thanks to embarcadero. long life to delphi 7.
I think it's the best for lots of reasons. And without feeling the need to throw mud at any other technologies. You should try it.
&gt; Oh, I forgot about type inference, something found in every statically typed language introduced since the start of the 21st century and retrofitted into many older ones such as C++. Yes, that's a good one. I do use it as an easy way to find the return type of a function. But type inference is required to create for Linq. And what makes Delphi the best is the form designer, and the rich control library. And other languages would do well to adopt [reference counted strings for performance.](https://www.reddit.com/r/programming/comments/32yiqx/a_million_lines_of_bad_code/cqgft8o/)
deleted ^^^^^^^^^^^^^^^^0.0699 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/21418)
&gt; the product is treated like a depreciating asset. I believe this observation truly hits the nail on the head. We've even seen the continual decline of resources subsequent product owners are willing to invest into it. Even the current guy in charge of Delphi at Idera, Popov, made a comment in an interview along these lines. Here we go... this one is very interesting regarding your wise observation about companies with legacy software being the remaining market.... &gt;I don't know the languages used to develop the &gt;IDERA tools....They are not written in Delphi for sure. &gt;I do know that a lot of database tools are written in &gt;Delphi. It lends itself very nicely for that, &gt;but IDERA tools **are quite new and probably &gt;leverage other technologies.** And here's the one I was thinking of: &gt;I think that the demand for a free Delphi Starter version may not be so &gt;high because there are fewer independent young developers. We have &gt;either people that have worked for a long time with Delphi and their &gt;companies can pay for the tools or students that will get access through &gt;our academic program. The interviewer objects, but Popov continues... &gt;Possible, but that is our perception of the market today and that is why we &gt;have not focused so much on the Delphi Starter edition. Basically Popov is admitting there's no signs that new developers have any real interest in Delphi. Based on other remarks, besides legacy customers they're hoping for an academic resurgence. That's another topic for another thread, but that's absolutely crazy (Pascal was removed from AP Computer Science exams way back in 1999 and open source rules in academia today). If that's what they're banking on, they're doomed. [Source of interview](https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwjQs52e0f_TAhWI2yYKHZDwBZUQFggnMAA&amp;url=http%3A%2F%2Fwww.blaisepascal.eu%2Fblaisepascal_53%2FBlaise_53_UK_Total.pdf&amp;usg=AFQjCNEenMK1GgxgmFxlaKfkknjcFxlpaA&amp;sig2=WUEakXnrJTXCKexXFTRH-g). &gt; it will devalue at the rate of the industry's growing desktop application &gt;irrelevance. Glad to see you've noticed that too. According to the 2017 Stack Overflow survey, 72.6% of developers said they do web development work, with just 28.9% doing work on desktop applications. Mobile was 23%. &gt; now its their REST server and Linux targetting. The world is going to collectively yawn at both of these, given the existence of mature open source server technology and the fact that every other language already targets Linux. A few might pay the upgrade fee to move their legacy Delphi code to Linux, but that's it. &gt; my guess itll be sold in 5 years Idera is owned by an investment company the same way Embarcadero was so you're probably correct.
So close... I'll give you the squiggly line thing, but I leave it on and it works really well 99 percent of the time. It seems silly to [loudly and repeatedly](https://www.reddit.com/r/programmingcirclejerk/comments/1xz0da/epic_delphi_rant/) condemn the product for what amounts to occasional glitches. I know that you have a lot of time and effort invested in insisting that Delphi is dead/dying. You have been trolling Delphi forums for years and keep getting banned and having your off-topic and misinformed posts deleted. And yet you keep posting very long winded walls of text condemning a product that you haven't used in years. You'd think that time might be better spent building up something that you like instead of constantly needing to tear something else down, but to each their own. I use Delphi every day, warts and all, and I have come to a completely different conclusion. Don't expect me to spend much effort trying to convince you. If you really want to know my thoughts on the subject, read my blog or any of my posts responding to people who are genuinely interested. You spend as much time in Delphi groups as I do, so you shouldn't have trouble finding them.
My home computer and laptop don't even have Windows on them at the moment. :-) I'll run it tomorrow, but the only application I have on my PC that I know of that is written in FreePascal is PeaZip and I can't recall the last time I used it. Nice work on the program though; very good idea and very well-documented post. It does reinforce the original contention that inspired it though that you're not finding Delphi development in anything other than little old utilities. Speaking of which, on both that blog post and an earlier one you include ImgBurn as a Delphi application. Wikipedia credits it as C++; I don't know which is right. Actually wait, now I do... http://forum.imgburn.com/index.php?/topic/1521-what-programming-language-is-imgburn-coded-in-c-c-delphi/ C++ Builder. 
I updated the ImgBurn enrty. It was compressed with UPX, which usually reports as "Delphi or C++ Builder". Feel free to report any other issues you find. I'm not sure how closely you read the [IsDelphi](https://glooscapsoftware.blogspot.ca/2017/05/software-made-with-delphi-how-do-you.html) or [Hanselman](https://glooscapsoftware.blogspot.ca/2017/04/something-something-delphi-something.html) posts, but they point to well known companies that continue to use Delphi in both large and small projects as well as new products and established products that are are still being actively developed. They reach the opposite conclusion that you did. 
Not wasting time trying to answer every gish-gallop argument you post is not the same as not being able to make a case. I only wish Embarcadero hadn't messed up their forum history with your posts. Did I imply that you had never used Delphi or did I claim that you hadn't used Delphi in years but are still ranting on about it? Feel free to correct me. But you're right. I don't like Delphi trolls. I just don't always have the willpower to ignore them.
Thats awesome! great work! Do you plan to ever share the source code? :P
I doubt you will find anything that combines creating dll's in Delphi with specific operations like PDF import, etc (there would be no reason for them to exist). Are you trying to understand DLL project file structure? (https://www.thoughtco.com/creating-and-using-dlls-from-delphi-1058459)
Any DLL that is a library to load in a Project and use it Works mine. I have a MySQL server so I can use it. But I must be blind because all I see is pas files not a DLL.
But see, thats the thing; All I see is .PAS files. I dont see any downloadable precomplied DLL files.
The .PAS headers just describe how to interact with the DLLs obtained elsewhere. You need to obtain the DLLs from the standard FFMPEG binary distribution.
You can probably use tools like Dependency Walker to see what functions are used by other programs. (There should be tools that examine a DLL directly, too, but I never needed one...) Afaik you won't get the calling convention, parameters or return type from that... might take some disassembling.
As /u/ShinyHappyREM has mentioned dependency walker should tell you the functions that are made external. Is this DLL provided by a company that allows you to call their functions externally? Calling undocumented functions in a third party dll could be breaking that third party's license agreement. Just something to consider. 
&gt; Is this DLL provided by a company that allows you to call their functions externally? Calling undocumented functions in a third party dll could be breaking that third party's license agreement. Just something to consider. Yes and obviously right now I dont really care about that. I just want to test it out and then once I do that, Ill see all the legal procedures.
Doesn't really appear to be any content, beyond links.
You have to upgrade to the "Enterprise Edition" of the post for an additional $2000 to get the content. ;-)
What a great use case for [unit tests](http://docwiki.embarcadero.com/RADStudio/en/DUnitX_Overview). Change your code to a function that accepts x and n and returns a real (or double). Then test it by passing in values that you already know the answer for and compare the result against that known answer. function MyFunc(x, n: Integer): Double; begin ... end;
I've corrected the numbers above according to the formula in the last part: 50 + Power(-1, 4 + 1) * ((4 - 1) * Power(x, 4)) / Factorial(4 - 1) + Power(-1, 5 + 1) * ((5 - 1) * Power(x, 5)) / Factorial(5 - 1) + //... + Power(-1, n + 1) * ((n - 1) * Power(x, n)) / Factorial(n - 1) Here's the code for calculating it: //////////////////////////////////////////////////////////////////////////////// function Factorial(const x : Cardinal) : Cardinal; begin if (x = 0) then Result := 1 else Result := x * Factorial(x - 1); end; function Power(const x : Cardinal; p : Cardinal) : Cardinal; begin if (p &lt; 1) then Halt(1); Result := x; for p := 2 to p do Result := Result * x; end; function f(n : Cardinal) : Double; begin Result := Power(-1, n + 1) * ((n - 1) * Power(x, n)) / Factorial(n - 1); end; //////////////////////////////////////////////////////////////////////////////// var n : Integer; tmp : Double; begin Write('n='); ReadLn(n); tmp := 50; for n := 4 to n do tmp := tmp + f(n); WriteLn(tmp); end.
&gt; I'm rewriting my synthesiser Windows app in either C++ or C# since I'm &gt;familiar with both those languages. The nice thing is that you get both of those languages in Visual Studio Community Edition for free.
Citation needed.
Good job! You were right! 
Which can be fixed by using DelphiDistiller.
"With regard to the numbers, REST seems to have become the Delphi topic that draws major interest." ...in 2017...
I've looked at this and honestly I've never "raised" an exception. I have always written my objects to handle the exception properly and be able to react accordingly. Code execution ends at raise so why use it? Write effective objects with proper error handling.
&gt; I have always written my objects to handle the exception properly and be &gt;able to react accordingly. Can you give an example? If, for example, someone passes a file name to your function that doesn't actually exist, how would it be handled?
The Delphi Starter edition is available for free, and there are lots of free (and non-free) training resources available. Take a look at [Getting Started with Delphi](http://glooscapsoftware.blogspot.ca/2017/04/getting-started-with-delphi.html).
You can pick up a used copy of Mastering Delphi 5 for [practically nothing](https://www.amazon.com/Mastering-Delphi-5-Marco-Cantu/dp/0782125654), about $3 plus shipping from a reseller on Amazon. You can also get a copy of Marco Cantu's Object Pascal Handbook for free... http://forms.embarcadero.com/DzoneDownloadMarcoseBook
Adding these to my list, thanks.
It is a typo! Went digging for delphi 6 BNF, and found this: Factor -&gt; Designator ['(' ExprList ')'] -&gt; '@' Designator -&gt; Number -&gt; String -&gt; NIL -&gt; '(' Expression ')' -&gt; NOT Factor -&gt; SetConstructor -&gt; TypeId '(' Expression ')'
this might actually be what I was looking for. now I just gotta learn that scripting tool.
Check http://glscene.sourceforge.net/wikka/ if you want something simple 
Thanks.. looks interesting but I will have to wait until I have XE2 or greater.
We use Delphi 2007 with DirectX9 and it works great. You just need to find the pascal headers but google should locate those for you. We package the correct directx dlls in with the innosetup installer and install them into the application folder so we don't run into issues with other versions being installed. 
I use FreePascal/Lazarus with the OpenGLContext unit's "TOpenGLControl" control, but with dglOpenGL (and a self-written OpenGL library that simulates 'OpenGL objects') to do the actual work. It's pretty easy once you understood how modern OpenGL works :)
People still use either of those things?
pchar? http://www.delphibasics.co.uk/RTL.asp?Name=PChar 
ELI5 please. I already saw pchar but dont fully understand it.
iirc the latest version requires xe or later but earlier versions will work with d5 and d7. 
I don't know if it suits your needs, but the Delphi Starter edition (10.2 Tokyo) is [available for free](http://glooscapsoftware.blogspot.ca/2017/04/getting-started-with-delphi.html). In addition to being able to use DirectX or OpenGL directly, the Starter edition includes FireMonkey on Windows, which uses DirectX under the covers.
Thank you. I hope you could lend me a hand next week.
deleted, because T_D runs scripts to exploit comment history in an effort to threaten doxxing... ^^^^^^^^^^^^^^^^0.3065 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/94729)
I complained not too long ago about other languages such as Python having fancy brochures and Delphi didn't; someone listened. Some of the material in the brochure is ridiculous though - are we really supposed to believe that 90 of the Fortune 100 companies are using Delphi *today*? Maybe there's a Pentium III box in the corner running a Delphi 7 app, but..... They also repeat the long-debunked 3 million users claim. "Strong global R&amp;D network" - didn't they disband that? One of the most absurd claims in the brochure is that out of 10K people to take part in their "boot camps" (misusing the term), these people represented "201 countries". Hmm, let's check if that's even possible.... http://www.worldometers.info/geography/how-many-countries-are-there-in-the-world/ Heh, out of the 195 countries in the world, Delphi users were found in 201 of them. ;-) The marketing department just loves to go all-in with their BS, doesn't it? How is anyone supposed to take this brochure seriously when it makes ridiculous claims like this that are readily debunked? Amazing how this 10K user sample reflected the whole world (and apparently that pocket dimension from Netflix's Stranger Things, Earth-2 from The Flash and The Other Side from Fringe) despite the fact it should have been biased towards countries with a higher proportion of English speakers. I liked the line at the end "You made the right choice!" Apparently this is designed to ease people's fears rather than attract new users. There's only one case study and we're not introduced to anyone from these supposed Fortune 100 companies. You never see any Delphi code and the product is never compared to anything else. I don't see what a potential new user is really going to be impressed with (much less so when they learn the price). This is what I believe they borrowed the idea from.... http://brochure.getpython.info/media/releases/psf-python-brochure-vol.-i-final-download.pdf/at_download/file
I'm back from vacation. So, what precisely are you looking for? In your question I see a couple of parts: 1 - Converting BMP to Vector 2 - Saving as DXF For item #1, that's really tricky, though there are algorithms out there and open source projects and the like that could get you started. Search for "raster to vector conversion". People make careers out of doing this well, and nobody does it perfect. For item #2... See Chapter 9 of this PDF: http://images.autodesk.com/adsk/files/autocad_2012_pdf_dxf-reference_enu.pdf. Page 233. That's basically the gist of writing a DXF. You will need to add a little more to dump out lines, arcs, and splines, though. PM me if you need more. If you are doing this on a professional basis, I can recommend a consultant that I work with. Also, I have some Delphi source, but it is not in a manner that you can compile, but is at least something to refer to (I would be ripping it out of a larger codebase that I cannot share.)
Hello. Thank you for remembering. 1 - For simple and quick BMP to DXF, we found potrace to be pretty well. It is a external program yet open source. How difficult would it be, in your opinion, to port potrace to Delphi? 2 - Our main goal would be lines, arc and circles. Splines AFAIK are VERY difficult so it would be excluded. Ill retake a look at that chapter although I believe I have read already. This is indeed for a profesional basis but we are not located in the US and we would perfer to develop this inhouse to keep costs low for us and the end customer. Ive gotten some progress...can't get spline working though. Arc, line, and circle for now, I can write out a file and its a valid DXF.
If you are unfamiliar with the math of Splines and how they work [here is the absolute best tutorial on them I have ever seen](https://youtu.be/o9RK6O2kOKo?t=15m54s) The math is actually very simple, just a bunch of linear interpolations between points. The video is for C#, but it's really clear from the video how to adapt it to any need. I don't know the DXF side of this, but I would guess the points described in this video map quite exactly to items the DXF is expecting.
[removed]
&gt; If you are unfamiliar with the math of Splines and how they work here is the absolute best tutorial on them I have ever seen The math is actually very simple, just a bunch of linear interpolations between points. The video is for C#, but it's really clear from the video how to adapt it to any need. I copied the code but almost fell asleep.
I just tried this on Windows 7 with Delphi 10.1 AND 10.2 and it seems to work as expected. - Create new multi-device application - Drop a TListBox on the form - Add three items at design time - Run the application When I click on any of the items in the ListBox, they are selected. I followed the same steps, except populated the ListBox in the form's constructor. Same results. Are you doing anything differently?
How could this example work when the values are being set at runtime - I can't imagine how that would be possible without running the program. Especially if the values are being pulled from a database - you would need the connection and everything? I am very interested in this program, but skeptical. Could alleviate some of my concerns? Edit: just realized it's called a static code analyzer, suppose I should do more research.
Assign an onclick event handler and read the Index of the clicked Item. Just to see if your click gets through. If it doesn't then the click is handled somewhere else in the app. What could also be happening is that the click registers but the standard method for drawing the component is replaced by something else. So check if there is a customdraw checkbox checked in the Property-editor. The same can happen when you use a custom theme for the appearance of your program. What's your source code for adding the items?
Also make sure the Property "selectable" is set to true.
Well i might write you in the future about opengl.
Is your OOP stuff still relevant? If so I'd like to help you out with it. We can go through it step by step. Won't take long either.