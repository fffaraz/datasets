Because it's a great chat platform to use for real time discussions about everything.
Sorry about that. I fixed the video and re-upload it here https://youtu.be/HXbyIMUvzNQ
Async support has been requested a lot, and 1.6.0 contains our first proposal. We didn't post here for 1.5.0, so here's what's new since last time: # Javalin 1.6.0 ## Javalin goes async We've been working on async on and off for a long time. We've always ended up postponing it due to its trickiness, but we finally decided to sit down and spend some time on it. The API has been through several iterations, and we've landed on something that is both simple enough for end-users to use, and for us to implement (it's also backwards compatible!). ### So how does it work? Just set a `CompletableFuture&lt;String&gt;` or `CompletableFuture&lt;InputStream&gt;` as your result: import io.javalin.Javalin fun main(args: Array&lt;String&gt;) { val app = Javalin.start(7000) app.get("/") { ctx -&gt; ctx.result(getFuture()) } } // hopefully your future is less pointless than this: private fun getFuture() = CompletableFuture&lt;String&gt;().apply { Executors.newSingleThreadScheduledExecutor().schedule({ this.complete("Hello World!") }, 1, TimeUnit.SECONDS) } You can only set future results in endpoint handlers (get/post/put/etc).\\ After-handlers, exception-handlers and error-handlers run like you'd expect them to after the future has been resolved or rejected. A lot has changed behind the scenes, but everything is backwards compatible, so existing users who don't care about asynchronicity shouldn't be affected at all. ### Example project We made a small example project for illustrating the effects of using futures: [https://github.com/tipsy/javalin-async-example](https://github.com/tipsy/javalin-async-example). Please note, the tool is only intended for illustration. Use a proper benchmarking tool (like [wrk](https://github.com/wg/wrk)) if you want to actually measure performance. ## Performance improvements Path matching now uses an `EnumMap` to split the search through the different http-methods (get/post/put/etc). This increases performance slightly for apps with a lot of routes. # Javalin 1.5.0 ## WebsSocket improvements One of the most requests WebSocket features has been the ability to use dynamic paths, like `/:param`. This has finally been added: ws("/chat/:channel") { ws -&gt; ws.onMessage { session, message -&gt; val channel = session.param("channel") broadcastMessage(channel, message) } } More convenience methods for extracting information from the upgrade-request were also added: session.paramMap() // get all param key/values as map session.header("key") // get a header session.headerMap() // get all header key/values as map session.host() // get request host ## Route overview You can now generate an overview of all the mapped paths in your application and host it on a path of your choice: val app = Javalin.create().apply { enableRouteOverview("route-overview") } The route-overview will show the verb, the path, the function/field/class handling the request, and any roles attached to the handler: &lt;img src="/img/news/route-overview.png" alt="Route overview"&gt; ## Multipart fields Previously the Apache FileUpload dependency was required in order to receive uploaded files, and multipart-fields simply didn't work. You can now access multipart-fields via the normal form-param function (`ctx.formParam("name")`), and Apache FileUpload is no longer necessary in order to receive uploaded files (the public API remains unchanged). ### Misc/Bugfixes * Jetty was bumped to `9.4.9.v20180320` which was released very recently. There were no breaking changes. * Fixed some minor bugs in path-prefixing in `ApiBuilder` 
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/wg/wrk) - Previous text "wrk" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20dxcjp32) 
Here you go: https://javalin.io/news/2018/04/14/javalin-1.6.0-released.html
Thanks you too. This is pretty new to us, so if if you have any feedback on the API/implementation please let us know. I've created a feedback-issue specifically for this feature: https://github.com/tipsy/javalin/issues/191
Solid stuff! If I may make a suggestion... when posting release notes a 1-liner of what the framework is at the top of the post helps a lot. Yours on the main page is perfect; &gt; A simple web framework for Java and Kotlin 
Thanks, that's a good idea. Will try to add it later.
Added!
Oh nice, thank you!
This looks just like Very.x a in a different skin 
Mmm, I wouldn't say that. Vert.x is pretty complex, having more than 100k lines of code. I think they've written a lot of things from scratch. Javalin is just a small DSL on top of Jetty, the entire library is less than 4k lines of code.
What you guys are doing is absolutely outstanding. If you keep going you may be a real alternative to Spring Boot for easy to get into Microservices. Already I’m thinking about writing Microservices in Javalin and just putting them behind Spring Boot based API gateway! Keep it up and thanks!
Thanks! If you have any feedback or feature requests, don't hesitate to use our [issue tracker](https://github.com/tipsy/javalin/issues).
Just get it and start using it. It has a lot of features, but you won't die if you don't use them from the get go. ctrl+shift+a is "search everything" (menus, options, commands), the rest is history.
Do you mean Android development or Android Studio?
Thanks. I mean how to use tools 
Alright. The keyboard shortcuts are mostly the same as in Intellj and other JetBrains products, so you're probably best off just memorizing some of those shortcuts
I mean I need how to work with list view and grid view and more tools
Good to see more and more Kotlin conferences to reflect its growth. 
So you mean Android Development?
Sorry. Imean android development 
Go to developers.android.com then
Oh, ok .. . Just get it and start using it
You alright bud?
What if you're already using it but you want to learn more. You can only search for what you know of. 
Because Discord is cool. Slack is crap.
I'm not saying everything needs Slack either. I don't need a chat for everything.
Can you use this on Google app engine?
I've never really tried, but if Google app engine can run a jar it should work. Let me know if you find out.
Go read through the key mapping and see what all the shortcuts do.
There's already a ton of Kotlin arg parsers, but having tried some out, I have to say this just might be my favorite. Any chance you could extend this library to a sensible `.properties` parser as well?
I'm glad you like it! I could potentially add something like that, but it seems like CLIs and file parsing are different enough that it might be better as a separate library. What kind of use cases did you have in mind?
It's both parametrization of an application, if you think about it. I wouldn't mind a parser that reads application config from a `.properties` file, but allows to override these settings with main args. Kind of like [konfig](https://github.com/npryce/konfig) without the ugly parts.
Yeah, would be really cool to integrate external configs and maybe even ENV configs into one tool, so the same param could have: - app-level default - file-based-config-level value - ENV-level override - CLI-level override Seems like it might be (relatively) straightforward to include, though it does add complexity. Maybe it could be handled as an external library which hooks into the initial processing and updates ARGV automatically or something like that.
That project uses a very early version of Kotlin-react that isn't supported. The official implementation of react for Kotlin is at https://github.com/JetBrains/kotlin-wrappers.
The official libraries for React and other related stuff is at https://github.com/JetBrains/kotlin-wrappers There are examples there that would be helpful.
Thank you very much, gonna have a look at it!
# How to create a Minimal, Complete, and Verifiable example When asking a question about a problem caused by your code, you will get much better answers if you provide code people can use to reproduce the problem. That code should be… - Minimal – Use as little code as possible that still produces the same problem - Complete – Provide all parts needed to reproduce the problem - Verifiable – Test the code you're about to provide to make sure it reproduces the problem # Minimal The more code there is to go through, the less likely people can find your problem. Streamline your example in one of two ways: 1. **Restart from scratch.** Create a new program, adding in only what is needed to see the problem. This can be faster for vast systems where you think you already know the source of the problem. Also useful if you can't post the original code publicly for legal or ethical reasons. 2. **Divide and conquer.** When you have a small amount of code, but the source of the problem is entirely unclear, start removing code a bit at a time until the problem disappears – then add the last part back. ## Minimal *and* readable Minimal does not mean terse – don't sacrifice communication to brevity. Use consistent naming and indentation, and include comments if needed to explain portions of the code. Most code editors have a shortcut for formatting code – find it, and use it! Also, **don't use tabs** – they may look good in your editor, but they'll just make a mess on Stack Overflow. # Complete Make sure all information necessary to reproduce the problem is included: - Some people might be prepared to load the parts up, and actually try them to test the answer they're about to post. - The problem might not be in the part you suspect it is, but another part entirely. If the problem requires some server-side code as well as an XML-based configuration file, include them both. If a web page problem requires HTML, some JavaScript and a stylesheet, include all three. # Verifiable To help you solve your problem, others will need to verify that it exists: - **Describe the problem.** "It doesn't work" is not a problem statement. Tell us what the expected behavior should be. Tell us what the exact wording of the error message is, and which line of code is producing it. Put a brief summary of the problem in the title of your question. - **Eliminate any issues that aren't relevant to the problem.** If your question isn’t about a compiler error, ensure that there are no compile-time errors. Use a program such as JSLint to validate interpreted languages. Validate any HTML or XML. - **Ensure that the example actually reproduces the problem!** If you inadvertently fixed the problem while composing the example but didn't test it again, you'd want to know that before asking someone else to help. It might help to shut the system down and restart it, or transport the example to a fresh machine to confirm it really does provide an example of the problem.
Looks great at first glance, thank you very much!
Can you please post a full section of code, along with the expected vs. actual behavior? As it stands, I can't understand what you're asking.
https://github.com/JetBrains/create-react-kotlin-app
Check out [Lightbend (formally Typesafe) Config](https://github.com/lightbend/config).
I can hardly understand what you're asking, but I think I get the general idea from your question and reply. I think this is your question: &gt; When defining a variable, you use the `var` keyword. For example, &gt; &gt; var name: String = "hah" &gt; &gt; But, when setting the text of a TextField, you don't. For example, &gt; &gt; val etc: TextField = ... &gt; etc.text = "hah" &gt; &gt; Why do we use `var` in the first case but not the second? A couple things to note about how I rephrased your question: - I used complete sentences to ensure all of my meaning gets across. (If English is not your first language, I understand this can be difficult, but you'll need to do better than "What different".) - I showed that `etc` is a TextField. Without knowing what etc is in your question, I'd have no idea whether it's an actual variable, or a package, or a class declaration, or anything else. Without your comment mentioning this is for Android, I'd have no idea how to answer. - I used proper Kotlin style - a space between the colon and `String` in the first example, spaces around the equals signs, and each statement on a new line. I also put and empty line before and after each code snippet, and four spaces before each line of code. Since I did this, Reddit makes the code look like code instead of just text. Both proper style and code blocks will make your code easier to read. People are more likely to help if they don't need to slog through unreadable formatting to actually read your code. - I stated that this question is for an Android app. There's more to Android than just Kotlin, and a lot of Android-specific questions have very Android-specific answers. Now, to answer your/my question: `var name: String = "hah"` declares a new variable, so it requires the `var` keyword. Once a variable is declared, you don't need the keyword again to reassign it - in fact, doing so would declare a second variable with the same name, which is a compile error. Here's a simple example. var name = "hah" // name is "hah" var name = "aha" // this will produce a compile error name = "aha" // name is "aha" The same goes for your second example. `etc.text` is already declared, so declaring it again with `var` would cause an error. (There are other reasons why it's an error, but this is the relevant one.) Instead, you set the existing variable to a new value, without re-declaring it.
Looks nice. I used https://github.com/airlift/airline for my last java project. Is there any chance it gets uploaded to maven central? Would be really helpful in corporate envs.
Sorry if I was unclear but they all know programming, but only some of them know Java, so I can't go completely from a Java perspective. Great suggestions though thanks!
I'm a bit disappointed that the article only talks about Java's exception handling and anything interesting from the title is reserved for part 2
"Kotlin is effective Java"
It’ll be along soon!
Tanks, mate!
Demo writing good dsls, with compile time checking. Do you use gradle at work? That might be a good demo, even though you are still stuck with some groovy in build.gradle.kts. 
Stung by your criticism I've pulled my finger out http://oneeyedmen.com/failure-is-not-an-option-part-2.html
Thanks, that was a much more interesting read :-)
Stay tuned. But specialised Result types are really just a dressed-up Either.
If Left is Either&lt;L, Nothing&gt; and Right is Either&lt;Nothing, R&gt; how can they satisfy the return type of BufferedReader.eitherReadLine(): Either&lt;String, String&gt;?
For those who are interested in part 2 instead: check out Arrow which implements data types like `Either` and much more [here](http://arrow-kt.io/docs/datatypes/either/).
Very easy to learn for someone who has used an object oriented language before. There's a lot of programming languages that someone can come from and jump right into it. It is smart enough to know what you are trying to do most of the time. The functional style programming features are nice for reducing the amount of code you need to write too.
I plan to get on to my experience with Arrow!
You can substitute Nothing for any type
While I appreciate pure Kotlin testing frameworks, nothing quite beats Groovy's Spock for me when it comes to parametrized tests. Mocks are trivial to define, and the `where` syntax with the parameters table allows to write some of the most readable tests I've seen in any language, in my opinion. The same test case (quickly) rewritten with Groovy/Spock: ``` def "given #value should return #expected"() { given: def converter = new DistanceConverter() when: result = converter.convert(value) then: result == expected where: value | expected 61888.123 | "&gt;50 km" 38777.23 | "38.8 km" 16984.44 | "17.0 km" 987.98 | "988 m" } ``` Even though I separated the tested method call from the assert, it's still shorter (less visual clutter), but also easier to extend to more parameters, and - in my opinion - more readable. IntelliJ has the parameters table formatter, by the way, so you don't have to align the parameters manually. I believe there is a potential for a similarly powerful Kotlin testing DSL, but I don't think any existing framework is there yet.
However, Spek isn't the only option. I've written an [example for KotlinTest](https://www.reddit.com/r/Kotlin/comments/848ild/testing_kotlin_with_spock_part_1_object/dvobo0l/?st=jg55uw8s&amp;sh=51dba3a6) recently.
I've used both Spek and KotlinTest, neither has as advanced error reporting, boilerplate-free mocking or clean parametrization syntax. Don't get me wrong, I wouldn't use Groovy to write actual applications, but its dynamic nature and expressive syntax is something I appreciate in tests. If any Kotlin framework gets close in terms of readability, I'll be happy to switch.
Hey all, this is my project - would love some feedback, both on Kweb itself and also how I describe it on the website. I've been working on it for over a year now in my spare time.
We use Spock at my company. I can’t stand how slow it is and we have to use a hack to run tests in parallel. I would rather spend more time writing the tests if it saved me hours in the future. 
I can recommend it. They put it together very nicely and the docs are suberb as well. I'm also planning to write about the topic on [my blog](http://the-cogitator.com/).
Cool stuff! I’m gonna give it a go and try to build a Calculator App with it. 
Nice! Let me know how you get on, I can normally be reached on [gitter](https://gitter.im/kwebio/Lobby).
This looks interesting. What do you consider the primary use-case for Kweb? Do you have any bigger examples? The links in the "More examples" part of the page seem to be dead.
In the command line: java -jar yourjar.jar
I am able to run it with that command, but I can't just click on the .jar file to open in terminal automatically I assume... I'm using vs code. I'll have to take a look at intellij
Havent seen the double click to run .jar working in a while And Intellij is made vy Jetbrains, they guys that make kotlin, so its the best you can get for it
Does the jar have a manifest file inside of it? It'll need a manifest file with the Main-Class attribute specified for double-clicking on the jar to work.
Basically, if you have your `main ` function in a file package.File, you need a file in a META-INF folder of your jar file called MANIFEST.mf that has a line `Main-Class: package.FileKt`. That tells java what file in the archive to run. You should definitely try switching to IDEA and maybe use Gradle later on. Makes it much easier.
There's still a long way in order to make Balin a full-featured library to ease the use of Selenium-Webdriver in Kotlin. For now, it supports the modeling of pages and components. Additionally, it also makes the execution of JS code fairly easy.
I ended up creating a .command file with java -jar myfile.jar to execute it on a Mac. And will do the equivalent .bat on Windows. Works well enough for me
my last 2 startup projects (unfortunately both dead) were Kotlin on server side. Currently working with a startup that's using it too (now with intellij's frameworks - ktor and the like). It's absolutely fun (compared to Java), and significantly easier to onboard devs to (compared to Scala)
I've spent the better part of the last six months porting and consolidating a bunch of various enterprise Web apps into a single, multi-module Spring Boot + Kotlin project. There are still some wonky disconnects/bugs here and there, like Spring's @ConfigurationProperties annotation not working on immutable data classes (or without a no-arg default constructor), or Jackson not deserializing Boolean val properties, or Spring-LDAP's entity repositories not playing nicely with Spring-Data-Rest (not a strictly Kotlin problem, but irritating nonetheless). Overall, though, the code base is much cleaner and more concise than the original legacy tools' code ever was, even with the workarounds for the couple of snags that I've hit. Given that the original tools range from Visual Basic and vanilla PHP+JQuery monstrosities to a quickly abandoned stint wherein the company decided to try out NodeJS+Express, I'm happy to be back on a JVM stack with a decent framework. Cutting out 90% of the Java boilerplate cruft is a nice bonus, as is ditching Spring's container config XML files.
This looks like it broke Long which are constants in JavaScript. I'll post a bug report if I have time
My company rewrote our php servers into Kotlin. It's been a wonderful experience.
 Okay. And what is purpose of this project? Who and why do we need this?
If you want to operate on 2d-arrays using sequences or indexes without having to use 2 nested loops, then this I Will be helpful. I was working on a project that depended heavily on 2d-arrays, that's why I made this.
We create integrations in the enterprise space and have written all major projects in it for nearly two years. It amounts to around 50 products or roughly half of our portfolio.
When do you plan on adding unit tests? Also, why is the artifact name capitalized? Any thoughts on supporting a map function, rather than just forEach?
I’ve been writing server side kotlin for a little over a year now. Its never felt foreign or out of place for me or the teams I’ve introduced it to. 
I didn't write tests as this was a helper tool for another project and I didn't have the time, also it's very small and totally dependant on kotlin apis. So, unless it becomes necessary, I wouldn't write tests at the meantime.
Nice. I'm currently working on a project where I drastically improved memory consumption just by using primitive arrays instead of lists in a couple places(in Java though). And before anyone says anything - from an OO perspective it was better after I was done. Anyway seeing someone actually care about this feature is awesome. Though I have to admit that I wanted to replace all the ```Array&lt;Array&lt;T&gt;&gt;``` with something like Matrix (which does imply same length sub-arrays) or Array2D. Though I guess nothing stops me from using ```typealias Matrix&lt;T&gt; = Array&lt;Array&lt;T&gt;&gt;``` on my end. 
you can always use Array&lt;Array&lt;Int&gt;&gt;. it would be quite painful to support each primitive array.
That's kind of true, but that way you lose out on a significant performance gain. But there are two easy solutions: you could either use a simple script that uses Regex to derives the type-specific classes from the general-purpose class (which should be neither hard nor error-prone) or go the same route Oracle went with Streams, i.e. only support the 'popular' types i.e. Double and Integer. 
I think [Kotlin Slack](https://kotlinlang.slack.com/) is better for this sort of questions.
Maybe will tinker with that later. Also, I think Matrix&lt;T&gt; is a good idea, maybe in a next commit.
Are you using gradle? You need to create a `gradle/wrapper/gradle-wrapper.properties` file with the `distributionUrl=` and then append the download link to the a compatible gradle release like 4.6: `distributionUrl=https\://services.gradle.org/distributions/gradle-4.6-bin.zip`
Backend Kotlin recently graduated to an official language at my place of work, a bank.
That all means nothing to me i'm new. I didn't have this issue when I downloaded Pycharm to learn Python and I am getting this error trying to run Kotlin koal to learn Kotlin. I don't think they would expect you to know how to do that above would they?
If you are using Gradle, you can add modules that are hosted on GitHub using JitPack
Well, what build system did you choose when creating the project? It seems to me, that you chose gradle. Whilst it is not a requirement to know all of gradle's in and outs, but when using something to do work for you, you should know, what you are using and how to make it work for you. For a heads up: I provided you an answer for a problem I had as well. It's just IDEA not choosing to use the latest gradle release possible.
Not really server-side, but I've been doing a lot of distributive programming with Kotlin and Apache Spark.
I ended up creating a .command file with java -jar myfile.jar to execute it on a Mac. And will do the equivalent .bat on Windows. Close as I'm going to get with my current skill level I think.
Why use FP in a language without FP support when there's Scala and Eta?
You will likely use gradle as it's being used out of the box (also to build and all other build related things!). Managing your dependencies is as simple as declaring them in your projects `dependencies`. As someone who did both I can say you will enjoy it, as both cocoapods and Carthage are slower and not fully integrated into the IDE
The article demonstrates FP support.
FP support at the same level at which C supports OOP.
Question re ConfigurationProperties, how are you guys dealing with this? We broke down and left the configuration properties in java, with notnull annotations. @ConfigurationProperties public class FooConfiguration { private String data; @NotNull public @org.jetbrains.annotations.NotNull String getData() { return data; } @NotNull public void setData(@org.jetbrains.annotations.NotNull String data) { this.data = data; } }
I've been doing this in Kotlin: @Component @Configuration @ConfigurationProperties(prefix = "com.example.myapp.conf") data class MyAppConfiguration( var myConfigProperty: String? = null ) You end up stuck having to either non-null-assert (!!) or elvis-operator all of your config property references, but Spring does populate the instance variables.
Awesome, thanks for the help.
Because you’re comfortable and productive in an OO style on the JVM but keen to see what all the FP fuss is about?
That would have been a valid argument if Scala's wasn't also better at OO than Kotlin.
Last numbers I have from my local kotlin group is 60% backend
Can you expound on that? Kotlin has lambdas and a library with a lot of these functional constructs. What is missing?
Please, do elaborate.
Then let's just say that there are teams (mine included) that, having developed in Scala, decided that, in their particular context, Kotlin was probably a better bet. Should those teams not be exposed to how to signal and handle errors in a functional way?
Kotlin is missing HKTs, typeclasses, typeclass derivation &amp; whole of generic programming which is IMHO the killer feature of FP languages. Kotlin lets you use functional *constructs*, but it doesn't have any functional *abstractions,* same as C would let you put a function pointer inside a struct and call it an object – but you wouldn't want to do that.
By using 'pure' constructs in impure setting they would[ lose out on benefits provided by imperative model](http://blog.paralleluniverse.co/2015/08/07/scoped-continuations/) while also making their code less flexible because their language does not provide means to abstract over \`FP concepts.
Then I apologise for cluttering your Reddit feed with my nonsense.
They've been in ~~proposal~~ discussion state for 2 years and are nowhere near close to being implemented. Arrow's emulations of typeclasses and HKTs via code generation is slow, brittle and gross. Kotlin as a language is overloaded with lots of concepts, keywords and syntax, even though it's less powerful than languages with less syntax, and some of these concepts are designed to shoot you in the foot \(such as lateinit\)
&gt; Accessing (untyped) json objects still feels klunky Even acessing typed JSON objects feels bad, yeah, it is better, but it has a lot of pitfalls when trying to access objects. If you try to convert a JSON string to a object, there is a issue that you can't use ANY functions of ANY object inside of the JSON string, or else you will have errors thrown at you. (Example: your object has a `Int` and it was converted from a JSON string? Well too bad, you can do `yourObj.integer + 1` because add isn't a function!) That bug made me do some... very nasty hacks: `if (currentTimeMillis &gt;= information.lastBump.toString().toLong() + 14_400_000) {` But as far as I know this isn't a Kotlin JS bug, it is actually how JavaScript works, but it is still a pain to do JSON stuff with Kotlin JS. Aside from that issue, Kotlin JS is very awesome.
I think kotlin generally treats Int as int, while Int? as Integer. but I'm not sure if this is true in arrays \(mostly not\).
Actually I should be less forthright. Part of my motivation for writing the series has been to explore for myself the pros and cons. I am not at all convinced that Either is better than exceptions for the majority of cases - the theme of the next instalment. 
Anybody knows any other video from Hadi Hadiri except for: https://youtu.be/eq3KiAH4IBI
&gt; via code generation is slow, brittle and gross. It's not slow because it's a safe downcast. We're literally generating an inlined typecast whose cost is 0, and just because it's boilerplate code. You're free to write it yourself, it's trivial. @higherkind data class ListK&lt;A&gt;(val list: List&lt;A&gt;): ListKOf&lt;A&gt; // Generates the following code: // // class ForListK private constructor() // typealias ListKOf&lt;A&gt; = Kind&lt;ForListK, A&gt; // fun ListKOf&lt;A&gt;.fix() = this as ListK&lt;A&gt; It's not brittle because it's compile-time checked due to static dispatch. We rewrote the library to remove all grossness. The only brittleness is when you reuse a witness type for multiple typeclasses, which is basically a malicious action.
In Arrow we have right-biased data types because it's the convention in Scala and other languages. It's made so on the chains the last block of a fold or similar operation is the one that continues to the next element. Either.fold( { left -&gt; } { right -&gt; } ). map { right -&gt; } If you want a different intuition, left is an "early return" of a function. int bla() { int ble = ble() if (ble == error) { return -1; } blu(ble); ... return 0; } I agree that catching `Throwable` doesn't align with Java's intuitions around checked exceptions. We look into it from the ergonomics perspective, which is, most of the times you don't care whether it's a Throwable or an Error because any legacy APIs we use today can return Cthulhu for all we know, and you want to deal with all of them. If you only want a subset you can rethrow them. That makes having uncaught "serious problems" an opt-in behavior done outside of the library :D
Ping any of us when you do :)
Slow during compilation as it's an additional code generation step. I see that you're no longer using gross default parameters, which is good, but makes it even more obvious to the user that there's no 'resolution' going on and 'ad-hoc polymorphism' amounts to manual dictionary passing that doesn't scale when there are multiple constraints or inductive constraints involved. I see that you provide some limited generic programming, which is also good, but it will remain limited to methods provided by the codegen as users can't express inductive type classes in Kotlin and so can't write their own functions on HLists.
Nice article. I found it intersting that `when` is most similar to `run` even though `when` is so often compared to `apply`. Also, it's interesting that `let` is always suggested for optional handling even though it seems like `run` would work too. Is the only difference style-wise?
Thank you! I guess you mean `with` instead of `when`? :) And yes, your observation is true, you can use both and it depends on wha happens with the receiver actually. 
&gt; And it's still an order of magnitude faster than your alternative, Scala, with a fraction of the bytecode size. Rust and Haskell are getting there. I don't know about ETA. Bull. Shit. Kotlinc has been slower than scalac for quite some time. At work we have 2 services of approximately the same LOC, it takes 6 minutes for scala service to compile with coverage, run tests, then recompile again without coverage, while it takes 10 minutes for a kotlin service to compile *once* and run the testsuite. &gt; hopefully should be stable until KEEP-87. Hopefully one day Kotlin will have a language feature that isn't just a gutted version of a Scala feature, but it won't be KEEP-87. &gt; automatic dictionary passing using the typeclassless technique. How's it automatic when the user is almost always explicitly referring to the specific dictionary she wants to apply the method too? &gt; Check the article on DI and look for the where clause. The pitfalls are extension methods inside classes, and instance collision which is a problem in other languages too. So given the limitation stated in ```The typeclasses Monad&lt;F&gt; and Traverse&lt;F&gt; both inherit from Functor&lt;F&gt;. You cannot define a boundary for two different values of F```, Kotlin can't even express the type signature of `traverse :: (Traversable t, Applicative f) =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)` – and you're selling it as a Killer FP lang?
Will do!
This, but he's using Java 10, which had support added in Gradle 4.7 \(released yesterday\) If you are already using gradle \(with wrapper\): gradlew wrapper \-\-gradle\-version 4.7 I haven't successfully built using Java 10 with Kotlin yet, so not sure how well that will go
That's exactly how I upgraded my wrappers, so it does work
Interesting, for me it always told me, that it couldn't determine my Java version. The more you know.
Did you set your `JAVA_HOME` env? It did tell me that aswell before I updated those from 1.8
Sure, `JAVA_HOME` is `C:\Program Files\Java\jdk-10` And all the Gradle scripts that rely on that work as well.
r/AndroidDev maybe. This is not a Kotlin issue
That's what I did for my app. I find it works much more organically than the builder pattern
Yup, it works out very nicely. It cuts down on a lot of boilerplate code that you need for the builder pattern.
Builder pattern still have value for cloning with immutability. I suppose you still have data class ".clone" but regardless, Lombok's @Builder annotation is pretty powerful and requires no extra boilerplate.
`data class`'s auto-gen'd copy methods solve that problem though. 
Thanks, not flagging it as an issue just looking for a little guidance on how to code this in Kotlin. Or is that frowned upon in this sub?
Not really. The purpose of the builder pattern is to configure how an object is created without knowing the exact type of that object (using an interface). This becomes apparent when you work on a library and realize that you messed up something. With named parameters you will just break your user's code. All being said named parameters are fine for one-off projects or microservices but once yoir code becomes a dependency, named parameters instead of builders become a liability.
Not if you need deep copy or you have mutable collections in your data class. Even immutable collections can leak if you pass a mutable collection as a constructor param.
I just think you're asking the wrong crowd ;-)
Maybe I did not understand you correctly, but aren't you referring to factory methods? 
You can't really do that when you need interop with Java. When you use @JvmOverloads, I believe it creates one method for every combination of parameters, so if you have 10 configurable properties with defaults, it would create 1024 methods.
No. Factory methods are for creating simple objects, builders are for complex ones. Take a look [here](https://github.com/Hexworks/zircon/tree/master/zircon.jvm/src/main/kotlin/org/codetome/zircon/api/builder). What you can do with builders/factories is [caching for example](https://github.com/Hexworks/zircon/blob/master/zircon.jvm/src/main/kotlin/org/codetome/zircon/api/Position.kt#L231) which you can never do with named params. 
If you need functionality different from the auto-generated data class copy method you could always mimic what it does with a single `deepCopy` (or whatever) method, rather than using a builder. eg: fun deepCopy(foo: Foo = this.foo, bars: List&lt;Bar&gt; = this.bars) = MyConstructor(foo = foo.deepCopy(), bars = bars.toList())
Hey there. Yes. Aware of it. My goals are slightly different I think. More opinionated and high level. Libktx sticks closer to libGDX in that it provides a set of versatile tools. I have said to myself that I need to take a closer look and actually use some of those tools. :)
Named params in constructors to replace the usual builders, functions with named params to replace builders that might return objects with different types. Imho, the only use case I see for full-fledged builders is Java interop.
Imagine a builder for a specific List implementation that looks like val a : SortedList&lt;T&gt; = ListBuilder().expectedSize(10).sorted().build() val b : ConcurrentList&lt;T&gt; = ListBuilder().concurrent().allowNulls().build() You can't handle different return values with named parameters and you can't have exclusive option (for example assume it's impossible to construct a List that's both sorted and concurrent).
Yeah somehow people started to think of builders as a replacement for constructors with a large number of parameters. This is one use I suppose, but the more useful and important one is to be able to instantiate different concrete implementations of some interface depending on which methods are invoked on the builder.
In addition you can create partially configured builders to be used for commonly created things. You can't do it using copy because you would need all fields to be nullable to allow them to be unconfigured, while nullable fields in the builder is not so bad
Yep, that's a pretty good use case!
This is covered in this Effective Java (in Kotlin) blog series: https://blog.kotlin-academy.com/effective-java-in-kotlin-item-2-consider-a-builder-when-faced-with-many-constructor-parameters-1927e69608e1
Thanks for the explanations. I hadn't thought of partial application as the reason for right-biased types. I'm still less convinced by catching Throwble for Try. The next in the series offers my reasoning
That is not quite true. You can use a factory with named parameters with default values to create instances of different types. This would be easier to implement than a builder. 
It is. There are use cases which you can't handle with a single function compared to an object. For example, you can't have nested builders with a factory method with named parameters nor can you have deprecated parameters. The list is long, but I think you get it.
I totally agree with you. I just wanted to mention the possibility to use factories to create different types. So builders could be replaced with simpler factories in some cases -- and nothing is wrong with builders in other cases.
Yep. What I mean is that in 90% of the cases it is perfectly fine to just use named parameters. What I was trying to point out is that we can't scrap builders because there is that pesky 10% when it is needed.
And than read my other comment above where I state with concrete examples why we can't scrape builders.
Where did I say we can scrap builders?
You referred to this post and this post is about scraping tgem.
Thanks! Didn't knew such things exist. 
Are you really trying to say only extreme views are allowed? Everyone has to be either "team builder" or "team named parameters"? It isn't possible to say "here's a case you can use named parameters instead of a builder" while still believing there are other situations a builder would be appropriate? To recap: - /u/besthelloworld said "Builder pattern still have value for cloning with immutability" - /u/apotheotical suggested using `copy` - you (correctly) pointed out that `copy` doesn't work "if you need deep copy or you have mutable collections in your data class" - I pointed out that this still doesn't mean that you need to use a builder **for this specific case**. That in no way implies that builders should be scrapped entirely, and the only way I can imagine someone would make that leap if they had a huge emotional investment in defending builders at all costs. FWIW, I do think builders have *less* use in Kotlin than in Java, but I wouldn't say they have no use at all.
Please read the full **post**. The **post** is about scraping builders. I said nothing that implies anything of this. If you would have read all the **comment threads** on **this post** you would have realized that I've already said all those things to **other people** including an **agreement that named parameters are perfectly ok in some situations** but you were so fixated on **this comment thread** that your tunnel vision got the best of you.
I'm not sure that you are aware of the contents of this post. It seems that you need a very thorough explanation to get it: &gt; Are you really trying to say only extreme views are allowed? Everyone has to be either "team builder" or "team named parameters"? I have said nothing like this. I'll now cite my own comments on **this post**: &gt; Yep I agree. What I mean is that in 90% of the cases it is perfectly fine to just use named parameters. What I was trying to point out is that we can't scrap builders because there is that pesky 10% (or even less) when it is needed. Please take the time to read all comments before going personal because you'll just make yourself look ridiculous. I'm not going to refute anything because I was not even talking to you and I made it clear in this comment: &gt; I was not talking about mimicking copy by using a builder. They are completely unrelated. &gt; &gt; What I have said is that copy does not solve the immutability problem. In fact it introduces hidden bugs to your code. Read the second sentence. Then keep reading it until you finally understand that I was not talking to you and I was not arguing with what you said about deep copying.
whoot? I did this a couple dozen of times and it worked every time. Are you sure you are doing it right? (sorry, I have to ask) Make sure you use the latest version of IntelliJ (do you?), that you are using the latest version of the Kotlin plugin (do you)...and just to be safe: That your current paste target can compile and doesn't have errors (this is not necessary).
You're probably using the default values for the JVMs initial heapsize, which is 1/64th of system memory for [Java 8](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html#default_heap_size). I could get your example to run with a max heap size of 19mb (ie `-Xmx19m`) any lower and it would crash with an OOM error. IIRC for garbage collected languages you want approximately 4 times the amount of memory as you'd need for manually managed program but I'm not sure if that figure is still current.
I've run into this problem a handful of times on AS 3.0.1, where pasted Java snippets stay Java instead of being prompted to convert to Kotlin. The best workaround I've found is to make a bogus Java class, paste your code there, then convert the class to Kotlin. 
For me as 6 year android dev I switched entirely to Kotlin and I love my work more than ever before. Cannot recomend something more than Kotlin. Its still good to know the background of Java and VM bytecode though. I personally think Kotlin is the next big thing and will only get bigger.
Based on the meetups attendance and the degree of interaction, JetBrains are fully behind a strong Kotlin push. My assumption is that Kotlin is going to absolutely smash on Android and even on the server-side within 3 to 5 years. If you learn Kotlin now you'll end up puking a little bit in your mouth every time you're dealing with Java assignments throughout the next year, so be prepared.
Its definitely a growing language, i know a lot of places like HubSpot are starting to adopt it, and not just in the Android department, but very much on the server-side of things too
Try not to focus on popularity. But on more general principles like, memory management, etc. To be honest if you just started a degree, by the time you graduate there will probably be all new languages that are the "hot thing." So try not to get too bogged down with learning all the specifics of a particular language, and instead focus on the more general ideas of programming that you can apply to everything. Personally I am looking into playing around with Dart and Flutter to make some Android/iOS apps right now. That looks fun. 
One thing you’ll need to be accustomed to is that language popularity doesn’t really matter to experienced developers, because they can shed and old one and pick up a new one pretty quickly. But hiring people... eh... they’re less sophisticated and love to pigeonhole software engineers by language. It’s a horrible, horrible practice but ... it is what it is. And you may have to deal with that stupidity. Kotlin is very popular by everyone I’ve met who has put it into use. So I anticipate it growing significantly, say, to grow more popular then Scala or Clojure, especially when it’s native backend tooling gets ironed out. IMO, it doesn’t hurt learning both Kotlin and Java at the same time. Java is basically simpler, but has a lot of wrinkles that Kotlin ironed out. Over time, you’ll write more “idiomatic Kotlin” but it’s hardly a requirement to use it. And most tools let you use both in the same project. That should give you some nice experience in a very popular language.
If you where to develop Android apps it doesn’t matter if you start with Java or Kotlin, the last is better IMO (because the Java that Android is using in always one step behind at the Oracle version). The thing here is that you learn the Android framework itself, I would recommend to at least do an app in Java and then jump to Kotlin, so you will know the benefits of each language, and as you point, you already had knowledge of Java so will be easier to learn the framework. Also even if Kotlin is more popular theres still big applications written in Java that may are seeking for Java Android developers. Its like in iOS, theres still apps written in Obj-c and are not going to migrate to Swift any time soon.
I'm outside of the US so not one of the banks you had in mind.
I can’t mention you the startup but recently I joined a unicorn and we are heavily using Kotlin for server side code. I have no doubt in my head it’s taking off and most probably going to replace default tendency to use Java in few years. I think Kotlin is to Java; what Swift is to Objective-C. It not only improved on certain areas but kept system backwards compatible enough to use existing set of libraries. 
I have heard about flutter devs but never actually met one haha
I have been developing android apps for 4 years in java it is a really good language and the thing i mostly like about it are the strict conventions, recently picked up kotlin and I love it, except for some things like not being able to inherit from data class or not having static methods and nkt being able to have constants in a class only by using companion object but I believe that with speed that kotlin is growing ( more than 50% apps are created with kotlin nowadays ) google is going to to deprecate java soon (1-2 years) also for the lost law suit with oracle maybe? But man kotlin can run on backend it compiles to javascript, it can be run on an ios device i think this thing is going to be huge in next 5 years competing with javascript( also can be used for mobile apps, backend, frontend ) and python which i will believe will mostly be used as a language for machine learning and math related stuff. And also dont forget C++ for IoT and low level stuff that needs to go fast !
Kotlin will be huge. I've been writing Java for 22 years, so I'm old and jaded, and I'm excited about it.
I am not one either. :-) Just think it sounds fun.
Great. Thanks! 
Why you put 1990 on your nickname? 
What can you get from a java static method that you can't get from a Kotlin companion method (+/- the @JvmStatic depending on where you're calling the method)?
Heyjust started a job (5month now) as a android dev. Self taugh most of the stuff. Just wanted to add : I think you are on the right path bust asking wrong question. You see good and passionate dev dont come from what you learned but what you want to try to do. On this when i started reading uour story what came onto me is " i want to build android app" but then you question became should i learn kotlin or java cause in my future class we learn java. From what i get you want yo do something. Then don't think about the future. Just do it! Experience is something i see way more valuable. Learn kotlin now if that is what you want and maybe in the end you'll prefer java.
Kotlin will overtake Java for Android development in about a year. Swift has a decent market share. . Given the vast majority of Swift code is for IOS and the Android market is much larger than the IOS market, it's safe to say that the Java market share will drop considerably once Android has transitioned. This will have a compounding effect as developers won't want to be stuck on the next Cobol so to speak. Kotlin is taking the market by storm due to the huge benefits over Java: https://proandroiddev.com/kotlin-avoids-entire-categories-of-java-defects-89f160ba4671 JetBrains is attacking on all fronts since you can compile Kotlin to JVM for the back-end, JavaScript or WebAssembly for the front-end, and you can even compile to native machine code for IOS or MacOS targets. Even the Gradle build script can now be written in Kotlin. Above all that, Kotlin also introduced multi-platform librabries which enable you to write a single set of utilities, business logic, and automation tests and then re-use these on the back-end and front-end (or for IOS and Android). Similar to Cobol, there will always be some companies that are hesitant to change but Kotlin is an obvious next step and many companies are starting to take Kotlin seriously. 
You've been writing Java since the 1.0 days? That's pretty hardcore. Also slightly masochistic.
10 years ago hardly anyone wanted to hire python programmers. Now they are in high demand. Right now the demand for Kotlin is probably not so high but it will likely go up. I think it's important not to base your decisions on popularity. Trends change, fads come and go. Learn a language if you think it's interesting and fun to work in.
Server side Kotlin is glorious. Compiling it to JS for a web app is pretty great too.
If like me you're using IdeaVim, pasting it via `p` or `Ctrl-V` doesn't trigger the conversion. I have to right click/click edit and click paste.
I wouldn't focus too much on the language. But Kotlin is a good vehicle to learn about the JVM ecosystem. However, I think Kotlin will grow significantly, since it is not only popular on Android but supported in more and more frameworks through dedicated Kotlin APIs. Examples are Spring, Reactor and Gradle. Take a look at this Stackoverflow [trend diagram](https://insights.stackoverflow.com/trends?tags=kotlin) to see how Kotlin is rising. 
You mean like other languages have overtaken C on UNIX, JavaScript on the browser, C# on .NET?
Can confirm.
Really? No mention about how a `Nothing` value can be assigned to any other type? Or how `throw` has return type `Nothing`? Only the superficial comparison to Java's `Void`...
The industry here hasn't really adopted Java 8 yet, so that's that. 
In short: very. If you check the results for the last [Stack Overflow survey](https://insights.stackoverflow.com/survey/2018?utm_source=so-owned&amp;utm_medium=meta&amp;utm_campaign=dev-survey-2018-promotion) it is visible that Kotlin is currently one of the most wanted and loved languages. It is also going through an exponential growth in both users and questions on SO.
I have first-hand experience with Kotlin multiplatform projects and Kotlin on the backend. It is not 100% good, but almost. My productivity skyrocketed and now it is possible to have a Kotlin-only stack.
I've been doing this for 2+ years. I mostly use Kotlin as a glue between Java libraries. Programming is fun again! I actually use Kotlin throughout the full stack. With the advent of multiplatform projects now I was finally able to do away with javascript completely. 
Most of the posts on that blog seem to be sub-par. 
For that to actually happen Google would need to rewrite Android in Java. Or be clear that there they will not move Android beyond Java 8 and stop Java compatibility there. 
Well, it was since 1.02. I actually worked for Borland at the time, when it became Inprise. Yes, C++ was a clusterfuck, and my job at the time was to write cross-platform C/C++ for AIX, HPUX, SunOS, Digital whatever, and NT. One day I got so cranky at MSVC and its impenetrable bullshit that I installed a prerelease version of JBuilder, which was a pile of shit. I eventually ended up using the JDK and a text editor, and got my code to work and never looked back from there. My next job was as a Java programmer. I never used a released version of JBuilder, in fact it scared me off IDEs entirely until IntelliJ IDEA came along. When the Scala spec was released I read it, and despite understanding the FP bit perfectly well, decided it was not in fact better than Java. But then when I read the Kotlin manual I got very excited, because they've done it exactly right. In 10 years we'll see what the omissions have been, but for the moment it's awesome.
ummmmmmmmm sorry but how do you do this? im using intellij and for class they are requiring use to use the gradle build. i have no idea how the gradle works, and it gives me some pretty stupid errors. for reference it wasnt working at java jdk 9.0.something (i think it was an 8?) and then i upgraded to 10.0. i set my java_home but nothing happened. i have no idea how to do the thing written above, and i dont even know where to start figuring that out
https://imgur.com/a/tLROHHy I hope I have made that as easy to follow as possible.
thank you
I don't know what this is. What's going on here?
It's some helper functions for Android's Spannable class.
Hello, I am using gradle too. Mine is still not working. I followed the steps in the image but where you said there will be error, I did not have any error and the problem remains unsolved. Any help is appreciated.
Kotlin is currently in the 49th position on the [TIOBE Index](https://www.tiobe.com/tiobe-index/), which indicates the popularity of programming languages. I might not seem that popular, but maybe if you count that it is mainly used for Android programming, I can be really good. 
Yep. the dude seems to have problems with English as well. 
I don't work in Kotlin professionally but have been using it since before the 1.0 release. I work in python daily, and I so wish I could use kotlin. There will be an inflection point where it will become big. What it needs is some more community libraries, unless I'm missing some. The multi platform is going to be massive. Once that is fleshed out it's a big win. On the backend it's amazing and have everything I need. Things like ktor are good, but last I checked need some more documentation. I haven't done much mobile, but obviously android is going to work excellent. Ios can't speak too. For the web frontend. It was so nice, to have strong typing and an IDE for a frontend. But I spent more time coercing type script definitions for react. I would say learn it, it will teach you a number of different things.
Not really a DSL, just some helper functions. ``` fun spannable(func: () -&gt; SpannableString) = func() ``` why?
This sealed class will not compile sealed class LinkedList&lt;T&gt; { data class Node&lt;T&gt;(val payload: T, var next: LinkedList&lt;T&gt; = EmptyList) : LinkedList&lt;T&gt;() object EmptyList : LinkedList&lt;Nothing&gt;() } The out variance modifier is missing. The compiler complains that the default value of next cannot be set. We cannot write var next: LinkedList&lt;T&gt; = EmptyList unless we write sealed class LinkedList&lt;out T&gt; When determining subtypes, variance must be considered in generics. 
This sealed class will not compile sealed class LinkedList&lt;T&gt; { data class Node&lt;T&gt;(val payload: T, var next: LinkedList&lt;T&gt; = EmptyList) : LinkedList&lt;T&gt;() object EmptyList : LinkedList&lt;Nothing&gt;() } The out variance modifier is missing. The compiler complains that the default value of next cannot be set. We cannot write var next: LinkedList&lt;T&gt; = EmptyList unless we write sealed class LinkedList&lt;out T&gt; When considering subtyping, the generic's type variance must be considered.
I wasn't talking about generics: Something that returns `Nothing` will be assignable to anything: val s: String = throw RuntimeException() This behavior is what allows the `EmptyList` from the blog post to be assigned to other types of `LinkedList`in the first place! It's weird they didn't explain any of that.
It is correct in the article: sealed class LinkedList&lt;out T&gt; { data class Node&lt;T&gt;(val payload: T, var next: LinkedList&lt;T&gt; = EmptyList) : LinkedList&lt;T&gt;() object EmptyList : LinkedList&lt;Nothing&gt;() }
&gt; Google would need to rewrite Android in Java. The framework team is writing new stuff and migrating stuff over to Kotlin. Samples now have examples in Kotlin and Java (a few I've seen).
&gt; That being said, I've looked for jobs involving Kotlin in Germany a couple months ago and there were pretty much none. That's pretty much true almost everywhere. Kotlin is too young (yes yes it started in 2010, I'm aware) to be listed exclusively.
&gt; ( more than 50% apps are created with kotlin nowadays ) google is going to to deprecate java soon (1-2 years) More than 50% new apps written in Kotlin? I don't buy that at all. And no way Java gets dropped in a couple of years (law suit is irrelevent).
You can find a lot of articles about `Nothing` that describe that. This one presents different usage. This is why it is named "Kotlin’s Nothing: Its Usefulness in Generics" and not "Nothing type in Kotlin". 
One way to "fix" this issue is by doing this (this is what I always do, but I was wondering if there was a better way to do this) ``` class Test @BsonCreator constructor(@BsonProperty("_id") _something: String) { @BsonProperty("_id") val something = _something } ``` Works fine, but it feels a bit hacky
Yup, that would work! But I feel that's bad for readability, since then you would need to use `_id` in the rest of the code, instead of something like `name`.
I think here's what you are looking for: https://kotlinlang.org/docs/reference/annotations.html Under Annotation Use-site Targets
Well in that sense for readability you could create another field with a getter that returns the value of the '_id' field, if you worry about readability: val name: String get() = _id Edit: from the comment linked above you could see that the solution is: @get:AnnotationName field: String
Native or not it shouldn't make a difference. When I'm reading these articles they have a slight overall sloppiness which just bugs me. It seems like as if these writings were put together in a hurry. Grammatical mistakes, weird phrasing, and some formatting issues are always present.
The entire Android API is written in Java and that won't change in the forseable future. How are you going to develop on a platform when you cant read the API?
You need to learn Java first. If you know object-oriented programming, it's going to be quick. If you don't, you'll have to learn that first.
You're gonna need to learn Java first. There are going to be lots of times where you're coding in Kotlin and are going to use Java components because Kotlin is built on top of JVM. For example, to launch an activity you need the Java class (My class::java.class). Luckily there is a myriad of resources to learn Java. Once you got the basics down it's simple to start picking up Kotlin. 
That does make sense
I'm looking forward to start with Kotlin. Would you recommend any tutorial to get started with?
How about you link [the original repository](https://github.com/czyzby/kotlin-multiplatform-example) you downright copied to write your article and [your own repository](https://github.com/AppCraft-Projects/kotlin-in-browser-example)? You haven't even bothered to [update](https://github.com/czyzby/kotlin-multiplatform-example/blob/master/client/package.json) the [dependencies](https://github.com/AppCraft-Projects/kotlin-in-browser-example/blob/0514d8f8d77b78c2b7e862bab1e3c41a65a7876e/package.json). I wouldn't mind the article if you credited the original repo, but this is just an asshole move, to be honest. You even used the original test example with my comments!
Are you proficient in Java?
No, I personally think Java sucks that's why I'm moving to Kotlin. All my friends have learned Java for Android, but I waited for something else and that is Kotlin I think.
I like how clean and minimal it is. Doesn't have any big logos or annoying emoji like some other code embeddables do.
I see. So I think that Kotlin is something like Clojure. You can learn the language but you can't avoid the Java ecosystem. This is even more true for Kotlin than Clojure because Kotlin reuses all the stuff from the JDK. So even if you don't learn Java syntax you are better off if you learn the tools which are provided by the JDK. If you only use libraries written in Kotlin you'll still have to use the Java Collections Framework for example. What platform do you work on? Android? Web?
Look. This article is a part of a series in which I explore frontend development as well. Technically I'm not obliged to mention you since you voluntarily chose a public domain license. I don't see the point in discussing this further. The example is simple enough for the purpose of the article. I did not sit down with your project and think "Oh wait! Let's write an article about this!". If you take a look at [the](https://medium.freecodecamp.org/beyond-android-exploring-kotlin-areas-of-application-5d28ff66a446) [history](https://medium.freecodecamp.org/going-beyond-android-kotlin-on-the-backend-2a75eef2582b) this immediately becomes apparent. The part which you said is wrong is taken out of context. I'll cite myself here: &gt; [...] we still need to set up Karma, Webpack and a package.json is also necessary. “Why are these necessary?” you might ask. The answer is that **if we don’t want to rewrite everything in Kotlin which is not part of our business domain (like testing tools, package management and such), wel’ll need to use those which are present within the javascript ecosystem.** If someone starts working with Kotlin he/she obviously **does not want to write a whole toolchain**. And even if you write a toolchain you still have to know how some Javascript stuff works. So no, you can't work around Javascript completely. &gt; I think it's because it depends on the original KotlinJS plugin. Anyway, if the project is not multi-platform, I'd say you shouldn't go with this plugin. Again if you had checked my articles you would have known that the next part will be about multiplatform development and this decision will fit into the whole picture. &gt; Except we're not using npm? yarn handles the dependencies. Except we are using `package.json` which is a file form `npm`'s domain. &gt; It already is run by the browser, even the basic unit tests: I did not say it is not. I just pointed out that you can manipulate the *DOM* as well. &gt; I'm sure Kotlin 1.20 will be production ready, lol. You purposefully misunderstood that part. It is not *Kotlin* that is production ready, but the javascript compiler. &gt; I haven't called you an asshole directly, just said that doing stuff like this isn't exactly nice. If you contacted me in any way, I'd honestly be happy to help and proof-read it. Again. **You chose** public domain so I'm technically not obliged to do so. If you don't like it why not choose MIT or Apache? &gt; I felt like you decided to write an article, found a repository, broke the code into pieces without full understanding and just went with it without giving any sort of credit. This is wrong in every aspect. First, I didn't decide to write a post about *your* code as I have already pointed out with the links to previous articles in this series. I just did some research and found code which fits my needs **and** has a permissive license. Second, I understand the code in your repo, I just didn't go into much detail regarding the javascript stuff (and I have even pointed this out in the article). &gt; Imagine how you'd feel about it. I wouldn't give a damn about it. If I put something in public domain it means for me that I don't care what happens to the code. To sum it all up: If you want to be cited or mentioned use a license which **prohibits** copying. I don't understand why you chose a public domain license in the first place if you are complaining that your code is being used. You could have told me in a more civilized way instead of implying that I'm an asshole when in fact I was perusing several repos with the same kind of code and just used some code from one of them (which also permitted me to do so).
He an do that, your repo is public domain, no? You can use MIT maybe if you want to be mentioned?
I wanna work on Android first. Isn't Kotlin official programming language for Android now.
It is! Then Kotlin is your best bet. I can't really comment on Android since I haven't programmed on for 5+ years, but it is definitely better than Java.
See my other replies. It's not that the code from the repository was used, it's that the author has shown no significant effort to change, expand upon or even update the project. I wouldn't complain if the article was error-free and extended the original content.
From what I see the cod example was simplified to fit the topic of the article and it also compiles so I don't see what your problem is apart from the fact that you seem to regret using a public domain license and now you are being smug about it.
The purpose of the article was not to expand or change but to simplify for the article. I still don't see why this is a problem for you since you waived those rights. 
There's the license, and there's common decency (not going to sue, heh). I agree you can do whatever you want with the code, but I just feel like taking the credit for something you haven't really done is just not fair and something I would never do. Hence the drama. I might have taken it far and overreacted though, sorry. &gt; You purposefully misunderstood that part. It is not Kotlin that is production ready, but the javascript compiler. Kotlin **1.20** never came out. It's **1.2.20**, and it's outdated for quite a bit. You haven't even bothered to update this dependency from my repo. That's the error I pointed out. &gt;&gt; It already is run by the browser, even the basic unit tests: &gt; &gt; I did not say it is not. I just pointed out that you can manipulate the DOM as well. Read this part again: &gt; While this covers unit testing we’re still not out of the woods yet because we also need to test our program in its native environment: the browser. It implies that the tests are not run in a browser, but they actually are. The snippet right before it shows the output from the tests ran against Chrome. --- I guess you're right about the license. I used it with coders in mind, the article kind of caught me off guard. You absolutely had the right to do this, I just wished you've shown more effort, or at least gave some credit. Not saying you _had to_, or even _should_, but it's something I would do, that's all. BTW, if I approached KotlinJS today, I'd go with [kotlin-frontend-plugin](https://github.com/Kotlin/kotlin-frontend-plugin), since it simplifies the configuration.
Ok, so this is what I'd like you to understand. I had **no intention** of using someone else's code without giving credit. I immediately added a link to your repo in my repo after your comment. I know it *sounds dumb* but **I simply forgot to do so**. For example when I was working on a lib I [went to great lengths](https://github.com/mabe02/lanterna/issues/314) to ask the author of a lib for permission even when I knew that he probably wouldn't have found about it. I have problems with task management that's why I'm working on a todo app right now. 
Ok, so I [added a reference](https://github.com/Hexworks/the-cogitator/commit/97f25bfe3c142fed71843f2bd52664c3b39f6465). Feel free to comment on the article (so others can see it), or open a PR if you have constructive feedback.
Well, my previous comments were nitpicky, but I do think you could fix these: * Update to the latest Kotlin version, change the invalid `1.20` to current version. `1.20` never came out. * Reword the "out of the woods" part about unit tests. It implies the regular tests are not run in a browser, but all Karma tests are executed via Chrome with the current setup. I'd also remove/move/rewrite the DOM part, since it has nothing to do with the async tests. * Mention `yarn`. `npm` repository is used, but not the tool itself. * Instead of saying that there's no way of _not_ using JS tools, mention the Kotlin frontend plugin - it hides the complexity of JS build tools and moves the config back into Gradle files. Actually, I'd consider rewriting the config to use this plugin in one of the next articles in the series, since it seems to be the preferred way of setting up KotlinJS for now. * Consider converting some comments to article paragraphs explaining the code. I feel like there's no need for code comments in this case, especially since some code blocks have horizontal scrolling bars because of them.
Thanks for the suggestions. &gt; Update to the latest Kotlin version Nice catch. This was a typo on my part, will fix it soon. &gt; Reword the "out of the woods" part I think it would be even better to add an actual test for the *DOM*. &gt; Mention yarn. Also a good catch. I was really happy when yarn came out. I did not like the non-deterministic behavior of npm. &gt; mention the Kotlin frontend plugin I chose to use your way because I fiddled around with other ways of doing this but most of the stuff felt like an unnecessary abstraction. The guy behind the [d3 port](https://medium.com/@addamsson/i-really-like-the-article-affa91b786a8) also felt the same way so this was enough for me to ditch the `kotlin-frontend-plugin`. I think that either way this will be a leaky abstraction and at some point, the user will have to figure out these js tools on his/her own. At least this is what happens to me most of the time when I try to use some less common functions. &gt; Consider converting some comments to article paragraphs explaining the code Good idea. I liked your comments that's why I left them there but it would be more consistent to have them in the code.
You will get headaches. Kotlin is fully interoperable with Java and a lot of what Kotlin offers is syntactic sugar over fundamental Java. I do not know Java and I've gotten pretty far with Kotlin but there have been days where I spend hours trying to figure out why I'm getting weird runtime errors. I search and search and search for hours as to why my program is crashing. And I find out, "Oh, it's because there were no package declarations at the top of source code." That is base, fundamental Java. When I was learning Kotlin, there was no emphasis on learning packages. I was vaguely aware of the concept when I tried to learn Java years ago (it's has to do with something, something... folders?) but because I never fully tried to grasp the concept, it came back and bit me in the ass years later. For me, this is a hiccup. I've had a few before, and I anticipate many more because I do not know Java. So, go head, learn Kotlin. But know there will be risks in your learning. 
I do Kotlin for my full time job but I don't do anything on Android. I didn't know anything about Java before starting and it's been fine. You can't learn Kotlin without having people tell you a lot about Java anyway so it really doesn't matter if you don't know Java before you start. If you're doing android, its gonna be a little different. 
Yep. Kotlin in a sense is a [leaky abstraction over Java](https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/). If you want to get out the maximum from it you gotta learn Java as well.
Kotlin is dead, long live dart and flutter.
/r/Android: 85k subscribers and 1562 online, /r/Kotlin: 10k and 15 online at the moment. Job site: 118 ads for "Kotlin", 1900+ for "Java".
How does the performance/memory usage compare to say a golang program doing same thing \(some kind of benchmarks\)
Kotlin/Native seems to be in beta for now, and they haven't optimized for speed yet. I'd wait for the official stable release before building performance-critical applications with it.
I see 0.330 ns/op for the primitive version, which doesn't add up to 2ns no matter how you count ops. Did you mean 2μs?
In part 2 (couldn't find a thread for it), you say about the `map` function you define, "Why is that function called map and not invokeUnlessLeft? Well if you squint you may be able to see that it is kind of the same thing as List.map". I'm squinting pretty hard and I don't see. Seems to me to be just a convention. Scala Either is also 'right-biased' (https://www.scala-lang.org/api/2.12.0/scala/util/Either.html).
I'm sorry what. 5038300.166 nano seconds is 5 m/s. I am not ever going to write code that is going to trim off 5/ms. That's effectively nothing. That's less than nothing. Does someone here have a use for it? Probably. Am I, or are most developers going to get any use from this ? Probably not. I hate this digging into the internals garbage, sorry but it just really irritates me. This is the reason most of the software out there is broken crap, focus on making your stuff work.
While I agree you should use primitives where possible, replacing lists with arrays all over the place to save a few nanos is a premature optimization - unless you're doing scientific computing, graphics processing, etc. In typical applications, database operations and the complexity of used algorithms will have a more significant effect on performance.
I agree, that in most cases this doesn't matter, but in real time graphics applications 5ms is a lot. If you want a display refresh rate of 60 frames per second you have 16ms for every frame to calculate.
Not sure if i misunderstood you, but i think that it's totally up to you how you implement your Delegation. The only thing is that you have to provide an interface Implementation - whether it's a singleton object or an instance based thing can be chosen.
Ahh I see. I just assumed that you needed classes since in the examples they always used classes. Thank you! You cleared things up for me a lot!
So you can use any construct which you can invoke setValue(...) and getValue(...) on?! Could you use some arbitrary class, add those two methods as extensions and then delegate from this class, too?
You arn't warming the JIT properly so you arn't getting fair numbers. 
Yes, you only need a class implementing of those property interfaces :) when you think about what's going up under the hood (resulting bytecode), this is fairly easy
That's actually pretty neat :), thank you you helped me a lot!
tbh i find this approach quite unelegant in Kotlin. By extending BaseOvervable you can build much more powerful and flexible Observables (which can be both NonNull and Optional). The so-called special support for ObservableField can be solved with a custom BindingConversion.
Yep, it is for Kotlin which is compiled to JS. So you'd say that for functions like `onProgress` having a function like in the *second* example is good, but for properties a simple `prop = value` is better? 
If the calling code will always be Kotlin the first option looks best to me.
It's not Kotlin\-specific. More of a JVM ecosystem thing. Maven and Gradle build systems can both consume dependencies from any Maven\-compatible repository \(Maven Central, Bintray/JCenter, etc..\)
For 1 million items? I'm sorry, but unless you're rendering particles it just seems absurd. I think that this kind of thing is very okay in a very small space of programs, but for 99% of applications out there it is of absolutely no use. That's why I heavily lean away from it, if this kind of optimisation is needed, I'd like to think it'd be very obvious. Maybe for that reason it's a good idea that this person has done the work up front. I digress
Yup, that's what I do [here](https://github.com/zsmb13/MaterialDrawerKt).
I'm at work so I just too the briefest of looks, but off the top of my head: \- You need to write tests. \- Packaging sample data in your library seems like a mistake. \- Package names should be lowercase. \- Code to interfaces not implementations \(prefer Map, not HashMap\). \- Most if not all of your "Util" functions should be extension functions. \- Try to write functions as single expression when you can. Several instances in utils don't need to temp vars declared, you can string all the calls together. \- In your implementation classes, just init the variables when you declare them, don't use the init block. Easier to read, less code. \- I don't know a thing about ML, but it's hard to tell how to use these. Some functions seem to mutate the state of the object. Might be nice to document these functions. Mention which of them are pure and idempotent and which aren't. I can take a better look later if nobody else jumps in.
Oh yeah, it's both problems. The getter/setter isn't the same for edit text, do it.setText(savedString) 
Awesome thanks! Will be taking these into account
I believe they're still technically optional (I think they have default values of empty strings), but they should basically always be provided. They're also more important than other properties, and this syntax forces them to be listed first in a more visible spot.
His suggestion reads like number 1 to me.
Sounds nice, thanks! I'll use this in my code as well!
&gt; Could you use some arbitrary class, add those two methods as extensions and then delegate from this class, too? Yes, and the standard library does this for Maps and MutableMaps.
So a couple changes I've made: Lowercase package names, using Map over HashMap and Set over HashSet, moved some of my helper functions to extension functions, cleaned up some code overall. I plan on writing tests soon as well. The sample data that I've included is a very common dataset (Iris), is it super necessary to remove it? 
Why dont you go add it? It's open source, take a shot at it.
As I said: &gt;I can probably do something like that myself but then my code won't be understood by someone else. I want to see if anyone at all thinks it would be more convenient first.
It makes code minutely shorter in exchange for being less readable. I'd vote no. 
Fair enough. I find common basic things being long to make things less readable. System.out.println() doesn't increase readability at all. The way I see it, some kind of map, set and array is used over and over again and making them short really helps.
You should generally strive for immutability. Ergo, mutable collections are an exception not a norm, but when you need them the longer, uglier names are a small pittance. Let's not clutter this nice language.
To be fair, that isn't an equivalent statement (but I actually am in favor of first class functions notwithstanding). Let's cut to the chase; you are proposing an arcane symbol solely to shorten function names. I'm not a fan. On the other hand, you can already achieve this with typealiases. Personally I would not like to run across it in a codebase.
&gt; I can probably do something like that myself but then my code won't be understood by someone else. That's your answer right there: If you aren't willing to do it because it will make your code less readable, why should it be added to the language.
It would be readable if other know what it is. Python's () [] {} (set, array, dictionary) are readable because everyone knows what it is.
That's tautological. Everything is readable once people know how to read it.
No, once it is universal for a given language.
&gt; One obstacle to widespread adoption of that is inconvenient syntax at some places, because script people don't like long names for basic stuff. Believe you me, if Kotlin does not get adopted, it will **not** be because it requires you to type `listOf(1, 2, 3)` instead of `[1, 2, 3]`.
It is one straw. That for some (not me in particular) would break camel's back.
The straw the breaks the camel's back implies there are so many other things that are wrong, and you were just at your very final threshold of being able to tolerate it, but then this last piece of BS comes along and then you finally say "fuck it, I've had enough". So, if that's really the case, then it's probably all those other things that the Kotlin team needs to focus on first, instead of the array initialization syntax. &gt; I believe universal language is possible and that Kotlin is pretty close to it. I like Kotlin but I don't think it's anywhere near being a universal language.
&gt; So, if that's really the case, then it's probably all those other things that the Kotlin team needs to focus on first, instead of the array initialization syntax. Other stuff that people would maybe find annoying would include fundamental concepts like nullability that can't be changed (and I don't want those changed). Syntax is easier. Especially since I don't even want new syntax -- I don't want [] --, just shorter names. Like I said instead of mutableYaddaYaddaOf(), just make it _YaddaYadda(). &gt; I like Kotlin but I don't think it's anywhere near being a universal language. To say it differently, I mean universal for all things when you are okay with garbage collection. You would still need e.g. Rust for system work. With some [DSLs](https://kotlinlang.org/docs/reference/type-safe-builders.html) you are more concise than with using HTML templates. You can (or will be able to do soon) compile to JavaScript. And of course you can use Kotlin on a server. That is pretty universal right there
Pakoito has an explanation https://www.reddit.com/r/Kotlin/comments/8dmc5i/functional_error_handling_in_kotlin_part_3_result/dxqyn6w/?utm_content=permalink&amp;utm_medium=front&amp;utm_source=reddit&amp;utm_name=Kotlin
There are static imports in Java to make shortcuts, i. e. call static methods like println without packages. If you want shorter names in Kotlin you can use typealiases.
It's more convenient to write, if you don't have code completion in your editor, but reading something like mutableMapOf happens quickly enough, doesn't it? 
Relying on code completion is less than ideal if I want to use Kotlin in e.g. some kind of console REPL. As I said, I am assessing how [universal](https://www.reddit.com/r/Kotlin/comments/8g3rwk/how_about_shorter_collection_initialization_names/dy93bhl/) can Kotlin be as a language, so I am thinking different environments. Also you have to compare convenience to other languages and Python, PHP JavaScript and even Java (for arrays) are more convenient.
Yes, Perl is even more convenient to write and if you can share very well readable code by using Kotlin, it still can be another level of convenience.
Thing is Pearl, Python etc. are dynamically typed. Point being Kotlin *approaches* convenience whilst remaining static. I am interested how far can you push convenience whilst remaining static.
There is no reason for the let construct here. That just makes the whole thing more complicated that it needs to be
It's now close to a year since Google announced their backing for Kotlin yet with JetBrains and Google behind the language its visibility in the jobs market is negligible. Search for Kotlin jobs by title at Indeed.com and you'll find 10 in the USA and 10 in the UK.
Sounds like an excuse to me. It's a whole year since Google announced its backing for Kotilin. Kotlin is in the same boat as Elixir which also has negligible visibility in the jobs market. Everyone was predicting how it would replace Ruby but job stats show that's not happening.
Popularity without adoption is a hollow metric.
You can put them in a companion object
Ok yeah that's what I was thinking
You've misunderstood the question.
Probably not. The JVM will run the linux or windows compiled .class files the same as long as it doesn't contain API calls. Or explain in other words? 
I'm asking about Kotlin Native, which is a native code compiler, not the bytecode compiler.
He's asking specifically about Kotlin Native, which has nothing to do with the JVM. [https://kotlinlang.org/docs/reference/native\-overview.html](https://kotlinlang.org/docs/reference/native-overview.html)
Oh sorry I didn't see Native in the title... I'm don't know that compiler particularly, but I think that it isn't cross platform since a native binary consists of instructions directly readable from the CPU with the help of OS. 
You could remove $Companion from the name - I'm sure there is a factory method for String. Also it would be nice to provide an asset-like API to make it possible: log.info { "some info with $param here" } With careful use of online function it makes the code run even faster than original template-like messages. 
To add onto this, there is an excellent [stack overflow answer](https://stackoverflow.com/a/34462577/4407321) which addresses this. Reflection is used to get the main class's name, but you could easily trim the string if you wish to avoid that. Relevant snippet: // unwrap companion class to enclosing class given a Java Class fun &lt;T : Any&gt; unwrapCompanionClass(ofClass: Class&lt;T&gt;): Class&lt;*&gt; { return ofClass.enclosingClass?.takeIf { ofClass.enclosingClass.kotlin.companionObject?.java == ofClass } ?: ofClass }
I've been using https://github.com/MicroUtils/kotlin-logging
I create my loggers like this. It correctly names instance, companion, and top level loggers inline fun getLogger(): Logger { return LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()) } class MyClass { companion object { val logger = getLogger() } } fun test() { assertEquals(MyClass::class.java.name, MyClass.logger.name) } More examples [here](https://github.com/kxtra/kxtra-slf4j)
Yes, the Kotlin/Native compiler is a frontend for LLVM https://en.m.wikipedia.org/wiki/LLVM The targets can be specified through the Kotlin/Native gradle plugin konan for example https://kotlinlang.org/docs/tutorials/native/gradle-for-kotlin-native.html
Non-Mobile link: https://en.wikipedia.org/wiki/LLVM *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^177220
That seems like a very good solution. It also has a clever way of getting the class name of top level loggers using a lambda! There is also lazy logging using lambdas, I wonder what the performance difference is compared to using the normal formatting using `{}`: `logger.info("Hello {}", "world")`
&gt; That means compiling for some target cpu and operating system that differs from current. For example compiling for Linux on Windows and vice versa. Not one binary that works on both Linux and Windows.
We'll see how well-adopted it gets. Getting support from Google, Pivotal and a lot of others speaks a thousand words.
It requires Java 7+ and can't be called from Java although a similar practice is recommended by SLF4J https://www.slf4j.org/faq.html#declaration_pattern
Cross-compiling means generating native Linux binaries (ELF) on Windows for example.
Yes, I think that one is very clean! I added that version in an edit. This approach lets you get rid of `$Companion` as well: inline fun &lt;reified T&gt; T.logger(): Logger { if (T::class.isCompanion) { return LoggerFactory.getLogger(T::class.java.enclosingClass) } return LoggerFactory.getLogger(T::class.java) }
I really wanted Kotlin to take off, but I recently went through a job search and I never saw anyone requesting it. If you search job boards it's hard to find any jobs that even mention the "Kotlin" keyword.
I meant bringing up Optional as part of your explanation of Either and Try/Result. It's a very similar data type. Yea, I mixed up the Left and Right, my bad.
As far as Pivotal is concerned I think Kotlin would benefit by distancing itself from Spring which is a framework designed to tame the bloat of J2EE but which has in turn become the new bloated Java. Focusing on Spring will lead to Kotlin bloat, I predict.
You do not need to implement interfaces, just provide `getValue` and `setValue` operator methods - either as members or as extensions: http://kotlinlang.org/docs/reference/delegated-properties.html#property-delegate-requirements
In Datasets, you should probably be loading these files as [resources](https://docs.oracle.com/javase/8/docs/technotes/guides/lang/resources.html). Agree with the other commenter about tests - they're really essential. Aim for at least [70% code coverage](https://www.jetbrains.com/help/idea/viewing-code-coverage-results.html), or if you really want to push the envelope, play around with [mutation testing](http://pitest.org/).
So it should download dependecies by itself using Gradle, it is kinda cool, though I will need to integrate it with my own build system. Anyway thanks, I will try it out.
I prefer to use Log4J2. Log4J is split in an API, similar to slf4j but more powerful, and the actual logger implementation. With Log4J you can simply write: val logger = LogManager.getLogger() You can use the Log4J API with different loggers such as logback. And you get a more powerful API making use of lambda expressions for example.
My point is that (I think that) classes have an extra cost because they have to save, or at least reserve the possibility to save state. So I wanted to use something that doesn't have this cost. A companion object would still sit inside a normal class. I don't know if that's true. If ao that cost surely isn't that significant but it made me curious. I always welcome corrections though :)
I actually made a Kotlin logger myself, just for lightweight logging. No instantiation required, just invoke the Logger object. https://github.com/serebit/loggerkt
I ended up getting this and Modern Web Development with Kotlin.
You don't need an instance if the class to use a companion object
Will do! Thanks for the tips
Just @Log with lombok. but I haven't tried that with kotlin. https://projectlombok.org/features/log
Lombok modifies the Java source code and thus does not work with Kotlin at all. Same for the @Slf4j annotation.
The article raises an important point where Java and Kotlin differs, but luckily there's a simple solution. TLDR: Unlike Java Streams Kotlin collection functions are evaluated eagerly by default. If you want lazy evaluation, like in Java Streams, use `asStream`. 
Wow. That could have been two lines. Also the beginning is wrong. &gt; This is one of the reasons why the only reasonable way to enrich the API, was to introduce a new abstraction – the Stream API.Streams aren’t collections so the API could be designed from scratch. Streams were introduced in Java 8, simultaneously with default interface methods - which is how streams were added to the collection interface. Oracle could have used the the same mechanism to provide map, filter, find, etc. (though they probably would have to add each method to each collection-subinterface). 
You'r right. I thought of `asSequence` but didn't write it ... It's fixed in my comment now.
WTF with these downvotes ? He just miss understood the question, he didn’t insulted or broke any rules nor provided bad/fake content... Seems like mistakes aren’t permitted here... what an openness...
I'm working on a [little library](https://github.com/abissell/kmpp-logging) to set up my loggers in a convenient way in multi-platform projects. It starts from a [fork of the MicroUtils library](https://github.com/Lewik/klogging), which I've found to be the best multi-platform implementation so far. I really only have use for loggers in static fields, i.e. on companion objects: companion object : Log() {} and top-level loggers: private val logger = initTopLevelLogger {} For the moment, everything just works by getting the `String` representation of the class derived from the `Any` owner passed into the builder, and then truncating it in various ways. I could probably make it more robust with separate JVM and JS implementations, but for the moment it works fine. I did have to suppress an IDE warning about leaking the `this` reference inside the abstract class constructor though!
I'm pretty sure they're not, don't quote me on that though
In case someone else is wondering &gt; KOIN - a pragmatic lightweight dependency injection framework for Kotlin That'll save you 3 clicks.
This brings a new question that I think should have been addressed in the article. Why are kotlin collections methods not lazy by default? I'm sure the answer is because that's the safest default but I'd still want to know
You can expect collections to be eager pretty much everywhere. If you want to leverage laziness/short\-circuiting, you need to look for a lazy sequence equivalent, in this case \- [https://www.scala\-lang.org/api/2.12.3/scala/collection/immutable/Stream.html](https://www.scala-lang.org/api/2.12.3/scala/collection/immutable/Stream.html)
I also don't see anything wrong with it being lazy by default which brings me to my question.
I mean I don't think many people have to be convinced to use Kotlin on Android. It's more about migrating existing applications with years of legacy, which is not easy or usually considered to have business value to any large company. Especially if it's an app with a large user base.
Time is on our side :)
As much as I like Kotlin, I equally dislike N26 :) But good for them to switch to Kotlin anyway. 
For me that is a non-issue. Good thing with Kotlin is that you can start using it right now for every new class you write in your existing Java project. Also the Java to Kotlin converter is very powerful. So converting legacy code to Kotlin is a bliss. You even learn quite a lot by converting existing Java classes to Kotlin.
Just guessing they wanted to be as close to Java as possible. IIRC they use the Java collections as their backbone on which their collections are built.
Is this better than dagger?
Their customer support is non existing
I already use dagger, but it looks so heavy and slow So koin is similar to dagger 1 than
dagger 2 is actually fast at runtime, since it does it's work at compile time. koin/kodein are definitely more lightweight than dagger 1 and much nicer to work with. I used both koin and kodein in multiple projects and I really like them. One downside as opposed to dagger is lack of compile time safety. That bit me before and probably will bite me again in the future.
weird, I contact them two times and the support was great..
It turns into Kotlin, but not very idiomatic Kotlin. I honestly have come to prefer leaving things unconverted, and maybe converting the logic to Kotlin so that I'm more reimplementing rather than wholesale converting. It's just so much neater than cleaning up the code that was translated by the tool.
It wasn't that bad for me, but it took them over a month to respond to my query. While with classic bank I can just walk into the branch at any moment. 
Unidiomatic Kotlin is still better than Java.
Since all elements are already in collections \(Streams compute them lazily\) \- going eager is the most natural way \- essentially, those methods are just a syntactic sugar for classic looping. If you wanted to make them lazy, you would need to involve some additional tools to achieve that \(unless we're talking about some fancy hybrid form of collections\), and this is exactly what Kotlin is doing at the moment, if you want to be lazy, create a Sequence that is pulling elements from some source lazily and then repackage to the collection of your choice. But for many simple scenarios, that will be an overkill, this is where a simple eager *map\(\)* will thrive. Does that make it more clear?
I disagree, but not from any love of (even idiomatic) Java. Reading, and understanding, code is far harder and more important than writing code. Unidiomatic Kotlin is going to be difficult to understand for both Java and Kotlin developers. It'll all end up as bytecode in the end, so leave it in the friendliest state possible for human comprehension.
&gt; I mean I don't think many people have to be convinced Actually they do. Kotlin also has downsides in comparison to pure java. If it would be an uncondional improvment, adoption rate would already have spiked.
fun&lt;T&gt; l(vararg t: T) = t.toList() There you go. l(1, 2, 3) One char diff compared to specialized syntax. I rather have library methods than a clusterfuck of language features. 
I did not ask for specialized syntax. I asked for shorter names. (But not that short).
Why exactly would you want to convert ObservableField&lt;T&gt; to T? Usually you want to return a string or an int. What is the databinding system supposed to do to transform your T to a string? I tackled that by never binding an ObservableField&lt;T&gt; to a textview or something, so the using class needs to provide a T to String transformation (by initalizing TransformedObservableField) This way the using class can decide if it uses an optional value or not by specifying it in its generics. I then wrote a binding conversion from TransformedObservableField to String and I'm done
https://media.ccc.de/v/33c3-7969-shut_up_and_take_my_money 
Yeah, but what you describe is a quite specific type of binding which also should work. The stack overflow post complaints about generic conversion.
I meant I have more usecases like that. So I'll probably have to write BindingConversions on a case by case basis, which is a bit of boilerplate. 
Uhm that's not true: the `Unit` type has exactly one value: `Unit`.
Why does mViews.remove(position) not work? If you really want to set the value to null, you must set the type of mViews to MutableList&lt;CardView?&gt; (note the ?, to make the Type nullable). Regarding the val cannot be reassigned: I think you can just remove the private setter. Or is there a reason you set the value of super baseElevation, but not the current? Thats confusing imo. Instead of 0.toFloat() you can also write 0f.
I think their software is also very insecure
that means you are trying to remove something from the list without you having added anything to it. that list is empty. I think there might be an error in your code. you could just create a fail check though, something like: ``` list.getOrNull(position) ?: return mViews.removeAt(position) ```
I'm actually curious as to what Android studio has that intellij with the plug-in doesn't.
I’m writing a websocket Spring Boot backend that uses Kafka for persistence, it’s basically just a PoC
This sounds fantastic, something I would definitely want to use. Thanks for sharing.
Just started learning Kotlin for app dev. I have no experience in Java and only minimal experience with app development. My aim is to make an app for tone interval training. 
At work I'm working on a admin-console with a Kotlin REST backend + vuetify frontend. On my spare time I'm making [Javalin](https://javalin.io), a web framework.
I am working on porting Java Topology Suite to multiplatform! 
Also working on a Kotlin 101/cheatsheet : http://www.slatekit.com/kotlin101.html 
[A simple grid collection for writing things like chess / checkers games ](https://github.com/Vincent-Carrier/kgrid)
Swipe In, Swipe Out system to keep track of equipment use. Kotlin Rest API and a React JS web frontend.
Very nice, thanks. I'll like this to kt-curious coworkers.
I work I'm actively evangelizing Kotlin for use in a financial services company that is used to Java. I'm making good progress in that I have people interested and have written a few small things in Kotlin \(back end\) destined for production. At home writing an adjudicator [for the game Diplomacy](https://en.wikipedia.org/wiki/Diplomacy_(game)). It's not the most challenging or glamorous bit of code, but it's fun so far. I'm also working on a conference talk around Kotlin, and have about 3 blog articles half written on various subjects \(some of which has Kotlin for the examples\).
At work, I'm building out a slew of intranet-based utilities using Spring Boot for the backend and VueJS for the frontend. The most recent sub-project was a tracking and communication/notification system for special order merchandise that integrates with our ERP and point-of-sale systems. Also built a few simple-ish CRUD apps and reports that deal with data that is ETL'ed from the ERP database. Getting Spring to crank out REST data in a way that VueTable could work with wasn't too hard; VueTable 2 "expects" a Laravel backend with 1-indexed paging and a slightly different structure from what Spring HATEOAS typically spits out, but there's an optional transform() method on the VueTable side. Integrating with the point-of-sale setup was a bitch and a half, though; the firm who built the software have no concept of how immutable primary keys work, or why something like a retail transaction history should, I don't know, maybe *not* delete all of the original fucking rows every time the sales transaction is reopened and altered. They also don't seem to find it necessary to explicitly track the state that a special order merchandise request might happen to be in at any given point, so there is no field anywhere in the POS or ERP software where the buyer can say that they've put out an order to the vendor, that the item is en route to the distribution center/branch, or that something that started out as a request for a price quote is now supposed to be ordered. I was able to reverse-engineer something like 85% of the data flow, so my utility can "detect" when a request's implicit state changes and raise notifications to the buyers or the retail branch accordingly. I probably just automated two-thirds of their workflow for these damned orders. The ERP system's sales transaction IDs are probably the worst part of it all, too -- they're 14-digit alphanumeric strings, and they're case sensitive. I watched one of the buyers fat-finger an ID six times before I said fuck it, since you guys all have barcode scanners, you're getting barcodes on your printouts. So yay for Kotlin/Java interop and being able to yoink in Barcode4J.
Card Game in libgdx with antlr and of course Kotlin
Have you considered using kotlin/js?
I'm migrating an old android app from Java to kotlin, just a sample to test stuff, right now adding dagger. 
I originally looked into using the kotlinx html dom, but the learning curve is too steep and documentation is non-existent. At the end of the day it was easier to use React.
Scheme R5RS implementation in Kotlin: https://github.com/kovrik/scheme-in-kotlin Not strictly R5RS, more like a hybrid of Scheme + Racket + Clojure. PS: readme is a bit outdated 
Working on a toy project to run sql against json files etc https://github.com/tim-patterson/jsonsql Hoping to circle back and try to learn/apply more kotlin idioms.
Which are? I'm not saying there aren't any, but I'm wondering which you have in mind.
I'm working on [kobalt](https://github.com/Hexworks/kobalt) which is a browser toolkit for Kotlin which compiles to JS. It has 3 modules at the moment: `event`, `http` and `html`. I decided to open source this because it might be useful for others. I use it on my own projects, but anyone can grab it from JitPack and it will just work on any Kotlin2Js project. Another project is [zircon](https://github.com/Hexworks/zircon) which is a text gui library. Currently I'm working on the `TextBox` (it is like a `textarea`) which was rather buggy and I refactored the code to use a proper state machine for insert/cursor move/delete.
Can you elaborate on this? Does it have anything to do with task managmenet and topology sort?
This ones come immediatly to my mind: * Compilation speed * Not every IDE supports it * Deeper Stacktraces * The risk of slower runtime performance * Some tools depend on java source code and will now not longer work * It takes a while till your existing programmers are capable of fully leveraging Kotlins capabilities * Given that you are already maintaining java projects, it increases complexity because from now on your programmers need to know switch between 2 programming languages mindsets. I am certain that there are many more, but that would require to think little bit longer. For whoever owns the project, it pretty much boils down to one single question: * What is the price/risk if we switch our programming language?
Hey, cybernd, just a quick heads-up: **immediatly** is actually spelled **immediately**. You can remember it by **ends with -ely**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Yeah, there are a couple, but then again, in my opinion and based on what I've observed myself and seen data elsewhere, most of these are almost negligible: - compilation speed is only marginally larger than Java's (ie. maybe up to 20%, mostly lower), provided you don't mix your code (in which case the impact is larger) - I haven't noticed the issue with deeper stacktraces, do you mean because of the Kotlin's standard library functions? - performance is the same, though there is indeed some risk if some patterns are used incorrectly (though that also applies for Java, for example lambdas are cheaper and lighter in Kotlin than in Java 8) - in our case, programmers totally unfamiliar with Kotlin were able to pick it up within days, at least to the level of Java proficiency (functional programming and other things added on top of Java need more time). So you're not wrong, it takes time for them to fully 'get' it, however not much time to be as productive as in Java I would also add that in some aspects, Kotlin is more "free" than Java, allowing potentially more instances of bad patterns and poorly written code (extensive and improper use of builtin higher-order functions), though this is only a fraction of a problem seen in Scala (where it's really a mess). In bottomline though, the benefits far, far outweigh the costs in my opinion (and indeed everyone I've worked with who's tried it). 
Sure. Java Topology Suite (JTS) is a library for creating and manipulating vector geometry. Currently there are ports for a variety of languages. I think it would be beneficial to be able to use the same API to manipulate geometry on all platforms that kotlin can target. Here is the github link to JTS: https://github.com/locationtech/jts
Continuing to improve [KotlinTest](https://github.com/kotlintest/kotlintest), a powerful, elegant and flexible Kotlin test framework. Recently added support for matchers for Arrow, which is cool. Then we're going to look at adding more extensions, such as assertions for http libraries.
Dagger's compile time safety isn't really that great, especially not on Android with the `dagger-android` additions. It's still easily possible to forget an annotation somewhere and have a runtime crash instead of a compile-time error.
That's cool! Why did you choose Maven over Gradle?
I have yet to make the repository public. Currently multiplatform is only supported by gradle so it is using gradle. The link is to the library i am porting. I still have some things to decide before i release it for others to contribute to and use it. 
And since return type is `Unit`, fact that `Unit` is returned gives no information at all. This is why lack od arguments in Haskell is insicates by `Unit` (`()`).
Hell yeah Javalin! 
You can use Kotlin-react! ...but the documentation thing is still true. 
Teaching myself Kotlin, reflection and server-side programming by writing a model-binding library for [spark-kotlin](http://sparkjava.com/) - adding SpringMVC like functionality without using Spring [caisson](https://github.com/v79/Caisson).
I'm making [Javalin](https://javalin.io), which has a bunch of tutorial for common web things. It's more like flask than Django though, so it might not have enough features for you. If you want a full framework then spring boot is very popular. It's originally for Java, but they have added extensions to make it more kotlin friendly. 
Spring Boot is pretty great for big projects: http://start.spring.io/ I also tried ktor for very small things: https://github.com/ktorio/ktor
I would recommend Spring Boot with Kotlin, too. Spring just solves so many real world problems! And you get a wide variety of modules. 
On the same way as you, I'm a starter at app dev using Kotlin. Tried Java before, but I was not able to finish something. Now I'm working in some apps for the visually impaired. Lots to do about presentation (text size, color) and using voice. Working all right so far.
Try Kotlin.link. Tons of Kotlin stuff.
I'd also go with the Spring Boot answers. Some things I'd like to point out that most blogs about Boot are crap. You should read the [reference docs](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/) instead. This is one of the most well written docs I have ever read! If you need performance though Spring is a bit lackluster in this regard, but in that case [vert.x](https://vertx.io/) could be another widely adopted project with very good documentation. Shameless plug: I've written [some articles](http://the-cogitator.com/posts.html) about Kotlin which could be useful to you! 
Thanks! Will take a look.
Thanks for the info!
Great, thanks, I'll give the docs a read! 
I have a production server written in KTOR, a fully Kotlin webserver, so far I've had zero issues with it except it lacks documentation.
I don't understand myself. But I created alternatives here (For mutables, as immutables are short enough) inline fun &lt;K, V&gt;_Map(vararg pairs: Pair&lt;K, V&gt;): MutableMap&lt;K, V&gt; { return pairs.toMap().toMutableMap(); } inline fun &lt;T&gt; _List(vararg elements: T): MutableList&lt;T&gt; { return elements.toMutableList(); } inline fun &lt;T&gt; _Set(vararg elements: T): MutableSet&lt;T&gt; { return elements.toMutableSet(); } Here you go.
Seven hours without anyone saying: your video doesn't work 
You mind me asking what blog post that was?
If you build it as an Android Gradle Plugin you've got [Variant.registerJavaGeneratingTask] (http://dcow.io/android-gradle-plugin-docs/com/android/build/gradle/api/BaseVariant.html#registerJavaGeneratingTask(org.gradle.api.Task%2C%20java.io.File)) then Gradle and Android Studio knows about your generated code.
What you need is a TypeToken. I generally define this function: inline fun &lt;reified T&gt; Gson.fromJson(json: String) = this.fromJson&lt;T&gt;(json, object: TypeToken&lt;T&gt;() {}.type) and then call it like: gson.fromJson&lt;MyMap&gt;(jsonblob) 
This one :\) [https://medium.com/@magnus.chatt/why\-you\-should\-totally\-switch\-to\-kotlin\-c7bbde9e10d5](https://medium.com/@magnus.chatt/why-you-should-totally-switch-to-kotlin-c7bbde9e10d5)
Ah, thanks for posting. Glad it has been done without issues. 
Note that instance will not contain the metadata that says its a HashMap of String, Int, just a HashMap of Object, Object. You need to actively create a(n anonymous) class to save that information, due to Java's type erasure. Hence the TypeReference/TypeToken objects. (Notice the {}? That's creating an anonymous subclass)
Awesome! Glad you liked it :D
&gt;distributionUrl=https\\://services.gradle.org/distributions/gradle\-4.6\-bin.zip It worked, thanks mate!
Oh, I'm a derp. Thank you.
[quicktype](https://app.quicktype.io/?l=kotlin) infers types from JSON data, then outputs models in Ruby, Swift, Objective-C, and many other languages for reading that data. You can also input JSON Schema, TypeScript, or GraphQL queries using our CLI. We just released Kotlin support today, and we're looking for feedback on the generated code, or what we could improve. Thank you for taking a look!
This is pretty neat! I may use it for some of my projects in the future.
The page-blocking ad that I can't close is great, but I would have rather read the article.
Wonderful! I'll definitely be using this.
If you are interested in using delegates you can take a look at https://discuss.kotlinlang.org/t/weakreference-lazy/4463/4?u=kotlinikov to simplify boilerplate.
Same except now I moved onto Spring Mail and I'm working on email confirmation stuff right now.
I put 50MB of JSON into it and the tab crashed. Anyone know how to reduce JSON to minimum representative?
Math.pow?
There is none, theyre functions of Double and Float called pow()
I have never used Fuel, so not sure if that matters, but if you're speaking about best practices, why would you choose Fuel over something like Retrofit or Feign?
Fuel felt more lightweight and easy to get started. We recently revamped the team and most are junior devs with less to no experience on Android. So fuel felt the easiest to "pick up"
I'm kind of surprised this isn't an infix function
Spring, Vertx, Spark, DropWizard. There's a couple Kotlin originals like HexagonKt and Javalin. You can't go wrong with Spring Boot as Kotlin is getting a heavy spotlight there. That said, Kotlin is suitable as much as Java itself or any other JVM language is suitable as they all pretty much run on the JVM. I'm personally watching [Proteus](https://github.com/noboomu/proteus) since it fits all my requirements (MVC routes, Swagger first, not mangling its own DI) and have nothing too magical like Spring.
I really like Vaadin.
The [quicktype CLI](https://www.npmjs.com/package/quicktype) should be able to deal with your JSON. If not, [please report it as a bug](https://github.com/quicktype/quicktype/issues).
Non-Markdown version of the links In this comment: **Link Text:** quicktype CLI **Link URL:** https://www.npmjs.com/package/quicktype **Link Text:** please report it as a bug **Link URL:** https://github.com/quicktype/quicktype/issues ^(Preventing misleading links on reddit by providing the links behind the markdown. **Why?** u/reallinkbot/comments/8igale/why_do_i_exist/)
Take a look at [Kweb](http://kweb.io/), it's a fairly novel approach to a web framework. All of your code remains in pure Kotlin on server-side, yet it lets you interact with the browser DOM as if it is local to the server. It's still fairly experimental, but it is being used actively on a few projects.
Try Spring Boot, it's very nice framework and has official kotlin support. 
Yes, we're exploring Moshi right now: https://github.com/square/moshi/issues/528 We'd love some guidance on using kotlinx.serialization. We're not Kotlin developers and have found kotlinx.serialization a bit confusing so far.
We use ktor and are very satisfied. With kotlinx.html you can even write isomorphic apps all in kotlin! There are even bindings for react (haven't tried it though).
Vaadin. 
Could you elaborate a bit on what you consider a webapp? Do you want to create the whole app (backend + frontend) in Kotlin? Do you want to create an API with a JS frontend? Do you want something simple with server side templates?
Additionally, does anybody have experience using Vue with kotlin? About to start a project, and I'm doing what I can to avoid javascript.
Well, to begin with you pretty much never use Arrays in Kotlin (or Java for that matter). Stick to Lists and avoid having to index in lists. For future reference, if you absolutely have to print the content of an array, use Arrays.toString(myArray). You're probably not looking for a nifty regex-solution but here is one anyway val data = """"{"rates":[{"rate":0.3859,"to":"AUD"},{"rate":0.3756,"to":"CAD"},{"rate":1.8701,"to":"CNY"},{"rate":0.2509,"to":"EUR"},{"rate":0.2073,"to":"GBP"},{"rate":19.4607,"to":"INR"},{"rate":32.7070,"to":"JPY"},{"rate":0.2953,"to":"USD"},{"rate":1.00,"to":"BRL"}],"baseCurrency":"BRL","timeStamp":1524858608,"executionTime":85,"licenseMessage":"Data Retrieved From www.ExchangeRateLab.com - Under license (Not for financial/professional use)"}""" println("\\d+\\.\\d+".toRegex().findAll(data).toList().map { it.value } )
Thanks Fojji, for taking your time to help me. I worked with lots of functional languages, but still trying to get the hang of Kotlin/java. 
Thanks Cmorriss, for taking some time to help me. 
You can also use Array.contentToString method, if you want to use the array type for any reason
I have use http4k and found it to be very nice. The docs are good and the slack channel is active.
Disclaimer - i have yet to use it in enterprise, just in my pet projects. I use Ktor. It's rather nice because of the "unopinionated" paradigm its team has.
As one of the authors of http4k, I can add here that it's battle tested in production. See the [blog post](https://www.http4k.org/blog/meet_http4k/) for details. Or feel free to shoot over some questions :) 
To complement this, you could wrap the MongoClienr instantiation with a try catch block so you handle the possible exception you might get when having a wrong port... You could also verify the port in advance and create the instance of the mongo client if it's correct.
Oh that makes sense, for some reason I thought infix functions had higher operator precedence
This is an excellent article. Thanks for writing it! Time to build my first TornadoFX application.
Thanks once again. Now I had the time to look at the code on a computer (yesterday I was reading on a tablet, code was all piled up), and using single line functions and the right extensions make the parsing a cinch. After getting the data I want, I'll try a json library to parse it in a more efficient way. Is Gson good enough?
Wrong subreddit, VERY incomplete question. Try [stack overflow](https://stackoverflow.com).
THAT is a really interesting paradigm. Thanks for posting this!
Thank you! I'm the creator, really looking for people to use it and give me feedback as it's mostly been a personal project so-far.
I currently have an application up and running with this, 10/10 would recommend. The documentation / knowledge base is invaluable.
Graphics issues are often caused by using OpenJDK instead of the official Oracle binaries.
Nice features but what's up with the package name `com.rubylichtenstein.rxtest.extentions` and it containing a file named `Extantions.kt`?
Gson is excellent :)
You can always just call [`.joinToString()`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/join-to-string.html) on Array, that would do the same thing and gives you flexibility to change the format. No need to iterate or convert to a List just to print it. 
Hi Jim, This is really helpful, thanks so much. I will give it a read and see what I can get out of it. Appreciate this help :) 
Official site - kotlinlang.org Also search for kotlin-koans - an online ide-like tool that teaches you. I think it’s also supported by JetBrains. It can also be found as an IntelliJ Idea plugin, if you use it. Books - Kotlin in Action. There are probably others as well, but this one is by 2 guys from the Kotlin team, if I remember correctly.
I learned it from just going through the [reference documentation](https://kotlinlang.org/docs/reference/), but I already knew Java beforehand. Still, it gives a detailed overview of language features. If you're not familiar with IntelliJ, you might also want to check out this quick guide: https://kotlinlang.org/docs/tutorials/getting-started.html. Most Kotlin projects will be using [Gradle](https://kotlinlang.org/docs/reference/using-gradle.html), but you learn the basic of that later. I also liked the introduction videos from this and last year's Google IO, which show some common patterns and things to avoid. https://youtu.be/X1RVYt2QKQE https://youtu.be/6P20npkvcb8
I second this. The documentation is very good, very straightforward for the language overview. And the Kotlin koans are a fun way to learn the language by doing.
Better try out the OReilly Kotlin course by by Hadi Hariri. He works in JetBrains and gave Kotlin intoducrion talk at io17.
If you are programming for Android so the book kotlin for Android developers by Antonio Leiva is great!
Given the languages mentioned it seems likely they're doing server side work.
I plan to learn kotlin specifically for android dev. I've never been a fan of java, so this alternative seems okay to start making simple apps.
I was wrong X_X
It's not an "alternative" anymore, I would say it's the way to go. You can see it yourself, there's no a single line of java (maybe one or two) presented during the Google IO, everything is done in kotlin nowadays.
Dev is actually my hobby, and I like to learn new stuff. I started with C back in 2006 iirc, then moved on to C++, but I never really got into it at the time. I then tried to learn Java, but found it too verbose, and not really convenient enough, and in 2012 I picked up python, loved every minute of it, and I picked up C# in 2017. Now I'm trying to broaden my experience, sincee I'm already proficient enough in all those languages, plus enough PHP and JavaScript to maintain my personal website. I think Kotlin may be a great addition to my developer toolbox, and the only thing I can't do right now is android dev.
I'm using it as a drop in replacement for Java on the server, since I get to use all of my favorite Java libraries in a nicer language. I alsways liked Java though. 
Wow
I quite like this solution: https://medium.com/@BladeCoder/kotlin-singletons-with-argument-194ef06edd9e
Thanks for the article. I would like a solution where I can put the initialization directly with the declaration, so not in the onCreate. Unfortunately I get a NullPointerException with that solution, because context isn't ready. My current code with this solution is val db = AppDatabase.getInstance(this) override fun onCreate(savedInstanceState: Bundle?) { // ... correct?
Nope, use directly AppDatabase.getInstance() when you need it (in your onCreate) or make db load lazily (by lazy {}) and the context will exist when you try to get it.
I'm reading Programming Kotlin, a very comprehensive book, it covers many topics about oo and functional programming, though some of the examples are not very practical, it gives you a 'keyword' to dig in. 
Just like you, I discovered Kotlin recently and It looked like an amazing language to me, so I started learning it, since I have some Android app ideas in my head. If you are interested in Kotlin as a language, without the Android part, I would recommend the "Kotlin Fundamentals" course by Kevin Jones on Pluralsight. That's the resource I'm currently using for learning Kotlin and I'm lovin' it so far! Other than that, I would like to use Kotlin for Android development, so If anybody can recommend a good book for Androind development with Kotlin, I would highly appreciate it.
I wonder if it is really beneficial to have `lazy` loggers. I think in most long running applications the logger of most classes gets called sooner or later, so that the case the logger is not needed is pretty rare. And it should be relatively cheap to create a logger instance. By the way: Log4J 2 offers an logger independent API similar to slf4j, but more capable. You can even use the Log4J API with Logback for example.
Not only that, but adding logger into a companion object makes sure that the logger would initialized only once for all entities of s single class.
That's why I don't get this article... Lazy to me is very useful when dealing with large collections or postponing things that might not happen - lazy loggers just seems very strange, as I'd imagine instantiating a logger isn't that expensive, but I could be wrong
The second approach, with delegate, is most useful when you don't want to put your logger in companion object. Therefore the laziness is making sure that we always have only one instance of logger per class. In most cases, Kotlin is more concise and has better syntax than Java. For me, companion objects don't look tidy and I try to avoid them. Maybe there's someone like me, so that's why I put the lazy logger declaration in this article.
Also, Log4J caches your loggers, so the performance cost is negligible.
I see, I personally don't really mind the companion object, I'm normally okay with putting something there
I've used this one recently https://github.com/MicroUtils/kotlin-logging Which allows you to create a logger with a simple private val logger = KotlinLogging.logger {}
You've pretty much summarized the article without even bothering to read it. It's amazing.
&gt; Therefore the laziness is making sure that we always have only one instance of logger per class. Not quite. Lazy ensures that the initialization happens either zero or one time, and only if utilized. Moreover, oven the usage in the blog post, that will occur once per class _instance_, not once per class.
I tried this when it first came out but got lost trying to add the security integration - how's that work now? Maybe it was just me being dumb, but I had a very hard time with it :/
I've been learning Kotlin over the last week or so and for me, the best resource is just trying stuff. My background is in Electrical Engineering, so most of my work is in plain ol' C, but I was still able to pick up Kotlin and hit the ground running within a couple hours (I know a little Python, and I am also self-taught and reasonably skilled in Java and C++, so those pools of experience probably helped a bit). I think you'll find that Kotlin feels *kinda* like a hybrid between C++ and Python. You didn't mention Java as a language you're familiar with, but if you've ever used Java, you'll feel right at home with Kotlin even though the syntax is different in a lot of ways. I'm not the most experienced Python guy, but the way Kotlin uses lambdas reminds me of Python, and the ability to assign variables without explicitly stating their type is DEFINITELY a Python thing. IntelliJ is by far the best IDE I have ever used, and I've used a ton of different IDEs for a bunch of different languages. It practically writes your code for you. I'd suggest hopping into IntelliJ, making a Gradle Kotlin project (Gradle is also very easy to pick up, and learning it has made my life a million times easier), and start goofing around with it: Make a list of things, and make a for loop that iterates through that list of things. Since you know Python, the Kotlin syntax for a for() loop will come to you naturally. Now replace the for loop with "yourlistofthings.forEach{ println(it) }". Congratulations, you now know one of the fundamental things that makes Kotlin a super cool language. The toughest thing to get used to is the way Kotlin handles nullable and non-nullable types. It's certainly not something I have dealt with in the languages I've used throughout most of my life (C, C++, and Java), but I'm gradually getting more comfortable with it. Although this is the thing it took me the longest to get used to, I've realized that it is *insanely* powerful and I honestly wish it were a feature in more languages.
What kind of security? JWT? I have used following example to try to understand this. Its Java but it should easily convert to Kotlin. https://github.com/szerhusenBC/jwt-spring-security-demo
Haha.. I did read. I swear it referred to a different library. Was thinking it was really similar to the `mu` one linked. :)
another pointless medium article that repeats the obvious. All this is on the kotlin docs. 
What's interesting in this article is the discussion it caused in java subreddit: https://www.reddit.com/r/java/comments/8cv24s/a_day_with_kotlin_what_kotlin_has_that_java_does/
A few other notable difference to be able to at least "do everything in Kotlin that you can do in Java": - `if`/`else` expressions instead of Java's `?:` - `when` instead of Java's `switch` - `in` and `out ` for variance, instead of Java's `extends` and `super` There are probably others.
Ok this post has convinced me to look at nim\-lang; I've been ignoring it for long enough now. It's pretty close in terms of memory overhead; so for IO bound processes it should work well. 
If you're looking for books, I'd recommend [Kotlin in Action](https://www.amazon.com/Kotlin-Action-Dmitry-Jemerov/dp/1617293296/ref=sr_1_1?ie=UTF8&amp;qid=1526365493&amp;sr=8-1&amp;keywords=kotlin+in+action). It's by a couple of core developers for Kotlin. The book is relatively short, it's pretty practical but not platform specific like it's not only for android.
Good catch! I'd argue though that except for 'when' these are just syntactic differences. It does exactly the same but with different keywords
Good catch! I'd argue though that except for 'when' these are just syntactic differences. It does exactly the same but with different keywords
Damn! Rust is fast and light!
Kotlin/Native has received 0 optimization for now, as JetBrains said. It will come when approaching the 1.0 release.
Shameless plug: I've written about this [here](https://medium.freecodecamp.org/going-beyond-android-kotlin-on-the-backend-2a75eef2582b).
I've tried a lot of JVM languages before (Scala, Clojure, Ceylon) and none of them worked out for me for different reasons. Kotlin was the first which is just in the **sweet spot** so I adopted it 2 years ago. This is not surprising for me but at last now I am not an early adopter anymore. :)
I completely agree on `if`/`else ` expressions, but the way variance works in Kotlin is more than just syntactic sugar. In particular, Kotlin [lets you specify variance at declaration site](https://kotlinlang.org/docs/reference/generics.html#declaration-site-variance). data class Foo&lt;out T&gt;(val x: T) fun bar(foo: Foo&lt;Shape&gt;) { ... } val y: Foo&lt;Circle&gt; = whatever() bar(y) In Java you'd have to say `Foo&lt;? extends Shape&gt;` in the signature of `bar `, and anywhere else you accept a `Foo&lt;Shape&gt;` to get the same behavior as Kotlin.
Can't believe nobody has mentioned this yet. The official koans https://kotlinlang.org/docs/tutorials/koans.html
Bonus points for function references like nullableResult?.let(consumer::accept)
Extra double bonus points!
I'm a Kotlin newbie, but I'm working on making bindings for the Last.FM API for Java. The only similar option out there for Java developers is absolutely atrocious, so I figure this might be a good way to learn Kotlin while also doing something useful.
Yeah it's funny to see this. It's been so stable for so long. I started writing tests with it just before their 1.0 release after watching it for a few years. 
Yep. This is my second workplace where I introduce Kotlin. Since it is so cheap to adopt and easy to learn it spreads even without me evangelizing it.
As someone who was working in Scala earlier and currently using Scala on the job, I can definitely agree with their analysis. Kotlin is in a sweet spot, is much easier than Scala, quick to pick up, and has enough functional programming elements to be powerful for most applications(both android and server)
https://github.com/FasterXML/jackson-module-kotlin/issues/50 mentions an ugly fix but this actually works. The constructor property is ignored and instead provide a dummy getter for the purpose of doing the unwrapping. @Embeddable data class Quantity(val qty: Int = 0) @Entity data class Product( @JsonIgnore val qty: Quantity = Quantity(0) ) { @field:[Id GeneratedValue(strategy = GenerationType.AUTO)] val id: Long? = null @get:JsonUnwrapped private val _qty: Quantity get() = qty } I am really not keen on this though
C has had this since the 90s.....
Nice read - the website, design and illustrations are on point and look pleasing I had a somewhat terrifying experience with a c++ legacyase that heavily relied on typedefs, which put me off of those until now. Im glad to say the article opened my mind a little bit again!
I love Kotlin, and if my team was picking up a new stack I would push for Kotlin/Spring Boot/Postgresql as well. I think this community and Postgresql are great ones to join. As for candidate search, I'm personally really responsive to messages on StackOverflow. I almost always delete recruiter emails, but respond to everyone who messages on StackOverflow.
I am happy to hear another voice saying we aren't deluding ourselves with the tech choices! I will check out the postgres community on reddit as well. You don't think it would be untoward to just message developers on StackOverflow about an open position?
It's a terrible way to find someone, and probably against SO terms of service, but nobody will stop you.
I honestly thing it harder to learn the in and out of springboot than kotlin Dont bother looking for Kotlin devs; they are very rare. Get someone with a java background &amp; springboot experience and give them a couple of week to get comfortable in the language. That's what i've done. 
I completely agree, I have found TONs of great resources on Kotlin, both from Jetbrains and the community while I've found comparatively few good idiot level guides to springboot. I just stumbled on a video of a talk that seems good so I haven't give up hope. That's exactly what I've been searching for and I have no problem letting someone get up to speed. I think I need to find better places to post my job ad. LinkedIn and Indeed have been huge busts so far.
Ah. I thought `let` was some kind of keyword, because often other languages tend to have that keyword. But anyways, the reason why I use `let` instead of `if != null` is that for a member variable, if I use `if != null`, I get that "the variable can be mutated and can be null by this time" or something message. That is, var doge:String?=null; fun main() { if(doge!=null) { functionThatTakesNonNull(doge); &lt;-- causes error. } 
As u/way_lines said, `let` is a function which takes a lambda. So while the elvis operator \(`?:`\) isn't a function and therefore can't take a lambda as an argument \(must be an expression\), you can use the` ru`n function as the other end to execute a block` on `null: fun main(vararg args: String) { var doge: String? = null doge?.let { println("wow") println("such doge") } ?: run { println("not wow") println("no doge") } }
Another article that's basically rewritten reference. Hooray
typealias.com really? Good read nonetheless.
C had objects before C++. It was just a pattern, rather than a language feature. So why does anyone even bother with all that syntactic sugar? Real programmers write binary
Myself and a colleague run this Kotlin course at SkillsMatter in London and are also possibly available for training gigs. I'll DM you with details: https://skillsmatter.com/courses/602-real-world-kotlin-development-workshop
Log4j team is working on a kotlin adapter https://issues.apache.org/jira/browse/LOG4J2-1705
Noted! I'll update the post when it's out.
Contact JetBrains they do training
Seriously though, Kotlin is full of too much random magic. There are the nice and cute features like constructor injection and named function parameters. But then there's the flat out crazy stuff like the contextual use of `@`. The nice thing about Java is that it's always 100% legible but yet isn't missing anything big after Java 8 (though adding privacy modifiers to create constructor injection like Kotlin and Typescript would be nice). If you know a programming language, you're not going to have a hard time reading Java. And if you would like some magic, there's always [Project Lombok](https://projectlombok.org).
I *think* all the messages I get about jobs there are from hiring teams that have posted positions on https://stackoverflow.com/jobs. I literally only just now noticed (while grabbing that link) that messages in my inbox on SO have labels like "jobs message". Honestly, if another user messaged me, I don't think I'd have noticed a difference.
I like Kotlin quite a bit, but... &gt; Never worry about NPEs Complete nonsense. For pure Kotlin code... mostly true. But when you're interfacing with Java that lacks nullability hints, every parameter or return type `X` is mapped to `X!` in Kotlin, which is *essentially* `X?` that doesn't do any checking. It's "this is maybe an `X`, or maybe it's a nullable `X`, I'm not really sure but I won't force the issue". &gt; Kotlin provides very simple way to lazily initialize a property using lazy keyword. Technically not a keyword; it's an ordinary function. --- I've been using Kotlin in anger for about 6 months now, and I'm about ready to convert our Java code over to Kotlin (it's not a huge codebase yet). 
Long type has to be 64 bit, right?
Just because a sentence begins with "how" doesn't mean it should end with a question mark...
Curious to see what you parts you think are magic, mind detailing some examples?
Yeah, `let` is just a utility method in Kotlin, useful - although be careful as overuse can make code less readable.
Age is a terrible way to choose between languages
This company is certified for Kotlin courses I think: https://instil.co/courses/kotlin/
At some point maybe using `if` is a good idea?
&gt; Kotlin in anger How should we interprete that? * you are angry with the state of java and used kotlin because of that * kotlin makes you angry, and despite that you are still moving forward and plan to migrate your code base ?
"In anger" is a phrase I picked up some years ago. To do something "in anger" means to do it "for real" - i.e. not as a pilot or experiment. I think it's a British English expression and I'm not British, but I don't care. I like it!
&gt; "In anger" is a phrase Ah! Now it makes sense. Was not aware that it is used like that.
I provided a simple use case. Imaging a very long chain of calls and at the end you want to do something on else case, this would be extremely useful at that point.
I'd also say that Spring Boot + Postgre is probably a solid choice for most use cases but this depends on what you are trying to achieve. For example if you want performance Spring will fall off and Vert.x starts to become a better choice. If you don't want highly performant stuff then Spring is the way to go since it is kind of a go for framework nowadays. The problem I see is that picking up Kotlin needs Java knowledge. Spring has excellent built-in features for Kotlin but it is a Java framework at its core. I have experience with Spring + Kotlin and it is pleasant but both Java and Spring have a ramp-up period which can be frustrating for newcomers especially if you don't have experience with designing programs with such frameworks. So it all boils down to what you are trying to achieve. Disclaimer: I have 10+ years experience with Java, 5+ with Spring and 3+ with Kotlin. I'm also very responsive to questions (Kotlin) on StackOverflow and I can also do some consulting work if you need more.
This is very useful. I also arrived at the same conclusions in most of the cases but there were some very useful things which I had no idea existed. Nice work! 
I also use Fuel and I really like it! Do you have APIs which should be human-readable? If not you might consider using other means of communication instead of REST, like messaging and binary formats like protobuf.
What happens if you remove the explicit type declaration from r2? My guess is that the call to `replace` might assume that its type parameters are A and A because of r2's type, which makes that call perfectly legal as both BI and AI are subtypes of A. If you remove r2's type declaration I suspect the type inference will be based on the actual parameters to r2.
Yeah. I dont know the guy who wrote the article but I found it clear and to the point.
If I remove the explicit type definition the code still compiles and the inferred type is also still `Pair&lt;A, A&gt;` since that is the most precise type that is valid. I want the expression `BI().replace(AI())` itself to be invalid, regardless of what type the variable it returns is. The function can even just return Unit and the same problem would still be there. Basically, I need to "turn off" the "upwards polymorphism". I hope this makes sense.
Wow, I'm totally going to use that `@Nested` idea. I knew it was a feature, but I've never really thought about it before seeing it here. It will be nice to separate my tests into `HappyPath` and various error groups \(`UserError`,` EnvironmentErro`r\).
On recruiting, a competent Java developer should be able to get up-to-speed with Kotlin in a matter of hours, and of course Java is much more widely known than Kotlin. I'd recommend not narrowing your options by only looking for people with prior Kotlin experience.
Try to add variance to generics in return type T.replace(t: P) : Pair&lt;out T, out P&gt; 
Some great tips here! I wasn't aware of `@TestInstance(Lifecycle.PER_CLASS)`, and have always wished that's the way JUint tests were run. I do find it kind of funny that the author repeatedly defends using AssertJ saying they don't mind "the dots and parenthesis". When I see Kotlin with a lot of user-defined operators, `foo bar baz quux`, I'm left wondering what's a function and what's an argument. So I not only don't mind the dots and parenthesis, but actually find that they make the code easier to read. That said, one thing I do prefer about [kotlintest](https://github.com/kotlintest/kotlintest) (or even [kotlin.test](https://kotlinlang.org/api/latest/kotlin.test/index.html) -- yes, two different things) over AssertJ is the exception testing: - AssertJ, even from Kotlin, is more verbose: // AssertJ assertThatThrownBy { // ... }.isInstanceOf(FooException::class.java) // kotlin.test assertFailsWith&lt;FooException&gt; { // ... } // kotlintest shouldThrow&lt;FooException&gt; { // ... } - The `assertThatThrownBy` error message isn't as helpful in the case where no exception is thrown: Expecting code to raise a throwable. versus (this is from `assertFailsWith`): Expected an exception of class com.example.FooException to be thrown, but was completed successfully. - `assertFailsWith` and `shouldThrow` just return the exception, so it can be tested like any other object, while AssertJ's `assertThatThrownBy` returns an `AbstractThrowableAssert`, which has its own API for testing common exception properties. More to learn/remember, and less flexible. If I've got a custom exception with a "foo" property, how do I test it in AssertJ? It's immediately obvious with the other libraries that just give me the exception.
You're going to need to be more specific...
They let you execute/invoke a piece of code :))
I need more explanation 
what mean
exactly. instead of writing it over and over, you can just call a function. it saves (development) time and makes the code more readable.
I've written about this [here](https://medium.freecodecamp.org/going-beyond-android-kotlin-on-the-frontend-d82e9f4f3155).
thank you Mango
It is a very good band. I like listening to their music.
oh man and i,m lol
أعني استخدام الوظيفة 
i mean use function
Thank you yelow13
Thank you for the post, but I still did not get further. \&gt; Now, if we build the project with \`./gradlew assemble\` , we’ll find an \`index.html\` in the \`build/dist\` folder. I ran the \`assemble\`command in gradle, because \`gradlew assemble\`failed with ClassNotFoundException: com.sun.tools.javac, and after specifying a java home in the properties file it failed with \`could not load properties\`. So, \`gradle assemble\` was it: \&gt; ERROR in Entry module not found: Error: Can't resolve 'main' in 'C:\\Users\\NotSoIncredibleA\\Documents\\intellij\\npmlearn\\learn1'\&gt; Child html\-webpack\-plugin for "index.html":\&gt; 1 asset\&gt; \[2\] \(webpack\)/buildin/global.js 509 bytes {0} \[built\]\&gt; \[3\] \(webpack\)/buildin/module.js 517 bytes {0} \[built\]\&gt; \+ 2 hidden modules\&gt; error Command failed with exit code 2.\&gt; info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.\&gt; :bundle FAILED \&gt; FAILURE: Build failed with an exception. \&gt; \* What went wrong:\&gt; Execution failed for task ':bundle'.\&gt; \&gt; Process 'command 'C:\\Users\\NotSoIncredibleA\\Documents\\intellij\\npmlearn\\learn1\\.gradle\\yarn\\yarn\-latest\\yarn.cmd'' finished with non\-zero exit value 1 \&gt; \* Try:\&gt; Run with \-\-stacktrace option to get the stack trace. Run with \-\-info or \-\-debug option to get more log output. Run with \-\-scan to get full insights. \&gt; \* Get more help at https://help.gradle.org \&gt; BUILD FAILED in 4m 48s \&gt; 6 actionable tasks: 6 executed\&gt; Process 'command 'C:\\Users\\NotSoIncredibleA\\Documents\\intellij\\npmlearn\\learn1\\.gradle\\yarn\\yarn\-latest\\yarn.cmd'' finished with non\-zero exit value 1 It is a great example why I am stuck. The build took way too long and I have no idea where to look for a solution and it has downloaded more than 120\+MB into the \`node\_modules\` folder. Is the problem here: \- \`webpack\`? \- \`npm\` or \`yarn\` version mismatch \(maybe I use an old one\)? \- is it a \`gradle\` error? \- somewhat related to \`Kotlin\`? \(the name \`main\` makes me assume that\) \- is it some problem of any \`gradle plugin\`? \- some form of cache invalidation? What do I have to learn to solve these problems?
Can we move this to StackOverflow?
I'd need to create a TypeScript project in itself to understand the other side. Cannot imagine i am the only one with these problems. No offense, but your tutorial was about the third tutorial where I got stuck for hours where it said 'just run this simple command'. I find this part of the development the most frustrating.
You mentioned KotlinTest and that also supports having a fresh instance of the test class for every test case. You override isInstancePerClasd in your test class.
Most of the code I've seen in my life didn't have tests. :-/
That's awesome. Kotlin and TensorFlow are two of my favorite things. I'm trying to embed a model in my Kotlin application now, so this should be helpful.
I could finally run the basic frontend demo I linked above, haven't checked yet if your tutorial works. &gt; Why do you need TypeScript? The whole reason is I am using Kotlin for JS is because JS has much superior libraries than JavaFX in terms of plotting. [This project](https://github.com/STRML/react-grid-layout) and a few others have the definitely typed TS header and I thought TS would be easier than JS. &gt; Where did you get stuck? Removing every module and re-installing node.js and starting a new gradle JS project gave me a successful build finally. My main problem was (and it's very embarassing to admit) that I did not know that the Kotlin frontend plugin does not have a builtin NodeJS but uses an existing one in my computer. Currently, the HTML file runs even with an uncaught typeerror from a generated file. Thank you for your input.
It looks like an interesting project. Will check it out.
Imo, there's no reason for this syntax to exist. You shouldn't be working code that requires multiple contexts of this within a single block, you should just be calling another method from your current method. https://kotlinlang.org/docs/reference/this-expressions.html
I really want a Kotlin DI framework to make use of javax.inject AND reified types. Projects like Koin are great, but they still don't allow for easy construction, good Java interoperability, and the ability to easily exchange one framework or component for another. 
What is the benefit of assistant
I would just argue that with so many little tricks, you're kind of begging for misinterpretations. Like with the if statement blocks, ternary statements exist.
I think languages with cool syntax are super cool. But my defense Java in the world is that fact that it has none of this magic. Basically, if you can program, you can program in Java. And I think there's a huge advantage to that for enterprise solutions. If all the devs on my team were hit by a very unfortunate bus tomorrow and a new team had to come in and pick up the pieces, they would have very little trouble sorting out the Java (besides the fact that there's a butt ton of it). But the other languages and toolsets, might be a bit more daunting.
well, you surely will have noticed, that you have to write your Main Methods Signature like this `fun main(args: Array&lt;String&gt;)` Here is Generic Code just as well! Well, have a look at a possible LinkedList implementation `class Node&lt;T&gt; {``value: T``next: Node&lt;T&gt;` `}` Okay, what happens, if we Create a Variable of Type Node\&lt;Int\&gt;? Well, you can basically imagine aligning the Node\&lt;T\&gt; Class to look like this in this Case: `Class Node&lt;Int&gt; {``value: Int` `next: Node&lt;Int&gt;` `}` and this works for any Type now! The Main difference between this and choosing `Any` is, that you can throw \(literally\) any Type in Any, but the Field `Node::value` will always be of typ`e I`nt for `a Node&lt;In`t\&gt;, and the fiel`d Node::ne`xt will have to be of ty`pe Node&lt;I`nt\&gt;, n`ot Node&lt;Stri`ng\&gt; for example. It's
The reason for &gt; fun &lt;T : Any&gt; T.asReference() = Ref(this) is that `Ref` is a generic type, too. &gt; fun Any.asReference() = Ref(this) would return a `Ref&lt;Any&gt;` but the original function can correctly say that `1.asReference()` is a `Ref&lt;Int&gt;`.
/u/QshelTier is right. When you're not returning a generic type, simply using the bound as the receiver is fine though. An `Any` bound is kinda special and perhaps surprising in that it doesn't encompass *every* type. Its purpose is actually to *narrow* the range of permitted types. In Kotlin, nullability is part of the type system, so the most generic type (and default bound for `T`) is actually `Any?`, so `T: Any` says don't accept null values.
I don't think that's what OP is asking ..
Perhaps this line of code make it more obvious. data class Shape(val sides:Int, weight: Float, stroke: Int) val (sides, weight, strokePx) = Shape(4, 2f, 8) **You can instantly assign a variable name at the moment of declaration** instead of covering the ambiguous name (or pixel scaling) with another `val strokePx = theShape.stroke`. So yes, it's just a sugar. While this is a crude example, this occasionally helps when multi-lining RxJava/streams calls where it can get old real fast if your original variable name may not carry the proper intent when marshalling across methods. Also, even if you had a proper variable name in the first place, don't ignore the fact where this also reduce the effort to refactor especially when a member of your team refactor that `stroke` property to `strokePx` later on. Notice what happen to your destructured Shape declaration? Zero refactor needed. The same can't be said with using accessors. Lastly, while it pretty much boils into a useful sugar, something that may not seems obvious is that "destructuring" implies a structure is already present in the first place. Maps, shapes, tables, pairs etc. I confess that I pretty much abused the hell out of destructuring declarations when handling maps: val map = mapOf( "Reddit" to "reddit.com", "Google" to "google.com" ) map.forEach { (title, url) -&gt; println("$title : $url") } // Outputs: Reddit : reddit.com Google : google.com No accessors, no extra data class, and just pure variables.
 fun &lt;T : Any&gt; T.asReference() = Ref(this) is a short version of fun &lt;T : Any&gt; T.asReference() : Ref&lt;T&gt; = Ref&lt;T&gt;(this) This generic type allows you to "remember" the type T and give it to the `Ref` object. If you'd just had written fun Any.asReference() = Ref(this) this wouldn't have been possible, and it would alsways return a `Ref&lt;Any&gt;`.
Excellent! Thank you very much. The indirection should be fine for my use case
Pretty sure there's also a refactoring for changing the order of things like these. That should update uses as well.
Not sure if trolling
42
Java is full of "magic" like @Bean, @Transactional, or the full-blown @SpringBootApplication. These are (imo unfortunately) a huge part of the Java ecosystem. In my opinion, Kotlin is moving in a much better direction by adding powerful syntactic features around functional patterns which helps avoid misusing the weak meta-programming language which is annotations.
Sorry my bad, it's `fun isInstancePerTest(): Boolean` and you need to be on KotlinTest 3.1.0 or higher.
Was originally not planning on posting this, but it's been very quiet in the sub lately, so why not. Changes since last post here (1.6.0): # 1.7.0 ## Custom JSON mapper `Context#json` used to rely on Jackson to do JSON mapping. As of `1.7.0` it relies on `JavalinJsonPlugin`. This plugin holds a default implementation for Jackson, but can be configured to use whatever you like. This is how to use GSON instead of Jackson: ```java Gson gson = new GsonBuilder().create(); JavalinJsonPlugin.setJsonToObjectMapper(gson::fromJson); JavalinJsonPlugin.setObjectToJsonMapper(gson::toJson); ``` ## jTwig templates jTwig is the Java implementation of a very popular PHP template engine. This can now be used via `Context#renderJtwig`. ## Miscellaneous * `Javalin`'s constructor is now `protected` instead of `private`. This means you can subclass `Javalin`. * `Javalin` now has `disableStartupBanner()`, which removes the Javalin banner from logs * `Javalin` will now print more helpful error messages if the current port can't be used. # 1.6.1 Bugfixes * You can now redirect inside exception mappers * Jackson now automatically register the Kotlin module if you’re using it * The LogUtil broke in 1.6.0 and stopped being able to measure time, this has been fixed 
The problem is that your `encounterId` is immutable. You need to make it a `var`.
I actually tried that : `@Id @GeneratedValue(strategy = GenerationType.IDENTITY) var encounterId : Long = 0` But it's still the same unfortunately. I don't understand why. The value stays 0. Do you have any idea why ? And is there a way to have a immutable generated id ? If not, what would be the best way to have the generated ID ?
In this specific case, you might want to check out [android-ktx](https://github.com/android/android-ktx). Otherwise, I'm no expert, but that looks fine to me! As long as it works, is readable, and makes sense semantically, why not.
Thanks, I'll check it :)
you can use GenerationType.AUTO and make id mutable, using var instead of val, same goes for isCaught and other data that you might want to change later.
I almost always use `run` rather than `with`, but they both have pretty much the same "danger": they both shadow `this`, so you don't want to use them so much that it becomes unclear what `this` is actually referring to. When I'm concerned about that I sometimes use `let` instead. Even though you have to name the value (or call it `it`), it's still sometimes nicer than having a separate variable declaration as it's all in one expression, and the scope of the new name is easy to keep small.
I think the “shadowing of `this`” is the key point. If I want to call for example multiple setters or other methods on an object, i’ll use `with()` without explicit `this.`.
Okay so it actually works with @Id @GeneratedValue(strategy = GenerationType.IDENTITY) val encounterId : Long = 0 Because it is modified through reflection. I tested it with a minimal example (removing the references to other entities). So if I have only : @Entity data class Encounter( @Id @GeneratedValue(strategy = GenerationType.IDENTITY) val encounterId : Long = 0, val encounterPercentage : Int, val isCaught : Boolean = false ) It works perfectly. But If I add the `Time` field like this : @Entity data class Encounter( @Id @GeneratedValue(strategy = GenerationType.IDENTITY) val encounterId : Long = 0, @OneToOne(cascade = [(CascadeType.ALL)]) val pokemon : Pokemon, @OneToOne(cascade = [(CascadeType.ALL)]) val time : Time, val encounterPercentage : Int, val isCaught : Boolean = false ) @Entity data class Time( @Id @GeneratedValue(strategy = GenerationType.IDENTITY) val timeId : Int = 0, val name : String ) It gives me the following error : `detached entity passed to persist: com.catchemall.catchemall.model.Time` Although it works fine if I remove the `@GeneratedValue` from time.
&gt; If I want to call for example multiple setters or other methods on an object, i’ll use `with()` without explicit `this.`. Sure, but that isn't shadowing. Shadowing is names from the outer scope being hidden by names introduced in the inner scope. In `with`, `run`, or any other lambda with a receiver parameter, in the process of making all of those names conveniently accessible (upside) it masks/shadows already existing names wherever there is a collision (downside). I'm not saying you should never use it. OP was just asking what the dangers are. My general rules of thumb are: - Avoid having too many of these nested. I don't want to have to guess where a property/method is coming from. - When you do nest, try to avoid doing it with objects that are likely to have similarly named members, most especially objects of the same class. In those cases, `let ` might be more clear.
yeah it was a subjective rant, not worth reading. I plan on converting our team to.kotlin, i fear that some of them may react similar.
Excellent question. The short answer is that most people don't need or care about the level of performance I'm discussing day to day, though some of the specifics could certainly come into play in tight loops or other performance sensitive areas. As for when something like unoptimized synchronization becomes a bottleneck well... it depends. If you're doing a lot of small units of work against an executor managing the work queue can certainly become an issue. That said if you're doing blocking IO or not being particularly performance conscious you probably have bigger things to worry about. Frankly I think far more about performance than most folks working on the JVM do just by virtue of the fact that I'm working on a relational database written in Kotlin, so avoiding things like GC pauses and blocking are important. All that said, I'm a big proponent of understanding what's going on underneath the covers of a feature as complex as Kotlin's coroutines are. I also think that a part of being a good software engineer is taking advantage of easy performance wins where available and appropriate.
I wouldn't even use `let` in that function, you can just use `plus(1)`, or even `return (number?.toIntOrNull() ?: return 0) + 1`
I believe there's also `.inc()`, I just didn't want to complicate it any further, as that's not someone I'd expect everyone to find. Plus (pun intended), it would've been specific for this small example, while `let` the isn't.
I made this experience already. One needs serious communication skills to transport the message to everyone and one has to be very sensible with people's attitudes towards change and new things. If your colleagues don't have the tiniest bit of interest in moving to something \(even subjectively\) better then Java, it's going to get tough.
I know this type. If you show him Python he'll point out that it has no braces so it is useless. If you show some Clojure code he'll point out that the parens are horrible. I think that any discussion about this guy is just a waste of time. &gt; I plan on converting our team to.kotlin, I fear that some of them may react similar. Spreading Kotlin in your company is like an exothermic reaction. You need to put in some energy to get the people through the first negative impressions then they realize that they are 50% more productive and will spread the word on their own. 
Very interesting read. I wasn't aware that it's possible to gain such an amount of performance out of non\-standard coroutines usage for certain scenarios, because I thought coroutines high level usage is very efficient already. Will definitely read this thing a few times again :\) Thanks.
Destructuring works the way it does because it was designed that way, not because of any JVM limitations. We haven't found it's position-based nature to be a problem in practice.
Ah i see. Thanks for clarifying.
I was absolutely fuming reading the original article. I opened it up expecting some perspective, because I'll be honest, I really enjoy kotlin. But Jesus Christ, absolutely the worst stuff I've read in a long time, and your responses were top notch.
We migrated a few weeks ago. I had the luck that many of my colleagues are a fan of python, ruby and dotNet. That made the switch a lot easier, because all of them dislike the verbosity of Java. My Java colleagues really favour the lack of checked exceptions and the explicitness in nulls. For the rest, it’s just code. 
Good read. You've done a great job of deconstructing the (exceedingly) flawed arguments.
Or... and this might be a little controversial, but maybe use the EventBus in guava? https://github.com/google/guava/wiki/EventBusExplained It's incredibly simple, all done for you. Depends on what you want, if you wanna learn, keep going down this path, but if you just want the functionality, introducing guava here may be better? As for the actual question, nope, don't think so, but I could be wrong. 
Wtf is with this trend of halting over a tiny detail? If the person is making 10 individual points, then maybe 8 are valid and 2 are trivial. To discount ALL of them because of a couple of them is .. just .. bad practice. Now, of course the article under scrutiny isn't making too many valid points anyway..
It’s always been a thing. I remember people complaining about obj c because of the square brackets. 
Yes, that original article was not great, and got tons of criticism. Do we really need more criticism, especially when it's "snarky"?
Yes, different languages make different design decisions; otherwise only a single language would exist.
I wish there was a way to do something like this for un-annotated Java classes. I've suggested adding annotations to third-party Java libraries and been told "we don't want the added dependency". It'd be nice if there was some way I could avoid platform types without having to either fork, wrap, or rewrite the entire library.
Someone should write a "From Kotlin to Java and Back Again" to put things into perspective :-)
Isn't this, fun foo(): String = thingThatReturnsPlatformString() effectively the same as this? fun foo(): String = thingThatReturnsPlatformString()!! I'm not seeing how having implicit null check assertions is any safer than doing them by hand. At least with the latter I'd know about them. But what I'd really prefer is a way to have external annotations. I know these used to exist, and the arguments for why they were removed never really made any sense to me, to be honest. (As an aside, there are still a bunch of pages on jetbrains.com and kotlinlang.org that describe external annotations with no mention of the fact that they no longer exist.) Accidentally passing null to Java libraries that don't take null, or getting nulls back and treating incorrectly them as not-null are my #1 pain point dealing with Java libraries from Kotlin. The claim is that platform types are "at least as safe as Java", but I've found that in practice they aren't because when writing Kotlin code I'm used to spending my mental energy on better things than runtime null checking, and so I end up getting more NPEs in Kotlin+Java than I do in plain Java (but pure Kotlin is obviously the best). Perhaps having an option in IntelliJ to have it highlight (and/or a way to search for) assignments from platform-type to non-null and from nullable to platform-type would be a reasonable middle-ground.
Thanks! I hadn't realized KotlinTest had upgraded, because they changed the package name, so the tool I use to upgrade dependencies didn't see the new version.
These expressions are identical in terms of safety, indeed. The difference is that you have to write the !!, and it gets very annoying very quick. External annotations do exist as a feature for improving the analysis of Java code in IntelliJ IDEA. If you see any pages that mention their availability for Kotlin (other than old blog posts), please send me the links, and I'll make sure the information is updated. A tool to highlight or otherwise report platform type operations would be easy to build. However, in our experience, there are so many such operations that there is no meaningful way to resolve them all. You'll see a report with a few thousand entries at it, look at it, sigh, turn off the highlighting and move on.
Kotlin will be better than Java 20
&gt; If you see any pages that mention their availability for Kotlin (other than old blog posts), please send me the links, and I'll make sure the information is updated. Even old blog posts could probably do with a big "Update: this feature no longer exists -- see &lt;link&gt; for details" notice at the top. I was fooled into thinking the annotations still existed for a while because the top search results for "Kotlin external annotations" were all blog posts, discussion board posts, and stackoverflow questions that mention nothing about their disappearance. &gt; However, in our experience, there are so many such operations that there is no meaningful way to resolve them all. You'll see a report with a few thousand entries at it, look at it, sigh, turn off the highlighting and move on. I'm thinking that if they were highlighted then at least I'd be reminded that there's fishy business going on as I write my code. Less in-your-face than an actual warning, but more obvious than pretending all is normal.
the link is dead. what happpened?
I only made it halfway through this. Everything was personal annoyances about things like order of parts in a method signature not being the same as in Java. If you want to write Java code, then yeah... you should write Java.
I had the same experience. I had to stop reading the original article about halfway through because it was one of the worst articles I've ever read. This article, however, was excellent and forced me to read the highlights of the original article anyway.
well dont let the 10 part deceive you. The only thing that has changed in 2 java versions from a developer comfort is `var` being recently introduced and `drop`, `take` from streams ... 
Fuck you! No I don't!
Don't search for it by title, almost all of the jobs with kotlin involve android dev from the ones I've seen posted. 
I don't know where you're from, but in the Boston area a lot of companies have kotlin mentioned. Twitter and Bose being the two bigger ones. I see some listings with just Java, Scala, and kotlin listed too. 
Prove it's truly better, enough to warrant switching away from Java. It will take a revolutionary language/platform to do that.
Migrating to kotlin (or any other language/toolset) is first and foremost a matter of solving existing problems. If the team realizes working in Java is a problem, or doing something in Java can be a lot better, it's easy to explain to them where kotlin can be helpful. And when they see it, the will believe it. My previous team saw the benefit of kotlin and easily jumped as soon as the opportunity arrived. My current team is ready to jump, waiting for an opportunity. On the other hand, if people think what they're doing is right and/or doing new will definitely break their things or methodology, will invite hostile reactions. It took me a lot to ask my android team to move to architecture components, because (almost rightfully) they believed they're handling MVVM right. And it was an effort to ask iOS team to move on swift because a) They were doing ObjC right way and b) They feared their efficiency will reduce if they move to swift, it took (my former) company to hire two new programmers (who worked on swift) to move to swift. In the case of the post, I believe, either OP just scratched the surface and saw Java10 doing the same thing, or lack a serious guidance, and lacked attitude to reach out to the community and ask for opinions/guidance or just talk. And they just believe they have to return to the "familiarity" of Java. 
Former Android dev, so Java it was. Transition was smooth thanks to interop and Android Studio/IDEA java-to-kotlin-converter. I was the only dev in the team :) but other teams (web applications, java) quickly adopted. I recently changed my job. Still Java so I tried to bring up kotlin because in my opinion it is a perfect fit with low risk. Too bad the acceptance here is not that good. Maybe because I am "the new one". We will see... :)
Backend in Java. Good opinion, smooth transition ✌️
You kind of answered your own question there - almost none of the points made are valid. Like I opened the article up expecting some conversation about the lack of true pattern matching and such - that would have been great, maybe the author would know a solution to that problem. But no. It was some guy talking about *colons* and other minutia about how the languages differ. Bad content is bad content and the original article being responded to here is just categorically bad content.
We mainly use Java 8, but we decided to try Kotlin for a large project. General opinions from the team: Negative: * they prefer the Java 10 syntax for variable declarations \(type first, if it's not implicit\) * the IDEA Kotlin plugin has lot's of issues and annoying warnings, for example when the plugin version and the Kotlin versions mismatch * sometimes, compiling fails for no apparent reason and works again after IDE restart * extension methods aren't easily discoverable * nobody really understands the design idea behind companion objects and why they would be better than static stuff or just singleton objects. Especially why they can be named. There may be very rare occurences where they may be slightly useful, but that doesn't warrant such a major language feature and the resulting compatibility mess with Java in our opinion. Positive: * more compact code possible * null\-safe code is generally good We probably won't use Kotlin again anytime soon. The language is okay, but it often seems slightly unstable and buggy and needs more maturing. We have more experience in Java.
May I ask what is your domain?
KotlinTest is actually _more_ flexible. This page lists the various styles you can use. https://github.com/kotlintest/kotlintest/blob/master/doc/styles.md
Sad to hear Kotlin isn't working out for you. &gt; they prefer the Java 10 syntax for variable declarations (type first, if it's not implicit) From my personal experience thats just something a developer is familiar with. After some time using the reversed syntax it gets natural. Same when going the other way from kotlin -&gt; java/c#/php &gt; extension methods aren't easily discoverable How could that be improved?
backend and frontend software to distribute and analyse large amounts of application specific data, that specific application was a prototype data viewer and editor using javafx/tornadofx.
I am surprised to hear about Extension discoverability. IMHO they are more discoverable as you will see the method in code completion on the object itself, rather than in some static method elsewhere
&gt;From my personal experience thats just something a developer is familiar with. That obviously plays a role, but I still think it's more natural to think about the type first and then \(often\) let the IDE generate a good name, instead of the other way around. &gt;How could that be improved? I have no idea, honestly. The IDE obviously helps somewhat, but I still feel that Kotlin has too many loose methods in random stray Kotlin files instead of organizing them together with the classes. For example I really think that `listOf()` should have been defined in the `List` interface and be written as `List.of()`. That would make much more clear to what interface the method belongs and what the return type is.
I feel that discovering methods through code completion isn't always a good strategy. You also often look at the source code or the \(generated\) documentation of the classes \(I prefer the source code so I can glance at the implementation\). Also code completion always contains lots of random extension methods like `run`, `apply`, `rangeTo` and so on, so finding the interesting ones isn't always easy.
Going from Java to Kotlin requires you to change how you approach things. (If you go from Java to Haskell, you'd need to change your coding-style too ;) If you ever going to try Kotlin again, just try to do it the Kotlin-way and join the Kotlin-Slack http://slack.kotlinlang.org/ a lot of friendly people there helping you to get into Kotlin :)
I moved through various languages, php(symfony) was for first job, python for few years on master degree studies, ruby (rails) on free time projects/hobbies and several c# (asp.net) projects at work. Later for about 3 years I worked with various jobs with java projects ranging from desktop apps with swing to backend development on java ee or spring. Now I am settled with kotlin and spring 5 (mvc and webflux) with angular 5 and typescript and never been happier :) kotlin reminds me of ruby in lots of cases. The conclusion I came to after many years with various languages is that there are a lot of different problems and each solves best with specific technology. There is no single solution for all problems. So far kotlin is pretty darn near that solution
Heavily disagree with your example. Using top level functions instead of binding them to classes is what makes kotlin neat, clean and compact to me. To each their own, though, I suppose.
Sad to hear that it didn't work out for you, too. I have some comments to your negative points: * I never experienced any problems regarding IntelliJ and/or the Kotlin plugin. It's very strange for me to hear that there are significant issues for people. But even more I don't understand that you find the said warnings annoying \- an outdated runtime should be updated, an outdated tool or plugin should be updated. That's something you do once your stuff gets out\-of\-date, how can such a thing be a problem, I'm wondering. Restarting IntelliJ is every now and then necessary regardless of the language after my experience. * What kind of problems did you encounter regarding discovering of extension methods?? For me, it worked in every single case without any problems. Maybe if I reindex the whole project and try to autocomplete too greedy, it doesn't show something, but hey, this is not your issue, isn't it? * I don't really get why companion objects are a problem. Those objects are really just singleton objects, semantically the same as in Java. And as a bonus, you can use them unqualified from the class they are companion to. It's not comparable to static methods, because therefore you would use top level functions in Kotlin. The benefit of making it a companion object is so that you don't have to rely on a strange convention like you would in Java \(call them INSTANCE or SINGLETON, for example\). This is for example nice for reflection access. All in all, after reading your positive aspects and missing a few very significant ones, I get the slight impression that you really didn't unfold the real advantages of Kotlin... I assume, that this is because you and your team are too stuck in Java idoms and Java code \(I don't want to be offensive, it's just that this was the case for me and some very near colleagues as well!\) which is that you have dozens of things that potentially enhance all your lines of code. Small example: The focus on having functions as a first class citizen in the language enables for more functional code \(functional as in "proper usage of functions", not as in mathematicscategorytheoryhaskell\). This is sth I experienced as a major benefit in order to structure and reuse code. Data classes, properties and abstract properties make so much Java code pieces obsolete and interface usage simpler, that this was a very positive experience for me too. Also Kotlin's nice extensions for collections and streams/sequence stuff made our code so much nicer. For me, personally, better code in so many places would outweight arguments like "strange variable declarations" or "i don't understand companions".
This seems like fine combo. BTW, what is your opinion on Angular? May I know your setup for complete solutions?
I started using angularjs back in 2013 when spa were just started to get traction, since then it started to grow into this complex framework. I remember when we had to use ui-routing library to have any routing for our templates, back then angular was simple and thin. Its learning curve is quite steep since it evolved so I would not use it on simple solutions or give it to a newbie. As far as I know most projects use a lightweight js framework in its initial phase and when project matures, projects migrate to Angular or similar framework. 
I usually dont bind my business logic to frameworks like spring, i develop it as a library which uses nothing but java se, for persistance or 3rd party services I create a set of interfaces which are used but the business use case library, those interfaces are implemented by adapters which are kept separately. This allows to wrap my core business logic with rest api application which uses spring or wrap with cli if I wanted to, in any case this allows to make my business logic portable and easy to migrate to any language. As for rest-apis they are thin because no logic is kept there so effort is minimal if need arises to create it newly in new technology
It looks like the author has barely used Kotlin. He still concatenates strings instead of using string templates. This is one of the first basic principles when switching. The author also doesn't know about best practices (eg. Java interop). Going about learning a new language and avoiding best practices is like purposely being silly and then wondering why it's silly.
Thanks.
Anther thing you could do is have file-naming conventions and conventions about where to place code. Perhaps something like &lt;specialization&gt;&lt;type&gt;extensions.kt so a String.toPerson extension function would reside in PersonStringExtensions.kt We found extension functions to be much more discoverable than static utility functions scattered throughout hundreds of utility classes. This is because we usually know part of the function name but don't know where it exists so Kotlin allows us to type part of it and code completion does the rest.
&gt;Using top level functions instead of binding them to classes is what makes kotlin neat, clean and compact to me. I heavily disagree with that. When I see standalone top level functions, I always feel like I'm back at some crappy scripting language. Toplevel functions feel wrong and they pollute the namespaces and I don't think there is anything wrong with being forced to put your functions into objects or classes to keep them neatly organized. Naming schemes for the Kotlin source files help when developing, but when using the functions tha becomes largely irrelevant. And in this case `List.of()` would be especially neat, because it resembles a common builder pattern, just as if `List` had a companion object.
&gt;an outdated runtime should be updated, an outdated tool or plugin should be updated That's not the issue. The issue is that the Kotlin plugin is updated, but the code uses a slightly older version defined somewhere in a gradle file. IDEA doesn't seem to like that. &gt;What kind of problems did you encounter regarding discovering of extension methods?? See my other posts in this thread. &gt;I don't really get why companion objects are a problem. Those objects are really just singleton objects, semantically the same as in Java. And as a bonus, you can use them unqualified from the class they are companion to. Normal singleton `object`s are a great feature. Companion objects aren't necessarily a problem. They're just weirdly designed. Even a Kotlin developer wrote somewhere that if they would design Kotlin now, they would have left out companion objects.
No it doesn't. There are revolutionary languages \(or at least they want to be\), like Go, Rust, Haskell, Ruby, C#, D, Scala, Xtend. No revolutionary approach is revolutionary enough to convince Java people and companies that there are better platforms. You can convince them only, if you directly address their pain points and give them the smoothest, easiest and cheapest migration. That's the reason Kotlin tries it this way. "Prove it's better"... funny.. it's not possible to prove anything, because it doesn't matter what arguments you use, the majority of Java people will disarm them somehow. The funny thing is, that Java is only nice for Java people. Other people mostly cry when they have to use it. So for Java people it's always "why should I switch" and for all others it's always "why the hell should I use Java, I would rather use every other JVM language". It's up to people to accept that this might be a hint on what is better and what isn't. \(This is the time where people start claiming that the opinion of a majority doesn't mean that it's a good opinion etc. etc. the discussions are always the same and repeating\)
&gt;the code uses a slightly older version defined somewhere in a gradle file. IDEA doesn't seem to like that. Yes, I got that. But again: Isn't it nice to get a hint that one should update the runtime, because there is a newer one? I don't understand why this is an issue. Just update the runtime and you have less bugs :\) &gt;They're just weirdly designed. Even a Kotlin developer wrote somewhere that if they would design Kotlin now, they would have left out companion objects. Yea, I read that quote sometime ago. But I think one has to rethink that. The only thing that differentiates companions from regular objects is that one class can access it without qualification.. if you don't have the need to use companions, why not just don't use it? There is no alternative approach \(as of now\). There are some use cases where having a companion is nicer than a pure object, what would you do in those cases given there is no alternative? That's not a downside in my eyes, it's at maximum something that exists, but you don't have a use case for it.
Came to Kotlin from Scala. I still use Scala on the job, but Kotlin for everything else. I've experienced too much stylistic/dogmatic/complexity issues in Scala in the Scala ecosystem/libraries, that turned me off in some way. Although the Scala language is absolutely amazing. Kotlin on the otherhand strikes a nice balance almost everywhere (Immutability, Functional Programming, language features, libraries, etc). I'm usibg Kotlin on the server side.
I think the author's point about compile\-time safety has merit. We're still dependent on a lot of libraries written in Java, so nullability can be an issue when importing back and forth.
&gt; Yes, I got that. But again: Isn't it nice to get a hint that one should update the runtime, because there is a newer one? I don't understand why this is an issue. Just update the runtime and you have less bugs :) The new versions of Kotlin also have some bugs, so if everything is working perfectly you sometimes don't want to update. I just don't see why they couple that so much, you can run Intellij Idea with JDK 10 and still write Java 8 or Java 7 applications. &gt; if you don't have the need to use companions, why not just don't use it? There is no alternative approach (as of now). Say you want to write a utility function that converts a `String` into a `Person`. `Person` is your own class, so you can add code to it. In Java, the only way to do that, that makes sense, is add a static factory method in the `Person` class. Or if `Person` is a concrete class, maybe a constructor. In Kotlin you can * create a toplevel function `personOf(...)` * create a constructor `Person()` * create an extension function `String.toPerson()` * create a companion Object function `Person.of()` * create a factory method inside some other object `PersonFactory.createPerson()` * create a DSL that returns a `Person` That isn't necessarily a bad thing that you could also use some of this in Java, but I still find that Kotlin often has too many ways to do something and then you aren't sure how to create a `Person` object or how to do something else, while Java is much simpler generally (because it has less features).
What exactly does Java 10 have? var for local variables is all I can really think of
&gt; the IDEA Kotlin plugin has lot's of issues and annoying warnings, for example when the plugin version and the Kotlin versions mismatch IIRC this isn't a compile-time warning but rather an IDE message. It shows up in the same place as "there are IntelliJ plugin updates available" or "there's an update to IntelliJ available". 
&gt; In Java, the only way to do that, that makes sense, is add a static factory method in the Person class. ... or you could create a `Persons` class that only has static members, or you could have a `PersonSupport`class that does the same. Both of those patterns are in the Java standard library. And what would a function that converts from `String` to `Person` be called? I'd expect `parse`, but you might expect something else. If your point is "there's no single, idiomatic way to convert an `A` into a `B` in Kotlin", then that same complaint applies to Java as well. If your point is "I don't know where to look to even *find* a relevant conversion in Kotlin", then that same complaint applies to Java, too. Sure, Kotlin adds toplevel functions and extension functions into the mix, but they're arguably no harder to find than any static function that lives on some other class `C`. If anything, with IDE support, extension methods are easier to discover. 
&gt; Companion objects aren't necessarily a problem. They're just weirdly designed. Even a Kotlin developer wrote somewhere that if they would design Kotlin now, they would have left out companion objects. And replace them with what, static members? Having used companion objects in Scala and Kotlin, I'm firmly in the camp that believes companion objects are better than static members. The only pain point is when interoperating with Java code, and is something that Scala does a little better than Kotlin. 
Yes, you're right. Still annoying.
Android developer - moved from Java. Started a new job, fresh app - well I needed to copy existing iOS app - so I figured this was a great time to start. Gave myself two weeks to either "get Kotlin" or go back to Java as I needed to get the app out quickly. I am the only Android dev on staff. It would have been easier to start with a second person to code review and bounce ideas off of as I was learning. Conversion was generally pretty smooth. Lots of Google Searches on syntax and I honestly found the official Kotlin documentation to not be very helpful. It is very terse, I needed to see example code not just their very terse description of syntax. I could always find sample code online or have the Java -&gt; Kotlin conversion get me where I needed to go. There are aspects of Kotlin I just cant remember the syntax as it is not very natural. I released the first cut of app to play store almost exactly 2 months to day I started. Pure Kotlin for what I wrote, used some 3rd party Java libs from Google and others of course. Also converted to Retrofit instead of Volley that I used at previous jobs. Since then I have learned a lot about Kotlin, refactored code, use of more Kotlin methods, more use of extensions, added lots of new functionality to app in general, etc. Switched to using Dagger 2, ROOM for database, more extensions from others, etc. Would not want to go back to Java. Kotlin is easier to write. At times it is a bit harder to read because you have to think about what the code is doing while it does map / filter / etc. series of actions. App is used by 20k people with nearly 40% using on a daily basis. Using Flurry to track crashes and lots of usage metrics. It is a business app used by folks to place orders. Over 4 millions orders have been processed by it so far.
There are some people who just don't want to improve. If you show them Python they will complain about the whitespace. If you show them Clojure they will complain about the parentheses. Maybe it is time for you to move on?
There are some people who just don't want to improve. If you show them Python they will complain about the whitespace. If you show them Clojure they will complain about the parentheses. Maybe it is time for you to move on?
I commented on the original article and the guy just copy pasted to every commenter something like "this comment should be deleted, because of it being a personal attack" then proceeded to copy-paste the definition of a personal attack. What the hell.
Nevertheless, if half the article is garbage, then your best refutation is _exactly_ that: "half the article is garbage". Nitpicking over a tiny detail, while you ignore the rest, just doesn't do justice to your intelligence. Regardless of the merits of the object under discussion. It's like reading a bad review of a movie, and you say you stopped reading because the author misused a comma.
I don't disagree that null safety is an issue in the jvm. It seems like the author is more bothered that you need to know what is Kotlin code and what isn't. Following Kotlin best practices avoids probably all of the gripes the author presents. But Kotlin sits atop the JVM, so it's limited to what the JVM can do.
&gt; There are aspects of Kotlin I just cant remember the syntax as it is not very natural. Out of curiosity, what parts of the syntax? The main thing I repeatedly have to look up is the custom setter and getter syntax. It doesn't feel like the rest of Kotlin at all to me, with its newline and indentation sensitivity.
 popupSpinner.onItemSelectedListener = object : AdapterView.OnItemSelectedListener { For when you need to add certain listeners such as this one on a Spinner.
Android developer here. My team migrated from Java to Kotlin around 1.5 years ago, a little before it became the official language for Android. Before transitioning I had read up on Kotlin and liked what I saw a lot. There are a ton of reasons why Kotlin is better than Java and a ton of articles out there on the topic. Some of the main points from my opinion are null safety and functional programming concepts. It also does a lot of smaller things that make your life as a programmer so much easier \(or at least an Android app programmer\) such as removing primitives \(everything is an object\). There were a few concerns I had about transitioning. It was a relatively new language that was unproven and didn't have official Android support at the time. I had previously worked on iOS using it's new programming language, Swift. Swift was a good programming language, but it had a lot of issues. Build times were slow, it caused an non\-negligible number of IDE crashes, it had compatibility issues with objc, there was poor tooling support in the IDE. I was worried that Kotlin would have similar issues. Also, would the rest of my team support it? I was talking with an engineer who had a lot of technical influence about how good Kotlin was. I apparently convinced him because he added the language to the project and started using it. I was happy to help start the transition. As we started using it, I was surprised that it had almost none of the issues that Swift had. It didn't have many issues with Android Studio, there were almost no compatibility issues with Java, build times might have been a little slower but not enough to affect anyone's workflow, Android Studio had good tooling support for the language such as linter, formatter, autocompletion. Today, everyone on my team likes Kotlin or at least accepts using it. It was very easy for everyone to learn Kotlin enough to start writing with it. Although becoming an expert is pretty hard. We write all new code in Kotlin with a few rare exceptions and slowly migrate existing Java code. Our codebase just reached \&gt;50&amp;#37; Kotlin code. I think the most visible effect that Kotlin has is almost no more NullPointerExceptions. Also, I now firmly believe that Kotlin is better than Swift.
Checked exceptions have to go if they want a chance of catching (ha) up.
You cant use java 10 in production. I bet at least half your frameworks and libs dont support it yet. So ye its much worse because there is no support which is the most important thing for any language. And its not LTS which means you WILL not use it hopefully. You can use java 8 and java is "worse" than kotlin 1.2 thats the reality. You can't even really use java 8 on android maybe java 7 and you drop support for anything older than 4.4 and use libraries like retrolambdas etc.
 &gt;No it doesn't. There are revolutionary languages \(or at least they want to be\), like Go, Rust, Haskell, Ruby, C#, D, Scala, Xtend. No revolutionary approach is revolutionary enough to convince Java people and companies that there are better platforms. As someone who has shipped production software in more than one of the alternatives you list, as well as java, I’m not sure there *is* a better platform. There are better *languages* then java, sure, but the JVM is pretty hard to beat in terms of performance, stability, monitoring, tuning, and so on. 
From c++, Java and Python and the transition was a bit hard, but pretty good
When I can be a coder like you, currently stuck on tornadofx..
&gt; If I’m halfway through a bad article and the quality suddenly dips even further, I’m not inclined to read the rest. Yes, but the point is, you should be assessing the article as a whole. "*This was a bad article, I could only read half*" makes you sound like a discerning reader. "*This article is bad because of this only one point that I dislike*" makes it sound like you're looking for reasons to stop reading. Do you see the difference?
That’s a false dichotomy. The ‘one point I dislike’ wasn’t a single point in isolation, it was a tipping point. 
Congrats I guess but please for the love of god rework that design. It's way easier to use material design with AppCompat than it is to build something like this.
A good first effort! Needs some love in the UX department but one step at a time, eh? :) I can help with that, if you like? 
Looks like a web view
Are you okay with out-of-order execution?
Yes, I don't think that would be a problem here.
www.material.io
&gt;He still concatenates strings instead of using string templates. This is one of the first basic principles when switching. What is the advantage of templates? If you're localizing String or you need to format numbers, Kotlin templates aren't really helpful anyway and you need at least something analogous to String.format with your own better template replacement.
&gt;You cant use java 10 in production. Java 11 is the next LTS version which will be more useful for production than Java 10. But there is no real reason why you wouldn't be able to use Java 10 for production. Most libraries that were using internal sun function and so on should have already been updated for the Java 9 module system, and if they haven't that's a reason to not use them ans they're then both unmaintained and using internal, unofficial functions.
Thanks for the link, I spent yesterday slowly upgrading the app using hints and tips about material design. So far I have added in floating action buttons. Also put in a navigation drawer. Still got lots more to do.
Yes I completely agree that is where I need major reworking. I would love any advice or help you could give. I am pretty new so won't take offense at being told what sucks lol. So far I have been researching this 'material design' people talk about. To the base app I have now changed the back button on each page to a floating action button that brings up a navigation drawer that switches the activity. Not sure how to tidy up the rest of it though. Without really knowing how to do any of it. I was assuming the image buttons on the main menu page which are currently flat and boring need to be changed somehow. And then each page with information on needs to be tidied up to look more professional for sure.
The author of that article told me on LinkedIn that they are using using Java 10 in production splendidly.
Do you not already know Android or Java? If not, I would start with that since Kotlin runs on the jvm.
This. I would love if Kotlin outright replaced Java, but the sad reality is that most Android docs and tutorials still heavily use Java. Though I suppose you could get by if you tried to convert every Java code sample into Kotlin via the IDE's conversion tool, but I'm not sure if that would really be ideal.
Are there more than 10 books on Kotlin total?
Get a good freebie on Udacity, they are all video courses. And you can always get a cheapo on Udemy (I think right now they are 10 bucks per course), and if you look well, you get to find a complete course (basic, sample apps, midrange and advanced, all in one). I got one in portuguese.
Thanks
This is stupid. If you know Java then Kotlin is a mild pickup. I would recommend *Effective Java* (especially since it influenced Kotlin in many ways) and then read the official Kotlin documentation. If you grok modern Java and general software idioms then Kotlin should be a cinch. 
`launch {}` multiple jobs that all run the consumeEach. Keep references to all of them, and in the runBlocking block, `.join()` them all.
Can I ask, would a "Kotliner" have a place for Effective Java? I don't know Java, and I was caught in the hype surrounding the Kotlin announcement at Google IO last year so that's my story. I'm at a place where I can look at most Java code and covert it to Kotlin without trouble but there are still weird cases that give me headaches. My situation is this, I learned Kotlin, around the time of Google IO, knowing that people were saying, "you should learn Java before learning Kotlin," but I never followed that advice. For me, I'd be going back 20 years. In order to learn Kotlin I leveraged my knowledge of C++ and Swift and that carried me quite far, but that knowledge doesn't allow me to "bend the language to my will." Reading the Effective C++ series was when I developed my tricks with the language. I imagine Effective Java mirrors Myers books. But if Kotlin is more than "syntactic sugar" over Java, then the language stands on its own two feet and has no place for "Effective Java." Inevitably, a series of Effective Kotlin books should pop up in the future. But Kotlin is bound Java and JVM... how much of Kotlin's development is steered by Oracle just by being a JVM language? So, I don't know. What do you think?
My own thought on whether a "Kotliner" would benefit from reading *Effective Java* depends on their familiarity with Java and the JVM ecosystem. "It depends" is a boring answer so let me try and explain. It sounds like you have sufficient programming experience and so the language and idioms are not the struggle. The struggle is filling in the gaps about the Java/JVM intricacies. You will begin to really feel this when you want to leverage Java libraries and tools in your Kotlin project. Kotlin does add a lot of syntactic sugar, but there is more to it than a desugaring step. JVM languages compile to JVM byte code to run on the JVM. Equivalent Kotlin and Java will always be different at the byte code level. A very nice feature is the Java-to-Kotlin converter in IDEA. But then the generated code will not behave the same under the covers. For example, with the converter, Java static variables become fields in the companion object of the Kotlin class, where the companion is really just a single instance of a hidden generated class. So there is more going on. Some Java libraries use reflection to do magical things and since Kotlin is not equivalent byte code you get confusing errors. So then you have to use Kotlin annotations to coerce the Kotlin compiler to generate more equivalent byte code, yada, yada... Learning Java is not a requirement, but I think there can be benefits. You even said there are headaches converting things because of small details. For you, *Effective Java* may be more like a skim through so you can pick up the crumbs and morsels that fill in your knowledge base. You probably don't need more general programming knowledge, but more JVM knowledge. As far as Oracle steering Java, its very interesting. It's supposed to be a committee driven language, but then you see the lawsuit with Google. Java is now getting rapid releases; Java 10 is out and Java 9 is already EOL (wow!). Google makes Kotlin an official Android lanuguage, but Flutter is the dev kit for their new OS. Kotlin is built on JVM, but JetBrains keeps pushing their native Kotlin compiler efforts. The point is that with any technology it's hard to know what will happen. I do know that the JVM ecosystem is massive and has decades of solid development and support. The JVM ecosystem is a lot bigger than Oracle and is not going anywhere anytime soon, and so it kind of reinforces having good Java/JVM knowledge that goes beyond Kotlin, Scala, Clojure, etc.
&gt;The new versions of Kotlin also have some bugs, so if everything is working perfectly you sometimes don't want to update. &gt; &gt;I just don't see why they couple that so much, you can run Intellij Idea with JDK 10 and still write Java 8 or Java 7 applications. Still, if you ask me, this is \- or should be \- such a rare condition, that I don't see it as a wrong thing, or something negative. Couldn't you just deactivate the popup [https://discuss.kotlinlang.org/t/make\-the\-kotlin\-plugin\-shut\-up/1479/10](https://discuss.kotlinlang.org/t/make-the-kotlin-plugin-shut-up/1479/10) and not see it so negative? I think in Java, it's much more common to have the need to stick to ooooooooolder versions...in Kotlin, you can, and should pretty much update immediately. As to the other points: Already answered by others. Seems again highly subjective and selective for me, as all those arguments can be applied to Java as well :\)
Congratulations, you are the snowflake out of 10000. But we have to talk about majorities or large share of people, not about a hand full of special ones. And upon your approval, you didn't name a single language that is mostly functional, uses first class properties or is not native\-and\-performance\-oriented in first instance...Trust me, someone who's coming from Ruby, Python, C#, JavaScript, Scala or Haskell will see a LOT of benefits in Kotlin over Java.
I totally agree. I just wanted to generify "alternative", for the rare case a company would let a completely new platform be possible. But then again: What alternative should a person convince to move away from Java? I think Kotlin is by far the best bet here. That's all I want to say.
Why do you think they're coming _from_ those languages if FP is so great for long term, enterprise maintenance?
Do you have any specific problem or just want an overview of these two working together?
Almost there, I read every line of todomvc example and tornadofx example. But when I built my my own project, I cann't believe a simple property would stop me. That's really depressed. I will go to sleep , it's midnight, don't know if I would continue next day.
No specific problem. I would like to see examples how to combine those two together.
TornadoFX isn't an alternative to JavaFX. Think of it primarily as a nice Kotlin DSL for building JavaFX applications, and secondarily as a source of other convenient utilities and abstractions. You need to know JavaFX in order for it to make sense.
Oh god. I'm developing a plug-in for IntelliJ and Swing literally feels like fighting the system.
&gt; Any time an `Airplane` is constructed, it will crash with a KotlinNullPointerException. Don't you mean `Episode`?
Uhh... Yes, I do mean an `Episode` :) Thanks for catching it, I've fixed it.
The PDF which is linked from your blog post is not the "Kotlin for Android Developers" book, but rather the PDF version of the official Kotlin language documentation, also available for free at [http://kotlinlang.org/docs/reference/](http://kotlinlang.org/docs/reference/).
Yes. You can find a larger \(but possibly still incomplete\) list at the official Kotlin Web site: [http://kotlinlang.org/docs/books.html](http://kotlinlang.org/docs/books.html)
Who said it is? And how about'because some times they don't have a choice'? Enterprise maintainance is sth completely different. None the less is proper use of fp (in Sense of Modularity, pureness, composition and Not overabstraction) good for enterprise maintainance as Well.
I just learned it because I was curious. I came from java, another language I taught myself because I was curious. I'm an Electrical Engineer so neither of these languages is particularly useful to my job, but I find Kotlin to be a lot better to work with. With java, I often felt like I was fighting with the arbitrary rules of the language; with Kotlin, that couldn't be further from the truth. It just makes sense.
If you don't know java, what languages do you know? That'd be a good starting point for us to help you.
I use a ton of these in the project I'm working on. I am making a library of API bindings for last.fm, and one of the issues with that API is that certain methods (e.g. track.getSimilar) only return part of the data for each thing in the list of results, e.g. each track returned by track.getSimilar has only some of the information that a track.getInfo request would return. With some higher-order shenanigans, though, the user can iterate through the tracks returned by track.getSimilar, with all of the information for that track (not just the limited info provided by the initial API request).
Hey, thanks for the response! My most recent Kotlin/Java headache was copying some Java reflection code. When I ran the app, I got a ClassNotFoundException. The first StackOverflow answer gave: &gt;Your classpath is broken (which is a very common problem in the Java world). &gt;Depending on how you start your application, you need to revise the argument to -cp, your Class-Path entry in MANIFEST.MF or your disk layout. I have no idea what that means. So I spent a half an hour toying with and learning Kotlin's version of reflection, changed my code, and now everything is working. It's just... I'm constantly pinging back to Java. It's a sign. So, I'm going to go ahead and learn. It feels like I'm about to regress a bit. I left C++ because I was becoming aware of the monumental effort to setup anything! And Java shares roots with C++. I would normally *sigh* here, but that's not a good kind of energy to take into learning any language. Thanks for your words. They've given quite a perspective on things.
I'm disappointed how nice Kotlin is :-) I'm a devops person, I'm often glueing various bits of things together. I regularly want to use various Java tools/libraries, Kotlin hits the sweet spot compared to Java/Scala/Clojure. I love the functional side of Kotlin - I've programmed in Clojure, Haskell and Scala so functional is natural for me, but it's not "pure" so makes life easier. I also program in Go and I like the ability of Kotlin to produce binaries, plus Kotlin has Generics which Go doesn't have. There's many other things I like - compiled language with static types, type inference, data classes, destructuring, multiparadigm (procedural, functional, OO), variable name followed by variable type, if/when expressions, null handling, Android support, IDEA, etc, etc. Now I just need a replacement for C++ :-O
When you have a lambda with two parameters, you can do ``` h.foo { k, v -&gt; println("key $k and value $v") } ``` You can only do this when you can infer the type of the parameters, which in your example you do know (map key type and value type) If you don't know the type you can indicate normally by doing ```{ k: Type, v: Type -&gt; ... } ``` Like normally. I recommend reading more on kotlin lambdas, such as on the kotlin guides or just googling, since they're a cool, well used feature.
Thanks, now I see how Kotlin is like Ruby for lambdas, life is easier. Something missing from the above section? ``` ... } ``` 
 Now I just need a replacement for C+ Rust?
I wish. I play on various algorithm competition sites, often the choice of language is limited to Java, C\+\+, Python. None of them amazing languages :\-\(
Ahh, that should read: If you don't know the type you can indicate normally by doing ``` { k: Type, v: Type -&gt; ... } ``` Looks like a Markdown/Fancy Pants error.
That has nothing to do with Kotlin. So without the context of the full example nobody can help you.
It's a parameter for the LoadQuery function... but I have no idea what LoadQuery is. Is this from a library you're using?
I'm trying to understand each line of the code use in this android tutorial app and i don't understand why he used "&amp;#37;" in dealing with queries [https://github.com/hussien89aa/KotlinUdemy/blob/master/Android/NoteApp/StartUp/app/src/main/java/com/hussein/startup/MainActivity.kt](https://github.com/hussien89aa/KotlinUdemy/blob/master/Android/NoteApp/StartUp/app/src/main/java/com/hussein/startup/MainActivity.kt)
What about [Effective Java](https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997)? Or is it considered too advanced?
A must have handbook for any Java developer, but it's definitely not a "textbook" to learn Java itself. It's more like "best practices". Definitely useful to beginners, too, but it won't teach you how to program \(in Java\).
The only way to achieve something like this is to look into the [Google Maps Places API](https://developers.google.com/places/web-service/search). There may be other similar APIs available, but you'll likely be paying for whatever you end up choosing. I didn't do any further searching, but I looked into the [Places API costs](https://developers.google.com/places/web-service/usage), and you'll get 1,000 free requests in a 24 hour period, or 150,000 free requests if you provide your credit card information.
Yep I already have the places api installed and it does let me search on google places already with the code I provided. However it isn't coming up with the correct results so there must be an error. Perhaps it needs me to put a radius for the search result, so only places within 20 miles appear, or a keyword to search for. Like dog groomer. However I don't know if that is the issue or how to program that.
Probably missing a Cascade type?
Can I do something like doge?.let { println(it.name) } ?: run { println("NO"+it.name) } }
I know, so I can not use other methods to replace \`run\` to achieve it?
In order to force a null unwrap, use the `!!` operator. Not that this can cause a NullPointerException or whatever Kotlin throws. It’s generally not the best practice to for a a null unwrap, but it’s possible.
Yes, I always use the latest version. Why wouldn't you?
When I replaced Java with Kotlin\(2 years ago\), I felt it was kinda unstable, I was afraid if I update it, I will get more bugs to fix. 
I had an issue with a Kotlin install in android-studio myself. I feel like it was 1.2.1, but it could have been 1.2.0.1 like yourself, I'm not sure. My app would not compile. I spent like an hour searching the error codes I was getting, and the solution was just to revert, and wait for a better update. That put a bad taste in my mouth, so the past couple days I've been ignoring a kotlin update popup in android-studio. I'll probably click it today or tomorrow though. I do generally update my stuff to the latest version.
Kotlin is interoperable with Java, so you can use both languages in the same codebase. You can create a file in Kotlin and use it from Java. For example: *MyRegex.kt* val helloWorld = Regex("""^[Hh]ello,?\s+world[.!]?$""") *Main.java* import java.util.regex.Pattern; public class Main { public static void main(String[] args) { Pattern pattern = MyRegexKt.getHelloWorld().toPattern(); // Use the pattern... } } Note the class name as used in Java is the same as the Kotlin filename (`MyRegex`) with `Kt` appended. Also note that the Kotlin compiler generates a getter for the `helloWorld` property, so you have to use `getHelloWorld()` in Java.
I stay up to date. The core JVM language has been very stable for me. If you're are an earlier adopted of the multi platform stuff, I'd suggest using the EAP releases.
Neat, though it seems to be a bit of a cheat to use the builtin HashMap (or LinkedHashMap) if we're truly building our own. ...then again, to make a cake from scratch first you must create the universe.
The ball ache associated with updating kotlin version is mainly around the tooling (intellij plugin/serialisation plugin if you use it etc) and then the grade scripts etc. After that, intellij handles migration really well. I've not been presented with any problems so far with a project not continuing to function. You don't want to be left behind the curve I suppose. It's kind of like a daily hygiene ritual at this point. You do it because it know it's good for you, not because it's massively fun.
Very interesting read! I really enjoyed it! I recently thought about doing something like a cache in my project, essentially my idea was to make it a sort of in memory database to quickly access elements, I was thinking of having some automatic expiration so this is very useful! Would you \(or anyone\) mind guiding me and telling me if that is a good idea, Here's the [link](https://github.com/basshelal/Waqti-Android/blob/master/app/src/main/java/uk/whitecrescent/waqti/Cache.kt), you don't need to read the code really, it's still a work in progress, just the note at the top that explains the intent of the whole thing. Anyway very useful stuff, thanks! :\)
You need to use a older version of the storage library. Look for "com.google.firebase:firebase-storage" in your gradle file. As stated here: https://firebase.google.com/support/release-notes/android#latest_sdk_versions they under "Cloud Storage version 16.0.1" "Removed the deprecated StorageMetadata.getDownloadUrl() and UploadTask.TaskSnapshot.getDownloadUrl() methods. To get a current download URL, use StorageReference.getDownloadUr()."
it forces me to change into latest version when syncing gradles. can you try changing the code so it fits the new update. Many thanks man.
If you're forced to use the new library, why don't you just use the new method? Looking at the class you're referring to, you simple need to change the code at line 92 from `var DownloadURL= taskSnapshot.downloadUrl!!.toString()` to `var DownloadURL= imageRef.downloadUrl!!.toString()`
Always up to date. The only Problems caused by newer kotlin version i know of are caching problems with intellij. Invalidate and restart or rebuild and it was fine again. You can deactivate the popups... I had the discussion with someone else here on reddit, i can't understand why the update hint can be sonething negative.. you update your operating system frequently too, do you.
I would stick to \[Caffeine\]\([https://github.com/ben\-manes/caffeine](https://github.com/ben-manes/caffeine)\), has everything you want out of the box and more. Caching is a solved problem.
I don't think it's a good idea to put all \`dbs\` \(such as \`taskDB\`, \`labelsDB\`\) in a single place to cache. I cannot figure out **the best solution** but **I found one of available so**lutions, from Google samples, here: [https://github.com/googlesamples/android\-architecture/blob/86c07eedabba8a690282cb1869d235ec0ac7003a/todoapp/app/src/main/java/com/example/android/architecture/blueprints/todoapp/data/source/TasksRepository.kt#L38](https://github.com/googlesamples/android-architecture/blob/86c07eedabba8a690282cb1869d235ec0ac7003a/todoapp/app/src/main/java/com/example/android/architecture/blueprints/todoapp/data/source/TasksRepository.kt#L38) Provide repositories where you access database and cache items there. Hope this helps. :\)
Awesome! Yeah I do plan on changing it to have each be their own cache \(so extend or implement a base Cache\) in order to more freely implement any persistence stuff depending on what we're caching. Thank you very much for linking me this, it's an amazing resource I completely forgot about, thank you! :\)
I also recommend to stay up to date, maybe wait till a fixed version comes out if you are afraid of error, i.e. when 1.3.0 comes out you can wait to 1.3.1. Why I recommend to update? because kotlin will get to a point where is mature enough and the API will not change so much (like was with Swift) and if you stay so long with an old version will be harder later on to update to a newer kotlin version.
If I recall the project's description correctly, it was created for study purposes mainly, not for replacing any existing frameworks. 
Why don't you link the target directly?
Besides the fact that you seemingly haven't posted it as a link, it seems to be the new Reddit behavior to first open a forum page and have to jump from there to the linked site. Strange.
The biggest issue to me for Gradle Kotlin DSL is documentation, which essentially does not exist.
\+ almost all examples use the old Groovy DSL. 
I don't think I've ever seen a case where a new release was less stable than the one that proceeded it.
Nope. The original project, ConcurrentLinkedHashMap, was like that prior to its 1.0. It was trying to solve a hard problem: how to make LRU concurrent (as every read is a write), without sacrificing O(1) like others do (Clock-based, poor quality sampling). But that was way back in 2008, and much of its code was ported into Guava for CacheBuilder. Caffeine is a rewrite to keep pushing things forward. Caffeine has contributed towards research. We have one paper in ACM Transaction on Storage and a conference paper under review. Both on the eviction policy being used. Someday we'll get around to a paper on the library itself, as it has a few other insights. But that's hard to do when its a hobby project that I work on during my work commute. Even when working on Google's, it was during my personal hours of handing off code &amp; ideas to the Guava team.
In regards to expiration, I think you'll enjoy this [article](https://www.confluent.io/blog/apache-kafka-purgatory-hierarchical-timing-wheels/) by the Kafka team. It describes an amortized O(1) priority queue, called a Hierarchical Timer Wheel, used by Operating Systems for scheduling. We use an implementation in Caffeine for its variable expiration.
Yea having auto complete would help a lot. I tend to just write shell script and have gradle call those because I just don't have the time to parse gradles confusing documentation. 
I have stopped updating because it always Fs my code all up. I tend to wait a few updates and then tackle all the problems. 
This new Reddit design is terrible and obviously aimed at keeping users on the site.
+ Gradle's Kotlin DSL copies a lot of the confusing behavior of their Groovy DSL. eg: getters that don't return anything, but have side effects.
There are a couple doc related issues set for the next release which will hopefully improve the situation https://github.com/gradle/kotlin-dsl/milestone/34
wait whats the point of a getter if you arent... getting?
 Take a look at [this example of Gradle's Kotlin DSL](https://github.com/gradle/kotlin-dsl/blob/master/samples/hello-world/build.gradle.kts). How does this work? plugins { application } Apparently `application ` is a getter on the receiver of the lambda passed to `plugins`, and *invoking the getter* causes the `application` plugin to be applied. This is IOCCC-level stuff. I keep hoping they'll bite the bullet, break the existing Kotlin DSL build scripts and change the syntax to be more like idiomatic Kotlin.
Great resources! Thank you very much. I'll check it out and study the expiration strategy, which is a critical aspect in cache I was not very familiar before. :)
Many Kotlin (and Java, for that matter) programmers don't use Hibernate. In general, if asking a question that involves a non-core library, it would be helpful to state the library's name in the question to give some context.
Well, I ran into those a couple of times during udemy's course. Fortunately, the instructors helped with uogrades, which are quite frequent. 
Would you share your repository? 
No offense to you, but I don't think this post belongs in this subreddit any more than a link to some java Android app belongs in /r/java
Awesome, I been looking for something like this for some time, do you have the source available?
Post this stuff in r/androiddev
This isn't strictly Kotlin related, so I'll absolutely understand if it gets removed, but I thought it could be interesting for people here.
Do you have source? I think without source all feedback will be UI. It is a a bit janky. Is there any work being done on UI thread?
It is not allowed in r/androiddev unless the source code is posted with it
Here's a sneak peek of /r/androiddev using the [top posts](https://np.reddit.com/r/androiddev/top/?sort=top&amp;t=year) of the year! \#1: [LPT: Drag up and down on process windows to accelerate gradle downloads](https://gfycat.com/VigorousPleasedHuman) | [50 comments](https://np.reddit.com/r/androiddev/comments/71xljr/lpt_drag_up_and_down_on_process_windows_to/) \#2: [As a developer of a free game, people like this grind my gears](https://i.imgur.com/nQRdRR2.png) | [161 comments](https://np.reddit.com/r/androiddev/comments/736tf5/as_a_developer_of_a_free_game_people_like_this/) \#3: [AR Remote Control Car - Proof of Concept](https://i.redd.it/3cpsm85n6xnz.gif) | [64 comments](https://np.reddit.com/r/androiddev/comments/728ubs/ar_remote_control_car_proof_of_concept/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
There is a post stuck to the top of the page for today, June 2nd, to post for app feedback and does not require the source, just the play store link. 
I always update to the \`1.x.y0\` releases \(for example, \`1.2.40\`\), but I skip other \`1.x.yz\` releases \(for example, \`1.2.41\`\).
Post this in /r/androiddev, this question isn't actually appropriate for this sub. 
`recyclerview.adapter` is just a statement not an assignment. I think you meant: `recyclerview.adapter = adapter`. This is more of an Android question than Kotlin related.
Thank you! I wasnt sure if its the right section, but this solved the Issue
So it was a kotlin question!
Kinda I guess.
No.
Sort of! It wasn't so much about adapters as to kotlin properties and assignment.
You would have had to do that in Java too.
What environment are you running them in? How are you running the test? In Android Studio sometimes I need to Edit Configuration and add Gradle Make Aware in order to pick up code changes
I am running this in Android Studio 3.1.2 the stable build. I am running the test by clicking the green icon next to the test in the gutter on Android Studio. I checked the configuration and the Gradle Make Aware is already set up.
I don't believe you're using [assertTrue](https://kotlinlang.org/api/latest/kotlin.test/kotlin.test/assert-true.html) correctly. It should look like one of the following: * assertTrue(false, "This is wrong") * assertTrue("This is wrong") { false }
so i think the problem is that its not detecting any changes i make inside a test class.
I think there is something messed up with run configurations.
Are your files in /test or /androidTest? If in androidTest, make sure you're using @RunWith - see Android instrumentation testing documentation for details
so the issue was not with a certain build of android studio, and its not an issue with the junit assert() methods, its an issue with the kotlin-koans project set up. Every time you make a change to a test function you have to run the testClasses gradle task. there is an issue documented here https://github.com/Kotlin/kotlin-koans/issues/90
so the issue was not with a certain build of android studio, and its not an issue with the junit assert() methods, its an issue with the kotlin-koans project set up. Every time you make a change to a test function you have to run the testClasses gradle task. there is an issue documented here https://github.com/Kotlin/kotlin-koans/issues/90
I'm not happy with the Kotlin DSL, too. The Groovy DSL looks a bit arbitrary here and there. It would be good if they would rethink it in idiomatic Kotlin. DSLs for the sake of having a DSL are rarely a good thing. Those APIs are often counter intuitive and poor for API discoverability in the IDE.
Gotta check this out. Any issues with Spring integration? 
hmm nvm guys. I found the solution. var stars: Map&lt;String, Boolean&gt; = HashMap() changed Map to MutableMap seems to work
No known so far
Private function mocking, now that's something I was looking for. :)
Yeah, Kotlin has separate mutable / immutable collection interfaces.
the .yz releases are bug fixes for the .y0 release.. if anything you should skip the .y0 and just get .yz
One of my least favorite things about Kotlin is that 90&amp;#37; of the libraries written for it try to make some play on the 'K' and end with a stupid name.
Hey, ho, JUnit is also stupid? :-) anyway the real reason was free and cheap domain which ia difficult to find
You really care that much about library names? If that's one your least favourite things then you're doing pretty well.
Been using this library for a while now on some personal projects. Had some issues when I updated to java 9 and then 10 but seemed to be more of an issue with bytebuddy. Really liking it though overall - definitely a good alternative to Mockito for Kotlin.
Always run latest. 
Java 10 is fixed by upgrading to bytebuddy 1.8.8 already
I think it speaks to how great Kotlin is ;\) Nothing better to complain about....
Yes, all Jwhatevers and whatever4js are stupid names as well. Not a commentary on the quality of the library, just a pet peeve.
I would agree to some extent, but JUnit and Slf4j already so known and cozy libs that they don't sound stupid. Anyway, for me, it is even plus, a weird name is something additional people talk about :-) As I said you can try doing this exercise and choose one of not used mocking library names, with free and cheap domain and sounding not super stupid.
I think you should wrap that last line in a `runBlocking { }` block
Because on the last line you use `joinChildren` instead of `join`.
oh you did that already, nvrmnd
Can you read all the lines of the file into memory? In that case Java's stream() implementation might be better for your use-case. E.g. // Unfortunately Files.lines does not parallelize, so we have to use readAllLines val stream = Files.readAllLines(Paths.get("/tmp/lines.txt")) .stream() .parallel() val meanSumOfSquares = stream .mapToDouble { s -&gt; println("I am being calculated on thread: " + Thread.currentThread().name) Thread.sleep(1_000) // Simulate slow computation val i = Double.parseDouble(s) i * i } .average() // or your own reduce function println(meanSumOfSquares) 
You have to use `consumer(chan).join()` not `.joinChildren()` val job = consumer(chan) println("Number of children jobs: ${job.children.count()}") // job.joinChildren() job.join() Consumer is a single job and has no children jobs. 
However this will leave the program hanging forever, since the receiver channel printing the results never gets closed. This proper point to close that channel would be once all the "doublers" have finished. So the whole logic would look like: val chan = Channel&lt;String&gt;() val doublers = 0.rangeTo(8).map { doubler(producer, chan) } val consumer = consumer(chan) doublers.forEach { it.join() } chan.close() consumer.join()
&gt; Can you read all the lines of the file into memory? Unfortunately not, the input and output files are very large.
I respect companies not afraid to show earning brackets in their adverts. Good luck in your search!
In California it's the law
In Argentina :(
Hey if you're open to an American Army vet then tell me where to apply.
Java's evolution is and will continue to be constrained by the requirement to maintain backwards compatibility.
I love this post, its openness and you as a company. I'd love to join but unfortunately it is not a remote job and I'm currently unable to relocate to London. :(. Good luck :)
Don't know if releveant, but turns out the Files.lines(...) stream should parallelize in Java 9: https://bytefish.de/blog/jdk8_files_lines_parallel_stream/
Like to go, but i'm not in the UK.
Hey \- are you based in the UK?
Hey \- are you currently based within the UK?
Hey \- sorry but at the moment, having someone based in the UK/able to come to the office is rather important to us. Feel free to get in touch in the future :)
Hey \- for now being in the UK is essential, though feel free to get in touch in the future!
Thanks for the compliment \- I think it makes it a little easier for everyone!
Hi. Unfortunately not. And I am unable to relocate until next year I am afraid.
Use the map and reduce functions. This probably won't compile but something like: ``` listOf(1, 3, 4).map { 1 shl it }.reduce { a, b -&gt; a or b } ```
```kotlin fun bitIndicesToInt(vararg bitsIndices: Int): Int = bitsIndices .map { bitIndex -&gt; 1.shl(bitIndex) } .sum() class TestBitIndicesToInt { @Test fun testBitIndicesToInt() { assertEquals(0, bitIndicesToInt()) assertEquals(1, bitIndicesToInt(0)) assertEquals(2, bitIndicesToInt(1)) assertEquals(3, bitIndicesToInt(0, 1)) assertEquals(10, bitIndicesToInt(1, 3)) assertEquals(26, bitIndicesToInt(1, 3, 4)) } } ``` But I think doing algorithms like this in a imperative way is fine, efficient algorithms require mutable state more often than not.
Remember that the primary objective is maintainability, rather than maximizing how "functional" it looks.
Yes, I always update my language and libraries as soon as the tooling supports it (which with Intellij and Kotlin is usually right away). Have enough automated tests that you can verify your program still works, and you should be fine. Very little constant effort is involved if you keep your stuff up to date, but if you let yourself get a few versions behind, it becomes bigger and easier to put off. Eventually you are stuck at an old version and have to upgrade 10 versions of some web framework to make some kind of compliance.
Thanks a lot, this is exactly what I was searching for!! 
you are right, but this was more or less a general question. I was searching for the "reduce" function apparently :)
Why switch from Gson to Moshi? 
No I live in the states.
One of the features is that it has an annotation processor that generates code for the type adapters at compile time, removing the need for reflection.
The same people who make Moshi make/made Gson. Gson has many broken defaults which cannot be changed without breaking the assumptions of the codebases of nearly all of its users. You can read more about this [here](https://medium.com/square-corner-blog/moshi-another-json-processor-624f8741f703) and [here](https://www.reddit.com/r/androiddev/comments/684flw/why_use_moshi_over_gson/dgx3gpm/).
Thought I was going to read something about stack overflow's backend. 
don't forget to remove this f* var and put a val !
You can alternatively use `fold` instead of `reduce`. Also, there isn't any need to do the `shl` in a separate `map`. I'd be inclined to just do it in the `fold`/`reduce`: listOf(1, 3, 4).fold(0) { a, b -&gt; a or 1.shl(b) }
By the way, it's more idiomatic to say: var stars = mutableMapOf&lt;String, Boolean&gt;() Also, you can probably use `val ` instead of `var` there, unless you are actually reassigning a new `MutableMap` to `stars ` at some point.
How does Moshi compare to Jackson? Working on back-end development in creating microservices, it seems Jackson is the go-to (at least where I am from).
Whatever4k is great though. Much better picture quality than whateverHD.
Ah \- that's a shame \- right now being in the UK is essential to us, thanks anyway \- feel free to get in touch in the future!
If you're going to do sum, make sure there are no duplicates
Good point!
I like to say Moshi is 90% of the functionality of Jackson for 10% of the size. Jackson is crazy powerful and crazy fast but also quite large. In server environments size is rarely a concern so if you're happy with Jackson I wouldn't switch. But for things like mobile its size can be prohibitive so that's where Gson and now Moshi really come into play. That's not to say that Moshi doesn't work on the server, but it's probably rare that you'd want to make a switch to it unless it was from Gson.
I have never used gson or moshi. Is there any reason to choose them over Jackson?
Just tried it out. Pretty sleek 
It's a peculiarly american thing not to show the salary. Wastes everyone's time.
I fixed few bugs, so recomended version now is 1.8.3
Thanks for the tip updated 
See my comment in the other thread: https://www.reddit.com/r/Kotlin/comments/8ox8uf/kotlin_users_safely_upgrade_to_moshi/e09k2tv/ If Jackson is working for you then no, it's probably not worth the effort to switch.
At this time there is no way to apply a single annotation to multiple target elements. If you don't want to repeat the annotation, then matching by name is the right way to solve this.
Ok thanks, do you think something is gonna change in the future? If I have a model with 50 vals I will need to iterate 50 times through 50 elements 
I'm not aware of any plans to change this in the Kotlin 1.3 timeframe. As for farther into the future, I don't think anyone knows. I'm pretty sure you can actually make do with iterating just once and collecting the data in an intermediate data structure, if you're concerned about performance.
Yes I guess I should find a better solution than: memberProperties.forEach { kProp -&gt; valueParams.find { it.name == kProp.name } } 
Too bad Kotlin guys not doing or even not planning to do compilation to MSIL, it would be so nice to have language like Kotlin on CLR.
I would say those numbers are biased, as I hardly see any Kotlin uptake outside Android development. All big data tools on the JVM are mostly Scala based. 
A survey on jetbrains saying Kotlin is more popular than Scala, I'm a little skeptical. 
It shows 12 other languages that are more popular than Kotlin (based on the same survey)
I remember seeing a YouTube introductory Kotlin video from Andrey Breslav saying that Kotlin adoption is a 50 / 50 split between Android and JVM backend development. Surprisingly, this same survey shows that more developers use Kotlin for JVM vs. Android
His examples are primitive and are clear examples where string templates should definitely be used. Why would someone code in a language in a purposely horrendous way and then complain about it (other than due to a lack of knowledge). It's clear that the author doesn't have a normal level of knowledge about Kotlin, best practices, and how to properly utilize Kotlin\-Java interop.
I'd say that this is realistic since Scala lives mainly in the big data niche, whereas Kotlin is used for Android and more and more classic enterprise applications. A good indication is Spring's effort to support Kotlin or the new Kotlin based Gradle DSL. Plus Kotlin is much easier to pick up and less risky for the enterprise. You can easily introduce Kotlin to an existing Java project without much problems. Although Scala has good Java interop, too, it is more of a different world compared with Java and Kotlin. All these factors sustain adoption.
I agree with /u/safgfsiogufas, A survey from JetBrains will give slightly biased results towards a language created by JetBrains. A safer bet would be to look at Google Trends results: https://trends.google.com/trends/explore?geo=US&amp;q=%2Fm%2F0_lcrx4,%2Fm%2F091hdj Kotlin seems to be slowly gaining momentum, and Scala is slowly declining... But Scala still seems to be about 2.5x more popular.
Because Kotlin is Java with syntactic sugar and null safety. Scala is a completely different language. And Scala is much more difficult to adopt because it's a different paradigm than Java.
[FTFY](https://trends.google.com/trends/explore?geo=US&amp;q=%2Fm%2F0_lcrx4,%2Fm%2F091hdj,%2Fm%2F07sbkfb)
I'm not... Scala was never popular outside a few specialist areas. Purely by Android numbers should surpass Scala easily.
That may be true, but I was just curious about the advantages of String templates. What is the advantage of, say val hello = "$num megabytes written" compared to val hello = num + " megabytes written" apart from being "less horrendous" (whatever that means), more Kotlin-y and saving a few chars.
Just depends how you collect your data \- [https://www.tiobe.com/tiobe\-index/](https://www.tiobe.com/tiobe-index/)
Is node.js experience (or lack thereof) a deal-breaker?
Scala simply made to many mistakes. * For a very long time, there was no proper ide support because core devs worked with emacs. * Afterwards there was eclipse ide but it seems like it got abandoned in favor of intellij plugin. But no problem, if you want to toy with dotty it seems like they focus on vs-code. I hope you are able to see some type of pattern. * Many developers started to hate build tools. Sbt's reputation is even worse as mavens (on the bright side - several new projects have started to address this issue, but none of them feels to be truly production ready) * Compiler is slow and it will still need some time till dotty is available with scala 3. For completness: There where already significant improvements for their current compiler. But judging on the involved changes, it seems like even low hanging fruits where simply ignored for years. Kotlin on the other side treated compilation speed as a requirement. * Native scala seemed like it is not really a serious attempt to get it done. Kotlin on the other side seems to actually deliver it. * Scala for android vs kotlin for android is pretty much the same story. Even if many of us would hope that adoption of scala increases, it is more than understandable that kotlin is faster growing. Especially, when oracle keeps alienating java developers, more will consider a switch towards kotlin. Scala might have more potential, but it also involves far more risks. 
Couldn't explain better
Couldn't explain better
I’ve always described Kotlin as the good parts of Scala, and Java should have been with 20 years hindsight
Yeah Tiobe is much more recognised.
Not sure that's a good metric either. That could just imply that Kotlin is easier to pick up and run with (for Java devs) whereas Scala requires more learning and thus more searching. Also, Kotlin has better IDE support in Intellij IDEA and thus in Android Studio, so less need for searching possibly. The annual Stack Overflow survey had them about the same in popularity and Kotlin about double in most wanted: https://insights.stackoverflow.com/survey/2018/#technology If you look at Github pull requests https://madnight.github.io/githut/#/pull_requests/2018/1 or pushes you see Scala is showing about 3x Kotlin in Q1 2018. But looking at the huge gains that Kotlin had in all of these reports vs. Scala which has stayed about the same or raised only slightly, this tells me that the data is not going to be very accurate anyway since it's in a growth phase. So it depends on what you're looking for. If you're looking for "increase in interest/adoption" then Kotlin is definitely beating Scala by huge margins over the last year, but if you're looking at actual usage, I'd say that Scala is higher for the time being. I think that the Stack Overflow "popularity" is basically a combination of interest, new adoption, and actual usage, so it makes sense that that one is about even.
&gt; Kotlin as the good parts of Scala Minus the good parts of the scala plattform - for example immutable collections.
List is by default immutable, unless you call for a MutableList. Same with Set and Map
Technically they are by default read-only, which is not the same thing.
Here's another example: val greeting = "Hello my name is" \+ name So the benefits are: * Reduces spacing mistakes (such as the one in my example above) which do happen from time to time * Easier to read * Consistent with the rest of the Kotlin codebase (&amp; unified style guide reduces surprises) * Shorter strings reduces the line length which reduces the number of line breaks (due to the column limit) which makes the code easier to understand at a glance Not using string templates when the opportunity presents itself shows the author's lack of basic knowledge and best practices.
I don't know why you were downvoted, but you're right. Nothing stops you from casting a List to MutableList, for example, and changing its contents. Behind the scenes, both are a java.util.List, which implements java.util.Collection, which is, guess what? Mutable. So Kotlin's List is **read-only**, and not immutable.
If you don't mind someone in Glasgow working remotely let me know!
Kotlin does have immutable collections: val fruits = listOf("apple", "banana", "pear") fruits as MutableList fruits.add("Broccoli") print("This line will never be reached even though it compiles") Note that MutableList inherits from List so you could store a reference to that from a variable of type List (so of course you could cast it back in that case). 
Tiobe is a joke. Honestly, any algorithm that puts Visual Basic ahead of Javascript and C++ 2.6 times higher than Javascript is seriously flawed. Delphi ahead of Go and Scala? Come on.
Seconded. Search Indeed.co.uk for -android title:kotlin location:Lonodon and you'll find 1 non-Android job compared with 86 for Scala. 
Yeah, The Tiobe page even mentions that it fudges the numbers by using compensation functions because they "can't accept that Google hits are only half of the number in comparison to the previous month". So they bumped Scala by 11 spots since the previous month even though everyone knows that Scala is actually slowly losing ground.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/scala] [Kotlin already surpassed Scala? (r\/Kotlin)](https://www.reddit.com/r/scala/comments/8pqnnm/kotlin_already_surpassed_scala_rkotlin/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Scala and Kotlin aren't competing, they are intended for different audiences. The one Kotlin is after is the bigger audience though: Kotlin is targeted for your traditional Java/Spring developer and has replaced Java in Android too. Whilst these days Scala is focused more on those interested in full FP, e.g Haskell devs -- and Dotty pushes that even further.
That is quite neat, working in Spring\+Kotlin a bit and getting to love the functional way more and more
Another angle would be: lots of Scala developers are likely to not use IntelliJ for a number of reasons and wouldn't be signed up for Jetbrains surveys. Whereas it's unlikely a Kotlin dev would use something other than Jetbrains tools and is more likely to be a participant in their surveys.
I hate to be that guy, but... 1. Just because some collections are immutable does not mean that List is by default immutable. 2. The ArrayList returned by listOf is mutable, you just can't add to it. val fruits = listOf("apple", "banana", "pear") (fruits as MutableList).add("kumquat") java.lang.UnsupportedOperationException at java.util.AbstractList.add(AbstractList.java:148) at java.util.AbstractList.add(AbstractList.java:108) (fruits as MutableList)[1] = "kumquat" fruits [apple, kumquat, pear]
I guess it was mostly about not having persistent collections implemented with red-black trees. In Kotlin when you create list from a list by adding one item whole list gets copied. In scala it works kind of like appending an item to a Linked List
Thank you for adding an example code that highlights, that there are different qualities of immutability.
kotlin is so envious of scala. most in the scala community don't give a shit about kotlin, yet kotlin is always trying measure itself against scala. kotlin: scala for those who love to hate scala.
Disclaimer: Scala programmer Generally agree with your points, however some extra remarks. Regarding Scala Native, it is actually working more or less completely apart from one proviso which is multicore support (I believe that Kotlin has, or had, similar issues). The only real area where Kotlin is ahead is support for IOS, although there is nothing stopping Scala-Native from doing the same it just wasn't a focus (most scala programmers aren't IOS people) Regarding compiler being slow and the low hanging fruit part, actually most of the low hanging fruit (afaik) has already been addressed, there was even a GSOC project to try and improve the scala compiler performance (iirc) and it failed because pretty much most of the low hanging fruit was already done. Even now, the focus is more on preventing performance regressions and adding some performance improvements in the few areas possible (which are non trivial areas, i.e. recently parallel backend for generating bytecode). tl;dr is that the Scala compiler is pretty much as fast as it can get unless you want to rebuild/redesign the entire compiler (which is Dotty/Scala3). The Scala compiler is slow because it simply does a lot more than the Kotlin compiler.
I don't think this is true, because First of all it's Not guaranteed that the cast is possible, since you don't know internals of the Implementation of the list. Second, the add method probably throws an exception, hence the underlying Implementation can be immutable, and it is afaik. So this discussion looks like a theoretical one, as too often...
Remind me again why we don't like annotations anymore?
Oh, I wasn't aware that the set method was allowed. I stand corrected. Thank you
I'm Not Sure If we should talk about guarantees and such Implementation casts at all. We're talking about apis, which are clearly violated, just the same as with reflection. To me, the conversation seems to be rather theoretical and academic, which is by the way sonething the typical kotlin guy doesn't like, while the scala guy seems to like it.
I'm curious too, what is all this hate for annotations lately? I've heard a lot of people complain about them but without providing any concrete reasons for why.
I wouldn't characterize it as envy but rather surprise/amazement. Scala has worked so hard to achieve their market share for almost 15 years. I was pleasantly surprised since I expected Kotlin adoption to follow a similar trend. I took a quick peek at Scala 5 years ago and was put off by cryptic code (the developer showcasing Scala was proud of the pure functional aspect of his solution not for the reason of being safer or cleaner but for the sake of using functional programming for everything and things like for-loops being taboo). While I really enjoy and use many functional programming aspects, I also realize that sometimes a simple loop is clearest. While this doesn't account for most Scala developers, Scala seems to attract functional programming extremists which leads to very complex / unreadable code. So I don't like that Scala allows some of its complexity which leads to some people on the team struggling to understand the codebase.
It always amazes me that anyone with any insight ever quotes the Tiobe index. 
languages don't create bad code; bad developers create bad code. anyone can write awful code in any language. when you say that "functional programming leads to very complex / unreadable code", it's all a matter of familiarity, education and training. i bet you the same could have been said a few decades ago by procedural programmers about "object-oriented extremists". imho, kotlin is, to paraphrase henry ford, a "faster horse". better than a slow horse, sure, but still a horse.
Used it to mock a Flux. Worked out really good. 
You didn't quote me correctly. I said "functional programming ***extremists***" not "functional programming". I use functional programming techniques all the time and absolutely agree that it is an improvement for many scenarios. My point was that "functional programming extremists" go to the extreme instead of using procedural techniques for scenarios where those would lead to simpler code. Scala tends to encourage these tendencies (for this extremist category of programmers) so I would have preferred if Scala made an effort to keep the language clean &amp; simple in its early days but now it's too late. Doubling the complexity (in general) for a marginal improvement in capabilities is typically a bad choice. It's not always as clear-cut as this since capabilities are typically added over time with the need to maintain backward compatibility. Kotlin was able to learn from Scala's mistakes and produce a cleaner product.
We don't like classpath scanning and reflection.
So now we dislike spring altogether?
Haha. Keep in mind that all Kotlin developers use Jetbrains products, whereas Scala developers don't necessarily use IntelliJ. It's a popular IDE, sure, but there are *lots* of people using Scala from vim, vscode, atom, emacs and other editors.
&gt; Disclaimer: Scala programme With your background: have you ever considered to switch towards kotlin? If yes: why?
Of course, annotations don't have to use reflection. The Android world is full of libraries based on compile-time annotation processing.
When you make an API that takes a list as a parameter in Scala, you can be sure it's _not_ going to be modified from under your feet by someone else at a future point, which would make it impossible to reason about your invariants. In Kotlin, you have no such guarantees. All you can say is ~~promise~~ _say_ you won't mutate the list (and actually you may), but you can't ask "pass me something _immutable_".
&gt; * Native scala seemed like it is not really a serious attempt to get it done. Kotlin on the other side seems to actually deliver it. I'd be interested to know what tangible facts you base this judgement upon. Not saying it's not true; I'm just interested to know what makes you say that.
of course, that which you do not understand will always seem complex to you
The core issue with annotations is that it's not possible to know how they will be processed, and by what annotation processor. There's no link from the annotation to the processor (there's obviously one from the processor to the annotation). Hence, the processing flow cannot be easily followed in the code. 
&gt; what tangible facts you base this judgement upon By reading announecements whenever something happens in this area. Its basically the same strategy i applied for my opinion on IDE support. 
But those other languages are not all directly competing with Kotlin for JVM developer share.
I've 'toyed' with Scala but wouldn't consider myself a Scala programmer, made some small projects. Scala has so much Functional Programming in it's DNA compared to Kotlin that if you are a fan of FP it's hard to even consider switching. Scala is... complicated, but it's also extremely simple on the surface, it's just different and hard to teach programmers previously exposed to either OO or FP alone. It's not so much the syntax, or the language that bite you, it's the larger design patterns, size of community, potential performance issues in the standard libraries. That said, since the language syntax is arguably too flexible, it makes it hard to build tooling and get nice error suggestions for syntax errors that make it hard to grasp. Kotlin on the other hand, whilst I havn't tried it, seems to have a much lower complexity, better tooling support, and are focused on getting a good baseline first. Where Scala has always leaned into the experimental, combining features that seem to work nearly perfectly together, except for the very sharp edges and surprising areas they don't. And over time, you need to learn about the rough edges, and the complexity. It's this, the size of the community, and the potential to use it professionally (locally in Adelaide) that stunted it's growth as my main language. (I was looking into using it 100% for my personal projects over Java) I've since been employed in C# on .net which also feels like a language grown over time but without much thought for syntax expansion (Unlike Scala, which was designed to be scaleable from the start) and it irks me. I've spent time as a Javascript developer, and you know something is wrong with Java, C#, Scala when Javascript with it's dynamic types and shear insanity in parts starts looking appealing. Kotlin just isn't attractive to me, at all. It doesn't offer me anything I can't get elsewhere, at least until more and more libraries start using it alone. and even then, I often feel, why not use Java? It provides less complexities in the applications I'm working in my hobby time (Minecraft modding, so multiple people providing standard libraries is a royal PITA, so shading is necessary, but that brings it's own interop pains) I barely use Scala for that, because of the aforementioned issues, so why would I gimp myself using Kotlin, just because it's easier to learn (after I already have started to grasp Scala basics?)
So essentially, marketing over facts, and Jetbrains has the commericial reasons to push Kotlin? I wish Scala had a backer as large as Jetbrains.
For loop in Scala: scala&gt; for (i &lt;- 0 to 5) println(i) 0 1 2 3 4 5 Scala is as simple or complex as you make it. There is a range of libraries out there that use simpler or more advanced techniques, use the ones you like.
Immutable APIs do exist since Kotlin can use any existing Java classes (eg. "ImmutableList" from the guava library) so you can in fact declare a function that accepts an "ImmutableList" as a parameter. There's also the option of making a copy as well.
I don't want full FP ever. It really complicates the codebase. OO FP fused however, I really enjoy, and I'm still trying to find the right balance. Kotlin? just doesn't offer me anything over Scala from a slightly experienced Scala position. If I was a newbie to both, I'd pick Kotlin.
I am tracking the scala community - not kotlin. So go away with your claims.
&gt; Scala has worked so hard to achieve their market share for almost 15 years. No. They really haven't. I would bet that most of the people behind Scala wouldn't even consider it a 'market' They just want to make a good language, marketing isn't really their thing. &gt; So I don't like that Scala allows some of its complexity which leads to some people on the team struggling to understand the codebase. Agree. Dotty will be a move in a great direction finally making some small truly breaking changes to unify what works well.
But if we talking about Spring and @Component annotations then it's all about scanning and reflection.
I don't understand your comment, but social media (which Reddit very much is) can be considered marketing as well. By announcements I originally gathered that to mean Kotlin's official announcements, and Scala's official announcements for each of the languages -native projects, cross posted to each communities sub-Reddit. Jetbrains, Google, both have the budgets to be able to push Kotlin further, pay people to write announcements, which then get cross-posted to Reddit.
Since you're mentioning Java, here is an article with over 25 reasons to use Kotlin over Java: https://proandroiddev.com/kotlin-avoids-entire-categories-of-java-defects-89f160ba4671
I don't need reasons to not use Java, I've got that in spades. What I need is the impediments of using Kotlin/Scala removed.
I'm understanding your response to mean that you believe JetBrains is manipulating the JVM language metrics and leaving the other non-JVM metrics alone. Is this your view?
I agree with your fact, however it comes off extremely demeaning and elitist. Pedagogy of a programming language is essential, and in my mind, it's only something that [Atomic Scala](http://www.atomicscala.com/) has recently been able to address for me. FP is incredibly abstract, and hard to come to grips with.
Your response implies that you dislike complicated codebases (which I try to avoid as well). Kotlin codebases are less complex than Scala codebases in general so this suggests that Kotlin might be a better fit ;)
The problem is I havn't actually gotten my hands that dirty with large codebases in Scala. the only comparison I have, is huge libraries / frameworks which are complex regardless of language, just to differing degrees.
Can't believe this isn't obvious enough to the people commenting here.
My view is that there is an undeclared conflict of interest and we should be aware of that. Survey results, comparisons etc. need to declare conflicts of interest so that people can make up their own minds about how far they trust them.
Let's see what actual Scala experts which invested heavily into Scala say about Scala complexity: https://codahale.com/downloads/email-to-donald.txt https://movio.co/en/blog/migrate-Scala-to-Go/ Here is a snippet: --- As it turned out, more flexibility led to devs writing code that others actually struggled to understand. It would be tough to decide if one should feel ashamed for not being smart enough to grasp the logic, or annoyed at the unnecessary complexity. On the flip side, on a few occasions one would feel "special" for understanding and applying concepts that would be hard for others. ---
TIOBE just started listing Scala this month due to changes in how Google indexes things. Scala should have been higher in the past, but all rankings I could find show that Scala is falling through the rankings as of lately.
Scala is a bit like the Titanic, instead that after hitting the first iceberg the captain decided that dealing with passengers is boring and turned his ship into a research vessel for hull integrity research and decided to keep hitting icebergs. Now passengers are jumping the ship, the crew is trying to fix the water leaks and prevent the ship from sinking altogether, while the bridge is busy looking for the next iceberg to ram. ---- On a more serious note, Scala has lost it's main IDE contributors to IntelliJ (moved to Kotlin), Ensime (wants to move to Haskell) and Eclipse (left Scala). The engineering quality just isn't where it needs to be after Paul Phillips (main scalac contributor) left, and the decision making is more focused on working on problems they want people to have instead of the problem people actually have.
Denys Shabalin, the creator of Scala Native, actually delivers a lot with Scala Native and there is a rich ecosystem being bootstrapped around it. The same Sébastien Doeraene did with Scala.js, almost alone. Performance-wise, I'd say Scala Native beats Kotlin Native by far. If you don't have technical arguments to back up that Kotlin Native is better than Scala Native, don't make that statement.
&gt; Titanic ... Thanks for making me laugh. &gt; be after Paul Phillips (main scalac contributor) left I suddenly remember his really interesting rant. I think it was this: [We're Doing It All Wrong by Paul Phillips](https://www.youtube.com/watch?v=TS1lpKBMkgg) I actualy recommend people watching it, because many projects are riddled with problems he is attempting to highlight. For example "the scala compiler is so ridiculously difficult to modify that you have to be a rocket scientist ..." is a type of problem that is not only holding back scala, but many commercial products. Hopefully dotty is better in this regards. &gt; Worked on the Scala for 5 years, also left. I never worked with scala in production. I only do some type of reevaluation of its current state and nearly always decided that its better to stay with java. (This time the decission was made to switch to kotlin) 
&gt; If you don't have technical arguments to back up that Kotlin Native is better than Scala Native, don't make that statement. The argument was **not** regarding it's technologic state. 
&gt; I suddenly remember his really interesting rant. That's actually an interesting point – since back then people understood what the design issues were with collections. For instance, Scala's collections are slow _by design_. Now they got reimplemented with largely the same design – and surprise, the same big-ticket problems still exist.
Not op, but Scala is my main driver for a bout a 1.5 year now. I started learning kotlin about 3 weeks now to do some android development, and i love it! it really shows that people behind Kotlin really know what they are doing. my only complaints are : * the default visibility modifier should have been private instead of public. * String interpolation should have different syntax than literal Strings, this way i don't have to escape $. * i can't understand the need for `const val`, so my assumption is it is useless. But to answer your question, at least for now i'll be staying with Scala and FP because they are the easiest route to a correct software.
Actually thank you for your response. One of my intends with my OP was to provoke a response like yours. I am just in progress of figuring out if we should switch from pure java to kotlin or scala at work. But after an evaluation of the current state of scala, i decided to stop advocating pro scala and decided to convince them to pick kotlin. Why? Given all the known issues it is simply far to much of a risk. Many scala developers (this includes the community projects surrounding scala) are ignoring one important fact: developers need reliable tools. Maybe this is different in the area of prototypes / scientific computing, but in case of typical product development: long term reliability² beats nearly everything. --- ²Remark for other readers: i am not talking about uptime - i am talking about how the language and ecosystem evolves. I felt that it is necessary to add this remark, because another post has already gotten an awkward implementation focused response which was completely missing the point.
&gt; sonething the typical ... guy doesn't like It's somehow sad that its often not possible to have a professional discussion. Take the very same article posted in scala's sub as example. Already downvoted into oblivion, because some people are not capable of reading information from a neutral point of view. 
&gt; I’ve always described Kotlin as the good parts of Scala I think that is a very unfair statement to Scala, a better description would be Kotlin is a specialised Scala. While Scala strive to offer flexible and general features (for comprehension, higher kinded types, implicit classes), Kotlin strives to offer specialised features (null operators, extensions...). 
I think one of the large problems is that Scala believes – because they successfully attracted early adopters with an early-adopter-level of user experience, documentation and tooling in the past – that this level of quality works just fine for attracting and retaining mainstream users. And when they occasionally fail to provide even an early-adopter-level of quality, they just retreat back to "Scala is first and foremost an academic research project, what do you expect?". They are stuck in time, while user expectations overtook them.
Glad to hear that you're enjoying Kotlin. The "const" keyword, instructs the compiler to inline the value directly where it's used instead of referencing the variable. I use this for flags that control which assumptions are verified (hidden behind my assumptions-library which uses inlined lambdas). This has a measurable impact on runtime performance and memory usage since large chunks of verification code get completely stripped out at compile time. I can also see a large reduction of the generated class sizes when I turn the verification flag off.
&gt; they just retreat back to "Scala is first and foremost an academic research project, what do you expect?". This type of mindset is actually something i hate. I would love to see someone treading feedback as input instead of blocking it while saying that we don't want you as customer. I am even fine with a response like "thanks, we will note it but most probably we have no time for it within this year", because it means that they at least listened. Sometimes even really minor things might put of a commercial developer. For example when i realized that idea will not jump into the for loop if i hit "step over" while i am currently at "for (x &lt;- whatever)", my mind noted it as "crap, tooling is still far behind". 
TIOBE admitted to fudging the numbers by using compensation functions because they (direct quote) "can't accept that Google hits are only half of the number in comparison to the previous month". So they bumped Scala by 11 spots since the previous month.
Yeah ... there was recently some discussion about feedback and tone, and it just felt incredibly entitled. I have filed more than 200 bug reports against scalac/std library alone (and worked on more than a few of them), and – trust me – if I had thrown a hissy fit every time I didn't like the wording or tone of someone telling me about his issues, I would have missed out on tons of valid bug reports and fixes.
Scala is a very powerful language, and because of this, it is very easy to “shoot oneself in the foot “ Being able to override symbols, or more accurately name have symbols be a function name often makes it hard to read. Scala has had a difficult time with backward and forward compatibility. An artifact compiled with 2.10 is not guaranteed to work on 2.11. For businesses this can be a huge barrier to acceptance. Even Kotlin’s designers have admitted to using Scala as a source of inspiration, it is an elegant and beautiful language. It tries to succeed as a functional and object oriented language, whereas Kotlin seems to be more of an OO language with functional aspects. Scala was a little difficult for me to grasp (admittedly it was much earlier in my career) whereas Kotlin just seemed to click for me (this may have been because I had already gotten comfortable with Scala, and I had much more experience under my belt) To say it’s the good parts was in no way a dig at Scala, rather it takes the parts that Java users would have wanted.
Yep, I know. I think the ranking is now more in line with other measurements, but it shows how unreliable their data sources are.
Why private and not internal?
"let's see what people who failed to adopt scala have say"... keep feeding your confirmation bias, you gonna go far
&gt; Kotlin codebases are less complex than Scala codebases in general It's always the same tradeoff. You take complexity out of the language so you get less surface-level complexity, but you also get more macro-level complexity due to the language's shortcomings in its abilities to abstract. Of course, one extreme example is Go. Super simple language. Would never use it because it basically gives much of the compiler's job to programmers.
Asynchronous programming in Java is just pain in the ass. Coroutines (better version of async/await of C#) on its own makes the change from Java to Kotlin worth it. And the language is just so much more pleasant to use :) 
Of course, you can make defensive copies, but that's a very unsatisfying way of programming. It's like null-checking function arguments everywhere, as often happens in Java land.
Spring is a joke.
Hmm, you could only say it's a failed adoption if they gave up after a short amount of time. Discounting professionals that have used Scala in production for several years as a failed adoption doesn't apply here. They were excited about Scala, went out of their way to create tooling so that Scala development would be improved, learned the ins &amp; outs of Scala, and then made a calculated decision that Scala had too many negatives for them.
`s/Scala/any other language ever/` "There are only two kinds of languages: the ones people complain about and the ones nobody uses." Bjarne Stroustrup Your weak piece of anecdotal evidence doesn't prove anyhing.
&gt; change from Java to Kotlin worth it If it would be without any downside, even the slightest improvment would make it worth it. But unfortionatly, kotlin also has some downsides and as such many companies are carefully weighting pros vs cons.
While your example is true, and that Scala is as simple or as complex as you make it, I find that its usually much more on the complex side. It's also true that many Scala places would not approve of that for loop I work on Kotlin in my side projects now, but I use Scala on my full time paying job. I do agree with /u/determinant that, for what ever reason, Scala does seem to attract FP extremists. And unfortunately I've experienced way too many stylistic/religious approaches/practices(because there are so many different ways of doing things) in Scala that the debates were exhausting and completely not worth it. Regarding libraries, I would say the majority of libraries are in fact unnecessarily complex. As much as I enjoy Scala the language the ecosystem is way too complex IMHO. 
\&gt; the conversation seems to be rather theoretical and academic It's the exact opposite: If your "immutability" is just a thin read\-only veneer over a mutable data\-structure, you are pretty much losing one of the two pillars on which the benefits of immutability rest. Pillar 1: Immutability makes reasoning easier. Pillar 2: Persistent data structures with structural sharing make immutability cheap. If you use mutable data structures, you lose the second pillar, and end up in a constant conflict between the benefits of immutability and the costs associated with it. If I had to pick between "read\-only" immutability (pillar 1 only), I'd just use mutable data structures, because the mental overhead isn't worth it.
&gt; are ignoring one important fact: developers need reliable tools. This is not the case. There's been a lot of energy poured into developer tooling recently: Scala compile times have [improved over the past year](https://scala-ci.typesafe.com/grafana/dashboard/db/scala-benchmark?orgId=1&amp;from=1497060066946&amp;to=1528596066946&amp;var-branch=2.12.x&amp;var-branch=2.13.x&amp;var-source=All&amp;var-bench=HotScalacBenchmark.compile&amp;var-host=scalabench@scalabench@). The Scala Center released a [code-rewriting lint fixer](https://scalacenter.github.io/scalafix/), a [web-based interpreter](https://github.com/scalacenter/scastie), and a [faster build server](https://github.com/scalacenter/bloop). The SBT authors and the Scala Center have been making Zinc (the incremental compiler used in SBT, Gradle, and possibly IntelliJ) faster. Code coverage (scoverage), linters (scalastyle, wartremover, compiler flags), and formatters (scalafmt) now work very well with Gradle and with IntelliJ. Developers at Stripe and others have been adding Scala support in Google's build tool Bazel. Scala 3 tooling for IDEs is being built on an emerging industry standard (Microsoft's Language Server Protocol).
&gt; Whilst these days Scala is focused more on those interested in full FP, e.g Haskell devs It might seem that way from conferences or reddit posts, but the top trending Scala projects on GitHub are not full FP: https://github.com/trending/developers/scala?since=monthly 
On build tools: Gradle is production ready. It has full Scala support for code coverage checks, style linting, parallel builds, parallel tests, local and remote build caching, dependency locks, and basically whatever else they support for other JVM languages as well.
&gt; It's also true that many Scala places would not approve of that for loop(b/c it's not "idiomatic" FP). If you mean because it's a loop, there's nothing unidiomatic about that. It desugars to `.foreach`. If you mean because of the println, I think that was besides the point. If you wanted to produce something you simply add the `yield` keyword, and it desugars to flatMap/map. 
You can't have the argument both ways, you were previously suggesting that the language seems complex because of a lack of understanding. I provided concrete examples where teams used Scala in production for several years and still decided to move away from it due to complexity. There's no way out, first you called it a failed adoption attempt and now a weak piece of anecdotal evidence. Your dismissal attempts do not apply to the provided evidence and suggests that you didn't read the linked articles.
This is great. By minimizing reflection usage and dynamic class loading this could be used with GraalVM to create native images without the JVM.
I don't know how you get to some 'intents' or why you are talking about defensive copies, but i think you and some other people mix up things here... The said list, used by the proper api (not some unsafe casts) is not mutable and can be used as is in apis. We're not talking about Implementation here, which class May or May not ne used under the hood. Since scala is a jvm language i am pretty sure you can fuckup everything through reflection there too...
I don't know why you overcomplicate things, that's again exactly an example of theoretical things i mentioned... Reasoning about the Implementation... Cost of immutability... This is extremely rarely relevant from my experience. Kotlin makes it easy to use readonly collections over mutable ones... that's everything one should care about, everything else are some special requirements i don't know why to talk about.
why?
because...
Let me explain it to you with an example (Scala): case class MyClass(persons: collection.Seq[Person]) { // assumption: `persons` is immutable // here I precompute some of its attributes val personNames = persons.map(_.name) } // Problem: someone can do: val ps = collection.mutable.Buffer(Person("Bob")) val mc = MyClass(ps) ps.clear() // here MyClass' invariant is broken // because personNames.size != persons.size // Solution in Scala: use standard immutable types: case class MyClass(persons: collection.immutable.Seq[Person]) { ... } // (or just a List, which extends collection.immutable.Seq) 
IMO because making `private` the default visibility modifier is fail-safe. When a variable or a function is defined inside a the body of a function, an if statement, or a loop, that variable or function is only accessible inside that body's scope. So effectively, it is private to that scope, and the only exception to that rule is a class's body. Since we write more functions, if statements and loops than we do classes, we get used to write a helper value as `val` and a helper function as `fun`, so when writing a helper value/function inside a class you have to consciously switch to `private val` and `private fun`. Maybe i am more susceptible to this kind of unintentional error than other, because i prefer two break down my functions into small functions. although despite my ranting, there is a simple solution which is i always define helper functions inside a the function that will use them, and only break this rule when i have to share that helper value/function with an other method.
Maybe that's some blub thing ... but having "read-only" not-quite-immutable collections where you have to defensively copy everything anyway – that's missing the whole point of immutability. There is pretty much no benefit to it; and that comes from someone who often enough used while loops and arrays despite having working immutable collections available in Scala. I cannot overstate how relevant persistent data structures are to regain the performance of their mutable counterparts. Without that there is no point to it.
I honestly never thought that that description came from a malicious intent, and even then i still think it is unfair, because it is very dismissive of Scala. When a new comer to Scala or to both languages reads that statements, he will automatically assume that he will not gain anything by picking it up, which is just untrue. No matter the reasons why someone would choose to use Kotlin over Scala, i would argue that picking up Scala and hanging out with in Scala related forums like /r/scala and the all typelevel gitter channels will make you a better Kotlin developer because : * Getting exposed to the Scala community is the easiest way to pick up a lot of Functional Programming techniques, which at worst will make your code a heck a lot easier to test and to maintain. * since there is some overlap between Scala's and Kotlin's features, and because developer have had their hands on Scala for longer than Kotlin, then you'll benefit from their experience with those features.
I mean, not really. The only real competition for Kotlin is Java itself. Scala is stagnant and obviously had a head start, but is on a clear decline. What major company has even decided to adopt it into their tech stack in the last 5 years?
Would love to hear your reasoning.
This has nothing to do with Kotlin. I'd recommend asking your question over at /r/learnprogramming . We're more than happy to answer your questions there!
Thought so. Thanks for the tip. The app that download the files is made in kotlin. 
I figured as much when you mentioned that it was an app. If this were asking for a kotlin-specific route of achieving this, I'd say the post was valid. However you mentioned that it was up for grabs how it was accomplished, so I suggested /r/learnprogramming . There I think you'll get a much better response from people with very diverse backgrounds, and come away with a better understanding that's not specifically related to Kotlin. 
Thanks once again. I'm still learning about all reddit structure. 
is starbucks major enough for you? i write scala for them since 2015. netflix tried to hire me last year for my scala skills. disney? they are hiring scala developers and contacted me too.
Are they really though? 
This survey doesn't reflect actual ecosystem state - at least for Scala. It seems like that there aren't a lot of Scala developers who participated in it. They say that 30% of users use regularly 2.13 version, which isn't released yet. I think for achieving more real numbers JetBrains should publish a participating form for all, not only for ones who found a submitting form at bottom of the resulting page in the previous year.
Spring is a separate macro language on top of Java/Kotlin that has completely different semantics to normal Java/Kotlin. The control flow in Spring applications, especially those sprinkled with AOP, is impossible to follow, it's also slow as shit. Does any developer really need annotation processing codegenerator to make a fucking REST endpoint? Maybe in a language as sucky as Java, but even Kotlin can do better these days, not to mention actually good languages.
Hmm, perhaps don't post in a Kotlin subreddit if you don't like Kotlin?
No I havent, my style of programming is not better Java so I don't code in Kotlin (idiomatic Scala has its own style and its not better than Java). Scala has its faults (which language doesn't), I was just trying to make it clear.
&gt; . But unfortionatly, kotlin also has some downsides and as such many companies are carefully weighting pros vs cons. What are some in your experience?
&gt; What are some in your experience? My first thought: kotlin's aggressive community.