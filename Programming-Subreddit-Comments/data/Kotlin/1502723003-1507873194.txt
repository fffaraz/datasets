My favorite question! I'm one of the Spark maintainers, and I have been using Spark professionally for three years. During those three years I've noticed some things that I don't like (the static api, the req/res pair, the inconsistency of having return-types in route-handlers vs no return-types in exception-handlers, uploads, etc). Javalin is my attempt at fixing these annoyances. Since Spark is a giant project with thousands of users, we can't really make any drastic changes, but Javalin is more of a personal playground. Hopefully some of ideas from Javalin will make their way back into Spark.
That leads to another question... Spark is unlikely to go away because it's a fairly successful project. In your comment you allude to Javalin being a testing ground for new ideas. Do you believe Javalin is a long term project or just a testing ground that will eventually outlive its usefulness? I like some of what I see, but I'd also be hesitant to pick it for something that needs to last.
Makes sense, didn't think about it that way.
&gt; Do you believe Javalin is a long term project or just a testing ground that will eventually outlive its usefulness? That's a hard question. I believe it will be a long term project. There are some features that will never make it into Spark (ex: Req/Res vs Context, returns vs no returns), so Javalin will always be distinctly different. I also learn a lot from building it, and it will never be possible to do the sort of changes I'm doing to Javalin to Spark. I will keep maintaining the project as long as people are using it. If I quit (which won't be in the next year or two at least) I will hand it over to whoever wants it.
You can, but I think the upper version looks less cryptic. I'd use the `=` version only in simple cases like fun getDrinkAuthorization(age: Int) = foo.canDrink(age) or something like that.
I'll just throw my expressiony LittleEndianInputStream from today out there; file.inputStream() .buffered(4096) .run { LittleEndianInputStream(this) } .use { input - &gt; /*use operator closes stream on catch or finally*/ } EDIT: Seriously, formatting code on your phone is hideous
This is very cool. It would be cool to have an example with an actual db in it, instead of a HashMap as a data store. I guess that may be out of scope though. And I know there are a lot of possibilities, but something simple and common like Postgres or MySql would be enough IMHO. This is really great though! Love the tutorials, and that they are in Kotlin and Java.
What is the benefit of writing &lt;insert other fluent lightweight framework here&gt;... Seems like there are plenty of players in this space doing it better and faster. 
&gt; What is the benefit of writing &lt;a framework&gt;... Seems like there are plenty of players in this space doing it better and faster. It's fun (and you learn a lot).
Thanks, I'm considering writing a MySQL (sqlite?) tutorial, but it would be almost all non-Javalin code.. Especially the "how to set up MySQL" part would be a drag to write. I'm not sure if I'll do it.
Crickets here compared to the [/r/androiddev thread on this update](https://www.reddit.com/r/androiddev/comments/6tstxs/kotlin_114_is_out/)
I suppose this is always a perennial discussion in Open Source. 'Why are you working on X when Y is more complete and could use more contributions.' Your comment is perfectly valid, and I should keep it in mind for the future. 
I didn't see much I was excited about (other than J1.9 support) in these notes. It feels like 1.1.3 was just released.
How is this better than data class + copy method? e.g. data class Car(modelNumber: Int, color: Color, engine: Engine) data class Engine(...) val car = Car(5, Color.Blue, Engine(...)) val car2 = car.copy(color = Color.Yellow)
I tend to drop more interesting expressions to the next line. fun getDrinkAuthorization(age: Int) = if (age &gt;= 18) "Authorized" else "Not Authorized" To me the `=` means "here comes some yummy functional stuff" Of course if the author really had internalized Kotlin he would already have done this: fun Int.isDrinkingAge() = this &gt;= 18
stackoverflow is the best resource for many common problems ;) I'm speaking as a C++/C# developer who never had any real Java experience but also started using Kotling a while ago for personal Android projects. 
I can recommend the book Gradle in Action if you want a real deep knowledge about the build. If Not, There are plenty of tutorials on the internet and even the official docunentation has quickstarts and really detailed Information about how to use gradle (for jvm projects, doesnt Matter if Java or kotlin). While i think it's Not necessary to know Java to learn kotlin, as you already figured Out, you have to know about jvm and jvm applications. The best place for this are probably the countless Java tutorials all over the internet. For example of you google for "how to package a Java application". IT will Take sone time though :)
And still no love for the Eclipse plugin :(
That was exactly what I thought after reading the project description :D I have to add, that I really really don't think that those suggested nestings make the code "better" or "cleaner". They make it look more like the "callback hell" we try to avoid nowadays.
Yeah the nesting of immutable objects is the key difference to data classes! That is a very good point and I think you are right, that the nested mutation syntax looks like putting callbacks into callbacks, but I think you can make more complex mutations with this syntax! You could change multiple attributes in every level of the object's definition based on other attributes in other levels. And I think nesting receiver functions is not comparable to callback hell, even kotlin makes exactly the same example in their guide and I do not see any of the downsides of callback hell in nesting receiver functions! https://kotlinlang.org/docs/reference/lambdas.html But maybe I could make the syntax linear for simple mutations? something like val mutation2 = object1.object2.int2.mutate(3) I think you can do very cool things when objects start to get really immutable, but finding a cool syntax is hard, I guess :) 
I added an example to the post to better show the difference! :)
First of all, I want to emphasize, that I appreciate your effort - I'm always very interested in everything that is done with Kotlin. But I'm afraid that too many people start creating DSL for stuff that is very well covered by the language itself already. &gt; And I think nesting receiver functions is not comparable to callback hell, since kotlin makes exactly the same example in their guide and I do not see any of the downsides of callback hell in nesting receiver functions! I can't follow your argument: Only because Kotlin examples do it, it is somehow magically better? Actually, nesting functions is almost exactly the same problem: Yes, Kotlin can write passed functions in a curly braces block so that it doesn't look like a callback hell, but for each function, you have to open a block that is nonetheless called by another scope..and every nested function adds indentation. That's why the example you linked never/rarely shows any indentation deeper than 1 - because that's something we should avoid. Actually I think Kotlin offers some tools to tackle your problem very well. Instead of your example, which is actually very ugly code, You could write something like data class Inner(val innerProp: String) data class Outer(val inner: Inner) val before = Outer(Inner("aString")) val after = with(before) { copy(inner.copy("aNewString")) } And if the nesting is deeper than one level, you could as well use standard functionality, like named parameters to make the code clean. Clean in the means of "understandable", not "fewer letters". Fewer letters would allow for this: data class InnerInner(val innerProp: String) data class Inner(val innerInner: InnerInner) data class Outer(val inner: Inner) val after = with(before) { copy(with(inner) { copy(innerInner.copy("aNewString")) }) } Personally, if objects are really that complex, I would go for fewer functions, more temporary variables and more named parameters :) 
Thanks, I'll take a look. I just spent a good two hours trying to get a simple ktor application to build and didn't really get anywhere. It's kind of a shame because kotlinc seems so easy to use -- I take it it's unrealistic to just point directly to some jars and sidestep the whole gradle / maven madness?
Hey! Thank you for your great answer! :) &gt;I can't follow your argument: Only because Kotlin examples do it, it is somehow magically better? You are right! The argument was very badly written. I did not want to say, that it is a good idea because they are using it, which obviously makes no sense, but I am still thinking, that this is far away from being something like callback hell because the problem with callback hell is that you have to manage an unspecific state of the program in a specific scope at an unspecific time and make further decisions on it (into the next nesting). The syntax provided above does not have these problems because nothing depends on it, afterward (I hope I could get this over :D ) val after = with(before) { copy(inner=with(inner) { copy(innerString=innerInner.copy("aNewString")) }) } That is a really cool example, thank you for that! But shouldn't this be criticized for the very same reasons imko's syntax is criticized? Isn't this even much harder to read and understand? And how could you forbid mutating specific values? Can you really enforce immutability? One cool advantage I see using data-classes is the "out of the box" compatibility with gson or jackson :) 
I'm in a rush so I can't dive too deep, but it looks like you're getting bitten by nullability assumptions. Try being explicit in your type: val foo:Array&lt;FloatArray&gt; = getterMethod()!! The !! means "this method will NEVER return null.". Otherwise your type for food is "Array&lt;FA&gt;?", which means potentially nullable array. Quick edit: also, I'm not sure if that 'out' is appropriate for what you're trying to do.
Even though it doesn't look Like it for you yet, build tools are one of the Most important parts in software development, because they allow you to modularize and therewith reuse Code. For beginners, it might bei easier to just accept that you have to bundle your dependencies in order to use them in your standalone App. Google for "fatjar", apply it to your gradle project and deal with build tools Later :)
Perhaps a library function like takeIfInstance could do this?
Thank you for the response. However (if I'm understanding right) ... the value is coming in as a method parameter (which is itself defined in a Java interface), and I'm just trying to forward it to some existing Java code, with no modifications. My first guess, yeah, was nullability problems (because that's 90% of my Kotlin issues), but tacking on a !! to the parameter when forwarding it to the inner call-to-Java has no effect. So I think it's rather something to do with how Kotlin handles (nested) array typing / 2D arrays coming from Java, not just nullability per se. I agree about the "out", but IntelliJ auto-generated that to implement the interface, so I just figured it knew what it was doing :) ... but removing "out" doesn't make any difference -- same error. It seems bizarre that the inner Java method (the one I'm handing off to) takes float[][], but the Kotlin error says it's expecting a "FloatArray!". Why not "Array&lt;FloatArray&gt;?" Because that's how it translated the float[][] from the Java interface, when auto-generating the implementation for me... It's my bedtime now, but if I still don't have any answers by the time I wake up, I'll try to come up with a minimal example to demonstrate the problem.
I just tried the same thing and got no error. Java public class Renderer { public static void render(float[][] buffers) { } } &amp;shy; public interface Uses2DArray { void doSomething(float[][] inputs); } ___ Kotlin class MyClass(): Uses2DArray { override fun doSomething(inputs: Array&lt;out FloatArray&gt;?) { Renderer.render(inputs) } }
Nah, I get it, I'm just used to build tools like make. The trivial "hello world" gradle file is a huge amount of boiler plate, and the whole convention-over-configuration thing is maddening because the most important thing (your source code) isn't actually explicitly mentioned. I'm blown away at the reinvention of a build system for a language that's "compile once, run anywhere".
I got it! inline fun &lt;reified R&gt; Any?.takeIfIsInstance(): R { if (this === null) return null else if (this is R) return this else return null } Now this compiles: left.takeIfIsInstance()?.preOrder() I like it!
Gradle isn't equivalent to make, it's make + apt-get, and multiplatform. In a skeleton file, most of the "boilerplate" is specification of dependencies. Enumerating your sources when the file system already does that sounds much more like boilerplate to me. For a simple Kotlin project, as long as your sources are under "src/main/kotlin", build.gradle can be something as basic as this: plugins { id "org.jetbrains.kotlin.jvm" version "1.1.4" } repositories { jcenter() } dependencies { compile "org.jetbrains.kotlin:kotlin-stdlib:1.1.4" }
Ack! I tried your example (thank you for taking the time, BTW) and it works fine. So I wonder why my in situ code isn't working, sigh. When I wake up I'll try to whittle it down to the smallest broken version I can, and report back here. But it is fundamentally the same as your example.
If you're not getting a linter error, try cleaning the build directory and doing File -&gt; Invalidate Caches / Restart. Sometimes that fixes weird build problems.
`(left as? Node&lt;E&gt;)?.preOrder(l)`
You can drop the null-check, `if(this is R)` already does an implicit null check anyways. Also, see the comment by /u/yawkat for a solution with an explicit safe cast that doesn't require a new extension function and is, IMO, clearer. Oh, and just one more thing: you can put code in backticks (like this: \`some code\` will display as `some code`) to format it on Reddit :)
Well, being explicit about source location seems like a lesser evil than the tool implicitly looking in e.g. `src/main/kotlin/thing.kt`, which is pretty undiscoverable -- couldn't find it anywhere in the docs, but maybe I'm just an idiot. Thanks for your patience. As for your minimal file above, don't you need the "application" plugin if you want something that's actually runnable? I've pieced together something that will run a minimal ktor application that seems to work, although it's a good bit more dense than your file above: https://pastebin.com/NjQfnJHK It's also unclear to me how to distribute applications -- "distZip" seems to make the thing I want, but it's unclear from the gradle docs what to do with the resulting file. Most material I'm running into about distributing java applications refers to jar files. Anyway, maybe I need to spend my time learning gradle / jvm application stuff rather than kotlin.
This is not exactly what you're looking for, but yeah. Unless you want to learn Kotlin (or this is a tiny one-time kind of thing), I'd go with Spring Boot. You might say it's huge and bloated with reflection usage, but it has a library or an extension for _everything_, can be integrated with almost anything painlessly, and it's pretty much as stable and secure as it gets. It's extremely easy to get the app up and running, especially if you've worked with Spring before. Since they're adopting Kotlin as an official language, I'd give the latest Spring Boot 2/Spring 5 releases a chance and use some of the new Kotlin-specific features.
Spring website introduces itself as an enterprise solution. I'm not an enterprise. Is it popular among small developers? Any non-enterprise popular user facing web apps built with Spring Boot?
Not a lot of frameworks as specifically designed for Kotlin, but there are at least two active ones: * [ktor](https://github.com/Kotlin/ktor), official web framework by JetBrains, definitely the top one * [http4k](https://github.com/http4k/http4k), more of a http toolkit, has both client and server, pretty neat though Most Java projets are starting to add Kotlin wrappers though, you shouldn't limit your search to a framework that only focuses on Kotlin.
The application plugin is the easiest way to make an executable jar, yes. There's also the JUnit plugin for unit tests. The `src/main/kotlin` convention comes from Maven, the other (older) major build system for the JVM. You can quite easily override it with a custom layout like so, but I've never seen the need. sourceSets { main { kotlin { srcDir "sources/main/kotlin" } } test { kotlin { srcDir "sources/test/kotlin" } } } Learning Java isn't necessary (it's almost a subset of Kotlin anyway), but learning the JVM tooling is. Both the [Kotlin](https://kotlinlang.org/docs/reference/using-gradle.html) and [Gradle](https://docs.gradle.org/4.1/userguide/java_plugin.html) documentation mention the default directory layout. My build.gradle was just a minimal example for the sake of argument. Real ones are more similar to yours but I still see little boilerplate in that. Distribution depends on what you're deploying to. JVM servers usually take jars along with any resources they depend upon. A jar is just a zip file with the compiled JVM bytecode along with some metadata. Running a jar requires a JVM since it's just bytecode, not a native binary. You do that with: `java -jar foo.jar`.
I've been working on a web framework called [Kweb](http://kweb.io/), that takes a fairly novel approach. Key features: * Build websites in Kotlin * Makes the barrier between web-browser and web-server largely invisible to the programmer * Seamlessly integrates with powerful JavaScript libraries like JQuery, Semantic-UI, and others * Update your web browser instantly in response to code changes * Bind DOM elements in the browser directly to persistent state on the server and have them update automatically, through the observer and data mapper patterns - following the "single source of truth" principle * Easy to add to an existing project, Kweb is just a library, it doesn’t seek to tell you how your project should be organized Caveat: It works, you can play with it, but it is still months away from being production-ready. I'm looking for interested developers to help me with it though so please check it out :)
Java is king of the enterprise so any Java library looking to make a profit positions itself as an "enterprise solution". It's likely the most popular JVM web framework so you don't have to worry about lack of documentation or support. If you're worried about "enterprise" implying ugly design-by-committee APIs and mountains of XML, you'd be right a few years ago but Spring Boot does away with a lot of that. Spring 5 adds WebFlux which is a completely new API following the async/reactive patterns that all the trendy frameworks use.
Great, thanks much; looks like I missed some stuff so I'll spend some more time reading.
When spring was first create was an alternative to J2EE. It still has that seem feel but, in order for pivotal to sell services they need to say the word enterprise a few times. Just ignore it.
The Javalin framework is a rewrite of spark Java focusing on Kotlin use. I have also heard of success with vert.x and Kotlin
Thanks for the mention, but I'd like to point out that Spark has kotlin support: [perwendel/spark-kotlin](https://github.com/perwendel/spark-kotlin). [Javalin](https://javalin.io/) started as a fork of Spark, but the API is a lot closer to [koa js](http://koajs.com/#application) than Spark now, and Java-interop is very important to me when I design the API. 
Thanks!
you can also use the new functional API to bootstrap the app and create the web handlers, give it a try it works pretty well, reactive support is awesome.
Makes sense. But, about the second part of my question, which big non enterprise web apps use Spring? If none, why have they avoided it?
JetBrains, maker of IntelliJ, is making Kotlin. I doubt you will ever see as much love for the eclipse plugin as you want. I would recommend IntelliJ tho. I used to use eclipse, but I've just absolutely fallen in love with this IDE.
I don't actually know the answer to your specific question, but as a small developer writing webapps, I finally gave in and started learning Spring and wish I'd have started a long time ago. Previously I had been using Java Spark + thin database libraries to roll my own DAOs. Spring has been pretty painless and a joy to use. I can get an app up in running in MUCH less time, with MUCH less boilerplate. Basically I've gone from "keep it away from me" (because I had heard it was a huge bloated mess) to fanboy in a short few months. Highly recommend you give it a try and see for yourself.
For the simple cases shown here there isn't a whole lot of difference, I agree. But I ran into a case where I needed to initialize a list of lists and it was a pain: val data = listOf( listOf(100, 1), listOf(100, 2), listOf(200, 1), listOf(300, 1), listOf(300, 2), listOf(300, 3) ) It would have been simpler to create (and read) to use: val data = [ [100, 1], [100, 2], [200, 1], [300, 1], [300, 2], [300, 3] ] 
until you have to support that app, and trace bugs, and wonder WTF is spring doing under the hood.
interesting. Are github's issues a good place to start digging in order to submit a PR?
Did you check ktor.io? We have detailed guide for gradle, maven and IntelliJ IDEA.
Absolutely! You're also welcome to join #kweb on the kotlin slack, happy to answer any questions there in realtime, or here if you prefer.
Probably not many, because right now JavaScript is the trendy language among startups. Kotlin just makes writing for the JVM a lot nicer though. You get a tonne of the functional features that JS developers try to emulate, and even more type safety than Java, without the verbose and redundant type declarations. Maybe with Google naming Kotlin an officially supported language for Android it'll gain some momentum outside the enterprise. Regardless, Spring has been very successful, it has a team of paid developers behind it unlike a lot of JS frameworks, WebFlux gives you an API similar to what you'd expect coming from JS. It's just a nice framework and it's as polished as they come.
I'm definitely a fan of the direction Javalin is going.
I updated the original post with what I finally figured out. Short version: the inner render() function was actually Groovy, not Java (derp), and the resulting bytecode is I guess what's causing Kotlin's compiler not to like it. Not sure if it qualifies as a bug, but the resulting error message doesn't really make sense.
I updated the original post with what I finally figured out. Short version: the inner render() function was actually Groovy, not Java (derp), and the resulting bytecode is I guess what's causing Kotlin's compiler not to like it. Not sure if it qualifies as a bug, but the resulting error message doesn't really make sense.
When you want to give an array to a varargs method from kotlin you need to use the spread operator (*). Simple as that. Otherwise kotlin will expect you to give separate float arrays as multiple parameters and the error message reflects that. 
But does it matter if it's not *supposed* to be a varargs method? The 'varargs' bit is some shenanigans the Groovy compiler is adding to the method signature, not anything that's there in the source code (supposed to be a plain float[][], grrr). My naive hope was that @CompileStatic made the bytecode as Java-like as possible, but apparently not. Anyhow, I tried the spread operator when passing to render() just now and got: Error:(63, 29) Kotlin: The spread operator (*foo) may not be applied to an argument of nullable type If I try to send it as *(inputs!!), I get: Error:(63, 29) Kotlin: The spread operator (*foo) may only be applied in a vararg position Sigh. I'm pretty out of my depth at this point, so I'm just going to rewrite everything in Kotlin and (hopefully) be done with it.
I've been trying to find a good, Kotlin-native framework, but I haven't had much success. The pure Kotlin ones, like Javalin or Ktor, don't have any validation framework built in, and I'm not of a mind to roll my own. I'd really like to see something like marshmallow in Python. Spring 5 is fine, but the new functional API only works with Reactive, which is a big pain if you're not using the reactive DAO interfaces. I wish they wouldn't force that paradigm on people who don't need it. Generally, I feel like this area is still fairly immature in Kotlin. I'm hopeful that it will get better as the language gains momentum.
I have no idea how groovy does this, so I'm out of ideas, too. Might be worth to file a Kotlin bug, maybe the interoperability with groovy can be improved somehow. 
Hello! I use ktor in Kotlin almost on daily basis. If there is something wrong with the Gradle build file I might be able to help. This is something similar to what I use https://github.com/mantono/GradleTemplate/blob/master/build Gradle (you still need to add ktor as a dependency tough). What error do you get? 
This is documented here: http://kotlinlang.org/docs/reference/java-interop.html#java-arrays
Thanks!
I'm not very familiar with marshmallow, but they advertise it as 'simplified object serialization'. In Javalin you can do val book = ctx.bodyAsClass(Book::class.java) Which works with data classes. What is missing here that you like in marshmallow? Anything I can add?
Ah! Thank you! I searched around for a little while, but I guess I was searching for the wrong criteria.
What type of validation are you thinking of? If it's unmarshalling objects from an HTTP request, then http4k supports that in a typesafe manner using it's lens mechanism. In the case of a deserialisation error, you get an 400 automatically generated. There's support built in for a load of common types (primitives, datetimes...), but if you add the jackson or gson modules then you can get full auto conversion for serialising classes. It also works for marshalling objects back onto the wire. See the lenses and message format sections here for more details: https://www.http4k.org/guide/modules/core/ https://www.http4k.org/guide/modules/message_formats/ 
&lt;shamelessplug&gt; Bit of an aside here - for anyone that's in London and is interested in Kotlin web-framework development in general, I'm co-hosting a talk at the next Kotlin London meetup about why we developed http4k and how it's affected our development and test strategies. Here's the meetup link: https://www.meetup.com/kotlin-london/events/241918493/ &lt;/shamelessplug&gt;
I have tried IntelliJ several times over the course of the last 5/6 years but in the end I never liked it enough to switch away from Eclipse. I always find it bloated and slow when compared to my (admittedly customized) Eclipse setup or even NetBeans. The point of my reply was that Kotlin is shaping up to be one of the very few mainstream languages (another being probably Swift) that is almost inextricably tied to a single commercial IDE. If Apple is always criticized for being a walled garden, then I don't see why Kotlin &amp; IntelliJ shouldn't be criticized as well. I develop on a daily basis in Java, Python, JavaScript and a few other languages and in each of these cases I can choose between a number of excellent and free development environments. Kotlin is the only exception to that. Another important point is that the market penetration of IntelliJ in large organizations is overestimated here on Reddit or other forums. My last two employers, over the last 12 years, total several thousands developers and the usage of IntelliJ is almost none, both of them being completely dominated by Eclipse. In such environments the proposition of introducing Kotlin will fall flat because of the need to switch to IntelliJ as well.
With regards to the bloated and slow comments, I always found Eclipse to be like that. Overall I've found IntelliJ's performance to be superior to Eclipse, but that's just my opinion. There's nothing that stops people from investing in Kotlin support for Eclipse. But overall, from a business perspective, JetBrains has less of an incentive to do so. They are hardly making Kotlin a walled garden, as there is nothing that would stop anyone else from working on a Kotlin/Eclipse plugin. I'm also a professional Java developer, my company uses IntelliJ btw. Eclipse has a big advantage being 100% free, even for some of the heavier enterprise features, while IntelliJ you have to pay for that stuff. Even so, market share studies show that IntelliJ and Eclipse split the market almost evenly. Anyway, I feel like I'm about go go down the My-IDE-Is-Best flame war road, and that's just dumb. So anyway, have fun with Kotlin. Bye.
Oh, I didn't want it to be a "good example" xD This is usually code written by people wo think that less letters means more readable code. Although functional and Kotlin programmers are more familiar with implicit return values and the special higher order function syntax of Kotlin... I wouldn't want to write it like that. Not even in a project I'm writing alone. I have to admit I haven't taken a too close look at what your framework can do to limit scopes of mutability for nested objects :) Maybe it is really just my opinion, but one rarely encounters such complex problems in terms of immutability. And if one is in such situations, it is often required to have a certain freedom to do stuff. And again, probably is it just me, but I rarely want to read tons of documentation how a DSL does stuff I can do in a very concise way with the language constructs alone. Having that said, programmatically waterproof are implementations very rarely...for example what prevents users from instantiating classes somehow else? And if you use data classes, who does people prevent from using copy() and changing arbitrary properties? I think most often, complex measures are not worth it.
Spring's webflux is an reactive web framework that has a [Kotlin API](https://dzone.com/articles/spring-webflux-kotlin-dsl-snippets).
That is true of any framework or library that you use in a project. Luckily Spring is open source so you can figure it out. :)
I was just testing a sorting algorithm using either Array&lt;Int&gt; or IntArray. The IntArray one is twice as fast. However the IntArray algorithm can't be made to use generics, which is quite a downside. If I want to use that code for doubles, I would have to do a lot of copy/paste, which is awful from a software engineering point of view.
[Jooby](http://jooby.org) comes with a Kotlin module: http://jooby.org/doc/lang-kotlin. There are two starter projects: - Maven: https://github.com/jooby-project/kotlin-starter - Gradle: https://github.com/jooby-project/kotlin-gradle-starter
Jackson obviously handles the deserialization part, but the part I care about is being able to control/configure error messages if the object doesn't deserialize, plus some more involved validation, like length of string, non-empty strings, enum validation, URL validation, etc. I'm sure some of those are in the JSR validation annotations, but it would nice to have a pure-Kotlin solution.
Nice, I'm moving to London next month. I will try to attend to a meetup.
few frameworks carry that amount of magic IMO. I try to stay as far away as possible from spring, play, grails and alike. Dropwizard seems like a saner approach.
That's fair, and I was doing the same thing for a long time. I came to the conclusion that I was wasting too much time connecting the pieces though and decided to give Spring a try. Haven't looked back, but I've also not hit any major issues so far. Obviously YMMV, but it's not as mysterious and black box-ish as it seems from the outside. Like I said, it's open source so you can trace it yourself. In the few instances I was getting unexpected behavior it was pretty quickly solved by popping into the debugger. The other side of the coin is that I haven't been using all that Spring has to offer. I've found the bits I've been using to be pretty straight forward and not as magical as I expected, but I'm only really using the REST server and some of the security modules. Other stuff could be a can of worms.
Focussed libraries &gt; gigaframeworks :)
my gripe with it is the reflection way of doing things. Everything seems to be "plug your config on a xml/yaml/whatever file and let reflection and DI do the magic" so you end up chasing bugs on runtime instead of compile time. Of course most of them can be prevented with proper testing but it still gives you headaches sometimes
Yah, I think that's a totally fair concern and exactly why I try to stay away from dynamic languages most of the time. I could see myself swinging back the other way if I ever get bit by it. The other piece here is that I'm not making anything that I'm under intense pressure to update/fix. If there are bugs I get some complaints but I'm not losing money over it. Being in a position where I can take time to dig into problems makes it an entirely different beast than if I were trying to use this for a widely used product. In regards to the XML/YAML stuff, you may want to check into Spring Boot. With boot they basically do away with a lot of the XML/YAML config stuffs and allow you to configure things using code. That may help eliminate some of the reflection issues but likely not all of them as it'll still have to do some magic at runtime.
I've came a long way ... to Spring. First Flask (Python), ASP.NET, Node and now Spring Boot (with Java, however, to avoid too many new tech to learn). Sooner or later your applications become more complex, you need more "production" features like security, logging or just a clear standard how to structure your app. But Spring is also hard to really get until you have had the pain to take care of all those things by yourself. I had this pain especially with Node. Things like configuration for dev and prod, mix different logging libs, "import hacks" for modularity (instead of DI) or lots of repetition in the data access classes / functions. It's all doable, but takes a lot of time and a lot of research of heterogenous resources. With Spring you know where to look and what to do. I can focus on beautifying the frontend :-) ...
annotations use reflection, it's just glued together in the code, but you still lose compile type checking of whatever you're doing (prime reason why we're on this sub instead of groovy or python, right?). I agree, YMMV, I wouldn't use Spring on a scalable project but for a throwaway or quick thing? sure, stuff like spring-data-jpa are sexy like hell.
There's a trick you can use here due to the compiler being amazing. class FooResult fun ByteArray.foo() = fooImpl(size, this::get) fun ShortArray.foo() = fooImpl(size, this::get) fun IntArray.foo() = fooImpl(size, this::get) fun LongArray.foo() = fooImpl(size, this::get) fun FloatArray.foo() = fooImpl(size, this::get) fun DoubleArray.foo() = fooImpl(size, this::get) private inline fun &lt;T : Number&gt; fooImpl(size: Int, get: (Int) -&gt; T): FooResult = TODO() You might think this has insane overhead of bound callable reflection + autoboxing but the compiler actually optimizes it all into neat primitive array accesses. I found this when I needed to shuffle primitive arrays since Java stdlib only has shuffle for generic lists.
&gt;The point of my reply was that Kotlin is shaping up to be one of the very few mainstream languages (another being probably Swift) that is almost inextricably tied to a single commercial IDE. I think you're seeing the situation the wrong way. In a literal sense, Kotlin isn't "inextricably tied to commercial IDEs". Kotlin does not require an IDE, it has a standard CLI compiler like most languages. Kotlin is just the few languages that considers high quality tooling a priority. A text editor and a terminal window seem like poor alternatives to the quality of tooling that Jetbrains has provided in IDEA. It seems unfair to me to criticize them for making their IDEA plugin *too good* to go without. Look at Rust/Go to see how bad things could really be if language developers don't bother with tooling.
In Java-land my go-to lightweight web framework has been [Spark](http://sparkjava.com/) for a while and it's recently received a [Kotlin-focused API](https://github.com/perwendel/spark-kotlin) that is actually quite nice to work with. Silly example: import spark.kotlin.ignite fun main(args: Array&lt;String&gt;) { val http = ignite() http.get("/subreddit/:name") { redirect("https://www.reddit.com/r/${params("name")}") } }
Doe the same apply to Spring Boot?
&gt; First Flask (Python), ASP.NET, Node and now Spring Boot Do you think you're going to stop at Boot? Or is it an ongoing list? 
How does it compare with Spring Boot?
Yes, spring boot is a "pluggable" edition of spring. You just add the dependencies you need incrementally, instead of loading, I.e a full MVC framework. 
That's awesome. Thanks for sharing it.
Don't know yet :-) ... I started 4-5 years ago with my first Python project. Only my adventure with Node was a bit hasty, as we wanted to get rid of our Windows Server by migrating to .NET Core on Linux, but there we hit some early adopters perfomance issues. So we needed a quick and dirty fix, which I made with Node. Unless there're downsides I haven't seen yet I'll probably try Spring with Kotlin next. Spring is at it's base a DI and AOP framework. So you can use it to create commandline apps, or to integrate with other technologie like Vert.X, or what ever. On my way so far I've found that I'm not willing to reinvent the wheel all the time any more. When I started, it was big fun. And I was curious. I enjoyed solving all those problems. Now I'm just happy with @Autowired.
If you can figure it out you must be a genius. Just because the code is on github doesn't make it any easier to decipher. It's such a massive project. 
@Autowired is exactly the thing you don't need anymore with Spring Boot 1.4+ if you're doing constructor wiring. And, for more elegant and testable code, that's the recommended approach (and looks even nicer with Kotlin)
I'll never go back to Java.
Spark is strictly _only_ a web framework, Spring Boot is more of an entire ecosystem. If you're building a larger application and know that you'll have lots of needs regarding persistence, authentication/authorisation and so on you can drop those components in from the wider Spring ecosystem. Spark is closer to how things work in modern functional languages, i.e. you pick your own selection of small, single-purpose libraries and assemble them. I personally prefer the latter approach, but lots of people also prefer the Spring way. You'll have to try and see :-)
Never say never :)
never
/r/madlads
But which kind of List?
You mean like people on UNIX never go back to C or on the browser never go back to JavaScript?
Some hopefully constructive critique: * put the answers together with the questions. I will believe you that the code does what you write in your answers, so I don't need to execute it. As as I don't need to execute it, there is no benefit from having the code in kotlin files and the answers separately. * make the puzzles so that the answer has an unexpected result. Avoid having puzzles that are simply compile errors because you did something slightly weird (looking at for example the "exhaustive main" puzzle). 
I think he means like something someone has actually ever said, unlike either of those 2.
I understand that there are multiple types that can be created. However that could be handled by a type declaration on the variable, or some other mechanism. This isn't a huge issue to me but one of convenience and readability - which Kotlin normally excels at, but not here.
Check out this repo: https://github.com/mixitconf/mixit It's the site for a programming conference written by the principal spring kotlin contributor. The repo is meant to be an idiomatic example of a larger spring boot/kotlin web app.
Saying Groovy is just a scripting language is BS. Groovy has optional (flow) typing and extension functions as well. 
I think the google search terms can be misleading. I find searching for Scala solutions via google means i might have to search more times to get the thing im looking for. In golang (for example) i search once or twice to get the thing I'm looking for. Also scala is more complex so you are going to be searching more often compared to Kotlin. Also reddit stats are useful. Seems like Scala and Kotlin are quite on par in terms of number of new subscribers (growth). Both are slowly growing, java still has much bigger growth. 
If it wasn't for Gradle and Google adopting it for Android's build system, Groovy would be long dead.
Kotlin does just everything right when it comes to the huge java base that want an improvement to the language. The tons of getter/setter boilerplate, the constant devestating null pointer exceptions, especially in enterprise interface development, the not perfect lambdas (type inference etc.), the stupid .class method parameters everywhere in frameworks that use reflection, etc. Kotlin improves all this but also retains all the experience gathered with frameworks, enterprise architecture and application servers that are tried and true for tens of years. With this, I myself see Kotlin objectively superior and will not use Java ever again. And should there be a niche case that pops up, where using kotlin just does not work right because of some framework specifics etc., I will just mix, and do them in Java. One example is copying a complex algorithm that has already been done in Java and just using it as is, not risking breaking anything by converting.
Grails is pretty popular aswell
I don't see Grails talks in JUG events on cities around my area since around 2012.
I see it used a lot for new systems, where JEE or Spring might have been used in the past. I also know several big consulting shops which mostly do Grails. But sure, it might not be the hottest new thing at conferences etc.
Plus Jenkins, where [Groovy is not going away anytime soon](https://issues.jenkins-ci.org/browse/JENKINS-41676).
I've been using nullable types in places where I would normally think about an Optional. The Kotlin compiler's handling of nullable types make the experience much smoother than Java Optionals. To your specific points: 1. I think this comes down to a design decision. Nullable types don't solve all problems, and you're right a more specific error value or default value might be more appropriate 2. No experience with RxJava2 3. `?.` is the same as `Optional.map`. Any value produced by it will also be nullable, so it shouldn't be any more susceptible to bugs 4. Kotlin doesn't do anything clever in interop scenarios. It generally puts the decision in the developer's hands whether something coming from Java is nullable or not. Sometimes you have to be explicit, but you can always do something like: `val x: JavaType? = javaCall()` or in the scenario you mentioned with generics you may have double nullable: `val x: List&lt;JavaType?&gt;? = javaCall()`
In response to your first point: just as with Optionals, I'd want proper documentation. An empty Optional can also mean several different things (error scenario, no data available, this is a sane case for which no value exists, …) just like null. Both systems are equally powerful but neither of them tell you WHY they were returned as you can't capture this info in the type system. So I see no downside of nullables here.
Optional in java [was never meant for use outside return types](https://stackoverflow.com/questions/26327957/should-java-8-getters-return-optional-type/26328555#26328555), and isn't all that great for those cases. It interacts poorly with existing libraries and is clunky to use. Kotlin nullable types are much more practical in my opinion, and much more usable when interacting with "normal" java libraries.
Basically the entire reason why nullable types exist in Kotlin is so that you don't have to use `Optional`; nullable types express exactly the same idea but have zero runtime overhead and much more support in the language. To address your specific points: * `Optional` is not specific either. In some cases, you may be better off using a custom wrapper object to express the idea, but we have found such cases to be pretty rare. * `?.` doesn't appear in your code by itself; it's your decision to use it. If you don't want silent no-op behavior, don't use it. * Kotlin will throw an exception if you try to store a null value coming from Java in a variable that has a non-nullable type in Kotlin. Not using nullable types in Kotlin will not help you avoid this problem in any way.
Couldn't have said it better. I'm a huge fan of Java because of my positive experience with it in large software projects (and I can compare it to professional projects with ruby, c++, python, c#...). Using Kotlin has nearly only beneftis, no real drawbacks and does preserve nearly all strenghts Java or the Java platform offers. Mixing Java and Kotlin is impressively easy and as so many others, I won't ever go back if I don't have to. Kotlin is one of very few languages that doesn't give developers unlimited power and all cool features, but pushes good coding and stable, maintainable codebases while making coding fun nevertheless.
People say it, because that's the main purpose the language is used for. Of course, you have tons of features, but the overall experience is so much worse than for example with Kotlin, that scripting is the only application where I would prefer Groovy nowadays at all... the bad type inference and dynamic typing is driving me nuts every single time I have to deal with Groovy at work. Grape besides is something I find impressive and I really like it :)
1) I don't think that the additional type information should be used to document every behaviour of your application. If a method can return a nullable value, than that is explicitely all you can know from it. Exceptions are highly argumented about nowadays, but if you have a method that can fail, don't return a nullable value, but throw an exception. If you don't agree with that (which I can truly understand), you have to document (apidoc) the behaviour... exactly as you would have to when you use optional. But from my experience people expect a method with an optional return type not to throw exceptions at all. 2) I don't know the implications of that because I don't know RxJava too much, but from my experience: Functional/object functional languages tend to use Optional as a crook for "list". In the means of they want it to behave like a potentially empty list, which is a handy thing, but doesn't always work to well wich Java APIs. Stick with Kotlin's collections extension functions where you can, is my advice :) 3) Yea, if you just do things to satisfy the compiler... than you could probably use !! everywhere. The thing is, although all those constructs are equally easy to type, you have to think about what fits your use case. For example there is the elvis operator where you could even throw an exception in the else part.. typing it really is not more effort than using save call operator, so why not slow down and do it properly in the first place? I think there's no difference between using Optional wrong or using nullability wrong. Sure, both is possible, but I prefer the concise one that doesn't introduce generic classes and works well with all other language features. 4) I have not much experience here, but I think everything coming from Java is treated as non-nullable (for our convenience). Null-checks are automatically added, so you have a fail-fast behaviour. This doesn't have to do anything with generics in particular. If you want nullsafety, you can simply treat everything as nullable - T is a subtype of T? in Kotlin.
I mostly use nullables for data modeling where I would use null in a database. Basically when you need to differentiate empty or 0 from DNE. A good example I usually give is for invoice payments, I use 0 if the payment was received and it was $0 (balanced out to 0 or whatever), but null to mean that no payment was received at all. Otherwise, I sometimes use nullables in place of Optionals for return values and for interoperability, of course. Otherwise, I generally avoid nullables and err on the side of exception handling. I've often used the Objects.requireNonNull with customized exceptions, so when interoperating with my old Java libraries, the exception handling is more useful anyway, so I just keep that consistency across.
I'm not aware of any, but someone else might be. But why not just continue using the JAXB classes. Any reason you need them to be in Kotlin? If you don't like having the mixed code in the same application, maybe think about making a library out of the JAXB classes and importing that jar into your Kotlin application. 
+1 for this approach
[removed]
It would be very advantageous to have XJC (or a similar tool) generate JAXB-annotated Kotlin data classes. Sure, your Kotlin codebase could just use the XJC-generated Java classes, but you lose a couple nice features * Kotlin nullability semantics (i.e., you get the !-suffixed "platform type" rather than the explicitly nullable or nonnull type) * val/var * equals/hashcode/toString * ability to use destructing declaration * named parameters * non-mutable collection types I don't know of a XJC extension (or alternative) that will generate Kotlin data classes but it sure would be nice!
If your looking to use Kotlin, Java, or any language on the JVM, there is now an unofficial SDK. https://github.com/TicketmasterMobileStudio/actions-on-google-kotlin
It is even better than anything else *without* the Kotlin specific bits. I use it daily and it is as seamless as it gets. This is a huge win especially that I know how long was the way the Spring guys have came to have Spring Boot right now (I'm working with spring since its 2.0 version).
&gt; Making blanked statements without backing them up is plain stupid. Making blanked response without reading the question is plain stupid. &gt; Spring is used in nearly all of the enterprise Java shops so I guess this is as enterprise as you can get. My question was about the opposite of this.
My bad. I read &gt; *It's not an enterprise* instead of &gt; "I'm not an enterprise" You can use it without being an enterprise. I'm not an enterprise either and I use it on my pet projects.
https://github.com/JetBrains/Exposed
That's exactly what I wanted, thank you! 
There is also https://github.com/orangy/squash by orangy (a jetbrains employee)
Anko has a sqlite helper module. Though I haven't used it in a Kotlin application that was not Android-based so I'm not sure about its applicability to e.g. servers. https://github.com/Kotlin/anko/wiki/Anko-SQLite It's not an ORM or anything. I use it to map rows from an SQL queries to a list of data class objects. I just have this helper function: inline fun &lt;reified T : Any&gt; SQLiteDatabase.query(sql: String, vararg args: String): List&lt;T&gt; { try { this.rawQuery(sql, args).use { return it.parseList(classParser&lt;T&gt;()) } } catch (e: Error) { e.printStackTrace() return listOf() } } And then I use it like this: data class UserDataRow(val user_id: Long, val user_name: String) val sRows = db.query&lt;UserDataRow&gt;("select user_id, user_name from users") // sRows is a list of UserDataRow // db is an instance of `android.database.sqlite.SQLiteDatabase` 
Is this library a blocking one?
Several Kotlin SQL libraries were mentioned in this thread, but don't forget that you can also just use plain JDBC as well if that's what you're used to. At work I have a Kotlin microservice that uses Hikari CP and standard PreparedStatements. Nothing too fancy.
https://github.com/requery/requery
It's DI framework but it's not support JSR-330. I think it's fail :(
Couldn't find a topic about Kodein in this sub. Anyone used it before? How does it compares against Dagger2? I'm wondering how difficult it would be to replace a project using Dagger2 to Kodein; and its pros/cons. I have experience with Dagger2, but the Kodein docs is not making much sense to me at this point.
No. Dagger 2 - JSR-330 implementation. Try Toothpick! It's realy more easy and cool than dagger) https://github.com/stephanenicolas/toothpick
It uses JDBC, so I'm assuming yes.
It says it doesn't use reflection but annotation processing. How can you do annotation processing without reflection?
&gt; How can you do annotation processing without reflection? Easily via compile-time code generation.
Wow, toothpick looks great. I always stop myself from using dagger in my small hobby projects due to it's verbosity and bloatness, toothpick looks like a much better candidate for DI in such case. 
If everything that isn't Java standard was a fail, Kotlin wouldn't be where it is today.
Now I'm migrating all my projects from dagger to TP (it's easy). And I will be talk about TP on android devfest Siberia soon ;-)
Why do you think it is a fail?
Because the standard allows you to use different libraries and easy migrate. A lot of very good enginers cteated JSR-330. I's very important. If Everyone will do it their own way then there will be chaos
One good thing about keeping some JUnit tests in Java is to prove out Java interop, if that's important to your project. It's easy to mess it up but the JUnit tests will keep you honest.
Why would there be chaos if you can choose between different DIs? Kodein does not follow JSR-330 and the annotation based approach on purpose.
When I was looking into different DI frameworks for my last project I looked at Kodein but I felt like it was very intrusive at the class level. When you need to inject something you end up having to either pass around some kodein specific object, make your class implement a Kodein interface, or some combination of the two. With Dagger 2 you just annotate the constructor. There are things about Kodein that are easier but that was the main issue I had.
Oh, your comments actually made a couple of things clearer for me. Thank you. Kodein seems to take a very different approach to DI. I may toy with further to see where it goes.
The whole point is that it doesn't. Dagger 2 is arguably the best JSR 330 implementation you can find. It does everything at compile time and is performant, safe, well documented, and well supported. Its only flaw is that JSR 330 involves a ton of boilerplate. Kodein is designed to feel like using Kotlin, not to feel like using a JSR 330 library.
Used it in an Android project. It's approach is totally different from Dagger or Guice but once you wrap head around it, you will like it. It's still immature, missing alot of features but I am sure with time those holes will be filled. 
Cool, thank you for sharing. I'll try to stop looking at it with my "dagger2" eyes.
That is not dependency *injection*, but a service locator! From my point of view it would be better to create a *real* ™ DI framework and keep the application classes independent from a certain DI framework. `@Inject` is ok, although there are example of DI frameworks without annotations (like Structure Map in the .NET world).
Kodein doesn't follow JSR 330 because it doesn't perform dependency injection. A DI framework without annotations could be nice, but it should just analyse the constructor and should not force to make domain classes dependent on such technical infrastructure.
Kodein DOES perform dependency injection. Not sure where you got the impression from that it doesn't. Usually I create a function for every Kotlin-Module that defines how to create different objects and what dependencies it has without the domain classes knowing where their constructor arguments are coming from. So your domain classes do not need to know about the DI framework in use (Talking about Kotlin projects, sadly in Android it doesn't work that way)
JSR-330 is five annotations and the Provider interface. Any boilerplate comes from the implementation itself.
Hi there, Kodein author here, so of course, I'm biased ;) There are many ways to use Kodein. You can pass a Kodein object around, use the Kodein interfaces (which, in effect, ask you to access a Kodein instance), or use Kodein.global to have one global source of truth. When you use Dagger 2, you just annotate the constructor, but then, to construct the class, you need to use the component interface. So, in your app, instead of passing/accessing a Kodein object, you still need to pass/access a Dagger 2 components interface, which you can register as a global, or pass around. I created Kodein because I wanted a DI library that was more semantic (bind this with that) and more idomatic (Kotlin-esque) ;) Of course, Dagger 2 is a very valid choice ;)
Hi there, Kodein author here, so of course, I'm biased ;) First, Kodein does support JSR-330. Have a look at the kodein-jxinject module, described in the "JSR-330: Using reflexivity to auto-inject" part of the documentation. Please note that I DO NOT RECOMMEND using this for any other purpose than transitionning from a JSR-330 based DI framework to Kodein. Which leads me to the second part: I strongly disagree that a DI lib that does not support JSR-330 fails. JSR-330 exists because Java lacks a lot of features of a modern language. JSR-330 anotations are, in effect, the only way to easily declare, in Java, that a property or method argument should be retrieved in a DI container. Luckilly, Kotlin brings a lot of features that makes both declaration (infix methods, inline lambdas) and retrieval (property delegation, inferred reified) a lot more semantic and idomatic. JSR-330 is the "relic of a distant past" when using Kotlin. In fact, most of annotation based standards are, since Kotlin allows for much more elegant designs.
Technically not correct. Kodein is a Dependency Retrieval container (true, not Injection: Retrieval). The main differences with a Service Locator are the binding scopes (singleton, multiton, provider, etc.) and the fact that it is immutable once constructed (which allows for a lot of caching).
Are you talking about an Android project or a pure Kotlin one? If its the latter and you solely rely on constructor injection, there is no need for the domain classes to know anything about Kodein at all.
Not entirely true. If you use Kodein only for constructor arguments, then it is a DI framework.
I should have qualified my statement a little better. It was an Android project and the module that allows for constructor injection uses reflection so that was off the table. Thanks for pointing that out.
Hey! I love Kodein so so much! Thank you for creating it ☺️
I'm not the author :) Pinging /u/timelzayus , the author!
Okay, but are there any implementations that are free of boilerplate? It'd be very difficult to impossible to make a DI library that conforms to JSR-330 and doesn't have a ton of boilerplate IMO.
If you find Kodein to be missing features you need, please file a ticket Github or ping me in Kotlin's Slack. I'll be happy to improve the lib based on your feedback ;)
Thanks a lot ;) That's always a joy to hear :D
Ok, I understand you. Thx for you response! I realy like Kotlin but don't ready to change JSR idioms yet.. May be I don't feel it) 
Hello! ... I'm making [Javalin](https://javalin.io/), inspired by express.js and koa.js: Add dependency: compile 'io.javalin:javalin:0.4.1' Start programming: import io.javalin.Javalin fun main(args: Array&lt;String&gt;) { val app = Javalin.start(7000) app.get("/") { ctx -&gt; ctx.result("Hello World") } } Additional tutorials: https://javalin.io/tutorials/ 
Yes! This is awesome. Do you support middleware (JS equivalent: http://expressjs.com/en/guide/using-middleware.html)? 
Not exactly the same as express's middleware, but I do support [before](https://javalin.io/documentation#before-handlers) and [after](https://javalin.io/documentation#after-handlers) handlers. (filters) app.before { ... } app.before { ... } app.get("/") { ... } app.after { ... } The handlers are executed in the order they are declared, and you can call `ctx.next()` in order to stop execution and pass control to the next handler.
If you want good middleware support, then ktor is really good. What problems did you have with "Hello world"? 
&lt;shameless self promotion warning&gt; If you're looking for something super simple that's proven in production, you could do worse than http://http4k.org It's a version of the **"Server as a Function"** concept written in pure Kotlin - absolutely no magic annotations or reflection. Basically an http4k app is made up of simple functions that allow you to serve and consume HTTP services. It's got middleware (Filters), nestable routing, typesafe parameter/body marshalling and spins up on Jetty, Undertow, Netty and SunHttp in 1LOC. Here's hello world running in Jetty: { request: Request -&gt; Response(OK).body("Hello World") }.asServer(Jetty(8000)).start() Oh, and it's *really* lightweight - there are zero dependencies for the core module (apart from Kotlin stdlib). If you want to get going quickly, take a look at http://start.http4k.org - you can create an entire CD-pipeline to Github/Travis/Heroku with one command. If anything is confusing from the docs, please let us know (@http4k on Gitter/KotlinSlack) and we'll fix it ASAP - one of things that's hardest about docs is writing them for people who don't have context. :) &lt;/shameless self promotion warning&gt; 
I couldn't get it to run, I'm a bit new to Kotlin.
Any trouble getting Javalin up and running? Would appreciate any feedback to improve the docs!
Solved .equalsIgnoreCase(String)
Kotlin Native still in preview, no beta or alpha releases exists. So, forget about compiling kotlin to IOS. If you really need to use Kotlin/Java, try Multi OS Engine, from Intel. Never used it, never needed it, perhaps someone else can share their experience on this. https://software.intel.com/en-us/multi-os-engine If you are just starting and really need to build an app for both platforms, take a look at Xamarin or Ionic.
I'd say to avoid ionic and use react native instead. But then again I'm not a fan of cross platform development at all.
MaterialDrawerKt is a Kotlin DSL wrapper around the [MaterialDrawer](https://github.com/mikepenz/MaterialDrawer) library. It had its first non-trivial update since its launch today, which includes a DSL for initializing the base library's image loading facilities. It's also coming up on 100 stars on GitHub. Any feedback is appreciated. 
The Maven part was effortless ❤️. The only thing I couldn't figure out is how to run the server with Gradle.
Thank you for help, Xamarin seems great but I never used C#... Maybe someone has experience with Intel Multi OS Engine?
There's also [this](https://www.codenameone.com/). Disclaimer: never used it. 
Forget about it. If you're serious to release something, then use React Native/Xamarin or even Flutter. 
I use Clean Architecture, Kotlin for Android &amp; Swift for iOS,then you can pretty much share code for the logic and only implement the UI natively 
You could build DSLs to some degree with operator overloading, which is the approach some C++ libraries like [Spirit](http://www.boost.org/doc/libs/1_65_0/libs/spirit/doc/html/index.html) take. However, what you get in C# is usually a [Fluent Interface](https://en.wikipedia.org/wiki/Fluent_interface), such as [NSubstitute](http://nsubstitute.github.io/). What makes Kotlin especially good for DSLs is: 1. Concise lambdas that are just block syntax (`{it*2}`) 2. Possibility of parenthesis elision (`foo { ... }` instead of `foo({ ... })`) 3. Type-derived context (methods of `T` being in scope when the receiver is of type `T`) All of these combine in order to have a contained DSL (methods of a class) with pleasant syntax, and C# has none of them, at least for this purpose (C# arguably does have type-derived context elsewhere). For example, in Kotlin, you have an `Html` class with `p` and `div` methods, as well as an `html` function `fun html(Html.() -&gt; Unit): Html`. What you get is the following call syntax: html { p { ... } div { ... } } You call `html` without parentheses because the lambda is the last argument. Lambdas are simply block syntax, so it looks like you're opening up an `html` scope. Finally, `p` and `div` are in scope because the receiver is an `Html` object. All of these throw a wrench into C# having something similar.
**Fluent interface** In software engineering, a fluent interface (as first coined by Eric Evans and Martin Fowler) is a method for constructing object oriented APIs, where the readability of the source code is close to that of ordinary written prose. A fluent interface is normally implemented by using method cascading (concretely method chaining) to relay the instruction context of a subsequent call (but a fluent interface entails more than just method chaining ). Generally, the context is defined through the return value of a called method self-referential, where the new context is equivalent to the last context terminated through the return of a void context. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Kotlin/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.26
Thanks. That's a comprehensive answer. What could be done with LINQ stuff thought?
LINQ is more an implementation of a fluent interface than anything. You could certainly express HTML code and other APIs like that, and that's exactly what [this HTML library](https://github.com/amoerie/HtmlBuilders) appears to have done: var fluent = new HtmlTag("div").Class("control-group") .Append(new HtmlTag("div").Class("controls") .Append(new HtmlTag("label").Class("checkbox") .Append(new HtmlTag("input").Type("checkbox")) .Append(" Remember me"))) .Append(new HtmlTag("button").Type("submit").Class("btn").Append("Sign in"));
Thanks. Not the answer I would like but I appreciate the truth.
If you have some web experience you can use Cordova with your favorite framework, like Vue or Angular 2+, and then use the KotlinJS compiler. I'm actually working on a cross platform app that uses Cordova, Angular 2+, Kotlin, and OnsenUI. I have the alpha on my phone right now and everything looks great and is very responsive. Can't tell the difference between it and a native app.
I would really reccomend considering using C# and xamarin. I think it's pretty cool and will run on all 3 platforms. You can write your Views in Xamarin Froms or native. C# is pretty great, I really recommend giving it a shot. Full disclosure: I work at MSFT, but not on those teams, just a personal opinion
To quote the article &gt; It is not a fully functional release yet And even when it's done you wont be able to just transpile it. You will be able to share simple kotlin data classes but you'll have to build a separate ui for iOS. You should just build a separate iOS app in Swift. [It's **really** similiar to Kotlin.](http://nilhcem.com/swift-is-like-kotlin/)
You only need to use the component at (or near) the entry points. Everything beneath that can use normal JSR 330 injection and know nothing about the container which is instantiating it.
Have you tried React Native?
From what I understand, is that Fluter uses html and styles the html to be like the native Android/iOS components, but it isn't really. That's different from React Native and Xamarin. Though in Flutter you can create your views once, instead of twice/more. It seems in the same ballpark as Ionic.
Flutter has its own graphics engine built on top of Skia, and does its own rendering. Nothing to do with HTML.
Honestly I'd rather stay with the basic theme. I don't like custom CSS for the sake of it (like Naut etc.).
If it ain't broken, don't fix it.
Thanks. I had thought about something along those lines, but I did not try to code it at the time. I have coded it now, but I needed a more complex interface and it seems I get quite a large indirection cost. I tried to inline as much as possible. I did not fiddle with it much, so maybe it's possible I could get the compiler to remove the indirection. I made a [gist](https://gist.github.com/max333/01dc267dd62f713c152f1f16ffc6e2f6) if anyone is interested; look for the parts about a "common interface".
Must be a habbit from using linux. EDIT: Yeah was grammar wrong
How does this comment make any sense at all? 
Must be a Hobbit.
For reals.
Kotlin just tidies up the syntax. The equivalent c# would be something like: Html.build(it =&gt; { it.p(it =&gt; { ... }); it.div(it =&gt; { ... }); }); The other interesting C# feature is that Html.build could be declared to take an Expr instead of Func, allowing for some metaprogramming on the AST that I haven't seen in Kotlin. 
Yes, both of those points are true. While fluent APIs are reasonably common in C#, they're not the closest approximation to Kotlin APIs, which is one reason I like looking through Kotlin libraries to see what people come up with. Expression trees are also interesting (especially to me after C++ expression templates), though rarely used outside of LINQ, with the only common case I've seen being `it =&gt; it.Foo` for the callee to be able to access the name "Foo" before `nameof` became a thing.
A little clarification (author here): Sequency is a JavaScript library for the browser and Node, written in TypeScript. The API is similar to Kotlins Sequences. I've built Sequency because I'm a big Kotlin fan and use Kotlin on the server but for some reasons still use TypeScript and JavaScript for client-side browser code. I find that using the same APIs for collection processing is a huge gain in productivity for me. Maybe this is also useful for someone else. Some methods from Kotlin Sequences are not available yet. On the other hand a few completely new methods are available which I needed in my code (e.g. chunk and reverse). You find the full API doc here: https://winterbe.github.io/sequency/ Let me know what you think. If you like the project please consider to [give a star on GitHub](https://github.com/winterbe/sequency/stargazers)! Thanks.
Did you try the getting started guide for Ktor? http://ktor.io/getting-started.html What didn't work for you? Are you using IntelliJ IDEA or something else?
I recently finished writing a tutorial on using the [AccessManager](https://javalin.io/documentation#access-manager) interface in Javalin. I haven't seen auth solved this way in any other library/framework, so it would be great to get some feedback (both on the tutorial, and the concept of `AccessManager` itself).
Thank you for the tutorial. It was well-written and good to understand, even for someone who hasn't tried javalin. In fact, you got me interested in your framework.
Thanks, I'm happy you liked it!
You might want to take a look at [Kweb](http://kweb.io/), it takes a fairly unique approach, effectively erasing the barrier between browser and server, letting you manipulate the DOM in the browser from server code. It's built on top of Ktor, but you don't need to understand Ktor to use it. (disclaimer: It's my project, it's also currently at an experimental stage of development)
&gt; Html.build could be declared to take an Expr instead of Func, allowing for some metaprogramming on the AST that I haven't seen in Kotlin. Could you please elaborate?
In C# a Lambda can be compiled to a Func as in: Func&lt;int, int&gt; myFunc = x =&gt; x + 1; Or it can be compiled to an Expression tree as in: Expression&lt;Func&lt;int, int&gt;&gt; myExpr = x =&gt; x + 1; This provides a limited form of macros that allow you to transform the literal lambda syntax into some other code, eg as used by linq to generate SQL queries from lambda expressions. https://weblogs.asp.net/dixin/functional-csharp-function-as-data-and-expression-tree 
Javalin looks very nice! From the docs it feels more approachable than Spring WebFlux which is also heading in the functional direction.
Looking good - was actually thinking of writing up a simple Javalin example project for the new release of HalBuilder - might adapt some of this to show role-based hyper-media actually!
Thanks! While Javalin is a lot more approachable than anything Spring-related, keep in mind that it's very small. It's like comparing apples and apple-orchards.
Cool. Let me know if you need any help and/or source-code changes.
Here ara my two cents: - Use `?let/also/etc` instead of the null checks. The whole point of using Kotlin is to get rid of java's problems - `UserController` should be an interface to enable easy testability - please don't display a like popup every time I visit the site Otherwise the stuff looks good but it does not seem revolutionary, so I don't see why I should dump Spring5 for javalin yet. What does javalin do/do better than spring 5?
You can't kill something which is already dead.
Choice would depend on requirements and specifications. One is not inherently better than the other.
A lot of good open source projects are built in Scala. Just take Kafka, Spark, Play...
Sounds like Games of thrones citation :)
Oh, definitely true! What I meant was that I personally dislike working with cross platform technologies. If you're good at react / Xamarin / &lt;insert cross platform technology here&gt;, the produced apps are totally fine and it's definitely a valid business decision to go this route.
Sorry I don't get it. We do a lot of Scala in my company and we care a lot about money...
I personally still don't see the benefit of using Spek or KotinTest over something like Spock, especially if you have tests which can benefit from [data tables](http://spockframework.org/spock/docs/1.0/data_driven_testing.html).
Thanks for clarifying, we definitely agree!
&gt; Use ?let/also/etc instead of the null checks. The whole point of using Kotlin is to get rid of java's problems Where do you mean? I don't have any null-checks in this tutorial. &gt; UserController should be an interface to enable easy testability Good point, but I also left out error-handling, as I think it's outside of the scope of the tutorial. &gt; please don't display a like popup every time I visit the site Thanks, I was using sessionStorage instead of localStorage. If you dismiss it now, it should stay dismissed forever (in that browser). &gt; Otherwise the stuff looks good but it does not seem revolutionary, so I don't see why I should dump Spring5 for javalin yet. &gt; What does javalin do/do better than spring 5? If you know Spring and you like Spring, there is really no reason for you to switch. If you don't know Spring, I think learning Javalin will be a lot easier (which makes it easy to onboard new people to a project).
One of the big benefits of DI is ease of testing, but testing is only mentioned a couple times in passing in the Kodein docs. What are the idiomatic ways to do unit tests with Kodein?
really cool, did you follow a guide at all? 
South Park, actually.
I mean using this operator: `!!` is an antipattern IMHO. You should use `?.let()` instead so no NPE will be thrown. I also write my Kotlin programs in a way that there is **no** possibility for `null`s to appear (I don't use the `?` in types for example. This way you can completely get rid of `null` problems. Fair enough, `UserController` is fine for this example but if someone comes from a java background he will be puzzled why it is an `object` in your example. Thanks! It is not about me not wanting to star your lib, but the annoying popup. Good point! I did not think about it this way. I'm sure that Javalin is easier to use compared to Spring!
Submit a PR! Looks like you've done the hard part
[removed]
I don't really see the need of the second parameter - new Output steam will overwrite the file anyways. Well, the creation date will be different, but otherwise it's okay to simply keep the file record as is. I think, it's even better: - file descriptor is reused - existing disk space can be reused If the new file has roughly the same size, the operation will take no time!
http://gameofthrones.wikia.com/wiki/What_Is_Dead_May_Never_Die
[removed]
I had to refresh my math skills in order to implement rotation http://mathworld.wolfram.com/RotationMatrix.html
If you would like to use Kotlin for cross platform app development, you should use libGDX at the moment. r/libgdx
Great catch! Make sure JetBrains knows about this (maybe a PR [here](https://github.com/JetBrains/kotlin))?
This is nice DSL to create units and combine units, but... ## The operator '==' does not always work reliably for quantities; ## the function qeq() should be used instead. 1.kilo.gram == 1000.gram &gt;&gt; false I don't like this part. I can't see any use case where 1 kilogram not being equal to 1000 gram will make sence. Also, looks like this library lacks unit comparators, which makes it not that useful. Being able to write something like `10.km/1.h &gt; 5.m/1.s` would be nice.
I actually said "wow" out loud when reading this. That's really impressive. It's a pity that `qeq` is required instead of ==, that's a bit ugly. For comparison here's a demonstration of the Java implementation: https://unitsofmeasurement.gitbooks.io/unit-ri-userguide/content/quantities.html
&gt; I don't like this part. I can't see any use case where 1 kilogram not being equal to 1000 gram will make sence If you override equals, you have to satisfy the symmetry contract, or your implementation is flawed (regardless of if you like it this way or need the implementation). That means you need to ensure x.equals(y) == y.equals(x) . If you override equals in the class of x (equals takes type Object), then you have to check getClass() for both of them to be equal. There are some other strategies, but it is hard to implement value equality for different types. The problem is with non-final classes, as the equals implementation is inherited in subclasses and therefore is not correct.... and this has to work for transitive relationships as well. that's the reason why one usually implements equals with checking classes to be equal.
I don't understand. This says that coroutines are non-blocking, but what happens in your program when you call coroutine.await()? Surely it blocks? I must be missing something because to me the "Going Deeper" example looks roughly the same as using Futures in Java.
Have a look at this very detailed description: https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md#non-blocking-sleep The important thing is, that `await` "supends" the coroutine, but DOES NOT block the executing thread, which is the big difference. For example, have a look at the description of a "non-blocking sleep":https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md#non-blocking-sleep
I agree that it's hard to implement equality for different classes, especially if they are open. However, this can be easily solved if kilogram and gram units are represented with single class, and all those kilo-, milli- etc. prefixes are just a view: println(Distance(999)) // prints "999 m" println(Distance(1000)) // prints "1 km" 
Everything made with Physikal DSL is of type ComparableQuantity which implements Comparable and so can use comparators. There should be an example in the readme though probably.
If you know nodejs - it's similar to that. await() "blocks" the code that's running, but not the thread. If there's another coroutine that's able to run, the thread will switch over to that coroutine. The gist is that switching from a "blocked" coroutine to another coroutine is much faster and more resource efficient that switching from a blocked thread to another thread.
This seems duplicative of [kotlin ranges](https://kotlinlang.org/docs/reference/ranges.html), in fact, I think it leads to less readable code.
Can you explain how ranges solve either of the problems solved by these two functions? I can see how my examples might remind you of ranges but these functions do something much more interesting than that. I think.
You can use `step` and `slice`. And for non-inclusive ranges you can use `until` instead of `..`. So your example would look like: val list = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) println(list[5]) println(list.slice(2 until 5).joinToString()) println(list.slice(2 until 10 step 2).joinToString()) I'm not sure if you could replicate the second part (with the `MutableList` and `set`), but it doesn't make much sense to me and I'm not sure I see the value EDIT: I see `slice` is only available on `List`. If you want a more general solution I think /u/gladed 's is simple and makes sense
`list[2, 10, 2]` seems like an abuse of the set/get operators. But how about: operator fun &lt;T: Any&gt; Iterable&lt;T&gt;.get(range: IntProgression) = asSequence().run { range.mapNotNull { index -&gt; elementAtOrNull(index) } } operator fun &lt;T: Any&gt; MutableList&lt;T&gt;.set(range: ClosedRange&lt;Int&gt;, from: Iterable&lt;T&gt;) { for (i in range.start..minOf(range.endInclusive, size - 1)) removeAt(range.start) addAll(range.start, from.toList()) } @Test fun slice() { val list = mutableListOf(5, 6, 7, 8, 9, 10) assertEquals(listOf(7, 8, 9), list[2..4]) assertEquals(listOf(10, 8), list[5 downTo 2 step 2]) list[2..4] = listOf(77) assertEquals(listOf(5, 6, 77, 10), list) list[0..10] = listOf(1, 2, 3) assertEquals(listOf(1, 2, 3), list) } (Behavior for negative indicies is undefined.) 
It's probably better to just do `.toList().slice(...)` I had to try and see if I could cram it into the `get`/`set` operators just for fun though. EDIT: clarity
Oh, I think I like this a lot! I wasn't happy about the "abuse" of get/set either.
Seems like everyone has their own micro web framework these days.
Passing a lambda expression to the super class constructor is not *that* idiomatic. class App: Kooby({ get { "Hello World!" } }) Idiomatic would be to use an `init` block.
Micro frameworks are fun to make. Jooby has almost [one hundred modules]( https://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.jooby%22) though, so I don't really think it's a micro-framework anymore.
Reddit will disable subreddit a custom styles soon so it is not worth the effort.
Both are supported (of course). Lambda expression was requested by a user and I like it more than the init block.
Except you?
It is a modular micro-framework :)
I learned a lot from [this](https://www.reddit.com/r/Kotlin/comments/6thpkg/todomvc_kotlin_implementation/) post. OP is using JS for frontend and Spring backend (both in Kotlin).
Thaaaaaaaaat's it! "Constructive criticism". That's why you're at Google, sir. That's why.
I'm not sure I understood your comment.
I mean that specifying "constructive" is a clever thing.
It really isn't "clever", it's an extremely common expression.
https://github.com/AppCraft-Projects/todomvc-kotlin/blob/master/settings.gradle#L2 I didn't know Gradle could do that!
Thanks! I'm replying pretty late but I was mostly having issues figuring out how the magic worked when I needed to change something. Like what the main class is or where the source code lives. I've since discovered that kobalt seems to bit a bit saner, at least at first, so that's what I've been using!
Yep, it was just missing a few things, like a bunch of imports in the example and the "main" class in the build file. Stuff that experienced kotlin/java people would have no trouble with, but was tough as a beginner.
I think it was added around 2.5 maybe? You can read about it [here](https://docs.gradle.org/current/userguide/multi_project_builds.html)!
I think this term is used rather commonly and I don't think it has anything to do with Google. Did I miss something? (apart from the "Google memo" scandal)
The "server as a function" bit is sweet. I've been looking around at other devs talking about various languages and tricks and one thing I've been seeing is the notion of just being able to test a fast HTTP request without setting up a big web server. I'm new to kotlin but it's giving me some good understanding of the language, seeing how this particular lib handles the design of serverless HTTP. Combining stuff like this with ngrok really gives me a lot of options.
And what if you would need some more methods called by the http handlers (`get` etc)? Passing a lambda expression to the super class constructor is a superficial syntax trick with little benefit and some serious drawbacks.
Use the `init` block: class App: Kooby { init { get { "Hello World!" } } } Otherwise go with the lambda expression and it is more common than you think. For example the [spek framework](http://spekframework.org/) does the same thing. It is limited as you point out, but depends on how you write your application.
I'm currently working on a Annotation Processor based approach of generating serializers and deserializers. So far I have: * Primitive types * Enums * Nullable fields * Some collection types * Static nesting of serializable types (where only one type is applicable) * Dynamic nesting of serializable types (e.g., an interface where the implementations are serializable) * Fields of generic types As I'm not writing into the annotated class, I am using an external *Module* class to handle locating the proper serializers. To carry type information, I made a new data class that also holds type arguments, the usage of that class is usually not seen when using the framework. Having a module class (or object) also allows to register services (as in `java.lang.ServiceLoader`), which makes locating serializers for types of other libraries easier. I'm including one of generated serializers, as they are not uploaded into the repository. https://gist.github.com/lukashaertel/9f7fe51283c8aa9494337cb20449d423 I am still figuring out if annotation based processing is the best approach. The upside is that it's not too complicated to write and easily integrated in different versions of Kotlin; plus, having the service loader approach is that I do not have direct references to generated code files. That way, it is possible to compile without cleaning the project first. The project can be found here: https://github.com/lukashaertel/kfunnels `:proc` contains the annotation processor and the API, `:test` contains the examples. The API and the processor are also bundles as a JAR in the releases tab. Please feel free to check it out and comment.
I found this example (https://hashnode.com/post/how-i-built-my-first-kotlin-vertx-hibernate-stack-cixhsnv1b002au6539uu6iw7r) from Jan Vladimir Mostert which may be useful
I am not entirely sure what has been achieved here, and it seems very not type safe. I also don't know how you are getting away with that cast to `Class&lt;Placeholder&gt;` I would expect an exception there. Why not something like this, fun &lt;T : Enum&lt;T&gt;&gt; read(type: KClass&lt;T&gt;): T { return java.lang.Enum.valueOf(type.java, "HELLO") } You may have to cast the `KClass` that you get out of `Type` (I am not sure which `Type` that is), but that makes sense to me. Right now the cast is shoved to the end after trying to create an `Enum` from some (possibly) random type.
The problem is that I have a class without a `T`, if I'd use the signature that you suggest, I could not put a `KClass&lt;*&gt;` in there. There's IIRC no way to cast it to a `Class&lt;T extends Enum&lt;T&gt;&gt;`. If I'd cast it to `Class&lt;Enum&lt;?&gt;&gt;` it would not meet the the required signature of `valueOf`. For the Placeholder part: since generics are erased at runtime, the given generic argument has no effect. If I would cast a `List&lt;Integer&gt;` to a `List&lt;String&gt;` and then invoke `get(0)` or something, an actual cast would be executed, that is where the errors come from if you do unchecked casts. The Placeholder is just to make the static analysis happy, the runtime part works because the actual class object is of the matching type.
This PDF file explains everything you need to know: http://kotlinlang.org/docs/kotlin-docs.pdf
Do these: https://try.kotlinlang.org/#/Kotlin%20Koans
Holly Shit. Everytime i think after several years of usage i understood everything about a feature i am using, someone surprises me. I have no idea what the Problem with generics is here :)
I would recommend using an IDE that inspects your Kotlin code such that it provides suggestions on how you could improve your code or use some more efficient structures. This is great to do if you want to actually practice using Kotlin and have the IDE hand hold you beyond the usual error checking. I think Intellij IDEA would be a great IDE for that sort of thing.
《Kotlin 极简教程 》Kotlin minimalist tutorial 中文图书，附精华视频教程 1. IDEA 创建 Kotlin Gradle 工程 ：快速开始 Hello World http://www.jianshu.com/p/1f97c3165b8a 2. forEachIndexed 带下标遍历 List http://www.jianshu.com/p/61f3fb6c97d5 3. 简单优雅的高阶函数：一个函数组合的例子 http://www.jianshu.com/p/61db795324bd 4. 使用Kotlin 创建 DSL 5. 扩展函数、扩展属性 6. 可空类型与空指针安全 7. Kotlin 的类型系统 8. Lambda 编程 9. 集合类与泛型 10. 文件 IO 操作与正则表达式 11. 协程与多线程 12. Kotlin Native 入门 Kotlin简介：http://www.jianshu.com/p/9d0821aa7e83 Kotlin 中文学习资料集锦： 1. 云端 IDE 在线学习 https://try.kotlinlang.org/#/Examples/Hello,%20world!/Simplest%20version/Simplest%20version.kt 2.官网（必看） https://kotlinlang.org/ 官网 https://blog.jetbrains.com/kotlin/ 官方博客 https://github.com/JetBrains/kotlin Kotlin源码 3. 中文社区 https://kotliner.cn/ 4. 书籍 https://kotlinlang.org/docs/books.html 《Kotlin In Action》 《Kotlin for Android Developers》 《Kotlin Programming》 上面几本都是老外写的书。 国内首本关于 Kotlin 的中文书籍是 《Kotlin 极简教程》（阿里的工程师出的书，推荐阅读）
《Kotlin 极简教程 》Kotlin minimalist tutorial 中文图书，附精华视频教程 1. IDEA 创建 Kotlin Gradle 工程 ：快速开始 Hello World http://www.jianshu.com/p/1f97c3165b8a 2. forEachIndexed 带下标遍历 List http://www.jianshu.com/p/61f3fb6c97d5 3. 简单优雅的高阶函数：一个函数组合的例子 http://www.jianshu.com/p/61db795324bd 4. 使用Kotlin 创建 DSL 5. 扩展函数、扩展属性 6. 可空类型与空指针安全 7. Kotlin 的类型系统 8. Lambda 编程 9. 集合类与泛型 10. 文件 IO 操作与正则表达式 11. 协程与多线程 12. Kotlin Native 入门 Kotlin简介：http://www.jianshu.com/p/9d0821aa7e83 Kotlin 中文学习资料集锦： 1. 云端 IDE 在线学习 https://try.kotlinlang.org/#/Examples/Hello,%20world!/Simplest%20version/Simplest%20version.kt 2.官网（必看） https://kotlinlang.org/ 官网 https://blog.jetbrains.com/kotlin/ 官方博客 https://github.com/JetBrains/kotlin Kotlin源码 3. 中文社区 https://kotliner.cn/ 4. 书籍 https://kotlinlang.org/docs/books.html 《Kotlin In Action》 《Kotlin for Android Developers》 《Kotlin Programming》 上面几本都是老外写的书。 国内首本关于 Kotlin 的中文书籍是 《Kotlin 极简教程》（阿里的工程师出的书，推荐阅读）
《Kotlin 极简教程 》Kotlin minimalist tutorial 中文图书，附精华视频教程 1. IDEA 创建 Kotlin Gradle 工程 ：快速开始 Hello World http://www.jianshu.com/p/1f97c3165b8a 2. forEachIndexed 带下标遍历 List http://www.jianshu.com/p/61f3fb6c97d5 3. 简单优雅的高阶函数：一个函数组合的例子 http://www.jianshu.com/p/61db795324bd 4. 使用Kotlin 创建 DSL 5. 扩展函数、扩展属性 6. 可空类型与空指针安全 7. Kotlin 的类型系统 8. Lambda 编程 9. 集合类与泛型 10. 文件 IO 操作与正则表达式 11. 协程与多线程 12. Kotlin Native 入门 Kotlin简介：http://www.jianshu.com/p/9d0821aa7e83 Kotlin 中文学习资料集锦： 1. 云端 IDE 在线学习 https://try.kotlinlang.org/#/Examples/Hello,%20world!/Simplest%20version/Simplest%20version.kt 2.官网（必看） https://kotlinlang.org/ 官网 https://blog.jetbrains.com/kotlin/ 官方博客 https://github.com/JetBrains/kotlin Kotlin源码 3. 中文社区 https://kotliner.cn/ 4. 书籍 https://kotlinlang.org/docs/books.html 《Kotlin In Action》 《Kotlin for Android Developers》 《Kotlin Programming》 上面几本都是老外写的书。 国内首本关于 Kotlin 的中文书籍是 《Kotlin 极简教程》（阿里的工程师出的书，推荐阅读）
The doc is really awesome, it helps getting started fast. Thank you for this alternative.
Ah right, I see. So something like this then? public static &lt;E extends Enum&lt;E&gt;&gt; E valueOf(final KClass&lt;?&gt; in, final String value) { return Enum.valueOf((Class&lt;E&gt;) (Class) JvmClassMappingKt.getJavaClass(in), value); }
Hey, just a couple things. This is primarily an English subreddit, if you want to post content for a local community, you should try the appropriate channels on the Kotlin Slack. You should also consider posting videos as a playlist instead of one by one, as well as this is usually a low traffic sub.
You can read the introduction to kotlin on the website and should basically be able to jump into writing code from there. Use IJs convert to kotlin feature to get familiar with the syntax, the standard library is so similar that the rest should be easy for a java developer.
This would still require me to know `E` at compile time in Kotlin. I do not have that `E`, if I did, I would not need that function.
Yes, Intellij really seems to have gotten a head start on everybody when it comes to Kotlin. I wonder how :)
You should just work through the [Kotlin docs](http://kotlinlang.org/docs/reference/), they explain the differences with Java nicely. As a Java dev you'll be writing Kotlin almost immediately and fairly comfortable in a few hours. Give yourself a small project (I created a complex numbers lib).
+1. I read pretty much all of those docs and they explain absolutely everything you need to know to get going!
Is it just me or is kotlins async/await too complicated? You need to keep track of all the builders/pools. In C# or JS you just use the await and async keywords.
When people say non-blocking they mean it doesn't block the thread on a system level. It does block the coroutine, obviously.
https://github.com/kotlin-graphics/ Enjoy!
I've been working on a project for the last few months that might interest you. It's called [Kweb](http://kweb.io/). It's fairly unique because it breaks down the barrier between browser and server, from the programmer's perspective. Here are the key features: * Build websites in Kotlin * Makes the barrier between web-browser and web-server largely invisible to the programmer * Seamlessly integrates with powerful JavaScript libraries like JQuery, Semantic-UI, and others * Update your web browser instantly in response to code changes * Bind DOM elements in the browser directly to persistent state on the server and have them update automatically, through the observer and data mapper patterns, and following the single source of truth principle) * Easy to add to an existing project, Kweb is just a library, it doesn’t seek to tell you how your project should be organized Two caveats: * This is my project, so I'm biased ;) * It is not yet production-ready On the positive side, I'm very open to help from anyone :) [Check it out](http://kweb.io/)
I just assign them defaults. Generating your own ids has other advantages too and the version always starts out as 0 as well: @Entity data class Entity( @Id val id: String = UUID.randomUUID().toString(), @Version val version: Long = 0, val field: String ) You can of course instantiate them like so then: val entity = Entity(field = "some content") Doing it like this will require the no-arg compiler plugin to generate zero argument constructors for the JPA, but it gives you really nice, clean and idiomatic Kotlin code. If you really don't want to do something like that, I'd recommend making them nullable. Mainly because they effectively actually are. When you write a function that accepts an Entity, you don't know if it was already persisted or not, so the fields could still be unassigned.
[removed]
But what if you want to use a database function to generate the UUID? For eg, postgresql has uuid_generate_v1mc() which gives better clustering performance as it returns time based and hence sequential keys. I don't know if Java has anything similar but if I want to use the postgresql function do I have any better choice than making it nullable?
Well typically I don't need sequential keys and random is the most secure. If you do need something like that, I'd make the fields nullable like I said above since there will be times in your program where you can't be sure if they've been persisted before or not. So in my opinion there wouldn't be a better choice in that situation. You could probably write an extension property that throws an exception if that field is unassigned to reduce null handling in your code: val Entity.seqId: String = id ?: throw SomeException()
You could do something similar with async/await.
I think that you can define some extensions: inline fun Activity.buildAlertDialog(block: AlertDialog.Builder.() -&gt; Unit) = AlertDialog.Builder(this).apply(block) fun AlertDialog.Builder.show(onButtonClickedListener: (dialog: AlertDialog, buttonId: Int) -&gt; Unit) { create().apply { setOnShowListener { listOf(AlertDialog.BUTTON_POSITIVE, AlertDialog.BUTTON_NEUTRAL, AlertDialog.BUTTON_NEGATIVE) .forEach { buttonId -&gt; getButton(buttonId)?.setOnClickListener { onButtonClickedListener(this, buttonId) } } } show() } } And then inside your activity: buildAlertDialog { setMessage("Test message.") setPositiveButton("OK", null) }.show { dialog, buttonId -&gt; if (buttonId == AlertDialog.BUTTON_POSITIVE) { TODO("OK button clicked.") } }
Should be possible with coroutines.
Whatever you do you need to handle activity recreation on rotation or process death. You can't keep a reference to the activity in the dialog.
Yeah, that's what async/await is based on.
Depends on your programming ability. The problem is that Kotlin tools are simple, but their documentation is crap. I'd recommend a Gradle+Spring Boot setup because Spring's documentation is superb. You basically have 9999999 pages of in-depth knowledge. Sorry to burst your bubble, but you can't realistically avoid Java, so you will end up learning bits and pieces of it if you decide to use Kotlin. The reward at the end is amazing though: I've worked with both Ruby and JS and you just can't beat the overall quality of java tools. Good luck.
In my opinion no Java/Kotlin Framework comes close to the Javascript world in building Web Applications. Backend services however are ridicolously easy in the Java/Kotlin world. So I for instance only do JS in frontend (like angularJS, VueJS etc.) and JavaEE in the backend. As Kotlin is 100% interop with Java, I can do JavaEE in Kotlin. JavaEE does caching, jobs, scheduling and calling outside APIs with ease. Not knowing Java language does not hurt, but not knowing the ecosystem does. The difference between Spring and JavaEE imho is: EE is standard and has conform app servers (jboss, payara etc.) which have the whole thing set up, and you just have to use the standards But you do have to find a host that has JavaEE servers (I do my hosting on openshift) Spring has the ability to do it on just a servlet container like tomcat which is more readily available But you have to mostly wire it by hand I have found. Both of these approaches are very well documented.
Martin obviously got his inspiration from [HP Lovecraft's The Nameless City](https://en.wikipedia.org/wiki/Nameless_City): &gt; That is not dead which can eternal lie, And with strange aeons, even death may die.
I've also been wondering why...
[Jooby](http://jooby.org) is a modular micro-framework, similar to sinatra and express. There are modules for all your requirements: - [AWS module](http://jooby.org/doc/aws) - [Cache modules](http://jooby.org/doc/caches/) - [CORS](http://jooby.org/doc/#misc-cors) - [Background jobs](http://jooby.org/doc/quartz/) - [Task scheduling](http://jooby.org/doc/executor/) 
Look into Spring Boot, Spring Web, and Spring MVC.
I wish this were longer.
hehe thats what she said *cries*
I believe the long version is titled `Kotlin in action`.
Which one is most likely to be the friendliest for somebody who has no experience with the java ecosystem.
Nice!. Authentication?
I don't mind learning Java I just don't know it now. Looks like a lot of people are saying spring although others have mentioned smaller frameworks too. I might give spring a go and see how I get along. 
That's interesting. I think being able to put it in a tomcat container would make it easier to deploy on AWS right? Can I run my app from a jar like I can with jruby apps? Is there a "how to JavaEE with kotlin for noobs" document someplace?
Yes via [pac4j](http://jooby.org/doc/pac4j)
Smaller frameworks are a Catch 22. If you start with them you'll bump into a serious problem eventually which will need you to dig deep (which you can't since you just started). If you start with Spring you'll have all the documentation to guide you so when you finally learn the reins you won't need the small framework anymore.
Good job, worth checking out. When will it be deployed on Maven Central?
Thanks for your feedback. A Maven artifact will be deployed in the next few days.
Nevermind all I had to do was change `code` to `code()`. Leaving this post up for posterity.
https://en.m.wikipedia.org/wiki/Rubber_duck_debugging
Non-Mobile link: https://en.wikipedia.org/wiki/Rubber_duck_debugging *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^108616
**Rubber duck debugging** In software engineering, rubber duck debugging or rubber ducking is a method of debugging code. The name is a reference to a story in the book The Pragmatic Programmer in which a programmer would carry around a rubber duck and debug their code by forcing themselves to explain it, line-by-line, to the duck. Many other terms exist for this technique, often involving different inanimate objects. Many programmers have had the experience of explaining a programming problem to someone else, possibly even to someone who knows nothing about programming, and then hitting upon the solution in the process of explaining the problem. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Kotlin/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
I do not know anything about AWS sorry I believe you can, but I have never done it. There should be "embedded" app servers (which are normally used for testing, so the main test suite spins up a ee server in memory for tests). Spring as its own "Spring Boot" which essentially starts a tomcat from a Main class. If you google JavaEE Kotlin there is a series on dzone. But I recommend to watch any Java EE tutorial, as Kotlin just has different syntax, and its the way the ecosystem with its standards interact with each other that defines JavaEE and not the Java Syntax. Especially since modern EE does everything with annotations, which are nearly identical in Kotlin.
Awesome! Kluent + JUnit 4 gets me most of Spock (readable mocking, stubbing and assertions), and I don't have to split test and main between Groovy and Kotlin. Nice to see that Android devs can get in on this.
Isn't using Thread.sleep in coroutines kind of against the point?
It is indeed against the point when waiting in cycle and just sleep() - check - sleep() - ... . In the article sleep() is used to emulate workload, i.e. amount of time spent computing something 
But he clearly expects the sleep to be interruptible, which is not the case for normal work.
My threaded routines regularly check if current thread was interrupted 
It is. What actually happens is that 3 threads on the threadpool get blocked instead of running coroutines. It's not more efficient than just using plain Java ExecutorService and `Future`'s. It's most likely also the reason why the author observes that cancellation does not work properly. To solve the issue the coroutine equivalent `delay(timeout)` should be used instead of `Thread.sleep()`. However the Rx implementation has a similar problem, it also blocks 2 threads. It should instead also use some timeout/scheduling behavior of Rx to fulfill the `Single`s later. So overall both examples show how these thing work together with traditional external blocking APIs, but don't go nonblocking/reactive all the way.
I've had a similar problem before... turns out that "soft" errors can actually be suppressed. Try something like: override fun read(module: Module, type: Type, source: SeqSource): Any { @Suppress("UPPER_BOUND_VIOLATED", "UNCHECKED_CAST") return java.lang.Enum.valueOf&lt;Any&gt;(type.kClass.java as Class&lt;Any&gt;, source.getString()) }
In Intellij, 1. type java code you want to learn 2. Make an empty kotlin file 3. Copy and paste java code to your kotlin file Then IDE will automatically convert java code to kotlin code 
I tried to add a comment on his webpage, but it's in some other language, so I'm not sure if it is moderated and will get posted later, or if it will never get posted. Here is what I had written: I'm not an expert in coroutines, but your code is quite wrong. Here is what I know is wrong: 1. Coroutines include `withTimeout`, so you don't have to do your complex logic for cancellation. See the [guide](https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#cancellation-and-timeouts). 2. Your code is not non-blocking. You use `Thread.sleep()` which coroutines know nothing about (it's not a `suspend` function), so it does block the thread. Coroutines have `delay()` as a `suspend` replacement to `Thread.sleep()`. 3. Your code is not cancellable. If you did use `delay()` it would be cancellable. Note that for a method that does real work, you have to make it cancellable yourself, which is unfortunately not trivial. See the [guide](https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#cancellation-and-timeouts). 
Whoever wrote this does not fully understand how to use Kotlin coroutines.
&gt; I assume because they're basically the same java classes. They literally **are** the Java classes. Kotlin having 100% Java interoperability means that it doesn't have to reimplement anything from the Java libraries. However, it often extends their functionality with extensions. Those are the types of things that are documented in the Kotlin documentation. Check the Java documentation for any functionality from Java.
https://github.com/Kotlin/kotlin-koans Tutorial as exercises inside your ide 
Backticks are terrible to type for me personally, not sure if it's because of my Swedish keyboard layout but I dread having to write them. Good to hear!
Maybe start with Spring Boot. It will lead you naturally into the others.
That's what everybody seems to be saying. I might go that route.
kotl.in/issue I noticed this today as well, doing the exact same thing you were doing!
JetBrains made Kotlin :)
Hello Paddy, Sorry I didn't see your message on RC. And for some reason I wasn't even watching rosettacode-kotlin github repo. I do watch it now, so may be the issue is the best place to discuss comments https://github.com/dkandalov/rosettacode-kotlin/issues/5. I agree that change comments could be better. Are there guidelines specific to RC or any reasonable comments like for version control is enough?
This depends on your definition of "main". Based on use in all projects or new projects? By companies or individuals? Etc.
Hi, I think the ruiles for RC would be satisfied if people add meaningful comments to check-ins. They don't have to be long, but descriptive is good. The only thing is that RC allows minor changes to be flagged as minor and they can be filtered from lists of what has [changed on RC](http://rosettacode.org/mw/index.php?title=Special:RecentChanges&amp;hidepatrolled=1). Maybe adding '-minor-' to the beginning of check-in messages for minor changes such as formatting or spelling checks in github could first be translated as-is to RC comments, and later maybe turned into proper RC minor changes on a longer timescale? I guess your use case wasn't thought of when RC started but the kotlin community finds it easier to use github. Cool :-) 
Impossible to say I'd say. A counter question; why do you want to know? :)
Sounds good to me. I'll add support for "minor" flag and mandatory comment.
😊
When you look at iOS and how Swift was supposed to replace Objective-C I would say Kotlin won't be doing it any time soon
My guess is for new projects it's already passed java
Never. Java is and will probably always be the de facto language simply for library support. A Java library works perfectly for an app written in Java or Kotlin. A Kotlin library requires that you import the Kotlin stdlib into a Java app, adding more bloat than what you actually needed from said library. Not to mention you'd then need to setup your entire Java project to support Kotlin. Sure, Proguard can strip that Kotlin bloat, but in a Java project, a Kotlin library that's not Kotlin-specific would be more troublesome than needed. Any dev that writes a library meant for both Java and Kotlin would best write it in Java.
Using a library built with Kotlin in a Java project requires zero extra setup compared to using a library written in Java. You don't need to "setup your entire Java project to support Kotlin". It's just a regular .jar file.
So you're saying in a pure Java project, if you want to import a Kotlin library, you just add `compile "library.package:library-name:library.version"` to your build.gradle, and that's it? No Tools-&gt;Kotlin-&gt;Configure Kotlin in Project necessary? No need to add the Kotlin stdlib to your project so it knows how to compile it? None of that?
Exactly. The Kotlin stdlib is a transitive dependency, so it will be pulled in automatically. "Configure Kotlin in project" is only necessary if your project contains Kotlin code.
But introducing Swift into your existing Obj-C codebase is non-trivial, and the interop story is not that pleasant. Introducing Kotlin is as much friction as introducing any other library via a Gradle dependency, and the interop story is basically perfect.
&gt; A Kotlin library requires that you import the Kotlin stdlib into a Java app This happens automatically without any user interaction so it's a non-issue. &gt; Proguard can strip that Kotlin bloat, but in a Java project, a Kotlin library that's not Kotlin-specific would be more troublesome than needed. The second half of this is a bit of a "[citation needed]", but there's an easy counterpoint: Flash back 5 years when the support library first came out. Absolutely nobody depended on it when writing a library. It was a large detractor. At some point there was enough usage that a tipping point was reached and it became okay to depend on it. Even then it was weird. Only in the last three years has it really become a no-brainer. Would you even think twice about adding multiple support library dependencies today? Eventually we'll reach the same tipping point where you don't care about the Kotlin dep because a majority of libraries are using it. One last point: Either you're not using ProGuard in which case the added dep doesn't matter because the support library and play services are much worse in their non-ProGuarded blot, or you are using ProGuard and then 90% is stripped and a few other percent is inlined making it a non-issue.
Very close... I'm not even using Java anymore. While Kotlin may be mostly used for Android development, my team and I have been using Kotlin as a replacement for server side Java and it has worked out great. Deployed a few Web APIS/Microservices to a live environment to support mobile apps. Since Kotlin works nicely with existing libraries, we were able to easily leverage Spark Java as the HTTP server. I can't imagine coding in Java again. Best part is that we can now share some of our common Kotlin code between the server and Client/Android. Plus, most of our code is now immutable and functional which has significantly reduced bugs. We also use Scala, so at this point we are almost exclusively not using Java at all except for external libraries.
Jdbc
What platform are you targeting? If JVM, use JDBC.
Yes, lol.
Yes, JVM - but isn't JDBC just the inbuilt Java database interface? I'm looking for a database abstraction layer.
Sql2o
Then jOOQ, but you need to pay for SQL Server support. I love it: https://www.jooq.org/ Has Kotlin extensions, too.
I absolutely love [JOOQ](https://www.jooq.org/) because it gives you a fairly type safe version of SQL in Kotlin. For example: fun booking(bookingId: Int): Booking = ctx.select() .from(BOOKING) .where(BOOKING.ID.eq(bookingId)) .fetchOneInto(Booking::class.java) fun addBatchJob(type: BatchJobType, payload: BatchJobPayload) { with (BATCH_JOB) { ctx.insertInto(BATCH_JOB, TYPE, PAYLOAD_JSON) .values(type, payload.toJson()) .execute() } } Here `ctx` is the result of calling `dslContext` below and supplying a `java.sql.Connection` JDBC connection: val sqlDialect: SQLDialect = SQLDialect.POSTGRES_9_5 fun dslContext(conn: Connection): DSLContext = DSL.using(conn, sqlDialect) And `Booking`, for example, is a POJO that was automatically generated by JOOQ based on my database schema which has a `booking` table and an `id` column of type `INTEGER`...
Yes, I like Jooq, although it's probably more heavyweight than I need - and the license is a disincentive too.
Interesting, and it works nicely with Kotlin?
Well, it's not written with Kotlin in mind, so there are some null assertions needed.
Those I can handle - thanks! Will take a closer look.
Library comes compiled.
AFAIK jOOQ costs a license fee if you want to use it with MSSQL server.
&gt; We also use Scala How does Kotlin compare to Scala in your experience?
what?
If you expect us to convert this into Java for you without you even bothering to try yourself, give context or even just actually *ask* then you're out of luck
Not sure how to reconcile the desire to be objective with the entirely made up (i.e., subjective) numbers used as justification. In a desire to be objective it makes an ironic twist into being subjective. Except it's written in a way that makes it far less approachable than the normal article which simply lauds the language for it's obvious (if unquantifiable) improvements.
Yes, it's an interesting article, but imho it focusses too much on initial efforts. Even if there was objective data, the initial effort would perhaps be about the made up numbers, but the benefits are maybe much greater than one can imagine. Even after a week of Kotlin it feels kind of backwards to use Java.
Thank you for voicing this concern. I truly appreciate an objective dialogue, however, I found myself being very skeptical about the values he constructs for his analysis.
Yeah I have a really hard time quantifying the improvement that I _feel_. I suppose if you have a large enough organization you can measure this with some metrics. But I don't think you can distill it down directly to something like feature X makes task Y Z% faster/easier. Maybe it's a "the whole is greater than the sum of its parts"-type situation with Kotlin. Each language and stdlib feature fixes small things that on their own doesn't measurably improve anything, but when you put them all together there's a c-c-c-combo effect that multiplies it.
 Spring-jdbc might the level of abstraction you're looking for.
I think that Kotlin is basically a simpler Scala, and this makes it much more accessible to the majority of Java users. Scala on the other hand is more powerful with a better type system. But so much of a language is more than simply its language features, but the collection of tools, libraries, community, philosophy etc. I see Scala as predominately a functional language ( even though its billed as a Hybrid Object-Functional one). IMO, the community and philosophy of Scala is much more inline with functional programming and moving further towards pure FP. This is noticeable in the open-source libraries, communities, conferences, online forums. This approach has pros and cons, it attracts pretty solid developers, yet at the same time creates some unnecessary complexity in code. Kotlin I feel is little more in the middle and more accurately a Hybrid Object/Functional language. It has taken away just a handful of features in Scala for the sake of simplicity. This is arguably its biggest strength. I really do miss for comprehensions and chaining of monadic operations in an elegant way like in Scala though. Again that is language level stuff. Community is still young and growing. And it does lower costs / effort if you are building mobile apps as now you can simply use 1 language for both client + server. Less for people to learn and less for people to mentally switch contexts between. -K 
Have a look at KDBC: https://github.com/edvin/kdbc . I dislike JOOQ myself because of the all the code generation required, I couldn't get it to work and I decided I didn't like it. Disclaimer: the library is WIP, it might not be your best choice if you need a stable API right now. It will probably change and will be extended and documented soon.
It does look interesting, but too risky to bet on something so early, I'm afraid :(
One huge potential dealbreaker goes unmentioned: Kotlin's runtime inflates the jar considerably for small projects. If your jar is already fairly large this can be acceptable, but it's still quite frustrating.
What is the increase in size?
This article was heavily downvoted in r/androiddev for that reason.
**Here's a sneak peek of /r/androiddev using the [top posts](https://np.reddit.com/r/androiddev/top/?sort=top&amp;t=year) of the year!** \#1: [Facebook stole my $160000! For those who use Facebook ads in their Android apps.](https://np.reddit.com/r/androiddev/comments/570gco/facebook_stole_my_160000_for_those_who_use/) \#2: [Kotlin is officially supported on Android](https://np.reddit.com/r/androiddev/comments/6bqlds/kotlin_is_officially_supported_on_android/) \#3: [You know you're and Android Developer when your browser looks like this...](https://i.redd.it/p324mjtxfzuy.jpg) | [90 comments](https://np.reddit.com/r/androiddev/comments/68pxak/you_know_youre_and_android_developer_when_your/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
From my experience my 100kb jars become like 5mb
Depends on what you include, kotlin-reflect is huge compared to kotlin-stdlib, so if you don't need reflection you can keep your JAR pretty small. 
Plus it's supposed to shrink very well if you use ProGuard. 
I don't know the answer, but I use data classes with Jackson and Jersey and it works great. Good luck
When "runtime inflates the jar...." was a problem in the Java world ?
At a guess, the `@XmlJavaTypeAdapter` annotation is being applied to the constructor param or one of the accessor methods. So I'd try modifying `@XmlJavaTypeAdapter` to point to the field by using `@field:XmlJavaTypeAdapter`? See the Kotlin documentation on [Annotation Use Sites](https://kotlinlang.org/docs/reference/annotations.html#annotation-use-site-targets). Assuming that the type adapter annotation is being applied to the property accessor methods by default, you could also try changing `@XmlAccessorType` to `XmlAccessType.PROPERTY`?
It adds 1MB
Kotlin's extension functions are compiled to static methods that are invoked with a regular `invokestatic` bytecode instruction; there is zero overhead for using them. I don't know what Groovy does exactly, but it can't be more efficient. :)
&gt; Error handling is a common use case for Either. Yeah... no, don't do that. `Either` is a terrible way to represent errors because the decision of which one of `Left` or `Right` represents the error is completely arbitrary and dependent on which language you learned in the past. It's very easy to get that wrong. [`Result`](https://github.com/kittinunf/Result) is a much better way to represent this kind of value. 
Result&lt;V,E&gt; is an Either&lt;A,B&gt; specifically for Exception handling. One limitation is that the error value has to be an Exception with Result&lt;V,E&gt;. If you were to write a form validator that returned a success value or a String why the form didn't validate, you would not be able to use Result. I was just trying to show that Kotlin is missing generic sum types in it's standard library. Result would be a great addition to Kotlin but not fit all uses of sum types. You could also represent Result in terms of Either using a type alias and some utility functions. typealias Result&lt;V&gt; = Either&lt;Exception, V&gt; fun &lt;V&gt; Success(v: V): Result&lt;V&gt; = Either.Right(v) fun &lt;V&gt; Failure(e: Exception): Result&lt;V&gt; = Either.Left(e) 
Thanks, @field:XmlJavaTypeAdapter worked.
The other comment answered it. I use data classes for that too, and they work great. Just needed to figure out this part of it.
But There's slack, and everyone is there, like really everyone related to Kotlin. 
That's good to know. I will get over there. Thanks a lot
Which part is easy to get wrong? Remembering the bias of Either for the language you're working in isn't any more difficult than remembering e.g.remembering basic syntax quirks, like () being used to access arrays instead of [] in Scala
&gt; Remembering the bias of Either That's the problem: you have to remember it. If you use something like `Result`, the fact that the values are called `Success` and `Failure` require no memorization. Also, the `Either` ambiguity has led to the Scala community spending years discussing whether to bias it or not. Such a waste of energy. Don't use `Either` to signal errors.
Also [wrote about](https://medium.com/@lupajz/you-either-love-it-or-you-havent-used-it-yet-a55f9b866dbe) Either some time ago. I got used to rather have Error &amp; Value subtypes instead of Left &amp; Right
Which side is the success path is an implementation detail that isn't important. If the standard library had a generic Sum type and choose a side for representing Success and Failure paths, every library could then settle on their implementation. Because generic sum types are missing, the community has made many implementations for what is missing ([Functionale](https://github.com/kategory/kategory/blob/539de80ba60aa81e176981573b8dacd050c3b668/kategory-core/src/main/kotlin/kategory/instances/EitherInstances.kt) and [Result](https://github.com/kittinunf/Result)) and people will debate which one to use and which side is better for the success path, etc. This also fragments all libraries that use sum types in their interfaces, since there are many different implementations. That's why I chose the title "Kotlin's missing type, Either". All this could have been avoided if there was a standard library implementation. Then I could just about how to use it.
Robert pretty much sums up my thoughts exactly, but to add to it: - The two languages I know of off the top of my head w/ Either are Haskell and Scala, both of which are right biased and its most likely anyone using or looking to use Either in Kotlin will be coming from one of the two or be new to the idra entirely and have no preference - If you are coming from some language X with unbiased or left biased Either, itd take you literally all of 15 seconds to get a compilation error, read it, and realize that it behaves slightly differently in language Y and modify your code accordingly. Not really any different from remembering e.g. # vs -- vs // etc for inline comments in different languages.
&gt; itd take you literally all of 15 seconds to get a compilation error, No: if you accidentally swap `Left` and `Right`, you won't get a compilation error. That's the problem and that's why using `Either` for error reporting is a bad practice.
Merely switching them around wont give you an error, sure, but you're gonna get one when you attempt to map some function onto your Exception which isnt defined for Exceptions.
You just mixed up the side you put Value and Exception on within your own short post... 
Where?
I mean here on Reddit: &gt; Result&lt;V,E&gt; is an Either&lt;A,B&gt; and &gt; You could also represent Result in terms of Either using a type alias and some utility functions. &gt; typealias Result&lt;V&gt; = Either&lt;Exception, V&gt; I do generally agree that it would be nice if the standard lib included Either... and Option... and then I realize it's a slippery slope best left to a library. I'm not sure how useful either really are without the nice syntactic sugar you get with e.g. Scala for comprehensions.
Perhaps I am alone on this but I feel like an rxjava2 Single is a better abstraction for something that produces a result or an error? You will already have rich api around the abstraction for composition and you are much more likely to hire *the new guy* and not have them be quite as lost as they otherwise would have been with some one off set of API.
You should avoid using the error state in Rx streams for anything that isn't fatal. It's really easy to complete a stream by accident by an error event.
That was intentional. I was just following the convention used here [https://github.com/kittinunf/Result](https://github.com/kittinunf/Result)
say I have a network call represented by a single. @GET fun repositories(ownerId: UUID): Single&lt;List&lt;Repository&gt;&gt; That may well error out in a dozen or more ways. Doesn't mean it will kill the whole stream or be a fatal error. The error will be consumed and converted to valid state representation because that is life. We live in a distributed world and the CAP theorem is alive and well. EDIT: in my original message I reference the rich api for composition. The network example above can easily take advantage of something like [onErrorResumeNext](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Single.html#onErrorResumeNext-io.reactivex.functions.Function-)
Rx should be used for asynchronous code. Either is more lightweight when compared to Rx and synchronous.
Yea I suppose there is the blocking nature of what you are sharing. Keeping in mind I am arguing only for the case of success or error as the types of the *Either*. It still seems more appropriate to me to just use the language level error propagation system than to invent a general abstraction over it. You can still use `@Throws` in Kotlin to express things that should really be handled by the caller. Even with the *Either* you are left with a `when` to decipher what happened. Now if you are chasing the goal of having the compiler really step in and help you with ensuring you don't miss cases you still need to model all of your error and success cases out via an appropriate construct. Once you have gone that far I would probably advocate you just model it out directly in a single sealed class model hierarchy rather than use an *Either*.
Here is an example where the sum type with flatMap would allow for composable form validation. Not all errors are exceptions which is when having a general abstraction would be better. Success&lt;String, Unit&gt;(Unit) .flatMap { checkEmailField() } .flatMap { checkNameField() } .flatMap { checkPhoneNumberField() } .catch { validationError -&gt; showError(validationError) } .flatMap { submitRequest() } 
Thank you for not calling sealed classes ADTs. People seem to forget that product types exist too, as well as exponents and the multiplicative/additive identities. How much algebra can you really do with just sums?
Naturally, the problem can be solved by using somebody else's library. It's nice to understand what's going on behind the scenes, so I like [this answer](https://stackoverflow.com/a/34462577) on StackOverflow.
I just use `val Any.logger: Logger get() = LoggerFactory.getLogger(this)`. I think it's a lot simpler and easier to understand how it's working. 
I can agree that the type would be useful for some functional work but... Ui interactions are inherently asynchronous callbacks as well as the submit request at the least being local io if not network, both potentially long running operations. This example is likely better implemented via rx. The other thing is that in your example it isn't clear what the behavior is if an error occurs at one or more of the check method calls. If check email fails will I still see an error for name and phone or do I have to hit submit every time I want to check if it is right. Pretty poor ux if that is the case. The code is super terse and the intent clear though. Which seems to be the goal but feels like a square peg being put in a round hole.
Yea, no telegram http://kotlinlang.org/community/
Very useful type indeed. You can vote for this Koltin issue if you think it should be part of the language : https://youtrack.jetbrains.com/issue/KT-12713
But if you want to build you app in a more reactive way, you likely want do use an Observable&lt;List&lt;Repository&gt;&gt;, so you don't have to do manual plumbing in case of reloading etc. A single error terminates the whole Observable, so you cannot use normal errors for that. You have to use something like Observable&lt;Either&lt;Error, List&lt;Repository&gt;&gt; . onErrorResumeNext() works, but you likely have to sacrifice type safety, especially if you want to handle different types of errors.
It seems like a poor man's union type.
The example above is similar to RxJava because both are monads. The big difference between Either and RxJava is the context of the wrapper. RxJava being async and Either being sync. The first field with an error gets short circuited to the next catch block. There is no need to subscribe because it is all runs sychronously. Also catch blocks can switch back to the success block if they return a Success object. Some of this might not be clear to the uninitiated but if you're coming from RxJava, it's like 90% the same.
By main I mean from now on/on new projects. I don't think anyone will start replacing/rewriting existing Java code to Kotlin :) I do want to know what language the companies prefer to work with given the opportunity on a new project. 
Let's say for question's sake that I want to build a new android app as an individual. What language would you recommend me to work with? ;)
That is a question much easier to answer :) I would say go for Kotlin. It's much more fun and removes a lot of noise Java code suffers from. Although I can't predict the future but I think kotlin will overtake Java. There is no real disadvantage from a language perspective, but many pros. I've developed in Java for 7+ years so I didn't just jump on the bandwagon 😂
The data class section is a bit odd. It says that even with lombok creating value objects is cumbersome but it doesn't explain why.
Thanks for the tip, I'll fix it!
Anyone has some other examples of corporate uses of Kotlin in server development?
This article is crap. I've commented on their page in which I refuted the main points of the article itself and the OP did not accept my comment (it was not published). I think that the OP only likes to live in his own echo chamber. I have shipped software written in both Java and Kotlin and I can extract all our story point estimations from the Java era and from the current Kotlin era so I can say objectively that our velocity increased by more than 25% just by switching to Kotlin. I've also rewritten a project in Kotlin (using the Java-to-Kotlin converter tool and some refactoring) and I can say that the code base is 25% of the original and it has `null` safety. The sheer amount of boilerplate I **don't have to write** alone is a huge win over Java but I can give countless examples proven by experience and hard facts why Kotlin is better than Java. This article is just **FUD** and has zero facts underpinning the point (just theorycrafting).
Just to get us started: these are the topics for our next meetup (in two weeks), each is a ~20 min talk: - Learn how to integrate services with Akka HTTP and Kotlin - DSL design - Kotlin coroutines: behind the scenes
Could you change links for books so that it doesn't redirect to German amazon ? Thanks
Links are localized. Are you using a VPN or anything that is Germany based? Or is that the nearest "big" Amazon site?
Hm, must be something setup on company network. Never mind then. 
No problem. Thanks for the heads up! :)
"Cool" technologies like Akka HTTP are nice but I think most people work with traditional frameworks which is a nice target audience for Kotlin - I'd look into something like Spring 5 support for Kotlin.
I've updated the article with an explanation!
Oh OLX, I really like them! Thanks for sharing 
Native
I've seen tons of talks about kotlin + android, but very few about kotlin used as a server side language..
Great idea, thanks!
We're trying to do more talks about this. I know a few people here who do backend with Kotlin, so there's more to come. Glad you like it! :)
Can you please elaborate? 
Oh sorry. Kotlin Native is Kotlin code that compiles to native code on LLVM, you dont need the JVM. https://github.com/JetBrains/kotlin-native
I am writing URL shortener website in Kotlin with Spring Boot. The goal of this project is to have both back as well as front end written entirely in Kotlin. I hope that this will spark some discussion. https://github.com/janpetryk/kotlin-url-shortener
Kotlin JS. I love Kotlin JVM but honestly it contains little mystery, it's the same Java we already love but with a better syntax. Kotlin JS is a deep topic I think most people don't grok yet.
Sounds like a job for coroutines. Not sure if they have this exact functionality in the stdlib, but it's easily built with coroutines.
You could use java 8 streams with kotlin, parallelStream is built on top of the work stealing forkjoinpool.
 import java.util.stream.Stream import kotlin.streams.asStream // If you use Sequences Stream.of(1, 2, 3).parallel().map(...) // or listOf(1, 2, 3).parallelStream().map(...) // or sequenceOf(1, 2, 3).asStream().map(...) As someone said it uses the built in ForkJoin thread pool which works similarly to rayon.
Use the [shadow](https://github.com/johnrengelman/shadow) plugin for Gradle. Basically just: plugins { id 'com.github.johnrengelman.shadow' version '2.0.1' } adds a shadowJar task, and optionally: shadowJar { baseName = 'shadow' classifier = null version = null }
Who is going to be using this library? If it's for external consumers, don't bundle kotlin. Instead you can just list kotlin as a separate dependency in your documentation, like this dependencies { compile 'org.mine:mylib:1.0' compile "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version" }
Sealed classes and algebraic data types 
 jar { manifest { attributes 'Main-Class': 'foo.bar.MainKt' } from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } } } this one works works me, iirc I got it from stackoverflow.
Thanks, but I meant what kind of talks would you like to hear about Native :)
You could talk about Coroutines. We use it in production (server-side JVM), i think it's really underrated
I'm not aware of any formatter tools for Kotlin other than IntelliJ's built-in formatter and the reformat features of ktlint (which don't do what you need). In the IntelliJ formatter, the behavior you're talking about is controlled by the "Keep line breaks" option in the code style settings; you can try turning it off and see if you like the results better. And of course you're welcome to file YouTrack issues for formatter improvements.
You mean something like this? https://gist.github.com/functionaldude/0b0216f61e3b69eccce8c7c98b2bb808
Y tho?
Yeah, like that. This doesn't allow you to chain additional operations in the same async context directly, but that would be an easy addition if it's needed.
For a name I like `Try` better than `Result`, because it's shorter and sounds more exception-related. Then you can: val result = Try { // Something that might throw or return } Had to implement this in my future library, see [Try.kt](https://github.com/gladed/kotlin-late/blob/master/src/main/java/com/gladed/util/Try.kt) but would rather not have. +1 to put this in stdlib so we don't have lots of implementations running around!
you could chain the .mapAsync calls, but if you want to have the full pipeline in a separate async context, you should probably use Sequences. Sequences are lazy evaluated so the computation process is always at the end, like Java streams. You can also convert a Sequence to an Iterable, which is helpful if the whole collection is really big, or you are reading it from an external source (eg.:MongoDB), because in this case there are no collection step, so it doesn't load the whole collection in memory
Correct. That was my idea in the first place, not sure if there's a utility for parallelizing sequences in the stdlib though. Or, like others have suggested, you could also directly use parallel Java streams, provided you're not stuck on an older Java version.
&gt; configurations.compile.collect Sometimes Gradle is an engima, where is this "configurations.compile.collect" documented? What resource would tell me that existed and what it means? 
[Detekt](https://github.com/arturbosch/detekt) has a Gradle task for formatting.
I just use per-instance loggers. The performance hit hasn't been worth thinking about yet because it's so negligible. 
This was also a problem for me in august writing a dropwizard application in a mix of kotlin and java, using jooq. I've since been back in java only land, but good to hear they are actively working on it.
This approach (which is growing on me) has other advantages. You might also do something potentially exception-throwing while evaluating the output string. With pass-as-lambda, that code wouldn't even run or at worst could be caught without impact to the call site.
I've tried a few options and settled on Shadow as well. The best thing for me is that it makes it really easy to configure what to include/exclude. I use it for a plugin architecture I developed where I don't need most dependencies since the main application will include them, but I do need dependencies that the plugin adds. Works really well for me.
Does Kweb serve HTML to the client, or Javascript? (I like HTML for seo because even though Google supports JS to some degree, it isn't optimal.)
Configurations is documented on the Gradle project object. compile dynamically retrieves a configuration by the name of "compile" (the conventional one used for dependencies to compile your project against). "collect" is the terrible Groovy name for what every normal language calls "map". Basically, it's Groovy's fault that Gradle is so cryptic. This should be improved once we all move to Kotlin Gradle scripts 
It serves up a small HTML+JS template, which then chats with the server. So you would want it to serve a simple SEO-friendly HTML page in response to a web crawler (I think this is SEO-best practice anyway). This functionality isn't currently supported directly but it would be very easy to add. I'd be happy to help with that.
I didn't know that this can be just suppresses, this is actually quite handy. So far I had the actual framework ([kfunnels](https://github.com/lukashaertel/kfunnels/)) only in mind for Kotlin. Because I read the class metadata, I can get the upper bounds of a type easily. I think once I move this to a more universal JVM based serialization I won't have that information and will have to resort to Any, in which case suppressing upper bounds is quite a nice workaround. I love that you call it a "soft" error, the static analysis on generics is quite thorough and well thought out. But in some cases it is just too limiting, and in this particular one not even satisfiable when static analysis is the only participating. Thanks a lot for this pointer!
For processing this data type, it could be helpful to have some transformation functions nicely applicable in infix notation: sealed classes to the rescue AGAIN! sealed class ResolvedLeft&lt;A, B, T&gt; class SomeLeft&lt;A, B, T&gt;(val it: T) : ResolvedLeft&lt;A, B, T&gt;() class NoneLeft&lt;A, B, T&gt;(val right: B) : ResolvedLeft&lt;A, B, T&gt;() sealed class ResolvedRight&lt;A, B, T&gt; class SomeRight&lt;A, B, T&gt;(val it: T) : ResolvedRight&lt;A, B, T&gt;() class NoneRight&lt;A, B, T&gt;(val left: A) : ResolvedRight&lt;A, B, T&gt;() sealed class Either&lt;A, B&gt; class Left&lt;A, B&gt;(val left: A) : Either&lt;A, B&gt;() class Right&lt;A, B&gt;(val right: B) : Either&lt;A, B&gt;() inline infix fun &lt;A, B, T&gt; Either&lt;A, B&gt;.onLeft(block: (A) -&gt; T): ResolvedLeft&lt;A, B, T&gt; = when (this) { is Left&lt;A, B&gt; -&gt; SomeLeft&lt;A, B, T&gt;(block(left)) is Right&lt;A, B&gt; -&gt; NoneLeft&lt;A, B, T&gt;(right) } inline infix fun &lt;A, B, T&gt; Either&lt;A, B&gt;.onRight(block: (B) -&gt; T): ResolvedRight&lt;A, B, T&gt; = when (this) { is Right&lt;A, B&gt; -&gt; SomeRight&lt;A, B, T&gt;(block(right)) is Left&lt;A, B&gt; -&gt; NoneRight&lt;A, B, T&gt;(left) } inline infix fun &lt;A, B, T&gt; ResolvedRight&lt;A, B, T&gt;.onLeft(block: (A) -&gt; T) = when (this) { is SomeRight&lt;A, B, T&gt; -&gt; it is NoneRight&lt;A, B, T&gt; -&gt; block(left) } inline infix fun &lt;A, B, T&gt; ResolvedLeft&lt;A, B, T&gt;.onRight(block: (B) -&gt; T) = when (this) { is SomeLeft&lt;A, B, T&gt; -&gt; it is NoneLeft&lt;A, B, T&gt; -&gt; block(right) } fun foo(arg: Either&lt;Int, String&gt;) { val r = arg onLeft { it * 20 } onRight { it.toInt() - 1000 } println(r) } fun main(args: Array&lt;String&gt;) { val x = Left&lt;Int, String&gt;(100) val y = Right&lt;Int, String&gt;("42") foo(x) foo(y) }
It's rather embedded DSLs, but this is one of the nicest features I see in Kotlin, it might be interesting to cover the DSLMarkers for this one. Coroutines are lovely too, don't know how much of "behind the scenes" can be put into a 20 minute talk, as their transformation into state machines and all the captures they have to do require quite some magic.
In my experience it is cumbersome because sometimes the annotation processor does not generate the code, causing wasted time.
We're doing a coroutine talk on the next meetup.
From my experiency my 500 kB jars become like 504 kB (https://github.com/dsyer/spring-boot-thin-launcher)
Saying Configuration is documented on the Gradle project object is stretching things. It mentions it and has links to other pages. However, after reading all three of these pages I still have no clue where I find a list of configurations or how to use them. It kind of looks like you can declare your own but even that isn't well explained. * https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:configurations(groovy.lang.Closure) * https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ConfigurationContainer.html * https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.Configuration.html
You're right, honestly. I don't fully understand configurations myself. What I do know is that yes, you can create your own, and yes, it's tough to figure out what configurations exist. That's because they're usually created by plugins you apply. For example, the Java plugin gives you "compile". Without applying the Java plugin, Gradle would complain that the compile configuration isn't found when it tries to run the line that declares your first compile dependency. Similarly, when you apply the Kotlin plugin, you get the "kapt" configuration which you add annotation processors to so they can process Kotlin source files. Presumably, the documentation around which configurations are available to you would be found on the plugins you're using. In this case, if you want documentation on compile, maybe that's in the Java plugin docs? Build systems are incredibly abstract by design so they can be adapted to many situations. Gradle can compile Java, Kotlin, C++, and probably a whole ton of other languages. The concept of a "configuration" naturally has to be very abstract, but I agree that they could maybe do a better job of surfacing a tutorial that explains Gradle "primitives" in layman's terms. 
Can you help me run a kotlin+ktor hello world using gradle? https://www.reddit.com/r/programming/comments/6zmf02/what_can_kotlin_do_for_me_gdd_europe_17/dmyaum6/ Somehow gradle isn't including kotlin in the jar, it seems..
Jetbrains/Corda
I really like the property delegate solution. Super elegant. 
The [top comment](https://www.reddit.com/r/Kotlin/comments/6zj73u/how_can_i_package_a_fat_jar_in_gradle_for_kotlin/dmw2wyn/) in this thread sounds like it would solve your problem
There is [ktlint](https://github.com/shyiko/ktlint), which is an opinionated style linter and formatter, but I don't think it's quite as aggressive as the Google tool for Java.
In this particular instance you can use street.name
Your Child class should get val loading in it's constructor and pass it to your MyParent class' constructor while extending it.
Yeah, but that was just an example, I'm speaking about value objects in general. While street.name sounds fine, there are many cases where such "trick" is not possible. What would you do with Timestamp VO? Or FirstName? Should I call them all 'value'?
But thats the restriction with DataClasses right? Again quoting from official doc : &gt; All primary constructor parameters need to be marked as val or var; you can not mark the parent class properties since they are val
Do you need the data class wrapper? If not, a [typealias](https://kotlinlang.org/docs/reference/type-aliases.html) could be enough: typealias Street = String
You can override vals (if they are declared as *open* ): abstract class MyParent(open val loading: Boolean = false) { abstract fun isDataPresent(): Boolean fun isLoading(): Boolean = loading &amp;&amp; !isDataPresent() } data class Child(val someValue: Int, override val loading: Boolean = false): MyParent(loading) { override fun isDataPresent(): Boolean = (someValue != 0) } fun main(args: Array&lt;String&gt;) { Child(1).copy(someValue = 2, loading = true) }
Thanks, this looks fun. I will check this and let you know
Thanks - that solved it :)
typealias isn't strong enough: typealias Street = String typealias NotAStreet = String fun giveMeAStreet(street: Street) { println("street=$street") } fun test() { val foo: NotAStreet = "foo" giveMeAStreet(foo) giveMeAStreet(":(") }
I would go with `value` for single value classes. `street.value` is fine. 
Kotlin does not have a really nice solution for this yet. If you want to save on some characters you could do something like: data class Street(private val value: String) { operator fun invoke(): String = value } And then use it like this: val street = Street("some street") println("Street name is ${street()}") But I find this still kinda ugly. You also have the overhead of an additional object and you could argue that this is abusing operator overloading in a bad way.
In FP and languages like Rust they call this a newtype and rely on pattern matching to get at the value. Kotlin has some pseudo-pattern matching syntax for data classes (or any class with `componentX` methods). Unfortunately you can't destructure in standard function argument declarations but you can in val/var statements, for-loops, and lambda arguments. val/var destructuring is probably pretty useless for single-valued types but for-loop and lambda destructuring may come in handy: data class Street(val name: String) fun printStreetNames(streets: Iterable&lt;Street&gt;) { for ((street) in streets) { println(street) } } fun Iterable&lt;Street&gt;.roads() = filter { (street) -&gt; street.findAnyOf(listOf("Road", "Rd"), ignoreCase = true) != null } And if you do happen to have a function that returns a newtype and you only need to refer to its content: val (street) = returnsAStreet()
This is largely irrelevant, but Kotlin is not a military base, it's the island on which the town of Kronstadt is situated. There is a fortified seaport there, but it's mostly just a place people live in. It just... irked a little, after the KGB comment. 
Here is a list of threads in other subreddits about the same content: * [Building Kotlin JVM Libraries](https://www.reddit.com/r/androiddev/comments/70699x/building_kotlin_jvm_libraries/) on /r/androiddev with 1 karma (created at 2017-09-15 04:06:26 by dayanruben[author of both threads]) ---- ^^I ^^am ^^a ^^bot ^^[FAQ](https://www.reddit.com/r/DuplicatesBot/wiki/index)-[Code](https://github.com/PokestarFan/DuplicateBot)-[Bugs](https://www.reddit.com/r/DuplicatesBot/comments/6ypgmx/bugs_and_problems/)-[Suggestions](https://www.reddit.com/r/DuplicatesBot/comments/6ypg85/suggestion_for_duplicatesbot/)-[Block](https://www.reddit.com/r/DuplicatesBot/wiki/index#wiki_block_bot_from_tagging_on_your_posts)
I definitely should not be. It is a type_alias_, not a new type.
Cool! Is it a private meetup? Im thinkin about joining you
You're welcome to join, more info [here](https://www.meetup.com/Kotlin-Budapest/events/243169020/)! It is in Budapest, Hungary.
But I notice JVM using a ton of memory
Can an ArrayList&lt;Integer&gt; be contagious in java? Can JIT do that?
Damn, that's clever.
I love how Kotlin makes it easy to be both clever *and* clear. 
Right? I've personally been doing this a lot: `private val logger = Logger.getLogger(javaClass)`
Good news :-)
thanx mate
Your welcome! Ask if you have any questions! :)
because java's server vm optimizes for cpu, not memory usage
I've been using spring 5 dev releases for a while, 100% in kotlin. It's working great!
Well, yeah. Even the client vm?
If the simple value types are all single-property wrappers for `String`, we can simply override the `toString()` method to return the value: data class Street(val value: String) { override fun toString(): String = value } Alternatively, if it is preferable to use a custom interface to avoid overriding `toString()`, we can do something like this instead: interface StringValue { val value: String } data class Street(override val value: String) : StringValue If some of the value types contain primitive classes other than `String`, such as `Int`, we can use the general-purpose `Supplier` interface: import java.util.function.Supplier data class Street(val value: String) : Supplier&lt;String&gt; { override fun get(): String = value } Edit: Added more backticks.
It's interesting that the author doesn't seem to like checked exceptions much but then says: &gt; the code we wrote gives us no indication that something might fail. Furthermore, okhttp's type signature for making an http call does not tell us what exceptions it might throw if something might go wrong. Well, yes: this is what you get when you get rid of checked exceptions, code that can fail in ways that can no longer be enforced by the compiler. Also, this: &gt; fun scores(): List&lt;Game&gt;? Is a beginner mistake. Return empty collections, not `null`ones (even if Kotlin can handle this case just fine with its nullability support). &gt; For handling exceptions, we generally want to use Try; while Either is for business logic errors. No. Don't use `Either` for errors. Period. Its values are `left` and `right` which completely fail to convey the concept of errors and require human discipline to use properly. Use `Try` or `Result`, which are much clearer about their scope and function. &gt; they can know right away from reading the type signature that it is an operation that can throw an exception, and that they need to handle it in their code. Sure. Or you could, you know, use checked exceptions and reach the same result, except you no longer have to bubble the result up the stack manually and which also give you direct access to values without having to `fold` or `flatMap` them `Try` object, another added value of exceptions). Finally, is it so hard to use black ink on a white background instead of faint grey on white? My eyes are sore from reading this article. 
If you will take heap dump of any java app you will see that most of memory is not used. Java takes much more memory than needs so garbage collection can run rarely. Client VM is obsolete. Oracle is not focused on it at all. Server VM is default even on Windows PCs.
&gt; Or you could, you know, use checked exceptions Kotlin doesn't have checked exceptions.
useful
Even if most memory isn't used, it's still taken by JVM, so other programs on the computer suffer. For example, minecraft requires 1Gig ram to be playable. That's just insane for a block game..
I use it in JavaEE space for JPA very often. inline fun &lt;reified T : Any&gt; findEntity(id: Any?): T? = if (id == null) null else entityManager.find(T::class.java, id) So it is nicer to call val user = findEntity&lt;User&gt;(id) or val user: User = findEntity(id) however you prefer.
Thats why this VM is called server. It's supposed to be run on the server where you have lots of RAM and only whats matter is performance.
Ah, that makes sense. It's a shame java is still used in client when it's only meant for server. :S
Ah, that makes sense. It's a shame java is still used in client when it's only meant for server. :S
Yet people keep making client programs in java, which is made for server.
What is TornadoFX?
No clue, if only there was a readme in the linked repo to explain it. Oh well.
The repo has both a readme and a wiki. Oh well.
Aren't you a delight.
I call it lack of experience. Everyone should choose best tool for purpose. When I have a need to make desktop aplication for windows, C# is obvious choice.
TornadoFX is built ontop of JavaFX and is used for creating desktop applications.
Yup it's JavaFX for Kotlin to reduce boilerplate code
Thank you. New to Kotlin/Java.
Whilst this is a good tutorial for *absolute* beginners, it doesn't really explore any Kotlin language-specific benefits over a standard Java implementation. In fact, it seems to just be a basic Kotlin port of a simplistic Java implementation. Nothing wrong with that, but doesn't really show off Kotlin as such. I personally found [this tutorial](https://antonioleiva.com/recyclerview-adapter-kotlin/) to be a little more interesting in how Kotlin can be used to enhance RecyclerView
No worries :) JavaFX is an excellent framework for creating graphical user interfaces on the desktop and TornadoFX makes it 10 times more productive, it's really nifty.
The only thing I've used for a similar purpose would be tkinter with Python. I enjoyed it but it was pretty basic. The sense of achievement in seeing visually what you created far surpassed any of the terminal type programs I had done up to then and even the Labview GUIs I had drag and dropped together. Looking forward to checking out TornadoFX.
Yes indeed! Well said, I'm always prouder for the software I produce that has gui's and that is presentable to the "average joe"! Haven't used Labview, is that another GUI builder? I only used the ones from Visual Studio before I discovered Scene Builder.
LabVIEW is a graphical programming language used for programming HMIs. It's very good for that type of thing but not really the same as the likes of python, c or Java
I don't disagree with the article, but, as with many articles it's too focused on Android. All these points apply for java devs in general. 
override fun getItemCount(): Int { return parkspot ?.takeUnless { it.isEmpty } ?.vehicles ?.let { it.size + HEADER_COUNT_WHEN_HAVING_VEHICLES } ?: ITEMS_COUNT_WHEN_NO_VEHICLES } The lack of indentation between the final Elvis else statement and the rest makes this much harder to read. I would say this is far too long of a chain of operations. 
Here are my 2 cents: * I think that Spring 5 + Kotlin is a very hot topic right now. Pivotal also advertises this on a lot of forums (I can see it on this very subreddit as well). * As others mentioned a well thought-out talk about coroutines would be awesome * There is a more arcane topic: delegation. We all heard the fable about composition being better than inheritance but there are no good examples for how to do it well. With Kotlin delegates I think composition is elevated to a new level I can talk about all three on a meetup if you are interested!
Somehow I had missed mapOf in Kotlin. I much prefer that then creating a hashmap, filling out the generic types and adding each item one by one. Especially useful when creating a json body to send on a PUT/POST request.
I'm doing Spring boot + Kotlin dev for a year now. Feel free to ask your questions if you have any, I might be able to help.
This actually did help, I wasn't aware of `mapOf`
Absolutely true. We've been using Kotlin on our backend services in production for at least 6 months and are still learning and unlocking it's potential. It's just a better language to use than Java in virtually any situation. Overtaking a behemoth like Java won't happen overnight, but I have yet to find a Dev that gets their hooks into it want to let go.
I got a chance to try it out at job-1 in a dropwizard + rx environment and loved it straight away. Unfortunately i'm not into android development so it's been a bit sobering at current job to find that folks are pretty resistant.
There are definitely a lot of hurdles, which is why it won't happen overnight or even in the next few years. It will take five years to a decade to unseat Java as the king on the backend if ever. Scala and Clojure have failed, but Kotlin has the tooling, interop, and quick ramp up time to give it a distinct advantage. Patience and a constant drumbeat​ that there's a better language out there truly within their grasp will, I think, win the day.
I sort of agree, it's not the slickest chain I ever saw. However, just the fact that it is a chain based from parkspot allows you to assume certain things about the code that you read which will speed code reading up once you get used to it. 
Awesome ideas, thanks! We're doing a coroutines talk on the next one, the other two is up for grabs :)
Not a huge fan of Elvis operator... Often it pushes you to break demeter's law :(
Yeah, it looks far less readable than the original to me. Why not just override fun getItemCount() = if (parkspot?.isEmpty ?: true) { ITEMS_COUNT_WHEN_NO_VEHICLES }else{ parkspot.vehicles.size + HEADER_COUNT_WHEN_HAVING_VEHICLES } Hell, even this is a bit too much I think, there was nothing wrong with the original in the first place... Though I do admit I'm not "used to" that style.
It's very rare that my sarcasm detector fails but I'll be damned, you're right. Definite detector failure back there. 
I'm a Kotliner and love the way it handles nulls and that method chaining often leads to very nice Rubyesque "program like you would naturally speak" code but I'd concur that getItemCount example is IMHO overusing chaining and safe traversal a bit. In my opinion, it should only be used to make code more readable and concise, not less. I prefer your if based solution better because it reads more naturally. In fact I would rewrite it to be even a bit more verbose in order to better state its intention: if (parkspot == null || parkspot.isEmpty()) ... 
Right back to the original before they *improved it*. 😃
Heh - you're right :) I suppose the only Kotlinesque improvment that I'd suggest there is the following: 1) Parkspot seems to be some kind of a collection. Why is it nullable and not just empty? 2) If nullable collections are necessary and often used in the codebase, then add isNullOrEmpty() helper extension function to nullable collections. fun &lt;T&gt; Collection&lt;T&gt;?.isNullOrEmpty() = this == null || isEmpty() ... if (parkspot.isNullOrEmpty()) ... 
If one insists on chaining, there is an interesting alternative to using let in that example: parkspot ?.takeUnless { it.isEmpty } ?.vehicles ?.size ?.plus(HEADER_COUNT_WHEN_HAVING_VEHICLES) ?: ITEMS_COUNT_WHEN_NO_VEHICLES
`hashMapOf()` is your friend :) 
When a function is a simple if expression I tend to prefer when: override fun getItemCount() = when { parkspot == null || parkspot.isEmpty -&gt; ITEMS_COUNT_WHEN_NO_VEHICLES else -&gt; parkspot.vehicles.size + HEADER_COUNT_WHEN_HAVING_VEHICLES } I think the indentation works better this way.
Or, for the json response use case, you could create a bunch of one-liner classes and get a protocol specification (almost) for free.
Well I can't share them (microservices) because I write them at my workplace but you can take a look at my GitHub profile. I have several Kotlin projects like [this](https://github.com/Hexworks/snap) one.
*bleep, bloop, I am a bot.* You linked to a GitHub repository, here are some of my favourite commits: - [fixed retard bug](https://github.com/Hexworks/snap/commit/ded3c4d0f75deb224e053ea8bfd8e4b211a593b4) ***** ^[Source](https://github.com/mike-eason/angry-commits-reddit-bot) ^| ^[Issues](https://github.com/mike-eason/angry-commits-reddit-bot/issues)
And it worked, Thanks a lot.
I love medium posts with goodies like this, does anyone have any recommended similar posts?
Can you show an example? Not sure that I got what you mean
When building a JSON response that you're going to send, instead of creating it like mapOf( "message" to "Hello world", "user" to mapOf("id" to user.id, "email" to user.email), "unreadCount" to 5 ) You would have class MessageResponse( val message: String, val user: User, val unreadCount: Int ) and just send `MessageResponse("Hello world", user, 5)` I assume whatever JSON serializer you're using (such as gson) would deal with that. There might be a performance hit (not sure), but I assume it can be dealt with. If you put all of these "response" classes into a single file, that file then tells you exactly how all the possible responses from your server can look like - it acts almost like a specification in that sense, especially if it's commented. I used a similar approach in [my library](https://github.com/peterholak/graphql-ws-kotlin/blob/master/src/main/kotlin/net/holak/graphql/ws/Protocol.kt).
I was struggling for a while to figure out how to introduce WebSockets in Javalin, and I finally landed on: app.ws("/websocket") { ws -&gt; ws.onConnect { session -&gt; println("Connected") } ws.onMessage { session, message -&gt; println("Received: " + message) session.remote.sendString("Echo: " + message) } ws.onClose { session, statusCode, reason -&gt; println("Closed") } ws.onError { session, throwable -&gt; println("Errored") } } Feedback would be very welcome!
JSR-305 support!
NO! You program Java WITH Kotlin! It compiles to the JVM! You can make Minecraft mods! Android apps! And MORE! NO!
wait so does that mean kotlin is java to make minecraft mods
...what?
There might be something for you among these [great Kotlin tutorials](https://reactdom.com/blog/kotlin-books).
November 2th through 3th? Wish I could make it.
Have you even informed yourself on this matter? Do you know how Java works (especially compared to binary compiled (like c++, golang), scripting (JavaScript, PHP, typescript, etc) and .net framework languages? Have you watched talks about kotlin (e.g from Google io,)?
Some major server-size frameworks (like Spring, Vert.x) introduced Kotlin DSL, but I'd say you still have to understand how Java and JVM work in order to use them effectively. Starting with Java will definitely make you appreciate the benefits that Kotlin brings, but I don't think it's necessary to be a Java expert to write idiomatic and efficient Kotlin code. Just know your way around the JVM ecosystem and make sure to understand just enough Java to use third-party libraries. As far as Kotlin Native goes, it seems too experimental to use in production for now. I'd wait until the first major stable release. Don't worry about the performance though - JVM is a beast and unless you have millions of users, you probably won't hit any major performance bottlenecks anytime soon.
You don't have to start with learning Java, but knowing Java and the most popular Java libraries/frameworks will make things a lot easier. Kotlin relies greatly on the existing JVM ecosystem, which is primarily Java based. I'm not a very big fan of Go (I think it's awful), but the tooling and support for native in Go is probably better than in Kotlin. When it comes to performance I don't know, but I would guess both of them are fast enough for whatever you'll use them for.
Thank you. So when you say I should know my way around the Java ecosystem, what are the things do you think I should learn from Java to be productive in Kotlin?
Get comfortable with IntelliJ IDEA. You'll be using it a lot. Learn to use a build tool. Maven and Gradle are the most common, both use basically the same repositories. Using a build tool will make dependencies management _waaay_ easier than downloading and linking jars manually. Note that most IDEs allow you generate empty Maven/Gradle-based projects. Learn the language basics. If you're already comfortable with C-like syntax and have previous experience with C++/C#, reading Java should not be a problem. A single entry level course or book should be enough, I think. If you're able to read Java third-party libraries' code without having to Google too much, you're good. If you're into server-side development, I suggest looking into Spring Boot. It's ridiculously easy to set up and it integrates seamlessly with pretty much anything that enterprise applications use. Do some tutorials, create a few REST APIs, learn as you go.
There is a whole lot of ressources on Swift tho. It helps taking full grasp on statically typed languages.
A lot of Kotlin devs are using it for Android right now, but it's great for desktop CLI applications, too. So I wrote this library to make it easy to add color and styles to you command line output. Let me know what you think!
Maybe you can use this one https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/with-timeout.html ? I'm not sure if using coroutines makes that much sense for this usecase - because you don't want cooperative multitasking but a batch processing mechanism. Also, I think I can extrapolate what you try to achieve... you try to have a update that never surpasses a threshold amount of time because you always want a minimum framerate... I don't want to stop you trying out your approach, but what you really want to have is a decoupled update and render setup. This could be better achieved (I think) with traditional threads, as update and render run constantly until you exit the application. Also keep in mind that interrupting the update at a certain point leads to a possibly inconsistent state because your entire world is not at the same update step anymore.
Thansk for sharing, looks pretty cool
You mean as in Swift the Apple language? In that case, I don't think Swift is the language for me. I can barely afford an Lenovo i3 laptop, so getting a MacBook just to learn a language is way beyond my limit. 
They will be available although maybe not all.
Thanks, do you have a source? 
Unfortunately I don't but they should be posted to the slack. http://slack.kotlinlang.org
I did learn the language on Teamtreehouse.com on my Windows machine. You can compile Swift on Linux machines too, if you would like to use it for web, with Vapor for example. I use it for web development now for larger applications.
[removed]
Thanks! Yeah I should have explained more, but you are basically right. My specific use case was not exactly the same as decoupled update/rendering. I was also generally just trying to avoid having to deal with multiple threads and any sort of synchronization. I actually do think that I want cooperative, for instance I want the tasks to be suspended after 5ms but continue processing on the next frame. That is why I think `withTimeout` doesn't work. I don't know enough about how coroutines are implemented, my concern is that coroutines can only be suspended during `suspend` functions, and I would need to sprinkle random `yield` everywhere in my code. At that point I would probably rather just deal with threading.
Or you could use https://github.com/ziggy42/kolor 😁
Please someone post it on the reddit when they become available
The tool looks great! jitpack.io makes me uncomfortable, though.
Yea, that should be correct, coroutines are only suspended at suspension points, which is where the context could stop the scheduling and Hand over control to the rendering. But i think your assumption Not to have to Deal with threads/synchronization is wrong: if you execute update coroutines on multiple threads through your coroutine context and you have shared mutable state, then you need synchronization just like you would if you use threads directly. I think the Link i posted can do what you want, but you have to model the suspending function that is passed appropriately (many suspension points). Random yields are Just as good as the alternative:either threads that Catch interruptedexceptions or a Command Queue with a Lot of small runnables... To implement those state machine characteristics you need. I would recommend to implement correct multithreaded rendering and make the update continuous :) or you could Just optimize your update and rendering and keep going with the current architecture.
Maybe that's because Kotlin is easy to learn if you know Java, and at this point, knowing Java is almost a necessity for Kotlin development anyway.
They kind of shot themselves in the foot marketing-wise for the sake of making a great JVM language. It's so easy to mingle Kotlin into a Java project and so easy to learn Kotlin as a Java developer, Kotlin doesn't really have a place on anyone's resume or job requirement listings.
Yeah I am aware that if my coroutines were updating shared mutable state I would need synchronization, luckily they are not! Threads catching InterruptedException can't really resume very easily unfortunately, and I have done the queue of runnables approach, and also manual creating continuations. I was just hoping to reuse the machinery of coroutines rather than implement continuations myself.
Which do you recommend between Maven and Gradle? IntelliJ comes loaded with both plugins by default and sometimes understanding the nuances to a build tool in a new ecosystem can be challenging.
I totally get where you're coming from. At the moment their isn't a lot of beginner programmer books that uses kotlin as an intro to programming as it's fairly new. Also if you're going into android dev. I highly recommend learning it through Java initially. All the docs in Android are in Java and if you don't understand it in Java it makes it more difficult to translate it to Kotlin Also when you have learned the basics of programming the O'Reilly kotlin course is very good
I suggest getting comfortable with both and choosing either of them for personal projects. Maven seems to be widely used for enterprise web apps, while Gradle is the main build tool for Android. Without going into too much details, Maven uses pretty verbose XML configuration and does not come with an easily accessible scripting API - it seems you basically have to write custom plugins or write Ant scripts to extend it. While it seems to have less features out of the box, it also turns out somewhat easier to maintain, as there's less you can screw up. Gradle, on the other hand, uses much more concise Groovy/Kotlin DSL and allows you write custom tasks out of the box. You can include any JVM library as the script dependency and invoke them in your tasks, with code completion and all. I personally prefer Gradle and use it almost exlusively in my projects, although I once read that Maven is generally better for libraries (where all you do is use dependencies and push to a lib repository), while Gradle scripting capabilities help with regular applications. You can't go wrong with either of them, really.
I prefer keeping them in the java style because a lot of my projects are mixed java/kotlin. I think thats also what the general consensus is since most people see kotlin as "java done the right way"
What's funny is, that I wanted to reimplement my own game engine with coroutines as well, but didn't have the time yet xD But I already implemented a very advanced multithreading technique that decouples perfectly and runs like hell. The one main point that I think really really won't work out with your approach is the fact that you end your update computation somewhen in the mid. While it sounds nice to get a continuation-style gamestate for free, in really it's not useful at all. I once implemented it and it is simply not possible to render it without artifacts, because the state is inherently inconsistent. Your only possibility to "suspend" the whole computation is at the end of all updates. And since you cannot efficiently distinguish between suspension points somewhere in your update classes and the update-finished-suspension point, this won't work. If it's only an update per gameobject entity and you don't have mutable state, why not implement Runnable per Entity and submit them all to a threadpool, wait for termination and you're done?
I had never even heard of Indeed. Is it supposed to be widely used? My own workplace recently advertised for a position using Kotlin in the description and it's a tiny bank in Sweden. I'd imagine there are actually thousands of Kotlin job ads out there. Have you checked LinkedIn?
Indeed.com/.co.uk etc. is the biggest jobs site in the tech industry.
&gt; "Intro to Programming, Using Kotlin" No, there isn't at the moment. Try Swift instead. e: No, I'm serious check this https://www.apple.com/swift/playgrounds/ out. ^^if ^^you ^^have ^^an ^^ipad
Somebody asked on the kotlin slack yesterday and the answer from Hari Hariri was "Hopefully" and "Live streaming won't be happening unfortunately". So it sounds like they are going to try and record them.
I'm in the same boat as you friend, I have very little java experience and the apps I have done for android are very easy ones. I'll keep reading, this language seems awesome.
Agreed, it's just lazy. Uploading a real artifact to JCenter is trivial.
Give it some time. Demand will rise with the release of AS 3.0.
I've been using pascal case for Java-style, one class/object files, and camel case for files which contain "util" stuff: multiple small classes, extension functions, etc.
If you have a file with a single public/internal member, use that members name - that is typically a class (so PascalCase), but in kotlin could also be a function (camelCase). If you have files with many members, there aren't really conventions yet. The kotlin project uses PascalCase for in most cases here, so you might want to follow that.
Unfortunately, Kotlin is too new to have much material aimed at beginner programmers, it's almost all aimed at Java developers making the switch to Kotlin. I learned Java a long time ago. When I was learning it I tried and failed with several books (most notably O'Reilly's book), then I found the first edition of [The Java Programming Language](https://www.amazon.com/Java-Programming-Language-4th/dp/0321349806), and suddenly it all clicked into place easily. The 4th edition of this book is a few years old (and it's unclear whether the 5th edition actually exists yet - I can't find it anywhere) - but this probably won't matter as a starter language. Spend some time with that book, then switch to Kotlin (the Kotlin website itself provides good documentation, and Kotlin is simpler than Java in some important ways - eg. how it handles "generics").
Definitely Gradle, it has been replacing Maven slowly but surely for years.
At the moment, the kotlin ecosystem is not sufficiently independent from java for this. It is a better idea to learn basic Java and then move to kotlin. Much of the standard library is the same, so it may be possible to move on to kotlin once you can read java immediately, depending on how well you can grasp it.
I try to have one class per file and to name the file after the class. For extension methods, say on the `String` class, I'd call the file `Strings.kt`. Lower-case file for other functions.
Thanks! So that particular book did a good job with the conceptual stuff? 
I know! Even though these are relatively minor things by themselves, the ease of punctuation and the optional variable types alone make it so much nicer to to just scribble something out and try it!
It really did for me. Stuff that seemed arbitrary and didn't make sense in the other books were explained in an intuitive and logical way.
Awesome. That's exactly what I'm looking for.
&gt; It's so easy to mingle Kotlin into a Java project and so easy to learn Kotlin as a Java developer, Kotlin doesn't really have a place on anyone's resume or job requirement listings. Who cares? Just as long as people are using it, the rest will follow.
Both are great and I like both. As /u/JustMy42Cents said, they have their places. For most projects I start with Maven to get started - I'm just that more familiar with it and have a personal boiler plate. But I'm slowly moving to Gradle. Gradle is really working its way past Maven and one of the big features for Gradle that's relatively new is hot reloading. Change one Class? That's all that Gradle compiles and reloads shortening build times dramatically. Only thing I don't like with Gradle is the Groovy syntax. Maven is working towards being Gradle-like with Maven Polyglot and if they can work on only compiling what's been changed, then there can be some serious competition between the two. 
You can override `it` with something more appropriate. This is how I usually do it. coll.forEach { item -&gt; item.someColl.forEach{ innerItem -&gt; // your code } }
https://github.com/yole/kotlin-style-guide/issues/10
I usually check ITJobswatch for this data. You can see Kotlin [here](https://www.itjobswatch.co.uk/jobs/uk/kotlin.do). It seems like exponential growth to me. [Scala](https://www.itjobswatch.co.uk/jobs/uk/scala.do) on the other hand is no longer growing. [Clojure](https://www.itjobswatch.co.uk/jobs/uk/clojure.do) is kind of oscillating but Kotlin will surpass Clojure soon if the trend continues.
while not answering your question, i think listOfIds .mapNotNull { id -&gt; listOfObjects.firstOrNull { it.id == id } } // still smells awkward :o .forEach { object -&gt; ... } should do the same but is a more readable (functional) approach ps: you might want to listOfObjects.associateBy { it.id } aswell to create a map of id to object
Thanks, didn't know about `associateBy`. Really impressive to see how many features the std-lib has. *looking at Swift*
Its possible, but probably not worth getting it to interlope with a framework. Me and my team are trying to figure out a way for our "Java" and JS components to share API objects from one source written in Kotlin.
Not quite what you're looking for but you might find [Kweb](http://kweb.io/) interesting. * Build websites in Kotlin * Makes the barrier between web-browser and web-server largely invisible to the programmer * Seamlessly integrates with powerful JavaScript libraries like JQuery, Semantic-UI, and others * Update your web browser instantly in response to code changes * Bind DOM elements in the browser directly to persistent state on the server and have them update automatically, through the [observer](https://en.wikipedia.org/wiki/Observer_pattern) and [data mapper](https://en.m.wikipedia.org/wiki/Data_mapper_pattern) patterns, and following the [single source of truth](https://en.wikipedia.org/wiki/Single_source_of_truth) principle) * Easy to add to an existing project, Kweb is just a library, it doesn't seek to tell you how your project should be organized Disclaimer: This is my project.
How would you use other JS-Frameworks or libs in your project? I see that the kotlin-fullstack sample includes a small wrapper for React. Do we need to write a wrapper/bridge for every JS module we want to use? Are there tools to generate a Kotlin interface from a JS source?
Much like Typescript (via Typings) you would need some kind of wrapper. They are usually pretty lightweight and as KotlinJS matures it'll be nice if a repo like Typings is developed.
Check out my [TodoMVC example project](https://github.com/AppCraft-Projects/todomvc-kotlin), it should be able to get you started.
Check out ts2kt ( https://github.com/Kotlin/ts2kt ), which creates kotlin wrappers from the typescript bindings for javascript libraries.
Seems like a cool library, I'll have to check it out. I've been looking at doing some web work in kotlin, especially to take advantage of the JS compilation.
Why do you think so? Did I miss an important Kotlin feature in AS 3.0? IMHO Kotlin biggest growth opportunity is web development (backend + frontend). Android developers already love Kotlin and its adoption will increase by itself with time.
Also check out https://github.com/Kotlin/kotlin-frontend-plugin which is used by fullstack-sample. Some simple tutorial is here: http://kotlinlang.org/docs/tutorials/javascript/kotlin-to-javascript/kotlin-to-javascript.html Beside this i'm afraid there aren't many tutorials and articles. I guess there is still not enough traction on kotlin-js. But i hope it will change. I've noticed that there will be two sessions at KotlinConf about kotlin-js: * Frontend Kotlin from the trenches * How to build a React app in Kotlin Full descriptions are here: https://kotlinconf.com/sessions/
Do you do anything with Kotlin-to-JS compilation, or is it like Vaadin communicating every browser event back to the server (even those that do nothing with server data)?
It's like Vaadin in that respect, the logic is server-side and it issues instructions to the browser via an efficient websocket connection. In case this is a source of concern, I have an idea about how to make it react to user events without a server round-trip, see [here](https://github.com/kwebio/core/issues/35). I would like to convert the JavaScript parts of it to Kotlin, but for now I just use native JavaScript.
Let me know what you think. Note that Kweb doesn't actually use Kotlin's javascript compilation target, it works more like Vaadin where JavaScript is composed server-side and sent to the client via a websocket.
Interesting! I wonder what coroutine solution you have in mind. You sort of need to capture all side effects - when the event handler performs a database query you would need to detect that and suspend the event handler marking it incapable of eager loading, or continue with the risk of showing outdated results when the handler is supposed to fire. Actually, I don't think it's a bad solution to not do it entirely transparant to the programmer, as the programmer can invariably bypass any checks you do. But coroutines sound very interesting for this purpose! I also wouldn't call it a "problem" per se, it just limits its use. Vaadin has its uses. If you quickly need to make a prototype or site with some forms, even with some interactive or bi-directional things, Vaadin is absolutely amazing. But it's slow, and most of all an absolute pain to debug if something breaks somewhere.
Another full stack example: [password manager](https://github.com/rnentjes/simple-password-manager)
yeah you get this job https://www.cv-library.co.uk/job/206558560/Senior-Software-Engineer-Kotlin /s
I use CamelCase.kt, but also have util.kt for extension methods :S
https://try.kotlinlang.org/ is entirely written in kotlin. Even if it's quite old and using frameworks you wouldn't use now (jquery), it's a good base for a big application. The github project contains all the code. It's quite complicated because it handles kotlin compilation. You should just look at the frontend part: https://github.com/JetBrains/kotlin-web-demo/tree/master/kotlin.web.demo.frontend I'm also currently working on an datavisualization library in kotlin. It's not precisely what you ask for but it can give you some hints about the builds: https://github.com/data2viz/data2viz
More info in the original post: https://www.reddit.com/r/androiddev/comments/72p908/kotlin_serialization_libraryplugin_v01_prototype/
Learn Java first. Then learn Kotlin.
I keep hearing dev-types talk about various reasons Java apparently sucks. Will I be learning bad habits if I learn Java first?
I'm confused, this sounds like Gson but with alternative serialization targets, but what is the purpose of the intellij and gradle plugins? Why not just the runtime library?
The problem with these stats is that they don't distinguish between Kotlin in the job title and Kotlin as a "nice to have" addition to a Java job post. Indeed.com has an API with which you can specify inclusion in the job title. I think this is a better adoption metric.
Looks like the compiler plugin does codegen to eliminate as much runtime reflection as necessary.
Kotlin is too new for it to be a requirement. I know most companies I talk to would not limit their pool to those already experienced in kotlin. They expect java Devs to learn on the job. 
You might not need jQuery
It doesn't require jQuery, it just supports it as an optional plugin.
`it@listOfIds` also works, but you probably shouldn't use it, I can't even find any documentation for it. Just name the parameter like the top comment says.
Kweb is somewhat based on the observation that most modern rich webapps are really just providing an in-browser view of state stored on the server, and almost any interaction with the webapp requires an update to this state. Consider Facebook, as an example. Almost every interaction with Facebook results in communication with the server, often waiting for a server response prior to any UI change being completed. This can be noticed if you really pay attention, but it doesn't seem to adversely affect the user experience. So, while it is natural to worry about this approach of keeping almost all of the logic server-side, my hope is that it will actually work quite nicely in practice. In particular, my hope is that Kweb's lightweight nature will help it avoid the slowness that has proved to be a problem for Vaadin. &gt; Interesting! I wonder what coroutine solution you have in mind. You sort of need to capture all side effects - when the event handler performs a database query you would need to detect that and suspend the event handler marking it incapable of eager loading, or continue with the risk of showing outdated results when the handler is supposed to fire. My solution may not be quite as nice as you're imagining :) On the event handling issue, by default event handlers would be handled server-side, so: button.on.click { label.text("button clicked") database.incrementClickCount() } This just works, the user clicks, a websocket message is sent to the server which responds with an instruction to modify the label text while also updating the server-side database. The disadvantage is a short delay before the label is updated (perhaps 50ms but could be longer on a slow Internet connection). My hope is that this isn't a significant problem since most browser-side widgets already incorporate visual feedback for the user when actions are taken like pressing a button. However, I think it would be valuable to have a way around this should it prove desirable. The improvement would be to support an "immediate" way to specify an event handler. I'm not sure of the best syntax yet, but without coroutines perhaps something like: button.on.click.immediate { spinner.enable() }.then { database.incrementClickCount() spinner.disable() checkMark.enable() } Here the spinner enabling is sent to the browser such that this occurs before (or in parallel with) the transmission of the event to the server - so there should be no perceivable delay for the user. Gotchas include that you need to be careful what you do in the `immediate` block, because this kotlin block is executed once when the page renders, and then the resultant JavaScript might be executed multiple times when the button is clicked. You can't query mutable state from within this block, and you definitely shouldn't mutate any server-side state. It should really be limited to mutating the client-DOM to provide visual feedback to the user (possibly something intermediate like a spinner). A more advanced version that uses coroutines could look like this: button.on.click.immediate { label.text("button clicked") event() database.incrementClickCount() } This does the same as the previous code, but both the "immediate" and the "per-event" code are now within the same block. But, to be clear, I'm really not yet sure of the best way to do this, the approach using coroutines might actually be worse, and I think there will be some gotchas for the programmer no matter how we do it (unless they just stick to the vanilla server-side approach). Anyway, I'm really hoping to get some other people interested in helping me with this - I think it's far enough along to show that it's an interesting approach, but not so far along that it's not open to other's ideas about how to change and improve any aspect of its approach.
Very cool, protobuf support out-of-the-box with almost no boilerplate.
Can kotlin interlope with JavaScript? Haven't heard anything of the sort.
Take the .kt source and have 2 different build steps, one to compile to JS one to compile to a .class file. Might work, really just a concept now but would be great for maintainability if we got it to work.
Interesting, have you found any elaboration on how this works exactly? I have an application where serialization efficiency is quite important.
Java isn't really a bad language people just like to shit on it for being verbose. You won't really learn anything bad by learning Java, in fact I'd say you'll learn a lot of good stuff. It definitely will lay out the foundation for Kotlin programming too.
Wow, this seems very nice, I was testing the example and I was like "whoa, I can do *this* without coding anything in JavaScript?" I even coded a small "update div with the text from the input without needing to click on a button" website https://i.imgur.com/C2Gyy2J.png (ignore that button, I just got the example and edited it) So yeah, thanks for creating Kweb, I'm even thinking on using it on my website just for fun :) One thing that would be nice is more simple examples (like the one I did). But one thing that I noticed... &gt; Easy to add to an existing project, Kweb is just a library, it doesn't seek to tell you how your project should be organized But I still need to drop my current website framework (Jooby) and replace it with Kweb, right?
Check out mustache 
This is one of the few things I really miss from Groovy
Hey, I'm very happy and flattered to hear that! With Kweb I'm trying to create the web framework that I always wished existed. I'm glad someone else agrees :) I definitely need more examples, Kweb is a little under-documented right now. [This](https://github.com/kwebio/kweb-demo/blob/master/src/main/kotlin/io/kweb/demo/joker.kt) is probably the most elaborate example (you can clone the repo its in and play with it). It demonstrates the routing functionality and bindable state, and also shows how [Shoebox](https://github.com/kwebio/shoebox) can be used with Kweb. One reason I haven't yet is that I'm not 100% sure I've figured out best practices for organizing code, specifically the best way to modularize it. It would be really great to have some other people to discuss it with \*nudge* ;) &gt; But I still need to drop my current website framework (Jooby) and replace it with Kweb, right? Hmm, I hadn't heard of Jooby before, but it seems similar to [Ktor](https://github.com/Kotlin/ktor), which is the framework that Kweb is built on (it mostly just handles the HTTP and Websockets protocols). If it was really important to you might be able to swap out Jooby with Ktor, but I don't know if there would be any benefit to doing that. Please don't hesitate to let me know if you have any questions or other feedback, and if you're interested in contributing to the project that would be even better, there is a [lot](https://github.com/Kotlin/ktor/issues) to do :)
And I bet it would be a lot higher if Kotlin wasn't so easy to use. I barely have to search for Kotlin-specific issues on SO because the language is so well designed, it just works as expected most of the time.
I think this is an important step forward for the use of Kotlin not only on Android, but also in enterprise software.
&gt; Hmm, I hadn't heard of Jooby before, but it seems similar to Ktor, which is the framework that Kweb is built on (it mostly just handles the HTTP and Websockets protocols). If it was really important to you might be able to swap out Jooby with Ktor, but I don't know if there would be any benefit to doing that. Yeah I was wondering if I could just add Kweb and not worry about rewriting my entire website... but I guess I need to rewrite it (well, I was postponing it for too much time, I guess I should start rewriting soon :P) And another question: Would I be able to use an templating engine instead of coding everything in Kotlin? (Of course I would need to code the JavaScript stuff with Kweb in Kotlin, but what about stuff that doesn't need to be done with JavaScript?)
The linked article seems to imply there aren't any dedicated Kotlin assertion libraries, but I know of two others off the top of my head: - [Expekt](http://winterbe.github.io/expekt/) - [Kluent](https://markusamshove.github.io/Kluent/)
&gt; expect fun &gt; actual fun I already like reading multiplatform code
&gt; We’ve added a new reflection API allowing you to check whether a lateinit variable has been initialized Anyone know why it's using reflection to check? And would there be any performance hits on Android compared to try catch?
What differentiates this from the REPL described [here](https://kotlinlang.org/docs/tutorials/command-line.html)?
There's also [kscript](https://github.com/holgerbrandl/kscript) which is much more elaborate and even lets you pull maven dependencies.
.
How does this compare to Hamkrest? 
Sounds like null pointers all over again.
In general, I don't like that code. It does not convey the intention. It appears to me that you want to get all objects from a list of objects that have an Id which exists in the some Id-list. If so, write it like that! Pseudo as I'm not familiar with Kotlin: `listOfObjects.filter{ listOfIds.contains(it.id) }` Unless performance is extremely critical I like this code much better as it is way easier to read. Also I suppose you have not multiple Ids in your list of Ids right? If so, *please* use a Set, not a list. This will vastly improve performance *and* will make the intention much more clear *and* will ever offer you extended functionality and safety in set operations.
It's an intrinsic, meaning the generated code is optimized. If you think about it, `lateinit` properties are just generated as fields and accessors. All you need to do in order to check if the property is initialized in the bytecode is to test if the backing field is `!= null`. Kotlin has other kinds of "reflection" that are based on code generation and not metadata introspection at runtime. E.g. `val name = ::myFunction.name` will load a constant string in the bytecode because at compile time the name of the method is known.
No, it's not. Please read https://www.reddit.com/r/Kotlin/comments/739imj/kotlin_12_beta_is_out/dnpovw8/
Have they added array literals yet? I think kotlin is the only major language that doesn't have them. It's pretty ridiculous.
This is where kotlin really shines. You can create a type safe DSL to template out files. https://github.com/Kotlin/kotlinx.html https://github.com/olegcherr/Aza-Kotlin-CSS
Java???
http://cs-fundamentals.com/tech-interview/java/java-array-literals.php
Yeesh...read that as Collection literals...facepalm*
Is it really that hard to type arrayOf(put, your, elements, here)?
Whenever building large nested structures, yes particularly when messing with json. It's just so odd that kotlin doesn't support it, every other popular language known to man does (even ancient ones like C and C++) , and kotlin isn't doing anything particularly original or interesting that it should alone be the exception. Kotlin is overall just a very practical language, it should have this, even for the small bump in readability it provides. 
Might help if you elaborate a bit next time. From Wikipedia: &gt;Tacit programming (point-free programming) is a programming paradigm in which a function definition does not include information regarding its arguments, using combinators and function composition [...] instead of variables. This is not natively supported, I think the closest you'll get is some composition: https://github.com/MarioAriasC/funKTionale/blob/master/funktionale-composition/src/main/kotlin/org/funktionale/composition/namespace.kt Eg. something like this: fun foo(a: String): Int = ... fun bar(b: Int): Double = ... val myFun = ::bar compose ::foo `myFun` doesn't include any type or parameter information.
Thanks, I added an example to the original post. This is quite close to what I've been looking for!
* What would you do differently if would start Kotlin today? * What is your favorite Kotlin feature? * What was the hardest trad-off you had to make? * What language feature would have you liked to implement but didn't? * What future language feature will have the biggest impact? 
Is the Kotlin parser written by hand, or generated by a tool like ANTLR? In your experience, what are the pros and cons of both approaches?
I messed around with it and I feel like I've found a convenient way to express such a thing using lambdas: val toUpperCase = { s: String -&gt; s.toUpperCase() } val toCharArray = { s: String -&gt; s.toCharArray() } infix fun &lt;init, mid, result&gt; ((mid) -&gt; result).compose(func: (init) -&gt; mid): (init) -&gt; result = { a: init -&gt; this(func(a)) } val toUpperCaseCharArray = toCharArray compose toUpperCase fun main(args: Array&lt;String&gt;) = toUpperCaseCharArray("hey").forEach { print("['$it'], ") } It's a super fun style. If you have anything to add, please do
What are the plans for Kotlin metaprograming? (things like AST transfomations on groovy)
I am a beginner in programming so forgive me if my questions are stupid but what are your future plans to get more programmers to adopt the language? Are there any plans to expand the help available to people new to programming in general?
It's a handwritten [recursive descent parser](https://en.wikipedia.org/wiki/Recursive_descent_parser), the main code is in [this file](https://github.com/JetBrains/kotlin/blob/master/compiler/frontend/src/org/jetbrains/kotlin/parsing/KotlinParsing.java), implementing the [context-free grammer](https://en.wikipedia.org/wiki/Context-free_grammar?wprov=sfla1) as described [here](https://kotlinlang.org/docs/reference/grammar.html). I think generating parsers is not that common in actual programming languages, it's often faster, easier and more maintainable to just write it yourself. 
Great questions!
This is a good intro course: https://www.safaribooksonline.com/library/view/introduction-to-kotlin/9781491964125/
I've introduced Kotlin to my team, and we're using it readily now, but I can see that many folks, including myself, fall back on Java idiomatic expressions when I feel there's likely a better way. Learning from other's code tends to be the best way to really grasp the nuances of the language. Are there any open source projects, besides tutorials, that you've seen or been involved with that you feel exemplify idiomatic Kotlin?
I wonder where Java is used for it to be in the #3 spot.
Every second server and every second smartphone (Edited - hit save prematurely :-) )
What are the plans of Kotlin with Flutter? Since the Flutter teanm has no intention on supporting Kotlin, but the Android team is excited on supporting it, would it be a let down for future mobile devs? 
Do Kotlin have plans to implement it's own stdlib(and not use java libs - collections for example) or Kotlin and Java are together forever?
About [85% of smartphones](https://www.idc.com/promo/smartphone-market-share/os) even! 
Kotlin seems to take some inspiration from Scala (val/var keywords and companion objects, for example). Are there other Scala features you miss in practice, but adopting them would make Kotlin too complicated?
&gt; I think generating parsers is not that common in actual programming languages, it's often faster, easier and more maintainable to just write it yourself. Thanks, but I would still love to hear Andrey's perspective on this :)
And when are we getting it ;)
Another good stat would be "users here now" and also the post frequency, and are those posts showcasing a new lib rather than a beginner type question. There's probably quite a lot of people subscribe to some channel but then hardly look. Just a thought not a criticism. I've noticed some programming subs don't show users here now, is this because they have not enabled the feature but its still part of the api ?. You could even go as far as sentiment analysis :). Are they a happy bunch or are they in disagreement / confused. 
Of course, I'd be interested as well.
The important indicator is the number of job posts. Programmers talk about many things.
Yes, as you saw, it can be emulated, but point free functions is not a very useful concept overall since it can only be used for functions that take one argument. Even for those, I find it clearer to write the argument and, more importantly, its type. 
I don't think it is possible to do this as elegantly as in FP-inclined languages which support currying and "functions as data" paradigm. That is you can, but it will look unnatural and cumbersome in Kotlin. By the way I remembered [this talk](https://www.youtube.com/watch?v=seVSlKazsNk) about the point-free style, you may be interested in it.
What's the biggest limitation on the language imposed by Java bytecode that you wish wasn't there? With multiplatform support emerging, how do you avoid future language goals being held back by the need to support more and more platforms?
What is your criteria for a success of the language? In Jetbrains and personal. Something, after what you could retire a happy person.
like this? https://kotlinlang.org/api/latest/jvm/stdlib/index.html
Not quite what parent was thinking. The current Kotlin "stdlib" is mostly just extension functions or thin wrappers around existing JDK code. I think parent is asking for a straight up Kotlin stdlib that can exist independent of the JDK standard library.
Komputation is now available through Maven Central: &lt;dependency&gt; &lt;groupId&gt;com.komputation&lt;/groupId&gt; &lt;artifactId&gt;komputation&lt;/artifactId&gt; &lt;version&gt;0.10.1&lt;/version&gt; &lt;/dependency&gt;
All good points. I was thinking about sentiment analysis just the other day -- there was an article about it over in /r/Ruby -- my feeling's that something like the Stack Overflow survey does a better job than I'd manage. Something for someone else to try though for sure, I'd be interested in the results. Post frequency &amp; number of viewers would be interesting too - but I'd have to hit each subreddit a few times a day to get that, rather than my current once a month effort, and I don't want to wear out my welcome with the reddit guys. :-) So far the number of subscribers has been on every subreddit I've tried, whether it's displayed or had the wording changed, that's been pretty stable for me.
From my experience the jobs on offer by language vary much more by geographical location than over short periods of time - interesting data to be sure, especially in a practical sense, but not what I was interested in looking at. The jobs offered where I live are almost 100% in the top 7 languages on Ripley, &amp; that hasn't changed much over the last 10 years. Go (#8) is yet to appear in a single ad here that I've noticed. Apart from the occasional Erlang or COBOL job I don't think the others come up either. There's a *very* long tail.
With kotlin native you can share some things at least. Albeit in alpha still I think. But in the end I think it depends on what the goal is with your app.
Depends what your app is doing and what targets you need to meet. Xamarin is very versatile and powerful but it may be missing some features you need. That all depends on the application you are making
Too early still, imo
No, I'm talking about independent standart library (as u/meddlepal said). Rigth now if you begginer programmer and want to learn Kotlin you have to learn Java first. I think if Kotlin would have lower coupling with Java - it will be more interesting and not scaring language for newbie. 
Impressive reddit formatting skills. Have an upvote.
Well, thanks! Check out the [Reddit Enhancement Suite](https://redditenhancementsuite.com/) if interested (I'm not affiliated with them though)! You can look at the source of reddit comments with it.
That is good news! Will try it out today. :)
What do you think are the biggest mis-perceptions about Kotlin?
In case you've somehow missed it, you should check out what 1.2 has in store for multiplatform projects: https://blog.jetbrains.com/kotlin/2017/09/kotlin-1-2-beta-is-out/
With reactive architectures becoming more and more popular (especially for GUI and Android programming) one thing I really wish we had (in an official library, or built-into the language standard library) is TRULY immutable collections. Any chance we can get persistent-data-structures in the language, and truly immutable collections?
If you use an IDE like IntelliJ IDEA, you get the code structure as one way of managing a file. You can sort, filter, search etc through that structure. Example from IDEA: [image](https://www.gianttree.de/imagehost/raw_image.php?h=7d80a770e9291984e5dc65dbbac924fa8a8a5581a43623965bf2167d472a10de8ed4c7dc9b75aacc5a5c559297a0a3655dc54b2a1bcfefaf75af0a33acae390a) There you can simply click on the location you want to jump to.
Instead of function composition on static functions (like your `toUpperCase(someString)`), you can use extension functions (`someString.toUpperCase()`). Both `toCharArray` and `toUpperCase` are built-in extension functions, so to compose them is as simple as `myString.toUpperCase().toCharArray()` If you really wanted to combine this into single function you could do: fun String.toUpperCaseCharArray(): CharArray { return this.toUpperCase().toCharArray() } val upperCaseArray = myString.toUpperCaseCharArray() I think this is the more idiomatic approach and for that reason will probably be easier than trying to use the more functional style. 
Thanks, but I search a solution for files that I don't know yet. I need a lib or something.
If you don't have the source: Decompile and use the structure view. But don't expect any good results.
Thank You all for wonderful questions. Much appreciated. Once done, I will post the interview here.
Probably either use the code from idea or the kotlin compiler. Both should be open source. Or write a parser yourself. The syntax tree of kotlin is documented. 
what do you mean by " decompile" ? I will not have the compiled file either. I'm developing an analysis plugin, for any kotlin code file.
https://github.com/vektory79/kotlin-script-parser-test Here you can find PoC of kotlin parsing
Why you even want to run it in command line? If it becomes popular, you will have to develop IDEA plugin for your tool. Why not make your tool a plugin in the first place? 
[removed]
Kotlin has read-only views on mutable collections (for example, `kotlin.collections.List` is such a read-only view). Are there any plans to incorporate truly immutable, persistent collections into the standard library, similar to `clojure.lang.PersistentVector` or `scala.collection.immutable.Vector`?
When is the "deadline" for submitting questions? :)
I've been looking for this kind of library to use in games... aaah... But now I have to start working on games... This looks great, good work guys!
Because when your analysis tool is running on a CI or build server, you won't have an IDE to be checking every commit coming in.
Thanks!
Might I ask what do you need it for? Feels like an [XY problem](http://xyproblem.info/).
Companion objects can extend classes and implement interfaces too, so it's great for metaprogramming.
The only reason for the existence of companion objects is compatibility with java. Same as secondary constructors
Can you give an example of metaprogramming that's possible this way?
Ah, so I guess in a Kotlin-only project, free functions would be somewhat preferrable, because there's a bit less syntactic hassle.
I would start this way: You can use object declarations for singletons. Singletons can be associated with a class -&gt; companion objects that can be referenced with the class name as a convenience. Since you would not compare static methods to singletons in Java, you should not compare kotlin's equivalents. companions are real objects, implementing real interfaces and extending real classes. functions are just functions.
I think he's speaking about the fact that Companion objects are lieterally called "Companion", which means you can check for each class via reflection, if there's a companion object or not. If there is one, you could check if special interfaces are implemented. You could to the same thing in Java, but there is no such strong convention. For example you can implement a Singleton-getter as a static method on a regular class. How is it named? getInstance()? getSingleton()? getSingletonInstance()? And singletons can be implemented with enums as well. How is it named here - INSTANCE? SINGLETON? It's easier with Kotlin, I guess.
No, I don't think so. How would a completely comparable construct look like that is free of Java-bounds? As for compatibility reasons for secondary constructors: Yea, that might be more likely true, as named parameters are a good replacement that Java lacks.
I talked to an engineer at a career fair and he said he was surprised I had Kotlin on my resume. He said theyre starting to use it, and I told him how much I loved the language. Pretty cool.
Maybe I was abit too harsh on the "only because of Java". The only reason I found why we have "companion object" is, that you can put some functionality into a class that does not depend on the instance-data (e.g. Factory-Functions). Top-Level-Functions can replace static methods. Secondary constructors were introduced for Android development: https://blog.jetbrains.com/kotlin/2015/03/kotlin-m11-is-out/
Can you give us a real world example where implementing an Interface/extending a class is beneficial?
Actually doing this right now to allow a class to specify it's default deployment options (using Vert.x). It works well.
As I noted in another answer, I have a setup where a Vert.x verticle class's companion object can implement a certain interface to specify it's default deployment options. 
And a great example of this is [kotlin-logging](https://github.com/MicroUtils/kotlin-logging) where you can have companion object: KLogging() And then throughout the rest of the class you can just use logger.debug{"Some message"} 
I hadn't even thought of that! That's actually really clever.
You'd be surprised how that's even true of a major tech hub like London. Searching Indeed.com's API for title=kotlin in the UK produces 3 results. Elixir and Clojure also have single figure adoption. The tech industry is paradoxically very conservative.
https://github.com/JetBrains/kotlin-native/releases though I'm not %100 sure on why this approach here. fwiw I am considering CGI for my low budget servers via kotlin (they can't run java) using kotlin native.
Hmm, so I see that this can be used to create native executables. But, I'm still hoping someone will chime in to discuss my specific usecase.
look more closely. One of the compiler options is: -produce (-p) {program|LIBRARY|bitcode} Specify output file kind 
Thanks for the reply. One of my concerns is the garbage collection aspect. That is, it's probably straight forward to call a simple Kotlin utility function (ie. pure functions) from C++. But, when dealing with something like a game engine, my concern is data that should be long-lived on the Kotlin side -- Is that supported? Essentially, the interaction between C++ and Kotlin will be something like this: // Live starts in the C++ app. // Initialize the C++ app. int main() { // initialize game engine // Initialize kotlin // enter main loop while(keepGoing) { doPreEngineStuff(); // Between calls, the Kotlin library/vm/engine/whatever needs to keep data that in processed in the previous frame. The garbage collector would need to know when is the proper time to delete such data. It's ok if I have to annotate that data, somehow, to tell the GC that it's used from the calling code (the host). callKotlinCode(maybeSomeTypeOfContextObjectWhereSomeDataIsKeptBetweenCalls); keegGoing = doPostEngineStuff(); } return 0; }
You can always just embed the entire JVM, with functions like `JNI_CreateJavaVM`, and then bridge the code in the normal JNI way (you could do the same with a JavaScript engine such as V8, and use the Kotlin JS target, but I imagine the results would be a lot worse). Usually it's done the other way, where the `main()` function is in the Java (or Kotlin) code, and the C++ part is used as a library, but there's no reason why it wouldn't work like you say. Question is, what are you hoping to gain from this. Moving the data back and forth between C++ and Kotlin will be both a hassle (lot of boilerplate code) and a performance hit. I would just stick to one language at the moment.
&gt;fwiw I am considering CGI for my low budget servers via kotlin (they can't run java) using kotlin native. Are you sure they can't run Java? Java can run in some pretty constrained environments (just limit the maximum heap size) and Kotlin Native is still very much [experimental technology](https://github.com/JetBrains/kotlin-native/blob/master/RELEASE_NOTES.md#known-limitations), where they don't care much about performance yet.
[That's not a shared library](https://github.com/JetBrains/kotlin-native/blob/master/FAQ.md).
Use [Wren](https://github.com/munificent/wren) 
Damn that looks slick.
Ah okay. Yes, it seems that people Just dont have other usecases than static methods, which can be replaced with top Level functions as Well.
ah thx for that
everything I've tried has failed on hello world, dunno. kotlin native didn't, and loaded and executed very quickly so I may experiment further with it.
sorry Im really a kotlin noob, so I have no idea how it will work when that tightly coupled. What about a socket interface between them? Or shared input and output memory file device (i.e. /tmp/?? )Whichever is more performant? skip the whole dll thing, there are other ways they can communicate (stdin/out?) https://stackoverflow.com/questions/35421699/how-to-invoke-external-command-from-within-kotlin-code so launch the C stuff from kotlin, and keep it resident, and communicate with it using an input and output stream from kotlin tied to C's stdout/stdin? Just a handshaking matter at that point.
If you'd like some kind of example, I have a demo for my library running at http://graphql.holak.net/. It uses [spark](http://sparkjava.com/) as the web server. Simply running [`./gradlew build`](https://github.com/peterholak/graphql-ws-kotlin/blob/master/example/docker/install.sh) packages it into a .tar file with a `bin/&lt;project-name&gt;` executable that you can just run. The .tar file will be in `build/distributions/` directory once you run the gradle `build` task. This is all just the *default gradle configuration generated by IntelliJ*. --- I run it with the `JAVA_OPTS` environment variable set to `-Xmx100m` to set the maximum heap size pretty low, and it works fine (though I have extremely little traffic). You can have it listening on localhost only, and use an nginx config that proxies requests to a specific domain to the app. It can be auto-started with a simple [systemd unit file](https://github.com/peterholak/graphql-ws-kotlin/blob/master/example/docker/graphql-ws-kotlin.service). I run it in a Docker container, but that's not necessary.
fyi the operating environment for this is those inexpensive little linux webhosting packages that are suited for php/python/cgi/perl (i.e. godaddy/1&amp;1/etc). I can just have the client sign up and I slap something together and get out, and they have an ongoing $3/month bill or something for the hosting.
Using scripting languages in game engines has been a thing, like, forever. Look it up.
I appreciate the answer, but all those options are non-starters. Those methods of communication would tank the performance.
Are you hoping for shared memory between kotlin and C? I'm not sure it is going to get much faster than stdout/stdin as streams to kotlin, and still allow C to be decoupled from GC. Note there is a way to leave the C program running here so it is just one call to runtime exec to get it started.
I'm just saying that with Kotlin, you're going to have to compile the code anyway (into `.class` files) before your C++ app can load it, so if your goal is to be able to rapidly iterate on level logic (reload a level while the game is running, etc.), this might go against that goal. Sure, it is possible, but you might as well just use C++ dynamic libraries at that point and save yourself all the cpp-vector-to-java-list-and-back conversions, have easier to setup debugging, etc. If you don't mind that, and your goal is mainly to have a more user-friendly language for the scripts, then the JVM solution is probably a good one. You might even use a more light-weight limited VM such as [Avian](https://readytalk.github.io/avian/), though it will probably be less polished and documented. If you don't want to write all the boilerplate bridge code, you can use a generator like [djinni](https://github.com/dropbox/djinni).
if there's one thing I've learned in my career, it's that you never say forever to an engineer.
You might want to look into how gradle's kotlin dsl is working
No need for a Companion Object. See: https://stackoverflow.com/a/34462577/4706743 It can be as simple as `val logger = logger()` inside a class
Can you elaborate more on this? How does it work afterwards? Does Vert.x check if your companion implements a specific interface and then uses the provided options instead of default ones?
After giving it a second thought, companion object weren't introduced specifically for compatibility with Java. Basically they are the same as top level functions, but both have their unique features. For example a companion object can implement an interface. (See hpernpeintern's answers) And top-level-functions can be used to "mimick" factories, e.g. class Foo(val s: String) fun Foo(val i: Int) = Foo(i.toString()) fun Foo(val b: Boolean) = Foo(b.toString()) I prefer top-level functions, because I have done some functional programming in the past
I have a "deployment manager" that checks the companion object. If it finds that the CO implements the interface, then it uses values from the CO to build the deployment options. I'll try to post some code later if I don't forget. 
Thats an interesting use-case. Never thought about that before
Here's some example code that shows the interface in action (as well as using Kodein to create Verticles): https://gitlab.com/snippets/1678203
Here's some example code that shows the interface in action (as well as using Kodein to create Verticles): https://gitlab.com/snippets/1678203
Basically, my wish is to use Kotlin as a scripting language because it hits all the buckets that are important to me (nice syntax, pragmatism, backing from big player, etc); I'm flexible in the way I could go about embedding it (within reason). I've been thinking about it today, and the following occurred to me. I'm not very familiar with Kotlin, yet, so I'm not sure how feasible it is: - Embed Google's V8 into the game engine. This will be the scripting runtime. - Compile Kotlin code to JavaScript - Load the generated JS code into the game engine and run it using V8. Is the JS generated by Kotlin designed to be used exclusively in web environments (client or server), or is the code generic enough to be used in a non-web context, such as a game engine? From the online docs, it sounds like it's web-centric.
&gt; Jump into Kotlin, wait an a-hole company to buy the language owner and there we go again. Doubt that someone will be able to buy JetBrains at this point. &gt; Combine that with the fact that Google had multiple languages under works internally already. None of them are on JVM. &gt; We’ve seen first hand the difficulties iOS legacy projects written in ObjC cause to our customers. There’s no way we want that to happen in Android projects we’re involved. Swift is entirely different approach, Kotlin has excellent interop with Java, so there's almost no problems with having legacy project in Java with new parts written in Kotlin.
Such an elegant language
I know it's pr talk but I was expecting to see recover functions in "innovative" features
If by "local", you mean the same machine, you can just include other projects locally with gradle, no server required. If it's a public project hosted on GitHub, you can use https://jitpack.io/. Otherwise, yeah, you can set up a maven repository. Here's a guide how to setup one https://inthecheesefactory.com/blog/how-to-setup-private-maven-repository/en. There are also docker containers that can simplify the setup. Or you can pay for a service that will host a private repository for you.
I'd like to see the performance of a pure Kotlin project vs a pure Java project.
You could as Well use your local maven repository... Install your lib locally, depend on it in the other project and you are done. No need for a Server if you stay on one machine.
Local I mean group - LAN local. Thanks! Also found this too http://www.yegor256.com/2015/09/07/maven-repository-amazon-s3.html
I suppose all you have to do is write it twice and measure. Maybe a team is migrating from Java and could benchmark features before and after migration.
Sorry for the delayed reply. &gt; Would I be able to use an templating engine instead of coding everything in Kotlin? (Of course I would need to code the JavaScript stuff with Kweb in Kotlin, but what about stuff that doesn't need to be done with JavaScript?) Kweb is flexible, but I think using a templating engine might negate some of the important benefits that Kweb provides, since it is designed such that you can directly bind persistent data on the back-end to DOM elements. So, I'd have to recommend against that.
 drawRectangle(Rectangle([10, 10], [50, 50])) That might be easier to write, but it hurts readability. If you **really** want to do this just overload drawRectangle, no need to make Kotlin's syntax any more complicated: drawRectangle(10, 10, 50, 50) If you're interested in building rich websites with Kotlin you might find [Kweb](http://kweb.io/) interesting (disclaimer: It's my project). 
Personally I would like something like **kwargs from Python in Kotlin. World be hard to use with maps combined with Kotlin's null safety though.
You're right in that in this example, it doesn't make that much sense. I just used it because it's short. The next one with `style` and the DSLs explains it a bit better (not having to write `style = style { ... }`). A similar case would be listOf(Position(10, 10), Position(10, 20), Position(30, 30)) vs. listOf&lt;Position&gt;([10, 10], [10, 20], [30, 30]) which is similar to what Go has, but probably not that common in practice. It's the DSLs where it really shines. I'll update the article with some better examples. The library I'm talking about is also not for web development - it's for desktop UI (that's why it also supports Kotlin Native). EDIT: So I updated the article and removed a few sections that just made it longer without adding much to it.
Please take a look at sonatype nexus or jfrog artifactory. Both have docker images that simplify running within your network. If you want filesystem local, gradle has composite builds.
Yeah, I could see something along those lines be useful - although adding a feature like this can be a minefield of unintended consequences, making it a lot more difficult than people imagine.
Do you have an example use case for it? It seems like a very dynamic thing, where it's impossible to even check if all the necessary keys are in the map, or if they are of the correct type.
You can have two data classes that have some overlapping variables which would be safe. Another example is calling a function with argument names in common with a data class' members. Eg: data class Person(val name: String, val age: Int) data class Employee(val name: String, val age: Int, val role: String) val steve = Person("Steve", 30) val employee = Employee(**steve, role = "Janitor") I bumped into a scenario like that but instead picture *EIGHT* common variables :P And yes, for my little example inheritance makes sense but not in my real world occurrence.
What do you think about using git? https://jeroenmols.com/blog/2016/02/05/wagongit/
(disclaimer: I'm fairly new to Kotlin, but here are my two cents anyway) Speaking of point number 1: couldn't you achieve something like that (maybe slightly less readable) if you just overload the constructors? On a side note, I personally like what Rust does in similar situation -- you can go with traits (namely `Into`) that allow you to convert almost any structure (with given trait implementation) into any other and pass that struct as parameter to your function. Maybe that can be mimicked with use of functional interfaces? Something like `ConvertableFrom&lt;T&gt;`, with implementations for any `T` you find necessary. This, however, won't be readable enough given that Kotlin doesn't have a lot of syntactic sugar for collections.
I see. Yeah, in that case, it *would* be possible for data classes. I've also run into some cases where it feels like a language with structural typing would be a better fit.
&gt;Speaking of point number 1: couldn't you achieve something like that (maybe slightly less readable) if you just overload the constructors? I don't think that would help much in this case. val boxStyle = style { border = Borders( width = EdgeSizes(top = 2, right = 3, bottom = 3, left = 2), color = EdgeColors( top = 0xAAAAAA.color, left = 0xAAAAAA.color, bottom = 0x444444.color, right = 0x444444.color ) ) } I do have a few overloaded versions, but it's a lot of boilerplate, plus you have to anticipate all of the possible variations.
You can use copy function: val jack = User(name = "Jack", age = 1) val olderJack = jack.copy(age = 2) Defined for all data classes https://kotlinlang.org/docs/reference/data-classes.html
That's only if they're exactly the same type (e.g. both are User).
I am actually doing that now. It will definitely be good to post the comparison. It’s a spring boot rest api with a MySQL backend. I am using it to try and convince my team/boss to switch to Kotlin.
Git isn’t designed to handle binaries. While you can store them there, your clone operations could become very slow. I inherited a codebase that put dependencies into git once, and spent a couple of days rewriting git history to make the repository usable.
But that aren't arrays anymore, they are just parameters.... Why use [] and not ()?
Might be worth noting that the Kotlin compiler won't generate the null checks if it knows that the code can't be called from Java - so, any private functions for example will not have that overhead.
In essence what you’re asking for is for the compiler to take the known type of an parameter, find a constructor for that type that takes the arguments specified in a tuple, and inject an invocation of that constructor with those arguments?
And to fail at compile time if there is not only one candidate 
Yes. I mentioned that it could slow down compilation if there are a lot of overloads of the function you're placing that argument into (because then you have to look at constructors of many different classes). But I believe that's a fairly rare case, most of the time, there will be just one version, so it won't be that different from what the compiler already does. (Plus you could always just specify an argument name if you have many overloads, or not use this feature in that case.)
Clarified in the post, thanks
Thanks for this, a very clear and to-the-point tutorial. I would be interested to see the JS compiled from Kotlin also though.
As in generating the client JavaScript with Kotlin? I'm generally not a big fan of x-to-javascript-compilation, so I haven't looked into how you'd do that.
Fair enough, it's just nice to leverage all the type-safe Kotlin-goodness on the client. I think it's going to be quite popular.
And that the check can be completely disabled as it seems https://discuss.kotlinlang.org/t/run-time-null-checks-and-performance/2086/12
Yeah, I don't think [] should be used.
Yeah, that was already mentioned in the article so I didn't repeat it :)
There's [a section](https://medium.com/@peterholak/in-an-ideal-world-features-i-miss-in-kotlin-7e7f548f5bed#ce36) addressing this.
Ah, I missed that.
There's just not enough kinds of brackets in the world 😃. Based on the discussions I've read so far, I'm not sure that collection literals are coming, ever, so that would leave `[]` free. Although to be real, this feature is not coming either, so it's all just hypothetical anyway.
Good to know of some of these, speaking as a person who is not only still kind of new to Kotlin, but as one who has chosen this sword to die on professionally lately 
THANK YOU for pointing out that there is an official example for runtime kotlin compilation. I didn't have too many problems building the module. Just do a mvn verify in kotlin-master\libraries\examples\kotlin-jsr223-local-example . I realized that they use the project version for kotlin dependency versions - I changed the version to 1.1.3-2 because I had those dependencies locally already. Worked like a charm. Since I "tried" to build the whole project (root folder) with gradle, I can't say exactly if I built some other dependencies and installed them accidentally into my local maven repo. If you give us a hint what your current problem is (error msg), maybe we can help you further.
Ah I'm sorry, I overlooked it :) Would have been nice if the actual flag was stated, or if my link was embedded.
@3: In my opinion, this is not the same as with type inference. With type inference, I have an assignment where I can specify a variable name, that most of the times indicates nearly/exactly what the variable contains - making explicit type declaration effectively clutter. While the most important thing in fact is the instantiated class' name, which is not omitted here. Omitting class names on the other hand, makes constructor calls look like array literals or add another different use of braces...both aspects are problematic. But for me personally, the worst is that it creates confusion: If there are multiple implementations of an interface with same/similar constructor arguments, which one is used? The potential benefit of such a feature doesn't outweight the disadvantages in my opinion.
@4: I have to say that I'm sorry first, because you stated that you can't think of many points agoainst it, but I have to disappoint you again :) Default values should be a reasonable configuration.... a type parameter is used to generify a class, so that you don't have to deal with Objects or Anys - having Any or Object as default value is the worst thing you can do with generics. Excplicitely demanding the user to specify a type is the only right thing to do with generics. If it is that problematic for the user, he can do a typedef with a single line of code.
There has been a long discussion about this in [TypeScript](https://github.com/Microsoft/TypeScript/issues/2175) and they eventually [added it](https://blogs.msdn.microsoft.com/typescript/2017/04/27/announcing-typescript-2-3/#default-type-arguments), quoting this exact React example. Rust also added it after a [proposal](https://github.com/rust-lang/rfcs/blob/master/text/0213-defaulted-type-params.md#why-defaulted-type-parameters) and a [discussion](https://github.com/rust-lang/rust/issues/27336). You're right in that it's easy to just have a type alias and that using this with `Any` is a bad idea, that's why I said it doesn't really solve any pressing issue.
&gt;If there are multiple implementations of an interface with same/similar constructor arguments, which one is used? It would not work with interfaces at all, only with concrete types. And if there are two overloaded functions that each take a different type with the same constructor parameters, that would be a compilation error. &gt;It has similar problems as structural typing After using TypeScript a good deal, both at work and in my personal projects, I find people's fears about structural typing way overblown. Yes, you could theoretically pass in the wrong object in a way that wasn't intended, but in practice, this pretty much never happens - it has never happened to me. Unless you were talking about a different problem with it... &gt;The potential benefit of such a feature doesn't outweight the disadvantages in my opinion. You're probably right. But the lack of it still makes it difficult to have nice, concise DSLs. Outside of DSLs and maybe that `listOf&lt;Position&gt;` case, I wouldn't use it myself either.
Could you perhaps actually test whether instatiating the `StringBuilder` with the first string is actually faster?
How does Jooby compare to [vert.x](http://vertx.io/)? I also did a research for a backend technology to finally get rid of Spring and I also checked [benchmarks](https://www.techempower.com/benchmarks/) and in the end I opted to use **vert.x**. It works like node.js on top of *Netty* and it also supports reactive exetensions out of the box (plus an array of fancy stuff). Did you bump into vert.x as well? If yes why did you not consider it? *Note: I did not find Jooby on the benchmarks page nor during my research.*
Vert.x it is nice and good framework. Jooby differs in its simplicity and the extensive number of modules. For benchmark it depends on what you do. Jooby seems slow in the single `Hello World` text compared to Vert.x. That's bc Jooby doesn't allow you to run your handler in the IO/Event loop thread. If you look at any of the database tests, either there is no difference or Jooby [performs better](https://www.techempower.com/benchmarks/previews/round15/#section=data-r15&amp;hw=ph&amp;test=fortune&amp;l=zik0vz)
&gt; performs better Those are **preliminary** results. If you check [Round14](https://www.techempower.com/benchmarks) you can see that in **none** of the categories does Jooby perform better and in addition in some categories Jooby is not even present. What do you mean by `extensive number of modules`? vert.x also has a lot of modules and you can use almost all JVM languages idomatically with vert.x.
That's correct. In R14 Jooby went with requery, while all other framework were using raw-jdbc. In R15 Jooby moves to raw-jdbc and add all the missing tests
You did not address my other and arguably more important questions.
Didn't answer bc it is hard to get an agreement and already mentioned Vert.x it is a nice framework. Still, believe Jooby is easy to learn and has [lot more modules](https://github.com/jooby-project/jooby/tree/master/modules). Yes, I'm the author.
I see. My problem is that I've already invested time into learning how vert.x works. If I am to use Jooby I need to see why Jooby is better than vert.x or simply what are the pros and cons. Is there some kind of comparison chart for me to peruse?
Vert.x worth it. I wrote about [why Jooby](https://medium.com/@espina.edgar/java-micro-frameworks-why-jooby-59f0b346e819), but there isn't any chart comparing Jooby with any other alternative.
I’ll add it to the list!
&gt; val means readonly. It's even less strong than Javas final because a val property doesn't need to return the same thing everytime. Not sure if I'm misunderstanding or not, but did you mean to say val is *more* strong than Java's final (instead of *less* strong)? Sorry, it's been a long day today, so not sure I'm reading this sentence too quickly or not.
I wrote an answer to your question [on Medium](https://medium.com/@Niklas_L/good-question-great-you-like-vert-x-if-it-fits-your-requirements-it-is-the-right-tool-for-you-192032f11cb1). My advice would be: Don't be frightened by some other persons opinion on the Internet. I didn't write the post to persuade you to use Jooby, I only want to tell others about my experience and raise awareness for Kotlin and Jooby, just because I think it is a good combination to try out and consider. Vert.x is a mature and stable framework and I heard quite some better known Java people speak highly of it on conferences as well, so by all means go with Vert.x if you like it. There is no wrong choice here. 
Preliminary results suggest maybe 5% faster for the 3 string concatenation benchmarked
I suppose that you could write a function that would use reified generics to deduce the required type and then inspect its own varargs to find a matching constructor...
I think that you misinterpreted my comment. I do not plan to switch from vert.x since I'm fine with it and I am also not frightened by some opinions. What I wanted to highlight above is that in order to get people use a library you have written you need to convince them and lower the barriers of entry. And IMHO you can only do that by supplying concrete evidences, case studies and comparisons plus migration guides. Been there, done that.
Did you look into SparkJava or Javalin?
You don't need case studies, concrete evidences and comparisons to choose a framework. You just try both and stick with what you like, it can't be any simpler than that. If you find yourself spending a lot of time with any of Java framework, its a flag. Modern Java frameworks has very low barrier to entry and in the case of Jooby, it took only just a 1-2 hrs for me to get into the groove.
No, I meant less strong. When you have a Java final field you're guaranteed to always get the same object when you query it (unless you do weird stuff with reflection and so on). A Kotlin val property doesn't have this guarantee, because it's more like a getter and can return something different each time. 
Ah, now I see. Thanks!
From the article: &gt; I tried out several different web-frameworks for the JVM, including Grails, Spring (Spring-Boot), SparkJava, Dropwizard, Jooby and others. 
Do you use it on mobile?
Not yet, strictly small web apps and api’s 
I also use it on the backend. :)
I didn't notice Javalin before. Judging from the commits on GitHub work on it has only begun in May this year and I looked at the Framework between February and March. What I dislike about SparkJava as well as Javalin is the way they handle the response, which is basically how Servlets do it as well, by providing a Response instance to the handler. Jooby supports that as well, but I like the alternative approach of simply returning the result from the handler function. Also it uses the same `send()` and `end()` methods in the end, the handler feels like a pure function that way. What I really don't like about SparkJava is that it is basically constructing the app in a global static way, correct? That makes it really hard to write good tests which is probably why the particular part of the documentation in SparkJava is so complicated: http://sparkjava.com/tutorials/unit-testing Another thing I would see in favor of Jooby is that it is not only a lightweight micro-framework, but due to the large amount of modules it can be extended to a full-stack framework as well, or you can also decide to do it on your own if you don't want to use the existing modules.
&gt; What I really don't like about SparkJava is that it is basically constructing the app in a global static way, correct? There is an instance api, so you can do `Service spark = Service.ignite().get(...).post(...)` etc. It's not heavily promoted though. &gt; One thing I dislike about SparkJava as well as Javalin is the way they handle the response, which is basically how Servlets do it as well, by providing a response instance to the handler and providing send() and end() functions. Jooby supports that as well, but I like the alternative approach of simply returning the result from the handler function. In Spark you're also supposed to use `return` for routes (but not filters). In Javalin I removed returns in favor of only allowing explicit mutating of the response via functions, because that's a lot more "honest". When you use `return` in a lot of web-frameworks you're just setting a temporary result that can be altered before it's written to the client. I wanted this to be clear in Javalin, so I decided to have a function for setting the result instead (I also thought it would be good to keep before-, after-, endpoint- and error-handlers all consistent). I'm not sure if it was the right decision, but it makes a lot more sense to me.
&gt; There is an instance api, so you can do Service spark = Service.ignite().get(...).post(...) etc. It's not heavily promoted though. Good to know. I actually couldn't find it in the docs even now with the knowledge that it exists. &gt; I decided to have a function for setting the result instead (I also thought it would be good to keep before-, after-, endpoint- and error-handlers all consistent). I'm not sure if it was the right decision, but it makes a lot more sense to me. At the moment, I tend to try and write code in an immutable fashion. When I see something like `ctx.json(object)` I immediately ask myself what would happen if I call it again with another object. I would also ask myself what would happen if `ctx.next()` has already been called but I have a Future running that will write something into the Response once completed. Will the Framework wait for that? How does it know about that? This is pretty much taken care of when the handler returns the response which might also be a `CompletableFuture&lt;Result&gt;` or an `Observable&lt;Result&gt;` in case of asynchronous handling. I am not sure if you have read the paper or seen the talk by Marius Eriksen on "Your Server as a Function"? It explains a lot better why I think this is a good idea: https://monkey.org/~marius/funsrv.pdf https://www.infoq.com/presentations/twitter-scala 
&gt; at the moment, I tend to try and write code in an immutable fashion. When I see something like ctx.json(object) I immediately ask myself what would happen if I call it again with another object. I get that, and I feel the same way.. which is why I reached the opposite conclusion :^) In jooby you have this very neat syntax get("/path", req -&gt; { return "Hello, World!" }); Which was what I wanted when I started working on Javalin. You get a request, and you return a response. In -&gt; Out. Makes perfect sense. But then you have this: after((req, rsp, result) -&gt; { return "Actually, nevermind!"; }); &gt; You are allowed to modify the request, response and result object. The handler returns a result which can be the same or an entirely new result For me, this just breaks the API. I prefer the less "pure" way, which is explicit/honest about its mutability: get("/") { ctx -&gt; ctx.result("Hello, World") } after { ctx -&gt; ctx.result("Actually, nevermind!") Just two different ways of seeing things, I guess. If Javalin was async the API would look different, but I'd rather use vert.x for that. Javalin is supposed to be very simple.
Wouldn't the AES protection steps be easily defeated by a modified/recompiled copy of their (open-source) JRE that just dumped all loaded bytecode data to an external file at runtime? The system would need to actually detect changes to the underlying JVM, not just Java-level debugging. That aside, do these subs allow such self-promotion?
We have a special process to decrypt the protected data, if the JRE is modified, the decryption process will refuse to run, but also the process of java is under debugging case.
You're never going to be able to cover every scenario. You provide an open-source runtime, which one could easily modify to silently dump class data as it gets parsed and loaded into the JVM space. One could modify their kernel to intercept certain operations (JVM in usermode can't do anything about it), or to even dump process memory while the process is suspended and extract the class data one way or another.
Your special process can be circumvented. You simply can't completely protect code that a client is running on their own machine. Your approach just makes it a bit harder, that's all. 
If the runtime is modified, the runtime hash would changed, if the runtime is not legal, the decryption process will not decrypt data. And if people can modify the kernel/os, they can do anything, but I don't think is an easy work. On every encryption task, we will generate a unique key, if people modify os to hack the data, they only can get the data once, they could not make a general way. Of course, any encryption is possible to crack, because the key and the data always to be together, but we could improve the difficulty to a higher level. This solution is much better than original java byte code or obfuscation. And we will continue to release new version, change the work-flow, modify the algorithm, make it harder and harder to crack.
Your assumption that modifying the OS/kernel is not an easy task is not something you can assume to be true. Cobbling together a system to intercept bytecode at the kernel level is next to trivial. Protect any page that is interacted with by the bytecode loader (post decryption), such as its instruction data, so the CPU traps to kernel, and then just copy from there, unprotect page, and resume execution. An appropriately modified setup should be able to do this without issuing a signal to the JVM process. This could occur consistently every time an encrypted class were loaded, without your runtime knowing. All in all, not a big task, and sufficiently easy if one were motivated to get the source code/bytecode to a program you're trying to protect.
I started with SparkJava and moved to Javalin. I need to investigate Jooby. I've actually switched from Kotlin to Swift as I've started iOS development and it made sense to me. I'm now using Vapor. From my research it seemed to be the most popular server side swift language. It took me a bit longer to pick up than SparkJava, mostly because I found Swift a bit odd. I'm really enjoying it now. Check it out if you get the chance.
Of course, any encryption is possible to crack, because the key and the data always to be together, but we could improve the difficulty to a higher level. This solution is much better than original java byte code or obfuscation. And we will continue to release new version, change the work-flow, modify the algorithm, make it harder and harder to crack. This is what we can do and all other similar products can do. And if you can find a way to circumvent the decryption process, welcome to tell us. We are glad to hear your suggestion. Thank you.
You should copy the whole memory page and read it, but how can you detect when to copy the page, and how to find the useful data from the page?
Which aspects would that be?
Sounds like someone should go write a medium article.
Or don't. Just discuss it like a normal person.
Yah I haven't done a lot of python, but I don't see a real solid connection either, python's weirdness stands out for me (forced indents, lack of type safety, slow). Whereas kotlin (java) is much more industrial strength.
Here. It's not a comprehensive list, put together in 10 minutes: 1) no semicolon at the end of lines 2) py&gt;&gt; a = 6 kt&gt;&gt; var a = 6 3) functions can stand alone in a source file, no need to put everything in a class 4) string formatting py&gt;&gt; print("Hello {}!".format("world")) kt&gt;&gt; println("Hello %s!".format("world")) 5) type conversions py&gt;&gt; a = 42 py&gt;&gt; str(a) '42' py&gt;&gt; b = "22" py&gt;&gt; n = int(b) kt&gt;&gt; var a = 42 kt&gt;&gt; var s = a.toString() kt&gt;&gt; var b = "22" kt&gt;&gt; var n = b.toInt() 6) reverse a string py&gt;&gt; "python"[::-1] 'nohtyp' kt&gt;&gt; "kotlin".reverse() niltok 7) read from stdin py&gt;&gt; s = input("Name: ") kt&gt;&gt; print("Name: ") kt&gt;&gt; var s = readLine()!! 8) interactive shell in both cases (python3 and kotlinc) 9) lists py&gt;&gt; li = [3, 7, 4] py&gt;&gt; li.append(20) kt&gt;&gt; var li = mutableListOf(3, 7, 4) kt&gt;&gt; li.add(20) 10) for loop py&gt;&gt; for e in li: print(e) kt&gt;&gt; for (e in li): println(e) 11) etc., etc., the list could go on and on... 
Discussing it is fine as long as it's somewhere it'll be indexed by a search engine. Medium is one of those places. So is Reddit I suppose. The problem with casual discussion about a topic that op has some insight on is that often it is unorganized and hard to read. A well organized body of work as a start point can serve as a platform for further discussion, and is more approachable.
These are features that exists in a lot of languages. They do not descend from Python. If they would include all languages with these kinds of features as inspiration, the list would be really long. However, if, for example, the `[::-1]` indexing from Python existed in Kotlin, then Python would be a natural language to list as an inspiration.
Groovy was strongly influenced by Python. Groovy is there, Python -- the source -- is not even mentioned. It's not fair to Python, that's what I want to say.
well there is also the agenda of "personal fame" associated with making every minor nit into a medium article, plus having to click through whatever medium is trying to sell you makes it less accessible. I don't really think medium is better organized on the whole. Plus you are left basically with just the authors opinion, and you have to go fishing for any dissenting opinions (or obvious flaws) somewhere else.
The only major influences Kotlin takes from Groovy are its lambda syntax and property shorthand. Groovy was "influenced" by Python in that it's a dynamic language on the JVM. I'd say both Groovy and Kotlin resemble Ruby more than Python considering their lambda-heavy APIs. Python uses a lot of free-functions. All the features you list existed in languages like Pascal, Ada, Smalltalk, and Lisp way before Python was created.
That AES protection remembers me a Flash Player times, there was many obfuscators aka encoders which encoded swf and loaded it using custom loader-decoder. It was challenging to tamper with it, but someone just created wonderful solution called "SWF File Vampire" which extracts decoded swf from the memory and dumped in to a file. And that's it - encryption has failed. I don't know is this is possible to do using Java VM, but Adobe Player also was VM so seems plausible?
Many of these things are either not specific to Python and are found in languages that are listed or actually aren't that similar. 1) Sure, but that is becoming more common in many languages. Both Javascript and Scala do not require semicolons. 2) Type inference. Available in Scala, C#, and Java, to some extent. 3) Scala and Javascript 4) Having format be a member function is not significant. When you look again, the python version works much different and is significantly more powerful. Python's version doesn't need to specify the type of the argument being formated, can reorder/repeat arguments, and can access properties of arguments. Kotlin's version is an alias for Java's string format which is much closer to Python's % format expression syntax (Python has lots of ways to format strings). 5) Passing a value to a constructor to get a value of a different type is hardly unique to Python. Additionally, the Kotlin syntax makes it a member function of String which is very different from how Python does it. 6) The fact that both languages have a way to revers a string is not significant. Calling a named method is very different from a special slice indexing syntax. 7) Kotlin's readLine() is an alias for the Java function. In fact, Python's version is more like the Scala version that allows you to output text in the same function call. 8) Available in many languages. Java even has it now. 9) List literals are available in many languages and different from a varg function (though it does sound like Kotlin will get collection literals soon.) 10) This is actually similar as there isn't a for loop variant that doesn't use an iterator. However, Scala also does the same thing. I think the take home is that the creators of Kotlin looked at lots of languages to pull in functionality they liked. While Python does have a number of features they liked, it was not a language they particularly focused on. 
I can't tell if this is a troll post or serious.
I don't know how the swf decoder do, how the flash vm run. But to jvm, I don't think it is easy to do so. Of course, nothing is impossible, but just how hard to do it and if anyone will do that and if it's a worth task to do it. 
I'll help you then: serious.
Based on the list provided by the OP, it seems like this post was more of a passing thought rather than a fully fleshed out topic ready for an full article.
``` 1) no semicolon at the end of lines 2) ghci&gt;&gt; let a = 6 kt&gt;&gt; var a = 6 3) functions can stand alone in a source file, no need to put everything in a class 4) string formatting ghci&gt;&gt; format "Hello %s!" ["world"] kt&gt;&gt; println("Hello %s!".format("world")) 5) type conversions ghci&gt;&gt; let a = 42 ghci&gt;&gt; show a '42' py&gt;&gt; let b = "22" py&gt;&gt; let n = read b :: Int kt&gt;&gt; var a = 42 kt&gt;&gt; var s = a.toString() kt&gt;&gt; var b = "22" kt&gt;&gt; var n = b.toInt() 6) reverse a string ghci&gt;&gt; reverse "haskell" 'lleksah' kt&gt;&gt; "kotlin".reverse() niltok 7) read from stdin ghci&gt;&gt; s &lt;- getLine kt&gt;&gt; print("Name: ") kt&gt;&gt; var s = readLine()!! 8) interactive shell in both cases (ghci and kotlinc) 9) lists ghci&gt;&gt; let li = [3, 7, 4] ghci&gt;&gt; li ++ [20] kt&gt;&gt; var li = mutableListOf(3, 7, 4) kt&gt;&gt; li.add(20) 10) for loop ghci&gt;&gt; mapM_ print li kt&gt;&gt; li.forEach { println(it) } 11) etc., etc., the list could go on and on... ``` Many modern languages function similarly and draw upon each other.
is there even any reason to the java format alias? The kotlin formatting seems so much better to me "Printing the value of x: $x or ${object.x}"
I would agree that this wouldn't make for great content, now that I've looked into the motivation. I also responded to the list comment (trying to show how thin an argument it was)
My guess is that string templates expressions were added later in the development cycle of the language. There was a need for string formating early on and the alias was an easy solution.
would recommend learning at least a few languages so you can get a better understanding of language features. even just 1 Lisp and 1 ML would help lots im sure.
Thanks, but I know some. And since I started learning Kotlin, I have the constant feeling that "it's like Python".
So? Python wasn't a direct influence for Kotlin. It doesn't matter if it has features that can be easily transferred. Should Kotlin have listed C++ (an influence for C# and Java)? Should it have listed Smalltalk because it supports OOP? Or Fortran? Or maybe it should have listed asm for giving us a reason for higher order languages? Do you see how ridiculous the argument is?
I just explained this. I copy the page when an operating accessing an interesting related page (or that page for writing) traps. The useful data can be found by heuristic analysis, searching for common sequences, inspection, and good guesswork of where data lies in memory. This is all well-documented and commonly done. 
I was able to stub out your anti-debugging routine from the binary in about 45 seconds so you may want to rethink this mechanism.
And I'm sure someone who has mostly done a lot of web development is going to have a feeling that "it's like JavaScript" and find a lot of superficial similarities such as - `val`/`var` is just like `const`/`let`! - in both you write a lot of `return collection.filter { ... }.map { ... }` - there's `try/catch`, but unlike Java, no checked exceptions! - `variable.toString()` is in JS too! - constructors are called `constructor` in both
There is not only one anti-debugging routine, and not only one security mechanism, If you are interested in continuing to crack it, welcome to tell us the finally result. Although there's no 100% security against the reverse engineering, nothing can. But if you have found the way to crack it and get the data, just let us know, it would help us to improve the product. Thanks.
It's simple, if you want people not reading your code, don't give them your code, provide it as a service. If you want people to run it on their own, provide a sufficient license for that and charge more so you can make a living from that. Just stop building such crappy products, use your talent to build valuable products, solve real problems.
Kotlin has nothing to do with Python. And the main argument is that [Guido van Rossum](https://en.wikipedia.org/wiki/Guido_van_Rossum) the author of Python [does not like FP](https://stackoverflow.com/questions/1017621/why-isnt-python-very-good-for-functional-programming). Kotlin on the other hand [embraces FP](https://blog.jetbrains.com/kotlin/2015/11/webinar-recording-functional-programming-with-kotlin/). This alone rules out any claims such as the one in this post.
**Guido van Rossum** Guido van Rossum (Dutch pronunciation: [ˈɣido vɑn ˈrɔsʏm, -səm], born 31 January 1956) is a Dutch programmer who is best known as the author of the Python programming language. In the Python community, van Rossum is known as a "Benevolent Dictator For Life" (BDFL), meaning that he continues to oversee the Python development process, making decisions where necessary. He was employed by Google from 2005 until December 7th 2012, where he spent half his time developing the Python language. In January 2013, van Rossum started working for Dropbox. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Kotlin/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
Of course, we (the designers of Kotlin) are familiar with Python and often recall the way Python implements certain language features, but I don't recall any features or design decisions in Kotlin for which Python was the primary inspiration and no other language had an equivalent feature.
You are very professional in this field. There's no 100% security against the reverse engineering. We just can make it more difficult. If you are interested, welcome to continue researching our product and give us professional advices. By the way this solution is much better than obfuscation, or just distribute original java class. The discussion of protection and cracking would never stop, even the biggest software company in the world, could not 100% protect their software. But I think for the apps that are not distributed very widely, this solution would help to protect their work from cracking too easily. We appreciate your analysis. But really, we are not sure that whether this product will be cracked by some great guy someday, what we can do is continuing to improve this product and help the people who have this requirement.Thank you for your analysis again.
This is actually a weird argument to make. What Guido van Rossum likes or doesn't like doesn't prevent the designers of other languages from looking at the design decisions in Python and getting inspired by them.
The Java .format() method allows you to customize the formatting (e.g. specify the number of decimal points for a floating point number), and string templates have no such customization possibility.
ah yea thats true.. good call
There's no 100% security against the reverse engineering. Even the largest software company in the world could not do that. But why windows still have to input the SN to install? Why the JetBrains product still ask you for license? In different areas will have different requirement. This project is from one of my requirement and I complete it, it's still in beta stage, if you have any professional advices, welcome to tell us. Thank you very much.
You're right, but JavaScript is indicated among the influential languages...
If you don't rely on heavy computation, you could use Apache Cordova (runs a JavaScript / webclient with a local node.js Backend) and Target that with kotlin -&gt; JavaScript
There's nothing related to Kotlin here, other than it's a custom JRE that won't run on Android and probably shouldn't be run on any web-server platform.
Lol I introduced a colleague to kotlin today, these were his exact complaints. Don't agree with them though, clarity over brevity. It's nice to create an array with `[1, 2, 3]`, but then how do you create lists? Or was this syntax for lists? `listOf` and `arrayOf` are more characters, but also clearer.
To add to the list: binary operations. In Java it's `1 &lt;&lt; 3` or `64 &gt;&gt;&gt; 2`, but in Kotlin it's `1 shl 3` and `64 ushr 2`. WHY?! However, considering how much the language still changes even now it's past 1.0, I am optimistic that these things will be polished in the future. 
&gt; replace hash map to with something sane like : or =&gt; sweet innocent child, you're gonna hate what `[..]mapOf(ab to cd, ef to gh, ..)` actually compiles to.. 
I prefer it actually &gt; `1 shl 3` **sh**ift to the **l**eft &gt; `64 ushr 2` **u**nsigned **sh**ift to the **right** 
Probably downvoted because it is not constructive; it's just several complaints thrown out at random. OP states that these things are poor design, but gives no examples, no reason _why_ they are poor, and what better alternatives might look like.
do you want a 2000 word essay justifying any opinion about language features? secondary constructors shouldn't even be in the language. There's default arguments and declaring factory methods (name them appropriately) for maximum freedom. don't understand the outrage about list vs array for collection literals either. Why care if [1, 2, 3] is a List&lt;Int&gt; and not an IntArray? Kotlin doesn't optimize performance a lot, especially around boxed primitives. And it shouldn't, profile first and then check if you have issues. speaking of optimizations however, file size...mapOf using ab to cd pair syntax is one of these many things that if optimized would reduce artifact size. Having to include the stdlib is bad enough...proguard helps a lot.
In fact, we tried to avoid secondary constructors as much as we could in the language. But we had to because of Java interoperability. If you inherit a Kotlin class from a Java class, and Java class happens to have several constructors there is simply no other choice. You can have no primary constructor and have some secondary, or you can have both, and the design is there for a consistency and balance between conceptual purity and real life. I think it is pretty good design given constraints we had. 
The other thing I've seen about this is that it's not extensible in any way. It takes `[...]` syntax from other possible uses and doesn't include any sort of user-defined use.
This project does not respect my 4 freedoms of Free Software
Coming from the world of PHP, I'd love if the `mapOf`'s `to` was replaced with `=&gt;` ;) 
I don't like the exception interop. Checked exceptions are not a nice error propagation mechanism, but they are used extensively in Java code and ignoring them should be explicit. Also, I want package visibility back. Most of the time only 1 or 2 classes in a package need to be exposed, but in Kotlin pretty much everything ends up public (internal is useless for non-library projects).
If, in your opinion, the “bad design decisions” in Kotlin are mostly limited to a personal preference for a more symbol-oriented language-level syntax in places where Kotlin tends to just use named functions, I’d say the overall design of the language is probably quite good. I don’t intend to marginalize your opinion regarding its syntax, of course. It’s just nice to hear that there’s not some more fundamental complaint regarding deeper problems with regard to the architecture of the compiler, the nature of continuations, etc.
There is some hacky way to explicitly select what type do you actually want: “Experiments with Kotlin Array Literals” https://medium.com/@kosiakk/experiments-with-kotlin-array-literals-7f4e75d24ebf
In the grand scheme of things, this list of "bad design decisions" ( which tend to be somewhat subjective ) is not that bad at all IMHO. This is especially true compared to some design choices in other languages I actually think that some of the other Kotlin features are under appreciated (again subjective). For example take property references. You can reference a property like 'User::email'. This is incredibly useful for meta and typesafe programming
If your use case is for games why not lua?
Sounds more like "syntax parts that do not fit my taste". Do you even design, bro?
The to keyword for key value pairs also got me in the beginning. When I tried using a map and read in the docs &gt; 5 to "Peter" I was confused. I read it as "value to key" and thought why would they reverse the order. I settled on being not a native English speaker and thought they might mean "5 leads to Peter" and then it was clearer.
The good thing about operators is that they stand out more from the code and also that they have an ordering so you can omit parens. 
Code taking advantage of the ordering of bit operators in Java would never pass code review here. Few people know the precedence rules, it makes code hard to read
`to` is just a function returning Pair
The thing about array literals is that you should rarely be using arrays outside of annotations anyway. Giving them prominence through a literal would be a bad thing. Primary constructors are kind of required to be this way to allow property declaration in constructors. I don't think it's much of a limitation but it is true that it limits what Java code you can translate a little. Kotlin likes its infix functions over syntax for lesser-used operators like `to` and the bitwise ones and does not allow symbols in operator names (at least without quoting). Both have their reasons - less language complexity and no danger of spaghetti dsl code you see in languages like scala sometimes.
You read it like »i want to map 5 to "Peter"«. It's pretty obvious honestly. Also map put operations always have the key first.
I’m not a native speaker, either but I never saw it as “value to key.” For me it was always “key to value” because that’s how you specify a pair, or entries in a map.
&gt; but they are used extensively in Java code and ignoring them should be explicit. That would make lambda expressions a pain, because you would be required to insert your "ignore checked exception" keyword/annotation/whatever everywhere.
Going down from 1k lines Java classes to 300 easily readable lines in idiomatic kotlin is just not enough for some people. lets replace all the things with parens, everybody loves perl anyway ''=~('(?{'.(']])@+}'^'-/@._]').'"'.('/&lt;[*-_&lt;+&gt;?}{&gt;]@}+@}]])@+}@&lt;[*-_&lt;+&gt;?}{&gt;]@^'^'`^=_^&lt;]_[[]+[/,]_/]-/@._]/^=_^&lt;]_[[]+[/,|').',$/})')
For a high level language, I don't think the use of shift warrant its own operator.
I really miss pattern matching. List comprehensions would also be great, but they're more a nice-to-have.
Python's wierdness? It's one of the simplest and readble languages ever created. As to lacking industrial strength I guess Dropbox, NASA, Instagram et al. didn't get your memo.
Yesterday I wrote proposal for these features: [Arrays-2.0, multiple varargs and collection literals](https://discuss.kotlinlang.org/t/arrays-2-0-multiple-varargs-and-collection-literals/4951). TLDR: You have array literals `[1, 2, 3]` and you can pass them to vararg functions `fn([1, 2, 3])` or constructors `ArrayList([1, 2, 3])`. And you apply last argument convention: fn({}) ---&gt; fn { } fn([]) ---&gt; fn [ ] So, you can create any syntax you want List [ 1, 2, 3 ] listOf [ 1, 2, 3 ] l [ 1, 2, 3 ] ArrayList [ 1, 2, 3 ] etc [ 1, 2, 3 ]
Yesterday I wrote proposal for these features: [Arrays-2.0, multiple varargs and collection literals](https://discuss.kotlinlang.org/t/arrays-2-0-multiple-varargs-and-collection-literals/4951). TLDR: You have array literals `[1, 2, 3]` and you can pass them to vararg functions `fn([1, 2, 3])` or constructors `ArrayList([1, 2, 3])`. And you apply last argument convention: fn({}) ---&gt; fn { } fn([]) ---&gt; fn [ ] So, you can create any syntax you want List [ 1, 2, 3 ] listOf [ 1, 2, 3 ] l [ 1, 2, 3 ] ArrayList [ 1, 2, 3 ] etc [ 1, 2, 3 ]
Neither Python nor Kotlin are hard core FP languages, but they both support FP to some degree. Neither has tail call optimization. Neither enforces immutability or purity. I'd say they support FP oriented programming about equally. 
Kotlin **has** tail call optimization (use `tailrec` keyword) just like in Clojure. You can implement Algebraic Data Structures using `sealed` classes. Moreover Kotlin comes with all the low level operations to use it in an FP way. Kotlin does not enforce immutability **but** it comes with immutable variants of data structures (`Set`, `List`, etc) and it supports operations on those data structures which create new data structures after performing the operation (`plus`, `minus`, `map`, `filter`, etc). If you want some collection to be mutable you have to **explicitly state it** using `MutableList` for example. If this is not an encouragement to do things the FP way then I don't know what is. Kotlin does not enforce FP because it is intended to be an enhanced Java. Python has none of these and as I stated above (I also included resources) it **actively hampers** FP. So *no* they **do not** support FP oriented programming equally.
Since Guido is the BDFL of Python it is a **pretty significant** argument to make. Let me quote *yole* here: &gt; Of course, we (the designers of Kotlin) are familiar with Python and often recall the way Python implements certain language features, but I don't recall any features or design decisions in Kotlin for which Python was the primary inspiration and no other language had an equivalent feature.
Python also comes with immutable data structures you can choose if you wish. Unlike Kotlin, Python has list comprehension, which is a common idiom in many FP languages, e.g. Haskell, Elixir. Python's standard library has all the functions you mention (plus, minus, map, filter). In fact, in Python these are used as functions, not methods on the object itself, like in Kotlin -- the former being more ideiomatic FP. In addiditon Python comes with functools and itertools -- modules for functionally oriented programming -- as part of the language. Both Kotlin and Python are multiparadigm programming languages. Both heavily support OOP and mutability and thus will never be pure FP languages. Therefore, FP is not the the thing that distinguishes them. Like yole says, it's a wierd argument to make. 
Yes, it will be very sad, if literals will be implemented that way. You may be interested in my proposal for extensible collection literals [here](https://www.reddit.com/r/Kotlin/comments/75rfjp/bad_kotlin_design_decisions/do9dr3n/)
Thanks for quoting myself to me, but this is still a weird argument. Even though we didn't borrow any specific features from Python, we could've done so or might do so in the future (e.g. the slice syntax looks really nice), and Guido's role in the Python project and his views on FP have zero impact on whether we're going to do so or not.
fyi, this is a kotlin forum, python looks weird, and sucks at performance and lots of other things. Maybe YOU didn't get the memo?
It's a Kotlin forum, so don't speak well of other languages? No, guess I didn't get that memo.
&gt; Even though we didn't borrow any specific features from Python, we could've done But you didn't.
This is all a moot point since *yole* already pointed out that Kotlin was not inspired by Python and this whole post is about influence not language features.
Wow, I had no idea there was a `to` operator. I was writing `Pair(blah, blah)` the whole time and wondering whether or not I was missing something!
You wish to discredit kotlin by asserting it is based on python without mentioning python (it isn't based on python AT ALL), python fanatics are weird too. Look at the crapfest that instagram has created, the number of servers is growing faster than their user base, it smacks of one or a few fanatics with something to prove. https://cdn.thenewstack.io/media/2017/06/63adbc8e-instagramusersvsservers-1024x576.jpg
&gt; You wish to discredit kotlin by asserting it is based on python Please point out where I've said anything remotely like that. You know, it's kinda irritating when people ascribe you an opinion you have never expressed. I actually like Kotlin a lot and root for it's success and growth. And there are many things in Python I miss or that irritate me. If I had to choose between the two, who knows which I'd pick in the end. But luckily I don't have to. When I see blanket statements like "... kotlin (java) is much more industrial strength" or claims that using Python and not C or Java is lazy, I know that the discussion will be on a level that is just not very interesting. In other words, feel free not to waste more energy on convincing me how crappy Python is. 
whatever, go do some python or something.
To add another one to the list: https://github.com/hexagonkt/hexagon it is a Web micro-framework focused on simplicity (still in development, but I intent to release 1.0 this year)
Project is still new and growing, but with this it will be possible to create an automated browser that can utilize the SikuliX framework to recognize on screen UI elements with computer vision and control them using actual mouse events as opposed to DOM events. Future prospects will be adding more DSLs to streamline writing scripts for automation. And of course ironing out any current bugs. Also plan on supporting scripting in other languages (like SikuliX) using JVM implementations of other languages like Jython, JRuby, Javascript etc. Thanks for taking a look!
Bit shift ops looking ugly is a feature. Furthermore, using infix functions makes parsing simpler.
I'm actually grateful to Kotlin for saving us from Java regex backslashitis.
&gt;create an automated browser that can utilize the SikuliX framework to recognize on screen UI elements with computer vision and control them using actual mouse events as opposed to DOM events What are the advantages of this approach?
It uses SikuliX framework meaning that it uses a visual based approach to test things. So it can account for any differences in how a UI component may look, so for example a button suddenly becomes 10px long in a 800x600 web view but is supposed to be 100px then SKrypton will not be able to find the expected button and error out. If you just manipulate the DOM, you only see html and css you can't check if it's producing the button in the way you want it to look like. The key difference with pure SikuliX is that when you use SikuliX, it uses the actual mouse cursor and keyboard when it is running. So your machine is rendered completely unusable while automating or testing. SKrypton provides a jailed environment for it. Then you sometimes you have UI components you cannot send DOM events for example Flash or other kinds of browser plugins. Also this is meant to simulate a user interacting with the web page. So its not like unit test in that you just call the function directly and it will do its thing. For SKrypton, the events are passed in to the window frame and have to go through all the intermediate stuff like a user generated click would. Might be more intuitive for the average joe to create scripts in that you just need to take a screenshot and save the picture somewhere and type `click("mybutton.png")` than open dev tools and filter the ID. SikuliX has a GUI IDE to help write scripts, so that can be leveraged as well. And I'm sure there is more potential to this visually based approach ;)
I asked because I once tried to use SikuliX to automate a GUI application, and my impression of things was that it's a really interesting idea, but currently way too much hassle to use in practice. I actually ended up wishing I had something like DOM available. Doing screenshots of every tested element is a painstaking process, and you'd have to re-do them every time something in the style changes (like a font, colors, size, etc.). Then you have to deal with things like duplicate elements (two elements on screen that look visually the same), so you have to narrow down the search regions and things like that. You also have to scroll elements into view, and the whole thing can be very brittle. The approach I tried was, instead of doing screenshots, I drew the elements that matched the application's - I had my own `drawButton` function that produced a picture, which I then searched for. On top of this, I created more high-level actions (e.g. `logIn`, `createTask`, `closeAllModals`, `fillTextBox` etc.) and the scripts were then built out of these. The built-in SikuliX IDE is more of a toy, but using it as a library was pretty reasonable.
Nice I'll add that to the todo list. I have an idea on how to implement that, extract the related html code, render that in another webview, take a screenshot and use that as the target. Though if you didn't know SikuliX can now use OCR, so it should be possible to find a region with certain text without getting affected by font/size/color etc. On the other hand, the browser provided can always be connected to a web driver for DOM manipulation like Selenium. You can always just use the SKrypton APIs as a supplement for example checking if the progress bar actually changed after you send a DOM click.
&gt;Though if you didn't know SikuliX can now use OCR If I remember correctly, I tried that, but it wasn't very reliable. It was over a year ago though, so maybe it improved since then? &gt;On the other hand, the browser provided can always be connected to a web driver for DOM manipulation like Selenium. You can always just use the SKrypton APIs as a supplement for example checking if the progress bar actually changed after you send a DOM click. Yeah, a hybrid approach like that could work. You'd be able to get the best of both worlds.
Love the name!
Interesting, I came up with the same thing in my head.
A lot of the examples you give actually show how different the two languages are. For example, Python does a lot of implicit conversions (which are an endless source of bugs) while Kotlin is explicit for those (e.g. your `toString()` example). Similarly, Kotlin is explicit (`reverse()`) instead of using obscure punctuation marks (`::-1`). Most of your other examples are simple standard library functions which are present in pretty much every single language under the sun. In languages, just because something "looks like" something else doesn't mean there was any inspiration one way or the other. Basically, I think your impression that Python inspired certain features in Kotlin stems from the fact that you haven't studied a lot of languages. 
&gt;Thanks for quoting myself to me Haha, not every day you get quoted to yourself!
Dude, you aren't talking to the OP ... different Reddit user!
I do think asserting that a jvm language is more "industrial strength" is reasonable. On the other hand Python has more libraries to support scientific applications is also reasonable. Probably all boils down to compiled vs dynamic. Faster absolute performance vs easier to quickly script.
A person can like and use both. I don't much like Python, but that's mostly only due to familiarity, not some innate deficiency in Python.
Might be more obvious to a native English speaker.
I really appreciate both those decisions. I've had _really_ painful discussions with co-workers who thought every method should declare 5 checked exceptions. (Unfortunately that is not an exaggeration.) Nice to have the language design prevent that argument. And I really dislike Java's visibility modifiers. 1. They turn into bloat 2. I think the Python method of "you can see and use everything but I'll mark these ones so you know you shouldn't" is best. I've been kneecapped too many times by overzealous visibility modifiers.