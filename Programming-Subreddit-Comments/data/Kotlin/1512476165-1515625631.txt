&gt; Plans for a Kotlin Conf in Europe? No definite plans by now. Weâ€™re considering all possible options
Is it possible to write device drivers for OSX with Kotlin/Native? Followup question, Xcode has a lot of templates when starting a new project. Will Jetbrains be adding something along these lines in IntelliJ IDEA to not need Xcode?
Only if they introduce a cycle collector, or complicate the language with affine types.
Does get(0) work?
&gt; Do you think Kotlin will be a supported language in the new fuchsia os? I think this should be addressed to developers of fuchsia.
Do you see Kotlin moving away from the JVM? I love the JVM, but see it hard to keep focus on language features and libraries that should work the same way across all platforms. Is Kotlin Native going to be available only to those that buy CLion? A bit hot political question, given that Kotlin only exists thanks to Java and JVM, how do you see those that bash the major platform and libraries where Kotlin runs on?
Any plans on supporting Visual Studio with their new Language Server Protocol?
As Kotlin was introduced as official ACM Programming Contest language and may be increasingly popular in other contests, do you have plans for dedicated effort to streamline this specific use case? For example, reading numbers from console or files could be made much funner than it is now: https://stackoverflow.com/questions/41283393/reading-console-input-in-kotlin. Would you consider a Codeforces post with call for other possible enhancements that would make Kotlin even more appealing for contesters? Many are currently also reluctant due to performance hit during JIT warmup. I guess this would be principally resolved when Kotlin Native goes stable. But then CLion would need a free Community Edition for students and schoolers. Universal Kotlin input API proposal at the link above would be also very useful for Kotlin Native CLI tools and for teaching Kotlin as first language in Junior School as currently it involves to explain streams and lambdas just to read a number from console.
How will Kotlin Native avoid the fate of similar projects like RoboVM or MoE both of which are dead/glacial due to the maintenance complexity? Both of these projects targeted a larger user base by supporting Java too and still failed to gain serious traction. Disclaimer: I'm asking this as a guy who works for Codename One which already supports Kotlin on iOS (and Windows, Android etc.) but we've taken a far simpler approach and IMO a more sustainable long term approach for platforms such as iOS. 
Yes, Kotlin/Native already supports WebAssembly as the target ([blogpost](https://blog.jetbrains.com/kotlin/2017/11/kotlinnative-v0-4-released-objective-c-interop-webassembly-and-more/)). You can find examples [here](https://github.com/JetBrains/kotlin-native/tree/master/samples/html5Canvas). No, we are not going to deprecate Kotlin/JS. Note WebAssembly canâ€™t replace JS yet.
&gt; But then CLion would need a free Community Edition for students and schoolers. It has: https://www.jetbrains.com/student/
what do you mean by "no comparison" ?
Check out flutter.io
&gt; val value = if thisIsTrue trueValue else falseValue I still prefer `val value = thisIsTrue ? trueValue : falseValue` after years of kotlin
Do it for the null safety, extension functions, the default parameter values, the `when`, the lambda/higher order functions that can also be inline, and, well, all other Kotlin features that are all awesome. BTW, you could already know by searching the WEB a little bit
That has literally nothing to do with Kotlin.
Can we expect partial classes as in C#? It'd be extra useful for code generation, annotation processing etc.. I'm aware of the short discussion on the topic with Hadi, where support for partial classes is kinda declined, but no definite conclusion.
What were the reasons for inventing a completly new language instead of supporting an existing modern language (like F#, Scala or even C#)? 
Who do I have to bribe to get low-level multi-threading support that doesn't require me to transfer complete ownership of object graphs between threads in Kotlin/Native?
Union types, please?
This. It's the missing ingredient. Sealed types are weak in comparison.
Any good tutorials coming? I always wanted to learn Java and never really had the chance. Now that Kotlin is out, I was really tempted but the lack of resources is staggering. Having a platform like Laravel did with Laracasts would be awesome!
How soon do you think something like Type Classes as extensions (KEEP#87 https://github.com/Kotlin/KEEP/pull/87) will be available in Kotlin? Or, at least, are there some plans for something like inline classes or scoped type aliases in the near future? It's very important for adopting more approaches from FP, and Kotlin will be a perfect general purpose language if it has whole might of both OOP and FP.
&gt; Note WebAssembly canâ€™t replace JS yet. What's missing?
All top student contesters master the language at high school or earlier and would not easily switch later. Lack of official Kotlin Native IDE in school environments would favor the choice to C++ instead.
Kotlin and Ceylon both appears to be "a better Java" and appeared at about the same time. Why do you think Kotlin won and Ceylon went into obscurity? Syntax? Marketing? Tooling? Anything else?
Why does kotlin have `variable?.let` instead of `guard let` like Swift? Why do if statements still need parenthesis unlike Python? Are there any plans to follow these behaviors?
Do you have any plans to make Kotlin/Native and/or Kotlin/JVM usable in low power embedded systems? I really love how Kotlin allows understanding the whole codebase and avoiding errors and un-maintainable code, but I did not find embedded systems developments to be so. I mean, I have a hard time understanding any embedded systems codebase written in C or C++ (did not see any serious embedded systems codebase in more readable languages). FYI, I'd like to make a firmware for e-bikes with extra features such as location tracking, theft detection and more, and I'd love to use Kotlin to avoid any codebase mess, benefit from great tooling and reuse code with other components. I'm also interested in experimenting more in electronics and embedded systems, using Kotlin preferably. PS: I found that [Zephyr Project](https://www.zephyrproject.org/) could be suitable for my use case, but I am lost on how to use it with Kotlin/Native
How far do you plan to go down the Scala path? I mean that Scala supports things like higher kinded types, persistent data structures, and such. I am not a Scala fan and I like Kotlin as it is but I'm curious about the direction Kotlin will take with regards to language features / stdlib options.
Any plans to revive the kotlin plugin for NetBeans? At lease a maintenance update for the tooling jars would be great.
Kotlin seems to be very inspired by Groovy. Are there any plans to add AST transformations or macros?
Do you recommend someone brand new to Android development start with Kotlin right now? If so, what's your favorite IDE setup tutorial and Hello World tutorial? 
Are there any possibilities for leveraging the metadata inserted by the kotlin compiler for faster reflection?
Right now WebAssembly interop with environment limited by import and export functions (and a memory block), i.e. you can't simply work with objects from JS. Also, you can't reuse native GC that is very critical for interactive apps since native GC takes into account many factors to provide the good user experience.
That's sounds like pretty severe limitations indeed :)
It reminds me of Ruby: `(1..5).map { |x| x*x }`. Also Swift appears to be using something similar `{ x in x*x }`
I am curious to know the Kotlin's team answer for this. Along with many new features, they have also changed their major release cycle to every six months. They will be slower since they need to do backwards compatibility, but will catch up. The previous complaints about Java was it was not improving at all. It has completely changed now.
Yes, we going to simplify creating and consuming libraries in Kotlin/JS in 1.2.x releases. Since you've referred to Kotlin/JS tutorial I concluded that the question about Kotlin/JS, let us know if it's not. 
There's a lightweight/experimental/proof-of-concept library at https://github.com/Kotlin/kotlinx.reflect.lite which contains the minimal subset of what's needed to correctly parse the Kotlin metadata. You can either improve it or build on it to support use cases you have in mind.
It seems Kotlin/Native is not production ready just yet, and WebAssembly target is experimental on top of that. JS ecosystem is much greater than WA in general.
Awsome! Iâ€™ll give it a look and see if thereâ€™s anything I can contribute 
Can you nest/group tests as you can with spek? I'm looking at the docs and it seems less flexible that way.
Valhalla seems to be more about value types than reified generics, but answering the core of your question: - The JVM features we can and will pick up as they appear (this applies to Valhalla), so we are only happy when they appear. - If the Java programming language becomes better than Kotlin in every respect, it will be really cool, because the world will benefit so much from it. Before it did, I think it's still good that it's making progress now. And competition tends to make you fit. So, I see it as a positive thing. Also, if any language gets ahead of Kotlin,it means that it tries some features first, and it's only to our benefit, because we can learn from their experience and hopefully make the feature even better (this is what happened to coroutines, for example). Bottomline: I'm not concerned with any positive progress any language in the world makes. I'm only happy with it :)
Yes, please!
[removed]
Variety of options is always good so weâ€™re not aiming to replace anything but Kotlin is definitely going to be suitable for developing cross-platform apps
We will consider hits if thereâ€™s enough use cases. What is your use case?
Hello, I've just finished Kotlin Koans and am really excited about this language. Having experience in other languages, the tutorial felt very easy to somehow thought-provoking. Until the last chapter about generics, which consists of a single problem, in which I stuck for good couple of hours. Now there are too many things to get wrong for a single lesson, can you consider splitting it into more?
Kapt provides JSR 269 support for Kotlin, and we don't have plans to extend its functionality (frankly speaking, Java Annotation Processing API is somehow *very limited*, it doesn't support any languages besides Java, and it's not really extensible). We do have plans to create a public API for compiler plugins someday, and I hope it'll be available for all target platforms we provide, including JVM, JS, and Native. But we need to do a huge compiler refactoring in order to provide a clean API, so I don't think we will release it soon.
+1, really cool sugar, especially when you need more than one var.
&gt; Did you try adding an issue on GitHub? We are already working on this, and I hope ConstraintLayout support will be added in the next version of Anko.
I think we have more than one question here: &gt; aren't you guys concerned that language might become too complex and bloated over the time? Yes, we are, and we've been from day one. It's the central issue in language design: what you leave out is more important than what you put into the language. We tend to focus on adding few features that change experience very significantly rather than many features with smaller impact. In short: we want Kotlin to remain lean and modern, and we are doing our best to keep it so. &gt; Do you see JVM as a main platform in the future or you want Kotlin to become first language to "rule the all"? JVM and Android are very important platforms for us, and we pay a lot of attention to them, but we realize that there's demand for multiplatform programming. And it's not simply writing Kotlin code for iOS or WebAssembly, it's about _sharing code_ between platforms. It's not only that we want to provide an alternative to C++ or Rust, or JavaScript, we want to make code shareable, and it's best possible when it's written in one language. It's cool to write a server in Kotlin, it's even cooler to write a web client in Kotlin as well, but it's so much cooler still to be able to share code between the two, and then all other components of a multiplatform application (mobile clients, etc). And this is what we believe in and what we are working towards. 
there already is a full featured kotlin kernel for jupyter: http://beakerx.com/
Do you have any plans to add transaction memory to standard library?
I'll second /u/stiggpwnz: sealed classes that we already have are a close enough approximation of ADTs and cover most of their functionality and benefits
For kotlin enums, you can get an NPE if you access a property from its companion object within one of the enums constructors. Iâ€™m assuming this is due to the order of instantiation but or there ways to mitigate this other than moving the property to the file scope?
Not OP but I think the biggest reason it won was its appeal to android developers who were stuck on Java 6 (no lambdas/default methods/etc). Tooling was also huge since the people who made the android and intellij IDEs made the language 
&gt; Bottomline: I'm not concerned with any positive progress any language in the world makes. I'm only happy with it :) Yes, as a developer. But as a company, if you are investing in learning one language and one tooling ecosystem, it means a lot of things. If Java itself is going to offer such things in the future then why would I choose Kotlin? I believe that the above question was asked in the context of choosing a language and not a developer's perspective. But yes, as far as the learning is concerned, its all good. You just have to re-learn the syntax which is far easier that understanding the concepts themselves.
Intersection types are secretly there (not in the language syntax, but under the hoods in the compiler). Not sure if we should surface them in the language syntax: it's adding tothe syntax of types and the use cases are not very many (and after adding something it's hard to take it back). Union types are more difficult, because they require changes in overload resolution algorithms and many other things. There are important use cases for them wrt JavaScript signatures, and there we are working on something, but it's too early to say whether it will work or not.
Hi everyone! First of all, thanks for an amazing language. Your team continues to make great decisions about the evolution of the language, which I'm sure is not an easy task. First question: what are the plans to expand the Kotlin common stdlib to include more APIs that are shared between languages? It strikes me that eventually it would be amazing to write pure, language agnostic Kotlin business logic libraries without having to write our own date time objects and logging tools. How much of this do you see as the community's responsibility vs. your responsibility? Another multiplatform question: one of my favorite parts of kotlin is the opportunity for interop across different environments. Since Kotlin Native is still in an infant state, I have to ask, what are the barriers to using Kotlin Native libraries from Python or other LLVM languages? Given that C can call into Kotlin Native and Python can call into C, this feels possible, but how possible is it, and is it a goal? Finally, I'll end with something open ended. Is there something in the back of your mind that you personally would like to explore adding to Kotlin, but haven't had the time from working on all of the other great language features in the pipeline? 
Is it possible to have function implementation in common modules in kotlin multiplatform projects with a standard lib. Currently platform implementations allow similar naming but actual implementation lie inside platform modules but if some implementations could be written in common modules itself, we could have more code reuse.
Ceylon is probably the better language design, but the implementation has lots of problems (especially Java interop) and I personally found the typesystem to be completely overengineered. Kotlin has a few issues too, but the Java-interop is spot on.
First of all, a bit about me: I am using Android Studio ever since it was available publicly, no idea what the first version was. In fact, for my private projects, I was already using IntelliJ IDEA instead of Eclipse, it was just working better. When Android Studio started to really mature (probably around 0.8.x, not really sure, the dates match though), I was the first developer to push the team I was then working in to migrate from Eclipse, which we eventually did. Having said that, I would **really** like to try out Kotlin/Native already for a private project, that would serve as experience on how viable it really is (or will be in a few). Two thing is blocking me though: - I am very familiar with IntelliJ, CLion looks about the same on screenshots, not sure if it is the case though - license price of CLion, just to play around with a new tech, â‚¬199 yearly *is a lot*, and the 30 days free trial is not really enough I understand that you need to make money from somewhere, so for now, a "lite" version of Kotlin/Native (if that even makes any sense) would be good, just so that we can experience the whole stuff first handed. I am thinking about targeting the following platforms: - Android - iOS - Windows app (be it UWP or JVM based, whatever, but a "native" app) - macOS (low priority) - probably linux app (very-very low priority) - web isn't planned for me, but this might change If Kotlin/Native feels like a (soon) viable solution, I will start to advocate for it in my company, where RN is a very hot topic now. And, if CLion will be the most powerful tool for it, I'm sure an enterprise license will easily be bought. That is my current use case.
I am just a beginner in Android development, and liked how kotlin makes it easier and efficient than java.How can i learn kotlin from scratch?? thanks in advance.
will kotlin support pointers like c++? kotlin jvm level is too easy to decompile,how about kotlin native interop with c/c++? 
Can we have Vue.js support for Kotlin JS?
I'd like to hear more about the future of Kotlin/Native and multi-platform projects. Kotlin/Native could have the potential to take on Go if given the right amount of resources and attention - is that a goal for you guys?
It's on the table, but it requires more work and consideration at this point.
What are the plans with ktor? Is it meant for production (like spring boot, spark, dropwizard, vertx) or it is intended for prototyping. If it's meant for production is it safe to use already? How does it compare in terms of performance to the others?
My use case is that I want to ensure my Kotlin libraries work on for all supported Kotlin platforms, but the IDE constraint means I can't test it on the native platform.
Kotlin's flow typing already gives you type-checked code paths.
Thanks!!
kotlinx.serialization can be used on resource critical systems like Android too? It would be great to see how does it stack up against other jvm json serializers (https://github.com/fabienrenaud/java-json-benchmark)
There was a number of reasons, among which is the ability to create functions that look like custom language constructs, this way we have `synchronized` as a function, and not a built-in keyword: ``` synchronized(lock) { // do something } ``` or `with`: ``` with(foo) { print(propOfFoo) funOfFoo() } ``` It also enables [type-safe builders](https://kotlinlang.org/docs/reference/type-safe-builders.html)
This is exactly the AMA I've been waiting for a long time since I have a number of questions about the language design: - The first question is about keywords in general. There are too many of them. Yes, some of them are context dependent. But that makes grammar really complicated. What led to that decision? - Why was `inline` made a keyword among with (like override or companion) instead of a mere annotation? In most cases, inline is completely unrelated to the program logic; it's just optimization a hint for the compiler. You've just copied C++, haven't you? - As far as I remember Kotlin supports Java enumerations and something that behaves like classical ADT: sealed classes. I see the reasons why you have both mechanisms in the language. Did you have any attempts to unify those two, and what were the results - +1 to the question about union and intersection types. Dotty adopted them. And that could possibly be a great solution to null-pointer evading constructs that complicate language grammar. Thanks
Say something about the checked exception? Kotlin eats all the exception warnings that would show up in Java, isn't it a bad idea if Kotlin takes all the exceptions and expect programmer to handle it themself?
Groovy uses this syntax as well.
Groovy uses exactly this syntax.
Functional programming is an important part of Kotlin. How is it evolving with other parts of language? How do you compare the functional programming aspect of Kotlin with Go language?
The bigger things we are working on now include: * Improving language support for multiplatform programming * Graduating coroutines * Writing common libraries for IO, sockets, serialization, dates, etc. * Bringing Kotlin/Native to release (currently it's a Technology Preview): for iOS and other platforms * Setting up a central repository for Kotlin headers for JS libraries (aka "DefnitelyKotlin") * Performance improvements in the compiler and IDE * Performance optimizations for generated code * Incremental compilation improvements in Kotlin/JVM and Kotlin/JS
First of all, it was never a vote :) It was a survey, we collected the input from the community and [explicitly said](https://blog.jetbrains.com/kotlin/2017/06/kotlin-future-features-survey-results/): &gt; Disclaimer: as announced previously, we are not committing here to implementing any of these features in a particular time frame, or at all. Not sure whether we are going to run this survey again soon, but the overall idea of running such surveys time and again seems like a good one. As for the features planned, see [my comment above](https://www.reddit.com/r/Kotlin/comments/7hoytl/kotlin_team_ama_ask_us_anything/dqsttz2/)
See the [question above](https://www.reddit.com/r/Kotlin/comments/7hoytl/kotlin_team_ama_ask_us_anything/dqsnujh/). Nobody has filed a formal proposal yet, but ideas have been floating around
See the [questions above](https://www.reddit.com/r/Kotlin/comments/7hoytl/kotlin_team_ama_ask_us_anything/dqsngu2/)
We are looking into value types for Kotlin, but they are likely to be more like Valhalla or Swift than C or C#. It's too early to say anything definite about the design really
Will Kotlin Native get a build/packaging/dependency tool similar to cargo, npm, etc.?
Such "sugar" features are possible, but our priorities now are with the more impactful ones like coroutines and multiplatform. P.S. Kotlin has infix functions already, do you mean something that's not supported yet?
This. It would be awesome to have that kind of content to newcomers to the language.
&gt; Do you see Kotlin moving away from the JVM? JVM has a lot of users that enjoy using Kotlin and we are not going to abandon them
Are there any plans to support (either directly in Kotlin, or by adopting any upcoming JVM changes) automatic M:N multiplexing of coroutines on operating system threads, like is done in Go(lang)? What I'm ultimately after is how easy it will be to code in a concurrent, CSP-kind of way with coroutines, and thereby get not only concurrency, but also good multi-core usage, automatically?
I think the reasons are: 1. Java interop, so you can incrementally add kotlin class by class and reuse the whole java ecosystem 2. Easy to start writing kotlin coming from java 3. Tooling
Why the focus on DSLs but the language doesn't support macros? Are there plans to add macros in the future?
Hi, thanks for taking the time to field questions. Have you guys looked at interop with, or streamlined support for developing Firebase Cloud Functions ( or Google Cloud Functions ) from some sort of Kotlin environment. Given we already have such great tooling for Android and Kotlin ( Thank you for that! ), some sort of additional plugin that clarified that process would really be helpful. Right now i have to leave your product, to try and cobble together NodeJS / Javascript in VS Code, and then maintain it from there as well. I particularly think with Kotlin targeting multiple platforms, this could be a really useful feature to streamline, as you'll find developers from both mobile spaces using these cloud functions.
http://kotlinlang.org/
For starters, if you want to develop a multi-platform project, I expect just one IDE to handle all platforms.
Why is there no multi-catch in Kotlin? This is one of my only frustrations with this great language!
Any plans to add more support for typed functional programming, for example the types defined in the Kategory project.
&gt; Both of these projects targeted a larger user base by supporting Java too and still failed to gain serious traction. Kotlin/Native is not trying to run JVM bytecode on native platfroms, so "we've taken a far simpler approach" applies to us as well as you :) Great job on Codename One, by the way!
&gt; How soon do you think something like Type Classes as extensions (KEEP#87 https://github.com/Kotlin/KEEP/pull/87) will be available in Kotlin? I'm not ready to speak about timeframes here. The feature is appealing, it could enable important use cases, but it's also a really tricky one, so we'll see. &gt; Or, at least, are there some plans for something like inline classes or scoped type aliases in the near future? We are looking into these too
Hi! I've been loving using kotlin so far! Would you say that coroutines are a good replacement for asynctasks or are they functionally different?
RemindMe! 2 hours
I will be messaging you on [**2017-12-05 16:50:04 UTC**](http://www.wolframalpha.com/input/?i=2017-12-05 16:50:04 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/Kotlin/comments/7hoytl/kotlin_team_ama_ask_us_anything/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/Kotlin/comments/7hoytl/kotlin_team_ama_ask_us_anything/]%0A%0ARemindMe! 2 hours) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
What connects the architecture of Kotlin for the JVM to Kotlin/native? Is this LLVM IR and a JVM backend or is it a proprietary IR that can produce LLVM IR?
I think it's not a question to the Kotlin team
I've seen mentioned elsewhere in this AMA that you're learning from other languages that have tried features before. I would widely regard every major effort I've seen into cross platform language development to be largely insufficient (as a developer who had to try to pull it off). A big win for Kotlin is being able to leverage the robust JVM ecosystem from day 1. When you toss in JS support (or tackle lower level language support) the ability to leverage JVM ecosystem goes away. I've tried other languages with modest goals such as "share validation code between backend and front end". It makes sense, why not apply same validation logic in both locations, never drift? Even minor things like that turn out to be hard because (for example) parsing a datetime from a string input field relies on different libraries in JVM and JS. My experiences lead me to believe this paradigm can work but only if you have a robust library of "pure" kotlin (or other language) code for people to leverage. But the community largely doesn't write such libraries because re-inventing the wheel is costly. Do you have a clear direction to avoid that kind of problem? Or put in another way "given other languages try this without success, why will kotlin succeed here?" 
Cool! I quite like the swift model.
See some answers above regarding future features. In particular, we are very cautious adding features to the type system
This. More this. So this.
&gt; Which domain would you like Kotlin to become popular in? Data science, microservices, IoT/Embedded, game development, and many more things :) &gt; Are you willing to support popular open source Kotlin projects financially or with commits from the official team? I think in general we support them enough with our commits to the Kotlin project :) But if you have some specific proposal, please contact me by email.
Maybe everything will eventually be WebAssembly? :)
Kotlin/Native has a cycle collector now
Maybe there's an opportunity for someone to make a site like laracasts for kotlin
Why 'instead'? In fact JetBrains invests a fortune to support many languages including Scala, C# and F#.
Maybe there's an opportunity for someone to make a site like laracasts for kotlin
Hi, Are you planning on compiling Kotlin to Dart (for usage with Flutter)? Can we see (tons) more Android + Coroutines examples? Are coroutines supposed to be fully cross-platform? Thanks for the hard work!
We are using ktor for production at JetBrains, and we mean it to be a production-ready microframework for everyone. It is also pretty good for prototyping services since it is concise, easy to spawn a service and very flexible (once you learn it a bit). We are actively developing it at the moment and while APIs and general ideas are mostly settled, we are working on underlying mechanics to get the client and server as well as multiplatform stories right. We have a lot of tests, may be more than in many other frameworks, so regressions are unlikely though they happen. There are quite a few people and companies using it in production already, though we don't have a list yet. Performance is pretty good, but not the fastest one in the Java world if you include low-level machines like Undertow, Netty, etc. However, comparing to frameworks with enough facilities, features and services, it is very good. E.g. it is significantly faster than Spring or Play2 in microservices-style operations according to latest TechEmpower benchmarks preview (round 15 preview 2). One important downside for Ktor is lack of documentation, which is we are aware of and working to resolve in a sustainable way. That said, we are considering to release version 1.0 pretty soon. 
I voted for this in the 1.1 survey, but after watching java collections refuelled talk, i finally understand the error of such thinking. 
Please don't
Awesome!
There's no official plans so far as it have never appeared on radar thus far. Sounds interesting though, we'll consider it.
I think the answer to that is both. There is already indeed Kotlin support for Jupyter. Support for an equivalent of Scala Worksheets for Kotlin is coming fairly soon, and it's possible that it will eventually be extended to become closer to Jupyter (but it depends on whether the required features will appear in the IntelliJ Platform).
I'll comment on first two. 1. This does sound like a conspiracy, doesn't it? Anyway I cannot come up with idea how this weapon going to work and why it's a Google to pull the trigger? 2. No, because JVM is running bytecodes (not Kotlin or any other language directly)
There is no such thing. When designing Kotlin, we did not focus on inventing features different from any other programming languages; quite the opposite. We tried to create a language that is easy to learn and productive to work with, and doing this requires relying on features that already exist in other programming languages.
I want, I NEED to be able to run my JavaScript test suite in Intellij CE. Right now I have some awful grade build steps to tear out JavaScript files from jar files and a Frankenstein HTML file. Whilst all the posh people get to run the tests fully integrated in the IDE ðŸ˜­ðŸ˜­ðŸ˜­ Are you guys working on running unit tests in CE? Also... Do you have a block diagram explaining the test plugin architecture so someone like me may release a plugin to help the situation?
I love LISP-style macros, but I don't think it would be a good idea to bolt them onto a language that isn't designed for it from the ground up.
It's something we're looking into yes, and not only for native. But I'd love to hear your thoughts on what problems you'd look for it to solve.
Well , it's best described ' **bargaining** chip'... maybe... For example : Google to make Kotlin as 1st class citizen , or releasing Kotlin API first (or only)... Luring more developers using Kotlin rather than Java... I think Oracle won't be happy at this. 
Are you planning to introduce bitwise operators? Without them, my native and OpenGL code doesn't read well. For example, `2 + 2` is easier to read than `2 plus 2`. The same with `2 &amp; 2`, especially in the large method. 
I dont understand this comment. Android has had java 7 featuers for a long time and some Java 8 with the use of jack compiler. Kotlin 1.0 was less than 2 years ago.
At this time we're focusing on supporting mobile apps where each platform has its own native UI, built against the APIs provided by the operating system. We have no plans to support Dart as a target at this time.
&gt; Any plan to support PWA (for those JS haters) ? I think it's more about libraries. So, you can use any JS libraries from Kotlin including JS libraries that help you to create PWA. For example, you can find many examples with Kotlin and React.
Yes, of course. We're working on this right now and plan to release the next set of features in 1.2.20.
What do you thing about overloading, is a good or bad thing? Languages like Ceylon, Go, Rust, Pony, does not support method overloading.
Two questions - 1. When will Kotlin-frontend be considered "production" ready as compared to the current React ecosystem i.e. is there a plan to keep it up-to-date? 2. A more particular question (maybe I missed it somewhere) - Is there an if-null -&gt; then do-something -&gt; else do-something-else shortcut? Most answers revolve around using let? in association with "?: run" block. 
Well , React is still JS , and writing JS is inevitable... I mean , the whole UI / notification / ServiceWorker / data bindings ... are all written in Kotlin , and maybe some toolchain can **compile** the app to PWA
/r/wholesomeprogramming
Actually, you can use any Java WebDriver from Kotlin/JVM and any JS WebDriver from Kotlin/JS.
Yes they said they are working on a common std lib (io/net/serialization/date etc) for all their targets
this, i actually use partial classes a lot in C#, it is really usefull
Not sure what you mean by the "weapon" comment. We're building tools, not fighting a war. Kotlin generates regular Java bytecode. I'm not sure on what basis and how exactly Oracle could ban any specific type of bytecode. You can already build a PWA with Kotlin; there is no support needed for that from our side. Tuples were supported in an early development version of Kotlin and we intentionally removed them. Instead, we recommend to use data classes: they are extremely easy to create and much more maintainable than multi-component tuples.
Are the Koans not appropriate for beginners?
We have no plans to support Language Server Protocol at this time. The set of features that can be supported via LSP is very limited, and we strongly prefer to deliver a complete experience to our users, in the form of our IntelliJ IDEA plugin.
By using "JS libraries from Kotlin" I mean you can use Kotlin/JS, i.e. you can compile Kotlin code to JS out of the box. To get more info see kotl.in/js. 
There are the Koans
You already can use Kotlin for Firebase Cloud Functions (Kotlin/JS) and Google Cloud Functions (Kotlin/JVM and Kotlin/JS). The only really important thing in terms of FCF (and any js library) you need API declaration to get type safety and code completion. You can define it yourself, but repo for Kotlin/JS type definitions would be really helpful
Scala uses `{ x -&gt; x*x }` syntax as well.
You can start building native applications with Kotlin/Native right now. See https://github.com/JetBrains/kotlin-native/releases.
Kotlin has smart casts, which provide functionality very similar to `guard let` in Swift without requiring explicit syntax. `if` statements need parenthesis because the condition and the body of the `if` statement need to be separated by something. In Python, the colon is used as the separator; in Kotlin, it's the parentheses. There are most definitely no plans to change the `if` statement syntax, and no near- or medium-term plans to add `guard` statements.
Are there official docs for writing compiler extensions?
At this time we have no plans to invest into the development of the NetBeans plugin, but we welcome community contributions.
Being new to Android, do you think you could explain the benefits to using Kotlin over Java?
Thanks. I'm not sure I follow so maybe I misunderstood the scope of kotlin native. As far as I understand you are building an LLVM language frontend to Kotlin with goals of supporting all of LLVM's targets including iOS and web. How is this different from RoboVM?
+1 for AST transformations
Well, it is already possible, see for example how Kotlin/Native compiler (written in Kotlin/JVM) interacts with LLVM: https://github.com/JetBrains/kotlin-native/blob/master/backend.native/compiler/ir/backend.native/src/org/jetbrains/kotlin/backend/konan/llvm/IrToBitcode.kt however we're not made it standalone project. 
I've listened to the podcast a bit, and I would love to have more informational sessions like that. One thing I'd be interested in is the processes the Kotlin team follows. For instance, what are sprints like, how does the team decide on features (new or breaking changes), and do your internal code reviews differ from those on public repos. Is there already something like this?
Experimental support for macOS hosts is available in v0.4 of Kotlin/Native: https://github.com/JetBrains/kotlin-native/releases/tag/v0.4 We're planning to extend this support in upcoming releases.
They are meant for people with a good grasp of the Java environment and programming language.
The problem of cycles in initialization has no general solution. No matter which exact rules we come up with, if the initializer of the object A accesses object B and the initializer of object B accesses object A, one of them will be able to observe the other in an uninitialized state.
Do you have a good practical example of guard let usage in Swift? (With Kotlin equivalent or just explanation). I'm just curious how to rewrite it in Kotlin with the best possible way. Because I saw an issue on Kotlin issue tracker where discussed Swift guard let and those samples look strange and completely non readable on Swift, and can be rewriten in Kotlin with a few local val assistance. Maybe you have some good examples
Not in my experience, they are good when you already know programing and want to learn the cool tricks of Kotlin but they are too hard to grasp for beginners. I coach a group in programming/Android for beginners on a local meetup and would love to start using Kotlin on our sessions. Udacity has beginner friendly content both for learning Java and Android for free, which we use for the sessions, so I'd love to have the same with Kotlin.
No, and we don't plan to provide them at this time. The current way to write compiler extensions hasn't really been designed; it's just a few holes drilled into the compiler in the right places to support the usecases we've encountered. If in the future Kotlin gets a supported way to write compiler extensions, it will be definitely documented, but most likely it will be completely different from the current way.
What is your favorite programming language besides Kotlin ? :)
Compiler plugins API is not public yet. You can find question about Kapt in this thread with answer about compiler plugins
Our JVM interop requirements have left us no choice in that matter. The JVM supports overloading, and the Java libraries that we need to interoperate with depend on overloading, so we had to support it in the language. Having said that, our style guide discourages the use of overloading and recommends to use default method parameters instead.
Thanks. I hope there'll be a complete [TODO](http://todomvc.com) app . Fully written in Kotlin (and compile to JS) , without any other JS libraries (react / angular) ... That would be great.
We might be able to support a nicer test results view for JS tests started via Gradle, but otherwise there are no plans. The JS test execution support in the current plugin version depends on the NodeJS plugin, which is Ultimate only. And no, there is no such block diagram.
Right now it seems like the focus behind kotlin native is iOS. Is there any interest in targeting Go's space of containers/CLI and Ops tools, maybe with a scheme for Go interop? Right now Go is the main choice there because there aren't many GC'd/higher level languages that can be statically linked (no runtime, easy deployment), with decent concurrency primatives but low level enough to do process management/syscalls/etc.
Any plan to introduce `if-let` to Kotlin like there is in: * Go `if x := f(); x &lt; y {}` * C++ `if (auto x = f(); x &gt; 10) {}`
&gt; A more particular question (maybe I missed it somewhere) - Is there an if-null -&gt; then do-something -&gt; else do-something-else shortcut? Most answers revolve around using let? in association with "?: run" bloc Why do you need a shortcut for plain `if-else` expression? 
Anything is a good replacement for AsyncTask. And you can achieve the same with coroutines (run some code in background and return result to the UI thread) but with much better API
Kotlin/Native v0.5 shall contain C language interop, and one could use it for interop with Python or R. 
&gt; Do you guys also believe that everything will eventually be Javascript? I hope "No" :) &gt; Also, what were the main challenges of making Kotlin compile to Javascript? * making good interop between Kotlin and JavaScript * it's hard to map some Kotlin features to JS ** especially things that have lazy semantic in Kotlin * file-to-file compilation (isn't done) * supporting full Kotlin reflection (isn't done)
TIL. That's pretty useful. Not maybe as expressive as say, F#, but useful.
I realize that it would be quite a breaking change but have you guys considered changing the default visibility from public to something like internal or package (and maybe private for fields and member functions) I really love Kotlin but I think the default visibility should be as restrictive as possible and having it a conscious effort to increase it, rather than today where everything is public by default
Value of Kotlin/Dart is not yet clear to us.
Most important is lack of proper DOM/HTML5 APIs access.
&gt;Thereâ€™s wonderful project called KScript (https://github.com/holgerbrandl/kscript) by Holger Brandl What would be the performance and ressource usage difference between that and for example python? Would be super interesting as a replacement for light user scripts.
Our current plan is to support checked exceptions via IDE inspections. Kotlin already supports the `@JvmThrows` annotation which is equivalent to Java's `throws` tag, and the inspection will warn you about exceptions that are known to be thrown by the methods that you call but not handled inside the method and not listed in the `@JvmThrows` annotation.
Technically it's more like a backend :). But actually our goals are more ambitious: we want to create Kotlin for native development, not give a way to run J-language on some other platform.
Don't shoot the messenger
If you mean support as language first-class citizen?
Alright, guess it's time to learn coroutines then ðŸ˜‚
* We do not view the number of keywords to be an important concept at all. The number of concepts is the important thing, and for each concept we decide whether it's best to represent it as a keyword or something else. Not sure what you mean by making the grammar really complicated; the support for context-dependent keywords in the actual Kotlin parser isn't complicated at all. * `inline` is much more than an optimization hint to the compiler. Among other things, it enables the use of non-local returns and reified type parameters, both of which greatly affect program logic. * No, we didn't make any attempts to unify enums and sealed classes, and I don't see many advantages in doing so. * See Andrey's answer for union/intersection types below: https://www.reddit.com/r/Kotlin/comments/7hoytl/kotlin_team_ama_ask_us_anything/dqssiny/ . We also think that Kotlin's first-class syntax support for dealing with nulls is a big advantage compared to languages that only rely on generic type system features for nullability, and not a problem that needs to be solved.
See https://discuss.kotlinlang.org/t/a-bit-about-picking-defaults/1418 for a post explaining why the defaults are the way they are. We don't have any plans to change it at this time.
To do the same in a more 'functional' way.
Union types might be hard to support on JVM considering interop with Java. There's no way to encode union type in a signature of a method, so that every public method accepting union type would have to make a series of `instanceOf`checks in the beginning to enforce that union type in runtime.
In my opinion, it is language's meta-feature: it's fun to think and code in Kotlin.
it will be grateful if Android+Firebase fans able to write Firebase cloud functions, webhooks completely in Kotlin! use cases: being an Android developer I want to skip learning Node.js at least while using Firebase! build a complete app development using Kotlin :) 
You've answered your own question. Supporting yet another language costs a fortune - not only for JetBrains, but also for developers and companies having to (see Android) adopt it. What makes Kotlin so different from existing modern languages that justifies that cost? I work on projects written in C++ (Linux), C# and F# (mostly Windows, Web and some Xamarin), Java (Android) and Python (anything data). Now we're adding yet more languages (like kotlin - and swift) - while I dream of one day being able to use a single modern language across all my projects. Wouldn't productivity rise with fewer languages - because less to learn, more code reuse, fixing bugs only once instead of n times,...? 
At this time the Kotlin/JVM and Kotlin/Native compilers only share the frontend. We're currently in the process of moving to a new architecture, where Kotlin/JVM and Kotlin/Native will share a common proprietary IR which will then be translated to the JVM bytecode in the case of Kotlin/JVM and LLVM IR for Kotlin/Native.
Hi Andrey, I am not sure if you remember me but I used to be very active with Kotlin forum circa version 0.5 - 0.9 with (https://github.com/dodyg/AndroidRivers). I am really looking forward to Kotlin/Native and Web Assembly support. Kotllin is amazing. It's just that Android programming is a bit meh. 
This concern is valid for authoring libraries. We have a plan to support library authoring mode where there would not be default public visibility and specifying explicit visibility would be mandatory: https://github.com/Kotlin/KEEP/issues/45
Are there any language design decisions that are now locked into the language that you regret?
You can do that now using Kotlin/JS. I've created small proof of concept that uses Gradle infrastructure and Kotlin JS to build and deploy functions, there is a few pitfalls, but still quite straight forward, it's just js code
I would like to kontribute but I am overwhelmed by the size of the project. Any advice on where to start? I mainly miss a Wiki on how do to this thing or that thing...
It really depends on the usecases: - sharing immutable structures is something we believe shall be feasible - sharing mutable structures is evil and we do not believe it's productive to do so - transforming mutable structures to immutable and then sharing is an area where we believe a lot of fun could happen
Is the JNI/JNA still the preferred way to interop with native libraries, or is that expected to be supplanted by Kotlin/Native?
Yes, it's being looked at by an external contributor, see https://github.com/JetBrains/kotlin-native/pull/1062
GUI?
Mine are C# and Python.
Do you plan on running tests against a few Kotlin frameworks from multiple domains before the releases? I recall Kotlin upgrades breaking some tests in [KTX](https://github.com/libktx/ktx) at least twice.
&gt; Maybe with a Kotlin/Dart target? I think it would make more sense to have a Kotlin/native version of flutter that used the Kotlin language and the flutter ui framework (which is also native). In other words, Kotlin/native would replace Dart and its runtime.
It's very open ended question: we're working hard on making Kotlin/Native pretty universal tool, including multi-platform support and areas where Go is currently being used. JetBrains is heavily investing in Kotlin/Native, so both compilers and toolchains shall improve rather quickly.
Thanks for this decision, I like this syntax very much! 
In general, it's much easier to start contributing to the tooling. Any changes to the language or the standard libraries need to go through the design process first, and this is unfortunately non-trivial for an external contributor. For tooling, the best source of documentation is the IntelliJ Platform SDK at http://www.jetbrains.org/intellij/sdk/docs/welcome.html There is not much Kotlin-specific documentation, mostly because the current set of APIs for interacting between the IDE and the compiler is very likely to change soon. However, you're welcome to ask for help on the #kontributors channel in Slack.
Seems you somewhat misunderstood the notion of 'inline' keyword. If compare to C/C++ it's more like macroses/templates, not inline functions, and it's not an optimization, it's a way to achieve certain important language features.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/firebase] [Requesting Kotlin as an option in writing Firebase CLI\/Firebase console](https://www.reddit.com/r/Firebase/comments/7hqo6v/requesting_kotlin_as_an_option_in_writing/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Coroutines are not against RxJava, you can use them together. We even have a support library, and it makes everything even simpler (https://github.com/Kotlin/kotlinx.coroutines/tree/master/reactive/kotlinx-coroutines-rx2). As about references and guidelines, I think it's just a matter of time. We provide a tool, and it's up to you how to use it :) There are so many architectural approaches so it's just impossible to cover it all by ourselves.
I'd really like it if `when` made you explicitly enumerate every case (no `else`) when a sealed class is passed as an argument.
Are there any plans to support "real" pattern matching like Scala does? 
What is the usecase you have in mind? Language like Kotlin has a lot of implicit cycles, coming from things like inner classes many mildly nontrivial datastructures.That's why we believe cycle collector is a better option. 
thanks!
You, /u/abreslav, mentioned in one of your talks that you plan to introduce an advanced meta programming system to Kotlin. Is this more concrete now?
Real Java 7 support (try with resources) available only from Android 4.4, other Java 7 features is just syntactic sugar and just preprocessed before compilation. Jack was always experimental and deprecated now and even now with Desugar it's not a real Java 8, because it's emulation of lambda and method reference on dexing. Real Java 8 available only starting from Android 7 (and doesn't include all Java 8 packages)
Yes, it shall be possible, however benefits of doing that may be questionable.
Hey there! I'm Kotlin tooling QA. Can you give an example of what you mean under "multiple domains", so I could understand the question better? You may also give an example of "broken test" in the project. The thing is, we have tooling testing and we also have [acceptance tests](https://medium.com/@liliia/kotlin-test-environment-fdc53500b711) for every release :)
&gt; At least : v1 , v2 , v3 , map1(), map2() and map3() We could introduce additional extension functions for Pair and Triple given that they cover a significant number of use cases. Feel free to file a request to http://kotl.in/issue 
Oraginally I have posted this [question](https://stackoverflow.com/questions/47588670/what-is-the-purpose-of-empty-class-in-kotlin) on Stackoverflow. I hope you will answer it 
We're already working on it: atomickotlin.com. There'll be a book suitable for beginners and an accompanying course within IntelliJ Idea.
I think Android might be a particularly poor showcase of coroutines, because of the Android lifecycle where the current view can be killed at any time. Afaik coroutines are not as easily disposed as streams, which means extra work and logic to handle those cases properly
Im aware of everything you just mentioned though even starting at android 7 its not "real" java 8. Its still desugared java 7 bytecode 
I'll go out on a limb and say C++.
You can define an empty class in basically any language that supports classes. Such a construct is unlikely to be useful in real code, but there is no reason why it needs to be an error, so it's allowed.
Sure, almost anything available on the platform: https://github.com/JetBrains/kotlin-native/tree/master/samples/gtk (GTK) https://github.com/JetBrains/kotlin-native/tree/master/samples/tetris (SDL), https://github.com/JetBrains/kotlin-native/tree/master/samples/win32 (Win32), https://github.com/JetBrains/kotlin-native/tree/master/samples/objc (AppKit) https://github.com/JetBrains/kotlin-native/tree/master/samples/uikit (UIKit) 
Kotlin/JVM is a language, running in managed environment, as such it uses notion of object reference, not raw memory address (more or less index in address space of the process). Kotlin/Native allows interoperability with C, so it has class CPointer, representing pointer in C world. 
Re: common libraries. Why? There's plenty of high quality solutions in Java ecosystem already: Okio Okhttp, Gson/Moshi/Jackson, JodaTime, etc.
Frontend (shared between Kotlin/JVM and Kotlin/Native) produces Kotlin IR (high level, tree structure) + descriptors tree. Lowerings transform IR to more basic operations, then native backend produces LLVM bitcode, passed to LLVM tools to produce machine code. 
We're definitely considering adding support for default common implementations in multiplatform projects. Subscribe to this issue to stay tuned: https://youtrack.jetbrains.com/issue/KT-20427
Libraries solving different problems and likely to use different language features. Like web (JS), server-side, data science, game dev and so on. Basically, it would be nice if the full test suit included cloning recent builds of popular frameworks, changing the Kotlin version and running all automated tests. As for the issues, some recent ones include: * Kotlin 1.2.0 [was released with a inline block-related bug](https://github.com/libktx/ktx/issues/94) which causes a compiler error. * Kotlin 1.1.4 [stopped working properly with Mockito](https://github.com/libktx/ktx/issues/100), causing a few tests to fail. * Kotlin 1.1.2-4 [caused multiple issues with stdlib and coroutines](https://github.com/libktx/ktx/issues/76).
In the scope of multiplatform projects, we are looking into a design that can cover the use cases of partial classes too, but it's too early stage now. When we shape the idea out, there will be a public proposal
Sorry I'm not a big LLVM follower so I think I understand the concepts but probably not the terms ;-) The main problems we saw when we evaluated using RoboVM was in the complexity level on tracking Apple in iOS. Back when they launched they only had 32 bit support. Apple migrated to 64 bit in less than a year since they announced it. We predicted that in advance and chose not to use RoboVM which had a hard time with the port. Since then Apple announced bitcode (but only requires it for watch development at the moment). The guys from RoboVM categorized bitcode support as "the hardest thing we ever did". I have no idea why because with our VM it "just worked". So my question is, do you guys support stuff like bitcode and how will you deal with curve-balls like this that Apple keeps lopping towards developers? Our solution was to generate a C based xcode project, that way we sidestep the whole issue of toolchain changes. It sounds primitive but as I said 64 bit and bitcode required literally zero VM changes on our part. It also provides a lot of great advantages as you can literally debug/profile within xcode which is really neat.
Kotlin/Native is fully supported for Linux, macOS and Windows hosts and targets, so it could be easily used in places where static binary is needed (i.e. microservices).
We're writing the book suitable for beginners, but it's not ready yet. https://www.reddit.com/r/Kotlin/comments/7hoytl/kotlin_team_ama_ask_us_anything/dqt0j7t/
Kotlin/Native is not intended for writing native methods in JVM ecosystem, it allows to use Kotlin in native ecosystems. However, there's interoperability mechanism (developed for needs of Kotlin/Native) that could allow transparent calls of C code from Kotlin/JVM as well. See https://github.com/JetBrains/kotlin-native/tree/master/Interop. It is not yet released as separate product, although.
We'd like to do this, just have many other things on our hands. But it's near the top of our priority list for the future
I thought it does?
I have interest in this question too.
For us things aren't too hard, as we integrate into existing ecosystem, not pushing Java concepts into that. See for example this code (Spinner demo from KotlinConf 2017): https://github.com/JetBrains/kotlinconf-spinner/blob/master/kotlin-native/samples/fullstack/clients/ios/src/main/kotlin/main.kt It uses Apple's APIs, and for the bitcode, we already use LLVM codegeneration, so it is not that hard for us to follow Apple advances (as long, as they keep using this technology). 
Thanx, I am looking forward for it.
God, I hope so.
I've presented the idea of kotlin native to fellow iOS developers and all the reaction was "hey it's cool but I hope not some garbage collector runs in the background". They want the same memory management approach as with swift (weak var...) I was not sure if it is possible to implement the same way as in swift/objC.
Only if the value returned by *when* is used
Are there plans to move into the Data Science/Machine Learning/AI area with Kotlin? Especially when a language is created by the same people as the best IDE there should be opportunities.
I think you can use vue.js and Kotlin/JS together now, but it will not be so smooth since Kotlin/JS doesn't support file-to-file compilation. I've found few examples, take a look them: https://github.com/nosix/vue-kotlin https://github.com/gbaldeck/vue.kt 
Perfect! Featurewise Kotlin currently has everything I could wish for. Better IDE and compiler perf are actually my only gripes I have with Kotlin (though it's not too bad).
For me C, JavaScript and very carefully subsetted C++.
I'd say the best person to ask this question from are Android developers, and there's a ton of blog posts and videos online about some of the benefits of Kotlin when doing Android development. From our side we do provide some information http://kotlinlang.org/docs/reference/android-overview.html
Kotlin is designed to be a general-purpose language and just like other unversal languages that are used at ICPC (take a look at C++, Java and Python) it is normal if some specific use-case like reading from console requires some effort. Take a look at a case of reading a line with two ints. Unlike both Java and C++, it is already one-liner in Kotlin (`val (a, b) = readLine()!!.split(" ").map { it.toInt() }`. It is longer than the corresponding one-liner in Python (`a, b = list(map(int, intput().split())`), but IMHO way more readable and streamlined (fluent). We don't have any special plans to streamline this specific use-case, but some other general improvements to the standard library in the future might be benefitial for storts programmers, too. I don't think that JIT warmup is something to worry in sports programming contests. For example, Legendary Grandmaster Petr Mitrichev writes mostly in Java, so JVM for Kotlin definitely would not become a handicap in sports programming. Unfortunately, some contests give problems with time limits that are so tightly set that solutions require lots of non-asymptotic optimizations to the point where they are completely unsolvable under JVM. I cannot help here. I can only ensure that it does not happen in the contests that I do organize, since I don't see any value in contest problems like that. We hope that Kotlin/Native, when it is released, will become a viable alternative for sports programmers who are looking for a modern that lets then clearly express their idea in code without having to worry about JIT warmup. 
Bidirectional C &lt;-&gt; Kotlin/Native interop is being worked on, and hopefully will be available in 0.5.
Yes, it's being discussed.
RemindMe! 2 hours
What kind of pitfalls? Can/should anything be fixed on Kotlin side?
What about C++ frameworks? wxWidgets and Qt
Kotlin: * had superior IDE integration from the start * better support for type-safe builders * much better Java interop * a simpler typesystem which was still an improvement over Java * Android dev as a killer feature
Show them KotlinConf spinner app, https://itunes.apple.com/us/app/kotlinconf-spinner/id1291282375?mt=8, Kotlin/Native doesn't have classical GC which intoduces pauses, so behavior shall be liked by Swift devs.
As soon as JVM adds intrinsics for xbegin and xend. I really hope that JSR to do that would appear quite soon and you can help by lobbying your OpenJDK representative to support it.
First, thanks for the great language and tools! I've heard a couple of interviews with the Kotlin team members that referenced some evolving the language by deprecating / removing features. Can you share any thoughts on what things might be removed, timeline (I assume one deprecate release, with tooling support to migrate) and rationale?
We could have done companion objects better, and inheritance by delegation too. We'll probably be able to fix these in the future, but it will take a long time
No "real" plans :), but the topic is coming up time and again, so it's not entirely out of the question. I'm still not convinced there's enough use cases besides what's already covered by when expressions and smart casts, though
What is the missing functionality of sealed classes?
Not sure if you know already, but have you seen the [`expect` and `actual` constructs](https://kotlinlang.org/docs/reference/multiplatform.html#platform-specific-declarations)? It is one of the ways they are planning on leveraging platform-specific implementations (such as for dates) on shared code. 
I don't think Kotlin Native is enough to replace Electron. You need a UI framework on top of that, like SWT or React Native to provide another layer of abstraction on top of the native components/objects. One of Electron's big selling points is cross-platform compatibility, including for UIs.
Ð¡++ automatic interoperability is not implemented, however using C bridges or reverse interop (using C bridges to Kotlin/Native) may help.
Multiplexing of M Kotlin Coroutines onto N hardware threads already happens automatically. Just like in Go(lang) you can have many hundreds thousands and millons of coroutines running on just a handful threads, you can communicate between them using channels, etc. You can already write CSP-kind of code with coroutines. You can read read more about those capabilities in the guide to kotlinx.coroutines: https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md
Any plans to better showcase Kotlin capabilities and advantages on it's website? I admit it took me months and multiple read articles to jump into Kotlin train 14 months ago after I first heard of this language and went onto it's website where I didn't understand the point of removing semicolons and the enclosing class. I'd be nice to have a snippets of nice code for popular usages. Non exhaustive proposal : * main function (already present) * Complete Android Activity using Kotlin android extensions and lambdas (already present) * Null safety examples with safe call operator (maybe elvis operator too) * relevant examples of extension functions and extension properties * beginner understandable lambdas examples * side by side java bean vs kotlin data class * side by side java 6 hardly readable code vs kotlin readable equivalent * html builders full simple page example (using table only isn't very good showcase IMHO) * ktor example or link * coroutines examples from Android apps, servers... Also, making the code snippets font smaller would help readability when close to screen, and would allow more more meaningful content. Also, could you make kotlinlang.org and try.kotl.in look a bit more modern? Or maybe we can open an issue to discuss this somewhere?
Nitpick, but Kotlin doesn't really "have" reified generics in the sense that most of us think of it. It supports inlining functions, and while inlining a function, you can easily reify a type param of that function, because you know at compile-time what it actually will resolve to. Your `T::class`, which is not valid, would turn into a `String::class` when inlined at the call-site, for example, which is valid.
Mine are Java and Python
One small thing... I miss my CTRL + ALT + C to make a constant with java. This feature doesn't exist using Kotlin in Android Studio, will this make a comeback?
Have there been discussions about expanding `when` to allow for more complex pattern matching Ã  la Scala `match`? I always find `when` to be lacking when I'm coming back to Kotlin from a project in a langauge that has better pattern matching (Scala, Rust)
I vaguely remember Andrey Breslav told he "regrets" something about interface delegation design. Could we know more about this and what should/could change in the future?
When I run gradle with --no-daemon, are there plans to have Kotlin use this parameter?
Is the JVM limiting? Are there certain features that have to be added to Java/the JVM first before Kotlin would be able to add them? Sorry if this doesn't make much sense, bit of a noob :)
Currently the Android Nanodegree at Udacity (supported by Google) is one of the best courses offered right now. With the fact that Kotlin now being officially supported by Android Studio and Google encouraging developers to write apps on Kotlin, are there future plans for an online course for Kotlin on Android?
for cloud functions, kotlin containers take much longer to boot up and run your code vs a node container. kotlin has the huge overhead of the JVM which makes constantly respinning up new containers for each request eat up response times.
I think the lack of union types makes it a little less powerful.
Great, thank you!
It has to be exhaustive if `when` is an assignment, but you can still use `else` to achieve that. This means the compiler doesn't yell at you if you add a new type to you sealed class.
No plans to compile to Dart at this time. We probably won't have the resources to write tons more examples for coroutines (or any other topic, for that matter), but I'm sure there will be lots of community-created resources on this topic. The underlying machinery of coroutines is fully cross-platform and is already supported for JS and Native. The high-level kotlinx.coroutines library is currently JVM-only, but we plan to port it to other platforms to the degree that it makes sense (a lot of it is integration with other JVM-only libraries).
I was wondering if Kotlin is mature enough to be my sole scripting language. I work for a telco and I use Python to automate reports etc, for instance. However, since I am also interested in mobile app development, I would like to adopt Kotlin. Also, at the risk of sounding ignorant, is script Kotlin the same as Android dev Kotlin? What I mean is that, are there structures etc that make using the language on either platform unique to them or once I learn on one, I can pretty much code on any other platform. P.S I apologise for my poor English. The language is not my first one (that would be Java :p)
I'd say that at this point you need to be able to at least read Java in order to learn Android development at this time. Most of the samples and documentation for Android will use Java code, and you'll need to be able to understand how it translates to Kotlin.
Kotlin coroutines work great with Android when the application has good architecture with separation of views and state management from application logic. Using coroutines with Android architecture components is especially effective. The corresponding examples are strating to appear in internet blogs. 
I'm not really sure why people want collection literals. They don't read well to me at all. Is `[0]` a `List&lt;Int&gt;`, an `Array&lt;Int&gt;`, or an `IntArray` (uses primitive `int`s, not boxed `Int`s)? How do you express a `Set&lt;Int&gt;`? How do you express a mutable collection? All this added complexity and baked-in language features just because people don't want to write `listOf`?
Classess infix functions are not supported yet, right? Also ones with more than one parameter, although I can see why you wouldn't implement that one.
Yes, it's basically the same language. There are some Android-specific extensions (they're optional, so you don't have to learn them), and the syntax for accessing the command line arguments is specific to scripts (but it's really simple), but otherwise it's the same.
We don't have any plans to create an Android-specific Kotlin course at JetBrains, but there are lots of courses already created by the community, and I'm sure there will be many more.
Possibly (although in most cases introducing a constant in Kotlin is exactly the same as introducing a variable). You're welcome to file a feature request in YouTrack.
Traditional macros are very hard to support well in the tooling, and I believe that tooling experience is more important than any one language feature. In terms of metaprogramming we are looking into less invasive ways like compiler/IDE plugins and techniques similar to bytecode rewriting, but for all platforms.
See Andrey's answer here: https://www.reddit.com/r/Kotlin/comments/7hoytl/kotlin_team_ama_ask_us_anything/dqt2wq2/
That seems like it makes WebAssembly a non-starter rn.
We haven't discussed this. At first glance there don't seem to be many situations where this would make the code more readable.
&gt; what are sprints like I can shed some light on how the compiler team organizes itself, but I doubt there's anything surprising there. We usually gather for an hour-long meeting each week, briefly discuss what's been done and what's not, what should be done during the following week, whether someone has a lot of work and it'd make sense to distribute that work among colleagues, etc. Then we discuss a bunch of language/compiler issues that we met that may need some brainstorming to be solved. Small issues are usually solved right away, bigger issues are redirected to the language design meeting, which happens several times a week and includes people from other sub-teams across the project (such as libraries, tooling, Native) for a better perspective. As soon as everyone on the language design meeting is OK with the solution, someone from the compiler team starts implementing a prototype, scheduling further language design meetings if necessary, i.e. if the design is unclear or if new related issues come up. &gt; how does the team decide on features (new or breaking changes) Right after a major release, we have a planning session, after which we usually have a rough understanding on what major language features do we want in the next release. I'd say the main consideration for a language feature is what use cases are enabled by it and whether workarounds / alternative solutions are too ugly at the moment. There are a lot of others though, such as would the feature be so complicated that it'd break our brains while we're trying to design it, or the brains of our users as they start using it, etc. Besides major language features, lots of smaller ones come up between releases. Those that we feel like should be solved immediately, are investigated at the language design meetings (mentioned above). Breaking changes that are just bugs in the compiler are usually discussed at the weekly compiler meetings and are mostly dealt with as standard issues. &gt; do your internal code reviews differ from those on public repos We mostly use [Upsource](https://www.jetbrains.com/upsource/) for code review, but smaller changes are also reviewed by some team members directly on GitHub. Every commit that goes into master must be reviewed by at least one other team member.
Kotlin loves functional programming. A number of Kotlin features are specifically designed to nudge developers into functional programming paradigms. It is easy to work with immutable data using `val` as opposed to `var`, defining immutable data structures is a joy in Kotlin and Kotlin syntax is specifically optimized to make it easy using higher-order functions via consise and consistent lambda syntax. Even IDE nudges developers to manupulate state via pure functions as opposed to just mutating state, as all vars are underlined in IntelliJ IDEA to make them stick out like a sore thumb. Kotlin standard library and its type system is specifically optimized for FP, too, by providing read-only collections by default and forcing you to opt-in into mutability. A rich library of functional collection-manipulation operations is available out-of-the-box in Kotlin stdlib. It is hard to compare that with Go language as none of those efforts are visible there. It looks like Go language design is centered about CSP-style imperative programming without any emphasis on functional paradigs of purity and immutability, and with only nominal effort to make higer-order functions easy to use. 
&gt; When will Kotlin-frontend be considered "production" ready as compared to the current React ecosystem i.e. is there a plan to keep it up-to-date? Kotlin/JS is production ready and we actively work on Kotlin/JS related things. If you missed anything feel free to file an [issue](https://kotl.in/issue) or to write it here.
See Andrey's answer here: https://www.reddit.com/r/Kotlin/comments/7hoytl/kotlin_team_ama_ask_us_anything/dqt56nv/
Can sealed classes satisfy some of this? https://kotlinlang.org/docs/reference/sealed-classes.html 
IIRC because noone of the existing languages met their requirements like full Java interop, concise, toolable, promotes good practices
Kotlin is already a 1st class citizen on Android. Releasing a Kotlin-only API is not possible, because Kotlin is fully interoperable with Java, and any Kotlin API can also be used from Java.
Is there any hope that we'll have a better build environment? I personally don't like gradle (too much magic), and would rather avoid learning a pretty much dead, full blown language _just_ for building.
Understood. Thanks! Really excited to see what the future holds for Kotlin.
An example of such feature would be value types (structured stack-allocated objects) which would make perfect sense in Kotlin and especially Kotlin/Native. We're looking forward to the [Project Valhalla](http://openjdk.java.net/jeps/169) that aims to add support for value types on JVM.
Is it planned to a body to annotation classes? To make thinks like Intdef from the android support library useful on kotlin? 
&gt; = null) check". They should really adopt the way Kotlin behaves and deprecate guard imo `guard` is not a null checker. Is for avoid pyramid conditionals. And also is useful to break/continue loops, or throw error (instead use of return). Is a really versatille feature.
In CE using grade does not execute tests either though :(.
Hi! It will be great to add an option on Android Studio or Intell IJ that allows us to convert a groovy based gradle build file to a kotlin one. It's not easy to do it. And when can we expect the 1.0 of the kotlin support of gradle. Thanks.
If you mean instructing our Gradle plugin to avoid firing up a Kotlin compiler daemon, then it's currently possible with `-Dkotlin.compiler.execution.strategy=in-process` in Gradle JVM options. There are plans to make a user-visible API to the compiler daemon: https://youtrack.jetbrains.com/issue/KT-17170
Also keep in mind that the JVM is a bytecode interpreter which runs on many platforms. So JVM bytecode is a multiplatform language which seamlessly shares code cross platform. The Clojure community has come up with a usable (if inelegant) solution as well. They wrote cross platform code in files with a cljc suffix and allow multiple implementations for each function with lookup by calling language implementation. Code that doesn't use host language features (JS or Java in clojure's case) don't need multiple implementations. Like creating a port library for your code base. These aren't perfect solutions, but they are places to start working from to build a more elegant solution in kotlin.
Yes, we are looking into it at the moment. Please subscribe to this issue: https://youtrack.jetbrains.com/issue/KT-11392
In a recent episode of Android Developers Backstage (http://androidbackstage.blogspot.de/2017/11/episode-81-gradle-sync.html), the Android tools team mentioned that they're looking into building such a converter. Once they do that, it's likely that we'll be able to integrate it into IntelliJ IDEA. The Kotlin support for Gradle is built by the team at Gradle, so you should ask them if you want to get the most up-to-date answer.
A book that doesn't require Java knowledge is coming (https://www.reddit.com/r/Kotlin/comments/7hoytl/kotlin_team_ama_ask_us_anything/dqt0j7t/), we're also thinking of doing the full course.
Which means everything will eventually be written in different source languages, oh wait! Thats already how it is and what drove us to a sub-optimal language like JS!
Where ask for another Jetbrain's products? I want to know if YouTrack is much for a solo developer.
What's on the wish list for Kotlin 2.0?
My use case: Windows desktop. I develop software for forest engineering and environmental engineering. I want to stop developing with Delphi. I want to write a Visual Component Library like Delphi's VCL and (re)write all my new programs in Kotlin. I'm sick of Delphi.
Do you take inspiration from non-JVM languages? If so, what are they, how do they inspire you?
Why don't you simply give it a try and see if you like it? You can create a hosted instance of YouTrack supporting 10 users for free.
[removed]
Multi-platform code. More features in stdlib - less platform-specific code you have to write for each target.
[removed]
I believe Kategory will benefit more from being developed as a separate library with its own release cycle. However some of its well-known data types might eventually get into the standard library.
This is good, but not enough for cross-platform development IMO. Kotlin needs something like Xamarin.Forms. People use Electron because they don't need to worry about other platforms. 
Take a look at [How to Kontribute by Yoshinori Isogai](https://www.youtube.com/watch?v=-y2vW94mBDE)
... which is bad indeed.
Hm... even if not, competition is nice. It pushes the powers to be to add the good stuff. You see C# and Java do this a lot
Thank you !!
When are you guys going to start to rewrite JetBrains' tools in Rust?
To add to others: if you bring it to the Community Edition as well, there'd be a free way to do Kotlin/Native development with the best available tooling. Of course this is a business decision, this could also be a great differentiator to get an Ultimate subscription.
Glad to hear this. The IDEA formatting options for Kotlin are very disappointing right now compared to the excellent options for Java.
I like this syntax much more than Java. Less characters, better contained bounds for a lambda with the braces, and no less legibility than in Java.
Kotlin serialization is designed with performance in mind. Serialization code is included during complication and no reflection is used during runtime, so it should vastly outperform most other JVM JSON serializars that are mostly based on reflection. Unfortunately, the current preview release of serialization library depends on kotlin reflection in a non-essentioal way. This dependency will be removed in the future updates.
I don't think it support auto-completion, sadly.
You can try writing code in Kotlin straight away. But you still need to know Java basics to read Android documentation and tutorials. We have some intro tutorials here: https://kotlinlang.org/docs/tutorials/getting-started.html, https://kotlinlang.org/docs/tutorials/kotlin-android.html, and then koans https://kotlinlang.org/docs/tutorials/koans.html.
Kotlin does have limited support for macro-like facilities via inline functions and there are some ideas on how to expnad that feature to support more use-cases that are solved via macros in other languages without sacrificing neither good and clear error message nor tooling support.
I'm not the guy doing the AMA, but no. Android development will require solid knowledge of Java since you'll need to interact with the framework and Java libraries very frequently. 
Would Kotlin ever written a documentation that similar to Swift? Mainly for Android development?
Since you're talking about tutorials for a specific environment that's not really in JetBrains ballpark. Google is currently porting a lot of their documentation to kotlin, especially for newer libraries/features, but don't expect it to ever be comprehensive.
Why? It's a perfectly fine pattern, since you're not assigning it anywhere. At best, the editor could give you a warning, but even that would just be a nuissance.
What's your elevator pitch for why I should learn Kotlin, if I already know C++ and Python and a little Java?
I really enjoy writing Kotlin for Android and the coroutines library makes it really much easier than Rx or other options. I really like the idea behind Native and would love to see it blossom. I think coroutines should be/are a huge part of that. Thank you for all the hard work! Android development is pleasant again!
I think it's better the way it is, since it encapsulates the entire lambda, and the arrow is a clear delimeter already. Also, defining lambdas inline, e.g. val lambda = { x -&gt; x * x } is nicer than val lambda = x -&gt; { x *x }, IMHO.
To be useful the python/R interop must be transparent, meaning that any python/R api can be called in an obvious way. It would probably require a special effort in tools and IDE to make it workable. Do you consider that as a possible investment?
If that's the worst of it then you're doing very well :)
We are not ruling out possibility of creating UI DSL or library. Stay tuned.
Pretty much, although we are working on JS interop, similar to what we have with C on other platforms. This way, JS DOM accessors could be used.
Whats one cool thing you like about Swift?
This is something I'm also interested in. I write books that teach Python to beginners, and I've been thinking of how I could do a Kotlin book because I really like the language. But given the complexity of OOP and Android, I'm having trouble coming up with how exactly I could teach Kotlin to teenagers and beginners.
I'm a fan of exhaustive pattern matching.
Any plans on adding things like higher kinded types? :)
Once you are used to it â€“ you use it quite often. The alternative is to wrap code into its own block, which looks much more ugly: if (auto x = f(); x &lt; y) { ... } vs { int x = f(); if (x &lt; y) { ... } }
Any plans on providing cross compilation for Kotlin native projects (something like Golang provides). My use case is to build some CLI/Server apps (assume using kotlin std libs &amp; posix apis) and could be able to build the native binaries (win/linux/osx) on my Linux build machine.
At JetBrains we're more concerned with unified project model description, which is scriptable, fast and repeatable. So, we're looking into what can be done here. Build is rather different story.
How would you improve on the companion objects? Maybe a pseudo-code example?
They're talking about using Kotlin/js to do it using node, not the JVM
Also there is http://kotlinbyexample.org which accepts contributions.
I don't think release cycle will change a lot. Small features can get in a bit faster. But the big features will still take years to develop.
Sorry, it looks like yours is not a question but rather you're trying to say that we shouldn't have built Kotlin. Well, Kotlin is our take on making programming more practical, predictable, safer and... fun. Any other company (or group of people) are free to make their calls here. We are learning from other's attempts and others will learn from our. Net result is beneficial to everyone. Unfortunately it's not an option most of the time to build on top of some other language because of backward compatibility requirement.
Can this be extended for methods without annotated exception, including Java code? "What exceptions this call may throw" is one of the most common and complicated questions in any language.
Hi, just out of curiosity: How is your relationship with /u/odersky or the rest of the Scala-lang team? Considering Kotlin and Scala share a lot of similarities, do you share experiences and thoughts or is it more of a open "rivalry"?
When the JVM has value types, how will Kotlin utilize them. Will data classes be mapped more or less directly to value types?
How can I use Kotlin native gradle tooling (https://github.com/JetBrains/kotlin-native/tree/master/samples/csvparser) on the newly released CLion IDE? 
This post is still valid and explains some of the reasons https://blog.jetbrains.com/kotlin/2011/08/why-jetbrains-needs-kotlin/
We are watching closely DS/ML/AI areas and incorporate the corresponding use-cases into our language design process. Kotlin, as a language, is already expressive and extensible enough so that many DS/ML/AI use-cases can be implemented in libraries in an esay to use and readable way with full benefits of type-safety and tooling support. Community is already working on the corresponding libraries and we support those efforts as much as we can. I suggest KotlinConf presensation on Kotlin for Data Science by Thomas Nield: https://www.youtube.com/watch?v=J8GYPG6pt5w You can also join #datascience channel on http://kolinlang.slack.com 
Yes I've seen this talk :)
I love Java but I don't have much hopes for it. It is cripped by poorly chosen defaults, pervasive mutability and nullability problems. It is nearly impossible to turn Java into a modern language while maintaining reasonable degree of backwards compatibily. There've been calls from Java community for backwards-incompatible "Java 2.0" many years ago. We finally have it. Kotlin is Java 2.0. The future of Java is Kotlin. 
In competitive programming using libraries is restricted, which robs languages with good ecosystems such as Java or Kotlin. Is there a chance of this situation improving, now that JB is sponsoring ACM? If not, will supporting libraries such as kotlinx be available and could some high level algorithms be added to them (not unlike python) ?
Do you have an expected release date for v1 of Ktor, or an idea of what v1 would include?
Do I advise beginners to start Android development with Kotlin or Java? If it's java for now, when do you expect it be best to start with Kotlin?
Having spent some time with Flutter, I think most people are just wishing Flutter had chosen Kotlin as opposed to Dart. Flutter's way of doing things is a big enough improvement that I find myself using it more and more even though I've not really used Dart before.
I'd say now is a fine time to start with Kotlin. If you're concerned about material, there's already a ton of stuff available and more is coming. 
 Random().nextInt().takeIf { it == 42 }?.let { print("Bingo!") }
Because your job will probably soon require it ;-)
There is no rivalry. We have been, are, and will continue to work with members of the Scala community to provide support for Scala and Scala frameworks in IntelliJ IDEA.
ktor is pretty much feature complete as of now. Currently we are working on some optimizations and inner structure of asynchronous data streams, in particular migrating to new channels developed in context of kotlinx.coroutines. Also we are working on async http client which is used for internal stuff (mainly OAuth) and will be available for microservices in experimental mode. We expect to finish main work this year and release a beta soon, with long enough period before v1 release in January. These are tentative plans and it might slip slightly if we find some major roadblocks. 
Yes, look at FreeSpec
*That.*
Ah, I see. Well, actually we already do it exactly as you described: having a set of internal projects using Kotlin, such as IDEA or [Ktor](http://ktor.io/), we do compile and other tests with them before every release. We also check a set of popular frameworks and other well-known user projects in the same way, cloning them and running all the tests. So, generally, we actively work on it to deliver the quality product and we continue the process improvements. I think we'll proceed the expansion of the products set, so the answer to the initial question â€” yes, we do :)
&gt; Data science God, yes.
What about inheritance by delegation would you have done differently?
- any plans for cross-compilation to Dart? - what changes to data classes and ADTs in general will there be in the near future? I find data classes to be extremely limited when you're trying to do some functional programming. For example: Imagine you want to model your app's state as a sealed hierarchy of data classes: sealed class State { abstract val list: List&lt;Something&gt; data class Loading(override val list: List&lt;Something&gt;) : State(list) data class NotLoading(override val list: List&lt;Something&gt;, val foo: Boolean) : State(list) } there are several problems with this: first of all, it is extremely annoying to list the common members in every data class constructor. Second, it is not possibly to call `copy(list = something)` on an instance of `State` even though it is clear that all subclasses must have a method like that. Third, given an instance of `Loading` it is not possible to easily create an instance of `NotLoading` from it. It would be nice if there was a `copyFrom` method for all superclasses of a data class, which has default values for all the inherited members, allowing you to do something like this: `val notLoading = NotLoading.copy(from = (loading as State), foo = true)`. A syntax like that would at least half the amount of boilerplate needed to implement functional reactive architectures like MVI on android. 
``` interface A { val a: String } interface B { val b: String } data class Both(override val a: String, override val b: String) : A, B sealed class Either data class AImpl(override val a: String): A, Either() data class BImpl(override val b: String): B, Either() fun getThing(e: Either): Either = when(e) { is AImpl -&gt; e is BImpl -&gt; e } ```
Any plans for supporting GObject-based libraries like GTK in a more object-oriented/'integrated'? way in Kotlin/Native?
To make the story straight, let my first clarify that JB is now sponsoring ICPC (Intenational Collegiate Programming Contest), not ACM. ICPC indeed operates under the auspices of ACM, but it is a totally separate entity. Now back to the question. Different competive events have different rules, but normally usage of 3rd party libraries is somehow restricted (some contents do allow your personally pre-written libraries, though). ICPC allows only the use of languge standard library and I don't expect this to change in a foreseeable future. However, if are to consider adding some popular algorithms to Kotlin, they would likely land in the Kotlin standard library in some shape anyway. The whole "kotlinx" is designed to host various domain-specific things, while Kotlin stdlib is for stuff that people use in many different domains. Various good algorithms usually fall into the second category with the exception of domain-specific algorithms (like geometry, advanced string algorithm on suffix trees, graph algorithms, etc)
 interface A { val a: String } interface B { val b: String } data class Both(override val a: String, override val b: String) : A, B sealed class Either data class AImpl(override val a: String): A, Either() data class BImpl(override val b: String): B, Either() fun getThing(e: Either): Either = when(e) { is AImpl -&gt; e is BImpl -&gt; e } what is missing?
Why Kotlin GC doesn't introduce pauses?
Interesting, how do you deal with the differences between GC and ARC? The problem with Apple has been that they employ some LLVM engineers and do pretty weird things down the toolchain e.g. with the build tools. Since our chief deployment is through the build servers we were able to control our environment very closely but back/forward support with every release of xcode is always a lot of fiddling. Also how do you integrate this with the rest of the toolchain, debugging, profiling etc.? 
I see, that makes sense. Is there anything framework developers can do to make your task easier, so they can be included in the test suite? ;) I'm willing to bet that a lot of us would gladly write a few more configuration files to make it into the official QA, especially if there would be some official documents describing how to do so.
How suitable is Kotlin for game development in its current state?
Thanks for the quick answer and the recommendations. I hope I can use it someday for ML and DS alongside Python. If you guys add support for scripting (like the REPL in Clojure) and a tool like Cargo that 'just works'â„¢... then it might become my favourite language.
What was the reasoning/motivation behind removing Java's package-private and adding `internal`? I like the lack of package-private members and everything being public by default, but I would definitely find use in package-private classes (for example, a small helper class that is only used by a few other classes within that package).
We will be defintely (but carefuly) expanding Kotlin stdlib. Just take a look at new math in 1.2, for example. Why I say "carefully", I mean it. We want to keep Kotlin stdlib generic, i.e. applicable to wide variety of domains. For more domain-specific things (date-time and logging included) we are working "kotlinx" libraries around it and the plan to make them all cross-platform to the largest possible extent. We'd love to see comunity stepping in here (we have no desire to reinvent the wheel), but we also see that we need to step up with some "core" stuff, because we, in Kotlin Libraries team, also dogfood all the new language features and provide direct feedback to the language design process. I personally would love exploring context-sensitive property delegation, so that we can build things like software-transactional-memory on top of it. But it is quite a niche feature that we don't have in the pipeline for the near future.
Right now you can't; the current version of CLion only supports CMake. Gradle support is currently planned for the next major release.
The main reasoning was that package-private visibility does not provide any real encapsulation because any other module can define a class in the same package and get access to your package-private parts. (This decision was made way before Java 9 introduced the split package restriction.) For things like small helper classes, private-to-file visibility usually provides a good replacement.
It is too early to tell as the design for Kotlin/JVM is contingent upon the design of JVM value types, which is still far from being final. Anyway, many design options are going to be on the table.
Rationale is the easiest: we don't want to keep the legacy around forever, especially compiler bugs that can only be fixed through changing behavior of the compiler. Some features may also grow out of date and may need to be replaced, but this not a matter of the nearest future. Yes, we generally keep things deprecated for a while (one release or more) and provide means for automated migration of the code that exhibited the wrong behavior. So far the changes we made affected a very low percentage of the users, and we intend to keep moving at the same pace more or less. Every change is carefully considered and we keep users' convenience a top priority. See more details in this [PR](https://github.com/JetBrains/kotlin-web-site/pull/924).
Assuming Kotlin had to support only java &gt;= 8, are there compiler optimization that might be significant (like using invokedynamic)? Is it already in place or possible to add? Do you think it will have a big performance advantage to applications code?
Can't say much about changes, but there are issues wrt default methods and some more complicated things regarding the semantics of inheritance. See this issue, for example: https://youtrack.jetbrains.com/issue/KT-19830
Swift has an interesting apporach to mutating immutabe data types. I tend to like it. I don't like Swift's approach to memory management. Having to be forced to think about weak refs is so last century. There is one thing that Kotlin does better -- flow sensitive typing, which completely eschews the need for guard lets and other kinds of boilerplate.
Isn't Delphi native in Windows?
I struggle with them and I consider myself a senior Dev! I think it'll get better, but my main problem with them is coming from such a history of Java the questions are really hard to parse. I don't know what it wants me to do half the time.
Itâ€™s hard to reason about performance without specific examples and proper benchmarks. I can just mention a couple of things to be aware of. They all make sense from Java point of view, or when you think of how theyâ€™re implemented, but might be misleading for newcomers. - Itâ€™s important to understand the difference between inline operations on collections and lazy operations on sequences. If you say list.filter {}.map {} operations are inlined =&gt; an intermediate collection is created, which might be an unexpected performance drawback if the collection is big. - We donâ€™t have primitive types in the language, itâ€™s either Int or Int?. But Int is still primitive int in the bytecode (for most of the cases), while Int? is a wrapper type, so all the regular reasoning about primitive / wrapper types apply here. - Our lambdas are truly closures, meaning they can capture a mutable variable, but in this case it works as youâ€™d write it in Java: with creating additional Ref object storing the reference to the variable. And lambdas that capture no variables are cheaper because they are implemented using only one object at runtime. Cool trick: â€œShow Kotlin bytecodeâ€ action, and then â€œdecompileâ€ button. Helps to understand whatâ€™s going on under the hood.
There are ways to explicitly provide the context -the desired type of the result: https://medium.com/@kosiakk/experiments-with-kotlin-array-literals-7f4e75d24ebf
I am a bit nervous to deploy this into production at my company because its in beta, but we started using Kotlin when it was in Beta too! 
&gt; I never get the right one in suggestion. Can you file an [issue](kotl.in/issue) demonstrating this problem? Thanks!
Given that JetBrains is an IDE developer, I understand this, but please reconsider this stance. I'd love to write Kotlin in vim for example, but without auto completion and live analysises it's not worth it. I know about IdeaVIM but sadly it doesn't implement everything the vim world has to offer (and the simple aesthetic of a terminal is sometimes hard to beat). I'm sure people would also like to use VSCode or Atom with the currently best programming language ;)
I saw this, but the syntax is no more concise than the stdlib function syntax we already have, and it seems hacky. What advantages are there when `mutableMapOf(foo to bar)` is already super-explicit, you can easily extend the syntax with your own functions for your own collections, and it's totally divorced from any language implementations in every way?
Maybe a bit of a silly question but as someone getting into android development and kotlin I wanted to ask if there will there be a way to create new android projects straight with kotlin in IntelliJ instead of having to convert the generated java files?
Thanks for your feedback! I'll think about it. But in this case we'll loose 42 tasks, it'll be 43 or 44... :)
It would be so interesting to have it! Just look at the all applications of annotation processing in Java land. Kapt is nice, but it has its toll (and as you've said annotation processing is not the best thing in the world...). So looking forward for this new API and thanks for working on kapt!
At some point in the history it worked and created a const val ... In the class companion object. Is this no longer the suggested way?
Oh, so the number is intentional? Come on guys, you aren't the solution to the universe... yet.
Sure, but a major feature of Kotlin is multi platform development. And I don't think Java will have this in its radar anytime soon. And Java also has a lot of historical baggage which it cant do away with for compatibility reasons. So they will always be constrained.
Aren't you guys from Czech Republic? You could throw one in Prague at least.
Yes, Delphi is native. But the language is old. Same code in Delphi and Kotlin: 800 lines in Delphi, 242 in Kotlin. In Delphi I have to magage all memory allocations, don't have multiline strings, syntax is hard to write lambdas/anonymous functions, don't have string interpolation, etc.
Destructuring is positional?!?! What were you thinking?
Oh didnâ€™t release kotlin could run outside the jvm 
Wow, this might not be a perfect fit for an AMA, but I wanted to express how much I love all your products, tools, and whatever you come up with!
But Jack uses the same approach as Desugar, just don't use javac and compiles directly to dex. And Android 7+ is not real Java 8, but it supports lambdas, method reference on bytecode level, so it's much closer to "real Java 8"
I'm really having trouble with limiting visibility in kotlin. In Java I relied heavily on package-private, I structured my code so that in a directory there were only a handful of public classes and everything else was package-private or private. This style allows creating kind of mini libraries within the app that makes the public interface easy to discover. I really hate that the automatic java to kotlin converter translates package-private to `internal` because that's just a lie. `internal` is mostly useless for organizing a large project. `internal` seems most suited to library developers. In addition to the loss of package-private, kotlin's strict rule function parameter visibility to rules, that function parameters types are required to be at least as visible as the function's visibility, breaks the Dependency Injection trick where you can inject package-private classes to create the one public class. So basically all of my code ends up being public, there's no indication which are the primary interfaces and classes in the app. And feels like it encourages creating a giant ball of interconnected mud. I get the feeling that kotlin's designers are not a fan of visibility modifers as interface boundaries and that they want to encourage us to use gradle modules and other compilation units as the interface boundaries. Is my suspicion correct? Is the idea that we should be writing tons of little libraries? Thanks
For example I've struggled with definition of firebase function as node.js module, you can check this my comment on Kotlin issue tracker: https://youtrack.jetbrains.com/issue/KT-19016#comment=27-2505111 But it's not a blocker, just simplest way to do that (create a public property with firebase function) doesn't work, but you can do that manually, just put function to list of modules manually Also, you probably want to have type definitions for Kotlin to use strong types and code completion, for now you should define external declarations yourself or use ts2kt to generate them from Type Script Declarations, but it also requires some manual fixes. But in a simples cases you can just define declarations that required for your case, it's easy. But it's nothing specific to Firebase, you need declaration for any external JS library 
But Google cloud functions (firebase functions based on them) support JVM for functions, so I don't think that this is JVM problem, they just don't provide Firebase functions API for other languages, at least for now. 
if its similar to how amazon lambda works infrastructure wise, they spin up a new container with your languages runtime on each request. that tends to mean JVM dependent stuff has much higher overhead in regards to spin-up times compared to say, node runtimes.
Yes, probably, It always depends on infrastructure, but anyway GCF supports JVM so probably they have solution for that
RemindMe! 12 hours
Please consider adding support for setting the number of lines minimum between methods like in Java, this is the one formatting setting I miss the most in Kotlin code
Are there any plans to improve error handling in Kotlin? Exceptions don't seem very clean, especially because you can just ignore them, and sealed hierarchies to model the various success / error return values are not always feasible (some methods might generate only a subset of the possible errors, forcing callers to handle impossible error cases). Are there any plans to include a Result/Success/Error data type in the stdlib? While this doesn't solve the general problem, I think it covers many use cases and seems to be cleaner than null-as-error or exceptions. Currently, the official coding style includes very few rules. While some things can be borrowed from Java as suggested, there are many unspecified guidelines arising from different syntax (e.g. wrapping long method calls with named parameters, formatting long method headers, etc.). Are there any plans to update these guidelines, and if yes, when? I would like to have a code formatting check integrated in CI builds. Are there plans to support an aggressive autoformatter like the Google java one besides the formatting rules in the IDE? (e.g. as an official Gradle/Maven plugin) Are there plans to improve Java static-interop? For example, I would like to define private top-level helper methods in a file containing a single class. These would be used by some companion object methods marked @JvmStatic for interoperability, but this way, I can no longer access private or protected members of the class in the helper methods. Also, it's a bit inconvenient that I either have all static methods at the top or the bottom of the class (in the middle doesn't make sense). I would like to have factory methods at the top and maybe other static helpers at the bottom. What are the plans for SAM conversion of kotlin interfaces? I don't want to expose Function1, etc. parameter types to Java 7 code, I would prefer to define my own SAM, pass in lambdas from kotlin / Java 8 and allow Java 7 to instantiate a sane name. Dokka is currently versioned 0.9.x. There are many things that still need to be improved, especially for javadoc generation. Are there any plans to invest some more effort in it and bump it to a stable 1.0? (in this particular case, I think it would be a one-time effort: while kotlin evolves as a language, the kdoc specification doesn't really change). As a bit of context, I'm working on some libraries that need to be easily consumed by Java (hence, many of my questions were related to Java interop at all levels - kotlin code, exposed API and documentation). Also, I've read one of your answers that you decided to not include package private visibility before knowing what Java 9 will bring. Now that Java 9 is here, would you consider adding it in the future? (I don't have a preference, internal works well enough for me, I'm just curious) Thank you for your patience and for the awesome work!
There will be a way when Android plugin 3.0+ will be bundled in Idea. Probably starting from Idea 181.
There's FeatureSpec testing mode where nested contexts are available. There's a lot more in the docs, but that means cognitive overhead, however in terms of flexibility, KotlinTest has way more use patterns than Spek. 
&gt; So, we're looking into what can be done here. Is there any info on this online?
I'm using it + Kotlin Exposed for a small cataloguing web app I'm creating. It's mostly fine, but the lack of documentation is very annoying. I've also ended up needing codegen (KotlinPoet) so my database structure and POST requests end up being the same.
It's already supported (not for all combinations of host/target for now)
Would it be possible for Kotlin Native to move closer into an RAII semantic similar to C++ instead of ARC and tracing GCs? I understand that this would pretty much be a 180Â° turn compared to what we are accustomed in Java, but this would be the one last thing which would be needed for me to say that not only is Kotlin a better Java, but also a better C++. Kotlin quickly became my 2nd favorite language of all time, with only Ada still having that sweet spot in my heart. Thanks for doing this AMA!
Go is pretty much the antithesis of functional programming. It's all designed around doing things in a very stateful way, and it's impossible to implement even basic higher-order functions (e.g. map, filter, etc.) in a useful way in Go.
Thanks. Where can I get more info on this? Would like to see an option to build OSX binary on linux CI machine.
Not really a question: just wanted to say the talk about functional programming in Malaga was really interesting and I'll probably delve into Kotlin because of it. I'm just a student atm who keeps jumping from language to language but Kotlin seems to have many of the features I enjoy in one neat little package. 
Are you planing to use some of Rust memory/thread features in Kotlin Native? 
Coroutines don't require context switching -- that's probably the biggest advantage over traditional threads.
How do they not require it? Each coroutine has its own context, and there _is_ some overhead involved in switching from one routine to another. The switching happens in user-space though (as far as I can tell), so maybe that means less overhead? I don't know; I can't tell.
A (very) advanced talk on a new construct brought by Kategory that allows you to have inside your program interpreted domain languages that allow sequence and concurrency. A meta-program!
St Petersburg
How about TornadoFX?
TornadoFX?
You can check [this example](https://github.com/msink/hello-kotlin) of cross-compilation Also, take a look at [list of supported targets](https://github.com/JetBrains/kotlin-native/blob/master/RELEASE_NOTES.md#supported-platforms) for cross-compilation. Curious too about future support of OSX/iphone binaries. 
Some platforms don't install BASH by default which means the wrapper scripts in /bin won't work. How about moving the scripts to sh to allow more target platforms? Groovy does this.
Where does Slack have performance issues? I have used it on Windows, Mac, and Linux without any issues.
My use cases are that I want to create some mobile multi-platform libraries, we plan on using Kotlin in the long-run for our projects, but I must prove it works and the tools are not a problem or a mess of tools for every step. And that I want to use Kotlin/Native in Android NDK, so using it from Android Studio is a must have for me.
Why did you choose "fun" as a function keyword?
Does it work on iOS?
I did a quick google for Kotlin style guide, but didnâ€™t see anything from Kotlinlang.org. Pointer please. 
I found it to be exactly the opposite. I got rid of RxJava in favor of a pure coroutines approach. It got a lot cleaner do manage, easier to dispose, easier to reason, to understand the flow and so on. Best decision i've made.
"Like the bracketless if's and fors in Swift" Man, I miss this so much.
You might try â€œAndroid Studio 3.0 Development Essentials - Kotlin Editionâ€. But youâ€™ll probably need other resources too. 
[removed]
Check out Kobalt by Cedric Beust. My company has been using it for two years for that reason: aversion to magic. Highlights: create tasks (in kotlin) instead of relying on obscure plugins. Simple, concise build files. Parallel builds. Common sense.
Check out Kobalt by Cedric Beust. My company has been using it for two years for that reason: aversion to magic. Highlights: create tasks (in kotlin) instead of relying on obscure plugins. Simple, concise build files. Parallel builds. Common sense.
Check out Kobalt by Cedric Beust. My company has been using it for two years for that reason: aversion to magic. Highlights: create tasks (in kotlin) instead of relying on obscure plugins. Simple, concise build files. Parallel builds. Common sense.
Check out Kobalt by Cedric Beust. My company has been using it for two years for that reason: aversion to magic. Highlights: create tasks (in kotlin) instead of relying on obscure plugins. Simple, concise build files. Parallel builds. Common sense.
Nice to know LibGDX is looking forward Kotlin :D
There's no GC, just Reference Counting like iOS ARC.
First of all, I'd have it not built in, but through some sort of a metaprogramming mechanism: it's too big a semantical surface with all the issues of granularity, annotating generated declarations, accessing the delegate object, changing the delegate object, etc being too entangled. This should have more API surface and less language surface.
To be fair I think Kotlin multi-platform, may in the future, help you get closer to your 1 language dream, but I believe you are kind of overreacting on Kotlin and JetBrains a problem not for them.
It's too early for code examples, but there's a number of issues, including the inconvenience of defining private constants and utilities in a class (with extra indent required by companion object), too many @JvmStatic annotations in some use cases, visibility issues with classifiers that block some of the typealias design (we'll fix this one soon enough), etc
Thanks :)
I don't think diversity is the cause of the world being stuck with JS. It's quite the opposite. The browser doesn't allow language diversity, really: transpilation to JS is limited in a number of ways that makes it inferior for many users, and WASM will enable true language diversity, competition and continuous improvement. The world will be a better place :)
&gt; Classess infix functions are not supported yet, right? Not quite sure what you mean
I donâ€™t believe that Rust memory and error-handling models could practically scale to multi MLOC projects and big teams. I do hold a strong belief that it became possible to economically design and build a project on the scale of IDEA only due to Java (now those benefits are built and improved upon by Kotlin). If IDEA were developed in C++ or Rust, it would have taken exponentially more effort. You could argue that it would be faster-working product, but it is an irrelevant argument since it would not became a competitive reality. 
We need common libraries for code sharing across platforms, and Java libraries are not available on iOS and web clients
Not very concrete yet. The overall idea is to have a compiler/IDE plugin API + a mechanism similar to JVM byte code transformation, but common for all platforms
It does when it's an expression (i.e. its value is used)
Hi! Glad to see you again, I do remember you and Android Rivers :)
RoboVM took Java bytecode and ran it on iOS. Kotlin/Native doesn't work with Java bytecode, so Java libraries don't work in Kotlin/Native. It compiles Kotlin sources to native binaries and allows for linking with native libraries (not Objective-C and C, Swift is on the way). So, no JDK, no JVM threading model, etc.
As I mentioned elsewhere in this AMA, we are working on common Kotlin libraries. I think people will write multiplatform libraries if they need to share code in their apps. And I believe that if a use case is in such a demand as code sharing is, it needs to be addressed. The previous attempts had their drawbacks, and we can learn from them. 
Many companies that are evaluating Kotlin are looking for security-related capabilities since new technologies usually require security approval first. Specifically: * Kotlin secure coding guidelines (perhaps a quick translation of http://www.oracle.com/technetwork/java/seccodeguide-139067.html) * Static code analyzers (current Java bytecode analyzer results don't map nicely to Kotlin code line numbers etc.). Detekt seems promising but the ruleset doesn't compare to established tools like FindBugs &amp; PMD (and especially more advanced tools with data flow analysis) * Tools for detecting &amp; enforcing code coverage for Kotlin code This makes it difficult to adopt Kotlin at many larger companies with established policies and regulations. Are there any plans to improve any of these areas?
what difference does it make if javac is used vs some other compiler? If you're going to claim that Jack produced bytecode is not "real" java 8 then by the same metrics that applies to Android 7+ and javac. Jack also supported lambdas 
A function outside a class can't be infix, correct?
Can a mod please add special flairs for the Kotlin team members? It's hard to distinguish them in the replies. 
We were thinking about positional concepts like first to second and key to value. We also support positional constructing (shock! what we were thinking again?) and positional destructuring complements that.
Yes it can. https://kotlinlang.org/docs/reference/functions.html#infix-notation
There are some ideas on how to improve resource management (like open files) that are inspired by RAII. Not in the short term plans though. For memory management I personally do not see any advantages of RAII over ARC. The later seems to strongly dominate the former. 
Thank you. That's great to hear! 
Thank you. We very much appreciate the support!
You'd need to ask a game developer, but I do believe quite a few number of people are using it with Libgdx. 
But no GC either? I'm assuming no Java memory model nuances (which is fine) but no threads? Does it use ARC? If so how portable is it?
What about a function that's not part of a class?
It uses a huge amount of RAM. 
Jack and desugar use anonymous classes to emulate lambdas and method reference. Java 8 and Android 7+ uses invokedynamic. Repeatable annotation at runtime also available only for Android 7+ Also, only Android 7+ supports streams
The example in the docs had a function that is not a member of a class. It's an extension function, you can read more there
&gt; I admit it took me months and multiple read articles to jump into Kotlin train 14 months ago after I first heard of this language and went onto it's website where I didn't understand the point of removing semicolons and the enclosing class. Examples you mention are great. It's just somewhat challenging to find a way to fit everything in at a glance that would entice people to look further at the language. Nonetheless, thank you for the feedback. We'll definitely use it. Curious. What *did* make you make the jump? 
The example in the docs had a function that is not a member of a class. It's an extension function, you can read more there
Not yet, but thanks for the idea, weâ€™ll discuss it :) Of course, it sounds interesting to us as well. What I can suggest you so far â€” participate in EAP so that the problems will be localized earlier, making the life of everybody easier. I know that's not what you expect me to tell you right now, but that's a possibility too. At least a problem may be fixed sooner in this way.
Can you, please, clarify what specific memory/thread features of Rust you missing and are looking for? 
Done. Thanks for the suggestion!
Wonderful!
The only reason to bump the version number to 2.0 would be making the language backwards-incompatible; any additions to the language can be released as 1.x features. With that in mind, my personal wishlist for 2.0 is very simple: get rid of companion objects and replace them with the regular `static` keyword. (But please don't take this as an official position of the team; we don't all agree on that.)
I really like Kotlin for back-end webdevelopment, especially with libraries like Ktor and Exposed. Ktor has recently seen a massive improvement in documentation, but Exposed unfortunately has not. Any chance there will be better (or any) docs in the future?
Kotlin is a practical tool; you should learn it if you like it and if you have projects where you can use it.
I'll chime in on exceptions. Exceptions in Kotlin are designed to be used for exceptional circumstances that the caller should not be immediately forced to handle, but that are more appropriate to be handled by some top-level code/globally. They are very clean and boilerplate-free for this particular purpose. Idiomatic Kotlin code should not use exceptions to represent error conditions that must be immediately handled at the call site. However, there are plans to improve tooling around Java checked exceptions to make it easier working with Java APIs that [ab]use exceptions for not so exceptional error conditions. In cases when you need to indicate an error condition that the caller must handle (like a function that normally returns something, but needs to indicate that it was not found and force caller to figure out what to do about it) Kotlin provides nullable types and various syntactic niceties to conveniently work with them, so that you can write `findSomething() ?: "default value"`, etc. There is a third class or errors (the least common one, in our practice). Where you must force a caller to process the error, but the error must have some additional information (like error type, message, position). It is a rare occurrence in general/business code, but happens often in some domains (like parsers). Kotlin provides sealed type hierarchies for that, `when` expression, and extension functions, so that you can create domain-specific extensions to make working those types convenient and boilerplate-free. Some of the most commonly used patterns like a `Result` type might find their way into the standard library some day. 
I wouldn't worry. Although they are not at v1 yet, that has more to do with API design than stability. If you're okay with rewriting a few things when they launch v1, you should be fine.
Not immediately, as Rust approach to memory is very radical, and we try to keep language more natural for programmers form Java/C# world.
It just a pretty common compromise in memory management system: if cost of object accounting is spread over runtime (classical ARC) or is paid during garbage collection (classical trassing colector). Kotlin/Native relying on reference counting, so pauses are minmal.
We do believe in modules. If you are writing a self-contained module with a number of interconnected concepts spanning several files, then you should extract it into a separate module in your code base and use `internal` more all your module-private declarations. On the other side, if your "mini library" is too small for a full-blown module, then you just write it in a single file and use `private` visibility in this file for the declarations that are private to your mini library. Kotlin is not Java. You should not be putting every small class in to a separate file in Kotlin, but rather combine groups of related classes into the single file. There does not seem to be much space for a 3rd [Java] way of doing it. In some sense, you might look at it as if Kotlin is nudging your to drop your Java habits of putting every class into a separate file and adopt a Kotlin style of doing thing.
Kotlin/Native uses reference counter, as well , as Objective-C runtime. So not much difference here. Existing debuggers and profilers works pretty well with code produced by LLVM codegenerators, so we're safe here.
Actually difference between those two, is optimized, becomes pretty minimal, I highly reccomend this Bacon's paper on the subject: https://courses.cs.washington.edu/courses/cse590p/05au/p50-bacon.pdf
No, there are no plans for cross-compilation to Dart. Repeating members in constructors is a common issue, and we have some ideas how we could solve that. See https://youtrack.jetbrains.com/issue/KT-15471 and related issues for our current thinking. Generating a `copy` method for a sealed class which has data classes as all of its subclasses might actually be feasible; please file a feature request in YouTrack. As for generating an additional method for every single data class out there, it would be an extremely hard sell; just imagine the total worldwide increase of method count in .apks. To support this pattern, a custom annotation processor would probably be a better solution.
Using `invokedynamic` is on the table, but the performance benefits it might bring are mostly mythical than real, because `invokedynamic` was not designed for performance, but for ability to delay decision on linking and code generation strategies until the code is run. It mostly shifts the overhead from compile-time to run-time.
It's up to external library developers, we are fully support such an idea.
Would that also fix `@StringRes` annotations not being highlighted when using wrong constant?
Nothing in particular thus far
A multi catch is basically Java supporting union types in a catch block. So from my point of view Kotlin could implement union types as well.
Secure coding guidelines make sense when they are written by security experts, and the Kotlin team basically consists of language design and tooling experts, not security experts. Oracle's secure coding guidelines are very sensible, and apply almost 100% to Kotlin, but I don't think we're ready to publish anything authoritative on our own. We do plan to invest into security-focused static code analysis, with the intent to reach feature parity with existing tools for Java. Our analysis tools will simply be IntelliJ IDEA inspections; we've already built a Gradle plugin that allows to easily run the inspections in a CI build. For code coverage, the IntelliJ IDEA coverage runner (which is also integrated into TeamCity) already supports Kotlin, and we'd be happy to collaborate with developers of other code coverage tools to help them support Kotlin too.
Thanks Maxim. :-) &gt; What would be the performance and ressource usage difference between that and for example python? Kotlin is a compiled language, so there is a compilation overhead when you first run a script/application written in Kotlin. Kotlin runs (mainly) on the JVM which needs some time (~200ms) to start up. In contrast, the python interpreter has close to zero warmup time. I think there is a consensus that JVM programs execute much faster than python equivalents. Still, python might be faster depending on your specific usecase. Also, with kotlin-native becoming more mature, you could compile into native binaries directly, which should bring it close to C/C++ performance. My main motivations for using Kotlin over Python for scripting and development are * Kotlin is the better designed, more fluent language with much better tooling around it * The JVM dependency ecosystem allows for strict versioning. No more messing around with virtualenv, e.g. to run a short 10liner against a specific version of numpy. 
What is the problem with the current implementation of companion objects and delegation? It worked fine so far, at least for me.
We're preparing to publish a greatly expanded style guide; you can find the current draft at http://jb.gg/kotlin-style-draft. We have no plans to build two different autoformatters; the one in the IDE is the only one which we support. We do plan to improve its handling of wrapping; it doesn't really do a good job in this regard at this time. We also have an inspection that detects code that would be formatted differently by the autoformatter, and we're working on a Gradle plugin to let you run inspections in CI builds. SAM conversions for Kotlin interfaces are on the roadmap; no specific promises, but I hope they'll be supported quite soon. We're actively working on Dokka right now, with the intent to finally push it to 1.0. Also, please make sure that the issues that you've encountered with javadoc generation are logged in youtrack or the dokka tracker on github, so that we don't miss them. Regarding exceptions, please also see https://www.reddit.com/r/Kotlin/comments/7hoytl/kotlin_team_ama_ask_us_anything/dqsyn6w/
We are working on establishing all required processes at JetBrains for libraries we produce. This is something we are only learning to do, so bear with us for a while :) 
Please file a YouTrack issue; I don't think there are any fundamental reasons why we can't use sh.
We have no plans to build interprocedural analysis tools for detecting thrown exceptions at this point. Our support will be restricted to regular Java checked exceptions.
I consider `static` a low level hack from C times ...
Another alternative (the one I use all the time) is not to introduce any block at all. If the methods are not too long, there is not much benefit in restricting the scope of a variable to the smallest possible range of code.
Initial idea was to have all var/var/fun keywords of the same length so declaration names are naturally aligned. But then function generic parameters ruined the idea somewhat
What would be the alternative? Java is somewhat hopeless with all the legacy, although Oracle is doing a pretty good job recently. We will even get local type inference next year! Scala? It was my language of choice before Kotlin, but Scala while elgant in principle has many practical drawbacks like binary incompatibility between major versions, implict conversions with all its implications (like slow performing compiler and IDE). Personally I don't like some things developers can do with Scala, like defining absurd methods (`#~&gt;`). When you look at the JVM there are not much more relevant candidates. Ceylon failed from my point of view, for example.
LibGDX already works beatifully with Kotlin.
You get a productive, concise and `fun` programming language with all the benefits of the fantastic Java eco system and world class tooling.
See my other replies
We are working on supporting threads (see other replies here). Currently we have reference counting with cycle collector. What kind of portability do you mean? Same code can be written against a weak memory model and run equally well on JVM and other platforms
&gt; Sorry, it looks like yours is not a question but rather you're trying to say that we shouldn't have built Kotlin. No, don't get me wrong - I'm not saying you shouldn't have built Kotlin, I'm only interested in the motivation behind building it. hhariri posted a link to the Jetbrains blog below. A "more expressive language (than Java)", "compilation speed" and some "fun" seem to have been the main reasons. Scala seems to have had too long compile times...
I have to admit that coming from other languages `fun` irritated me at first, but know I like it very much. The aligning is nice and it is obviously more fun than `def` (and `def` is a bad keyword for `function` anyway).
Personally, having built a large application in Kotlin, I find Kotlin's visibility modifiers *far* better than Java's, and specifically the internal modifier. Java's visibility modifiers to not reflect how the app is organised into modules, while Kotlin's does. Internal meaning visible within a module, invisible to other modules, is a good fit with the way we organise our work into modules and compose them into systems.
tl;dr more expressive language than Java, compilation speed, fun. thanks
What do you think about "design by contract" like implemented by Microsoft with [code contracts](https://msdn.microsoft.com/de-de/library/dd264808(v=vs.110).aspx)? Wouldn't that be a useful addition to Kotlin?
What are your plans regarding structurual typing like in Go (also know as "static duck typing")?
&gt; Java interop, concise, toolable Scala is all of that, isn't it? I guess the reason why they didn't love Scala might be compilation speed...
&gt; Kotlin loves functional programming. A number of Kotlin features are specifically designed to nudge developers into functional programming paradigms Could we please (please with cherries) get an Either/Result type in the Stdlib then?
Thank. It would be great if you blog about your experience. We would help you to share the story. 
Robovm was killed by Microsoft
Swift might be apparently. I'd be happy either way. 
There are significant differences between Kotlin on the JVM and on JS. It is difficult to write code that compiles on both platforms, let alone produce the same behaviour. And with the recent release of Kotlin Native, there are now three platforms. Will the team define a common subset of Kotlin that is guaranteed to behave the same on all platforms?
Isn't it part of the Int class?
The extension functions, null safety incl. safe call operator, the inline keyword and light stdlib that showed how performance is seriously considered by the language authors and the easy to use lambdas. The type inference, the `when` and the smart casts also looked great. Finally, at the center at the deal, I understood I could try right now just by adding language dependencies and converting the java file I hated the most, without breaking my project, using more and more Kotlin as I got more comfortable with it. In short, after reading several feedback articles, I was sold when I understood the language brought useful features (importance of showcasing them), was already serious about performance (I'm not building a wasting machine), keeping lean (unlike Scala...), and the future (especially considering Android is locked to Java 6/7 for probably at least 5 years from now) I also liked the `TODO()` and functions always throwing that can return `Nothing` for impossible cases. Thinking again, I think the Kotlin main web page should showcase ALL cool language features across different use cases, with a link to documentation on each example to see how it works exactly. And a paragraph (with an eye candy design to attract overlooking eyes) on how Kotlin is set to evolve to support more platforms, and smoothly add more features (with a few words about experimental features lifecycles and tooling supported migrations), because we need to know this is a language we can rely on and invest in. BTW, since how huge Kotlin can be when you start using it, I think what's important is to gain first time visitor interest, even if the visitor stays longer on the page because it has more content rather than making the whole page digest in a glance. What I mean is that the home page is where there are already too many links to click, and if the visitor is not sold enough, (s)he'll feel more overwhelmed by the choice of which link to click than he is excited to learn more and try it out.
Compilation speed is one of the reasons. In theory scala is toolable, but in practice it is hard to get it right. And back then when they started with kotlin, scala was binary incompatible between 2.x versions (not sure how it is today).
/r/scala
Here's a sneak peek of /r/scala using the [top posts](https://np.reddit.com/r/scala/top/?sort=top&amp;t=year) of the year! \#1: [Duolingo rewrites its engine in Scala](http://making.duolingo.com/rewriting-duolingos-engine-in-scala) | [12 comments](https://np.reddit.com/r/scala/comments/5rapf6/duolingo_rewrites_its_engine_in_scala/) \#2: [SBT 1.0.0 is out](https://github.com/sbt/sbt/releases/tag/v1.0.0) | [7 comments](https://np.reddit.com/r/scala/comments/6t06v7/sbt_100_is_out/) \#3: [Underscore's books are now free and open source](http://underscore.io/blog/posts/2017/05/29/why-we-open-sourced-our-books.html) | [11 comments](https://np.reddit.com/r/scala/comments/6ektwr/underscores_books_are_now_free_and_open_source/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
Do you have any idea (or rough estimate) of market share for Kotlin? How are you planning on growing this market share? The reason I ask is that I really like the language and have done a few simple hobby projects in it but (here in the UK at least) there never seems to be any jobs for the Kotlin language.
Ah, ok. It's minimal, not pauseless.
RefCount is a GC technic. AFAIK there is a tracing collector for cycles, which pause, could be little but it pauses.
https://josephg.com/blog/electron-is-flash-for-the-desktop/
Thanks a lot! I tried to scan that document for info on this issue, but somehow missed it. Anyways, that is great to know!
We know the number of active users of Kotlin. How this translates to "market share" depends on your definition of "market". One number that has been announced is that &gt;17% projects in Android Studio are now using Kotlin. We plan on growing the market share by continuing to do what we've been doing up to this point: building a solid language with great tools, rich library ecosystem and a vibrant community.
Please file a YouTrack issue so that it's not forgotten.
The main problem with things like ARC is things like cyclic references which are really hard to track down in a high level language. In xcode we have these amazing memory tracking tools that allow you to locate the problematic bits visually and flag the reference level accordingly e.g. as a weak reference (not to be confused with the way Java uses weak references). I'm assuming this gets harder when you cross the boundary between kotlin and Swift/Objective-C so you would need to debug a lot in the native environment... So in theory you can write some portable code like you can write portable C code, but it's not like Java where it mostly "just works". So the question is, how do you address the toolchain to debug these potential memory issues which might be compounded when dealing with a native OS view? 
How the hell is Electron (Javascript on desktop) related in any way to Kotlin Native (compiles to machine code, not JVM)? What kind of question is this..
Yes, we do plan on improving the REPL. In the short term we plan to support executing code in a running JVM is by connecting the REPL to the debugger, so that you can execute from a REPL UI code while stopped on a breakpoint. Not exactly sure why such a REPL statement would be useful; can you please explain? Something like Figwheel for Android can be built on top of Kotlin, but given how much of it is Android specific (and knowing how much effort the instant run feature in Android Studio has costed), I'm not sure if the Kotlin team would ever have the resources to implement it. I think this should be a feature request for the Android tools team.
But that's just reinventing Java. You can as well use an ahead of time compiling Java compiler.
[removed]
I don't see any reason to even link the two projects together. One is for building UI apps in Javascript and the other is for compiling a JVM language to native binaries. OP must have read "native" in both projects' descriptions/names and thought that's enough to link the two projects. Obviously tho, "native" means two different things in this case, for Electron it means running on the desktop (instead of a browser), for Kotlin it means compiling to machine code (instead of needing the JVM).
I've just recently submitted my first PR, which was accepted rather quickly. I used the talk by Yoshinori Isogai as previously linked and checked the Up for Grabs tag to look for the easiest category of fixes (intentions and inspections, from what I've seen) and am trying to slowly increase the complexity. 
Unfortunately the LSP story is about much more than vim.
Aren't you worried about going down the route of essentially re-creating the JDK class library, by doing this? Do we really need to s/java.*/kotlin.*/g in the name of portability across abstraction layers which are themselves abstraction layers designed for portability?
Yes. The work on common Kotlin subset is high on our priority list. In Kotlin 1.2 the large fraction of the standard library is already common and is supported on all three platform. 
Sure but it wasn't very popular before that. Most of its user base was LibGDX users which is a relative niche. Since libGDX is a special case and not applicable to kotlin native. We estimated back then LibGDX was roughly 90% of the RoboVM user base and roughly 3% were diehard JavaFX fans. The rest used RoboVM in a way similar to Kotlin native or Xamarin which means there isn't that much of an "addressable market". This is important even for developers to understand as it gives an indication of project long term sustainability.
OK, it's actually only in the draft that hasn't been published yet (but will be very soon). See http://jb.gg/kotlin-style-draft
We strongly believe based on our past experience that in order for a programming language to scale to large projects and be easy toolable and readable it has to be nominally statically typed.
It's only for desktop applications.
The Kotlin team at JetBrains has no plans to create documentation focused on Android development; we're not Android developers ourselves, so we're not the right people to create such docs. However, Google does plan to greatly expand the amount of Kotlin documentation, and there is a huge amount of material out in the community too.
What's the Swift model. How is it different from C/C#? 
If Kotlin/Native and Kotlin/JVM differ in an aspect as fundamental as whether you share mutable states between threads, isn't that rather compromising on the multi-platform vision? Quite reasonable code that uses threads for performance would not be portable in this regard.
In the early years of the language, before 1.0, it relied much more heavily on annotations instead of keywords/modifiers. However it apparently complicated the IDE in ways that hurt performance, because the meaning of the code started much more on full resolution. Andrey wrote about this journey here: https://blog.jetbrains.com/kotlin/2015/08/modifiers-vs-annotations/
There are some theoretical performance benefits. I've never measured to see how much real world difference it makes: * It does make bytecode and thus JARs quite a bit smaller. Less code to page in from disk if you are using a slow disk drive. * Such generated classes are anonymous so there is not contention on the global class dictionary. But this probably only matters if you are running very heavily multi-threaded code that uses capturing lambdas a lot. * No generated class if it doesn't capture anything so no heap overhead.
Thank You
Actually Kotlin 1.3 has some support for a limited kind of contracts in it, but it's internal only for now and designed to enhance dataflow analysis. I was playing with a hacked compiler the other day. So let me ask a question about that - the new contracts DSL (called an "effects system" in the code) seems to be developing quite nicely but I haven't heard anything about it anywhere. I had a go at hacking the type system by exploiting generics erasure to make a single object whose set of available methods changes as you use it, like this: import kotlin.internal.contracts.contract sealed class State object NEW : State() object OPENED : State() object CLOSED : State() class Resource&lt;STATE : State&gt; private constructor() { companion object { fun new(): Resource&lt;NEW&gt; = Resource() } } fun Resource&lt;NEW&gt;.open(): Boolean { contract { returns() implies (this@open is Resource&lt;OPENED&gt;) } return true } fun Resource&lt;OPENED&gt;.read(): ByteArray = byteArrayOf(1,2,3) fun Resource&lt;OPENED&gt;.close(): Boolean { contract { returns() implies (this@close is Resource&lt;CLOSED&gt; &amp;&amp; this@close !is Resource&lt;OPENED&gt;) } return true } fun main(args: Array&lt;String&gt;) { val r = Resource.new() r.open() r.read() r.close() r.read() // Goal is that this line doesn't compile } I hacked the compiler to take out the error preventing me from writing an `is` check with a generic type argument (obviously this works only if you use such a construct in the contracts DSL and not real compiled code), but the issue is - of course - that flow typing is additive. It doesn't have any notion that a type can change in ways that _reduce_ the number of types a value can have due to casting. This kind of type system abuse probably isn't possible to do in a clean way that doesn't cause all kinds of side effects, but if it was, it'd be a nice way to model a state machine of some sort in the types. Combined with some sort of move-only / affine types, it could be a good way to increase the type safety of working with stateful resources. WDYT?
Some companies that use Kotlin don't advertise specifically for Kotlin developers (because there aren't enough to make that worthwhile). For example the company I work for (R3) is based in London and we use Kotlin for everything.
I admire the fact that you're willing to actually take a stance and hold a strong opinion on that :) I know it's not official JetBrains policy or anything but it's good to see some robust views from individual team members.
Check hiring channel at Kotlin slack; I saw a recent increase in UK jobs recently
https://kotl.in
Thanks for the tip
Thanks for the tip. Are these advertised as just general engineering jobs then?
&gt; Kotlin/Native compiler and runtime are free and OSS, so it can be used by anyone. The IDE plugin is only available for CLion, we'll extend this to other JetBrains IDEs, but so far we are planning for the IDE experience to be commercial (the way we do with many other languages). Don't you think that it limits the appeal of Kotlin Native? Other languages that are supported by your commercial IDEs do have another alternative IDEs/editor support/language servers that your product competes with. Kotlin Native doesn't, the CLion plugin is the only IDE for it, making it pay-up-to-us-or-no-ide language.
I will follow soon this path! I've got the env ready and looked into Youtrack but couldn't find a bug I could understand and that was not already taken. I've decided to learn more about the [IntelliJ Platform](http://www.jetbrains.org/intellij/sdk/docs/welcome.html) first before continuing for now... 
Ah yes, but thinks may get hotter with Kotlin Native :)
Indeed
I will try, I want to start blogging, I am just postponing it. Where should I share so you guys would take a look when I come up with something?
Your response is confusing... Your're no making it a standalone project... at all, or yet?
Thanks for the reply. The problem is: In Clojure we don't need to switch to a REPL input prompt and manually paste or enter commands we want to run. This is of course nice, but it's much less productive than if I can just send a form right there in my editor window to the running REPL. I can edit my function and try out an example invocation without ever leaving the editor window. Consider this code block: (defn sum [xs] (reduce + 0 xs)) #_(sum [1 2 3]) (comment (sum 1 2 3)) If my cursor is somewhere in the function and I "send to REPL" the entire function will be redefined. If I now move the cursor to the "block comment `#_` and "send to REPL" the function will be invoked and I see the result. Same goes for the macro comment `(comment ...)`. Both, `(comment ...)` and `#_(...)` won't actually compile into any code. They're comment. So basically I can write short example and leave them in the code. With Kotlin the only way to ignore code is to put it into a comment like `/** ... */`. I won't get syntax highlighting and if I wanted to send something to the REPL I'd have to select the text in comment manually and send it to the REPL. A first class construct to "Block comment" a construct would allow this. Of course and alternative could be to add this functionality purely on an IDE level and do syntax highlighting on special comment syntax and allow sending the code to the REPL. Something like: /**@CODE for (x in 1..10 step 2) { print(x) } /* or: //@CODE: if (0) "truthy" else "falsy" And an IDE can then send these commands (or the current selection) to the REPL. I know that most people are used to living in the debugger while coding but I think REPL driven development is MUCH more productive. It's fantastic, seriously :)
Yes, you can switch from JavaScript to Kotlin/JS and continue to use RxJS.
How you see the future of Kotlin? Do you think that it will replace Java soon for Android Development?!
Yeah, usually requiring Java or Android skills. Java devs can be turned into Kotlin devs with no special effort.
Just use an `Array&lt;Array&lt;String&gt;&gt;` to represent it in-memory and Gson or your serialization library of choice for storage.
Java has too much legacy stuff they can't get rid of as long as they don't want to break Java 1.0 code. E.g. look at the collection API where they still are stuck with Object instead of the type parameter not to break old code.
Got it, thank you for feedback
We already have a cross platform Java 8 like date/time library for both Scala and Scala.Js: https://github.com/cquiroz/scala-java-time so it is perfectly doable.
You could come the Kotlin Koans repo: https://github.com/Kotlin/kotlin-koans I'm not sure if that ends up being the same as the Edu plugin for IntelliJ https://kotlinlang.org/docs/tutorials/edu-tools-learner.html?idea
Hi! First of all, I'd like to emphasize that this feature currently isn't as powerful as full-blown "design by contract", and at the moment, we don't have any plans to push it further. It's primary purpose is to provide compiler with additional guarantees on functions in order to improve analysis, not to introduce completely new model of programming. There are several reasons why we haven't announced it yet. First of all, there are still some things (purely techincal) unfinished here and there. But we also not entirely sure about general design of this feature - how powerful and expressive this language should be? It is completely compile-time, on some contracts can have runtime representation (e.g. in form of assertions)? Which use cases should be supported? Should we trust contracts unconditionally, or compiler has to check them? So, there are a lot of open questions here, and right now this feature is in the state of internal prototype. We're currently experimenting with contracts in our own codebase, collecting feedback and use cases from the team. As soon as we will have clear vision of how contracts should appear in the leanguage, we will of course make a proper announcement or publish a KEEP :) If you have any other questions regarding this feature, feel free to ask them =)
&gt; Embedded/IoT Yeah, totally need Kotlin there.
They're no union types, which means you cannot freely create new types ad-hoc. x: A | B, instead of created a sealed class for every combination. Throw intersection types into the mix, and you have something very powerful. Try Typescript and see :)
Phrased another way, I'd want to disallow `else` when switching on sealed types. sealed class Sealed class A : Sealed() class B : Sealed() class C : Sealed() // Using else, implicitly exhaustive // Does not error if I add class D : Sealed() fun withElse(sealed: Sealed) = when(sealed) { is A -&gt; println("A") else -&gt; println("B or C") } // Would like compiler to explicitly require A/B/C. // Should error if I add class D : Sealed() fun exhaustive(sealed: Sealed) = when(sealed) { is A -&gt; println("A") is B -&gt; println("B") is C -&gt; println("C") }
Post it on #coroutines channel on http://kotlinlang.slack.com/ please
Post it on #coroutines channel on http://kotlinlang.slack.com/ please
Fun fact: newer versions of gradle will allow you to use kotlin to write the build script, so you don't have to learn "a pretty much dead, full blow language just for building" (assuming you meant groovy). It's worth noting though, if you've got much more than 100 lines of gradle code (android, 200 is safe) then you're probably overthinking it and creating somebody elses future nightmare of code. If it gets more complex than 100 LOC, i'd say compile with gradle and do extra assembly steps with something else. I understand some people have special needs for their builds, but I've done about 20 services and 2 android apps with kotlin and never needed more than a short file of dependencies.
I wouldn't count on it.
There's your use case for bringing native support to IDEA.
Well, yeah, I just wanted to give my user story so to speak. 
That makes sense. But for the example you provided, what's stopping them from introducing a "generified" version of the collections API while keeping the previous one as not to break backward compatibility?
I really like Ktor, but you have to expect at least some bugs given its maturity. Can your product live with that? If so, then by all means go for it. Ktor is awesome!
I built my computer 6 years ago with 24GB of ram. 2 sticks went bad, so I am down to 16GB. Loading slack, code/atom, plus other apps is still a non-issue. I would rather have a nice cross platform experience. If more ram is the trade-off, I am OK with that. It is really nice having the same code/atom extensions between platforms. This is why operating systems cache a bunch of stuff into memory now. If you aren't using it, it is not helping you.
Will be possible to use infix fun in next syntax: class Sample (initializer: Sample.() -&gt; Unit) { infix fun foo(bar: String) = ??? } val sample = Sample { foo "bar" } 
Thanks, I will do that.
So why won't you start blogging?
There is a proposal about type classes and HKT https://github.com/Kotlin/KEEP/pull/87
This is Android lint feature, future releases of AS and lint should fix that, but you still can create an issue on Android issue tracker
Well there is some overlap. Kotlin Native does give you access to native objects so you can use that to write a native app right now. A cross-platform UI framework could theoretically be written entirely in Kotlin Native on top of this bridge.
One practical problem I've personally faced with: some web API provided JSON format for I/O - pretty much standard stuff. But I was not able to just paste it to Kotlin, I had to convert the syntax. Or things like [EDN](https://github.com/Datomic/day-of-datomic/blob/master/resources/day-of-datomic/clojure-data-functions.edn) look much better with just brackets - I don't really care so much whether it is ArrayList, LinkedList or something library-specific.
Check out [KTX](https://github.com/libktx/ktx).
I have to say, I haven't ever really needed collection literals that deeply-nested. At that point, I think most of my applications would read it in from JSON or something. Hardcoding literals like that right into my application code seems inflexible to me, and it seems like data should live alone as purely data files. But that's just my opinion, and you're right, it looks way better in that scenario without all the `listOf`/`mapOf`/`___of`
Without talking about use cases, Kotlin and its toolchain is until now free and open source. I would like that it stay like this. Currently, using IntelliJ Ultimate with Kotlin has the benefit of supporting HTML/CSS/JS and other web technologies, so Kotlin/JS is much better using IJ Ultimate, but it's still possible to write Kotlin/JS with the community edition. I'd imagine the same with Kotlin/Native : possibility to do it with IJ Community, but an enhanced version with Ultimate/CLion. (This also bring to the question "when a C/C++ plugin for IJ ?")
No, extension function is not a part of receiver class, you can define it everywhere for any class, same way you can define infix function. The only restriction: infix function should always have 2 arguments (implicit receiver and one explicit), so you cannot just omit parentheses like in groovy
Idea already support code fragments in comments and in strings 
You have a point with diversity not being the cause of JS's ubiquity. I'm just bothered by say, Kotlin vs Swift, which have slight differences (ARC/Garbage Colleciton) that most users writing simple apps will never deal with. I would like the web to not become the same context switch mess that mobile app development is. (I say its a mess because Xamarin, Codename One, and Appcelerator all exist and have markets) Language diversity is great, except when you're talking to recruiters/hr people who don't know that C# is like Java, Kotlin is like Swift, React is like Vue, ect, ect. 
What exactly can you do with this, that you could not have done with interfaces?
HKT â€” not so sure, type classes are an interesting possibility
&gt; lso, I've read one of your answers that you decided to not include package private visibility before knowing what Java 9 will bring. Now that Java 9 is here, would you consider adding it in the future? (I don't have a preference, internal works well enough for me, I'm just curious) Unfortunately, the Jigsaw proposal has been reduced in scope a number of times, so it's still unclear what the JVM is going to settle on. And it doesn't seem that lack of package private is a big pain point for Kotlin users now
Ah, now I see. I'm afraid it's going to be inconvenient in a big number of cases, especially when the sealed class has many subclasses.
Sweet, my company is considering rolling it out into production. But because its so new we are a bit hesitant.
In the space of native programming it's fairly standard to use text editors like vim or Sublime Text, that can still be used with Kotlin/Native with no problem. I don't quite see how this is different. Also, it's important to note that JetBrains is a business and needs to make money on something. We are releasing very much to OSS, and the rest will be commercial. I think it's fair. If the technology is in demand in industry, it's not a problem to pay for the tools if the price is reasonable (and we'll make sure it is).
I don't see a problem here: the existence of common libraries is not making anything worse, only better. If someone doesn't want to use them, all the platform libraries (JDK, POSIX, React.js) are still there
It's a bit too early to dig into such details, but we'll definitely pay a lot of attention to such tooling
No, please refer to the docs on extension functions.
I'm glad it did, please see other answers here
Yes, this is perfect. I glanced at the online IDE turtorial the other day but somehow missed this. Thank you so much for the suggestion.
These are all great news! From what I can see, the new style guide adopts a continuation indent of 4 spaces, is that correct? This would be somewhat a relief for me, because the 8-space continuation can get ugly in many cases. This is also convenient, because then I can set the continuation indent for .kt files in my editorconfig to 4 (the directive is supported by IntelliJ IDEA). Maybe I didn't phrase well the question about the autoformatter, I didn't mean to ask if an entirely new one will be provided, but rather if there will be more options to make the formatter very strict and if there will be official plugins for Gradle/Maven. I've got my answer, thanks! To my knowledge, all the issues I've encountered with Dokka are reported. Glad to hear it will get more attention for 1.0! Thank you for your time and for the answers!
The new contenders for native programming, like Rust, Go or Swift, come with either language server, tool like rls than is being used as a base for language server, or in the case of Swift, with IDE (macOS only though). Even folks using Emacs like autocompletion, type hints, linting or debugging. I understand you need to make revenue, and your product range is a tremendous value for the money, but the question remains, how it will affect Kotlin Native adoption. Having a language server, that the emacs/vi/sublime/vscode users could use for creating an extension for their respective editors would certainly help.
They go into detail the difference between interfaces and the expect/actual stuff This allows you to write common code for js and JVM apps in a way that wasn't previously possible, since before you would need either a js or a JVM module and now you can have a common platform module
Thanks for the in-depth answer! The library I'm working on extracts Java code metadata from a git repository and persists it to disk. This way, clients can read the persisted metadata (or interpret it from the repository directly) and analyze various properties of the code. The source of my frustration with the error handling was my inability to find a clean design for my needs. Namely, a factory method checks to see if git is on the PATH, and if yes, launches a subprocess to check if the current directory is a git repository. The returned value should either be a GitProxy, GitNotFound (client could try and read persisted metadata) or RepoNotFound (client should exit, because no data could have been persisted). Obviously, methods on GitProxy can return other git-related error cases, but not RepoNotFound. This is why I said sealed classes aren't always feasible. Probably I would need sum-types to cleanly model this, but I am aware this would completely break the Java interop and is most likely not going to arrive in Kotlin. Anyways, glad to hear warnings for potentially undeclared checked exceptions are on the way! Also, I do hope a Result-like type will be included in the stdlib sometime. Thanks for your time and good luck making Kotlin even more fun for all of us!
Thanks for the answer and thanks for making the JVM a simple and fun experience! 
Just write .let{} after when block: fun exhaustive(sealed: Sealed) = when(sealed) { is A -&gt; println("A") is B -&gt; println("B") is C -&gt; println("C") }.let {}
Who the fuck are you
&gt;Groovy jumped the shark years ago What you mean?
We'll see how it goes. If the market shows reluctance, we'll adapt 
There is the Conan package manager which already exists for C++. Maybe Kotlin/Native could work with it ? :)
I'm using kotlin in Android development. I found that there is no proguard profile for kotlin. How can I make customized proguardï¼ŸTksï¼
Nothing, in fact the new Stream API has some improvements over the old API, e.g. toArray which takes an array constructor instead of an array element to use reflection on (as is done in the old collection api, even though it should not be necessary as in Scala/Kotlin). 
It's really useful for implementing extension interfaces. For example, really would like to be able to implement Parcelable for existing Java types like Map, List, String, etc.
Is it possible to add C++ like const modifiers to class member variables and functions in Kotlin so that we can achieve not just reference but true data immutability?
Why not move to C# then? You can also get native compilation via mono -aot, ngen, .NET Native, CoreRT. And Anders still has a say on language design.
That will only happen the day OpenJDK is actually written in Kotlin.
It is called JavaFX. Usable from Kotlin as TornadoFX.
Personal preference. I like Kotlin more. 
Almost nobody really uses it if they can avoid it.
My project [Kweb](http://kweb.io/) is built on top of Ktor and it works pretty nicely. Kweb is a fairly novel approach to building rich interactive web applications without having to use JavaScript or having to worry about client-browser communication.
Thank you for sharing KotlinPoet, I was just researching how to do something similar. The documentation is the biggest thing as well. I'm still very naive in its use to give a pro/con with it. 
https://applauncher.gotowebinar.com/#join/attendee/en_US/e0-S99KZihsHY-EHADU2IvKboui7MOmH/e0-S99KZihsHY-EHADU2IvKboui7MOmHe9NnsKczI77mZYkLJF_o9GL4GIW-7IQtBzyOCnXGcwcSWPQjvKnMzXAJc-UKjkc5T73W-mDZSmdmKZgwyK4wfK28766fw309j9iD9N8c0QN4tBwjEscbVLXGRVdm2wVu5W7VGre4AHZX5OtDm5EcHwS3aWcdcSsdSH5gfXbPciOEk8Y41WYg4RWTaOSAjzvICDimo4YMKgO2Y-mEdgUMxJy-dHYvbutZTAU5PdpB00rZ8DNWoHvBLZKh7iYW_cTgDoEhufbxncEdulkHxtwo8juWUxshFjCeRliA2-ZLIShjqozwEJX2CnjkfwvXqgPyIRuJemmbNFX3DBmvzqh2ebfSJGaUGitCGs-ie8qM4s48t-wPzFPENCQFpx9LxSpo3x1kMpleS8Xwfx266lEAgMBa5rzVbmduckbUSG1Y9CDvPOS1wGJzJ7P_L_Jv5TQOrIIvBaoYVaByGziriDELnqt_28UrbN1Jl-Wp6JFFqVzAjGtu-iUSn6iziJ6RyvDuQ0OPeUjTq9mnyJnJVHGM_W9v5K218yez5omZ286LciEAKStA6O-RlDoCs3eXwCzhopNJF8o1dKSHm7xW7P8/9180933474083490561/780573610
Is the phrase "dispatch receiver" in the official docs somewhere?
Yes, but does it work on iOS?
Yeah, but why? Is it slow? Is it a bad language? Does it lack something?
Sure. http://gluonhq.com/products/mobile/javafxports/
It is slow, it is somewhat haphazardly designed, and even its creator said he wouldn't create the same language again today given that there are languages like Scala and Kotlin. It was an evolutionary dead-end.
Thank you for the wonderful webinar :) This was my firt experience with this kind of stuff, but now I think I will join more for sure.
I could be wrong but I don't recall ever having seen it. 
Sounds really useful for stuff like DTOs
Will the webinar be available for those like me who couldn't make it to watch it live?
I love this, signed up even though 95% of my code is closed source. It'll encourage me to publish more OSS.
Thank you for trying out Sourcerer! Just to be clear our servers will never receive or see any of your code. The app that you download is looking for generic statistics, such as number of lines of code you wrote in python, or the number of times you used a particular library, etc. This data is collected locally on your own computer, and only then the statistics is sent to our servers. We are entirely transparent about what we do, and we also publish all source code of the app on github: https://github.com/sourcerer-io/sourcerer-app For an example of a profile, please take a look at my co-founder's: https://sourcerer.io/sergey - it displays pretty much all information that Sourcerer knows about him but you cannot tell what projects were those. Sourcerer simply does not receive or store any more detail than that. Please let me know if you have questions!
It is not yet done, and we have no ETA when it will be available.
No, it is not a full blown tracing GC, it's an algorithm which is a variation of trial deletion, where analyzed only recently changed part of the object graph.
Yes on youtube JetbrainsTV in about a week they said.
It's meant for those cases where you can't convert a project to Kotlin yet, but you miss Kotlin's null safety too much.
Really nice job
`@Nullable` annotations are already supported by most major IDEs (or IntelliJ, at the very least). You can even turn possible null warnings into errors. The biggest problem with this approach is that not every JVM library uses these sort of annotations, which makes you have to code "defensively" against third-party APIs. To be honest, your DSL does not look very good in Java. It's also limited by the amount of methods that you write (or generate?) and long transformations might be tedious. It's also not immediately obvious what you're doing in `let`, for example. I'd very much rather have an API similar to this: let(object) .map(SomeClass::getStuff) .map(stuff -&gt; doSomething(stuff, otherStuff)) .orElseThrow(MissingResourceException::new) But that's just basically Optional, isn't it?
Can you please add more details about why macros are very hard to support in tooling?
Regarding the annotations, it actually expands on JetBrain's @NotNull and @Nullable annotations. While it is true that those annotations already exists, having to annotate nearly everything as @NotNull would be very tedious. That's why there is the @NotNullByDefault meta annotation that automatically annotates everything as @NotNull. Regarding let, my experience is that people take a few days to get used to the syntax, but after that it feels natural to them. Your orElseThrow idea is interesting, if I added a special version of let I would write your example like this: letElseThrow(someClass, SomeClass::getStuff, stuff -&gt; doSomething(stuff, otherStuff) ); I honestly feel that the let syntax is as readable as method chaining, the only difference is that instead of starting lines with a period you end them with a comma.
The lack of documentation is painful. I still don't know how to get @Location working right. But it seems widely used, at least in Kotlin circles.
It's not "the Java way" and isn't very flexible. I can chain as many `map`s and `filter`s as I want, while your `let` just allows me to use up to like 7 transformations in a row. Hell, I need to work _around_ your API to use something as basic as `filter`. If your library needs some getting used to for no obvious benefits, it's unlikely to be widely used. Compare `let` to Vavr's [Option](http://www.vavr.io/vavr-docs/#_option) or Try. It's great that you want to contribute to open source, but I think there are already too many tiny utility libraries out there. Vavr, Guava and even Java stdlib all solve this issue. Don't reinvent the wheel, contribute to existing projects.
That seems to be a common sentiment and it's something I noticed when looking at the repo.
That's not the point. Sure, Vavr is great if you work in a team that understands it and isn't completely opposed to anything that's not 100% compatible to Java's standard collections but if you just want to solve some NPEs in a non invasive way null4j works great (at least in the team for which I wrote this). Also, if you really need it you can add a way to filter; let is expansible because it uses function parameters instead of method chaining so you could do something roughly like this (not tested): public static &lt;T&gt; Function&lt;T, @Nullable T&gt; filter(Predicate&lt;T&gt; p) { return (t) -&gt; p.test(t) ? t : null; } let(x, filter(X::isNice)); I guess what I'm trying to say is that you might not be the target audience. Null4j is for those projects where people want to write plain old java but also want to get rid of NPEs. If you like FP you might like my other completely different library "Ravr", which is Ramda for Vavr, i.e. functional programming with curried function, partial application, parameter placeholders etc. https://github.com/rednifre/ravr
One thing I wish such tutorial would point out is that the syntax: ... , block: T.() -&gt; R ... actually makes a lot of sense. It's "as if" the block was a new method on the type T.
thanks 
Do you mean that the block is added to the class similar to how extension functions work?
Yes, lambdas-with-receivers are the lambda equivalent of an extension function.
&gt; Null4j is for those projects where people want to write plain old java but also want to get rid of NPEs. But Optional already does that, and it's in the stdlib making it the definition of plain old java: Optional&lt;Street&gt; getStreet(Person person) { // Use safe navigation to reach into objects without NPE return Optional .ofNullable(person) .map(Person::getAddress) .map(Address::getStreet); } // implicitely NotNull String getStreetName(Person person) { return Optional.ofNullable(person) .map(Person::getAddress) .map(Address::getStreet) .map(Street::getStreetName) .orElse("could not find street name"); } And Java 9 brings Optional.or, solving the use case for requireNonNullElse =/ You're requesting people learn an entirely new set of API calls when people are already familiar with map/flatMap/filter from streams, making it less readable for the average developer with less options than Optional (get, orElse, orElseThrow, etc). I appreciate the idea, I just think that it doesn't solve anything that hasn't already been solved in at least an equally good way.
Dagger works without problems. I've also used Injekt which was very pleasant to work with, but the project is discontinued. There are new di libraries for kotlin: kodein and koin but i didn't use them. But you can check them out I would probably stay with dagger since it is almost standard tool. 
Kodein feels a little like using Guice in Scala. Really good and fun framework to use. It also worked for me on the first try, no configuration issues.
Thanks! Good to know that dagger is a solid choice for Kotlin.
Kodein looks interesting. Thanks!
Is that something you want though? The creators of Guice made Dagger because of all of the flaws in Guice (everything was wired up at runtime, mainly). Kodein is cool and elegant but I don't get see a lot of advantages to it over doing DI manually. Dagger, on the other hand, does constructor injection (the right way to do injection) and handles calling `new` for you automatically. 
This only works for objects. What would be in the list if all the subtypes were data classes? What about mixed data classes and objects?
Why do you need the list? Part of the awesomeness of sealed classes is that you can use `when` to exhaust all the cases. You just need to use the result of `when`. 
Koin is another alternative https://github.com/Ekito/koin Have not used it so no opinion on its quality. I only know it is Kotlin only (doesn't work with Java). Might be worth a look.
You could put an init-block into the sealed class so that any new created object that inherits from it registers itself with a central list when it is created. Something like this: ``` sealed class ViewType { val values = mutableListOf&lt;ViewType&gt;() init { values.add(this) } } ``` I've typed this on my mobile, so no idea if it works exactly like that, but it should get the idea across
Or `fun exhaust(type: ViewType) = type.name` So you don't need to touch `exhaust` after adding another subtype. Actually you don't even need `exhaust`, if `ViewType` asks for an implementation of `name`. And it doesn't help to iterate over all available subclasses. You can save instantiations in an companion object of the super class or use reflection (if not necessarily all subclasses will be instantiated): https://stackoverflow.com/a/44789360
I have been using [Toothpick](https://github.com/stephanenicolas/toothpick) lately, and I'm quite pleased at how much more intuitive it is than Dagger 2.
In Java I was a heavy user of the "New" framework, but as Kotlin doesn't have "New", I just don't use any DI framework anymore. ;) 
:D
If you are willing to nest class definitions in your sealed classes, you could try something like: type.nestedClasses.filter { type in it.superclasses } 
Why would you write main class in Java if you use Kotlin? This line really hurts my eyes since Kotlin has string interpolation: &gt; return String.format("%.1f %sB", bytes / Math.pow(unit.toDouble(), exp.toDouble()), pre)
This is really great to see, hopefully in time picking up a job in kotlin will be a little easier, because I would loved to be paid to write it.
Just go to /r/adventofcode there are many using kotlin to solve the Christmas daily challenges :) 
I cannot find it, there was a ticket about it on Jetbrains tracker to do it using reflection.
This will create a singleton list for every subclassed instance. `values` needs to be in a companion object.
Try to ask in stackoverflow
I just found it in the docs, must be new terminology.
You're right, I knew I'd overlook something obvious like that. Thanks for the correction, I've fixed my example~
I like your reassignment the list instead of using a mutable list. I do hope you're not using that in other places where the list might have a lot more elements, though. ;)
There's a dozen of us! ;)
Unfortunately shifts like these are much easier explained by sites like google cleaning up their index than anything else really. TIOBE is pretty much the worst way to assess popularity because it's simply wrong 100% of the time. 
Yeah, I changed that because I noticed that otherwise outside classes could modify the list, and I didn't feel like creating a separate variable for a public immutable view on the list. :D If my explorations into the functional world have taught me something, it is that this is often the safer approach, and using mutable lists is often akin to premature optimization. But yes, I am always aware of the potential resource hog and prepared to switch to a more memory efficient solution if it proves too much :)
TIOBE is such a joke, I can't fathom why it's quoted so often. Search Indeed.co.uk's API by title and you'll find 4 Kotlin jobs in London so not quite lift-off yet, I'm afraid.
&gt; Why would you write main class in Java if you use Kotlin? when i tried to bundle the jar file, the manifest file was not visible to jvm if the main method is within kotlin class, so i had to make it in Java class, &gt;This line really hurts my eyes since Kotlin has string interpolation: it was copied paste from SO, i'll change it, keeping your eyes safe 
Because an IDE has to know what a macro has expanded into, and that means executing arbitrary code in dev time, which a) will not work if the project does not compile (e.g. in the middle of a refactoring) and make some of the tooling useless a lot of the time, b) may slow things down considerably, c) complicates the implementation considerably
https://stackoverflow.com/a/28364983
Extension functions are represented as static methods where the first argument is an instance of the type you are "extending." The only way to invoke extension functions in Java is through those static methods.
You can access extensions methods as you would normally use static utilities in Java. There's even a way to use Kotlinesque syntax for extension methods thanks to [Lombok](https://projectlombok.org/features/experimental/ExtensionMethod), but not everyone is a fan of this framework (or its experimental features), so proceed with caution.
Don't forget @file:JvmName() to get rid of ugly Kt suffix.
How about /** Delete all duplicate files at or under the supplied files */ fun File.deleteDuplicates(): Unit = listOf(this).duplicates().forEach { it.delete() } /** Recursively search for duplicate files anywhere at or under files in this list */ private fun List&lt;File&gt;.duplicates(): List&lt;File&gt; = flatMap { it.allFilesIn() } // Find lists of files having the same size .groupBy { it.length() }.values.filter { it.size &gt; 1 } // Group these files by md5 hash, ignoring the first .flatMap { it.groupBy { it.md5() }.values.drop(1) } .flatten() /** Return a list of all files at or under this one (recursively) */ private fun File.allFilesIn(): List&lt;File&gt; = when { isFile -&gt; listOf(this) else -&gt; listFiles().flatMap { it.allFilesIn() } } /** Return an MD5 hash of this file as a string */ private fun File.md5(): String = with(MessageDigest.getInstance("MD5")) { forEachBlock { buffer, bytesRead -&gt; update(buffer, 0, bytesRead) } BigInteger(1, digest()).toString(16) } 
Well, have you tried Java then? Especially JavaFX, it's possible to reuse JavaFX code on desktop and Android/iOS, and Kotlin is interoperable with Java, so you can, actually, start writing in Kotlin right away.
I know a few places which finished Kotlin eval (running on smaller side projects). They are getting ready to roll out initial prod services on Kotlin. 2018 should see a presence in the job market.
really interesting, thanks for sharing 
I had to modify this part of the code to let it work correctly private fun List&lt;File&gt;.duplicates(): List&lt;File&gt; = flatMap { it.allFilesIn() }.distinct() // Find lists of files having the same size .groupBy { it.length() }.values.filter { it.size &gt; 1 } // Group these files by md5 hash, ignoring the first .flatMap { it.groupBy { it.md5() }.values.filter { it.size &gt; 1 } } .map { it.drop(1) } .flatten()
You are right! Good catch.
At work so skipping through, but that looks like Free Monads / Free Applicatives. I've done a bit of this in Kotlin. It's a bit more verbose in Kotlin compared to using something Cats in Scala (especially with the many libraries that aid with this in Scala).
It is indeed! And we're working on the verbosity ;)
Kategory je a nice reader monad
That's that crappy course that was posted a week or so ago. They need to actually finish it properly. Too little content with too fast a pace.
Yah! I agree with you, but its a intro to kotlin and anko not a complete course that's why I suggest you to please fill out the survey so that they understand what the audience what to you learn :D
It's not that either. It's a useless course. It should have been a web page.
Totally agree. It ranks a 6.5 on the Bristol scale. Substance is thin and watery with only a few notable nuggets. Easily passed in minutes.
I don't necessarily consider Kotlin a beginner-friendly language, TBH. In fact, in my experience, all Kotlin has ever achieved to do for one entry level developer that I know, was confusion. He's been working with the language for more than a year now and he's still confused about many concepts.
I want a similar course to the java ones available for free
`count()` also accepts a predicate
Is update the reason why my Kotlin tests aren't reporting wrong line numbers anymore? I was losing my mind about that.
Oh youâ€™re right. Thanks! 
If you are going to make a tutorial at least cover the basics. That means a database, authentication (JWt,m facebook etc), migrations, live reloading, swagger etc. 
Does anybody know of any good Android course using Kotlin? I found some on Udemy but there are so many I got confused. Any help is appreciated, thank you.
I wrote this tutorial the day I picked up Kotlin. It was intended for Spark developers curious about the language. For better or worse, Spark doesn't care about databases, authentication, facebook, live-reload, or swagger, so I don't agree that that's something basic that should be included in all tutorials. 
Which is the better choice really depends on your usage. Spek is more opinionated, enforcing a specific given-when-then like structure to testing. This can be both good or bad, depending on whether it aligns with your approach. It has better IntelliJ support with its own plugin (Kotlintest simply doesn't work as well there, in my prior experience). KotlinTest has several usage patterns - similar to its inspiration, Scalatest. It also currently has a couple more features - property-driven and table-driven tests, which means that it is a bit more advanced than Spek right now IMO. The latter can be done in Spek, but are not fully implemented yet (more work required/poorly documented). I would love to see both frameworks merged, because I really don't think one needs two specification-driven test frameworks in a small language, but that does not seem to be happening anytime soon (see also Specs2 vs Scalatest in Scala, for a similar situation). It's a pity, because I don't see any benefit from splitting the community. Personally, although I like KotlinTest more, I would lean more towards Spek at the moment for the simple reason that the latter has a group of developers behind it (including people from Jetbrains), while the former is primarily the work of a single person.
I would agree here, the example is not about implementing those features but about bootstrapping a Spark App with kotlin, to lower the barrier for people to try it.
Hi! Try kotlin and anko course on treehouse just Google "android koltin course teamtreehouse" :)
Interesting, thanks! have you taken it?
Yup! Its great :D 
I'm interested in this as well, would like to know beyond the basics to set up a spark server
There are tutorials on the page for that, but they are in Java. 
From "Kotlin in Action" book: SIDEBAR "Using the right function for the job: count vs. size Itâ€™s extremely easy to forget about count and implement it by filtering the collection and getting its size: &gt;&gt;&gt; println(people.filter(canBeInClub27).size) 1 But in this case, an intermediate collection is created to store all the elements that satisfy the predicate. On the other hand, the count method only tracks the number of matching elements, not the elements themselves, and is therefore more efficient. As a general rule, try to find the most appropriate operation that satisfies your needs."
This is about SparkJava, not about Hadoop Spark.
If you want people to use Kotlin I say you provide a real world example. Chances are they don't know spark either. Also if spark doesn't care about all that why should we use it?
Interested in the technique even though I don't play mobile games!
&gt; If you want people to use Kotlin I say you provide a real world example. Chances are they don't know spark either. The tutorial was written for Spark users and published on the Spark website. It focuses on trying out Kotlin with Spark, and shows some differences from working in Java. Even if the tutorial wasn't interesting to you, it's one of our more shared tutorials (note that I wasn't the one who posted it here). &gt; Also if spark doesn't care about all that why should we use it? No one is asking you to use it. If you don't see any benefit to using Spark, you shouldn't. And that's okay, you can't please everyone.
I tend to agree that in terms of immediate usefulness Spek is a better choice, although that's purely based on Intellij integration. I forget that people like GUI Integration, a lot.
Nice article in general, but I don't know why not use a simple while-loop everyone understands immediately for those cases? Instead of writing a cumbersome lambda-stuff solution that is most likely slower than a regular loop. Am I missing something?
This is pretty much just having fun with Kotlin :) I'd actually write it using while loops in production.
Hello, Verbosity!
The one saving grace of old-style for loops is that they force you to write an increment clause. With `while` it's easy to forget or accidentally delete that clause, and bam, infinite loop.
What is this and what does it do? I read the Github readme and am still confused.
It makes a JSON of all the users, the groups they belong to and can be used with a settings file to add to the JSON if the user is an elevated user/belongs to any elevated groups. Does that make sense? 
Could be a few things. Are you using minify/proguard on debug builds? It can cause strangeness like this. Also I have seen it blow past the debugger if you are trying to debug a line that is within an inline function
Ah okay, i have to try Not to See everything as production Code immediately xD
I did this a lot when first starting out with Android Studio. Make sure you are hitting the 'debug app' button and not the run button. The run button ignores breakpoints.
What a weird and beautifully unkonventional idea you had, I like that approach. 
Can't resist. A bit more functional approach: fun cFor(seed: Int, predicate: (Int) -&gt; Boolean, next: (Int) -&gt; Int, block: (Int) -&gt; Unit) = generateSequence(seed, next).takeWhile(predicate).forEach(block) But yeah, don't write like this. :)
that dsl function needs to be inline...don't even want to imagine the bytecode...
This looks even better +1
You are right. I have made the change.
Or, functional without generating any Sequence: tailrec fun &lt;A&gt; loop(init: A, test: (A) -&gt; Boolean, next: (A) -&gt; A, block: (A) -&gt; Unit): Unit = if (!test(init)) Unit else { block(init) loop(next(init), test, next, block) } `tailrec` causes the compiler to unroll this to ... well, almost exactly what OP wrote!
In while-loop, we often forget to increment because it's placed at the end of the loop, so they invented for-loop.
I know this is going to sound stupid, but make sure the code in question is actually running. I can't count the number of times that I've had the same problem only to find out the code was never being invoked. 
&gt; `tailrec` causes the compiler to unroll this to ... well, almost exactly what OP wrote! Almost. When you use the `tailrec` modifier, the compiler warns you, if there is no tail recursion and therefore it can't replace the recursion with a loop.
100% the second one, the first one is just misleading. There's also no performance difference. Even better would be: ```for (value in li) { //process value }```
Check it via the Kotlin bytecode and decompile to Java and tell us then which one is more efficient!
Traversing a list was just an example, sorry if it was misleading. My question is about where to put variables: inside a loop or outside a loop? If I put the variable declaration outside, it must be `var`, however inside they can be `val`, which can express better my intention and thus the code is more readable IMO. I don't find the first option misleading at all, by the way.
Before doing that, I'd like to hear the opinion of some people who know the answer to the question. Following your logic, we could send everyone away with "hey, check it out yourself".
I could have sworn they were the other way around in your post, of course the first one (with a variable inside the loop) is the correct one and the other one is misleading. In general, declare variables in the smallest possible scope.
 for (row in matrix) { for (value in row) { // process current value } } &gt; In general, declare variables in the smallest possible scope. I fully agree, but I prefer: In general, declare `val`ues in the smallest possible scope.
personally: li.forEach { process value }
Vscode is not just an editor. You need plugins to do basically anything and that makes it an IDE.
Even though I didn't benchmark it (and that's the point where someone has to advice that you should always benchmark first and never guess), I tend to say that there's no difference in performance. Either the compiler unrolls the loop or escape analysis will do the job. Of course, this remains to be proven. In general, write the code exactly after your semantics... that means leave the reference at the smallest scope possible and make it immutable. Or use another loop construct, as some other people already suggested :)
Yes, in nearly all cases, performance is the compiler's problem to solve. Our job as developers is clarity and correctness. In that order!
How is it different from this? for (value in li) { // process value } Is there a reason to prefer one over the other?
 for (i in 0..10) { li[i]?.let { value -&gt; // do stuff } }
This isn't something you can cleanly do in a garbage collected language. When objects go out of scope, only their references are guaranteed to be destroyed immediately. If you need to do stuff after executing some code, check out the use function in Kotlin's standard library.
It is possible in java using phantom reference, so also applies to kotlin on the jvm. See this article for details: https://dzone.com/articles/finalization-and-phantom
normally I'm using this at the end of the chain: li.map { ... }.filter { ... }.forEach { process value } Furthermore, if you suddenly decide you want to pre-filter the list or something, you can more easily add it if you're already using forEach (like if business rules change) fun doSomething() { li.forEach { processValue() } } // later... fun doSomething(predicate: Predicate&lt;T&gt; = { true }) { li.filter(predicate).forEach { processValue() } } It's really a personal choice as well. I'm not very fond of imperative programming patterns and tend not to think that way anymore, so the more functional/pipelined style suits me more.
Strange that nobody seems to be interested in this topic that much :) I recently researched for a good way to to data oriented design or a construct comparable to type classes. While delegation is one good way to extend an existing API, here's a nice example how the in the article mentioned extension functions could be used as the poor man's type classes: interface ExtensionProvider&lt;T&gt; { fun T.customExtensionMethod() } object IntExtensionProvider : ExtensionProvider&lt;Int&gt; { override fun Int.customExtensionMethod() = println("Custom method prints: " + this) } fun &lt;T&gt; someFrameWorkFunction(list : List&lt;T&gt;, extensionProvider: ExtensionProvider&lt;T&gt;) { with(extensionProvider) { list.forEach { it.customExtensionMethod() } } } fun main(args: Array&lt;String&gt;) { someFrameWorkFunction(listOf(1,2,3), IntExtensionProvider) } Although one has to provide the extensions as a seperate parameter, there are some advantages: The extension provider can be a singleton object, hence eliminates the need to create objects. Maybe it's easier to optimize for the compiler as well, i dunno. Also, being explicite makes it easy to grasp what's going on here.
I have only used it for small microservice like projects. A 3 line webserver to display the location and distance of an object in a camera. I imagine if you wanted to do a full app, you would need to connect an orm, a templating library, some logging, and some testing libraries. May be easier to use something else at that point.
`finalize` is supported, see https://kotlinlang.org/docs/reference/java-interop.html#finalize. But really, just don't.
Maybe create your own Destroyable interface and create a function that takes a list of such objects and an inline lambda function. 
pluralsight have 3 months free access check it
Kotlin can do some optimizations when you add **inline** to a method. Then the compiler inlines the function call logic. https://kotlinlang.org/docs/reference/inline-functions.html
I want to understand kotlin native more... Is it will enable me making a button in android, iOS with same methods then I can use one code to control it?
You article has nothing to do with Kotlin. In Kotlin you'd like to avoid Streams from Java Library. Instead use Kotlins build-in extension functions, like **forEach** **filter** **map** **fold**. If you want paralellism use Coroutines. Much more efficient then using streams. someList.map{ launch { item -&gt; /* stuff in parallel */ } }. forEach { it.join() }
Yeah you could do that. Probably you'd write you presenter/model/networking logic in kotlin and keep your view stuff in swift though. You could just call to UIKit via objc from kotlin and avoid swift altogether though.
It allows Kotlin to target native platforms and by extension their ecosystems, which could mean what you said there by targeting iOS, or you could use Kotlin with GTK+, Caffe, any library that you'd normally not have access to from the JVM, because you wouldn't have a JVM at all :)
Thank you for your answers :)
As to why not: http://www.informit.com/articles/article.aspx?p=1216151&amp;seqNum=7
Have you heard about Kategory yet? It might be what you're looking for, check http://kategory.io/docs/datatypes/either/
Ok, now what about multiple variable cases: for (i=0, j=0; i &lt; a.size || j &lt; b.size; i++, j++) { }
I wish there had been more practical tips for the actual Android side of things. There are plenty of vanilla Kotlin tutorials already -- some of us know Kotlin and want to learn Android, now.
Random link is random... 
Same company homie.
Agree, except for the ordering - correctness then clarity [did you work on any of these?](https://en.wikipedia.org/wiki/List_of_software_bugs) 
Neat
This links to projects which are 18 days old, have zero stars and no documentation just because some random dude made a pull request to get his project added. It shouldnt be called awesome Kotlin but random uncurated Kotlin.
From my experience it's pretty easy (with the right amount of experience) to convince people in small and medium companies to start using Kotlin. You just have to approach it correctly and be prepared to spend some extra hours selling the team on it and documenting use. Christine Lee had a great Google I/O session on exactly this. 
The huge problem with Java based DI libraries is type erasure. Using a kotlin based DI library will make it easier to inject generically typed things. 
It also clearly rips the name of the long-standing and much better awesome-kotlin: https://github.com/KotlinBy/awesome-kotlin
And maybe find another name for SparkJava
I've always liked https://kotlin.link
Like most of the talking kotlin podcasts I hear a lot of kotlin love but very little theoretical arguments about why... most developers it seems understand and appreciate little more than the syntactic sugar. Hadi needs to be a bit more aggressive in his interviewing style rather than mostly laid back and hearing the same stuff every podcast.
Sparkjava is a terrible framework. It has an unnecessary amount of global state and odd api decisions just for the sake of saving one or two lines of code. I recommend anyone planning a project that will span more than a single file of code to avoid it. If you want a minimalistic web framework there are much better alternatives available. Dropwizard, undertow, hell even ktor if you want to try something made specifically for kotlin. Just please don't use sparkjava.
I wrote a very basic web framework that works like I think it should work. Requests and responses are just POJOs, and handlers are just functions from request to response. Each component is composable and can be tested on its own, without starting a server or mocking (usually). It minimizes global and mutable state, and tries to wrap HTML in enums where possible (leveraging the compiler to better prevent bugs). I haven't written many libraries before and definitely nothing even close to a web server, so I'm very much shooting from the hip in this project. [Link](https://github.com/snordgren/hydrogen) What do you think?
[Oh no!](https://pbs.twimg.com/media/CJV74ErUYAITant.jpg)
I am not a fan of these functional-only web frameworks (I like my annotations) but the design and API look alright. It's hard to judge without trying, though :)
Hah, very true!
Thank you! Different strokes for different folks I guess, I wrote it because I found annotations complicated ;)
What do you think about [javalin](https://javalin.io)? 
Nice. Iâ€™ve been meaning to play with this. I have my Christmas project.
I dunno, as I've said in the other comment, I like my annotation-based frameworks, but it looks fairly sane. It's hard to really judge without trying, and there's way too many such frameworks to try them all :)
Tell us how you liked it! :)
Gotcha. I made javalin to fix the problems with Spark that you mentioned (among other things), but if you like annotations then I guess it's not for you. 
I feel like if you want to promote your project as a guideline on the languages subreddit, you should at least use and understand basic features of the language. This looks no different than a standard Java code just overwritten into Kotlin withtout using any of the languages features (just by looking at first 3 files I found): You are using getInstance pattern from Java for singleton objects instead of using object keyword defined in Kotlin. You are creating unnessecary nullability by returning nulls from function where e.g. empty string would have been sufficient. I also feel like in some places lateinit keyword could be used instead of initializing variable with a null value.
I don't think I am experienced enough to post it as a strict guideline, but I believe it may be helpful to people who just started learning Kotlin and/or Android, or are just curious how to make a quiz :) Without a doubt that code could be improved (and it will), but it's not that I don't know basic features of Kotlin. For example - for some reason creators of Kotlin and Anko *do* use that getInstance pattern (https://github.com/Kotlin/anko/wiki/Anko-SQLite). I am also pretty sure I have found it in some examples from Google. Sometimes object keyword is just not so appropriate to use. Anyway, thank you for your answer. Constructive feedback is always appreciated. I'll look into those pesky nulls soon ;)
A killerfeature to me, but so far I have only used Ktor for Kotlin APIs. Is Jooby comparable to Ktor in stability and features?
I appreciate your calm response and the fact that you responded at all. You should always take reviews like this with a grain of salt. I looked at your project without knowing anything about the tools you use or any knowledge about how familiar you are with the tools Kotlin provides. That said if you think that some kind of pattern should be used, then it should be used - you are the developer. But to avoid situations like this you could maybe add a comment explaining why do you do this, instead of the other choice, especially if you plan to publish your code and want other people to look at it. Nonetheless, great project and attitude. Keep it coming.
Inb4 we start seeing 12 fps (except for that one 2-second frame) games written in Kotlin on the JVM.
There are better ways I think, like min(10,length) for upper range, or using li.take(10).foreach { ... }
What?
You underestimate the JVM and today's machines.
Minecraft is probably good testimony that the JVM can work just fine for 3D, but it's still far from what modern hardware can give. This should be useful on Android.
Minecraft is also very poorly written. The JVM is actually quite fast nowadays.
Minecraft is an example of a poorly written game. C#, Lua and JS are not particularly faster than Java, but they are still commonly used to develop games - the heavy parts are usually implemented in optimized native code anyway. What JVM lacks is a popular, feature-complete game engine with a proper GUI. LibGDX is OK for mobile/2D, while jMonkeyEngine seems pretty good for 3D (never tried it out), but nothing comes close to Unity or Unreal in terms of tooling or community. One could argue that Java is not a very good language for gamedev - Kotlin could potentially shine in that area, but unless some company heavily invests in it, I don't think it's going to be mainstream. I've seen some efforts to [introduce Kotlin API to some popular engines](https://github.com/hiperbou/kotlin-unreal), so I might be wrong though.
I'm not familiar with web backend/frontend development, but recently a [webminar about multiplatform kotlin projects was release](https://blog.jetbrains.com/kotlin/2017/12/webinar-recording-developing-multiplatform-projects-in-kotlin-1-2/) explaining how to build jvm/js/native projects. According to [minute 44:10 in the webminar video](https://youtu.be/afc5PUs_EPE?t=2657) it is possible for kotlin code to _import_ typescript files. You will have to explore yourself how long this integration goes and if it allows what you need. There are several github links embedded along the video which might provide help or existing examples of integration.
You could use something like https://github.com/ntrrgc/ts-generator to generate the type definitions and just compile the actual kotlin code to javascript. I have no idea how well it would work though.
Haha no but I have inherited many, many lines of code. Project A: you read the code. It is clearly written and clearly solves the wrong problem. It is easily fixed and remains readable. Project B: you read the code. You can't tell what it does or why it does it. You ask your manager for 2 weeks to refactor the code to readability. She laughs at you. You make a change and hope it fixes the problem without creating new ones. The code becomes a bit less readable along the way. Repeat endlessly. I would rather work on Project A 10/10 times.
&gt;A quiz, in which the player has to choose the correct country based on **it's** flag. *its
&gt;Much more efficient **then** using streams. *than
If you're setting it inside init you can just make it val. Otherwise, you could use a lateinit var
If you really want it to be val you could assign it with a function which assigns value to it when creating an instance of the class e.g.: val prop = countLines()
Thanks, the `init` way worked. Could you give an example of `lateinit`? I haven't used that feature yet.
I use it all the time with stuff that gets initialized in onCreate: lateinit var a: A onCreate(...) { // Accessing a here will throw error a = A() // Accessing a here is fine. } Main usecase is for injected properties or views.
If the value is needed later while the calculation of it is kind of expensive (file io, network, ...), there's also `lazy` val numberOfLines by lazy { lines() }
Any reason for not using val a by lazy {...} Is the lambda cost not worth it?
You can do that if the initializer doesn't depend on any local vars you would have access to in onCreate. But what if, say, it depended on savedInstanceState, which is a param passed to onCreate? 
Yeah, good point.
Lambda cost is negligible in kotlin. Most stdlib methods will inline stuff for you automatically. The cost of lazy comes with the thread synchronization code it uses.
s/girl/engineer/
Recommend other talks by Christina Lee also. Sheâ€™s great at making complex topics understandable
Bah, enough with the PC attitude. If it was a male doing the talk and the title had said "This guy explains covariance", nobody would have batted an eye. Equality for all. 
Ask a female engineer at your company, if you can find one!
Why did you feel the need to draw attention on the gender of the presenter? Nobody cared until you did. 
I disagree - boy:girl::guy:gal - if the title had been "this boy explains...", people would have called it out. But more importantly, nobody gives a shit about whether you were _not_ offended by the title; that's not how it works.
&gt; Why did you feel the need to draw attention on the gender of the presenter? Jake didn't draw attention to the gender of the presenter. In fact, he suggested a _much more relevant_, gender neutral term (extra emphasis on much more relevant). &gt; Nobody cared until you did. I did. When I saw the title, I came to make the same comment Jake did. &gt; your remark is naÃ¯ve and only serves to perpetuate sexism Jake's comment was about recognizing the speaker's qualifications instead of their genitals. _You_ made it about gender.
&gt; Jake's comment was about recognizing the speaker's qualifications instead of their genitals Would you have had a similar reaction if the title had been "This guy explains covariance"? Actually don't answer, I found the answer in your history, a post of five days ago, where [you quoted someone saying](https://www.reddit.com/r/Android/comments/7lebny/holy_shit_note_8_camera_stabilization_is_top_notch/drm0647): &gt; this guy's pulling out four phones one after the other You didn't feel the need to correct that person to use "that person" instead. So you suffer from the same double standard, and its attached subconscious sexism. I'm not accusing you of being sexist, but of perpetuating sexist stereotypes. There is no need to correct "guy" or "girl" in much the same way it doesn't make sense to correct someone describing someone else as being dark haired. It's just a description. You are the one choosing to add sexist undertones to it. 
&gt; The cost of lazy comes with the thread synchronization code it uses. If your initializer can tolerate multiple calls, [LazyThreadSafetyMode.PUBLICATION](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-lazy-thread-safety-mode/-p-u-b-l-i-c-a-t-i-o-n.html) will reduce overhead after initialization; see [SafePublicationLazyImpl source code](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/util/Lazy.kt#L176). 
&gt; Would you have had a similar reaction if the title had been "This guy explains covariance"? As I already said in reply to your original comment, that's not the male equivalent of girl. I don't think anyone would have cared if OP had said, "she explains covariance..." &gt; It's just a description Yeah, just a factually incorrect one.
Heh, good catch :)
Gal is just Girl pronounced with a shitty cockney accent. Gal is to girl what ma'am is to madam. Some people find "gal" more offensive than girl.
Just give it time :)
Swift isn't on there either.
Absence does not clear something... Brainfuck, whitespace, Delphi, and COBOL are all omitted from this list. Does that mean they don't suck as well?
I guess after enough production code is written in Kotlin antipatterns will surface.
The undisciplined masses from a certain unnamed subcontinent will start producing spaghetti like you have never seen before.
You should include many of the large corporation "developers" all over the US as well. 
The "US". Almost all large corporation developers in US companies are outsourced.
Madagascar? :P
â€œGuyâ€ doesnâ€™t carry the same connotation as â€œgirlâ€ for a lot of people. When I hear â€œgirlâ€, I think of an adolescent or a child (same with â€œboyâ€). So the post title makes an unnecessary reference to the presenters gender _and_ subtly (and probably unintentionally) infantilizes her. â€œGuyâ€ is informal, but not necessarily young. In some places, â€œyou guysâ€ can be used to refer to a mixed group of men and women. Iâ€™ve been corrected for calling female engineers â€œgirlsâ€ before. Like you, I didnâ€™t think it was insulting, but they did. Instead of arguing with them, I decided it was probably best to stop doing the thing that offended them. It costs me nothing. 
Oh kotlin definitely sucks: 1) No ternary operator val foo = if (bar) 1 else 2 vs int foo = bar ? 1 : 2; 2) No bitwise operators val x = (1 shl 2) and 0x000FF000 vs int x = (1 &lt;&lt; 2) &amp; 0x000FF000; 3) lackluster type inference fun &lt;T, R&gt; foo(value: T, bar: (T) -&gt; R) ... fun &lt;T, R&gt; bar(f: (T) -&gt; R): (T) -&gt; R ... does not type check foo(1, bar { it.toString() }) vs java works fine foo(1, bar(i -&gt; i.toString())); 4) Missing `compose()` and `andThen()` on [functions](https://docs.oracle.com/javase/9/docs/api/java/util/function/Function.html#compose-java.util.function.Function-) 5) No equivalent to [package-info.java](https://discuss.kotlinlang.org/t/equivalent-of-package-info-java/3272) (for real kotlin is awesome but there are def little things they can improve)
Don't forget silent nulls from Java interop Remember to either annotate your Java source or treat it as nullable.
Definitely agree it can improve! A few replies, though: 1. I used to long for ternary and was surprised to find it missing, but really I do not miss it anymore. `if` as an expression works fine. 2. If I remember correctly, these might be making an appearance in a later version of Kotlin. They were the second most voted for feature in the Future Features Survey earlier this year. 3. That for sure sucks! No reply for this one, the type system needs some work. 4. With implicit invokation syntax, can these not be modeled normally like f(g())? 5. I would argue this is a tooling isuse, but those are still relevant. Would love to see Dokka support for something like this.
4) It's for when you want to create a new function out of existing ones. You can do it directly but it's sometimes it's nice to read things left-to right instead of in-out val r = f.andThen(g) r(foo) vs val r = { a: Int -&gt; g(f(a)) } r(foo)
The biggest one for me is lack of package access modifier, breakable as it may be.
Swift isn't there either.... I'm not sure "Swift doesn't suck." is a true sentence though.
You mean internal modifier?
Didn't realise compose and andThen were missing, haven't written a lit of Kotlin recently.
No, internal is functionally more public than package access. If we mix Java and Kotlin access modifier: public &gt; protected &gt; Kotlin internal &gt; Java default package level access &gt; private I wish they add them back as having both internal and package access actually complete the security hierarchy much more intuitively.
Damn, those JavaScript and PHP lists. The Clojure ones I can partially get, and the Scala ones I can get too (especially with it feeling like there's hundreds ways to one specific thing in Scala). Anyhow having like...a weeks worth of Kotlin experience and knowledge, my only complaint it the type system is just meh. It's not awful but it's not anything that amazes me/feels like a massive improvement from Java. But it's *definitely* an improvement, don't get me wrong.
* bad literals (negative hex literals impossible, no hexadecimal float literals, impossible to write minimum Long value in code) * problems with modern Java features (default interface methods) * no generic enums * lots of functions like apply and also and so on that don't do anything themselves and are often used to create antipatterns instead of simple if/else blocks and methods. 
Either Package private or Prorected does not belong on that list. Protected is not a strict subset of Package private. You can use protected methods in another package as long as you extend the base class. There is no Package protected where you can extend and use something but only in this package.
The list is based *access hierarchy*. Not subsets. Probably should clarify that. Kotlin `internal` is the language level hard boundary between consumers and producer, whereas Java package private is just structural formality for anything below Kotlin `internal`. Hence, why I mix them both to illustrate why both of them, or rather, Java package private can neatly exist in Kotlin. They might need to add something like `package-only`modifier given the default modifier being public.
Kotlin sucks: any integer between 0x80000000..0xFFFFFFFF throws error, stating theyâ€™re out of range (which is my only gripe with the language btw)
Technically you could use a custom property delegate, but I can't imagine why you would want to do so
Rookie guide?
Rookide. *** ^(Bleep-bloop, I'm a bot. This )^[portmanteau](https://en.wikipedia.org/wiki/Portmanteau) ^( was created from the phrase 'Rookie guide?'. To learn more about me, check out this )^[FAQ](https://www.reddit.com/78ilq0).
Hello Bot
[88 million years ago](https://www.google.co.uk/search?q=when+did+madagascar+split+from+india)
A bit xP
Nice, been waiting for this for a while, looking forward to trying it.
Interesting! Any comparisons with CoreNLP, spaCy and NLTK?
To be honest, I don't see any advantages over jOOQ or Hibernate.
Well *that* added a new dimension to my smartass comment. O.o
&gt; smart ass-comment *** ^(Bleep-bloop, I'm a bot. This comment was inspired by )^[xkcd#37](https://xkcd.com/37)
Oh *brother*.
The library was built for a very specific use case. From how I export data, to how I store it, merge it, add/drop new fields and even report on specific fields etc. Apart from being used in personal projects, it was built to address problems that I/we encountered when handling the backend of a National Electronic Health Record System that is currently deployed in Southern Africa. With extremely poor connectivity and rapidly changing requirements we had to deal with a lot of crap on the backend. The concept of "custom reporting tables", based on entities or specific fields from across many sources, in particular was of great importance. Regular views had terrible implications for performance. Outside of writing stored procedures or custom code I doubt Hibernate or JOOQ would give us exactly what we wanted out of the box. Also, at the time I wanted to bind straight to JavaFX beans as they were directly linked to my JavaFX based UI, and get around aforementioned bean serialization issues that are handled automatically by the lib.
Not sure why you're downvoted, this is one of the biggest problems in my opinion, too. Android colors for example are annoying to use. 
Hi, thank you for your feedback! KotlinNLP is entirely written in Kotlin except for few dependencies. Google Guava could be easily replaced as it is used just for its outstanding MultiMap implementation. Mathematical operations within the SimpleDNN library (https://github.com/KotlinNLP/SimpleDNN) are performed with jblas. Different libraries (or no libraries at all) can be used instead: the effort required is minimum as the essential mathematical functions are wrapped in a single package and thoroughly tested :) We have not made any benchmarks at the moment as we do not know yet which transition-based parsing strategy we would like to use for the default parser, mainly to handle non-projective sentences. Most likely we will create a new algorithm, inspired by the notes described here: https://arxiv.org/abs/1507.05630 NeuralParser uses SyntaxDecoder transition systems framework (https://github.com/KotlinNLP/SyntaxDecoder) so it is easy to implement the same parsing strategy Matthew Honnibal used in spaCy. We can not say anything yet about the speed of execution: spaCy is very fast! Right now KotlinNLP lacks proper documentation. Soon we will take care of this and compare with other systems, including those that participated in the CoNLL 2017 Shared Task (http://universaldependencies.org/conll17/) Thank you
very interesting... thanks!
This would be really nice for python generators. *ducks*
It would make sense to keep SimpleDNN as a Kotlin multi-platform project. You'd start with a single implementation first, but eventually changing from CPU/BLAS to GPU/CUDA could be as simple as choosing a different dependency for the end users. I look forward to a stable, documented release. I'd love Kotlin to become a viable choice for data science - I'm pretty sure it won't be able to compete with Python any time soon, but we've got to start somewhere. BTW, would you consider basing your libraries on some other Kotlin projects? I know there's an effort to create a Kotlin NumPy equivalent - [Koma](https://github.com/kyonifer/koma). It seems you could use that for your DNN project.
I like it. Looks a lot like how Option / Optional is used but then for try / catch. I've always found the try / catch construct to be verbose, this looks like an elegant solution.
The next steps will be making significant progress on language processing modules. Anyhow that is definitely an option that we will evaluate as soon as we have more contributors!
Author of koma here. One of koma's backends is jblas. If you used koma's API and selected the jblas' matrix backend you could conceivably get similar performance to your current solution, but with the option to switch platforms or libraries in the future. Koma doesn't use multiplatform yet as I'm waiting for kotlin/native to support it before rewriting the build system. Its on the roadmap though.
Hi, many thanks for your reply and compliments for your library. Do you plan on using GPU? SimpleDNN performs operations among dense, sparse and sparse-binary matrix. We currently developed a naive implementation for that, do you plan to make a better support?
So currently koma itself just offloads the computation to the backend implementation, thus if you can configure the backend to use the GPU then you can use koma on the GPU. For example, MTJ supports cublas so you can use backend-matrix-mtj with koma and then [configure MTJ to use cublas](https://github.com/fommil/netlib-java/wiki/NVBLAS). In the future, it would also be possible to write a direct-to-gpu backend for koma, maybe using something like aparapi on the jvm. For kotlin/native, it should be easy enough to target NVBLAS directly. With regards to sparse and sparse-binary, koma doesn't have any support yet but its on the todo list. There's a few implementations that could be used. In particular ND4J appears to support it via cusparse, and MTJ might have some limited support (doesn't look like [jblas has any](http://jblas.org/javadoc/index.html) though). On native we could directly target cusparse, eigen, etc. I haven't looked into the javascript options. If there's any functionality thats missing and would be useful to you please feel free to open an issue, as that would help me track what people would like to have. If it doesn't already exist in a jvm/native/js library then koma could add a new implementation, however I'm trying to avoid reimplementing well known algorithms whenever possible. 
basic but great for beginners... like the burger analogy!
Any plans to support Android Studio?
Thanks - I do know about Kategory, but TBH that's even more like smashing an acorn with a nuke. :) A standardised either will allow ALL library writers to get on board with functional error handling, rather than creating the same type of stdlib+religiousFunctionalAddOnLibrary mess that currently inhabits the scala ecosystem.
Link to official guide: http://kotlinlang.org/docs/reference/coding-conventions.html
Also Jetbrains is working on [better auto-formatting](https://www.reddit.com/r/Kotlin/comments/7hoytl/kotlin_team_ama_ask_us_anything/dqso7xg/) in IntelliJ.
Yes! Check out Kotlin Koans.
Great! I really like the indentation rules. Currently IntelliJ wants to use two tabs (8 spaces) for things like constructor parameters and functions with expression bodies. Looks bad and fills the code with unnecessary space.
I think Java's probably the easiest to learn (well). It teaches you to have (fairly) good code, and kotlin has a lot more features / less restrictions. Personally, I'd start with java before moving to kotlin 
1. I actually like the Kotlin way, it is more readable. Ternary operators get abused and mutilitated by newbie programmers who want to be 1337
Set â€œcontinuation indentâ€ to 4. 
The last isn't operator precedence so much as `-1` being a negation instead of a literal. It does not make sense to me for `-foo.bar()` to mean `(-foo).bar()`.
&gt;It does not make sense to me for `-foo.bar()` to mean `(-foo).bar()`. I don't know, that looks plausible to me. But you're right, it looks especially wrong with literals. 
It's probably my experience with pointers making it feel weird. `*foo.bar()` and `&amp;foo.bar` have always worked like that.
The computers can not display all floating numbers exactly, because there are infinite amount of them so it tries to approximate by 32 bits (i.e in total it can display 2^32 floating numbers exactly). In your case, the computer could not represent 1.08 exactly so the closest representation is 1.07999999. There are two solutions: 1. Convert everything to `Int`s. 2. Add very small number before converting to a `Int`, i.e ((MAX - MIN) * FACTOR+ 0.001).toInt() 
[roundToInt](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.math/round-to-int.html) should stop the truncation error you get from using `toInt`
Thanks. That looks promising. Is this a static method? Android studio is giving a red squiggly when I try this: binding.seekBar.max = ((MAX - MIN) * FACTOR).roundToInt() 
Are you on Kotlin v1.2? The kotlin.math was introduced in 1.2.
The problem is conversion from decimal to binary. E. g. the decimal nr 0.1 has an infinite representation in binary. http://www.exploringbinary.com/why-0-point-1-does-not-exist-in-floating-point/
docs, sources, examples
I'm glad MDC support is here, I use this all over the place in slf4j to track request ids throughout my logs.
Just like you would do in any other language. You said you don't know html/css/js, start with them for now. If you're so eager to implement something, then spring tutorials would be a good start, also vert.x.
Udemy (finally!) has some good courses available on Kotlin, though naturally they are all Android focused for now. Look for Mark Price or Tim Bulchaka for high quality courses that also help with building professional developer skill sets and habits too. Kotlin in Action is also a good read, especially as it is written by the developers of Kotlin so it brings the usual â€œwhatâ€ and â€œhowâ€ instructions but also the â€œwhyâ€ behind decisions that make Kotlin an easy and sensible choice for development. For both Udemy and the book, sign up for the site email list and I guarantee that if you wait a few youâ€™ll get courses for $10-$15 and the book for half price.
Me too. One (stupid?) question: how does MDC work with coroutines?
That's - sad. :(
I guess the signature will be `initLoader(id: Int!, args: Bundle, callback: LoaderCallbacks&lt;&gt;!)` in Kotlin The `convert to Kotlin` function is not perfect and sometimes it adds some `!` where they are not needed
I know but thatâ€™s not the case since initLoader is a built-in function from Android sdk.
Pretty sure they're both (the only) official languages. And aside from the Kotlin website, Android Studio has plenty of examples and will even let you paste java code into a Kotlin file and translate it for you on the fly, or so I've heard. 
If you know Java I think you will be ok for a long time. Java is not going anywhere soon.
You can still code in Java as they both are supported officially. I suggest you do the Koans: https://kotlinlang.org/docs/tutorials/koans.html Depending on how you know Java, it can take from a day to a week. Converting an existing code piecewise into Kotlin (especially with `data` class, inline functions, and lambdas) can also help as they both work side by side with Java.
have you tried `Bundle.EMPTY`?
Yeah that's exactly what I ended up using.
If you want to develop android app you should go with Android Studio. About getting start with kotlin you may look at here: [https://developer.android.com/kotlin/get-started.html] 
Thank you for the response, I originally had IntelliJ but when looking online Android Studio seems to be universally used more, and looks simpler to use. Just wanted to make sure I wasn't making a mistake changing over. I will look at that link now.
Please show a full stacktrace of the exception you're getting and the code of the call. Kotlin never inserts null checks resulting in a `KotlinNullPointerException` into calls of Java methods, so the problem is not where you think it is.
I opted to use ViewModel instead of Loader so I no longer have this problem. But since you replied I went I checked it out again. It turns out you're right and I was wrong. The stacktrace didn't help much but I figured out that the problem lied in my Callbacks. I had `override fun onCreateLoader(id: Int, args: Bundle)` but it should be `override fun onCreateLoader(id: Int, args: Bundle?)`. [Here's](https://gist.github.com/ezamelczyk/5d4f9f6ba533639b2443a3a44ec07202) the stacktrace if you're still interested in that
Pretty nice with examples and Koans https://try.kotlinlang.org 
Great! But when I moved my source files to the directory structure suggested by them, Android Studio still displays the warning "Package directive doesn't match file location". Everything compiles and runs fine though.
He could also add some tangentially-related gifs inline every 5 sentences.
Function arguments like `a: Int` are values. Values cannot be reassigned. You can, however, shadow the variable of assign the value to another variable, so you can reassign the value.
How would I do that? I'm coming from a Python background so this statically typed thing is new to me. 
This has nothing to do with types or those types being static. Simply put: A value, like the name suggests, never changes. In your case, you change your number stored in `a`. In order to do that, you can shadow this reference (which isn't the best, but works fine) by using var a = a This will create a *variable* (something that can change) an allows you to leave the rest of the code as is. Although, you should replace that `while` loop with more expressive loop like `for` or `repeat`. Your code is basically: (a..10).forEach { println(it) } or for (i in a..10) { println(i) } 
 fun secondFunc(a: Int) { var a = a while(a &lt;= 10) { a++ println(a) } } Altough that is a bit hacky I would suggest to give them different names like: fun secondFunc(a: Int) { var i = a while(i &lt;= 10) { i++ println(i) } } Edit: you can also do more idiomic loops in kotlin like this: fun secondFunc(a: Int) { for(i in a..10) { println(i) } }
That cannot be true. The Kotlin compiler will allow you to pass null to any platform type and will not insert a null check for it.
Yes I know. That was actually my fault as I explained [here](https://www.reddit.com/r/Kotlin/comments/7nviuf/android_loadermanagerinitloader_has_a_bad/ds6a9yz/)
`val`s are basically read-only, you cannot reassign them. If you need to mutate the variable, use `var`s. [Python does not have `final`/`const` keyword](https://stackoverflow.com/questions/802578/final-keyword-equivalent-for-variables-in-python), so I get why it can be confusing. Using `val`s is preferred and tends to make it easier to make your objects immutable.
[These](https://hackr.io/tutorials/learn-kotlin) curated Kotlin resources may help.
I put my companion objects at the top... this is heresy
Start learning how to use spring boot a few months back, decided to use Kotlin as much as possible, and make a REST API with it for a friend of mine. Overall I like Kotlin a lot, but don't like spring boot in general. I would not do Kotlin + spring boot again, but I would still be interested to try out other frameworks
At my job, I write a lot of POCs and prototypes of back end services. All of this is in Kotlin when I can. Most of that is in Spring Boot because they play so well together (and we have a pretty good mental investment in SB already). I have a couple of things in production (at a past job I had this year) and I suspect 2018 will bring a few more at this job. Ironically, I haven't done anything on Android in years, but Kotlin has made me want to take another look. In terms of comparisons to scala or clojure, I feel at least at the shops I've worked at, Kotlin is an easier sell. The learning curve isn't as steep, it's easy to read (my most important factor), and is very well documented (not that others aren't). Getting team members to consider Kotlin for a new service is much easier than it was when I tried (and failed) with scala a few years ago.
Text classification - assigning products bought by hospitals (extracted from invoices) to categories based on their purpose and type. Deeplearning4J + CoreNLP + Apache Spark with a REST API implemented with Spring Boot. Had no issues with Kotlin itself, and using it for data pre-processing was a pleasure - it has pretty much every useful `String` utility method you can think of. Still, today I would probably use Python simply because of the ecosystem, even though I don't really enjoy it as a language. JVM does have some nice libraries for machine learning, but they usually lack the community and commercial backing. I hope this will change some day.
I don't think the author of the article should write guides on Kotlin just yet. 1. You don't have to mark your classes with `open` anymore. Use `kotlin-spring` Gradle plugin and the compiler will do that automatically. 2. Mark entities as `data class`es and you get all the useful utilities for free, including the ability to copy (with optional field changing in the process as well!). The copy constructor is just unnecessary boilerplate. You should also keep all the fields in the constructor and keep them in separate lines. ID should be nullable and default to `null`, marking a new unsaved entity. 3. Never do that: `@Autowired lateinit var`. Even in Java you should always prefer constructor injections, Kotlin makes it even nicer. @Service class SomeService(private val someDependency: DependencyType) 4. Using optionals in Kotlin is just silly. Mark the `findBy...` methods as returning nullable types (e.g. `User?`) and use regular Kotlin null handling to process them. `CustomUserDetailsService` is plain ugly, as if you copied a Java class, run the automatic conversion and never bother to refactor it. 5. Not sure if the `PasswordEncoderAndMatcherConfig` is OK and why you wrap the original `PasswordEncoder` with your anonymous object, since it has no extra logic. Can't you just use the `BCryptPasswordEncoder`? 6. `produces = arrayOf(MediaType.APPLICATION_JSON_VALUE)` - not only is this not needed since you have a `@RestController` annotation, but also recent Kotlin allows you to use `[ ]` syntax for arrays in annotations.
After first deploying it in July 2016, pure Kotlin services are now serving the vast majority of the website traffic for one of my clients (top 850 ranking globally according to Alexa.com). Load is in the region of 10-20mhpd, and each supporting service has 4-6 nodes. We've had precisely zero production problems due to the language switch, other than the odd NPE which was lurking below the surface which were bugs anyway. After a bit of a shaky start with IDE support, it's now pretty solid - JetBrains have done a very good job IMHO, and I think that the vast majority of Devs wouldn't want to go back - Java is just too painful to write after using Kotlin. Java interop is seamless - although when you take full advantage of the Kotlin feature-set, then calling Kotlin from Java can look a little strange. Not that you'd really want to - you just end up converting to Kotlin and sidestepping the issue! Our Java-style was pretty functional already, so the leap to using nullables/let/apply etc has been quite satisfying - you tend to use a lot more expressions. Stack-wise, we're using all manual DI (no magic or annotations), servers are all http4k (which hands-up: I am a committer on) on Jetty, with Handlebars for templating and Jackson-auto marshalling for the JSON messaging. Tests are all JUnit+Hamkrest, with Okeydoke for approval testing, and we generally spark everything up in memory which makes for super-fast build times. Personally, having done a few years of Scala and Kotlin, I prefer Kotlin by a mile - it's very similar looking - in fact to port the majority of (sane/non implicit) Scala-code is pretty much a case of pasting it in, then changing "def" to "fun" and "case" to "data". Compilation is also much quicker, and 3rd party APIs and community aren't as mental. tl;dr; Very happy. Would use again. :)
Just out of curiosity what do you dislike about spring?
I made a couple microservices with it, powered by JavaSpark With the Kaitlin wrappers I loved it 
I've never used it for Android. Instead I use it with Spring for web app development, and it's great. Data classes work really well with Jackson for API representation, the simplified syntax makes some controllers easier to write, and basically nothing harder...
I learned Kotlin using just the IntelliJ IDE instead of Android Studio to write some small utilities. I found them much easier and cleaner to write than Java for sure. I need to do some file processing, lots of files in directories / subdirectories. I would have used Python for that but wanted to see if I liked Kotlin before I tried it for Android. When I found that it was pretty powerful and I figured out various aspects of the syntax I then decided to start my next Android project using strictly Kotlin. I am not on my 3rd Kotlin Android project and I still continue to write small utility programs in Kotlin.
I've been using it for all of my personal projects that otherwise would have been Java. I have really enjoyed it. The only problem I have with it from a design perspective is the way they implemented generics. My biggest open source project which is really a series of experiments that will eventually result in a usable application for encrypted file backup to cloud services, is on Github https://github.com/irotsoma/cloudbackenc-parent if anyone is interested. I've been working on it for about 2 year. It includes a few spring rest applications, which I intend to eventually convert to use a lighter weight framework and break up into microservices. But I wanted to learn more about Spring Boot and wait for other frameworks to mature. Also includes a client side application using tornadofx (javafx) for the GUI and spring boot for a callback rest service (which eventually again I'll convert to something lighter). It also includes a plugin architecture with two different types of plugins that share the same base repository code, one for encryption libraries and one for adding cloud services, which is what I used the generics for. Right now the plugins load at startup, but eventually I'll make them dynamic without restarting the application like OSGI to learn more about that area. It is of course a work in progress, but I've learned a lot about complex gradle scripts, submodules, encryption, classloaders, Kotlin, Spring, designing APIs, interacting with the file system, and several other topics. And it does have some limited working parts. I'm working on refactoring some stuff to get rid of some bad naming conventions, but after that I'm going to improve the documentation and test coverage to make it more useful for others to use bits and pieces if they want. I'm always open for questions or helping others with what I've learned.
I work with a small startup called mitter.io and about a year ago we switched to Kotlin exclusively for our backend code. We still have a lot of Java code lying around, but the integration has been extremely smooth and we use all our existing tools and infrastructure just as easily with Kotlin. Our decision to switch with Kotlin has been extremely well received and we are absolutely loving it!
I've been using Kotlin and ratpack to develop RESTful APIs for almost a year now and it's absolutely wonderful! Would recommend to a friend
If it didn't match there would be compilation error. Read my other answers in this thread. This issue was resolved.
I haven't used it for Android at all. Only for backend / networking stuff. No framework. In production. It's been great.
Yeah and especially spring boot. Just watch latest Josh Long lecture from kotlin conf. What you can do using kotlin with spring boot web flux and additional extension functions made for kotlin is amazing.
It's so bad that people write java code in kotlin.
what were the resources you used? I'm also interested in learning Spring(boot) but dunno where to start
In this post, I write my first impression &amp; usage of Kotlin in Android. It would be great if you also share your tips!
I've been using Kotlin for machine learning work for several years now - I've also [released](https://github.com/sanity/pairAdjacentViolators) a Kotlin library for a certain useful type of machine learning called "isotonic regression". 
I'd like to use it for machine learning but I don't think it's going to happen.
I think you replied to the wrong post. But anyway, do you have a link to that video?
I think you replied to the wrong post. But anyway, do you have a link to that video?
I think *maxBy* is what you're looking for. It takes a predicate so you can specify how you want to calculate the cost of a car from your list of cars. 
In OP's case it would be: cars.maxBy { it.cost }
You can also created a sorted list, e.g. val sortedList = myCarArray.sortedWith(compareBy({ it.cost }, { it.model })).asReversed() 
Do something like that in your RecyclerView class MyRecyclerViewAdapter(params , val itemClick: (Int) -&gt; Unit): RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() { internal inner class MyViewHolder(view: View) : RecyclerView.ViewHolder(view) { ... itemView.setOnClickListener( {itemClick(layoutPosition)} ) } } In your fragment val myAdapter = MyRecyclerViewAdapter(params) { position -&gt; // do something } There is a tuto here: https://antonioleiva.com/recyclerview-adapter-kotlin/
Thanks, when I do that my other functions (onCreateViewHolder) break though. I'm obviously doing something wrong!
Sorting is much slower despite that it works and sometimes seems more intuitive. I actually tried to solve this problem with sorting once years ago, and ended up investigating a better way: http://steve-adams.me/efficiently-summing-the-highest-values-in-an-array-with-js/ Iterating once and keeping the highest value is the fastest option available (O^n) since it only looks at each value once. I believe this is what maxBy does: retains the highest value for a given property after iterating through the entire list. Not saying you're wrong, just trying to give insight into why you might not want to sort. It's a lot of extra computation and syntax to reach the same result.
Agreed, if you only want the highest then maxBy does the job, but if they need more than that then sorting may be the solution. Performance will depend on the size of the array obviously. Was just throwing out another option so OP can see what's best for them.
Absolutely - there are definitely cases where you could benefit from sorting. There's rarely a 'right answer' when programming.
Why can't you do it the old fashioned way? var foundCar: Car = carList[0] for(c in carList) { if (c.cost &gt; foundCar.cost) { foundCar = c } } // foundCar is the car with the highest cost
Kotlin has two ways to declare variables: `var` and `val`. A `val` cannot be re-assigned. val x = 5 // ... ok x = 10 // ... error, cannot re-assign a val A `var` can be reassigned normally var x = 5 // ... ok x = 10 // ... ok Function parameters are treated like `val` and cannot be reassigned. So what you can do is: fun secondFunc(a:Int){ var a = a // create a local var with the same name while(a &lt;= 10){ a++ println(a) } } 
Wow, first of all, thanks for the downvote? I'll tell you the point of my comment: Don't always wait for something to exist in the standard library. Specially something trivial like this, you should be able to write yourself. There's nothing wrong with using loops and conditionals. You think an 'if' condition inside a 'for' loop is confusing or juggling too much data? And yes, obviously you should check if the list is empty and return null. The snippet was not meant to be complete, but was meant to show how to do this kind of basic logic without holding up and waiting for a "standard" solution. 
I prefer setting the ID equal to a nonsense ID by default, like -1. That way I don't have to reason with the id as if it is nullable when in my mind it really isn't.
It's what I was doing but was almost certain there was a much shorter and easier way that I couldn't figure out. I've never used lambdas before so I'm not very familiar with how to use them but boy do they make things much easier. Also I gave you an upvote because whether an answer is the best answer or not, as long as it promotes debate, it is valuable. :)
In **Kotlin** its better off to make good use of the [when] expression to control conditions. It's more readable as well. fun main(args: Array&lt;String&gt;) { secondFunc() // which will call the function } for instance: fun secondFunc() { val data = 1..10 val outOfRange = false while (!outOfRange) { println("Printing the list 1 to 10") for (nums in data) println(nums) break } println("Not in the list or less than 1") } This should give you a pretty cool understanding of how Kotlin works. Cheers! :)
Kotlin is great but if your just learning Java may be a bit simpler with more documentation available.
Agree. Java is easier
Interesting. The author echoes my own opinion of ktor by saying that "the documentation is quite lacking". I would even go as far as to say it's generally true of the Kotlin world. Jetbrains' documentation for kotlin look like it is an afterthought (or trie hard not to prevent book sales) and it trickles in the various libraries who seem to follow suits. 
As an open-source library author myself, documentation is bloody difficult and painful. All your time gets devoted to writing the code itself, tests, deployments, releases and so on. Unless contributors are helping you with that, there is no way to keep it update it 
Kotlin is being developed by a company, not an open-source dev working on weekends.
I did not have difficulties learning Kotlin, because I think that it is rather simple and the documentation is OK, but I usually prefer Java libs for my projects for the reason above. One counterexample might be [TornadoFX](https://tornadofx.io/) library. I'm fine with using Java tools from the Kotlin language though. It greatly simplifies my work.
It's not hard, it's work. How you prioritize that work against your backlog is up to you though. If you're just putting something out there and don't care if people use it or not then no documentation is fine. Not everyone has the time or wants to be running a community. I have a lot of code out there on a *it's here and that's it* basis. If you're hoping to build a community then no/bad docs is a huge hindrance because it increases the barrier to entry in the community thus increasing the likelihood that only highly technical people who don't need doc, and thus won't write doc, will join. In the python community when the [Flask framework](http://flask.pocoo.org/docs/) came out it didn't win heart and minds because of it's technical merits (it's was originally mediocre at best). It did it for a very large part because the day 1 documentation was already fantastic. You can compare it to [Ktor's](http://ktor.io/servers/lifecycle.html) where a [large](http://ktor.io/clients/index.html) amount of [pages](http://ktor.io/advanced/pipeline.html) have been leading to empty placeholders for months.
I guess I've been spoilt by python for too long. :)
Yes, it is encouraged. There is an inspection in IntelliJ IDEA that tells you to do that, and can perform the replacement automatically.
**Heisenbug** In computer programming jargon, a heisenbug is a software bug that seems to disappear or alter its behavior when one attempts to study it. The term is a pun on the name of Werner Heisenberg, the physicist who first asserted the observer effect of quantum mechanics, which states that the act of observing a system inevitably alters its state. In electronics the traditional term is probe effect, where attaching a test probe to a device changes its behavior. Similar terms, such as bohrbug, mandelbug, hindenbug, and schrÃ¶dinbug (see the section on related terms) have been occasionally proposed for other kinds of unusual software bugs, sometimes in jest; however, unlike the term heisenbug, they are not widely known or used. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Kotlin/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Sure, but the goal is obviously not for just a single object to be immutable but for the entire tree to be. In these kinds of situations those trees tend to not be very deep. 
Use Kotlin. It's no problem to use Java documentation for Kotlin programming. You will get used to the syntax differences very quickly. Most of the time you will be learning libraries and frameworks and you will be happy, when your Kotlin code looks much nicer than the Java code from the documentation. Kotlin has some additional idioms like e.g.`apply` and you can learn and use them later on. Also: Do the Kotlin Koans first! https://kotlinlang.org/docs/tutorials/koans.html
Yeah, I tried ktor out for a while, and ultimately went with Javalin due to the documentation frustrations. It's been much more pleasant. Javalin does not offer coroutines out of the box, if that matters to you. edit: To elaborate, one of the reasons the Javalin's documentation is so successful is that it has soup-to-nuts examples of very common web development patterns, fully available on github: https://javalin.io/tutorials/
I just rolled out a server written in KTOR to staging. KTOR's documentation is abysmal, but I found the framework to be very intuitive. I really like it.
This has been my experience. KTORs design is fantastic.
If the code above was so trivial and obvious it wouldn't have had so many moving parts, inefficiencies, and latent bugs. If you use the [library implementation of maxBy](https://github.com/JetBrains/kotlin/blob/1.2.0/libraries/stdlib/src/generated/_Arrays.kt#L9991), you can avoid all of these issues, and get back to the business logic you actually need.
I think if you are a beginner you would find Spring to be pretty confusing. I know I did when I first looked at it. You should check out Drop Wizard or Javalin for easy to use web frameworks. You might find later that you like frameworks like Spring, since it does a lot for you. Personally I don't, but I see the appeal.
Interested. I did not know about http4k. I just rolled out a server in KTOR. I was very pleased with it. I would probably have used http4k if I had known about it. I have a few questions would you mind answering them? 1. Why Jackson over other JSON libraries such as GSON or Moshi? Also why Jackson over something like org.json? I often roll our org.json because I enjoy its simplicity, but I've been meaning to give GSON a fair chance. 2. Working off 1. Is it easy to do specific JSON replies with Jackson? For example someone requests information about user 1, if the user is user 1 themselves I return more information about the user than if they were user 2. 3. What about parsing arbitrary JSON? 4. What system do you use for restful authentication? Do you use any libraries to help with that? Thanks :) -ps please don't feel any pressure to answer my question if you don't want to.
Thanks for the eagle eye! I fixed it!
While I agree with everything in your list - in this particular example maxBy is implemented pretty much exactly in "the old fasioned way" above. So it still relies on state though encapsuled in a function thus more protected. 2 still holds though it is very unlikely to find a bug in a standard library function of this kind. I'm a bit disappointed that the "functional functions" arent implemented in a functional manner though. But perhaps a recursive implementation would be slower in kotlin. 
vJoy is a program that creates virtual joysticks with up to 9 axes (x, y, z, rx, ry, rz, sl0, sl1, whl), some stupid amount of buttons, and up to 4 pov switches either discrete (only n/e/s/w/center) or continuous (360 degrees). A vJoy feeder is something that feeds inputs into a vJoy virtual device. I made this for a personal project, but also to experiment with JNA in Kotlin. It's like 90% feature complete, I didn't implement `UpdateVJD(rID)` because I think the more robust method of state updates is better and I didn't implement any of the force feedback API because I won't need it.