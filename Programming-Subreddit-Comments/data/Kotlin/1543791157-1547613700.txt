I’m doing server-side Kotlin development for video games produced by one of the most recognizable entertainment companies in the world.
My team has built ~6 rest apis in Kotlin. It's not officially approved for use by the larger organization yet, but we're working on it. Almost all of the developers that touch it want it. The mucky mucks are pushing back of course. Every day I'm seeing more non-Android Kotlin jobs out there. 
We were using Kotlin to write our microservices, and we even started to convert out existing Java microservices into Kotlin. Ever since I started writing our microservices using Kotlin I just hated to even read Java code. 
I'm using Kotlin on the JVM and in the browser. Never coded on Android with Kotlin. I use it for server side development, Big Data and game development as well! You can take a look at some of the stuff I write [here](https://github.com/Hexworks).
Mind saying what company you're working at?
I would say that Java code is a bit lengthier than Kotlin code, but it isn't all that _uglier_ imo. I though happened to read Kotlin code and then C++ code shortly after and that was such a huge drop in "prettiness"! :)
Thanks! :)
I'm using Kotlin for astrodynamics research. Leveraging Apache Commons Math with fewer lines that Java. It has been great moving from Matlab/Python due to the static typing and the speed! I would kill for a good 3D plotting libary similar to matplotlib though!
First Slick2D, then migrated to the LibGDX/The correct question is “Why Java?”, in which the answer is Write Once ~~Run~~Test Everywhere.
At my work we are using Kotlin as an API backen server and will be interfacing with a number of hardware devices (printers, scanners, cash recycler, signature pad).
Kotlin is a lot like Python, where it counts. String parsing is just as easy.
Dont know anything about that. Just using kotlin like you would use java to do various file handling tasks and call the system binaries.
Are you using intellij? The IDE makes it a piece of cake
I love Kotlin for Android but it's definitely not limited to that. It's great for serverless functions. Ktor, a new all Kotlin server framework made by JetBrains, the creators of Kotlin, is my new go to backend. 
Clojure would like a word with you. :)
I work at DoorDash and we have several performance-critical backend services written in Kotlin (rest are in Python)
The company I work for is using Kotlin all over it's code base (for reference: \~400k monthly active users, 10+ years old, 2 figure millions revenue per year). We have 1 or 2 pure-Kotline microservices (I think Spring based) but in most other services have some percentage of Kotlin in them. &amp;#x200B; We use Gradle for most of our building so it's super easy to just put a bit of Kotlin in it. We have Java and Kotlin code in the same directory structure (both in \`src/main/java\`) so it's easier to work with. My take on it is: When I need to add new functionality to a class or need to do some refactoring and it looks like I need to touch a lot of lines \_anyway\_ I usually press "Convert to Kotlin" first, do some cleanup and then do my stuff. The result is often less code and easier to understand. Since we have good unit and integration test coverage the risk of doing this is next to none. In fact, I don't think we had any production issue ever due to Kotlin. &amp;#x200B; tl/dr: For new code and refactoring "Convert to Kotlin" first.
It's usually okayish. In my experience the most work is needed for code that has a lot of nullability checks, \`Option\`s or Java streams in it. The rest is pretty much good to go.
There's already an example of Kotlin with React available on Jetbrains' github
Use it for a web backend. Also have been using it for a number of projects at university
Checking in. We're using it as a straight replacement for Java to build APIs and Office automation software. 
I wrote the backend server for a mobile game in Kotlin. That worked brilliantly, but then we tried to reuse the code to build the admin UI Javascript in Kotlin and while it worked it wasn't particularly elegant, we're using Typescript these days. I'm also dreaming of building a common backend logic for an Android &amp; iOS app in Kotlin (with native view technologies for each platform), talking to a Kotlin backend, but the right project hasn't come along yet :)
Why would you not want to use gradle / maven if you're making anything bigger than a 1-5 files project?
What, I never said I’m against of that. Actually I’m teaching myself that damn thing right now, and Android is making me confused.
Lol no. It's not newer languages. It's all languages. Checked exceptions are Java's failed experiment and it is a very good thing that Kotlin and other JVM languages didn't try to recreate them. There are typically two kinds of checked exceptions in practice: 1. Completely useless checked exceptions that aren't handled any differently from unchecked exceptions but constantly get in the way, pollute interfaces and demand reams of boilerplate wrapping and converting logic for absolutely no benefit. Most cases of "throws IOException" are this. 2. Semantic checked exceptions that function as variant return types. An example is an atomic openFile method throwing FileNotFound. These exceptions do not represent truly exceptional circumstances but are instead the "exceptions for flow control" anti-pattern where catch blocks are used to switch on method results. Specific exceptions like FileNotFound are usually downcast from a checked superclass creating substitutability violations. Checked exceptions add little to no value in either of these situations and methods that fail in ways that aren't inherently exceptional should model this in their return type rather than expecting callers to catch specific exceptions.
Happy to hear, you are going to learn Kotlin for Android Development, Nowadays! Kotlin is a most popular language &amp; Android developers are very excited to learn Kotlin, So [Why Kotlin is better than Java?](https://www.metizsoft.com/blog/should-you-make-a-switch-from-java-to-kotlin/) You can see in our article &amp; also [Why Android Developers should be Interest to Learn Kotlin Programming Langauge?](https://www.metizsoft.com/blog/learning-kotlin-programming-language/) &amp;#x200B; 
I use the auto-converter in IntelliJ but it's not perfect so I usually need to make a few changes manually to get it to compile. Once compiling, I make a bunch of changes to make the code more idiomatic and replace chunks of code with calls to utilities from the Kotlin standard library (eg. list.find, list.any, list.map, apply, with, etc.). The process takes some time but the code ends up being much more readable and obvious (which will also improve productivity when I need to work with that file again in the future).
This is a fantastic article
My only complaint about these sorts of articles is that they're not about Kotlin stdlib coroutines, they're about the kotlinx.coroutines library. 
(are (you (sure [(about (that)&gt;?)])))??!?! /s
I did have to check to make sure your braces were correctly nested.
Sorry for the formatting, Reddit does not seem to want to keep the formatting or let me put it in a code block.
I'm working on a desktop application with Kotlin+TornadoFX. Personal project, and while I'm doing this part first, I intend to make an Android app with the same functionality once this part works.
There are no Kotlin stdlib coroutines AFAIK. You get coroutines through kotlinx.coroutines. Did I miss something?
No.
Yes. There are stdlib coroutines, and kotlinx.coroutines is built on them. [Here are the docs](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/index.html) for the package in the stdlib. Notably, things like [`sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/sequence.html) (formerly `buildSequence`) and [`iterator`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/iterator.html) (formerly `buildIterator`) are constructed using stdlib coroutines and don't depend on kotlinx.coroutines. 
Great! That's the effect I was hoping the doc would have :-) Have fun!
Good to know. I was not aware of them.
Think of kotlin.coroutines as the low-level constructs that make coroutines work under the hood. They aren’t the layer of abstraction one generally finds themselves working with directly; they’re more just the underlying machinery for creating the higher-level abstractions in kotlinx.coroutines. The reason more things aren’t in kotlin.coroutines is because JetBrains doesn’t want the Kotlin standard library to be bloated with a whole bunch of things that your application might not even be using. Even kotlinx.coroutines itself is divided into multiple dependencies like kotlinx.coroutines.rx2 which deals exclusively with adapting coroutines to RxJava 2.0.
It sort of depends on your needs. If you need a task library, actor library, or other thing that's covered by kotlinx.coroutines, then you're set. But there are plenty of uses for coroutines beyond those. Coroutines can be used for *any* suspendable computation, and not all suspendable computations fit nicely into the kotlinx.coroutine model.
Nice. There's a lot of _"here's how to use that Java lib in your Kotlin project"_, but not many that go the other way.
Thanks!
Previously wrote a lot of java and python for misc things related to things I do with my computer, things I whip up as concepts, projects I work on with friends, and projects\code I write to present in College class. I also Intern for a High School Level 2 Programming class, so I tend to rewrite them in java as a comparison. Finally convinced teacher to let the kids choose from java and kotlin on a project by project basis rather than do the whole class in java throughout the semester. They are fully interoperable so he can still run his java program to check that the code actually works, and the written code can look extremely similar looks-wise if you are new to kotlin coming from a java background. Other than that, all of the android stuff I have ever done is sending a toast with "Hello World" on it. Not my cuppa tea! Interesting note: After the switch, the results have actually been pretty interesting! Some of the Java kids say its not fair that the Kotlin kids have to write less lines of code, but to be fair I did go over what Kotlin is compared to Java, what its improvements are, and how it could affect their future with Kotlin being an official language for Android. One of the main points was null safety (which was a small portion of the code not written by kotlin writers who used non-nullable type like `Int` rather than `Int?`, which I did leave a nice note and +1 point on their score to the java writers checking for null, however only a few out of the tens of java writers did check for nulls), and the other big one was reducing boilerplate code (very large portion of the code not written by kotlin writers. nearly all of the java writers did write getter-setter which is good because thats how you should write java code). From day 1 to now, id say about 1/3 of the people who used solely Java for projects are now doing more and more in kotlin and stepping away from java.
I’m confused. Everything in kotlinx.coroutines uses the primitives in kotlin.coroutines. That’s what they’re built on top of.
Scope is kind of redundant if live data is used? It's better to start a coroutine outside of activities and fragments and use live data to pass results back to them.
The best solution is what you already had, using the `running`. This pattern is very common and is considered best practice. The running flag must be `@Volatile` for the pattern to work.
Thanks! How long does it take for a newcomer to start writing idiomatic Kotlin?
Nice. Can you jump to declaration (Cmd+B) and view the resolved value (^+J) from your dependency in `app/build.gradle` now? Those used to only work if your Libs class was Java.
Excuse my ignorance but why is busy waiting considered practice? Isn't there something like notify and wait?
Ah, I thought you were doing some work in that loop. So you're actually just waiting for something to finish and then performing cleanup. You don't need channels for that, you can use a `CompletableDeferred&lt;Unit&gt;` and `await` on it.
I'm using Kotlin for quite complex Dropwizard+Akka backend service. Started it 5yr ago in Groovy (as our web part was on Grails) but after maybe 1yr or less switched to Java - was too tired of Groovy's mostly absence of type safety. Several months later discovered Kotlin, slowly migrated from Groovy+Java to pure Kotlin during next year. So through that year this project was really a multi-language - Groovy+Kotlin+Java (+ Akka &amp; Scala 2.10 as dependency). So now all backend development is in Kotlin and I'm totally happy with it and never look back. Type safety, null safety, concise syntax, extension functions, companion objects, data classes, sealed classes, etc. I'm probably not using only a small part of Kotlin language features as most of them are really helpful in day-to-day development. And will definitely try coroutines and Ktor as web framework on next project.
Yes you can, Cmd+B and Cmd click. It jumps from your build.gradle dependency line through to the Kotlin Libs.kt source where the dependency is defined. I have been using this solution for over 6 months and it was working when I first started using it. Not sure at what point before that it was working.
Thanks, this is what I'm looking for!
Sure. Stdlib coroutines are primitive yet flexible. Kotlinx.coroutines is less primitive but also less flexible. For example, I was toying around with building a library to simplify trampolined tail-calls, for which coroutines are a great fit. But kotlinx.coroutines are overkill; I don't need to deal with a Dispatcher (everything happens on the thread that kicks off the calculation) or even a ContinuationScope (I don't need to abort families of jobs). Stdlib coroutines are a much better fit. 
If you want to stick to threads, you can use a [`CountDownLatch`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html) with an initial count of 1. All threads can `await` that latch, then one thread can `countDown` that latch to release all the others. Anybody who arrives at the latch after it has already been decremented to 0 will proceed immediately.
This looks great aswell. Are there any significant differences? I don't really need the result of `CompletableDeferred`, so that doesn't matter.
It's more a question of whether you want to use coroutines or threads. If you'd be using coroutines for other purposes anyway, then `CompletableDeferred` is better. But all else being the same, I've found debugging threads to generally work better than debugging long `suspend fun`s (at least in IntelliJ), so on my project I've stuck with threads. 
I convinced my company, or better said my team, to use Kotlin. We're doing pure backend development... web apps, tooling, modules in a module system based enterprise application etc. Works perfectly :) We're going to use it everywhere one can use Java. We haven't tested or decided whether using it for JavaScript targets is a good idea, but we're going to concider it.
Are you able to update the dependencies to the latest version through "alt + enter" in Intellij? 
I was able to fix the formatting.
There is nothing special about objects in terms of placement. Where would you place EventLog if it was a regular class? Put the object into the same place. If it's only used by model classes, put it in the model package. If it's used everywhere, create a 'util' package. (I generally dislike calling something "util", and always try to come up with more meaningful names, but sometimes it's OK to just go with "util".)
Graphics, [https://github.com/kotlin-graphics/](https://github.com/kotlin-graphics/) And now I'm playing also with native, [https://github.com/elect86/glfw](https://github.com/elect86/glfw) 
Gradle/Maven is like a dependency manager and package downloader for me. (I know it's supposed to be more than that.) If you need any third party library, Maven/Gradle is the easiest way to obtain that.
I doubt it, due to the dependency definition being a String property.
Look at Gluon Mobile [https://gluonhq.com/products/mobile/](https://gluonhq.com/products/mobile/)
I see. So how does one go about checking and updating their dependencies? 
Either looking it up yourself or there are Gradle plugins for finding outdated ones and giving you latest versions to update to. Personally, I've never really had any issue, will definitely look into it more now that you mention it.
Kotlin by far
It's worth a try, but depending on how you wrote your app you'll have to refactor a lot from "Kotlin using Android/Java APIs" to common Kotlin code. In other words, it would probably have been a lot easier if you started out with this in mind. If you're asking if it's worth learning this to apply it in future apps, then yes I think so.
In my experience so far, Kotlin Native isn’t quite ready for prime time for this use case. If you need to knock something out quick, try Google’s Flutter.io (it went 1.0 today).
One issue you will face is that every java based library you use will have to be replaced with a custom implementation. Kotlin native is very sparse and new just now. But the potential is brilliant.
This is what I was thinking, that it's not quite ready. I feel like I'm in a predicament. I haven't released yet, but want to do so with an iOS version from day 1. If kotlin native isn't quite there, I could go and create a new swift version, but that requires me learning a new language, as well as a long time building it (I'm building this app on my own, and my android one so far has taken me months) Then i risk bugs as I'm writing the same code twice, I'm much more prone to errors. The thing I liked the sound of in Kotlin native is that if I'm using the same methods etc, I'm less likely to produce logic bugs, as I can share it 
Yeah I saw flutter. Looks nice but I've spent months on my android app, don't want to just scrap it! 
No no... just do the iOS one in Flutter. It’s been the easiest and cleanest way I’ve found to bounce across Android and iOS, but it’s not platform reactive - so when you use “Cupertino” theme for iOS your app is pretty much only iOS.
I'm not exactly sure for a fresh out of the box programmer, as everyone in the Level 2 class has already taken the Level 1 and learned Java for 9 months last year, but it took the Java users who switched to Kotlin around 2 weeks to start writing idiomatic kotlin. I would suspect if you have more experience with programming, it would be even less time to ramp up to standard. I asked some other jobs I was hoping to intern at (where applicable), and they said it takes most people 2 to 4 days to go from Java to Kotlin as they are very similar languages. Pretty great compared to nearly a month for Java -&gt; Scala, though they are very different languages used for very different things.
Depends on how big it is. You can extract a bunch of business logic into the common module but you can't use any Java APIs. If it's huge, it's not a small amount of work to do so
So kotlin native just hit beta a few weeks back. If it's a for fun app it could be fun trying it out. If it's a serious thing I wouldn't depend on it.
Yeah, I'm hoping to make money out of this app when I release it! Hmm... If its in beta now then it might be in a stable place to start trying it. As I'm sure I'll be spending ages working on it, it'll get more stable and solid as I go along. 
that's fair. From my initial look it's meant to be better as a shared library between code bases, and then work in native code for UI implementation. But that was nothing more than reading a blog or two.
I haven't really used swift. But it seems like transitioning from Kotlin to Swift, would be the smallest hurdle here. The languages look pretty similar syntactically imo. Kotlin does look better though. I don't know how involved your app is, but it may be worth just trying to build it in swift, if you have a mac with Xcode.
Ive been using gradle versions plugin for all of my projects lately. https://github.com/ben-manes/gradle-versions-plugin
&gt; Through Java has been reigning the world for programming language since long, as Google announced the advent of Kotlin JetBrains is the company that created Kotlin. Are you referring to Google announcing first-class support for Kotlin on Android? &gt; Being robust with statistical typing, Kotlin is great and is less verbose as compared to Java. I'd guess you meant static typing instead of statistical. Java is also statically typed, so I'm not sure how that's relevant to this point. &gt; [Java is] An open source language The Oracle JVM, which is the one touted as running on 3 billion devices worldwide, is not open-source. Android's JVM [apparently is](https://source.android.com/setup/build/downloading). There's also [OpenJDK](https://openjdk.java.net/), which is open-source. However, calling Java an open-source language is a stretch. Kotlin seems more qualified for that title considering the [compiler](https://github.com/JetBrains/kotlin/tree/master/compiler), [standard library](https://github.com/JetBrains/kotlin/tree/master/core), and various other components ([koans](https://github.com/Kotlin/kotlin-koans), [kotlinx.coroutines](https://github.com/Kotlin/kotlinx.coroutines), [kotlinx.dom](https://github.com/Kotlin/kotlinx.dom)) can be found on GitHub under MIT or various Apache licenses. The rest of that bullet point seems to be about the fact you can write open-source code in Java; however, you can write open-source code in pretty much anything else, including Kotlin. &gt; Github projects can be accessed easily owing to the Anko Library in Kotlin. Anko is an open-source project hosted on GitHub, but I don't understand how it enables accessing other "GitHub projects." &gt; Though Java development has been surpassed in multiple cases by kotlin when it comes to speed, Java takes the stride. What benchmarks do you have to back this up? &gt; Since the language is just in it’s growing phase, you might find hard to look for solutions. Limited resources refrain from getting exposure to a variety of projects. One of Kotlin's many important features is complete interoperability with Java. If you find a solution in Java but not in Kotlin, and for some reason can't translate it to Kotlin yourself, you can call that Java solution from Kotlin code anyway. &gt; Java, as we all know, is a procedural language. So if you need to choose between Kotlin vs Java, than former takes the lead. If you classify Java as procedural, Kotlin is too. Explaining in what sense Java is procedural but Kotlin isn't, and how that is beneficial, would be a welcome addition.
I’m using in few of my projects plugin https://github.com/jmfayard/gradle-kotlin-dsl-libs, and it’s the best of both worlds: autocomplete/static resolution via buildSrc and version updates via ben-manes-versions baked into.
This is something you decided BEFORE you make the app. Your choices are react native or google flutter.
What's wrong with this: [https://github.com/pgutkowski/KGraphQL](https://github.com/pgutkowski/KGraphQL)
I'm sure I can refactor if I really want 
&gt; It's worth a try, but depending on how you wrote your app you'll have to refactor a lot from "Kotlin using Android/Java APIs" to common Kotlin code. ...oh crap. I thought you could use the same crap? Even dagger and other shit?
Yes, that is a plugin I was referring to you. Thanks for linking.
Maybe you can use: [https://multi-os-engine.org/](https://multi-os-engine.org/). In theory this let's you run your android app business logic and just re-implement the GUI. Note: I never used it and it seems youngish.
You can only use stuff that's explicitly built for Kotlin Native. Dagger and other libraries are built for the JVM and rely on platform specific code that is not available for Kotlin Native.
No. You for sure don't have access to Java classes, but also not all Kotlin classes you're used to. You also can't just import dependencies, even if they are Kotlin only classes (since dependencies are packaged as JVM .class files which mean nothing to Native). Native even has some classes that JVM Kotlin does not. It also has some conceptual differences (e.g. different memory management). Kotlinconf is an old app that doesn't (everywhere) use the updated MPP patterns from Jetbrains. In this you have a common module, that's extended by platform modules (VM (which you can use on Android), Native (that has the possibility to also interface with Objc/Swift if you're on iOS), Kotlin for Javascript). Read about Kotlin MPP here: https://kotlinlang.org/docs/tutorials/native/mpp-ios-android.html If you browse the stdlib documentation it actually shows you which platforms (common, jvm, js, native) have which method. For example `jvm` and `js` don't have their own weak reference class (on jvm you can use the java class for this), native has its own class and common has nothing for (most likely since there is no such thing on js). Dagger is even more special, it used the `kapt` tool, which is only in the jvm toolchain (it requires compiled .class files to do it's work). This limitation might be lifted in the future, then theoretically a Dagger 100% written in Kotlin could work.
I personally tried Flutter and it's just..............eh. Dart is just inferior to Kotlin in my own observation. Sure I can see the appeal of coding layouts entirely on the main file, but I can do that with Kotlin on Android too. 
It's /r/Kotlin. Not /r/androiddev. Please see: https://www.reddit.com/r/androiddev/comments/a2nmyl/weekly_questions_thread_december_03_2018/.
Woops. Lemme delete this thread. Sorry!
&gt; but I can do that with Kotlin on Android too Anko is a far cry from Flutter.
Swift is not that bug of a leap from Kotlin, if you are not cross compiling I would try learning that first. Depending on what your app does extracting business logic to common lib might work as well but if it is mainly UI focused you will have better results in the long run using the separate platforms. 
I don't find it a great idea, unless you have no other options. &amp;#x200B; You said you didn't like to use objects as they'd be very hard to mock and setup for tests. Well, that's no entirely true. With \[Mockk\]([https://github.com/mockk/mockk](https://github.com/mockk/mockk)), one can setup objects mock with \`mockObject\`, and that would solve your issue. &amp;#x200B; Using a data class is weird to me, as what you actually want are static values, but are afraid of them due to testing purposes. You're changing your production code to be able to test it, and this is a big smell to me. &amp;#x200B; &amp;#x200B;
Sort of off topic, but why is it that so many GraphQL libraries regardless of programming language are built to generate a schema from your code? This does not seem to me like a sound way to create or maintain a stable API. I saw similar patterns back in the age of SOAP with WSDL. With e.g. Thrift or proto/grpc one typically defines the schema/interface first and then create code from that. This makes it easier to stay on top of API stability.
It’s all because of Kotlin/Native. It required all forces!
As someone looking at Kotlin's coroutines from the viewpoint of C#, golang, or even Java's upcoming Fiber implementation, why do things seem more complicated here? Things like Job(), SupervisorJob(), CoroutineScope(), withContext(), etc.
That's just when that particular article has been updated. The latest version of Kotlin was [released on 29 October](https://blog.jetbrains.com/kotlin/2018/10/kotlin-1-3/).
Oh, and you noticed that Kotlin to JavaScript documentation las updated Sept 2016. But transpiler itself is las updated today https://github.com/JetBrains/kotlin/tree/master/js
That's cool but we also need the documentation. Those tools are far a way from being trivial! 
I don't agree with other poster saying it's a bad idea, actually I think it's a good idea even if you wouldn't need it for testing. Using data classes (or even better hide it behind interface) for configuration gives you more elasticity in general compared with using static values - you can more easily prepare different configurations for different releases, this configuration may be coming from different sources etc (for example at some point you may decide to implement remote config/put it into text file etc), you may need different configs for running A/B tests, performance tests, run some debug mode etc. 
I am using MockK and it is nice, but from what I could tell, fancy things like final class and object mocking for instrumented tests only work for Android P+. As I don't have access to such a device, I'd be forced to use a slow emulator instead. Changing production code is not a problem as I am proposing a complete rebuild anyway
Volume is so low, at least on mobile.
Probably not but you're more likely to get hired if you know both.
I'm using Kotlin for all my side projects. My coworkers are still like "what is kotlin?" , so I'm jealous of all of you who use it at work.
It appears that my clients agree with this approach, as they also want to do A/B testing and other things. I changed it so that it's behind an interface, then they can do whatever they want with it so long as they return a config object that the app can use through the interface.
You could do the views with Flutter and use the Kotlin application logic for both platforms.
I'm not too sure why some of the comments here are that controversial. If I didn't overread something elementary, what you do is a best practice (exchanging global variables with a scoped config object that is dependency injected), so I think it is a good idea. As you already experienced, you get way better testability this way. So, thumbs up.
In this PR [https://github.com/JetBrains/kotlin-wrappers/pull/91](https://github.com/JetBrains/kotlin-wrappers/pull/91) I wrote build.gradle.kts which publishes wrappers to npm. You could try to use it.
&gt; I saw similar patterns back in the age of SOAP with WSDL. Yup. It was a mistake then and it is a mistake now. Working code first as opposed to contract-first you generally end up with schema's that don't work well cross-platform. I 'fondly' remember having to work with WSDLs generated from code that just plain crashed some clients due to their complexity (often stemming from a lot of repetition). A nice example I ran into several times were byte arrays serialised as lists of XML elements, one tag per byte. I don't consider it off-topic at all; it's really interesting to see bad patterns like these repeating themselves.
While I agree with you (the article is absolute trash) I want to comment on this point: &gt; The Oracle JVM, which is the one touted as running on 3 billion devices worldwide, is not open-source. Android's JVM apparently is. There's also OpenJDK, which is open-source. However, calling Java an open-source language is a stretch. Java is fully open source nowadays. OpenJDK is Java and vendors (like Oracle but also IBM and Amazon) can create their own JDK packages from OpenJDK if they want. OpenJDK = Java. 
Publishing to npm is not the issue per se, but when a potential user installs the package kotlin doesn't see the new code. This happens cause you need to add you lib to .idea/libraries and to your .iml file. Doing this I think could be better...
Having a separate configuration for integration tests that's used in the set-up is a perfectly normal pattern. It doesn't really matter much how you set it up (it depends on the frameworks you use). If you using Spring you can use an @ConfigurationProperties class you can fill with test data when running tests just fine.
It's just update date of this particular page Java Interop tutorial last time updated in 2014 https://kotlinlang.org/docs/tutorials/mixing-java-kotlin-intellij.html
I've been looking at the same stuff. I realized that there are two ways to reuse kotlin code: 1) pulling a jar dependency with kotlin code from a maven repository. This is what you do when you import the kotlin std library or other third party libraries. You might also publish your own kotlin code like this to a maven repository. This is useful when reusing portable kotlin-js projects. To build libraries like this, you need to use kotlin-js to compile the library code including the metadata needed by kotlin-js in any depending projects and package this up as a jar and publish it to a maven repository. In the same way you can also publish kotlin native libraries for use in kotlin native projects. If you look around on Github, there are quite a few kotlin projects that are targeting kotlin-js. 2) pulling an npm dependency. This makes more sense if you are consuming kotlin code in a javascript project. In that case kotlin-js spits out javascript code for your stuff + any kotlin dependencies. So, if you are looking to reuse kotlin-js code in other kotlin-js projects, option 1 might be the easier way. 
I have yet to try option 1, I'll give it a go
[create-react-kotlin-app](https://github.com/JetBrains/create-react-kotlin-app) has been regularly updated with the last update a month ago.
This is the way to go. I have used both approaches in real projects. 1) is the preferred way if you write a library for kotlin-js that is consumed in a kotlin-js project. You simply use the existing tooling for jvm. Everything just works. 2) is what you do when you want to consume from a js/ts project. This is how we include a kotin-js dependency in our angular frontend at work.
&gt;You need an extensive learning for the language. Syntax specific and so need deep learning. Is this the stupidest article ever? Was it written by an AI?
Design Patterns: Elements of Reusable Object-Oriented Software https://www.amazon.com/dp/0201633612/ref=cm_sw_r_cp_apa_i_8gMcCbJGKW2B3
I would start with SOLID. But only after you understand SOLID I can reccommend to start with design patterns. If you still are new to OOP don't start with design patterns, it will make you more confidencial the path, because you are not prepared yet 
Confuse instead of confidential. Fucking autocomplete in spanish
/r/learnprogramming 
Dude you can edit your comments. No need to make a new one :)
Start here, Java Design: Building Better Apps and Applets (2nd Edition) by Coad and Mayfield. It's old, but will get you firmly grounded in the concepts of inheritance and composition and when to use one or the other. This will get you the basics you've mentioned. Then you can confidently move on to learning other importing OO principles, such as SOLID.
Learn what a class is and what an object is. Then learn inheritance. Then you’ll get 75% of it
I use it for machine learning, and sometimes web development. I've also created some related open source libraries, an implementation of the [pair adjacent violators](https://github.com/sanity/pairAdjacentViolators) algorithm for isotonic regression (click link for an explanation), and a framework for building rich web apps in pure Kotlin called [Kweb](http://kweb.io/) (which is built on Ktor).
That's one of the big criticisms Ive had about graphql. It's a cool concept but it's going back to the monolith approach of SOAP, just with JSON instead of XML. I have yet to implemrnt a graphql API, so maybe I'll change my mind, but im not sure it's the best direction to go in.
Thanks for sharing!
I would add [Refactoring by Martin Fowler](https://martinfowler.com/books/refactoring.html) here. It is not as clearly about object orientation as Design Patterns is, but it is the book that made Design Patterns click for me, and really helps to improve your OO code. The second edition was just released.
Best resources are from Sandi Metz : https://www.sandimetz.com/products/ The best books I ever read on the subject
The reason you can't cast Int to Float is that you can only cast to a subclass. What you want to do is convert to a Float. Casting: ``` val x: Any = 1.0f x as Float ``` Conversion: ``` val y: Int = 1 y.toFloat() ```
For what it's worth, graphql-java has the ability to generate a schema from an IDL file. 
I recommend you search for Kotlin's issue tracker and if issue is not there yet, make one: https://youtrack.jetbrains.com/issues/KT Jetbrains is surprisingly active in their issue tracker.
No surprise they are active. Jet means fast :)
If we make the analogy with cooking, this book is a list of recipes that is only useful if we have previously learned to cook. So I really wouldn't recommend it for a beginner.
Folks are recommending some pretty good books, but I would start with Head First Design Patterns -- it's easier to read than the Gang of Four book and is written with Java examples rather than smalltalk. http://shop.oreilly.com/product/9780596007126.do Next, I would move on to Effective Java by Joshua Bloch, (a lot of Kotlin's design was heavily influenced by this book) https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997 
Kotlin doesn't have direct variants, but you can wrap them in a [sealed class](https://kotlinlang.org/docs/reference/sealed-classes.html): sealed class StackPermittedDataType data class BooleanWrapper(val value: Boolean) : StackPermittedDataType data class IntegerWrapper(val i: Int) : StackPermittedDataType when (value) { is BooleanWrapper -&gt; value.value is IntegerWrapper -&gt; value.i } If you need to return either, you have to return a `StackPermittedDataType`. If you need the actual type+value, you need the derived type (e.g., through `when`). Truthfully, the main differences here are no `Any` because you're not returning the value directly and the compiler's knowledge that these derived classes are the only two cases.
You grasp generics fine enough to realize that `Deque&lt;Any&gt;` is essentially equivalent to `Deque&lt;StackPermittedDataType&lt;Any&gt;&gt;`. You do have a sort of a dilemma here with the `StackPermittedDataType&lt;T&gt;`. You want to allow only a certain type of data in. In this case, `Int` and `Boolean`. You technically already achieve this in your code by only ever defining `IntegerWrapper` and `BooleanWrapper`, but generics are somewhat misused because you want to use them to work with any data type given, hence the name generic. I think a better way to deal with this problem would be using `sealed class`, you essentially know exactly what every child class of the `sealed class` is at compile time. `sealed class` is somewhat similar to `enum`, but (IMO) more powerful. I would probably do something like &amp;#x200B; sealed class StackPermittedDataType { class IntegerWrapper(val value: Int) : StackPermittedDataType() class BooleanWrapper(val value: Boolean): StackPermittedDataType() } &amp;#x200B; This allows you to just use `Deque&lt;StackPermittedDataType&gt;`, and you will only ever be able to put `IntegerWrapper` and `BooleanWrapper` in there. &amp;#x200B; As a side note: You don't need to ever define `getValue` boilerplate because anything instantiated as `val` cannot be changed (it is equal to a `final` variable in java). If you are planning to use this from java, the `getValue` java bind will already be created by the kotlin compiler. `setValue` will only be created if the value is instantiated as a `var`, so no need to worry about any of the boilerplate!
I just wish they would use the github issue tracker :-(
Nah, I think at their scale better issue tracker is needed with categories and statuses and shit.
Interfaces may declare properties! interface StackPermittedDataType&lt;out T&gt; { val value : T } Gives you the same Java signature, as with `getValue`, but a little bit better Koltin interface. But Sealed classes are created exactly for your task.
You should post this to r/androiddev
As others point out, normally you could use sealed classes. For simulating a VM, you could be somewhat worried about overhead. Sometimes the most obvious solutions are the best though (even though they don't involve generics), you could simply overload pushHead with two implementation, one for `Int` and one for `Boolean`. For the result of `popHead` you can use a when clause, which due to autocasting gives a quite nice syntax: when(val head = popHead()) { is Boolean -&gt; println(head.not()) // head is autocasted to Boolean so method only available on Boolean works is Int -&gt; println(head.inc()) // head is autocasted to Integer so method only available on Integer works In Kotlin I actually find myself just writing classes that return Any as a result instead of a generic type or a sealed class wrapper on occasion. On Java this syntax would be horrible, in Kotlin it actually expresses quite well what you are doing.
Thanks, that's another really nice feature I had no idea existed! 
I believe the JVM to be an actually great environment to build games in, the thing holding it back the most is the lack of value types, causing us to stress the garbage collection for no reason when doing lots of vector operations. That's the number one blocking factor for the JVM to me, above all else. There are vague plans to include value types in the JVM bytecode, but it's taking it's sweet time unfortunately. I'm actually working on a [voxel game engine](https://github.com/Hugobros3/chunkstories/tree/vulkan) in Java myself, and I'm currently converting it over to Kotlin, Kotlin has been great for me and has dramatically improved both the quantity and the readability of the code I'm able to put out. My engine is nowhere near as fancy as Godot is obviously, but it's not trivial either, I've been working on it for over three years and I'm looking forward to get more people onboard in the near future.
Hey I've been using O'Reilly. The sign up is a trial, but they didn't require your CC info. They treat the audience like complete coding beginners (which I am), so that's pretty good. All the best!
I use Kotlin heavily with Gradle. You’re going to need access to the internet anytime you install a new dependency, but you should be good to go after that. Hope this helps 
I have some experience with this. To start playing around, all you need in the IntelliJ installer. IntelliJ comes bundled with *a* version of the IntelliJ Kotlin plugin, and that includes *a* version of both the Kotlin compiler and the Kotlin stdlib. But that won't really cut it for real development. You'll want to use Kotlin with a build tool, and that means that you'll need to download additional things. IntelliJ would normally check the internet for an updated Kotlin plugin. You can download [standalone IntelliJ Kotlin plugin releases](https://plugins.jetbrains.com/plugin/6954-kotlin), which you can manually install into IntelliJ. If you're using IntelliJ 2018.3, then you want the one called `1.3.11-release-IJ2018.3-1` You'll want to download the Kotlin library dependencies as well. You'll want to grab them from either Maven Central or JCenter. You'll want at least `org.jetbrains.kotlin:kotlin-stdlib` or maybe `org.jetbrains.kotlin:kotlin-stdlib-jdk8`. You might also want `org.jetbrains.kotlinx:kotlinx-coroutines-core`. Of course, you'll want to grab not just these direct packages but also all of their dependencies, which can be a bit of a hassle. One way is to, on a computer with direct internet access, create a Maven project with all your direct dependencies, "build" that project, then grab the packages out of your .m2 directory (I don't remember the structure off the top of my head). We went a step further and built a custom tool that uses the [Maven Resolver](https://maven.apache.org/resolver/index.html) library to give us more control. Finally, you'll probably need to get the Kotlin plugin for your build tool of choice. I'm using Gradle. The Gradle plugins are served by a maven repo (https://plugins.gradle.org/m2), so I can use the same downloading tool as I used for libraries. If you're using the Gradle plugins DSL, you'll want `org.jetbrains.kotlin.jvm:org.jetbrains.kotlin.jvm.gradle.plugin`. I'm not sure what you need if you're not using the plugins DSL, and I'm not sure what you'd need if you're using Maven or Ant instead. Finally, you need to host all these dependencies somewhere. [You can point Gradle at a directory full of packages](https://docs.gradle.org/current/userguide/repository_types.html#sec:flat_dir_resolver). Presumably you could do the same with Maven. You could also opt to run a full Maven server to host these. You might want to keep the packages separate based on their origin - files from Maven Central are kept separate from plugins.gradle.org, for example. That's pretty much it. It's a pain in the ass, but it's doable.
Offline?! Like, no stack overflow?! Impossible! :P
Kotlin is great. For small projects and simple apps you are good to go only with kotlin. How ever, when you start doing more challenging things you will have to learn/know some Java (Since most of the libraries of the ecosystem are written in Java). 
People who develop offline usually have another laptop for online stuff.
Exactly this. Plus the native interop and struct memory layout, or my number one desire: use a block of memory, put my (heap) objects in there and multibuffer it for gpu sharing. A very common thing for heavy games. I developed an experimental framework for this and use it in my own engine: https://github.com/hannespernpeintner/kotlin-structs :)
Oh. Why would you develop offline then? Security?
Kotlin/Native could easily be integrated into any LLVM based game platform. Some quick googling shows Clang works on XBone, PS4 and the Switch (and AFAIK all of these have commodity ARM of x84 runtimes now). The C++ interop is not particularly great however. You kind of hit upon the fact that though that a lot of indie games, and some major studio games use high level game engines like Unity. Not sure what your milage there is. Unreal Engine might be a good bet since a bog standard Clang/LLVM environment is their default recommended way of developing. In the "traditional" AAA industry I'd expect a lot of resistance against it though, due to the compiler being relatively new. Not to mention it uses garbage collection (through a relatively untested implementation).
Yes.
&gt; The C++ interop is not particularly great however. And it's likely to stay that way, C++ makes it nearly impossible to have a stable ABI and then you have templates on top to contend with.
Create a local ivy (or maven) repo
Kotlin should be the end goal, however unfortunately if you don't know Java you will be at a loss (eg stackoverflow answers will often use Java). I would spend a few weeks learning the basics of Java first
Yes, and I remember some Jetbrains person somewhere stating as much. 
You already can do "the iOS views" in Kotlin/Native, just look at the UI examples. Kotlin/Native can essentially do anything ObjectiveC can, including calling to Swift code that exports to ObjectiveC. You do need to generate bindings in cases they are not part of a default framework. 
There's not much left to learn from Java when you know Kotlin. In most cases there's a clear-cut mapping between a Java feature and a Kotlin feature.
Kotlin does help a lot in Android development, and I can't live without it anymore. I also have a passion for Kotlin in other places, such as in the back-end with Kotlin JVM. For starting, I recommend doing Kotlin Koans
I'm doing all my game development on the JVM and Kotlin! I've also written a Tile Engine for this purpose called [Zircon](https://github.com/Hexworks/zircon).
Kotlin makes me write better code. Not null by default being the biggest thing. Its also just a joy to write in, especially compared to java.
is Kotlin good for big projects?
is Kotlin good for the big projects?
Depends on what you consider a big project. If it's a backend project, it is. In the company I work we develop many microservices in Kotlin, and they compose a very big project. In Android I didn't work professionally using Kotlin yet, but I have released 2 fairly big apps 100% in Kotlin as a hobby. I don't see any reason on why you wouldn't use Kotlin in a big project.
I don't know, as a user I have a lot of problems working with YouTrack, as the kotlin issue tracker is the only place I get in touch with it. It might be just me being lazy, but having to create an account and get informations within a to me unknown issue tracker is hard. The scale argument doesn't do it for me, because there are way nigger orgs/repos organized on Github. But I'm okay with Jetbrains feeling at home with YouTrack and being more productive there ;-) It's just another burden for me to think twice about filing an issue
I was thinking that Kotlin still new and does't rich as Java..
It's richer than Java! First things first (this may be important for you to know): Kotlin JVM can run interoperable with Java. That means that you can call Kotlin code from Java and call Java code from Kotlin. This is an amazing feature for the Kotlin language, as you can use all libraries and functionalities from Java, but write everything in Kotlin. Second: Kotlin is, in my opinion, a better language to write in than Java. With it's features you can write good and safe code
&gt; Kotlin JVM can run interoperable with Java. Strictly speaking - Kotlin compiles to JVM bytecode, just like Java. It's the same runtime. Same as Groovy, Scala, Clojure or Ceylon. The difference is in the compiler alone.
I don't think OP is talking about running Kotlin on the JVM, but rather "Kotlin Native" that isn't on the JVM.
Are you sure `btnSave` is a `Button`? I have a feeling it's the resource ID and `Int` doesn't have the `setOnClickListener` method. I'm on my phone so I can't test it out but try using `findViewById` to get a reference to the actual button 
I don't know anything about game development but recently Google has been pushing filament for 3d rendering. And it supports Kotlin.
Are you inflating the correct layout resource? It looks like you're inflating `articlerecycler_item` when the layout you showed (with the button) is `articlerecycler_view`.
This was a mistype on my part, the layout is `articlerecycler_item`.
On which branch is the Kotlin conversion happening? :)
Yes.
The learning resources are better in Java though. A lot of kotlin will make more sense if you know Java.
A lot of Java won't make sense if you know Kotlin :-)
It looks good, but I wouldn't recommend it: you break contract with [MutableList.add(index, element)](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/add.html#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex).
The `vulkan` branch which I linked. Github is not updating the code repartition, it's still showing the master numbers
Just like Java, Kotlin suffer from same issues that prevent it from being used intensively for making games Auto-boxing and lack of value types just to name a few And kotlin native have the same issues + slow runtime, hopefully it's gonna improve with time, but the lack of value type in kotlin native is just plain stupid choice imo
Last I worked in kotlin I remember getting lint errors for unused resources which they were referenced on kotlin files (running gradlew lint on CI). Have they fixed that?
Thanks for your example! I created an issue: [KT-28726](https://youtrack.jetbrains.com/issue/KT-28726)
I say just follow Kotlin based learning resources amd get as far as you can. At some point Java will keep creeping in more and more, and you'll learn Java as you go. The syntax of Java should be pretty easy to understand if you know Kotlin if you use a reference. You'll need to learn more and more of the inners of Java the more you go, mostly because you'll run into weird issues you didn't expect. Happens to me a lot, I think I'm clever in the way I'm doing something, but then it doesn't work because Java under the hood isnt magic.
I've had good experiences with the repository manager Apache Archiva. You can use it as a local proxy for repositories. After it downloaded the dependencies it can be used without an internet connection. An easier (although less reliable) way is to just rely on the Gradle dependency cache.
It's worth pointing out that if you ever decide to add a third option, you'll receive zero help from the compiler about what else needs to change. Forgetting to change _any_ of the things using `popHead` could break previous assumptions in a way that won't be discovered until the program is run with that path trying to operate on the new option. This might not matter so much for N2T (though I'm fairly sure it also requires address support in addition to bool and int). It does matter for software being actively developed, which might also be by people other than yourself. It's good to be aware of this limitation when hardening against it is more important. 
I'd agree with this. Having worked with a few cross platform solutions as well as Kotlin and Swift, I'd say that separate codebases for separate platforms will be more maintainable. There are often platform specific issues (Depending on what you're doing) and modifying the common codebase to compensate for that is generally worse than maintaining 2 different repos. And as wasunsofpeace said, Kotlin and Swift aren't that different. It's not Obj C anymore (thank god) unless you're making a Framework.
Contracts should solve this in the future. Though using a similar flow (contracts require top level functions the moment) it seems currently the compiler doesn't hint like it does for enums / sealed classes, I believe it could. 
I could imagine, that it could work together nicely. Flutter for multiplatform UI and Kotlin for multiplatform application logic.
I think kotlin will be around for native development. Google is kinda bad for putting their weight behind something only to be abandoned two years later. I mean how many chat apps have we seen now. Not to mention Google+. I think they will still need to support a native base for some applications. Heavy lifting apps like If this than that probably can't easily be written with common code base since system apis are so different.
Yeah they do that sometimes. Flutter doesn't seem like one of those things though because of how widely adopted it is internal to Google. Its almost as if they said, "Hey everybody, we've made this great tool and use it in a lot of our mission critical apps. Feel free to use it too." So I don't think it will be abandoned. I may be proven wrong but right now it doesn't look like that. 
I don't think they will abandon Flutter. They use it for too many mission-critical apps. Plus they have put so much behind Dart and it is super successful internal to Google.
I assume that someone (maybe Jetbrains) brings out something similar for Kotlin but with a pure native approach. Darts downside is it's leak of interopability. Kotlin on the other hand tries very hard to integrate as much as possible. And wait until the Flutter hype is over... I think Kotlins way has much more potential in general.
Flutter 1.0 means nothing, status of it hasn't changed at all, they just went and put a 1.0 mark on it, like they do with many things. will see in 2 years from now, will we be reading a blog post saying 'we're closing flutter in March's or not. it's not ready for production, not nearly there.
They abandoned gwt even though it was in extensive use internally.
Most frameworks do eventually get replaced by the new hotness. For GWT it was AngularJS internally at Google.
I am also wondrring how to mock exposed operations.
The cross-plattform-native promise has been given before. Most still use native. Google nowadays does a lot of "phrase based marketing". I've seen a presentation on Flutter and found it off-putting because of all the buzzwords. It's important not to believe the marketing. On the other hand: Why should Kotlin for Android go away? Even if in 5 years 60% was done with Flutter?
Kotlin is great as a language. So so much better than dart but unfortunately, Flutter just stole the show for me. I think Flutter stole a big opportunity from Kotlin to gain huge traction. 
As a newbie, I would suggest Flutter/Dart if you: 1) don't need to do anything unusual (low level access/gamedev) 2) might also want to have the same app on iOS I already know Android/Java dev and though Kotlin makes it so much nicer, still prefer the Flutter layout components and React-style component-tree rendering compared to Android's legacy interfaces. I still use Kotlin/Java whenever I can, e.g. back-end dev and for the native parts of a Flutter/Dart app.
After that GWT was further developed by e. g. Vaadin, so GWT was not taken away like some Google platforms. Now Vaadin switched to Polymer (also from Google), a library to provide the Web Components Standard to browsers that do not support it yet. But you are right, before more big companies (that would invest in further development, after Google) use Flutter it is kind of risky.
If the Android team thought that Flutter mattered for their audience, they would have mentioned the Flutter 1.0 release on their developers blog (https://android-developers.googleblog.com/), right? Guess what - they did not.
Should the kotlin part even have any effect on the results? I'd expect java code to perform the same. Also, please don't microbenchmark without JMH
Hi Hugo, &amp;#x200B; I'm working on a wrapper, called vk², to make vulkan more kotlin-idiomatic [here](https://github.com/kotlin-graphics/vkk) To get a raw idea, an hello triangle like [this](https://github.com/jvm-graphics-labs/Vulkan/blob/master/src/main/kotlin/vulkan/basics/01a%20Triangle%20Verbose.kt) becomes [this](https://github.com/jvm-graphics-labs/Vulkan/blob/master/src/main/kotlin/vulkan/basics/01b%20Triangle.kt)
I spent last night learning Kotlin through their docs, and the only topic I found a bit tough to grasp, *personally*, is Generics, with particular regard to declaration-site variance. The idea is great, it'll just need a bit more work on my side to truly understand it. Like, if I have something like this: `interface Consumer&lt;in T&gt; { fun consume (t: T) } ` Why is it fine to assign `Consumer&lt;Double&gt; = Consumer&lt;Number&gt;`? I'm assigning a supertype to a subtype and this would require an unsafe cast in Java. What if `Consumer&lt;Number&gt;` contains an instance of `Integer`? I would now be storing it as a `Consumer&lt;Double&gt;`.
Published: May 26, 2017 
&gt; NullPointerException is a word that gives every Java developer an instant headache. Kotlin has null-safety built into the language. You als can produce a NullPointerException with pure Kotlin: ``` class Foo { val fail: String = fail() private val bar = "bar" private fun fail() = bar } fun main(args: Array&lt;String&gt;) { println(Foo().fail.length) } ```
Hello :), you may remember I made a PR for the assimp port, so I've gone through the other projects of the kotlin-graphics org and indeed saw vk² and the benefits it offers are greatly relevant. However I'm sorry to say I actually chose against using it in my project, and decided to use "vanilla" LWJGL3 instead; The Vulkan backend was my first contact with Vulkan, learning it when being new to Kotlin was already a tall order and using a fancy wrapper over it would only further complicate my learning process. I've taken a few months to wrap my head around the Vulkan way, and I now have my own abstractions/helper methods in my code, so I don't think this was a terrible choice. Also vkk, much like the other projects in the kotlin-graphics org, come with it's own set of dependencies, and I don't need `glm`for example, since I already use `joml` in it's place. I'm also not interested in `gli` and afaik neither of these two are optional. Since I'm not building this backend in a vacuum and I already have a fair bit of dependency bloat on the rest of the project. Then finally, I'm wary about the maturity of `vkk`. I've already had a few roadblocks with Vulkan features that I had hoped would be pretty standard by now ( `ext_push_descriptor`, `ext_descriptor_indexing` causing me so much pain lately ). I'm already pushing the limits of what I can accomplish on my free time with this Vulkan backend, and the perspective of dealing with yet another bleeding-edge component just isn't worth a better wrapper. I really like what you're trying to do with it, and sure enough I'm doing some of my own vk+k in my engine. I wish you the best with it
I think Google might still change their mind on flutter. IMHO it will largely depend on whether there will be adoption of it by developers. If not, it might go the same path as Google Inbox, where it's hyped for a few years and then quietly taken out the back and shot a few years later. Kotlin Native might be a future path but not one that has been acknowledged by Google much yet. And it is very clear that their not quite jvm/dalvik/whatever they call it now is not a long term plan either. It's not something they talk much about in the context of e.g. Fuchsia. They bought some time by adopting kotlin but I could see them deprecating running things in a jvm in favor of native applications using either flutter or any of the other already supported native tool chains (including kotlin native). So the real question to ask is what will happen to non native kotlin on Android and how that will fare relative to flutter and other natively compiled stuff. My guess is that they will stop being something they invest in and may eventually deprecate. IMHO, another question to be asked is when they will get around to doing Kotlin native bindings for flutter and why that has not been a goal to begin with given the fact that they just spent several years moving android developers onto Kotlin. From what I can see Kotlin is at least as nice as Dart, very similar in capabilities, etc. Also, Dart is an odd choice in a world of llvm based natively compiled languages such as Kotlin, Rust, Swift, and others. Add wasm to the mix and it starts looking more puzzling. Wasm is an obvious way to target native applications to e.g. chrome os. Two years into making sure chrome runs that stuff well, it's an odd choice to start pushing people to yet another virtual machine for Dart. All things considered, I would not jump on flutter just yet. I have a hunch that they will either re-architect it significantly or shelve it entirely. I'm not sure they have actually made up their mind on this either. Google is looking increasingly like it is improvising on these topics rather than operating against some grand plan. Is Fuchsia/Flutter going to be announced as a thing that we all need to jump on yet? Or are we supposed to do PWA web applications + wasm on Chrome OS, or shall we support Android applications there. Or maybe we should all start running linux applications there (like they proudly announced just weeks ago). It's a bit of a toss up which team ends up on top. IMHO, the flutter/fuchsia stack needs a lot of work before they can deprecate all of that and not piss off their precious developer community. &amp;#x200B;
The practice of posting meme images in tech articles needs to stop. 
&gt; when they will get around to doing Kotlin native bindings for flutter and why that has not been a goal to begin with given the fact that they just spent several years moving android developers onto Kotlin The two "they"'s in your sentence refers to two different groups of people who do not necessarily share the same goals.
I think that sums up the whole problem because it's the same company trying to pull the same group of developers different directions.
There's talk that Flutter is a way of getting people ready for Fuchsia. Just rumors as far as I know though.
But isn't Google pretty fragmented because of its size? It's not the first time I've heard of teams inside Google contradicting each other. Polymer vs. Angular is a good example. Both frameworks have been promoted extensively by Google though they both do roughly the same thing. Angular has a lot more bells and whistles than Polymer (like RxJS, dependency injection, etc.) but they are both front-end framework designed specifically for rendering the view in browsers.
The object of type Consumer&lt;Number&gt; may very well contain an Int. When you assign it to a variable with the declared type Consumer&lt;Double&gt; it doesn't mean that from now on you store the Int in it as a Double. It just means that calling its functions on that variable you can only **put** Double in it (because it only has functions that have the generic type as a parameter type, not as a return type). Since your object can contain any Number (Int, Double, whatever), putting a Double in it is safe. Trying to **extract** a Double out of it would be unsafe, since it may contain an Int, but it doesn't have function with which you could do it, so no problem.
Ahhh so you're actually restricting the input range of the `consume()` method, which can technically accept any `Number` but can accept only instances of `Double` if invoked through a `Consumer&lt;Double&gt;` instance. Thanks, that helped a lot! I was planning on writing some code snippets in the IDE because I find the autocompletion feature very useful when trying to understand Generics.
Especially when they're 100% of the time not funny. 
At least it's not reaction GIFs
Interesting. Utilizing my limitless creativity I came up with an even shorter version: \`\`\`\` throw NullPointerException() \`\`\`\`
I see \~5 upvotes on Flutter posts. I have not seen anyone apart from Google implementing any semi-large app with Flutter. If it does not suddenly take off I imagine it being abandoned within a few years.
Honestly Dart failed already I just don't see people jumping on this vagon. Especially when Kotlin/Swift is just so much more mature, faster and safer. People keep saying that oh this and that company already uses Flutter ye like less than 1%. The same marketshare as Delphi/Pascal. I don't see anyone start hypeing up Delphi, they still developing there IDE btw.
leave the company
I don’t know Kotlin, but why is this NPE seems like it would return 3 (length of bar) v
This article explains it a bit https://medium.com/@elizarov/structured-concurrency-722d765aa952 It is about giving more control over coroutines. For example how it should behave if a child job fails
fail is called before bar is initialized
Awesome, I'm also loving to use coroutines at work and I'm really wanting to replace all my Rx with them, they're so much simpler to mantain due to the readability, really a great feature of the language, actors for example are so useful in some cases like loading and queued operations, a really easy way to deal with backpressure using send or offer.
Great article. It would be interesting to see the performance differences between the two.
I would really love to see this benchmarked against Reactor as well.
Yes. 
Kotlin `suspend fun`s and coroutines are like a generalized version of what you get in C#. In C#, `async/await` and `yield/return` are similar to each other, yet they use different syntaxes, produce different types, and possibly different implementation under the hood. Kotlin has just once low-level concept (`suspend fun` and its associated infrastructure). Higher-level APIs are built on top of this low-level concept. For example, Kotlin has the factory functions `sequence` and `iterator` that essentially replace `yield/return` in C#. There's also an extra library `kotlinx.coroutines` that adds things resembling the TPL from .NET. All of these are built on top of the intrinsic coroutine support provided by `suspend fun`s.
It's something like 100-1000 times slower. It's the same reason you don't see Subjects/Processors inside each operator. It's not an approach that yields performance.
Hi :) yeah, I do understand your concerns. However, I also do believe that a wrapper making the code more concise, and consequently more readable, is a win-win rathen than an obstacles to learning Vulkan.This is especially true if one uses only the first-layer vk² calls which are strictly connected/related to the vanilla ones, but avoid all the burden that comes with direct buffers, pointers, uses enums, inline classes and check eventually automatically the result (and most inline directly the native call). You are right, vk² comes with its set of dependencies, one of my main goals has always been to have a highly interconnected libraries environment in order to have any library benefits from each other when possible and push behind the curtains as much as boilerplate possible, making also at the same time code less error prone as possible.But I do understand this may represent an obstacle for people using something else then \`glm\` and \`gli\`.Also \`joml\` has surely a larger userbase, and I see this as an opportunity rather than a threat, so I'm totally available in having a "nude" branchwith no problematic dependencies or a \`joml\` branch, it shouldnt be hard at all, the impact of \`glm\` and \`gli\` is actually quite minimal in \`vk²\`. This could be also easily become the master branch, I have no problems with it.Or we could even implement some generic interfaces, in order to have a neutral binding to any libraries implementing those interfaces (I'm thinking for example to \`componentN()\`).I can imagine you have also your own set of utilities and helpers, but Kotlin comes quite in help also in this case (I'm looking especially at you, extension functions :p). Then, the maturity of \`vk²\` is also a super valid point. And this is also one of my major goals: the benefits of a larger userbase helps making the library mature and shape it based on the most common usages and needings.This is the very same reason I'm working to a port of Sasha [examples](https://github.com/java-opengl-labs/Vulkan), with Ulrik [here](https://github.com/scenerygraphics/scenery/pull/223) in order to implement it inside scenery and also with [Frederic Nieto](https://github.com/Wicpar), who took \`vkk\` enums for his private project. I really think is a waste if everyone does always everything in his own from scratch again and again.I do understand this represents a compromise sometime, because things arent always the way one'd like or do, but I also do recognize as a much higher value the joint effort of people into a single place, where different heads brings together different views and ideas, that with discussion and comparison will help creating something valuable for everyone else, or at least most :p. my 2c very nice project chunkstories though! 
I don't get the hype for serverless. What makes it so nice and worth switching to compared to a traditional server in the cloud ?
Running on a server requires more resources in terms of storage and memory. Serverless can utilise less cpu, disk and memory which lowers the price. Servers needs maintenance. Sec patches etc.. serverless moves that pain to the cloud operators. 
I'm a bit disappointed. I thought that this kind of issues are checked by the compiler. If I'm not wrong, we are talking about this (open) bug: [https://youtrack.jetbrains.net/issue/KT-10573](https://youtrack.jetbrains.net/issue/KT-10573)
Yes. A rough outline: 1. Flatten everything down into a linear list of pairs of `(album, photo)` (or more directly as `(album id, photo id)`) 2. Group elements by photo ID 3. clean up the groupings I started typing out the solution, but the answer by Omar Mainegra in that SO post is the same as what I was putting together. One tweak you could make to his solution: instead of creating a `Pair(photo.id, album.id)`, you can use object expressions to create an anonymous type that nonetheless threads its type information through collection transforms. So instead of: Pair(photo.id, album.id) You can instead do: object { val photoId = photo.id; val albumId = album.id } Then later, instead of using destructuring (i.e. `groupBy ( { (photoId, _) -&gt; photoId }, ...)`, you could instead reference the element by name: groupBy ( { it.photoId }, ...) `Pair` is fine, but obviously only works if you need two items. And while it's perfectly readable in short chunks of code like this, it can get awkward in longer chunks of code to remember which element was first in the pair and which was second. Object expressions with named properties can resolve those issues. One downside to object expressions is that, unlike `Pair`, they don't have value semantics. So two "equivalent" object expressions are not actually treated as the same. That means you probably would not want to use object expressions to establish the keys in a map or the elements in a set. 
Don’t forget the automatic horizontal scaling! Not having to tune autoscale groups is worth the “hassle”.
Additionally to what for example @balefrost already stated, kotlin's coroutines are used to implement structured concurrency. This is not implemented in c# and Javascript (correct me) and i think this is a real game changer, because otherwise, resource handling is quite complex. The generic concept of suspending functions can also be used to implement other constructs (take a look at at arrow's monads, but i don't have much knowledge here) or custom, high performance scheduling for special use cases (take a look at pronghorn Blog).
This is quite confusing and I'd kill to know what is the real position of JetBrains on this matter. Both economically and ideologically. I really like their work for almost every language/platform. Google's position, on the other hand, seems clear to me: they want to impose their platform for Android. Even if Flutter/Dart is successful there's a long path before reaching maturity. Kotlin is great but still is a smooth transition from Java. In the long run I can imagine &lt;insert Google language here&gt; for Android develoment and Kotlin as the most balanced multi platform language. At least that's what I hope.
An important difference between Kotlin coroutines and C# async/await (and I think JS as well, but never used them so I'm not sure) is that **by default** when you call multiple suspending functions in the same block they will be called sequentially (i.e. one after the other) as opposed to C# calls that will be done in parallel unless you explicitly await for them after each call. If you want to make parallel calls to multiple suspend functions you will have to explicitly use an *async { ... }* or *launch { ... }* builder. IMO the Kotlin default is much better for readability (it's clearer for someone new to the code when you make concurrent calls) and to avoid some common pitfalls :) 
I can understand this, but I am perplexed about startup &amp; warm-up times (at least for Java world).
They are still run on servers operated by the cloud. If you do not access them they might be unloaded. What that means can be different between clouds. So its probably similar to mobile apps being suspended if not used for a while. When you switch they are started again. If they were in the background and recently accessed it will be alot quicker.
Hey, pure\_x01, just a quick heads-up: **alot** is actually spelled **a lot**. You can remember it by **it is one lot, 'a lot'**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Wow thanks for the detailed explanation and alternative solution!
There are some very powerful things you can do with serverless tech like Lambda. There’s Lambda@edge which means your serverless code can run out on the CloudFront servers without you having to specify “put this server in 150 global locations”. Serverless code can get moved around and scaled really quickly. 
This is not reflection. In this case, the simplest approach would be to convert it to a lambda rather than a function reference: calcs.forEach { it.plus(5) }
Depending on size, you might also want to separate into domains. Once you start adding configuration it can grow quite big, so having a config object that injects several other objects with config separated by domain might help you have everything organised.
&gt;Using a data class is weird to me, as what you actually want are static values, but are afraid of them due to testing purposes. You're changing your production code to be able to test it, and this is a big smell to me. not being able to test your code is a bigger problem, imho
forEach takes a method `(T) -&gt; Unit` - takes a single argument (whose type is the type of the iterable, Calc in this case) and doesn't return anything useful. `Calc::plusOne` is of type `Calc.() -&gt; Unit`, which Kotlin will implicitly transform into a `(Calc) -&gt; Unit` where the argument becomes `this`. `Calc::plus` is a `Calc.(Int) -&gt; Unit` or `(Calc, Int) -&gt; Unit`, which can't be converted to anything forEach can call. You need to make a new method with the right signature. The easy way is with a lambda expression: calcs.forEach({ num: Calc -&gt; num.plus(5) }) Everything inside the curly brackets is part of a method; before the arrow is the argument list, and after is the body. The single argument is a Calc, and plus returns Unit, so this lambda is of type `(Calc) -&gt; Unit` - perfect for forEach. Parameter types are usually inferrable for lambdas, so you can omit them: calcs.forEach({ num -&gt; num.plus(5) }) Since the type of num has to be Calc (or a superclass) for this to compile, Kotlin infers the type to be Calc and you don't need to specify it. You can even omit the parameter name since there's only one parameter, and the parameter will be called `it`. calcs.forEach({ it.plus(5) }) Again, same thing, just using inferrence to our advantage. Since the lambda expression is the last argument, you can move it outside of the parentheses: calcs.forEach() { it.plus(5) } And since the parentheses are now empty, you can remove them: calcs.forEach { it.plus(5) }
I know I can do it this way, just wonder can I do it with forEach()
Thanks, I knew I can do `calcs.forEach { it.plus(5) }` but I didn't know it comes from `calcs.forEach({ num: Calc -&gt; num.plus(5) })`
 fun &lt;A, B, C&gt; ((A, B) -&gt; C).bind(argument: B) = { a: A -&gt; this(a, argument) } calcs.forEach(Calc::plus.bind(5)) 
I agree. But in my experience, when your code is way too hard to test, it's design could probably be improved. If there are no other options, sure, change code to test it. But if redesign makes iteasier, I'd likely go for it instead
Channels are 100-1000 times slower, or channels are 100-1000 times faster? (No native speaker here) Do you have any material regarding performance comparisons? I took a look at a reactive streams implementation from someone on the internet that was based on channels, where the author also showed how slow the implementation is, and my profiling showed 90% time spent in primitive boxing etc, so I didn't trust the results much. Would be nice to have something better to put one's trust in :)
Channels are 100-1000x slower? If that's true, do you see it as a hard-limitation of the approach or just because Channels are not yet optimized in Kotlin? If it is a hard limit, that seems like a rather damning indictment of the whole co-routine implementation. I thought co-routines were supposed to be 'lighter' than Threading?
It read ambiguously to me, too.
But why?
&gt; just wonder can I do it with forEach() Well, you can. Of course, I'd prefer a simple lambda in most (all?) cases.
No you can't. An `ArrayList` has an internal `Array&lt;Any&gt;`, that is, an array of objects, and you cannot get to it directly without really ugly hacks. It's the core principle of OO programming - encapsulation, and it sometimes induces some overhead like here. Making a copy is often not that bad though, unless you need it a lot. But it's worse, because it's an array of `Any` (reference types), all elements must be a reference type, so all elements will be boxed versions of chars for the JVM `java.lang.Character` instances. So even if you could get the array they are not interchangeable. To make things even more ridiculous, it's never possible to substitute types of arrays (`Array&lt;T&gt;` as `Array&lt;M&gt;` is only possible if T == M, otherwise it will throw an exception). The interchangeability of array types is a somewhat counter-intuitive problem, and JVM (also Kotlin) arrays are _type invariant_, meaning that even if you wanted an `Array&lt;Char&gt;` (not a `CharArray`) and you had an `Array&lt;Object&gt;` you _still_ could not cast one to the other without making a copy (not even cast an `Array&lt;Char&gt;` _to_ an `Array&lt;Object&gt;`!). You can read more about it here: https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)
**Covariance and contravariance (computer science)** Many programming language type systems support subtyping. Variance refers to how subtyping between more complex types relates to subtyping between their components. For instance, if the type Cat is a subtype of Animal, then an expression of type Cat can be used wherever an expression of type Animal is used. How should a list of Cats relate to a list of Animals? *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Kotlin/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Thanks for the explanation. 
The problem is that the instance of the array in `ArrayList` is not final. If ArrayList had a method that would return a reference to that array there were no guarantee how long this reference would be identical to the array instance in the ArrayList. Two possible solutions: 1. You can use `ArrayList.toArray()` which uses `System.arraycopy()` which is much faster than the for loop in `toShortArray()`. 2. You can take the code of `ArrayList` from the OpenJDK sources, pick what you need regarding dynamic array management and create your own class that also exports a member `arraydata()` which returns a reference to the internal array instance. Have fun :)
The only thing you're missing is the fact that ArrayList (at leas tin Java) contains a array of references, not the actual short values. In Java ArrayList.toArray() would give you a Short[], not a short[]. As far as I can tell the Kotlin ArrayList doesn't have a normal toArray() method.
It's because of the synchronization primitives in use to supply the consumer with values from the producer. Regular Rx operators chains don't require this to the same degree at every stage. You can still build a coroutine-based Rx implementation, but it should be based on suspend only and channels should only be used where strictly needed for fan in/out and not at every operator in the chain.
I built my own experimental Rx implementation a long time ago. I feel like everyone starts with channels because it's so easy. In reality you need to use suspension only and save channels for the fan in/out operators only.
What you are after is called *partial application* and that is currently not supported by kotlin.
Keep in mind that you're working with a plain old Java list here (array list of type Character in Java speak) since using collections in Kotlin is really using Java collections. So what you're trying to do is not possible in Java either (due to char[] being different than Object[] with references to Character instances and also due to list encapsulation). It looks like what you really want is to work with a primitive char array in Kotlin so that you can pass it around. This is defined as CharArray instead of Array&lt;Char&gt; or list of Char): https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-char-array/index.html
Do you have any code examples on hand? I would be interested to see the difference in implementation.
It will be deprecated, along with Java and native toolkit, why would we need native development, when you can write multiplatform.^^^^^/s
When will you learn, that Google is not a *homogeneous* entity there are thousands of teams working on it's products, each possibly competing with each other.
No it's not, the only thing that binds them is the same company, Google couldn't care less what you use, as long as you use their products.
And then what? Billions of dollars poured into an Android SDK will just be deprecated? Hey, guys, we know that you like and use this battle-tested SDK that we've been developing for more than 10 years, that's used by a millions of developers and is getting better every year while we pour millions of dollars into it's development, yeah it's deprecated now, lol, just go and write you some Dart my man. Oh, and while we deprecated Android SDK, there's no way to save and restore on process death, so fuck you.
\+1 This is such an interesting topic. Maybe just a comparison for a single non trivial operator, with and without channels, would be very interesting :)
I did a bunch of experimentation in https://github.com/JakeWharton/Reagent. Haven't touched it in a long time though…
That's not a proper conclusion. This is just a count of questions - I can ask questions about the language that don't specifically pertain to android features or SDKs but still use it for android.
Hence the part "according to Stack Overflow". Apart from that Android-related questions quickly get edited by Kotlin users who are not programming on Android (like myself) to include said tag.
And ?
There is no and.
This is according to you, not them lol.
Facts are hard to argue with (as you can see in the screenshot).
You’re drawing conclusions based on 2 numbers. That’s not fact nor something they claimed.
It is on Stack Overflow and hard numbers.
What's the significance of this figure ?
I’m glad you’re not in charge of statistics somewhere lol.
Whatever.
That Kotlin is used outside of Android world.
The first big supporter of Kotlin was Google and Android. Most of the developers made an assumptions that Kotlin will be language embraced by the mobile developer community. These numbers could be a sign that this is not true anymore, and Kotlin is a widely used, general programming language. I think this is the essence of it, even if these statistics are not official ones :)
I see another hard number in that screenshot as well: "-1". From that, I can conclude that Kotlin questions that aren't also Android questions are universally bad! You can't argue with facts! All snarkiness aside, the only facts here are the number of Kotlin-tagged questions asked on SO, partitioned by whether they are also tagged with Android or not. Jumping from that to "number of users" is a looooooong stretch at best. Nobody is arguing against your facts; they're arguing against your poor interpretation of those facts. In fact, [the one question](https://stackoverflow.com/questions/53782129/decode-html-entities-in-kotlin) that is shown on the right side appears be using the [Android HTML api](https://developer.android.com/reference/android/text/Html), so it arguably *should* be tagged with Android as well.
Why not, it's a solid replacement for Java for, as far as I know, all circumstances.
Those numbers are just facts of course, no one is arguing against that. The problem is that you've made a logical error: questions not tagged `android` can still come from people that only use Kotlin on Android. Maybe they're just asking general questions that aren't directly related to Android.
Apple did it several years ago. Can't remember for what iOS version but they basically said, "We will provide support for older apps for a while, but you need to rewrite everything with our new SDK." It's not too farfetched.
That's what I'm saying though - that only applies if the question *specifically* pertains to an Android SDK or feature. If I'm writing Kotlin code for my android app and I have a generic question about how lists or data classes work, I can write that question completely agnostic of the platform for which I'm developing and it would thus be inappropriate to tag it with Android. I like the message you're attempting to convey (I'm not even an android developer, I use kotlin with spring), but these numbers don't support it, they are next to meaningless.
I don't see how this is relevant.
That was the point, thanks.
If you're talking about deprecation of 32-bit apps, then it's not the same.
I think you are missing the point. The fact is 1/2 of the entries tagged Kotlin contain an android tag. So for those users that enter a question, 1/2 of them have questions about android and kotlin specifically. The other 1/2 are questions specifically about kotlin. Let’s say I’m a kotlin, android developer and perhaps have a question regarding extension methods. Because android isn’t relevant to the situation, there is no reason to include that tag so the kotlin tag is added but not android. This doesn’t mean I’m not a kotlin, android developer, this only means I have a question only about kotlin and not android.
I got it. What's not visible from my post is that I'm observing the Kotlin tag for more than a year daily so I have a pretty good picture of the questions. Of course it is possible that someone asks about Kotlin, but more often than not if they are using Android it is clear from the context. Of course it is possible that some percentage of those people don't state this in any way but I don't think it affects this 50%-50% ratio significantly.
I recently convinced my small team to switch from Java to Kotlin for backend work. I fully converted the one small (but important) Java app to Kotlin and all new work is in Kotlin. So there are definitely non-Android teams picking it up, but it's hard to know how many.
You only pay for the time your lambda is running, no infrastructure to deal with, automatic, elastic scaling.
I agree. I did the same, already converted 2 projects to Kotlin in work. What's interesting is that is it orders of magnitude easier to convert Scala devs than Java devs.
I feel like /r/learnprogramming is a better source for you. If you're fairly new to programming they'll have better resources. There are a few threads already if you search for them https://www.reddit.com/r/Kotlin/search?q=learn&amp;restrict_sr=on&amp;sort=relevance&amp;t=all Intellij is the supported IDE, but there's no reason why you can't use any plain ol text editor you want. 
What model is it? You might be able to add more RAM. Everything else is just fine for the purpose. 
It’s a x121e with 4GB RAM upgradable up to 8. 
I have some programming skills and apps made for iOS (using Swift) and there’s one current project that I want to write for both Android and iOS, so after little research I thought Kotlin will be the better option for me. 
I have some programming skills and apps made for iOS (using Swift) and there’s one current project that I want to write for both Android and iOS, so after little research I thought Kotlin will be the better option for me. 
Gee, free beta testing for an app with no description for no reason, yeah that'll work.
Where about do you live? I have 2x DDR3 4Gb SODIMM modules that I can give away
Thanks for posting this. Do you know how to configure this in Android Studio for an Android app? I can't seem to get it to work. 
Hahaha thanks mate, but it’s not about the money :)
I've just upgraded mine x220 from 8Gb to 16Gb a few days ago, and now have 8Gb that are no use to me anyway. But if you don't need it - I'm not going to insist on it :) 
I really appreciate it, I have 2 macs 8GB both with SSDs etc. that are doing fine, but I wanted to use this one partly because I hate to throw electronic stuff up, partly because I believe it still can be useful.
&gt; Dmitry Jemerov and Svetlana Isakova speak to Matthew Farwell about the Kotlin programming language. They cover what the goals of Kotlin are, why Kotlin was created, what the target use cases are for Kotlin, syntax differences between Java &amp; Kotlin, differences in classes and interfaces between Java &amp; Kotlin, pattern matching in Kotlin, Kotlin’s type system, including nullable/notnull types. Interaction between Java &amp; Kotlin, variance and co-variance in Kotlin, DSL construction, Android development with Kotlin, the Kotlin ecosystem, and the future of Kotlin. Note: The episode is 6 months old, but was never posted to reddit if I'm not mistaken.
Kotlin is a better Java. I don't use it for Android development, I use it to create extremely complex HPC systems. So, I can see why this might be the case.
The schema is the interface, it should be the source :/
&gt; Overloading operators is so easy and allows us to manipulate objects with less syntax There I fixed it for ya
I think it's very relevant, Kotlin's usability shines not only in Android ecosystem, hence it's not surprising it's not a narrow-niche language.
I mean the whole post's point was this. Why stating the obvious?
You do realize this is overriding and not overloading right?
What does less syntax even mean? If you just have normal function calls and no operator overloading, that would be less syntax in my opinion, because functions are less than functions plus operators. Or are you counting characters and call that less syntax?
Normally a netcore guy, so my language idioms may well be all over the place. Had lots of fun putting this together. Would welcome any feedback or comments - bit of a learning exercise for me that hopefully might be of use to some people.
Must say, that looks pretty sweet. There are a few places, especially the !! parts, which make me frown, but I haven't dived enough into it to completely understand why it's needed. (Also, I'm trying really hard to not get to upset about prefixing interfaces with a capital I.... and I'm failing. I know it's conventional in .net, but not so in .java ;-) Plus, you might need to consider renaming your package name again, Java/Kotlin people have a very strong preference to use an inversed domain name, like com.something.kotlinject)
Jetbrains uses the I prefix in the code style conventions page and it's the default if you use the extract interface refactoring. I know, I'm not happy about it either, but apparently it *is* in fact idiomatic to kotlin
Interesting. Where did you see that? I had a look here: https://kotlinlang.org/docs/reference/coding-conventions.html#naming-rules, and I don't see it there, nor can I find that anywhere else. 
https://kotlinlang.org/docs/reference/operator-overloading.html
It's not said explicitly, search for "IFoo" on that page. It's definitely in their example
Nope, idiomatic is like they do in Java, their examples are flawed.
Yeah, I was consciously fighting against com.* because it's so dumb, but I'll follow convention in all likelihood. The I thing is a mix - seemed to be what the style guide suggested, and something I'm predisposed to prefer, but certainly in user-land I'll implement auto-discovery around standard JVM conventions *Impl etc
TIL 1st party sources are not trustworthy
TIL that example under "Colon" section defines naming conventions for naming.
Okay here's an experiment. Open IntelliJ, open a class and go to Refactor -&gt; Refactor This -&gt; Extract Interface. Please post below what the suggested name for the interface is
Damn, you're right, I thought it does the same for Java, but no, for Java I is missing. Would like to hear opinion on this from someone from JetBrains. What do you think about this, /u/yole?
I'm not a fan of the I prefix, just saying that Jetbrains really seems to advocate for it in kotlin
Sure, but one example doesn't make it idiomatic Kotlin. I wouldn't read to much in it.
I don't think the Kotlin team has any strong preference in this regard. We do use the I prefix in some of our Kotlin codebases, but it's not something we're advocating for.
To be fair, it does make sense in Kotlin context, because of : thing instead of explicit extends/implements keywords.
Yeah that's true. I still avoid it though
What's about the gradle-bintray-plugin? https://github.com/bintray/gradle-bintray-plugin I think this should do it.
Extended types have constructor invocations, interfaces do not. Prefixes don't add any disambiguation that isn't already there.
Is this limited to just 1 validator at a time? Asking as I have multiple rules for some fields, which I'd like to display different validation messages for
I've tried before (and for the sake of it, tried again) and I always get authentication errors despite everything seemingly working. [I adapted my build.gradle](https://gitlab.com/yak-stack/yak-library/blob/bintray/build.gradle) to do what the README said, and running: `./gradlew clean install bintrayUpload` I get: \* What went wrong: `Execution failed for task ':bintrayUpload'.` `&gt; Could not create package 'darrien/YakLib/com.darrienglasser.yaklib': HTTP/1.1 401 Unauthorized [message:This resource requires authentication]` Any idea what could be wrong?
&gt; Extended types have constructor invocations, interfaces do not. I've thought about this, but what if we have overloaded constructor?
Did you specify your user and API key in the bintray configuration in gradle? bintray { user = System.getenv('BINTRAY_USER') key = System.getenv('BINTRAY_KEY') } 
You can not usually deploy into Bintray directly from your own machine iirc. You have to do it via a CI tool like Travis or something. I also had this about 2 years ago for my own lib. You add a YML file to your project (there is a guide on Travis out there for Android). I only assume this because of the Unauthorised exception you get (from other comment). Travis is an allowed domain so to speak. It is possible to upload snapshots from your personal machine maybe. But I have never tried that, only release builds.
This works for me, with BINTRAY_API_KEY specified in the environment. https://github.com/dmcg/minutest/blob/master/core/build.gradle.kts It’s the Kotlin DSL rather than Groovy I’m afraid. 
you would've learned this long ago if you were an Android developer. 
No worries, I can read both. I'll give it a shot, thanks. 
I wrote something for publishing to a private S3 backed maven repository for a pure Kotlin project here: https://gist.github.com/vinaysshenoy/b92cc84c98858b9d4416eb09bf25f40b You should be able to use most of this for Bintray upload as well.
I have a couple of playlists on my channel that aim to fit this. Includes things like how to try the language, how to setup a new project,etc. Might be helpful Start Learning Kotlin: https://www.youtube.com/playlist?list=PLEPZdzLLJH959ZLA-eOwg77ltN3yHTk-J Learning Kotlin: https://www.youtube.com/playlist?list=PLEPZdzLLJH964FjaGyzyNChnQgAObu0LN If you want to try out the language online in a really easy way you could try this: https://try.kotlinlang.org/
This isn't with reflection, but based on one of your other comments it sounds like you may care about about simplicity at the call site than anything else. If that is actually what you care about, you can achieve that using a companion object... class Calc(var number: Int = 0) { // fun plus (int : Int) { number += int } companion object { fun plus(int: Int): Calc.() -&gt; Unit { return { number += int } } } } fun main() { val list = listOf(Calc(2), Calc(4)) // list.forEach(Calc::plus(5)) list.forEach(Calc.plus(5)) // &lt;-- one character less typing even...at the call site :p }
Are these katas for arrow only? 
How is the comment negative?
This would work way better as a pipeline using Coroutine Channels like so: --&gt; (even # consumer coroutine) (number producer coroutine) ---(broadcast channel)---| --&gt; (odd # consumer coroutine) i.e. suspend fun numProducer(limit: Int, channel: SendChannel&lt;Int&gt;) { repeat(limit) { channel.send(it) delay(1000) } } suspend fun evenOddConsumer(channel: ReceiveChannel&lt;Int&gt;, receivingEven: Boolean) { val expectedRemainder = if (receivingEven) 0 else 1 val evenness = if (receivingEven) "even" else "odd" for (number in channel) { val number = channel.receive() if (number % 2 == expectedRemainder) { println("Got an $evenness number") } } } fun main() { val asyncJobs = GlobalScope.launch { val numberChannel = BroadcastChannel&lt;Int&gt;() // Launch even/odd consumers launch { evenOddConsumer(numberChannel, true) } launch { evenOddConsumer(numberChannel, false) } launch { numProducer(30, numberChannel) numberChannel.close() } } runBlocking { asyncJobs.join() } } &amp;#x200B;
So far only one, but looking forward to some more. Especially if they're more industry focussed problems.
What frameworks are yous using? 
It's a Dropwizard app, so it's using the various bits and pieces that come with that. 
Well - I own that book, it's good, bit it dedicates a lot to "this is how it's done in Java" or "this is how it interops with Java". But in general it's good, you can skip those parts (at least that's what I did, as I'm not a Java dev nor have the intention to use it with Java). I also recommend the Intellij Edu edition with Kotlin Koans.
First of all, if you have any previous experience with Java that will help you a lot while learning Kotlin. Even if Kotlin aims to be a better programming language overall, it still has a strong connection with Java (being it an overlay of the last, that still runs on the JVM). &amp;#x200B; That being said, I think you can easily learn Kotlin even if you don't have any experience with Java or you are not that skilled. This is because Kotlin is significantly less verbose than Java, and has a lot of things already built in. &amp;#x200B; About the book, it is written in collaboration with Svetlana, which is the right hand of Andrey, the head developer of Kotlin. They even presented the book at the last KotlinConf so I think it might be the best book available at the moment. Another great resource is the free documentation (filled with examples) you can find on the official Kotlin website.
It "depends". Since Kotlin will be compiled to java bytecode, it would be helpful to know how it works in order to write performant code. If you are just trying to get stuff done (without requirements on the actual performance or clean working code) then you dont really have to know much about java. One point that is frustrating me over and over agains is that people think that Kotlin is better because the code is shorter. Yes it is maybe easier to read if there are less "words". But then you have to understand the magic behind the short syntax, because the compiled output does mostly more than you see in all the "shortcuts".
Yes, currently it is. A validator can be used on multiple EditText fields, but you can't add more than one validators to a single field. In the future I might add support for multiple validators at the same time, but for now you're gonna have to create one which does the job. Here is what I suggest. Inside the validator, you can check which error you want to display and simply use the "setError()" function on the edittext multiple times inside the validator to display the message you want.
I think Kotlin is easier to pick up, but it's difficult to take advantage of all its features well, kind of like Python. Kotlin builds on top of Java by improving on what Java didn't get right. So it does help to know java, to truly understand each feature and the motivation behind it.
For me, the answer is no, you don't need to learn Java first, there is a high probability that you end up knowing a bit of Java after reading the book, and for sure you will learn Java if you use kotlin in conjunction with Java code bases. But you don't have to learn it first. 
No, until you start to code. Most libs that you will use are java, em.... 
You should be fine doing kotlin without knowing Java in deep. As many say here, Kotlin is less verbose than Java, now one of the things you should understand are the Java 8 lamdas and functional interfaces.
I meant to say of less verbose. I updated it. Thanks for pointing.
As someone who learned Python first, then Java and finally Kotlin, I give you the advice to learn Kotlin first when you are working on Android software anyway. If you know Python pretty well, then you will feel much more familiar and "at home" with Kotlin. Java's syntax feels clumsy in comparison and distracts you from what's going on. Write your code directly in Kotlin. IntelliJ's conversion of Java code works most of the time but produces very Java-like Kotlin code. It's better to learn and write idiomatic Kotlin code from the very start. I once skimmed through the book you mentioned. It's actually the best read so far although it's a little bit outdated already as fas as Kotlin 1.3 is concerned. Nevertheless, you will learn a lot from this book if you are still a beginner.
That logo is horrifying
👅
Haha, yes you are right. But it is memorable, don't you think? ;-) And it has a meaning. If you find out of which language's origin the term 'lingua' is and then look up the term's other meanings in that language, then you will understand. :-)
Have you benchmarked it against Apache Tika? That's usually my go-to if I need to figure out the language of some document.
Thanks for your suggestion. Not yet. This is on my todo list, probably for version 0.2.1. I will extend my accuracy report classes to compare my test set with Tika and the Java language detector on GitHub that I have linked to in the readme file. But feel free to test it yourself and to tell me your experience. 
Come on! Horrifying? What hyperbole! \*clicks link\* *Yikes!*
Cool project. I was going to fork it and submit a pull request to make various bits more idiomatic but I don't want that image to show up in my profile as it can be misinterpreted so I'll just add some comments here instead: &amp;#x200B; LanguageDetector.kt * See if you can change \`loadLanguageModels\` to use reified generics instead as that will make the call site cleaner * This would be more efficient as a sequence: \`for (language in languages.filterNot { it.isExcludedFromDetection }\` * Similarly, sequence for \`Languages.values().filterNot { ... }.forEach {...}\` * The getMostLikelyLanguage function would be much more efficient if you used \`maxBy\` instead * I noticed that you're creating new lists all over the place even though those aren't stored so I recommend sequences for the type of actions where you just want to filter a collection and do something with the remainder * It seems like it's a common requirement to perform some actions with the languages that meet some condition so I would create a private inline extension function on \`Set&lt;Language&gt;\` (or use generics) to perform some operation on the languages given 2 lambdas (a filter which accepts a Language and returns a Boolean, and an action to perform on a Language which passes the filter). * For the detectLanguageWithRules function, you can replace the sequence of if-statements with a \`when\` * For lookUpNgramProbabilities, once you get comfortable with using the \`let\` function, you could use this: \`lookUpFunction(language, ngram)?.let { return it.log() }\` * I would declare all the private variables that are at the bottom at the top level above the class (but only do this with private variables otherwise you'll pollute the namespace) Ok, cool, I won't look at the other files but you could probably apply many of these suggestions to the other classes as well.
The Result type is essentially an Either&lt;Left,Right&gt;. However (IMO), I think it's a little more clear as most implementations of it represent the branches as Ok/Error, Success/Failure rather than left/right. What's interesting is that Rust Lang has a Result, Swift has a proposal for a Result, and Kotlin has an implementation(although it does not provide customization for the Error type).
Oh, wait, I know you! You're the guy who developed Bus Time - an app with bus routes for my hometown.
Wow, Reddit was the last place on Earth I’ve expected to hear this.
Wow, thank you very much for looking at my code and suggesting improvements. :-) I still don't know a lot about Kotlin sequences. I think they are not always lazily evaluated as is the case with Java streams, right? So I was not sure where to apply them so that it makes sense. I have to read more about them. Anyway, I will definitely consider your suggestions for the next release. Thank you. And the logo... oh my, I think I will have to add some explanation to the readme. :D 
I'd guess latin? French is my mother _tongue_, and the word for language and tongue is the same: langue! It looks like it inspired English 😉
Very good! :-) Latin is the correct answer. 
This is interesting. I don't know how many times I've swept error handling under the rug as "yeah, I'll get back to this." Basically, checked exceptions suck, but their replacement is usually "TBD". I'll still take this scenario, however, where people just don't actively "swallow" exceptions. That at least doesn't hide errors, which is like "maturity level 1 - don't hide errors". But I do like thinking about error handling as "more mature". Seems like making sure we properly identify "panic vs handle-able" error conditions using exceptions vs sealed class return values is another layer of the onion, so to speak. 
https://docs.kweb.io/en/latest/faq.html#won-t-kweb-be-slow-relative-to-client-side-web-frameworks While hilarious, this would be an interesting blog article with a bit more detail. :) 
Yes, that's a placeholder ;)
Looks great for JS-haters . I've been building rich server side webapp for a long time, with wicket / vaadin , And it seems your approach is slick ... Hope there will be more progress. thanks.
Thank you! While it definitely does a nice job of quarantining javascript, my hope is that the way it deals with state will also prove useful. I still have to document it, but in short: you can bind the value of a DOM element to a specific value in your database, and have it update in realtime *automatically*. The animation on [kweb.io](http://kweb.io/) illustrates a very simple version of this.
It is interesting how other people react to different languages as I think Python looks messy. Though part of that is just the effort of interpretation. I think once you are pretty familar with Java that is is pretty easy to interpret what is happening because it is very excplicit. I still can't say I am 100% comfortale with Kotlins implicit types, not that they don't work, but more that my Java impulse kicks in. I say don't learn Java, but don't try to not learn Java. When you are learning Kotlin, you'll naturally be learning Java. Java honestly isn't that difficult to read once you get it. It's not like I am an expert in programming so feel free to ignore me, but I'd kind of drop the idea of trying to learn an language and instead focus on learning the system of how to program something inparticular. WIth android programming your focus should be learning the android platform, not java or kotlin. I'm not saying to ignore java and kotlin when trying to develop on android, I mean you can't, but more that you focus on android instead. Somtimes you'll find that the programming is completely outside your league and that you have no clue what is happening, inwhich case you then focus on that segment of the language. Honestly, the approach I've been taking is a combination of just in time learning combined with a course/textbook. I can explore whereever and learn what is useful to me in the moment, and I can fill in the gaps in knowledge with the course.
`Array(8) { Complex(0.0, 0.0) }`
Thanks a lot.
Or if your use case allows not creating the object N times (presumably because it's an immutable object): Complex(0.0, 0.0).let { c -&gt; Array(8) { c } } (don't listen to stupid IDE saying redundant let can be removed, the semantics are different)
It would probably be clearer to just create a local variable with the object instead of that nested abomination. 
Inspired by Haskell's `const` and Clojure's `constantly`: fun &lt;Result, Ignored&gt; always(x: Result) = { _: Ignored -&gt; x } val cinput = Array(8, always(Complex(0.0, 0.0))) Does Kotlin already have such a function in the standard library?
That gives you another name that's valid way beyond its intended scope of usage.
Beware that `async` in Kotlin is a very different tool than `async` in C#. In Kotlin it's intended for the special case of parallel task decomposition only, and should be used in a structured manner, within a `coroutineScope { }` block. The default in Kotlin is to just call the function, with no other syntax involved.
\&gt; The first runs on the web server, the second runs in the web browser You listed client first. Shouldn't this sentence be reversed?
The best project is one, which solves a problem you have. Otherwise you can try and make a 2D game with JavaFX/TornadoFX or even a console game.
A good first project is something which addresses your own personal need, for example, you'd like to have a diary, or a simple game, or anything. Kotlin itself is quite general purpose, just as Java or C# would be, and quite suitable for Android too, so, maybe a Kotlin Android app with a (Spring Boot?) backend service? Or make something silly, like a project idea generator ;-)
Find some good open api on the web and make a client for it.
Make a secret Santa program for your extended family which won't let you pick yourself, anyone in your immediate family, or someone you had last year. 
You could also use operator overloading to have something that looks more like math. Some example usages: ``` 0 * i 1.4 * i 3.5 + 2 * i 1 - 0.5 * i ``` The above requires several things: * constant i which is Complex(0.0, 1.0) * operator overloading function for multiplying an Int time a Complex which converts the Int to a Double and creates another Complex instance with the result. Similarly for a double * Operator overloading functions to add Int or Double to Complex and similarly for subtract.
This was always a stumbling block for me...needs to be doable for a noob but interesting and worthwhile..
What's worse, an immutable object that is available slightly outside the scope (but is available anyway as element of the array) or code that is unreadable because everything has to be functional?
This is a false dichotomy. The idiom's strength is not that it's functional but that it's self-contained. You think it's unreadable because you're not used to it. I think it's readable because I am.
Ah yes, thanks - that sentence was redundant so I removed it.
That's a fair point, on the other hand could should be readable not only by the author but by as many people as possible. I'm sure you'd have no problem reading the code if there was a local variable. 
I just reply to myself for this: I've just released version 0.2.1. Lingua actually outperforms Apache Tika for short paragraphs of text. All accuracy results can be found in a comparison table now: [https://github.com/pemistahl/lingua#library-comparison](https://github.com/pemistahl/lingua#library-comparison)
Close, but you can't have variance in the lambda's param types, so you can't make a lambda that accepts any arguments that I'm aware of. You have to explicit accept the single param. So it'd be: ```kotlin inline fun &lt;T : Any?&gt; always(v: T): (Int) -&gt; T = { v } val cinput = Array(8, always(Complex(0.0, 0.0))) ``` 
&gt; Does Kotlin already have such a function in the standard library? Nah, because you'd have to have it for every param count.
'Stable' version, yet half of the API is littered with Obsolete/Experimental annotations and actors are now marked obsolete (!?) with no active alternative available as far as I can see. Still don't think the 1.0 release has really happened yet.
Yeah, it's a bummer.
Whenever i'm learning a new language I make a basic CRUD (create, read, update, delete) using the same open API. I personally use swagger's [petstore API](https://petstore.swagger.io/): but it can be [anything really](https://www.programmableweb.com/apis/directory). The basic app features are login, create a pet, edit a pet, delete a pet, view a list of pets, search for pets. Once you have that then add persistence. In this case I would do an Android app and use their suggested [persistence library](https://developer.android.com/training/data-storage/room/). The great thing about building the same app using the same API is once you've done it a couple times you naturally focus more on the language and frameworks and less on the app's features, business-logic, etc.
Actually the proliferation of local variables does make my life harder. Each variable declaration creates another vertex in the graph of connections between parts of code. I have no idea when, where and how many times it will be used; I don't understand its purpose in the block of code until I have spent enough time analyzing all its use sites. I prefer a local variable to an inline expression if it's quite long and complex and there's a nice name that captures what it is. I don't mind a local variable in a short method. But for anything more than 10 lines of code, I strongly prefer self-contained statements that do their part of work and explicitly show there are no dependencies to them from the later parts of the block. That's why I came to love Kotlin's `also`, `let` and friends. Code reading is a skill you have to acquire and this applies to each new idiom you encounter. You can't decide whether the idiom is readable or not until you have given it a chance by using it many times, even overusing it while learning. Of course everything you're not familiar with is unreadable -- to you.
If you don't mind kotlin-js you could create a browser extension that is useful to you. There is a video of a talk from kotlin-conf 2018 to get you started. Or you could play [screeps](http://www.screeps.com), an mmo-rts played by writing code [starter project](https://github.com/exaV/screeps-kotlin-starter) If you want to stick to the jvm then there is [kscript](https://github.com/holgerbrandl/kscript) a library/runtime that lets you write scripts in kotlin, which is nice because there is always something to automate with a script.
Kotlin can stand on its own: No need to learn Java first. Kotlin is a newer language that takes advantage of some technology that was first developed for Java, but that technology is also used for other languages (like Scala and a version of Python) and those languages don't require learning Java first either. The [**Java point Tutorial**](https://www.javapointtutorial.com/2017/11/about.html) is designed for students and working professionals. Java is a high level, robust, secured and pure object-oriented programming language. 
Kotlin can stand on its own: No need to learn Java first. Kotlin is a newer language that takes advantage of some technology that was first developed for Java, but that technology is also used for other languages (like Scala and a version of Python) and those languages don't require learning Java first either. The [**Java point Tutorial**](https://www.javapointtutorial.com/2017/11/about.html) is designed for students and working professionals. Java is a high level, robust, secured and pure object-oriented programming language.
This heavily depends how well versed you are with other object oriented languages and frameworks. But I would go with something that I personally use - when I wanted to learn a little bit about microcontrollers and electronics, I had built an alarm system with movement detection and NFC readers. &amp;#x200B; This is a very good resource to find project ideas: [https://www.reddit.com/r/learnprogramming/comments/2a9ygh/1000\_beginner\_programming\_projects\_xpost/](https://www.reddit.com/r/learnprogramming/comments/2a9ygh/1000_beginner_programming_projects_xpost/)
I recommend writing out a list of 5 - 10 problems that you've had in work, school, or in general. Go through the list and see if you can come up with an app that helps solve one of those problems. This usually leads to an app with a relevant and clear purpose that keeps you interested. For example, I used to work at an asset management firm that needed to show investors statistics and distributions from their portfolio of bonds, which could range from several to hundreds of different bonds. I made a simple app that reads bond data from a CSV file and prints out: * totals by par, original cost, amortized cost, market value, and accrued interest * averages by yield and maturity * bond distributions by security type, maturity, and S&amp;P rating The app uses a simple command line interface. Link to the [source code](https://github.com/xiao-vincent/Portfolio-Analysis) if you're interested. Happy coding!
These are places with app ideas: * [https://iwishtherewasanappfor.com](https://iwishtherewasanappfor.com) * [https://www.fiveideasaday.com/](https://www.fiveideasaday.com/) Have a look to find something that interests you + seems relatively doable :)
I started by porting an older Java project, then refactored and improved it. I really liked the experience thanks to great tooling. Kudos to the Kotlin team.
Web scraping with JSoup! That way you don’t need to learn a huge framework like Android but instead you can focus on furthering your knowledge in Kotlin, You usually only need JSoup, SQlite API for storage, and the Executor API for parallel scraping.
In many ways It's the same kotlin you're familiar with from targeting the JVM. But aside from the libraries provided by Jetbrains the ecosystem can feel very different. My first kotlin front-end project encountered quite a few struggles as I grappled with how to provide correct &amp; usable type definitions for Javascript libraries. You won't be able to avoid learning things like the DOM or CSS or the various conventions, idioms, and idiosyncrasies of Javascript libraries. Might be worth reading up a bit ahead of time but for an experienced programmer like you, well, you'll learn what you need to when you need it one way or another.
If you don't plan to use javascript libraries (which I highly recommend) then you should be fine without it. What you need to learn is the DOM API and related tech. Look gor Kotlin multiplatform libraries.
While the docs are rather limited and simplistic I have found them to be more than sufficient for anything I have had to do. I haven't really used the stdlib docs, but the language reference documentation has been enough to learn to use Kotlin, coming from a Java background.
Fork -&gt; Improve -&gt; PR To just complain is cheap. If you think there's space to improve, point it out and better yet, be part of the improvements. Saying something sucks is just mediocre. Specially if you're using Kotlin because you want and not because you have to.
Does the progress listener fire only once or multiple times? You might consider using a channel in the case that multiple progress messages are send. Otherwise can you expand on the case that both callbacks get called. Is it because progress occurs and then fails? Do you have documentation/source for UploadTask?
I find the ktoc satisfactory. You can have them pop up in IDEA.
If it's stdlib that's bugging you, try just clicking through to the actual implementation. Reading functions like `apply` and `forEach` etc. is helpful because not only will you see what the function does, but you'll learn to read Kotlin code faster and see how good code is written, too.
Your comment is like what you are complaining about.
Here's the class doc https://firebase.google.com/docs/reference/android/com/google/firebase/storage/UploadTask The method progress method can fire multiple times until the task completes. This means that failure can be called at some point after progress has been called. Using a channel actually would be better since progress is a stream of results. However there's still the case of failed, complete, success called backs but I may be able to consolidate them under the on complete listener and check the status of the task. 
Documentation is not a tutorial. 
As u/kaffinator said, I'd recommend reading the implementation yourself, I find it to be the greatest way to understand what an API is doing, period, in fact it's one of the first things I recommend, get used to Ctrl-Click and reading through the source material which itself will include the documentation which is nice (never again will you have to visit the site or even use the Documentation pop-up) An example of when this was invaluable is when I needed to understand what `toList()` was doing was it returning a copy of the Collection so that I can modify it freely or was it just returning it as a List, meaning changes to the list would be reflected on the original Collection, something that annoys me with the Java Collections sometimes. A quick read through the source code gives this: This is in \_Arrays.kt `/**` `* Returns a [List] containing all elements.` `*/` `public fun &lt;T&gt; Array&lt;out T&gt;.toList(): List&lt;T&gt; {` `return when (size) {` `0 -&gt; emptyList()` `1 -&gt; listOf(this[0])` `else -&gt; this.toMutableList()` `}` `}` alright then what does `this.toMutableList()` look like? &amp;#x200B; `/**` `* Returns a [MutableList] filled with all elements of this array.` `*/` `public fun &lt;T&gt; Array&lt;out T&gt;.toMutableList(): MutableList&lt;T&gt; {` `return ArrayList(this.asCollection())` `}` &amp;#x200B; Damn it literally just creates an ArrayList with the elements of this Array in it, as we would all do, so it does return a new List that I can safely modify without affecting the original. &amp;#x200B; This is just a toy example of course but it did actually happen, you'll find reading through source will also help you understand the abilities of the language better as well as the idiomatic ways of writing. &amp;#x200B; **TL;DR** read through the sources &amp;#x200B;
The problem is that if it isn't documented, there is no contract and the next kotlin version might do something completely different. And lots of stuff really isn't documented, for example what happens when calling `"Hello".get(42)`.
Growing pains at best, IMO. I think they need to make Dokka more mainstream, though, didn't even know it existed until yesterday... I've been using kotlin since Google IO for reference.
This isn't something that you can fix with a few simple PRs. Lots of stuff is probably intentionally undefined (and thus undocunented) as the implementation differs between the Kotlin JVM, JS AND native implementation. 
I dont get paid for writing comments.
Both get the same response so, whoosh!
Good points. My guess is that the documentation is minimal on purpose so that there is clarity on the contract. Use cases, examples, etc might clutter that up.
I tried to avoid JS but that's not possible. If you want to use JS/TS libs with Kotlin you need to know at least the basics of npm, node, webpack or bable.
How do you expect the caller to interact with this. Let's strip it down to just the happy path. Suppose you had this: suspend fun UploadTask.await(): Long { return suspendCoroutine { cont -&gt; addOnProgressListener { progress -&gt; cont.resume(progress.bytesTransferred) } } } So the caller would say something like: val progress = myUploadTask.await() When `await` is called, the current continuation is suspended. Later, when the `OnProgress` event fires, that original continuation is resumed and, from the callers point-of-view, `await` returns some number. Now what? Since the `OnProgress` event can presumably fire multiple times before the upload is complete, the caller would have to "pump" the await loop. You would need some sentinel return value to indicate "the operation has completed": while (true) { if (myUploadTask.await() == 0) { break } } //do the next thing or maybe while (myUploadTask.await() != 0) { } //do the next thing Is that what you want? OK, suppose that's what you want. Now, every time the client code calls `await`, another `OnProgress` listener will get registered (`addOnProgressListener` is called every time that `await` is called). That's almost certainly not what you want. Whatever you end up doing, you probably want to register the callbacks just once - probably before the first `await` call. Also, you'll want to make those callbacks "smart" enough to not both try to resume the same continuation. When a callback decides to resume a continuation, you need to ensure that *no* subsequent callback can attempt to resume the same continuation. And if a callback is fired when nobody is `await`ing, you'll need to stash that notification for later. It's also worth mentioning that your continuation will be resumed on your callback's thread. So if you're currently running client code in some Thread A, and that code calls `myUploadTask.await()`, that call to `await` will likely resume on some other thread B. Depending on what you're trying to do, that might or might not be desired.
Thank you for the the insightful reply. &gt; while (myUploadTask.await() != 0) { } //do the next thing Is that what you want? I certainly do not want this. Another commenter mentioned channels. From what I can tell, they would be ideal as the on progress update fires multiple times delivering data. I expect the calling code to await to get the value to use in the UI. However, if channels would allow me to to stream data from the multiple progress update calls that would be ideal. I also want to bubble up the exception if the task fails. So client can expect await to either give them a value or exception. I agree, if I plan to register multiple callback listeners then I'll need to mold the functionality so that only one callback can resume the continuation. The example code that I saw had the callback return value as a sealed class which contained child callback status. Here's a rough snippet (disregard minor syntax errors) : `sealed class NetworkCall class NetworkSucess(val data: T) class NetworkFailure(val error: Exception) ` So that code could easily integrate a callback and based on the type, chose what to do with the continuation with one extension function. The callback api in using does not and I don't own that code. &gt;It's also worth mentioning that your continuation will be resumed on your callback's thread. So if you're currently running client code in some Thread A, and that code calls `myUploadTask.await()`, that call to `await` will likely resume on some other thread B. Depending on what you're trying to do, that might or might not be desired So suppose the await is called by the client in an IO context coroutine but the callback returns on the main thread, how would I switch back to the thread the client expects to be in? 
Continuations can only be resolved once, as they memoize. If you want multiple returns you need to tinker with internal state. Roman is aware of this and already proposed a solution to serialize and deserialize coroutine state to allow "resetting" them.
I used channels but if I try to publish the value to the channel I get an error since the callback lambda isn't a suspend fun. Not sure how to get around this. I'll probably just have to use Rx. 
This is one of the best ideas! one of my first projects outside of modifying existing code was to create an item parser\editor for the game "Fate: The Cursed King"! Had to identify patterns, how to parse the plaintext document all the item info was in and how to break them up so I could edit them each individually. Then I had to figure out how to work with the command line (and later make a gui) and finally, format what data I had back in to the original format and still be readable, but with the new edited values. Granted, it was in python.... but the same idea applies to learning nearly every language if you aren't familiar with programming.
Can you give any examples on specific issues you've had with it?
The convention I use in my codebases and that seems to be used in the stdlib is that `asX` returns a view of the contents and `toX` copies the contents.
I tend to agree for the coroutine docs. The docs are not easy for ordinary developers.
In general if I'm unsure about how to use a function, I need to search for an example on how to use it, on an other side. 
In which way are you importing that?
I've had no problem importing type aliases from other packages, even from a library. Make sure the type alias is top level in the file
I have begun to implement a LISP in Kotlin according to the guide from https://github.com/kanaka/mal
I went back to double check, and it turns out I tried to import the wrong package (because it was named very similar to PkgB). Everything works now, Thanks for the suggestion!
So the right place to use continuations is when you want to allow the client to write straightline (i.e. not callback-based) code that is periodically suspended and later resumed. That could be for any number of reasons. The [`sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/sequence.html) and [`iterator`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/iterator.html) factory functions use continuations to lazily compute their elements. The kotlinx.coroutines library uses them so that functions like [`delay`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html) and [`receive`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html) don't block the current thread. Compare with JVM analogues [`Thread.sleep`](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#sleep-long-) and [`BlockingQueue.take`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#take--), which do block the current thread. If your case, the question really becomes one of "how will the client use your library?" Even if you were to use channels, the client code would *still* need to pull items from the channel in a loop: messageLoop@ while (true) { when (val message = channel.receive()) { is Progress -&gt; //handle progress is NetworkSuccess -&gt; { //handle "upload finished" break@messageLoop } is NetworkFailure -&gt; { throw Exception(message.error) } } } This is necessary to avoid blocking the continuation that's ultimately trying to `send` messages to that same channel. If this continuation doesn't `receive` those messages promptly, then the buffer between the sender and receiver will eventually fill up and the sender will become suspended. Ultimately, the question is really "does the client care about progress messages"? If not - if the client only cares about the eventual success or failure - then you don't need to use channels at all. If they do care about progress messages, then they're obligated to receive and process every message, whether you choose to send them via channels or not. &gt; So suppose the await is called by the client in an IO context coroutine but the callback returns on the main thread, how would I switch back to the thread the client expects to be in? All the code that you've shown so far is dealing with "low-level" stdlib continuations. You are responsible for ensuring that you resume the continuations on the correct thread. You can do that with any mechanism that is provided by Java - e.g. [`SwingUtilities.invokeLater`](https://docs.oracle.com/javase/8/docs/api/javax/swing/SwingUtilities.html#invokeLater-java.lang.Runnable-), [`ExecutorService.submit`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html#submit-java.util.concurrent.Callable-), or something of your own design. However, if you work with the higher-level [kotlinx.coroutines](https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/README.md) library, you have access to a number of [`CoroutineDispatcher`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html) implementations. In your case, the [`Main`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html) dispatcher can be used to resume on the main thread (note: read the docs; you need additional runtime libraries to make this work). When you work in the kotlinx.coroutines world, you do *not* need to call `suspendCoroutine` yourself. You'll always use one of their suspension functions (like the aforementioned [`receive`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html)). The kotlinx.coroutines infrastructure uses the dispatcher that you chose to ensure that your continuation is resumed on the correct thread - it will call `cont.resume` in the right context. I'm not super familiar with kotlinx.coroutines - I've spent more time with stdlib coroutines, and with the experimental versions no less. But Roman Elizarov had written some blog posts about how some of the kotlinx.coroutines functionality is supposed to work. [Here's one of them.](https://medium.com/@elizarov/structured-concurrency-722d765aa952) You can research `CoroutineScope` and `CoroutineDispatcher` to learn more.
&gt; Continuations can only be resolved once Correct. &gt; as they memoize They what now? Usually "memoization" refers to storing the result of some operation the first time it runs so that we can save time when that operation is invoked in the future - we just return the result computed initially. Kotlin stdlib continuations aren't reusable at all at the moment, so I don't know what you mean by "they memoize". Are you thinking specifically of [`Deferred`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/index.html)?
Correct. You can only call `suspend fun`s from within other `suspend fun`s. Kotlin's coroutine ecosystem is a sort of "all-or-nothing" situation. If you want to invoke `suspend fun`s from within one of your functions, then you have to make your function a `suspend fun`. Then all the callers of your function also need to become `suspend fun`s. You eventually reach some bulkhead where the caller invokes your function in a fire-and-forget fashion, at which point you can instead use some coroutine initiation function (like [`startCoroutine`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/start-coroutine.html) or [`launch`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html)). 
Yep, thanks for the correction
Either you're trolling, or joking. 
well, you combine both really
You can cover most use cases with a function that takes one argument 
Interesting, but why not use the framework SortedList and SortedList.callback to handle the changes?
Ya . We can use. Both SortedList and DiffUtil does the same job, though there are certain differences between these two in terms of performance, flexibility and other aspects
A `Files` has only one String field, not a list, and a `Dirs` has only one `Files`. I would guess the error is that it can't construct one object from a list of them.
Your problem is not that both callbacks are called, but that the contract of `UploadTask` is not about continuing when some async result is ready. It is about receiving a stream of events that continuously report the upload progress. If you want to use this callback just for the purpose of resuming your computation once the upload is done, then write return suspendCoroutine { cont -&gt; addOnCompleteListener { _ -&gt; cont.resume(Unit) } addFailedListener { e -&gt; cont.resumeWithException(e) } These two are mutually exclusive and won't be called both. Otherwise, if you want to react to fine-grained progress reports, then clearly you can't express this as a single step of coroutine suspension and resumption and you need another programming model, like channels.
The major part is done, though. I've been a very happy user of coroutines for a whole year now, they were production-ready even before the release. Channels, actors and other stuff are just further features you can build on top of coroutines. For non-blocking programming, the major use case, everything is mature.
IMO actors are for a pretty standard user case - sequential non-blocking processing. I'm anxious about API stabilization.
Thank you. Yes I'm aware I could use those to signal completion or failure. Using channels is a nice idea but I may just use rxjava since it's probably better suited for the task. 
Basically if I had a java object for your two data classes and serialized it, it would look like {"name": "110_0212", "files": {"files": "onlyonestringpossible" } } To match up with your json I'd expect something more like: data class Dirs(val name: String, val files: List&lt;String&gt;)
What I came up was `data class Directorys(val dirs : Dir)` `data class Dir(val name : String, val files : ArrayList&lt;String&gt;)` But Klaxton is still not able to work with. Do you think that one class is enough? I will give your structure a try.
If you generate the json and the classes you can do whatever you want. What's important to note with deserializing with libraries like Klaxton is that any instance of a class WILL be enclosed in '{, }'s when serialized. Thus in your new case you have { "dirs": { "name": "somename", "files": ["string1", "string2"] } } Basically we can look at the raw json you have and look at the kinda of objects enclosed by "{, }"s, and those are the only class objects we actually have. The entire raw json is summarized with the following classes in the simplist form: data class ResponseObject(val errCode: Int, val errMsg: "String", dirs: List&lt;Dir&gt;) data class Dir(val name: String, val files: List&lt;String&gt;) When developing with anything regarding serialization, I try to include unit tests, but even more on the fly I make a kotlin scratch file, make some instance of my class, and serialize it to string to see what that will actually look like.
Could you provide some examples? Thanks
val array = arrayOf(1,2,3,4,5,6,7,8,9,0) array.filter { it%2 ==0 }.forEach{ println(it) } This could be used instead is looping through each element in the array, using if statement and printing the elements
Java's Streams are just as good for this example aren't they? But I do agree with you, Kotlin is a great language :)
Are you still looping? 
&amp;#x200B; It works like expected with your suggested changes. Thank you! data class Dir(val name: String, val files: List&lt;String&gt;) [..] val klaxon = Klaxon() val parsed = klaxon.parseJsonObject(StringReader("$text")) val dataDirsArray = parsed.array&lt;Dir&gt;("dirs") val responseDirs = dataDirsArray?.let { klaxon.parseFromJsonArray&lt;Dir&gt;(it) } for (i in responseDirs!!){ Log.i(TAG, "for loop : ${i.name} ${i.files}") for (j in i.files) { Log.i(TAG, " inner for loop $j") } } &amp;#x200B;
Looping through what?
I don't know Java so I can't use Java streams therefore using Kotlin is the only option I have
&gt; Looping through what? looping for a while :) it's a FP joke
Use asSequence() after the call to arrayOf(). This will also reduce object turnover, as each call in a non-sequenced pipeline will return a new collection.
The advantage, in my opinion, is that it's a lot easier to make ad-hoc collections for looping in Kotlin versus Java with the ____Of() assortment of functions. Coming from Ruby, it's a pleasure to see this capability in a language that has stricter typing than Ruby does
You can make the constructor private and then only call it from your companion object. data class ABC private constructor( val a: Char, val b: Char, val c: Char ) { companion object { fun create(a: Char = 'A', b: Char = 'B', c: Char = 'C') = ABC(a,b,c) } } fun main() { val a = ABC('a', 'b', 'c') // invalid val b = ABC.create('a', 'b', 'c') // valid a.c // 'c' a.c = 'd' // invalid }
Treating platform types as always-nullable is silly. The reason why they’re different from nullable types is precisely that you don’t actually statically know whether they are nullable or not. What you really *should* be doing is learning what’s on the other side of the fence. As an example: I use Undertow as my web framework of choice. Routes are handled by [HttpHandlers](http://undertow.io/javadoc/1.3.x/io/undertow/server/HttpHandler.html#handleRequest-io.undertow.server.HttpServerExchange-). The argument to that handle method can never, ever, be nullable. Adding null validation in my handlers is redundant, and leads readers astray. 
The *Of() functions are great for hard-coded data but don’t see that much use in the real world — there is a reason we still use those instead of having some sort of collection literals.
They’re about on par, yes. I find that first class function support (both as anonymous functions or function references) is better in Kotlin, though, which makes a big difference. 
List.of(1, 2, 3, 4, 5).stream().filter(i -&gt; i % 2 == 0).forEach(System.out::println); Just as easy imo. 
So if im understanding correctly, not using sequences on kotlin collections iterates them for each operation called? And a sequence is much like a java stream?
Yes, it creates intermediate collection on every step. So if you initial collection if quite big and proceeded through several transformations - use asSequence to evaluate it lazyly like with Java streams. Or just use Intellij Idea - they added code suggestion in Kotlin plugin for such cases recently. 
The project files (.idea directory) shouldn't be submitted to github because that's dependent on the version of IntelliJ that you have installed. I generally also don't submit the built results (eg. class files or jar).
You can use `Stream.of(1, 2, 3, 4, 5)` to skip a step
what warning are you seeing in intellij? I don't get any warnings for an internal class or data class
One addition to this - spend a bit more time and look through not only ctrl+clicked method but whole containing file. You will be surprised how many gems are hidden in Kotlin standard library. 
I agree with this 100%! :)
It made writing complex algorithms actually fun and concise.
&gt;don’t see that much use in the real world Coming from Android, these are used in some areas. For example, you feed the data to adapter for spinners as an array so you use arrayOf()
In this case sure, but there’s a few things that make these kinds of things quite a bit nicer in kotlin. The convention allowing () to be removed when the last parameter is a lambda, implicit it, no collector required, no stream(), etc
Ah interesting. TIL.
I recommend publishing it to mavencentral instead of asking the dev to build it
&gt; As Kotlin developers, we love designing method contracts around non-nulls, avoiding optional types as part of the parameter signature. This whole paragraph is false. Kotlin gives you confidence in using null. Optionality is a ubiquitous concept that is orthogonal to default values. And it goes on to assert that null checks aren't idiomatic?!?
It was one of the first things I learned in school, and I always have a hard time using languages that don't have a good stdlib of higher order functions like kotlin, or that make them syntactically hard to use 
Imo its just as difficult (not that either is). The difference between () and {} is negligible, and you'll need asSequence() instead of stream(). The only advantage I see is implicit it, which doesn't make it any easier to write.
Except in Java you need to do [array.stream](https://array.stream)() and then collect(Collectors.toList()) if you need the result and not only the forEach(System.out::println)
I still haven't reached my base case :(
I am very glad you can usually just remove the ! from a function parameter or explicitly state the type of a variable instead of using inference. It would have been madness if Kotlin forced you to deal with platform types all the time.
All of these small subtle features kotlin has contribute to making it a really pleasant language to work with. I develop in Java full time, but work on an open source project I wrote in kotlin and really enjoy working with it. 
I wish the brackets in kotlin's lambdas were optional :(
You might already know some of this bht I thought I'd share it jn case it might be useful. For versioning, you usually want to stick to a consistent and clearly reasoned pattern. The most common might be Major.Minor.Path. A Major version change is where you're changing things significantly with regards to your projects api and how devs interact/use with your library. These could be/often are "breaking changes" and an evolution of the project meaning upgrading the version you're using would render compilations error. A Minor version change is typically for adding new functionality/options or a larger update that contains many bug fixes or changes. This version change should not affect existing functionality and shouldn't cause errors when you upgrade. A Patch version change is typically used for smaller bug/fixes that you push out quicker, more so in between "regular" planned updates that you might planning and working towards. Secondly, as another user suggested, you should look at publishing and distributing your library through a public repository. Maven central along with jCenter is the default supported and recognized repo. If you want a quicker/easier way until you figure things out you could look into jitpack as well which will grab your project from your github repo. Thirdly, you can look at the .gitignore plugin available for intellij that helps with setting up flexible .gitignore files that you can create using check lists for your projects features.
Nice that you enjoy Kotlin. I love it myself ... but ... having studied Functional Programing in college a while ago(and been teacher assistant for a while) ... I cannot help myself but to point to the actual definition of functional programing: https://en.m.wikipedia.org/wiki/Functional_programming Kotlin is not a functional programing language :)
I develop full time in the equivalent of java 5. Kotlin would be a dream for me tbh. 
We just moved to Java 8 (from 7) like 2 months ago, it’s been nice!
Honestly I have never seen this API before, but looks great! Saving this post:)
Glad to hear that! :)
If you're using a good IDE, yes.
I'm using Android Studio 
I'm pretty sure it's part of the intentions menu 
Yeah shift-enter maybe? It's one of the light bulb suggestions.
Not sure about when, but there is an intention to fill out a switch statement with all of the case statements based on an enum.
`'public' function exposes its 'internal' return type RadicalObject`
Thank you all. Highlight the 'when', then press Alt-Enter 
Looks nice! Will definitely try it in my new little project and hopefully give some good feedback in a few days.
Thanks, I would really appreciate that 
Looks cool! I especially like the animations when the fab moves from center to the right.
Swift was against ObjC which is described C++ inspired by Java. Those who have used ObjC and Java both, agree that ObjC is faster in runtime (because it runs natively instead of JVM) and also in development time (because it is support functional programming and other features). But in my opinion swift is a solid language and some may even say that it is better than all the other languages in this discussion. I agree with the point that it is unstable now, with every new version there are breaking changes. But I can clearly see why. Swift 5 is going to be released in 2019 March, and it is focusing only on feature i.e. ABI stability. Currently Swift is not ABI stable, so each binary (App), bundles its own version of the Swift Dynamic Library. Swift doesn’t live on the iOS Operating System, it lives within each App. This means that Swift will be binary compatible, bundle sizes will be small and precompiled libraries can be used. I can safely say, that swift is about to become a matured language in 2019 with less frequent code changes. So, up until now I totally understand why big enterprises were better off in ObjC world. But from 2019, every new iOS/macOS project can be done in swift without any issues. Also, swift is now a general purpose language, with Apple officially supporting projects like SwiftNio, swift getting REPL support and official SwiftPackageManager puts swift in the league of python. Swift 5 will only lack one major feature i.e. async/await and actors, which are present in python. Swift has not won yet. But everybody knows ObjC days are numbered. On other hand JAVA is one of the most popular language on this planet and Kotlin has recently got official recognition. Kotlin should follow swift, and focus on becoming better by evolving. It should not care about wooing developers by becoming stable. It has the potential to beat Java, and even if it does everything right, it can only replace Java in 10 years from now. Java is no ObjC, it is ubiquitous. It can be defeated, but cannot be destroyed.
/r/abreslav /r/chocolategirl 
That is from the official component 😁
try kotlin koans and the official doc
I like it a lot. Seems pretty flexible. If I am going to complain about anything after a quick glance it is that the package clutters up the namespace with some util extensions. getColorCompat() is a great extension function but it isn't one I need from the library. There is some other functions as well. Normally it isn't a issue but it could result in it.
Thanks you, very appreciated the hint 😊 I'll make a check and hide lib-related utilities 
It doesn't explain the basics
Start with really simple stuff, but try and cover the areas of: * Displaying stuff on screen - "Hello world" * Reading input - "Hello &lt;Your name&gt;" * File I/O - "Welcome back, &lt;Your name&gt;" * Date manipulation - "Today is 25/12/2018 or Tuesday the 25th of December" This covers quite a bit of the basics, but you also have the kotlin katas from jetbrains, but if you are really new, they might be a tiny bit impenetrable.
Kotlin koans are here for that : https://kotlinlang.org/docs/tutorials/koans.html
First, you need to learn Java. Then you can read books about Kotlin full of “this is like Java” parts. &lt;/sarcasm partly&gt;
Read the best book "Kotlin in Action" from Kotlin creators. It's quite exhaustive.
OkHttp supports websockets. You could use Retrofit for the rest calls and share the http client. https://square.github.io/okhttp/3.x/okhttp/okhttp3/WebSocket.html
There is a nice course of Kotlin on Udacity 
There's also tinder/scarlet for sockets
Ktor.
Btw, both on server and client side
Just opened this issue 😊 thanks again for your contribution https://github.com/4face-studi0/MaterialBottomBar/issues/7
Snarky but there's truth to it. Kotlin is certainly not my first programming language, and in learning it I've been surprised by the number of times in my introduction to it that things are just sort of passed over because the authors assume you know that part of working in Java. There are things I'm definitely liking about Kotlin but I would be reluctant to recommend it as a first language for this reason. I'm glad the Kotlin Koans are there for the elementary language concepts, but it stops short of some practical things you need for even small working projects, like managing your namespaces, dependencies, and build process.
It’s nice thatKotlin still has currying too. Swift got rid of it for some strange reason. I’m guessing it conflicted with most of the other parts of the language.
What about val arr: Array&lt;Int&gt; run { val c = Complex(0.0, 0.0) arr = Array (8) { c } } ?
Yes, I like it, too. But I'd definitely simplify to val arr = run { val c = Complex(0.0, 0.0) Array (8) { c } } 
Looks like a winner to me 😄
I second that. On top, ktor is developed by Jetbrains, the company that builds IntelliJ and Kotlin, hence you can expect great adoption and documentation. 
For HTTP I usually use Fuel, not sure if it supports sockets
in KotlinConf 2018 - Conference Opening Keynote they talked about Ktor. and it also is at higher rate in [github](https://github.com/ktorio/ktor) than javalin or jooby or etc . if you want a reliable web framework in kotlin i think these are some important points to keep in mind.
Koans are *terrible* for someone who's completely new to programming.
For Android, I would recommend Retrofit
As an alternative, you can download an existing app template written in Kotlin (such as those offered by instamobile.io), and try to read the code and make incremental improvements to it.
I learnt Kotlin as my first language by following a course on skillshare
There is only one correct answer. Scarlet.
Exactly what I feel
Kotlin JVM runs in a Java Virtual Machine. JS translates kotlin to JavaScript code. Native is just native code, just like most compiled languages. And mobile I believe is JVM with additional frameworks.
Happy Cake Day Turtvaiz! Don't be pushed around by the fears in your mind. Be led by the dreams in your heart.
Kotlin JVM is standard Kotlin, runs on JVM, basically its Java with a different syntax and language features (to put it very simply), also you can convert your \*.java files to Kotlin (or the other way around) in Kotlin JVM Kotlin JS, although I haven't tried it myself, I guess changes your Kotlin code to JavaScript when you export (probably gives you an kotlin.js? I'm not sure). Kotlin Native is exactly what it says, Kotlin native. Your code would no longer run on JVM (instead its LLVM) and you will get a native binary when you export. I did not know about Kotlin for iOS, but Kotlin Android is basically you writing your android app in Kotlin instead of Java, Kotlin is officially supported for Android. &amp;#x200B;
Kotlin code can be compiled to different execution platforms. What do you intend to do with your code? If you're using only kotlin and want to build a binary for execution on your computer, you could try kotlin native. But the easiest way is probably to follow the getting started guide and run on the JVM (java virtual machine): [https://kotlinlang.org/docs/tutorials/getting-started.html](https://kotlinlang.org/docs/tutorials/getting-started.html)
Kotlin JS transpiles your code to javascript. Which you can then run in the browser or in nodejs. It is like if you had written your code in Typescript (you get js-file, sourcmaps etc) except that your js file additionally depends on the kotlinjs library. LLVM is not another vm like the comment seems to suggest. Kotlin native emits LLVM intermediate representation which is compiled into a native executable (.exe on windows) by the LLVM compiler.
You can actually use .forEach() on collections (It's part of [Iterable](https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html)), but to filter, map and other shenanigans, you have to go into a stream, unless you put that logic inside your forEach lambda.
The line between functional and non-functional languages is sort of blurry at this point, don't you think? Kotlin, Java and others have functional features, and no language out there is 100% pure. In my mind, the question isn't "Is this language functional", but rather "Does this language allow me to write functional code". Kotlin has functions as first-class members, it's collections natively support streaming operations, it's data classes are super simple and useful, and you can write curried code, CPS and tail-recursion to your heart's content (though, you probably wouldn't since there are easier ways to get things done). What are you missing, to consider it a functional programming language?
Not really. A functional "program" is a program were the computation is completely declarative, by applying functions on top of functions, and NOT having any side effect. Same input implies same output, always, mathematically. Kotlin has functions as first class members, yes. It has streams, and everything you say, and that is why I love it. But from there to say that is a functional programing language is just plain wrong. None of the constructions that you have named make it even closer to being functional. Those constructions of the language may be inspired by functional constructions (or maybe not ... check Smalltalk and you will have a whole set of similar constructions on a purely Object Oriented language) All these constructions can cause side effect, just by having a variable that can be assigned to a value, you are having a state change (a side effect). From Wikipedia: " In computer science, functional programming is a programming paradigm—a style of building the structure and elements of computer programs—that treats computation as the evaluation of mathematical functions and avoids changing-stateand mutable data. It is a declarative programmingparadigm, which means programming is done with expressions or declarations[1] instead of statements. In functional code, the output value of a function depends only on the arguments that are passed to the function, so calling a function f twice with the same value for an argument x produces the same result f(x) each time" Read the Wikipedia link I posted, and then you will see how everyone miss-use the term functional programing. But just cause everyone miss-use it it does not make Kottlin more functional :). Haskell is a purely functional language if you like to dig deeper :). 
That's simple exercises that explain specific points of the language. I thought it would be nice for a newbie... I learnt programming 10 years ago, that's hard to know what is nice for someone that discover programming.
Retrofit if you are on android.
Why do you have to select one? You should choose whats best for the job. Go for backend, Kotlin for android If you really have to choose one, choose Kotlin. Its much easier and better supported to use Kotlin for android instead of Go
It's just time crunch that's it. What is your opinion on Spring + Kotlin for backend?
Do you not know both languages? Unfortunately never got the time to try any java/kotlin web server frameworks yet
I don't know any language :p, I will learn, I am experienced in java and have experience in dropwizard framework for backend.
It's great! With spring boot and Kotlin you can stand your backend up in a matter of minutes. 
Go is a simple language to learn, there isnt a huge amount to it. with some proper dedication, you could learn it to a productive level within a week either way, id use kotlin for android over anything else any day, even as a diehard Go fan
Because time seems to be the primary factor, build the backend in whichever language/framework that you already know and are comfortable with. It sounds like you may have more experience with Go than Kotlin. It doesn't matter if the backend is written in Go, PHP, Node.js, etc..., it will be more than enough to get you up and running. Regardless of language, scaling is mostly done through caching and multiple servers.
Spring + Kotlin its the standard, if you design it well its quite flexible Spring also has a lot of starters so its fairly easy to setup, just use the initiliazer https://start.spring.io/ (or the same thing on Intellij Idea) and you have a base where you can get started
Thank you, I just feel like Go has very few libraries, but Kotlin can use all the power of java and can use Spring framework, which apparently is very powerful. What is your opinion?
Java frameworks are gonna have the batteries included. Go might be easier to program but you are gonna have to hook up more stuff. Personally, I use Netty and Kotlin for work. Spring doesn't go low level enough for what I'm doing.
Hey, irrelevant question but why are you using KTOR over spring with Kotlin, any reason?
Really hard to help without the project. I think you somehow have a messed up project structure. Publish to gitlab.com?
Libraries debate very much depends on what youre wanting to do. when it comes to web backend, youll find most of what youd generally want with Go. People have no problem adopting Go for web backend
Thank you, was mostly concerned about that.
While the Go language is great, the go ecosystem is... strongly opinionated, not always for the best. One example: It’s taken years to acknowledge they need better package management and versioning, which is something that’s existed in pretty much all other language ecosystems for a long time. With Kotlin, you can rely on a very mature and broad JVM ecosystem. Or roll your own. I end up doing a mix of both depending on the problem. The only drawback for Kotlin IMO is serverless application development. It’s a _little_ easier to throw together serverless apps using Go since you don’t deal with JVM warm up and huge package sizes. But it’s not a deal breaker. 
&gt; You should choose whats best for the job. It doesn't work that way in this situation.
why not? an explanation would been nice :p
Just create a new maven project and add the ktor dependency in your pom file. I've never used the intelliJ plugin nor the star.ktor project builder thingy. But if those things don't work then just make a new project the old fashion way. If you're trying out alternatives to spring then maybe look at Micronaut(http://micronaut.io/). Ktor has inadequate documentation (imo) and its only benefit is coroutine support. Micronaut feels like spring boot but less bloated.
The argument in itself is stupid. But even If we close eyes on that, in this case both Go and Kotlin are more than capable to do the job.
I created about 10 projects using IDEA plugin and didnt have any problems with it. Could you please download your project to GitHub and share a link?
i wouldnt recommend to people to use Go for an android app over something with native support like kotlin, kotlin has is clearly and undeniably more capable of doing the job there, especially given the go-mobile repo is still marked as experimental
&gt; I wouldnt recommend to people to use Go for an android app over something with native support like kotlin Lol what, who would even use that? Using Go on mobile is out of question, I'm talking about web part.
And about the Go ecosystem being opinionated, people used to claim that having no generics and no exception handling makes Go better than other languages. Go 2.0 will add both features.
\&gt; The only drawback for Kotlin IMO is serverless application development. How about Kotlin/Native?
Kotlin multi-platform enables you to share the data model, validation, and business logic for back-end, mobile, and front-end (kotlin-js). Although you only mentioned Android, this would allow you to add an iOS app with very little extra effort (you just need to create the UI and hook it up).
IMO, the biggest downside to Spring is the size. It's fantastic, but it's big. If size is important - e.g. for containers, or serverless - you might want something lighter.
[removed]
Go is still very immature. In terms of language itself, tooling for the language, and ecosystem of libraries available. Kotlin, on the other hand, builds on the Java ecosystem and so has fantastic library support and generally good tooling support. The language is still fairly new, but again builds on the JVM so started from a very mature base...
when did you ever imply that youre talking about the web part and not about both parts. "The job" as far as im concerned was the web backend AND the android app, nowhere did you specifiy
I thought it was obvious. What madman would use Go on mobile? 
OP said they had to use either Go or Kotlin for both
Spring Boot + Kotlin is great if you have the server resources to handle it. I wouldn't run that setup on an instance with less than half a gig of RAM. There are some gotchas with containerized setups and JVM launch parameters, too. Maven is fine for building Spring+Kotlin services, too (but you will still need Gradle for Android builds). Honestly, try out Android Studio and IntelliJ Community Edition -- they're pretty much the same IDE, just with different workflow focuses -- and go from there. Cranking out an Android project in Android Studio is braindead-easy, and handles all of the Gradle bullshit for you. Likewise, on the IntelliJ side, a Spring Initializr project will get you up and running with your server-side Boot code pretty quickly, and IntelliJ has a project dialog that wraps all of that for you, too. I think Elastic/Solr is even one of the database driver options in there. Just make sure you have your no-args compiler plugin set up right, or you won't be able to do much with Spring Data or Jackson. But yeah, figure out your JPA entity classes (which CAN be Kotlin data classes with everything in the constructor) and pull in the Spring-Data-REST plugin as a build dependency, and your backend is done. As in, make a couple of RestRepository interfaces, and Spring will build full RESTful CRUD services for you. Done. Finished. Next problem.
The answer is Kotlin but you'll get a different answer if you ask on the golang sub.
Neither will be more future proof than the other. Both languages/platforms have large developer communities and strong backing. Both will be about the same in terms of performance (minus JVM startup time, but for most deploys that won't mean anything). They are both really great from an implementation perspective. I personally don't like Go's lack of null-safety and some of its minimalism can be aggravating at points. It's lack of enums can be annoying, the fact that it's errors are only guaranteed to be a string can be annoying (rather than something with a more specific type or enum result), etc. Of course, Kotlin's runtime exceptions can be annoying as well since a function doesn't tell you it might have an error (rather than a more Rust-style result being returned). Go's lack of package management by default (at least for now) makes it quick to get started, but ultimately you'll have to deal with package management if you're looking to have a reliably-built program. C# is also a fine language and platform with similar speed and tools. I don't think it matters what you choose as much as writing your program. With Go, you'll likely have to write a bit more of the tools that you need. With Java/Kotlin or C#, you might have to learn some tools that have already been built. Go certainly has tools, but because its package management story has been quite weak, it doesn't have the same culture. Just as an example, for a while people were trying to figure out how to make dependency injection for Go (I'm guessing many still are). People put out libraries that felt very rough and felt like they were fighting the language. By contrast, Java has a spec for dependency injection and the community has coalesced around a couple DI frameworks with additional ones that are slightly different, but mostly sticking to the spec. Maybe take a quick look at Jooby (https://jooby.org, https://jooby.org/doc/lang-kotlin/). You can clone the Kotlin starter project and try it out. If you're going with Go, Gin and Echo are what a lot of people reach for.
&gt; Go 2.0 will add both features. Do you have a source on this? All of my research says they’re popular topics of discussion for the Go 2 spec but are nowhere near to being agreed upon.
&gt; What would be better in these both for a backend-server for website and Android app I read this as "a backend-server for (website and Android app)," rather than "(a backend-server for website) and Android app." - this is a server that backs both a website and an app, not an app and also a server. Given that OP has discussed webserver frameworks but nothing about Android dev elsewhere in the thread, I think this question is only about the backend.
can kotlin native be a mobile app? like react native is used for mobile app?
GraalVM can improve load times for JVM based applications (including Kotlin of course) which can make for a comparable serverless experience.
Anyone use Graal in practice? I’m more interested in painfulness of use :) It’s on my “check it out sometime” radar, though if it’s truly not too bad to use I might take the time to get to know it sooner then later 
I don't think so. Try out the following code: &amp;#x200B; data class Person( val name:String, val age:Int ) fun main(args: Array&lt;String&gt;) { val people = listOf( Person( "Bob", 19 ), Person( "John", 22 ), Person( "Shaw", 23 ), Person( "Mary", 25 ) ) people.filter { it.age &gt; 23 } .forEach{ println( "Name: ${it.name}; Age: ${it.age}" )} } &amp;#x200B; Something like this? The original 'people' list remains unaltered.
The list changes, the references to the elements don't
Thanks for the reply, my question was if i where to change the name for example in the filtered would that change in the original list?
I can't find the source I was thinking about. It was not a precise implementation proposal, but that those two features would be introduced one way or another. It seemed pretty official, but I could be wrong. Anyway it does seem inevitable that they will be included, from your reference, or from https://blog.golang.org/go2-here-we-come (Nov 2018): &gt; Ideas from the remaining proposals will likely influence Go 2’s libraries and languages. Two major themes have emerged early on: support for better error handling, and generics. Draft designs for these two areas have been published at this year’s GopherCon, and more exploration is needed.
Thanks, so then the changes should carry over (which is what I need). 
Everything in the JVM can be thought to be passed by reference, if you modify an object passed to you then you modified what the caller sees upon return. This is a huge reason why data classes and immutable references (val) exist in Kotlin, it gives you a way to pass around data that can't be mutated under your feet while getting compiler-generated helpers to create mutated COPIES of that data. In the case of /u/SuperFluffyPunch's example, you actually can't change the "name" property because they are immutable references (val, not var).
 data class Person( val name:String, val age:Int ) fun main(args: Array&lt;String&gt;) { val people = listOf( Person( "Bob", 19 ), Person( "John", 22 ), Person( "Shaw", 23 ), Person( "Mary", 25 ) ) // New List val new_list = people.filter { it.age &gt; 23 } .map{ it.name.toUpperCase() } .toList() // Original List println( "--Original List--") people.forEach { println( "Name: ${it.name}; Age: ${it.age}" )} // New List println( "--New List--") new_list.forEach { println( "Name: ${it};" )} } Output --Original List-- Name: Bob; Age: 19 Name: John; Age: 22 Name: Shaw; Age: 23 Name: Mary; Age: 25 --New List-- Name: MARY; As you can see the original list 'people' is still intact
In your case where the Person uses val that is what happens, my question should have been specifically if it was a var that you can directly change. So in the following code it does change. Sorry if I wasnt clear &amp;#x200B; data class Person(var name: String, var age: Int) val people = listOf(Person("Bob", 19), Person("John", 22), Person("Shaw", 23), Person("Mary", 25)) // New List val new\_list = people.filter { it.age &gt; 23 } new\_list.forEach { it.age++ } // Original List println("--Original List--") people.forEach { println("Name: ${[it.name](https://it.name)}; Age: ${it.age}\\n") } // New List println("--New List--") new\_list.forEach { println("Name: ${it};\\n") } \--Original List--Name: Bob; Age: 19 Name: John; Age: 22 Name: Shaw; Age: 23 Name: Mary; Age: 26 \--New List--Name: Person(name=Mary, age=26); &amp;#x200B; &amp;#x200B;
Kotlin uses regular Java collections. The standard collections use generics which are erased at compile time and so they're really storing references to Object instances. When you use the Kotlin filter function, it creates a new list and iterates over the original collection invoking the specified lambda on each element to see which ones meet the filter criteria. Those that meet the criteria are added to the new list. Now since the original collection stored references to the Object instances, those references are copied into the new list. Lastly, references are like addresses specifying where the Object resides in memory so when you copy the reference, both references refer to the same Object. In fact, you have to go out of your way in Kotlin or Java to make deep copies of any object. If the object class doesn't have a clone method, it would be very difficult to automatically make a deep copy since you could have circular references so attempting to follow all non-null references could encounter a stack overflow. I recommend navigating to the implementation of the filter function (or any other Kotlin standard library function) as it's just regular Kotlin code without any magic.
The list doesn't change since a new list is created
HTTP4K + Kotlin will get you into the zone of productivity pretty quickly.
What is your opinion about spring and KTOR, will I be able to find solutions to problems in http4k on stack overflow like spring?
I'm new to Kotlin in general, but Spring and Spring Boot fill me with utter hate. Just a horrible framework that I can barely understand the popularity of. HTTP4Ks docs have been easy to read, it's minimal enough that I've not found myself reaching for Q&amp;A, seems good to me.
I'm mostly going to go with Kotlin, but what framework is better, I am going to buid back-end for a startup, so hosting costs and ease of connecting to elastic search, MySQL, having features like authentication and payments is important. Spring vs dropwizard vs ktor vs vertx.
I'm mostly going to go with Kotlin, but what framework is better, I am going to buid back-end for a startup, so hosting costs and ease of connecting to elastic search, MySQL, having features like authentication and payments is important. Spring vs dropwizard vs ktor vs vertx.
I like ktor for small focused stuff, but, Spring Boot is where I still start when I expect a project to move to other team members. The ecosystem for Spring is huge, so everything you want already has documentation and tutorials available. For ktor, you’re gonna immediately hit a documentation wall. You will hit hurdles trying to figure out how things work. I can’t really speak for Dropwizard or Vertx. 
Wow, this is fantastic. I don't know how I missed the 1.0 for this but it's going in my shortlist of favorite libraries. 
Kotlin making my life too easier to live. 😜
Right, I can see how you would read my comment that way. That was the intention of my statement (the list is new, because of filter, thus the list you're operating on following that is a different list) but the wording was terrible.
Did you add jar by hand, per chance? Because it sounds like you have ktor-server-core jar, but none of the core jars it depends on, liek the ones that actually have all shared client-server logic and http pipeline logic.
Because Spring, even in the most basic form, is giant and often way too bloated for any smaller scale project. Aslo Spring is fairly opinionated and provides you with overengineered "solutions" out of the box that you need to go out of your way to not use. Ktor is very slim and allows you to craft service in any way you want
&gt; What is your opinion about spring and KTOR To put it simply: http4k is manicure scissors, ktor is a gardener tool kit and Spring is an industrial harvester combine. So it's all about whenever you need to sculpt your bonsai, trim you hedge or harvest a 50 hectare field &gt; will I be able to find solutions to problems in http4k on stack overflow like spring? Yes and no. You'll be able to find answers for most common problems in ktor/http4k on SO, but not for every single possible problem that could happen, like with Spring. On a flip side, the answers you'll find will almost all be relevant instead of being 5 years out of date recommending you "solutions" that re not only no longer best practices, but are now heavily frowned upon.
I would politely disagree. Spring is great. For a use case when a business wants a standard solution without any unusual solutions and doesn't want to spend too much time developing it yet wants to still have all the possible stability, extensibility, maintainability etc
Is this multiplatform?
&gt;Sequences are lazy, so intermediate functions for Sequence processing don’t do any calculations. Instead they return new Sequence that decorates the previous one with new operation. All these computations are evaluated during terminal operation like toList or count. On the other hand, functions for Iterable processing returns a new collection. Look here: [Use sequences for bigger collections](https://blog.kotlin-academy.com/effective-kotlin-use-sequence-for-bigger-collections-with-more-than-one-processing-step-649a15bb4bf) &amp;#x200B;
They explain it assuming lots of existing knowledge though. You definitely need to know the syntax of a C-style language before you can have a go at them, and even then the functional parts are a bit rough if you haven't done Scala/Groovy/Swift, or something like that before.
&gt; Everything in the JVM can be thought to be passed by reference Neither Java nor the JVM have a concept of "pass by reference". Both primitive values and object references are passed by value.
Only JVM at the moment. I'd like 2.0 to be multiplatform but I'd need to rid any dependencies on Apache Commons Math. 
Or just packaging your code into a jar. I mean, TornadoFX is there for a reason.
Object references are passed by value, which could equally be interpreted as the objects themselves being passed by reference.
A thousand ways to get there without the friction though. :) Appreciate the polite disagreement! As ever, peoples milages vary. Have a wonderful Christmas.
I see. I'd like to use this in the browser in my next project, that's why I asked. Do you know of any multiplatform alternatives which exist?
The closest project is Koma, which is multiplatform. However, it is much more oriented to linear algebra structures (vectors, matrices, etc) rather than Kotlin idioms on POKO models. &amp;#x200B; [https://github.com/kyonifer/koma](https://github.com/kyonifer/koma) &amp;#x200B; For what it's worth, not all of Kotlin-Statistics relies on Apache Commons Math. If you are interesting in the binning and grouping API, those are built with pure Kotlin code. You could rip the source out if you like. &amp;#x200B; &amp;#x200B;
Thanks! I'm not really into Linear Algebra, I'm going to work on a Financial calculator program instead. Also thanks for the suggestions! I'm putting your lib on my list though.
Oh, that's coincidental. I just listened to your interview on the Kotlin podcast. It was pretty informative! [http://talkingkotlin.com/Data-Science-with-Thomas-Nield/](http://talkingkotlin.com/Data-Science-with-Thomas-Nield/) I'll be trying it out pretty soon on an Android app I'll be working on. Something the podcast got me thinking about as well as a talk you gave was about the possible future expansion of data science and kotlin and how there is a lot to be done. I'm certainly a bit inexperienced in programming but attempting to get a job in it, do you think getting involved in developing a data science/machine learning library might be a good idea for someone who isn't already extremely knowledgeable? Or would it be a bit over my head? Data science and machine learning is kind of one of my interests right now so I figure it might be a good way to learn and get practice, but on the other hand, I am not certain it would be feasible without having a full picture. 
Thank you, I appreciate that. Programming is only useful when you learn how to apply it to something, and data science/machine learning/optimization is certainly a great place to apply it. You might want to read this document I wrote to learn how to get started: [https://github.com/thomasnield/kotlin-data-science-resources](https://github.com/thomasnield/kotlin-data-science-resources)
Bit late here, but I found that Kotlin contained the features of Go enough that I'm toying around w/ a [Go-to-Kotlin compiler](https://github.com/cretz/go2k). The Go ecosystem is rich. I don't want to write a bunch comparing the languages/runtimes in general. I write a ton of code in both languages and would be willing to answer more nuanced comparison questions though.
Could you please provide examples of "tools, libraries, and frameworks, having perfectly working equivalents in Java" that you feel are unnecessarily throwing existing solutions off-board?
Kotlin was created in 2011 and launched 1.0 in 2016. It got a boom in popularity recently. But what I mean is: Kotlin is it's own programming language (and so is Scala). &amp;#x200B; Also, I want to say 3 things: * Google have put Kotlin in the spotlight of the Android Development. * Mobile is a different paradigm from the usual backend stuff that gets you familiarized with the JVM ecosystem. * Many mobile developers already dislike Java because of the complexity of the Android plataform (and the complexity of the Java language itself). The point I want to make saying this is: Not everyone that adopted Kotlin is familiarized with the JVM ecosystem. Developers often "reinvent the wheel" because they either: * didn't know there was something that could solve their problem * or the current solution doesn't solve their problems. Of course there are other motives, such as the "Not invented here" syndrome, but let stick with these two for simplicity sake. That leaves us with two situations: * Someone likes Kotlin but is not experienced with the JVM ecosystem * Someone is experienced with the JVM ecosystem, but want to take full advantage of Kotlin features, such as nullability or extensions, etc. People not experienced with the JVM ecosystem, if unaware of the current Java solutions, often will roll out their own solutions. People who want to take full advantage of Kotlin features will often write Kotlinized "wrappers" or "extensions" for Java solutions. The problem is, such wrappers and extensions are limited by their parents design, because of that, if wrapping and extending is not enough to provide the wanted benefits, people will also roll out their own solutions. &amp;#x200B; And there is my two cents
Kotlin and Java influence each other, Java has a lot of upcoming features from project Amber where it can basically look how other languages such as Kotlin implemented things like switch expressions, destructuring, etc. My own experience is that Kotlin often leads to cleaner and less bug prone code, but sometimes becomes a bit cryptic. Also calling Java code from Kotlin can be a bit rough, that's why wrappers are created. It means you can stay in your Kotlin world while having the Java stuff hidden away.
Mockk, for example. Mockito exists and work, but mockk is better
I try to keep Java interop in mind when developing any library in Kotlin. The best way is to write JUnit test cases in Java and see how the lib. interface looks like there.
Another thing is that Kotlin itself is a language with several different backends. You may target JS or Native, but you can’t do such with existing Java libraries. 
To allow for other people also join the discussion, I have reposted it to my blog as well: [https://preslav.me/2018/12/28/the-kotlin-way/](https://preslav.me/2018/12/28/the-kotlin-way/)
You're going to see that regardless, because "I built X in Y language" tends to be the bulk of posts in most language forums like this. However I guarantee you the bulk of Kotlin users are building things in much the same way as they did with Java, using tried and true frameworks and tools.
https://kotlinlang.org/docs/resources.html
The only thing I've found to be at all rough about calling Java from Kotlin is needing to remember to specify your returned type as nullable. What else isn't just buttery smooth?
That's the way Java interop used to work in earlier pre-release versions of Kotlin. There's a very good reason why the designers added platform types so that you don't need to treat everything from Java as nullable everywhere. I deal with platform types on a daily basis at work and there is just no way around the discussion, dealing with a Kotlin library is much much better as you can code without needing to stop and think about the types as much. Not to meantion being able to leverage Kotlin features which don't exist in Java.
&gt; Yet, this is not quite what is happening. I have seen the birth of a Kotlin-first community of developers, preaching things "the Kotlin way". I was involved in Scala in the early days (2009ish), Scala's problems went way deeper. Scala's creators used it as a playground for ideas, throwing sometimes ill-considered features into the language - often quite experimental ideas from functinal programming. I think this helped to contribute towards the strange puritanism and culture that developed around the language. I remember debating people about whether `:/` was an appropriate name for a standard library infix function. Kotlin's culture appears to be far more pragmatic than Scala's, so while people will always want to create libraries that take full advantage of the language they're using, I don't think we'll see the same snobbishness that occurred with Scala (and IMHO contributed to its downfall).
Having used Java for over a decade and Kotlin for about 1.5 years (I use Kotlin at work for back-end development), I can say without hesitation that there are some really good reasons for re-writing a library in Kotlin: 1. When writing multi-platform code, it cannot depend on the JVM. Kotlin Native should emerge out of beta soon. 2. When the library can make use of Kotlin features to reduce defect rates. Eg. Sealed classes can leverage exhaustive compile-time checks. Eg. Take advantage of Kotlin's more robust generics such as function-level variance. Etc. 3. When the library can make use of Kotlin features to improve readability as readability is one of the most important goals after correctness. Some examples: infix functions for unit tests `name shouldBe "Bob"` is much more readable than `Assert.assertEquals(name, "Bob") // is the param order correct?` Another example would be to leverage reified generics. Etc 4. Address separation of concerns which cannot be addressed with just Java. A common example is that logging frameworks recommend wrapping your log statements in checks to see if the logging level is enabled in order to avoid performance issues due to unnecessary string concatenation. This tight coupling design flaw can be fixed by using Kotlin inline functions which accept a lambda to generate the message. Trying to use lambdas in Java for this defeats the purpose since it's a capturing lambda so a new object is created anyway. Note that this is not premature optimization as logging has already been identified as a scalability issue hence the recommendation from all logging frameworks. 5. Finally, if a Java library is used often enough, dealing with platform types on a regular basis is somewhat bothersome as you always need to stop and re-evaluate what you're getting from Java so writing a Kotlin wrapper can improve productivity and reduce mistakes (which I still encounter with platform types). Note that treating it all as nullable is not a good solution as this has already been tried with earlier pre-release versions of Kotlin. It should become clear that Kotlin is much much more than just prettier syntax. The more robust type system with stronger generics, the cleaner sequences, extension functions, lambdas with receiver, sealed classes, etc. etc. all come together to enable much more readable code with more correctness guarantees than what is possible in Java. All of this also improves productivity by quite a noticible amount.
The last Dokka [release](https://github.com/Kotlin/dokka/releases) was over 6 months ago :/ That and the lack of apparent progress in its features make me question whether JetBrains is investing in it.
Most answers about the standard library can be answered by looking at their implementations: public inline fun &lt;T&gt; Iterable&lt;T&gt;.filter(predicate: (T) -&gt; Boolean): List&lt;T&gt; { return filterTo(ArrayList&lt;T&gt;(), predicate) } &amp;#x200B; public inline fun &lt;T, C : MutableCollection&lt;in T&gt;&gt; Iterable&lt;T&gt;.filterTo(destination: C, predicate: (T) -&gt; Boolean): C { for (element in this) if (predicate(element)) destination.add(element) return destination } so it seems like there's no copying at all, it just adds the elements that match the predicate to a new list
I understand, but multi-platform support has only recently become the focus. Kotlin was and still primarily is, built to serve the JVM. I am not sure as to how much the multi-platform move was the original intention of the developer team, and how much of it was dictated by the community.
It's neither the original idea nor dictated by the community. I think it's mainly the result of the later thinking of the Kotlin creators, what to do with the language to make it more appealing than the incumbents. Today, Google has a strong influence over Kotlin. Android is currently the language's most important focus, and Google's hope is to entirely push out Java due to the legal fights with Oracle. They should get rid of the JVM eventually as well, but that's still a long way into the future. The JVM approach is slowly dying out. On the client side the JIT compiler is falling out of favor due to cold startup problems. On the server side it didn't use to be a problem, but now with the serverless architecture, it is. Kotlin wants to survive this power shift. 
Thank you very much!
\+1 for Code by Petzold
I feel like some of this comes from limitations of Android, where larger existing java libraries either don’t fit or have unwanted dependencies. I am not too familiar with it but this seems to be the case for some java libraries like OkHttp instead of using Apache commons http client
Kotlin, for the most part, is Java as it should have been had it had decent stewardship over the past decade. Most of its features are just Java best practices captured in the language, giving more reasoning power to the compiler. Therefore, "the Kotlin way" is much like "the Java way, only better" "The Scala way", on the other hand, is mostly "anything I can write to prove that I'm better than you". The problem isn't that there's a new ecosystem being built around it; the problem is that the ecosystem stinks. I got interested in Scala in 2007 and by 2008 I was already disillusioned. In 2009 I got into Clojure, it took me a little longer, I got disillusioned by 2012. Almost the same thing happened to it, [snobs and weenies](http://wiki.c2.com/?SmugLispWeenie) suffocating the community. This fundamental difference between Scala and Kotlin means that you don't experience a 180-degree paradigm shift when going from a Java library to a Kotlin library. It's the same, proven ways of getting things done, but leveraging the extra features.
Basically you want to narrow down the term "FP language" so much that not even Haskell qualifies. Haskell has unsafe mutable arrays, for example. The modern way to use the term "FP" is to imply language features that allow you to use the FP style in your code. We don't divide the languages into FP and non-FP, just like we don't divide them into OOP and non-OOP anymore. Languages have features, some coming from the OOP paradigm, some coming from FP, etc.
You probably have some constrained notion of "currying" in mind because Kotlin functions aren't curried. If they were, you could take any val binaryFun = (a: String, b: Int) -&gt; Int and turn it into (b: Int) -&gt; Int just by writing val unaryFun = binaryFun("a") 
change "modern" for "wrong", and change "you want to" for "computer science defines" and we are in an agreement :). The change "we don't divide" for "hackometer does not divide". Just a bit of extra clarification :) I am not an "old" developer (that should not matter anyway) but I feel that you are trying to make a distinction into "we = new" and "you = old". I am an Android lead on my job that has a University Degree in Computer Science, I have been working in Android for 10 years now, using Dagger, Retrofit, MVP (again it should neither matter). Computer Science defines Functional Programing on a way, you are using it wrong to add some extra quality to Kotlin that does not need. Kotlin is really nice and it does not need to be a "Functional Programing" language to be as good as it is.
"We" is what most of the community uses today. The division into "FP languages", "OOP languages", etc., is outdated. What you call "FP language" would today have to be additionally qualified as a "pure FP language". Your Wikipedia quote clearly agrees with what I wrote: FP is a _style_ of building code. You can use the FP style in Kotlin, or Java, or Swift, or JavaScript. Would you call Scala an FP language? How about Clojure? Is there any language except Haskell that qualifies as an FP language? Since you can write code with side effects in Haskell, how come you consider it an FP language?
You can use reflection to do this.
I simply looked it up and it said that Kotlin has currying. Thanks for enriching my overly shallow assessment of that. As a huge fan of Haskell, I was bummed when Swift dropped currying.
Check out Micronaut as well. It's pretty new, but spring-inspired and has lots of Kotlin-focused documentation.
First opion traverses the collection once. Second one traverses it the first time, creates a new collection and filters the result collection with the second predicate creating a new collection. So they are not the same, second one is worse performance wise.
Well I do not dare to speak for "most of the community", but I could speak for me, my coworkers at my current job, my coworkers on my previous job, some of my classmates that I still keep touch with and some other ppl of the dev world that I had the chance to meet around ;). Anyway, having functions as first-class objects does not make a language to be functional. There is not arguing on that. You can keep calling it functional, you are free to do so. I am just pointing out that having "functional like" constructions is not the same as being functional. You can always choose to ignore what I say (what every book say) and keep going with what "most" of "the community" use :). Again, I would not dare to speak for "most of" anything, I can only speak for myself :). Cheers! We can agree on disagreeing :) 
The second is much worse unless you change it to use a sequence and then it would be better than the first if you just operate on the result without converting it to a list: ``` list.asSequence .filter { it.something == "qwerty" } .filter { it.somethingElse == "asdf" } .forEach { do something with each element } ```
- ktor - klaxon - kobalt The thing is that people like to reimplement libraries in new languages for practice. It's only a problem when they become the default out of some unfounded aversion to the existing java solutions, or thin wrappers around them.
I wouldn't be so sure about that. When the kotlin tutorial covers kotlin-test instead of the established frameworks, when the common recommendation for a web framework is ktor, newcomers will inevitably use those frameworks even though they may not be the best solutions. Kotlin is now large enough that people learn it without a deep knowledge of Java and its frameworks.
&gt; This tight coupling design flaw can be fixed by using Kotlin inline functions which accept a lambda to generate the message. That’s a good use case. I think Scala and Rust solve this by using macros. Is there a popular/mature Kotlin logging library that uses this?
You can use a debugger for this kind of thing and then evaluate expression. https://www.jetbrains.com/help/idea/evaluating-expressions.html
Totally agree. Op should explain why a break point and a debugger wouldn't give all the needed functionality. 
totally agree
That is certainly a debate that is happening about the defination. From my awareness of it, the question is whether it should be defined as a language which can be used in a functional way exclusively, or if it should be defined as a lnaguage that can only be used in an functional way. Personally, I don't know. I'm still trying to learn what functional programming is, so that doesn't help, but it seems like a semantic difference. Functional programming is based heavily on logic and mathmatical theory and so I think there is a disconnect between people who get heavy into the concepts and their validity and people who want to use the ideas as a tool. I listened to a podcast today where a guy was talking about the hisotry of computer science and about how the math comes about and how mathmaticians had to throw out entire theories because there were small problems with them and talked a lot about being concerned with truth and what functional programming can tell us about reality. What I think he was talking about is far different than what other people are talking about. He was more speaking about the mathmatical roots and logical proofs, but other people seem to be talking more about it more as a property of something. Probably talking out of my depth here.
You might be able to do something with kotlinx.serialization, which doesn't use reflection (and thus works cross platform).
I believe at the time Mockk was more than an alternate over mockito as the latter could not work well with Kotlin's final classes by default so mockk was developed to be a far more efficient (and usable) library that did not require changes to your production code.
It's hard to either agree or disagree with a person who argues with himself. I say "it is outdated to divide languages into FP languages and OOP languages". You respond "No, Kotlin is _not_ an FP language". I say "But Haskell has mutable arrays". You say "No, Kotlin is _not_ an FP language". I say "FP is a _style_. You can use that style in many languages." You say "No, Kotlin is _not_ an FP language." 
I would like to listen to that postcast. Can you share it? :) I think that you get my point. It does not matter that Kotlin is not functional, it does matter that allows us to write cleaner code, and that is why many of us (or at least me) love it.
Well, if I say "JavaScript is strong typed cause you can use TypeScrip on top of it" how would you react? :) You said "you want to narrow FP dow so much that only Haskell supports it" ... Well I do not, I just expressed what Functiona Programing Paradigm is. I like programing in general :) and I like Kotlin cause allows me to do it on a cleaner way I do not thing it is outdated to know the theory behind stuffs, that can help you to see the difference in between GoLang Inheritance system or Java, or to choose strongly typed or not, etc, etc. Supporting functions as 1st classes object or having a stream Api does not make a language functional, C++, Smalltalk, JavaScript and many others yet you do not say "I write functional code" cause you use a Stream Api. We do not have to agree, no need :) It was fun though, as because of this arguing I had to go back and re-read some definitions that is always a good thing to remember :)
&gt; Well, if I say "JavaScript is strong typed cause you can use TypeScrip on top of it" how would you react? :) Let me guess: your point here is that _Kotlin is not an FP language_. &gt; You said "you want to narrow FP dow so much that only Haskell supports it" ... Well I do not, I just expressed what Functiona Programing Paradigm is. Let me guess: your point here is that _Kotlin is not an FP language_. I like programing in general :) and I like Kotlin cause allows me to do it on a cleaner way &gt; I do not thing it is outdated to know the theory behind stuffs, that can help you to see the difference in between GoLang Inheritance system or Java, or to choose strongly typed or not, etc, etc. FYI the opposite of "strongly typed" is "weakly typed", not "dynamically typed". [Go check that out.](https://stackoverflow.com/questions/2690544/what-is-the-difference-between-a-strongly-typed-language-and-a-statically-typed) &gt; Supporting functions as 1st classes object or having a stream Api does not make a language functional, C++, Smalltalk, JavaScript and many others yet you do not say "I write functional code" cause you use a Stream Api. Let me guess: your point here is that _Kotlin is not an FP language_. &gt; We do not have to agree, no need :) It was fun though, as because of this arguing I had to go back and re-read some definitions that is always a good thing to remember :) It's hard to either agree or disagree with a person who argues with himself.
&gt;the opposite of "strongly typed" is "weakly typed", not "dynamically typed haha when did I used "dynamically typed" or "weakly type"? I am not arguing. I can notice that your mood is changing. Cheers mate! have a good weekend and use Functional in whatever way makes you happier !
&gt; haha when did I used "dynamically typed" or "weakly type"? When you wrote &gt; Well, if I say "JavaScript is strong typed cause you can use TypeScrip on top of it" how would you react? :) I guess I made the mistake of assuming you write sentences that are supposed to make sense. So I tried to make sense of this sentence, and my finding was that you think JavaScript is not a strongly-typed language, and that the argument that you can use TypeScript on top of it doesn't change that. Apparently, I was wrong and you meant nothing whatsoever with that sentence. &gt; I am not arguing. I can notice that your mood is changing. Cheers mate! have a good weekend and use Functional in whatever way makes you happier ! Let me guess: your point here is that _Kotlin is not an FP language._
If your T is a data class, you can just use equals. This sounds like an XY problem, you want to iterate over properties of an object to detect changes but you can easily detect changes with equals is the object is properly designed.
&gt;So I tried to make sense of this sentence, and my finding was that you think JavaScript is not a strongly-typed language, and that the argument that you can use TypeScript on top of it doesn't change that. Yes, you got the point :). Still I never wrote "weakly" nor "dynamically" that was all in your mind ;). I just wrote "strong or not". 
those three things aren't competing in the same problem space, so kotlin-to-javascript's future is not dependent on kotlin native or webassembly The only way webassembly would be a "threat" is if it gets direct access to the DOM api, but that's not happening any time soon: https://webassembly.org/docs/faq/#is-webassembly-trying-to-replace-javascript 
So your updated claim is &gt; JavaScript is a programming language that is neither strongly nor weakly typed. What a perfectly silly thought to close this perfectly silly discussion on Kotlin and FP.
No :) you can re-read my replies. Please stop putting words on my mouth that I have not said, it is all written there. I said that TypeScript does not make JavaScript a strong typed language. Then, on another different paragraph I expressed that knowing the theory behind stuffs, will help you to know why to choose in between a Strong typed language or not. I haven't updated any claim. Sorry to end this "arguing" but well ... it is new year's weekend and I rather do something else that argue nonsenses with you. Have fun! 
Honestly I don't see a big future for kotlinJS. Kotlin Native uses LLVM like Swift, which is a good thing! LLVM is rock solid, fast and generally pretty well fought out. Webassembly will replace js eventually. But why? Because people don't like JS(terribly stuctured language my humble opinion) and they need an alternative. Which mean people/companies will poor money and manpower to projects that will based on webassembly. 
Y tho?
You actually claimed that JavaScript is not a strongly-typed language. Given that "weakly typed" means nothing else but "not strongly typed", you also claimed that JavaScript is a weakly typed language. Your insistence on the opposite betrays your ignorance on the topics you pretend to be discussing.
&gt; It would be pretty interesting to see ktor run outside of the jvm
well yes, I claimed that JavaScript is NOT strong typed, as it is NOT strong typed. What i was saying, and maybe my English is not good enough for you to understand, is that you "corrected" me about weakly typed vs dynamically typed... anyway (sic) 
There you go http://corecursive.libsyn.com/021-gods-programming-language
JavaScript is either a strongly or weakly typed language. You claim it's wrakly typed. Your claim is wrong.
I'm not aware of any so I usually create a light 0 overhead wrapper. This makes my codes much cleaner since it's no longer littered with logging category checks and it also ensures that performance is never compromised. This is one of those cases when I get the best of both worlds, clean and fast. I'm starting to see many opportunities where this applies for many patterns by using inline functions which accept lambdas with receiver and actually most of these also reduce defect rates since it enforces correct sequence of events.
You may want to review your definition of "Weakly typed"... not much else to add here... “There is no worse blind man than the one who doesn’t want to see. There is no worse deaf man than the one who doesn’t want to hear. And there is no worse madman than the one who doesn’t want to understand.” -Ancient Proverb from the web ;)
Or review your knowledge about JavaScript :)
There is no worse teacher who pretends to know what he's talking about, while clearly not having the first clue. JavaScript is even more strongly typed than Java. That's because in Java you can violate the type system through `Unsafe`. There is no way known to me whereby you can violate the type system in JavaScript.
Thanks! I ll listen to it later.
hahaha you amaze me :) that was for sure a fun paragraph to read :D Thanks!
Talking to you feels like talking to a kindergarten kid. You laugh at all the inappropriate moments, it must be that the words of a professional are just funny gibberish to you.
I'm not convinced by Kotlin/JS. Typescript has mostly solved the JS issues and is taking over more and more. E.g. Vue is rewritten in TS. Angular already is, of course. A lot of React libs are written in TS, too. Kotlin/Native and WASM is a whole other story. To be able to write compute intensive parts of a web app in Kotlin and compile it to WASM with proper multithreading support would be a huge step forward. However, I've got the feeling that WASM is not as fast moving as some blog posts suggest.
You're right they aren't competing but Dom access definitely is coming soon. The host bindings proposal is being very actively developed right now
I doubt that Kotlin/JS has future. As mentioned before, Typescript is fine alternative to JS with one important difference: while transpiled Typescript generates less code of Javascript, this is not the case of Kotlin/JS. I guess nobody need their pages loading another js library.
I suspect that FAQ entry may not end up being effectively true in the long run. A lot of people wouldn't bother with JS if they could just use another language via WASM and have it be faster too. Keep in mind, webassembly involves the backing of browsers that have been working on adding to JS for decades. Admitting that all of that work may be irrelevant is probably politically infeasible, hence halfhearted notions of people maintaining two stacks to develop browser code, one WASM, one JS.
I don't see why you would use a GC language with WASM. There is a reason why C, C++, and Rust are the languages that you often hear of when reading about WASM. &amp;#x200B; &amp;#x200B;
You can use Kotlin with this http://micronaut.io/ for micro services. It also support https://www.graalvm.org/d 
Mockito can cause problems with non nullable APIs, so I'm not sure how well it works.
Don't forget about new upcoming google OS Fuchsia. It may suppose the Google will don't need to use java any more on mobile :) https://www.youtube.com/watch?v=FhX6cANaJ6o
Sometimes this is no very easy when using extensions for a dsl, for example
Just bootstrap a minimal project in your IDE and start working on a simple app. I've learned most of it through googling exact problems that I had to solve. Most of the times I ended up going to https://developer.android.com/
Awesome can't wait to try 
Extensions and DSL are nothing that is intended for Java... extensions may be used as utility classes, yes, but generaly I test in Kava code that is intended as Java library, not Kotlin syntax improvement for particular domain.
Jetbrains’s Anko Logger for Android is a step further... you can just call info(), error(), etc. and do not need the “logger.” pointer.
Oh, hey - a place to plug the structured logging library I wrote that others may find useful. [KSL](https://github.com/vituity/ksl) is a fairly light library I wrote on top of SLF4J to provide easy-to-use structured logging for kotlin applications. My workplace is mostly a .Net shop and we've used Serilog for ages, so I wanted something similar for Kotlin.
Awesome, great timing for me. Can someone please show me where to get it? Any official link? I didn't find it on maven or at the downloads of the log4j page.
Well it can be done with extensions but I rather prefer to see logger pointer to be honest. If say, you have error( .. ) methods in the class, it may start to get confusing really fast. Also, it is much easier to search. If it were me, I put logInfo, logError instead. Much easier to find in auto complete and you get the best of both worlds.
Updated post with a link to announcement (accidental oversight). Download link here: https://logging.apache.org/log4j/kotlin/download.html
I really like the idea, especially that log4j2 supports being a facade to other backends (see it here: [https://stackoverflow.com/a/41500347/411965](https://stackoverflow.com/a/41500347/411965)). I don't like logger extension on Any. It will clutter my autocompletion in idea with another method that is not always useful. Disclaimer: I am maintaining [kotlin-logging](https://github.com/MicroUtils/kotlin-logging) and I think about adding log4j2 as a backing facade (I think the multiplatform support allows that hack).
I wasn’t concerned with naming. I just more liked the extension approach. But this is just cosmetics. 👍
Hmmmm.....
What's full pattern matching?
&gt; Actually, most of these also reduce defect rates since it enforces correct sequence of events. Could you provide an example of such? Is this something similar to the builder pattern?
Totally a nit but I'm not a fan of calling the standard functions `magic functions`. There's no magic there. You or I could've implemented them. As opposed to, for example, Python magic methods which are actually magic. 
The kind of pattern matching you would find in Scala, Haskell, etc. It's similar to Kotlin's `when` expression but more powerful. 
Not sure there really is a way to do that. And if there is I am also curious. You could do it with using a anonymous object. You could also write your own extension function with different naming the two calls differently.
What you can do is this: ``` // uses the ContextTransactionalRunnable variant dsl.transaction { -&gt; // your code } ``` ``` // uses the TransactionalRunnable variant dsl.transaction { _ -&gt; // your code } ``` ``` // also uses the TransactionalRunnable variant dsl.transaction { cfg: Configuration -&gt; // your code } ```
There's an open issue for squelching the intention/warning in this situation. I don't have the link handy, but someone pointed me to it when I brought up this issue in the kotlinlang slack.
Thanks for the work around. IntelliJ still complains about it, but I guess that will do for now until the Kotlin folks figure it out.
Yeah, at first I thought it was related only to java interop, but I just tested it in pure kotlin and the plugin still indicates a warning. I'd file a bug report with Jetbrains. Every little bit helps, and they're really good about responding. I submitted a bug for a weird edge-case related to inheritance and it was fixed in the next point release in a few weeks.
Sure, I'll provide an example with plain lambdas. Suppose you have a typical pattern that's repeated many times like this: fun withDrawFunds(amount: Long) { operationStarted(WITHDRAWAL) try { writeLock.withLock { balance -= amount } } catch (exception: Exception) { LOGGER.error(exception.localizedMessage) } finally { operationCompleted(WITHDRAWAL) } } fun depositFunds(amount: Long) { operationStarted(DEPOSIT) try { writeLock.withLock { balance += amount } } catch (exception: Exception) { LOGGER.error(exception.localizedMessage) } finally { operationCompleted(DEPOSIT) } } From a Java mindset, it doesn't look like the above can be made any cleaner because checked exceptions aren't allowed to be thrown from Java lambdas. The above is also error prone because we might not repeat the pattern perfectly. &amp;#x200B; Let's take advantage of Kotlin to make the code cleaner and also more robust without sacrificing scalability: // This is so much easier to read and understand without all of the operational clutter fun withDrawFunds(amount: Long) { performOperation(WITHDRAWAL) { balance -= amount } } fun depositFunds(amount: Long) { performOperation(DEPOSIT) { balance += amount } } // Pattern is defined in only 1 place so it will always be repeated correctly private inline fun performOperation(operation: Operation, execute: () -&gt; Unit) { operationStarted(operation) try { writeLock.withLock { execute() } } catch (exception: Exception) { LOGGER.error(exception.localizedMessage) } finally { operationCompleted(operation) } }
Thanks for taking the time to reply :) This makes sense, but how does `inline` benefit us here? Wouldn't the same behavior remain even if `performOperation()` were not defined as `inline`?
GitHub source code is [here](https://github.com/thomasnield/poisson-optimizer-and-simulator/blob/master/README.md). I used two [Poisson Distributions](https://en.wikipedia.org/wiki/Poisson_distribution): one for the [stochastic](https://en.wikipedia.org/wiki/Stochastic_simulation) arrivals and another for the stochastic processing time of customers. I'll try to create a walkthrough video of this soon 
This was a quick project over the past two nights. You can learn about [Poisson Distributions](https://en.wikipedia.org/wiki/Poisson_distribution) quickly from [PatrickJMT's video](https://www.youtube.com/watch?v=Fk02TW6reiA). GitHub source code is [here](https://github.com/thomasnield/poisson-optimizer-and-simulator/blob/master/README.md). I used two Poisson distributions: one for the [stochastic](https://en.wikipedia.org/wiki/Stochastic_simulation) arrivals and another for the stochastic processing time of customers. I'll try to create a walkthrough video/blog of this soon. 
**Poisson distribution** In probability theory and statistics, the Poisson distribution (French pronunciation: ​[pwasɔ̃]; in English often rendered ), named after French mathematician Siméon Denis Poisson, is a discrete probability distribution that expresses the probability of a given number of events occurring in a fixed interval of time or space if these events occur with a known constant rate and independently of the time since the last event. The Poisson distribution can also be used for the number of events in other specified intervals such as distance, area or volume. For instance, an individual keeping track of the amount of mail they receive each day may notice that they receive an average number of 4 letters per day. If receiving any particular piece of mail does not affect the arrival times of future pieces of mail, i.e., if pieces of mail from a wide range of sources arrive independently of one another, then a reasonable assumption is that the number of pieces of mail received in a day obeys a Poisson distribution. *** **Stochastic simulation** A stochastic simulation is a simulation that traces the evolution of variables that can change stochastically (randomly) with certain probabilities.With a stochastic model we create a projection which is based on a set of random values. Outputs are recorded and the projection is repeated with a new set of random values of the variables. These steps are repeated until a sufficient amount of data is gathered. In the end, the distribution of the outputs shows the most probable estimates as well as a frame of expectations regarding what ranges of values the variables are more or less likely to fall in. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Kotlin/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
It's much more structured: Instead of something like CompletableFuture.supplyAsync(()-&gt;longFunction()).thenRun(()-&gt;//stuff).thenRun(()-&gt;//More stuff) And remember, it's entirely possible for there to be nested lambdas to make all the callbacks work You can do: launch{ val result=longFunction() runThingOne() runThingTwo() } &amp;#x200B;
Sure, but can't you do the same thing with a `CompletableFuture` using `await()`?
await Blocks the thread whereas coroutines are suspended-the difference being that when you call await the thread cannot be used until the operation finishes whereas with suspend it can
I'm pretty sure await() is a [suspend function](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-jdk8/kotlinx.coroutines.future/java.util.concurrent.-completion-stage/await.html), so it's not blocking the thread either.
That’s a kotlin extension. Since it’s a suspend function, you need to call it from a coroutine-hence why it can suspend. Java’s Future#get will block the thread.
&gt; Java’s Future#get will block the thread. Wouldn't that mean `await()` is violating its contract? &gt; Awaits for completion of the completion stage without blocking a thread. &gt; This suspending function is cancellable. If the Job of the current coroutine is cancelled or completed while this suspending function is waiting, this function stops waiting for the completion stage and immediately resumes with CancellationException. This method is intended to be used with one-shot futures, so on coroutine cancellation completion stage is cancelled as well if it is instance of CompletableFuture. If cancelling given stage is undesired, stage.asDeferred().await() should be used instead.
Like normal Future#get Blocks the thread, that’s putting kotlin aside. With kotlin coroutines, you can call CompletableFuture#await, suspending the thread. You can only call await with a coroutine.
Queueing theory can be quite fascinating.
Kotlin Coroutines was designed for "concurrency to be explicit". Providing a `suspend fun` ensures the caller is prepared to handle concurrency instead of forcing it on them and hoping that they remember to immediately use `await()` when they don't want concurrency.
A good reference on this is in the coroutine docs and gives examples of how the coroutines library is more comprehensive for certain edge cases https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/composing-suspending-functions.md
I've stumbled upon this guys code before. Very cool stuff! I'll encourage everyone to checkout the rest of the stuff he got on GitHub.
You can do a _similar_ thing. The difference being that the API being suspending uses the `CoroutineDispatcher` that the launch uses (ie, the threads *allocated by the caller* to execute the `launch` are used on resumes) which allows your API to not worry about how it's dispatched. By returning a `CompletableFuture`, your API *had to know* which executor to use or assume it should allocate it's own. By calling `doSomethingFuture().await()`, you are non-blocking on your `launch`'s thread, but are doing the _actual_ work on a potentially *different* executor altogether (which may not be desirable). You would have had to do an additional configuration step for it to use the same executor. By calling `doSomethingSuspend()`, you are non-blocking on your `launch`'s thread, but are doing the work on the *same* executor (called a dispatcher for coroutines).
Good bot
Thank you, ChristianGeek, for voting on WikiTextBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://botrank.pastimes.eu/). *** ^(Even if I don't reply to your comment, I'm still listening for votes. Check the webpage to see if your vote registered!)
Coroutines are also designed to correctly deal with errors and easilly stop computations when a sibling fails, something that is not easy to do with CompletableFuture 
Awesome Man !!!
Okay, so I understand not everyone speaks English as a first language, and with that I can ignore lots of the clumsy phrasing and very weird pacing of sentences due to (mostly) odd punctuation. However, there are also a lot of meaningless, misleading, or straight up incorrect sounding sentences in here. In no particular order, just some highlights (lowlights?): &gt;When working with a customized Android application, an advanced technology is always of advantage. Not sure if this means anything at all. &gt;As Kotlin offers numerous benefits, to the developers, it’s always a wise idea. Sounds positive, but doesn't actually say anything. &gt;Technically it is difficult to predict situations and it is similar to mobile app development and there must be more changes in the programming language, platform, and technology with time. No idea what this means. &gt;Though Kotlin has excellent support in Android studio, but not officially endorsed by Google. Don't know how this is possible to miss these days, but Kotlin is very much greenlit by Google. See [here](https://blog.jetbrains.com/kotlin/2017/05/kotlin-on-android-now-official/) or [here](https://developer.android.com/kotlin/) for example. &gt;If you are working with a large project, of duration, over a year, then it is **impossible** to convert Java into Kotlin. Bit of an overkill statement. &gt;You can make Android app in any language and after compilation, can run on the Java Virtual Machine (JVM). *Any* language seems like an overstatement, some languages would surely be extremely difficult to compile for Android. &gt;Kotlin is an easy language and a developer from OOP domain knows about its syntax. I'd argue that Kotlin is *not* an easy language whatsoever, rather easy to get started with if you already know Java. Object oriented knowledge might help, but there are many important aspects where Kotlin shines via its functional features.
You're very kind : )
Not realistic. The third one always run to empty counter. The second one mostly stick with counter with original queue
/u/Yona168 misspoke a few comments up. There are two functions: `get` (part of the `Future` interface) and `await` (an extension function on `CompletionStage` provided by Kotlin). A `CompletableFuture` is both a `Future` and a `CompletionStage`. `get` will block the current thread, because that's what it does. `await` will not block the current thread, but *is* a `suspend fun` so can only be called from within a `suspend fun`. 
Ah, thank you - yes, that comports with my understanding.
Why does your blog take 3 fucking seconds to load?
The question is how many tracking scripts get loaded in that time. This post didn't really offer any kind of insight, and another comment here went into detail why a good portion of it didn't even make sense.
Is that not what I said? Maybe I wasn’t clear:P
Just calling it as i see it :-)
The first question is if you want developers from other JVM languages to use it. If it's true then CompletableFuture is better. Even if it's only Kotlin, I think that for people that use coroutines it's easier to use CompletableFuture and transform that then people that are using other framework and will struggle to bridge coroutines to their framework. Having said that, I think the best for convinience is to have two flaviours of the API, one with Future and one with suspend methods, and that what I did in the API in the lib I develop: jasync-sql. see it in the [wiki](https://github.com/jasync-sql/jasync-sql/wiki/Kotlin-API).
This https://stackoverflow.com/a/46247234/97777 is the best I’ve come up with
The way that I do this is using multiple objects. I have the following defined: ``` /** * Interface describing an ID of some resource */ interface Id&lt;out T&gt; { /** The value of the ID */ val id: T } /** * The identity of some resource * @property id The ID value * @property updated When the resource was updated */ data class Identity&lt;out ID : Id&lt;*&gt;&gt;( val id: ID, val updated: Instant ) /** * Representation of some resource * @property identity The identity of the resource * @property data The data of the resource */ data class Resource&lt;out ID : Id&lt;*&gt;, out DATA&gt;( val identity: Identity&lt;ID&gt;, val data: DATA ) ``` In your case I would then define: ``` data class UserId(override val id: Int): Id&lt;Int&gt; data class UserData(val name: String, val age: Int) ``` The advantages here are that I've separated the raw data of a user - `UserData` from the metadata about the record. I can, for example, create a new user by using `UserDao.save(data: UserData) : Resource&lt;UserId, UserData&gt;`. It does mean that there's an extra level of indirection to access the properties, but the null safety in Kotlin makes that easy. I can just do `user.data.name` instead of `user.name` and know it'll work.
Even later here, out of curiosity, why are you considering that direction? I am more tempted to do Kotlin-to-Go, as Go's native implementation so far is superior but Kotlin as a language is much saner (Go is too simple, I hate 'go generate' required by lack of generics with passion). Disclaimer: I have done some Go projects, and am just looking at Kotlin, but so far very impressed with that.
I do this in my code: `dsl.transaction(fun() {` `})` No warnings.
Data classes only reference the properties that are defined in the primary constructor when generating the toString, equals, and hashcode functions: https://kotlinlang.org/docs/reference/data-classes.html#properties-declared-in-the-class-body So you just need to declare the auxiliary information that you don't want to be included innthe body of the class instead of in the constructor.
Or you can add extension properties and have both? 
Yeah, that works, but it also breaks the nice DSL style that having a lambda as the last parameter gives you.
Thank you for the suggestions. I don't anticipate use from other JVM languages as my library relies quite heavily on Kotlin language features. I'm not sure if it will be practical to maintain parallel libraries, and CompletableFuture has the advantage of being able to create several of them and then wait on all of them to complete in parallel, which is quite useful in my situation.
This is something I've toyed with as well: https://github.com/cretz/goahead. But the Go compiler couldn't take it: https://github.com/golang/go/issues/18602. I'm going in this direction because there's a lot of go libs I want on the JVM.
If this issue is about kotlin, you should ask which specific kotlin problem are you trying to solve. If this issue is about the RecyclerView framework, this should be in r/androiddev - specifically the weekly questions thread.
The issue is not a bug at all but my in-ability to create a low maintenance adapter for a recyclerview
I don't know your case, but for me the suspend function is only wrappers so no maintenance overhead: [https://github.com/jasync-sql/jasync-sql/blob/master/db-async-common/src/main/java/com/github/jasync/sql/db/SuspendingConnection.kt](https://github.com/jasync-sql/jasync-sql/blob/master/db-async-common/src/main/java/com/github/jasync/sql/db/SuspendingConnection.kt)
You make a good point, why not use both? I guess the counterargument might be that using `.await()` is no more of an imposition than using your `.asSuspending`.
Can you please clarify what you mean?
Sorry, my point is that with a CompletableFuture you can use `.await()` to take advantage of Kotlin coroutines. Is using `.await()` any more trouble than using something like `asSuspending` earlier in the call-chain?
That's still an Android Framework question, and not a Kotlin one. [This](https://www.reddit.com/r/androiddev/comments/ab65lu/weekly_questions_thread_december_31_2018/) is the place for your question. Not r/Kotlin
It ***is*** a kotlin question because the code is written in kotlin....I have a question about coding a recyclerview adapter in 'kotlin' I'll show a snippet of what I have so far in about 30mins.
The key takeaway is that Kotlin allows us to extract more patterns than what is possible with Java with one example being that Java lambdas are not as capable as Kotlin (eg. don't allow checked exceptions, aren't closures, etc.). OP was suggesting that we shouldn't rewrite Java code in Kotlin but Kotlin allows us to make our code more robust by leveraging capabilities which don't exist in Java. Now to answer your question, the behavior would be very different since removing the inline keyword will no longer compile for less trivial use-cases. I trivialized the above example but we usually have various checks and early returns. As an example, you could return from a forEach lambda the same way as you could from a standard for-loop because it's inlined. This behavior is only possible with inlined lambdas and isn't possible in Java. Another less obvious difference is that the stack trace differs so this could change the behavior if this is enclosed in a try / catch higher up which branches based on the result of analyzing the stack trace &amp;#x200B; One side note is that the return keyword has a single meaning in Kotlin (return from the closest enclosing function) whereas it has different meanings in Java depending on context. This is really important to note because of the Kotlin last lambda parameter calling convention which makes the code much more clear and readable. &amp;#x200B; Some more reasons for using inline lambdas: 1. It's a Kotlin best practice to mark functions that accept lambdas as inline (when possible and as long as you keep the body of the inlined function small) 2. Inline allows us to use lambdas everywhere liberally so the codebase quality improves. In Java, we always think twice before using lambdas (eg. don't use capturing lambdas in a tight loop etc.). So inline avoids any scalability concerns that you could get from Java lambdas (increased memory usage, increased cache misses due to indirection, increased pressure on garbage collector leads to increased latency or even GC loops, small object creation overhead, etc.). Inlined lambdas also enable additional follow-on JIT optimizations. 3. Inline lambdas make it much easier to debug defects when analyzing stack traces (looking at stacktraces for exceptions thrown from non-inlined lambdas can be misleading sometimes and definitely not as clear)
The main advantage is that \`asSuspending()\` returns an interface that all it's method are suspending. So reusing that interface can save you more than one \`await()\` call. It can also help users understand how to use the lib.
Ah, yes - that is true, thank you. This probably isn't an issue for you, but in my application the ability to call `await()` several times is actually an advantage - since it means you can obtain several Futures and then wait on all of them in parallel.
That's a good point.
Makes a lot of sense. Thank you for the response!
It'd be nice if this could be done automatically
Good idea. For JUnit 5 it is pretty easy to do with the extension.
The code won't really compile if exception isn't handled. Runtime exceptions and errors are allowed to be unhandled though. But should you really be expecting a runtime exception? That's like putting a try catch for a index out of bound exception. And errors you should never handle, those are out of memory and such.
You cant really compare the two. Kotlin2js is for devs who want an isomorphic Kotlin experience which is working right now. I don't even want to use anything from the js ecosystem. I can use all multiplatform projects which happen to have a js target. Ts is for js devs...or for people who got fed up with js and want something which sucks less.
Dunno why you say that. Isomorphic Kotlin is a thing, and kotlin2js is part of that.
I dont want to use ts. I dont care what it solves. I want isomorphic Kotlin and I get it with Kotlin2js. This is infinitely better than struggling with crap js libs.
You're probably thinking of Java. Kotlin doesn't force you to handle checked exceptions.
Hi! There are two main linting tools right now, one of them is [ktlint](https://github.com/shyiko/ktlint) and the other one is [detekt](https://github.com/arturbosch/detekt). They check things like number of methods in a class, number of columns, whitespaces policy, etc. I'm not sure if any of those detects unhandled exceptions though. I'm now working on a tool to create your own rules using Android Lint (still in alpha/beta), it's called [Lin](https://github.com/serchinastico/lin) and you might find it useful if you want to go that path. How would you want to go with those exceptions? Should it raise an error if there is just a `throw Error("")` line? Or should it traverse the whole callers graph to see if there are no catches in the way? The first approach is really easy with Lin, the other one I'd go by creating a custom Android Lint by yourself. Finally a word of advice: exceptions are often avoided in the Kotlin code I've seen and I've been working on. That's because with [sealed classes](https://kotlinlang.org/docs/reference/sealed-classes.html) and [nullable](https://kotlinlang.org/docs/reference/null-safety.html) types you can create generic data types representing error scenarios (What in other languages is called Maybe/Optional + Either). Instead of throwing a `UserNotFoundError` you can just return a value of type `User?`. If you need to know what type of error you got, you can use a generic `Either` implementation like [this one](https://gist.github.com/Serchinastico/6993b69f79057eefa9a32650d23d17b6) and return `Either.Left(UnknownError)`.
Very late to this but.. We use both Go and Kotlin on the back end. For a lot of what we do Go is great. It's super simple and quick to learn, has a lot of very good packages which tend towards the small and composable which aids in the shallow learning curve, is a breeze to deploy in a container and has excellent concurrency support. We use Kotlin where go support is a little lacking. It's great a big improvement over Java but still a steeper leaning curve than Go, build and deployment is more problematic and it's more resource hungry. Where it wins though is being compatible with the huge range of JVM libraries, many of which do not have mature Go alternatives and would be impractical for us to port. It's not really an either/or choice unless you are building a monolith. Use the best tool for the job. 
Thanks, planning to build a small backend with integration with databases like MySQL, elastic search, storing images etc, need lower server costs as well, kind of a startup. I'm leaning towards Go
That's exactly what `async` is for, executing multiple coroutines in parallel. It also would fulfill a core coroutines design objective: `concurrency must be explicit`
To my knowledge there is currently no tool and no IntelliJ rule which can detect this case. Anyway, you could try to write your own custom rule with [detekt](https://arturbosch.github.io/detekt/extensions.html#custom-rulesets). You can find the documentation [here](https://arturbosch.github.io/detekt/extensions.html#custom-rulesets).
No offense but who the **** uses that? I never heard about it before. There is a jetbrains video about it on youtube with less than 20 likes.
Offense: your douche behavior is not welcome here.
I for example use it to great effect. Much better than the half-dead npm mess.
Just because you don't know about it doesn't mean that no one uses it. You should do some research next time before posting dumb comments on Reddit.
This was exactly my thought when i read the example, but since i haven't used mockk yet, i was to shy to say it :)
Is ProGuard even kotlin-compatible? I wouldn't use them together. Then it would work just fine.
I switched to moshi because it handles kotlin non-nullables properly. Don't know if this will help with defaults but it might be worth a look if it's not too much effort.
Sure, many people proguard their Android apps. IDK if Jackson is popular there though, I use GSON or Moshi.
I had to switch off Jackson after learning that the maintainer has/had some fairly silly views on what a serialization library is supposed to do. For instance, apparently it's the serializer's job to ensure your JSON doesn't contain duplicates. Duplicate objects or ids would cause errors by the serializer, which means you couldn't have JSON that looked like this: //list of students [ { "id": 1, "name": "john", "courses": [ { "id": 1234, "name": "algebra" } ... ] }, { "id": 2, "name": "sarah", "courses": [ { "id": 1234, "name": "algebra" }, ... ] }, ... ] This would throw an error saying that the course object with id 1234 is duplicated.
On Android, you can use `@Keep` from [Android Annotation support library](https://developer.android.com/topic/libraries/support-library/packages#annotations) for your Kotlin data classes if the JSON library you are using are failing after going through ProGuard.
I have been using KotlinX Serialization for JSON with great success in the past. It handles default values quite well. https://github.com/Kotlin/kotlinx.serialization
Calling BS on this; I've used Jackson a lot and even dug around the source a fair bit, so this smelled off, but you made me actually double-check to prove it, and this JSON serializes/deserializes just fine. Sounds to me like the error was coming from your application code, or perhaps you were using an advanced/non-standard Jackson feature, perhaps one that relies on unique identifiers (though none comes to mind). &amp;#x200B; Test code: import com.fasterxml.jackson.databind.ObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import com.fasterxml.jackson.module.kotlin.registerKotlinModule fun main(args: Array&lt;String&gt;) { val objectMapper = ObjectMapper().registerKotlinModule() // deserializes just fine... val students: List&lt;Student&gt; = objectMapper.readValue(""" [ { "id": 1, "name": "john", "courses": [ { "id": 1234, "name": "algebra" } ] }, { "id": 2, "name": "sarah", "courses": [ { "id": 1234, "name": "algebra" } ] } ] """.trimIndent()) println(students) // re-serializes too... println(objectMapper.writeValueAsString(students)) // maybe you meant serializing using the same Course object reference? val algebra = Course(id = 1234, name = "algebra") // nope, that works perfectly also... println(objectMapper.writeValueAsString(listOf( Student(id = 1, name = "john", courses = listOf(algebra)), Student(id = 2, name = "sarah", courses = listOf(algebra)) ))) } data class Student(val id: Int, val name: String, val courses: List&lt;Course&gt;) data class Course(val id: Int, val name: String) &amp;#x200B;
Whenever I use Kotlin data classes with Jackson, I make sure I specify `field` for the annotations, ie. `@field:JsonProperty("foo")`, so we end up annotating the actual Java members and not just the constructor parameters. I do it to ensure that Jackson knows where to get values when serializing, but since Java doesn't really have support for default arguments, I imagine it might be necessary to make those work, too.
thanks for putting the effort into this. I knew it to be wrong but wouldn't have bothered myself.
The dude might've changed his mentality on it at some point, but it was strange enough at the time for me to not even bother with it anymore. I went ahead and dug up [the old github thread](https://github.com/FasterXML/jackson-databind/issues/266) for you. Some quotes from the thread: &gt; You are trying to use two objects with same object id -- that would seem to be your bug right there. So you need to resolve the problem of producing duplicate ids. Jackson has no mechanism for resolving duplicate ids, and I don't think that it something that should be allowed. &gt; Input JSON has two full department definitions, both with id 9. Use of JSON Object is taken to mean POJO, and references MUST use simple scalar values. So from Jackson perspective you do have conflicting definitions, two departments that claim to have same id.
Appreciate the response; it seems like I was on the mark with: &gt;perhaps you were using an advanced/non-standard Jackson feature, perhaps one that relies on unique identifiers (though none comes to mind). In particular, it appears that the use of `@JsonIdentityInfo` was at fault. I'm not super familiar with it, but it appears to expect the identified object to be unique or to otherwise be explicitly resolved, as an answer further down your github issue points out + provides a gist for.
Should be configurable, I don't wanna fill tests with useless verifications that are not asserting the exact unit of work I'm testing
&gt; I hope that Kotlin coroutines will progress and let us express more information about functions. I think you mean contracts instead of coroutines here.
I went over two types of projects. I half built a SMS app for animations, new Android architecture components and Kotlin focused more on the design and not functionality. I then built a web scrapping MVVM list view filtering app for a website I hated the mobile website design. This give me plenty of time to learn Kotlin and use it while testing different aspects of daily development. If you need an API to test your web stuff on, hit up Wargamings API for players and build out something for that. Hitting a third party API and showing results on lists and profiles is the bread and butter of our jobs. Try out different architecture as well. Do MVP, MVVM and MVI, use different libraries that you don't normally use.
I do like the buildSequence function, but once you have a `Sequence` why not use its abstractions? I guess you have to way up the benefits you mentioned (communicate the purpose better, debugging) and the amount of extra code. For this specific example the amount of code saved would sway me in the direction of a fluent API. import java.io.File fun main(args: Array&lt;String&gt;) { val file = File("path/to/access.log") val total = file.useLines { lines -&gt; lines.filter(String::isNotBlank) .map(::getBytesColumn) .mapNotNull(String::toIntOrNull) .sum() } println(total) } fun getBytesColumn(line: String) = line.split(" ")[9]
I still don't know anything after this article lol
Both work actually 😋
You know those extensions methods you think are the best thing in existence? Ya now you can give it more documentation, protection and annotations with doing less. Like want to have the app crash if the element being sent is null, you can do that. The end of the article says this is still a work in progress part of Kotlin. We shall see want this actually does
ah, that sounds pretty cool indeed
Its good but needs to do more as knowing that it takes 10-20s doing what it does yourself without having to know about these random usage method calls.
They not only feel more at home with YouTrack - they BUILD YouTrack ;) [https://www.jetbrains.com/youtrack/](https://www.jetbrains.com/youtrack/)
As the parent said in his comment, the "crap js libs" have been rewritten in TypeScript, like Angular, Vue, etc. I think that with the rise of TypeScript, the ship has sailed for Kotlin/JS in the mainstream. By what metric is Kotlin/JS infinitely better than TypeScript? And why isomorphic will help your cause?
&gt;this thank you for your valuable feedback. It helps us to improve our writing. 
&gt; **I think** ^^^--- this is the main point. You just *think*, but you can't be further from the truth. You just need to check Google Trends, Stack Overflow Trends, etc... Javascript is declining for more than a year and Kotli is rising exponentially. Apart from this with Kotlin you can have a single project which will run your server, desktop client, web client, native client with a shared codebase. You simply can't do this with ts without either being constrained or hard to set up / use. And I haven't even started talking about the quality of js libs, npm, which is not even deterministic and the ecosystem which allows things like the [kik fiasco](https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/) to happen. This is simply unimaginable with Maven/Gradle + Kotlin.
I have checked Google Trends, comparing javascript against typescript and kotlin keywords. It seems like JavaScript has always been stable, TypeScript is on the rise and Kotlin has a modest growth. All of them decreased in the past weeks because you know... Christmas, family time and stuff. I did the same for Stack Overflow Trends, jQuery and AngularJS are decreasing in popularity and others like Angular and ReactJS have a huge growth \[0\]. I don't know where do you get your statistics from and how you interpret them, but "Kotlin rising exponentially" is an overstatement. It is still way smaller than Scala community. Secondly, I can't have the luxury of a single shared codebase. Only if I am building non-production ready apps. My daily work involves scalable systems built around Spring &amp; Hadoop ecosystem, streaming frameworks and data analysis. Kotlin is totally out of the question. Period. Moreover, NPM, Maven &amp; Gradle are in no way impacted by JavaScript or Kotlin. Deleting/Modifying something from an artifactory and breaking the build process is more common than you think in a lot of companies. You are correlating apple with oranges. And there are a lot of gems in the world of JavaScript libraries. Web development is a hard domain from an engineering point of view. As I have told my friends in the past, Kotlin is all about Android, but for server-side Java and data stacks, I would rather stay away from it. \[0\] [https://stackoverflow.blog/2017/05/09/introducing-stack-overflow-trends/](https://stackoverflow.blog/2017/05/09/introducing-stack-overflow-trends/)
I did not check the last 2 weeks but the last 5 years. Kotlin has already surpassed Scala. Even the Scala guys [admit this](https://www.youtube.com/watch?v=v8IQ-X2HkGE&amp;feature=youtu.be&amp;t=375). You are wrong **again**. Period. I actually work with **Spring** &amp; **Apache Spark** &amp; **Databricks** on a single unified Kotlin project every day. I have never been this productive with anything else. Just because you didn't bother to try it does not mean that i is not possible. It **is** possible and it is also easier to interface with BigData libraries from Kotlin than from Java. I am not comparing apples with oranges. You **can't delete** an artifact from Maven Central. If you publish something there it will be there even after the world is consumed by nuclear fire. I didn't say that Maven, Gradle or npm was impacted by Kotlin or javascript, dunno where did you read it. I said that npm and the javascript ecosystem was broken and I backed it with concrete examples. There are no such examples for Java because it doesn't happen. Kotlin is **definitely not about Android**. Maybe you have been sleeping under a rock, but even the **most prominent backend frameworks, like Spring embrace Kotlin**. Spring 5 comes with [first class Kotlin support](https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0). You can [ditch groovy for Kotlin in Gradle](https://docs.gradle.org/current/userguide/userguide.html) since it is supported out of the box. Even smaller frameworks like Sparkjava ([link](http://sparkjava.com/news#spark-kotlin-released)) come with Kotlin support out of the box. You are totally wrong in your last claim and again you don't back any of that up with data. Maybe it is time for you to take an actual look instead of living in a fantasy world.
Hi guys, author here. I've recently given a few talks about Kotlin/Native. Many found them quite useful, so I've decided to summarise the content into a set of tutorials. It'd be great to get some feedback/constructive criticism around the content or some pointers on how to improve it further. Thanks!
Awesome thanks! I just started learning kotlin, I'll definitely take a look 😀
I wish there was a real competitor to JavaScript in the web. I don't see web assembly taking off any time soon. I would like to see Dart rise in popularity
Most of the questions from StackOverflow related to JavaScript have been solved. New questions are on the rise only when ECMAScript brings new changes to the language. JavaScript has a huge ecosystem, the tags on the questions can vary. When I want help for Vue, I don't tag my question with JavaScript at all. The metrics that you are using to demonstrate that Kotlin surpsassed X are flawed. Javascript tag alone currently has 1740489 questions, 810 asked today, 4407 this week, while Kotlin has a much smaller rate, 55 asked today, 284 this week. When you say that JavaScript is on the decline, you are comparing the behemoth with the behemoth itself. Apache Spark tag has 42 asked today, 226 this week, let that sink in. (and no, it is not PySpark or other interfaces). And again, StackOverflow is a bad metric to measure the popularity of a language. You are just predicting the likelihood of the next question being about Kotlin. &gt; It **is** possible and it is also easier to interface with BigData libraries from Kotlin than from Java. All the Big Data frameworks that you are talking about have supported Java interfaces and none provide mature, stable Kotlin ones. &gt; You **can't delete** an artifact from Maven Central. I have never said that. Only that companies (that I worked for) use their own artifactories, not Maven Central. Only some packages are mirrored. And yes, you can delete an artifact from JFrog. &gt; Kotlin is **definitely not about Android**. Take a look [here](https://octoverse.github.com/projects#languages), you will see that the Top Topics table has React on the first place, Android on the second place, NodeJS third and the Fastest growing languages has Kotlin at 2.6x, TypeScript comes second at 1.9x. You can correlate those and infer that both are driven by those hot ecosystems. 
I can't access the site right now (web filter on our end 😭). Does your site cover kotlin/native windows?
This sounds awesome. I'm going to have to take a close look some time soon.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/grpc] [gRPC + Kotlin + Coroutines: Kroto+ 0.2.2-RC1 is released, featuring async client \/ service code gen with backpressure support.](https://www.reddit.com/r/grpc/comments/adykze/grpc_kotlin_coroutines_kroto_022rc1_is_released/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
&gt; Most of the questions from StackOverflow related to JavaScript have been solved. I don't see how this relates. &gt; The metrics that you are using to demonstrate that Kotlin surpsassed X are flawed. If it is flawed then all your arguments are also flawed where you use Stack Overflow metrics. &gt; When you say that JavaScript is on the decline, you are comparing the behemoth with the behemoth itself. This doesn't mean anything. It is still declining no matter what I compare it to. Javascript has been around for 20+ years while Kotlin is realatively new. What is important to see here is the trends. Javascript goes down, Kotlin goes up. You sound like someone who was a VHS fan and will keep VHS cassettes at home eve after BlueRay is long fogotten. &gt; Apache Spark tag has 42 asked today, 226 this week, let that sink in. Again, not related. You can't compare Apache Spark (which is a framework) to javascript (which is a language). &gt; All the Big Data frameworks that you are talking about have supported Java interfaces and none provide mature, stable Kotlin ones. You don't need Kotlin interfaces since Java + Kotlin interop is seamless. I can write a Kotlin library which you won't even recognize it is written in Kotlin. In fact this had already happened. It is obvious that you don't know anything about Kotlin so you should stop making a fool of yourself. &gt; I have never said that. You *implied*. I don't know what kind of companies did you work for but literally everybody uses OSS libraries published to Maven Central. Even IBM, Siemens and Volkswagen does this. I know I worked for them. What the point is that with javascript you don't even have the option to have immutable artifacts. &gt; Take a look here I'm not taking a look since I have already proved my point. You are just trying to ignore the facts and failing at it. 
You still didn't understand what I was trying to say. Keep cherry-picking, after all, everyone's entitled to their opinion. But just stop using the words 'facts'. They are mere correlations.
"generating lambda based builders" &amp;#x200B; Is this like a code generator?
This project is a plugin for the protobuf compiler `protoc`. Protobuf just so happens to be the definition format for gRPC services as well as data models. There are existing plugins for generating data models, clients, and services for just about every language. This one aims at making generated java code more Kotlin friendly. 
And you still don't understand a single thing. But hey, this is what's expected of a javascript dev.
Actually had some trouble getting into kotlin/native based on the official documentation. Might try your tutorials later. Wanna make OpenGL apps.
Does it support win32? And why does it not support C++?
\&gt; Kotlin/Native does not support C++ libraries, only C and Objective-C. It’s possible in theory, but hard to implement, and currently no plans for this. From the team.
Great job! I'm eager to use it, although don't think I will be able to include on my workday projects until it is production ready. Some support from Jetbrains would be awesome!
We've been using it in production at my current job slowly ironing out kinks. The current RC hasnt shown any issues so far so Im hoping to graduate the RC soon after increasing the test coverage a bit. The long term goal is to migrate the project to the kotlin coroutines repo under integrations. You can read more about the current discussions in this github [issue](https://github.com/Kotlin/kotlinx.coroutines/issues/360) and [PR](https://github.com/Kotlin/kotlinx.coroutines/pull/518)
What about win32? Or is it using .net when running on windows?
Great news! I have also been reading the documentation and it is quite better than several "production ready" open source projects. Thanks a lot!
This tool looks really interesting, but honestly the thing I'm really waiting for is [support for other SQL dialects](https://github.com/square/sqldelight/issues/1009). I'd really like to try using this with PostgreSQL. Any idea when non-SQLite support will be available? Is there anything that could be done to help it along?
It's a big task, for sure, but we're excited by the prospect of it. I don't know how to encourage you to get started. Maybe /u/rewind can chip in here?
It's a big task, for sure, but we're excited by the prospect of it. I don't know how to encourage you to get started. Maybe /u/rewind can chip in here?
There are several decisions in Kotlin where one can that there were some C# fans in the language design team. Mostly to the language's detriment, in my opinion.
The bulk of the work is actually in a separate project: https://github.com/AlecStrong/sqlite-psi That's the compiler backend which parses .sq files into the SQLite AST. For other dialects this needs to modified to parse a .sq file into some compile-time-specified dialect. SQLDelight already does since it's a variant of SQLite which adds custom kotlin type syntax, labels, import statements, and some other things. I'm in the process of writing some blog posts detailing the internals of SQLDelight to better document how to work on the project. Stay tuned for those, and I'll use them to kick off some github issues to track pluggable dialect support which I think will be the next major feature. Those issues will probably be the best forum for figuring out how to contribute if that's something you're interested in.
Wonder will it be possible some times to implement in Kotlin anything similar to SQLSyntaxSupport from [http://scalikejdbc.org/documentation/sql-interpolation.html](http://scalikejdbc.org/documentation/sql-interpolation.html) ? I was really impressed how it can bring together best of two worlds - type-safety and pure embedded SQL queries. Yes, I know it's a Scala with a lot of compile-time magic under the hood. I used it in one Play-based project and wish to have it in Kotlin which is now my main dev language :-) And yes I know that even in Scala-world a lot of people use type-safe builders similar to Exposed, etc. But I still believe that none of them are as expressive and flexible as pure SQL. Or maybe I just need to leave behind my ancient habits? I used to be a PL/SQL developer 10 years ago ...
The Kotlin design team has been pretty open about its influences, and yes, C# is one of those influences. However, the occurrence of an I letter in a single code example in the docs and the behavior of a single action in the IDE (which is what all of this hubbub is about) were not decisions made by the Kotlin design team, so I'm not sure how your generalization is applicable.
The tutorials and code have been written using a Mac, and I'll admit they do come with a bit of a unixy flavor. However, Kotlin/Native is fully supported on Windows and simply updating a few paths with `\` instead of `/` should get you through it with no problem. Let me know if you run into any issues, happy to help further.
Win32 is [fully](https://github.com/JetBrains/kotlin-native/tree/master/samples/win32) supported out of the box, with no `.NET` involvement whatsoever. 
I completely agree with above solution. Thanks for putting it out there.
Most of the Kotlin standard library is available on all platforms. You can also use Kotlin multiplatform libraries which support the native target, as well as native libraries. You can't use JAR libraries. You can FFI to the JVM if you really want to, but there are no tools to make this easier. Kotlin/Native is self-contained, it does not require any other compilers to be installed.
According to the comaprison table Kotlin/JS has "None" documentation. I think, instead the official Kotlin language documentation ([https://kotlinlang.org/docs/reference/](https://kotlinlang.org/docs/reference/)) should be linked, because it applies to Kotlin/JS also. Regarding the Kotlin Standard library it is also made visible, what APIs are supported on what platform (Common, JVM, JS, Native): [https://kotlinlang.org/api/latest/jvm/stdlib/index.html](https://kotlinlang.org/api/latest/jvm/stdlib/index.html)
Thanks for the feedback. I have been doubting on this, but while there is indeed documentation on the Kotlin language, there is hardly any documentation on Kotlin.js specifically. For example, documentation on how to get started, how to integrate it into build systems like gulp or grunt, etc. So, I tried to keep things 'pure' by focussing on the JS part of Kotlin only. For example, there are also a few books on Kotlin, but none of them focus, or mention Kotlin.js even (at least, afaik)
Wouldn't TypeScript be that competitor? It's a safer language than JavaScript in terms of types and nullability, and has quite some interesting features which make it a competition to JS.
Yes, you are right, and I think this only affects build configuration or bootstrapping a Kotlin/JS project. There are some examples on GitHub though. Currently the "kotlin-frontend-plugin" is maintained the most, I think: [https://github.com/Kotlin/kotlin-frontend-plugin](https://github.com/Kotlin/kotlin-frontend-plugin) The repository has also examples how to use it with a custom webpack configuration: [https://github.com/Kotlin/kotlin-frontend-plugin/tree/master/examples/custom-webpack-config](https://github.com/Kotlin/kotlin-frontend-plugin/tree/master/examples/custom-webpack-config) You can also find examples, how to use gradle for Kotlin/JS compilation only and npm directly for bundling and so on: [https://github.com/gbaldeck/vue.kt](https://github.com/gbaldeck/vue.kt) Of course it would be nice, if the documentation how to bootstrap a Kotlin/JS project would be better.
Great, thanks for sharing. I'm not sure if you saw it, but there's also this project: https://github.com/JetBrains/create-react-kotlin-app (It's still quite beta though) And this one seems to be interesting too: https://superkotlin.com/kotlin-javascript/ the reason why I was a bit harsh on the 'none' part is that I think a tool like Kotlin.js deserves good documentation to have any adoption. Something like cross target compilation (for example, create an util class which is usable in both JS and JVM), Kotlin+NodeJS, Kotlin+Vue, Kotlin+Webpack, maybe even Kotlin+Typescript, etc, it would be great if (some of) these options would be documented. Right now, it's not much more than this: https://kotlinlang.org/docs/tutorials/javascript/kotlin-to-javascript/kotlin-to-javascript.html And I think that's definitely an area where big improvements can be made.
Is the only Android-specific bit of this the fact that it comes with Android-specific detectors? I'm wondering if there's value in the DSL for non-Android projects.
This is certainly possible with a compiler plugin but I'm not sure if we'll ever go that route. Definitely not while compiler plugins are an unsupported feature. Once they are stable it's worth a look to see if it can be leveraged to improve the developer experience.
Android Lint isn't even Android-specific since about 18 months ago. It works fine on any pure Java or Kotlin (or mixed) codebase.
I'm afraid it will only work for Android projects because Lin creates [Android Lint](https://developer.android.com/studio/write/lint) detectors. Lin is focused on a project's code but there are many other Android-specific things you can check with the linter like XML resources.
I was about to say it wasn't possible so there is that.
Nice. How does this play with flutter?
Why are contracts not annotations, instead of normal code that don't get compiled?
Interesting but I don’t really like the explanation. What if there’s a case when there is no “driver?” Ie fun thing()=launch{ println(“Gonna be suspended!”) delay(1000)//Delay println(“I hath waited”) } All this does is pause it. No one really “gets control” as it’s not waiting on anything. While he explains usages of it well, I think that really suspend functions should just be defined as functions that may contain code that pauses execution with that pause defined by time or outside interactions
Most of the blog post compares language features but then concludes with this question: “Why did Google choose Dart for Flutter?”. The author never considers that Typescript and “Kotlin.js” do not compile to native binaries, which is a core feature of Flutter apps. Kotlin/native does compile to native, and could have been an option for flutter, but is still in beta in 2019. There are other characteristics of the Dart VM (or runtime) that make it suitable for Flutter development. Otherwise, someone would have made a Flutter based on Kotlin by now. 
Interesting. How long did it took you guys to come with final product? 
I don't understand why you'd want to crash with NPE. Do you mean an easy way to call the method and use the default value if the value you have is null?
Yes, I want to be able use the default value of a non-nullable parameter when a null is passed. Looking for opinions on why this could or couldn't exist in Kotlin. Personally I thought this could be built into the named parameter mechanism (attempt 2 in the example).
&gt; I want to be able use the default value of a non-nullable parameter when a null is passed This will almost certainly never happen. It's too easy to do accidentally (from Java) and it's weird and confusing from Kotlin.
Doing that breaks the type system. It was socially designed so that don't have the constant fear of null values coming into your code when you don't expect it. The function you want to call was explicitly written in a way so that it doesn't have to consider null values. If you pass a null value, it almost certainly will cause a NullPointerException. Your code has the nullable type and your code has the context to properly decide what to do when the value is null. It is probably best to check the value when it first enters your code, then you don't need to constant check it each time you use it.
The question here is really why someOtherFunction allows a nullable value to be passed into it. The caller of someOtherFunction can probably decide much better how to prevent calling any method at all, if the inputs are null. On the callsite of someOtherFunction, no, there is no proper way other than some if/else or safe call construct.
Well, it was quite long about the initial deadline ;) Here you can read our backstory where we described the development challenges [https://www.netguru.com/codestories/what-weve-learned-by-developing-the-kotlin-multiplatform-storage-library](https://www.netguru.com/codestories/what-weve-learned-by-developing-the-kotlin-multiplatform-storage-library)
You are misunderstanding OPs question. OP doesn't want `x` in `someFunction` to ever be able to hold the value `null`, but rather he wants it to automatically become `1` (the default value) when it would be given `null` as input. I don't think it's such an unreasonable request as it means you won't have your default/fallback values scattered over all the call sites, although I'm not quite sure if `null` would be the way to do it. You'd ideally want union types or something like that for this.
I was thinking the same, but now there's no nice way of utilizing default values in places where the data decides whether a parameter is available or not. This becomes much more pronounced when you have a lot of parameters. Say you have the following function with very specific, non-obvious defaults which are somehow relevant to the inner workings or domain of the function: ``` fun process(a: Long = 1, b: Long = 200, c: Long = 40) { ... ``` And the following situation at a call site val a: Long? = ... val b: Long? = ... val c: Long? = ... process(a,b,c) // obviously doesn't compile So how do you make it compile? Either with the Elvis operator (`?:`), but then you have to put the defaults in there again. If you dont want to do that, your only solution is to write this monstrosity when { a != null &amp;&amp; b != null &amp;&amp; c != null -&gt; process(a,b,c) a != null &amp;&amp; b != null -&gt; process(a = a, b = b) a != null &amp;&amp; c != null -&gt; process(a = a, c = c) b != null &amp;&amp; c != null -&gt; process(b = b, c = c) a != null -&gt; process(a = a) b != null -&gt; process(b = b) c != null -&gt; process(c = c) else -&gt; process() } I don't think reusing nulls for this is the answer though, but I don't see another good solution besides simply not using default values, letting the parameters be nullable and dealing with them in the `process` method body. You want to somehow make a distinction between 'null' and 'not provided'.
I think the best way to accomplish what you're trying to do is with an explicit bridge function, it's not pretty, but thanks to extension functions, it can be relatively easy to use: const val DEFAULT_X = 1 fun realFunction(x: Long = DEFAULT_X) { ... } fun bridgeFunction(x: Long?) = realFunction(x ?: DEFAULT_X) This pattern doesn't get much more ugly if there are a handful of parameters, or if some should be nullable/default while others should be required: const val DEFAULT_X = 1 const val DEFAULT_Y = 42 fun realFunction2(x: Long = DEFAULT_X, y: Long = DEFAULT_Y, z: Long) { ... } fun bridgeFunction2(x: Long?, y: Long?, z: Long) = realFunction(x ?: DEFAULT_X, y ?: DEFAULT_Y, z) 
That's it exactly
Thank you, I love the idea of multiplatform kotlin libraries coming out. Looking forward to see more stuff from your R&amp;D department :)
If you want a true either type you can use https://arrow-kt.io
You can use Java OpenCV with Kotlin or the C++ version (through NDK in Android) for maximum performance. 
There is no compatibility problem on use Java OpenCV on iOS?
If you don't need to return any extra information together with the negative lookup result, then using `null` is exactly the idiomatic solution, and is also more efficient than creating an `Either` instance.
I feel like a "default" keywork would be the best solution.
 ``` y?.let { someFunction(it) } ?: someFunction() ``` is the best I can do. I don't think you can get the default value out of the function to pass it as an argument.
Yes, some new language construct could make for a much cleaner solution.
I think that having to be explicit about this is preferable (check if your param is null and if it is, call the function without parameters).
Java can't be used in iOS (as far as I know). In this case you have to use the C++ version for both platforms
Thanks, I'll try
I'm excited to use these once they are out of "Experimental".
Thanks for your feedback, that's appreciated. The compilation to native is a bit of tricky subject, which you addressed already for Kotlin: both Kotlin and Dart can compile to native, but Kotlin is still quite immature in this (but getting there). TypeScript can actually compile to native code (https://github.com/AssemblyScript/assemblyscript), and from a developer's perspective, a similar approach for iOS/Android would have been nice, it would have saved people from learning Yet Another Programming Language.
Ok, that wasn't clear to me when I first read the question. I still feel like I wouldn't want something like that to be atomic. Not paying an argument and passing an argument that happens to be null are different things. If it is your function, it's easy to implement. If it's 3rd party code, it's not hard to wrap it.
I basically ported Rust's `Result&lt;T, E&gt;` for my project for this purpose (needing to supply a result value or error data), also using a sealed class.
I've considered using this approach in the past but opted not to for various reasons at the time. @jakewharton, could you or someone please explain: 1. what the trade-offs/drawbacks(if any) are using this approach instead of normal ids? 2. we use a generics based DAO/Repository pattern such as **UserRepository : Repository&lt;Long, User&gt;**, where Long is the primary key and User is the model, and most CRUD methods are provided out of the box in the base class. what would be the impact of using inline classes for the ids here? 3. lastly would this approach make code more complex in any ways? Thanks 
Hello, Thank you so much for feedback. What i really meant is , coroutines are also running over the threads , in fact because of this feature of voluntarily releasing control of the thread , we can run thousands of coroutines on a single thread cause its not blocking. When i meant i releases control, i meant the control goes back to driver thread which can then schedule other coroutine to run and if that coroutine also yields , it can move to other one. This is what it is known as cooperative concurrency. Also imagine if coroutine releases the control with delay (), while i agree that it is not doing anything but it is also expecting to be resumed after that delay. Resuming after the delay is the job of the driver. Hope that makes for a little better explanation than that i did on the blog. Let me know what do you think. Again thanks a lot for reading the blog. 
Ah ok so you’re basically explaining how suspending is non-blocking? I would maybe make that a little clearer. Great blog!
In short, yes. Kotlin is official Android language, all Android documentation includes code references/snippets/examples in Kotlin (as well as Java). In fact, you can even do things in Kotlin for Android that you cannot do in Java, like automatic view referencing in your activities, for example. For a modern approach to Android development, make sure to check Jetpack, Google's Kotlin-first library. 
Yes, Kotlin can do everything Java can and you can even use existing Java libraries from Kotlin. Actually, I lied because many categories of defects that are possible in Java are impossible with Kotlin ;) There's also Kotlin multi-platform which allows you to share 80% of the code between iOS and Android (pretty much everything except for the UI)
for #2 it would become UserRepository: Repository&lt;CustomID, User&gt; and prevent you from accidentally passing your id you constructed for ProductRepository: Repository&lt;Custom2ID, Product&gt; where both CustomID and CUstom2ID are Longs.
If you want null to be treated as a default value then you should define the function as accepting nullable parameters and define the default in 1 place manually. ``` fun doSomething(y: Long?, x: Long?) { val yValue = y ?: 0 val xValue = x ?: 0 ... } ``` And now you can call it from different places and the defaults are only defined in one place.
Yes. absolutely. Thanks for the feedback.
Flutter has nothing to do with Google/Oracle relationship, and Java/Kotlin is not on the way out.
Looks like your modifying your sample until the arrays full (size == MAX_LEN). The next function checks the size of the arrays on THE SAME OBJECT again, and since it is already MAX_LEN, does not need to do anything. The assignment var ret_vakue = sample Does not clone the data
80% might be a bit high on that estimation, but Kotlin is amazing and there is no reason to use Java for Android. Worst case they are interoperable anyway. 
I suppose the exact percentage depends on how complex the app is underneath the UI (data models, query capabilities, business logic, validation, unit tests, etc versus the UI code)
I would recommend stackoverflow.com for these types of questions
Have you had any luck using it with the AWS sdk at all? Or another third party lib? How well does it integrate with those?
You should return a mutated copy of the sample object. Something like this: ``` fun DoubleArray.padLeft(): DoubleArray = DoubleArray(MAX_LEN - this.size) + this fun pad_left(sample: Sample: Sample = Sample( sample.timestamp.padLeft(), sample.absoluteSquare_flow.padLeft(), sample.x_float.padLeft(), sample.y_float.padLeft(), sample.z_float.padLeft() ) 
As others have said, `var ret_val = sample` does not do what you want it to do. `ret_val` now points to the same object as sample, so when you modify it in the function, you're modifying the same object that's being passed in to the other functions.
I've used various Java libraries from Kotlin and usually don't even notice it because Kotlin exposes Java classes in a Kotlin friendly way (eg. property syntax). I haven't used AWS sdk myself but 10 seconds of googling got me here showing examples of using the AWS Java SDK from Kotlin: [https://github.com/bertanasco/aws-kotlin](https://github.com/bertanasco/aws-kotlin)
Wow! Thank you for sharing
Interesting idea. Here are my thoughts: 1) You're missing /src/main/resources, so I can't run this to try it out. 2) Why are you writing to sql-lite? Why not just store the decompose outputs into memory, or serialize them? Is the output very large? I probably wouldn't use a library that brought in sql-lite unless there was a really good reason to use it. &amp;#x200B; Here is a presentation I put together on creating, and publishing an OSS project to maven central. [https://docs.google.com/presentation/d/1sTDRgbG09XoAbszGwzFeU2\_t4b3kVq7AsT5dRagCijg/edit](https://docs.google.com/presentation/d/1sTDRgbG09XoAbszGwzFeU2_t4b3kVq7AsT5dRagCijg/edit) Here is one part of a project I've published. You can check it out, including the travis build file to see how i configured it. [https://github.com/GreaterMKEMeetup/slack-integrations-api](https://github.com/GreaterMKEMeetup/slack-integrations-api)
The biggest downside will be you won't know how much better Kotlin syntax is over Java.
The idiomatic thing to do is for the function to return a nullable type and return null when an entity doesn't exist matching the query criteria. However, when retrieving an entity by id, I treat it as an error condition if the entity doesn't exist (I prefer exceptions in this case). This also avoids excessive null handling everywhere.
Marty is a great instructor glad to see he is continuing the course with Kotlin! Took it in 2015 and loved it
SQLite partly because I am trying to separate Database from the package uploaded to OSS. Also, a part of Database is generated from https://github.com/LuminosoInsight/wordfreq that is Python.
Wow!!! Thanks. :-)
While Kotlin offers many advantages that Java doesn't, it still has some shortcomings. When letting your team experiment with Kotlin, remember that transitioning to a new language isn't always that exciting for developers who have already found the tools and strategies that work for them. You'll need to give your team at least a month for getting familiar with Kotlin, risking that some team members might not adopt in time for the launch of your Kotlin project. You also need to bear in mind that Java isn't going anywhere and will remain essential for Android app development. But if you're a beginner looking for a new challenge, it makes sense to try Kotlin, especially if you'd like to work on innovative projects for startups. However, check out this article to learn more about differences: [https://www.androidauthority.com/kotlin-vs-java-783187/](https://www.androidauthority.com/kotlin-vs-java-783187/)
&gt; "The Scala way", on the other hand, is mostly "anything I can write to prove that I'm better than you". This has not been my experience, and certainly doesn't seem to be promoted by Martin Odersky. It may be your experience, but it is not universal. &amp;#x200B; &amp;#x200B;
There is a similar discussion [here](https://www.google.com/url?sa=i&amp;source=web&amp;cd=&amp;ved=2ahUKEwiKkMLCz-jfAhUPhaYKHSDKByoQzPwBegQIARAC&amp;url=https%3A%2F%2Fwww.reddit.com%2Fr%2FKotlin%2Fcomments%2F891bb5%2Fnothing_can_save_us%2F&amp;psig=AOvVaw3wTyNdWvuK7x2bZ2iggOZm&amp;ust=1547395484091074). I have personally used the approach described in in the article, i. e. type alias, and that worked okayish. The problem was Json serialization which in Moshi has problems with Nothing?. The solution was to use an object (we called it NoID) instead of Nothing?. This let me differentiate between saved and unsaved data classes by using the type alias, but also use the base class with &lt;Any&gt; when I didn't care about if it was persisted.
Really, this is very similar to debates about using [DTO][DTO] vs [Entity][Entity] objects. (Feel free to search for these terms: lots of "enterprise architect" articles on it.) But... this gets very application specific, really. What you're doing is fine, but, if your Kotlin class here isn't actually ever used outside the server, you can also just use the Jackson `@JsonIgnore` annotation on your `id` field. For example, if I wanted a _client API_ library in Kotlin, I'd still just make two data classes: one for internal usage, and one for external. And then I'd just put the interface in a common shared place, and use something like [BeanUtils][BeanUtils] to basically create factories from one class to another. But these factories frequently need special logic too. Like, do you fetch an ID based on other information to create an "entity" representation (making the factory part of your data layer), or, just default the value to different states, like "-1" for new, "-2" for unknown, etc. The main point I want to make is that there just isn't a "general solution" to this problem that fits all use cases. I'm also pretty sure there isn't a common reflection API across platforms. [DTO]: https://en.wikipedia.org/wiki/Data_transfer_object [Entity]: https://docs.oracle.com/cd/B10463_01/web.904/b10390/bc_awhatisaneo.htm [BeanUtils]: http://commons.apache.org/proper/commons-beanutils/
Yeah, this is exactly the context :) , but it's exacerbated by Kotlin's null safety. Whereas in Java we could just happily ignore a nullable id field, in Kotlin if we have a non-null id field we should feel good about using it. I mentioned the "new" state id in my post as well - it's an OK solution, but it has a special smell to it. It'd be nice to use strong typing to cover the lifecycle. 
I quite like it - thanks.
I hear ya, and, I've generally found that having more immutable data classes tends to cause fewer problems, too, mostly because nullable anything always seems to allow for bonehead mistakes. People get used to the lovely type system combined with autocomplete... boom, forgot the id. Besides, having more representations plays nicely with the "polyglot data" systems that have different database representations. You might have a numeric DB id on one representation for an RDMBS, but primary + sort string id combinations for NoSQL DBs. I suspect once people get used to cross-platform Kotlin, we might see more of this kind of pattern, since a client might store things in SQLLite but the backend in Dynamo, etc. I guess I just don't shy away from lots of data class representations with copy functions all over the place as my default :) It seems like storage or memory is cheap, might as well use it. CPU is the expensive thing. Not exactly sure about the cost of `Proxy`, but it's pretty Java specific and I suspect good ol data classes are less CPU taxing. And portable.
Null or javas optional.
Yes, this is known problem, so [mockito-kotlin](https://github.com/nhaarman/mockito-kotlin) exists. I've used it in early days, but now I use [mockk](https://mockk.io/) instead of mockito+mockito-kotlin, since it's feels much better from kotlin code. But you feel free to use either, if you can drop mockito - do it, if not - use mockito-kotlin. &amp;#x200B; *Have a nice Kotlin!* 
I first tried mockk when I ran into the problem that Mockito can't mock extension functions. I was pleasantly surprised, and kind of want to port all the other tests to use it instead of mockito
Great tips I learned a lot about things I rarely use in kotlin but now feel more confident doing. 
Did you bump into any problems with the article?
No it was well-structured. Only thing I would do to improve is link to real use-cases where these idioms are used to show more fleshed out examples. The reified section is a bit difficult to understand w/o looking up reified functions in kotlin and looking at outside examples so maybe fleshing that out a bit and reworking the example slightly - you use a lot of keywords like inline, noinline, and mention an annotation all without real explanations to what these do or if they are just a part of the example or not. 
Thx for the feedback. I'll add some clarifications and links to actual examples!
https://blog.philipphauer.de/best-practices-unit-testing-kotlin/ Philipp Hauer wrote a great blog on unit testing in kotlin. He suggests, like others here, to use Mockk w/ Assertj (or a kotlin variant of it) for testing. 
Hey mate! Try putting $list_id instead of $.list_id. This is not the correct usage of string templates. Let me know if it works. Cheers! 
I get: java.lang.AssertionError: No value at JSON path "31fdb3cb-3aad-494e-a5de-37d3f0217293"
I'd use mockk in java if I could lol
Just a guess but maybe they are both different types. One is a java.util.UUID and the other is a java.lang.String.
Types - json assert will be returning a string for $.list_id but you’re comparing to a UUID - try “$list_id” as the expected value (or list_id.toString())
As the others said, Types. Try some kind of type assert like this `assertTrue(jsonPath("$.list_id") is UUID)` `assertTrue(list_id is UUID)` I'm sure it's a types issue, if not see if there are extra spaces in the Strings, this ruined my life for hours once, particularly end of lines. Hope this helps
I have been using mockk and never looked back. [https://mockk.io/](https://mockk.io/) It can mock statics, companion objects, coroutines, extension functions. 
Thanks. I might look into Jitpack for deployment, instead of OSS Sonatype.
It is super simple albeit sometimes slow.
Yes. Interop is 100% seamless so Kotlin can do **everything** Java can do.
Note that Kotlin *can* be used on iOS.
I don't think that Go is a good choice. It doesn't even have generics and the ecosystem is awful. OTOH Kotlin can use **everything** which is present in the Java ecosystem, and all the tools it provides. I wouldn't recommend Spring if you are new with the language since Spring in itself is a complex beast. I'd go for something more simple like http4k or Ktor instead.
If you already have a "professional" setup somewhere else, don't switch to Jitpack. We have been using it at our company but it has often not been stable/performant enough for our needs. Now we are in the process of switching to Artifactory. I find it to be wokring well enough for private use tough. 
So many courses focus on android development. Don't people know it's a general purpose language and that it could be used for other things?
Mockk is very nice indeed.
After troubles, I seems that I have succeeded, by following https://central.sonatype.org/pages/gradle.html and also signing { useGpgCmd() sign configurations.archives } I do also have to install GnuPG on my Mac as well. Now, it is available from maven { url 'https://oss.sonatype.org/content/groups/staging' } But not `mavenCentral()` or `jcenter()`
I believe it goes to maven central automatically after that
Ofcourse Kotlin is a general purpose language, just thought I’d share a free resource from a great school. 
Yeah, I know about Kotlin Native, but it can be used with C++ currently. But one can use the old C version of OpenCv with Kotlin Native
If you have aspirations for library usage as wide as possible, then unfortunately Maven Central is much more important as a target, with JCenter not an inconsiderable distance behind. Many corporate environments have nexus caches which may only proxy to these repos. TBH apart from still being a bit manual for new libs, the Bintray/JCenter setup isn't \*too\* bad (especially compared to the hilarious joke that is Sonatype "raise a Jira"). You can then get JCenter to sync to MC (although this is incredibly slow and fails/times fairly often IMHO). There's an example of the gradle voodoo for a multi-module project [here](https://github.com/http4k/http4k/blob/master/build.gradle)
Try: val list_id: UUID = UUID.randomUUID() mockMvc.perform(request) .andExpect(status().isOk) .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8)) .andExpect(jsonPath("$.list_id").value(list_id.toString()))
Voted to close as duplicate of https://stackoverflow.com/questions/47049867/xmlelement-does-not-work-when-used-in-kotlin which you should have been able to find with a simple Google search.
We're you successful in getting @XmlRootElement(name = "Root") to work? It throws an out of range exception. I did find this, and it appears the API has changed surrounding this annotation
No, not Java's Optional. There are basically no cases where you should use Java's Optional in pure Kotlin code that does not need to interoperate with Java libraries that use Optional. Nulls in Kotlin are strictly better: no runtime overhead, more concise syntax and exactly the same semantics.
Winner winner chicken dinner. Thanks.
Yup, thanks!
Anyone know of a similar collection for C++ or C?
Cool, will study. Is there a tutorial somewhere that explains this sort of notation? I kind of understand it by figuring it out, but I haven't found anything that explains it at a more foundational level. Everything I've read either doesn't explain it, or is very technical and confusing. I believe they are called generics, corect me if I'm wrong.
Change 0f.toDouble() to 0.0
sure. thanks 
Would be nice if const keyword worked here in conjunction with .trimMargin().
Not at this time, but it's likely that it will be supported at a later time. See https://youtrack.jetbrains.com/issue/KT-17755 for the corresponding YouTrack issue.
May you be more explicit about what you mean when you say “this sort of notation”? If you *are* referring to generics, is a description like this too technical: https://en.m.wikipedia.org/wiki/Generics_in_Java ?
I would also replace 1.rangeTo(30).map { ... } with either (1..30).map { ... } since Kotlin has a range operator or I would suggest Array(30) { ... +1 } .toList() 
Sry for putting my feedback into so many replies, but I am reviewing this on my phone. I don't know if it would make your tutorial to complicated for beginners, but in a real world application I would replace the functions Order.total() and Order.finalPrice() with (lazy) properties. And I suggest renaming qty to quantity. Makes the code more readable and that is what Kotlin is all about. Thank you for creating this tutorial. I hope you don't feel offended by my feedback. Those are really minor things or matters of taste.
Thanks, that's what I was looking for. Voted for the issue.
So why did Google create Flutter? They never answered this. 
Reminded me of a recent school assignment where we had to implement some basic sorting algorithms with the use of Strategy. After I finished I realized *it's kotlin* and the professor was cool so [I had a go at it](https://github.com/mhashim6/Kotlin-Sorting-Algorithms) with functions instead of classes.
I think the point is that Flutter _fans_ themselves couldn't answer that question. Ergo, Flutter has large organizational risk.
Can you explain why?
To expand, because this was interesting: if you can't really understand the business case for the people supporting a particular tool, that's a problem. I'm not sure anyone knows exactly what Google expects from Flutter, ergo, in a year, if it doesn't seem to have adoption, they may just decide to drop it. Google has a tendency to kill things for unclear reasons. It reminds me of similar conundrums of open source service projects, like MongoDB, and AWS. These OSS projects often gain some steam by being free, then AWS can come by, just build something with a compatible API, and boom - they undercut the entire business of MongoDB, who can't really make money on tooling. Ergo, MongoDB (the company) might be facing some time, and what happens to apps using it? Who knows. It kind of kills some different "open source" business models, and is significant organizational risk. One of the nice things about Kotlin/Native is that it's pretty clear that JetBrains expects to make money selling license that supports Kotlin/Native development. I do think there's risk, in that Apple, for example, could just say "no" and pull the rug out from iOS apps that aren't written in Swift, if they feel they no longer have "control". But the Kotlin/Native approach doesn't seem to get in the way of Apple's ability to control their own platform, so I don't think it's a big risk. With Flutter, where you're writing on a completely different abstraction, I suspect there's a much more substantial risk.
It seem that that isn't the case. I have to manually press release. Now, it's in mavenCentral(). See https://search.maven.org/search?q=patarapolw And, https://issues.sonatype.org/browse/OSSRH-45124?page=com.atlassian.jira.plugin.system.issuetabpanels%3Aall-tabpanel
Although I am inclined to ignore the whole `.idea/` directory. IntelliJ officials would tell me to keep some part of it to Git -- https://github.com/github/gitignore/blob/master/Global/JetBrains.gitignore
Thank you so much for the feedback. These are really great suggestions.
Thank you so much for the feedback. Passing functions like that was something new to me and i thought why not explore the possibility of implementing strategy. Otherwise creating Concrete Strategy classes with only one method to implement and that too without a state looked a little too much, hence tried this approach.
Nice! A few code review comments -- minor details: 5: make this a one-line function `fun total(): Double = qtyInKg * pricePerKg` (like `Order::total`) 10: instead of making the promo nullable use null object pattern to make the default value be a `= NullPromo()` whose implementation returns 0.0f 10: also, introduce a typealias for the `(Order) -&gt; Double` function here and use throughout 
You are welcome! In this scenario it seemed more natural to me to use actual strategies/functions.
order.total() * 0.5 is not 5% but 50 ;) Also, functions like total() can be a read-only property with a getter, then you can use it like order.total * 0.05 Nevertheless good article, thanks :)
Obviously to have an easy to use Framework that allows quick development of cross-platform UIs. Of course it would be nicer, if Flutter would be written in Kotlin.
As the UI for Fuchsia, the Android replacement and Dart's savior project. Now Android team is adding support to run ART on Fuchsia, so it is an open question who will win the internal political wars between the two groups. Android won over Brillo, pivoting the project into Android Things, and having ChromeOS supporting ART as well. So it remains to be seen how Fuchsia will evolve.
To justify the existence of dart. 
That’s what makes me worried about Android Things. My company is considering using AT for IOT devices but we are worried that if Google drops AT, we would be screwed. 
Sorry for the absurdly late reply. I'm not sure if that's what you're talking about but there is something named "kotlin-stdlib.jar" under "KotlinJavaRuntime" that's under "External Libraries". I tried the same thing with clean installs of various versions of JDKs and various versions of IDEA Community Edition and same error occured everytime. I don't even touch anything other than what I mentioned above. That made me think the issue must be outside of the IDE. Can this be the case? What do you think can cause this?
Sorry for the late reply. At the time, I used JDK 10 but I tried a couple of previous versions and 11 too. Same error.
I believe strings in Kotlin work the same as in Java. Iteration and index access are by 16-bit char, which is \_usually\_ a unicode character. There are however some unicode code points which are represented by two or more 16-bit chars.
You could try with StringBuilder::codePointAt etc
The short answer is no, it is not safe to use `[]` or anything else that returns a `Char`. This is because Kotlin inherits 16-bit chars from Java, which has kept them around for backwards-compatibility. The correct way to safely iterate through Unicode codepoints (I believe rune is the Go terminology?), is any of the "codepoint" methods e.g. `"hello world".codePointAt(3)` [which returns an int](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#codePointAt(int)). Ints are 32-bits and thus safely wide enough for all Unicode codepoints. Another kettle of fish is when you get into topics like emojis or languages which combine multiple codepoints. What appears to be one emoji, e.g. 👨‍👩‍👦 ([Family: Man, Woman, Boy](https://emojipedia.org/family-man-woman-boy/)) is actually a sequence of emojis, separated by a special character - in this case, man-separator-woman-separator-boy. Emoji genders and skin tones are also implemented similarly, by having a base emoji (single codepoint) followed by a skin tone modifier and a gender modifier.
Hold up, Java chars are 16 bits wide?
Yes, they have been from the beginning. The idea was to bake Unicode support into the language so you wouldn't have to mess around with variable-length encodings and character sets. The initial design of Java (when it was called "Oak") happened before Unicode expanded beyond 16 bits per character, so it seemed like a sufficient solution at first.
Oh boy, my day has come! I prefer to use a maven plugin to generate a data class for me. There are a couple of plugins that help with this, they all use the xjc program that comes with the jdk (just check the bin directory for your jdk). If you look at the Sample Sitemap data, you'll find a link to http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd. This is an xml schema definition that the plugins can use to generate a data class for you. The advantage of doing this is that even if you come across some xml you haven't seen in the examples, your code won't fail to parse it. Here are some plugins to choose from: * http://cxf.apache.org/cxf-xjc-plugin.html * http://www.mojohaus.org/jaxb2-maven-plugin/Documentation/v2.2/example_xjc_basic.html * https://github.com/highsource/maven-jaxb2-plugin They generate a java class, and then you use that java class the same way you're using the SitemapData class in your stackoverflow post. Here is an example of how I configured the maven plugin &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.jvnet.jaxb2.maven2&lt;/groupId&gt; &lt;artifactId&gt;maven-jaxb2-plugin&lt;/artifactId&gt; &lt;version&gt;0.14.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;generatePackage&gt;jaxbtest.xmlbinding&lt;/generatePackage&gt; &lt;schemaDirectory&gt;src/main/resources/xsd/&lt;/schemaDirectory&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; Make sure you download the xsd file and place it in src/main/resources/xsd/ (you can of course change this to wherever you want to place the file) Run `mvn compile` to generate the java class. 
They're also the only unsigned primitive type it has. A very weird design.
There shouldn't be an issue with getting the nested classes mixed up because you always need to qualify the nested class by referencing the parent like in your last code example: val messageFromA = ResponseA.Message() val messageFromB = ResponseB.Message() But let me ask; is your code going to be part of a shared project or is it going to be available via a library? If it is part of a shared project, I think I would take a pragmatic approach here (there is no such thing as perfect code after all); add some documentation to tell the other programmers that these classes are for serialization purposes only. Write some tests, call it good, and move on to better things. You can always refactor later if you like. If it is available as a library, then your code is almost certainly delivered in a module and so you could use the \`internal\` keyword to control what aspects of your library are exposed to the programmer. You could have code that looks something like this: data class ResponseA internal constructor(val id: String = "", val threads: Message = Message()) { internal data class Message(val channels: String = "", val next: String = "") } // Likewise for ResponseB This way you can still reference \`ResponseA\` and \`ResponseB\` from outside your module, but the programmer will not be able to use the \`Response\` constructors or reference the nested \`Message\` classes. I suppose you could still use a module for your server requests if you are working on shared project, but then you need to think about whether you want to structure your code that way.