Out of all the built-in operators Java has (at least the ones that are commonly used), I think ternary requires the most mental effort for me to parse and understand. Using `if` and `else` results in a total of four more characters than using `:` and `?`, but helps (in my opinion) with readability. It's also more expressive of what it's actually doing. Where else in Java is `?` used for `if`? I guess it can be implied, but then why does `:` mean `else`, but also `in` in a foreach?
At first I was annoyed, but you're right. Ternary ops always force me to waste a couple brain cycles. I like if else in this case
&gt; (ktor - web framework, exposed - ORM) Have you had a deeper look? E.g. Exposed looks more like a proof of concept...
I have not looked deeply at Exposed, honestly. It does not surprise me that anything they have to offer is &lt; 1.0. The community is small and young still. I am interested to see what community-developed idiomatic Kotlin looks like in a few months and how the tool at that point are designed to be implemented.
So a sealed class is what swift called an enum
*in every aspect besides gaming*
Scala ([scalable language](https://www.scala-lang.org/what-is-scala.html#a-scalable-language)) allows a team of 7 to write a price of software in 8 different ways. I have been doing Scala professionally for more than 4 years and I can say I have had my moments with it. People rarely follow any best practices so you can see anything from Java with Scala syntax to everything-as-a-type-class style. Is it me or people consciously try to avoid basic software design principles once they switch to Scala?! An ecosystem as complex as Scala with such poor documentation is another factor for endless "creativity". Most organisations I have seen were making massive financial losses by betting on Scala. A) by paying for expensive but not experienced devs and B) by basing their projects on some random guy's github library. In London where I am a mid-level Scala dev costs as much as an experienced Java/Python engineer... That's after you spend months trying to hire that Scala dev. The argument that clever devs are more prone to using nich√© technologies might be true but when it comes to delivering business value the KISS principle wins. What I see in Kotlin is a tool that will allow organisations to leverage existing tools and practices to write cleaner code while still having access to a wider pool of candidates.
&gt; It's simple like Java No. Java is crippled, not simple. Kotlin supports FP very well. Avoid FP at your peril.
Linux is worse than Windows in many aspects: upgrades of the OS, hardware support (yes, Linux users are still routinely struggling with hibernation and wifi), tool ecosystem, inconsistency in the GUI, lack of keyboard shortcut and accessibility in general, etc... 
Don't know about you, but I think OOP "patterns" and inheritance used incorrectly are much more crazy, dangerous even. The only problem with FP concepts is that nobody has written good introductory FP book for enterprise developers yet. 
There are some valid points here, but this one I strongly disagree with: &gt;"1".toInt() // 1 - parsed to number &gt; '1'.toInt() // 49 - its ASCII code It would be weird if the integer value of a character was not it's ascii code.
like really weird
Hi Wavy, I do understand that developers can pick up new languages quickly, however, the view of most hiring managers is that for the first few months you will still be fairly novice. It's a frustrating situation that most companies still adopt but recruiters don't have much choice other than to dance to the tune. I'm hoping that I can slightly change that paradigm one day and be far more of a consultant than the majority of recruiters out there today! (Still trying to figure out how to get a Head of Eng to listen to that advice, I'd love to chat with you and see if you have any ideas on how I might be able to do this though!)
I had never thought of them like that. Thanks for the tip :) 
I added deeper explanation of my point in article.
Those statements are perfectly fine to me. 
This one also makes perfect sense: &gt;1.inc() // 2 &gt;1.dec() // 0 &gt;-1.inc() // -2 &gt;-1.dec() // 0 It all boils down to operator precedence, something that is true for all and math itself. In all languages I know of the .-operator has the highest precedence, above both + and -. I think it's wrong to blame the language for this. It's our job as programmers to know that operator precedence exists and how it impacts the code.
The example with the destructuring declaration of the student class actually works: data class Student( val name: String, val surname: String, val passing: Boolean, val grade: Double ) val s = Student("a", "b", false, 1.0) val (name, surname, passing, grade) = s println(name) This prints "a". So data classes can be used like tuples here. If one wants (for the sake of incomprehensibility) to use the elements by index, it is also possible: println(s.component1())
Ternary operator is not only hard to read, but would be also redundant, since (as others already mentioned) `if` is an expression in Kotlin. And the ternary operator gets extraordinary ugly when used with more complex conditions. Chaining some if/if else/else branches with the Kotlin approach looks always clear and readable. The Kotlin designers considered __language usability__.
I agree and I stressed that in the article. This is not the point
 fun foo(strings: List&lt;String&gt;) {} fun foo(ints: List&lt;Int&gt;) {} You _can_ define those two functions if you put the `@JvmName` annotation on at least one of those. As you said, this is a JVM restriction and is mitigated by a JVM-specific annotation. ---- &gt; It is correct, but wired in the same time. Typo here -------- 1.inc() // 2 1.dec() // 0 -1.inc() // -2 -1.dec() // 0 I think there should be an IDE inspection for this. I reported it here: https://youtrack.jetbrains.com/issue/KT-18236 ------------ &gt; whole day I was repeating ‚Äúincretable‚Äù Typo here. Did you mean "incredible"? 
The second method should be called "getCharacterCode" or something like that.
Let me just print this little document... Oh wait.
The minus sign is completely wrong too. I mean, if I were to look at the code, I would expect that first list to be [2, 2, 0] rather than [2, 2], so that is strange to me that it removes one element. But the second where it removes all 2s is intuitive and clearly by design. Not a problem. 
&gt; fun foo(strings: List&lt;String&gt;) {} fun foo(ints: List&lt;Int&gt;) {} Just use the `@JvmName` annotation
Hell, in Javascript `:` is even a freaking overloaded operator. I dare people to say ternary is more readable. 
&gt; I worked with a team that transitioned from Java 7 to Kotlin 1.0 for building web services with Spring Boot. Hi Mike! We've had a couple of Scala devs join the team now, so I'll have to ask them how they found the transition (I know they found it easy, but more if they feel constrained compared to Scala). I don't think anyone on the team is sad to have left Java though! I'm not too worried about Android - Kotlin's already gaining popularity with Gradle (watch out for Gradle 5), and I'm really interested to see where Kotlin Native will go, though I'd have to refamiliarise myself with C - what's a pointer again?? :P Oh and ditto on the tooling - the way Kotlin works with IntelliJ is awesome.
/r/ProgrammingJokes 
&gt; Windows wins at one thing: making stupid people too scared to try other stuff ... sigh. Please save this kind of thing for slashdot. 
If you're ok with using a theme, this one maps all kotlin files to the same icon. https://kotlinlang.org/assets/images/open-graph/kotlin_250x250.png https://plugins.jetbrains.com/plugin/8006-material-theme-ui 
I've started making each file it's own Class, Object, or Enum with the exception of a few files for constants. If they added an icon for single-public-function classes I'd be pretty happy.
Unfortunately not an option for me since I have many data classes (one liners) that clearly belong together. 
Oh wow you weren't kidding. I wonder if it has to do with me using the dark version of the theme or a setting? Im on mobile right now but I'll check it out later
Tried all themes. Also tried the other, similarly named plugin ("Material Theme Extended"). Might have missed a setting somewhere. Will take another look tomorrow. Thanks so far.
Not sure if fixed yet, but I often ran into problem where a Kotlin property doesn't override a getter/setter method defined in a Java parent class. Makes me cringe a little bit when JetBrains claim 100% Java compatibility - it's more like 99.9% üòÑ
The behavior is not inappropriate, but I can see why the author might be confused. I was learning Kotlin by doing a lot of code puzzles, and those frequently make you convert a number into a string and vice versa, and I hit upon the same thing. So say I had a string and I wanted to decompose it to its individual numbers, e.g., "32768" -&gt; [3, 2, 7, 6, 8] I came up with: "32768".toCharArray().map { it.toString().toInt() } Is there an easier / more idiomatic way? 
For me, using different symbols for files that do similar things feels weird. I have many files which declare a single class. Those are blue. Then I have files declaring single classes, but also containing one or two one-liners that clearly belong to the declared class. Those are grey - the IDE now makes me think the file does not serve the purpose of a single class declaration, which it clearly does. So the only thing I can do is putting those one-liners in another file (which I don't want to, because they belong right next to the class declaration). Having two files with the same purpose (declaring a class), one being blue and one being grey just feels wrong - such a harsh visual distinction should also hint to large differences in the purpose of the file.
Or inside a companion object if they're related functions.
right, not a subclass. either a nested class or a companion object. composition over inheritance.
What about sealed classes? 
It's pretty easy to convert characters to their representation as an integer by looking at an ascii table: http://www.asciitable.com/ Here's 3 ways which involves less casting and operations: "32768".map { it.toInt() - 48 } "32768".map { it.toInt() - '0'.toInt() } "32768".map { it - '0' } I would use the last one, since it involves no casting or intermediate objects.
For sealed classes, it depends where you declare the inheriting classes. If you declare them inside the sealed class, the icon is blue. If you declare them outside the class, but in the same file (possible since 1.1), the icon is grey.
I JUST switched to Ktor because I couldn't stand the lack of Kotlin support in Spark. I really like Spark though so I'm probably going to switch back... 
Never tried spark. Is Kotlin version just a java clone or does it use some Kotlin-specific features like e.g. DSLs?
You can use `jvisualvm` it comes with the JDK
Turns out there wasn't a memory leak at all! I didn't have a good grasp on how garbage collection worked. After a while my memory dropped down....
DSLs are not a feature. Compile time construct are.
I was saying, that would give ktor an up on spark if it worked
it's high in our backlog. Probably one of the next features for Spark.
we're contemplating making spark-kotlin work with Kotlin native. We'll gather feedback and try to prioritize the most wished for features.
Well, in a sense they are. Replacing e.g. XML with something in the code definitely counts as a "feature" to me.
It can't "replace" XML or what ever that means. Kotlin doesn't even provide most suitable compile time capabilities to create DSL. 
Not in every situation (because it operates in compile time) but it can in some situations, like Anko with user interface. To me that is a feature.
The question is: which sort of developer are you searching for? 1. an expert being capable of building a maintainable, scalable system 2. cheaply available developers who can be exchanged like a puppet Kotlin has the potential to become mainstream, and as such 2.) will be easier available. Because of that, companies will hire out of group 2.) even if they would require an expert. They will most probably keep believing that 2.) is important in order to compensate staff turnover and to reduce their risks and costs. But if you believe that a smaller, stable (less turnover) team of experts can deliver a better product, you might consider searching for scala developers. They might seem to be "rare" but chances are higher that this developers share the same mindset.
Why is this problem worse with Kotlin than with Java?
I was an early-adopter of Scala, and was on the first Scala program committee. Kotlin is better than Scala every way. The most important thing to know is that while it will take weeks or months for a Java developer to be proficient in Scala, they will be proficient in Kotlin after days or weeks (and productive within hours). Scala's creators were like kids in a candy store with language features, and the end-result is a mess. Sure, Scala was better than Java, when it was the only alternative. But that hasn't been true for a long time. In contrast, Kotlin's creators have been much more careful and deliberative, with a focus on baking decades of experience with what is wrong and what is right with Java into a new language. Scala jumped the shark years ago. It had a brief resurgence due to the Apache Spark machine learning library when a few bandwagon-jumpers decided it must be the new "language of machine learning". But that didn't stick.
Ktor does support http2, but was not extensively tested in the wild. We would appreciate more input. Also, ktor is async from top to bottom ;)
You can use `apply` instead of chained methods to call multiple methods on an object.
I know, but method chaining is more elegant and leads to less bloated code.
The suspence!
I would argue that apply makes things way way cleaner for the scenario where you are just setting a bunch of attributes. To me it really helps with "squint testing", to see logical blocks of code affecting one class. sprite.apply { color = x size = y pos = z } 
I do not want to sound snarky, but really, why? If you have an existing JEE project in Java, you do not rewrite it in Kotlin just for the sake of it. If you start a new project with Kotlin, or add a service to an existing microservice application, then why choosing JEE when there are other arguably better choices like Spring, Dropwizard or Spark? I am really interested to understand what would be the typical profile of a developer that writes JEE with Kotlin. I mean, if one wants to try new things and jump from Java to Kotlin, why sticking with JEE? Or are there really people that like JEE but are disappointed with Java (and so want to try Kotlin)?
I can't think of a single valid use case for -1.inc(). Can somebody help enlighten me? (Serious)
Are there more examples of how this differs from the Java version?
Maybe that would work. I'm not sure, but I think it should be a reference to the class that is generated by Kotlin for the top level functions. Wouldn't an object inside the fun share the same one?
VisualBasic.Net more popular than JavaScript? Seriously? 
I don't understand. I thought you already kept the interfaces as Java (as I suggested). You second syntax should work, too, if there is no overload ambiguity.
Sorry, I was unclear. I also need to keep the method using **Handler** in Java. public Javalin get(String path, Handler handler) { ... } ^ Above works Below does not: fun get(String path, Handler handler) : Javalin { ... } If I explicitly type it app.get("/") {req : Request, res : Response -&gt; } I still get Type mismatch. Required: Handler Found: (Request, Response) ‚Üí Unit Which looks like it should match Handler: @FunctionalInterface public interface Handler { void handle(Request request, Response response) throws Exception; } 
&gt; make it one of the best for this in my opinion. For what?
For writing DSLs concisely.
How? It doesn't even provide macros and it's inline functions are crippled.
I'm new to Kotlin, and having just completed the [koans](https://github.com/Kotlin/kotlin-koans), I wanted to build a new project with it. I welcome everyone's comments and suggestions.
Lisp Macros, ever heard of them? The power to make any language imaginable? Power Kotlin doesn't hold.
Lisps are very useful in this regard, but Kotlin's DSLs are much more portable between teams and easier to implement and test. So are Ruby's, actually; part of what I'm getting at is that Kotlin is the next iteration of years of such improvements. Honestly, try implementing a DSL for your favorite weird proprietary format in Kotlin sometime. I guarantee it will be more pleasant than in a Lisp. And you'll feel confident you could explain your implementation to a toddler.
Actually, intellij did that automatically: I started with a list like this, and after I added more than five or so things from the same package, it changed it to just ".*" import javax.ws.rs.DELETE import javax.ws.rs.GET import javax.ws.rs.PUT import javax.ws.rs.Path import javax.ws.rs.Produces Perhaps that's a setting I can change?
Ah, so there's no difference between "import javax.ws.rs.*" and individual imports?
I see, well, I am sorry.
The only difference is issues with namespace collision.
TIOBE is poorly thought out (as are most of these popularity ranking systems). Not surprising though. After the I/O announcement I would expect to see pretty massive Kotlin growth over the next 12-24 months. 
You can change that setting. Type import in the preferences search bar.
Star imports add zero overhead. You can configure IDEA to define the number over which it will automatically replace individual imports with a star. Star imports are typically discouraged in Java but they don't really bother me in Kotlin (and besides, imports are folded most of the time anyway). 
Search **Kotlin** in preferences search bar. Under *Code Style/Kotlin* you can change this behaviour. [Reference screenshot](http://imgur.com/a/4ToTf)
Not Kotlin specific but since you are asking for review: the MongoConnection class seems to serve no purpose at all. It's just a wrapper around one object, and the only method it has returns that only!
We're several months into the development of a mobile game backend in Kotlin, it's been going lovely so far.
This is a longshot, but could you do a quick essay going over your code? Like a quick analysis, "this is what we did", "this is what we would have done had we had more time", "this is a weird/interesting quirk in Kotlin gamedev", "these are the tools/libs we used and why we chose them". Something like that. I'd love to do some game programming in Kotlin but resources are sparse.
I'm not a professional game developer, and the whole project would be a poor choice if you wanted to learn from an example. I could try to find some time to write an article, but - to be honest - there are far better gamedev resources out there. As far as programming tools go, I used [LibGDX](https://libgdx.badlogicgames.com/) game framework with [Kotlin API wrapper](https://github.com/libktx/ktx) and [Box2D](https://github.com/libgdx/libgdx/wiki/Box2d) physics engine. There are plenty of LibGDX tutorials - if you _really_ want to make 2D games in Kotlin, I suggest starting with that. Gradually convert Java examples to Kotlin and you should be fine. If you want complete honesty though, I'd probably go with Unity or Unreal if I were seriously considering a career as a game programmer. I think these are the standard, at least for the indie studios. It's just that I know Java/Kotlin well, and currently I would be _much_ more efficient with a JVM game framework, so we went with that on the jam.
Alright, thanks!
Dart has this. They call it method cascades and it uses a .. operator.
External function literals makes some advanced stuff possible without much hassle. See https://stackoverflow.com/questions/34797366/in-kotlin-how-do-i-add-extension-methods-to-another-class-but-only-visible-in
The ternary operator isn't exclusive to Java though, in most languages I've developed in it was available for use. Yes, it can require some mental effort to understand what is going on at first but it's not terribly difficult if you use it in many places. I miss it's inclusion in Kotlin and I hope it gets added back in one of these days.
You shouldn't be using a ternary operator for complex conditions, if you are then you are an inconsiderate developer trying to play code golf. It is however nice to be able to do something like `return string.length &lt; 1 ? "empty" : string`.
I'm fairly hopeful for Kotlin. Right now it can run anywhere the JVM can and can also cross compile to JavaScript so by writing something in Kotlin you can now run on a server, on a desktop, in a web browser, and on an Android phone. They introduced Kotlin/Native which lets you build stuff for iOS. To me, Kotlin feels like the answer to JavaScript for a compiled language. So I'm excited about it.
You can take advantage of Kotlin's raw string support. If you enclose a string in triple quotes ("""), you don't have to escape quotes within them. So this: val content = if( matches == 1L ) "{\"deleted\": \"1 document\"}" else "{\"deleted\": \"$matches documents\"}" Becomes this: val content = if( matches == 1L ) """{"deleted": "1 document"}""" else """{"deleted": "$matches documents"}"""
I may just have to borrow those slides when I pitch kotlin to my company
I second that. Scala is baroque and baroque people tend to use it. You won't find pragmatism in the Scala community.
I agree that the ternary operator shouldn't be used for complex conditions, but I've seen it more than once. One could say, that this operator doesn't scale for more complex conditions, whereas kotlins if expressions do scale.
Data class generates the toString, equals, etc. Which you won't have on a normal class. 
I just downloaded it yesterday... is there support for Templating Engines like Thymeleaf? I tried to make it work with some code I found on github, but my Kotlin MutableMaps were not translated to java.util.Map.
Can you add screenshots please?
As you said, it can be, so it is already fulfilling that role. The language gaining popularity and credibility in general should also increase it's potential as a general-purpose language like Java.
Yeah. It seems to me that the main thing preventing Java from being used in most things was its legendary verbosity. To the point that many folks prefer javascript (think node.js) simply to escape boilerplate. Kotlin ameliorates this considerably so it really should be used more generally. There is no reason not to.
I wholeheartedly agree there. I really dislike writing Java, and I thought Scala would be the language I did like on the JVM, Kotlin really is just Java with less verbosity and some sugar. It's very nice. The trouble is, that's only half of the battle. There also has to be the libraries that are easy to use and straightforward. I recently had to send an email with Java... oh boy, that was an experience. I just wish there was a standard library more like Go's - high quality, very complete, solves many common problems in an easy-to-use and understand way.
Hmm... does not look so hard... //dependency: compile group: 'org.apache.commons', name: 'commons-email', version: '1.4' fun main(args: Array&lt;String&gt;) { SimpleEmail().apply { setHostName("smtp.gmail.com") setAuthentication("someone@gmail.com", "&lt;password&gt;") setSmtpPort(587) setStartTLSEnabled(true) setFrom("someone@gmail.com") setSubject("Test Mail") setMsg("This is a test mail") addTo("someone@gmail.com") }.send() } 
Interfaces in Kotlin cannot maintain state, so while the db actions are the same regardless of the specific connection, the MongoConnection class serves the important purpose of being instantiable. I also saw your other comment, about why not put all the methods in a class definition. Well, for the same reason: there's nothing different about those actions, so why put them in an instantiable construct?
&gt; A good alternative to OCaml is F# I'm coming from Python world and I wanted to learn some another language. I have tried Kotlin and it was okay. I understand why Java people love it, but for me it was nice, but nothing groundbreaking. The other thing that bothered me is that support in VS Code for Kotlin is not that great, and I had to use IntelliJ IDEA, which Java people praise, but for me it was quite buggy and it was constantly crashing. I've tried Haskell but never managed to move past some basic stuff, and thought I'm not capable of understanding functional languages. Enter F#. I just started using it, but so far it has been really a pleasure. Support in VS Code is great, I like the syntax, and it seems that after all I'm ok with functional languages. It gets a recommendation from me.
*Here's the Urban Dictionary definition of* [***Gatekeeping***](http://www.urbandictionary.com/define.php?term=gatekeeping) : --- &gt;When someone takes it upon themselves to decide who does or does not have access or rights to a community or identity. --- _"I love punk bands like Green Day!"_ _"Ugh, they're not even punk. They totally sold out."_ _"Oh man, I love Harry Potter. I am such a geek!"_ _"Hardly. Talk to me when you're into theoretical physics."_ _"Erika Moen is my favorite queer cartoonist."_ _"She's not queer, she married a man!"_ _"Quit your gatekeeping. No one died and made you Queen of the Gays!"_ --- [^(about)](http://www.reddit.com/r/autourbanbot/wiki/index) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autourbanbot&amp;subject=bot%20glitch&amp;message=%0Acontext:https://www.reddit.com/r/Kotlin/comments/6fv567/the_programming_language_i_want_part_2/dimah0f) ^| ^(**Summon**: urbanbot, what is something?)
Yeah, I suppose so - and in fairness, Go is much the same for the most-part. I have also used PHP and NodeJS though, where there is a single, central source of packages. That does help a lot too. I suppose the longer you're with a language the more you'll come across libraries and get better at knowing what to look for specifically.
In general yes, but in this case you can't because this particular library made some unusual choices. SmtpPort's setter takes an int, but internal smtpPort field is a String and setter converts int to String - this prevents use of Kotlin's property access syntax. Similarly, setFrom, and setMsg modifiy some internal state which does not correspond to properties of the same name and type so you can't use it there either. So in the end, since it's not possible to use property access syntax consistently everywhere, I decided that in this case using classic setter method call looks more consistent than mixing method calls and property access syntax.
Yeah, I was trying to find the documentation for that specific functionality and wasn't able to within the time I allot to researching Reddit comments :) I'm sure you can find it if you spend a bit of time though.
`1.sum(2)` is more likely an example of extension function. It let's you add functions to preexisting datatypes. In JVM it is translated to a static function, i.e. `sum(1, 2)`. As for function with receiver, I think it is more like a shorthand. Like ```Abc().let { it -&gt; it.asd() }```, but with receiver like `run` does, `it` becomes a `this`. 
Chapter 11 of "Kotlin in Action", which you can download for free from https://www.manning.com/books/kotlin-in-action , explains this in quite a lot of detail.
I really like the DSL things that Kotlin can do, how I wish I can do the same in golang
I hate ranges of numbers and `for`'s dependency on it. For example take a look at this small exercise [based on this code golf](https://codegolf.stackexchange.com/questions/125383/draw-a-big-slash-x) [Try it online! Example code](https://tio.run/##pZG5DsIwEET7fMWIJjaIhFCGQ6KkhoLCjTkSWYQ1chwQQnw7JE44JRpwYWln/WZ35K22maJrUhB2UhGTJs1jTIyRp@HMGkXpmOPsoTz7srIZsVRnCYt6nHsXx7maYkzJ8hg11CAHaZBj1IiMDzwnJ9qASShCFAR09390lq6DgqzKIHnp0BnBh/94VQtC@O/cqnFkhG7FtdFHB9E3g1YoqOWky8ta6rnWG1Yjiwr5yEBY6yPNdTXptyThn0GEeCapbrOxhSHk5Qddbw) You'll notice there's so many different ways to iterate over a range of ints incrementing, decrementing, inclusive of end and exclusive of end. And don't even try iterating over a range of int decrementing exclusive of end. I'd rather just write c-style `for` loops
Maybe easier to go with kotlin native. 
&gt; In the JavaScript world, Flux Actions are just described as an object that has a type and a payload. But we don‚Äôt live in this mad world of anything and everything goes. We gladly wrap ourselves in type-safety blankets. They are warm and gentle, you scripting language lunatics. And oh so warm they are
Hmmm. I was looking for something like this recently. 
From what you explained, they are just convenience, no? If you have two cores, and you split the job between two coroutines, only one core would do actual work? So thread do the job faster if you have equal number of threads and cores, but if you have more you should use coroutines?
&gt;as anyone run into this before? Yes. &gt;have a good way of getting around it? Not really. I just avoid using lambdas as zip functions, and use actual methods with declared types instead. It also helps with readability since the zip operator is often hard to read. You could add type declarations to lambdas instead, but that's not as readable. 
My only comment is that I would think setting a null value on the property would intuitively remove the value from the bundle. I don't know how often that would occur but it would be surprising to set the property to null and have the operation ignored.
Good call. I'm pretty spoiled at this point so I was hoping for some clever trick that I hadn't considered. Thanks!
How do i join in on Kotlin discussions on slack? i thought it was a chat client
http://slack.kotlinlang.org 
Because this is a common pattern in my app, I ended up using extensions functions to deal with it. This is the one for `zip`: inline fun &lt;reified T&gt; List&lt;Observable&lt;T&gt;&gt;.observableZip(): Observable&lt;List&lt;T&gt;&gt; = when (isEmpty()) { true -&gt; Observable.just(emptyList()) else -&gt; Observable.zip(this) { it.toList() } .cast() // cast is from RxKotlin, but, you can avoid it like this: // .map { // @Suppress("UNCHECKED_CAST") // it as List&lt;T&gt; // } } Ps.: A `zip` on an empty list will return nothing, like a `Observable.never()`. My answer changes the behavior to something that works better for my app. If the list is empty, then complete that stream.
This is awesome thanks!
Kotlin is not a beginner's language
I think this mostly applies to Java developers. If you've never had to deal with boilerplate or life without lambdas, Kotlin is amazing. If you're coming from some more modern languages, it's not quite as life changing.
Not life changing, but I've been impressed by the approach to DSLs in Kotlin using lambdas-with-receivers. No macros, reflection or clever metaprogramming required.
You can extract the code and put it in a small library, given that it doesn't depend on any platform specific code.
It's not an easy language to pickup for someone new to programming. Jetbrains even says so in their docs.
Is it any harder to learn than Java? There was a time (granted, over 15 years ago) that Java was taught in CS 101...
I would say it is. Especially because of the functional aspect of it. I think the passing of functions and whatnot would be too much for beginners.
Is this a necessary part of the language to make a functional beginning program though? There are certainly advanced features of languages that are only used by more absence programmers, right? I still consider myself a beginner so I don't the real answer. 
agree. for a beginner that wants to learn programming, I think Java (+ C) and its verbosity is still better. The great features of Kotlin might be too much of "magic" for a beginner. Furthermore, besides the language details, it is also a matter of number and quality of tutorials and didactic material (eg also questions on StackOverflow), etc. Kotlin is still bit behind in those...
Als very minimal program with just a main function and some print statements looks way easier, clearer and to the point than Java. For a beginner there is no point in learning OO when you need to learn variables, conditions, branching and looping. Making mutability and nullability explicit seems logical (it can be thought of part of static typing). I do think students moving to Java afterwards will get a bad taste because of the implicitness.
Does it complain if you use a typealias?
I would recommend to get syntax highlighting for the code snippets in your blog.
I mean I can pass pointers around in C++ which is also confusing for beginners. Just because you can do something in a language doesn't mean you need to. It'd be very short sighted to try to teach a beginner to program by first telling them to pass a function into another function. **Edit** just wanted to add a Java example too, things are always passed by value in Java. However that value may be a reference so if I pass in a collection to a method, within that method remove an item and then outside of that method try to access that value it might be confusing why the item was removed.
 get() = if (weakRef == null) null else weakRef!!.get() When Java programmers try Kotlin first time 
They are more than a convenience. Thread context switch is expensive, real expensive. Besides threads cost memory as well. You can not create millions of threads, but you can have millions of coroutines (depending on implementation). And final bonus of coroutines is that you do not need to use any locking for shared resources if coroutines run on the same thread. Since scheduling is done manually you can always be sure that one coroutine is accessing things at certain time. Now if you have coroutines on multiple threads then cross-thread object access still needs locking.
I'll fix the typos... thanks for feedback :-) 
Certainly hope it will, here.
Personally. Everyone has their syntactic preference. So if they always can interop. No need for one to die
I'd use defaults in the primary constructor though in order to get the builder pattern. Like Car(color = "red", seats = 5) and leave the rest unchanged. IMHO way more concise and explicit than .apply mentioned in the post.
Ah, thanks. I like the visualization with a single timeline much better, by the way. How do you get the numbers?
This is pretty cool. I was just looking for a site to get started on Kotlin.
Found these queries that might help: https://gist.github.com/alysonla/e14c01ec7a0d2823e7317f7b58b22926 And this: http://githubarchive.org/ And this: http://githut.info
So, if i put const on a field in the companion object, what will the bytecode look like? 
I don't want to be negative about the above, but you might do better with [the existing, interactive tools from Kotlin](https://try.kotlinlang.org/#/Kotlin%20Koans/Introduction/Hello,%20world!/Task.kt). They have a series called _Kotlin Koans_, which walk you through all the basics and let you run and modify the example code as you go.
Great stuff, thank you
I agree, the use of apply is wrong here, those should be immutable vals, not vars. The shown use of apply leads to the "bean" antipattern. 
Ive read the documentation and written several programs. Ive just never had this issue. And what you are doing doesnt solve my issue since i need it declared as a JDA which is a class in the java library. Maybe i should try converting the library to kotlin
Great detective work! Good to have honest tear downs. 
I have difficulty believing that anyone starting out now would prefer Java.
&gt; The survey gained much attention, and we‚Äôve now placed it online to listen to the wider community. Now you can have your say on the Kotlin future online! But it doesn't accept any response any longer... :( I had no idea of this survey, I would have loved to answer it... Anyway, as Kotlin can be considered as a "better" version of Java, for me the most important features for the future is to add what is still missing from Java: * "Ternary conditional operator": for simple conditionals in expressions, it is so much better than if/else. Not a big deal for junior programmers, or developers coming from outside Java, but having used the ternary operators for the last 20 years, it is really annoying that Kotlin does not support it :( * "Static members": static state is evil (unless constant, and truly immutable), but static methods are so useful! Companion objects lead to so much boilerplate, which I really do not understand considering that Kotlin was supposed to reduce the boilerplate of Java, not increasing it :( 
Speak for yourself, I like Kotlin's Syntax but the same way there are people who enjoy the taste of cold sprouts, there are people who will like Java's syntax more. 
Thanks. Gathering as much resources as I can for when I get the time to play around with it all.
Because there exists a lot of implementations for Lists, Sets and Maps and it's generally a good idea to think about which to use (sorted, threadsafe, concurrent, immutable, observable) and so on. A literal would favor one specific implementation and looks unclean to me. In the same sense, I would have preferred if listOf() were instead List.of() and arrayListOf were ArrayList.of() so you could more easily see the implemented class/interface. I would be fine with literals like `ArrayList["a", "b"]` or `ImmutableList[1,6,7]` or `EnumSet[Red, Green]` when they specify the implementation, but I still find it questionable if this syntax is really beneficial or needed here and it could be complicated to automatically determine how to create the object at runtime. For example EnumSet and ArrayLists are constructed differently. In general, i also think that literal values need to be immutable. Something like `["a", "b"].add("foo")` would look very confusing to me. 
What if they make the syntax extensible? Something like c++ list initialisation? http://en.cppreference.com/w/cpp/language/list_initialization
Kotlin if/else can already be used as an expression, so I haven't missed ternary conditional operator. For stateless static methods I just put functions at module scope, works well with data classes.
if expression reads much better and isn't much longer IMO. Ternary operator could be confusing when there is also elvis operator in the language.
fair enough. My problem though is that I am used to always have {} for "if" statements, as I do for any statement having a block (eg, "for"/"while"). So, I usually would write: if(x) {"a"} else {"b"} which becomes too verbose compared to x ? "a" : "b" of course, I can write "if" statements without {} when used as expressions, but that is a hard habit to lose...
Oh, yes, forgot about those! Thanks! I'm dreaming of a pure Kotlin world, I guess. Trying to get our app to that point bit by bit and at one point I can finally do a replace-all on those annotations. ;)
I really like the Scala syntax: Map("a" -&gt; 1, "b" -&gt; 99) List(1, 2, 3, 5) LinkedHashSet(9, 82, 78) Map is a generic method producing the default Map implementation. If you want to have some specific implementation, you can specifiy it like `LinkedHashSet` in my example. I find it much more pleasant than `listOf` and the likes.
Ternary operator could especially be confused with the elvis operator (at least by beginners).
Also extra indent for the whole body of a companion object
`for (i in 0..10)` is optimized to good ol' for loop, but not `(1..10).forEach`.
"This overhead is spared"... and replaced with a different overhead. Sequences are far from free, and can be significant in or even dominate computation time depending on workload, and even JetBrains points this out in their various documentation. As is usually the case in engineering: use the simpler option (aka not sequences) until enough of your system comes together such that you can collect sufficient empirical data to find the first hotspot and attempt to optimize it. Measure. Optimize. Repeat.
Oh my, so it's named after an island. Hate to see your code. If a=b and b=c then a=c
Its not equality though. If the island was not named Java, but the coffee still was, the programming language would still be named Java.
I would hate to see YOUR code! You make poor assumptions and don't pay attention to detail ;)
Kotlin is named after the ketchup named after the Kotlin island. 
K is also the successor of J ;-)
Kotlin was named after me.
Kotlin is actually jimschubert?
No. I was named 37 years ago.
Kotlin drew its inspiration from the Simon &amp; Garfunkel song "I am a Rock" in which they sing "I am a rock / I am an island". Kotlin is not a rock, but it is an island, hence the name.
If you use AppCode, your transition will be a piece of cake.
Yeah but AppCode doesn't provide a few features and even the auto-complete is kind of lacking (overridden methods in the class etc)
One issue with `?.` chaining is that if something along the chain is `null` and you don't expect it to be, it can be hard to figure out which link in the chain was `null`. `?.` and related operators can encourage this kind of "silent failure", which is ultimately a bad thing. `!!.` might be ugly, but at least it makes some noise when something goes wrong.
As someone whose full time job uses both Kotlin and Swift. I think moving from XCode -&gt; IntelliJ will be the easiest transition lol. XCode is utter garbage and the Swift complier is very buggy.
Eh, I'm happy with Python. It just feels weird that there is 2 school, 2 and 3. I'm not a big fan of Scala even though Kotlin looks damn close to Scala.
The preview version of Kotlin Native was released back in April I think. Once that matures (in a couple years I'm guessing) we'll be able to code iOS apps using Kotlin!
What's your experience been with AppCode been? Any issues vs using Xcode?
Cool articles! A little jab though - making any assumptions about performance without benchmarks seems a bit premature. JVM does many optimization tricks and GC is great on collecting short living objects. Without numeric data it's hard to say whether overhead is significant.
Haha I didn't know I can use `associate{}` instead of `map{}.toMap()`.
Does Swift have true immutability support? True immutability like in C++ with something like const methods that are not allowed to modify object state, no matter if the object is on a heap or on a stack (like structs in Swift)?
Yes. Kotlin has `var` and `val` variables. But `val` simply prevents you from re-assigning the variable, but does not prevent you from mutating it. Swift has `var` and `let` variables. If you declare a variable as `let` you cannot mutate it, even if the type is otherwise mutable. Example: This is ok: struct Point { var x: Double var y: Double } var p1 = Point(x: 10, y: 20) p1.x += 1.2 But this is not: let p2 = Point(x: 12.3, y: 23.9) p2.x -= 5.3 Even though `Point` itself is mutable, the variable `p2` is declared as `let`, so you cannot mutate it. The compiler will complain: Swift:: Error: left side of mutating operator isn't mutable: 'p2' is a 'let' con stant p2.x -= 5.3 ~~ ^ It will also tell how to fix that error: note: change 'let' to 'var' to make it mutable let p2 = Point(x: 12.3, y: 23.9) ^~~ var See: https://iswift.org/playground?KEq3At
But the coffee would not have been named Java if the island wasn't named Java
Hmm, I guess Swift's immutability only applies to value types. Dictionaries, Arrays, and Structs are value types. Classes are reference types. So I guess a `let` declaration for class instances behaves like the Kotlin version.
But the `let` declaration is made on a value type, i. e. the struct "UserManager". And still it is allowed to modify (referenced) things, the struct instance owns.
But it's weird, because you declare `let` on a value type to rely on "true" immutability and then, suddenly, it's state is changed. So you can not trust a declaration, but must always look into the implementation details of the struct, to know, if it possibly will change it's state nonetheless: class User { var name: String = "default" var age: Int = 0 } struct UserManager { var u = User() func printName() { print(u.name) } func weird() { u.name = "weird" } } let um = UserManager() um.printName() um.weird() um.printName() Output: default weird See https://iswift.org/playground?MXm7L4
I don't know. I think once you get a bit familiar with Swift's value semantics, you might see that putting a class reference inside a struct makes very little sense (if at all), but I'm a newb myself so I'm open to to being corrected here.
Then it should be forbidden by the compiler.
/r/dadjokes
Maybe I don't quite know what true immutability is supposed to mean, but the important thing is that arrays are value types. When you pass an array to another function, you can be sure that the function cannot mess around with *your* version of the array. If the function tries to change the array, it will change a copy of the array. (It's copy-on-write so you don't have to worry about copying arrays needlessly).
&gt; When you pass an array to another function, you can be sure that the function cannot mess around with *your* version of the array. No. class User { var name: String = "default" var age: Int = 0 } func messAroundWithMyArray(ua: [User]) { ua[0].name = "weird" } let ua = [User()] print(ua[0].name) messAroundWithMyArray(ua: ua) print(ua[0].name) Output: default weird See: https://iswift.org/playground?eFhR8Q Swift really seems to have a half-assed implementation of immutability and that's even worse than the immutable reference only implementation (at least you always know what's up) in Java and Kotlin.
This could be ameliorated with some limited type inference. If basic types are list, map and set then syntax could be maybe something like [], ${} and $() respectively. If function asks for e.g. hashmap this is a type of a map so it would be someFunction(${foo to bar, baz to zaz}) or whatever. &gt; I don't think that tradeoff is worth it to save a few characters. But again, just my opinion. Everything is just a few characters but it does add up. I mean why sacrifice OOP purity just to have functions? And those characters add up quickly when you have deeply nested trees in code.
ok. I will make the post on Monday 16:00 GMT (reddit's peak hour).
Good point! In some cases the object may not have a key yet, so recommended practice is to compare just the business key.
Hi, I make these videos, my name is Oday. I usually make video tutorials about Android but lately I've picked up some Kotlin and thought I'd start a video series about that. I'd love to get some feedback on the work above, and if you can't provide feedback and you're new to the content, let me know how well you think the content was delivered. Enjoy the video either way!
vimeo sucks, would be better on youtube so I can watch at 2x. 
Hi! These *are* the original koans from Jetbrains, and I've mentioned this on the Play Store listing in the 2nd paragraph: &gt; The challenges in Kotlin K≈çans were designed and created by Jetbrains itself (the makers of Kotlin), so you can be assured that the content is high quality and up-to-date. You're right though, I should mention this on the Github README as well - that fell through the cracks in the rush of launching. This is definitely an oversight on my part. I will add it there and on the About screen of the app in the next release. Thanks for the feedback! **EDIT**: I've also added a link to the original koans repository on the Play Store listing, to make the source of the content extra clear: https://github.com/Kotlin/kotlin-koans-edu **EDIT #2**: Added links on the Github README.
Are the koans available through a public API? Where does the compilation and test running happen?
i think you meant reified, not refried
Yes, normally you should update, because these update releases are published to fix specific critical issues in the last full release. You can find the changelog for 1.1.2-x releases here: https://github.com/JetBrains/kotlin/blob/1.1.2/ChangeLog.md
typo fixed, thx
Ah yes, the good ol' refried types
Is it safe to assume that someone should know how to code to use this? This isn't a beginner tutorial correct?
Honestly, all the wasted space at the top looks terrible. It's a third of my screen.
What projects? Care to link them?
Its not RES Night mode compatible :(
TBH i don't think kotlin will replace java (even if i would love to see that ...). 
Yeah but with Kotlin native you have access to C and C++ libraries. 
Yes, but I'd rather not. The type system doesn't match and you will be dealing with char* and void* and whatever everywhere in Kotlin, which will be awkward. Also I'd rather avoid any language which doesn't check array bounds and allows use-after-free attacks and so on. The nice thing about Java in Kotlin is that they integrate almost perfectly.
char*-s and void*-s are long gone in modern C++. They don't even use 'new' for allocating objects anymore
Something like std::make_shared&lt;Type&gt;(ctor-args...);
This article is an unnecessary re-write of the original blog post from Andrey Breslav: https://blog.jetbrains.com/kotlin/2017/06/kotlin-future-features-survey-results/
Hoping to develop for both Android and iOS with this.
I am able to remember the good old days where Java native was hyped (yes there existed several products for that reasons). Guess what happened: Nearly nobody used them.
Thank you!
Is it because Java is an unpleasant language to begin with? 
No. --- Hint: Don't expect an answer explaining something, when you are asking like that. --- Edit: its nice to see down-votes, because it highlights the "maturity" of the kotlin community. "Java native" was a hype when java was perceived as the new sexy, better language. So basically when it was at the same stage as kotlin is today. As such, i interpret bruce3434's comment and also the down-votes as insulting. (Under the assumption that his "question" was not sarcastic)
No. The coffee likely wouldn't have been named Java if the island had a different name, but that's not the point they're trying to make. When you name something after something else, there's an intention. If you name your kid after Marilyn Manson, that does NOT mean that you also named them after Marilyn Monroe.
If Marilyn Manson was named after Marilyn Monroe, then by extension you did name your kid after Marily Monroe.
This is the strong point of Kotlin, there are only a limited way to misuse language features to harm maintainability, and it's pretty easy to tell people to stay away from those. Let's hope it stays that way.
Yet all commercial JDKs do support AOT compilation to native code, are still in business since Java exists. A feature OpenJDK is introducing for Java 9 targeting GNU/Linux x64, with support for other OSes planned for Java 10.
Thanks. Would you like to say something about your framework? What your motivation is etc. ?
I'd be really interested in whatever would be posted in this sub!
The little cast that could
I'm guessing this is downvoted for promoting a product, but the content is pretty well made and a decent intro to kotlin and spring boot for beginners.
How do you use those collection functions on non-collection iterations like LocalDate start to LocalDate end with a step of 1, as in the post?
You need to generate a sequence or an iterator with the elements first. You can create it simply with: val range = generateSequence(start) { it.plusDays(1) }.takeWhile { it.isBefore(end) } being *start* and *end* two LocalDate and then you can do: range.forEach { /* stuff */ }
Yeah, but you're generating a sequence which is a collection right? I seem to recall reading that sequences don't yet compile into streams, so wouldn't the progression have the potential to be more performant?
A sequence is an interface, that provides an iterator. Extensions like filter or map are decorations, so they do not iterate over anything, but work on each item flowing through them when e. g. forEach is finally called.
You can also just write an iterator, if you insist on a for loop: import java.time.LocalDate class LocalDateIterator(start: LocalDate, private val end: LocalDate) : Iterator&lt;LocalDate&gt; { private var current = start override fun hasNext() = !current.isAfter(end) override fun next() = current.apply { current = plusDays(1) } } fun main(args: Array&lt;String&gt;) { val dates = LocalDateIterator(LocalDate.now(), LocalDate.now().plusDays(9)) for ((index, date) in dates.withIndex()) { println("$index: $date") } } Output: 0: 2017-06-22 1: 2017-06-23 2: 2017-06-24 3: 2017-06-25 4: 2017-06-26 5: 2017-06-27 6: 2017-06-28 7: 2017-06-29 8: 2017-06-30 9: 2017-07-01 But i would prefer a boring while loop: fun main(args: Array&lt;String&gt;) { val start = LocalDate.now() val end = LocalDate.now().plusDays(9) var current = start while (!current.isAfter(end)) { println(current.apply { current = plusDays(1) }) } } Edit: Another possibility is to define your own "Java-ish" for loop inline fun &lt;T&gt; loop(first: () -&gt; T, isOk: (T) -&gt; Boolean, next: (T) -&gt; T, block: (T) -&gt; Unit) { var current = first() while (isOk(current)) { block(current) current = next(current) } } and use it in the following way: fun main(args: Array&lt;String&gt;) { val start = LocalDate.now() val end = LocalDate.now().plusDays(9) loop({ start }, { !it.isAfter(end) }, { it.plusDays(1) }) { println(it) } } The definition of an indexed loop could be inline fun &lt;T&gt; loopIndexed( first: () -&gt; T, isOk: (T) -&gt; Boolean, next: (T) -&gt; T, block: (Int, T) -&gt; Unit) { var current = first() var index = 0 while (isOk(current)) { block(index, current) current = next(current) ++index } } and you can use it like this: fun main(args: Array&lt;String&gt;) { val start = LocalDate.now() val end = LocalDate.now().plusDays(9) loopIndexed({ start }, { !it.isAfter(end) }, { it.plusDays(1) }) { index, item -&gt; println("$index: $item") } }
The Kotlin compiler optimises the range and lambda away though, so they're not really the same. The actual Java version would be for (int i = 1; i &lt;= 5; i++){ System.out.println(i); } 
Got it, thanks. I misunderstood what sequence was doing, and so I thought the approach in the blog post would have been the only natural solution. Thanks to the people above for taking the time to explain.
&gt; `current.apply { current = plusDays(1) }` Why not simply current = current.plusDays(1) 
&gt; `current = current.plusDays(1)` An assignment is no expression in Kotlin. Also `current.apply` is evaluated to the unreplaced `current`. Example: fun main(args: Array&lt;String&gt;) { var x = 5 println(x.apply { x = 7 }) println(x) } Output: 5 7
Feels like structs in JVM
If you're in Windows, use the normalization feature. http://lifehacker.com/5986236/normalize-the-sound-volume-on-your-pc-with-windows-loudness-equalization-setting
All five comments are negative, but the poll has a 82% in favour. Let me know later if you want the files after the later poll if "I" happen to win.
Thanks. That really is simple, and having never done this I just assumed the article was correct that LocalDate doesn't have rangeTo. Also, thanks for succinctly answering my question. I'm not sure why I got downvoted, I was genuinely asking.
That's because when we talk Java we really mean the JVM platform, which is quite big and dynamic, so there is a little benefit in AOT compiling Java while preserving the full JVM semantics. For example it is not possible to be fully compatible with the JVM spec without JIT, because classes can be loaded dynamically during a program's execution. Also the reflection is used heavily in the standard library, and the library is quite large for some use-cases. Kotlin Native is not intended as a replacement for the JVM. Instead it targets use-cases where the JVM won't fit.
This is great, Windows and Android Native! Congratulations on the work achieved, looking forward to test it over the weekend.
Try using ```.apply()``` if (regex.matcher(s).matches().apply { m = it }) { ... } ... 
My only concern with this is the logic needs to be different depending on the matcher that gets returned. Though I might be able to get the original regex back from the `m` variable to determine which it is.
I am more interested, are there GUI libraries that can be used multiplatform?
Oh true, specially if op wants to re-use those regex. I'll update my answer.
Can you use a sequence since it's lazily evaluated? val regex1 = Regex(...) val regex2 = Regex(...) val regex3 = Regex(...) fun test(s: String) = sequenceOf( regex1 to ::branch1, regex2 to ::branch2, regex3 to ::branch3 ).map { (r, b) -&gt; r.matchEntire(s)?.let(b) }.firstOrNull { it != null } fun branch1(m: MatchResult) = "hello" fun branch2(m: MatchResult) = "bye" fun branch3(m: MatchResult) = "third" Or if you want to keep the same sort of feel as the Java, you could define some extra functions to create a kind of DSL: typealias MatchResultProcessor = (MatchResult) -&gt; String inline fun matches(regex: Regex, s: String, branch: MatchResultProcessor) = regex.matchEntire(s)?.let(branch) inline fun String?.orMatches(regex: Regex, s: String, branch: MatchResultProcessor) = if (this != null) this else matches(regex, s, branch) fun test2(s:String) = matches(regex1, s) { m -&gt; "hello" }.orMatches(regex2, s) { m -&gt; "bye" }.orMatches(regex3, s) { m -&gt; "third" } Of course, you could use Any, Unit or some other type as the return type depending on what your branches do
I assume once the multi-platform work is done, someone will provide an abstraction on top of a few. The real problem is a lack of native cross-platform GUI libs w/ native look (Qt is annoying to use outside C++, see https://github.com/therecipe/qt/ and https://github.com/rust-qt/cpp_to_rust). Then on top of that someone's gonna have to have another abstraction over that, a JVM version (Swing, SWT, etc), a JS version (Qooxdoo?), etc. And even then, there are impedance mismatches when sharing UI code across platforms, especially mobile. So in a nutshell, not really, and you should target desktop, mobile, or web explicitly.
Semantic highlighting is here! Rejoice!
Ctrl+Q will show the signature of a method or type of a variable.
Try Ctrl+Shift+P on any expression. For example for generic methods it will show actual type instead of T Edit: shortcut 
I don't know either. I did not downvote here. 
But this is so beautiful! MULTIPLY NETTO-PRICE BY VAT GIVING PRICE. ADD PRICE TO SHIPPING-COST GIVING TOTAL. 
Fantastic cashing in on recent popularity boost of kotlin. Tons of in-page ads with no real content, just links to other sites. Bravo. We all thought about it, but they found a way to dance around integrity and have full on done it.
I would love to take a shot at this. Could you perhaps put the entire code block somewhere like a GitHub gist or similar?
The only outside link is "Kotlin in the Android World", for they have this great post https://developer.android.com/kotlin/index.html.
Can't wait for an iOS target! Kotlin all the things!
GPU-accelerated?
&gt; Conclusion: forEach provides a lambda style for a normal for loop, but this still compiles down to for. The for expression is therefore not redundant at all. How does this implementation detail prevent it from being redundant to the end user (a programmer using Kotlin)? For and foreach are interchangeable, and that's fine with me, but both are not strictly needed in the language.
ForEach is just an extension function built around for - anyone is able to create it, it is not a keyword: forEach cannot exist without for existing in the language. One can conclude the question about one of the two versions being redundant is invalid: they are the same thing. If you're wondering why you'd ever use a normal for directly: sometimes for is preferred over forEach, for example when using a simple range.
&gt; ForEach is just an extension function built around for - anyone is able to create it, it is not a keyword: forEach cannot exist without for existing in the language. Yes, it can: public inline fun &lt;T&gt; Iterable&lt;T&gt;.forEach(action: (T) -&gt; Unit): Unit { repeat(this.count()) { action(this.elementAt(it)) } } &gt; One can conclude the question about one of the two versions being redundant is invalid: they are the same thing. That kind of is the definition of redundant. &gt; If you're wondering why you'd ever use a normal for directly: sometimes for is preferred over forEach, for example when using a simple range. Why? forEach works just as well: (1..10).forEach { println(it) } 
&gt; Conclusion: forEach provides a lambda style for a normal for loop, but this still compiles down to for. The for expression is therefore not redundant at all. If A and B do the same thing then one of them is redundant. My question is about which of these two very similar pieces of functionality should people use - what are the pros and cons of each from a perspective of convenience, writability, readability, etc? (I'm aware that they compile to the same thing so it's not a question of CPU efficiency).
You have the same 'redundancy problem' in other languages, like JavaScript and C#. I usually prefer forEach because I think it expresses the intent clearer and is a bit shorter. If your team mates are not used to it, maybe a for loop is the way to go. I tend to avoid loops whenever I can because I prefer a more decalarative approach. One thing you cannot do in forEach is use the brake or continue keywords, they only work in loops. 
Either Kotlin Native or Java Native. I mean how else would you use OpenGL in Java.
An `object` is basically *static* (not really but I think of it like that). This means that there is no `this` in the context of the inner object. Either: make the outside class an `object` and make it basically static *or* make the `inner object` an `inner class` to get access to the outer `this` reference. Also read this: https://kotlinlang.org/docs/reference/nested-classes.html --- The possible ways: class Test { var test = "test" inner class InnerTest { var inner = this@Test.test // can be replaced by "test" } } object Test1 { var test = "test" object InnerTest { var inner = Test1.test // could be "test" as well } } 
&gt; Apparently an object inside a class is accessible without an instance of that class??? Yes, that's how static nested classes work: https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html
That's an inner class and IIRC, that's exactly how it works in Kotlin, too.
For classes, yes. For objects, not so much. In scala, you can do this: class Outer { object Inner { var i = 2 } } and if you have an instance of `Outer`, let's say `x` and do `x.Inner.i = 4`, the value is only `4` for that instance of `Outer`. Which is what I was trying to do in the OP EDIT: But of course, scala has immense hacks that look ugly when called from Java and maybe this is one of them
make Test open, implement it in the object, you get access to the variables, and the methods you want to leave alone just dont place open next to them the above works but I dont know the costs really or the effects, just trying things
Awesome! That's how science works: precise repeatable experiment with measurable results. Not just "blah-blah-I-guess" in the original blog post.
That doesn't follow. The original blog post was about Android, and this article is about Oracle's JVM. Performance characteristics may differ significantly between the two.
I have never got the impression that the original series was trying to guess anything. It showed you what happens to higher level language constructs so that you are aware of how it all behaves and where there might be impact to consider. It doesn't follow that it results in prohibitive cost. Not to mention that most of the costs were related to memory pressure rather than pure throughput. That, and method count, which is rather Android-specific to my understanding.
"Please support us and disable your Ad Blocker"... No thanks. I'm not going to do that for some unverified quality content. I'm guessing this isn't any better than a rewriting of some obscure part of the Kotlin docs. 
Actually I believe the original blog posts were describing cost in terms of the size of the generated code whereas this article is about performance. I enjoyed reading the original, as it helps me understand a little more about what Kotlin does "behind the scenes", but I find this article more valuable in terms of knowing what the runtime performance cost is of various techniques. 
Why is `forEach` so much slower?
Cool. Learned some new things. The linked article by uncle bob is also interesting (http://blog.cleancoder.com/uncle-bob/2017/01/11/TheDarkPath.html). I don't agree either, but I see the point that he's making.
If your asking that question then you already have the answer you wanted. I know when I need to use a `for` loop directly and when using the `forEach` extension will turn out better. The answer to whether it is redundant or not is no. It's not redundant. The answer on when to use it more complicated. It depends on the project, the established patterns, the team and the full needs of the problem. 
&gt; The answer to when more complicated. It depends on the project, the established patterns, the team and the full needs the problem. Right, and that's the discussion I was hoping for.
Totally disagree with the premise of the article. Kotlin and Swift are walking the right path, and we need everyone to get on board already!
Agreed. To use an analogy, Bob's premise seems to be that we should only have guns that always have a chambered round, no safety or trigger guard, and cannot fire blanks. My job is to write useful (hopefully!) software, and any technique, tool, or principle that helps me do that is fair game. I'm a TDD advocate, but that doesn't mean I won't take whatever help I can get from the language/compiler/tools! I wonder if Bob is also against memory management and running applications in ring3. 
As far as I can tell he's one of the leaders of the "design patterns" and "TDD" cults that gave us the likes of "dependency injection" and other atrocities. But that's a rant for another day. What really bothers me is that he seems to favor either a crippled language with poor static typing (Java) or a flexible language with dynamic typing and no static type checking at all. How can any seasoned developer not see the need for a more powerful type system that expresses the kinds of things you often do in dynamically typed languages?
I think he had a good thing going for a while, and I still agree with a fair bit of what he says, but he's been drinking the Kool-aid he helped make for too long. 
I admit it's uncharitable of me but I suspect there's a conflict of interest here. This guys *sells* TDD and design patterns. If the mainstream languages were powerful and flexible enough to greatly reduce the need for these things, then he would have spent a big portion of his career basically wasting his time. Of course dynamically typed languages are ok because they increase the need for testing (since you have no idea what's going on by just looking at the code). Java is ok because it's so rigid it's almost impossible to do anything interesting without overly complicated design patterns. I for one cannot wait for the day where Swift, Kotlin, and Typescript are *the* obvious choices for *any* kind of application, whether it's web, mobile, enterprise, system-level, etc. Kotlin can already fill in for java so that takes care of android and enterprise and servers. Swift can take care of ios and servers and system tools. Typescript can take care of web (frontend and backend).
Very good question. It looks like there's something wrong, because `forEach` should be inlined. It's definition is: public inline fun &lt;T&gt; Iterable&lt;T&gt;.forEach(action: (T) -&gt; Unit): Unit { for (element in this) action(element) } Edit: According to https://blog.gouline.net/kotlin-bits-for-loops-vs-foreach-30548d7472a5 there are two objects allocated for the forEach function. So it's not the forEach function that is that much slower, but many many small forEach functions (=&gt; object allocations + garbage collection) one after another. If the benchmark would compare looping over a range of 1,000,000 instead of over a range of 10, forEach should not be that much slower.
After a good night of sleep, I tried again and with great success. The trick is to use the syntax on(it.getUserByEmail("test@example.org")) doReturn User(...) instead of on { getUserByEmail("test@example.org") } doReturn User(...) and to update the mockito version to testCompile "org.mockito:mockito-core:2.8.29" which requires repository maven { url 'https://dl.bintray.com/mockito/maven' } Most of this comes from https://github.com/nhaarman/mockito-kotlin/pull/171 and https://github.com/mockito/mockito/pull/1032 Big thanks to the contributors of mockito and mockito-kotlin ;)
&gt; he's one of the leaders of the "design patterns" and "TDD" cults that gave us the likes of "dependency injection" and other atrocities hahaha dude do you even know what you're doing
&gt; but by the time you've wrangled it into submission over your function, by damn, that function works! Nitpick, but who really wrangled who into submission? I interpret it as the compiler wrangling you into writing correct code.
&gt; What does that even mean. Are the illuminati somehow involved as well? Well, cult as in cargo cult programming. People doing something because they think it has a desirable effect but without really understanding why it works (or whether it does at all)! 
Man don't bother this guy is fried.
Default functional parameters in inlined functions is something I've been waiting for. I hope the multi-platform API (`header`) makes it into the 1.2 as non-experimental.
Tnx, but there's a course on udemy that i enrolled in, it teaches you the language from scratch and it's all good, except that the guy doesn't speak English very well
Yes, I've read that, thanks. It's a perfectly good enumeration of language features, but doesn't really offer much information about which language features end up having the biggest practical impact in real-world code.
I've made a presentation for a talk I had given in this topic. You can check the slides here: (https://docs.google.com/presentation/d/1BC5DKfD2A-pgAk-bgDGzrHCp67U_R89XdMLMg8Dzu-s/edit?usp=drivesdk) As for Lombok: you don't need annotation processors and IDE plugins for data classes to work in Kotlin. Feel free to ask if you have any java-to-kotlin questions!
Java equivalent requires instance allocation for each debug statement which isn't too good.
For me, the small differences add up to a significant improvement in long-term maintainability.
Thank you guys
I personally really dislike the way the field checks get indented... But everyone got their own style I suppose.
Found this link: https://github.com/jreijn/spring-comparing-template-engines Gonna try them all.
And this: http://www.mitchellbosecke.com/pebble/home
https://github.com/Kotlin/kotlinx.html
For who's interested in the bytecode produced by the compiler I made [javap.yawk.at](https://javap.yawk.at) (select kotlin on the bottom left). It also lets you decompile the produced classes with procyon to see the equivalent java code (though procyon doesn't always succeed).
&gt; Kotlin generates these methods automatically when you create a data class, but sometimes this is not preferred. Just curious, why are the default implicit implementations sometimes not preferred?
I I believe this is default style for jdk (&amp;&amp; operator on new line): http://hg.openjdk.java.net/jdk10/jdk10/jdk/rev/1f0fb30f5279
The companion object is a singleton object. The methods in the companion object are analogous to (public) static methods. Moving them out of the companion object is similar to removing the static. 
Ok, that makes sense. Thanks for the info!
You can make this more concise and avoid the mutable map: companion object { private val valueMap = TestEnum.values().associateBy(TestEnum::displayName) fun fromDisplayName(displayName: String): TestEnum? { return valueMap[displayName] } } From: https://stackoverflow.com/a/37795810/2675560
Extension functions are good for dealing with 3rd party code. If an api returns a specific class, you cannot just create a subclass of it to add functionality. You would still get an instance of the original class
 I'm not 100% sure about yours, but here's a straightforward example that I think accomplishes what you are trying for: data class Node(val data: Int, val next: Node?) tailrec fun Node.rev(prev: Node? = null) : Node { return if (this.next == null) { this.copy(next = prev) } else { this.next.rev(this.copy(next = prev)) } }
This post should be named: How to answer your own questions... 
 &gt;But to be honest: i have no idea how to formulate it clearer. For any recursive call, once the function's arguments have been evaluated, it should be possible to free the stack frame before making the call.
Not read the docs, but imagine: If a method that takes a lambda is inlined, not only the method, but the lambda itself can be inlined. As a lambda will likely have captured arguments from the outside scope, you would be avoiding generation of access methods to allow access to what would be private members. As for overridden methods; if you inline an overridden method, calls to the method will be inlined at the call site of the method. Due to polymorphism, it won't always be possible to guarantee that the type being interacted with will be known at the call site. So, imagine a `Fruit` interface with a `rot` method. If you have an `Apple` implementation that inlines the `rot` method and you invoke `rot` on a variable of type `Fruit` referencing an `Apple` instance, the compiler will not know that the type being interacted with was an `Apple`. I only **imagine** this is the reason, but would love confirmation! 
Are there any SQL-like query DSLs?
But `Apple` would have to implement its own version of `rot`; I don't see the problem.
I try to code in a lot of different languages, C is one of them, yes. I was trying to squeeze out the maximum performance possible on a bit of code and was wondering why the Kotlin plugin was complaining. Edit: yes, I've read that article back when it was posted. Did *you* understand it though? The author writes about inlining lambdas, not normal functions!
I pasted that straight from the kotlin docs (i should have put quotes around it)
It exists just like it exists for Java. I just tried it: http://i.imgur.com/HoGxaOU.png
Ah, thank you! I was aware of that but was under the impression I was already using it, but I wasn't. It didn't solve the problem directly but did reveal it. Thanks again :)
You can use it to give a name to a block of code (and reuse it if necessary). Or, to create a shorter scope‚Äìuseful if you want to prevent the rest of the function from accessing intermediate values; or if you want a shorter lifetime for some variables. Or maybe you just want a narrower visibility, preventing the outside from accessing the inner functions. Now, if the question is about a named lambda vs a function, then I'm not sure. Maybe it's just a syntax thing?
You are right, but you cannot inline methods in open classes.
I guess that's for a similar reason as per polymorphism?
This is one of a few features that makes DSLs possible in kotlin. [The html DSL example in the reference is just lambda-ception](https://kotlinlang.org/docs/reference/type-safe-builders.html)
It started getting like a conversation between children and divorcing parents... &gt;Is JetBrains going to be acquired by Google? 
 inline fun &lt;T&gt; Iterable&lt;T&gt;.sumBy(selector: (T) -&gt; Long): Long { val sum: Long = this .map { selector(it) } .sum() return sum } fun main(args: Array&lt;String&gt;) { val timeIn = System.currentTimeMillis() val deferred: List&lt;Deferred&lt;Long&gt;&gt; = (1..1_000_000).map { async(CommonPool) { var count: Long = 0 for (i in 1..1_000_000) count++ count } } runBlocking { val sum: Long = deferred.sumBy { it.await() } println("Sum: $sum") println(System.currentTimeMillis() - timeIn) } } On my machine this runs in about 8 seconds. If I replace the for with (1 .. 1_000_000).forEach{count ++} it now takes about 3 minutes...why the increase? edit: formatting
Okay, will do. Thanks for the information!
It's certainly less weird than allowing a class inside a function which Java allows and where I have never seen someone use this productively. (not talking about anonymous classes or lambda expressions, real classes with name and so on) A function in a function is helpful for things like gradle build scripts and other dsls. It allows you to define a helper function at arbitrary points in the dsl which is quite nice. 
I've personally only ever used it for recursive functions that I only use in a single method. It's also nice in these situations that when you need things from the outer scope, you don't need to pass it as a parameter. And if you ever need to use the function somewhere else, then you can easily move it out of the function then just add the parameters from the local scope.
So, what does a class being final have to do with mutability? Honestly nothing comes to mind but I don't write much Java. Other than blocking inheritance and pissing off spring (in my limited kotlin/spring experience).
Unless I've missed something the author isn't using coroutines here at all, he's just using a thread pool to implement the [fork join](https://en.wikipedia.org/wiki/Fork%E2%80%93join_model) pattern. The purpose of coroutines is to be able to suspend threads in a super-lightweight way and resume them at a later time. There is no call to a suspending function in his code that I can see.
**Fork‚Äìjoin model** In parallel computing, the fork‚Äìjoin model is a way of setting up and executing parallel programs, such that execution branches off in parallel at designated points in the program, to "join" (merge) at a subsequent point and resume sequential execution. Parallel sections may fork recursively until a certain task granularity is reached. Fork‚Äìjoin can be considered a parallel design pattern. It was formulated as early as 1963. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Kotlin/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
You can write a recursive function with an accumulator that has an accumulator-less function wrapping around it. Eg: fun countThings(list: List): Int { fun _countThings(list: List, acc: Int): Int { // stuff _countThings(list, acc + 1) } return countThings(list, 0) } Or if it's a function that explores graph, you might have a "seen so far" list inner parameter etc. Excluding it from the outer function means the caller doesn't have to care about it.
The author is using the kotlinx.coroutines library so he is arguably using coroutines in this context.
Good catch! The example JetBrains posts does use a suspended function, I omitted that for clarity. Thanks!
Yeah we decided that the small performance hit was worth it for the increased readability/maintainability. I keep seeing this issue pop up in various forms. I think the problem is that when you first start using Kotlin you discover data classes and try to use them for everything, then you discover a use-case where you can't use them and it's disappointing. I'm holding out for Jetbrains to come up with a more elegant solution - until then we'll just keep using kassava as it works for us.
Not sure what the article wants to get into exactly, but if you have an open class, even if all properties of the class are immutable, you are not safe from someone inheriting from that class and making their child class mutable. But if a class is final, and all it's properties are final and also immutable, you can statically guarantee that that all instances of that class are immutable. 
Great example. I use functions within functions for this in JavaScript, and when I'm in other languages I feel a bit constrained by not having the feature.
In your `renderEach` you have `f(b)` where `b` is a `Z` and `f` is a `Z.() -&gt; Unit`. That call should be `b.f()` most likely. 
Without final you can make the variable accessible with reflection and give it new values. 
This is allowed in many other languages too, e.g. Python, JavaScript and soon in C#. A typicall use case for me is when I have a function with a bit of logic that can benefit from being broken down to increase clarity, or when there is duplicated functionality. It is clearer to put such a dunction inside the function that uses it instead of in the outer scope.
Check out an example from the "Kotlin in Action" book when a piece of code is refactored to reduce duplication using local functions: https://try.kotlinlang.org/#/Kotlin%20in%20Action/Chapter%203/3.6/3.6_1_ValidateUser.kt and the subsequent three files
If you use reflection like that you lose all guarantees anyway.
I just removed the inline modifier from my overridden function, and the code is running 3 times slower.
Other benefits of a for loop include iterating elements in reverse and starting at something other than the first element.
He is "using" it, much as I might "use" an iphone to hammer a nail into the wall :) He's not using it for what makes it valuable.
&gt;:) I am happy that you are happy. Spread the happiness around. [This doggo demands it.](http://data.whicdn.com/images/130230618/large.jpg)
So, for clarity, you omitted the one thing that makes coroutines useful? ;)
Basically just a copy-paste from the official documentation.
I see your point, but most of the things he used from the library in the example are variants of coroutines. Besides you can also use coroutines to implement a fork-join pattern, so implementing one doesn't imply he isn't using coroutines.
&gt; but most of the things he used from the library in the example are variants of coroutines. Except the one thing that makes coroutines unique and valuable, the ability to suspend. &gt; Besides you can also use coroutines to implement a fork-join pattern, so implementing one doesn't imply he isn't using coroutines. Right, just like you can use an iphone to hammer a nail.
&gt; The purpose of coroutines is to be able to suspend threads in a super-lightweight way and resume them at a later time. No, the purpose of asynchronous programming is to suspend routines (detaching these from thread) and resume them at a later time (in the same or on another thread). The purpose of the coroutines is to provide a clear syntax for asynchronous programming. You are describing a thread: a light way process. The cost of each thread and the context switch cost is defined by operating system, asynchronous programming define a layer over thread using a lighter scheduler (fork &amp; join). Finally I agree with you, this example does not benefit of coroutines at all.
Coroutines don't need to suspend to be valuable, they are lightweight, that alone is great and valuable. Otherwise you can argue that the current library is missing the point of coroutines creating all those `async` and `launch` etc. abstractions. Indeed it would be nice if they could expose the `suspend` function on the coroutines created using those functions And besides the point of the article was to introduce the coroutine library of kotlin, not exactly coroutines themselves. If you get my gist.
If I recall correctly this only works if you have already imported something from the class/file already. 
We're going around in circles here. &gt; Coroutines don't need to suspend to be valuable At the risk of belaboring the analogy, this is akin to saying an iphone doesn't need to make phone calls to be valuable, since you can always use it as a hammer. Coroutines are all about suspending, so this article misses the point of coroutines. The article will therefore mislead any reader that isn't already familiar with coroutines, which is unfortunate.
&gt; No, the purpose of asynchronous programming is to suspend routines (detaching these from thread) and resume them at a later time (in the same or on another thread). That's a semantic argument depending on how you define "thread", "suspending", and "routine". It's debatable but probably not worth the effort. I used the term "thread" to avoid introducing a new term which would then need to be defined carefully for it to be useful. &gt; The purpose of the coroutines is to provide a clear syntax for asynchronous programming. That's the purpose of lots of things, callbacks, futures, etc. The *unique* purpose of coroutines is to allow you to suspect *execution of your program* and resume it later in a very lightweight way.
When I was using JSoup I figured out my selectors with straight jquery from the chrome developer tools console, and transplanted them into JSoup, but there were some syntax that differed slightly. Of the jquery features JSoup implemented, I wish JSoup had kept a more thorough parity with jquery syntax.
Ah, I was thinking reflection but I didn't know that I couldn't access them via reflection if it was final. Which sort of makes sense why non open Kotlin classes have some issues with certain facets of Spring. 
Tiny suggestion: link to JSoup in your readme.
&gt; a class inside a function you can... you can do that? I've been developing with Java for about 3 years now. I have not seen that before. Or maybe I have and it confused me. I'm sort of glad
Thanks for sharing this üëçüèº
You probably never had. It's just useless.
It's for when you want to reuse a bit of code but only in one particular function. For this use case, it replaces private methods and provides better encapsulation. 
I think Kotlin will replace Java in the Android development and if the code can be compiled for each platform in the long term will be easy to switch in the Android OS, besides the benefits to share business logic with iOS and maybe write the backend implementation also in Kotlin (like swift its doing) but in a near/mid future
He doesn't mean high order functions. EDIT: Although this is how it works on bytecode level IIRC.
Exposed: https://github.com/JetBrains/Exposed
Just what I was looking for!
I will love to see something like html-ish language to build the GUI, I mean implement some kind of template engine that can render the UI just like the browsers doit, in other words, an electron like for Kotlin
Nested methods will not invoked if element not found chromeDriver { get("http://cool-website.com") elementByClassOrNull("possible-button") { click() wait(10) { elementVisibilityByClass("dynamic-popup") { sendKeys("Kotlin is awesome") submit() } elementInvisibilityByClass("dynamic-popup") } } }
Wasn't JSoup released before jQuery?
Thanks for your suggestions! Simple extractors weren't *that* problematic to maintain, but when you start getting chains of "fetch subview data" and "get all children by their next links", that's where the code gets difficult to comprehend in one view. So that's next, various subviews. If you have opinions on how you'd like for the subview handling to look like, feel free to share!
Got featured in this week's KotlinWeekly üòä http://mailchi.mp/kotlinweekly/kotlin-weekly-48?e=bdc73c03ac
Does that mean they're silently ignored if the element doesn't exist? Or are you demonstrating usage for the common misunderstanding by new Selenium users where you have to wait for elements to appear?
Thanks. That's what I was looking for.
If [findElements(By.className(className))](https://github.com/qwertukg/SeleniumBuilder/blob/master/src/main/java/kz/qwertukg/webDriverExtensions.kt#L149) is empty - [element](https://github.com/qwertukg/SeleniumBuilder/blob/master/src/main/java/kz/qwertukg/webDriverExtensions.kt#L152) will not be [build](https://github.com/qwertukg/SeleniumBuilder/blob/master/src/main/java/kz/qwertukg/webDriverExtensions.kt#L153) and `click()` and [wait()](https://github.com/qwertukg/SeleniumBuilder/blob/master/src/main/java/kz/qwertukg/webDriverExtensions.kt#L17) :) More about [Type-Safe Builders](https://kotlinlang.org/docs/reference/type-safe-builders.html)
but isn't async lambda itself is a suspend function https://kotlinlang.org/docs/reference/coroutines.html#suspending-functions
The lambda passed to async is a suspending lambda so you *can* call a suspending function within it, but the author of the article doesn't.
Oh interesting. I don't know. Interesting if JSoup came first
Where are the unit tests?
You're right, you can send a pull request üòÅ Not sure how to test the coloring works though
The same way [chalk](https://github.com/chalk/chalk/blob/master/test.js) does it. It doesn't necessarily check that the output is in color, but rather that the ANSI codes are included in the output string. edit: Do you like [Spek](http://spekframework.org/)? I would be happy to write a few tests.
Thanks, I'll add them then. EDIT: I've seen your edit. Sure! Go for it
My question doesn't really have anything to do with typesafe builders, though. If I've written a test suite with this DSL, it can be assumed that I've coded selectors correctly. As it's written, a page could change significantly and a test could still appear to pass because you're silently dropping blocks of assertions. Any reason you decided to return null rather than throw an error?
What line length are you using by the way?
120
Nice, can you add it to jcenter? I'd rather not add each repo on bintray :)
I feel your pain, I'll submit the package in a couple of days
Nice tutorials. But to be honest I find it very hard to understand what you're saying, because of microphone quality and your strong accent. Take this with a grain of salt though, cause I'm notoriously bad at hearing people in imperfect conditions.
Thanks!
I would love to hear your feedback!
I was looking for something like this yesterday! I'm going to try this out in a project I'm working on soon. I'll let you know how it goes! Thanks!!
thanks for suggesting and you took some time to watch my video..I will definitely improve on this. 
Okay, /u/vjames19, I'm wanting to use this with [Lettuce](https://github.com/lettuce-io/lettuce-core) who's asynchronous methods return **RedisFuture**s (a subclass of **CompletionStage**, not **CompletableFuture**). However, your extension functions are only available on CompleteableFuture so I can't use them. I suspect you can probably extend CompletionStage instead though?
It was necessary for me, to check if element exists, and i thought - it will be cool, if i make method, who can work with element if it exists. And u can always use usually methods, who throw an exception. I think, it can be useful, to check some filters results, do not thought about that in this case 
Haven't tried it or anything but I really dislike that you called your class Future because that collides with the jvm class. 
This is a bit worrying indeed. I tried it at some point but I immediately hit a few issues (including a stacktrace when trying to use autocomplete for the first time). I didn't try for much longer, but I'm interested in this because my company uses Eclipse with Scala currently. I'm trying to push for starting to try writing some parts in Kotlin, because of issues with Scala. But IntelliJ does not understand some of our Scala code (for instance, it highlights some perfectly valid implicit conversions as errors). So we would be in a situation where IntelliJ works for the Kotlin code, and Eclipse for the Scala code, meaning we would not actually be able to have a good experience in either of those IDEs for the whole project.
This is also a problem for us. We mostly use Eclipse (with Java and a COBOL like legacy language) and people might like to try Kotlin, but not at the cost of learning a different IDE.
The eclipse plugin has many issues and often doesn't work correctly. Most of these issues are already reported but I feel like JetBrains doesn't really care about the eclipse plugin: https://youtrack.jetbrains.com/search/Kotlin%20Eclipse-19206 
Can confirm. My company is an Eclipse shop and the low quality of the Eclipse plugin rules out Kotlin for the moment. I am still using it for personal projects with IntelliJ but, being an Eclipse (and NetBeans) guy, the friction is high. All in all I very much prefer my languages to be IDE agnostic. Maybe we could suggest the Eclipse Foundation to take over the development.
You aren't providing much detail here, so I'm making some guesses, but you could probably [add a extension methods](http://kotlinlang.org/docs/reference/extensions.html) to the class for `g` that accept the data types you want and convert them quietly. fun GClass.setColor(r: OtherType, g: OtherType, b: OtherType) = this.setColor(r.toFloat(), g.toFloat(), b.toFloat()) Now you can just call `g.setColor(a.r, a.g, a.b)`. You can do something similar for `.draw` Or you can go further and add `GClass.setColor(a: ClassForA)` and have it extract the properties. It depends on how often you are doing this.
It was the hope of JetBrains that the "community" will pick up this plug-in. However, I didn't except they let it die so early.
Eclipse is community developed, JetBrains has its own IDE to support. Why can't the Eclipse community improve the Eclipse plugin? 
Thanks, extension methods could probably simplify this code a lot. But I see code like that all over the project. Are we really meant to add extension methods for all those functions? If so, I find this particular Kotlin design decision extremely odd. The Kotlin compiler is normally very helpful and infers types for you but in this particular case it goes to the opposite direction.
It's mostly written by a JetBrains employee. Sure it's open source and everyone can contribute. But they are advertising that Kotlin works with eclipse or any IDE: "Tool-friendly Choose any Java IDE or build from the command line." "USE Eclipse Install the plugin from the Eclipse Marketplace" No hate but a working eclipse plugin would help Kotlins adoption.
There's a [fairly lengthy discussion in the docs about when Kotlin doesn't perform implicit casts](https://kotlinlang.org/docs/reference/basic-types.html#explicit-conversions). Due the reasons outlined there, I doubt you'll find a way to implicitly convert primitives, because it can lead to unexpected errors. While Kotlin _is_ designed to reduce boilerplate, it's primary goal is safer code. Forcing the developer to be aware of type conversions like this is a good example of where safety was chosen over being terse. Hopefully someone with more experience can help further. You may get more help if you included specific types for the original example. It's hard to infer what you are converting from with the examples there, and which libraries you are using.
Have you considered [Ceylon](https://ceylon-lang.org/) instead of Kotlin? It doesn't get talked about as much, but it's got a lot going for it. It has a plugin for Eclipse that may work better than Kotlin's. I know it came before their IntelliJ plugin, but I think they switched focus when Google moved Android development. Ceylon is very good at consuming Java libraries, but probably not as good as Kotlin in the other direction. On the plus side, it's a much tidier language than Kotlin (imo, obviously). The syntax is instantly familiar to Java programmers. It changes some "keywords" (quotes because Ceylon tends to use annotations instead of reserved keywords, but its annotations don't require any special syntax like an `@` prefix so you don't usually notice), but mostly for the better. It has reified generics, typesafe reflection, comprehensions, optional named parameters for every function (you choose whether to invoke positionally or using names), and the best type system on the JVM. Seriously, the type system is so cool. Great type inferencing, flow-sensitive typing, union and intersection types, typed tuples, etc. It can even encode whether a sequence of elements may be empty or if it's guaranteed to have at least 1 member. `null` is implemented as a singleton object of type `Null`, which cannot have any other instances. A nullable variable is just a variable with type `T|Null` (abbreviated as `T?`), where `T` is the type and `|` is the union operator for types. The compiler is smart enough to eliminate branches of a union type mid-function, so you never have to do the instanceof/cast dance you do in Java. Oh, I almost forgot one of the best parts: it has a real module system built into the language. It's compatible with OSGi, JBoss modules, and Jigsaw. Ceylon can compile to Java byte code, JavaScript, and there's even a compiler backend for Dart. Someone was working on a translator for TypeScript declaration files, but I think that project may have stalled. Ceylon definitely isn't as popular as Kotlin, so the community isn't as active. The good news is that there's [a proposal](http://projects.eclipse.org/proposals/eclipse-ceylon) for it to move from Red Hat to the Eclipse Foundation. Hopefully that will give it a bit more visibility. For the record, I know Kotlin has a lot of those features too. I'm just really excited about Ceylon ;)
/u/rikbrown If I provide extension functions for CompletionStage it will return a CompletionStage and not a RedisFuture(not sure if this is what you want). CompletationStage has a method toCompletableFuture(), you can use that and then all the extension functions will be available to you. Looking through the RedisFuture, it doesn't seem to be providing much besides a new type and "boolean await(long timeout, TimeUnit unit) throws InterruptedException" which is the same as "CompletableFuture.get(long timeout, TimeUnit unit)". Is there an use case for the await function? The only implementation they have is [PipelinedRedisFuture](https://github.com/lettuce-io/lettuce-core/blob/1aa6353ccd6b37111cb5c7c69b5cd91984e24617/src/main/java/com/lambdaworks/redis/cluster/PipelinedRedisFuture.java) which is in fact a subclass of CompletableFuture. Do you have an explicit need for RedisFuture? Can you send me an usecase?
[The object class](https://github.com/vjames19/kotlin-futures/blob/master/kotlin-futures-jdk8/src/main/kotlin/io/github/vjames19/futures/jdk8/CompletableFutureExt.kt#L78) or the [function Future](https://github.com/vjames19/kotlin-futures/blob/master/kotlin-futures-jdk8/src/main/kotlin/io/github/vjames19/futures/jdk8/CompletableFutureExt.kt#L12)? In any case it seems like this would create a clash for some. I could renamed the object class from Future to KotlinFutures and the function from Future to future. Would this improve it?
I assumed Future is a class since it starts with an uppercase letter. Having an uppercase function also is confusing in addition to the collision with the Java Future interface. 
I'm not really surprised.... If we read one oldish post on their blog: https://blog.jetbrains.com/kotlin/2011/08/why-jetbrains-needs-kotlin/ I quote: &gt; The next thing is also fairly straightforward: we expect Kotlin to drive the sales of IntelliJ IDEA. 
The logo should be a bit smaller. It takes up a lot of space unnecessarily IMHO. Apart from that it is cool!
You could use JSON, another structured serialization format. Otherwise: there a few easy to use XML parsers with XML-&gt;Object and Object-&gt;XML.
I know now that Google is sponsoring Kotlin, Kotlin development is going to be moved from Jetbrains to a new non-profit organisation. Maybe when that move is complete they will get more serious about the Eclipse plugin. Or they're hoping Eclipse foundation will take over as the language gains traction. Either way, they shouldn't have stopped supporting it so soon.
Unless you will benefit from XML (e.g. using schemas and the like) then I would go with JSON.
But Google uses IntelliJ, too (at least for Android). There will probably no big motivation to move the Eclipse plug-in forward, then.
Ceylon never took off and probably never will. Even the best Eclipse plug-in can not rescue this language. And I doubt that IntelliJ, my preferred IDE, has decent Ceylon support. 
I've used Simple XML and Jackson to some success, as in they parsed XML just fine and created the POJOs needed. I didn't get too deep into either though. One aspect I couldn't quite figure out at the time was putting together something that ignored unused tags or attributes. So my data classes were rife with default values of null. That said, I really would go with JSON if you're going down this route. It's a bit more 'modern' and you can find a lot more Kotlin-centric solutions here than with XML.
I'm a mustache fan myself, but Spring is much better integrated with thymeleaf. Once you learn the spring gotchas for mustache (like enabling CRSF tokens and form parsing) it's all peachy though.
https://github.com/pvo99i/ksax
[Actually there is a Ceylon plugin for IntelliJ!](https://ceylon-lang.org/documentation/1.3/ide/intellij/). I think they switched focus from Eclipse to IntelliJ after Google switched for Android development. It's pretty good, but probably not as good as Kotlin's support for obvious reasons. I agree that Ceylon isn't as popular as Kotlin but I haven't given up hope yet! It's a really nice language. Even if it never takes off, I'm really happy to see that its ideas are spreading to other languages like TypeScript and Kotlin. Anyway, I didn't mean to offend. I just thought it sounded like a good alternative given your constraints. I hope you enjoy using Kotlin!
jaxb ships with java, should be usable from kotlin.
Might help but not much. I'm actually surprised that there are still some prople out there who use Eclipse or Netbeans. I really liked Eclipse but ever since I started using IDEA using Eclipse is like using Java after programming in Kotlin (horrible). No one I know uses Eclipse anymore.
See "Configuring your build" at the bottom of your linked Readme. Past the `compile` line in the `dependencies` section of your `build.gradle`. You may also need to add the `jcenter()` repo as indicated. Just note the `buildscript` top-level section should come before any `plugins` or `apply plugin` sections if you end up having to add it. Next time you run `./gradlew run` (or `test` or whatever) it will download the dependency automatically and link against it during compilation.
Gradle can automatically download and include libraries that are in public repositories. kotlin-argparser is in a public repo called jcenter. The readme tells you how to do it. Here I'm copy pasting from the readme: buildscript { repositories { jcenter() } } dependencies { compile "com.xenomachina:kotlin-argparser:$kotlin_argparser_version" } you can hardcode the latest version number (2.0.3) in place of "$kotlin_argparser_version" to get this in your code.
Okay, I don't know anything about this ecosystem and doesn't seem worth the trouble. Thanks for the reply though edit: okay guys, I was a bit of a cunt when I posted this. Got it working, I'm fine now. gradle's aight 
Gradle is pretty straightforward and something you should be familiar with for most jobs in most JVM languages. It's basically Maven written like JSON (actually Groovy) and you should know Maven too. But seriously, paste the lines in the file and run the build a few times, you'll get it.
If you're a Python user, Maven repos and dependencies are like a decentralized PIP. Maven/Gradle "plugins" that do builds of your app/library and run tests are something like PyBuilder, for instance. Both Maven and Gradle do both (and Gradle can use Maven repos for dependencies). Both of them support things like testing and having different dependencies when you run tests than in production. But really, stop reading other stuff and paste the shit from the Readme into your file and hit run and repeat until it works. It's like a few minutes' worth of effort even if you just randomly dumped the lines in random places and just read the error messages.
There must be plenty to know about gradle, but what command would typically just build the updated gradle file? I take it that to add libraries to your project in the future, you could just add `compile "address here"` to that snippet. It seems that whenever I look up something like "gradle tutorial", I would always land on a book full of information. I'm just hoping for something about as easy to remember as python's pip. 
I guess you're right, I'll try sticking with it. I only say worth the trouble because my job currently doesn't require kotlin, gradle, or anything of the kind. Just been playing around with it, but yeah I guess it's not so bad
It's used a lot in the Java world. A lot of enterprise development will happen in NetBeans or eclipse. That being said I completely agree, IDEA is a very very very good product that makes eclipse feel like a whale.
So you are surprised, that people are using an IDE that has dominated the marked for a decade? Seriously?
there's nothing like pip in Java. It's different languages, with different build and dependency management models. For a small script-style project, maybe Grape (http://docs.groovy-lang.org/latest/html/documentation/grape.html) will sound a bit more lightweight. Or maybe try this: https://github.com/ctrueden/jrun
Typically I will search for Gradle kotlin or java setup. Gradle has plugins for many languages so you need to be language specific. Generally 'gradle build' is the most common command to rebuild latest code and run is common to both build and execute the code. 
Yes. I'd be surprised if I saw someone use Fortran which dominated the market for more than a decade. Same stands for seeing someone use a Walkman (casette player). Now Eclipse is eclipsed.
There is a slight difference: Eclipses domination is only a few years old, and it still shares roughly 50% of the market. I wonder if you are really believing the nonsense you are talking
At this time there's no active development on the plugin because the developer who used to be responsible for the plugin moved on to other tasks within the team. However, we do plan to resume active development very soon.
The way gradle &amp; maven (java's two most popular build tools) manage dependencies is through an _artifact repo_, similar in some ways to pip. The big difference is that java is not dependent on a 'runtime environment' the same way that python is. Where you might use something like `virtualenv` or some other tool in python to separate the environments of different projects and `pip install` to get dependencies, java tooling does things a little differently. In the case of maven and gradle, you don't generally have something like `pip install` or `npm install`. You simply add the dependencies you want to your `dependencies` configuration, either in the `build.gradle` or, in the case of maven, the `pom.xml` file. Then to 'download' the dependency, you simply execute the build: `gradle build`, and gradle will first evaluate what dependencies are needed, see if they are available in your local cache (~/.gradle, or ~/.m2 directory), and if not, then it will download them through the repositories you have configured. Build will also run tests and compilation. Dependencies are identified by a unique _coordinate_ which is a trio of _group_, _name_, and _version_. So you simply figure out the library you want to use (say, through a search like maven-central or finding the library on github and using the info provided in a readme), and add it to your config file. These dependencies are generally served from an artifact repo much like pip or npm. The most common ones are _jcenter_ and _maven central_, but there are a few out there. Gradle is a pluggable build tool and resolving dependencies is only a small part of what it does, so right away it's quite a bit different. It's more like pip + make + fabric + pybuilder + more. The gradle docs are pretty good, but also very long due to the large number of things gradle can do. With gradle installed, try running "gradle init" in an empty directory, then run `gradle tasks` to see the tasks of a simple empty project, and that should be a good way to start looking into what is available as a baseline. Init will also create an example build.gradle for you with some comments, which may be helpful.
You're not going to find PIP in Java land, because the use of PIP makes Python projects notoriously hard to build out of the box. After you clone nearly any Gradle project, you should be able to just run `./gradlew build` and everything will be downloaded and your project will be built, no extra effort. (Java, Android, Spring, etc. plugins will give you `run` and `test` (or similar) tasks so it's one command to get from cloning to running, but `build` is common to all the plugins. Most `run` and `test` tasks will depend on the `build` task.) Any time you run any Gradle task, Gradle will download the dependencies required for it. So `dependencies` in the `buildscript` section, which affects what plugins you can use and how the build works, are downloaded first (you can run`./gradlew tasks`, which doesn't need to do a build, to see what tasks are available). If you run a task that depends on a `build` task to be done (like `run` or `test`) it will also download dependencies in the top level `dependencies` section below your `buildscript` and `plugins`.
I got the overall feeling that we should have a contest. Hopefully someone has energy to organise one.
I didn't take it as offense. It is just that I've seen way too many technologies never got traction and silently disappeared. I'm trying to avoid waisting my time with such technologies, as nice as they might be in some cases.
I did hear about sealed classes, but never had the time to try to study them in details. This was a very clear and succinct explanation! thanks. although if the main use case is to avoid an *else* branch in *when* statements, then it does not seem to be such a critical feature (or are there more important use cases for sealed classes?)
Data classes with a shared base class are only achievable using sealed classes - that's something we've found really useful.
[removed]
I've found that I (and most JetBrains Kotlin libs I've seen) use Kotlin extension functions in place of where you would use "utility" classes in Java. For /u/OverZealousCreations's solution above I would put this function and any other `fun GClass.blah(...)` extension functions in the file/package `/my/project/src/main/kotlin/my/package/util/GClassUtils.kt`, where your class is `GClass`. For things that extend various Number types I just Keeps things pretty straightforward, and you could literally convert it to a Java utility class if you really had to.
Glad you liked it! Thanks. It's not critical at all :)
Yes I do. Look here and see for yourself: https://zeroturnaround.com/wp-content/uploads/2016/07/intellij-idea-overtakes-eclipse.png This looks strangely familiar to this which is a sales graph of music grouped by media (mc, cd, etc): https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAj3AAAAJGZkMjMzNTM5LTNlZDYtNDhlNy1iZGZhLTgyNWM1NjA3ZDI2ZA.png Eclipse is on its way out. Good riddance I say.
It's basically the same as an enum except you can apply more complex inheritance to the abstract class. Nice!
It is really important! When you currently have 2 cases and use: if (case1) { ... } else { ... } And half a year later you or some new guy add a 3rd case. You now have a potential silent bug in your code. The "else" also catches your new case! With sealed classes and "when" expression the compiler FORCES you to handle the new case. 
For more info, this isn't a "Scala" thing that Jetbrains used (as so many authors imply). Many languages use "algebraic data types". Here is an article for you to peruse: https://en.wikipedia.org/wiki/Algebraic_data_type 
Selenium is really good and it supports Java. http://docs.seleniumhq.org/download/
Worked with both jsoup and HtmlUnit for web scraping. Both great libraries. jsoup is mostly an HTML parser and is easy to use + efficient. HtmlUnit is a headless Java browser. HtmlUnit can deal with Javascript websites, but requires more resources. You can also use it with Selenium. 
I have used jsoup many times and it is great for html parsing. Plus, it can take css selectors and give you a list of all elements that match. I don't know where you got the idea that it was outdated since the latest release, [1.10.3](https://mvnrepository.com/artifact/org.jsoup/jsoup/1.10.3), was released on June 11, 2017.
What do you mean exactly? This code works just fine: open class A data class B(val x: Int) : A() data class C(val y: String) : A() Do you mean something different by data classes with a shared base class?
You can get it from jcenter now compile 'com.andreapivetta.kolor:kolor:0.0.2' 
Thank you!
No, you're totally right - for some reason I had it in my head that data classes could only extend sealed classes. Hooray, data classes are even better!
Hey in java for general web scraping the best available solution is absolutely Jsoup. It is very convenient to use. And it was updated exactly a day ago by the author Jonathan Hedley so it's as up-to-date as possible. Also, jaunt might a good choice it's a very lightweight parser lib. HtmlUnit is not created for scraping but testing though it can deal with javascript generated content. I developed several projects with Jsoup and I think it's the best choice in java if you don't need js support
Not that I am aware of, but feel free to pay for one and release it publicly :)
I'm not aware of any such audit formally, however, Kotlin is typically used on the Java Virtual Machine and the JVM's design prevents many types of security vulnerability (like buffer overflows). Kotlin was created by JetBrains and they are, in my experience, among the most competent software engineers on the planet, while the code is written to an extremely high standard. It is likely that they employ peer-code-review processes which could be considered a form of audit. They may also employ static code analysis tools which may be considered a form of automated audit. It might be helpful if you could explain why you need this.
I'm sure they use code review and static code analysis, but it is not the same as independent audit, and they are not replacement for each other. As I want to believe in JetBrains I cannot tell my partners "they are great guys, I believe in them". We don't use their products after some security issues long time ago (I don't quite understand or remember, but it was something with one of their IDE and youtrack) and convincing all peers that this is in the past require more work (Not mention of a "russian paranoya" of some people :) ). I would like to prepare to the speech and provide as many strong points with proof as possible. I've done some research and found nothing except Google sort of approved it, but this may be not enough. And this is why I'm asking it. Thanks for understanding!
Not only has Google approved it, but it is officially support on the same level as Java is for Android. Google has a lot invested in Android and have tied that to Kotlin being a success.
&gt; I'm sure they use code review and static code analysis, but it is not the same as independent audit, and they are not replacement for each other. Can you provide more information on what exactly one of these independent audits consists of? I hate to be cynical, but it sounds like the type of thing a [PHB](https://en.wikipedia.org/wiki/Pointy-haired_Boss) would ask for. How much of the software we all use on a daily basis would meet the standard you're setting? Does the web browser you're using right now meet it? A chain is only as strong as its weakest link, which means your entire stack would need to be audited, including all libraries, right down to the OS. And then there are truly evil hacks like [this one](http://wiki.c2.com/?TheKenThompsonHack) where even if you could perfectly audit your source code, and then perfectly audit your compiler's source code, you could **still** have a malicious backdoor in your code.
The big question here is whether the website you're scraping is likely to take countermeasures against web scrapers, and whether you need to simulate javascript in the browser for it to work (eg. if it is a React website or something like that). If the answer is "no" to both questions then go with JSoup. It's a great library, powerful and well-designed API (it mirrors the JavaScript DOM API). JSoup has been around for a while, but I don't think it's dated at all. If "yes" to either question then Selenium or HtmlUnit. Selenium is messy to set up because it has to talk to an actual web browser (ie. it's not pure Java), but because it's using an actual modern web browser it tends to work well, and would be difficult (but not completely impossible) to detect from the server side. I use HtmlUnit for testing a current project because I need JavaScript support but don't want to deal with a separate web browser. HtmlUnit can be very temperamental. There are things that should work but don't, and you have to find workarounds. Use jsoup if possible.
&gt; The big question here is whether the website you're scraping is likely to take countermeasures against web scrapers, and whether you need to simulate javascript in the browser for it to work (eg. if it is a React website or something like that). Why? You can set any user agent with jsoup: https://www.javacodeexamples.com/jsoup-set-user-agent-example/760 You also can use cookies (for login etc.) with jsoup: https://www.javacodeexamples.com/jsoup-login-to-website-using-post-method-example/830
I'm not an expert in the security at all, I need some authority source to proof, that not only Kotlin contributors and fans looked at their source code with big wet shiny eyes. So far all hopes on Google, but there some concerns too. Independent audit performed for bunch of software, browsers have their "audit" through bug bounty programs (but it more like black box testing) and, since they big enough, they have own security team, independent from main dev team. Even some frameworks did audit (Symfony). Sadly not so many OS projects do so, MOSS was completed for [only 11 projects](https://wiki.mozilla.org/MOSS/Secure_Open_Source/Completed). JetBrains actually not so much big company and not well known for their security specialists or activity in security domain, and it seems they don't have bug bounty program either, concerns of some people have a right to exist. Since other peers of my company had bad experience with JetBrains products, they completely rejected them "because of lack of security". To change this opinions I need more information as a proof that at least this product Is worth looking at, and that risks are not so high as they think. Points like "but others product don't have it" may not work in this case. It's like if you many times stuck in the middle of a desert on a ford and not once on any other car, will you trust ford after this? In other words, I need to fight with irrational fear. So far only Google will be my "strong point". And now I'm starting freaking out :)
dom4j: https://dom4j.github.io/ There are also many other alternatives like jdom, xalan, xerces and so on.
Because JSoup doesn't execute JavaScript, meaning that if the page relies on JavaScript to retrieve information from an API, as many do, JSoup won't see this information.
Ah, ok. That makes sense. Then maybe a HTTP client and a JSON Deserializer would be better. You could browse the page and look with Firebug, other tools or browser specific means, what requests are made, to fetch data and use these urls to fetch and deserialize the responses.
Unless your company is doing something **extremely** security sensitive then it's ridiculous for your coworkers to suggest that what's good enough for Google isn't good enough for your company. They sound clueless, to be honest with you. I don't know what bad experience your peers had with JetBrains products, but I do know that JetBrains has an excellent reputation, and not just among fans of Kotlin. Their IDEs are used by about 1 in 5 software developers according to [this survey](https://insights.stackoverflow.com/survey/2016). If you can point to some concrete evidence of why they can't be trusted then I'm happy to take a look at it, but I doubt it exists. Beyond that, I don't know what advice to give you. Perhaps you should look for a better company to work for?
Yeah, reverse-engineering their API would be easier - but fragile. Then again, scraping is fragile too.
Awesome, in-depth article. Thumbs up.
Thanks, happy to hear that 
Agreed, this is another reason I want to use Kotlin.
Nobody does external security audits unless it's medical, aerospace, or there are otherwise lives or financials at stake. There's Corda, a distributed ledger platform, which uses Kotlin: https://github.com/corda/corda, with backing from the financial industry. I also have no idea what history your coworkers have with Jetbrains to earn this much distrust.
Can't you just put this stuff in a sequence? Or am i missing something? Code below might not compile ;) "Given a set" - { val set = HashSet&lt;Int&gt;() "on adding and then removing a value" - { set += 5 "should first contain that value" { set shouldEqual setOf(5) } set -= 5 "should then no-longer contain that value" { set shouldEqual setOf&lt;Int&gt;() } } }
The problem is that kotlintest won't always execute the "should then no-longer contain that value" block after the "should first contain that value", so this would fail at random :/
This is not intended to produce 100% correct Kotlin that compiles and runs out of the box (even if that would be very nice if possible). But rather as a helper when porting code from C# to Kotlin. Any help is welcome.
How many percent correct Kotlin is it intended to produce?
Is "as much as possible" an acceptable answer? ;-) There are things that will not translate well, C# unsafe pointers, native interop etc. The reason for building this is to be able to port Proto.Actor to Kotlin with as little effort as possible. This will still require manual fixing of code and adapting to use JVM libs. 
Interesting read, but since when does Scala provide coroutines natively? Serious question, perhaps there's some concept that is not usually referred to as coroutines, but can be used as coroutines.
Scala has Actors, which is at least similar to what we can do with Coroutines. Have a look here http://www.scala-lang.org/old/node/242
Actors have been removed from Scala, nowadays Akka is the go-to framework for using Actors in Scala. Even so, actors are not coroutines.
Okay, then this is obsolete probably. No they're not. I have to admit that I didn't verify this information taken from Wikipedia. I'm gonna remove it, thanks for your feedback.
Wikipedia refers to [storm-enroute/coroutines](https://github.com/storm-enroute/coroutines) for a coroutine implementation in Scala, but this is a library-level extension. Also, a look at their issue tracker shows that this project is still immature. Another problem is that this implementation does not provide stackful coroutines, which is a real bummer in a language like Scala where even the for-"loop" is desugared into method calls.
https://stonesoupprogramming.com/2017/07/08/kotlin-spring-security-hibernate-login/
This should get you what you want. I wouldn't recommend using a sequence, or stream, in this example as the overhead wouldn't be worth it for a URL as I'm guessing that there are just not enough elements to warrant the use. parameters.map {(k, v) -&gt; "${urlEncodeUTF8(k)}=${urlEncodeUTF8(v)}"} .joinToString("&amp;")
JSoup worked just fine, project still maintained, last commit 3 days ago, not sure what you mean by &gt;"seems a bit outdated"
To answer my own question. the first question can be solved with `.apply`. so that one is not an issue anymore
1. I'm using `apply{ ... }` for this all the time: Example: val limeDye = NBTItemExt(Dye(DyeColor.LIME).toItemStack(1)).apply { setBoolean(NBTIdentifier.PREFIX, true) setInteger(NBTIdentifier.TYPE, GMCType.HIDE_PLAYERS.ordinal) setInteger(NBTIdentifier.HIDE_STATE, VisibilityStates.ALL.ordinal) if (hideState == VisibilityStates.ALL) addEnchantment(Enchantment.LUCK) addItemFlags(ItemFlag.HIDE_ENCHANTS) displayName = I18n.getString("visibility.all", player.spigot().locale) } 2. Put all `is ...` statements on their own line, they need to be separated. Feel free to use blocks (`{ ... }`) 3. I haven't looked too much into coroutines, but I suspect you could use `suspend` functions. Keep in mind that those can only be called inside `async` blocks (or other blocks that allow suspend functions to be called)
Question 3: You can use the following library, be aware that it is still experimental https://github.com/Kotlin/kotlinx.coroutines In Kotlin, suspend functions and other language primitives for coroutines are only to low level, higher level constructs (like async and await, yield) are implemented by libraries. More about the design and philosophy of Kotlin coroutines can be found here https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md
You can visit the text tutorial at https://stonesoupprogramming.com/2017/07/08/kotlin-stream-image-from-database/
For 2) assign it to a temp `val` for now. Some possible improvements are being discussed.
I would not provide both a vararg and an Iterable version of that function in the API, but just one of them, preferably the vararg one. Otherwise it overburdens the API, especially if you have many such functions. Kotlin already has the spread (\*) operator exactly for that use case: sum(*listOf(1, 2, 3)).
&gt; Kotlin already has the spread (*) operator exactly for that use case That's _true_, but it only applies to `Array`s (and their primitive counterparts), which can definitely make APIs more burdensome. Your example of supplying a literal collection is still straightforward, though: sum(*intArrayOf(1, 2, 3)) - However, a more common situation might be that you already have a `List&lt;Int&gt;` or something like that. In this situation, you end up with a more awkward call site: val values = listOf(1, 2, 3) sum(*values.toIntArray()) There's additional weirdness with having to spread an `IntArray` instead of an `Array&lt;Int&gt;` as well, so for this case we need to use `toIntArray` rather than `toTypedArray&lt;Int&gt;`. My preference would be to create both overloads for the function. Not only does it make the call sites cleaner in both cases, but also avoids the performance penalty of converting iterables/collections to arrays, which could be severe in the case of large collections, and the other/additional penalty of copying the array when using the spread operator.
I didn't know you can spread a list. Is it implemented for all iterables?
I see a few problems with `*spread`: 1. Creates intermediate array. This means you'll have a performance surprise if you have a lot of arguments or you spread inside a hot loop. 2. Users usually have a list, not an array, at the callsite since we tend to default to lists in Kotlin. 3. Since you can only spread an array, it leaks too much impl detail to the user now that they have to use `arrayOf()` instead of `listOf()` (or transform the collection they *already have*) just so they can spread it into your library function. I'm not saying every vararg/iterable API function needs a vararg/iterable counterpart. There are just cases where you know the user can reasonably need either form (like mounting individual middlewares vs programmatically building a list of middlewares) and the overload really improves UX.
Don't use thread sleep... It wastes CPU cycles. There are built in functions for this kind of thing.
There's a built in function in `kotlin.concurrent` called `timer`, that lets you schedule a function to repeat itself with a given `period`. Use that.
I was gonna say it's always poor practice to use `sleep` in any language.
I came across this... ``` fun kotlinTimer() { timer.scheduleAtFixedRate(0, 1800000) { checkForUpdates() } } ``` This looks like it does the same thing as `scheduledExecutor.scheduleAtFixedRate`. Does it do thread management for you?
Using ScheduledExecutor in kotlin is fine. Kotlin tries to be 100% java compatible to be able to use the full java ecosystem. The question is: what error do you get?
You can always look at the source.
The scheduled executor will stop executing your job if it throws an Exception. Could this be what's happening? If an Exception is possible, you should wrap the Runnable code in a try/catch.
Potentially, its unpredictable so next time it happens I'll see what the error was. I'll wrap it in a try catch just to be safe. 
Also youtube video: https://www.youtube.com/edit?o=U&amp;video_id=bUzhbor0U5g
I'll even update this as I don't know where that function "urlEncodeUTF8 ()" came from, so here is a better example that would actually work and having fun with an extension function. fun String.utf8(): String = java.net.URLEncoder.encode(this, "UTF-8") parameters.map {(k, v) -&gt; "${k.utf8()}=${v.utf8()}"}.joinToString("&amp;") 
&gt; Creates intermediate array. [Which actually can have a pretty high performance penalty](https://sites.google.com/a/athaydes.com/renato-athaydes/posts/kotlinshiddencosts-benchmarks). 
&gt; C++ is famous for allowing multiple inheritance Whenever I read "multiple inheritance" without any further qualification, I can't help but think that the author of the article doesn't really understand the problem. C++ allows multiple inheritance of implementation. Java allows multiple inheritance of interfaces. 
My bad. I got the impression that it is outdated from a google hit which was like 4 years old. I ended up using jsoup for this project!
Thanks! I chose jsoup for now since I don't want to deal with js but I don't want to consume too much bandwidth.
I chose Jsoup. Jaunt won't work since it is not open source and I can't add it as a dependency to my project. I don't want to mess with proprietary code.
You lost the generics off the JpaRepository.
If you are in an EE environment, @Schedule is a very easy way to do this. Also it doesn't just die on you.
You should fix your license issues, assuming you reused parts of Lanterna. Lanterna is LGPL and you just can't switch that to MIT license, especially not without retaining the original copyright notices and so on. Apart from that I can't say much. I mainly use and like Lanterna because it can print colored text and stuff to real xterm-compatible or windows terminals. Not because I want to make an ascii game. Code looks fine, though.
Since I copied no code from Lanterna (it is a java project), and I do not link to it this is not a derivative work so I can use MIT. I asked for a written permission though and they didn't say no.
Then that's fine. I assumed you copied some code because the classes at least look similar and you wrote you "ported" some part which could have been also understood as copy&amp;paste and convert to kotlin.
Isn't Kotlin's solution identical to Java's since Java 8 allows default methods?
I did not copy and paste the code but I used the Lanterna codebase as a basis. I wrote every line of code by hand.
If you replace the version number with a plus, then Gradle will download the latest version of the library. Otherwise, you have to update the Kotlin dependency everytime you update the plug-in.
I doubled checked the code and I'm not sure what you mean. interface EmployeeRepository : JpaRepository&lt;Employee, Long&gt; I passed my type arguments &lt;Employee, Long&gt; into the interface. Can you expand further on what you mean?
Traits are not interfaces. Show multiple inheritance w/ the base types holding state please. Otherwise, I don't think using the phrase "multiple inheritance" is accurate here as opposed to just implementing multiple interfaces.
I'm not a lawyer, but my understanding is that directly looking at the source code for thing X and using it to guide your implementation and/or architecture, without actually copying the code and then editing it, is still a derived work. The GNU website has a specific FAQ section about [translating a code base to a different language](https://www.gnu.org/licenses/gpl-faq.html#TranslateCode). &gt; What does the GPL say about translating some code to a different programming language? &gt; Under copyright law, translation of a work is considered a kind of modification. Therefore, what the GPL says about modified versions applies also to translated versions. Based on how you described the work you did, it does seem like you are not allowed to re-license the code to MIT license.
I see. Then I'll have to wait for his response on the GitHub Issue I created. This is not just translating though. This is a rewrite.
Look at the code example in your blog post. EmployeeRepository should implement JpaRepository&lt;Employee, Long&gt; but it implements JpaRepository, probably because you didn't HTML escape the lt and gt.
How does this compare to JediTerm?
I don't know it flew under my radar. I guess it has different goals than this lib (I do not support real terminals).
Oh! Thanks! I'm going to take care of that!
Nice writeup, thanks for sharing! The timing was perfect for me - I was struggling to understand how this worked earlier today, but this helped clear things up a bit for me. 
I don't feel like migrating an application for someone else will add any value. If nobody in the company knows Kotlin, you're doing them a disservice. If you've trained then, but they're not receptive or Kotlin has a higher learning curve for their team for some reason, they'll be stuck with an application they can't maintain or migrate back. In the US, that's something that could get you sued.
My idea is that most successful companies are very busy and developers are a bottleneck: there are not enough to work on all the interesting idea the company has. So instead of spending their own time on the migration they could delegate it. They could then benefit from Kotlin in terms of faster development, but without the time investment for the conversion. This is just an idea and I should consider very carefully your point in proposing this service. Thanks!
It helps when you include a GitHub repo link to your test case. It's kind of pointless to waste our time on twenty questions, when there's no earthly reason to.
Can't really share the source code, because it's for work, but I can create a minimal example app to reproduce the problem. I was really just hoping it was a solved problem, and somebody had an example using manytomany, but I guess it's a long shot, seeing how new spring boot kotlin integration is
60% of the time you'll figure it out yourself while creating your minimal example.
didn't happen this time, anyway if you want to check it out: [example app](https://github.com/NiklasRenner/kotlin-spring-error)
Asking as an outsider that doesn't know Kotlin (yet?): Is Kotlin really significantly more productive (by whatever metric) than Java? Also, who knows Kotlin will stick around? As far as I can tell, one of the primary motivations of JetBrains to design it, was to push their IDE. What happens if they decide to drop their efforts on improving it one day?
It is true: 3 years from now this market could not exist. But for me to be profitable I would basically need a few clients per year among those who want to adopt Kotlin. So even if 99% want to stick to Java is fine for me. I need to figure out if and how I can find 10 companies every year that would pay me for helping moving to Kotlin and how complicate would be to find them
How about you add a `hashCode` implementation which doesn't make calls between the two objects recursively forever? override fun hashCode(): Int = (id * 6).toInt() 
&gt; I need to figure out if and how I can find 10 companies every year that would pay me for helping moving to Kotlin Good luck!
Thanks!
So simple, I'm an idiot, should have known when the loop was happening in a hashmap, thank you so much!
We've all been there.
It would be better to provide `Sequence` instead of `Iterator`, so that all stdlib functions would work: ``` Schedule.parse("every monday 09:00").sequenceFrom(now).filter { !it.isFriday() }.map { it.toString() }.take(10) ``` 
&gt; Sequence I tried to stay away from any Kotlin-specific types in public API + kotlin.collections.Sequences.kt contains `fun &lt;T&gt; Iterator&lt;T&gt;.asSequence(): Sequence&lt;T&gt;` extension function so having Iterator&lt;T&gt; isn't all that bad - `Schedule.parse("every monday 09:00").iterate(ZonedDateTime.now()).asSequence().filter { ... }`
I haven't looked at the code yet, but is this just an API that acts as a wrapper around `ScheduledExecutorService`'s `scheduleAtFixedRate` by calculating what `initialDelay`, `period`, and `unit` should be?
I think Kodein is the way to go... I'm not a fluent kotlin developer but I heard a lot about that library : https://github.com/SalomonBrys/Kodein
Spring Boot runs in kotlin with no problem - everything is done with Constructor Injection, which seems to work fine according to documentation. https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin No practical experience myself, just started looking at Kotlin. 
Yes, I have looked at Kodein. Lots to learn. I suppose I'm just used to annotation-driven injection running on a JEE container.
Keep in mind that Dagger 2's widespread adoption by the Android community is largely because it doesn't use reflection. The Android specific stuff is also a separate dependency, 'com.google.dagger:dagger-android:2.x', which is a recent addition anyway. So you shouldn't have any problems getting Dagger 2 working in a standard JVM project using Kotlin. 
I felt the same way at first, but I've warmed up to Kodein a lot. It took me a while to get over not doing DI-via-IoC *a la* Spring, but I adjusted after building some real services with it. Kodein is incredibly simple to use, and there's very little cognative overhead needed to understand what's going on, which was a big plus since only myself and one other dev on my team have experience with JEE, Spring, and IoC in general. I'm happy with it, overall.
Here is how I did it in a small HTTP utility class I have: private fun pairsToUrlQueryString(pairs: HashMap&lt;String, String&gt;): String { return pairs.entries .map { "${it.key}=${URLEncoder.encode(it.value, "UTF-8")}" } .joinToString("&amp;") }
 There is a video where Gregory Kick says they had a (iirc) 13% improvement when the switched some services to dagger2. Which at the scale that almost any Google service would be is probably a huge bit if money saved on just a power bill. Kotlin works fine with dagger2 and you will want to do primarily constructor injection so you can have things as vals and avoid the lateinit vars. Dagger2 was successful on Android because most reflection based solutions cause the consuming app to suffer poor performance during startup in the form of start up delay. With dagger2 the work of resolving dependencies and validation is moved to compile time. No more unresolved dependency crashes at runtime is great for productivity especially for long build chains like Android has. So yea the Android crowd ate it up but the gains made apply to any project really. There are other wins like a static call stack of actual code so when a problem does occur you can walk through the code to learn why. Also it is about as fast as anything could be at runtime and probably places nicer with the jit compared to reflection based options.
Right. I've been using Dagger 2 with Kotlin (albeit in Android) since shortly after the 1.0 release. I had to refactor a couple of aspects of the previous Java code (as you said, constructor injection vs field injection), but nothing overtly time consuming in the end. Jake Wharton said it best at the end of one of his Kotlin Presentations (I can't remember which one), "Dagger 2 on Kotlin, it just works".
I mean, if you're building a full stack web application, are you using Spring? I'd stick with just using spring. What's key is probably a couple of compiler plugins that make spring integration a little easier. See: https://kotlinlang.org/docs/reference/compiler-plugins.html * `kotlin-spring` which makes it less onerous to "force open" components, etc * `kotlin-noarg` may be needed for generating default constructors for entities or data classes you use with frameworks that need a no-arg default. If you're not using Spring, then looking at something like Kodein, or even something small like Kapsule makes sense: https://blog.gouline.net/kapsule-minimalist-dependency-injection-for-kotlin-ed3e344d60ed But these depend on overall size. If you're pulling in Spring, you've got a lot coming in, so ... I'd probably just stick with it.
Very nice!
Just to help you avoid a future bug, you forgot to encode the key. Also, I would suggest you reduce your type from **HashMap** to **Map** as now your function will only work with a specific type of Map. If it's a utility class, why is the function private as nothing else would be able to invoke it? Destructuring in maps is also supported, so no need to dig into the "entries" . If you want to save a couple more keystrokes, you can omit the return type as it's inferred (but that can be a bit harder to read) and just use the expression and not a block of {} for the function body. Oh, and I'm totally being a pedant. :-) fun pairsToUrlQueryString(pairs: Map&lt;String, String&gt;) = pairs.map {(k,v) -&gt; "${URLEncoder.encode(k, "UTF-8")}=${URLEncoder.encode(v, "UTF-8")}" } .joinToString("&amp;") Oh, and even more fun... You could also write that as an extension function on the type of Map&lt;String, String&gt;: fun Map&lt;String, String&gt;.toUrlQueryString() = this.map {(k,v) -&gt; "${URLEncoder.encode(k, "UTF-8")}=${URLEncoder.encode(v, "UTF-8")}" } .joinToString("&amp;") Then you can simply invoke: someMap.toUrlQueryString() //Sorry for all the edits, writing code in the comment window isn't fun.
&gt; Just to help you avoid a future bug, you forgot to encode the key. I personally have never written an API that has key names containing a character that needs to be URL encoded. If I ever run across an API that does I would add encoding of the key, although I have yet to run across an API that would need encoded keys (why would someone do this?) &gt; Also, I would suggest you reduce your type from HashMap to Map as now your function will only work with a specific type of Map. Indeed, no idea why I made that accept a HashMap instead of Map. &gt; If it's a utility class, why is the function private as nothing else would be able to invoke it? The utility class is immutable, query pairs and HTTP header pairs are passed in the constructor (they have default values of empty Maps). This function isn't needed outside the class. &gt; Destructuring in maps is also supported, so no need to dig into the "entries" Lambas are already a little too magical for me (in both Java and Kotlin), taking baby steps wrapping my head around a functional style. My current version is a good mix of jumping into lambdas and readability (I find them very difficult to read). I am sure I will get more used to them as I use them, but this is where I am now :-) Thanks for the tip about not needing entries though! Is there any difference in explicitly passing (k,v) parameters rather than just depending on the implicit "it"? (destructuring is a little too magical for me at this point too)
Thank you!
It's not (for example, `Schedule.parse("1st monday of april-june,october-december 12:00")` cannot be expressed with &lt;initialDelay,period,unit&gt;). What it allows you to do is to calculate the time until the next event given schedule &amp; starting point (among other things) (for example, calling [next() on aforementionedSchedule.iterate("2017-07-12T12:00:00Z")](https://github.com/shyiko/skedule/blob/master/src/main/java/com/github/shyiko/skedule/Schedule.java#L29) twice would give "2017-10-01T12:00:00Z", "2017-11-06T12:00:00Z"). You can then use whatever scheduling mechanism you want (ScheduledExecutorService (binary heap), hierarchical hashed wheel timers, etc) (combine it with some retry/backoff logic and you got yourself a poor man's quartz :)).
I second this. Was warming up for some time, a bit afraid that I still don't get lots of stuff. But after I actually started, it was not as complex as I was thinking. Kodein concepts are simple. Library is also **very** well documented. That is what I absolutely love about it. Currently I'm in process of porting a rather large and complex android app from Dagger2 (used in production) to Kodein. We'll see how it'll behave on the battlefield, but for now I like how it goes!
:-) I mentioned I was being totally pedantic. Oh, and as for iterating on a map... you can still go ahead and not destructure the entries, and use the "it" variable. I can't say they are the same because they do have different values as you don't get Map.Entry instances as values when destructuring. But, that object is pretty much a useless value IMHO. I prefer the destructuring option as it makes the function a bit more forward compatible to newer key/value data structures as the Map.Entry is a Java implementation artifact. I wish they were just Pair instances in the iterator as that is a type that can be used all over as it's very generic and can be destructured any other place it's used. Not to mention you set Pair instances within a map ("to" is just an infix function which returns a Pair) but get Entry instances when iterating. A bit of a parity issue, IMHO. But, the overhead of conversion to Pair on iteration would be useless overhead and that would be a bad thing. Sorry, for the terse message... typing this on my phone (painful).
I somewhat appreciate the idea here, but if this is gonna go 3 posts a day through all the koans, then it's basically just spam. Perhaps group these together into larger articles or post them in larger batches?
I'm hoping to avoid Spring entirely. As you say, if you use part of Spring, you might as well use the whole thing. This is a personal learning project and I'm trying to use alternatives to Spring, Hibernate, etc, to help me better understand these tools and why they are used.
Why are you on CM13? Sorry I was curious but I have a serious question: why the nested cards? They don't look bad but Im curious
Wasn't the purpose of this particular Koan named arguments, not default arguments? 
Good catch, this isn't even the "right" solution.
Yeah, if you're not using spring, you basically have a couple of choices for DI, something full featured, like Kodein, or basically simple and delegate based. It sure seems Kodein is probably the most used approach for "pure Kotlin" apps. But, I linked the Kapsule blog for a different way of looking at DI using delegates. I'd also just say that the JetBrains GitHub repositories are a fantastic source of components: https://github.com/JetBrains, you know, for other component ideas.
I'm using sultan ROM on an OPO, which works very smoothly and don't feel the need to upgrade. I used a nested card view so I could reuse a recycler view adapter (which didn't look good while not in a card). 
Oh ok. Downloaded your app and it's actually way better than I thought it would be. Nice job
Currently there is the Multi-OS Engine plugin for Android Studio for cross platform Android/iOS. You can use Java or Kotlin.
I ~~hate~~ don't like all the "Beginner tutorial for Kotlin" posts in this sub because the official Kotlin Koans are perfect to get started but this guide can be actually really helpful for a beginner. üëç
Nice work, even though the stacked cards look a bit odd. A few things: How can I change the currency in "Personalized"? I didn't find Euro in the "All Currencies" list. When I open the preference tab I can't quit the app by pressing back. btw: It's nice that you add the ad toggle in "Preferences".
Thanks for the useful feedback! The currency can be changed using the floating button. Rates are based of the euro itself; so I'll have to get a work around to add the euro. Exiting the app using the back button doesn't appear to work if preferences has been tapped - I'll fix that in coming versions. 
I wonder if the author actually read the books, because I have #3 and it's not worth the money
Agreed, it's a helpful basic rundown of core concepts but it's pretty overpriced for what it is.
Agreed. I actually returned mine. It was full of obvious errors, such that I had to fix nearly every example provided. I returned it after chapter 3. Completely unusable. Kotlin-in-action on the other hand, FANTASTIC! highly recommended it! 
Is this app written in Kotlin?
on the comiing update it will be written in kotlin and made open source
It gets even better: it's also available in IntelliJ. `Tools &gt; Kotlin &gt; Kotlin REPL`.
I don't know if it's just my configuration but I found the intellij one to be a bit clunky. Requiring the use to hit the play button rather than pressing enter to execute a statement.
It probably works with command(or control)+enter
And a JIT script mode? Neat!
Yes it does.
Kotlin in Action is the only one you need. 
Looks really great. I hope that the kotlin will soon be used by corporations. 
Prefixing interfaces with I looks more like C#.
Proto.Actor is an opensource, cross platform actor framework available for C#, Go, and now Kotlin too. The Kotlin implementation is based on Kotlin coroutines and it is extremely fast both over network and inprocess. for benchmarks see: proto.actor/docs/performance If anyone is interested in this space feel free to join in on the effort.
Sorry for that, I've updated the readme to reflect the latest code
Nice. I've been looking for something like this. Was actually in the middle of writing a small background processing library in Kotlin, similar to Rails SideKiq. I'll definitely take a look at this. 
Eh...what?
Same here, I never found any easy to use MySQL/PostgreSQL ORMs for Java/Kotlin, the lack of easy to use ORMs is the reason I'm using MongoDB + Morphia, since you just need to annotate your classes with ~2 annotations and that's it but I wanted to give PostgreSQL a try, so I wanted to use some fancy Java/Kotlin tools to make development easier.
I'd say here: https://youtrack.jetbrains.com/issues/KT but i'm not sure
Appearently that guy created a _superior_ programming language and is jealous of Kotlin for actually having a userbase. He's angry that Google and Microsoft won't answer his emails. Now he is just sulking because nobody wants/needs/knows his language
ctx.Message seems like artifacts from Go. Properties should be named using lower camel case. Bit nitpicky, but hey, feedback!
From my limited experience (quick experiment building a dropwizard+hibernate webapp in Kotlin), JPA-annotated data classes and the entity manager seem to work as expected once you apply the [kotlin-jpa compiler plugin](https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-jpa-compiler-plugin).
Here the discussion of other available actor frameworks for jvm: https://www.reddit.com/r/programming/comments/31112u/bioware_opensources_their_java_actor_framework/ 
If you want people to use it you need to get it into Maven Central. I like what I see, but without being Mavenized I'll never touch it.
Try jooq instead. Its not an ORM (it generates a DSL based on your db scheme), but it's absolutely a blast to work with. Also, has some nice kotlin extensions (and kotlin solves some minor gripes I have with it).
This looks great! I've been using Quasar from Parallel Universe for a while and am really happy with it but will check this out.
In the meantime, anyone wanting to try can use https://jitpack.io/#AsynkronIT/protoactor-kotlin
The color scheme makes it hard to read for me, especially symbols like : &lt; and &gt;
&gt;Jake is an Android engineer at Square not anymore!
That's the correct place ;) I have used it to report a bug
Just extract the DTOs in a library module and add the dependency on this library from the two other parts of the app.
If I understand you correctly, I tried that with no success. The same problem exists in the library, is it a Java library or a JS library, I can't pick both.
Have to wait for "multiplatform" support...it's coming
Ooh does that mean I get native DTOs too!? That will be +1 nifty. 
Yeah I'm using the symlink approach as well. Its seems like jetbrains plan to address this at some point. Personally I'm just going to stick with the symlinks until a real solution is available. https://discuss.kotlinlang.org/t/best-practice-for-multi-target-project/2287 
Ty for the link. Yeah I don't need or want ifdef either, just multiple targets.
Can't you just have the DTO a separate module that both depends on?
I's suggest dumping Hibernate altogether and using something simpler (like [Squash](https://github.com/orangy/squash)).
I copy the shared Kt files into each module build folder in a pre assemble step and then added that as a source set. I don't recommend it, it leads to two editable copies of the shared code and any usage references open to the build source set rather than the original source. I am looking for a better method, I'll have to try the symlink next. 
That's definitely a sensible design solution when keeping the client and the server in different modules for separation-of-concerns reasons. In my case, I'm not separating them for logical reasons, it's entirely out of necessity, as one is bytecode that runs on a JVM, and the other is JavaScript that runs in the browser. The "separate module" would need to be either be JavaScript or JVM, it cannot be both, at least as far as Intellij is concerned. As other replies have mentioned, this is apparently a future awesomeness on its way.
Does this even work? Iirc Hibernate requires entities to be `open` (non-final) to work its bytecode magic which is not possible with `data` classes. Unless you need the equals/hashCode I would simply leave them out leaving it an `open class`. You are right to exclude some fields as besides performance problems you may also end up with recursion if those `Ware` and `BrandImage` entities also contain equals/hashCode.
desc.replace(‚ÄùSquare‚Äù, ‚ÄùGoogle‚Äù)
There is a compiler [plugin](https://kotlinlang.org/docs/reference/compiler-plugins.html) to add open classes automatically.
Yeah the lazy loading and recursion are the main reasons why I don't want those in my equals/hashCode/toString. Thanks for your input!
Squash looks similar to JetBrain's own Exposed DSL. Are they related?
I'm not sure, probably yes.
Squash is written by Ilya Ryzhenkov of JetBrains, who has 10 commits on Exposed DSL, so they are connected, but not necessarily related. One is definitely not based on the other, but like minds tend to think alike, especially when sharing offices ;)
The fact that GreenDAO doesn't support Kotlin (hopefully it will someday) doesn't prohibit you from using it in Kotlin projects, I have my whole app written in Kotlin and just the DB-annotated classes in Java and it works fine with GreenDAO.
Good non-technical article for people not overly familiar with the language, though I dislike the use of the word 'upstart'. That implies arrogance on the part of JetBrains to getting Kotlin out there, which couldn't be further from the truth.
Interesting. But would it work with Spring?
Why wouldn't it? I actually use Spring (Boot) with a hand-written orm which wraps the plain mongodb client. Spring is not tied to JPA (or Hibernate).
Kotlin is great and i love it but I still don't understand all the excitement about using it for Android, I mean sure it is better than java but surely there are many multiplatform development solutions out there so you don't have to use java objective c android or swift. What am I missing here? I mean most developers would want to target android and ios?
Those experiences are measurably worse than Java, let alone Kotlin which is superior to Java.
The short answer is that Kotlin gives us what the current version of Java in Android cannot. Jake Wharton [gave a talk](https://youtu.be/A2LukgT2mKc) just before Kotlin v1.0 was released that summed it up about a minute in. Though Google is working to incorporate stuff from Java 8 into Android, lambdas being one, the truth of the matter is that Android developers will never be able to use the latest and greatest version of Java in their development. The Android SDK just won't let you. Java 9 is around the corner as well, and there's probably a lot of useful stuff in there we'd never get to play with until years down the road. I think Google's adoption of Kotlin as a first-class language was both an acknowledgement of that limitation (and maybe a subtle middle finger to Oracle), and of the extremely fast widespread adoption of the language within the community. It allows for Android development to exist in the here and now, with no fear that this is just a passing fad. Besides, for multi-platform solutions you're most likely not coding in Java in the first place, which means Kotlin isn't even an option. I'm unfamiliar with almost everything except Xamarin in that regards so take that comment with a grain of salt. For Android-only development though, you can't get much better than Kotlin at the moment.
Just started looking at this. Looks like a concise/easy to navigate quick reference/primer which is perfect for those needing to look up something quickly.
I use this same approach for hierarchically creating 'by map' representations of JSON/Map objects.
Kotlin targets: * JVM * JS * Native(including webassembly) (still early access preview) https://github.com/JetBrains/kotlin-native/ 
agreed.. upstart was a poor word choice
before kotlin, java was really the only language you could use if you wanted to fully take advantage of all the sdk/libs available to android. I think c# support is fairly decent now but i havent personally used it and i dont think you have the ability to use the support libs nor the vast amount of android java libraries out there (i could be wrong about that) c/c++ support is there but unless you are writing a game, there is no reason to torture yourself by doing an entire app in c/c++. The majority of the apis you would have to access through JNI since there isnt a c equivalent kotlin gives you access to everything that java has access to, but is a much nicer language
I use Kotlin on the backend and on the frontend as well! Definitely not just for Android!
I am really interested to see memory load and type of memory model this will put up for interop. How will it work with existing JVM libraries specially stuff like JavaFX and NIO? Just doing that opens up the possibility of IDEA guys moving their entire IDE ecosystem to native machine code and with right memory/cpu optimizations it can beat any IDE's ass. The most important thing for me will be the co-routine library and how efficient web servers I can make out of it. I have a web service with coroutines today that takes around 121MB - 630ish MB. I rewrote the same thing in golang and it runs under 16MB. So until that is not fixed I am still waiting for a better syntax language with something close to even go let alone the native languages like C++/C. 
How would you access JVM stuff when you're not running on the JVM? Pretty sure that won't be supported. 
I am really not a performance expert, however I am also very interested in seeing if they get good ideas about JVM interoperability. JNI will be the solution?
You could maybe use JNI and access Kotlin/native code from the JVM, but not the other way around
You can actually implement the `getValue` and `setValue` operators directly as extension functions without wrapping the property in another object: operator fun &lt;R&gt; KProperty0&lt;R&gt;.getValue(instance: Nothing?, metadata: KProperty&lt;*&gt;): R { return get() } operator fun &lt;R&gt; KMutableProperty0&lt;R&gt;.setValue(instance: Nothing?, metadata: KProperty&lt;*&gt;, value: R) { set(value) } operator fun &lt;T, R&gt; KProperty1&lt;T, R&gt;.getValue(instance: T, metadata: KProperty&lt;*&gt;): R { return get(instance) } operator fun &lt;T, R&gt; KMutableProperty1&lt;T, R&gt;.setValue(instance: T, metadata: KProperty&lt;*&gt;, value: R) { set(instance, value) } It's definitely a common use case and there is an [open ticket in the issue tracker](https://youtrack.jetbrains.com/issue/KT-8658) to include this in the standard library (vote on it!).
&gt; That said it is possible to build something today, with the Kotlin native compiler as it is but there is a big roadblock: the editor support. Can you elaborate on this? Isn't that what Kotlin is supposed to shine in, first-hand IDE support with IntelliJ?
Ah! This is the kind of thing I was hoping to see :D awesome
IDE Support for Kotlin is great when you are using the java or the javascript target. However the native target is still experimental and the IDE support is not great. While the language is the same what changes are the functions available in the standard library and the libraries you can use (you cannot use JAR libraries when compiling to native, but you can use native libraries) and those things are not well supported yet so autocompletion does not work perfectly, the editor shows you errors because it is not resolving the symbols correctly, etc. However the compiler works fine, so those errors that you see in the editor are just confusing
Some JVM stuff could be. They limited many parts of the language and stdlib because JVM was its primary target, no reason that Java SDK cannot be in part re-implemented in Kotlin. Scala native ships w/ its own JVM stdlib which [includes nio](https://github.com/scala-native/scala-native/tree/master/javalib/src/main/scala/java/nio) for example.
Thanks, interesting read and experiment. Article said that transpire to JavaScript is mature. Could you please suggest me which tool that used to do this?
I wrote a tutorial on the JavaScript target: https://superkotlin.com/kotlin-javascript/ Let me know if something is not clear
Thank you. I got more info and idea further from reading your article, just finished reading it recently after you replied. Informative. A question: I heard about TeaVM although not tested yet and it can compile kotlin to js that gwt cannot do (I‚Äôm in game dev using libgdx). If you know or use TeaVM before: Could we do the same as TeaVM in kotlin-js? Anything that kotlin-js didn‚Äôt support I should be aware of?
I never heard about TeaVM but now I will look into it, thanks
Cool. If you write about it in the future, then I should see it. Subscribed to your site.
Yes, this is right. Multi OS engine also uses this technique with lots of JNI to let Android dev or JVM language to write iOS app, or allow access to iOS API. The way they expose for devs to integrate 3rd party iOS SDKs into their JVM-language app is via JNI too. I haven‚Äôt test kotlin-native yet but yeah those channel of communication is solution.
sweet thank you!
Thank you!
I've worked on Hybrid Apps and Native apps and I can tell you hybrid apps still have a long way to go before they can completely replace native. It's like saying why write in C++ when you can write video games in python. 
I would leave out equals/hashCode, as JPA entities are interned to begin with in the same persistence context. Meaning the same object is going to be the same reference. And if they're not (and thus not in the same persistence context) you need to ask yourself wtf you're doing.
The developper of TeaVM is one off the core member of kotlin-js team. He is currently developing some cool tools for kotlin-js.
Thank you, good to know.
I don't like trio of apply, also and with functions they are too similar so it feels like they're redundant and it's hard to remember differences between them. Personally I'm only using apply function
There's a pretty big difference between "apply" &amp; "also" since "apply" returns "this". I think they all have a place when trying to express nuances. However, they are not necessary and just tools in a toolbox. 
I could increase the speed with [Video Speed Controller Chrome extension] (https://chrome.google.com/webstore/detail/video-speed-controller/nffaoalbilbmmfgbnbgppjihopabppdk)
I don't know why you get downvoted.. This is just awesome, so thanks for making this, i'm installing it :) good job, you even added darcula theme for code syntax :D 
I bought #3 (Kotlin for Android developers) and it helped me a lot to get started with Kotlin on Android in addition to the koans I did before. You maybe got an early version of the book? I know the author often publishes updates and he also provides a GitHub project which is the project we make during the book. Going to buy Kotlin in Action now, I've only heard good things about it :)
Start here: http://sparkjava.com/ The tutorial has pretty much everything you need, including building an API and deploying to Heroku.
What do you think about Ktor?
I ordered it like a month ago on amazon, which I assume to be somewhat recent. The problem is that it's blogpost content for almost 50 bucks, that's way too much. For me, advent of code helped me most with understanding kotlin, but this book? Might be okay for beginners
"also" also returns this
Super popular? http://start.spring.io/ is by far the most used backend framework in JVM-land, and has good support for Kotlin. Here's a full example: https://github.com/mikaelhg/kotlin-spring-boot-data-rest Edit: and here's a multimodule frontend / backend example: https://github.com/mikaelhg/modern-mainstream-web-example
Thanks for your feedback and support! :)
It looks interesting for simple backend or microservices, like SparkJava.
Wow, their tutorials and documentation is one of the greatest I've ever seen
That is correct. My bad. So the difference is more semantical than technical. Which all languages generally have. A for-loop and a while loop are essentially the same for instance.
I really recommend vertx.io. we're using it in production for microservices and we're very happy with it.
The only gripe I have with Spark is that it doesn't send the file size to the browser when downloading static files. (So the file is "Unknown time remaining" when downloading it and Minecraft hates downloading files like that) Seems a very silly issue, but I needed that for my use case. :/ So I migrated to [Jooby](http://jooby.org/), it is very similar to Sparkjava (I migrated an entire website to Jooby in less than an hour) and it has a bunch of extensions for APIs, it even has a [Kotlin extension](https://github.com/jooby-project/jooby/tree/master/modules/jooby-lang-kotlin)! Anyway, both are very awesome projects, very easy to pickup and use, after I learned about Sparkjava/Jooby I just dropped every PHP project I had (I never liked PHP and my code was always a mess) and migrated everything to Java (and soon(tm) Kotlin), best decision I ever had! :)
[Spring security](http://projects.spring.io/spring-security/)
You're using Kotlin Map interface, which indeed doesn't have a remove function (it's in MutableMap). But, the interface in the compiled bytecode will still be a Java Map, which does have a remove method (using Object as key, the one mentioned in the stacktrace). The generated Java remove method is marked as final and is bridged to your own remove method after a type check. For some reason though it is added to your subclasses as well, even if it's identical and doesn't really override anything. This causes the error. I think the Kotlin compiler gets confused because of the mutable methods in a class that implements an immutable interface. You should refactor AbstractTreeProperties to implement MutableMap instead, which is what you probably wanted to do since you have methods that mutate the state. Note that other Collections have mutable counterparts as well, like MutableCollection, MutableSet and MutableMap.MutableEntry. After making the changes to mutable interfaces (and removing some operator overloads which were causing errors after changes, I'll leave fixing those to you) the code builds and runs ok.
How would one go about a simple back-end for a website with an account system? I've used spring before, and while I really like spring boot, I **really** hate spring security. I can never understand it, something always goes wrong, something that should make sense and allow logins *just does not*. I've looked at Apache shiro and that seems to be a big bulky thing that I don't want anything to do with -- so my question is, is there a kotlin web framework that will allow me to circumvent reading 500 pages of documentation prior to making something actually useful, that I can easily integrate with a templating engine and security ? 
While it may not be nearly as elegant as using `copy`, you could make all these data classes implement an interface with an `id` property and a `withId` method replacing `copy`. Something like this: interface Keyed&lt;A: Keyed&lt;A&gt;&gt; { val id: Long fun withId(id: Long): A } Of course, you'd have to implement this `withId` method in each of these data classes by calling their own `copy`.
If I understand your question, you want `updateLastInsertId` to work on many types, all of which are data classes that have an integer `id` (and of course a `copy` method)? There is no `DataClass` base type, and Kotlin doesn't have structural typing which I think is what makes it not completely straightforward. The best way I can think of is to not rely on the data class `copy` method and instead create an interface, something like: interface DBObject { val id: Long? fun withId(id: Long): DBObject } data class Account(override val id: Long) : DBObject { override fun withId(id: Long): Account { return this.copy(id = id) } } fun updateLastInsertId(lastInsertId: Long, dbObjects: List&lt;DBObject&gt;): List&lt;DBObject&gt; { var mutableLastInsertId = lastInsertId return dbObjects .map { dbObject -&gt; if (dbObject.id == null) dbObject.withId(mutableLastInsertId++) else dbObject } } It still requires duplication for each data class you create, but it's minimal. It also allows you to use `updateLastInsertId` on types that are not data classes (as long as they implement the interface). Note that this is not 100% type safe - the `withId` could technically return _any_ `DBObject`. You could probably fix this with some use of generics (something like `fun &lt;T: DBObject&gt; withId(id: Long): T`)
Yeah, wow, this seems so obvious when you say. I think I was just stuck in my head trying to solve it without making another method, but this is totally the right thing to do, thank you!!
Yeah, wow, this seems so obvious when you say. I think I was just stuck in my head trying to solve it without making another method, but this is totally the right thing to do, thank you!!
Thanks for the thorough explanation and solution! 
Like u/toxxmeister posted, the correct way to make this type safe is to use `&lt;T: DBObject&lt;T&gt;&gt;`. I have never actually used this before, so I looked up an explanation: https://stackoverflow.com/a/211161 Updated code using the generic type: interface DBObject&lt;T: DBObject&lt;T&gt;&gt; { val id: Long? fun withId(id: Long): T } data class Account(override val id: Long) : DBObject&lt;Account&gt; { override fun withId(id: Long): Account { return this.copy(id = id) } } private fun &lt;T: DBObject&lt;T&gt;&gt;updateLastInsertId(lastInsertId: Long, dbObjects: List&lt;T&gt;): List&lt;T&gt; { var mutableLastInsertId = lastInsertId return dbObjects .map { dbObject -&gt; if (dbObject.id == null) dbObject.withId(mutableLastInsertId++) else dbObject } }
Thank you for the answers :) I'll give a look at all of the links you suggested, that's gonna be super helpful!
&gt;Destructing operations *Destructuring* operations ...
Shame on me. Thank you
Np, if you're using IntelliJ IDEA or Android Studio you can check the generated byte code via Tools-&gt;Kotlin-&gt;Show Kotlin byte code, and then decompile it to Java code. This might help you understand better how the language works and debug errors like this in the future.
This is great to see. Will have to give it a shot. While a lack of static analysis has not stopped us from using Kotlin (The language is just too great not to use if you're on the JVM), it's great to have. Reading through the GitHub readme, it looks like they've ported over the ktlint rules, so this can replace it while adding more advanced static code analysis.
Part 2 here: https://www.youtube.com/watch?v=iQsN_IDUTSc
&gt; However, it is only run when B is first used (lazily). TIL! Not sure if the best solution, but you could "instantiate" B with a "package-level variable", like this: private val _ignore = B Here's a short sample: https://pastebin.com/77pQibAY
Can you just make your init logic a top level or companion object function and call it manually somewhere early in your program's lifecycle?
The last part of the article is plain wrong. You don't need reflection or casting to modify a List&lt;T&gt;, you can just assign a MutableList to a List and modify the original variable later. A separate ImmutableList implementation like in Guava is just much nicer because you don't need defensive copying. 
[official reference guide](https://kotlinlang.org/docs/reference/) [how to set up a basic Kotlin android project](https://www.raywenderlich.com/132381/kotlin-for-android-an-introduction) [place where you can practice coding specific concepts](https://try.kotlinlang.org/#/Examples/Hello,%20world!/Simplest%20version/Simplest%20version.kt) [Java to Kotlin cheat sheet](https://fabiomsr.github.io/from-java-to-kotlin/) [Swift vs Kotlin](http://angelolloqui.com/blog/38-Swift-vs-Kotlin-for-real-iOS-Android-apps) I found that one of the best ways to learn Kotlin is by coding in an IDE, such as Android Studio or Eclipse (you have to install a plugin for Kotlin). This is because the IDE gives you a lot of hints and suggestions to optimize your code and adhere to best practices beyond the normal error checking. 
That's a private variable, not package-level. You'd want just internal val _ignore = B
init is an instance initialization, it will be called whenever an instance of type A (or B) is created. What you want is something like static in java and that would be companion objects. Though they are also only loaded when the class is first accessed.. 
Well `A` will probably have many subclasses, and I want to avoid calling the init logic for each individual subclass. Do you have some way to avoid that? _edit_: Actually I think this proposal is similar to the workaround I found.
Well, I found a solution for my specific use case. I didn't actually need the singleton to be available to code, I only needed it to be able to be dispatched using `A`. So I just defined another function and used that instead: abstract class A { // ... } fun newA(name: String, fn: /* ... */) { println(name) /* logic using fn */ } newA("B") { /* fn */ } I'm still interested if anyone has a solution to the original problem!
I actually like this solution a lot, although it's a little too magical.
Yeah, it may introduce a lot of headache in the future. The order in which those initialization will run will not be well defined (or easy to understand). I think /u/Herb_Derb has a better approach. For my app, the singletons are initialized at the start of my application. I manually call their initialization before distributing them with my DI framework (Dagger2).
Hey buddy great Post, I found something helpful which I want to share as I was browsing the web for learning some coding algorithms it was very difficult to visit different sites at a time but I found a site named https://hackr.io/ I went here and found that the stuff from best programming sites were all allocated at a single place so I just thought of sharing with you all.... I hope it will help you This might be useful to your readers: https://hackr.io/tutorials/learn-kotlin
I never understood why kotlin claims it has immutable collections. It provides an interface for its collections that do not have methods to mutate it. This is probably a trade off that was made to avoid making an opiniated choice that would drift away from Java, making interop harder / with overhead. In kotlin, this means that a function taking a List&lt;T&gt; implicitly has a contract of not modifying the list. However, the question of mutability remains, and it is not a guarantee that if something has a reference to a List&lt;T&gt;, it can assume the list will never be changed. To me, guava's ImmutableList is a better way to approach such problem from scratch. But you say guava's immutable list does not require making a defensive copy. I'd argue that Guava's ImmutableList FORCES you to make a defensive copy at the place the list is made, in exchange for guaranteeing that the list that a callee receives will never change.
 Kotlin seems to be more progressive and comfortable language for teamwork due to its conciseness and simplicity. You can forget all the doubts and make an optimal choice ‚Äì Kotlin. In this blog, for instant, I found some useful information: https://erminesoft.com/java-vs-kotlin-for-android-development/
&gt; I'd argue that Guava's ImmutableList FORCES you to make a defensive copy at the place the list is made Correct. And as soon as you have a ImmutableList, you don't need to do defensive copies anymore after. In fact, ImmutableList.copyOf(list) will not make a copy if list already is immutable. That's the nice thing about them. As soon as you have a variable of ImmutableList, you're sure that it's really immutable.
I've been trying to build a web MVC framework using various Kotlin technologies and avoiding Spring and Hibernate. I've blogged about my progress here http://www.liamjdavison.co.uk/2017/07/kotlin-web-development-experiments/ 
Good question! Kotlin seems to be more progressive and comfortable language for teamwork due to its conciseness and simplicity. You can forget all the doubts and make an optimal choice ‚Äì Kotlin. In this blog, for instant, I found some useful information: https://erminesoft.com/java-vs-kotlin-for-android-development/
Interesting comments (this whole thread). A 'downside' of the Guava approach is less seamless interop - callers (that are not using ImmutableLists already) have to convert to ImmutableList everywhere they call your code. This could actually be seen as an advantage, as mentioned above, as it means you are guaranteed the caller will not mutate the list later. But I guess Kotlin's designers preferred seamless interop, as that was their top priority... Ultimately, the problem is that the Java Collections API does not distinguish, so any immutability built on top of that is going to have to make some tradeoffs.
Callers don't have to modify code anywhere. ImmutableList implements the standard List interface and thus can be used anywhere you use a normal list (unless you want to mutate it obviously). What you usually should do is have your constructors (and so on) still use regular List parameters, but create a defensive copy with ImmutableList.copyOf() before storing it in a field. If the list is already immutable, this won't create any relevant overhead (because it doesn't actually copy) and else you would have to do the copy anyway to be sure. Edit: you ‚û° your
BTW there is a [proposal](https://github.com/Kotlin/kotlinx.collections.immutable/blob/master/proposal.md) to do a 'proper' implementation of immutable collections, i.e. using persistent data structures. This will have mutating operations, that will return a new collection. It will/should introduce new Immutable interfaces that extend the current 'read-only' List, Map, Set ones, with the aim of guaranteeing an immutable collection is never changed (as well as the advantage of *structural sharing* that persistent collections provide).
Kotlin is an upgrade from Java, and it is explained like that, with equivalents to Java. If you don't know the language but know the concepts from another language you'll be able to understand but if not, it'll be hard.
No, you needn't. Kotlin seems to be more progressive and comfortable language for teamwork due to its conciseness and simplicity. You can forget all the doubts and make an optimal choice ‚Äì Kotlin. In this blog, for instant, I found some useful information: https://erminesoft.com/java-vs-kotlin-for-android-development/
I haven't used Scala.js but so far I am happy with Kotlin's interoperability with Javascript. I've created a wrapper for both Vue and Angular (version 4 now). Also, if you know how Typescript/ESNext decorators work under the covers you can easily use them on your classes in Kotlin. That's what I did with my Angular wrapper. If anyone is interested I'll post my wrapper to my github so you can see how it works with the Angular decorators. I'm sure you could do the same with Scala for Javascript since it all compiles down to JS anyway. It probably comes down to personally preference between the two languages at that point.
I would love to see it in action (sample hello world app).
&gt; If anyone is interested I'll post my wrapper to my github so you can see how it works with the Angular decorators. I'm interested.
Ah yes, I agree with that. I wasn't clear in my previous post - I have seen cases where: * a *Interface* defines parameters of type ImmutableList (presumably to communicate to *implementers* of said Interface to not mutate the list) * methods are declared as returning ImmutableList (presumably to communicate to the caller they must not mutate the List they get back (it would have resulted in RuntimeException anyway, but by declaring it in method signature you are broadcasting that fact) Both of the above permeates ImmutableList throughout your codebase, and ties you in to Guava. But is not a problem of Guava/ImmutableList per se - it is not the recommended way to use it. 
You don't have any static keyword in Kotlin, so you need a unique object to hold your methods. From a modeling point of view this is equivalent. JVM singletons are considered bad because when you want to use one it usually means it has its own state and life cycle. *This* is actually bad. If it doesn't have any of those it has no point in existing because static methods and fields can serve the same purpose (which, again, is not the case in Kotlin).
Right. The documentation for guava is pretty clear here: &gt; For field types and method return types, you should generally use the immutable type (such as ImmutableList) instead of the general collection interface type (such as List). This communicates to your callers all of the semantic guarantees listed above, which is almost always very useful information. &gt; &gt; On the other hand, a parameter type of ImmutableList is generally a nuisance to callers. Instead, accept Iterable and have your method or constructor body pass it to the appropriate copyOf method itself. We can of course discuss if it's useful to have the guava collections as return type. I like them generally because the guava interfaces have a few nice convenience methods and so you can be clear about the mutability of the returned collection. 
&gt; so you need a unique object to hold your methods Except Kotlin has top level functions.
What's your point? I said this in relation to static methods. You can't namespace a top-level function in a package nor can you annotate it with `@JvmStatic`, which was the whole point of using an object in the blog post.
You gotta ask yourself, "why are singletons bad?" They're bad because generally, they're hard to test, encourages tight coupling and hiding of dependencies, and may contain state that can make it hard to know what its functions will actually do or return for a given argument. But if you have a singleton object that doesn't have state, gets all its dependencies as function parameters, and either doesn't require external resources or is an implementation of an interface that can be mocked, then you don't have these issues. Many Kotlin projects that have singletons containing their static, dependency free methods are off the hook. I don't have any numbers but I imagine (hope) most people use singletons as a replacement for static functionality. And of course, for hobby projects, breaking the rules to get something done quicker and simpler isn't too bad as long as the code stays manageable size. Doing things that don't scale isn't that bad if you don't intend to scale.
I'd recommend signing up for [HackerRank](https://www.hackerrank.com). They support Kotlin and a ton of other languages. Aside from being a good place to practice interview-like problems, you can start off with the easy stuff (finding longest substrings, detecting palindromes, etc...), and work up to slightly more complex topics, such as implementing data structures and/or various algorithms. You could do this on your own, but there's an entire community there, with hundreds of well-defined problems already setup, test cases to make sure you've implemented things correctly, etc... I've been using this in my spare time to teach myself Kotlin, since I currently don't have a pet-project to work on.
I would suggest you to go and watch videos from Telusko Learnings on YouTube. He has a playlist for Kotlin. I enjoyed the videos and I think you will too.
Is Kotlin really interesting on top of Javascript? Is there really an added value? I definitely see it for the JVM but I have a hard time seeing the advantage in the JS world.
In the end, it's just synthax-learning. I personally just did the Kotlin koans a bunch of times and Advent of Code afterwards
Aren't package level functions already static methods that can be called from Java, so for them there is no need for @JvmStatic to begin with?
Once again, they are namespaced at the package level (via a generated class). If you need interoperability with Java it is usually not what you want.
I think main differences which you can observe are differences in the languages and differences in tooling (compiler, IDE etc). So: If you like Kotlin or already have code in Kotlin try Kotlin/JS and feel free to join our community in the slack (http://kotl.in/slack) If you like Scala or already have code in Scala try Scala.js Kotlin/JS * has good interoperability with JS (https://kotlinlang.org/docs/reference/js-interop.html) * has excellent support in IDE (because we think about tooling when developing any new feature) * very soon will have the excellent incremental compilation (https://medium.com/keepsafe-engineering/kotlin-vs-java-compilation-speed-e6c174b39b5d)
JetBrains are developing their own Kotlin backend framework. It hasn't hit version 1.0 yet, but it looks really promising. For a "simple" backend project it's definately suited! https://github.com/Kotlin/ktor
Correct. This example in the article was not the way to discuss the usage of singletons, but to give an example, how you can deal with Kotlin `object`s in Java.
It's the syntactic sugar. Same as with the JVM. Delegated properties, infix functions, operator functions, objects and companion objects, etc. Not to mention the standard lib and the type system. You can get a type system with TypeScript but it's not the same thing as Kotlin's. The only real syntactic sugar that was already in JavaScript are lambdas.
If you have a good background in JS React Native seems like the easier approach into mobile. BUT learning languages like Java and Kotlin would probably benefit more from a learning perspective.
transitioning from java -&gt; kotlin will be a lot easier than diving into a new language, with little to no material to learn from. Even if the Kotlin adoption has been rising for something like 2 years, most of the resources you'll find online are Java based. If you really want to learn Android, learn java -&gt; android -&gt; kotlin.
No. I would go Java first, it'll be a lot easier then to work on android and to pick up kotlin
Don't listen to the grumpy java developers in here :) I'd say go for it! It's much more fun coding in Kotlin than it is in Java. I'm saying that with many many many years in Java &amp; Android.
Here it is: https://github.com/gbaldeck/angular-kotlin-starter
Honestly, I would go for it. If you have a basic understanding of looping, conditional logic, and able to understand syntax and idioms. It's a matter of just practicing. It took me a weekend to pick up the language, granted I have a background in Java, Python, Go and among others, I found Kotlin to be very easy to pick up. Using IntelliJ made it even better. The hard part is when you need to use dependencies or picking up libraries, which in of it self is straight forward with Gradle. Resources will most likely be written in Java (guides and tutorial). Protip: Pasting Java code in Kotlin code, IntelliJ will ask if you want to convert it to Kotlin (this works for other languages like, Java -&gt; Scala.) It's not perfect but it will do. Since Google is supporting Kotlin, I can imagine that there will be guide, tutorials and videos out there in a matter of time. You should do it!
Really? I don't see it on the dashboard? I only see, C++/Java/Python/Ruby
Hmm.. Open one of the problems, there's a language drop-down next to the code template. There should be dozens of languages to choose from.
Despite being type-safe, null-safe, and compiled down to JVM bytecode, programming in Kotlin feels a lot more like a high-level dynamic interpreted language than Java. It feels more like Ruby than anything else, but if you are used to Javascript you'll probably find it quite comfortable. Java, by contrast, feels hopelessly outdated, awkward, verbose and just plain painful. If you are used to Javascript then I expect you will feel that Java is fighting you every step of the way. Much of the Android standard library will seem pointlessly complex and difficult to use from the Kotlin perspective simply because it's written to deal with Java's limitations. In many cases you can avoid Java's stuff and use Kotlin's stdlib instead, which is very nice indeed, and very powerful. Once you have a little Kotlin under your belt, check out Anko, which is a Kotlin library that smooths over a whole bunch of the rough edges in the Android framework. Both Java and Kotlin will feel weird at first because the compiler will catch a lot of basic errors at compile time rather than throwing a runtime exception, and you'll have less flexibility mixing different types in the same data structure because of the strong typing, but Kotlin is definitely better than Java in this respect because of type-inference (that is, a lot of the time you don't have to declare the type of a variable because the compiler infers it from context - Java's type inference is much more limited). That said, Kotlin's null-safety rules bite you at first because you don't understand what it's complaining about, or indeed what a null reference exception even *is*, if you are used to Javascript. The biggest downside to Kotlin is that most of the Android examples you'll find online will be for Java, at least for now. In most cases you'll be able to translate in your head once you get a feel for the basic syntax differences, but it might make the learning process more difficult. To summarize: Java is obsolete. It's been obsolete for over a decade, frankly. Don't use it for new projects. Learn it only if you absolutely have to. Kotlin is now fully Google-blessed, it's easy to learn and easier to use than Java, and honestly it's just plain fun!
Kotlin's just a programming language. Learning the Android environment is a much harder task.
Any chance of seeing your Vue-wrapper as well?
You can also learn Kotlin for free with the Kotlin docs, interactively 
Seconded, built a game with HTML and spark and definitely would do again
In my opinion, Kotlin is definitely a better language than Java, the problem is that most of the documentation and examples you'll see relating to Android will be in Java. However, Kotlin and Java are extremely similar under the surface: they use the same libraries(barring some Kotlin wrappers to make APIs nicer), and the same paradigm(class based OOP), so the primary difference is the syntax and some Kotlin concepts (such as emphasis on null safety), but the differences are mostly trivial so you can easily translate between Java and Kotlin(IntelliJ can do Java-&gt;Kotlin automatically) For someone coming from a JS background, your primary difficulty would be getting used to static typing and class based OOP, whether you use Kotlin or Java. To recap, I would recommend the following: Try learning Kotlin and Java side by side, focus on Kotlin but keep mind how each Kotlin feature translates to/from Java. If that's too difficult, focus on Java first, and once you have more experience try out Kotlin.
imo Java is so straightforward that you can skip it. At which point you can ID the mechanical translation of any Javaism you see. I learned Clojure and then Kotlin without writing a line of Java. But then again I also wasn't new to programming in general. Also, all exposure is good exposure as a newer developer. I think starting off the Kotlin is not much different than switching between Java and Kotlin. The hard part is the Android API which both will expose you to. It's a weird myth that experienced devs have that there's some sort of roadmap to learning something. I think most of us dabbled in various concepts unlike in the roadmaps we seem to pitch. 
No.
Android development is terrible. The libraries have enormous amounts of documentation, none of which contains the information that you actually need to use them. Add to that poor design choices that compromise both developer ergonomics and performance, and you have a development environment that's somehow even more verbose than a typical Java environment. Kotlin does cut down on the code you have to slog through writing and reading so I recommend that you use it. The examples are in Java so you should have at least a basic knowledge of it before trying to translate it into Kotlin, but you can pick that up as you go. Android Studio has a handy "Convert Java to Kotlin" function that you can use on Java files.
I think it highly depends on the context. Is OP learning a new language on his spare time, after 9-5? Is he a bachelor with a lot of extra time? Learning the Android api itself will take some time to grok, adding gradle, kotlin, etc will only make some stuff more confusing. For example, first time I tried to run some kotlin code, I couldn't get my head around top level objects and static annotations for the main method. Took me something like an hour to understand what I was supposed to do. Then, Jackson mapping for kotlin, etc. Most likely these stuff will only get on his way first and will become frustrating if he doesn't have the time to deal with. 
Here you go: https://github.com/gbaldeck/vue.kt Quick comment on that. It is more than just a wrapper in that I tried adding additional functionality too, so some things like computed properties were broken by that. But if you strip away the additional stuff I added you'll see how it can be wrapped fairly easily.
Thanks!
&gt; The libraries have enormous amounts of documentation, none of which contains the information that you actually need to use them. Bullshit. Even if that's the case, there's plenty of info from other developers on SO/various blogs.
I cleared it with the author of Lanterna! MIT can stay.
Nice use of multibindings. But you could also create the config classes without dagger, and create and call them manually. You have to be pretty confident in using dagger before this adds readability instead of appearing very, very complex.
You are absolutely right. All of this could have been done without dagger. I used dagger as an example because the concept is pretty simple, so it is easy to understand dagger multibindings and in the same time clean your Application class.
May I annoy you with a question, what's the deal with Dagger? I have such a short attention span and haven't gotten a AHA-moment by what I've read. I've done a few small applications and I'm not sure what I'm missing or might gain.
You must have real liked gamecube as a kid
Video -&gt; https://www.pscp.tv/londroid/1djGXLaelZOGZ
Imo this is an advanced example of what's possible with Dagger. If you want to dive into dagger, you first have to see the advantages of dependency injection, which might not be apparent on small apps. To me Dagger was really confusing at first. Now I (over-)use it a lot. Let it grow on you.
Yeah it's a good example to showcase the idea of multibindings. With this in my head, I'll keep on the lookout for when I would be able to use it in any one of my projects. Thanks for the post
No problem :) feel free to subscribe to my medium channel. I will be posting more articles soon
Source of a finished game?
&gt; gamecube What?
The logo
Do you know of any example about how to integrate metrics (e.g. http://metrics.dropwizard.io/3.2.3/) with Spark?
Dagger2 is a library for dependency injection (DI). It's a great tool for Android since it does not use reflection at all. With DI you don't have to create your dependencies. They are "automagically" created and injected to the places they are needed. With this, object creation is encapsulated in a different layer and by that follow the Single Responsibility Principle (SRP). You can easily swap them with other implementations or mock implementation for tests. If the signature of a dependency changes, you only make changes in that layer. There are more benefits. I suggest that you read some more about DI, watch some videos and give it a try. I had a hard time with Dagger, it seemed unnatural to me. But after a few try-fails I got the hang of it and now I wouldn't even consider making a (medium to large) app without it.
This sounds interesting. Have not looked at it closely yet, but I have been wondering about using kotlin as a replacement for typescript with Angular4. I feel like there would be advantages in having the "same" model objects on the front end ans the back. And possibly some cool advantages for writing your Angular services. You could make your service interfaces available on the client side possibly??? I am full of questions as you can see. I will definitely be taking a closer look.
excellent wording for the "in" and "out" concept. I always tried to map it to java and then got confused. 
Awesome, congrats for getting that up! I've been wondering when I would see this. I'm a long time Java dev but have been using TypeScript with Ionic/Angular and Node for a while now too, and like being able to use the same language on the front and backend. I thought using Kotlin for Angular would be nice if I wanted to use Kotlin on the backend. I was almost enteratining the idea of using Vaadin again so I could do full stack Kotlin.
Not a big fan of abusing unaryPlus the way you have. Feels inconsistent with how the standard library uses unaryPlus and tends a little bit towards too much magic.
Cool as a fun learning project butt in all honesty I think this is a solution to a non existent problem. Kotlin's 'using' is just fine the way it is. resAqcuire().use { res -&gt; ...... } And res is out of scope when it's done. Using too many resources just smells bad. Why have a feature that encourages smelly code? Exception handling is a completely orthogonal issue. No point in creating a new a language construct that just combines two already existing constructs for no good reason. Both use and try-catch are expressions and can be composed naturally.
You're right - and this is feedback I've received from several people. I've gone ahead and switched it out in favor of a normal extension method, `.autoClose()`.
&gt; And res is out of scope when it's done. This is a good point I hadn't considered, I suppose that isn't an issue with Kotlin's `.use()` method. &gt; Using too many resources just smells bad. Why have a feature that encourages smelly code? I think that is a somewhat silly statement considering using many resources is _necessary_, regardless of how it smells. Doing anything with databases (which is my primary example) is the perfect example of this. You have _no choice_ but to use many resources when working with databases without an ORM. And not using an ORM is _not_ code smell. &gt; Exception handling is a completely orthogonal issue. No point in creating a new a language construct that just combines two already existing constructs for no good reason. No it's not, exception handling and resource usage go hand-in-hand. The problem here is how messy it is to require code to be several indentions deep to handle all the issues of catching exceptions and nested resources. Java's `try-with-resources` was no accident, Java is known for being slow and conservative when adding language features, but resource management was something they felt was so important it was added as a primary language construct. &gt; Both use and try-catch are expressions and can be composed naturally. Kind of? But not without heavy nesting, which is in my opinion the real code smell here.
Yeah. I can see why people don't recommend Kotlin as your first language because of a lack of learning resources for beginners, but if you can already program, I would not bother with Java. Reading Java code should be trivial if you know Kotlin.
Yeah I agree to that first point as well. There is a surprising amount or resources out there already though. Not close to what there is in Java.
&gt; I think that is a somewhat silly statement considering using many resources is necessary, regardless of how it smells. Doing anything with databases (which is my primary example) is the perfect example of this. You have no choice but to use many resources when working with databases without an ORM. And not using an ORM is not code smell. I‚Äôd argue that if you do need to use many resources it should be abstracted and only be managed in one place where using ‚Äòuse‚Äô wouldn‚Äôt be an issue. Although, I still agree with your point on a language level construct for resource usage.
With databases, you first create a connection and 'use' it. Any other resources created from the connection (such as cursors) should get automatically closed when the connection is closed. 
That seems like perfect opportunity for some kind of form-making DSL. Why make them in HTML?
I'm trying to think of situations I've encountered where this would be useful, and I'm struggling to :/
The topic is how to handle HTML forms when you have a Kotlin backend, so I think creating DSL is a bit artificial. Do people do that in the production? Would you create static HTML in Kotlin? It's (in my opinion) a poor use of cpu-cycles, static content should ideally be served by a CDN. I could write another tutorial on working with a HTML-DSL to create dynamic HTML though, if that's something people would be interested in.
[removed]
I couldn't for the life of me work out how to make incremental compiling for projects with multiple files, working from the CLI, kinda lost interest after that, as I'm not a right IDE fan...
To be perfectly fair, I (mostly) come from PHP world, so JVM is much faster almost no matter what you do. I would trade performance for legibility any time.
For what it's worth, the Kotlin plugin for IntelliJ already includes a bytecode viewer tool window (can be found under `Tools -&gt; Kotlin -&gt; Show Kotlin Bytecode`). It even follows your cursor from the main editor.
You do all of that with Gradle, not an IDE... 
I ran your exact code. I got 1 and 1 the first time. However it seems that was lucky. Repeating 10000 times: (2, 1): 145 (1, 2): 9851 (1, 1): 4 As to what you could do to synchronize your code, maybe you should rethink the approach to your real task and try to program it in the message passing style, which avoids multi-threading issues. For example, if there is shared mutable state, you can have a single coroutine that deals exclusively with that state and the other coroutines can call that coroutine to get or update the state. So you don't have to synchronize the shared state explicitly. However you can just use the usual Java constructs and synchronize on a and b. You could use explicit [Locks](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html) and [withLock](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.concurrent/java.util.concurrent.locks.-lock/with-lock.html) for example. I also tried adding @Volatile to the fields in Foo, but ++ is not an atomic operation, so it does not help. Edit: you can look at the [coroutine guide](https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#shared-mutable-state-and-concurrency). The advice is basically to use an AtomicInteger for your case.
gradle *shudder* abomb to crack a nut...
Honestly sounds more like you should be using Python or C. 
you can use delegates to get some synchronization on the get/set in an easy way. class Foo { var a by Synchronize(0) var b by Synchronize(0) } class Synchronize&lt;T&gt;(defaultValue: T): ReadWriteProperty&lt;Any, T&gt; { private var backingField = defaultValue override fun getValue(thisRef: Any, property: KProperty&lt;*&gt;): T { return synchronized(this) { backingField } } override fun setValue(thisRef: Any, property: KProperty&lt;*&gt;, value: T) { synchronized(this) { backingField = value } } }
- Any read or write of a value is atomic on the JVM, unless the value has the type Long or Double. This applies to reads or writes of Kotlin properties too. - The Kotlin compiler does not generate any synchronization code in the generated getters and setters. - 'a++' is not an atomic operation, because it consists of a read, an increment and a write. Making all getters and setters synchronized will not help make it atomic, because another thread could update the value of `a` after the getter has released the lock and before the setter has acquired it. - In general, synchronization needs to be applied at a higher level than individual property getters and setters. In your particular example, you'd need to enclose the entire 'a++' operation in a lock (or use a class such as `AtomicInteger` that lets you perform increments atomically without taking a lock).
both nice languages, when I'm not using Java or Verilog
&gt; Any read or write of a value is atomic on the JVM, unless the value has the type Long or Double. This applies to reads or writes of Kotlin properties too. Strictly speaking, this applies to reads or writes of properties' *backing fields*. How this corresponds to a property depends on the particular property. The bigger issue with respect to multi-threading would be that of visibility. Even if the write is atomic, if the backing field is not volatile and in absence of other means of synchronisation, other threads may not see the new value, ever. You need a way of establishing a happens-before relationship between write and read for that.
All valid points. It seems that Kotlin is mostly useful in _adding_ things to a project, but it's nowhere near a good idea to start re-writing things yet.
This is good to know. But the article isn't a total downer, this is mostly early adopter woes. There's a reason this language is supported over others. Given time, I'll bet kotlin becomes the primary development language of Android. 
The learning curve should not be a problem, if you do the Koans. https://kotlinlang.org/docs/tutorials/koans.html They are done quickly, for sure in a few hours, if you know the relevant programming paradigms. And syntax is not really a problem, if you use an IDE or any editor with syntax checks.
I'd say there's another problem: IntelliJ has trouble handling classes with _a lot_ of methods or written in different languages than Java. If you try using libraries like jOOQ (with huge APIs) or Apache Spark (written in Scala), the experience is pretty much smooth in Java. The IDE becomes nearly unresponsive on auto-complete if you try using Kotlin instead. Java tooling just seems more mature and much faster - I hope Kotlin gets there eventually.
seeing as jetbrains made both intellij and kotlin.. i would expect to see intellij support for kotlin get better and better as time goes on
This is probably the best answer so far, even though I'm still not thrilled with the solution. I think people have been a bit too fixated on my example, and not the specific challenge I'm concerned about, which is synchronizing access to individual fields and an object's mutable state as a whole. But thank you for providing this.
I think my example was probably not ideal for my question, so I apologize. I'm very familiar with the rules for safe concurrency in Java. My main concern would be how to ensure proper synchronization for Kotlin objects where fields/properties represent its mutable state.
I appreciate the coroutine guide link, I'll take a look at it when I have the time. I've read a few small things about it, but haven't gotten into it in any significant sense. One of my favorite Java textbooks was Java - Concurrency in Practice, which is one of the reasons I am by my very nature obsessive over thread safety. Without traditional getters/setters, I have some concerns that I feel are legitimate about how Kotlin is able to handle mutable state properties. The answer about using delegates to synchronize access that someone gave is a nice one so far, it provides a way to add this kind of synchronization fairly elegantly. But I wish that Kotlin would make it a little bit easier, I don't understand why you can't just directly synchronize mutable properties.
 class Foo { var a = 0 @Synchronized get @Synchronized set var b = 0 @Synchronized get @Synchronized set } This is valid, as opposed to adding the annotation directly on `var a`. However it still does not make your code thread-safe since the `++` is actually two operations and the threads can interleave in between. I carried the experiment and it fails about 1 out of 20000 trials. See AtomicInteger as discussed above. 
yea it certainly is gross in the sense that you are now allocating a delegate instance for each field. Like you said you could manually do the get and set but that is boilerplate hell. class Foo { var a = 0 @Synchronized get() { return field } @Synchronized set(value) { field = value } var b = 0 @Synchronized get() { return field } @Synchronized set(value) { field = value } }
I suppose the delegate might be more performant if there is tons of contention to the same object since it locks on the delegate rather than the whole object? Seems negligible. You could probably even use `@Synchronized` on the delegate methods rather than `synchronized(lock, block)` if you like.
Also having de facto only one IDE supported at the moment (the eclipse plugin isn't really usable)
I completely agree that ++ is not atomic. I threw the example together super quickly, without too much thought, hoping that it would further clarify my question. Simply figuring out the options for synchronizing properties themselves was my main goal.
jOOQ is indeed an exceptional API with respect to its size (and with respect to everything else, of course üòâ), I just suspect that this sort of API support was not on the IntelliJ / Kotlin developers radar from the beginning, following an 80/20 strategy. There's been a popular issue about this, which has been resolved: https://youtrack.jetbrains.com/issue/KT-10978 Is it still an issue for you?
Doing Koans is very different than being comfortable writing production code for one of the busiest websites/apps in the world.
I admit it got somewhat better after the recent release, but it's still very much an issue. It's even worse with Spark. I might have to reinstall the IDE or deactivate some plugins (Scala?), as it's currently downright unusable - IntelliJ freezes after each _CTRL+SPACE_. Don't get me wrong, I really appreciate Kotlin as a language, and I'm lucky enough to actually get paid to write it for a non-Android project. Still, after I recently switched back to Java to write a small module, I was surprised how smooth the code completion was. Kotlin has the syntax sugar advantage, but I have to admit that I'm able to write Java business logic just as fast - if not faster - due to better IDE experience.
But most of the time that is because of the colleagues. You can write Kotlin like Java with the only difference, that in Java you write: ```final int a = 0;``` instead of: ```val a = 0``` or, if the type is hidden to the reader, you friendly write: ```val a: Int = b``` to show the type.
I think JB is actively looking in improving completion performance. Here's a commit from 15 days ago: https://github.com/JetBrains/kotlin/commit/ccfcfd8721f6fc2aa3a95685963fc6206642dbe5
I'm always confused with the syntax for lambda expressions. The kotlin syntax is fine and makes sense, but it's different from the one in Java 8 and it gets confusing as I switch between both languages often. Mainly if you need brackets or not and if you need parentheses around the parameters. Also covariance / contravariance is confusing sometimes. For simple cases in/out makes totally sense but sometimes I want to write a method that takes a ListModel of subclasses of Foo and then I have to think about if I should use in or out. I know out is right, but it's not super intuitive because I put the items in and don't take them out. Probably I'm just used to Java.
Thanks man! Yeah lambda expressions are a little tricky to get used to. I still have to pause when I come across them.
For loop iteration over ranges Consider the ff examples where 1 and 4 might come from elsewhere in your program: **Iterate ascending inclusive** `for (i in 1..4) print(i) // prints "1234"` **Iterate descending inclusive** `for (i in 4 downTo 1) print(i) // prints "4321"` *there are 2 more ways to do this* **Iterate ascending exclusive** `for (i in 1 until 4) print(i) // prints "123"` **Iterate descending exclusive** `for (i in 4 downTo (1+1)) print(i) // prints "432"` *there are 2 more ways to do this* **Iterate ascending with steps** `for (i in 1..4 step 2) print(i) // prints "13"` I like to do code golf challenges to get familiar with a language and when trying challenges such as [this one](https://codegolf.stackexchange.com/questions/4114/print-a-christmas-tree), I encounter this Range hullabaloo. I wish c style for loops was a thing in kotlin for the sake of integral types. Not everything has an iterator [See ranges here](https://kotlinlang.org/docs/reference/ranges.html) [Stack overflow confusion](https://stackoverflow.com/questions/9562605/in-kotlin-can-i-create-a-range-that-counts-backwards) 
That `val` [does not necessarily mean immutable](http://blog.danlew.net/2017/05/30/mutable-vals-in-kotlin/), and reading from one [does not always happen quickly](https://medium.com/@breandan/be-careful-with-custom-accessors-in-kotlin-fbd9834922e5). When learning Kotlin, I heavily abused `val` and custom accessors/mutators.
What I find funny is that the Kotlin syntax for lambdas seems much more in line with the overall syntax rules of Java (and c#, js, c, etc) than the lambda syntax used by Java itself. It makes a lot of sense to use blocks for such a thing. It is too bad the languages have copied each other's syntax rules, because, at least for js, it results in confusing ambiguity. For instance `() =&gt; {}` is often used by people who are new to the syntax to create a function that returns an empty object, but this does in fact create a function that returns `undefined`. If lambda blocks were used like in Kotlin, none of such ambiguity would have been possible.
I'm glad you mentioned this, because it can be a huge "gotcha" on Android when you accidentally use the Java lambdas and your app starts crashing on older phones. 
You cant override a getXXX() function in a Java interface with a Kotlin property.
[here](https://news.ycombinator.com/item?id=14882209) is the relevant HackerNews thread. This is my comment copied from there verbatim: This article is most likely written by someone who does not like Kotlin but has to live with the fact that he has to use it. Let's see some invalid points: &gt; If you‚Äôre going to use Kotlin in your code base, you‚Äôll need to teach almost every developer on your team how to use it. Not true. Java and Kotlin can be used on the same project and Kotlin also has seamless Java interop. If you don't want to write Kotlin you don't have to. It is also easy to read for other devs so readibility is not an issue. Then the writer goes on and on how the velocity is affected by learning Kotlin but misses the point: you don't have to burn any bridges by using it. &gt; When I realized very few developers actually saw the developer velocity gain, I was left with a bit of a, ‚Äúso what‚Äôs the point‚Äù feeling. Then the op should question the capabilities of his developers. I came from a Java background and after several weeks of Kotlin exposure my productivity skyrocketed. It helps if you have some FP background but you can learn it on the way. Currently the whole team writes Kotlin code and looking back at previous sprints I can say that the velocity increased by a double digit percentage. &gt; Kotlin accounts for about 25 percent of our clean build time and 40 percent of our incremental build time. Then the op has some serious Gradle configuration problems. We also had this then tweaked Gradle (upped the version, started using parallel builds, etc) and now the difference is minimal. You are also better off with tools like JRebel even if you work with Java. &gt; Not being familiar with Kotlin, the developer immediately assumed Kotlin was causing the problem and lost time investigating what was a simple fix. This ‚Äúweirdness‚Äù combined with the actual stability issues means there‚Äôs significant maintenance time lost. I've been using Kotlin for more than a year and I only had a single stability issue (and it was an IDEA plugin problem). Kotlin works amazingly well with other libraries and after using it for several months I felt that I never want to go back to Java. Maybe the op's issues are with the Android ecosystem or a bad development team, and not with Kotlin itself since we use it on the backend and we don't see the problems mentioned in the article. The only valid point I've seen in the article is the lack of static analysis tools and as the article states it will get better.
Seems like you never used Kotlin and never ported a project to Kotlin. I've already ported 3 projects and they are infinitely easier to maintain / use / develop. Just go and try the language out before making blanket statements like this. I'm also working on a Kotlin project for more than a year at my workplace and I'de never go back to Java since it is a much more smooth experience to work with Kotlin.
Not just Android. The developers of Spring (a prominant back-end framework for Java) are specifically encouraging Kotlin adoption and for the newest version they have built-in [Kotlin Support](https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0). This is very important since Spring is used at **a lot** of places (just look up Java jobs and you'll see Spring + Hibernate at more than 60% of jobs).
May be it's just that I've got too many languages going on in things i do, but my "how do you exit from vi" of kotlin is How do you pass a class as an argument to a method?
I wonder, how come you experienced such a boost in productivity? I find Kotlin a lot more fun, but I still spend 90% of the time designing algorithms and solutions just as before. I've been able to create some slightly more functional solutions with Rx since I transitioned to Kotlin though, but mostly just due to syntactic sugar.
Yea, once I sat in the train, coding my first lines of Kotlin offline and I had to access the class of something - didn't find it out then :D "Of course" it is Vector3f::class or Vector3f::javaClass.
&gt; If you don't want to write Kotlin you don't have to. In a team with one Kotlin codebase you're not gonna be the only one person that writes java. You could have that person work on legacy code i guess. &gt; tweaked Gradle (upped the version, started using parallel builds, etc) These optimizations work for Java as well. Doesn't change the fact that Kotlin compiles slower. 
My understanding is that val is like finally in Java, which means the reference can't be changed even though the underlying object may be mutable. Reading that link, I see one of the challenges is the affect of customizing the getter. But beyond that, you can't re-assign a val, right?
In a mixed team you can choose which one to use. You can also write Kotlin in a way that it almost looks like Java (with concrete types all the way for example). Gradle build is slower with Kotlin but not orders of magnitude slower. It is around 10% for us. More information [here](https://medium.com/keepsafe-engineering/kotlin-vs-java-compilation-speed-e6c174b39b5d).
It entirely depends on the the implementation of coroutines context. For example, if the context is implemented using the `ForkJoinPool.commonPool()`, I guess you could think of coroutines as fancy syntax sugar for scheduling callables. Let's assume you want to serialize JSON file, save it to a file (blocking) and continue working on the JSON after you're done. Using callbacks, it would look roughly like this: CompletableFuture .supplyAsync { serialize(someObject) } .thenApply { saveJson(it); it } .thenAccept { println(it) } The same logic using coroutines would be similar to this: val json = serialize(someObject) saveJson(json) // Suspending call, executed as separate task. println(json) // Resuming. Under the hood, the execution would be broken into 3 separate tasks invoked after each other (serialization, JSON saving, resuming of the code after `saveJson`). It's easier to read, extend and debug. Also, it's _much_ easier to handle exceptions and conditionals - exceptions can be a pain to work with when using nested callbacks. With coroutines, you use the good old `try {} catch {}` mechanism and it _just works_. And don't even let me start talking about creating complex conditional expressions using futures. Coroutines basically abstract the asynchronous execution of your code, without forcing a functional/fluent/reactive/you-name-it API down your throat. Note that it isn't a silver bullet: it's great for scheduling multi-phase tasks, potentially with blocking operations that can be executed on a separate I/O thread pool. It doesn't work for everything, though. For example, I'd still choose Java parallel streams to handle massive multi-threaded operations on collections. I'd like to think of coroutines as a tool to simplify the asynchronous code, not a magic feature that automatically parallelizes your application and makes it ten times faster.
Well, _mostly_ just works. I believe there are still some scenarios with inlined functions and try {} catch {} that will cause internal compiler errors still. But that's what the experimental status is for :P
its* You could have just copy/pasted the title of the article (which spells it right). 
What are we supposed to see here? There's nothing but an empty profile page.
I'd say you need to think about, why you wanted to type to be private in the first place, but expose it via property. Maybe you only wanted a subset of that type's members to be accessible, so you should create a public interface with only those members, and make the property use that type. Or you could use some delegated properties for that property's members you need to expose. Not bashing on the article here, just thought I'd list these options in addition to the once mentioned in there. Let me know, if I'm off, though. Always want to learn. üôÇ
Looks like spam
`val` just means readonly. If you use a custom getter or a delegate you can return a new reference every time. 
A while loop is still an option for the more complex cases.
one thing I've been wondering about... is there a good way to expose a property externally as a more limited type? For example: private val name = MutableLiveData&lt;String&gt;() public val nameLiveData: LiveData&lt;String&gt; get() = this.name but what I'd like is some way to combine those two in a more concise statement like... private val name = MutableLiveData&lt;String&gt;() public get(): LiveData&lt;String&gt;
Kotlin coroutine primitives that are built into the language are not intended to be directly used in applications. They are meant to have libraries built on top of them and those libraries are intended to be used in applications. Have you read this https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md ? For me it took a while to understand coroutines, luckily I started with Quasar before picking up Kotlin coroutines so I had been wanting language support for coroutines from the beginning. Coroutines are most definitely not syntatic sugar. Multiple coroutines in a single Thread can be waiting on something to happen at the same time but they, of course, cannot process data at the same time. When working with coroutines it's extremely important to understand which tasks are CPU bound and which are IO bound. Let's look at an example of 10 coroutines making a suspending HTTP request from the same thread. The first will execute until the request is sent and the coroutine is told to suspend until it gets a response from the server then the next and the next etc. The next part could vary a bit depending on many things but let's just keep it simple and say all coroutines will run to their first suspension point and be waiting for a server response and the thread they're running in will be sitting idle. Then eventually one coroutine will get a response and finishing doing what it needs to do, then the thread will either move to the next coroutine or go idle again. This will continue until all coroutines in the thread have completely finished executing or have been canceled in some way. Suspending a coroutine tells the thread it can move to the next coroutine and come back to this one later, it does not block the Thread. This means you don't need entire resource intensive threads laying around solely for the purpose of waiting for a server response or UI event or some other IO bound thing. Instead you have as many as tens of thousands of lightweight coroutines in a single thread. That is coroutines for IO bound things, this is where it has the most clear benefits from a performance standpoint, but coroutines always have benefits from a safety standpoint. For CPU bound things coroutines are basically just a safe way to encapsulate execution and transfer data around, because of course multiple coroutines cannot actually be utilizing the processor at the same time from the same thread. So basically you would use a ThreadPool as a coroutine context and schedule your coroutines on that ThreadPool. This makes getting the data that resulted from this concurrent processing much safer and even allows you to do really cool stuff like start a coroutine in a ThreadPool and then move it to another context (like the UI Thread or something) after it's done with it's heavy work. You can also (and probably should do so more often) use some channel construct to send data between coroutines (channels are basically suspending Ques with the intent to be used for sending data between coroutines). So you can have a coroutine sitting there waiting for this channel to have something in it and as soon as it does it can do something with the data from the channel then die or go back to waiting, and this coroutine can safely be a on a different thread then the coroutine that put the data on the channel so you have a lightweight mechanism for safe communication between Threads. Usually I have a "main" Thread (a Thread which is a coroutine context meaning it knows how to cycle through scheduled coroutines, it still a regular Thread though so you can run stuff on it not in a coroutine just fine) like this: https://gist.github.com/zjuhasz/bef3aa1dea590783864b84f437f14a62. On this main thread I keep all of my dangerous mutable state and I only modify it from that thread, either directly or by sending a message from a coroutine in another thread. There are lots of other ways to safely handle mutable state without locks using coroutines, for example you have actors or similar contructs (an actor is basically an abstraction for a coroutine + some state + a channel, it keeps the state safe by only ever directly accessing it from a single coroutine) but I don't think you should worry about these too much yet. I hope this helped somewhat, cheers!
RemindMe! 3 days
I will be messaging you on [**2017-08-07 17:58:38 UTC**](http://www.wolframalpha.com/input/?i=2017-08-07 17:58:38 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/Kotlin/comments/6ri0ao/kotlin_public_property_exposes_its_private_type/dl629m4) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/Kotlin/comments/6ri0ao/kotlin_public_property_exposes_its_private_type/dl629m4]%0A%0ARemindMe! 3 days) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! dl62a79) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Look at this [Coroutine in Kotlin youtube video](https://www.youtube.com/watch?v=XEgibiHdJtQ) if you have the time. It will answer all your questions. The speaker is Svetlana Isakova, one the co-author of the Kotlin in Action book. The video is not even a month old.
https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take-while.html zipStream.takeWhile { it != null }.forEach { System.out.printline(it) } No need for a mutable value this way 
I got stuck at this as well, I also needed some Java libs for File processing, but for that one has to use a build system like Gradle or Maven (to stay sane). That's where I stopped and switched to IntelliJ :/ 
Yup, Kotlin CLI tools are not near being as simple to use as Python. But Kotlin script is a good goto for small scripts in the terminal
&gt; https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take-while.html Isn't that for Iterables and Arrays? ZipInputStream doesn't seem to implement any of the extended interfaces.
You could do this: while(true){ val entry = zipStream.nextEntry ?: break // do something with entry }
I found this limitation to be the single most frustrating thing about trying to introduce Kotlin into my existing Java code base.
Answers? Too lazy...
There are answers in the presentation slides. (I could add them to puzzlers.md I guess.)
DSL's as builders are nice, but please don't take them too far. When Scala started to gain traction, every library created its own DSL, and the result was a living hell, were you needed to learn the particulars of a hundred DSL's to get something done. And everything combined with custom operators, of course. One DSL looks like a small nice addition if you are the creator of the library, but for the user of your library it may hide the cause of a problem. After creating a DSL, always carefully check how clear the error messages are if there is any problem, and how easy is to debug problems, specially if you are creating a library. Users of your library are typically not familiar with the details of your work as you are.
That would be nice. It's easier to not have to deal with the slides or download anything.
Nice writeup! Folks, keep in mind that the cost of performance improvements is almost always increased code complexity -&gt; meaning, it takes longer to make changes and there's an increased chance of bugs. Always consider this tradeoff when making a decision about whether to optimize. Also, before you embark on an optimization journey, read as much as you can about why it's NOT the right answer. Make sure you've done everything possible to get good performance (architecture, algorithms, data structures) without resorting to optimization. Get your co-workers to talk you out of it. Finally, after all that, if the consensus is that the code needs performance tuning, go ahead and optimize. Go for the quick, easy wins and be leery of increasingly-clever hacks. And remember the fastest code is the code that doesn't exist. Examine assumptions: does that (slow) operation need to be done at all? And finally, be wary of caching: here be dragons. Ooops. I'll just... step off my soapbox now... yeah. 
takeWhile doesn't appear to be a thing for ZipInputStreams, but there are some other functions (takeIf and takeUnless). Interesting...
You can write an extension function on ZipInputStream that returns an iterator. This will make you able to use it in a for-loop. Something like this: operator fun ZipInputStream.iterator() = object : Iterator&lt;ZipEntry&gt; { // This line eagerly pulls the first element from the stream when the iterator is created. // You may have to do something in next() if this doesn't work for you. var next: ZipEntry? = nextEntry override operator fun hasNext() = next != null override operator fun next(): ZipEntry { val tmp = next ?: throw NoSuchElementException() next = nextEntry return tmp } } You can now do this: for (entry in zipStream) { .... }
I actually did something similar while I was poking at it. The challenge, of course, is exposing both the ZipEntry and ZipInputStream for each iteration, as both have value for the end user. I did something without actually providing an Iterable: fun ZipInputStream.forEachEntry(block: (entry: ZipEntry, stream: InputStream) -&gt; Unit) { var entry: ZipEntry? = null while({entry = this.nextEntry; entry }() != null){ try{ block(entry as ZipEntry, this) } finally{ this.closeEntry() } } } Which would be used like: zipStream.forEachEntry { entry, stream -&gt; println(entry.name); count++ } Although it is something I should poke at more. I've been putting together this library of cool ways to use Kotlin extension functions to improve standard java libraries while playing with the language. The ZipInputStream is just one part of it. I've created shortcuts to executing parameterized JDBC PreparedStatements in a single line, and handling the results, iterable DOM NodeLists, and a few other small tweaks.
Yes I totally get what you mean. It's a pretty interesting topic anyways which is why I posted about it :)
I've experimented with several ways and I prefer [something like this](https://github.com/irotsoma/cloudbackenc-centralcontroller/blob/master/src/main/kotlin/com/irotsoma/cloudbackenc/centralcontroller/files/FileObject.kt) if you want the user to be able to set a UUID as the row ID. Or [something like this](https://github.com/irotsoma/cloudbackenc-centralcontroller/blob/master/src/main/kotlin/com/irotsoma/cloudbackenc/centralcontroller/cloudservices/UserCloudService.kt) if you want the row ID to be automatically generated. And [here is a little more complicated example] (https://github.com/irotsoma/cloudbackenc-centralcontroller/blob/master/src/main/kotlin/com/irotsoma/cloudbackenc/centralcontroller/authentication/UserAccount.kt) where I wanted to return enum values as the values from a child table. I use a fair number of JPA Spring classes throughout that project. Feel free to check it out. It's my current hobby project so it's a WIP and series of POCs right now, and not everything is fully documented yet, so feel free to ask I f you get inspired, feel free to send pull requests, too. :) Anyway, to get the entire project you need to check out [the parent project](https://github.com/irotsoma/cloudbackenc-parent) which has all of the submodules for the different components and plugins. 
Added answers to kotlin-puzzlers.md.
I wonder whether we are in the minority.
I think the concept of a property does not allow this for good reasons: What you want is not a property. You can do something like this private val mutableName = mutableListOf("asd") val name get() : List&lt;String&gt; = mutableName or instead of a property, just use a function, which would be more appropriate I think: private val name = mutableListOf("asd") fun getName() : List&lt;String&gt; = name
Interesting. I'd prefer it if there wasn't a contains function for IntRange that takes a Float at all, since Kotlin generally requires explicit casts. I suppose they had to keep binary compatibility, and couldn't just remove the function altogether. Perhaps it should be deprecated though.
I read the [main coroutine guide](https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#actors) and I agree with you that it is not crystal clear about what blocks or does not block threads running coroutines. What is very clear is that coroutines will not block a thread when calling a magical `suspend` function. However I think that they don't put enough emphasis on the fact that coroutines will still block with the usual blocking functions. If you do I/O, the standard Java methods are not `suspend` functions so they will block. You will have to use [java.nio](https://en.wikipedia.org/wiki/New_I/O_(Java)), which is non-blocking and define your own `suspend` functions on top of that. But actually I noticed that [kotlinx-coroutines-nio](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-nio/kotlinx.coroutines.experimental.nio/index.html) already exists. I'm not sure how complete it is, but it will save you some implementation. You should use those `suspend` I/O functions instead of standard Java I/O if you don't want your coroutines to block. Another example is `Thread.sleep()` which is not a `suspend` function and which you should therefore not use inside a coroutine since it will block the thread. Instead you can use [`delay()`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/delay.html) which does the same, but which is a magical `suspend` non-blocking function. It is discussed in this [other document](https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md#non-blocking-sleep).
Thanks for my reply. I think my biggest problem with it is I don't like the idea of "calling a magical suspend function". I'd prefer to understand a bit more of how the "magic" works.
Yeah, this is what I'm doing currently
They give an overview of the implementation in this other [document](https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md#implementation-details). Basically the whole state of the coroutine is saved when it reaches a `suspend` function and another coroutine is revived on that thread. So there is quite some work going on in the background. It's not quite magic.
Ooh nice! is this Intellij or Android Studio (canary)?
It's in IntelliJ (I'm using 2017.2.2 EAP) &gt; Preferences &gt; Editor &gt; Inspections &gt; Kotlin &gt; Style issues
Seems like this is maybe something an inspection could catch to warn you if you mismatch types?
Wasn't one of the design decisions that JetBrains made that Kotlin does not need literals since they just add unnecessary complexity to the syntax that can be done with functions (and inline functions)?
Unnecessary complexity? How is this [object1, object2, object3] more complex than this? arrayOf(object1, object2, object3)
The first example introduces a new element to the syntax which makes it more complex. I like how Koltin uses built-in features instead of literals. Say you wanted a linked list, would there be a seperate syntax? What about if I wanted an instance of a custom list implementation how would I do that?
 val linkedList: LinkedList&lt;T&gt; = [object1, object2, object3] val customList: CustomList&lt;T&gt; = [object1, object2, object3]
[Yes.](https://blog.jetbrains.com/kotlin/2017/06/early-access-program-for-kotlin-1-2-has-been-started/)
[Jake Whartons reaction](https://blog.jetbrains.com/kotlin/2017/06/kotlin-future-features-survey-results/) to the announcement: &gt; Ah, yes: collection literals. Spitting in the face of a language design principle to save a whole 5 characters. For the next survey please include ‚Äúsynchronized as a keyword‚Äù and ‚Äúasync/await keywords‚Äù so that we can continue to regress things into the language when a library function is already doing Just Fine‚Ñ¢. &gt; Please executive decision this to the bottom of the ‚ÄúNO‚Äù pile.
Yeah, but that's only for values in annotations... at least for now.
I really hope this is not happening. I like my arrayOf and listOf, thank you. It's perfectly readable just how it is. I'd love to see more development times focused on other issues. 
How is that better than: `val linkedList = linkedListOf(obj, obj, obj)` For the custom list you can create a new function (customListOf) or: `val customList = CustomList(listOf(obj, obj, obj))` With the new syntax it is required for the compiler to know to which type it needs to infer. With the `*Of` syntax it is know at construction, from which the rest can be inferred. It seems to me that the main advantage of `[]` is familiarity.
For what it's worth, array literals in compile-time constant expressions (aka annotations) aren't bad. That is what this is: https://blog.jetbrains.com/kotlin/2017/06/early-access-program-for-kotlin-1-2-has-been-started/ I don't really want them for declaring runtime arrays or collections (constant or not) though. At least not without persistent immutable collections, but perhaps not even then...
I think what's worse is that this isn't even a change caused by recompiling from source and getting some other overload (for example). This is a backwards-incompatible in behavior but binary-compatible change which is a bit scary to see. Old code relying on this behavior suddenly gets new behavior if you put a new stdlib on the classpath. If you argue the old behavior is a bug, then I guess this is okay. Technically all bug fixes that are binary compatible break behavior compatibility. But I would too argue for this to be deprecated in 1.2 and then hidden in 1.3. Especially for a language that is otherwise so forceful about the need to be explicit in numeric type conversion.
I can't imagine a situation where I would find it useful.
I'm sure you're familiar with the statement "Technically correct: The most useless kind of correct." What you've said is technically correct, collection literals literally make the parser slightly harder and the cognitive overhead slightly more difficult because there is Yet Another Option, but let's be serious, not all complexity is made the same. Groovy solves your second point by default to ArrayList and LinkedHashMap. You can then pass to a copy constructor or cast as necessary for a different type. Alternatively you could just continue to use the standard library functions or constructors. I mean I still regularly have to do ConcurrentHashMap() in Kotlin because there is no concurrentMapOf() function. It's funny how folks are railing on the collection literal idea when the language has tons of other syntactic complexity like the fact there are two different function definition syntax depending on whether you can fit the function into a single expression or not.
I think that enforcing purity in a language that is supposed to be pragmatic is a folly. Kotlin is supposed to be "like Java but practical." This ain't Scala. So, [] instead of arrayOf is practical. I respectfully disagree with u/JakeWharton and agree with the feature. Now we just need literal for mapOf and I am totally happy camper.
What map though? Mutable or immutable? Ordered or unordered? And it only gets worse from there if you start doing lists and sets. Factory functions that are both declarative and descriptive for all 4 of those cases already exist and are only a few characters longer which seems perfectly pragmatic.
How is val l: List&lt;Int&gt; = [1, 2, 3, 4] better than val l = listOf(1, 2, 3, 4) IMHO it would just introduce some inconsistency, because kotlin uses the *val name: Type* syntax in order to be able to omit the Type in most of the cases. With Literals you're forced to write out the Type
I love you kotlin
Well, what does arrayOf use? What does mapOf use? You probably want it to be an ordered immutable list. 
`val l = [1,2,3,4]` Type can automatically be inferred. Heck it could just be some sugar on `listOf(...)`. I really don't see your point. 
Because it could end up being self.l = [1, 2, 3, 4] later on. 
What type does *l* have there? Looking at the code it isn't clear. It'd be just a convention or you have to look it up. Basically with Literals you have: * One "default" List/Array-Type * Implicit types * Added Syntax * Added complexity of the compiler (do not underestimate the implementation of collection literals) * Another way of doing the same thing (don't want another scala) just for saving 5 characters. And if we go that route, people want other sugar aswell "because its just a little bit more syntax" and we end up with a bloated language. I'd rather be conservative with syntax additions that can easily be done with library-constructs already
How are you enforcing your domain objects are created in a valid state? I life to favor immutability but I also like to take a DDD approach and have business logic in the domain layer. Thus these objects should never be able to get into an invalid state. In your one example what prevents the caller from instantiating FileObject with an invalid List&lt;CloudServiceFileObject&gt;? if there were some kind of business rules around it like they can't duplicate, or they can't be over a specific size? Would you just handle that in the service layer only?
But listOf doesn't tell you the type either. It's an opaque factory method.
The obvious question come forward in my head... how would you compare this to a more widely adopted tool like Rx?
I think in general they are nicer, but the advantage is clearer when looking at a larger nested structure (imagine representing JSON in code). In Kotlin: val request = mapOf( "data" to listOf("one", "two", "three"), "other" to mapOf("first" to listOf("x"), "second" to listOf("y", "z")) ) In Clojure (a JVM language that makes heavy use of collection literals): (def request {"data" ["one" "two" "three"] "other" {"first" ["x"] "second" ["y" "z"]}}) In an imaginary Kotlin world: val request = { "data" to ["one", "two", "three"], "other" to {"first" to ["x"], "second" to ["y", "z"]} } Only in cases where I'm looking for absolute performance do I actually care what type of list and map I'm using (as long as the default is sane), so I'd rather have the improvement in quality of life.
A [`Late`](https://gladed.github.io/kotlin-late/com.gladed.late/-late/) is intended to be more like Scala's [`Future`](http://www.scala-lang.org/api/2.9.3/scala/concurrent/Future.html). In Rx I guess it would compare to a [`Single`](http://reactivex.io/RxJava/javadoc/io/reactivex/Single.html). I find the Future construct easier to adopt in small bites, versus having to swallow Rx's entire `Observable` enchilada whole.
&gt; just for saving 5 characters I think that the idea is to have json-like structures in the code. So it is not just about saving characters. I agree that it is less necessary with DSLs.
This is nice, i just wish they would have added more stuff about intellij plugin performance, this is the only thing that i wish they'd improve, the language itself is perfect
Currently the POST method on /files which is implemented by [this class](https://github.com/irotsoma/cloudbackenc-centralcontroller/blob/master/src/main/kotlin/com/irotsoma/cloudbackenc/centralcontroller/controllers/FileController.kt) accepts a file. Determines if it exists in the database and if so loads that FileObject and if not creates a new one. This is then used to represent a file from a specific client with a specific path. Either way a CloudServiceFileObject is created only when the file is successfully uploaded to a cloud service provider. At that point this represents a version of the file and only the UUID is passed back to the caller. Currently this is the only use of that object, but there will be a GET method which accepts only the UUID that then downloads the appropriate version of the file represented as a CloudServiceFileObject. There will be some logic at this level to ensure that the CloudServiceFileObject is valid and exists on the cloud service. The external caller will never be creating a CloudServiceFileObject, because it doesn't have any visibility into what happens to the file. The only service accessing this object is the centralcontroller. Any objects that get passed via rest services are part of the common library and those have some minimal logic, but aren't JPA objects. Not sure if that answered your question.
We're constantly working on that, and 1.2-M2 includes that work as part of "many of the tooling features available in the upcoming release of Kotlin 1.1.4".
I just want to say that you guys are amazing with amazing products.
Awesome, thanks a lot guys &lt;3
The only thing I miss is proper namespacing (like in clojure). With package private gone it is even worse than java. The internal keyword is only applicable if the program won't be used from java...apart from this issue I'm happy with the language.
I can not confirm that. I've never noticed that code completion with kotlin would be slow.
Coroutine integration is far better.
Integration with what?
&gt; When learning Kotlin, I heavily abused val and custom accessors/mutators. Every new language feature is heavily abused until we find out what works out and what doesn't...
Maybe explorative programming? In Kotlin, you can write 10 lines of code and figure out quite quickly that your idea won't work, whereas in Java, you have to write 100 lines of boilerplate before you come to the same conclusion ;)
I second that. Someting more restrictive than the entire module would be nice. Specifically, I'd like to keep the internals of an Android screen private to that screen. Right now each of them is in one package. Putting them all into separate modules really doesn't make any sense for my project so now everything is public :-{
I don't want to judge your work but the ability to avoid the callbacks in asynchronous programming (onPass, onFail) is very helpful. JetBrains are working on a module to integrate coroutine with Java Future. https://github.com/Kotlin/kotlinx.coroutines/tree/master/integration 
Currently you can work around that in a way that you return `interface`s from your methods and not concrete implementations but internally you refer to your objects by those implementing classes (or more specialized `interface`s).
Nice tutorial! I also wrote my first Alexa skill in Kotlin. I had only used the web UI for all the interaction with Lambda, so next time I publish a skill, I will give your CLI tips a try.
Yeah, I found that when you get the hang of it it's quite handy to just do everything through terminal.
Getting critique is why I posted here, so no worries! I think with coroutines you trade the overhead of callbacks for the overhead of grasping some new language constructs. Maybe an example would help? Suppose I want to background-copy an input stream to an output stream, close both streams, and return the byte count. With `kotlin-late`: // Streams.kt fun InputStream.drain(output: OutputStream): Late&lt;Long&gt; = work { copyTo(output) } onDone { Try { close() } Try { output.close() } } I could call this from Kotlin with `inStream.drain(outStream)` or from Java with `StreamsKt.drain(inStream, outStream)`. `.cancel()` on the return would cause both streams to be cleaned up nicely in any condition. How would I achieve that with coroutines+integrations? 
listOf() already has that problem. You just have to know it gives you an immutable list. I wouldn't say no to some syntax sugar here. Kotlin tries not to be excessively verbose, but this is one of those areas where it's quite a bit worse than other languages. [] being a way to write listOf() is quite easily understood, I think.
The `List` type is immutable in Kotlin so why would you expect anything else? `mutableListOf` gives you a `MutableList`. `arrayListOf` gives you an `ArrayList`. I'm not seeing how these aren't superior by virtue of being declarative. The biggest problem with the syntax for `listOf` is that you eventually want a mutable one. And then sets and maps are even worse because stable ordering comes into play.
Yes, and in Java List is mutable. So we can rephrase it - you just have to know that List is read only and MutableList is what Java calls List. Once you can read Kotlin of course it makes no difference either way. Kotlin has all sorts of convenient syntax shortcuts for common cases of a more general concept. It has `it` despite the fact that when using lambdas, pretty quickly you'll want a named parameter or a lambda with two parameters. It has `::method` although it's not intuitive syntax at all unless you're already familiar with it from other languages like Java 8. I don't see what the big deal is with [] being an ordered list. So many languages have such syntax it'd not confuse anyone. It can default to being MutableList if there's no way to infer it as List or Set from the use site.
Your arguments of convenient syntax, again, don't apply here because of the variance of intent with collection literals. If you've ever used collection literals in Groovy you'll know that the complexity of how they behavior is unintuitive to the point of being prohibitively useful. Defaulting to `MutableList` instead of `List` and using the same notation for also creating a `Set` (and what about `MutableSet` and what about ordered sets?) sounds awful. Kotlin syntax, while attempting to be brief, retains a set of clarity and determinism which collection literals, at present, are not.
Sorry, I don't get it. How do I restrict the visibility of the actual implementations then? Those should be private to the screen in my case.
 interface Foo { fun bar() } interface InternalFoo : Foo { fun internalBar() } interface UserFacingAPI { fun createFoo(): Foo } You refer to your concrete implementation by `InternalFoo` within your code (whenever you use it internally). You return `Foo` objects through your external API to your callees. Of course your users can cast `Foo` to `InternalFoo` if they figure this out but then it is their problem because they use your stuff in an unintended way.
Hi gladed, `onDone` function is a regular `finally` block, you can learn about it in "The Coroutine Guide", specifically here https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#closing-resources-with-finally but I really suggest you to read all the document. NIO vs IO, using a single thread pool for blocking and nonblocking operations, and many other aspects to tackle for a full analisys, but after reading the guide I invite you to join to discuss.kotlinlang.org for further questions ;)
That doesn't really fit my use case. I wanted true visibility constraints like protected, private, ‚Ä¶. This is just a naming scheme :-( but thanks for taking the time to explain it to me! :-)
Well, let's hope they'll do something about it :)
Obviously CompletableFuture is componible, `onDone` is `whenComplete`, it works out of the box (no coroutine or kotlin-late required).
I wish they did this. Like python. Lists = [] Dicts = {} Tuples = (,) listOf is fine until you make nested lists mapOf is fine until you have nested maps and why did they remove Tuples? I know data classes are preferred but why? 
Thanks for the reference. I'm still getting on top of everything coroutines can do. The `onDone` section in my example is more than just a `finally` block, it's something that is able to stop the original operation upon reaching the cancel state. This is important because Kotlin's `copyTo` and the IO operations in Input/OutputStream may block and also won't voluntarily `yield`. So they're somewhat resistant to cancellation. I think in both Java 8's CompletableFuture and Kotlin coroutines I would need to juggle *two* futures -- a settable one to manage cancellation and of course the actual background execution future. Sure this works but it's more cognitive load and lines of code for the implementer to get wrong.
For my purposes, the JPA / Domain layer sits in its own Gradle module and is used by two web api projects with different developers. I'm building more of a library than an application. I cannot guarantee that there code will always pass my library good data or be in a valid state. In my case I'm trying to take a more DDD and OOP approach where the domain logic / validation code lives inside the domain class, that way they can never be created or get into an invalid state. I see your point as well though where you have full control so your service layer presumably would do that logic to ensure you are in a valid state before proceeding. A class like this API allows the user to set an ID, which should be handled by database. That is just a very simple example. data class User(val id:Long, name: String) 
Unfortunately, Spring JPA isn't going to be able to set the ID value if it is immutable, but it doesn't have to be a part of the parameters and it can be private. I modified the [UserCloudService](https://github.com/irotsoma/cloudbackenc-centralcontroller/blob/master/src/main/kotlin/com/irotsoma/cloudbackenc/centralcontroller/cloudservices/UserCloudService.kt) object to be this way to show an example since that's probably how I should have done it in the first place. Also, made everything except for the loggedIn property to be unmutable and also set the updatabale property on the column to false so if it someone were to create an object with different values in those fields, they wouldn't get overwritten. It's not possible in my case, but it's still a good practice so I figured I'd add it. If you want more logic, though, getters and setters are still a good way to do it. In [this case](https://github.com/irotsoma/cloudbackenc-centralcontroller/blob/master/src/main/kotlin/com/irotsoma/cloudbackenc/centralcontroller/authentication/UserAccount.kt) I want to make sure that all user roles are actually valid. So I used an enum list property "roles" which actually just has getters and setters that use the private string list property "roleList" for storing the data. I did this because I wanted to be able to add error handling that if a value from the database is invalid just ignore it. Otherwise it would have thrown an exception when using the getter and trying to convert the invalid string to the enum, which might be ok, too, for your situation. So when loading from the database it will load the invalid value into roleList just fine, but when accessing roles it will just ignore that value. "Roles" (both the parameter and the property) can't be set to an invalid value because it is the appropriate enum data type, so there's validation on that end as well. Eventually, I'll also add the logic for validating email addresses as well, which means I'll probably make it much like the roles.
&gt; Unfortunately, Spring JPA isn't going to be able to set the ID value if it is immutable. Hibernate can set the value if its final (Java) or val (Kotlin) as it's done through reflection. I see your points though, good luck with your application!
Blocking operations don't fit well to asynchronous programming. See https://discuss.kotlinlang.org/t/calling-blocking-code-in-coroutines/2368 &gt; the IO operations in Input/OutputStream may block and also won't voluntarily yield This is the chapter: NIO vs IO
&gt; Blocking operations don't fit well to asynchronous programming. I think that's overstated. In my experience, blocking operations are the primary reason asynchronous programming is needed in the first place: dealing with file IO, web requests, RPCs, and so forth. If you have big enough thread pool and a way to cancel things on occasion, it works just fine. As my example was intended to illustrate :)
I've been toying around with Kotlin personally and am generally happy with it. It's a nice refreshment of Java and I really like interchangeability with it. I've had minor issues some features (like refactoring) in latest Android Studio beta. I would not push it too hard. Practical advantages are not that great and it will let you write nasty unreadable code much more willingly than Java.
Groovy does alright with most annotations I've tried.
I've had the opposite experience working on a JAX-RS application at work in Kotlin. Resources are super concise, interoperability being the way it is makes it feel almost refreshing. And I tend to loathe the Java EE stuff.
It works well with all of that. Just make sure you declare all EJBs as open or you use: plugins { id "org.jetbrains.kotlin.plugin.allopen" version "&lt;version to use&gt;" } Another thing you should use is https://github.com/FasterXML/jackson-module-kotlin. Otherwise all Objects which should get deserialized by a JaxRS Resource don't work with default values. You can build with maven now if you want to use apt, so no need to switch to gradle for that if you are not comfortable with gradle. Latest DCEVM / Jrebel works fine too. I use kotlin in an JEE B2B application deployed on openshift wildfly that is in production since 2016. One of my JEE Kotlin favourites are: Getting rid of ugly *.class on every entityManager call `inline fun &lt;reified T : Any&gt; findEntity(id: Any?): T? = if (id == null) null else em.find(T::class.java, id)` `val person = findEntity&lt;Person&gt;(id)` `val customer: Person = findEntity(id)`
I would recommend using [KTX](https://github.com/libktx/ktx), which provides Kotlin utilities for LibGDX. I myself don't have much experience with LibGDX nor with KTX, but I thought it would be helpful to share that.
You could mix and match: use Kotlin for low level stuff, but use Java for the service / wiring part of the application.
Working with Kotlin really requires knowing Java at this point, partially because of things like this where you want to be able to use Java documentation to help you. 
LibGDX and Kotlin work very well together even without the KTX utilities. You shouldn't run into any issues.
I've been using Kotlin with linGDX for a while now. I ended up writing a few math wrappers because I didn't like how GDX's vectors work (and didn't know of KTX when I started my project). Pretty smooth sailing so far. Only word of advice: if you try to initialize textures before your create function, you'll hit issues. This is less noticable in Java because you generally only do stuff in create(), but it's easy to take the Kotlin habit of doing things in init without thinking.
I've used libGDX with Scala, and it worked fine, so Kotlin should be easy. :) The only real challenge is translating the Java-esque build setup into a Scala/Kotlin one. That should be easier with Kotlin than with Scala, because Scala uses a completely different build tool.
Try to use kotlin plugin with jooq generated classes. It's going to be really slow even on really good development machine.
https://skia.org/ was created (or bought and then published) by Google for Android and Chromium. 
The game loop of LibGDX is itself modeled after the Android lifecycle so my guess is that it won't be hard. I've just written a little LibGDX poc for the library I'm working on and I can tell that it is seamless to use from Kotlin but I did not dig deep.
Is LibGDX for 2d only? How is its 3d support?
I didn't know about this. Thank you for sharing!
I appreciate you contributions to the kotlin community but it is incredibly hard to get a grasp of what is going on without sufficient documentation; reading the code is great and all but as someone with little spare time, I don't have the time to devote myself to reading it all to get a grasp for what's going on and possibly provide constructive feedback. Best of luck regardless :)
I hear you. I'll write a little more documentation to it when I have the time. Check out the other projects in the meantime and the whole TodoMVC stuff [here](http://todomvc.com/).
Wasn't this bought for use in Flutter (Dart framework for IOS and Android)?
You can actually further simplify the function fun getDrinkAuthorization(age: Int): String{ return if(age &gt;=18) "Authorized" else "Not Authorized"; } to fun getDrinkAuthorization(age: Int) = if(age &gt;= 18) "Authorized" else "Not Authorized" 
I'm a fan of further simplifying Bundle creation with [this snippet](https://gist.github.com/zachtib/58b4a94d05c4e3e3cb388536843acbd9), replacing: Bundle().apply{ this.putString("Key","value") this.putParcelable("parcelableKey", parcelable) } with: bundleOf("Key" to "value", "parcelableKey" to parcelable)
We are using Kotlin for one of our backend systems at one of the largest european banks. The backend serves account and financial transaction data for about 600k active users. It is a Spring (Boot) application that uses all the libraries and technologies we would also use if we would code in Java. This is not like many other languages on the VM, which bring their own SDKs, frameworks and idioms. You don't need to wait for any of your dependencies to support Kotlin, and you don't need to search for special "Kotlin Developers" if you hire. 
Agree. Another way would be to mimic a constructor: fun Bundle(vararg params: Pair&lt;String, Any?&gt;) = Bundle().apply { ... but this might lead to confusion as it's not *really* a constructor. A cleaner way would be to create an extension function to Bundle, such as Bundle.of(vararg params: Pair&lt;String, Any?&gt;) = this.apply {... and then just call it as Bundle().of("Key" to "value", "parcelableKey" to parcelable)
I am in favor of both being ordered and immutable. The idea is to enable JSON like structures in the code. Which JavaScript and Python both support. Why I want it? Because one thing I love about kotlin is DSL support and the amount of declarative programming that you can do with it. Having to always specify exactly what kind of collection you want goes against it.
I like `bundleOf(...)` because it mimics Kotlin's built in `arrayOf` and `listOf` methods
Is Javalin just a copycat of Spark? I'm not seeing a lot of differences. 