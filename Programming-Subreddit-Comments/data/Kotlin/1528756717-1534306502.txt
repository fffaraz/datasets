I use it with spring. Pretty amazing
I find it the exact opposite. There are some posts that directly compare Kotlin with Scala in some way (such as this one) but for the majority of Kotlin posts which are unrelated to Scala, I find a bunch of Scala people dismissing the posts and pointing us towards Scala. This would be expected in the Scala subreddit but these posts are typically in the Programming subreddit and some even in the Kotlin subreddit. Many Scala people respond very aggressively when faced with possible alternatives so the Scala community doesn't seem too friendly (but I wonder if this is the case of a small number of squeaky wheels which makes it seem like all the wheels need grease). Anyone that comes off as aggressive or less calculated is typically not taken seriously. Some Scala members would have you believe that Kotlin is worse than Java. The Scala community would probably be taken more seriously if they acknowledged the presented strengths from each post and then present the related strengths of Scala.
"golang is the most promising programming language among developers. " C for pussies, lol
Your whitespace in the autoconverted Kotlin code seems to be a bit messed up. Could you also post what the specific error message you're getting is?
From [methodology section](https://www.jetbrains.com/research/devecosystem-2018/demographics/): &gt; More than 15K people participated in the Developer Ecosystem Survey 2018, but only the responses of 6K respondents were included in this report. &gt; We used Twitter Ads, Facebook Ads, Google Adwords, and JetBrains' own communication channels to invite potential survey respondents to take part. To minimize bias, the reports only include responses coming from Twitter Ads, Facebook Ads and Google Adwords. From other surveys including my own informal surveys at meetups and conferences, about 80-90% of people use an IDE, usually IntelliJ, as their primary development environment
I think I do understand it well, but you already impose use cases that seam to be your focus somehow. Introducing persistent collection implementations as the default is (from my point of view, and seemingly from jetbrains' too) not the best decision, because using the jdk collections makes more sense (arguable, but this is the wrong place for this). The exact same use case you are describing can be done equivalent with Java and with Kotlin too. In Java, it's common to use some third party libraries like Guava or PCollections for interfaces and implementation, in Kotlin you could use kotlinx.collections.immutable, at least for the interfaces. Same example (i guess) in Kotlin: data class Person(val name: String) class MyClass(people: ImmutableList&lt;Person&gt;) { val peopleNames = people.map { it.name } } No matter how long I think about all those arguments, I always come to the same conclusion: The easy use of read only collection is fine for most use cases and Java interop, while there are also easy solutions for other problems. What am I missing here?
I think at least regarding variance, you get some advantages. But yes, I also see that there can be a lot of loss, if you don't get your usage regarding read-only and immutable not right. I would recommend to just think enough about what your APIs should demand - nothing stops you from using an ImmutableList if you want someone to pass exactly that in...whether it's Kotlin or Java or Scala. In Scala, you have the advantage of having those std things always in, but that should be a smaller problem for most people, since there are many implementations out there and a lot of interfaces for Kotlin and Java that you can use.
Thanks for sharing this insightful knowledge with us. This professional response really adds to the discussion. p.s. Although I never used golang and it's not my favorite language, that's no reason for putting down those that actually enjoy it.
&gt; What am I missing here? When programming in Scala, you have a totally different mindset than when programming in Java/Kotlin. In Scala, you usually write total functions that are referentially transparent, so you want the default to be immutable. That's all. To quote /u/cybernd: &gt; As long as there is the chance that someone modifies the collection, your whole immutability guaranty is falling apart
I want to belive that this is their goal
Hey, LouizFC, just a quick heads-up: **belive** is actually spelled **believe**. You can remember it by **i before e**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Not at home so can't give 100% error message. Says basically that AutoValue_ToDoModel doesn't exist. Believe in Java it gets made when you make project according to book which is true since when I load up the example in Java it works.
And then came reflection and busted us all. Just a joke, but I think you got it. I'm talking/Kotlin is about the best compromise. In most cases, there is no need to have something else than the standard List interface...it's only a problem when people start casting to implementations (I won't comment this one), or if you take it as input while you didn't want to have a read only list but a truly immutable list. I suggest that people start thinking about how their signatures should look like and what input types they accept. Using immutable data structures should be a very precise choice, because it can complicate a lot of things too, especially if you and your staff aren't comfortable with some kinds of concurrency, or eventing when immutable collections are altered... you're talking about mindsets, but then people have to realize that there are different mindsets for others as well, that maybe aren't "dumb", but just "different", or with a different focus.
I wonder: will we see a future, where such discussions are already resolved? Use GC as example. In its early stage, everyone ranted against it and nowerdays most languages are GC based per default. Most programmers are not longer thinking that the GC is a burden. Could it be possible that we reach a point, where reducing side effects is far more important than the performance implication coming from immutability? ZFS might be another interesting example: COW based filesystems are reliability first. Many companies are already using it as default storage, even if there are still use cases where its not reasonable because of its performance implications.
Im a bit lazy so i didnt even red the code bude i assume that its AutoValue model class. Kotlin data classes are pretty much replacement with both auto getters, setters, builders via copy method, equals and hashcode. For a while some of the people used them also in Kotlin because of easy Parcelable generation but nowdays Kotlin support this as well. I recomend to reimplement this with simple data class ToDoModel(val isCompleted: Boolean, val description: String etc. ) You should be able to use AutoValue library if you really want to so just google how to use AutoValue in Kotlin.
&gt; And then came reflection Reflection is almost never used in Scala (we prefer compile-time mechanisms, which the language is expressive enough to enable), and certainly _not_ to perform this kind of things. You know, you can actually ruin a program's correct execution in many ways (e.g., press your computer's power button), I don't know what's the obsession with reflection, which is just one of them.
üòê.. so basically all I had to do was Google data classes and autovalue. Thanks for the help. Was tad tired I should of thought of that.
Actually I think you'll find it's only 80% so I have to Korrect you.
Elastic4s and pulsar4s and http4s on Scala. I wonder if clojure have log4c.
They are high-profile software. I don't think they would move (even gradually) to another language if it was just a "new name".
JetBrains has developed Kotlin to be more productive and to reduce bugs. I think that is interesting for other companies too. And, yes, Kotlin is better than Java in many aspects.
Kotlin is just far better Java. Try it, you will love it
Because it's a better, safer and more enjoyable language. Evidently, you can do the same functionalities with Java. Furthermore, everything is equivalent to assembly in the end. But it's all about the developer experience.
try to ask the same question in /r/Java and you'll get different answers :)
Because it's the same ecosystem and language with syntactic sugar. You get Java and more, so why use less?
[removed]
[removed]
[removed]
This was a simple example to show you, that all your correctness can get busted somehow. This is the reason why people use different shades of correctness. It's not because we all like reflection that much, but it is simply there if you are on the JVM. Your quote &gt;As long as there is the chance that someone modifies the collection, your whole immutability guaranty is falling apart really fits in here, right? So all in all, I'm just confused why people think immutable collections is something that only Scala has...I automatically have to assume that those people are way to arrogant realizing that other languages are able to do the very same things, with a few exceptions (I have absolutely no problem to admit). And that not everyone agrees to always apply the same principles like them in every place, while it's **not** because they didn't understand it.
Would be best to list all the aspects it is better
Here is a [comparison of Kotlin and Java](https://kotlinlang.org/docs/reference/comparison-to-java.html). You can search for [Kotlin vs Java](http://lmgtfy.com/?q=kotlin+vs+java) to find more comparisons. 
&gt;The control flow in Spring applications, especially those sprinkled with AOP, is impossible to follow It's not. &gt;Does any developer really need an annotation processing runtime codegenerator to make a fucking REST endpoint? Spring MVC does process annotations but it doesn't generate code. Spring Webflux can do the trick even without annotation processing. &gt;not to mention actually good languages. And what are "actually good languages" for you?
&gt; Spring MVC does process annotations but it doesn't generate code. Spring Webflux can do the trick even without annotation processing. Spring AOP generates bytecode. Spring IoC Container generates runtime proxies for everything. &gt; And what are "actually good languages" for you? Not the kind that need a framework on top of framework of brittle runtime reflection and annotation processing to deal with even the most basic tasks.
&gt; Your quote [...] really fits in here, right? There is a difference between abusing the arcane capabilities of a language's runtime, and using a public interface the way they were intended to be used. It's all about what a _language and community_ encourages and sees as good practices. Same reason Scala doesn't need special `null`-handling mechanisms, because people normally don't use `null` in Scala. &gt; I'm just confused why people think immutable collections is something that only Scala has That is not what people think.
Because on r/java most of the people are backend developers and Java EE developers. When you're used to writing 10000 loc classes it's hard to transition to a language as concise as kotlin.
I've heard of 5, 6, 7 and 9. I've also heard of Scala and Haskell but have no details about them at all. #5 is R language. Again no details, but I've seen it on many places and ads. #6 is Kotlin. And you've got to be kidding me if you say you don't know Swift and Go. #7 Swift is the major programming language used for iOS app development. Why do you use Kotlin? Just like Kotlin is the official programming language for Android. Swift is the official programming language for iOS devices. #9 Go is the sole programming language of Google. Man you are either 15 year old or you're a real noob that you're subscribed to Kotlin subreddit but you don't even know he names of these basic programming languages.
Take my upvote man. You just stole my words.
Hi! I'm primarily a backend dev and I'll take Kotlin over Java any day. And I hate the 1_000+ line classes too, regardless of the language. 
Playing with Kotlin made me fall in love with programming again.
Kotlin isn't going to revolutionize your development experience, but it's a very nice upgrade. It gets rid of a lot of the inconveniences and tedium of Java, helps you write better, safer code, and provides some features that Java doesn't have at all. Some of the things I like: * Variables by default cannot be null, so NPEs are less common. Sure, you can write Java code that is "null-free" but it takes discipline. Kotlin gives it to you for free. * Full interoperability with Java. This means the entire ecosystem of Java libraries and frameworks is at your disposal. * Relating to the above, Spring has introduced support for Kotlin with the release of Spring 5, in the form of conveniences that allow for more expressiveness/conciseness. * The concept of "data classes". Basically, a POJO with extremely reduced syntax. A one-line `data class Name(val first: String, val last: String)` is the equivalent to a Java class with fields, constructor, getters, toString, hashCode, and equals methods. One line versus about 30. * Type inference. Write `val name = Name("Elon", "Musk")` or `val name = getName()`. * Classes and methods are `final` by default. You want inheritance, fine, but you have to explicitly allow it. This might seem like an odd decision, but it's a good one as it affords the opportunity to stop for a moment and think, "is inheritance *really* the right answer here?" Too many Java class hierarchies are a muddled, jumbled mess of code reuse and "is-a [base class] except these 5 methods that completely change the behavior of the class in unexpected ways and another 15 methods that add completely new behavior -- so you'd better be ready to do a lot of casting". Read up on the fragile base class problem. * First-class support for functions and functional composition. Mix object-oriented and functional paradigms in the same codebase. Use "extension functions" to add capabilities to an existing class -- useful when you don't have its source code, and to avoid inheritance. E.g. `fun String.firstUpperCase() : String = this[0].toUpperCase() + this.substring(1)` * Better generics. I can't easily describe this in a couple sentences without assuming you understand things like "use site variance" and "contravariance". So I'll point you to https://kotlinlang.org/docs/reference/generics.html. * Support for properties. https://kotlinlang.org/docs/reference/properties.html. There's more but I'll stop there. And if you want to give it a try, check out the koans online at https://try.kotlinlang.org/#/Kotlin%20Koans/Introduction/Hello,%20world!/Task.kt. 
I heard that Kotlin is difficult to adopt using Spring. Is that true?
It's a rather poorly worded question and one that can easily be answered with a few minutes of Googling, but you don't need to act like a condescending prick. 
[removed]
Not in my experience. The teething pains I had were related to learning "the Kotlin way", or proper syntax required to interoperate with Java code, which you'll have any time you mix Kotlin and Java. So I'd phrase it "you'll have to learn the proper syntax when using Kotlin with Java libraries and frameworks such as Spring or RxJava".
Well even IDEA understand java code better than kotlin and there is no other IDE you can realisticly use currently. Ye notepad always works. Also sadly gradle kotlin dsl is still garbage :( What we need is more support ofc for that we need more people to use the language (youdontsay). Still the language itself (syntactic, features) is better.
Establishing a platform is part of the whole thing, so I don't get why people complain if some other people do it just right... If they would want to, every big player could back Scala as intensive as Jetbrains backs Kotlin \- even Jetbrains itself, as they support it with their IDEs. Guess why they don't do? Because they chose not to do. The reason why Groovy is not going to be any more successful despite backed by a big player some time ago. And to the topic: Having nice presentations and articles about people actually using Kotlin native and how much they like it (honestly) is the thing that makes **me** believe that at least now, people prefer Kotlin native over Scala native. If not, where are the people posting about it, where are new presentations how easy it is to use common modules, one of the biggest pain points so far? Some people have success just because they deserve it, not because it is marketing.
I can't remember a Scala project (although I have to admit that there aren't too many in my reach) where people wanted to use gradle over sbt...and I don't remember any Scala person leaving a good word about groovy, so yea... you get the idea.
Yes, it is.
No, I think we talk about principles here, which you apply one time correctly and one time not. Than where should the difference be? The interface defined in the std? The Kotlin example shows clearly, that the intent to accept a immutable collection can be implemented exactly in the same way as you showed with the Scala example. I think every developer is able to add a dependency, just like for other things that are not considered a necessary part of the "std", like advanced reflection utilities in Kotlin, and use the appropriate immutable interface. Having everybody always use immutable collections doesn't give you an advantage - applying them in the right spot is what matters. I honestly don't know what we are still discussing here. The only difference is a dependency and most probably the maturity of the implementation (I don't know to be honest). Saying that it has anything to do with the language is... I dunno, just ridiculous.
&gt;Spring IoC Container generates runtime proxies for everything. It's not true at all. &gt;Spring AOP generates bytecode. I can't understend how does Spring AOP linked to Spring MVC or Spring Webflux. You're switching topics. &gt;Not the kind that need a framework on top of framework of brittle runtime reflection and annotation processing to deal with even the most basic tasks. So you're afraid to tell us, ok.
We use Gradle to build a mixed Scala and Java monorepo at my work. We use https://github.com/gradle/kotlin-dsl instead of Groovy for our Gradle build scripts.
You can start off a spring-boot project just as easily you would in java - by generating a base project from https://start.spring.io. And if you are talking about existing project, you can start using kotlin alongside java by simply adding a dependancy and do 'convert to kotlin' in intellij (start with data classes)
Wow nice. We have a maven project using Scala and java at the same time, worked okayish. Besides, I didn't make a good experience with kotlin instead of groovy for gradle builds. Mind to share your experience and/or problems you encountered?
Using Kotlin was tricky at first with some parts of the Gradle DSL missing, but the latest version of the DSL is more complete. It also helps to put most of your build logic in buildSrc, defining either functions that take a Project argument, or defining Plugin classes. https://zeroturnaround.com/rebellabs/using-buildsrc-for-custom-logic-in-gradle-builds/ If you go the plugin route, you could even write the plugins in Scala as well.
But doesn't it have problems with translating classes using Lombok e.g.?
Pinterest has done talks on why they like Kotlin: https://youtu.be/mDpnc45WwlI
Apparently yes - after looking at some StackOverflow posts. I never used Lombok much, so did not face this. I think it would be best to avoid using Lombok altogether if moving to Kotlin, because Kotlin does not have a lot of boilerplate to eliminate anyway. Would like to get any thoughts on this from any lombok users.
&gt; It's not true at all. Bullshit. It's enough to look at any Spring app's stacktrace and count the ratio of actual application's classes to Spring's generated classes. &gt; I can't understend how does Spring AOP linked to Spring MVC or Spring Webflux. You're switching topics. Spring MVC [directly depends on](https://search.maven.org/#artifactdetails%7Corg.springframework%7Cspring-webmvc%7C5.0.7.RELEASE%7Cjar), and is built using Spring's AOP. You're never using Spring without their codegen, you'd know that given any curiosity about the framework you're using. &gt; So you're afraid to tell us, ok. You've asked `what`, not `which`. If you want examples: Scala, Haskell &amp; Rust are `good` compared to Java/Kotlin.
Companies care about quality and reducing defects since they spend many resources dealing with these. Here's an article showing over 25 types of defects (grouped into 6 themes) that are avoided: [https://proandroiddev.com/kotlin\-avoids\-entire\-categories\-of\-java\-defects\-89f160ba4671](https://proandroiddev.com/kotlin-avoids-entire-categories-of-java-defects-89f160ba4671) Companies also care about productivity which Kotlin has a large impact on: [https://proandroiddev.com/kotlin\-a\-massive\-leap\-forward\-78251531f616](https://proandroiddev.com/kotlin-a-massive-leap-forward-78251531f616)
I think using Kotlin for new projects is definitely a great idea but migrating big projects could cause a lot more headache than it's worth. Could be a lot easier though if the project was based on microarchitectures.
&gt;Bullshit. It's enough to look at any Spring app's stacktrace and count the ratio of actual application's classes to Spring's generated classes. [This](https://pastebin.com/NLTWrjgY) shows me that: &gt;Exception in thread "main" java.lang.RuntimeException &gt; at com.example.SomeService.someMethod(TestForReddit.kt:9) &gt; at com.example.TestForRedditKt.main(TestForReddit.kt:19) Where's runtime generated proxies? &gt;Spring MVC directly depends on, and is built using Spring's AOP. Because Spring AOP is one of the core modules. And [this](https://pastebin.com/2QxHxd8d) shows me that (called with get request): &gt;java.lang.RuntimeException: null &gt; at com.example.SomeService.someMethod(TestForReddit.kt:32) ~[classes/:na] &gt; at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_111] &gt; at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_111] &gt; at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_111] &gt; at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_111] &gt; at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:209) ~[spring-web-5.0.6.RELEASE.jar:5.0.6.RELEASE] &gt; at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:136) ~[spring-web-5.0.6.RELEASE.jar:5.0.6.RELEASE] &gt; at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:102) ~[spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE] &gt; at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:877) ~[spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE] &gt; at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:783) ~[spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE] &gt; at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE] &gt; at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:991) ~[spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE] &gt; ... tomcat's stacktrace Can't see any aspects or generated code. Just one reflection call. &gt;If you want examples: Scala, Haskell &amp; Rust Show me the way make "a fucking REST endpoint". Simplier than Spring with Kotlin provides.
üé∂ HARDER, BETTER, FASTER, STRONGER üé∂ 
Java has improved a lot. The main problem being Java 8 and higher versions cannot be used in Android because of licensing issues. This IMO is the single biggest driver of Kotlin because Java 7 is just bad. If the higher versions were allowed, the impact of Kotlin would have been far lesser. Java 8,9,10 have improved a lot upon it but still not that good as Kotlin. This can be seen in the fact outside of Android ecosystem. There has not been much enthusiasm for Kotlin outside of Android.
Jake Wharton gave a talk around the time 1.0 was released that highlighted some pretty good reasons why Kotlin was good for Android. The TLDW version is that Java on Android is pretty much never going to be up to date with current Java. At the time of the talk, support for things like lambdas weren't even possible without using an outside plugin. He did highlight that it was possible to get close to current functionality of Java using libraries and plugins, however, most of that comes right out of the box with Kotlin. Basically, Kotlin allows Android developers to live in the now. Google gave it first class citizen status last year, so they clearly saw some sort of benefit to the developer community. 
&gt; Here's an article showing over 25 types of defects (grouped into 6 themes) that are avoided: "Unlike Java, an assignment is a statement in Kotlin (which does not evaluate to a value) so it cannot be used in a condition." I actually find this to be one of the only things about Kotlin I don't like. I hate the fact I can't assign a variable in a condition, makes reading from InputStreams and the like unwieldy. 
&gt; The only difference is a dependency and most probably the maturity of the implementation No, the difference is in which mindset a language/ecosystem encourages. As you've said, we're not going anywhere, so I'm going to stop answering you now.
This comment is stupid and wholly inaccurate. Not sure how a troll comment is getting upvotes. Most java programmers immediately see the benefit of Kotlin when they first use it. No one likes writing thousands lines of code when a few will do. What kind of apps are Kotlin programmers writing? 
Try it out for yourself. You'll understand why.
You could just write new classes in kotlin and leave the java stuff. Or slowly migrate the java classes as you touch them. No reason you have to do a wholesale migration of your java code to kotlin all at once.
Wow sorry didn't mean to trigger anybody. I'm just speaking from my personal experience. Most of Kotlin developers I know use it only for Android. And migrating from Java to Kotlin is difficult in big backend projects because many libraries are still not compatible.
I kinda dislike these kinds of sentiments. I'm a Java "EE" developer, worked at banks, etc. I'm a huge Kotlin fan. The people who bitch and moan about Kotlin are the same that bitch and moan about the new Java 8 goodies. Some people just resist change. I'm sure there are Android devs who strongly dislike Kotlin too. 
Not at all. Works really well together, especially in Spring 5/Spring Boot 2. 
Idea is pretty much fantastic with kotlin code. Sure, Java support is more complete (more inspections and intentions etc), but seriously, what do you expect from a 20+yo language that also happens to be the language the IDE was originally develops for vs a new, more complex language that is just getting traction? It works great and I'm not missing anything major, not sure what you're complaining about. About other IDEs, yep, fair point. Eclipse would be your next best bet, I guess, but I think the support there is not far beyond "the basics work". Problem is, jetbrains has no incentive to bring the language to other IDEs, and from what I gather the existing Java Community is mostly on IntelliJ anyways.
Huh, what libraries are not compatible? Pretty much everything Java is compatible with Kotlin, haven't found a case yet where something wouldn't work after some patience figuring it out. Standard JavaEE works perfectly fine with Kotlin. Migrating to kotlin really is not difficult even on backend. IntelliJ does most of the work for you, and you can switch one piece at a time, you can keep most of your codebase untouched for as long as you want.
Where I work we have most of our services in kotlin and spring. works perfectly. 
&gt;And migrating from Java to Kotlin is difficult in big backend projects because many libraries are still not compatible. That is blatantly false. We use Kotlin with spring from Spring boot 1.x admittedly way better with spring boot 2. I cannot think of any legitimate reason except preference in which switching to Kotlin would be difficult. 
&gt; And migrating from Java to Kotlin is difficult in big backend projects because many libraries are still not compatible. What? From this comment and your previous comment you obviously have no idea what you are talking about. Kotlin provides java interop, you can use all existing libraries. 
&gt; This shows me that: You're not defining a REST controller or using any Spring annotations. &gt; Because Spring AOP is one of the core modules. Yes, exactly what I'm talking about. &gt; Can't see any aspects or generated code. Just one reflection call. Add a `@PreAuthorize`. And don't tell me you're writing apps without authorization. &gt; Show me the way make "a fucking REST endpoint" with any of those languages. Simplier than Spring with Kotlin provides. Don't think you can get any simpler than [that](https://pastebin.com/uPP5sJEK). And guess what, all of these languages actually have useful DSLs and metaprogramming tools, so they don't need a runtime-interpreted stringly-typed language-within-a-language abomination that is SpringEL.
Lombok
Kotlin is an Object Oriented language, Scala is also a Functional Programming language. So if you want to do old fashion Object Oriented do Kotlin, if you want to do Functional Programming use Scala or Haskell. Again I repeat: Object Oriented &amp; Functional Programming =\&gt; Scala Object Oriented Programming =\&gt; Kotlin So when people tell you "Kotlin is Scala without the bad parts", they actually mean "Kotlin is Scala without Functional Programming", because they didn't get this paradigm. 
Me too.
Firstly, there‚Äôs no reason to use lombok if you have kotlin - that‚Äôs the first thing you should port. Secondly, no backend project I have any authority over uses lombok, since unstable and undocumented bytecode manipulation is not a good thing to have in your mission-critical services. Immutables is a much better option. 
Non-null-by-default immutable-by-default values are reason enough to use kotlin imo. I don‚Äôt know if java will ever get those features. 
Non null by default and immutable aren't big deals even if Java is not getting them. 
If I could make any changes to java, at all, with no limitation, they would be the first two. 
Things that are simple in Java are still simple in Kotlin. Things that are tedious in Java are a lot less tedious in Kotlin. This is anecdotal, but I find it much easier to see someone else's intent when reading Kotlin over Java.
Yep, that pretty much covers my thoughts on lombok as well. No reason to use it with Kotlin, and even with plain Java that's something I'm deliberately staying away from.
It's more enjoyable to program in Kotlin than in Java. There's no down side what so ever. Kotlin has _more_ features than Java, not less. It's still statically typed, so you don't even lose the compile time type checking. 
Here is an excellent demo repo that demonstrates idiomatic Kotlin/Spring Boot development. https://github.com/sdeleuze/spring-boot-kotlin-demo
**TL;DR:** * Updates Kotlin support in the Eclipse IDE plugin * Adds new functions in common and JS parts of the standard library * Brings JUnit 5 support to kotlin.test * Improves experimental scripting support * Introduces Runnable Kotlin scratch files in IntelliJ IDEA * Speeds up kapt and building multimodule Android projects with Gradle * Updates experimental @JvmDefault support with a binary compatibility mode * Introduces a progressive compiler mode * Fixes a lot of known issues in the compiler and the IDE plugin and provides performance improvements 
Yes, so delombok first then convert to kotlin.
I'm a back\-end developer and there is huge excitement about it at my workplace. Companies are taking Kotlin seriously due to the improved productivity and reduced defect rates. There was a talk last year from a JetBrains representative mentioning that Kotlin adoption is roughly a 50 / 50 split between Android and JVM backend development.
&gt;"Kotlin is Scala without Functional Programming" Kotlin has a bunch of functional programming capabilities. This clearly shows that you don't even know the Kotlin basics so you are not qualified to compare them.
By the way, am I the only one having this issue when using newer Kotlin compiler versions (Maven) while incremental compiler is enabled? [WARNING] Using experimental Kotlin incremental compilation WARN: Failed to initialize native filesystem for Windows java.lang.RuntimeException: Could not find installation home path. Please make sure bin/idea.properties is present in the installation directory. This breaks incremental compiler, older Kotlin compiler Maven versions didn't have this issue.
There are very few applications where Java offers more than kotlin. In trivial game development for example its clearer to declare and use a multidimensional array in Java to represent a chess board. Java also has C-style for loops which is simpler to use when none of the Ranged/Enhanced/Iterated for loops work. Kotlin is superior in most applications such as app development but Java still has it's uses. It's better to choose the tool most appropriate for the problem. Something about Hammering things that aren't nails.
Yeah personally I ditched java upon rewriting a part of my current project to use kotlin rather than java. It just provides a much better experience than java. Also coming from python roots, glad I no longer need semis as I ALWAYS forget it when switching to java. Another part of kotlin I love is being able to create infix functions as well as overload operators (python ‚ù§Ô∏è), I just hate seeing stuff like object.isEqualTo(other); when you could do object == other kotlin is a blessing to my soul 
Java is and always has been hot garbage and Kotlin fixes everything wrong about it.
&gt; When you're used to writing 10000 loc classes it's hard to transition to a language as concise as kotlin. Ridiculous.
Those are nice features I agree, but they aren't "I am going to change my language' level features. Java has to move slowly because of it's large and legacy user base. The problem of every language at it's level. Oracle is stepping up th game, but there is a lot of space for improvement
I thought Android N or later uses Java 8.
[removed]
[removed]
I use Kotlin with Spark + Databricks. It never crossed my mind to use the baroque abomination instead.
Bit fiddling is much better in Java than in Kotlin, that's for sure.
That's another one I forgot. Bit flags aren't used often but when it's necessary there's not a lot of substitutes you can use.
I like kotlin from what i've Seen, but i agree with &lt;type&gt;.of being neater
That's a very nice little demo, I like it! I'd suggest a couple changes: 1. Your unit test is more of an integration test as it spins up the entire application and executes a test against it. I like unit tests that exercise business logic and integration tests that exercise a component or application. (In both cases, there's nothing remote -- no REST/SOAP calls or calls to a remote database. That's for end-to-end tests.) We have separate `integTests` and `test` folders for integration and unit tests, respectively. Both are executed with our CI build but in normal development we typically run unit tests "all the time" and then run the integration tests before pushing (and sometimes during development). This has worked well for us. 2. Maybe find a way to add a bit of business logic. Something that lets you demonstrate CQRS and good separation of concerns between the controller and business logic. This goes hand-in-hand with the above -- integration tests are for the app/controller and unit tests for the business logic. IMO the above changes would make it a better guide/demo. Nice intro though. 
Unfortunately, it is not my demo code, but Sebastian Deleuze, who is responsible for driving out a lot of the Spring-Kotlin compatibility from the Spring side. His Github profile is full of excellent Kotlin demo repositories. On a side note, I am glad that you have found a testing strategy that works well, sounds very sensible to me.
I'm not saying that the marketing is bad in and of itself, just that it modifies the perception without it necessarily being based in fact. I'm just a little jealous.
There is an interesting juxtaposition between Clojure and Scala. I just watched the video you linked and [here](https://youtu.be/TS1lpKBMkgg?t=467) he says **"Many, perhaps most bugs arise from entanglements with state and time"**. In [this talk](https://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey) Rich Hickey talks about time and state and how lack of time management causes a lot of problems with state and how Clojure solves them. It is a very good talk, I recommend it after the one above.
I'm really glad the eclipse plugin gets some love :)
It's a shame that it's so expensive.
That's a pretty normal conference price. What price would be not expensive for you? 
Well I haven't been to many conferences so maybe I don't know shit, but to me that is just expensive. 520 euros not including travel, accommodation and food. For that kind of money you can go for a full week of vacation somewhere nice.
That might be, but most people that go to conferences are there through their employer, not out of their own pocket. But expensiveness is relative. Do you have any example of a conference of this size that is cheaper?
I really want to understand why everyone insists on comparing swift and kotlin. Try as I might, I can't find anything other than wanting clicks, karma or reads. The comparison here focused more on android gc which has nothing to do with kotlin. Nor does it go on to say anything about the other compilation targets of kotlin and how their memory management works. I just left a job a month ago and a long time friend of mine had to stop working on the iOS team to help fill the gap I left behind. When I ask how he likes kotlin and Android he states early in the response that memory management is much nicer. Other items in the list include everything from Gradle being the transparent customizable build system apple should be using all the way down to how much nicer kotlin generics are when compared to things like protocols with associated types. His plan now is to stay working in kotlin for two more years until swift can clean up it's act. This from a huge swift proponent and probably the most avid apple fan boy I know. So if you want clicks, reads or whatever, maybe try some sort of sensationalist bashing piece about swift being yet another failed attempt at a silver bullet?
Yes, it would be even nicer, if multi platform projects were supported, because with Eclipse all the platforms can be managed in one IDE.
Yeah I don't get it either. It's not like you can switch one out for the other in real-world situations.
Yeah, some people even tell me that Java 8 is a functional programming language :D Lets be honest, Kotlin is not a true Functional Programming language, it doesn't even support Type Classes. Someone said here: &gt;Scala has so much Functional Programming in it's DNA compared to Kotlin that if you are a fan of FP it's hard to even consider switching.
It would have more sense if you were comparing Swift and Kotlin **Native**, both use LLVM atleast.
I agree that the Java 8 functional capabilities are very lackluster. Here are some Kotlin functional capabilities: * Functions are first class citizens (eg. store it in a variable) * Propper lambdas. Kotlin lambdas are also closures * Higher order functions (this alone is a huge functional programming capability) * Tons of built-in functional utilities (eg. map, flatmap, fold, etc.) I found a tutorial about Type Classes (since I'm not familiar with the concept): [https://blog.scalac.io/2017/04/19/typeclasses-in-scala.html](https://blog.scalac.io/2017/04/19/typeclasses-in-scala.html) And at the end of the day it seems like all that jumping through hoops in the tutorial gets you the capability of Kotlin's extension functions (extension functions can also be defined using Generics). It probably has additional use-cases as well since I'm not familiar with that but the tutorial demonstrates a bunch of additional complexity which is so much simpler to achieve with extension functions. Lastly, the Arrow library actually adds support for Typeclasses in Kotlin (plus more): [https://arrow-kt.io/](https://arrow-kt.io/)
can my types have types?
Or maybe it's just interesting for ppl who enjoy learning about technology?
You‚Äôd be amazed just how much it costs to run a conference for several hundred people. Consider speakers‚Äô expenses, venue hire, catering, Internet, video recording... the price is quite a bargain. 
That is Java man, not Kotlin!
This is really useful. One question, what does the comment "TODO make the jar public" mean if it's available in Maven?
Trying it out now for my Android app. One thing that's bothering me, why is a relaxed mock not the default behaviour? Or can't you at least not expect an answer for mocked method calls that return Java void or Kotlin Unit/Nothing?
Like I stated in /r/androiddev: --- Whereas Square's Ray Ryan [explicitly states](https://youtu.be/KjoMnsc2lPo?t=32m38s) that "there is no reason for anybody to open source a finite state machine library, they're just that easy to write". I guess that was secretly a cue for anybody to write a finite state machine library.^/s It's even a [single File](https://github.com/Tinder/StateMachine/blob/master/src/main/kotlin/com/tinder/StateMachine.kt).
Relaxed mocking not by default is a design choice. 1. relaxed mocks not always works well with generic type returning functions 2. returning arbitrary results is error-prone technique. Anyway choice is made. a lot of fans of this aproach and it is not possible to change it. you can always create alias fun for relaxed mock to be default mocking. DSL requires you to state a full phrase: every bla-bla-bla returns something. For Unit you do have `every { ... } just Runs` There was one or two tickets regarding returning void and they were fixed. If you want me check please submit some minimum code that fails here: https://github.com/mockk/mockk/issues
Already, I've opened an issue: [https://github.com/mockk/mockk/issues/91](https://github.com/mockk/mockk/issues/91)
\&gt; [The original author](https://github.com/georgewfraser) created this project while he was considering using Kotlin in his work. I usually do a hello world followed by a todo list. Now I feel like I should step up my game.
Nice work! Are you looking for a code review regarding following the style guide and taking advantage of more Kotlin capabilities?
Yes definitely I would really like that :-)
Cool, here are a few suggestions (don't feel obligated to follow them). I'll post a comment per package so that they're short &amp; meaningful (especially if some of them generate any discussion) com/jodge/movies/util package: **ActivityUtils.kt** * Each parameter should be on a separate line if the signature doesn't fit on 1 line: * [https://android.github.io/kotlin-guides/style.html#functions](https://android.github.io/kotlin-guides/style.html#functions) **RxUtils.kt** * The if-statement: Kotlin doesn't enforce semicolons at the end of lines so a new line has significant meaning. To avoid surprises, braces are always required unless you can fit the entire statement on 1 line: * [https://android.github.io/kotlin-guides/style.html#braces](https://android.github.io/kotlin-guides/style.html#braces) * The for-loop: This would be simpler (without losing any performance) if written as: subscriptions.forEach { unsubscribe(it) }
 com/jodge/movies/util package:**ActivityUtils.kt** * Each parameter should be on a separate line if the signature doesn't fit on 1 line: * [https://android.github.io/kotlin-guides/style.html#functions](https://android.github.io/kotlin-guides/style.html#functions) **RxUtils.kt** * The if-statement: Kotlin doesn't enforce semicolons at the end of lines so a new line has significant meaning. To avoid surprises, braces are always required unless you can fit the entire statement on 1 line: * [https://android.github.io/kotlin-guides/style.html#braces](https://android.github.io/kotlin-guides/style.html#braces) * The for-loop: This would be simpler (without losing any performance) if written as: subscriptions.forEach { unsubscribe(it) } 
com/jodge/movies/api package: **ApiModule.kt** * The provideBaseUrl function can be written as a single line: * `fun provideBaseUrl(): String = "`[`http://api.themoviedb.org`](http://api.themoviedb.org)`"`
com/jodge/movies/data/models/response package: **ApiResponse.kt** * Does the generic type T have any bound? Note that the current implementation also allows null values (not sure if this is on purpose). If you want to allow any class except for nulls then you would declare that as: * `class ApiResponse&lt;T : Any&gt;`
com/jodge/movies/data/models package: **Movie.kt** * The getPosterUrl function could be written as a single line: * `fun getPosterUrl(): String = "${Constants.BASE_POSTER_PATH}$posterPath"` * The writeToParcel function: * This is somewhat misleading since it doesn't actually write anything if the destination parcel is null. It seems like the only valid thing to do is to throw an exception if it is null therefore I would declare the "dest" parameter as "Parcel" (not nullable) and Kotlin will ensure this to be true (at runtime) and also remove the safe calls. * Since we're repeatedly calling a function on the same variable, this would be cleaner as: * Note that if dest really is nullable then you could add a `if (dest == null) return` before all of this which automatically smart casts it into a non-null type after the if statement. Alternatively you could also use dest?.let { it.writeString(id) ... } but you would have to keep repeating the "it" lambda parameter so it's not quite as clean in this case. with(dest) { writeString(id) writeDouble(voteAverage) writeString(title) ... } **Review.kt** * Same comments as Movie.kt **Video.kt** * Same comments as Movie.kt for the writeToParcel function * The class header declaration formatting should follow this style: * [https://kotlinlang.org/docs/reference/coding-conventions.html#class-header-formatting](https://kotlinlang.org/docs/reference/coding-conventions.html#class-header-formatting) * The getUrl &amp; getThumbnailUrl functions: * Need to use braces (since they don't fit on a single line) * You can use the "if" as an expression so that you don't need to repeat the return statement. Eg. `return if (a &gt; b) a else b` * Or you could replace that with a when expression: return when { SITE\_YOUTUBE.equals(video.site, true) -&gt; String.format(...) else -&gt; Constants.EMPTY }
Alternatively, `subscriptions.forEach(::unsubscribe)` for the loop in RxUtils
com/jodge/movies/data/persistence package: **Movie.kt** * The first parameter &amp; annotation should start on a new line * The parameters are indented too much (because of that first parameter) * The closing parenthesis should be on a new line [https://kotlinlang.org/docs/reference/coding-conventions.html#class-header-formatting](https://kotlinlang.org/docs/reference/coding-conventions.html#class-header-formatting) **MovieDataSource.kt** * Each function probably fits on a single line by using the expression syntax: * eg. `override fun findAll(): List&lt;Movie&gt; = movieDao.findAll()`
Thanks this is eye opener. I am going through then then I'll update the code. Thanks
com/jodge/movies/di package: **AppModule.kt** * The provideContext function can be written on a single line: &amp;#8203; fun provideContext(): Context = application **RoomModule.kt** * The functions in here could probably also be converted to single-line functions
com/jodge/movies/network package: **NetworkModule.kt** * The provideGson function could be written as a single line &amp;#8203; fun provideGson(): Gson = GsonBuilder().create() * The if expression in the getInterceptorLevel function needs braces since it doesn't fit on a single line
&gt; Movie.kt The getPosterUrl function could be written as a single line: ‚Äã fun getPosterUrl(): String = "${Constants.BASE_POSTER_PATH}$posterPath" To follow up on this, this could be actually declared as a property and it would make much more sense when calling it: val posterUrl: get() = "${Constants.BASE_POSTER_PATH}$posterPath" 
Determinant buddy respect for your effort.
Well, apparently John Carmack implemented Wolfenstein 3D in Haskell for his hello world, so... yeah. 
That would work but it fails the styleguide requirement of only using the property syntax for constant time operations (which string concatenation fails). The main problem with it is that users typically store function call results in a variable when used multiple times whereas properties typically aren't cached like that.
Thanks üòÄ. I'm hoping this helps increase adoption
I would even say go 1 step further and use type inference
/r/beetlejuicing
Submit a PR to remove that line and find out for us :)
I didn't know about extensions, this is a good feature. What I personally like with Scala is that it has a very small set of features, probably smaller than Kotlin. Here are the features I think are missing in Kotlin: \- Heterogenous list (val hlist = HList("hey", 23, true)) \- Refined types (val port: Int Refined Port = 8080 or val color: String Refined Color = "#000000") \- Implicit parameters \- A better pattern matching
Nice work! great review comments :)
&gt;Thanks this is eye opener. I am going through then then I'll update the code. Thanks
love the name
If you use data classes with default values, Moshi does the right thing but Gson gives unexpected results that can trigger hard to find bugs. I ended up switching a few days ago when I discovered that Gson was setting string properties to null when they were not provided: data class User(val name: String = "no name provided", val age: Int) would end up as JSON: "{age:50}" Gson Result: User(name = null, age = 50) Moshi Result: User(name = "no name provided", age = 50) The docs were a bit confusing, so a quick example is: // build.gradle: dependencies { ... implementation 'com.squareup.moshi:moshi:1.6.0' kapt 'com.squareup.moshi:moshi-kotlin-codegen:1.6.0' ... } // MyApp.kt: @JsonClass(generateAdapter = true) data class User(val name: String = "no name provided", val age: Int) fun jsonToUser(json: String): User { val adapter = Moshi.Builder().build().adapter(User::class.java) return adapter.fromJson(json) as User }
Seems like a pretty big deal, hasn't AirBnB been one of the poster children for React Native?
These frameworks almost *never* work. They have their place for smaller players who just want an app store presence but beyond that they're never worth it. I expect more bigger players to follow suit.
Yeah well, when you have 100 developers within multiple teams working on a single app, maintain a separate fork of React Native because of all the bugs and issues, the whole promise of "single codebase for less effort" becomes moot. I'm having a hard time believing they couldn't do the same with the same amount of people within the same amount of time if they just went full native with Swift/Kotlin. It's not like the app's business logic is rocket science (and if it were, you can still use a cross-platform library for this (yeah, I meant Kotlin Native :) )).
React Native is aptly named. If all you need is basic HTTP and other stuff you could do in a browser, then it *might* work for you.
$1178 EUR + 21% + air + hotel? This would be out of the price range for many startups and Small businesses
I think multiplatform support is available on the Jetbrains IDEA IDE
Yes, and it's great, but as far as I know for debugging Kotlin/Native you have to use the Jetbrains CLion IDE.
Sorry for not answering you question, but: Do not use FXML. Use tornadofx instead. 
Wish i could upvote more. I spent 5 hours making something in javafx/fxml and it didnt work 30 mins with tornado and I'm sitting pretty
Hello, tornadofx seems interesting to me, are there any more detailed guides about that? I mean styling the app and placing labels, buttons, images at chosen destination? Thanks for your answer
There's a guide book here: https://legacy.gitbook.com/book/edvin/tornadofx-guide/details that taught me pretty quickly
I... you... the link you provided in your post is a link to the TornadoFx documentation!
The problem appears to be that that TornadoFX is helping too much. When you put an `fx:controller` attribute in your FXML file, it instructs the `FXMLLoader` to create an instance of the named class to use as the controller. But that [`fxml`](https://github.com/edvin/tornadofx/blob/v1.7.16/src/main/java/tornadofx/Component.kt#L981) property delegate [automatically configures the `FXMLLoader`](https://github.com/edvin/tornadofx/blob/v1.7.16/src/main/java/tornadofx/Component.kt#L998) to use `this` as the controller for the FXML file. In your case, that would be the instance of `MainView`. That's why `FXMLLoader` is complaining about duplicate controllers - TornadoFx is setting one, as is your FXML. There are a two solutions: 1. Don't us `fx:controller` in your FXML. This should work fine, but you lose auto-complete in the FXML. 2. Use `fx:controller` in your FXML, but change your property delegate to `by fxml("/views/MainViewFXML.fxml", hasControllerAttribute = true)`. This [will prevent](https://github.com/edvin/tornadofx/blob/v1.7.16/src/main/java/tornadofx/Component.kt#L995) TornadoFX from configuring the `controller` of the `FXMLLoader`. This [is documented](https://github.com/edvin/tornadofx/blob/v1.7.16/src/main/java/tornadofx/Component.kt#L972) in the `fxml` function. Note *how* the `loadFXML` function achieves this. It sets the `FXMLLoader`'s `controllerFactory` to a function that always returns `this`. This means that the `FXMLLoader` isn't *actually* instantiating any controller instances - the controller is getting bound to the object that called the `fxml` function.
Well, when Kotlin/Native will be be production ready, it could be used together with Swift and instead of Swift in "real life".
Hey, it's very cool technically but I need to ask if there's any benefits to it aside from the docker image size mentioned at the end. Have you been able to measure any performance gain or memory usage gain making it worth the effort? Disk size and a few milliseconds of startup time are mostly irrelevant in my experience.
I don't have any stats to hand but from a number of blog posts there can be up to 10x decrease in memory usage, obviously this depends on your application but I can see Graal getting some traction!
That is exactly what I needed. Thanks you mate, that fixed my problem!
You could use a mocking framework like Mockito (or some Kotlin wrapper library) to create a mock object.
I wanted to avoid mocks and try to use real objects....
&gt; stringParams.substring(0, stringParams.length - 1) Can be replace by stringParams.dropLast(1) You can also think about to do try-with-resource in kotlin way http://www.baeldung.com/kotlin-try-with-resources
Startup time is particularly important when running serverless via lambda
I created a project to do this a while ago. However it's not bulletproof by any means, and relies on some deprecated reflection stuff in Kotlln. It will work for simple things though so you might be able to update it to work with 1.2: [https://github.com/daviddenton/databob.kotlin](https://github.com/daviddenton/databob.kotlin)
Note that I'm a moderator and I do keep track of the reddit and intervene once in a while. I wouldn't mind giving moderator privileges to someone else who's already a known person in the Kotlin community. 
Me, im lazy and want street creds
I would be happy to moderate. I'm not sure whether or not I'm known in the community, though.
Thanks, that was really helpful. 
I'd be happy to mod if you guys need help. I'm a Android dev and a mod of r/Android and r/showerthoughts among other subs.
Not sure how/if we're casting votes on this, but I would like to submit my +1 for Multimoon. Already a mod of two big, active, high-quality subs, and is a Kotlin lover. Big win in my book.
Depends. There's a few /r/android mods that are very biased against certain websites, and a few mods are very inconsistent about random posts that don't break the rules over there. Not saying OP is one of those mods, but I wouldn't put my full support behind someone who possibly would misuse their biases on sub postings. I don't think there's any way for him to prove he's not one of those mods though (or that there's a way to prove he is)
I would be honored to assist. I mod over at /r/SysAdmin, and others as well. I also use Kotlin 8 hours a day in a high-volume enterprise environment at one of the largest enterprises on the planet. I love Kotlin! It has made me fall in love with the JVM all over again, and more importantly, I am once again happy as an engineer; not just because of Kotlin, but the professional communities emerging around its use.
It's a Java library, haven't used it for Kotlin yet, but this is the library I'm a big fan of: https://github.com/benas/random-beans It creates your bands automatically filled with the right information, and understands things like jsr 303. Might be worth checking out
I recommend using this in combination with object mothers (see Martin Fowler wiki). Then you can do something like: val person = createAdult() which removes a lot of the boilerplate code required in setting up tests. 
Good point. I forgot about those. 
u/yopla, I updated my post above to add some differences between the native and executable. And as u/idreamincolour says, FaaS do rely heavily on a fast startup time
I would really like to. While I'm not a well known person in the community, I'm an active redditor for multiple years and am a moderator of r/unexpected and also collected moderator experience outside of reddit, even in communities with 100.000+ members. I'm reliable and stick to the sub rules and things the team agreed on.
The only other solution is not shading stdlib in the JAR and loading it in the app using classpaths, but this is my last resort.
**Update:** After taking a look at IDEA's log, it seems this is causing the issue: https://gist.github.com/MrPowerGamerBR/5da495e71d2b56a8c3bf21f2c9c1c86e However I have no idea how to fix it and searching the error on Google didn't help.
I decided that https://www.reddit.com/user/chocolategirl should handle the assignment of moderation, and I'll be going away now.
will test this! thank you!
thank you!
Have you tried shading into a different package? So instead of just copying `kotlin.*` it would move it to `custom.internal.package.kotlin.*` and automatically adjust the bytecode for you.
You shouldn't take fat jars as dependencies. Use regular jars during development and bundle only the final result into a fat jar. I was once almost driven mad by inexplicable MethodNotFound errors because a fat jar bundled an older version of JodaTime than the one I was deliberately putting on the classpath...
I probably should've given a better context in the post lol The "dependency" in question is a Bukkit plugin, because the Bukkit API doesn't shade Kotlin's stdlib, I need to shade it myself on a plugin, which other plugins can rely on. This always worked well I never had this issue, so I guess it is a IDEA plugin regression (I think this started happening after I updated the Kotlin plugin to 1.2.50). About the classpath issue, yeah, I triple checked if there was any other dependencies on my project that had Kotlin bundled with (which had!) and excluded then with Maven so they didn't include outdated Kotlin stdlib versions.
I tried doing this after your suggestion and... nope, still didn't work :( (And again, deleting the realocated package within the JAR made my code work again... well, aside from the missing references to Kotlin's stdlib) The only *other* alternative I found was: 1. Compiling two versions of the `Core` dependency, one with the Kotlin shaded in, another without 2. All projects relying on the `Core` project should be compiled with the `Core` without Kotlin shaded in (then on those projects, set Kotlin as a `provided` dependency) 3. When running on the server, then the version with Kotlin shaded it should be used (or well, when compiling with Maven, after all the issue is only within IntelliJ IDEA when coding, not when compiling)
Here is the JAR: https://jitpack.io/com/github/PerfectDreams/DreamCore/0f3887cde0/DreamCore-0f3887cde0.jar Try creating a project in IDEA and adding that JAR to your project, then try using any of the classes in Kotlin's stdlib or any of the other classes within the JAR. If it works... then my computer is weird, if it doesn't, yay I found a regression in the new Kotlin plugin version (after all, it worked before without any issues).
Wonderful article! I've been using Ktor but seeing that it does not seem to be maturing particularly quickly have been exploring HTTP4K as an alternative!
I really enjoyed this blogpost. Thanks a lot. 
I believe jackson-module-kotlin does this when instantiating objects that have required values. Might be a way to use this in your context. https://github.com/FasterXML/jackson-module-kotlin
I enjoyed your comment, thanks fam
There is already a comment about this on the stackoverflow, but the issue is the lack of no arg constructor. Data classes don't have one by default. While you can bring in various components for third party libraries to deal with it I have always found it easier to apply the kotlin compiler plugin `noarg` which allows you to denote an annotation to force a synthetic, otherwise uncallable no-arg constructor. This is useful for Jackson as well as MyBatis and other Java libraries.
Is there a downside to using sequences?
I fixed the issue with approach provided as an answer on SO. That's required to add **jackson-module-kotlin** dependency.
 val validTransition = it as? StateMachine.Transition.Valid ?: return@onTransition What's this doing, and why is it necessary?
Hi guys! Sourcerer is a visual profile for software engineers. It's a useful tool to show your developing experience and to learn more about fields you're interested in. Find out more at our GitHub page. I hope you'll like it and will be happy to hear your feedback :)
you can use x("abcd",123) but you cannot for z(...)
to clarify it, in your example T of X is set to String, but Z has Any which obviously it means Any type.
hey in class z i use ("lashin",1999) and working
&gt;but in generic can i use any object int ,String 
&gt;hey in class z i used ("lashin",1999) and working
that means auto inference set T as Any, but if you use the following Z&lt;Int&gt;("Hi", 1234) it wont work
the z class will ensure that both Name1 and Name2 arguments will be of the same type, instead of accepting anything as arguments. You can also use this for type safety, if you need to accept a z of a specific type as an argument later.
Any is the root of the Kotlin class hierarchy; like Object in other languages. Since Any is the common ancestor of EVERY type in Kotlin, all types can be cast to Any or Any?. The type z&lt;T&gt; means you have defined a class called z that accepts an unbounded generic type called T; that is, ANY and every type - because we haven't added any constraints - can be passed for T. It just so happens that, in your main function, you are creating two variables; one instantiated with the x constructor, and another instantiated using the z constructor. In the case of x("lashin", "lashin"), you are passing String objects to the Name and Age parameters, and these String objects are being cast to Any, which is a valid cast since Any is at the root of the class hierarchy. If you passed different types and values to the x constructor, the type of your g objects is still x. When you call the z("lashin", "lashin") constructor, you are actually instantiating an object with the type signature of z&lt;String&gt;. Had you constructed the object like this: var w=z(1, 1) The object would have the type signature of z&lt;Int&gt;. And this is a completely different and discrete type compared to z&lt;String&gt; and would return false if compared for equality against z&lt;Int&gt;. But if you invoke: var g=x(1, 1) The type of object g is still x and has the same type signature as: var g=x("lashin, "lashin") If you want to create a more versatile z class, you could: class z&lt;T1, T2&gt;() { And then, instantiate an object like this: var w=z("lashin", 30) And the type signature of variable w would be: z&lt;String, Int&gt;
It‚Äôs used to make it look like a constructor call, since the actual constructor is private (invoke in a companion object has the same syntax.) I suppose this is a stylistic choice, to make construction feel more ‚Äúnatural‚Äù.
`invoke` is the function call operator ‚Äî `object(args)` desugars to `object.invoke(args)`. the part you're looking at is just there for java compatibility (since java doesn't support any operator overloads).
got it. Thanks
Thanks man what's the benefit of Generic 
In scala I would usually do this, (define a new type parameter R as a lower type bound of T) sealed class Test[+T] { def map[R &gt;: T](f: Int =&gt; Test[R]): Unit = ??? } Is there a equivalent in kotlin?
Just to be precise, unbounded generic types are of type Any? (not Any) since you could use a nullable type as the generic type. Also, Any? is the root of the hierarchy (not Any). One way of thinking about it is that Int? Is a subtype of Any? but not a subtype of Any.
no difference
For x the type is inferred. For z the type is defined before assigning a value to it. No different in the end.
In your example, there is basically no difference in functionality, just in semantics. What you did there is specifying your types, it is useful when you, well, need to be more specific about your types. You could do `Array&lt;CharSequence&gt;` and it would work, but when acessing the array contents, you would only be able to access the methods defined in the `CharSequence` interface. Kotlin will complain about redundancy on 'x' because you passed only Strings to the 'arrayOf' method, so the language (most of the time) can figure out this for you.
can i write var x=arrayof("As","ass") And works good to display data in list view ?
With `x`, the type of the variable is inferred based on the result of the expression on the right hand side of the equals sign. `arrayOf()` is explicitly specified to take `String` arguments. As a result, `x` has the type `Array&lt;String&gt;`. If any of the arguments to `arrayOf()` are not a `String`, they would be flagged as a compile time error, because it is expecting `String` arguments. With `z`, the type of the variable is explicitly stated to be `Array&lt;String&gt;`. `arrayOf()` inferred its return type based on the arguments it received. Since all of the arguments are `String`s, the return type is `Array&lt;String&gt;`. If any of the arguments to `arrayOf()` are not a `String`, the whole expression would be flagged as a compile time error, because the result is expected to be `Array&lt;String&gt;`. The end result is still two variables of the same type, but done in different ways and will have different error if any of the arguments are not a `String`. 
are used array &lt;String&gt; in example 1 to use arrayadapter
yes
are used array &lt;String&gt; in example 1 to use arrayadapter . to display data in list view 
 For 2example var z. are can use arrayadapter or No 
you can use it in ArrayAdapters 
both x and z are Array&lt;String&gt;. For z you explicitly state the type, for x the compiler can infer the type
&gt;thanks mosh\_java
&gt;THanks Xylez iunderstand Now
thank you gonemad
LouizFC thank you
&gt;unholysampler thank you very much
I've found myself doing this with android fragments, since I can't have any args in the actual constructor for it to work properly.
Well, I didnt read the context, so I will explain based only on this code and some assumptions. "it" is being cast with the [safe cast operator(as?)](https://kotlinlang.org/docs/reference/typecasts.html#safe-nullable-cast-operator) it means that, if the casting fails, it will return null. After the safe casting, the [elvis operator (?:)](https://kotlinlang.org/docs/reference/null-safety.html#elvis-operator) is used. The "return@onTransition" is used to stop the method for going further, just like using "return;" in a void method (java), the difference is that it is using a [return label](https://kotlinlang.org/docs/reference/returns.html#return-at-labels), so it will return for the "onTransition" lambda / method. So, in summary, they are trying to cast "it" to type "Valid", if the cast fails, it becomes null, the elvis operator checks for this nullability, and will "return" if the current cast was null, stopping further execution.
Since Test is covariant over its type parameter, a reference of type Test&lt;Animal&gt; could hold a object of type Test&lt;Cat&gt;. That would mean the holder of the Test&lt;Animal&gt; reference could call abc((x) -&gt; Test&lt;Animal&gt;()) and then your object of type Test&lt;Cat&gt; is getting Test&lt;Animal&gt; objects from calling the provided lambda, which is clearly against expectation of the Test class. In other words the rest of that abc() method would think is has a reference to a Test&lt;Cat&gt; that it call methods to return a Cat from, but it would get an unexpected Animal instead. I'm not sure how scala can deal with this, as this seems like more of a logic problem than a coding problem. 
Type constraints in Kotlin aren't as powerful as they could be, unfortunately. They're a little more flexible on extension methods, though, so you can do something close to the equivalent of your Scala code in Kotlin like this: sealed class Test&lt;out T&gt; { } fun &lt;T, R : T&gt; Test&lt;T&gt;.abc(fn: (Int) -&gt; Test&lt;R&gt;) { fn(10) }
Those are all good points. Thanks!
Great question! Let's take a common example in the standard library: List&lt;T&gt; Let's say I have a function: fun &lt;T&gt; transformListToArrayList(theList: List&lt;T&gt;): ArrrayList&lt;T&gt; This means we can write our transformation code once and transform all type of List&lt;T&gt; to ArrayList&lt;T&gt; using the same function: transformListToArray(...) and this means if/when we need to refactor our code, we only have one implementation to change. In other words, a generic function allows you to decouple an algorithm and the types consumed and/or produced by that algorithm.
Please post these as text instead of images. And if you have lots of these, consider using Stack Overflow instead of this subreddit.
Not that I know of, but shouldn't be too difficult post-compile if use something like [asm](https://asm.ow2.io/) on compiled code. Have the visitor find all the invoke insns and look em up (either via other asm reads e.g. the tree api w/ MethodNode, or by having your Java deps on the classpath and using old fashioned reflection). The checked exceptions should be in the signature of the methods you are invoking.
&gt; But as a general note, if I were you, I'd let them bubble up and not be afraid of exceptions in Kotlin code either. If I'm trying to parse some input format, and already have a mechanism for reporting errors in my return type (or possibly even recovering from partial errors) I'd rather not have some helper method I'm using side-step that entirely. &gt; Checked exceptions do not represent "expected" error conditions IMO and while in many cases clearer result types would have been better than exception-based control flow, it's not universal so you shouldn't assume a Java author was smart enough to differentiate the two types. Have the author doing the interop determine whether something is "expected" or not instead of relying on the "checkedness" of the exception class. Yes, it's definitely true that checked exceptions are not *always* expected error conditions. There are also occasionally unchecked exceptions that are arguably expected error conditions, like `NumberFormatException`. (And Kotlin even uses some of these, like in `String.toInt`!) I'm not looking for something that's completely bulletproof -- I'm afraid it's too late for that -- just something that helps improve the situation.
I don't know of any, but I really like this Idea (pun embraced). The problem would be having the tool know when you had accounted for the exception - should you wrap every invocation in resultOf or its ilk, or allow the exceptions to propagate, but just not outside the current function? Perhaps the first has the most legs - it would be analogous to dealing with nulls in Scala - wrap in Option immediately.
thanks! this worked for me.
Do you mean like, you get back a `T?`, and it's null if the exception was thrown? Then you lose all of the info about the actual exception though. You would need more like a `Try` or an `Either&lt;Throwable, T&gt;`
That's a good question. There are some cases where you *must* use an extension function: - adding methods to a class you don't control - adding methods to a nullable type (eg: `Any?.toString()`) - you need more complex type constraints (and even then, it only adds a *bit* more flexibility) There are some cases where you must *not* use an extension method: - you need to access inaccessible (eg: private) members - you need to override an existing method - you need the new method to be overridable That still leaves a lot of cases where either way is possible. In general I'd lean towards the method being in the class unless I either wanted to make it very clear that it's a shorthand for some other behavior, or I wanted the freedom to split it out into a separate module. Extension methods are somewhat less discoverable, and they can also require an import. Even when using an IDE that auto-imports, this can occasionally be an annoyance. More than once I've had to manually insert an import because IntelliJ refused to auto-import an extension method on its own.
If I could choose either, I think I'd go with #2, "allow the exceptions to propagate, but just not outside the current function", as it would let me use a regular `try...catch`. #1 would be fine too, though. There might need to be a way to let such a tool know which functions are okay to have exceptions propagate, so that exception-wrapping helpers would work without warning. BTW: What is the "resultOf" you're referring to? Right now I'm using: Try { thingThatMightThrowAnException() } from [Arrow](https://arrow-kt.io/docs/datatypes/try/).
Namespaced functions enforce pure functions, while services (non-static classes that are as utility classes) can hold state. Kotlin ends up wrapping namespaced functions in an object, so the namespaced functions are more a sugar that help enforce coding standards.
No, I mean that you must wrap every call that could throw a checked exception in something that catches it and returns a Try or Either
Certainly #2 is like Java, but the analysis would have to be more sophisticated than for #1. resultOf was just my shorthand for functions like Try that catch and convert exceptions. I‚Äôm not a fan of Arrow‚Äôs Try though, as it catches all throwables.
how about companion objects? they are very similar to namespaced functions. 
I don't understand the question. Companion Objects are just an Object wrapped in the namespace of a Class rather than it's own namespace or the namespace of a file. The end result is the same, as long as you want the functions in the companion object to always be associated with the Class it's a part of
&gt;Certainly #2 is like Java, but the analysis would have to be more sophisticated than for #1. True. Even #1 would be very useful. &gt; I‚Äôm not a fan of Arrow‚Äôs Try though, as it catches all throwables. Yeah, I'd noticed this as well, and have been meaning to ask the Arrow devs if there was a reason for this. Catching Errors seems pretty odd.
Some rationale here https://www.reddit.com/r/Kotlin/comments/8dmc5i/functional_error_handling_in_kotlin_part_3_result/dxqyn6w/?utm_content=permalink&amp;utm_medium=front&amp;utm_source=reddit&amp;utm_name=Kotlin
Note that you are using SubstrateVM not GraalVM under the hood. More info about the difference [here](http://www.oracle.com/technetwork/java/jvmls2015-wimmer-2637907.pdf).
Great job! I'm preparing an internal talk in my company for people interested in cross platform Kotlin, so this comes in handy! Do you need any help with anything?
If you want to contribute to address some other point on the list, go ahead, your help is very welcome. If you would like to include some other topic in the outline, or if you notice any argument that you think deserves more details, please let me know
Sure thing, I'll get more active once I come back from my holidays
This is great, thanks
Would you mind elaborating on your use case? I've read this post a couple times and I'm afraid I'm still not sure about the possible applications of such a class.
These are android extensions, not platform agnostic just FYI. 
Well, Scala developers also said that Scala was ready for production when it really wasn't, so forgive me for taking any article which begins with "Scala developers say..." with more salt than usual.
The idea is nice, but the comparison has a poor database. Take a look at the number of repositories they analyzed: * Java: 410 * Scala: 129 * Kotlin: 6 I would say: Please repeat the analysis with a proper data base!
Coroutines are an abstraction of suspending and resuming execution of a function. You can use them to implement async / await, as well as other things like generators for sequences. I believe that the C# implementation of async / await delegates to threads, while by default Kotlin uses more cooperative multitasking, but the concepts should be familiar to you.
I see you like to live dangerously. 
I prefer to play safe. ` return null ?: throw NullPointerException `
I found [this talk](https://www.youtube.com/watch?v=_hfBv0a09Jc) goes over it well. Kotlin took a different approach to coroutines and the talk explains how.
#### [KotlinConf 2017 - Introduction to Coroutines by Roman Elizarov](https://www.youtube.com/watch?v=_hfBv0a09Jc) ##### 21,593 views &amp;nbsp;üëç436 üëé6 *** Description: We live in an asynchronous era of concurrency. Modern front-end and mobile applications provide real-time feedback and communication, server-side appl... *JetBrainsTV, Published on Nov 15, 2017* *** ^(Beep Boop. I'm a bot! This content was auto-generated to provide Youtube details. Respond 'delete' to delete this.) ^(|) [^(Opt Out)](http://np.reddit.com/r/YTubeInfoBot/wiki/index) ^(|) [^(More Info)](http://np.reddit.com/r/YTubeInfoBot/)
What is !!
[Double secret Null](https://kotlinlang.org/docs/reference/null-safety.html)
I love this operator. null check returns are like ``` somethingNull ?: return ``` and nothing below it would execute. 
It's basically syntatic sugar for "if not null". Basically in kotlin, variables and method returns, can not be null. Unless, you specify they can be null. I can do var numberOfKids : Int = 3. I've now declared a variable, that I specifically say is an int, and set it to 3. If I want it to be able to be null, I can do var numberOfKids : Int? = 3. It can now be null. But, doing anything with a variable, that is equal to null, would be a problem. so if I wanted to do something like numberOfKids.toString(), on a null value. I'd have an issue. The verbose way to handle that would be doing if (numberOfKids != null) { numberOfKids.toString() } But, in kotlin, I can just do numberOfKids!!.toString() and it will automatically check if it's null or not, and do what I want it to. 
!! is asserting that it isn't null. ?. is if not null.
Not exactly. You are thinking of the ? Operator. In your example, numberOfKids?.toString() would be equivalent to the if statement you provided. numberOfKids!! tells the compiler that you want to force the variable to be considered not null. If numberOfKids *is* null, you will get a runtime Null Pointer Exception. If you use ?, the statement will not evaluate if numberOfKids is null.
It's interesting how the article wants to measure the frequency of WTFs and comes to the conclusion that the most complex language which confuses tons of developers is somehow the least surprizing. Another thing to consider is that most Scala developers use other functional constructs with their own associated complexity instead of using exceptions. It's clear that there would be less exceptions if you purposely use different approaches to error handling. Lets compare languages based on the usages of GOTO statements while we're at it.
or use `something?.let { }` and it will only execute the stuff in the brackets if `something` isn‚Äôt null, and passes through a non-nullable instance (i.e. the !! is already done for you) through the `it` field 
Yeah, you could. I don't like it if all the code in the method depends on that one thing being not null though.
Can also assign the non-null value to a new variable with `val nonNullValue = somethingNull ?: return` No nesting, no null values, no `!!`
oh shit. Yeah! I like this. Kotlin is just a joy to type! 
It forces an optional to a non optional type. Eg, String? would become String. It'll throw a null pointer exception at runtime if it's null though, so you are basically throwing out compile time type safety and should rarely use it. It's mostly for java interoperability when you know the value is never null, but the type system doesn't. Use with caution.
And in general if you find yourself using `!!` you have already screwed up. It's a common code smell from inexperienced devs migrating from Java.
You monster!! What have you done... :(
The sweet part is that you don‚Äôt need the !! below it, it will be smart cast as long as it‚Äôs not a mutable field. This works for `throw` and `continue` too, so the days of recursive `if (stuff != null)` are over. 
Yes, it should be considered as ¬´throw a `NullPointerException` if this is not set¬ª, as you‚Äôd be forcing that to happen. Which is fine in the instances where it makes sense to crash rather than continue with an inconsistent data model. But for code readability, it‚Äôs better to throw a more descriptive exception instead. An exception (...) would be where smart casting doesn‚Äôt work, such as with filter. `nullableCollection.filter { it != null }.map { it.someProperty } ` doesn‚Äôt smart cast, but definitly should be safe, so you‚Äôd have to write: `nullableCollection.filter { it != null }.map { it!!.someProperty } `
But... But why? O_O You monster!
I don't like it too, but sometimes it's the only way to convince compiler that value was not randomly changed in-between two sequential operations.
I like how Swift does it. guard let foo = something else { return } //use the variable here foo.name = "Rick Astley" This avoids nesting, and sets the scope of the `foo` variable to the function scope, rather than the `if` block scope.
I will hunt you down if you do that to my codebase. 
That's why we have filterNotNull, which does do the cast!
Wow, the more you know...! Thanks for the tip! (Still think the smart cast should work with map though). 
Isn't the size of a char 2 byte similar to Java?
No they won't.
If you are running Kotlin in the JVM or similar environment (Android), then yes, it is 2 bytes in size.
&gt;as long as it‚Äôs not a mutable field Ah 
Isn't that equivalent to `return null!!`?
Java interop doesn't force null checks unless they are annotated nullable. I say it's only reasonably responsible usage is in testing and red green refactor. If I find those in main we're having a conversation in techtro about it!
In the first example, should ``` recycler_view.bind(list, R.layout.item) { it -&gt; Item ``` be ``` recycler_view.bind(list, R.layout.item) { it: Item -&gt; ``` ? (At work where we don't do Kotlin but that doesn't look right...)
Yea, you're right. I was manually typing that example in the readme üòÄ
That was the joke. üòâ
D'oh
at work we recently discovered a more intricate way to travel into the nasty land: ``` fun &lt;T as Any?&gt; myStuff(): T { return null } val fireAway = myStuff().property println("I am not null, am I? $fireAway") ``` ```
The kotlin std Lib is Just Compiled for java 8 or higher, that's what it means. You can use jpms stuff besides this as usual. Maybe you just forgot to require the Java.xml module?
No I haven't tried yet. I'm just learning the Java module system now (I've been procrastinating on that) so then I'm gonna integrate it into my app. Just wanted to make sure that wouldn't cause me a problem. Thanks.
I can't believe what a low effort website this is.. posting it here pretty much amounts to spam.
What about bitcode support (https://github.com/JetBrains/kotlin-native/issues/1202)? Seems like a dealbreaker for any serious efforts on iOS.
JAXB, the xml package is no longer included in the JDK. Just add it as a dependency manually.
This code doesn't compile. The errors are on null, that is not assignable to T, and on myStuff, that can't be called without specifying generic type argument.
&gt; Bullshit Please keep comments civil.
I'm sorry that was the wrong example. The one we found was this: private val data: MutableMap&lt;String, Any&gt; = mutableMapOf() @Suppress("UNCHECKED_CAST") override fun &lt;T : Any?&gt; get(key: String): T { return data[key] as T } It is obviously wrong on many levels, it was made by junior programmer, but it effectively turned null value into not null, causing crash at runtime. Of course there's suppressed warning there and totally expected, but otoh I keep thinking if such brute violations can still be found by compiler...
Not sure I recommend it, but if it‚Äôs literally just 3 branches, inverting it would turn it into an if-else if-else, which is flatter: return if (!condition_one) TripPrices(price1, emptyList()) else if (condition_two) TripPrices(price1, listOf(price2, price3)) else TripPrices(price1, listOf(price2)) (I say I might not recommend it because the flow may be less clear this way.)
You can use a ¬¥when¬¥ expression. return when { cond_one -&gt; a cond_two -&gt; b else -&gt; c }
I usually try to use early returns in order to reduce nesting: if (!condition1) return TripPrices(..., emptyList()) return when (condition2) { true -&gt; TripPrices(..., listOf(price2, price3)) false -&gt; TripPrices(..., listOf(price2)) } Note that if condition2 is short then I would put that inline in the when expression with an else instead.
I normally avoid "if not" as people tend to miss the '!', but overall here I think it's a win for readability. I shortened it slightly further to `return if(cond1) foo else when (cond2) { ... }`. Thanks!
Can you expand on the websocket rewrite? 
Sometimes it may be worth to do something like When{ Cond_one &amp;&amp; cond_two -&gt; a Cond_one - &gt; b Else -&gt; c }
I like to use `not()` for that very reason `if (condition.not()) return TripPrices(..., emptyList())`
In the early versions of Javalin WebSocket proxied directly to Jetty, so WebSocket routes had to be declared before the server was started. There were three ways of declaring a WebSocket route: using an annotated class, using an object extending/implementing the right Jetty things, or using a custom Javalin lambda: app.ws("/websocket") { ws -&gt; ws.onConnect { session -&gt; println("Connected") } ws.onMessage { session, message -&gt; println("Received: " + message) session.remote.sendString("Echo: " + message) } ws.onClose { session, statusCode, reason -&gt; println("Closed") } ws.onError { session, throwable -&gt; println("Errored") } } In Javalin 1.5.0, path parameters for websockets was introduced, so you could do `/websocket/:my-param`, and Javalin would route your websockets appropriately and let you extract path params. This means Javalin was not relying on Jetty for routing anymore. Aso, a `fat session` containing additional methods was added. These things were only available if you were using the Javalin lambda approach. &amp;nbsp; The code had become a bit messy due to having two/three different implementations for the same thing, so the inferior (no path params, no fat session) ways of doing websockets was removed. The websocket creation code was also rewritten to make everything a bit easier to understand, and the one class that did a bit too was split in two. Here are the relevant commits, if you're interested: * https://github.com/tipsy/javalin/commit/3312f099608184ebce701534cf7306ee21bd8550 * https://github.com/tipsy/javalin/commit/e0517d36e307a8f7a2482ad144fa5fa257fdd201 * https://github.com/tipsy/javalin/commit/0b56919ecc1fd3d2826195c30c99835539a24e20 * https://github.com/tipsy/javalin/commit/37278f1a8d143aa9d1aabce19669a9abf845dcb3 &amp;nbsp; I listed this as an internal change, because most of the API is similar to Javalin 1.7.0. The main difference is that you can no longer use annotated classes or Jetty objects for declaring WebSockets. 
Didn't know that existed... thanks!
Just looked at your solution again. Originally I thought it wouldn't work for me -- but /u/Determinant's answer realized I could do `!cond_one` for the first case. Which makes this one the most readable. 
Not to be discouraging, but there doesn't seem to be much beyond the [official docs](https://kotlinlang.org/docs/reference/basic-syntax.html#defining-variables).
This is really just spam.
Sorry, I'm not sure I understand, can you post some example code to help make it more clear what the problem is?
You got all the reasons üòÅ that's because I'm not experienced in js and I also don't know that a "plain object" is üòÖ Here you can find the header for DocumentReference with the extension functions: https://github.com/4face-studi0/Kloud-FunKtions/blob/master/kloudfunktions/firestore/DocumentReference.kt This is the method for transform a map, I would do the same from Any: fun Map&lt;String, Any&gt;.toJs() = json( * map { it.key to it.value }.toTypedArray() ) 
I've just realized I don't need that conversion for map üòÖüòÖüòÖ so let's say I need to convert a model into a map 
Man there's so many extension functions on Iterables. I need to go through that documentation. Just the other day I was writing a function to select the most recent objects who's timestamps were all within a certain amount of time with each other and sortedBy, zipWithNext, and takeWhile would have done it way more succinctly than what I wrote. 
If you're going to create a website it needs to add to what's already available. There's nothing here as to why to prefer `val` over `var`. Plus, even worse, the "code" is an image, so if I find something useful, I can't even copy it. Hell, I can't even read it. https://imgur.com/a/7ZMwG2p 
So .window sounds like it'd be perfect for paging results, no?
Nope because it's daft to interview for kotlin. When you interview developpers yould should be looking for general CS knowledge, problem solving ability and experience. If you need mobile dev, test for that, if you need backend dev, test for that. You'll have much better result by discussing OSI layers and the protocol stacks he'll need to interact with than those questionnaire. Learning enough kotlin is a matter of a few days for someone with a solid java experience and by actually interviewing for Kotlin you're limiting your applicant pool.
That's an excellent article. TIL that Kotlin, like Haskell, has a type to represent the Bottom.
Been going through the libgdx for Kotlin course on Udemy. It looks like the author cloned their Java course and redid the content with Kotlin. It's been ok so far. I figured I would give the Java one a go after and try to convert the code to Kotlin as I went. 
Looks like table of contents of pretty much any book on Kotlin :/
I tottaly agree with this. The programming language should be used as a tool. I've switched easily from Java to Kotlin and I know many other excellent developers that achieved this too. Problem solving skills and experience is what really matters. Switching between languages in the same paradigm is not that hard at all. And limiting the pool for experienced Kotlin developers is not a good choice, the language is "new", so you won't have many applicants.
You might find this useful: http://jussi.hallila.com/Kollections/
If you look closely that is a series of articles. Kotlin is just one of 5 about mobile interviews. 
As a said above Kotlin is just one of 5 about mobile interviews articles that are linked. Check ‚ÄúNot another Interviews‚Äô article‚Äù @neteinstein https://medium.com/code-procedure-and-rants/not-another-android-interviews-article-5b478671793b
There's [this](https://www.youtube.com/watch?v=JY75pC5l0d0&amp;list=PLbH4r1N8PmBLHriCYXFNBdbwa33yTd4YY) video series, which I've found quite interesting.
The most important part is to understand the logic of how to make a game, language specifics can be worked out once you know it. As truemobius wrote, there is a course on Udemy on libgdx for Kotlin. I marked it for future usage. But sounds a good start. A for little money.
i personally find this "porting" of a course between two languages very informative.
User is a future at this point, whereas userString will be the value. I don't know if this helps with your answer at all. They are confusing for sure. 
‚ÄúBlock‚Äù is not exactly correct word here, nothing is really blocked here, on any thread. Async/Await helps to write async code in sync manner ‚Äúas if‚Äù code is blocking, but it is still not. Everything that looks ‚Äúblocked‚Äù to you is scheduled as a continuation to ‚Äúblocking‚Äù work. Even your example is good enough to see benefits of coroutines: you are updating UI without both blocking UI thread and without need to do any cross-thread data passing explicitly. You are saved from explicit dealing with deadlocks, threads, synchronization etc, and you still get property functional code. Your example in particular and more general case are well described here, so now Im about I save some typing :) https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md#launch-ui-coroutine
`launch` is for a coroutine that you run and don't obtain a result from, like a fire-and-forget coroutine. `async/await()` is for a coroutine where you need the result. Both will execute on threads outside of the main thread.
If I use two coroutines , if I don't delay them, they are always going to run in parallel no matter which coroutine builder I use? Thanks
Yep. They aren't guaranteed to finish at the same time, and they might execute sequentially depending on how many you queue, but they will execute in parallel.
Thanks for your time
The advantage is readability: it nearly looks like plain sequential code, but is non-blocking.
Just what I need, thanks! 
u/serebit is close but not quite. Coroutines may very well run sequentially, depending on the implementation behind them (eg certain executors.) And, though it may bite from time to time, therein lays the beauty: a consistent syntactical abstraction over any number of different async implementation details. Maybe this one uses a dedicated thread. Maybe that one uses a thread pool. Maybe that one over there is tied to something else. Who knows. :)
Update your version of Rouge to get rid of those annoying syntax highlighting errors btw :)
Coroutines is kind of like multithreading‚Äîyour example could better utilize it if you queried multiple users at once: val userString1 = fetchUserString("1") val userString2 = fetchUserString("2") val userString3 = fetchUserString("3") val user1 = deserializeUser(userString1.await()) val user2 = deserializeUser(userString2.await()) val user3 = deserializeUser(userString3.await()) showUserData(user1.await(), user2.await(), user3.await()) Notice that I'm starting as many coroutines as possible before awaiting any of them. This means that the three fetches are done at the same time, then you wait for the first fetch to finish, then the three deserializes are done at the same time. If a function returns an `async {...}`, then doing `await()` immediately on it kind of defeats the purpose.
&gt;Even your example is good enough to see benefits of coroutines: you are updating UI without both blocking UI thread and without need to do any cross-thread data passing explicitly. You are saved from explicit dealing with deadlocks, threads, synchronization etc, and you still get properly functional code But the non-blocking of the UI part is already solved if I put all methods in a launch {} block, isn't it?
Good point!
It's already blocking with just launch {} right?
So the only "real" usecase to use async over a huge launch blog is that I can start x coroutines and join all of them at the end, right?
No, the first two lines with `await()` are dispatched to other threads without blocking the UI thread. Only `showUserData()` will run on the UI thread.
Yeah, I'd say that's the main use case.
Yeah meant not blocking with launch{} But seems like not using await there would block the UI
There‚Äôs nothing that guarantees ‚Äúat the same time‚Äù parallelism here, depending on system load they very well could finish sequentially 
it is solved until you need to propagate updates to UI thread, this will require you to write code that you did not have to write here
It really depends on what your 'methods in good old synchronized fashion' are doing and what are doing their async counter-parties. if we imagine that `fetchUserString` is blocking network call, then putting it inside `launch` will block/eat one of the real/software threads of your threadpool, this thread won't be available to anyone else while network call is inflight, using all the resources required for a thread for nothing but waiting. If we have `fetchUserStringAsync` that is implemented using non-blocking network api then 'awaiting' it costs zero threads, there is no need for threads at all while network call in flight, you (or rather runtime) will only have to borrow thread to handle the response and run continuation
If you don't need your (de)serialize functions to be callable from Java, you can just use suspend functions and you won't even need all those async/await calls.
But how do I implement it in a non-blocking way? Most examples have delay(1000) // do something expensive Great, delay free's up the thread and allows another coroutine to run on it. But in no real world application I would use delay. Instead, I would make a web request etc. So the time there is required to get the result. I would love a real world use case without delay
https://discuss.kotlinlang.org/t/kotlin-support-for-java-9-module-system/2499/10
Read [guide](https://www.jetbrains.com/help/idea/plugin-development-guidelines.html) to get a big picture. After that you can study other open-source [plugins](https://plugins.jetbrains.com/).
Regarding your interest in data science, here are some Kotlin data science resources: https://github.com/thomasnield/kotlin-data-science-resources/blob/master/README.md
I started by looking at the plug-in examples linked in IntelliJ docs. My plug-in is https://github.com/jimschubert/intellij-openapi-generator (previously named intellij-swagger-codegen, but I'm renaming it to my team's fork).
Just google for "Java vs Python in ML" 
well, speed and predictability of the language itself, for one. As for the rest - ML is not done in either Python (even notion of that is ridiculous), nor in JVM (which while far more suitable for calculations than Python, sadly is still not high-performance enough for real applications). ML is done via native libs, and those are completely agnostic as to which language you call them from. But more to the point - you can use wide variety of ML and linear algebra libs bindings for which are available for Java, and there are even some developing libs for Kotlin specifically: https://github.com/thomasnield/kotlin-data-science-resources
Lol I wish I read this much earlier.
The libraries are not there. 
There is some documentation on using [Kotlin for plugin development](http://www.jetbrains.org/intellij/sdk/docs/tutorials/kotlin.html). I wrote one plugin, called [AceJump](https://github.com/acejump/acejump), however there are a number of [open source plugins written in Kotlin](https://github.com/search?l=Kotlin&amp;q=+intellij&amp;ref=searchresults&amp;type=Repositories). If you know Java and Scala, you should have no problem writing Kotlin. The IntelliJ Platform has some learning curve, but there is [plenty of documentation and examples](http://www.jetbrains.org/intellij/sdk/docs/welcome.html). What sort of plugin are you thinking of writing?
Bundling is optional. If you skip it you get a raw Javascript file that you can do with as you please. The examples tend to have webpack because it is convenient.
Negative, there are plenty. [https://github.com/thomasnield/kotlin-data-science-resources/blob/master/README.md](https://github.com/thomasnield/kotlin-data-science-resources/blob/master/README.md)
python is so dominant in the field both because there's a lot of momentum behind it, and because a lot of the people working/interested in the field aren't full-time programmers (rather scientists, data scientists, analysts, etc.) and python is easier for them to write and understand. you can 100% do ML on the JVM (i've done a good chunk in scala), but whether you *should* is really dependent on the constraints on your project. if you're building something that less-technical people will be working on, or if you need something working quick, python is a safe bet. if you're just building an ml component for a larger system in a more "typical" programming environment, the jvm is as good as anything else.
Oh, i've seen this one! It was even featured in https://github.com/thomasnield/kotlin-data-science-resources
Important libraries like tensorflow or sklearn are not complete in Java. 
If it's a personal project, you can give Kotlin a try. Having to I'd say that the tooling and the ecosystem are worse for now, and you'll have trouble finding a job as a Kotlin data scientist, but it's still possible to build ML project entirely on JVM. Anyway, these are the most important libs/tools alternatives: - Keras/TensorFlow/PyTorch: [Deeplearning4j](https://deeplearning4j.org/) is a decent deep learning framework. It was actually the first deep learning lib that I've tried, coming from Java backend development background. I used it a while back, but I have to say that Keras/PyTorch had a better API. - scikit-learn: [Smile](https://haifengl.github.io/smile/) seems like a comprehensive and performant machine learning lib, but I haven't used it personally. I'd give a try. - Spacy/NLTK: [CoreNLP](https://stanfordnlp.github.io/CoreNLP/) fills most of your NLP needs, although I found Spacy API far easier to work with. - Pandas: I've heard good things about [Tablesaw](https://github.com/jtablesaw/tablesaw) and [krangl](https://github.com/holgerbrandl/krangl). - Numpy: [ND4J](https://nd4j.org/) is used internally by Deeplearning4j and some ML Java projects. It's not quite as commonly used in the ecosystem as Numpy is, though. - Jupyter: [BeakerX](http://beakerx.com/) gives you basic Kotlin support, but the last time I checked, it's not quite there yet. I believe it also comes with a plotting lib. As far as advantages go, you might find Kotlin more pleasant to work with. Most data science projects are about cleaning and processing the data anyway, so Kotlin might shine there. But honestly, you should always choose the best tool for the job, and I believe Python is currently the best language for machine learning due to sheer amount of resources and the quality of the frameworks.
Start with any LibGDX Java tutorial, gradually rewrite to Kotlin. You might want to give [KTX](https://github.com/libktx/ktx) a try if you settle on LibGDX. Honestly though, you'll probably ship products faster with a high level engine line Unity/Unreal/Godot. There are some projects trying to bring Kotlin Native scripting for these engines, but both K/N and these plugins do not seem mature yet.
To be honest, most are not as mature, battle-tested and as widely used as its Python equivalents. There's a lot more resources on Python libs out there.
looks cool, but im a bit sad that he's using 25+ years old map of europe (czechoslovakia).
Why would you want to avoid using Webpack? Kotlin aims to integrate seamlessly with existing ecosystems - that's why it relies on standard JVM and JS tooling. Even the official KotlinJS frontend plugin relies on JS tools. Afaik, you _could_ try to use Kotlin without Webpack, but some tools are simply not available for plain Kotlin. You might have to ship unminified, unobfuscated code, which is not a very good practice. Including third-party JS dependencies will also be a pain. Sure, you have to learn a new tool or two, but using an existing project template is a good way to limit to initial learning curve. [Try out one of the project templates](https://github.com/czyzby/kotlin-multiplatform-example).
One possible solution is to not shadow it: val variableName: String? = ‚Ä¶ variableName?.let { // use "it" }
love it! thanks
I like to do something like this: var myVar: Any? = null ... myVar?.let { myVar -&gt; // non-null myVar in this scope }
clever! i'll try it 
actually it's complaining anyway. i'm not saying it's wrong...
Really? What does it say? I do this shadowing all the time.
"name shadowed". i repeat it: it's not a problem it's just something that bugs me :)
It bugs me too because my codebase is full of this intentional shadowing and it seems like they added this new check yesterday in Kotlin 1.2.51 :/ ... Let's see whether it's possible to disable this check only for lambdas.
feeeels 
Here is a gradle example: (https://github.com/rnentjes/simple-password-manager)
I'm fine with 0 js external dependencies and so far it seems that I'll never need them. Frontend development is fun again with Kotlin. I can imagine that there are others like me who want to completely get rid of javascript. I can't blame them.
Where does it say the salesman is traveling in 2018? It could very well be the 1980's.
good point :-)
Kotlin is widely accepted as the better alternative, so - yes.
Keep in mind that Kotlin smart casts might make this unnecessary. var variableName : String? = null ... if (variableName != null) { // here you can use `variableName` as if its type was `String`, not `String?` }
sure mate, but i'd like to take advance of ? operator and smart cast to not to write ifs
I sure do hope so, seeing that it is considered by many to be better than Java in every relevant way.
actually i found that this will work var variableName : String? = nil .... variableName ?: return //here onwards variableName is not null
You *can* write it like this: var variableName : String? = null ... variableName?.let { // here you can use `variableName` as if its type was `String`, not `String?` } That shouldn't be allowed, but it does work. But to understand *why* it works, you have to understand how inline functions are expanded, how the `?.` operator works, and you have to actually know what the implementation of `let` looks like. I feel that this pattern is tricky and I wouldn't encourage people to use it. In general, there's no reason to avoid `if` expressions in Kotlin. I'd point out that `if` has the additional advantage of permitting an `else` clause, which `?.let` doesn't. 
I for one welcome our new Delphi overlords.
yeah sure! maybe i could have been more specific but i wanted a no-else case or better an else-return case
it's a forced feeding i can accept :D
Smart cast isn't available here. You can't do this since variableName is a `var` and not a final `val`. We have this restriction because another thread can modify a `var` at anytime.
Smart cast is absolutely available here, and I tested the code before I posted it. Here's a full example that compiles without issue: fun main(args: Array&lt;String&gt;) { var variableName : String? = null if (Math.random() &gt; 0.5) { variableName = "foo" } if (variableName != null) { println(variableName.length) } else { println("was null") } } If that's not supposed to work, then it's an egregious error in the compiler that has existed for I believe several versions.
It works for local variables, but if `variableName` were a field, the smart cast wouldn't work (which I think is what /u/BRAAComp was getting at).
Sure, but that didn't appear to be the situation that OP was asking about. 
Wrong sub mate. 
Kotlin is a better alternative and with Oracle lawsuit, ofc they are siding with it.
That‚Äôs right, it‚Äôs an alternate to Java, with Java still being the primary language.
But what gives anyone the right to force something onto someone? By doing so you are only repelling the other person.
To really be effective, we really need to start differentiating "machine learning", "data science", etc. These terms mean a lot of things to different people, and sometimes this [well-marketed buzzword called "data science" is just downright unproductive](https://thenextweb.com/syndication/2017/12/28/data-scientists-frauds-according-data-scientist/). It's hard to pin down what parts of data science could be concerned with production (e.g. machine learning, ETL) versus just exploratory analysis and Jupyter notebooks. Kotlin is not going to overtake the latter anytime soon, but it can certainly excel in the former. I think the best thing the Kotlin community can do is be pragmatic as always, and focus on specific problems and solutions rather than shoving Kotlin into a broad buzzword domain. 
Well, it's their platform. They can choose which language to promote. Just as Apple can promote Swift as a modern alternative to Objective-C.
Mea culpa. I didn't know Smart Cast is that smart. At least I was right about the problematic edge case. Try this code snippet: fun smartCastTest() { var myAny: Any? = null if (myAny != null) { print(myAny.hashCode() + 4) } } Everything compiles fine until you change it to something something like: fun smartCastTest() { var myAny: Any? = null val myClosure = { myAny = Any() } if (myAny != null) { print(myAny.hashCode() + 4) } } This will create a warning like: &gt; Smart cast to 'Any' is impossible, because 'localAny' is a local variable that is captured by a changing closure
Mockk is amazing. I use it for everything!
Yep, but [there is also another restriction with changing closures](https://www.reddit.com/r/Kotlin/comments/8w9at1/maybe_a_silly_question_variable_name_shadowing/e1ty90u/)
Yes, any time a local `var` "escapes" (or has the potential to escape), it's no longer eligible to be used in smart casts. An example that *could* work, but doesn't, is this: fun main(args: Array&lt;String&gt;) { var variableName : String? = null listOf(1, 2, 3).forEach { variableName = it.toString() } if (variableName != null) { println(variableName.length) } else { println("was null") } } Compare that to this, which does work: fun main(args: Array&lt;String&gt;) { var variableName : String? = null for (element in listOf(1, 2, 3)) { variableName = element.toString() } if (variableName != null) { println(variableName.length) } else { println("was null") } } `forEach` is an inline function that essentially gets expanded to the second form, yet the compiler thinks that `variableName` *could* get modified in a way that would break the smart cast (even though it can't). If you look at the generated bytecode, it's clear that no closure was actually created, so `variableName` wasn't *actually* captured by a closure. 
1. Google owns Android so they can pretty much do whatever they want. 2. Nobody is stopping you from using anything else. 3. If you‚Äôre ‚Äúrepelled‚Äù by some Kotlin example code you should probably simply drop anything Android. Win-win for everyone involved.
I‚Äôve seen this explanation a million times before, but Apple and Google are not the same, also comparing Obj C and Java is ridiculous.
Actually it‚Äôs the right sub to get this message across to the Ayatollah Khomeini‚Äôs at Google who are making these decisions. 
1. ‚Å†Google owns Android so they can pretty much do whatever they want - Yes as long as they can keep millions of developers happy, I understand that 10000 people will want to use Kotlin, but don‚Äôt force it on the rest. 2. ‚Å†Nobody is stopping you from using anything else - Actually they are. 3. ‚Å†If you‚Äôre ‚Äúrepelled‚Äù by some Kotlin example code you should probably simply drop anything Android. Win-win for everyone involved. - See this is the problem I am talking about, no one should force you to use a language or to drop Android.
Well, I don't know whether you can call Java the primary language for Apps today. The AOSP source is written in Java and this won't change in the near future but an overwhelming amount of developers (including Google developers) prefer Kotlin for new projects. It makes sense to write new docs in Kotlin.
&gt; but an overwhelming amount of developers (including Google developers) prefer Kotlin for new projects. Isn't backed up by the job postings at all. I write code in Kotlin and I prefer it, in fact I pushed for it's adoption (before google made it official) but there is still a lot of resistance from other devs. You can say "they are shit devs or shit managers" or whatever. The bottom line is, we can't say for sure that most of the Android devs prefer Kotlin for new projects. 
Nah, that would be /r/androiddev since that deals with Android. This is just for discussions about Kotlin. 
Here's a sneak peek of /r/androiddev using the [top posts](https://np.reddit.com/r/androiddev/top/?sort=top&amp;t=year) of the year! \#1: [LPT: Drag up and down on process windows to accelerate gradle downloads](https://gfycat.com/VigorousPleasedHuman) | [50 comments](https://np.reddit.com/r/androiddev/comments/71xljr/lpt_drag_up_and_down_on_process_windows_to/) \#2: [As a developer of a free game, people like this grind my gears](https://i.imgur.com/nQRdRR2.png) | [160 comments](https://np.reddit.com/r/androiddev/comments/736tf5/as_a_developer_of_a_free_game_people_like_this/) \#3: [When you change the code but forget to rebuild](https://v.redd.it/rq3argkri3411) | [27 comments](https://np.reddit.com/r/androiddev/comments/8r8ikt/when_you_change_the_code_but_forget_to_rebuild/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
Yeah, I'd prefer if Google didn't follow Apple at all *cries in play libraries*
&gt; Isn't backed up by the job postings at all. Understandable. Kotlin is still a very young language and you'll mostly have to work with legacy code and Java devs. It doesn't make sense to push for Kotlin with a team of Java devs that have absolutely no clue about Kotlin. &gt; You can say "they are shit devs or shit managers" or whatever. I don't say anything bad about Java or Java developers. &gt; The bottom line is, we can't say for sure that most of the Android devs prefer Kotlin for new projects. You're right. I can't say this for sure but it's pretty hard to find an active developer in r/androiddev that would prefer Java over Kotlin for a new project. My point is developers that know Java and Kotlin will probably always prefer to write Kotlin whenever they can. There is a clear shift towards Kotlin and it makes sense to fill the docs with Kotlin snippets to make them future-proof.
"No one should force you to use a language or to drop Android". So, wait, before when everything was in Java, that's not "forcing you to use a language"? Yes, you can write web code wrapped in something like Cordova, or C# and use a bridge or other compiler, but the main language Google promoted was Java. Now they have changed to something else, and they have VERY good reasons for doing so. Even ignoring the "Java vs Kotlin" quality debate, Oracle has been getting crazy lawsuit happy, so Google is well within their rights to defend themselves here. You're just unhappy because you don't like Kotlin. Ok, cool, then write it in Java. Just like folks who didn't like Java could do the C# or web dev thing. Stop whining here about it though, if you're too lazy of a developer to learn new things then we just don't care. PS. I'm a software engineer and I have to learn new shit all the time at my day job, whether I want to or not.
Why are you so angry? What's so bad about Kotlin? I found Kotlin a pleasure to work with after years of Java, maybe you should give it a try. (Or a second chance.) It's basically like Java from the future - same ecosystem, extra syntax sugar.
&gt;Discussion about Kotlin, statically typed programming language for the JVM, Android and the browser. This is from r/Kotlin &gt;Discussion about Kotlin, statically typed programming language for the JVM, Android and the browser.
I found Haskell a pleasure to work with, it doesn't mean I would like to see it everywhere. I'm not sure that you understand the problem, Kotlin is being forced onto the developers, in the webpage I've linked there's only Kotlin example whereas in other places it is the default and first tab in the example code. Why is that the case when very few people use Kotlin as their main language?
I have no comments for your first paragraph, it makes no sense to me. &gt;You're just unhappy because you don't like Kotlin. No, infact I've used Kotlin in the past, I just don't like seeing it everywhere, I prefer reading code in a language I can read and understand when I wake up from my sleep, sadly for most people Kotlin is not that language.
I‚Äôve been a big JS user (webpack, browserify, uplift, grunt, gulp) been through most /all of it. For the most part I feel that these thing actually get in the way and hurt more than they help when it come to what I‚Äôm trying to achieve. What I‚Äôd like to do is write a (mostly) server rendered app and sprinkle progressive enhancements where it makes sense. Since the back end would be kotlin, the template engine would be kotlin, so I‚Äôd be able to share not only language but any templating snippets with the front end also None of this would require webpack :)
Thanks at first glance this looks like what I‚Äôm trying to achieve :) 
But it is shadowing. You're just renaming "it" to myVar, shadowing the nullable one.
I didn't know you could use the elvis operator that way. Nice.
Neither I :) but I was playing with the code and ta-daa 
\&gt; a language I can read and understand when I wake up from my sleep, sadly for most people Kotlin is not that language. How on earth is that a problem that Kotlin has when it‚Äôs really a problem that *you* (and reportedly ‚Äúmost people‚Äù \[citation needed\]) have?
I think you're overreacting. Google is free to choose the main language of their platform, period. The examples you posted are trivial to rewrite in Java. Encouragement does not equal forcing - if your Java applications would no longer run on Android devices and crash with a huge "USING JAVA INSTEAD OF KOTLIN" error, that would be forcing.
Android has existed since 2007, many people have written Android code in Java since then, fast forward to 2017, Kotlin is the alternative language, for most people it has existed only for past 1 year (when it was supported officially), now let‚Äôs do the math. Which of the following is easier to understand for Android developers? 1. Code written in Java which they have been using since 10 years. 2. Code written in Kotlin which many of us have just began looking at since past year. Do you now see the need to have official documentation written in Java? 
No they are not, for me Kotlin is equivalent to Hieroglyphics, can‚Äôt understand most of it, infact it‚Äôs trivial for Kotlin developers, you have Java to Kotlin converters, let Google write official documentation in Java and maybe you guys can use your converter. Also are you implying that people should now learn a language before learning the core concept behind that SDK feature?
You can do this because computing expressions and throwing away their result is allowed. This is similar to writing down lines like this: ``` 25 "hello" ``;
What would prevent him from utilizing Gradle to minify and/or obfuscate the resulting JS code without bundling the output through Webpack or something?
Again, you're exaggerating. Kotlin takes literally a single evening to learn if you already know Java. Do Kotlin koans and you're good to go. It's not a Lisp. And by the way, it's well worth your time: I think every language that does certain things differently teaches you something new, and makes you a better programmer. I'm implying that as a programmer you have to learn new things constantly, and you should rethink your career choices if giving a new language a try is beyond your capabilities.
It really had me until: &gt; Our code now compiles. Why is that? The answer is that since Nothing is a subtype of every other class in Kotlin, the compiler can accept it, and because throwException is never going to return successfully, its assignment will never happen. In short: Nothing is magic. It was a perfectly fine explanation that made sense, but they had to drop the "magic" bomb.
&gt; for me Kotlin is equivalent to Hieroglyphics, can‚Äôt understand most of it, infact it‚Äôs trivial for Kotlin developers, you have Java to Kotlin converters Are you sure you know Java? Because learning Kotlin if you know Java takes an evening for the basics, a week to be proficient, a month for mastery. &gt; Java to Kotlin converters They're awful.
Honestly both are just as easy to read.
You can actually even go a step further and do this: `val varName: String? = myFunction() ?: return` It‚Äôs essentially the same but even shorter - absolutely love this feature.
A while ago, I made a Bukkit plugin that shades kotlin and provides a few extra functions for making my life easier when developing plugins. Right now it depends on another (strictly proprietary) library I made, but I might manage to separate them or could just make a separate open source version of the plugin.
What I ended up doing is loading the library via the classpath argument and adding Kotlin as a `provided` dependency in Maven, it works fine now!
Thanks, I wasn't aware that Kotlin was so widely used for Data Science. I'll definitely look through it.
It seems to me that this entire sub reddit works on assumptions, you may find it easier to read, it doesn‚Äôt work that way for the rest. Let me explain it to you this way, I may be fluent in 10 tongues, but I would still prefer to hear and speak my native language. Makes sense? 
Again you are making an assumption for the masses. It might take an evening or may be a month for you. It‚Äôs not the case with the million others. But that‚Äôs not the point is it? Even if I know Kotlin in an out I would still prefer to read documentation code in Java which I have known since I was a kid in college, then maybe if time allows and my project manager allows, I‚Äôll convert that to Kotlin. You guys are taking it wrong, I‚Äôm just saying that let the official documentation be written in Java as it is easier for a majority of developers to understand the concepts behind that SDK implementation or usage, people who love Kotlin will convert it anyways, the reverse might not be true.
No, please don‚Äôt ask me to rethink my career choices, I know my abilities very well and thank you for the suggestions but I would rather spend that time learning cutting edge technologies like AI and Machine Learning, for most of us time ‚â° money.
Did you take a look at the official Android documentation? [https://developer.android.com/docs/](https://developer.android.com/docs/) There are examples written in Kotlin and you can paste Java examples into Kotlin files to make Android Studio convert them into Kotlin.
&gt; What I‚Äôd like to do is write a (mostly) server rendered app and sprinkle progressive enhancements where it makes sense. Since the back end would be kotlin, the template engine would be kotlin, so I‚Äôd be able to share not only language but any templating snippets with the front end also Is performance important? If not, I have a setup I think you might like (going to work now, but can elaborate later). 
Author here: do you think dropping the "magic" bomb is overdoing it?
Now you went from "hard to read" to "I prefer Java"
&gt; It might take an evening or may be a month for you. It‚Äôs not the case with the million others. Objectively it does unless you're not already proficient at Java. This is fact.
But this actually returns from the function ;)
You would do everything else but answer my question and understand the real problem. Let me put it to you in a simpler perspective... Let's say I use Tinder and I indicate that I like women, so if Tinder shows profile of other men on home screen and forces me to watch them; does that make me like them? Can they force me to like men? Can they make me change my preference? Can they say, well you like women so you may also like men, you just need to spend 1 week with them to like them? No right? Similarly you cannot force me to use Kotlin. Let's respect each others choices and not enforce anything onto each other.
I recommend installing the EduTools plugin and joining the free "Kotlin Koans" course. This is a collection of 42 exercises. Each exercise has a link to some reading material and your solution is validated against unit tests. This course is fairly quick and then you can start using Kotlin.
The magic part was not overdoing it, it was more unexpected after reading such accurate information. Suddenly reading "magic" kind of dismisses the explanation before it. And if the reader does not already understood the theory behind types and cannot immediately verify the words that were said before it - it kind of casts doubt on the veracity of the whole article. When I hear "magic" used as an explanation I usually understand that the explainer is copping out of the explanation for whatever reason. On another point, I maybe had a good context for reading your article, so that's why it made so much sense to me to begin with. I have the idea that types are not classes in the Java/Kotlin sense, they are more like sets in the mathematical sense. A type of "String" is a set of objects, a type of "Serializable" is another set of objects. And "Nothing" is another type, which is a set of objects. Though this type's set is empty. So it is a perfectly valid type, but with no instances. There seems nothing magical about it. I am in no way an expert in type theory or anything and I got this set idea from https://vimeo.com/113588389#t=705s (time 11:45 - 12:58, so ~2mins of watching). The video is about functional programming, but I think the type part is applicable. Thanks for the article though, always happy to see helpful stuff.
Spare 10 bucks and buy a well renowned course on Udemy (look at the reviews). I bought one that sped up my game quite fast. Go for something like Kotlin for Android. The best spent money you may have, and if you have doubts, the instructor can help you.
Yes, this is the only obstacle that I see that can prevent, for the moment, the use of k / n for production ready implementations :/ Even this PR ([https://github.com/JetBrains/kotlin-native/pull/1564](https://github.com/JetBrains/kotlin-native/pull/1564)) has been closed recently with this comment: &gt;Seems this way valid bitcode cannot be generated, so let's close this one for now, and come back again, when focus on that feature again. We are therefore waiting for the works to continue.. 
Using coroutines in kscript is a joy when it comes to doing a lot of data processing. It‚Äôs not ML per but sure is handy. I‚Äôm just expecting with anything data related a huge part of your time is processing, converting and cleaning data. Writing a script that can spin off thousands of tasks waiting on IO is super easy in Kotlin. I suspect that most ML at scale really is a tricky big data system that‚Äôs been wired together with ‚Äúbits of bailing wire and string‚Äù. But that‚Äôs just my impression.
Stack simplicity is the key driver for me, hence the push to get rid of a rather large part (webpack &amp; node dependency)
Good point. I'll erase the magic from the article.
The subtitle of the coroutines section is perfect.
What I've been doing lately is a little ridiculous, but it seems to work really well. I keep the routing on the server side, and render static templates (I don't put any dynamic data in them) per route. The templates use a traditional "frame", which contains the static resources and meta tags, and a body for the current page #parse("/view/_layout.vm") #@layout() &lt;nav-bar&gt;&lt;/nav-bar&gt; &lt;my-view&gt;&lt;/my-view&gt; #end The layout template contains all static resources (and all custom components) in the `&lt;head&gt;` tag. It is also responsible for initializing a Vue app for the current view. All frontend code is written as single-file Vue components: &lt;template id="nav-bar"&gt; &lt;header class="navbar"&gt; ... &lt;/header&gt; &lt;/template&gt; &lt;script&gt; Vue.component("nav-bar", { template: "#nav-bar", data() { return { ... } }, }); &lt;/script&gt; &lt;style&gt; header.navbar { background: #f5f5f5; border-bottom: 1px solid #ddd; } &lt;/style&gt; Pros of this approach: * It's not an SPA, you get a new app per request * No need for a frontend pipeline, no node or anything * Single file components * No need for a "loading" page, the correct page is rendered directly (never any flickering when loading or refreshing) * Save and refresh, no need for watchers or live CSS injection and whatnot Cons: * Need a server for the frontend * The entire app (user written code) is download per request. I'm working on a fairly big admin-page with this approach. The entire app is about 80kb, but gzips down to about 14kb * Time to first paint is pretty long, since it requires loading all static resources before doing anything. I'm sort of waiting for this architecture to blow up in my face, but even if it does all my code is in `.vue` files, so it should be very simple to switch to webpack... So for now I'm enjoying it. It's the most fun I've had doing frontend in years. It's like getting to use all the good parts of modern frontend (vue, vuetify, components), without having to deal with any the mess.
I recommend this course on Udemy: [https://www.udemy.com/android-oreo-kotlin-app-masterclass/](https://www.udemy.com/android-oreo-kotlin-app-masterclass/) This course will give you a solid foundation in Android development.
Developers complain when new documentation is in Java because if Kotlin is a first-class language then why aren't the docs available in Kotlin? As we release more Kotlin docs, it's inevitable that the opposite complaint will occur. A lot of the documentation has a toggle between the two languages. The bottom line is that we can't have everything available in all languages. Just ask the folk doing C/C++ which has also been supported for 10 years on Android.
I like tabs, give us options when you can, Kotlin code in the aforementioned document is friction for me, please understand that most people don‚Äôt use Kotlin, besides example code should be written in a language that majority of people use. 
Between 25 and 28 years to be exact. - Dissolution of Czechoslovakia: 1 January 1993 - Reunification of Germany: 3 October 1990
Tabs are up to the person writing the docs. There's no mandate on what language is chosen. As to the majority, I believe the expression is: throw the ball to where the player will be, not where they are.
Kotlin is more than just Android
Let's say that you're a douchebag. Because you are. There's no follow up. You're just a douchebag. Fuck off.
Hahaha, looks like I triggered some enthusiasts. 
I believe that you are throwing the ball too soon. 
Yes, it is, and OP's wish is to develop Android apps.
I just mean there are a lot of pure kotlin resources to learn from
Downvoted this too way too small sample size.
That I am! Glad you liked it; and thank you for the explanation.
All of the data says otherwise, sorry
&gt; No they are not, for me Kotlin is equivalent to Hieroglyphics, can‚Äôt understand most of it That just says a lot about you really. I'm a back-end dev and I have had similar discussions with back-end devs who "hated" the new Java 8 stuff. You will always have inflexible people who resist chance. Guess what; most Java documentation also is getting updated with the less verbose lambda syntax instead of using anonymous interfaces. 
Exclamation marks and question marks make my head spin and it's no 'fun' to watch them. Your argument (and argument of many others here) of Kotlin being a better Java diminishes every time Java progresses. like you have rightly mentioned Java 8 brought a lot to the table things like streams, lambdas, method references etc that make it more appealing. For back-end developers there's Java 10 that has even more features and is very close to what Kotlin offers, [there's proposal for how data classes (a feature that I like) can be implemented](http://cr.openjdk.java.net/~briangoetz/amber/datum.html), I am not sure why would someone on the back-end would use Kotlin without evaluating/considering what will happen when Java implements all features that Kotlin claims are missing! Anyways that is not my point anyways, I'm saying that people should not be forced to write code in a particular language, I am surprised that most people here don't see that as a problem, there will always be next language, next hype, next better Kotlin etc, doesn't mean people have to change what works for them well, I hope that in future people on this subreddit taste their own medicine and maybe then they will understand what it is like for companies and communities to dictate what they can and cannot use.
Hint: Nobody likes people like you. You have a choice going into your senior year of high school. Continue being a worthless piece of shit that whines this much, stop being a worthless piece of shit, or just fucking kill yourself with your mom's dildo. It's up to you. Now shut the fuck up.
Hahaha, you are making me laugh even more, I love the frustration and desperation I have caused here by asking a simple question, you don't have answers to my questions, bullshit claims and brow beating didn't work and so now you fall back to verbal abuse. What's next? Death threats? Very great community indeed and a message indeed for Kotlin adopters, you will face same kind of abuse if you ask questions or wonder why you used Kotlin in the first place.
&gt; I'm saying that people should not be forced to write code in a particular language You're not.
It does seem that they're nudging devs to use Kotlin more, but that's their prerogative. In the iOS world, the push to move from Obj-C to Swift was more hardcore than this.
Nah, that map is just wrong. It has Yugoslavia all split up, but Czechoslovakia still in it. Europe *never* existed like that.
can you please say what IDE you are using for working with native/kotlin project?also, what your os is. Thanks
Were there some people who actually complained about it? I don't think I've seen anyone who actually prefers Objective C over Swift. I had zero experience with both of them, but I was able to pick up Swift effortlessly. It's such a pleasant language too, very much like Kotlin. I really don't get people who are resistant to using modern tools. Yeah, you need to learn a thing or two, but modern tools are modern because they learned something from past mistakes.
I'm working with Android Studio 3.1 for the common and the Android modules, xcode 9.4 for the iOS module. As os I'm using macOS (High Sierra)
It certainly was! I had to pickup iOS development at work and had to do Obj-C even though Swift 2 had just come out and was picking up traction. I found that many of the official guides in Obj-C had been removed from Apple's developer pages for Swift ones. Just had to use Google cache to get the old ones! I didn't mind too much, I much preferred Swift as a language to Objective C! 
&gt; Honestly both are just as easy to read. Show both to a C# developer who has never touched Java or Kotlin and he'll read both fine with some minor questions. Tbh, a decent Java developer should be able to read Kotlin, C#, Swift, and Scala with only a few questions. We hire devs for a backend Kotlin role -- only 2 developers had prior Kotlin experience, even our QA guys have been able to pickup Kotlin without any issues. These days I only find the old mutable state style Java hard to read, mostly because that style is out of fashion so you never seem to see it outside of old Java libraries.
You can write it like this: ``` jdbcClient.update(sql) { queryResult -&gt; if(queryResult.failed()) { } } ```
It doesn't want you to do anything, it suggests an improvement that it can apply by itself. Press Alt-Enter to apply the suggestion.
Lovely, thanks guys!
You'll need to use y-combinator. There is an example of y-combinator written in kotlin on stackoverflow.
Whenever IntelliJ warns about something just click somewhere in the warning and press Alt+Enter and then Enter again: IntelliJ will do the fix for you :)
link?
A lambda can't call `this`, you should just turn it into an anonymous object. Which is ugly, but the only way this can work. For example, frequently in Android you do this with an `OnGlobalLayoutListener`: viewTreeObserver.addOnGlobalLayoutListener(object : OnGlobalLayoutListener { fun onGlobalLayout() { viewTreeObserver.removeOnGlobalLayoutListener(this) // ... logic to be done on first global layout completion } }) Not ideal, but the only real way to do this.
https://stackoverflow.com/questions/45331701/how-to-use-kotlin-to-write-a-y-combinator-function#45336637
Honestly op. If you were on my team you won‚Äôt fair well. You won‚Äôt even get a job. I‚Äôm picturing you during an interview being asked about how you stay abreast and evolve with new languages, and I do understand languages to a certain point are subjective, but your handling of this situation is telling about your experience or age or maybe both. Doesn‚Äôt have to be mutually exclusive. There are many reasons google will ‚Äúpush‚Äù for kotlin - oracle lawsuit against google for using Java api on google‚Äôs runtime. (Yes Android is not jvm, but I‚Äôm sure you know that) if you do not understand this, then see my precious paragraph for reinforcement - kotlin is just way better (again can be subjective, but at this point there are just way many pros that some objectivity should be accounted for) - easier entry barrier for people from dynamic languages (python) while appealing to strong typers. To summarize. Don‚Äôt be a Cobol developer. 
I feel pity for your team and I am happy that I am not a part of it, if you select candidates on whether or not they know a language then it says a lot about you. If you would ask me that question in an interview I would walk out on you. You should hire for problem solving skills and ability to take on challenges, ask system design questions and if you ask them to solve a problem; you should let them solve it in their language of choice, that is what most companies including tech giants do, asking them do that specifically in a made up language which claims to be better is arrogance. Also kindly tell me one thing you can do with Kotlin and cannot do with Java and I mean in the context of solving a problem and developing for Android and not in context of syntactic sugar and fairy tale problems like nullpointerexceptions and I‚Äôll use Kotlin straight away. In summary don‚Äôt love a language, they come and go, love the underlying technology and computer science in general which will be there forever. 
The irony in your response is just... yea we shall just leave it at that. 
You should also see the real irony behind your comment and the comments of your fellow enthusiasts, I‚Äôll mention a few comments from earlier threads. 1. I‚Äôve been told that I‚Äôll will not get a job and that I‚Äôll not work well with their teams. 2. That I should reevaluate my career choices. 3. That I should drop anything Android. 4. Been verbally abused by some nut job. 5. That I don‚Äôt know Java 6. That I should blindly follow what everyone else is doing and not ask questions. 7. That I can‚Äôt learn this language in a week then I am not a good programmer. Your community believes that shaming, belittling, bullying, threatening and verbally abusing people is the best way to spread the use of this language, if you do not see a problem with this behaviour and if you do not see what‚Äôs wrong when someone forces you to do something then you have serious issues. I‚Äôll further say that I am very happy that I‚Äôm not a part of this community and that I‚Äôve not adopted your language. Please learn to live with difference of opinion and be humble enough to acknowledge that people might not want to use your language.
Same as Swift, if anyone is interested. 
&gt;No they are not, for me Kotlin is equivalent to Hieroglyphics, *can‚Äôt understand most of it* So what you're doing here is externalizing your feelings of frustration and inadequacy as a rant. "I can't understand this thing, it must be bullshit! It must be Someone Elses Fault‚Ñ¢!" This is a common maladaptive behavior amongst programmers. The thing to realize here is that it doesn't actually matter whether Google is trying to force Kotlin down your throat. You could have taken this frustrated energy and used it to learn a bit of Kotlin, solve your immediate problem and get on with your project. Instead you wasted it having a tantrum on the internet.
IMO, the simplest way is with an inner local function: val lmbda: (Int)-&gt;Int = { x -&gt; fun inner(y: Int): Int { return if (y &lt; 0) 0 else inner(y-1) + 1 } inner(x) }
The lambda is an argument of update and should be trailing the parens
Both are inspired on ML languages where functions technically only take 1 parameter.
Your code would be more "kotlin" if you avoid using null type as much as possible.
Do \`list1\` and \`list2\` really need to be immutable? You could just declare them each as a \`MutableList&lt;Int&gt;?\`, and then you may be able to make them non-nullable and \`val\`s instead of \`var\`s. Sorry if this doesn't help, but to me it seems better than defining temporary variables every time you want to change the data. Reassigning the temporary MutableLists to immutable Lists is probably more wasteful than just working on MutableLists throughout.
I‚Äôd prefer a more streamy solution: list1 = things.map(this::process1) But really, the nullable types are a pest, as well as mutable member variables. Best to get rid of those altogether.
Using a local `val` in a function is fine and nothing to worry about. Using a `var` at the top level in your class is more concerning because you are leaking mutable state into your program. Another thing I'll point out is that with collections you generally don't want to make them nullable, because then you have to deal with the difference between `null` and an empty collection, which intuitively _should_ be the same thing. A few ways to make the dependency here less error-prone: 1) You can have an alternate constructor that takes in the unprocessed list, and then process and set the values there. (If you need something in an `init` block, use `lateinit val x: List&lt;Int&gt;` instead of `var x: List&lt;Int&gt;?`. 2) You can have the constructor take in both of the already-processed lists, and do the processing elsewhere (a companion object factory method?) The second approach would look like: fun createA(things: List&lt;Thing&gt;): A { val list1 = things.map { process1(it) } val list2 = things.map { process2(it) } return A(list1 = list1, list2 = list2) } 
lateinit is always var
Oh duh, my bad. I'll edit that
Quite often list1 and list2 remain closely related. Maybe it's just a single List&lt;Pair&lt;Int, Int&gt;&gt; instead?
OP, this is the best answer. If you actually, really do have a reason for things to be nullable, just use the `?.` operator to call `map` instead: ``` val list1 = things?.map { process1(it) } ``` But really ask yourself if you need nullable `Lists` or if `emptyList()` is fine.
Alot of people saying to avoid nulls in kotlin, but kotlin has great null support. For your scenario: fun doThingWith(things: List?): Pair&lt;List?, List?&gt; { val firstList = things?.map(process1) val secondList = things?.map(process2) return Pair(firstList, secondList) } The map.operation will only execute if the input list is not null because of the ?. operator. Or you can remove the null as possible output and return empty lists in the case of it being null. As far as the var and val's are concerned. Look into functional programming like [functional programming in scala](https://www.manning.com/books/functional-programming-in-scala) for ways to make your code more "kotlin" (aka functional)
&gt; "Is Google trying to shove Kotlin down our throats?" We can't say for sure what the intentions are since we do not have any direction information from Google. What we can do is say that if indeed the documentations show only examples in a particular languages, then this demonstrates a potential bias of the authors of those documentation. * Is this bias intentional? * Is this bias driven by internal policy? * Is this bias driven by some wider agenda? The answer is: no we don't have any information to suggest anything, and more importantly it doesn't matter. Most professional programmers know multiple languages, in fact doing web development, will typically mean doing context switching between a minimum of 5 "languages". I hope that helps.
+1 using javalin in most my projects, keep up the good work
Unfortunately in the real life use case, they are not close and would be used separately. \`process1()\` and \`process2()\` here is supposed to show that the data is being processed very differently and the results are completely different. Also I kind of messed up in the example by making the two lists of Int implying the lists are simple.
&gt;val list1 = things?.map { process1(it) } is something I considered but it just feels bad writing it because it means I have to iterate over \`things\` twice (or once per list I want to make if there are more than one list). I guess I'll have to just get over the performance cost since it is likely negligible in 95&amp;#37; of cases.
This works ok in most cases but not all cases. In my project, there are actually a few places that has code similar but not exactly the same as my example code (thus the reason why my question is framed so generically). The solution you provided would work in about 90&amp;#37; of the places in my project. The other 10&amp;#37; would need another type of solution. I think the more Kotlin I write the more I realize that in Java, everything was verbose and nothing was elegant so all of the code felt really homogenous which gave the code base a nice, consistent feel to it. Kotlin introduced many clever and elegant ways to do 80&amp;#37; of the things. What this led to is that in 80&amp;#37; of code base, the code is elegant, short and sweet but in 20&amp;#37;, your code is messy and Java like. Although this isn't necessarily bad what annoys me is that 20&amp;#37; of code I just can't seem to write elegantly or write in a style that is consistent with the rest of the code.
If you want to iterate over the whole list and do two things for each element, just do that instead of allocating two lists! Just use `forEach` instead of `map`ping. Or do `things.map { process1(it) to process2(it) }` and deal with the pairs later.
Hmm, do you have a specific example? You can always make a function to do the complex legwork to compute a value and then just provide that as an argument.
JDK 8 is needed, while JDK 10 just doesn't work. According to the log, it seems as if the gradle procedure is broken because of some change of java.exe --version in JDK 10.
Komponent looks pretty cool. Will you be presenting at Kotlinconf in Amsterdam?
Haskell does not have a Bottom type, only a bottom value.
Putting aside the null safety comments that have been made by a good many people, and building on the Pair that people have put forward: data class Scratch&lt;T, R1, R2&gt; ( val r1: List&lt;R1&gt;, val r2: List&lt;R2&gt; ) { constructor(list: List&lt;T&gt;, fn1: (T) -&gt; R1, fn2: (T) -&gt; R2) : this(process(list, fn1, fn2)) constructor(pair: Pair&lt;List&lt;R1&gt;, List&lt;R2&gt;&gt;) : this(pair.first, pair.second) companion object { fun &lt;T, R1, R2&gt; process(list: List&lt;T&gt;, fn1: (T) -&gt; R1, fn2: (T) -&gt; R2): Pair&lt;List&lt;R1&gt;, List&lt;R2&gt;&gt; = list.fold(Pair(emptyList(), emptyList())) { result, element -&gt; result.copy(first = result.first + fn1(element), second = result.second + fn2(element)) } } } Which can be run via: fun main(vararg args: String) = println(Scratch(listOf("one", "two", "three"), String::toUpperCase, String::reversed)) Giving you: Scratch(r1=[ONE, TWO, THREE], r2=[eno, owt, eerht]) It's more code than what you've started with (some of that comes from the generic function handling, etc), but only iterates the list once
Or you could do away with your "A" (my "Scratch") altogether: fun &lt;T, R1, R2&gt; List&lt;T&gt;.process(fn1: (T) -&gt; R1, fn2: (T) -&gt; R2): Pair&lt;List&lt;R1&gt;, List&lt;R2&gt;&gt; = fold(Pair(emptyList(), emptyList())) { result, element -&gt; Pair(first = result.first + fn1(element), second = result.second + fn2(element)) } Run: fun main(vararg args: String) = println(listOf("one", "two", "three").process(String::toUpperCase, String::reversed)) Giving: ([ONE, TWO, THREE], [eno, owt, eerht]) No need to invent data structures that don't give you much (anything)
 Javalin.create().apply { disableJerk() get("/response") { ctx.result("Thanks!") } }
_TL;DR:_ - Scala is losing interest, mind share and contributors. - Competition for adoption comes from multiple angles: Kotlin, Java, Haskell. - Scala 3 is not the savior. - Focus on addressing issues people actually have, instead of producing papers with academic novelties. - Decision-making and development shouldn't be lead by people who don't have any skin in the game. - Sacrifice half the community, send them to Kotlin. - Focus on having fewer, better features to make Scala a great FP language. (Best effort, corrections welcome.)
No, I won't even be there. Komponent is just a simple helper using the static html builders to simplify front-end work, but it works for me.
You can make it this way: import kotlin.properties.Delegates var s:(Int)-&gt;Int by Delegates.notNull() var counter = 0 fun main(args:Array&lt;String&gt;){ s={_-&gt;if(counter==6) -1 else {counter++; s(counter)}} println(s(-1)) } Which means you can assign variable later and lambda will see this variable.
That was the keynote for scalapeno 2018. I've been in the audience and the talk was awesome. Was hard to believe so much praise to kotlin over there but it is well justified. Seems like kotlin is on a good path to take over Scala popularity.
I think this post should be removed.
Judging by my day-to-day interactions, there's mainly 2 reactions from Scala "fans" towards Kotlin at this point: - "it's Java for Hipsters lol" - "Woah they're doing it right"
There are fonts that help with that.
Ok, didn't know! Are there languages supporting bottom type? 
https://www.dyslexiefont.com/en/typeface/ https://www.opendyslexic.org 
val doesn't mean immutable, it means readonly. Kotlin doesn't have a keyword for immutable. 
Scala has a `Nothing` type that Kotlin borrowed. TypeScript has `never` type.
You can compile it using llvm without the standard library so... sure.
I recommend you to signup to the kotlin slack and search for the kotlin native channel and ask there, the devs of kotlin itself are super active there and answers almost every question. http://slack.kotlinlang.org
Ok, thanks. ill try
Effectively same though right?
I have no experience with Kotlin native, but I'm very profound in Kotlin itself, and I have quite a bit experience with native languages and system level tooling (not too much though). Although I can understand your thoughts, I'm not sure if you ask the right question. If you talk about system level stuff, there are some very important things to consider, that aren't necessarily the very important things for Kotlin, or Kotlin native. For example you talk about simplicity. You get a bigger portion of simplicity and easiness with Go, as this is what it was designed for. Kotlin is simple, yes, but it's simple in it's own domain, compared to other stacks in its domain...which is mostly JVM. So there are a lot of things that are done in Kotlin having this background in mind. Also, there is Rust, which is the most probable replacement for C++. Rust is not simple, but it makes achieving the common goals in system level programming very easy. You get a lot of modern features you may miss in C when coming from C#, but maybe the features you want are already present in Go (coroutines, multiple returns, no exceptions, structural typing). Finally, I think that Kotlin native currently still lacks some things that you get for free using Go or Rust: Speed/Performance. Libraries. Bigger communities. Production readiness.
No, you can make a val be for example a mutable list, which wouldn't be immutable. You can even return different objects if you define a getter or use a delegate. 
It does mean immutable if you get the scope right. You *cannot* change the thing that the val references to a different thing. If the val references a mutable thing, you *can* modify that thing in place.
Unless the val is a delegate or has a custom getter. A val in Java would just be a getter without a setter, but there is no guarantee that a getter always returns the same thing. 
You‚Äôre getting a lot of downvotes, and I suppose it‚Äôs because that‚Äôs a bit of a strong statement. I‚Äôm sure no one set out to make your life harder. Maybe a post asking for advice about how to make the keywords differentiable would get a better response.
Apart from anything else, they just look cool. I might try them out.. 
An alternative is to use Mockk. It adds the possibility to mock static
a a dyslexic those fonts are terrible! actually makes it harder to read...
A "powerful" language is not necessarily a good language for OS dev. For that you want something very low level, like Assembly, C, and other "system languages". Kotlin in my opinion is a great "application / industrial" level language. Each have their own quite different set of requirements. Languages are tools, nothing more. Make sure you use the proper tool for a given job. Like, I wouldn't try writing a native Android app in C or C#, but also wouldn't write a high performance RTOS for a microcomputer in a JVM Lang like Java or Kotlin.
I don't think so as even the LLVM backend is garbage collected thus includes some kind of runtime.
Isn't val the equivalent of declaring a variable as "final" in Java? 
I do believe it's fine. I came from a Java background, but you might as well start with kotlin.
This is a very frequent question on /r/androiddev and the general consensus is, you should be able to read Java at least. Most of the commonly used libraries are written in Java and a lot of sample code you'll find will be in Java. I'd say learn Java and then switching to Kotlin will be quite easy.
I started programming in earnest only a few months ago and I started with kotlin instead of java. I've hit this point where if I want to learn a new feature, there's always a tutorial about it in Java and maybe 50% chance there is one in kotlin. That being said, even though I haven't taken a course on Java, I am extremely confident when reading the Java code. I'm actually wondering when I'm going to need to take a course on Java. I feel like it shouldn't be difficult to pick up.
It's similar, but as I wrote in my other comment a val is more like a getter without a setter. For example this is a Kotlin val, that can't be written as a final field in Java: val now get() = java.time.Instant.now()
[The related conversation over in /r/scala.](https://np.reddit.com/r/scala/comments/8xreuv/keynote_the_last_hope_for_scalas_infinity_war/)
I'm not trying to bash Kotlin, I actually quite like it, but how can people claim that it is suited for Functional Programming, if it does not have immutable (as in [persistent data structures](https://en.m.wikipedia.org/wiki/Persistent_data_structure) ) collections. I think that programming using immutability is the single most important factor for FP. Kotlin started a [incubator project](https://github.com/Kotlin/kotlinx.collections.immutable) some time ago to add this to the language, but it doesn't seem like much progress is being made. 
**Persistent data structure** In computing, a persistent data structure is a data structure that always preserves the previous version of itself when it is modified. Such data structures are effectively immutable, as their operations do not (visibly) update the structure in-place, but instead always yield a new updated structure. The term was introduced in Driscoll, Sarnak, Sleator, and Tarjans' 1986 article . A data structure is partially persistent if all versions can be accessed but only the newest version can be modified. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Kotlin/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Non-Mobile link: https://en.wikipedia.org/wiki/Persistent_data_structure *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^199574
A good start may be doing the koans [https://kotlinlang.org/docs/tutorials/koans.html](https://kotlinlang.org/docs/tutorials/koans.html)
The reality is that this is pretty much untested. Java has been around for yonks and most people switching to Kotlin will have had a lot of exposure to Java. Kotlin is going to become stronger as a standalone thing to learn as the years go on but, realistically, Java comparisons will be made until we get there. Having said that, throw yourself in, ask questions online, when you're stuck or unsure - people will be only too happy to help you colour in the picture - and most importantly, have fun! Developer feedback with people who write Kotlin tends to be that they really enjoy using the language. If you've come from another language, you shouldn't have much problem building on your software engineering core to get to grips with Kotlin. If you're new to programming, welcome! :) 
You should be fine learning Kotlin. You'll get exposure to Java just because so many libraries were written in Java or some Android docs are still written in Java, so it will be nice to know what that's doing, too. Focusing on Kotlin is fine. Join the [kotlinlang slack](http://slack.kotlinlang.org/) if you want a huge community to post questions to.
Thank you for your help. I just got myself in *kotlinlang slack*. I think I will really enjoy this. Thank you again. :) 
Will I face any difficulty later on reading Java codes from libraries? 
Can you help me with what specific elements of java should I know before getting myself enrolled with Kotlin? 
Can you let me know where (sites, forums, courses) you started with. Please share the links if possible. 
All of the basic stuff (classes, variables, loops, conditionals, code structuring). Whatever you learn in Java will translate over to Kotlin (or any other programming language really). 
Kotlin is like simplified Scala. In order to achieve a good level in Kotlin you have to know Java, the same is for Scala. I'd recommend you to go to official Kotlin website and check the tutorials there
Thank you for your help, I got some free courses on Udacity and Udemy. First I will learn all the basics. 
I don't think so. If you're a good Kotlin programmer, you will probably understand Java. This happened to me the other way around: I had good knowledge in Java, and reading Kotlin wasn't very hard. But if you're fearing this, then you should start with Java.
I'm still a beginner, but I began on this udemy course, and the subsequent one recomended at the end. https://www.udemy.com/kotlin-course/ after that, I started picking courses that looked interesting or catered to exactly what I wanted. 
Yes, I have been thinking of clearing the basics of Java first. 
I wonder if this was inspired by the Talking Kotlin episode.
Author here. I do listen to the podcast, but this wasn't inspired by it, certainly not consciously. Which episode did you mean though?
AFAIK this was only recently acknowledged by lint?
It's not exactly like Java and Kotlin running in the JVM are completely different languages. They have loads in common so once you understood Kotlin, you should be able to understand Java. You will see that there are a lot of patterns/boilerplate in Java that are solved with syntactic sugar in Kotlin. 
Learning Java first will make you a better Kotlin dev and open you up to many more job opportunities. 
They talk about it in the Application Monitoring with micrometer episode, even talk about making a Kotlin Conf talk.
You may as well learn the java first. Your app will end up full of bugs. The bugs won't be there because of java, although it does make the bugs easier. The bugs will be there because you're learning and android is full of pitfalls. Once you have a few activities done and you can run your app and identify your bugs, then it might be time to switch to kotlin. You'll have a good enough understanding of java to make kotlin programming easier. This is how a few people did it at a company I used to work for. Eventually, we rewrote all the java activities in kotlin. I think that learning kotlin at the same time as android programming will be too complicated in the beginning. You'll have to interact with too much java and will essentially be learning two languages at once. 
You can copy paste code from Java to Kotlin, not the other way around. As long as you know Java, Kotlin will be easier to grasp.
Hi, I code for 3 years Android and my advice is to stick with Java for now. Hiring companies are more likely to ask you Java. Most senior developers are just starting with kotlin in small pieces at most of the companies I know and they don't use kotlin full yet even in new projects because it's a new language and not everyone is so eager to learn it at the same pace as you. On the web almost all articles nowadays are on kotlin (medium tutorials) but those are seniors and they can take the risk to experiment with something new. If you want to get hired fast Java is still the norm and kotlin is optional or bonus points. Learn the activities, fragments, services, broadcasts, retrofit and maybe rxjava then you are good to go. You will learn kotlin at the job if your colleagues are into it but you will not be able to write kotlin if your colleagues write Java. Also in a corporation you will find Java(bigger teams), in a startup you might find kotlin because you might be the only developer or will be a small team that adopts things quickly
I guess it depends on whether you are using the purist definition of immutability and FP. I actually code in Scala on my day job but use Kotlin for everything else (side projects, mobile apps and open source projects). IMHO, if you have effective/reasonable level of immutability, null handling, higher order functions, map/filter/reduce, then you have just enough to significantly reduce bugs in code just from these features. Kotlin brings these plus a whole lot of other cool non-FP features as well. Sure, Kotlin is missing Higher kinder types, implicits, for comprehensions, etc, but I can honestly say that I can be extremely effective even without these features. 
Sure, knowing Java will help you learn Kotlin faster. Do you need to know Java before you learn Kotlin? Absolutely not. I've been teaching Kotlin to new co-workers with no Java experience with no problem. I'm even teaching our product managers with little to no programming background. The real question is, what is your priority? Kotlin or Android? Android can be tough to learn, and it's possible you will find more/better tutorials in Java. That said, the Android community has really embraced Kotlin, so it might not be that much more difficult, but I can't speak from experience. The only other question I would ask is what is your programming background? Personally, if I we're starting fresh, I'd take the leap and learn both Kotlin and Android, but it's probably not the right choice for everyone.
This seems like a bad set of questions. Java has statics which are companion objects at the end of the day. Kotlin can also be used as a functional language, it‚Äôs even in their FAQ. I stopped reading after that point.
Agree. I'm also missing the part that it can be used with the functional programming paradigm.
Another Design Pattern is destroyed by Kotlin
I have started with Java 10 a few hours ago. After reading all these suggestions I thought it would be better if I get my Java basics clear. And after I'm done with Java I will shift to Kotlin. 
I'm just getting started with programming. And I'm doing this because I just dropped out of college and want to learn this as I'm really interested in it. Also can you help me with C and C++ and Android NDK to develop app many or few people have been using it. Is it fine not to know C/C++ as it is not something google promotes. 
You should absolutely learn Java first. It will make you appreciate Kotlin more.
Imo java is easier to learn. Once you know kotlin well you will only need to spend a couple minutes learning java. The good thing about kotlin is that you have to write less and it looks nicer.
Imo Java? Could you please elaborate a little?
My dad's dyslexic and likes the dyslexie font
Kotlin is easy to learn, harder to master. (Which is a good thing) It has a good learning curve but alot of room for learning. Java is similar, but you have to write alot for small tasks. This makes java look ugly.
Hey, Sho3Boom, just a quick heads-up: **alot** is actually spelled **a lot**. You can remember it by **it is one lot, 'a lot'**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
So I think I should get my Java basics right for now. Thank you for your help. 
delete this
Those font don't work for everyone (sadly they don't for me) and probably would not work in this case with var and val being so similar.
Doesn't it mean immutable reference ?
It is true that the usefulness of fonts or any specific font will vary from dyslexic person to dyslexic person, dyslexie font specifically would likely help with the L and R issues because the lowercase L and R look dramatically different to eachother, but, again, each individual case is different. I wasn't stating that the fonts will fix everything, but merely trying to help you.
I have a few options to deal with it, from making `var` bold red to making `val` spell `let` or quitting Kotlin. I'll be sure to share my solution, if I don't end up going for option 3.
It's enough to learn signatures in Java, so you can read documentation. Learning big libraries or frameworks like Java / Android takes the most effort and it is enough, if you understand how Java signatures work to read the documentation and learn the usage of these libraries by using Kotlin.
It mostly means readonly property. 
The biggest thing about learning kotlin is thinking about problems with a kotlin mindset instead of a java mindset. In kotlin, you don't need to wrap your functions in a class, and you dont need to pass Field instances, if you use reified type parameters with an inline fun. Consider the following code: enum class TheEnum { A, B, C, D } fun main(args: Array&lt;String&gt;) { val value = "B" val enumValue: TheEnum = getEnumValue&lt;TheEnum&gt;(value) println(enumValue) } inline fun &lt;reified T: Enum&lt;*&gt;&gt; getEnumValue(value: String): T { return T::class.java.enumConstants.first { it.name == value } }
I understand and that makes perfect sense if you now what is *TheEnum* but this method accepts various types of enums and I need to convert it to appropriate one and therefore I am not sure how to invoke *getEnumValue* 
My code accepts any enum
your method `getEnumValue` accepts any value but when you invoke you know which enum to pass `(getEnumValue&lt;TheEnum&gt;)` but in my case I don't know which type is Enum, so my question would be how would you find out which enum type is `field` and than invoke `getEnumValue&lt;myGenericEnum&gt;`
OP is using reflection, to use reified types you need to know your types in advance.
/u/smurfkiller013 pointed you in the right direction in terms of mindset (no need to put this function in a class) but unfortunately missed your use case. The problem is your bypass of the generic signature of Enum.valueOf(..) with a raw type (in your local variable). Kotlin doesn't allow this, so the workaround is getting all enum constants via getEnumConstants, casting the returned array to the enum supertype (all enums extend java.lang.Enum by default) and finding the first element that matches your name. I'm also not sure why you're getting the class name from the field type and then invoking Class.forName, so I'm cutting that out aswell. With all that, your function looks something like this: fun parse(field: Field, value: String): Enum&lt;*&gt;? { return field.type.enumConstants.map { it as Enum&lt;*&gt; }.find { it.name == value } } Also, I believe there isn't an SO question for this kind of problem space (reflecting an enum value via a class and name only known at runtime). Would you be ok with me putting this on there, with proper attribution?
Pretty much the main points.
You can wrap Clojure's persistent data structures in a very simple way. I actually \[did it\]([https://github.com/Hexworks/funktion](https://github.com/Hexworks/funktion)). There is also \[Arrow\]([https://github.com/arrow-kt/arrow](https://github.com/arrow-kt/arrow)).
How is this different to just using default values in the data class itself?
nice, that's just what I was looking for, thanks to you and /u/smurfkiller013. I agree, kotlin is change of mindset :)
I think the point here is that Kotlin gets you at ~80% of FP functionality you generally need and if you don't need the exotic stuff from the long tail that's enough. What you get in return is pragmatism and simplicity.
There's just one difference, you're not specifying these default values yourself. As I said in another comment, sometimes it feels wrong to set default values in a data class. An example would be when representing business entities. It may not make sense in a business logic point of view. I don't want my app core business class to have erroneous information just because it would make testing easier. Another example where it will help is in nested classes, where you'd need to specify a default value for a class to specify a default value for another one etc. 
It won't translate into functional languages, though. 
I would really like hkt, etc., though... Just would make kotlin even greater. 
Arrow has hkts!
Kinda true. Functions are still there. The looping/conditional constructs will be different (map, filter, reduce etc instead of foreach....). But if he's looking into get into Android, I think understanding OO is more important initially. 
Just use try catch. 
I'd suggest learning one language deeply to start instead of spreading yourself thin across multiple languages. You'll find that new languages are easy to learn once you have solid understanding and experience with one. I'd say Java is the better choice for you from a job market standpoint. Kotlin has only recently started to get adopted in larger companies, so there really aren't many jobs out there. I know I haven't really seen any. I personally wouldn't bother with learning ndk until you've gone pretty deep into Android. Java or Kotlin would be the right choice to start.
No. It's not really needed, either - Kotlin isn't completely "safe" by default and any unsafe code is unsafe because of possible exceptions. As for asm, Kotlin isn't a super high performance language that would need that feature. Besides, it has multiple compilation targets (JVM, JavaScript, native) so that would be either impractical or limited scope anyways. The closest things to what you're talking about are @Throws and try blocks. 
Ok thx.
I am not sure I agree with not needed. There are been cases where I've needed at least raw Java but bytecode would have helped. Agree with other points though.
&gt; As Kotlin runs on JVM platform so it is secure. Kotlin has removed null pointer exception that was a big problem in Java. Can we please ban these submissions?
The link seems to be dead
Thanks!
It works for me :/ 
Is Kotlin now availaable in CLion on Windows?
The URL-encoded hash seems to break it on Safari for iOS. This here works: https://github.com/thomasnield/kotlin-statistics/blob/master/README.md#random-selection
I'm not talking about things like Higher kinded types, etc. I'm saying I do not believe Kotlin provides effective/reasonable level of immutability, which to me is the most important feature for 'functional programming'. /u/addamsson above mentioned that it is easy to wrap something like Clojure's persistent data structures. I'll give that a try. 
Very nice. For Butter Knife we talked about generating an extension function so that you write `bindViews()` with the implicit `this` as the specialized receiver type and the more general `Activity.bindViews(): Unbinder` falling back to the reflective lookup for polymorphic binding. I'd be happy to have this part of Butter Knife directly.
Why don't you use JavaScript?
I know Java really well. I have not used Javascript or Kotlin. I would rather learn Kotlin than Javascript, so I will give that a try first. I am curious about any hurdles I may run into. If for some reason the Kotlin route does not work out then I will try implementing in javascript.
I don't think using Javascript as a compile target is the same thing as writing a Javascript implementation. Think about it from the perspective of other Javascript engineers coming to this project to help mantain the "Javascript" implementation.
ahhh, now i get it. you're a java developer and need to make things unnecessarily complicated ;-)
but seriously, if you're not interested in learning or using javascript, why even bother with this project? the people who benefit from it will know js but not necessarily know kotlin. aside from transpiled code being a bunch of gobbledygook, their ability to assist in fixing bugs will be limited unless they know kotlin
&gt; Is there any good reason not to take this path? When you do library and API development, you need to keep a certain set of design principles firmly at the forefront of your mind. Please give this some serious thought. Consider what kinds of people will be interacting through different channels regarding your library, what their own perspectives and objectives might be, and what kind of different future scenarios might affect your library and its useres in different ways.
I've listened to the episode again, and it's eerie how precisely they're talking about this. Nevertheless, the library is more than a year old. Maybe the idea to write about it now came subconsciously from listening to the podcast :)
Good poing, looking at the source for a dependency is a common thing I do when debugging a problem with a dependency. 
Thats a good point. There is no way to know if your API is good w/o a good understanding of JS.
Zing. I could also try to work Graalvm into the mix.
I think you can just wrap the Go API with FFI too.
I think you will find that chars are 2 bytes https://github.com/JetBrains/kotlin/blob/1.2.50/core/builtins/native/kotlin/Char.kt#L20
Instead of performing a map with an unchecked cast, I would recommend using the Kotlin Standard Library's `filterIsInstance` method. That would instead give you `return field.type.enumConstants.filterIsInstance(Enum::class). firstOrNull { it.name == value }`
Instead of a `map` with an unchecked cast, I would recommend using the Kotlin stdlib [filterIsInstance](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/filter-is-instance.html) extension. That will give you `return field.type.enumConstants.filterIsInstance(Enum::class).firstOrNull { it.name == value }`
Ya, to me that seems the obvious reason. If Google stayed with Java it would be a future of dog bites from the top Dog at Oracle. 
another example of the readers of a medium article knowing more than the author
I thought about that, but the intention here isn't filtering, but assertion. If for some reason ```Class.getEnumConstants()``` returns an array of objects that do not extend the Enum type (think spec non-compliant JVM, bytecode translators, etc.), it would silently return an empty collection and the call to firstOrNull would always return null. Casting via a map will throw an exception directly in your face. 
When you try to teach something in Kotkin and half the post is about Swift, that's a bad sign. But comments are great. 
Consider Typescript. It's both closer to the mindset of a Java/C# developer and very accessible for a JS developer. Unlike KotlinJS, it's pretty popular. It also has a lot of overlapping features with KotlinJS. 
&gt; In this talk I'd like to show You the biggest advantages of Kotlin - a great new programming language for JVM, Web &amp; Native. &gt; I use it for over two years now, and I simply love its readability, elegant solutions of Java‚Äôs biggest issues, and vast amount of features that we won‚Äôt see in Java anytime soon‚Ä¶ &gt; During this talk You'll learn about Kotlin's main characteristics (e.g. null-safety), seamless Java interop, greatest features (e.g. extensions, data classes) etc. &gt; But, most importantly, you'll see that Kotlin is easy to learn and makes you more productive and satisfied as a developer :)
Why shouldn't that smart cast behaviour be allowed?
"Shouldn't be allowed" is too strong. "Would be surprised when it works" is more what I meant. Smart casts change the effective type of a value within some delimited scope. The most common example is: if (someValue != null) { //someValue guaranteed to not be null } You might think that `?.let` ends up doing the same thing, and it sort of does: var someValue : String? = null //... someValue?.let { println(someValue.length) //someValue smart cast to String } But it's easy to fool this construct: var someValue : String? = null //... someValue?.let { println(someValue.length) //error: local variable captured by changing closure } someValue = "foo" I was actually mistaken before. I thought that the `inline` nature of `let` might have been helping it check the smart cast, since it could prove that the lambda parameter to `let` isn't captured and, if invoked, is immediately invoked. The compiler *could* do that. But now I'm pretty sure that the current Kotlin compiler doesn't consider `inline` functions in smart cast resolution in this case. So really, using `let` in this way only works in really specific circumstances. It's far more idiomatic and clear to use it this way instead: var someValue : String? = null //... someValue?.let { println(it.length) } or to just use an explicit `if` with smart casts: var someValue : String? = null //... if (someValue != null) { println(someValue.length) } 
Thing is the `if` version on a var where you call any lambda earlier also doesn't work, so that's not really a problem of the `let`-way. You're right that it is surprising though. I believe fancy type stuff with functions is coming with the contracts api!
The OP wants an "Enum object" from the field, so it seems unlikely that would be the case besides a non-compliant JVM which seems like a different issue altogether
Can anyone share his or her experience on using the reactive / functional APIs?
"Do I need reactive?" is the first question you should ask yourself. If you don't need it, just forget it. Really.
Nice article! From time to time, I'm amazed by other people's work. Very nice ideas - I think I have to read the article one or two times again to get it completely.
One thing I've observed by looking at the docs is "dsl hell". Kotlin would make this bearable but using spring 5 in java would be a massive headache imo. 
Sources are available. If you have time and willing, I'd suggest you go through all the steps to go deeper.
There is so much of that everywhere nowadays. I mean, I like lambdas as much as anyone, but they've got some downside as well with all the huge blocks of chained calls which are difficult to read let alone debug.
Thank you! If you have any questions regarding the contents of the post, feel free to reply at medium. I would be happy to help you understand it.
Do you have an example of this? I use lambdas in pretty much all the APIs I make, I've never really noticed any downsides.
That's only really in the context of a class property, though. `val`s declared in actual methods are ultimately `final` as far as the JVM is concerned. And a class property `val` will have a `final` backing field, if the backing field is used (i.e., you don't write a custom field that uses the backing field). e.g. compile ``` class Foo { val bar: Int = 5 get() = field val bar2: Int get() = 6 } ``` with `kotlinc test.kt`, then upload your `Foo.class` to, for instance, [here](http://www.javadecompilers.com/). (I'm omitting some Kotline metadatastuff here.) ``` public final class Foo { private final int bar = 5; public final int getBar() { return bar; } public final int getBar2() { return 6; } public Foo() {} } ```
The big one that comes to mind is RxJava. It's very powerful but I've seen some giant blocks of it chained together with lambdas everywhere. Quite unreadable. Note we're talking about Java here. The syntax for Kotlin lambdas/builders make things a bit nicer.
Very nice! Although I personally haven't gotten a chance to use Kotlin, the Extension Bridge technique will come in handy for Scala as well (Scala has macros, but it is still considered an experimental feature).
Thanks, I'll have to agree in the case of RxJava. I'm not familiar with it, so I'm already confused by some of the examples I'm reading.
Maybe it's just because I'm not familiar with the Android paging library, but I have no idea what this library does
What is about SonarQube?
Good question. I guess you'll have to ask the guy.
Or, you know, you could let your IDE tell you‚Ä¶
Can anyone share their experience of using this feature, especially for ha target?
My suggestion would be to try typescript with strict options turned on. It has some of kotlin's features mixed with some of javascript's legacy issues. It will be easier to sell to any front end devs you get later than Kotlin.
Is it open source? I'd like to implement this to my app.
Yup. Available on gist though, not a full GitHub project.
Yes you are right ! by default this checkmark is off for me :) I added an extra line in the blog post :) thanks for letting me know ! 
This is not a problem here but having a screenshot from IDEA has a lot of downsides: \- Can't copy it from the browser \- Can't see it if I'm using a big screen \- The text becomes blurry if you stretch it. I'd suggest using a \`code\` block or some code formatter tool instead.
Love the idea but how do install the plugin? Do you just jar up the git repo and tell intellJ to install from disk?
Hi! To be able to integrate these kind of services with the new Android Paging Library (which is awesome!) you‚Äôll have to write a lot of code just to initialize everything you'll need. Once you have everything initialized, the paging issue becomes trivial, but the initialization is not. And this is only if you don‚Äôt need database support, in that case you‚Äôll have to write even more code on top of that. This is where Fountain comes to life. It provides everything you‚Äôll need to work with these services and more, easily and without boilerplate.
&gt; Very nice Thank you! I really appreciate your opinion. &gt; I'd be happy to have this part of Butter Knife directly. I would love that. I will create a PR in the upcoming week. Would you rather have the `ButterKnifeKtx.bind(this)` or the "original" `Activity.bindViews()` with specialized receiver type? 
What exactly do you mean by "Java 11 support"? Kotlin-compiled code runs perfectly well under JDK 11, the Kotlin compiler understands .class files generated by javac 11, and you can access APIs added in JDK 11 from Kotlin code. Kotlin does not support marking the bytecode it generates as Java 11, but that doesn't bring any benefits by itself, so it's not a priority.
Thanks for the answer. So it's just that bytecode generation will be stuck to 1.8 and nothing else? That sounds okay.
thanks for the tip ! :D 
The "stuck" word you use implies there is some advantage to it moving. As I said, there isn't any.
Okay, I get it :)
I don't think thats true jigsaw should work and thats a new feature.
Can you please share a link to the github page?
As far as I know, Jigsaw does not depend on bytecode version in any way. The module-info file needs to be written in Java in any case (it's effectively a DSL, and there is no point in creating an identical DSL based on Kotlin). Accessibility checks depend on whether you add .jar files to the classpath or to the modulepath. The Kotlin compiler already supports module-based accessibility checks. In other words, Jigsaw already works.
My favorite: `companion object : Logger`
[https://github.com/thomasnield/bayes\_user\_input\_prediction](https://github.com/thomasnield/bayes_user_input_prediction)
Thanks! Nice demo
Myn is the file level private member.
What's the implementation behind the `Logger` interface? Afaik interfaces can't hold state, so you'd look up the logger in every logging call, right?
Glad you liked it. Forgot here's also source code for an email spam example: [https://github.com/thomasnield/bayes\_email\_spam](https://github.com/thomasnield/bayes_email_spam)
Oh sorry, this one isn't an interface, but an abstract class.
Ah okay, missing the instantiation parens then. With that solution you must keep in mind though that companion objects doing this won't be able to inherit from any other class, which might be annoying down the line.
You're right. I forgot the parens there. 
Kotlins syntax us quite complex, does this cover everything?
[This stackoverflow anserw](https://stackoverflow.com/a/34462577) is more complete.
I believe so. I tested across a large corpus and even ran into some grammar issues I opened YouTrack issues for. There are definitely some edge cases/complexity and while I believe the AST covers everything, not every exact use of whitespace/comments is supported.
I've generally put my loggers within the companion object and it irritates me everytime as it's often the only member within - especially after seeing how much the compiler generates each time. I still don't think there is a great solution here either as mentioned in the article - but private member variables are potentially the best of a bad bunch. The kotlin-logging library is nice, but really just another workaround in itself and I don't want yet another logging dependency just for the syntactic sugar.
Presumably they will update for Java 11 as it's the next LTS release.
If you're learning, start with Java over C, C++, and Kotlin
&gt; Why no static keyword? &gt; No idea. It‚Äôs one of the very few annoyances that I have with Kotlin in that it‚Äôs way too difficult to define static variables. If you're defining a lot of static variables in your code you might be doing something wrong.
True, but there are still plenty of reasonable use cases for static - logging being one of the biggest - for which there really isn't a great solution in Kotlin. Companion objects can you the same final behaviour, but at the cost of unnecessary boilerplate and inefficiency.
Why is a companion object inefficient? Because it allocates an extra MyClass.Companion instance? If that's inefficient, it's rather bad design.
Logging frameworks usually cache created loggers, so calling the factory method for every instance is not a problem. SLF4J with log back for example does. Secondly, if you‚Äôre building a spring application for example, most of the beans are just created once (scope: application). So just make it an instance field and you‚Äôre good. 
This article explains what happens behind the scenes. It's quite ugly https://medium.com/@BladeCoder/exploring-kotlins-hidden-costs-part-1-fbb9935d9b62
Agreed, don't see what the fuss is about.
&gt; logging being one of the biggest - for which there really isn't a great solution in Kotlin. What's wrong with [kotlin-logging](https://github.com/MicroUtils/kotlin-logging)? 
With the new Java SE support model, the difference between LTS and non-LTS releases is relevant only for commercial customers of Oracle, so no, Java 11 has no special significance for the team in this regard.
Oh absolutely nothing and I've used it before. It's just unfortunate to have to depend on yet another logging library for those features
Fair enough. Presumably you don't plan on staying on 1.8 for the foreseeable future though right? I guess there are much bigger things to worry about but is it not easier to stay current in that case? Forgive my ignorance I don't know how much work it is to generate newer versions and what/if anything has changed 
I would really love to learn kotlin and looking for some books or guides online. Can you guys help me. Where and how did you guys learn and any suggestions would be great. Mainly want to learn for developing android apps. Thanks 
https://kotlinlang.org/docs/reference/sealed-classes.html
How can you mimic the last two cases using Kotlin? | Student("Richard") =&gt; "Still here Ricky?" | Student(anyOtherName) =&gt; "Hey, " ++ anyOtherName ++ "." 
You can achieve this by usng `when` and also introducing the [`is` keyword and smart casts](https://kotlinlang.org/docs/reference/typecasts.html). when(person) { ... is Student &amp;&amp; person.studentName == "Richard" =&gt; "Still here Ricky?" is Student &amp;&amp; person.studentName == "Foo" =&gt; "Hey, ${person.studentName}." ...
Well, in this simple case you can exploit an equality check. This works: sealed class Person data class Student(val name: String): Person() fun main(args: Array&lt;String&gt;) { val person: Person = Student("John") when(person) { Student("John") -&gt; println("It's John!") is Student -&gt; println("Oh, it's ${person.name}.") } } In case of more complex objects (and if you want to use any wildcards), smart casts and additional checks are the way to go. I wish they introduced union types for interoperability with JS, though.
That's pattern matching. Kotlin has the `when` expression, which looks like pattern matching, but is really just fancy syntax for a switch statement which also casts when necessary. IIRC there is a proposal to add proper pattern matching to Java, and if that's implemented I would expect Kotlin to follow suit.
For type declarations, not likely at all. Kotlin already has a syntax to express this. For pattern matching, it is possible that Kotlin will eventually gain a more powerful version of \`when\` that will support unpacking nested structures and inspecting values and types at the same time, but right now it's not a priority.
The widly repeated claim was that two way data binding made Angular inefficient. Now we're doing two way data binding from the server?
Is there a place where we can learn about what priorities Kotlin team currently has or is this an internal thing? ;)
Why does the documentation encourage using `object` to manage database access? :( Single instance good, Singleton bad.
Im still learning a nice bit, so would you be able to explain what the difference is between single instance and singleton? Also why is single instance good, singleton is bad?
&gt; Now we're doing two way data binding from the server? Yup, and the best thing is that **it's efficient** (!) because the server can really optimize its communication with the browser in a way that would be very difficult with more conventional approaches. It's a bit like how higher-level programming languages can sometimes be subject to better compiler optimizations than lower level languages. It works surprisingly well already despite being pre-release. [Here](http://mediator.ai/) is a site I'm working on using Kweb. While it's still a work-in-progress, note that it's quite snappy, despite running on a $50/mo shared EC2 instance. Take a look at Google's page speed benchmark for [the site](https://developers.google.com/speed/pagespeed/insights/?url=http%3A%2F%2Fmediator.ai%2F&amp;tab=mobile), 99/100 on mobile and 97/100 on desktop. And on top of that it's running on a cheap shared EC2 instance. What made Angular's inefficient?
http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/ One of favourite blog series for good OOP style code.
Yeah, I feel like logging is one of those things we haven't fully figured out yet. It's like we're thinking inside a box without realizing it, and that's why none of the solutions are all that satisfactory.
It is just a simplistic example, I don't think it encourages that.
&gt; Yup, and the best thing is that **it's efficient** (!) because the server can really optimize its communication with the browser in a way that would be very difficult with more conventional approaches. I'm sorry, I really don't mean to be rude, but this is nonsense. Nothing can update the client faster than the client itself. There's no magic in server code that will allow it to overcome the speed of light and somehow push and poll updates faster than can be done in the browser. Maybe this tech makes it so easy to build SPAs that its worth overlooking the performance hit for prototypes and side projects, but two way data-binding killed Angular and I don't see how extending that to the server will lead to a successful framework. I would be quite happy to be proven wrong, as I would kill to use Kotlin over JS.
The transaction manager (also global) uses thread locals for storage as well. It's a good library, but has some questionable design decision surrounding globals. I think they are planning on revisiting that at some point though.
yes, see this issue: https://github.com/JetBrains/Exposed/issues/255
At this time the Kotlin team does not publish any official roadmaps.
Incrementing the bytecode version is a simple change, but once again - this brings no value by itself. Incrementing a version number from 8 to 9 is exactly as much effort as from 8 to 11. We'll definitely update the version when new bytecode versions will support new features that we'll want and will be able to use. Before that, the bump may or may not happen.
I think you're misinterpreting the results from Google Page Speed a little in this case. Your page doesn't have a speed-score because google doesn't seem to understand how it's built. You do have a good optimization score because your page doesn't have a lot of things that can be optimized. Change your network settings to "Slow 3G" in Chrome, and you'll see that your page takes 10 seconds for the first render, a typical SPA should take 3-4 seconds (first render is typically a loading page then though). Overall it might be better than traditional SPA (I don't know), but I wouldn't use Google Page Speed as proof of that.
&gt; Nothing can update the client faster than the client itself. I agree, however Kweb can pre-load DOM modifications to be executed immediately on a browser event without a server round-trip. &gt; There's no magic in server code that will allow it to overcome the speed of light and somehow push and poll updates faster than can be done in the browser. True, but it can do a lot of optimizations to minimize the amount of delay experienced by the browser and user. &gt; I would be quite happy to be proven wrong, as I would kill to use Kotlin over JS. I suggest you try it, it's fairly optimized even today and there are many ways to improve it further.
That may have been a hasty comparison, typically I use a Chrome audit and most of the time required for page render is spent pulling various JavaScript dependencies from their CDNs, not generating or rendering the page. The point is that it is fairly efficient by SPA standards, and has the potential to be significantly more so because this can be optimized further.
singletons make unit testing *very* difficult. Dependency injection (specifically constructor injection) makes unit testing easy. https://softwareengineering.stackexchange.com/a/40610 tl;dr: generally speaking, don't use `object SomeClass` where `SomeClass` contains mutable state. If you are storing constants within `SomeClass`, that's cool
Pity it's not a priority. It's one the key missing features from an otherwise excellent language imo.
If HP Fortify would get proper Kotlin support, I'd be able to switch my customer over to Kotlin for all new development. Fortify can can bytecode, but the results are less than impressive.
I've used Fortify once. On 180 pages, I had 3 really relevant security issue, and one of them was really severe. But it's a lot of noise....
Oh, Fortify is a rancid piece of shit, no doubt about it, but it's also a requirement for anything that people might devote serious attention to attacking. For a static blog generator it's overkill, but if you're doing something like financial transactions over the internet, it's definitely a better safe than sorry situation.
Great write-up! Although I would like to add one more significant difference between sequences and collections: sequence operations are evaluated lazily (much like the Java Stream API) while list operations are evaluated eagerly. So, when working with large collections, choosing a sequence over a list may end up giving you a large performance boost, especially when doing a bunch of filtering, or using operators like `take`, `first`, `last` etc. Note that sequences are not always faster, here‚Äôs a good write up I found that shows a couple of different scenarios: https://medium.com/@elye.project/kotlin-slow-list-and-lazy-sequence-61691fc974c5
I just started writing on this new series and blogging in general, so I would be thankful for constructive feedback. In this series I want not only to show how to use coroutines, but also how one can get from the few primitives, Kotlin provides, to the high level abstractions we get from kotlinx.coroutines.
In our experience, the number of cases where Kotlin's existing combination of 'when' and smart casts is not enough is rather limited.
Thanks for your feedback. I'll edit the appropriate section in my blog post. I've read the linked post regarding Collection vs Sequence performance and I have to say that it's plain wrong. This is not how you do performance measurement on the JVM. The main mistake of is that the author measures both sequence and list operations one after the other in the same JVM instance. That way you get totally different results if you flip the order of the code because of JIT and GC. If you isolate the tests and run each test one by one, you get totally different results. See: https://github.com/winterbe/kotlin-examples/blob/6240fffb2355bb981f2d5a59c738b2416d2c4abf/src/test/kotlin/com/winterbe/kotlin/sequences/PerformanceTest.kt Sequences are an order of magnitude faster due to lazy evaluation.
Thanks for the response, you make a good point. I learned something today! üòÖ
I like that you didn't go the easy route just repeating what the first page of the official documentation already tells us - because there are already so many basic tutorials about this topic. So a +1 for this alone.
I like seeing Kotlin articles so a +1 for me. Thanks.
Could you review the comma usage on the article? It was a bit difficult to read some sentences as (I think) there are some commas where there shouldn't be. For example, about in the middle of the article you wrote: &gt;Now this extremely simple example only works, because neither of the two coroutines \[...\] You are kinda separating the explanation from the fact with this comma in the middle of the sentence (see more here: [https://www.grammarly.com/blog/comma-before-because/](https://www.grammarly.com/blog/comma-before-because/)). Not trying to be punctuation nazi here. It's just to improve the readability.
I guess my German caught me there.
I haven't used Coroutines much (yet). I have 2 questions about them, would really appreciate if anyone could answer them. I'm writing Scheme R5RS interpreter in Kotlin (https://github.com/kovrik/scheme-in-kotlin), so far so good, though a bit stuck at the moment, don't have much time and also being lazy. I want to introduce Kotlin's coroutines as special forms in Scheme. Not a problem for async, runBlocking and launch because they don't need function to be marked as suspend. 1) However, others (delay, for example) require **suspend** keyword. My special forms all implement the same interface which has method eval(...). If I add suspend to eval(...), then I'll have to add it everywhere -- in all other special forms, then in evaluator and so on. So it kind of propagates all the way up, if I understand it correctly. Is there a solution for that? Can I mark with suspend just some of them? 2) Under the hood coroutines use continuations. How does they compare to Scheme's Continuations? I have my own Continuation class, implemented via exceptions (inspired by Kawa's implementation). Can I replace it with Kotlin's Continuations completely or they are different things?
That's something I wanted to do for a few months now, so thanks :) What would be really awesome with that is some kind of gradle plugin that allows to parse classes at compile time, generate code and start a new compilation round until nothing is generated (similar to Java annotation processing).
[http://caster.io](http://caster.io) is one I can think of.
This time I am writing about obvious and not so obvious situations for you to encounter NPEs in Kotlin.
This is an interesting article, but I wonder how much of the improvement can be attributed to the JVM itself rather than Kotlin specifically. I am glad to see more companies embracing Kotlin on the back end, however.
Nice, short article, thank you! Especially the information about null values as arguments could be useful for many people :)
The performance win is obviously caused by the JVM, but Kotlin is the language that makes using the JVM far more attractive for Python developers compared to Java.
I kind of wish there was a compiler switch to treat Platform Types the same as ? and force checking on them. I've been burned by NPE's from Java libraries before.
This. I can understand why jetbrains decided to add Platform types, but at least an official compiler flag should be provided so that people wanting maximum safety can get it. 
Can you show us some specific code? Generally, you shouldn't really worry about efficiency unless you have a specific reason to. Oftentimes, just creating a new list instance is fine. But if performance actually is critical, then you'll probably have to use mutable lists and change the elements in place, doesn't get more performant than that.
You probably know that the collections in kotlin are not immutable, the collections by default are read only. Probably [this ](https://stackoverflow.com/questions/33727657/kotlin-and-immutable-collections/33738910#33738910)stackoverflow question will help you understand the differences between the types of collections. So, when to use them? Kotlin offers a great type of methods for this type of collections, that is a point in favor. Another question is why we always use, in other languages, mutable type collections when we do not take advantage of them as we should. For example, imagine that I want to obtain data from an API and save the information in a list, this data is only obtained and displayed, it does not make sense to use a mutable table, since it will not be edited, it will be read only. [Kotlin official docs](https://kotlinlang.org/docs/reference/collections.html) give you a better idea of what I mean. I hope I have helped. Greets and keep coding. ![](https://media.giphy.com/media/5u1BmupTSGSA0/giphy.gif) 
Thank you! That was helpful. After reading your stack overflow reference I realize I did not understand the default state of Kotlin collections. If I understand it now, the collections are mutable by default and can be used/accessed with a read-only interface, almost mimicking an immutable collection. Correct? Thank you for the API data fetching example. That makes perfect sense. I feel silly not thinking of it before! I appreciate your time and patience!
&gt;If I understand it now, the collections are mutable by default and can be used/accessed with a read-only interface, almost mimicking an immutable collection. Correct? Yes, I think you got the most important part. Besides that, although Java's interfaces are used, the underlying implementation could be immutable nonetheless - most (all?) altering methods will throw exceptions. Since the differences between readonly, mutable and immutable are clear after the stackoverflow thread, and **if** you need immutability, there is this one [https://github.com/Kotlin/kotlinx.collections.immutable](https://github.com/Kotlin/kotlinx.collections.immutable) :)
It doesn't work: https://www.youtube.com/watch?v=2IhT8HACc2E
&gt; you shouldn't really worry about efficiency unless you have a specific reason to I mean, I get your point, but I wouldn't say this is something to strive for at all. Immutability is one thing, but regarding efficiency as an afterthought is how we've ended up with such slow apps nowadays even though we have more compute power than ever.
Well, expecting big lists is a perfectly valid "reason to worry about efficiency" :) I'm just saying that mutable shouldn't be the thoughtless default, because that's how you get mutability / shared state bugs. If being mutable is a conscious deviation from the immutable default, then you're more likely to actually think about the potential for bugs and ways to avoid them.
That was very interesting to watch. Thank you!
Yes, i know this video. But he states that you can't have null safety, convenience and java interop at the same time but just two of them three. I would prefer to have the choice to exchange convenience with null safetyness. Or at least i *think* i want to have it, because i don't know how it is being forced to work like that :)
I love the InlineClass and UInt implementation of it.
Look forward to quite a few of these things. I appreciate some of the bugs being fixed, but there are a lot more I think should be tackled. There are so many puzzlers and oddities. Also, I wish dokka would get some love. In the meantime, where I can I see updated stdlib KDoc for all of these new items?
I was one of those asking for serializable continuations a few years ago, they could prove very useful for [kweb](http://kweb.io/), among other things. Great to see it make it into 1.3.
xposting the reply from /r/androiddev &gt;Note that the Kotlin style guide discourages using SuccessOrFailure type as a return type of Kotlin functions. This is similar to how users are encouraged to have suspend functions return some type instead of plain functions returning a Deferred of that type. Usages of `SuccessOrFailure` as function returns are going to start popping up in libraries. Flag them and push back when you see them, as `SuccessOrFailure` is designed to be a barebones API that's verbose on purpose. We'd liked a fully fledged `Try` type instead, but the proposal was scoped just to coroutines and we can only help by respecting JB's design wishes.
Inline classes are awesome. This should replace alot of usages of type aliases since inline classes have stronger type safety.
Hey, Determinant, just a quick heads-up: **alot** is actually spelled **a lot**. You can remember it by **it is one lot, 'a lot'**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Wondering if "Kotlin in Action", written back in the days of 1.1, will get an update with Coroutines and other things added in 1.2 and 1.3
delete
Kotlin is different than Java, not necessarily better. Depends on what we talk about.
We do have plans for the second edition of the book, but due to other commitments we won't be able to start working on it before 2019.
People have a lot of complaints about JS, but most of them fall into one of two categories. they are irrelevant gotchas that are never encountered in real life or complaints stemming from not taking the time to learn JS. I don't love javascript, but I don't hate it either. however Javascript date handling is just fundamentally broken and anti-usable (intentionally differentiating from 'unusable'). If they have functionality to effectively convert to date handling, i'd love to see the generate code
I really hate these cheap posts that just name 4 things that are better in kotlin than in Java and then state that obviously because of that kotlin is the better language. These just sound like someone wants to get upvotes. I could also easily name 4 things that are better in Java, so Java is the better language? Probably not. They're just different languages and lots of things in kotlin are still rather unstable and incomplete design-wise. 
Do you have a specific use case? I could think of Value Objects in DDD, which can however be modelled with data classes (but seem to have more overhead than inline classes)
Say you have a method that creates a list of files your program needs to open. Say you have another method that reads these files and turns them into some data structure. Like for example the source files are images and you turn them into a gif animation. This list of files doesn't need to be mutable. It's created in one method and read in another. In my experience 90% of collections in a typical program can be immutable. Reducing the chance of issues a lot. 
&gt; I could also easily name 4 things that are better in Java, out of curiosity, what would those four things be? for bonus points, try to focus purely on the language and not reference ecosystem or any tangential benefits
* Java has better type inference in many cases, for example [KT-5464](https://youtrack.jetbrains.com/oauth?state=%2Fissue%2FKT-5464) and related issues. * I don't know if you count this as ecosystem, but official language-tools like dokka are not well supported and often produce garbage output compared to the Java-equivalent tools like javadoc. * Java has better literal support, like hexadecimal float literals, the ability to write Long.MIN_VALUE as literal, unsigned hex literals (they're coming with Kotlin 1.3). The absence of octal literals in Kotlin is fine by me. * Kotlin has many more Language design issues and other bugs, and while Java also has some problems and had some problems, mostly for historic reasons, it just doesn't just [ignore annotations sometimes](https://youtrack.jetbrains.com/issue/KT-15453), [rearranges the code execution order inconsistently](https://youtrack.jetbrains.com/issue/KT-23626), [fails to iterate over arrays properly](https://youtrack.jetbrains.com/issue/KT-21354) and again doesn't [have lot's of type inference problems and similar oddities](https://youtrack.jetbrains.com/issue/KT-25268).
Are unsigned integers compatible with Java? Or, in other words, can a Kotlin API exposing unsigned integers be called from Java without increasing the risk of errors?
someone spent hundreds of man hours on this
[https://github.com/dimabory/ecoji-js](https://github.com/dimabory/ecoji-js)
YouTube playlist -&gt; https://www.youtube.com/playlist?list=PLnYRVL0Cw1FT5LO1r3QWku_VyY1H1et7w
That went well... 
Suppose you have a function that accepts multiple parameters of the same type (eg. age &amp; weight), inline classes prevent mixing up the arguments (named parameters also help with this)
Another really awesome use-case is to prevent using incorrect units (eg. kilometers vs. miles) like Nasa did. I would have an inline class for each type of unit [eg. inline class Kilometers(amount: Double)] and conversion functions that return a new "instance" of the correct type. So this effectively guarantees that I'm working with amounts of the correct type at compile time without any performance or memory overhead
Could we also have a book / guide about performance considerations &amp; mitigation strategies specific to the Kotlin language (please)?
The goal of both JetBrains and Google is to reach a point where such a guide would be empty, and we're making good progress towards that goal.
I don't understand their reasoning behind this at all. If anything the situation is now worse. I get the want to create dedicated domain models etc, but Try/Result variants are used more and more now and this was the perfect time to introduce a defacto implementation. `SuccessOrFailure` is going to start popping up now because it's a valid use case for it. They said that you should never use it for this reason, but I can't believe how naive they must be to believe it won't start happening. If anything they've just created more problems for themselves.
Yeah I see that and the other use case you mentioned, that's what I'm already doing :) However I'm using data classes instead of typealiases, so I guess the difference is that inner classes don't have to create a boxing object? Because it's seems to be syntactical equal, e.g. Name("Peter") I can't tell if it is an inner class or data class. I love features going in that direction, was just curious about the technical side :) What is really cool about it compared to data classes is that it's just a wrapper around the type, so Name("Peter") == "Peter" should be valid, where in data classes I would have to write equality myself in that case
And how would a negative integer passed from Java be interpreted in Kotlin? Will it throw an exception? Will it be interpreted as a corresponding positive number with the same bit representation of the 2-compliment negative number?
They are inline classes with respective primitive types as contents, and so they will be represented in bytecode and for Java users as those types. For example `UInt` becomes `int` on the JVM, with the same exact bits sets but just interpreted differently. Before, if you want unsigned bytes in Java you just use the signed ones and "manually" fake the toString, modulus etc, but that was always a hassle.
See my reply to the parent comment.
In what category does static typing fall?
well, it's not the first one because it's a not some obscure gotcha. it's a fundamental concept of dynamic languages. so if that's tripping you up you're probably incompetent hrm...that pretty much goes for the second category as well i guess that puts it in a third category: complaints from incompetent whiners
It's a bit tricky as you have to modify `KotlinCMakeModule/CMakeKotlinInformation.cmake`. Here is a working cmake file (works on my Win10): https://gist.github.com/Scellow/20cf766add31326fa02506d3b697f7cc
The one who came up with an idea to name it SuccessOrFailure should be fired immediately IMO. What a horrible name. Try is known everywhere, why introduce such boilerplate? Just implement proper discriminated unions and the issue would be gone. I was always Kotlin's advocate but these things smell so badly...
You should read the discussion in the keep. They explicitly named it this way bacause it is not and should Not be the universal return type for everything. Try or either type are seperate concerns that are still under discussion.
I definitely understand dynamic typing, let's be honest it's not a difficult concept. I can simulate it in nearly every statically typed language by casting everything to `Any` or `Object` and back. I just think it is a rediculous waste to not tell the compiler what type everything has, it can prevent so much mistakes, it helps a lot when going trough docs and it allows IDEs to come up with some helpful suggestions. All dynamically typed languages are flawed IMO, but JS is weakly typed on top too: most of the operators cast stuff until it fits what they expect. I hope you can see that that is not good language design.
* Your first point will be addressed in Kotlin 1.3 (the 1.3 pre-release has just been announced) * Dokka is open source so anyone is able to submit fixes / improvements * Kotlin 1.3 adds support for unsigned literals * Your last point also references defects. The Oracle Java Bug database shows that over 200,000 issues were submitted (with many of them fixed): [https://www.oracle.com/search/results?Ntt=&amp;Dy=1&amp;Nty=1&amp;cat=bugs&amp;Ntk=S3](https://www.oracle.com/search/results?Ntt=&amp;Dy=1&amp;Nty=1&amp;cat=bugs&amp;Ntk=S3) The point I'm trying to get across is that there doesn't exist any non-trivial project which doesn't have any defects and Kotlin is progressing at a very fast pace. Regarding actual language issues, Java pioneered many ideas over time (which is great) but it chose to maintain backwards compatibility (which is also important) so defective scenarios are still allowed. Kotlin borrowed many ideas from various languages so it benefits from the experimentation &amp; progress of other languages. As an example, Kotlin generics are much more robust than Java since Kotlin had generics from the start (so it prevents some broken scenarios which Java allows). Java was a great language for its time and I used it for over a decade. Since Kotlin allows me to leverage my existing Java investments (eg. libraries, tools, etc.) while improving so many areas (such as a reduction in defect rates), there really is no reason for me to continue to use Java.
This is a title that would be written by an "immature" developer. Is clickbaiting really worth of personal reputation?
This line of reasoning prevents anything that is different from being compared. Eg. Honda vs. Ferrari even though intuitively we know which is the better car overall. For me personally, I try to list all the pros &amp; cons that affect me and specify a value for each point (with cons getting negative points). If the total number of points is positive then I am inclined to say that one option is better than the other option overall.
&gt; not good language design certainly not for the purposes javascript is used today, but I think it's unfair to say it was designed poorly. it was designed in a week and a half by a guy who was tasked with creating some super-simple (read: easy to learn and "get off the ground" with) scripting language for the minuscule amount of scripting needed for the early web, and to that end, I think he succeeded. it's not his fault that javascript is used for a completely different set of problems today than those that existed during the language's inception. 
The main difference is that inline classes try to avoid the creation of the wrapper object. Performing numerical intensive computations with my units example above (Kilometers &amp; Miles) would be hundreds / thousands of times faster with inline classes that just work on the primitives directly compared to creating a new wrapper object for each new value. This also reduces the pressure on the garbage collector which will reduce the amount of pauses / stutter and will generally improve the response time of the application.
Sure, it might have been designed it a week by a smart guy and it would indeed be better as a tiny language, I don't want to downplay any of that. What I said above was about the current situation and context.
&gt; To enable Kotlin support in our buildSrcmodule, let‚Äôs create a module-level build.gradle file Not `build.gradle.kts`?
Methods with a lot of arguments. Instead of passing a lot of arguments you can structure the data with an inline class and destructure immediately. 
There is no problem with the definition \`object SomeClass\`, but with static access to it from everywhere. Instead of accessing SomeClass directly, you can also pass the SomeClass instance around and that is okay and as testable as passing non-singleton instances around.
That's a good point! But the `object` itself can't take in anything in its constructors
Thanks for the link.
This looks amazing. Typescript source, lots of tests, and packaging! I am looking at this now trying to determine how to build locally. 
Just use Log4j 2 with a companion object: private val logger = LogManager.getLogger() That's it! Log4j figures out the clasname itself. And Log4j offers an API similar to slf4j, but more powerful. 
&gt; Your first point will be addressed in Kotlin 1.3 I'm only counting current features/issues. Otherwise I would have stated that Java is obviously better because it will support value types. &gt; Dokka is open source so anyone is able to submit fixes / improvements So is Java and Kotlin. I only count what's there, not what some random contributors could've done. My company tried to use Kotlin for a prototype software and requirement from client would have been a Javadoc-like documentation. We sure could've convinced them to accept Dokka-documentation if it had been properly formatted, but generating a proper Javadoc-like documentation for a mixed Java and Kotlin codebase (we obviously have some existing Java-code that would need integration) seems to be impossible. Rewriting Dokka along with the project would be out-of-scope. &gt; The Oracle Java Bug database shows that over 200,000 Java issues were submitted Counting bugs is useless. Java is existing for a long time and has had lots of beta versions which obviously had bugs. Java is very stable since Version 1.6 or so, I think I had experienced 2 real bugs in the Java language, one was when you define a lambda expression as a field and have a constructor with a return statement, the code would sometimes not compile. The other was an error when computing hashcodes for specific Objects or something like that. Kotlin ist much more unstable and quickly changing and has much more bugs in general. It still feels like a beta version often. Which isn't necessarily bad, just something that isn't as usable for stable business software.
I mean, it's not enforced by the compiler, you can do whatever you want... those are suggestions, not rules. 
I understand that, but I'm asking for readability.
What do you mean by &gt; but singletons are scoped 
You are allowed to use the UpperCase naming variant for singleton objects (created using the `object` keyword) and for immutable top-level vals that serve a similar purpose, even if they're not created using the `object` keyword (as the comparator on that example). So yes, you're allowed to use the UpperCase scheme for your single instance object inside your class if it works like a singleton object. 
This isn't allowed then: class Object { private val Instance = getInstance() companion object { fun getInstance() = returns same instance each time... } }
It wouldn't make any sense to write this as you could put the val inside the companion object. Just replace the `fun getInstance() =` with `val Instance =`. Then it would be perfectly fine. 
What if I wanted an instance to be created only when an instance of `Object` was created? A companion would hold the object in memory even if it's never used. Lazy instantiation is also possible, but there's still some logical to do what I mentioned in my comment, right?
&gt; What if I wanted an instance to be created only when an instance of &gt; Object &gt; was created? A companion would hold the object in memory even if it's never used. The companion object is only initializes when it's first accessed, anyway, so it probably makes no difference unless you're doing something very weird. &gt; there's still some logical to do what I mentioned in my comment, right? No, not really. It looks like you're trying to manually create a singleton object, for which `object` would work totally fine. The original documentation is more meant for the following case (pseudocode, incomplete): class Person(val age:Int, val name: String) { companion object { val OrderByAge = Comparator.comparingInt(Person::age) object OrderByName : Comparator&lt;Person&gt; { ... } } } Here the user of the class doesn't need to care if the comparators are singleton objects or vals, they can be both accessed using the same naming system.
&gt;object declarations are initialized **lazily**, when accessed for the first time; &gt; &gt;a companion object is initialized when the corresponding class is loaded (resolved), matching the semantics of a Java static initializer. \- Kotlin Docs I'm confused about this. 
I'm not sure about this myself. The documentation of Kotlin isn't always that great, unfortunately. My suggestion would be to try it out yourself and if it initializes too early, try `by lazy {...}`. That would be the standard Kotlin way instead of using unnecessary `val`s.
I just checked. `companion object` is initialised when you create an instance of the type but `object` is instantiated only when first accessed. 
Correct. Don't use this pattern, this is what the `object` keyboard is designed to replace.
`object` is specifically for when you want to be implicitly creating a new class. If you're just extending a type and using it, use `val`: ``` class PersonSorter { val comparator = Comparator&lt;Person&gt; { _, _ -&gt; TODO() } } ``` If you need to add members to the comparator (or whatever supertype), use `object` (this is *not* really a good case for when to do that, I'm just using your example): ``` class ConfigurablePersonSorter { object ConfigurableComparator: Comparator&lt;Person&gt; { var isCaseSensitive = false override fun compare(o1: Person?, o2: Person?): Int { if(isCaseSensitive) TODO() else TODO() } } } ``` Basically, think of `object` in this case as being about "de-anonymizing anonymous classes."
Slides: https://speakerdeck.com/pakoito/state-of-the-functional-ecosystem-in-kotlin-mid-2018-checkup
Thanks for the talk /u/pakoito I've been lurking around Arrow for a while and it's the presentation I was looking for
I am back for the second article in my series on coroutines. Feel free to suggest improvements, both linguistic and technical. This time it is all about the two core functions buildIterator and buildSequence which come with the Kotlin standard library. I am also aware of the changes coming with the release of Kotlin 1.3 in the near future. I will publish updated versions of the articles as soon as 1.3 is fully released (no milestone or RC).
Sorry for the late response, but I don't really feel that competent here. For 1.) I would probably even try that as an experiment: everything could be suspendable... Other than that you could do it like Kotlin itself and have basically two worlds: As I wrote, you cannot call coroutines from normal functions. It would be the same in your scenario: Instead of having a suspendable function implement that eval-interface you could wrap it in something that implements it. For 2.) Not sure about that. I sadly lack experience with scheme.
Bit late to the party, but wanted to add onto what the others have said, because *even if* it makes intuitive sense to have a mutable collection, it can still prove beneficial to use immutable collections, and do mutation through functions like map, filter, reduce and the likes that actually produce new version of collections instead of mutating the original one. The main benefit is that it makes it much harder to produce certain types of bugs you otherwise have to guard against. For example, imagine a function taking a list as a parameter. If that list is mutable, both the caller of the function as well as the function itself need to think about what effects mutating the list will have. In a defensive programming style, the caller of the function would probably copy the list to give it to the function, so that the original list will not change unexpectedly, while the function itself might also decide to copy the list before using it just in case the list might get mutated asynchronously while the function is running. This is a non-issue if the type system already differentiate between mutable and immutable collections and gives certain guarantees this way.
Thank you for this. Excellent point (for my learning) to consider functions handling the collection. I appreciate your time!
Thank you for this example! I haven't worked with accessing files/images yet so this is helpful to consider.
Will coroutines be part of the standard library in 1.3 or will it still require adding a dependency? 
These are great APIs. The yield syntax makes me feel like I'm writing beautiful, statically typed python generators, which I've always been a fan of. 
&gt;I'm only counting current features/issues. Otherwise I would have stated that Java is obviously better because it will support value types. It's a completely different matter to talk about future features as opposed to an example bug which has already been fixed and will be included in the next release (Kotlin 1.3 is just around the corner). Regarding value types, there's still much needed before they can be released so it's quite a ways off. Also note that Kotlin allows you to use any Java classes so whatever new type of classes that get added to Java should be able to be used by Kotlin code due to the strong interop support. Somewhat related, Kotlin 1.3 is introducing inline classes. Taking into account the focus on Java interop, this implies that Kotlin will automatically benefit from JVM enhancements so future Java enhancements have a difficult time of narrowing the gap between Java &amp; Kotlin. Kotlin continues to improve as well (and at a faster pace than Java). The only way Java can possibly catch up to Kotlin is if they throw away backwards compile-time compatibility so that they can fix problematic areas (and then they would arrive at a language like Kotlin after a multi-year effort).
Not really sure these are that secret. Also: &gt; One of the great things about working in Kotlin across the board is the symmetry between methods. That's not really true. They leave off many shortcuts because they think they're uncommon. E.g. you might want to `mapIndexed`, but you better not want to `flatMapIndexed`. We can argue that these are easy to write ourselves, but we shouldn't pretend all the shortcuts are consistently symmetric.
Orgiu works for NYT now? Damn, awesome :D
The no null pointers claim is BS. Kotlin severely reduces the occurrence of NPEs but it doesn't completely eliminate them, especially when you start dealing with Java libraries in kotlin.
The article is in the context of Android where Java 8 streams are essentially just not not available.
Fair enough, we have to wait for Nougat to be a reasonable minimum before we can effectively use the API.
I had to recently write `associateNotNull` and `groupByNotNull`, analogous to the standard library's `mapNotNull`. It's not that big of a deal, but there could at least be a widely known 3rd party library that everyone could use.
Vaadin is only usable for webapps. If you're into Plots and user management then vaadin is for you. Everything else: nope. Kotlin is not yet a perfect Javascript replacement (unfortunately). If you need a full, flexible website, then I suggest typescript. 
Kotlin js works very well for frontend development. Is use static html builders with a few helper classes to handle dom updates. You can find an example here: https://github.com/rnentjes/simple-password-manager You can find the helper classes here: https://github.com/rnentjes/komponent
This entire site is plagiarized and should be blocked. This post is taken from [here](https://www.tutorialspoint.com/kotlin/kotlin_delegation.htm). This same user posted to r/coding [two days ago](https://www.reddit.com/r/coding/comments/93eaen/kotlin_if_expression/), which is taken from [here](http://www.kotlintutorialblog.com/kotlin-if-expression/). On top of that, the content is doesn't provide anything above the official documentation and contains errors.
I'm building a web project at the moment using a a Vert.x / Kotlin / Postgres combo and it's pretty awesome. On the front end I'm using VueJS and typescript. If you're wanting to do traditional back-end templating, you could use a templating engine such as JTwig (I'm using this for email templating).
Me too. The exact same stack from front to back. It gets even better once you get a hang on how to use coroutines inside vertx. Out of curiosity what do you use for db access? I gave up with vertx and kotlin based stuff and settled on JPA/Hibernate. 
Full stack dev here - TypeScript is definitely the way to go on the frontend, for now.
They're not hidden in the sense that they're secret, but I feel they are things often left out of introductory Kotlin presentations and that you don't learn about them until you happen to stumble upon them along the way. So I thought there'd be benefit in a post like this to help point them out. That's a good counter example about the symmetry, and I'm happy to change the wording on that! Thanks for the feedback. 
&gt;23 hours ago Have you considered making YouTrack tickets for these or making PRs into Kotlin? I think methods like these, if they're truly analogous to something that already exist, could be accepted by the team. 
That's a bunch of rubbish you just wrote. Dynamic languages used to make sense from a technical/hardware standpoint. They don't anymore today, and certainly not from a language design standpoint.
no
The project is still in very early stage, but I'm already rolling it out at my work to replace an older implementation that became cumbersome to maintain. It's relatively easy to try it out locally, but I yet need to document the detailed deployment instructions for production use.
What is Kotlin lacking? I have used it for three web apps at this time and I far prefer it over something like type script
Great job. Thanks for that. Why did you choose Exposed over "JPA magic" ?
I generally prefer frameworks that force one think more of the queries one executes on the db. In the past I have used JDBI a few times and it was fine except for whenever I needed to refactor the queries. Hence, Exposed was a natural choice. The only thing I don't like about it so far is that a lot of more complicated queries with joins and sub-selects are either difficult or impossible with Exposed DSL.
Yes, agree. Exposed works great for my projects. Easy to learn - no weird magic. But there is no silver bullet. I had one edge case related to gis earthbox queries in postgres. But I solved it using Exposed Native Query.
It is clear that null safety is a Kotlin win. On the other hand some aspects of the powerful Kotlin syntax can be abused by the programmer if not cognizant of the possible unintended consequences. For example default parameter values in functions lie in wait for some unsuspecting usages. In the calling line where there is no explicit reference to the default parameter the default parameter value serves as a static constant in some sense. It remains for the image in the programmer‚Äôs mind to ensure the intended functionality. That is a weak link that trades off with the convenience. In Java the same mechanism is treated with function overloads. The stack trace then gives explicit clue about the parameter setting... at the cost of more lines of code. 
What BS‚Ä¶ they look at very few "smells", most of which I'd consider irrelevant to code maintenance, and call that code quality. Most of these "smells" don't even have anything to do with the used programming language. Their main finding even contradicts the article's premise. This article is completely overhyping a bad paper
I found that our code quality improved as well after migrating to Kotlin (back-end server code). This was mostly due to the code being more expressive and easier to get the gist at a glance. We now get less surprise-defects.
This is excellent u/oleksiyp ! I was just working on testing some retry logic and this should help a ton. As a side note, do you think there will ever be something along the lines of verifyNoInteractions { mockedObj } I know that verify(exactly = 0) can kind of accomplish this too but was also just curious. Anyways thanks for all you hard work, this is one of the best kotlin libs out there! 
Ah yep, thank you.
Agreed. The improvement is measurable and not in a place we would normally think to look for gains.
I haven't really focused on that, but ``` Package Class Method Line javalin 93% 81% 85% ``` It's 230 tests currently for slightly less than 4k LoC (including comments). Tests actually make up the majority of the code base. I could easily push up the coverage numbers by testing overloaded methods directly, but I haven't really thought much about it.
&gt; especially when you start dealing with Java libraries in kotlin. So that's not really Kotlin's fault then is it? 
But why? You're actually typing 3 more characters.
The return type of `postStuffs` is `Deferred&lt;Void&gt;`, which means that this method completes right away, returning the `Deferred` object you can `await` on. You call this method in an `async` block, which itself creates a `Deferred`, so the type of `post` is `Deferred&lt;Deferred&lt;Void&gt;&gt;`. The call `post.await()` also completes immediately, resulting in the original `Deferred&lt;Void&gt;` from `postStuffs()`, which you don't await on at all. This means that, quite contrary to your description of actual behavior, this code will complete immediately and the code following `post.await()` will run without the post operation actually having happened. Solution: remove the `async { }` wrapper around `postStuffs()`. The Retrofit adapt.r already turns it into a `Deferred` automatically.
BTW if you have more questions like this one, consider Stack Overflow instead. I'm there, as well as the top guys from the Kotlin team.
I will
This has already been answered, but wouldn't it be more idiomatic to have your postStuffs function return a Deferred&lt;Unit&gt;? I thought Void was a no-no in Kotlin.
Yes, for this example.
Yes you can. Small difference though: when the first block gets executed and returns null, the second one will execute too.
Thank you. I have some difficult to understand some Kotlin expressions :P
The proper equivalent to `if-else` is `?.also {} ?: run {}` because it doesn't depend on the result type of the "then" block. Also note that an example such as yours, which uses a simple variable as the tested expression, doesn't properly motivate the use of `?.also ?: run`. A good reason to use it is when you don't already have the variable ready and want to avoid polluting your scope with a variable you'll use only in the "then" branch. For example: fetchUsernames(domain) ?.also { it.removeAll { it.isEmpty() } } ?: run { val initialNames = generateInitialNames() validate(initialNames) initialNames } 
Clear example, thanks :)
Is this good practice? I try to avoid if-statements if I can but isn't it much more readable in this case? 
I meant the use of let/run instead of if/else. I get that the nullable boolean is just used as an example in this case.
Although you could use something like: value?.also { print("not null") } ?: print("null") I typically use "also" for side-effects so I would find this clearer and easier to understand: val message = if (value != null) "not null" else "null" print(message) 
Actually no, only one part of the expression will be executed if there is an Elvis operator. That‚Äôs the whole point of it.
Your example may look more clear as ``` fetchUsernames(domain)?.removeAll { it.isEmpty() } ?: generateInitialNames().also(::validate) ``` Subjective of course
My goal was to show an example that uses `run`, but didn't come up with a snippet that's both short and perfectly motivates its use.
Eh... if the third value is meant to represent the absence of a value, then `null` is a perfectly good choice. Kotlin went out of its way to provide good `null` handling, yet everybody seems to want to avoid `null` for some reason. For example, suppose I have a map whose values are `Boolean`. I can use `get` or `[]` to look up a value from the map, and I'll get a `Boolean?`. I could go through an extra step to convert this `Boolean?` into a `TriStateBoolean` enum as you propose. Or I could just handle the `Boolean?` itself directly. 
Read it again, I think he's right though: &gt; when the first block gets executed and [the executed block] **returns null**, the second one will execute too.
I disagree. That might be better in some cases, and might be worse in other cases. The downside to your proposed representation is that a given value can be present in both sets, so you would need to enforce that invariant externally. This isn't the case if they're all in a single map. But the whole "map whose values are booleans" was just an example of how you might get a `Boolean?`. Another possibility is, given a map with `String` values, we do something like: myMap[someKey]?.let { it.startsWith("foo") } There are countless ways that I might end up with a `Boolean?`, and I wouldn't say that a tristate enum would be appropriate in all those cases. It might be appropriate in some cases, but `Boolean?` is a perfectly valid type to use in the other cases.
For someone new to Android development would you recommend they start out using Kotlin? Or should they go the Java route first?
hi! there are a lot of articles covering this topic with professional opinions. Though I would recommend kotlin as I see a lot of potential in it. Good luck with anything you choose :)
``` var lines: List&lt;List&lt;String&gt;&gt; = load() lines = lines.map { it.dropLast(1) + if (it.last() == 'b') '1' else '0' } ``` (didn't test, just off the top of my head)
It looked so promising Exception in thread "main" java.util.NoSuchElementException: Char sequence is empty. at kotlin.text.StringsKt___StringsKt.last(_Strings.kt:139) at TestingKt.main(testing.kt:16)
Sounds like you have an empty line in there. Filter it out. I just pasted a quick example to get you started. You'll need to work through these things as part of a normal programmer's problem solving.
`Math.round` only rounds to a whole number. In Java you often multiply by a 100.0 then round then divide again by 100.0. It's [how .Net does it](https://github.com/dotnet/corefx/blob/c26eb56a6222a581fb51b672c6503ba2ead3fdca/src/Common/src/CoreLib/System/MathF.cs#L182-L200) :-)
So it is Math.round(value\*100.0)/100.0? 
It's [this]( https://archive.ics.uci.edu/ml/machine-learning-databases/ionosphere/ionosphere.data) dataset, there aren't any empty lines in it. I worked around it in a way, that it would work in C as well :D Fuck idiomatic programming (at least right now) Out of curiousity, why did you used it.dropLast(1) Wouldn't this cut the cell away, that I need?
Hey, a2a2a2a2a2a2a2a2a2a2, just a quick heads-up: **curiousity** is actually spelled **curiosity**. You can remember it by **-os- in the middle**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Ok I think I get It now. But can you tell me why the number 100.0 specifically?
Wow 12 downvotes in 12 minutes, in this empty place, someone hates you bot. Poor guy.
Simple math...because you want 2 decimal places. Want 3? Do 1000 (i.e. 10^n where n = digits)
Thanks for the help.
Interesting really, but I already found a solution to my problem.Still thanks for the suggestion.
Just test it in see the result yourself.
Null boolean was not a good choice for my example :/
Kotlin's compiler generates a ton of code. Look at data classes - Kotlin's compiler is generating you `toString`, `equals`, `hashcode`, and any getters and setters you need in Java-land for properties. And that's just data classes. Think about function arguments with default values. Kotlin has to generate methods to make that work: So this Kotlin code... class MyCustomType { fun doSomething(x: Int = 0) = false } Becomes this after generation (decompiled back to Java): public final class MyCustomType { public final boolean doSomething(int x) { return false; } // $FF: synthetic method // $FF: bridge method public static boolean doSomething$default(MyCustomType var0, int var1, int var2, Object var3) { if ((var2 &amp; 1) != 0) { var1 = 0; } return var0.doSomething(var1); } } So to say "no generated code" probably means no Kotlin, because it is generating a lot of code for you by its nature. Lombok is the same way. Even if we forgive both of those examples, I still feel that a blanket "no generated code" rule makes things harder not easier. Believe it or not, a lot of places still use SOAP or other RPC style services. Most of the interface and stub code for those is generated. So are Google Protocol Buffers. Why? Mostly for the same reason you "generate" code in your IDE (when is the last time you wrote a hashcode method from scratch?). Because it's convenient and less error prone. Sure, languages like Kotlin highlight just how much boilerplate code there is in the world, but that's the world we live in. I don't generate a lot of code (in the Protocol Buffers sense) in my codebase either, but I'm glad the facility exists. My $0.02.
To my eyes, it is fundamentally wrong to try to "round an FP number to two decimals". It should only be a way of formatting a string that describes it. Most two-decimal numbers aren't exactly representable in FP so you shouldn't do any calculations with them. That's why, as a matter of coding practice, the advice to use string formatting functions is correct.
No. It's fascinating what people do to avoid if. Prefer if-else over blocks like these unless there is a reason to. I mean, always prefer if-else, unless you have a reason not to. For example `?.let{}` for null-checks on fields is fine, because you need the implicit variable. 
Lately, those discounts have only dropped the prices to $13.99 or $11.99. It's been a few months since I've seen the sales drop to $9.99.
I use BigDecimal instead of Float. It solves a number of issues. Of course if you must convert back to Float to use with other methods / libraries you are back in its land of issues.
This. Want it to be inexact, but fast - use Float/Double. Want exactness and accept overhead - BigDecimal.
Who said anything about having generated code in a code base? Jacoco tests coverage from compiled code which is obviously not part of the code base, but compiled from it. 
Tsek
I have to excuse myself, there was an empty line in it. I don't know where it came from, but it was there. Your code worked as intended. Thank you.
Hello everyone. I made my first kotlin library. You can check it on github. In two words it allows perform manipulations with text and easily combine it with images. https://github.com/Cleveroad/DroidArt Please share your opinion with me.
I've never enjoyed writing code more than with Vert.x / Kotlin / Reactivex (RxJava). This is a good overall introduction into Vert.x: https://vertx.io/docs/guide-for-java-devs/ I don't believe there's a Kotlin version, but the code isn't terribly different to convert.
&gt; is there any harm in me just stuffing the HttpSession object on to the model like any other variable? It seems insecure, somehow... That should be fine. You're still the one in control of what happens, Thymeleaf shouldn't expose anything without you asking it to explicitly. The Thymeleaf integration in Javalin is very basic, but I'd be happy to merge any PR you might have to expand on it. You should have access to all the objects you listed (request, session, servletContext) through the Javalin [Context](https://javalin.io/documentation#context). 
I don't know anything about Discord bots but you can use [`readLine()`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/read-line.html) to read a single line of input.
Assuming you're using Retrofit, which you didn't mention, you use the @SerializedName annotation.
Using OKHttp and Gson.
Ok, Gson supports that.
I mean, i wan't to make a list and do a thing depending on what the user choose
Yeah, you definitely can. You just have to save the state per channel somehow and depending on the state (listening for commands/listening for whatever this command wants) you handle the next message(s) differently. I'd go for a reaction-based option menu though
Don't do this. This should only be used for naming test methods
Keep in mind that the Console command you are talking about BLOCKS everything until it receives input. For a chat bit, you cannot block, it needs to process the I out and finish. So you will have to store the data keyed by user and look it up at every request
Oh, then i'll prob make an menu and get the entry data, ty ty 
Not super related, but isn't it against code convention to use underscore in variable names for Kotlin? i.e. shouldn't it be CamelCase? e.g. `not_before_policy ` -&gt; `notBeforePolicy`
Thanks for the information. I'm going for the simplest option for now and work on the IWebContext approach over time... It's necessary to support other Thymeleaf features too.
That's not really a thing using standard Discord frameworks (in Java). You might be able to rig up something using coroutines if you know how to, but that's an advanced topic.
How do I convert the Json received into different names?
I'm porting a dart library I wrote to kotlin, so I can see how building a real-world app with flutter compares to native android. specifically it's a GUI for my web host's API
Among other things, I'm writing a [JVM method splitter](https://github.com/cretz/msplit) to solve [all those "method code too large" exceptions](https://www.google.com/search?q=%22method+code+too+large%21%22) people get when compiling to the JVM (selfishly because my WASM compiler is [having the problem](https://github.com/cretz/asmble/issues/19)). Also, as a toy project, I am playing with compiling [Go to Kotlin](https://github.com/cretz/go2k) because there are so many Go libs I want to use on the JVM (the proj requires a few of my other recent projects including a [Protobuf code gen](https://github.com/cretz/pb-and-k), a [Kotlin AST writer](https://github.com/cretz/kastree), and a simple [Go dump tool](https://github.com/cretz/go-dump)). It [was done before](https://github.com/tardisgo/tardisgo) in a different fashion and unmaintained. Note, /r/scala sticks this question at the top every two weeks (e.g. [currently](https://www.reddit.com/r/scala/comments/933k0l/what_are_you_working_on_july_30_2018/)) and /r/rust asks the same at the beginning of every week and on their Discourse board (e.g. this week [on Reddit](https://www.reddit.com/r/rust/comments/94ybka/whats_everyone_working_on_this_week_322018/) and [Discourse](https://users.rust-lang.org/t/whats-everyone-working-on-this-week-32-2018/19360)). Maybe the Kotlin mods want to do the same here and/or at discuss.kotlinlang.org.
I am rewriting my bachelor thesis' project, formerly implemented in Java. It is a science project concerned with automatically extracting text from Android applications; a very frankenstein-y project consisting of two modules, a complicated data structure and lots of bad code that needs to be replaced. It's fun! You can find it [here](https://www.github.com/cheapmon/apc-kotlin).
If you noticed my comment in the comments if the same post, I'm porting from dart to kotlin as well. What problems are you having?
Besides that I think you can configure gson to convert underscore to camelcase
When I grow up, I want to be like you.
Working on [Skiley](https://www.skiley.net) (a Spotify-based service for discovering new music, managing your playlists, viewing rankings, etc) and lots of hobby projects :)
Hmm - I compile/transpile to JS. I played with Kotlin frontend plugin. Seems to be very Beta. Compile time is slow, slower than Dart dev compiler. Another issue is that I could not figure out how to generate *.d.ts files from Kotlin 2 JS (OK - I expect something like JS with type infos). It would make no sense to me compiling from Kotlin to JS and loosing all the type infos. Overall I find the tool chain quit complicated which is needed for a full stack Kotlin webapp
Working on a Discord bot using Discord4J's Java bindings. Its pretty fun writing in Kotlin, then reworking everything because Kotlin. Soon going to work on a desktop task/note app (using TornadoFX).
The Discord Android app.
I don't think you can really know Kotlin well without knowing Java well. As in, understand the tricky parts of JMM and JLS.
TECHNICALLY you could say you know java, kotlin is 100% interop with java and intellij does have java-&gt;kotlin conversion and vice versa built in. Honestly I don't think they are too different anyways and the differences are small enough that i went from 2y of java to working 100% in kotlin in less than a week. No semicolons was nice but i was still putting semis for a month or so (doesnt matter cause kotlin gets rid of semis m), no having to use `new` for object instantiation. it would be good to do a bit of stuff in java so you know the differences and arent bamboozled when you see them.
Only if you can do interview problems in it without resorting to those nice kotlin methods. 
Make sure you check out the v3 reactive rewrite.
I wouldn't dare put it on my resume. Kotlin has a lot of convenience that you have to write out in long-hand in Java, and have to know it by heart. A random example: write, without consulting any resources, a thread-safe singleton lazy init idiom. Then there are important parts of the JDK you're not using, like Collections and Streams. You're used to the Kotlin equivalents. You could also trip over some very basic stuff, like the semantics of static vs. inner classes, and so on. Basically, mentioning you know Java is a bluff, one that may get easily called out.
Why should it not compile? Semantically, your example is very similar to a regular if-statement. Would you expect an if-statement to only let you use certain variables in its conditions? Hint: if you use when as an expression instead of assigning a value to a in all branches, you get a compile error that your when expression is not exhaustive. This forces you to either add an else-branch or a branch for Numbers.two. This uses the type of the variable you put into the when expression. // compile error fun main(args: Array&lt;String&gt;) { var a = when (Numbers.two) { Numbers.one -&gt; 1 Counts.two -&gt; 2 } println(a) // prints 2 } Maybe this also answers your question. You get a compile error only when using when as an expression, because otherwise it is more like an if-statement and less than a matching construct.
The compiler prove that an instance of the `Numbers` type can never equal an insatnce of the `Counts` type. It stands to reason that it could flag the `Counts.two` branch as "unreachable code"
It's true that compiler will promote warning to hard error if expression syntax is used. But there is still an inconsistency here: compiler refuses to accept `Counts.two` as variant to exhaust selection in expression, but it is happy to match Numbers.two against Counts.two in statement. 
I'm working on an important server-side project for SIX Swiss Stock Exchange. I'm pushing for Kotlin instead of Java and all devs are quickly convinced =) Going to production soon. Anybody want to join? Write a PM
This compiles, too, and prints 2: fun main(args: Array&lt;String&gt;) { val a = when (Numbers.two) { Numbers.one -&gt; 1 Counts.two -&gt; 2 else -&gt; 3 } println(a) } It thinks that `Numbers.two == Counts.two`. I don't think this is right.
There's an [acknowledged bug](https://youtrack.jetbrains.net/issue/KT-24708) closely related to this. It will be fixed for 1.2.70. As an example, this code compiles but gives a runtime error: enum class MentalState { SOBER, HIGH } enum class Temperature { LOW, HIGH } fun main(args: Array&lt;String&gt;) { val result = when (Temperature.HIGH) { Temperature.LOW -&gt; "low temp" Temperature.HIGH -&gt; "high temp" MentalState.HIGH -&gt; "high" MentalState.SOBER -&gt; "sober" } println(result) } If you remove the `SOBER` clause, it will match against `MentalState.HIGH` instead of `Temperature.HIGH`.
Inlining large functions can lead to increased compiled code and on some platforms size of compiled runtime size matters e.g. android while not providing significant performance gain.
On Kotlin JVM, the HotSpot JIT compiler will perform inlining where it finds it suitable. In fact, it is specifically optimized for code split into multiple methods. For instance, HotSpot will refuse to optimize any method with an amount of instructions exceeding a certain threshold. Inline functions are mostly useful for increasing performance of higher order functions.
No you don't. Unless you've actually written Java programs and understand the languages constructs then you don't know it. Once you've learned a C style language you can be read any of them mostly fine but saying you know it would be a big bluff. 
Actually, AFAIK, inlining large function might result into performance hit. At least in assembly. Example ``` i = 0 while(...) { // rare condition if (i % 1000 == 0) { longFunction() } i++ } ``` Here, after inlining, begining of the `if` and its end become futher apart. And cpus don't like jumping to instructions that are far from current. So, instead of small local loop, it is split into a handfull of blocks. P.S. This is derived from my limited knowledge of Assembly, so it might be completly wrong or inapplicable.
Hey, cpud36, just a quick heads-up: **begining** is actually spelled **beginning**. You can remember it by **double n before the -ing**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Delete 
&gt; You can remember it by double n before the -ing. what the hell kind of mnemonic is that supposed to be? also, dumb bot seems to be broken
Hm. So inst
Is there any specification or a compiler warning for that? I haven't seen any official reason against that or that backticks are made exculively for test methods
They also allow reified generics.
https://kotlinlang.org/docs/reference/coding-conventions.html &gt;In tests (and only in tests), it's acceptable to use method names with spaces enclosed in backticks
.d.ts files contains type information. It's important for other TypeScript users using my libs. Sure you are right if it's just the webapp then .d.ts files are not necessary but my app is split into several libs... Anyways - wish you good luck and success with your Dart2Kotlin port 
Inlining means cod duplication. This makes sense for small functions like lambdas but not for large functions
I think the mnemonic is supposed to be a joke
It would be like saying I know Scala because I know Java. I can tell you I know nothing about Scala 
Well, now I'm thinking to code my Android app in Java just for practicing.
I too think they are similar and interchangeable, looks like others don't agree.
So keep in mind with kotlin when you define a var or val on your interface it is a property and not necessarily a field. So the compiler generated methods for 'val mFoo: Int' end up as 'getMFoo()' or some equivalent/similar puke. pretty gross. I think it is a feature that you don't need to Hungarian for your code to be clear in kotlin. And some reading from this decade on the topic: https://jakewharton.com/just-say-no-to-hungarian-notation/
That's not the same thing at all and not what this person said.
You can put anything on your resume and say you know it. The only question is whether you can answer the questions the interviewer decides to ask about it. 
N before -ing is *usually* double n just as I is *usually* before e. It doesn't tell you what the correct spelling is because it's not a rule, but it is clue enough that you should stop and consider if it's a double n
The overhead of calling a lambda instance vs. inlining is 0.5 nanoseconds. It is significant only in very narrowly defined scenarios. However, the more serious overhead of a full-blown lambda is that on the JVM it implies a whole new class that must be generated, stored in the JAR, and loaded at runtime, with all its metadata. If it weren't for this, Kotlin may not have bothered to support inline funs. &gt;inlined functions do not gave access to private fields/methods of a class since they are inlined without class context. Inlining changes nothing about the semantics of either a function or lambda. Lambdas do and functions don't have access to the context of the call site.
There's no splitting into blocks of code. The last time this was relevant was on the 16-bit 8086, whose program counter couldn't address more than 64K at a time (the infamous _memory segmentation_ that older geeks may remember). There is _some_ effect of a longer jump due to a more likely cache miss, though.
Notification&lt;T:Any?&gt;? Isn't Any? supertype for all classes anyway?
Good point on the first item. Generally I would agree about the imports, but when using ktor and exposed a lot more imports are required than normal. It gets very unwieldy when you start to expand them. Besides all the samples for both projects make use of star imports as well
Yeah. I think it is better to use \`&lt;T: Any&gt;\` instead in most places like this so it can't be \`null\`.
Kotlin doesn't support destucturing patterns in when expressions, unforunately.
NSFW? 
Hah!
Oh jeeze...edit incoming. 
Since 5.0, the [Spring Framework](https://spring.io) has had native support for kotlin and should also support all of the features you're looking for.
I'm a *little* surprised that you were able to make a public Java method that exposes a package-protected interface. I guess maybe it's not an error but merely a warning in javac. 