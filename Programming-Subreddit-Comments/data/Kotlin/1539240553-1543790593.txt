This move wouldn't make much sense, since Kotlin is effectively a better Java while C# already is a better language than Java.
Did anyone do some profiling of the benchmarks here? I took a short ride and it looks like the vaaaaast majority of the execution time is spent in java.util collections like hashmap and arraylist. I have to suspect that this benchmark is seriously flawed somehow. But I didn't have the time to take a proper investigation, the code looks pretty complex. Here's a another performance comparison between RxJava and coroutines, although of course the context is different: [https://www.reddit.com/r/Kotlin/comments/9hpbqv/kotlin\_coroutines\_vs\_rxjava\_an\_initial/](https://www.reddit.com/r/Kotlin/comments/9hpbqv/kotlin_coroutines_vs_rxjava_an_initial/) &amp;#x200B;
conceptually, nothing. it's basically just the visual similarity that bothers me. when scanning over a file im not likely to differentiate which is which at just a glance so it requires more cognitive overhead to parse
About generics in general? Or specifically for Kotlin?
They displayed a graph at the keynote showing about 45% of developers using Kotlin for back-end development (myself included). Back-end runs on the JVM. As much as I'm completely convinced on Kotlin and view Java as a dinosaur, I can't deny that the JVM is an amazing piece of technology (which is what Oracle is selling). Since Kotlin interops nicely with Java, we also benefit from the addition of APIs such as Date-time or the Money API as they get introduced with new releases. The title was a bit much.
This medium article describes it pretty well: https://medium.com/@elye.project/in-and-out-type-variant-of-kotlin-587e4fa2944c Basically generic variance is more about assigning generic types to other generic types than the actual type represented by the generic
I find this very interesting. I don't think you will reach your goal - Kotlin is an English programming language, and there are many other things with an 'L' in them, like `List`, `class`, `filter`, `lazy` and so on. A pragmatic solution sounds like making a front-end for the Kotlin compiler which uses Japanese keywords instead of English ones, but then you still have the problem that the whole JDK is full of English stuff. And you fragment the ecosystem by effectively creating a new language. That really brings me to a question: if you do not want to use (some) English words, how do you name your own variables, classes and functions? I know a lot of shops in non-English (not a native myself) countries use their own language for those, and I consider that a huge antipattern. You can no longer publish your code into the larger Java or Kotlin community, and you cannot get rid all the English anyways. But for me that's easy to say, as English was easy to learn for me compared to what it must be like for a Japanese person.
Were you speaking at KotlinConf? Did you say "Hi Reddit" and wave at the camera?
But `var`s are underlined. Of course not if you're just viewing the code in GitHub, but that's more an argument for having better code inspection in web-based tools.
Christina Lee's 2017 Oredev talk is one of the best explanations of variance I have ever seen: https://www.youtube.com/watch?v=B1UfltiA6jQ (explains a bunch of other tricky concepts too) 
Thanks :-) see You maybe on the next one ;-)
Im not arguing the removal of the letter L from Kotlin. I'm saying there can be confusion because the R sound is used for the L sound when translating foreign words into Japanese, which makes var and val the same thing when spoken. 
i use intellij and there is no way to target specific keywords so `var` and `val` appear the same what do you use?
Ok. Seems to me like they're degrading the very ecosystem that the Kotlin community is dependent on. Maybe it was a bit much, but if they keep going down the walled garden road, then it won't feel quite so cozy.
`const` in typescript is really misleading as well. It really means `final` or `readonly`, as you can declare a fully mutable object in a `const` declaration, when it isn't at all "constant".
Is this homework?
For anyone interested in the Angular question, there are community made wrappers for it. Here's mine, which is dated but works well and could be easily updated to the latest Angular version. Angular honestly doesn't change that much from version to version anymore. [https://github.com/gbaldeck/angular-kotlin-starter](https://github.com/gbaldeck/angular-kotlin-starter)
Hi all. I just finished writing this article and thought it may be helpful/interesting to some people here. Feedback is always appreciated. Thanks!
So what we need is kotlintest with multi platform support.
Yes it‚Äôs the last part of it. I‚Äôm not asking for a solution just help. But thank you for your help 
There might be a variant or option in split you can keep. Are you trying to keep it in each chunk or just in the final string?
I guess. And some nice assertion framework (like AssertJ).
I‚Äôm trying to split the string into a list by using the added symbols. It should act just like split but keeping the character you‚Äôre delimitating along. When you split a string it‚Äôs type is now a list. So don‚Äôt know what you mean by final string 
'keeping the character you are deliniating along' Can you clarify?
Thanks, I'll watch it.
Why not just make address a non-private `var` in the builder so you can do `address = "123 main"`?
Yeah `name = "blah"` is much better than `name { "blah" }` imo
And if you still just gotta have braces you can still do `name = { "Fred" }()`
It's simple really: since `val` stands for `value` and `var` stands for `variable`, just pronounce it in full when talking about it in Japanese; „Éê„É™„É•„Éº„Å®„É¥„Ç°„É™„Ç¢„Éñ„É´„ÄÇ Or you can go with a pretext and explain how `val` is simply akin to `final variable` in Java and describe it as a final var in Japanese. The origin and root of higher level programming languages has chosen English as its main form of representation, so you can't really expect the Kotlin language designers to introduce a potentially breaking change just to avoid a slight conflict for another spoken language. Introducing an extra alias for both `val` and `var` would not be a good idea because then you would practically be promoting inconsistencies in coding practices.
KotlinTest has more matchers than assertj already. Kotlintest is not Kotlin Test. 
Aren't there many places where Kotlin's type system just can't express something, give all the things is lacks compared to TypeScript?
Thanks for compiling the list of questions and timestamps; this is very helpful!
&gt;`val p= input.split("\\s+").zip(token).map {it}.flatMap { it.toList()}.subList(0, input.split("\\s+").size*2 -1)` That whole line is completely unreadable, and some of the steps don't make sense. What do you assume each step is doing?
Yea, but the goal is ultimately to be able to write Kotlin - so what do you want to imply with your question\^\^
I don't know if that will get inlined, but `name = run { "Fred" }` definitely will
Very easy-to-understand and descriptive article, and I'm glad to see `@DslMarker` mentioned! One problem with the DSL as written is that it involves a lot of anonymous classes; each lambda body is going to become its own class implementing `Function1` or `Function0` and every lambda invocation will become a `lambda.invoke(reciever)` call, which will create lots of unnecessary `.class` files and runtime overhead. Fortunately, Kotlin has a fix: public builder properties and inline methods. class AddressBuilder { lateinit var street: String // lateinit is also helpful to ensure all fields are specified lateinit var city: String inline fun street(lambda: () -&gt; String) { street = lambda() } inline fun city(lambda: () -&gt; String) { city = lambda() } // build() is unchanged } //address(lambda) gets the inline modifier but is otherwise unchanged With this change (applied to the rest of the builders as well), you would see no function types in the compiled code at all; the Kotlin compiler will reduce the beautiful DSL into minimal-overhead Java-builder-like `setCity("")`/`setAddress("")` calls during compilation. This also allows for a bit friendlier use from Java, where lambdas aren't nearly as useful and calling setters on builders is the way of the world.
I always assumed that the whole effort of trying to work with an existing JS framework with Kotlin/JS is ultimately futile, because the experience will always be sub-par. But if people are actively trying, I'm wondering if maybe someone figured out a way to deal with these issues. So I'm asking to see if a solution was found, or if it's still not there yet. Or if maybe Angular doesn't rely as much on union/intersection/mapped types like for example React does, so it's not much of an issue there.
Seeing the example I would just go with calling the data class constructors directly with named parameters. Looks pretty similar with no overhead and no boilerplate code. 
Yeah that's definitely an option. I chose to go the other route in order to show that DSLs can be manipulated in several ways that allow you to decide how you want your data to be represented. I also like passing lambdas because in real-life cases where we aren't just setting simple values, it's an easy transition to defining more behavioral type data. In this simple example it's all up to preference of syntax though, you're right.
Honestly, I prefer this "DSL": val business = Business( name = "Generic.io", address = Address(street = "Agile St", city = "Disruptville"), employees = listOf( Employee( name = "Grace Elliot", id = "12345", title = "VP Engineering", salary = 125_000), Employee( name = "Jeff Jefferson", id = "54321", title = "Chief Jeff Officer", salary = 100_00))) It does not require any mutable machinery underneath: it's just data. It's future-proof: adding new required field breaks at compile time, not runtime. It does not require learning new API: it's just data class constructors. It's easily extensible: just add more data classes and you are done. It's composable: you can create your employee elsewhere and just add it to your list like that: `... employees = listOf(grace, jeff) ...` To me, these pros outweight slightly better indentation and curly braces.
I appreciate the transparency of the article, but it might be better if your DSL had side effects. As it is written, you've created statically typed YAML-esque language. When I think DSL, I think of special use cases like code builds or specific types of calculations. Most importantly, I think of _doing_ something (side effects) not representing something. 
Kotlin works fine with both React and Angular. It all compiles down to typeless javascript in the end so they all work. Kotlin has the dynamic keyword if you need to turn off type checking for a time. I have found that it is not necessary that often though. Until we have a company like Facebook, Google, or Jetbrains supporting a frontend framework for Kotlin we are going to have to accept second class support. It would be nice to see the community come together to create a Kotlin frontend framework but it is too small right now with people coming from Java who are inexperienced with Javascript. I use Kotlin with the React wrapper for my projects and have no problems. It works great and it interfaces well with React. The biggest hurdle right now is setting up a working project. I created a starter for people who want to use Kotlin with React and Webpack in a Kotlin 1.3 multiplatform project. It has everything setup for you so you can start developing right away. Here's the link if you're interested: [https://github.com/gbaldeck/react-js-jvm-kotlin-multiplatform](https://github.com/gbaldeck/react-js-jvm-kotlin-multiplatform)
I have the very Same opinion as you :)
I think this is a bad use of `lateinit`. If `street` is not specified within the DSL it will simply throw at runtime. If a value is truly required then it should be passed, perhaps as an argument to the builder func: `address("123 Main") { ...rest of DSL body... }` 
I don't think we have that technology yet.
Interesting alternative. For the address function, both street and city are presumably required, but making both of them arguments to a function removes the DSL part of it entirely.
I am converting a prototype compiler targeting the commodore-64 8-bit system which I originally wrote in Python, into Kotlin. The Python program got too unwieldy and I had problems refactoring the code as I progressed. It is the first time I encountered this problem with writing Python, but, I thought it was a good moment to start learning a new language. I considered moving to C# (which I already know) but I chose Kotlin instead because I wanted to learn something new and I like it and the open nature of it.
Developing web apps with Ktor :)
Try not to think in terms of "Android" or "not Android". Most of these talks will make you a better engineer.
You can use any Kotlin code, as long as it does not use reflection or any Java libraries.
OK. I would like to write a single page REST client. I guess that wouldn't work since REST calls is probably using Java or reflections?
Take a look of declaring of external functionality to Kotlin. With this, you can use any JS library within your code. Downside is, these functionalities will be lacking typing (unless you provide some). It's like saying "hey, I don't have this function declaration anywhere, it comes from external source. Let me use it anyway". Think about alert function (dom api)
If this is browser-based JS then you use the browser APIs for REST calls, either XmlHttpRequest (but you‚Äôre better using a library like request or axioms) or the fetch API. You declare these as external, then call them from your Kotlin code. 
How do you work with DateTime when targeting JavaScript from Kotlin?
Working on releasing a stable 1.0 version of my server-side Kotlin framework called SlateKit (www.slatekit.com). It's a modular set of utilities, architecture components and more for building a mobile backend.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Futures, cancellation and coroutines in Kotlin \[x-post from r\/Kotlin\]](https://www.reddit.com/r/programming/comments/9o0rx6/futures_cancellation_and_coroutines_in_kotlin/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
The article talks about the difficulties with writing correct async code and then shows how it's so much easier with coroutines
Arrow proves that you don't need to write operators to chain elements. You will need the other operators regardless, and kotlinx.coroutines is re-building them one by one. Imagine implementing buffer, window, debounce or zip yourself!
Working on a set of time tracking utils [https://gitlab.com/time-tracker-utils](https://gitlab.com/time-tracker-utils) &amp;#x200B; Terminal client is mostly done, back-end needs test, terminal client needs more test. But they're coming along well :)
The most important reason for using the Kotlin DSL would be because the majority of the Java ecosystem uses the builder pattern (for better or worse, mostly worse imo). DSLs play nicely with that sort of pattern. 
Data classes really are a better solution than builders (or DSLs) for most cases. So the question I'm trying to answer is: when is it appropriate to solve with a DSL?
Any particular reason are you posting about Go in the Kotlin channel? I realise you're porting from Kotlin to Go, but people here I'd imagine want to learn about writing great Kotlin code. A Go sub is probably a better fit? 
For people with emotional connection to a particular technology this post is an annoying post because it is not reassure their believes. For others it is just a piece of information which could be useful.
When you compile you decide your target - JVM, JavaScript or KotlinNative - and the libraries available to you change depending on target. For example, when targeting JVM you have java.util.Date but when targeting JS or Native you don't. And vice-versa. The kotlin docs note when a function isn't available for a particular target. Java bytecode is only generated when targeting JVM, when targeting JavaScript it generates JS code, and for Native it generates native code for a chosen processor architecture (a bit of a simplification here but it'll do...) IntelliJ asks you to make the target choice up front so it can only show you the libs you have access to and hide the others. When Android people speak of kotlin they're referring to kotlin/jvm. Server side could mean any of the targets, the JS would run on node.js the same way the bytecode runs on a JVM.
Pointless article stating the obvious. It shouldn't be a surprise to anyone. Any language with a VM will be slow on lambda... Its just like saying moved from python to c++ to make a blazing fast XYZ. 
[removed]
I'm not sure that many people believe the JVM performs better than native code on Lambda. The article even states that "most people" think using a JVM language on Lambda is a bad idea. It would be more interesting if the article were a comparison of Go vs Kotlin/GraalVM.
The question about using Kotlin on a server is interesting. Because a server is just a remote computer. So you've got options. If you wanted to use Kotlin in a website, you could compile kotlin into javascript. But I don't know when I'd do this. If I wanted to use Kotlin for a website, I'd use Spring, a java framework that allows you to build web applications, and I'd use Kotlin with that and target the JVM still.
Been using Kotlin + spring boot + gradle and mongo. Can be slightly challenging at times due to lack of documentation, but it pays off in the end considering how idiomatic the language is!
We plan to provide a multiplatform date handling library. For now, you can use expect/actual to roll your own, as shown here for example: [https://github.com/yole/kxhtml-isomorphic/blob/master/shared/src/main/kotlin/Date.kt](https://github.com/yole/kxhtml-isomorphic/blob/master/shared/src/main/kotlin/Date.kt)
I normally am very hesitant about new test frameworks (Mockito + JUnit pretty much solve all of my problems), but I will admit that this looks like a very well designed API that could improve the readability and verbosity of my test assertions. I might have to give it a shot soon!
Looks like there's a significant overlap in approach with [Atrium](https://github.com/robstoll/atrium/blob/master/README.md). Any distinguishing features between the two?
Good question. I have no prior knowledge of Atrium, I just stumbled upon Strikt and posted it to let interested redditers know about it too.
If you can't find an official solution, you can clone the Kotlin Website repository (here's where in the tree they store the reference pages): https://github.com/JetBrains/kotlin-web-site/tree/master/pages/docs/reference
For the time being you can audit for free it seems. To get graded and receive a certificate, you pay 49$
Devdocs allows you to download the data for offline use in your browser.
Well you need to add one. https://www.jetbrains.com/help/idea/run-debug-configuration-kotlin.html
Just a quick guess, try going to File-&gt; project structure and make src a source directory. It doesn't look like you have the project set up correctly. I could be wrong, I usually use intelliJ with Java. 
I second Dash (or Zeal for windows). It's invaluable and it's the first thing I install on a new device. I'm using the Kotlin 1.2 docset provided at the link above and it's pretty good. 
Thanks, but I did this with the Exposed Wiki and I couldn't find any viewer for Markdownfiles where I can use the links, so it would be my last straw. But it's good to know that the website is on Github.
Oh my, thats a really good program, I would never have thought about searching for something like this. Unfortunately, I can't find the option to use user-generated docsets in Zeal for Linux. But I'm gonna search for it, there should be an option.
Thats's also a very good Idea, thanks!
Never mind, I found it. If others have the same problem, you have to download the docset zip file, extract it to the docset folder (it's listed in the preferences) and restart Zeal.
**The problem solved.** It was fun.. The firewall blocked all functions of mavel,jdk and part of IDEA. Adding to exceptions didn't help. Switching off the Firewall - helped. Strange were: Empty repositories of maven, the same settings as at the another computers where it have worked. Now everything is working. 
This is how I sell the value of Kotlin while mentioning that productivity also improves: https://proandroiddev.com/kotlin-avoids-entire-categories-of-java-defects-89f160ba4671
‚ÄúDo you want fast paced more bug free code which is functional as well? Try Kotlin. Oh yes, the bonus will be 0 NPEs.‚Äù
Look at the document attached. https://plus.google.com/+JakeWharton/posts/WSCoqkJ5MBj
You need to say bug free very fast, but all in all that'd be it üòÑ
I will most certainly be using this wonderful article. Thanks man!
Amazing material! The work on the summarisation is neat. Thanks!
Won't look great when everyone says "you promised no NPE's, why are we using this again" though will it 
&gt; TL;DR : how should I catch the interest of senior java developers If it's on you for Kotlin to catch their interest, they are not seniors.
I won't lie, it will be said. But I'll sell the dream. 
Or bang operator.
I meant by that, how do I talk high level enough for juniors and intricate enough for seniors who might have heard of "blablabla data class blablabla null check" many times in the last 2 years. To rephrase: keep them interested even if they already heard of basic kotlin capabilities.
Regarding nullable types, you can point out: The fact that Java doesn't differentiate between nullable and non-nullable types is a hole in its type system. You can compare it to dynamic typing where you have to manually keep track of what every variable type is in your head - except it doesn't go quite that far. And most importantly, people focus a lot on the safety aspect, but the fact that you clearly see that a variable is *never* null and don't have to worry about it when reading code is just as important. To put it into a picture - https://imgur.com/LJ3wk06.png, the bottom highlighted part (redundant check, representing the fact that you don't have to make those checks or worry about them) is just as important as the top part (safety).
If the NPEs originate from Java code, it will still have been true. While it is highly likely that you will interface with Java code, it is not required and cannot be blamed on Kotlin.
I'm not trying to sell Java as a NPE free language though. It's not Kotlins fault for sure, but you can't say that life is going to be 100% NPE free if you just switch to Kotlin. Much reduced chance of NPE's? Sure! Language features to help you out? Definitely! 
One of the aspects of Kotlin that i am always happy to use are the scoping (let, apply, also, etc) and array (map, filter, first, firstOrNull, onEach, etc) functions. Show some business logic in java with loops, null checks, object instantiation with setters, and then do that in kotlin. Its shorter and more readable if you do it correctly
Honest question. How do I find a job in Kotlin? I've been looking and blogging on it for a while. But barely find any out there, except for mobile. I'm a backend dev largely.
Me too. It‚Äôs hard for sure on the backend. 
Find a progressive company because they will inevitably switch to Kotlin. I see it happening all around me. You could come on as a Java dev and help a team migrate to Kotlin.
I've pitched it internally at prior jobs. Coming from Python &amp; Java team. Both the teams really like it and wanted to move. But management wouldn't give the go ahead. The general reason I get is it's esoteric and the developers will cost too much. 
Is there a start date somewhere?
Find a Java shop. Show them that what they consider "the good side of Java" is actually "the advantages of the JVM", which they can get with Kotlin, which has actual upsides and solves many of the downsides of Java.
I sort of have. I've come in as a bridge from Java to python. Or Java to x. Make the case for Kotlin, team likes it. But management wouldn't approve because the developers we're too expensive.
At my job I‚Äôve been pushing for it for over a year. Lots of resistance from a few senior devs. But I‚Äôve still been using it here and there. 
I think that‚Äôs the wrong way to look at it. Kotlin should be a selling point for recruitment. 
I pitch on technical benefits, ease of development Acquiring passionate talent, ease recruiting A young ecosystem you can contribute back to, free marketing via open source or local talks 
If senior developers in your company are not curious enough to investigate themselves and fall in love with Kotlin already, then you are doomed.
Backend frameworks exists, like Ktor ([https://ktor.io/](https://ktor.io/)) but not yet adapted widely. Many organizations are still sticking on to Spring because that is all they have and doesn't want to try something new. You will need to land a job in a startup or a small scale organization. Such orgs are good in trying out new things.
So far on this sub, /r/androiddev, or any other similar sub, the only excuses I've seen from java devs refusing to use kotlin are either A) "I don't want to convert my whole project to kotlin!", B) "I don't want to learn a new language when java is fine!", or C) Both If they took 5 minutes out of their day, they'd realize that kotlin interops just fine with java and vice versa, and their refusal to learn a new language will bite them in the ass if they ever need a new job and they get turned down over a candidate who is proficient in both java and kotlin.
Here's a sneak peek of /r/androiddev using the [top posts](https://np.reddit.com/r/androiddev/top/?sort=top&amp;t=year) of the year! \#1: [The future of Android Development](https://np.reddit.com/r/androiddev/comments/9n88wv/the_future_of_android_development/) \#2: [When you change the code but forget to rebuild](https://v.redd.it/rq3argkri3411) | [26 comments](https://np.reddit.com/r/androiddev/comments/8r8ikt/when_you_change_the_code_but_forget_to_rebuild/) \#3: [The android developer starter pack](https://imgur.com/gallery/OFsMt) | [94 comments](https://np.reddit.com/r/androiddev/comments/7cfnzz/the_android_developer_starter_pack/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/8wfgsm/blacklist/)
Also, ktor is not just a backend framework but an http client altogether. It's like Spring and OkHttp put together.
Where are you based? We are looking Kotlin back end engineers at Madrid - Spain. Our quota of back end engineers in SF is complete though :(
In my company we use kotlin for a while on Android and it was not a very hard sell. But obviously it's a bit more common on Android and endorsed by Google. However our backend devs started using it more and more, too. It's been a bit harder to sell there (I tried about a year ago by converting a microservice from java and I think it counted but the pace was slower). Colleagues held a presentation a few weeks back and I really liked how they presented it to less technical people . Basically they said: * almost 0 learning curve or setup * more fun * write less code to achieve the same thing * no null pointers I am a bit blessed that we did not really have to sell that to managers. Only tech people had to be convinced. But I feel that there was actually almost no overhead in learning the language and it made us more productive in the end. What also is a big help is that libraries and frameworks like spring / android and others are all doing cool shit specifically for kotlin (even though they all work with kotlin if they work with Java in the first place) 
DM me if you (or anyone else) wants a (cloud/backend) Kotlin job in Munich, Germany.
&gt; they'd realize that kotlin interops just fine with java and vice versa This is the biggest concern I have, or not that they interop, but the fact that since I would have to fall back to Java still a lot, why not just write the whole thing in Java? (This might be different situation for Android devs, I wouldn't know). And please don't get me wrong, I would love to start learning Kotlin, but since your typical backend / full stack job pretty much requires knowledge of at least JS and a few scripting / templating languages + HTML/CSS _on top_ of Java, it's just hard to justify. Keeping the Java skills top notch requires constant work, at least for me.
&gt; This is the biggest concern I have, or not that they interop, but the fact that since I would have to fall back to Java still a lot, why not just write the whole thing in Java? When would you, though? So far I've only had to do interop with java because I'm pulling in a dependency written in Java (like Spring) or with existing code. I have yet to encounter an issue I could only solve by writing new java.
Well, the idea behind interoping kotlin with java is based on the dev creating new classes and code in general in kotlin going forward. If you're going to still make new classes in java, you're defeating the point of using kotlin (or mixing kotlin) in the first place and yes, you might as well just keep writing in java. It's more when you're working on a project that is 100% java with 500 classes and 100k lines of java code. If you start from this day forward on that project adding every new class in kotlin, you could rest easy knowing that any new kotlin code you write works 100% perfectly with your old java code and vice versa if your old java code ever needs to reference new kotlin code.
Hello, i might be interested! I contacted you by DM
Honest question, and a super common use case: You gotta write a large DB abstraction using e.g. Mongo DB driver, obviously the official one because enterprise, which is only available in Java. Is it really better idea to write it using the kotlin interop mechanisms than java? The code mostly consist of using the db's interface methods, often quite complex stuff too.
Spring works great with kotlin
There're no special "interop mechanism". You instantiate/implement/call the Java classes/interfaces/methods just like Kotlin code. The only differences are: * Libraries without nullability annotations aren't null-safe (Look up Kotlin's platform type). * The lack of Kotlin specific goodies like sealed classes but that's self-explanatory You can even access getters/setters with Kotlin's property syntax and use lambdas for single-method-interfaces (look up SAM conversion). On the other hand making Kotlin code accessible for Java classes and annotation processors can be a little bit tricky.
&gt; Afaik a ton of fundamental dependecies are still available only in Java, from stuff like (official) DB drivers to Bcrypt and 3rd party SDK's like AWS. Not to mention legacy code, which is still running just fine and re-writing is definitely not an investment companies want to do. All of which work seamlessly when called from Kotlin. They may not take advantage of Kotlin idioms, but there's 0 issues using them in Kotlin code either. 
I can echo this. I've given a number of presentations on reduction of code, and increase of safety. The biggest hurdle actually was leaving mavne, no one wanted to learn gradle. But the above. &amp;#x200B; The worst when I was pushing a change from JDK5 -&gt; JDK8. None of the team wanted to learn lambda or streams.
This is why I leave every job, and why I haven't stayed at a job for more than six months. Granted I start with contracts. But yeah during interview. We're so eager to learn and try new tech. Once on site, nothing but brick walls.
Sadly Philadelphia area right now. I wish more companies would be open to remote :\\. But thanks for the comment.
Well for one, it's open source...
What's your company? I am from Madrid
We just started a project where the backend is using kotlin. I love the language. 
&gt; The biggest hurdle actually was leaving mavne, no one wanted to learn gradle. I know Gradle, I still use Maven - I don't understand why so many people insist on pushing a switch away from perfectly functional tooling. I get it if you NEED to do something that doesn't fit Maven's declarative model, but every project I've worked on a Maven POM is adequate and easier to reason about.
The right company allows good engineers to use the language they find suits them best. My team at Amazon uses Kotlin exclusively on the back end. While I wouldn't say its use is widespread throughout the company, teams are empowered to to make that decision on their own. It's one of the reasons I love working here. We've got openings now if you're interested. [https://www.linkedin.com/feed/update/urn:li:activity:6444024140604280832](https://www.linkedin.com/feed/update/urn:li:activity:6444024140604280832)
Okay, that was a poor choice of words, but skimming through an [interop](https://kotlinlang.org/docs/reference/java-interop.html) doc it seems there are quite a bit of special cases you have to take into consideration when using Java. Things that are fluent when writing plain Java. Things you don't need when writing plain Kotilin. But I'll take your word for it and give it a proper chance at some point in the near future.
&gt; They may not take advantage of Kotlin idioms Don't you think this is a problem? If an app is heavily relying on java dependecies, you have to take [all sort of stuff](https://kotlinlang.org/docs/reference/java-interop.html) into consideration. I mean, swithing to Python means I can start writing Python as it's meant to because all the tools are there natively. That's why I said "still". But what I'm reading here seems that this is not a real concern and I don't want to start arguing about it. So gonna give it Kotlin a proper chance at some point in the near future.
Okay thanks, that's actually really good to hear!
JooQ ‚ô•
We're using vert.x with kotlin...But I gotta say I really didn't like jooq when I used it for 6 months. Felt like such an overhead for little gain.
Well it's in its own foundation now, so besides JetBrains there's now also google behind it - whether that's a good or a bad thing can be argued about, but it definitely speaks for the language being a long term investment.
You don't have to switch to gradle for kotlin though, maven works just fine from what I've tried so far.
That page isn't a list of things to watch out for, it's a list of things the Kotlin compiler does to translate idiomatic Java into idiomatic Kotlin automatically. The first section, getters and setters, shows how a Java class with getters and setters will magically grow a property when used from Kotlin (since property access becomes getter/setter calls under the hood). Similarly, Kotlin will look for any of the NotNull/Nullable annotations it knows about to provide a signature with accurate nullability. The gist of the page is "Here's everything we do to make your life easier when using Java code."
It's funny how most of the "warty" bits of Kotlin are caused by Java interop....
Just go ahead and start a project. The goal is to make it **so good**, that no more questions remain. Once you do that - congratulations! You've just created a job for yourself in the current company.
Yeah, right? But I appreciate that you don't notice any of that for the most part if you're not actually interoping with Java.
I'm in same boat. What did you end up using?
That is like telling UNIX is going be rewritten in something else other than C. Koltin is a pleasure on Android because most likely Google is not going to support anything else other than Java 8, and for that only when targeting Oreo or later. Everywhere else we have Java 11 to choose from. I am going through the Kotlinconf videos and already have some basic experience in Kotlin due to Android. Slower build times, integration issues with annotation processor and the semantic model differences between JVM/JS/Native targets are not appealing to me.
We recently started using Kotlin for back-end development at NetSuite (several teams) and NetSuite is always hiring so you could make it a condition to join one of the teams that use Kotlin
I ended up going with Jackson, since it comes with Spring, as it turned out all the configuration needed is @Bean fun mapper(): ObjectMapper { return ObjectMapper().registerKotlinModule() } with **'com.fasterxml.jackson.module:jackson-module-kotlin'** added as a dependency
I don't see why Kotlin is easier to learn compared to Java. IMHO: Kotlin is easier to write and read because of the concise syntax but the languages offers also a lot of advanced concepts while Java keeps it simple.
I agree, I prefer writing Spring Boot apps with Kotlin now
`interface IUser`, no thank you.
Understandable. Most people seem against this. I picked this up from some C# developers on my team and I think I like the fact that it's obvious that it's an interface and not a concrete implementation.
As someone who doesn't know anything about inline classes, I know writing beginner style tutorials/quick glances is hard, but I feel like in trying to be simple so many miss the mark on how to use something in a practical application. For instance, the problem presented is that there is no distinction between a name and an email.. they're both just strings. But the end product as stated is still the same thing but with new names. So the problem still hasn't been address. I can still do val email = "john@doe.org" val name = "john doe" val contact = Contact(name = Name(email), email = Email(name)) Are there any ways to add restrictions? If so, how do you handle assignments that fail the restrictions? If not, is there a good explanation or article on what actual problem these inline classes solve? If I create a fancy inline class called Age around an Int but can still assign a negative number, how useful is this class really?
As for restrictions, I'm not sure. [According to the docs](http://kotlinlang.org/docs/reference/inline-classes.html), inline classes can't have `init` blocks, which would have been the obvious way to ensure that the provided value was valid. Maybe they'll add them in the future (`inline init` maybe?) What's not clear to me is whether the constructor of an inline class can be private or internal. If the constructor's visibility was allowed to be restricted, then you could create an API where consumers don't create instances of the inline class by direct construction; rather, they would call a function which would validate the value and then either throw or return an instance of the inline class. The net effect would be that, at runtime, whenever you convert from a "bare" `String` to an `Email`, your validation code would run. After that, the email would be passed around as a plain `String` with no overhead. Essentially, by receiving an `Email` instance, you would have evidence that the `String` which backs the `Email` had been properly validated at some point previously. Whether it's possible to ensure that validation or not, the other value is in communicating intent. Suppose I have a function that receives an `Email` instead of a plain `String`. Then I'm communicating intent to callers - you had better provide me with an `Email` whose `String` content is a valid email address. If you can't enforce that validation code is run at the time that the `Email` instance is produced, then you'll never know *for sure* that the `Email` provided to you is correct. But it's still more communicative than receiving a `String`. 
The thing is, to the one using the interface, those technicalities should and do not matter. Adding the 'I' in front of interfaces unnecesarily obfuscates your type system. You use the interface name way more often than the implementation name, that's what interfaces are for. How often do you use List in your code vs. ArrayList? Only when instantiating you might specify the implementation, but everything else just uses the interface.
This was actually one of my favourite talks. It shows how simple it is to create a web service. Very clear and concise presentation! 
Everything I can find on their blog points to CLion...
Can't one just use a factory method for validation and then have the assignment Advantages of an inline class?
Off topic, but Reddit MD doesn't use ``` for code blocks. You have to indent every line. If using an ide, just select all and tab once before pasting into Reddit. It sucks but it is what it is.
Well, I got a legacy project full of "IUser, IProject" naming, the main justification from the devs there was class name duplicates, because the "base" class was named e.g User (which was a simple Pojo) and the interface was e.g IUser. When I said "but, you could name the User implementation something like SimpleUser, BaseUser, DefaultUser, etc" and their minds blowed &amp;#x200B; &amp;#x200B;
hmm.. it is formatted correctly on my screen though. Does it not look correct for you? I didn't have any tabs/indents, so I mostly just used it to block off the code.
To each their own of course. And like i said, as long as everyone is consistent go with whichever style works for you. But like /u/DJDavio said below, the interface name is whats generally going to get used most often, it makes more sense for it to have the cleaner name in most cases. saying it in a sentence really kind of shows how weird of a naming scheme it is though. `User is an IUser` no, thats weird `SimpleUser is a User` much better.
I think a slightly better example might be `fun doSomething(dt: Millisecond)` rather than `fun doSomething(dtMs: Long)` for delta time. I guess it doesn't matter much when you have an IDE that shows you parameter names, but something feels better about it. Like, names can better describe a concept without having to also describe the type of the concept? `time` is more idiomatic than `timeSeconds`, for example. But if you need to constantly repeat `doSomething(Milliseconds(20L))` instead of the shorter `doSomething(20L)`, then I'm not sure it's much better. I don't think restrictions would work, since you'd have to throw an exception during initialization, but inline classes can't have `init` blocks or backing fields, so there's nowhere to prevent construction from happening. I was initially excited about inline classes, but now I'm not sure what benefit they provide over typealiases, since it seems all they do is force you to construct the inline class
It's also broken for me on old reddit, but it looks fine when I checked new reddit!
You might already be aware of this, but since you're on the Kotlin subreddit, I think you should try out the Gradle Kotlin DSL which is almost 1.0 released. It should work fine for most cases, and it offers types/IDE completion/etc, as opposed to the weird Groovy-like stuff you're used to seeing. Even the creator of Gradle himself praised Kotlin at KotlinConf for being much closer to what he envisioned when he first made Gradle.
I couldn't find a source on the deprecation status of old reddit, but I'm assuming you're right, they'll keep it up but won't update it anymore :/
I don't think inline is a very good name for this, consider inline functions: https://kotlinlang.org/docs/reference/inline-functions.html Every language seems to call this concept something different Haskell: newtype (wrapper types) Scala: value classes Go: doesn't even give it a name.
Im still very new to kotlin and havent learned everything but i wonder if Contracts could eventually aid in this sort of thing.
I like the 5.5MB full page image of colors at the start of a 4KB page about coding.
Reddit Enhancement Suite also adds a button that will indent the selected lines. I think "new Reddit"'s comment editor also has a button to do that.
&gt; I don't think restrictions would work, since you'd have to throw an exception during initialization, but inline classes can't have init blocks or backing fields, so there's nowhere to prevent construction from happening. That's why I had suggested that maybe it could be called `inline init`, because if an inline class could have init blocks, they would have to be inlined at every place where an inline class is instantiated. ... which honestly doesn't seem terrible to me. If that's a simple validation, I see no problem with the compiler inserting it everywhere. Alternatively, the compiler could even *potentially* extract the body of the hypothetical `inline init` block to a function and just inline a call to that function at every location where the inline class is being instantiated. &gt; I was initially excited about inline classes, but now I'm not sure what benefit they provide over typealiases, since it seems all they do is force you to construct the inline class Yes, if at every callsite that requires an inline class, you construct it on-the-spot. No, if you thread the same inline class instance through several layers of callers, or store the inline class instance in a field. In that case, you'd construct the inline instance once (and you'd better make sure it's valid!), but then everybody downstream wouldn't have to think about it - they could assume that the incoming value was valid. The difference between inline classes and type aliases is that inline classes represent a completely different type to the typechecker. But without the ability to enforce restrictions on valid values, I agree that they're less interesting.
You can certainly use a factory to create instances of the inline class, and the factory can do validation. The question is whether you can *force* clients to use the factory. If client code has the ability to construct an instance of the inline class *without* going through the factory, then the inline class instance only bears intent, not evidence of correctness. (i.e. callees would still potentially want to do their own validation.)
I'm not sure how I feel about inlining the checks as well. For something simple like `value &gt;= 0` for unsigned ints, that should be fine. But something like checking an arbitrarily long string against a regex could be less fine. But hey, it's optional, so why not? I took a look at the [proposal discussion](https://github.com/Kotlin/KEEP/issues/104) but haven't seen your idea mentioned, I wonder what the designers think of it. And yeah, I meant it has to get constructed at some point (even if just once), like you have to start with `Email("foo@example.com")`. You're right that it being a completely different type is valuable, because that potentially allows for inheritance, among other things.
&gt;(no `UInt(10)`) no `U`
I disagree, the problem is not altogether fixed but it's better. You can close the gap with code reviews. For example by forbidding `val email = "john@doe.org"` and ensuring we have `val email = Email("john@doe.org")` everywhere. I think the Age example shows the limitations and the Email one shows where it will shine. Small improvement but still an improvement.
The way you would ensure that an email has a valid format would be to make the constructor private and have a factory that takes a **String** and only returns **Option&lt;Email&gt;** or **Email?** if you don't want to box the type. I haven't tried it myself yet so I'm not sure if there will be any issues with this technique. This idea comes from Haskell's newtype keyword. It allows you to create a what looks like a new type wrapping another type. But the type only exists during compile time type checking and doesn't have a runtime cost.
&gt;I think Gradle itself switched to Kotlin DSL for its own build process Yeah I think he mentioned that in the talk, pretty neat! &gt;the fact that you run code to configure your build, instead of it being all declarative. Every Gradle file I've managed has looked almost exactly like XML, but replacing `&lt;&gt;` with `{}`. Sure it's technically code, but code doesn't have to be imperative, *especially* not Kotlin. But yeah I was addressing their concern about it being its own DSL, where Kotlin helps because you can go-to-declaration or list all possible actions and such. That's what I personally hated about Groovy Gradle, there was far less structure. But yeah, different strokes for different folks!
All generics get boxed here, so no wins for Arrow :(
Fair enough. I was floored when I learned that Gradle does Groovy AST transforms on the project script file... that's for example how their weird "task" syntax works. It's like "yeah, it's cool and all, but WHY?"
Thank you for pointing it out. I will take care of this =&gt; no more images!
To add to this, I also dislike the reverse: choosing `User` as interface name and `UserImpl` as implementation name. The implementation should tell what kind of implementation it is, not just that it is an implementation. Like `ArrayList`, `HashSet` etc.
It would be helpful to let us know what is actually happening when you run it compared to what should happening. I can see that you're calling `fruit(). toString()` but `fruit` is a variable not a method, and calling `toString` on a sequence will return all of the contents as a string. You can try something like `fruit[position]` and that should return the correct value
Isn't this basically trying to be a value type? Why not wait until the JVM adds support for them?
TornadoFX is the only one I know and its nowadays the standard for kotlin GUIs. It‚Äôs based on javaFX. You can use any java related gui Solutions too on kotlin.
If it's based on JavaFX, how is it a frontend framework? Kotlin script doesn't work with Java.
Kotlin scripts (.kts files) work just fine on JVM.
If you're targetting JS, you can use any frontend JS library natively with the [external keyword](https://kotlinlang.org/docs/reference/js-interop.html#external-modifier). There aren't and probably won't be any Kotlin-lang libraries because they'd just be cross-compiled to JS anyway.
How do you run JavaFX in browser on JavaScript without applets? If you don't then it is not a frontend framework.
Yeah, my bad. I thought kts was for targeting JS.
You are right, the linked blog posts implies that they are eliminated, but the docs do indeed state otherwise https://kotlinlang.org/docs/reference/inline-classes.html#representation 
When I made the comment I was thinking of them being *declared* inline rather than what happens at compile time (which I agree is consistent). My point is its better to name things from the users persepective rather than the implementors perspective, most of the time I don't want to be concerned with the compile time representation of these constructs.
QT for Kotlin would be cool!
That is why you would use a factory method. Factory methods are static methods and do not have a restiction on their return type. Java or kotlin could pass in an invalid email string but then the factory would check it for validity and return null if it does not pass.
You can't have private constructors either, so you can't force people to use your factory function.
It's more comparable to a type alias, but with strict semantics.
Take a look at: https://github.com/rjaros/kvision . It's actively developed and seems pretty stable from the last time I used it.
You're right about the primary constructor having to be public. I just tried it with Kotlin 1.3.0-rc-190-IJ2018.1-1 and got the following error. `Error:(3, 20) Kotlin: Primary constructor of inline class must be public`
You probably looking for one of the following: ``` private fun createDummyItem(position: Int): DummyItem { val fruit = arrayOf("Apple","Strawberry","Pineapple","Grape","Jalapeno","Etc") return DummyItem(position.toString(), fruit[position].toString(), makeDetails(position)) } ``` ``` private fun createDummyItem(position: Int): DummyItem { val fruit = sequenceOf("Apple","Strawberry","Pineapple","Grape","Jalapeno","Etc") return DummyItem(position.toString(), fruit.drop(position).first().toString(), makeDetails(position)) } ```
Front end just means user facing. Not every front end framework targets the web
Sure, especially when the author wanted something without dependencies on external JavaScript libraries. Advicing JavaFX should be the way to go, right?
Technically speaking, TornadoFX has no JS dependencies...
Technically speaking, TornadoFX has no JS dependencies...
Qt Jambi makes this possible I think. It's a java thing, but Kotlin could definitely leverage it.
I have great respect for the author of Strikt, I've been using his open source projects in the Groovy ecosystem before and they were always well engineered and maintained. I've only used Strikt for a few trivial tests for now but it's definitely going into my next Kotlin project.
Still struggling to get Jacoco coverage picked up by SonarQube, it just won't use the Jacoco sensor. :(
I don't know if there are many great answers. The approach I might try is to start building some simple random apps and just filling in knowledge where you need it. Do that in conjunction with learning Kotlin in a more uniform manner to cover any gaps. What my approach has been is to have some test project that I am working on, and then to watch/listen language overviews and developer videos close to bed. [https://www.youtube.com/watch?v=H\_oGi8uuDpA](https://www.youtube.com/watch?v=H_oGi8uuDpA) Is that approach going to work for you? Who knows, but there probably isn't an easy approach. There are good resources for people for going from Java to Kotlin (for obvious reasons), but there aren't nearly as many resources for people coming from other languages into Kotlin, what they are kind of stuck with are more beginner tutorials.
Ah, because no private constructor, i forgot, thanks. Thats probably due to the need of boxing, i guess.
Try disabling the browser cache in dev-tools.
It could also be used with KotlinTest. I know KotlinTest comes with its own assertion library, but you can use another one instead.
Thats the odd thing - DevTools are open, cache is disabled. 
Are your lat and lon specified in degrees? Math.cos and Math.sin expect an input in radians so you may need to convert them.
Just scanning through the code, the other only error that I'm seeing is that the denominator in the arctan is implemented incorrectly. Right now it's implemented as: `cos œÜ1 ‚ãÖ (sin œÜ2 ‚àí sin œÜ1) ‚ãÖ cos œÜ2 ‚ãÖ cos ŒîŒª` but based on your original post, you actually want `(cos œÜ1 ‚ãÖ sin œÜ2) ‚àí (sin œÜ1 ‚ãÖ cos œÜ2 ‚ãÖ cos ŒîŒª )`
okay, can you check this link [I copied formula from](http://www.movable-type.co.uk/scripts/latlong.html) and since it does not have parenthesis defined in JS code as well I am a bit confused, I tried doing this way because I thought that values were first going to be subtracted
You'd need gradle to do a kotlin multiplatform project
I believe it starts on October 22nd
What's very odd is that kotlinApp.js, kotlin.js, kotlinApp.meta.js - they all show 01.01.70 as their modification date. Though I created a abc.txt with touch abc.txt and this file shows the correct date
Yeah, but we're talking about switching from Java to kotlin, I think going multiplatform is a bit out of Scott for that, so maven should be just fine.
IMHO it is. I presume how it will be handled on the JVM later on is an implementation detail, though.
great, I have seen people using `Location.bearingTo` for finding the direction but I don't know why that returns wrong results or maybe I am not giving it something I should, anyways, I see your approach, need to look at the code
Sequential by default. For parallel execution, you have to use launch or async :)
As /u/hpempeintner said, sequential, one after the other, just as it looks in your code. This presentation really cleared up a lot of the questions and misunderstandings I had about coroutines: [https://www.youtube.com/watch?v=\_hfBv0a09Jc](https://www.youtube.com/watch?v=_hfBv0a09Jc)
Perfect. Thanks so much. 
Spring boot for the most part. We'll start replacing stuff with Ktor when it hits 1.0
That's one of the many reasons I don't use Dagger. Sadly, even with this feature it's still horribly documented and produces horrible, unhelpful compile errors. Plus I find I can do fine without DI for normal sized apps as a solo dev. YMMV
OMG pleas not - Dagger 2 is the worst piece of SW I can think of.
I completely agree with you, Dagger has caused way more problems than its solved in our project. Unfortunately I'm stuck with it because it runs throughout our in-house frameworks and project source code. Like you I never found a problem with coding to interfaces and writing a properly formed 'App startup' routine. It rarely ever gets complicated and most of the time is so much simpler.
Indeed. Just don't want to lose any more seconds of my life to it than necessary.
Since no one else bothered I'll add a note. My experience with both kotlin and ktor is very limited. But overall it looks good. Only thing I would do different is that I would wrap my repository in a service and use that in my controller but beside that (and the lack of tests) it looks good.
While I like the idea behind Dagger2, compile-time DI, annotation processors are horrible! Maybe as a Kotlin Compiler plugin?
Maybe as a language feature! https://github.com/Kotlin/KEEP/pull/87
I remember watching that talk and understanding absolutely nothing.
I'm explaining it from scratch with examples at Droidcon UK, and AndroidTO. Look for the videos in a week or so, it'll hopefully be more clear.
I'm explaining it from scratch with examples at Droidcon UK, and AndroidTO. Look for the videos in a week or so, it'll hopefully be more clear.
I'm surprised by the hate for Dagger in this thread. I've been using it with Kotlin for a while and am pretty happy with the combination.
yEAh But HAVe you hEard aBOuT aLL THeSe PUre kOtLiN DI SOLuTIONs ThAT Are BeTTER? GooDbYE DagGEr WON'T MISs yA
I don't know the request library you are using. Is the response delivered to you on the main thread? If not you might have to look into scheduling things to run in background and return to main thread. There are many ways to achieve this. The simplest would be probably async task. Or you look into a network library like ok http or retrofit that can do these things for you 
Please use Koin. Thank me later
To be fair, handwriting DI code in Java is so verbose that it's not trivial. It certainly solves a problem in that respect
I gave it a good try and honestly feel too stupid to understand it
Dagger might be good, it might not be. But the documentation and examples are dreadful, and I could never get my head around what it was trying to do or how I was supposed to use it. What the eff is a "Thermosiphon" and how does it relate to services, DAOs and other things I might actually want to inject?
I use [Volley](https://developer.android.com/training/volley/). I think it's running in main thread
Personally I think it is as simple as the following. 1) Explain advantages of Kotlin, assuming you know this already or you wouldn't be asking this question 2) Learning curve for java devs is easy and straightforward, at least for the basics, advanced stuff can come later 3) Works side by side with java, can start with 1 file, you don't have to convert the entire project, just a few as proof of concept while everyone adjusts.
Yes we successfully adopted Kotlin at NetSuite by showing examples how Kotlin will: * Increase productivity * Reduce defect rates since Kotlin eliminates many types of common defects (many more guarantees in addition to null safety) * Increased code re-use (Kotlin allows you to extract more patterns than what is possible with Java) * Pattern enforcement (Kotlin enables us to enforce more patterns than what is possible with Java) &amp;#x200B; Additionally, Kotlin will: * Enable us to deliver more value to our customers (increased productivity &amp; reduced defect rates allows us to deliver more features especially since companies spend considerable resources on defects) * Increase employee retention (developers like to learn and use newer technologies) * Increase employee morale / happiness (recent stackoverflow survey showed that Kotlin is one of the most loved languages) * Increase the number of candidates that will apply to work here (many developers are excited to work at a company where they can use Kotlin) &amp;#x200B; Lastly, you just need to show how the common concerns don't apply (eg. Java interop allows you to continue leveraging your existing investments, same security guidelines apply, etc.)
What is the use case for this? I don't really get the point.
Well, now you have.
Now you have
For a real product? Is it available anywhere (both source and product)? I'm pretty interested in it, but I've only ever seen it used for small demos. How do you like working with it? 
i personally don't like transpiling/cross-compiling anything to javascript. The JS ecosystem is very chaotic as it is, and adding the extra step to do that makes the whole thing even more rickety. I'd rather just write vanilla JS. I understand why people do, but I was fortunate enough to mostly avoid the JS world until about 2 years ago, but by that time the in-browser development tools and IDE support have gotten quite good, so with effective documentation, linting, and testing, all of which you should be doing any way, you won't get bitten by the traditional JS pitfalls to answer your question, i've never used or met anyone using kotlin to write JS. If you like JS slightly more, take a look at dart. it looks and feels a lot like JS
We have some admin backend pages for a game server written in Kotlin Javascript (and the server itself is 100% Kotlin). Half way through the development process we tried switching to TypeScript for these pages and from then on all new pages were coded in TypeScript only. Maybe it's the frontend library we're using (Vue - it relies a lot on the quirks of Javascript) but TypeScript has much less friction. We used a library from GitHub to transform selected Kotlin classes into TypeScript definitions so we don't have to code the DTO objects twice and it works just fine.
Fair enough! The main use case for Zircon is \[roguelike game development\]([https://www.reddit.com/r/roguelikedev/](https://www.reddit.com/r/roguelikedev/)). The reason why I shared this here is because Zircon is a Kotlin multiplatform project and I thought that some people might be interested in taking a look. That's all!
How in the holy hell did you manage to convince anyone in government to use kotlin? The same government that still primarily uses IE
Somebody posted a similar question a few days ago, and one of the suggestions was genius: make a hypothetical pull request showing a select few Java files versus how they look in Kotlin. Guarantee you you're going to get much more concise code with the Kotlin version (unless it's an extremely trivial file or an interface), plus the code will likely have better null safety.
&gt;If you like JS slightly more, take a look at dart. it looks and feels a lot like JS TypeScript is a far more obvious (and far better) choice than Dart.
a) Don't assume you know which government I'm talking about (well, if you've gone through my post history it's kinda easy). b) The first iteration of this ran on IE 9. The requirement has since been relaxed to IE 10. c) Server-side, as long as it runs on a JVM, they don't care that much.
We used it to write some developer facing tooling. We had trouble finding good ways to test it and then I think that project migrated to typescript. 
Don't know the book but Venkat is a solid author. Based on that alone I'd have no qualms in buying it if the subject matter was at a level I was interested in.
I'm using kotlin-react for a new site I'm creating for my company. It was somewhat of a steep learning curve, since the documentation is currently somewhat lackluster, but a couple of weeks in I'm almost as productive in kotlin-js (with fully type safe css might I add, which may be my favourite part) as I am in vanilla JS/TS. Creating bindings for JS libraries are similar to creating type definitions in TypeScript. &amp;#x200B; As a sidenote: At KotlinConf this year I remember from the keynote that one of the biggest banks in the UK were rewriting all their frontend code to Kotlin, so at least someone is making the jump.
i understand why you would say that, but it is heavily dependent on career goals. dart fills the same application space as dart. typescript is targeted solely at javascript (if that has changed, please correct me). i interpreted op's post to be in search of something closer to the former than the latter
We've written an internal tool that requires pretty strict typing (or at least, we desire that) and I find kotlin much much easier to work in than TypeScript.
I found it useful time and time again for small tasks that require JavaScript which I will avoid to use whenever possible. The latest is an automation tool for an online browsergame. I decided to implement it as a simple user script, using Kotlin I can fortunately implement that in an organized manner in my favorite IDE. I just need to @require kotlin.js from a CDN and copy paste the output from IntelliJ to the userscript and everything works fine. In Kotlin, I can just place HTML as raw strings and use string templates to conveniently insert values. This works better than I hoped for and I enjoy writing this script. With JavaScript, there would have been no joy. I am happy Kotlin/JS is a thing.
The way I see it, if Fuchsia gets big, Flutter gets big. Otherwise I don't see it happening. It would be nice if someone made a similar React-like framework based on Kotlin, because Android's native UI is a pain in the ass.
I'm finding ConstraintLayout with databinding really quick and easy, HTML+CSS is much clunkier. What does React add to the UI layer?
I bought it yesterday. Its decent so far, although the sections I was looking forward to such as coroutines and internal iteration etc are not complete yet. About 100 pages in it's a decent book. I'm coming up to the OOP section now. 
Would like to know if it is more focused on Android 
Neato. Will check it out later.
That's neat. I guess the difference is declarative vs programmatic. You could create an Android UI the same way, \`layout.addChild(TextView(...)))\`. One Activity with no Fragments is fine if you don't like them, it's just recreating its root view heirarchy when the data changes. Storing the data in a ViewModel would take care of the lifecycle things for you. Or just (\*cough\*) reference it in the Application - probably bad Android design but that's effectively what React does with its global state. &amp;#x200B; Mogul looks similar to TornadoFX, or libui-kotlin which has a nice kotlin-DSL wrapper for cross-platform native desktop apps. Actually a web target for libui-kotlin would be interesting... &amp;#x200B; The web's mostly been declarative from JSP through JQuery to Angular/Vue - properties on elements to hide/show/repeat - I guess that's what I'm used to so Android's XML layouts seem natural. With databinding the amount of code needed to back a layout is vastly reduced. &amp;#x200B; The per-user loop I'd do with a Recycler passing the List&lt;User&gt; in a databinding property then specifying the layout to use for each row, I guess it's clunkier than the above example because the row's layout would have to be in a separate file. But I really like the design-time preview, especially since they added sample data sets. You could do it with one Activity, no Fragments and a very busy root layout using databinding to hide/show nested layouts based on observable data.
Let me leave this nasty review here just because I can. You can't delete it. Yelp should die.
buzzword-driven development is more effective
What's the name of the library you used?
You are not Yelping!
&gt;I guess the difference is declarative vs programmatic. You could create an Android UI the same way, `layout.addChild(TextView(...)))`. The #1 key difference is that `layout.addChild(TextView(...)))` (same as Android XML) usually only creates the **initial state** of the UI - how it looks when that part of the app first starts. The React example specifies how the UI looks in **every possible state** - the `render()` function doesn't just get called at start, but on every single prop or state change (you can also filter it for performance reasons) and then the UI gets updated by the library to match whatever the `render` returned. It's kind of like databinding on steroids in that sense. &gt;Storing the data in a ViewModel would take care of the lifecycle things for you. I use that a lot on Android, but it doesn't solve everything. For example `viewLifecycleOwner` on fragments only very recently arrived into the stable version of the support library. See for example https://medium.com/@BladeCoder/architecture-components-pitfalls-part-1-9300dd969808. There is a lot of crap you have to keep in your head to do things correctly.
Sorry, I don't exactly understand what you're referring to. If you mean containers as in Docker, I'm pretty sure that there is no way that bumping the bytecode version would affect container support.
Rust uses `let` and `let mut` but like others said, mutability already means something else in kotlin. 
You could do the same in Android or the other libs if you wanted to - a render() method could detach the root view and build a new one, triggered by observables. I guess that's how mogul works. Given both are reactive I'm not sure if I'd prefer the concept of building a UI using code vs a declarative layout, I don't see the advantages. That's probably because I haven't tried it. I guess many people do because react is popular... But then react provides many other features that people like and I presume it has a declarative way of defining layout too. 
This guy is yelping us all 
I have read some stuff again and think I was mistaken. The newer JVM will be able to run older bytecode? And in that case a docker container running java 11 JVM with Kotlin 1.8 bytecode application logic will still receive the advantages of better integration with containers that arrived in java 10? In that case, yeah sure, upgrading the bytecode seems unnecessary, thanks :)
Yes, of course you can run Kotlin-produced bytecode on JVM 11, and benefit from all the new features added to the JVM.
&gt;You could do the same in Android or the other libs if you wanted to - a render() method could detach the root view and build a new one You could (not build a new one each time, but apply the diff), and there are a few libraries like that for Android, such an [Anvil](https://github.com/zserge/anvil) or [Litho](https://fblitho.com/) (and [Flutter](https://flutter.io/) I guess), but they each have their own drawbacks and a degree of clunkiness. &gt;triggered by observables Not really. How state is represented and managed is a whole huge topic in the React world and there are many options, many of them requiring immutable objects. Many basically shape a huge part of your app's architecture. Though one of the options is [MobX](https://github.com/mobxjs/mobx#core-concepts), that uses the classic observable approach.
I liked it more than kotlin in action, although the in action book seemed more thorough, this one has better explanations and was more concise and a nice quic read. For example I hadn't worked with properties before and this book had a better although shorter explanation of properties and backing fields. This is just my subjective opinion though, and I haven't read the full in action book, only parts of it. YMMV
I wrote a node application with Kotlin after I got frustrated from JavaScript. I have experience with Kotlin coding Android apps and KotlinJS is a pleasure. I don't need to learn the differences between different JS versions or what's best practice regarding syntax (;) etc. There are just a few npm libraries that require some workarounds, like Sqlite.
Have you tried declaring the class not in the scope of that test function?
Yes, ofc, I first tryed on a real data class. 
And have you tried a clean build + fresh run? I don't really know how that plugin works, but I think it's a compile time thing. 
Its looking for a no-arg constructor. I think you need to add a plugin for that, forgot the name but try 'no-args' for starters
Bashing my head against the wall on this one today; resorted to only ever using gradle to run the project. Specifically for tests, you can go to settings and delegate test running to gradle which the kotlinx serialisation documentation states.
ok, someone please help me out. what the hell is with kotlin and the shitty library names? ktor, kwang, krangl, etc. they look more like an unfortunate scrabble draw than anything else. other languages don't do this. why does the kotlin community?
Hey, the pronunciation of my name (and its resemblance) is not that shitty.
would you walk me through how you came up with the name?
tbh, choosing the name is like bikeshedding. And it is a lwan wrapper, based on my name [https://en.wiktionary.org/wiki/quang](https://en.wiktionary.org/wiki/quang), starting everything with K is just conformity with expectations/convention
Yes, it's okay to not name a project beginning with K just because its Kotlin.
I tried your suggestion and it seems that mine and `Location.toBearing` are now giving almost the same result, still I am confused in fact that when I am providing same location for both source and destination, then inital bearing should return 0 degrees which is what formulas return (initial bearing), but they return 90 degrees.
It's unfortunate that all the discussions devolve into bikeshedding issues around names/cosmetics instead of discussing the actual concept and goal of a project. Anyway, good on you to be working on a **server side** component for Kotlin, something that is needed in the Kotlin community to counter balance the Android heavy projects.
yes can i order 1 kpineapple kdrink thank you ksir
IMPOSSIBLE *glances at ktextutils, knumutils, kitem, kontainer, yes these are actual class names i have in my project*
What is the company where people decide to use/not to use tech because of its name you are taking about?
I was just searching some good resources about TDD lately ‚ù§Ô∏è
Kotlin 1.3 is being released. Please wait until a proper announcement from JetBrains.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/androiddev] [Kotlin 1.3 stable released!](https://www.reddit.com/r/androiddev/comments/9sdun1/kotlin_13_stable_released/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Well, coroutines are finally stable. One of the best and mostly expected features in the whole language imho.
Is there a ELI5? Learning Kotlin right now and haven't gotten to deeper things but starting.
&gt;Kotlin/Native Beta Does it mean we can complain about performance now? üòÉ
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Kotlin 1.3 Released with Coroutines, Kotlin\/Native Beta, and more \[x-post from r\/Kotlin\]](https://www.reddit.com/r/programming/comments/9se5wo/kotlin_13_released_with_coroutines_kotlinnative/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
tbh I think you could could complain about performance much more earlier, but there still a chance that JB team is already working on it or have made the statement. That's what the JB feedback loop during beta is about.
Yeah same, I can¬¥t find beginner tutorials about them, especially ones related to Android
There were tons of talks about this at KotlinConf this year. This one by Chris Banes is Android-specific and explains it well: [https://youtu.be/P7ov\_r1JZ1g](https://youtu.be/P7ov_r1JZ1g)
"Works" first, "Fast" second :) We will be working on performance throughout the next big iteration. 
You can read about coroutines at https://kotl.in/coroutines
Hadi said at Droidcon London how it was funny the first time and then it made you want to ü§¶‚Äç‚ôÇÔ∏è 
From what I understand, they allow you to write async code very easily (just as easily as blocking code, in fact). Like writing an anonymous AsyncTask but without the drawbacks. Can someone correct me on this? I only regret that we _have_ to learn a whole new language just for this feature. I really like Java.
thanks
&gt;y regret that we &gt; &gt;have &gt; &gt; to learn a whole new language just for this feature. I really like Java The transition from Java to Kotlin is really dead simple. At which point you'll basically just be writing Java inside Kotlin, but with more concise syntax. Then you can start to learn to write more idiomatic Kotlin. But don't let that stop you, even at the "Writting Java in Kotlin" phase, it's a joy to work with!
I wrote some blog posts on [coroutines](https://www.codingstoic.com/introduction-to-kotlin-coroutines/) 
[my short intro ](https://www.codingstoic.com/introduction-to-kotlin-coroutines/) 
I don't see why not have inline class support unlimited number of parameters, so long as they are primitives, strings, or also inline classes
It might be possible to extend inline classes in that way, but I can't say off the top of my head which difficulties with the design it will cause (I'm pretty sure there will be some).
Is the serialization library now part of the core library so it doesn't need to have its own `compile` line in build.gradle?
How would a List of that inline class work on the JVM?
Aha, thank you for that! 
With coroutines becoming stable, does anyone know about a piece of non-trivial, open source code which can be treated as "coroutines capabilities showcase"? I'd like to try and assess for myself what coroutines really bring to the table by rewriting such a code using "old" techniques and comparing the results. 
I like this, Java in Kotlin while you learn Kotlin.
Is there a guide or example on how to distribute libraries for native now? :)
By boxing.
probably because they wanted it to sound professional and not add a gimmicky play on words name for it. I applaud them for this 
How would you return such an inline class from a method without boxing on a JVM?
I don't think its a full showcase but this is using an Actor: https://github.com/jasync-sql/jasync-sql/pull/26
Thank you very much
This is exiting since the backend of our current project is being developed in kotlin.
That would slow it down. The whole reason why inline classes exist is to have good performance while maintaining good typing. If you start boxing stuff, you might as well just not use inline classes at all...
Why would you rather not use these? They're the easiest way to manage the build of a project. That being said, you can get the jars from maven directly and manually add them as jar dependencies 
_Great!_ I was waiting for coroutines to become stable. Concurrency/paralellism was a PITA in multiplatform projects before. And now the tooling is also improved. Nice work!
&gt;I only regret that we have to learn a whole new language just for this feature. I really like Java. &amp;#x200B; I'm pretty sure learning Coroutines is harder than learning Kotlin. There's quite a bit of depth to coroutines, and you can pick up Kotlin (without some of its nice features though) right away. We're not talking Lisp or Scala here.
Which framework do you use?
Using a long, as in a "pointer". https://GitHub.com/Jire/Strukt I did it sorta here, but I'm sure it could get a whole lot better with support from the compiler.
You're already boxing if you don't use something like fastutil, since the JVM doesn't support primitives in generics. Anyway how it could be done is by using pointers and providing collection implementations that use this, although, I think it's unreasonable to expect.
I wouldn't say this is necessarily a "showcase", but I've recently used the co-routines API in my machine learning framework. You can see an example of using the actor model [here](https://github.com/JedS6391/LGP/blob/develop/src/main/kotlin/lgp/core/evolution/training/DistributedTrainer.kt).
Please see https://github.com/JetBrains/kotlin-native/tree/master/samples/libcurl for local repo.
We are aware about it, but of course feel free to complain, especially if you have concrete code where performance suffer.
Just create a new Kotlin project from Intellij. Gradle will be setup for you... then it's just a case of adding a single dependency. Pretty much every Kotlin project will use Gradle or Maven.
SQL Delight sounds very promising: https://github.com/square/sqldelight Here is a talk from KotlinConf 2018 about it: https://www.youtube.com/watch?v=WkIry790PHI
That's probably the best name for the talk covering coroutines usage lmao
If you need multiple writers, SQlite is not suitable for you.
You really should learn it. Maven is really easy once you get the hang of it and adding jars manually is not something you should need to do.
Vertex and ktor
The main issue for me right now is build speed. The small videoplayer sample from the KN repo takes about 13 seconds to compile on my laptop (Linux, dependencies are up to date prior to the build) after a tiny change. On Windows, the same takes around 25 seconds. I haven't used Kotlin Native on a larger project yet, but if this grows with the size of the project, it will have a major impact on productivity.
Is this already availible in Android Studio? Is some action needed to use this version of Kotlin in existing projects?
But If you don't need it than stick to sqlite.
The writers of Head First Android are currently working on Head First Kotlin, which assumes no prior knowledge of Java, but isn't specifically geared towards Android programming. Here's the current blurb: &amp;#x200B; "Head First Kotlin is a complete introduction to coding in Kotlin. This book helps you learn the Kotlin language with a unique method that goes beyond syntax and how-to manuals, and teaches you how to think like a great Kotlin developer. Despite its playful appearance, it's serious stuff. You'll learn everything from language fundamentals, through to collections, generics, lambdas and higher-order functions. And along the way, you'll get to play with both object-oriented and functional programming. If you want to really understand Kotlin, this is the book for you".
We are using gradle, ktor, kotlintest, and mockk currently but are going to possibly switch to mockito for mocking.
The linked blog post includes upgrade instructions in the end.
I know this doesn't help much, but because the interopable nature of Kotlin, you should stick to whatever best pratice the platform you are targeting follows, if you are targeting the JVM, you can find many resources for best pratices in Java that are very applicable to Kotlin, the same can be said for JS (to a lesser extent) and Native. &amp;#x200B; In most cases you stick to the "kotlin-test" lib
I like KotlinTest, it allows for property based testing (it generates test cases for you) which pairs well with unidirectional flows that use sealed classes to represent state :D
We use a combination of JUnit 5 and Spek, all running under Gradle. I like Kluent for assertions, and use Mockk for mocking. 
Basically what this guy says [https://blog.philipphauer.de/best-practices-unit-testing-kotlin/](https://blog.philipphauer.de/best-practices-unit-testing-kotlin/)
kotlin-test is by far the best unit testing framework for Kotlin. Forget Spek or JUnit 5.
Lol
Based on your questions you should start with something smaller and not on Android, the UI part sucks imho. The video files can be saved as some sort of other object that your program can encode/decode. The sharing part can be solved with Bluetooth or NFC I guess. Try to make some sort of Note store app in Kotlin for desktop first, whenever you stuck, ask Google. Store the notes in plain txt, then "encode" them, decode them, etc. Good luck!
Do you mean [KotlinTest](https://github.com/kotlintest/kotlintest) or [kotlin.test](https://kotlinlang.org/api/latest/kotlin.test/index.html)? Assuming the former, I like it too, though I wish the "matchers" were... *actually* matchers. What the documentation calls matchers are assertions. They are usually backed by something that's matcher-like (and there's even a Matcher class/interface in there) but there seems to be little documentation or support for using them directly, composing them, or creating your own matchers, at least last I checked. I've been kind of tempted to switch to using hamkrest for assertions/matchers on top of KotlinTest.
You can use Gradle and still depend on local jars. You also can use a repository manager like e. g. Apache Archiva, so it can mirror dependencies.
Hey! I'm actively developing KotlinTest. Would you like to talk a little bit more about this? Feel free to PM me or to open an issue at Github. Let us get these issues improved!
My team uses [KotlinTest](https://github.com/kotlintest/kotlintest) for test writing and assertions and [Mockk](https://mockk.io) for mocks
That sounds really awesome! Is it available to the public? :)
That's what we use as well, Mockk is very good
I use junit5, with kotlintest for assertions, and mockk for mocking. I'm still on the fence about what to use but I have a growing amount of tests based on this combination. I actually also have some older testng projects where I'm now bringing in kotlin test and mockk as well. This stuff probably also works fine if you are stuck with junit4. Kotlintest basically addresses assertions with a very nice idiomatic syntax for assertions like list.size() shouldBe 20. IMHO this is its core strength. It also offers various ways of structuring tests which are also nice but in my view a more or less orthogonal set of functionality and not really that important to me. Honestly, it feels a bit experimental/gimmicky to me and also kind of limited. It actually builds on top of junit 5, which is of course is fine for what it does. And if you use kotlin's backticks you can write nice tests like @Test fun `this list should have a size`() { ... } So, I see kotlintest as providing two sets of more or less orthogonal functionality of which I only use one set. Maybe breaking it up would be a good idea. This style of assertions is definitely the most elegant I've seen for Kotlin. And then there is also stuff like assertk, which is sort of adapting assertj for kotlin. Unfortunately they are not really taking that to the next level by e.g. using infix notation like kotlintest does. So you end up with a lot of stuff in brackets, which to me looks ugly now that I've seen how it can look like with kotlintest. Mockk makes nice use of kotlin's DSL features and I love using @RelaxedMock to avoid having to micromanage every interactions with dependencies. Judging from the stars in github, the projects I mentioned seem to each have a lot of momentum. 
So far my go to stack has been JUnit 5 + Kluent + Mockk. KotlinTest looks good, but somehow I never got into it. Now planning to try out (Strikt)[https://github.com/robfletcher/strikt]. 
I'm pretty sold on their approach, really hoping to see support for backends other than Sqlite. Postgres, Mysql, ect. &amp;#x200B; This could become an industry standard if it supports other dbs!
That was a great summary!
Nice write-up, thanks! 
I'm guessing `currentRoute` is defined as a `var`. Because the reference is mutable, there's nothing stopping another thread (or another function that has `currentRoute` in scope) from changing it to null before you try to dereference it. If we assumed `var currentRoute` was non-null inside the `if` block, this would be okay: fun doSomethingWithVar() { if (mutableThing != null) { naughtyFunction() mutableThing.doSomething() // this is null! } } fun naughtyFunction() { mutableThing = null } So how do we fix this? One idiom is to use `let`: mutableThing?.let { it -&gt; // we know "it" is non-null here } But your code has an `else` branch, which is a little clunky to get done with `let`. We can also copy the mutable `var` to a `val` reference -- then we know it can't possibly change! val immutableReference = mutableThing if (immutableReference != null) { immutableReference.doSomething() // this is okay! } else { // do something else } If `currentRoute.transList` and `lastStation.trainsStation` are the same type, you could also do something like this: val target = currentRoute?.trainsList ?: lastStation.trainsStationed target.add(this) Hope that helps!
&gt;But your code has an `else` branch, which is a little clunky to get done with `let`. We It's not really that clunky. Just do: currentRoute?.let { it.trainsList.add(this) } ?: kotlin.run { lastStation.trainsStation.add(this) } 
Now that we have FunctionN, is there a good reason for not deprecating Function1 to Function23?
Awesome write up! I am just have a question about this example return when(val answer = theAnswer()) { 42 -&gt; "You got the right answer!" else -&gt; "Sorry, $answer is not correct" } Is there any value we get for creating a variable vs. just writing this? return when(theAnswer()) { 42 -&gt; "You got the right answer!" else -&gt; "Sorry, $answer is not correct" } Or is it just more of a readability thing?
id guess \`currentRoute\` is defined as a nullable type of a variable, it will either be null or that type of variable. if \`currentRoute\` is optional and is... "optionalized"? as a null (null is the default value for this variable). &amp;#x200B; `if (currentRoute != null) {` `currentRoute.trainsList.add(this)` `} else { // smartcast is here and only in this scope, because currentRoute is verifiable as not null in this scope, therefore the compiler assumes it is &lt;type&gt; in this scope` `lastStation.trainsStationed.add(this)` `}` 
That's not the same thing. Java supports function composition too, but the pipe forward operator is not exactly the same. It is syntax sugar that let's you write `x |&gt; f |&gt; g |&gt; h` instead of `h(g(f(x)))`.
Great summary. Thanks.
for some reason i still cant really understand what a contract actually DOES. i feel like all the places i can use a contract, i dont really need to. maybe its just because i dont understand all the possible uses?
Performance, no need to wrap all the arguments in an array every time.
`inline infix fun &lt;T, U&gt; T.pipe(func: (T -&gt; U)) = func(this)` Used like this: `x pipe f pipe g pipe h`, replace with `::f` as necessary.
Koding Kotling Koroutines... KKK. Just don't.
For any method making http requests we use wiremock For normal mocking the kotlin http://mockk.io/ library is excellent All under gradle of course
I wonder if you could override an operator function here, something like plus, to reduce the verbosity of repeated calls to ‚Äúpipe‚Äù. 
In your `main`, don't type `testImp` as `Operator&lt;*&gt;`; type it as `Operator&lt;Any&gt;` or `Operator&lt;Any?&gt;` or maybe `Operator&lt;out String&gt;` (not positive about that last one, but I think it will work). You may also need an explicit cast (since `TestOperator` doesn't match any of those types), and you'll certainly get an unchecked cast warning, but that should get you past the compiler error. &gt; We parse JSON data and we don't know about the type of the generics, there are more than 20 Operators in our codebase and they use different generic types. What are the alternative approach in Kotlin and what's the safe way of doing without having casts everywhere or verbose code? I don't think you've shown enough code to answer that question. But Kotlin has some features that might help: [`sealed` classes](https://kotlinlang.org/docs/reference/sealed-classes.html) along `when` expressions, as well as [smart casts](https://kotlinlang.org/docs/reference/typecasts.html). Those wouldn't help with the problem that you describe in your code snippet, but maybe can help you avoid the problem in your code snippet.
Sure you could, although the readability of those is questionable as well. `+` needs to _add_ things together.
I just use vanilla JUnit 4.12 because it's what I'm used to and it works good enough for me. Anybody feel free to change my mind :)
Not yet, but I'm going to make it. I'll give you a pm when I finished, maybe you can give me some input then :) I took a look at your repository and your project is quite different than mine. I realized that I have a set of maybe very unique demands, but we'll see.
Kotlin will replace the `*` type to `Nothing` in your example, and since nothing implements `Nothing`, those methods are impossible to call. One possible solution is as you had guessed simple casting the `Operator` to an `Operator&lt;Any&gt;` internal inline fun Operator&lt;*&gt;.asAny() : Operator&lt;Any&gt; = this as Operator&lt;Any&gt; It's fast, cheap, not too much extra effort and it'll explode the moment you're not looking at your code &amp;#x200B; However, add in an extension function, a bit of reflection and Kotlin nullability and you could have something type safe internal inline fun &lt;reified T&gt; Operator&lt;out Any?&gt;.tryMap(col: String, value: T): String? { return when(this::map.parameters[1].type) { is T -&gt; (this as Operator&lt;T&gt;).map(col, value) else -&gt; null } } main: fun main(args: Array&lt;String&gt;) { val testImp = TestOperator() val result: String? = testImp.tryMap("test", "test") } Do note that using reflection makes this slow(er) and makes your jar quite a big bigger. &amp;#x200B; Kotlin Reflection can be bypasses altogether by having a `KClass&lt;T&gt;` field that we can check against instead of using method reflection internal interface Operator&lt;T : Any&gt; { val type: KClass&lt;T&gt; fun map(col: String, value: T): String } internal class TestOperator : Operator&lt;String&gt; { override val type = String::class override fun map(col: String, value: String): String { return "test" } } internal inline fun &lt;reified T : Any&gt; Operator&lt;out Any&gt;.tryMap(col: String, value: T): String? { return when(type) { is T -&gt; (this as Operator&lt;T&gt;).map(col, value) else -&gt; null } } But then we're entering muddy design imo &amp;#x200B; There's no escaping the type erasure of the JVM during runtime, if your code operates on the idea that it won't know what type the operator will be, why not do away with the generics completely? object NoGenericsTest { internal interface Operator { fun map(col: String, value: Any): String? } internal class TestOperator : Operator { override fun map(col: String, value: Any): String? { return when(value) { String -&gt; "test" else -&gt; null } } } @JvmStatic fun main(args: Array&lt;String&gt;) { val testImp = TestOperator() testImp.map("test", "test") } } You're now making the same check as the JVM in your java codebase but without the unforeseen risks of explosions
I don't have access to a computer to test right now, but does using a qualified `this` work, like so? Cache = this@PermissionTableHelper.CacheProvider()
Arrow has a pipe extension function https://github.com/arrow-kt/arrow/blob/master/modules/core/arrow-syntax/src/main/kotlin/arrow/syntax/function/pipe.kt
No this gives me the same error Overload resolution ambiguity. All these functions match. &amp;#x200B;
DatabaseTableHelper is in java and there is no open keyword or I'm not aware of it
oh, my mistake. i skimmed to quickly. i'll downvote myself to save others the effort
&gt; From what I understand, they allow you to write async code very easily (just as easily as blocking code, in fact). Like writing an anonymous AsyncTask but without the drawbacks. It has exactly the same drawbacks, except now it's easier to do unexpected captures :D
The reason you can't access it in the constructor is because you're already inheriting a field called `Cache` which is expecting to be type `DatabaseTableHelper.CacheProvider`.Here's 2 easy ways to resolve this: 1. Create another variable like `permissionCache` of type `PermissionTableHelper.CacheProvider` E.g: ``` class PermissionTableHelper: DatabaseTableHelper&lt;Permission&gt; { val permissionCache: CacheProvider constructor(): super() { permissionCache = CacheProvider() } inner class CacheProvider } ``` 2) Have your `PermissionTableHelper.CacheProvider` inherit from `DatabaseTableHelper.CacheProvider` and remove the `Cache` variable from your Kotlin class. E.g: ``` class PermissionTableHelper: DatabaseTableHelper&lt;Permission&gt; { constructor(): super() { cache = CacheProvider() } inner class CacheProvider: DatabaseTableHelper.CacheProvider() } ``` 
point 2 seems reasonable. But what if I want it to be completely different type and don't want to inherit from DatabaseTableHelper.CacheProvider ? Because in java this is possible: public class A { public int a = 1; } public class B extends A { public String a = "a"; } How is this possible in my case scenario (first class in java, second in kotlin, maybe it is not possible in my case, don't know.) ?
I did a bit of experimenting and it turns out that field hiding doesn't work in Kotlin. I would generally prefer to use `private` fields with getters over `public` fields, but it seems like you are misusing inheritance if you're trying to hide a field with a different type variable. Is your `Cache` variable accessed from outside of the class? If not then you could just make it private in both and you won't have any issues
Like someone else said, `.let()`/`.run()` fulfills this purpose. `56.let { double(it) }. let { sqrt(it) }.let { it.toString() }`. Either way, Kotlin is pretty general purpose, so you probably shouldn't expect something this specific to make it into the language. It would only work with functions that take no receivers and take only one parameter, and creating a whole language construct around these specific conditions adds to much complexity for what it's worth.
Another recommendation for arrow. I come from f#. While not one to one it's good for all I need.
My ideal set up JUnit5 for the framework and assertions and MockK for mocking. JUnit5 supports nested test classes and if you look at the main features for the other testing frameworks out there like Spek and KotlinTest, they essentially boil down to being able to write more structured and readable tests with nesting. Since JUnit5 is powerful and established and already does what these other frameworks do, I'd pick it over the others unless if I really care about readability. I'd use JUnit5 for assertions too because it does everything I need so I see no reason to have a more complex assertion library that would require significant effort to learn. The only benefit I see with the other libraries is that it might make assertions more elegant and readable. I'm used to MockK for mocking. I like mockito-kotlin because I'm used to mockito, but MockK looks like it fully takes advantage of kotlin features and has a lot of new powerful functionality that mockito doesn't.
`*` isn't the same in Kotlin as Java. You want an `Operator&lt;Any&gt;`. Or even better, consider that you have absolutely no need to write this the way you did anyway (in Kotlin *or* Java), and are being verbose/complex without adding any clarity to your code: `val testImp = TestOperator()` `TestOperatoe testImp = new TestOperator()`
What else do you need? ;)
Well, no code example nothing specific about testing in Android, the title could have been named "TDD concepts"
&gt;Reply I've often thought myself the matchers could be improved to allow better composability. You can in fact use AND and OR with matchers but it is a bit obtuse, and you can create your own and then use it with should. Eg myvar should doWhatmyMatcherSays() &amp;#x200B; [https://github.com/kotlintest/kotlintest/blob/master/doc/reference.md#custom-matchers](https://github.com/kotlintest/kotlintest/blob/master/doc/reference.md#custom-matchers)
I'm the original author of KotlinTest (but now just one of several contributors), and there's plenty of "assertion libraries" out there (although I think KotlinTest's is the best for the same reasons you say). So for that reason I would have thought the opposite to your feedback, which is that KotlinTest is \_most\_ useful for laying out tests. It offers far more flexibility than say Spek, and provides table testing, property testing (with excellent narrowing). So it's very interesting what you say. 
You're way too early in the design process to be deciding languages. What you have is an idea written on the back of a beermat. To be honest from your description you'd benefit from going on a decent programming course first.
It definitely does seem like we had different requirements, my primary one being avoiding allocation in its entirety; but we were definitely in the same mindset for the layout using delegated properties. I didn't even know about defining extension operator function, really awesome! You did a great job on yours, learned quite a few things!
Thank you very much for you time. You are probably right that I misused inheritance. I will need to rethink design, it is probably not the best possible. Good to know that hiding does not work in kotlin. Good job, thanks.
The short answer is - by design, all parallelism is explicit. In your first example you are not explicitly saying to run in parallel, so it doesnt. 
I think your runBlocking will make it all run sequentially, &amp;#x200B; your second example look more like the idiomatic way to me 
It did not answer my question. The talk didn't go into interacting with blocking code. It only talked about launching coroutines from suspending functions/coroutineScopes. But they too need to be called from a coroutine/suspending function/coroutineScope. The talk didn't leave the coroutine world and didn't show the interaction between blocking and asynchronous code.
runBlocking only uses the current thread iirc, so only one coroutine is executing at any given time. Because your suspending functions have no suspension points, they are run to completion in the order they were scheduled.
CommonPool doesn't seem to be available in Kotlin 1.3.0.
Looks like it was renamed to [`Dispatchers.Default`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html).
That explains it (specifically the multi-threading possibility). Thanks. Too bad there isn't a cleaner fix.
I like separation of concerns and it seems there are more assertion frameworks than unit test frameworks. So as a consequence, my test classpath is kind of cluttered with stuff I don't really need. Feels wrong to me. I'd appreciate having separate dependencies. In larger teams there's always the risk of somebody using the wrong thing just because it is there. So, for me it makes sense to separate these things since they don't really depend on each other. You could take kotlintest style bdd tests and use assertk, assertj, hamcrest, default junit 5 assertions, or whatever. That should work just fine. Likewise, I've used kotlintest should* assertions with several test frameworks now and I kind of like it (good work). IMHO both might end up being better frameworks if provided and maintained separately. Certainly both sides feel like there's room for improvement still. For me BDD in Kotlin still feels a bit forced. There are limitations with respect to setting up shared test fixtures in nested tests that you wouldn't have in ruby or javascript. That largely defeats the point for me. I might go back to revisit this again but a few months ago I ended up doing vanilla junit 5 (which you end up having on the classpath anyway) and that seems to work well enough. Also, they are still planning to do their own style of BDD in a future 5.x. However, I'm not that convinced of their particular approach (see their issuetracker) or the apparent infatuation with having ton of stupid annotation verbosity. Having this all this stuff bundled makes it even more awkward to use the assertions with other frameworks because now you are inheriting multiple things that you are not planning to use. E.g. in kotlintest in combination with testng, I somehow ended up with junit 4 and 5 on the classpath as well as assertions libraries coming along with all three of them. Add mojito and mockk to the mix and it becomes even worse. Ugly. If you are wondering, it's a legacy project that I'm slowly nudging towards kotlin. I have a ton of legacy tests that I need to keep happy and I don't have a lot of bandwidth for doing code migrations. The default assertions in junit have always been kind of limited. Thankfully, at least they've given up on repackaging and bastardizing hamcrest now. 
According to the KotlinConf talk [Kotlin Coroutines in Practice by Roman Elizarov](https://www.youtube.com/watch?v=a3agLJQ6vt8) the "parallelFor" should be suspending and a CoroutineScope extension, so the solution would look more like: ``` import kotlinx.coroutines.* fun main(args: Array&lt;String&gt;) = runBlocking { parallelFor(0..99) { index -&gt; println(index) } } suspend inline fun &lt;T&gt; CoroutineScope.parallelFor(range: Iterable&lt;T&gt;, crossinline block: (item: T) -&gt; Unit) { for (item in range) { launch(Dispatchers.Default) { block(item) } } coroutineContext[Job]?.children?.forEach { it.join() } } ```
I had that solution before, but the API for the caller looks terrible. I am happier with my solution above. 
The caller uses `parallelFor(0..99)` and it can be called unblocking (but still suspending, i. e. imperative) also while in your solution `parallelFor` is called blocking always. 
It's more useful in F# as most calls are "static" methods (e.g. `List.map myLambda myList`) instead of Kotlin's more OO-style (`myList.map { }`) So in general, I would say "piping" in Kotlin is just calling methods. This is where Kotlin's extension functions are very useful, because if the function doesn't exist on the right type, you can create it to continue your pipeline. Technically extension functions are static methods under the covers, but they act like normal methods. To use the example from the hackernoon article, in Kotlin it would look like: fun s(x: Int) = (1..x).filter { x -&gt; x % 2 == 0 }.map { x -&gt; x * 2 } You can see how the `.someFn` here replaces the `|&gt; someFn` from the F# version
Is `when` an expression here?
Im pretty sure it's just a statement. That was my first idea but I'll have to check. I'll send broader code when I am back at my computer.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/coding] [Blocking threads, suspending coroutines \[x-post from r\/Kotlin\]](https://www.reddit.com/r/coding/comments/9txc13/blocking_threads_suspending_coroutines_xpost_from/) - [/r/programming] [Blocking threads, suspending coroutines \[x-post from r\/Kotlin\]](https://www.reddit.com/r/programming/comments/9txc4i/blocking_threads_suspending_coroutines_xpost_from/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Thank you !!! it's fixed now :)
Great article, as always
&gt; What would be really awesome with that is some kind of gradle plugin that allows to parse classes at compile time, generate code and start a new compilation round until nothing is generated (similar to Java annotation processing). There's [kapt](https://kotlinlang.org/docs/reference/kapt.html) that does exactly that. I'm working on a project that combines kapt, Kotlinpoet and now kastree. It's a fucking kickass combination and that's why I'm awake at half 1 in the morning.
It'd be nice to support kotlin coroutines and also cross request queues/channels.
My team uses junit and mockk
It would have been nice to relate the article to Kotlin. Perhaps you could have shown how Kotlin helps you deliver cleaner and more maintainable code. If the article isn't related to Kotlin then the general programming subreddit might be a better fit.
Still very new to kotlin, and even newer to it's coroutines implementation, so take anything I say with an extreme grain of salt. I would guess that threads are appropriate when working with Java frameworks that are written with them in mind (and many are). So think backwards compatibility. Coroutines should be used when either higher levels of concurrency are desired or the abstractions are safer or in some other way better. I'm assuming kotlins coroutines are balanced over threads automatically like in go. If they aren't then threads give you true parallelism while coroutines wouldn't. I don't think that's the case though. Now I need to go look that up. If it's the the case that they are balenced over threads, then you should prefer coroutines to threads in all cases where backwards compatibility isn't a thing to worry about. Looking forward to reading more educated takes on the topic that mine.
&gt; I'm assuming kotlins coroutines are balanced over threads automatically like in go. Coroutines by themselves don't have any inherent dispatch strategy. It's up to code outside the Kotlin standard library to actually start or resume a coroutine on a specific thread. [kotlinx.coroutines](https://github.com/Kotlin/kotlinx.coroutines), however, does have specific [dispatch strategies](https://kotlinlang.org/docs/reference/coroutines/coroutine-context-and-dispatchers.html#dispatchers-and-threads). For example, you can have coroutines always resume on a single thread, or have them scheduled to the thread pool, or something even more exotic. I'm not familiar with Go, but I'm assuming that it doesn't allow you to interact with threads directly. If that's true, then Kotlin gives you more control, which is necessary for Java interop reasons. 
That's true but I'm more so asking about how you should architect your code.
&gt; Coroutines by themselves don't have any inherent dispatch strategy. In fact, Kotlin hasn't yet implemented any dispatch strategy. The `Default` and `IO` dispatchers delegate to a Java `ExecutorService`; on Android the `Main` dispatcher delegates to the GUI event loop. There is a plan, however, to implement a thread pool dispatcher specifically tailored to handling a lot of coroutines.
Please, Just to make your answer simpler: A typical client side mobile application that has to display server data on lists through several rest JSON API calls to a remote database (via Retrofit as example). Should use threads or coroutines? No hundreds of calls, but dozens of them that should be 80%-20% asynchronous - concurrent trying not to block user interface. Could you do an approach on this architecture decission? (Threads vs Coroutines) We are about to start writing networking code and have exactly the same hello world function via coroutines and via threads. Really don't know wich is best option.
You probably should not be using Threads directly anyway, unless you're building something at the framework level. Instead use Executor or something similar.
Threads are what co-routines run on. By using co-routines, you are using threads - though you may interact with the Thread API rarely. I would argue the Java 7 threading API lacks the features needed to easily develop a modern Android app. Co-routines are a great help here. I'd definitely use co-routines or RxJava.
Hoping for multi platform support next time :)
That's a hard one, we depend on `kapt` at the moment. Keep on pinging Jetbrains to prioritise multiplatform support for it :D
Multiplatform support for kapt? Perhaps only certain modules that don't require kapt could be supported?
IMO, it basically boils down to your APIs in use. If you can use pure non-blocking APIs across the board, coroutines are easy to integrate with. If you can't, then stick with threads. One notable example where you can't use a non-blocking API: JDBC. So, if you're writing a CRUD app, coroutines are going to basically block the thread, and all your coroutine configuration won't matter, so you'll just confuse yourself. Many "NoSQL" databases however do support non-blocking APIs, so, there, you'll get really great control over processing characteristics. Another rule of thumb: if your code spends it's "waiting time" on IO, coroutines. If it's CPU-bound, probably threads, because the context switching costs of coroutines are significant. But, in 18 years of professional software engineering experience, I've only worked on \_one\_ CPU-bound application. Everything else has been IO bound. Ergo, coroutines are pretty fantastic, most of the time.
All modules use kapt at the moment. We could potentially checkout their codegen instead for *some*, but we aren't there yet and the platform split would look weird, I checked. It's more sensible to get multiplatform support for metaprogramming from Jetbrains.
If I understand your situation correctly, either approach could work for the requirements that you have today. Coroutines and async I/O can better utilize the threads in a thread pool, so you might have lower memory overhead by using coroutines. On the other hand, at least in my experience, threads and blocking I/O are easier to debug (that may change going forward; it might even have improved with the 1.3.0 Kotlin plugin for IntelliJ, which I haven't really spent much time with yet). Kotlin coroutines work on the JVM, in JS, and in native code, whereas working with the thread API will make your code Java-specific. Coroutines are lighter-weight than threads. So if you expect the needs of your application to scale, or you anticipate that you might want to use the same Kotlin code in another context, that might tip the balance towards coroutines.
&gt;One notable example where you can't use a non-blocking API: JDBC. So, if you're writing a CRUD app, coroutines are going to basically block the thread, and all your coroutine configuration won't matter, so you'll just confuse yourself. This part kind of confused me. Could you explain this one more time please?
This is awesome. Date/time is something dearly missed in the standard library. Will be using this soon!
Wow, it's like people haven't learned from java.util.Date at all. Or even looked at how java.time does this *properly*. Really, mixing unix time with datetime again?
Great article! Very well written and adds clearity to coroutine dispatchers.
If you run the Kotlin REPL from the IDE, it automatically adds the classes in your project to the classpath. If you're using the command line, you need to compile the class into a .jar file and then call `kotlinc -cp &lt;jar file name&gt;`.
Without having looked at the api that much, what are your gripes with it?
A property `.unixMillis` and `.hours` on the same object that wraps a unix time.
Non-Android Kotlin adoption is still very low. On Indeed.co.uk/London by job title it's stagnant at around 5 jobs.
Agree. Any time library that doesn't distinguish between a local date(time) and a zoned/offset date(time) is wasted potential. I would encourage the author to take a good look at java.time and copy as much as possible because that's the most sane time library I've used to date.
&gt; Any time library that doesn't distinguish between a local date(time) and a zoned/offset date(time) is wasted potential. Read the first lines of documentation... Klock clearly defines and manages offset times.
A datetime in UTC is not the same as a local date time. But point taken. Also, it would be nice to have separate entities for local time without a date.
Offset "times". Except they're actually instants.
Or just use java.time. Works perfectly already with kotlin
Doesn't work at all when the majority of your targets are not a JVM.
Agree. People inventing their own stuff instead of porting `java.time` are doing it wrong.
¬Ø\\\_(„ÉÑ)_/¬Ø Just port it? Better to write code for a feature where you have thousands of existing tests than to reinvent the wheel.
Sorry, I'm brand new to kotlin so I'm still trying to learn all the terminology. I used `kotlinc filename.kt`, and I see the class file that I want to use. However, when I go into REPL, and import the class file "Article.class" by typing `import Article`, it says "unresolved reference".
*Beep boop* I am a bot that sniffs out spammers, and this smells like spam. At least 50.0% out of the 2 submissions from /u/shaytavor appear to be for courses, coupons, and things like affiliate marketing links. Don't let spam take over Reddit! Throw it out! *Bee bop*
Kotlin koans is perfect for experienced developers who want to learn Kotlin
That's right :)
You should never connect directly to a sql database from an app. If you need local storage, use sqlite. If you need something server side, check out Firebase
If local use SQLite, ( Room makes it convenient). For online/ offline there is Firebase ofc. It is free to some point and you should have more than enough in that free package. Here is some Room example i did in the past (it is very simple) : [https://github.com/kolboch/RoomDemo/blob/master/app/src/main/java/com/kakaboc/roomdemo/database/model/Training.kt](https://github.com/kolboch/RoomDemo/blob/master/app/src/main/java/com/kakaboc/roomdemo/database/model/Training.kt) For firebase I cannot provide you with full project but you can checkout this one: [https://gist.github.com/kolboch/f79b3bebbbf1eba0778d1d326bee1cb9](https://gist.github.com/kolboch/f79b3bebbbf1eba0778d1d326bee1cb9) It is basically how it is likely to look in your code. Ofcourse it is not everything, you have to get connection first but it is very easy googleable ;) Sry I cannot give you full code as it is commercial app.
For data being locally stored on the users device, use android's official library 'Room' For online, use Firebase/Firestore. Im currently building an app, using a mix of offline and online data. I'm using Room and Firestore. 
Not to mention there are security concerns. You don't have users and permissions the same way you do in a real backend service (without a lot of extra work, at least), and for the most part, if a connection has read/write access to a table, it's to the ENTIRE table. So, if you need read access to access information about your user, you have that access to the entire Users table. And even if you program your application correctly, a malicious actor could extract the database credentials out of your application and use those to connect to your database directly. You should never have a SQL database accept connections over the internet.
I have the similar pull request for the Kotlin web site. It is merged! Thank you for noticing that! [https://github.com/JetBrains/kotlin-web-site/pull/1193](https://github.com/JetBrains/kotlin-web-site/pull/1193)
Thank you: Will definitly have a look at the code!
Thanks for your answer; will definitely notice this
Well, you always can use exceptions if you want, its totally supported. However, I would however recommend creating a sealed class that can contain your successful result or an object representing your error. When you want to get the data or handle your error use a when. Take a look at this talk for a quick overview : https://www.youtube.com/watch?v=uGMm3StjqLI
A sealed class (or its equivalent) is a workaround that has to be used in languages that have no proper nullability support, such as Java and Scala. In Kotlin it's perfectly fine to return nulls, and Kotlin's syntax for handling nulls is much more concise than `when` statements that can be used to extract data from sealed classes.
 If you only want success or failure, I would agree a null is the way to go, but its also harder to return information on why a process failed. Lets say you are calling an endpoint that creates a User. You may want to handle errors differently if you get a 400 from using a duplicate name than you would from a 500 for some database being down. If its a 4xx code you would want to return that to the user, but if its a 5xx you would log that and tell the user something is wrong.
Well, I heard someone saying that in a talk, something like "you shouldn't throw exceptions in kotlin because the language gives you stuff to not have to throw them" or something.
Someone saying something in a talk is not really an argument, sorry :)
Comment for later
I was just saying that what I heard didn't come from me. I was just asking. May I ask what the problem is here ? I am not bothering anyone AFAIK
I also thought that intersection and union types were neat when I looked at Ceylon a year or two ago, but this [has been discussed before](https://discuss.kotlinlang.org/t/union-and-intersection-types-feature-request/4191/5) and I imagine at this point it's probably unlikely that it will ever be added at the language level. I took a peek on github and found [a library for union types (KUnion)](https://github.com/renatoathaydes/kunion), and intersection types could be done through something like [this](https://discuss.kotlinlang.org/t/union-and-intersection-types-feature-request/4191/7) or alternatively just implementing something like KUnion, but for intersection types instead.
You know you can save posts/comments, right?
I don't see any good reason not to start with Kotlin 
You'll be ok. Don't worry about java unless you want to know java.
It's the [either](https://arrow-kt.io/docs/datatypes/either/) type of [arrow](https://arrow-kt.io/).
&gt; May I ask what the problem is here ? What do you mean? You asked a question and I just answered. No ill intent here. 
The "Kotlin Apprentice" book is targeted at people with no programming experience: https://store.raywenderlich.com/products/kotlin-apprentice
Yes, if you need to pass that additional information, then it's often a good idea to wrap it into a sealed class. But I would never use something like `Optional`, which doesn't carry any information beyond the presence of the object.
There‚Äôs a bookmark icon on the top, that saves the post 
Have you added a dependency on the core coroutines module? 
I updated my question to show this
This course doesn't assume you know Java: https://www.udemy.com/android-oreo-kotlin-app-masterclass/ 
Those guides are most likely for pre-1.3.0 coroutines, where that was allowed. The coroutines available in 1.3.0 make a push towards [structured concurrency](https://kotlinlang.org/docs/reference/coroutines/basics.html#structured-concurrency), where every coroutine has a scope and when that scope ends it can be cancelled. To launch a coroutine like you would pre-1.3.0, use [`GlobalScope.launch {}`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html) instead.
Thanks for this
Great explanation, thank you
Agreed. 
Not going to happen, as there would be no Java interop. There are plenty of libraries that provide wrapper types, however, and sealed classes plus overloads and `when` gets you 90% of what flow typing gives you with optional polymorphism.
Genuinely curious, what are some situations you've encountered where union types have been really helpful? I always have trouble appreciating them, since it looks like they work against the concept of separation of concerns. When would it be good for a function to return more than 1 possible type?
Result or error of the computation
hi , thanks for the reply , what do you think about our program in the university , after kotlin we will study java , after that c . it is like we are studying everything the opposite way , at least i think that way 
That actually sounds like a good plan and how I would have structured a new course these days. From easiest to hardest language. Funnily enough my learning experience over the years was the reverse of this lol and i kinda regret it with hindsight (mind you kotlin didnt exist then and Java was exponentially worse in early 00s) With Kotlin you can get a grip of basics of OO and Functional programming and good understanding of typing (which is very important on any project with more than one person) By moving onto Java you would gain a deeper understanding of why Kotlin is nice, but also give you the knowhow to work in your average industry, unfortunately many companies have not heard of Kotlin yet, but this is changing, people like me are driving this change which sorta started with Scala. And then going onto C you would gain a low level understanding of fun things such as pointers and will truly come to appreciate higher level languages. But well worth knowing.
Understanding the jvm and java helps understanding why certain things work the way they work in Kotlin; especially when you are using java libraries or advanced topics like generics and reflection. However, if you target browsers or Kotlin native, that is less relevant. And if you are just getting started maybe you should skip those kinds of topics for now and focus on the essentials. So, I would just go for it and start coding and learning. Do something fun with kotlin native like writing a small command line tool. Try to get something going with kotlin react. Alternatively, maybe try building an Android app using kotlin. Much of the documentation for that is increasingly kotlin centric. I find that learning new things works best for me when I set concrete, achievable goals: learn by doing. &amp;#x200B;
What would be the advantages compared to sealed classes?
I don‚Äôt believe there are any. I‚Äôve just made an example 
You cannot just throw exceptions in asynchronous world, see kotlin.Result and kotlin.coroutines.Continuation#resumeWith for example
For example if you have a json parser. All nodes can be of type JsonObject|Array|Bool|String|Number|Null Or if you would like to have a List that contains two types of objects e.g. List&lt;BigIntegers|BigDecimal&gt; 
Also: [https://eu.udacity.com/course/kotlin-bootcamp-for-programmers--ud9011](https://eu.udacity.com/course/kotlin-bootcamp-for-programmers--ud9011)
Sealed classes.
Good stuff with good examples. After using Kotlin extensively for a while now, I'm still finding another nice feature/function/etc here and there.
Thank you so much, I could not figure out what IntelliJ was trying to tell me.
I would recommend you to learn enough java just to be able to read Java and write Kotlin. Since you're a begginer, there are tons of good stuff for begginers using Java. Once you're confortable with it, the jump to Kotlin should very smooth
I wrote a compiler in C, so I can see how it would be helpful there, you're right. So union types are helpful in that you can transport data within a single container, and only evaluate it at the end when you need to process it? Even in your second example, I feel I would only encounter that situation when reading a file of numbers for example. So union types are great for when you're facing unknown values, like parsing raw strings. I see!
Of course that's the solution, but I was asking about union types' value on their own, not in the context of Kotlin. Why you would need a union type in a language. And they brought up a useful example, parsing arbitrary data.
Donated, thanks for the heads up.
Looks like https://youtrack.jetbrains.com/issue/KT-27994
Thank you!
Just donated to this cause. I hope the procedure is successful.
Thank you! That's exactly it. 
There is a big risk involved here. So, yes we also here hope that it will be at least not worse.
Supporting fellow engineer. Hope he'll reach the amount needed soon. 
Are you doing the course? I'm following this course, but sometimes i get quite confused and felt so defeated. 
I hope it all works out, here‚Äôs hoping. 
I'm in the middle of the course now... Doing it off and on. While it doesn't require Java knowledge, I could see how it could be challenging if you are totally new to coding. I know a few languages well but for some reason I have always hated Java....too much busywork and boilerplate code. I figured Kotlin was my chance to make Android app and not be miserable. There may be more beginner materials for Python if you are getting frustrated with Kotlin. 
Thanks!
Thanks!
Thanks!
No problem man, my cousin has a rare genetic brain disorder and I know how hard this stuff hits on the family. Thank you for taking the time and effort to work on an awesome project when you already have a lot on your plate. Take care, hope the procedure goes well.
Donated, too. I hope the best for Masha and all of you.
I post that blog post, feedback is welcome!
hey carjacker, I am the author of Atrium and I am sorry to hear that my deprecation messed things up for you. Notice that the deprecated stuff stays in Atrium until 1.0.0 and you can move to non-deprecated functionality in a quite easy way (search and replace). Have you seen the following migration path https://github.com/robstoll/atrium/releases/tag/v0.7.0#migration
You would be surprised, but the exception gets thrown in the current thread because some other thread caught it and resumed the coroutine with Result.failure() instance. 
I'm a little confused. The home page makes me think this is Kubernetes written in Kotlin. A glance over the guide makes me think it's a version of RPC that uses JSON. It's neat and all, but the explanations aren't really there (unless I'm missing something). Likewise, is it just a JSON marshaller/unmarshaller? I'm not really sure.
Kotlin always aimed to be a general purpose language, just like java is. I think it was created because java lacks Things that a general purpose language can have, to be more suitable for non-backend development, which is java's first resort. This makes kotlin a broader general purpose language, for example suddenly it can be used for scripting because it is less verbose and more convenient. And it is statically typed but thanks to powerful inference and its Syntax, it becomes interesting for Javascript people as well, so why not compile the language for another runtime. And then again, If the language is that good, why not make it possible to use it on all Platforms for general purpose usage? So that it becomes your full stack language. That's where we are now, If you ask me. Kotlin is becoming its own Definition of a general purpose language :)
I think Kotlin wants to be **the** pragmatic language. It solves my **actual** problems. It is not like Scala which has features which just complicates the language. It is also not like Java because they *do* put in features which might not be perfect but they solve 90% of the use cases. Data classes for example are not present in Java because they said that there is no consensus about how they should be implemented. Jetbrains just put them in the language which is good for most people. So I think that it is targeted (and succeeds) as a **pragmatic** language which you use to solve **actual problems** in a robust and efficient way.
For the question, if its better than Java or Swift: After doing Kotlin for a while, it feels like Kotlin is a more mature version of Swift.
I've viewed it as a modern interpretation of Java. Java is a great language but it is almost 25 years old. It has been retrofitting a lot of new techniques into the language but maintaining a project that old presents challenges when adding these new techniques/tools. Kotlin does away with a lot of boilerplate and has a lot of the same modern functionality (lambdas, map-filter-reduce) natively out of the box. It'll be interesting to watch it evolve as new techniques are developed. 
JetBrains was looking for a successor to Java, to solve some practical problems they themselves were experiencing with their platform. Scala has some nice features but has very bad tooling and compile times. Also I think the overall opportunity was there since as a tool vendor they could provide a great end to end experience and ensure very practical needs were met, when compared to other modern JVM languages The other platforms are similarly inspired: Why have to deal with maintaining the same business logic on multiple platforms. But nicely, it was just about the logic not the runtime. So when you target the JVM, or JavaScript or iOS or Android you‚Äôre not working through some abstract application runtime VM; your code compiles for but obeys that platforms‚Äô idiosyncrasies. But you can share generic rules for everything. Much easier to deal with a web API, web site and phone apps IMO then most other ‚Äúwrite one run everywhere‚Äù approaches.
For the future I think the focus is on making concurrency ‚Äújust work‚Äù everywhere, and then making that fast. Parallelization is very hard and bigger patterns and libraries will probably come to fruition. Not sure what other major language extensions will occur since a lot of this might simply be library based
For the last part: I'd say that they want to avoid Ruby's fate more than eventually getting off the JVM. Ruby's a great language, in my opinion - I prefer it to Python any day - but it got so tied to Rails that when that framework lost popularity, the language took a hit in popularity that it's never recovered from. Likewise, Kotlin has found great success in the Android community, but that's not a guarantee for all time, especially if Android bumps its Java standard to 8 higher or if Dart takes off. So, Jetbrains is trying to diversify the language with the JavaScript transpiling and the KotlinNative project so they'll get a wider - and more secure" community acceptance as a result.
Thanks for the information. I will try the upgrade following this doc.
Does your MySQL database use innodb ?
Improving their own productivity and driving sales of Intellij. https://blog.jetbrains.com/kotlin/2011/08/why-jetbrains-needs-kotlin/
That makes sense. I really like the developments on the server side frameworks as well. Spring and vert.x supports Kotlin natively and I can even use it in Gradle. `.kts` has great potential! You could sit down and write a better [Airflow](https://airflow.apache.org/) with it in days!
Yes it does. Tested with some other engines, but same result.
These are more commonly called sum types, which may open some more avenues to use cases. One great example is building a REPL or compiler. Sum types are converse to product types.
It's just Russia's attempt at taking over software development.
&gt;especially if Android bumps its Java standard to 8 higher Android 7 I believe bumped it up to Java 8 so it'll be about 5 years or so before it's the standard
The one thing I hate most about swift is how it doesn't let you accidentally use the Optional operator (?) on a non-Optional object. It'll fail to build. Meanwhile on kotlin, it'll compile fine, just gives a warning saying the Optional operator is unnecessary.
Is it really driving sales if the community edition is free, or if you wanted to just do Android dev, Android Studio is free as well?
Some people will pay to upgrade to ultimate, but I think it's also about getting market share. Intellij's great support for kotlin is definitely helping getting new customers from eclipse.
&gt; or if Dart takes off I was under the impression that Dart was as good as dead. Is that not the case any more?
I think Flutter uses it and Flutter may end up being big. It's certainly generating a lot of interest right now as competition for React Native.
I don‚Äôt know, I use it for everything.
I think both approaches (warning and error) are fine and rather insignificant ¬Ø\\\_(„ÉÑ)\_/¬Ø
You can only debug Kotlin/Native code on CLion, which you have to buy.
It is a general purpose programming language, which it for whatever purpose you desire.
Don‚Äôt know about a wrapper but the Cassandra driver are pretty awesome out of the box. 
Yo dawg
I think Jetbrains as tool manufacturer wants to be able to provide us with great tools (and an incentive to buy them) - regardless of the platform. And Kotlin is such a tool: I can develop iOs Apps, Android Apps, Desktop Apps, Web Apps with almost (exaggerated) identical code. Plus the back end can be developed in this language as well - One language, one IDE, many deliverables. Write once - run everywhere ? (-; Ok I guess the same would be possible with a language such as C++ but I personally think kotlin is easier then C++
Ping me here or on slack if you encounter problems or need help
Catlin?
I agree!
Coming from swift, elvis works exactly how I'd expect...
&gt; println(null != null ?: false) Even if that had been interpreted as println((null != null) ?: false) It still doesn't make sense. Why would != return null? If doesn't. It returns true or false. TLDR: nullable booleans are confusing. 
Doesn't look like a bug to me. The right side of the expression is null and so the elvis changes it to false. The statement is then null != false... Which is true. Works exactly as I'd expect! 
Vyne's query engine isn't, though I may choose to open source it later. However, some pretty beefy parts of the Vyne ecosystem are -- specifically, [taxi] (https://taxilang.org) which is the language that Vyne uses to model all the services. This includes a bunch of generators and compilers, and includes the annotation processor for capturing typealias data at compile time. 
Hey guys, this meetup will be very different from all other talks on DSLs that I've come across. &amp;#x200B; We have a nice surprise in addition to showing how to create DSLs to be used as type-safe builders. We'll show how DSLs can be used to enforce correct usage of patterns (so they won't be used to construct anything).
&gt; orks exactly as I'd expect! I said false without even looking at it... they said `aha` and I said... well not, aha, it's true because null != false is true.
Yep, and I'm not saying it is a bug. It tricks the mind of newcomers to the language (coming from c, javascript or pure java) that might think of the elvis as a `cond ? value_if_true : value_if_false` expression
There is no single main purpose. Being a better Java? Yes, definitely. Being a better Swift? For iOS, our main focus is on supporting multiplatform development; it's unlikely that Kotlin can be a viable replacement for Swift for pure iOS projects. Server-side? Yes, definitely (check out Ktor). Client-side? Yes, sure. Desktop? Yes, of course (IntelliJ IDEA is a desktop app and it uses Kotlin quite a bit). Web? Yes, both as a JavaScript target and as WebAssembly.
Quoting a blog post from 2011 may not be the best way to answer a question about Kotlin's main purpose in 2018.
Here's the actual meetup: https://www.meetup.com/Kotlin-Waterloo-P2P/events/256039478/ It's in Ontario.
Just use the official Datastax Java one? Works fine with Kotlin AFAIK.
Why would Android upping the Java standard hurt Kotlin?
But how to use data classes for protobuf?
Less reasons for some people to switch, I guess.
Except C++ is dog shit ugly, and there are more ways where you can shoot yourself in the foot.
I mean: if you can generate a builder on top of generated Java code, why not generate data classes directly?
Is there any way how Intellij will benefit from Kotlin Native in the future? As in performance, I mean. I know that Java is plenty fast, but still. 
I agree, I think builders is the wrong approach
It's just order of operation, seen herehttps://kotlinlang.org/docs/reference/grammar.html Elvis operator has higher precedence than inequality check. 
I authored a library to do generate protons builders and recently added support for kotlin a dsl markers. You can give it a look to meet your needs in the mean time. https://github.com/marcoferrer/kroto-plus If they need contributors I can see about porting over the code gen portion. 
Flutter is basically Dart + Skia. Are you suggesting that Google will rewrite Flutter in something else then? 
Because Kotlin provides a way to use a lot of features - lambda-like structures, for one - that are not present in the Java 6 standard that you have to use for writing Android. If the Java standard gets increased and those features are added, that reason goes away.
ah, thanks to the reference to structured concurrency. I'd missed that memo and it was confusing me.
Have you looked at Kotlin's sequence? https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/index.html
RxJava does this, even if it's a bit heavyweight. We may have something in Arrow with Sequence, I need to ask ü§î
Looks promising in 1.3 - unfortunately, I'm still using 1.2 and IntelliJ is not liking some of this syntax. Trying to figure out a way to still accomplish this in 1.2. Ultimately what I'm trying to do is paginate through API calls without having to store any state in a mutable variable (I can always revert to mutability if I have to, but I just don't like it, consider it a kind of code smell).
 generateSequence(3) { it - 1 }.takeWhile { it &gt; 0 }
Really appreciate your work. Unfortunately, I only able read text articles on programming as watching video takes way too much time without any addition of information.
There are no immediate plans. The only benefit that Kotlin/Native might bring is the possibility to use more compact data structures, without Java's object header overhead, and there are not that many places in IntelliJ which could benefit from such data structures. In terms of raw code execution speed, you can't get much faster than Java bytecode JIT-compiled with Hotspot.
I'm not saying this isn't true, but it's far from a complete picture. The multiplatform vision, which is Kotlin's main priority at this time, didn't exist at all in 2011.
In video, you are "locked" at the pace at which video author talks about topics. You can consume text at your own pace and navigate back and forth very quickly. Finding exact needed moment on video timeline is untrivial. Also it's much easier to work with the code in text form. Video really can't add anything of value to most programming topics, it's not guitar learning lessons where you need to watch some kind of hand movements, etc. Number of things which are explained has nothing to do with the medium (text/video). One can write a very boring, hollow and long article or an article which is very short, focused and on point. 
Because Android is stuck with Java 8, actually 7 if you want to target all devices, while in the rest of the world the latest version is Java 11, which already including a few goodies and more are on the roadmap for upcoming versions. So if Android had support for modern Java with type inference, library factory methods, streams, reactive APIs, switch expressions, value types, easier FFI with native code, co-routines, SIMD, ...., there wouldn't be a such high need for Kotlin. [0] As it is, Kotlin is the escape route for those that don't want to be stuck writing Java 7 code. [0] - Some of those features aren't yet fully implemented.
Try this: ``` fun infiniteNumberSequence(number: Int): Sequence&lt;Int&gt; = generateSequence(number) { it + 1 } fun main() = infiniteNumberSequence(1).take(20).forEach(::println) ``` 
Oh, wow. I always forget how old Java 7 really is. Time flies. Thanks for the explanation!
Quick question. Why the nodejs backend? Doesn't firebase already have Android and iOS plugins that you can plugin directly to the apps?
Man I just saw Elvis in Vegas handing out copies of the Book of Mormon to tourists.
Had a quick look, definitely shows potential. I' m wondering: It' s pretty conceivable that you might have pretty identical (named) attributes within one landscape (e.g. Balance, or Streetname, etc.). How would Vyne know which service to use? What are you looking for in a partner? What skillsets would be complimentary to yours? What goal are you hoping to fulfill with a partner? 
If I were considering starting a project like this, I would make it a simple library of extensions to the Datastax driver. I would probably start by wrapping all the callback based APIs to use a simple API of suspending functions. After using that for a while, try to identify any remaining pain points.
but the proper way to name a kotlin project is to replace a letter with a k, right ?
you would be happy to hear that I'm working on a JSON library named.... kson 
awesome &amp;#x200B;
&gt; Flexible, so that you can run it in any browser &gt; Can be a great choice for hybrid app development &gt; Java is an open-source programming language. So is Kotlin. &gt; If we compare it to Kotlin, Java app is lighter but Kotlin includes complex computing process in its code, which can turn out the code to work slowly on user‚Äôs device with low technical specs. What. &gt; If we talk about the development speed, Java ensures faster build process than Kotlin. Are talking about development speed or build speed? &gt; Due to limitations in Java, it causes problems with Android API design. What. &gt; As a wordy language, Java requires more code to write which carries a high risk of errors &amp; bugs. Yeah, very wordy. int number = 10; &gt; It is slower because requires a lot of memory. What. &gt; Kotlin is a general-purpose language, incorporates functional features **to support interoperability &amp; intelligibility.** What. &gt; Has null in its type system ‚Äî null ability problems are a common pain point in Java, and since Android often uses null to represent the absence of a value, Kotlin solves it by placing null directly in its type system; Who even writes this shit? I can't even. 
Oh wow, it reads just like a highschool freshman's history day research project or something.
I think I've gotten pretty close with this one. Doesn't seem to be executing my runnable function that derives the while Boolean though (I set a breakpoint inside those curly brackets and it never gets there). Any thoughts? ``` generateSequence(0) { it + 1 }.takeWhile { run { val documents = documentController.search(offset = it * 5, limit = 5) if(documents.isNotEmpty()) { processData(documents) } documents.isNotEmpty() } } ```
Is kotlin developed by jetbrains ? 
Perhaps a bit of a long answer but this talk by Christina Lee at Droidcon London this year was really useful for anyone interested in Coroutines: http://uk.droidcon.com/skillscasts/12727-coroutines-by-example
I don't think I've ever seen a shittier set of interview questions in my life. How to declare a kotlin variable, seriously? How do these questions verify an understanding of Kotlin or competency in anything?
`takeWhile` isn't a terminal operator, also `run` problem doesn't do what you think either, it serves no use in your code. &amp;#x200B; You'd need something like this generateSequence(0) { it + 5 } .map { documentController.search(it, 5) } .takeWhile { it.isNotEmpty() } .forEach { processData(it) } &amp;#x200B; do note that sequences are not async nor multi-threaded only lazy, making this async with coroutines would be tricky as well since you're expecting the result of an async operation to continue your sequence. You'd be better off using [channels](https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/channels.md#channels-experimental) &amp;#x200B; you'd end up with a structure like this val channel = Channel&lt;Document&gt;() GlobalScope.launch { generateSequence(0) { it + 5 } .map { documentController.search(it, 5) } .takeWhile { it.isNotEmpty() } .flatten() .forEach { channel.send(it) } channel.close() } GlobalScope.launch { channel.consumeEach { processData(it) } } now both your producer and consumer work separately from each other 
In the shortest answer I can give... You can use a coroutine scope to launch child coroutines. (Just use launch instead of GlobalScope.launch) If a child coroutine fails, it'll also cancel all the others to free up resources. If they're all independant and you don't care about failures, launch them all from GlobalScope 
Hey, thomhurst, just a quick heads-up: **independant** is actually spelled **independent**. You can remember it by **ends with -ent**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
hEy, ThOmHuRsT, jUsT A QuIcK HeAdS-Up: **InDePeNdAnT** Is aCtUaLlY SpElLeD **InDePeNdEnT**. yOu cAn rEmEmBeR It bY **EnDs wItH -eNt**. HaVe a nIcE DaY! ^^^^ThE ^^^^PaReNt ^^^^cOmMeNtEr ^^^^cAn ^^^^rEpLy ^^^^wItH ^^^^'dElEtE' ^^^^tO ^^^^DeLeTe ^^^^tHiS ^^^^CoMmEnT.
What if you didn't? We live in an age of spellcheck, so there's realy no poin in correctong people. How bout you mind your own buisness? ^^bleep, ^^bloop. ^^I'm ^^a ^^bot.
Hey CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Hey BooCMB, just a quick heads up: The spelling hints really aren't as shitty as you think, the 'one lot' actually helped me learn and remember as a non-native english speaker. They're not *completely* useless. Most of them are. Still, don't bully somebody for trying to help. Also, remember that these spambots will continue until yours stops. Do the right thing, for the community. Yes I'm holding Reddit for hostage here. Oh, and /u/AntiAntiSwear, no u Now we have a chain of at least 4 bots if you don't include AutoMod removing the last one in every sub! It continues! Also also also also also Have a nice day!
 Oh shut up, you little talking doll. ^^^^I'm ^^^^a ^^^^bot. ^^^^Feedback? ^^^^[hmu](https://www.reddit.com/user/stopalreadybot/comments/9w7cy9/feedback/) ^^^^Dear ^^^^mods, ^^^^just ^^^^ban ^^^^CommonMisspellingBot ^^^^and ^^^^the ^^^^other ^^^^bots ^^^^will ^^^^automatically ^^^^stop. 
 Hey CommonMisspellingBot, just a quick heads-up: **independant** was the name of a very disorganized witchdoctor who lived in Aunt Bertha's house. Luckily,, **independant** developed a fetish for very old Indian men. When this was discovered by the law, it led to a beautiful, romantic wedding . **independant**'s tombstone said: **Stfu CommonMisspellingBot, no one cares what you have to say.** ^^^^I'm ^^^^a ^^^^bot. ^^^^Feedback? ^^^^[hmu](https://www.reddit.com/user/stopalreadybot/comments/9w7cy9/feedback/) ^^^^Dear ^^^^mods, ^^^^just ^^^^ban ^^^^CommonMisspellingBot ^^^^and ^^^^the ^^^^other ^^^^bots ^^^^will ^^^^automatically ^^^^stop. 
dOn't eVeN ThInK AbOuT It.
If you have classes with a specific lifecycle (like Android activities or spring framework beans) you can have the class implement the CoroutineScope interface, define your own job, then create and cancel the job with appropriate lifecycle hooks, i.e.: ``` kotlin class MyActivity : CoroutineScope { lateinit val childCoroutinesJob: Job override val coroutineContext get() = Dispatchers.Default + childCoroutinesJob fun onCreate() { childCoroutinesJob = Job() } fun onDestroy() { childCoroutinesJob.cancel() } fun doSomething() { launch { println("This will execute in the context defined above and will be cancelled with onDestroy") } } } ``` For the function you defined above though I would recommend passing a CoroutineContext as a third parameter, then you can just do this: ``` kotlin fun updateMany(..., parentContext: CoroutineContext) { ... launch(parentContext) { // Do long running work here, if the parent gets cancelled this will too } return ids } ``` By passing the context, you can launch a coroutine that outlives the function but can still be cancelled in the context where it is invoked
For the most part yes, but you can also contribute, see [https://github.com/JetBrains/kotlin#contributing](https://github.com/JetBrains/kotlin#contributing)
It works the same as Java when you run it on the JVM 
Thank you! If is a mindf why java do this!!! T\_T 
Appears to require credentials that I don't have :( 
Because when you pass a BIG parameter with a lot of information, do a copy is totally inadvisable. I think you would have the choice to decide how you want to pass parameters
But the ‚Äúcopy‚Äù is a copy of a reference, so I don‚Äôt understand what you‚Äôre trying to say. val o = MyObject() // o is actually a reference to the heap address doAThing(o) // passes a COPY of the REFERENCE to the fun This is why you can modify `val` objects as long as you don‚Äôt reassign them.
Hey Mods, can we ban all of the bots that are children to this comment?
You actually do have the choice on how to pass parameters. If you mark your function as `inline` by writing `inline fun whatevermethod() {}`, your method will actually pass-by-reference instead of pass-by-value. But this is completely stupid to do because Java's/Kotlin's pass-by-value is actually really, really fast. What Kotlin/Java actually does is if your variable is of type: `Int, Long ,Double, Float, Short, Char, Boolean, Byte` it will copy it when you run your function. If your variables is of ANY other type, Java/Kotlin will actually just copy the location of the variable in memory, instead of the variable itself. This means that if you run a function and give it a String that is 1000000 characters long or something, it will still be very fast since Java/Kotlin will not copy the giant string, but will instead copy just copy the location of the String in memory, which is very fast.
That's not true, inline functions are pass-by-value(-of-reference) too.
Kotlin is a little cleaner to me, because there's no "autoboxing" to confuse things. Everything, to the programmer, is an object. But... it has concepts of "val", and all parameters are vals: // Doesn't compile: num is a val, not var, can't be mutated fun addTwo(num: Int) { num += 2 } So, any "mutation" of a parameter can only come from a mutable method on that object, you can't reassign them. All native types have no methods to mutate state. (Protip: mutation is tricky - if you avoid it, your life will be better.) Unlike C++ or Java, it's a lot more consistent - everything is an object, the object reference is passed, it's a val, and can't be reassigned.
A 'copy' means that in memory you must do a copy of the object reference bits. So actually you're duplicating the object.
It passes the reference by value ;).
That's not how passing copies of references works at all. Re-read what jbristow wrote. &amp;#x200B; The only thing being copied (the reference address) is effectively the same size as a native pointer but that isn't guaranteed (ie, on the order of 32 or 64bits) &amp;#x200B; The object itself is on the heap in a single place.
The generated bytecode doesn't matter, what matters is if the bytecode behaves [as if](https://en.wikipedia.org/wiki/As-if_rule) it's pass-by-value-of-reference. If you say it's pass-by-reference, I have a challenge for you: do whatever you want in the body of `foo` to make the program print `"b"`: ``` fun main() { var str = "a" foo(str) println(str) } inline fun foo(str: String) { //do whatever you want here } ```
**As-if rule** The standard for the C++ programming language allows compilers for this language to apply any optimizing transformation to a program during compilation, provided that such optimizations make no change in the "observable behavior" of the program, as specified in the standard; this mostly means that any actions the program performs on its environment occur in the specified order. This rule is commonly referred to as the as-if rule. The rule has three main exceptions. The first is that programs exhibiting undefined behavior are exempt; since the observable behavior is not well-defined anyway, any transformation is valid. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Kotlin/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
So I assume you're using Spring MVC? I recognize those annotations :) If that's the case, you just have to tie all the coroutines you're using to the lifecycle of your @RestController class. In that case, it would look like this: @RestController class MyCoolRestController @Autowired constructor(/* Add autowired dependencies here */) : CoroutineScope { override val coroutineContext = Dispatchers.IO + workerJobs private val workerJobs = Job() // This is the parent job for all coroutines launched in the controller @PreDestroy fun killChildJobs() = workerJobs.cancel() @GetMapping("/") fun sayHiAndLaunchJob(): String { launch { // This launches in the coroutine context defined above, with the IO dispatcher and as a child of workerJobs doWork() } return "Hi there!" } } By implementing the CoroutineScope interface, any `launch{}`, `async{}`, etc. coroutine launchers get launched within the `coroutineContext` you define, and since you place your own `Job` instance onto that context any coroutines you launch will be children of that job. The `@PreDestroy` annotation there will be invoked if Spring decides to destroy your bean, which will also cancel all pending coroutines you launched inside the controller. 
That's actually a very good point. I'll reword my comment but it's intention was originally to provide a workaround from copying due to OP's fear against it in pass-by-value languages.
delete
I‚Äôm working on a Firebase sdk wrapper which presents an API as close to the Firebase Java sdk as possible but calls into the relevant Firebase sdk for the underlying platform https://github.com/multiplatform-io/firebase
AQL docs here: https://arrow-kt.io/docs/aql/intro/ We'll expand them to Observable, Deferred, and Flux in the future! Also worth noting in this release, `arrow-effects-kotlinx-coroutines` has been updated to support `CoroutineScope`. And now you can use `binding` at global scope instead of needing `Something.monad().binding`. That also means that you won't need to `fix()` it at the end either! It's now simpler and easier to use.
&gt; Regarding Option: What are the benefits of using the Option data type in Kotlin that already has null safety support via ? and ?: ? Operators to combine and transform them. `?` only allows one possible operation and you have to write your helpers for it, i.e. transform only on null, transform both cases, etc. If you prefer the direct style of having those patterns repeated through your codebase that's also a legitimate usage. The second reason is abstraction. You can write generic and polymorphic code that works on Option as a type, but cannot with nullable types. That's a bit more high level if you're starting, so it's mostly the first reason for you. &gt; Regarding Try: With Kotlin 1.3, the new Result&lt;T&gt; type has been added which closely resembles the use case/purpose of a Try. Same question, when would one use Try&lt;T&gt; vs Result&lt;T&gt; ? We asked for `Result` to be a fully fledged replacement for Try so we could remove it from Arrow, and didn't get it. Last I know the compiler disallows using `Result&lt;T&gt;` as a function return. If that's not the case anymore, go for it.
I asked myself the same question, regarding the optional and kotlin's nullable. Could you give a more detailed example of an abstraction where nullables aren't suitable and the optional wrapper works better? Would be very interested :)
You can try creating a (de)serializer that doesn't require mangling your data classes and can automatically call the constructor with the correct arguments. Requires named parameter compilation I think.
Im not entirely sure what you mean by "mangling your data classes", im not yet perfectly familiar with Kotlin data classes. Could you please explain what you mean ?
Here! https://arrow-kt.io/docs/patterns/polymorphic_programs/
Methods for data class are generated not by IDE but rather by compiler.
tl;dr Kotlin's data classes use the equals method to determine if two objects are equal. Java arrays don't implement equals. This was definitely not worth reading and a widely known fact. Also if you didn't know and you encounter it in the wild you would probably realize something's wrong and now you know. 
This post contains several mistakes, for example 0..5 includes the 5 in Kotlin while the posted Java code doesn't include the 5. It also shows why Java is a lot clearer in many cases, in `for (int i = 0; i &lt; 5; i++)` it's a lot clearer that 5 is exclusive than when iterating in Kotlin over `0..5` (or `0 until 5`).
&gt; it can read any JSON and make it into a Kotlin map How did you represent a json array as a map? 
Arrays are represented as lists for now, and objects as maps. I understand why that was confusing though, my english isn't exactly perfect.
Most IDEs will generated common methods when you create certain classes.
That title looked awfully fishy. Thank you for saving a click.
With pleasure. I haven't read a decent medium post in ages so whenever curiosity gets the best of me I try to at least be helpful to others 
From my experience with Kotlin, I would pick Groovy any day for non-android applications.
Am I wasting my time doing kotlin server side development?
I don't think so. Kotlin has huge potential. Adoption of a new language takes a while. Industry is slow in adopting new technology.
Intellij starts yelling at me the moment there's an array in any of my data classes and suggests it generates its own hashcode/equals instead of the auto generation. That's fine by me I guess, but I'm confused as to why the compiler itself can't generate the same hashcode/equals.
Intellij starts yelling at me the moment there's an array in any of my data classes and suggests it generates its own hashcode/equals instead of the auto generation. That's fine by me I guess, but I'm confused as to why the compiler itself can't generate the same hashcode/equals.
Yes, it's because they are conservative. Most java developers are happy in their situations and they can't imagine how kotlin could make their life better. I'm a (ex?) java Developer doing kotlin server side happily :) with Platforms like spring and gradle supporting kotlin, times will change, but as always in backend dev and with technologies concurrent to java, it's a slooooow process, so adjust your expectations :)
My thoughts exactly. One of the biggest attractions for me with Kotlin was clean regexes but raw sting support is coming in Java 12. Coupled with type inference in Java 11 and Fibers on the horizon the reasons for Java companies to switch to Kotlin are becoming less compelling.
Multiplatform Kotlin is still very very new. Large companies have a lot of momentum to contend with, but I think, as it gets a little more mature, we'll start seeing Kotlin grab a foothold. There's enormous power and potential that JetBrains is bringing to the industry, but widespread industry adoption takes years. 
Absolutely not! 
Very cool! What made you choose Kotlin for writing the simulator?
Thank you. IntelliJ gives you a warning if adding an array property to a data class. Do people really not pay attention to these warnings? Okay, I know that many people don't. I see it all the time. I just don't understand it. 
The article misses an extremely important detail. Suspend functions are not obligated to suspend. They can - and will, in fact - execute in the same thread as the caller if they can do so and don‚Äôt need to actually suspend.
Of course not, marking a function suspend tells the caller that the method may suspend.
This is soooo coool, my man! I'm gonna download that code and have a look. One of my first really fun "programming for learning" was a friend of mine and me (mostly him because I just seem smart, he was actually smart) had a plotter for an Amiga, I think, that plotted the courses of celestial bodies, and we could get slingshots and stuff. So much fun! 
Over the years, I've gradually migrated from C to C# to Kotlin (trying lots of other languages on the way), and I think Kotlin is the easiest language that I've tried, for stuff like this. The other languages that might be considered, like Go, Rust, C++, Julia, etc., all seem to miss out important things (like functional style) or are harder / slower to develop in. So yes, I'm planning on using Kotlin as my main language for a while - till I find / someone writes something better. The runner up language, by the way, is C#. &amp;#x200B; Advantages of C#: C# is really underrated for things like this --- people think it's basically just for windows-based business systems, but it's also a really nice language. Overall, I find that the debug process in VS is slightly better than the debug process in IntelliJ --- easier to control flow manually (like dragging the active point around), and sometimes when debugging line by line, the IntelliJ / JVM really slows down. Also, in my opinion, things like reflection and generics work better in C# because there are fewer limitations imposed by .net than the jvm. I see this, for instance, when trying to deseriealise a list, which is straightforward in C#, but in Kotlin / Java, I need to do 2 weird things to get round typing problems --- (1) I need to pass the type I want to convert to (This is unnecessary in C# because the generic function has access to the type). For instance in C#, I can write "\[{a:3}\]".fromJson&lt;List&lt;A&gt;&gt;() In Kotlin, this is something like "\[{a:3}\]".fromJson&lt;List&lt;A&gt;&gt;(getListType(A::java.class)), assuming you've already written a getListType function previously. &amp;#x200B; Advantages of Kotlin: Kotlin's syntax is more concise than C#, a bit safer, and just nicer to use --- maybe more productive. Also, kotlin allows multiple main functions in the same project, which I see as a major drawback of C#, and for me, has been a tiny bit faster than C# (but I haven't tested enough to be sure). In C#, you need to add a new project, and sort out dependencies and all sorts of things, if you want two programs. So yes, overall, I prefer Kotlin to C#. &amp;#x200B;
I work for a prop trading firm. Our large, ridiculously large system is built in Kotlin. The productivity increase we had is incomparable. But, there will be issues with adoption in larger companies with mature code bases. For one thing, there isn't any commercial support for Kotlin, and this is an issue. For example, we faced several times where there have been compiler issues, but we just didn't have the time to produce non-property code to reproduce the bug. But in time, these things will change.
I'm a bit worried about all the similar looking magic incantations added by coroutines that do similar but apparently subtly different things. IMHO this is asking for trouble since chances are that people will start randomly copying pasting them all over. I'm doing something vaguely expensive here. Let me just call runBlocking {} or launch {} or async {} and bang on it until it works. This obviously already backfired so all the code I had that did that (and actually worked) broke in between the betas and the release candidates because some of it was deprecated and removed. So now I use GlobalScope.launch {} instead of runBlocking { async {...} }. Reads completely different, does the exact same thing. Problem solved. Except, I'm getting the vibe that this may not be ideal. There seems to be this complex notion of scopes and contexts (are they not the same thing?) with different ways of launching or running things in them and keywords such as suspend that you need to add to indicate that such things may or may not be used. Also there seems to be an over reliance on conventions, which worries me because now we rely on programmers knowing how to do things right instead of compilers telling them they are doing it wrong. Suspend reminds me of people slapping synchronized and volatile on just about everything back in the day. There was all this magical thinking around these keywords that resulted in a lot of awful bugs. Why do we need this keyword? I don't have the answers here but, saying this as a someone with nearly 25 years of java experience, this stuff is not that intuitive just yet and mildly confusing. Of course concurrency always was hard. People being pedantic about what is and isn't concurrent are not being that helpful. I get that some of my code translates to some generated code that does the polling, 'are we there yet type logic', etc. that is associated with doing green threads (aka. faking threads). The meaning of suspend is explicitly telling a scheduler "I can stop what I'm doing for a while so you can schedule something else". However for the casual reader of the code, this reads as "these two bits of code can run at the same time".
As far as I can tell, most (all?) Java developers who try Kotlin prefer it. They tell their team mates who eventually tell the boss. In the enterprise movement is slow. Java interop is a great boon, it allows experienced devs with large projects to dabble by converting or adding one bit. You get the huge ecosystem of libraries, tools and VM knowledge. Kotlin is the easiest language for a Java shop to change to. I'd like to see more adoption on the web front end. When people prefer using it over JS we get the bonus of 'one language for both'. Enterprise will like that. Multiplatform is also coming along... At the moment the only 'enterprise' solution for cross platform mobile is Xamarin and that doesn't mesh with a Java shop.
We are looking at early adopters at the moment but the feedback coming out is very positive. Over time this will reach a critical tipping point. There are a lot of people who never care about improving and will continue to use X till they are forced to. Respected publications like Thoughtwoks radar have given it the adopt signal. https://www.thoughtworks.com/radar/languages-and-frameworks/kotlin. If you think kotlin makes be you more productive, go ahead and adopt. 
Thats true, a little more flexibility traded for a lot less safety :)
Have you heard about the compile static annotation? 
My guess is that it is being used more often than we all think. It's a great language (I have used it professionally in an enterprise-environment) but with the excellent Java-interop, it's kinda "boring". Everything works great (i.e. existing libraries and frameworks), the job gets done, and everyone moves on to the next task without much fanfare.
I'm talking here about the methods in data classes - they are generated by compiler, not by IDE, if I got wrong what was stated in article- my bad. As of data classes I insist ) 
I'm not sure if that is a typo or... But runBlocking DOESN'T do the same thing as launch/async launch = Launches a coroutine, can't get the result async = Launches a coroutine, can get the result runBlocking = Allows using "suspend" methods OUTSIDE of an coroutine, it blocks the thread until the method returns a value. You shouldn't use runBlocking inside of an coroutine (blocks the coroutine thread) And for me it didn't break, it got deprecated and I just replaced them with "GlobalScope.launch/async" You should use suspend if you want to use the coroutine scope, if an method uses coroutine stuff, you should mark it as suspend (as in: "This method may suspend the coroutine", when a coroutine is in a "suspended" state, other coroutine can reuse the same thread, that's why coroutine is more lightweight) An example is wrapping JavaScript's http request code, instead of having a lot of callbacks, I made a wrapper class that I don't need to use callbacks, so the code looks like blocking code but doesn't block everything. When using that (marked with suspend!), it calls the XMLHttpRequest code and while the request isn't finished, it suspends the coroutine (allowing other coroutines to use the same thread!) and, when the request is done, the coroutine is resumed. That's how you can convert Java APIs that uses callbacks to coroutines, so you can have pretty code (blocking) without having a lot of callback hell. However I'm not on my computer atm so maybe I missed something, so ignore this comment if I'm wrong. (And it looks like I talked a lot while explaining almost nothing) :(
It's one thing to adopt a whole new language, but the fact that Kotlin "runs" alongside Java on the JVM has an amazing persuasion factor when proposing it in "conservative" companies.
All I know is I had a runBlocking bit of code that actually started blocking (as in nothing after that ran) somewhere around the RCs that I then changed to GlobalScope.launch to get going again. The point is, the semantics changed and probably for the good reason that somebody figured they were not ideal. I had a test that worked and then it didn't work.
Of course I have, and I use it here and there. Heavy groovy user here because I do a lot of gradle tooling for my company :) But if you ask me, you lose most of what's cool about groovy with compile static. Every language feature, from named parameters, over value based classes, over annotations for not loosing closure types, up to IDE support... everything in groovy looks wobbly and not part of the language at all. Seems to be like that on purpose because of the heavy meta programming approach groovy took. Plus if you want to connect static with regular groovy, everything turns into shit again as well. Even Hans Dockter said on the kotlinconf that kotlin is what he thought groovy could be when he invented gradle. So no hard feelings, but I think I'm not able to understand you :) Nonetheless interesting opinion, thanks.
I'd say an annotation would just move the problem instead of solving it. I generally don't like them because I cannot possibly know what happens from just looking at them and I hate code that does anything else than is obvious from looking at it. And things requiring a lot of medium posts, stackoverflow explanations, and documentation kind of smell like maybe there is an underlying problem that is not quite being addressed (like clarifying parallelism vs concurrency). I'd argue having less ways of doing things with maybe parameters that have sane defaults is the way to go in kotlin. Instead of having something called GlobalScope that has methods and that may or not be the right scope, maybe there should be a launch function that has a scope parameter that just defaults to GlobalScope that you can override to give it a different scope? Same with the difference between runBlocking, async and launch. They each take a block of something that does stuff. Apparently the semantic difference is relevant enough for there to be multiple things instead of one but yet not expressive enough so we also need things called scope and context (which I'd take to mean sort of the same thing if I hadn't read the documentation). I'm not actually able to articulate/deduce what the difference is from just looking at the code. To me it all reads like "do unspecified magic with this block". In my experience that means it is almost guaranteed some junior will end up copy pasting shit around instead of reading up. I've cleaned up a fair bit of java code like that. I'm actually quite positive about the current design. It's just that it seems there are still some rough edges and plenty of potential for people to get it wrong. &amp;#x200B;
I‚Äôm doing Kotlin in the server side and loving it. Large companies sometimes have people that smooth over some of Java‚Äôs issues and often move a bit slower. Kotlin is new and it takes a while for languages to catch on. Scala took up some of the share that Kotlin would have gotten and Java 8 did similarly. However, many people are finding that Scala‚Äôs features make it hard to read and Java 8+ still doesn‚Äôt have many of the nice things in Kotlin. You certainly aren‚Äôt wasting your time given the easy interoperability with Java. Uptake might just be slower. With Android, uptake was fast because Java 6 is feeling old and Scala isn‚Äôt really an option. On the server, Kotlin has to compete with Java 8+ and Scala (and non-JVM languages like Python and Go). But it‚Äôs still a compelling experience offering great performance and ease of use with access to a huge Java ecosystem. Kotlin is popular on Android like Swift is popular on iOS - it‚Äôs one of two languages that the platform really supports and it‚Äôs a lot newer than the alternative. On the server side, nothing will be as dominant because we can run anything. 
I'm still a bit fuzzy on what this keyword actually signals (and to whom) or why it matters to e.g. the compiler. I suspect that it's absence is actually more significant in the sense that it could end up blocking. Which raises the question why there isn't a blocks keyword instead? &amp;#x200B; &amp;#x200B;
It depends on how you measure, there are a gazillion backend systems written in Java, so it will take a long time before even 1% of them is written in Kotlin. But almost all of the Java shops I know are either moving over to Kotlin or thinking about it. One reason to postpone it is lack of knowledge, but that is a chicken and egg problem. Besides, it is a pretty easy language to get into, you will struggle with syntax now and then, but a good IDE will help you.
I often connect compile static with regular groovy and never had any issues, why do you say it turns into shit? Also, I don't think Groovy is unsafe at all, why do you think it is? Languages like C or C++ can be unsafe, but how can Groovy be? I definitely have way more experience with Groovy than with Kotlin and when using Kotlin I often miss certain Groovy features, but this might be caused by the fact I just spent more time with the latter. You definitely made some valid points throughout our exchange and I appreciate your input, also thank you!
It signals that this function may suspend it's execution at some point. If you're interested in how it likely works I'd suggest watching the [coroutines deep dive](https://youtu.be/YrrUCSi72E8). My hunch is that the suspend keyword enables compiler magic to support suspension/resumption.
With Kotlin you have all those features and more, and you have them right now, compatible with Java 8. Most big companies are so fucked they're still on 6 or 8 and migrating to 11 is a BFD. You think there's a chance in hell they'll get to use 12 or anything else that isn't the next LTS after 11 (if they even get to 11)?
First of all, thanks for this exchange. I sometimes use harsh words, I apologize :) &gt; I often connect compile static with regular groovy and never had any issues, why do you say it turns into shit? Because when people write APIs in groovy, they write them so that it can be used fine with groovy, not static groovy, which is not much better than Java itself if you ask me - also regarding APIs you write with it. I remember a situation where I wanted to write some static groovy in a gradle plugin. I tried to convert code from buildscripts that had to connect to regular groovy APIs and I had to understand how on earth the dispatching and method-missing magic was used under the hood, just to find out which classes were involved... circumventing everything with mad checks if properties exist and type switches, compensating the autoconversion that groovy applies. Also I have the impression that even features like type inference (def etc.) are gone when using static compilation, so I really don't know why I should use this feature (in more than just a few very small methods). &gt; Also, I don't think Groovy is unsafe at all, why do you think it is? It's dynamically typed, which means code changes don't give you compile time errors. If you don't have a test touching your wrong code ... well, you're doomed. This is unsafe, if you ask me :) Combined with ide-refactoring that certainly doesn't work waterproof.... Also, groovy is weakly typed...so many situations where a boolean is auto converted to "true" String, where it makes zero sense at all. Kotlin otoh has no auto conversion. Just as with you, it could be my lack of knowledge about groovy, that makes me unable to handle said situations properly. But I don't think so, I have to assume that I have decent knowledge about it, or I failed my job :) However, I would really like to talk with you about situations where you miss groovy features (you mentioned there are some situations). How about giving some examples and I try to help? :)
The *need* for Kotlin on Android is very high since we are stuck on Java 7 :( For server-side development though, I am not sure the *need* is there. Companies have a much larger selection of tools and programming languages they can use. [https://en.wikipedia.org/wiki/Programming\_languages\_used\_in\_most\_popular\_websites](https://en.wikipedia.org/wiki/Programming_languages_used_in_most_popular_websites)
Just to add, data classes might also be coming to java ([https://cr.openjdk.java.net/\~briangoetz/amber/datum.html](https://cr.openjdk.java.net/~briangoetz/amber/datum.html))
What about a consistent API between kotlinx.coroutines, RxJava, Project Reactor, and any other library that deals with similar concerns? Would a set of interfaces and tests that describe what all of them have in common, in ways where they behave the same like running blocking and non-blocking, sequential or parallel, fulfill your requirements?
Sure, for someone who knows traditional for loops the Java version is easier to understand. But take a step back and pretend you know nothing. Which one is easier to understand? Neither? Now look at them being able to understand both. Which one is quicker to read?
I don't use rxjava or reactor, so I don't really have an opinion on that. But I'd like less magic and more code that is more obvious in what it does. I think the current implementation is indeed shoving too many implementation details under the carpet meaning "you just have to know" instead of you "you can obviously know from looking at it". Hence all the lengthy articles, documentation, etc. trying to compensate for what is apparently not so obvious from the code or documentation. 
You are aware of the fact that you did use code marked as "experimental", do you? What exactly did you expect, is my question :) There's extensive documentation that explains every (?) application of coroutines, every library function and so on. I think you overread sth.
\&gt; Instead of having something called GlobalScope that has methods and that may or not be the right scope, maybe there should be a launch function that has a scope parameter that just defaults to GlobalScope that you can override to give it a different scope? &amp;#x200B; I'm a bit confused - you DID read all the information regarding structured concurrency by Roman Elizarov, did you? What you describe is exactly the old version of coroutines, and it was adjusted for very, very good reasons. "launching" something creates resources, that should be connected to a scope that is able to clean up its resources. Having global scope as the default is really not the best choice. So the implementation demands launching something from a context, making launch an extension function, which was a super nice decision, if you ask me.
Here in Holland we are seeing quite a few big companies (Bol.com, ING to name a few) are seriously adapting or at least looking into using Kotlin on the back-end. My current project we already have 3 non-production tools in Kotlin and are now trialling it for a production microservice too. &gt; Maybe being a better Java is a lost cause given that companies who choose Java are essentially conservative. There's loads and loads of Java devs who are complete fans of Kotlin. Why would they not be? They're the ones doing the programming. 
Java 11 still doesn't hold a candle to Kotlin in regard to ease of use. Most Java devs I know are fans or at least interested. The ones that are 'against' Kotlin were 'against' the Java 8 streams/lambda stuff to. And those guys will be against any change. 
Definitely not. Kotlin, due to it's tight integration with the Java ecosystem, is more of a Java dialect than a separate language.
\&gt; seems to be extremely low. What are your sources and how do you define "extremely low"? It's a new language, it can't take over the Java usage overnight. And it probably won't take over all of it, ever.
How is Kotlin ease of use going with Java libraries that require annotations and open classes?
Language wars are not won with bullet points of feature lists, there is so much more that matters. Doing @JVM.... annotations, issues with frameworks that require open classes for reflection and the corner cases with annotations still feel a bit bitter. Plus Java is the language of the platform, no FFI is needed and any Java IDE will do, not so with Kotlin.
&gt; How is Kotlin ease of use going with Java libraries that require annotations and open classes? Annotations work just fine generally and there's a kotlin-allopen plugin that can help if you're in need of that kind of stuff. Generally, if you look at frameworks like Spring and Micronaut, it 'just works' really. 
Yes I'm aware. I'm not complaining that it changed, merely observing that it changed quite late in the process (going from beta to rc) and that there are still a lot of things that aren't that intuitive or that clear at face value. Hence perhaps the need for lots of documentation and articles on the topic. And don't get me wrong, I mostly like what I see but I do worry that lots of people have just been given plenty of ways to get it wrong. Documentation/education is only part of the solution. 
It's /r/Kotlin, not /r/androiddev. Try this https://www.reddit.com/r/androiddev/comments/9yfrwy/weekly_questions_thread_november_19_2018/ thread.
You must pass childfragmentManager or supportchildfragmentmanager as a constructor parameter to the viewpager, not activity!!.application The viewpager works with fragments and needs the fragmentmanager to deal with them. Please don't use the !! It's a bad practice. 
I think one of the best features of Kotlin is the null-handling in the type system. This will catch so many bugs and can also be used on the server side. I also think this feature won't be implemented in Java in the future.
What is your question 
Hi, my question is how make a post with multiple parameters. I'm trying request to webservice with multiple file with images but the content request in webservice is null. In my code I try reproduced what happen in the postman (image attached).
There's a weekly questoins thread that this would be better posted in.
&gt; .addBodyParameter(FileBody instead of '.addBodyParameter(FileBody' try using addFileBody(file)
I tried this but it didn't work.
I wonder if Kotlin's long term goal is to get rid of the JVM and go full native, while keeping JVM interop with something like GraalVM.
So tried implementing it this way and everything works fine on the first iteration through this controller path. The second time I try to hit the same endpoint I get an exception thrown: Exception in thread "Exception in thread "DefaultDispatcher-worker-5" kotlin.KotlinNullPointerException at com.riskalyze.trading.application.controllers.AccountController$updateMany$1.invokeSuspend(AccountController.kt:127) at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:32) at kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:236) at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594) at kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:742) I realize this isn't stackoverflow and I shouldn't really be posting this here but since you have helped already and have the context, if something is obviously wrong to you that you could point out it would be greatly appreciated. If not, I can keep digging to see if I can figure out what the root cause of this is. Thanks for all the help so far though /u/emanguy you have been awesome.
Great that this is now stable, I've just released [Kweb](http://kweb.io/) 0.3.11 which uses Ktor 1.0.0 (Ktor is used internally by Kweb for HTTP and websocket handling). Kweb a high-level library for building rich web applications where all of the logic remains on the server (you can modify the remote browser DOM directly) but it feels like a rich JavaScript app from the user's perspective. The approach is fairly novel and takes advantage of some unique Kotlin features like coroutines. It's still pre-release but I could really use some feedback at this stage as I'd like to try solidifying the API.
I've started using Ktor in production recently-- really love how you can build your routes modularly that allow you to compose routes and let you write APIs with almost zero boilerplate.
So what's on AccountController line 127? Looks like that's where your NPE is happening
I also ran it in production at my last company. It worked great! I've also used HTTP4K have had similar results. 
They might, but they aren't the only game in town in native languages and Kotlin/Native libraries are pretty thin.
In kweb there is an example with a button that changes a header does that happen in the client or server side?
I use Kotlin for Android and Kotlin for all my utility programs. Previously I used Java or Python for my utility programs. There are so many times I need to write a quick parser for a CSV file or something similar that extracts weird data and maybe does some summary of it. Of course I am the only Android dev where I am so I did not have to talk anyone else into it but I am very happy to see Kotlin support on may other platforms and for not just Android programming in general. It will take some time to take off but for as new of a language as it is I think it is making fast inroads. 
You can do it either way, depending on your needs. button.on.click { header.text("Button clicked") } When the button is clicked the server will be notified and the codeblock will execute on the server, there will be a short delay for the browser-server round-trip (50-200ms typically), but the advantage is that the event can update any server-side state. If the event doesn't need to update server state, then you can use: button.onImmediate.click { header.text("Button clicked") } This will "pre-load" the instruction to the browser such that the header text will update instantly when the button is pressed, no communication with the server is required. Does that answer your question?
Yes amazing response! Thank you :)
Is this something like Vaadin?
Vaadin may be the closest thing to it, at least in the JVM ecosystem. The main difference is that Kweb is far less proscriptive than Vaadin. Vaadin requires that you use their UI elements and widgets. Kweb gives you direct access to the JavaScript interpreter in the browser, and you build what you want on that. So you can use whatever JavaScript UI framework you prefer in the client, but if you don't want to have to deal with that you can also use a Kweb plugin, which acts as a wrapper for the JavaScript framework. Currently the only one Kweb has direct for is the excellent [Semantic UI](https://semantic-ui.com/), through its Semantic plugin. You can see what this looks like [in this example](https://github.com/kwebio/core/blob/master/src/main/kotlin/io/kweb/demos/todo/todoApp.kt). But it is fairly easy to add new Kweb plugins to provide nice typesafe DSLs for whatever JavaScript framework you like. I started with MDC and then tried Bootstrap but they both annoyed me so I focussed on Semantic UI and Kweb is bundled with that plugin.
Make Stateful great again ) &amp;#x200B; &amp;#x200B;
Our universe is stateful, the important question is how to manage it architecturally :)
Sounds interesting. Can you point me to the code?
* [Main website](http://kweb.io/) * [Github project for main library](https://github.com/kwebio/core) * [A simple example app](https://github.com/kwebio/core/tree/master/src/main/kotlin/io/kweb/demos/todo)
Thanks.
The site is GREAT. Haven't had any problems with docs so far, and they have useful examples as well. 
It's joy to work with. Documentation is much better now and there is whole repository with working examples. After first few days I didn't really need to use the documentation. Everything just simply works :-) feels kinda like magic.
Single source of truth, maintained server-side.
I just finished prototyping a full stack kotlin app with ktor. I thought I could take a break but here you are tempting me to rewrite it with your super cool looking library.
Yeah, it's pretty much Spring Boot for cases where I have Java developers in a corporate environment, or ktor for smaller more focused stuff. I'm not sure where I'd pick Spark. Just depends. With other devs, most are gonna jump into Spring Boot faster unless they're pretty familiar with Kotlin. But if you have other Kotlin devs (even folk coming out of Android development), I'd probably go with ktor, since the coroutine setup is gonna be an easy sell.
At my last 2 workplaces I was coding in Kotlin on the backend. I code in Kotlin right now on backend. I write Kotlin libraries with seamless interop with Java and it turned out that most of my users use Kotlin. Even people doing homework assignments using my libs are using Kotlin. So no, I don't think there are problems with Kotlin adoption outside Android.
Play around with it, see what you think. Happy to help any way I can.
You could specify the SSL configuration in most of the client engines. Probably this page is outdated: https://ktor.io/clients/http-client/engines.html. CIO engine have the separate https config: https://github.com/ktorio/ktor/blob/master/ktor-client/ktor-client-cio/src/io/ktor/client/engine/cio/CIOEngineConfig.kt#L28 
Woah, really?
I haven't found anything that does everything I want, they way I want, while being issue free but: [sqldelight](https://github.com/square/sqldelight) - probably the most similar to Room, but only supports sqlite atm, though they have plans to add support for other dbs [exposed](https://github.com/JetBrains/Exposed) - from a jetbrains employee [squash](https://github.com/orangy/squash) - also from a jetbrains employee. I like the api better than exposed, but there seems to be less traction [requery](https://github.com/requery/requery) - also good 
I'd go QRM, and run with jdbi (it has a kotlin plugin that you'll want to install when you set it up so that you can handle data classes: ``` dbi.installPlugin(KotlinPlugin()) dbi.installPlugin(KotlinSqlObjectPlugin()) dbi.installPlugin(SqlObjectPlugin()) ``` ). 
I'm curious, I basically only use Hibernate. How do they compare to it? Are they similar or do you see some winning feature/simplification?
I looked at Requery and Exposed. Requery seemed like a decent option, Exposed's bug list was concerningly long. What are your pros/cons of Requery if you don't mind?
I haven't used Requery in probably about a year, but I was experiencing an annoying issue with getting it work, at all, due to how it [generates code](https://github.com/requery/requery/issues/663). Java isn't really my bg so it may have been PEBKAC (and it also could have been fixed in the interim). As for Exposed vs Requery, I found the Requery API a lot easier to work with. I had to jump through a lot of hoops to do more complex queries, certain features are missing and as you noted, there's a lot of bugs. That said, Requery isn't bug-free either, but the author is more active about addressing issues. Neither have great documentation, so you're going to be reading the source code to figure things out. I'm not really happen with any of the db solutions out there currently. 
Using request right now and it's been fantastic. A few bugs but all were worked around or fixed quickly. Ability to use rxjava or kotlin or rxkotlin or whatever was really handy as I wanted to listen on a few DB events and this made it easy
Doesn't look like CIO's HTTPS config will let you set client certificates. It has an `X509TrustManager` config option, but as far as I know, that just controls validation of certificates you receive from the remote side, not which certificate is sent *to* the remote side.
Kotlin is better than Java for **Any**~droid apps development.
understood, thank you :)
It‚Äôs not an ORM, but look at jooq. It works great in Kotlin and it produces much better results. http://www.jooq.org
[https://github.com/x2bool/kuery](https://github.com/x2bool/kuery) \- not an ORM, per se, more like DSL
We use Exposed on produciton for some time. Its joy to work with.
Why do you think it is "bullshit"? 
**exposed** is what I'm using currently. Using it's DSL instead of it's DAO is a nice type safe way of writing your database access, and still having lots of flexibility. I think **sqldelight** is maybe the best "production ready" solution, but currently it only supports Sqlite. Once they add more dialects I think that will be the killer app for production ready database access in Kotlin.
Why are more people not using Realm?, it's got it's flaws like any ORM, but by far the best I've used in a long while.
What does Ktor have to do with anything? It's a http client, not a DB/ORM solution
I still don't quite understand what a coroutine is. I get threads. But this confuses me for some reason. I must be brain damaged from my mom force feeding me radiation milk when I was a child.
Yes and JDBI is very similar to Room. You can annotate interact methods with SQL Queries (or update/delete etc) and use them as Dao's.
It has motivated me to use Kotlin outside of Android, which has a baked in ORM.
If you want something like typesafe SQL instead, because of flexible queries, take a look at `jooq`. It generates code from a database schema to use in a query DSL. 
If you have taken any OS courses you might have heard about user mode threads. Coroutines are conceptually identical. 
How about something like &amp;#x200B; fun isCarryingLightWeightItem(player: Player): Boolean = player.inventory.any { it.props.any { it.name == "weight" &amp;&amp; it.intValue &lt; 1 }}
Make it an extension function and you‚Äôre onto something.
We have a winner.
I would alter it slightly to avoid shadowing the implicit variable in those lambdas ``` fun isCarryingLightWeightItem(player: Player) = player.inventory.any { item -&gt; item.props.any { prop -&gt; prop.name == "weight" &amp;&amp; prop.intValue &lt; 1 } } ``` IMO your `Item` class should be a map if each prop has a name anyway. That way you're not iterating over the entire list of props to access any individual prop in the future. That makes this particular function simpler as well (rewritten as extension function as others have recommended): ``` data class Item( val props: Map&lt;String, ItemProp&gt; ) fun Player.isCarryingLightWeightItem() = player.inventory.any { item -&gt; item.props["weight"]?.let { it.intValue &lt; 1 } ?: false } ``` It sounds to me like `weight` should be a property of the `Item` class directly instead of being contained in that `List`/`Map`, but I obviously don't know much about the implementation.
I'm on mobile, so please forgive minor syntax errors. `fun isCarryingLightWeightItem(player: Player) = player.inventory.any { it.props.any { it.name == "weight" &amp;&amp; it.intValue &lt; 1 } }`
Single source of truth, maintained server-side. *edit:* Elaborating, Kweb maintains state server-side, and effectively defines a transformation between this state and (ultimately) the DOM in the visitor's web browser. When the state changes, the DOM updates automatically *in realtime*. This would require a **lot** more plumbing with any other framework I'm familiar with, but with Kweb you get it for free if you do things idiomatically.
 fun Player.isCarryingLightWeightItem(lightWeightThreshold: Int): Boolean = player .inventory .asSequence() .flatMap { it.props } .any { prop-&gt; prop.name == "weight" &amp;&amp; prop.intValue &lt; lightWeightThreshold } 
Thanks to you and /u/redditric for the solution; `.any` was what I needed. (Just FYI my actual domain classes are different, but I agree that `weight` probably would be a first-class citizen on `Item`.)
Thanks for the notice. It definitely should be fixed.
@msadeqhe, You are right.
This! Make it a sequence to avoid a bunch of interim data objects and iterations: ``` fun isCarryingLightWeightItem(player: Player): Boolean = player .inventory .asSequence() // Like Java's streams - lazily iterate through each item .flatMap { it.props.asSequence() } // Sequence.flatMap() requires another sequence .any { it.name === "weight" &amp;&amp; it.intValue &lt; 1 } ```
I'd personally go with more "one-line-ish" approach fun Player.isCarryingLightWeightItem() = inventory .flatMap { it.props } .any { it.name == "weight" &amp;&amp; it.intValue &lt; 1 } &amp;#x200B;
Does that mean there is no client-only state (including UI state) at all? If a user expands/collapses a block of text, all of that has to go through the server? If so, it sounds interesting for some niche uses, like collaborative real-time tools, but not something I'd use for a more typical web app.
That's not true. I work on the mobile team at HubSpot, our whole Android app is in Kotlin but no other teams use it or have plans to use it.
Yeah but realm is mobile only. 
I like Kotlin because not using an ORM is easier than ever. Really, there's not much to it. I replaced some hibernate cruft with plain JDBC (using the spring JdbcTemplate). Basically you need a bit of mapping code to map to and from your models. However in lines of code that is about the same you would use as slapping annotations on the field. Otherwise, my models are nicely immutable, free of annotation magic, getters/setters, etc. I map field names to column names in one place instead of all over the place. I'd argue that this is now so easy that doing this manually, actually has more upsides to this than downsides. IMHO ORMs have their place but they tend to be overused for usecases where they add little or no value; and where they add value it is mostly because the database schema got out of hand, thus necessitating a lot of complicated ORM stuff. I prefer fixing the schema or preventing it from getting out of hand. If you are interested, here's what I did: [https://dev.to/jillesvangurp/ripping-out-hibernate-and-going-native-jdbc-1lf2](https://dev.to/jillesvangurp/ripping-out-hibernate-and-going-native-jdbc-1lf2)
No, the DOM is maintained on the client, and "cosmetic" changes (which would include expanding and collapsing a block of text) can be done using an `onImmediate`event callback - so that will occur in the client-only without a server round-trip. Kweb can also do things like "caching" DOM fragments in the client and keeping them updated even while not visible (using the `cacheOnClient` option of [render](https://github.com/kwebio/core/blob/master/src/main/kotlin/io/kweb/state/persistent/persistent.kt#L40)). As such, Kweb should be fine for most typical apps webapps, in fact some of its optimizations (like the DOM caching) should mean you get a faster more responsive app out of the box.
FWIW, if you actually want a `findFirst` (i.e. you want to get the actual item that matches the predicate, not just see whether there is such an item), it exists: either `first
Dunno about Ktor, but took literally 10 minutes to get a [Javalin](https://javalin.io/) webapp up and running.
"I tried creating various tables with different names, but nothing seems to work." &amp;#x200B; You're looking for "jdbc:mysql://localhost:3306/db\_name". Are you getting db name mixed up with table name?
Open Settings dialog (Ctrl Alt S, I think?) Find plugins section Under "updates", you'll find options to update the plugin to the new version. Worked for me, anyway. I got the same error as you, initially, until I did this.
I have already checked that. There aren't any updates available. I did update the plugin yesterday though. It seems weird that it isn't compatible
I went and uninstalled the updated plugin I had, and could thus use the default version. This seems to work amicably
&gt; exposed - from jetbrains Oh! That's nice! I'm currently working on a pet projects where I'm just using Spring Data JDBC but this is a nice addition!
You posted basically the same thing just 1 day ago: https://old.reddit.com/r/Kotlin/comments/9yqim6/java_vs_kotlin_which_one_is_better_for_android/
10 minutes is too long. 
I think that depends on how you define "up and running". Since the "Hello World" example is literally 6 lines, including imports, I don't think he meant it took him ten minutes to copy-paste that snippet.
If you don't have any particular reason to use Ktor, I would recommend having a look at [Javalin](https://javalin.io/) too. Its design was largely inspired by express and koa, so it will feel a bit more familiar than Ktor.
Ah, thanks! I figured Ktor was fairly similar to Express in that it's a lightweight server extendable by middleware (features). I'll take a look at Javelin!
What gave you the impression TornadoFX isn't stable? The only mark against it right now is that Java 11 support is WIP.
&gt; The only mark against it right now is that Java 11 support is WIP. That's what I wanted to say, I phrased it very wrong...
Also, you can get a full CD github-&gt;travis-&gt;heroku pipeline with one command for http4k üòÄ https://github.com/http4k/http4k-bootstrap
Is it an option to create a view in your database using native SQL, and use the ORM to access that?
The lack of an SSL certificate in the day and age of LetsEncrypt makes me a sad panda. It looks nice, but this still is a little sad to me.
I didn't know kotlin had an up-to-date port of imgui. Neat. *schemes*
/u/nutrecht, the article https://www.reddit.com/r/Kotlin/comments/9z0h1l/why_android_developers_should_be_interested_to/ is for Android Developer, why they are interested in Kotlin. And https://old.reddit.com/r/Kotlin/comments/9yqim6/java_vs_kotlin_which_one_is_better_for_android/ this one is pros &amp; cons of Java &amp; Kotlin, 
jOOQ is awesome, have a Kotlin project in production that uses it and I can absolutely recommend it!
It seems to be a common problem for IDEA plugins. Please also vote for https://youtrack.jetbrains.com/issue/IDEA-202648
what about ``` repeat(5) { index -&gt; } ```
Sure, that works, as would `for (index in 0 until 5) {}` or `for (index in 0..4) {}`. As I wrote in my other reply, Kotlin isn't bad, but it often has way to many ways to do the same thing. In Java you just need to learn that there are c-style for-loops and for-each-loops. And that c-style for loops have an initializer, a condition and an operation that is executed after each loop. And then you can pretty much understand every for loop. In Kotlin, there are numerous ways to build such a range or sequence and they're all fine and optimized, but you need to learn way more stuff. You need to learn that `repeat` calls a lambda with a zero-based index as first parameter. You need to learn that `..` creates ranges with inclusive upper bounds you can iterate over. You need to learn all the other range-spequence stuff, like steps and iterating backwards and the special keywords (or, more correctly, infix functions) for them.
Thanks a lot
2 different philosphies? rofl
Imo tornadofx is quite easy and has good documentation and examples, but if you *need* java 11 you should wait or pick an alternative. Vaadin doesnt look complicated (using a talk at devvox as a reference) and has some clear examples on their website.
Do you want access to the listener outside? I'm not clear what the question is.
It's the complete contrary. Vaadin is very simple, but not suited for everything. If you want to display data, user management and the likes vaadin is fine. If you want heavy customization a fully featured Javascript frontend is required. 
&gt; heavy customization Not at all, so it sounds promising. Thanks
I think he wants to access some map object that is outside..
Hmm, can I not use this at work for an Oracle Database without paying? :/
Hi man, &amp;#x200B; you can find the sample under [https://github.com/kotlin-graphics/imgui/blob/master/src/test/kotlin/imgui/gl/test%20lwjgl.kt](https://github.com/kotlin-graphics/imgui/blob/master/src/test/kotlin/imgui/gl/test%20lwjgl.kt), they are directly referenced in the readme &amp;#x200B; If you have suggestions/hints/question, dont hesitate :) &amp;#x200B; &amp;#x200B;
Thanks for that. The link wasn't working till shortly it seems? I tried it some times in the last couple of days and it always led me to 404...
I just published this post, hope you'll enjoy it.
Well now you're just moaning about having to learn new things. Yes, learning a new language requires... learning new things. Tada! Java also has 4+ ways of declaring a for loop, for example. I'm happy to have all of these tools in Kotlin at my disposal. If you've spent time learning other languages, besides Java, you will recognize that most of these facilities are borrowed from other languages. For example `for (i in 0..5)` is the same as bash `for i in {0..5}`.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/kweb] [Comparison between Kweb and Vaadin](https://www.reddit.com/r/kweb/comments/9zixi1/comparison_between_kweb_and_vaadin/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
‚ÄúCoroutines framework is based on keywords and conventions. It looks like magic sometimes. You write code but it is doing something different.‚Äù This is the exact opposite of my experience. There‚Äôs one keyword (suspend), which indicates a function needs a context/can be preempted, and the rest is pretty much functions on a context object. The somewhat hard to grasp concept is understanding routines don‚Äôt match 1:1 to threads, but that‚Äôs not super surprising on other languages with green threads either...?
Thanks for the feedback. I will try to explain what I mean although since this is an opinion so it is very subjective. The suspend keyword itself "hides" a lot of magic behind it: changing function signature in the bytecode and compiling the code into a state machine. In addition, I was referring to the convention in the kotlinx.coroutines framework and especially CoroutinesScope extension methods and scope hierarchy concept. I agree the framework is not very big, but since it is a paradigm shift plus some of the changes it has some learning curve in my opinion.
Kotlin, for sure. There's still some workarounds Kotlin has to do to work with Java backwards-compatibility, but overall, I see a far more modernized Android system with better overall health of the code base. 
There are no plans to support LSP from JetBrains team, afaik. So you're out of luck, use Eclipse/Intellij.
hmm, maybe I'll just use Java then... Kotlin might be better, but at least Java is accessible.
What's wrong with Intellij?
It's visually cluttered, noisy. Difficult to zoom in and out on different fonts in different places. &amp;#x200B;
you can remove/ hide many of the ui components you don't like and alternatively go into presentation mode or distraction-free mode how is it difficult to zoom in? ctrl-scroll is pretty simple
Definitely don't use Eclipse to program in Kotlin! The quality of the plug-in is terrible.
Previously I've tried setting up VSCode for working with Java (got a bit fed up with slow load times of IDEA) and had a lot of problems with that. I'm assuming it would be event more difficult to achieve this with Kotlin. In the end I stuck with IDEA and I'd suggest you do the same. To avoid performance issues you can disable all unnecessary plugins. Also when setting up projects make sure to ignore folders which you do not use (for example log folders and so on - exclude them from scan). If you don't like the looks, that can be customized as well.
Sorry guys it was not clear what i mean :) &amp;#x200B; here is an sample code &amp;#x200B; class Sample { &amp;#x200B; lateinit map : Map &amp;#x200B; init { doRoute() } fun doRoute() { val error : RouteManager.Error = routeManager.calculateRoute( routePlan, routeListener ) } object routeListener : RouteManager.Listener { override fun onCalculateRouteFinished(p0: RouteManager.Error?, p1: MutableList&lt;RouteResult&gt;) { val route = MapRoute(p1.get(0).route) map.addMapObject(route) &amp;#x200B; &amp;#x200B; val gbb = p1.get(0).route.boundingBox map.zoomTo(gbb, Map.Animation.NONE, Map.MOVE\_PRESERVE\_ORIENTATION) // HERE I cant access map &amp;#x200B; } &amp;#x200B; override fun onProgress(p0: Int) { &amp;#x200B; } } }
Seems to me that you need more types if you want to avoid the risks of fields moving around :D
Thanks! Either that, or freezing class signatures from day 1 :D
Uh, no, it has been the same since long, if some links are broken just tell me which ones or push directly the fix &amp;#x200B;
Interesting article, but I have the same problem with your article as OP's. &gt; Classes are not positional This is still true. But by choosing to define `componentN` methods (whether you do it explicitly, or by making a `data class`), you introduce position to your properties. I don't see how you don't think one can argue that position can sometimes be a valid part of a class's semantics. For example, when reading a file sequentially.
If you don't mind a web-based interface, [Kweb](http://kweb.io/) already supports the [Semantic UI](https://semantic-ui.com/) framework. [Here](https://github.com/kwebio/core/tree/master/src/main/kotlin/io/kweb/demos/todo) is an example app.
JDBI is not an ORM, and I vote for it.
What do you mean, the link is SSL.
I'd argue that, in general, that is considered an issue for functions as well. A large part of the desire for default and named parameters in other languages is because function arguments can get mixed up, and it becomes complex to remember the correct incantation to get the data you want. It's a similar motivation for the parameter name hints provided JetBrains' IDEs. Arguably it also partially forms the motivation for patterns like the Builder Pattern, which aims to convert constructors using implicit parameter position into builder objects use named methods to define the parameters. In the sense that it is defined clearly by the language, and is documented behaviour, it is, as you say, not "dangerous" per se, but it is still behaviour that fundamentally goes against are tuition that names semantically represent data, especially in this case, where the names we provide will often be similar or the same to the names we originally gave the data. I think it's very reasonable to ensure that users of this feature are aware of the pitfalls of using it excessively, particularly in situations where data structures are prone to change.
This is a surprising behavior. Why not make it a compile time error when trying to bind to a different number of values? E.g. ``` data class Foo(val a: Int, val b: Int, val c: Int) val (a, b) = getFoo() // Compile error since Foo has 3 members ```
Mb, meant to reply on a comment.
Yeah I agree! Like I said, in my semantically-ideal world, named arguments should be used everywhere. We shouldn't rely on arguably unintentional information such as order of parameters. My point was, this isn't a new pitfall, anyone who programs deals with this all the time with functions. The other aspect of my point was that you *could* decide that order is semantically valid to you, for example, if you want to be lazy and read a raw file sequentially to fill in a class in order. (I know that `componentN` is read-only, but I'm saying in theory The only new pitfall is that changing the *amount* of class properties does not break compilation, and I don't think the article focused on the right issue. But I'm just being nit-picky, I love these specific conversations on semantics and such. I'm assuming the Kotlin team and community gave a lot of thought to the whole `componentN` thing, I wonder what made them go ahead with it despite it going against the convention of order not mattering?
Maybe the rationale there is, if you only need the first two `component`s, there's no need to break your code since it everything you need is still in place? 
jOOQ is designed to pull an arbitrary object from the DB, and it's really good at that. It can also easily load parents and their children. After that, it's basically impossible to load a more complicated configuration with a single query, so if you want children of children, or siblings of the parent, you need n+1 to query again. With hibernate, you just map everything, turn on eager fetch, and let it rip. The question is when it becomes worth it to deal with hibernate's idiosyncrasies.
When I set up the site Github Pages didn't support SSL :(
I could see the argument to allow the behavior, but most of the time if your data is really positional you just use a tuple. I wouldn't care if it was still allowed, just not the default. To your example reading data out of a file sequentially sounds I will give you that you can't really get away from the positions in the file, but that shouldn't affect your class. For example when I do sql queries I do return UsersQueryResults( record[record.getIndex("id")], record[record.getIndex("name")], record[record.getIndex("age")]); So yes positional stuff will always exist, but once you give it a name in general you should use the name.
Try invalidate cache and restart?
I think it is much more important that the jdk and libraries use loom. By doing so, the blocking problem on Kotlin coroutines or Akka actor will be almost banished ;)
Ah yeah, fair enough. I don't think the article was saying that it's a new pitfall though, just one that's in a different place to normal. We've got very used to functions having order, but objects having order of their methods is a bit more unusual. And yes, if you implement the componentN methods manually, you've got to be explicit about order, but I'd imagine most people just use those when they're already provided by the compiler, rather than implementing them themselves.
Agreed, maybe they should update the destructuring reference page to mention how this sort of breaks conventions. But I don't think they're a fan of that, judging by their responses to people criticizing their lack of a C-style for loop, or their lack of `switch`. (basically "stop saying we changed/removed conventions from other languages")
Apart from performance, Fiber never blocks on os threads and all your blocking java apis will become non blocking, so no need to differentiate between suspending and non suspending functions.
I'm not sure. Coroutines need to work in a multiplatform environment. Loom is just for the JVM.
That was not really a deep dive
Yes Please Share. codinginfinite1@gmail.com
As far as I'm aware you should be able to call `countDownTimer.cancel()` followed by `countDownTime.start()`
If you‚Äôre interested in this, you might also be interested in the [Advent of Code](https://adventofcode.com) A new challenge every day in December, use any programming language you‚Äôd like to solve it, there‚Äôs a leaderboard for the fastest solutions, or private leaderboard to compete among your friends. The challenges follow a fun themed adventure and are always pretty creative, so check it out!
I love Advent of Code, I look forward to it every year! Last year I solved [each day in Kotlin](https://github.com/tginsberg/advent-2017-kotlin) and [wrote a blog post](https://todd.ginsberg.com/post/advent-of-code/2017/) every day. &amp;#x200B; I'm going to try the [same thing this year](https://github.com/tginsberg/advent-2018-kotlin), but I'm traveling for work, speaking at a conference, and moving, so things might not be as timely as last year! But I'll have idiomatic solutions posted and explained as quick as I can, that's for sure. &amp;#x200B; There are also a group of us who discuss this in #adventofcode on the Kotlin Slack.
I'm sorry, don't get me wrong. It's a good article, but was not really that deep. What i mean by deep is that at first I thought you would go in to the kotlin compiler an explain what is better than the others.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/coding] [Kotlin, collections and sequences \[x-post from r\/Kotlin\]](https://www.reddit.com/r/coding/comments/a0admf/kotlin_collections_and_sequences_xpost_from/) - [/r/programming] [Kotlin, collections and sequences \[x-post from r\/Kotlin\]](https://www.reddit.com/r/programming/comments/a0adgr/kotlin_collections_and_sequences_xpost_from/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Just as a note to anyone on Android. You need 3.4 of Gradle plugin and of Android Studio. These are in canary channel. See the note at the top of the upgrade guide. https://docs.gradle.org/5.0/userguide/upgrading_version_4.html
You seem to know how coroutines work under the hood. I've been looking for this but all I ever find are guides on how to use them. I'd be happy if you could share something relevant to read.
Those unit test changes are pretty nice. I've wanted fast fail, and prioritizing running the failed cases for a long time. Should really speed up the testing cycle.
Thank you so much all of you! We've made it. 100% &amp;#x200B;
Didn't realize this either. Awesome.
I can't try it right now, but defining map inside a Companion Object should make it accessible. 
Well, you don‚Äôt refactor from red, after all.
You did nothing wrong. That's just how floating-point numbers work in computers, unfortunately.
Open up your Javascript console and run for (i=0.1; i&lt;1.1; i += 0.1) { console.log(i) } You'll see pretty surprising results there too. Just like how you can't represent 1/3 exactly in decimal, you also can't represent 1/10 exactly in binary.
You can use the following code : fa.forEachIndexed { index: Int, fl: Float -&gt; test = test.toBigDecimal().add(BigDecimal(0.1)).toFloat() fa[index] = test } But you have to us BigDecimal class to correctly add Float values.
Can‚Äôt help but feel like the annotations are unnecessary. Thinking an api built around well expressed extension functions would go a long way in Kotlin.
Computers don't do math with decimals perfectly, because only a finite set of numbers can be stored / represented and the number of fractional (real) numbers is infinite. With floating point numbers, the computer doesn't literally store the numbers before the decimal point and after the decimal point. Instead, it stores a formula, such as \`12 \* 2\^-23\` (oversimplification) which approaches your number.
Yes, I would prefer a SQL-centric DSL. I‚Äôm not a fan of the existing ones in Kotlin either. Something in the nature of jdbi, but with more of a Kotlin DSL api. 
Everyone has explained why it happens but none has given advice on how to fix it. Here's a SO question about high precision floating point if you really need the precision. https://stackoverflow.com/questions/277309/java-floating-point-high-precision-library Otherwise use the classes in java.math package to round them off. https://docs.oracle.com/javase/7/docs/api/java/lang/Math.html Or you can also use string formatting to truncate the string value of your float number. https://stackoverflow.com/questions/433958/java-decimal-string-format
Have you tried [jOOQ](https://www.jooq.org/)? It's almost like writing SQL, but typesafe.
&gt; what did I do wrong? Took up a career in programming 
You probably want to learn the general kotlin constructs first and apply them to android app development afterwards. [Kotlin koans](https://kotlinlang.org/docs/tutorials/koans.html) is a great guided way to start. 
I'd be astounded if there were any real cross platform UI libraries built on top of Kotlin Native at this point in the game - it's still pretty early for the technology, and the focus right now seems to be more along the lines that you described before - i.e. a separate ViewController/Activity for each screen and shared business logic. I wonder if there's been any significant work trying to make KotlinJS react-native work...
&gt; Hey, what if I need Postgres specific features, and don't want to be limited by MySQL's lack of features? You know, like upserts, returning clauses, aggregate filters, nice types like jsonb or UUID, ... This is what really hurts me the most. Exposed works very well for basic CRUD, but unfortunately it doesn't do so well when you want to give it something more complicated. Just passing it some raw sql isn't as easy as it should be and it doesn't do anything with the results set either. You can (I have) got some things like jsonb working by making custom column definitions etc. It's a hassle, but it works. When it gets to actually querying it though with db specific syntax, things fall apart.
&gt; Hey, what if I need Postgres specific features, and don't want to be limited by MySQL's lack of features? You know, like upserts, returning clauses, aggregate filters, nice types like jsonb or UUID, ... While you are kinda wrong about UUIDs (it supports UUIDs out of the box), that's one of the things I don't like about Exposed... they want to only support what the "SQL server with less features" supports, and not supporting anything else. While you can support some types (example: `jsonb`) easily, it is still kinda "meh" that you need to do this in the first place. (However I still really like Exposed and I do use it for my projects)
On a side note, its gonna be hard to skip 1.0 and go straight to 1.1 without an ugly if check in your loop
[PDF version](http://kt.academy/Kotlin_Cheat_Sheet.pdf) if you don't want to subscribe to cat facts
Thanks very much! Will save that.
I would really love to use a micro ORM that works like Dapper. Just a thin wrapper above jdbc for nice handling of parameters and mapping
"Don't be lazy using general language code reuse features, use the framework-specific one no longer supported"
Tell me more!
!subscribe
Dogs feel most vulnerable when defecating, so they look to their owners for protection.
Dogs only produce sweat on areas not covered with fur, such as the nose and paw pads, unlike humans who sweat almost everywhere.
You actually don‚Äôt create an abstract class ever. You can‚Äôt, that‚Äôs the whole premise of abstract classes. You can only use it to define other classes of which you can make instances. Also a lot of times you want to have classes that you don‚Äôt want to have instances of, but still want all the typing and structural facility of a class. In the second case, what you would do is simply ‚Äòobject MyObject { val x = ‚Äúhello‚Äù }‚Äô. Then you could access it by simply ‚ÄòMyObject.x‚Äô. The java equivalent would be using Singleton classes using static methods and fields However, since you have all the facility of a class, you should be able to inherit interfaces and other classes too. So what you are doing now is ‚Äòobject MyObject : BaseClass() { }‚Äô instead of ‚Äòclass MyClass : BaseClass() {}‚Äô where you are telling the language ‚Äúgive me an object whose class extends the class BaseClass‚Äù, which is what you wanted to do in the first place. Also note that when you specify an object it is an expression, not a statement. So while you cannot pass a class definition as a fiction argument or assign it to a variable, you can do so with an object. In Java when you do ‚Äònew BaseClass() {{ }}‚Äô you are doing the same thing. You are actually creating a NEW class and getting a new instance of that class. If you tried to do a ‚Äò.class‚Äô on that you‚Äôd actually get something like ‚ÄòCallingClass$BaseClass$1‚Äô which is just the name the java complied generates for this new class. And that also is how the ‚Äòobject ...‚Äô syntax behaves. 
Great reference. Shame about all the typos!
&gt; I wonder if there's been any significant work trying to make KotlinJS react-native work... That's not nearly enough layers of abstraction, I'm sure we can do better 
I haven't done JOOQ specifically, but I did use the similar library QueryDSL for a while. I think the major difference between kdbgen and any such DSL-like library is that in kdbgen there's no DSL. That could be a disadvantage if you know your DSL well, or an advantage if you know SQL well. Personally, I just want to query my database, be reasonably sure it'll work, use complex queries to minimize round trips, use fancy Postgres features, and not have to write a bunch of code describing the results of my queries. If you embrace your database as a dependency, then that's trivial to achieve. If not, I think JOOQ's is to use its own internal SQL parser and a separate "query the database schema" step.
Very helpful
Have an upvote. You apparently also made the mistake of providing an accurate answer.
There are two significant advantages to going ahead and lifting blocking JDBC calls into the coroutines API using an appropriate dispatcher. 1. Parallelism: there are usually opportunities to dispatch a number of queries at the same time and aggregate the result, and the coroutines API provides a nice abstraction for doing so. 2. Greater control over the size of the thread pools and what that means for server resource utilization: Generally speaking when you‚Äôre using JDBC you‚Äôre using a connection pool with a finite upper limit. For example, let‚Äôs say your JDBC connection pool keeps 50 connections around. If you use a server that allocates a dedicated thread for each API request, those API handler threads are going to be spending a lot of their time fighting over JDBC pool threads. It isn‚Äôt uncommon to see systems where 500 request handler threads are essentially contending over 50 database connections. Those 500 threads can generally be replaced by 2 or 3 threads if you use coroutines, and the reduction of load and wear and tear on the server can be absolutely dramatic because thread context switching and lock management has a nonzero cost.
If Kotlin were truly the future of Android in that sense then you would make far more as a Java developer. For an example, consider the price a COBOL developer gets to charge nowadays compared to Java in the banking world. Just imagine the rates Java developers could charge for adding features to so-called legacy apps if Kotlin completely took over. You'd be rich. That being said, it's at least a decade before that's the case and Kotlin and Java are more like two sides of the same coin whereas Java and COBOL are different currency. The higher salary likely belongs to the programmer that knows both for the next decade. Each language actually makes you better at the other. You see they're advantages and their faults and you learn why both exist and where both are going.
And why not learn both and split the risk :) Learning one helps with the other in my experience.
&gt;n that sense then you would make far more as a Java developer. For an example, consider the price a COBOL developer gets to charge nowadays compared to Java in the banking world. Just imagine the rates Java developers could charge for adding featur Thank for replying. Couldn't agree more to your point that Kotlin and Java are like two sides of the same coin. It's not choosing between both language but the developer should truly understanding both language.
You can pick up both languages at the same time as was stated before they are very similar. Most of Android is knowing the frameworks anyway. I mean if you only know kotlin just hit cmd-k on this java files sand your are all set. :)
No, but being able to learn Kotlin will make you more money. Kotlin is really just an abstraction on Java, adding a lot of functional and declarative syntax taken from other languages. IMO, Java has a lot of libraries that help you program a certain way. Kotlin is one way to bring several of these concepts to bear - all under the guise of a new language. It's kind of like do C++ programmers make more than C programmers. Depends what you want to do, but there's no doubt that knowing some C++ helps you better understand the strengths and limitations of C. In actual code, you can do a lot more with a lot less in Kotlin, so from a practical perspective, probably. But being a Java expert also lends you more flexibility in opportunities due to the sheer volume of Java code. 
A developer that 'can't' do Kotlin can't do Java either. So it's not really a matter of how much you're going to be paid, it's about whether you get paid at all. Kotlin is in my opinion more of a (better) dialect than a separate language. It's starting to gain a lot of traction in the Java back-end scene as well. 
&gt; If Kotlin were truly the future of Android in that sense then you would make far more as a Java developer. This would only be true if Kotlin was the _today_ of Android whereas Java was a distant past, a relic of the previous generation. Let me argue the opposite case: if it's correct that Kotlin is the future of Android, and if many companies are realizing that, then the Kotlin salaries should be rising due to expanding demand that can't be met right away from the existing developer pool. Salaries will begin declining only after the effect of the higher salary attracts more devs to that segment.
Does it mean that the DB credentials need to be in clear in the code or can it be loaded via a config file ? Sorry I haven't got into Kotlin yet, just lurking.
Technically yes, though only because: - I haven't yet made any provisions for providing DB creds from anything but hardcoding on the settings annotation. In the future, any source accessible to the compiler could work- files, environment variables, etc. - The @SqlGenerationSettings annotation isn't marked with source retention, which it probably should be, so the annotation and its URL stick around after compile time. That's an easy fix though. My thinking is that the credentials should be for a local database though, or at most some random dev box. It _does_ work with production credentials, but ideally you'd be developing your schema hand-in-hand with your code. I guess if you're not going to be changing the schema it wouldn't matter though.
How to open a camera is Android development basics, not Kotlin basics, You won't find any information on this in most Kotlin beginner guides.
The section about receivers (with, let, etc.) could have been clearer. Given a variable called `foo` of `type T`, called with the following function: * let: foo is the `it` argument of the lambda, returns Unit * run: foo is the `this` in the lambda's context (no argument), returns foo * apply: foo is `this` in the lambda's context (no argument), returns foo * also: foo is the `it` argument of the lambda, returns foo 
&gt; IntelliJ will literally convert copy and pasted Java to Kotlin, and you can do it one class/file at a time. Which has to be refactored then.
That's exactly how salaries rise. Adding a scarce skill as a requirement for the job.
It depends whether Kotlin is a scarce skill.
It will be scarce if demand suddenly rises due to a lot of companies jumping on board. Basically you aren't arguing against my point, but attacking its premise. The premise is already guarded by "if it's correct" so this is moot.
It's not scarce given the today's demand, but its usage is at something like 10% of Java.
If all it does, is assign variables, then yeah.
Sure man, whatever you say. I can tell you have a lot of experience with it.
Just my two cents. I know it has gotten better. But a year ago, it would choke on complex constructs. 
Please keep me updated as well.
I believe the latest version of IntelliJ supports it. I sorta got it to work but got linker errors with libcurl so I stopped.
i've seen the option for creating a native project for a couple minor versions, but i've never started one so i don't know what it does
IntelliJ IDEA supports editing Kotlin/Native projects, but not running or debugging. For debugging, you need to use AppCode or CLion.
https://kotlinlang.org/docs/tutorials/koans.html Good luck.
Thank you!
"Atomic Kotlin" is intended for people with no Java experience and covers Kotlin as a language, not Android development. https://www.atomickotlin.com/atomickotlin/
Here is a pretty good kotlin programming course book -&gt; [https://books.goalkicker.com/KotlinBook/](https://books.goalkicker.com/KotlinBook/) .
I will check this one too, thanks!
You may find this course to be useful: https://www.udacity.com/course/kotlin-bootcamp-for-programmers--ud9011
That's a cool one!
I recommand **Kotlin in action :** [**https://www.amazon.com/Kotlin-Action-Dmitry-Jemerov/dp/1617293296/ref=sr\_1\_2?ie=UTF8&amp;qid=1543497633&amp;sr=8-2&amp;keywords=kotlin+in+action**](https://www.amazon.com/Kotlin-Action-Dmitry-Jemerov/dp/1617293296/ref=sr_1_2?ie=UTF8&amp;qid=1543497633&amp;sr=8-2&amp;keywords=kotlin+in+action) &amp;#x200B;
I like [jsoup.org](https://jsoup.org/)
Learning the syntax of a language is the easy part. I wish there were more intermediate, project-oriented books out there (design patterns, algorithms, real world usage of coroutines, unit tdd, cloud, etc.)
I am currently using JSOUP java library to extract the image of a website, so sounds like there is no point to move to this library
Thank you for sharing
Essence uses JSoup under the covers. Unless you know the structure of the HTML, extracting the main text body is a fairly difficult task. Essence extracts the main text content without needing to have specific knowledge of a webpages HTML structure. It applies heuristics to ignore navigation, advertisements, headers, footers, etc. JSoup does not address this problem. It provides the fundamental tooling to parse and modify the DOM
Gradle is for me trouble maker, never works properly. Complicated tend to like programming environment instead of build tool. 
To simply pull HTML data, you can simply make a GET request. Essence is a library to extract the main text content from a page, along with various other metadata
If you are into coding backends, you can quickly write a simple REST API using [https://ktor.io/](https://ktor.io/), and grow your project from there.
OMG! Someone other than me plugging Atomic Kotlin! That's my response to questions like this as well.
If you're interested, here's a link to essence web. Its source code is also available. [https://essence.mybluemix.net](https://essence.mybluemix.net)
If you're interested, here's a link to essence web. It pulls down the full HTML content and feeds it to the essence lib. [https://essence.mybluemix.net](https://essence.mybluemix.net/) If you're looking for an example, its source code is also available to check out. 
Does anyone know if they abstracted away the internal vs public Gradle APIs for plugins yet? I ran into some issues with kotlin plugins because a lower level DSL method used some internal API, which locked the plugin build to a specific gradle version. I thought this was gonna be fixed for 5.0 but I‚Äôm curious if there‚Äôs other plugin authors that know this for sure
Looks like the answer is ‚Äúno, but it probably only affects a few plugins‚Äù: https://github.com/gradle/gradle/issues/1842 I just happened to do something similar to plugins that had issues (abstract away our crazy internal server config for publication into plugins that alleviate devs from needing to cargo cult config around everywhere).
This is what we use in arrow to include generated sources in the IDE: https://github.com/arrow-kt/arrow#additional-setup
Official Kotlin course by jetbrains https://www.coursera.org/learn/kotlin-for-java-developers (no android :))
If you're brand new to programming, get a full course (like $10 on udemy). You can definitely teach yourself, but it's nice to have some format to the learning from an instructor. &amp;#x200B; I use this one [here](https://www.udemy.com/complete-kotlin-android-developer-course-tutorial/)on udemy. I don't have any connection to the instructor, just spreading what seems to be working for me! Good luck. 
&gt; Read-only variables ‡≤†_‡≤†
Well, as you mentioned is that the problem is you end up passing the value and not a reference to the property itself. One way to solve it, and I mention is purely as a technical possibility is to use reflections. When you do foo::property you will get a KProperty which you can get the value for and set the value too if you want. But then I would absolutely not recommend it for just the sake of some syntactic sugar. 
You can define a custom setter and only invoke side effects if the value has changed: var myProp: String set(value) { if (field != value) { field = value sideEffects(value) } }
Rich's talks are always fantastic. It's worth watching this one in its entirety, if you have time.
I would like to suggest: [Introductory Kotlin workshop for programmers](https://stepik.org/course/50282) &amp;#x200B; This is an open Kotlin course specially created for people with programming experience. Not assuming you have any Java or Android knowledge. 
Those are not Kotlin basics , but Android basics.
Yeah, I suppose so. Might be useful if I ever need to do something similar but much more complicated with properties, but probably overkill for this case.
It's worth noting that the billion dollar mistake is not the null reference itself, but that very important languages like C, C++ and Java made every (non-primitive) type implicitly nullable while allowing the programmers to not check for null value. Which makes sense of course, since if every type is nullable, then mandatory null checks would make every code unreadable, but it resulted in increased fragility of programs, and it probably cost billions of dollars over time. Now consider how some newer languages (C#, Kotlin) got rid of checked exceptions...
Yes, `Dispatchers.IO` is yet another thread pool. Note that `Dispatchers.Default` is also a thread pool, and probably what you would use for this example. If you poke through the kotlinx.coroutines source a bit, you'll find `Dispatchers.Default` keeps one thread per core (or one less than the core count, because the main thread occupies one core? I forget) and `Dispatchers.IO` has max(64, core count) threads. Java doesn't have any idea of asynchronous I/O. Every time you interact with the outside world, you're going to be blocking a thread. The idea behind async I/O on the JVM is to block someone else's thread so your thread can keep working. This is an Executor with Java's new futures, or a very large threadpool behind `Dispatchers.IO` for Kotlin. The idea is you can have 64 I/O operations going at once, blocking your 64 threads, and as long as you don't schedule a 65th one it's almost like they're all actually asynchronous.
User name checks out. :D
C and C++ did not make every non-primitive nullable. Only pointers are nullable. Especially in C++ because of the power and encapsulation it gives, most of the time, you aren't handling pointers that much, so you don't have implicitly nullable types. On the rare chance that you want a raw pointer, the nullability is usually fine. There's also `std::optional` which gives you a nullable type with value semantics. In short both C and C++ don't have implicit nullability. Instead, nullability is opt-in.
The problem with checked exceptions in a language where everything is nullable is that any line can throw an exception. This means that you really need some type of unchecked exception as well. Since you need to handle unchecked exceptions anyway on basically any line it makes sense to want to get rid of checked exceptions. I hate dealing with checked exceptions in Java because almost every exception is handled in one of two ways. Either notify someone and return to a known state, or notify someone and kill the app. OTOH, if nulls disappeared, every exception could be checked and the coffee could track the kinds of problems that were actually expected.
Thanks for this!!
Thanks, I stand corrected.
Well, there are a couple of other runtime exceptions that are very common (e.g. ArrayIndexOutOfBoundsException) although not as common as NullPointerException, and I wouldn't exactly like it to be a checked exception, but I think there are clever ways to avoid it (dependent types, for example). Anyway, to me the problem with checked exceptions in most languages is that they can only be handled with a very ugly and clumsy syntax (try{...}catch(...){...} is not an expression in most languages), which disrupts the natural flow of the code and hinders readability. Personally I would like to see a language that handles exceptions the exact same way as Kotlin (and Swing) handles null values, as a potential return value. String? is just a shorthand for String|Null, but instead it could be a shorthand for String|Exception, where Null would be also a kind of Exception. Of course it would mean that the language also should provide a way to distinguish between the different kinds of exceptions, and allow several different ways to handle them (in addition to either returning it to a String? variable or providing a default value), but I'm sure it can be achieved.
Thank you for the explanation! I did see that the `Dispatchers.IO` had max(64, core count) threads, but I wasn't sure if it was "yet another thread pool" or if it was something else. So technically using a "custom" thread pool won't have any differences compared to using `Dispatchers.IO`, and that's where I was confused.
Glad you like it! :-)
I have bought this book. Awesome!
C and C++ get really close but still are effected by the problem of nullability (we‚Äôve all seen the segfaults to prove it). Because pointers conflate optionality with sharing. Go, D and a lot of other systemsy languages sit at this point. C++ references + std::optional get really close to eliminating the problem but are unfortunately unsound in the presence of aliasing. Managed languages with nullability annotations such as kotlin also fit in this category. You typically see these problems in invalidated iterators or concurrent code. You can totally eliminate the problem by controlling mutability (or banning it outright) Haskell and rust fit in this category, but it‚Äôs an open research problem to cover some use cases and so they need to leave some strategic holes in the type system (unsafe) and often need to sacrifice ergonomics and compiler simplicity. 
Correct, it should be the same. The `Dispatchers` object provides some dispatchers for common cases so you don't have to reinvent the wheel, but it should operate the same as one you make on your own.
I think there's a difference between using Kotlin and being a Kotlin developer. I know of a lot of Android developers that use Kotlin the exact same way they use Java. They write te exact same code and use none of the tools Kotlin has over Java. Personally, I think Kotlin is a scarce skill.
Not quite the same; AtomicReference requires a specific expected value to use compareAndSet, not just inequality.
Well, yes, but these are wrapper types, with their own problems, as explained in the video. I would like String? to simply mean String|Ex (where Null is a kind of exception), and simply write val userZip:Zip? = db.getUser(id)?.getAddress()?.getZip() if (userZip is Ex) { alert("Couldn't get the zip code for some reason, but I won't tell you why, so fuck off or try again later."); return; } ... // do something with userZip while getUser(), getAddress() and getZip() all can return ("throw") various kinds of exceptions, e.g. DatabaseCrashed, DatabaseTimedOut, UserForThisIdWasNotInitialized, UserWasDeleted, AccessToUserIsRestricted, UserAddressWasNotInitialized, UserAddressWasDeleted, AccessToUserAddressIsRestricted, and so on. Of course you can do something similar with try...catch, and Kotlin is nice enough to make try..catch an expression, so you can even return a default value from the catch block. I just don't see any reason why we need to handle exceptions differently than return values. On the other hand, I feel Kotlin's safe call operator is somewhat lacking. It would be nice to have a chain of calls, where you can handle the exceptional case in each call individually. So, something like this: val userZip:Zip = db .getUser(id) : ... //handle the exceptional case somehow ?.getAddress() : ... //handle the exceptional case somehow ?.getZip() : ... //handle the exceptional case somehow ... // do something with userZip where "handle the exceptional case somehow" could be anything. Off the top of my head: 1. return a default value to the userZip variable (optionally depending on the type of exception), 2. pass a default value to the next function in the chain (optionally depending on the type of exception) 3. make the function this code is in to return some default value (optionally depending on the type of exception) 4. make the function this code is in to return ("throw") the exception 5. jump to the end of the function with the exception, where there is an exception handling block
Thanks!
I actually didn't see the video (I was at work), but it still sounds like the result type. a Result can hold different error types, and you use pattern matching to handle different types. or you can use `map`, `map_err`, or `unwrap_or_default` to handle the exceptions as you describe. I like it better that it's a type and not special language syntax. 
Absolutely. That's like hire a Scala developer that writes Java-like style.
\&gt;As far as I can tell, this is allowed to me by the Apache software license that the Udacity code samples are released under. But would it be still recommended that I instead use similar but different app concepts? If so, I might need some help coming up with those as I'm short of ideas at the moment. &amp;#x200B; Just create your own code samples. The udacity samples are simple enough that you shouldn't have a problem making samples that follow 30 second to 3 minute videos. &amp;#x200B; \&gt;What should the tutorial series be called? I'm a bit worried that I'm "calling out" Udacity with this current working name. &amp;#x200B; **Android Basics using MVVM and TDD principles?** &amp;#x200B; \&gt;How much interest is there is such a series? &amp;#x200B; If it was free (on udacity, udemy, etc.) I'd probably give it a look. There's a lot of movement on those sites but there's also a lot of nonsense. I'll give things a look if they might expose me to something interesting I might not otherwise be exposed to.
Wow, I just started messing with Kotlin more seriously after getting to a intermediate level of a language for the first time with Python. This is perfect for me, thank you.
Key difference, and the crux of Rich's argument, is that in Kotlin, functions of the form `T? -&gt; U` can directly accept arguments of type `T` without affecting correctness. In Rust and most other languages with algebraic data types, functions of type `Option&lt;T&gt; -&gt; U` cannot accept arguments of type `T` (you'd have to wrap it in a `Some(T)`).
Actually I use Kotlin in a place where people would use Java (and making a game), and I don‚Äôt even know how to make mobile apps at all. It‚Äôs a little bummer when I search for the language (e. g. Kotlin with Gradle) most of the results have Android in them.
In my previous job, we used Kotlin with Dropwizard for some API.
I've used Kotlin for 2 years and not once for Android development. We used it at my company for building JVM libraries that connect to all sorts of APIs; such as databases, servers, cloud services, applications, and more. I've tried Groovy and JRuby but Kotlin was far more useful/enjoyable. The design decisions make developing a breeze and helps cut down on so many common problems you'd find writing Java code. If I ever have the decision of what JVM language I can use, you can bet it's going to be Kotlin.
I use Kotlin for everything and anything I need to do (well, almost everything), 99% of them aren't related to Android at all! (And I don't regret dropping Java for Kotlin)
Khan Academy is running Kotlin in a couple of small services on our website.
50% of the developers using kotlin are android developers, so it makes sense...
Yeah, I'm still reading through the docs and I've only written the toy programs you write when you're learning; but it's been great so far, pretty intuitive. 
I am using kotlin in place of java in my regular development 
Yup. Spring Boot.
We started using Kotlin for back-end tooling about a year ago and we're now also starting to use it for back-end (Spring) productio microservices.
100% with you on this one. I've tried making android apps in the past and can't say I liked it. Kotlin itself however has been a blessing to me
I have no idea how to make an app, but I use it as an alternative to java. I find that I‚Äôm writing more readable code in less time. Also, coroutines have made multithreading a lot easier for me.
I've been using kotlin with vert.x to develop an API. It's rather nice to work with. 
My company uses Kotlin for one of our internal JVM-based systems (plus Dropwizard, PostgreSQL, and Bootstrap). Based on this very positive experience I expect that future systems we develop will also be written in Kotlin rather than Java. The only language feature I miss in Kotlin is checked exceptions, although I understand why Kotlin‚Äôs designer made all exceptions unchecked.
I've used it for AWS Lambda, database connectivity from my laptop, and the beginnings of a game that won't go anywhere, in addition to Android. I use it wherever I can. 
We use Kotlin for back-end development at work. I also use it for my side projects which aren't Android. I feel so much more productive in Kotlin and it's so pleasant to work with. When I need to modify an existing Java class (eg. old unit tests), I first convert it to Kotlin to allow me to extract out additional repetitive patterns which cannot be achieved with Java (eg. Lambda with reciever enables really clean and readable tests)
I use Kotlin without doing any Android at all. At my job I'm responsible for a lot of R&amp;D, so I use Kotlin whenever I can. We have a very large investment in Java dating back to the J2EE days. We're porting a lot of stuff to Spring Boot where we can, and encouraging the use of Kotlin. Spring Boot + Kotlin == Very clear.
It is the most beautiful language on the JVM - so I use it.
Checked exceptions have always been controversial. I think they do make your code a bit clumsier. I didn't know Kotlin designer decided to make all exceptions unchecked though; like I said, I'm still reading through the docs. Thank you!
I'm using kotlin with Corda - a blockchain framework. 
Do you convert it by hand or use some automatic tool? I read that the IntelliJ's (or Android Studio) built-in tool is not quite perfect and needs you to review the output code.
Thank you! And happy cake day! :)
But I still need to setup the Gradle‚Ä¶ 
I've been told you should learn spring boot then spring later. But it seems like many jobs only use spring boot. I guess that should be enough?
What made you decide to use Kotlin for a game? and what frameworks/libs do you use for if any? 
I'm \*only\* using Kotlin outside of Android development. Doing backend/network server type projects. 
I have wired a number of helper kotlin modules in my arch box for running multiple admin and android dev support tasks. Slowly moving away from all my shell scripts. 
Yeah, only with Gradle 5.0 has the Kotlin DSL really had much documentation and it‚Äôs still pretty lean 
Well, yeah, the interoperability with Java is their main selling point, as far as I understand.
Can you use Kotlin for scripting natively?
One approach which is often suggested is to start writing/migrating unit tests in Kotlin for an existing project. When you get more comfortable with the language you might start writing Kotlin production code within the same project. There is no need to rewrite the entire project in a single step.
Our backend are fully Kotlin and heavily utilized JetBrains Exposed. My personal stuff (outside Android) nowadays are all in Kotlin as well.
Do you have any links for some projects that I can contribute to ? and Thx for answering. &amp;#x200B;
Just take any project you want to write or have written and simply do it in kotlin. Supplement with Java libraries where needed. 
My team writes our backend services exclusively in Kotlin + Spring boot. I work at a medium-size bank.
You could join me and many others in this year's [Advent of Code](https://adventofcode.com). Solving each day's challenges is a great way to explore the standard library, in particular the collection and sequence APIs. And it's great fun to go through other people's solutions afterwards on /r/adventofcode to learn new tricks and idioms. 
I‚Äôve written a couple of Gradle plugins in Kotlin just to get a feel for the language 
How did you find it?
I don't use Java anymore
I use kotlin for all my personal projects and have done one small kotlin/spring micro service professionally.
Big libraries like grpc Java dont even work with kotlin DSL in Gradle 5.0 yet. Had to downgrade to 4.10 yesterday :/
You should review it but definitely use it. I can review the output and fix it up if needed in like a minute which is far faster than rewriting it
If you‚Äôre thinking server side, not mobile app, I‚Äôd probably consider a serverless app or two. I myself am looking into the serverless framework (https://serverless.com) and have screwed around with lambdas in AWS with kotlin. You can do lots of small focused stuff. Doesn‚Äôt have to be an API behind a gateway, can do things like read emails and send notifications, scale images when you upload them to S3, etc. Other than that, using kscript is like ‚Äúbash scripts on steroids‚Äù.
I'm just starting to use Kotlin to write server-side libraries. It's great. 