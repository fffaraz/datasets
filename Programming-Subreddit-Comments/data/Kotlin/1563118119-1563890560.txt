No problem - but I warn you before that you really are overthinking it üôÉ. Maybe this is the best trick that DI containers ever pulled... Dependency Injection is merely the process of supplying dependencies to an object that you're creating. This can be done through a "main" class, or through some magical framework which reads annotations/XML config/whatever. Our microservices use a main App class (which in http4k terms merely exposes an HttpHandler interface), and a Kotlin script (the launcher) which takes that HttpHandler and launches it as a running Undertow server on the configured port. The key thing is that all dependencies required to construct the App are passed (injected) through the constructor. And the App constructs its own dependencies using their constructors. And so on....
Try this for Micronaut in Kotlin: https://guides.micronaut.io/creating-your-first-micronaut-app-kotlin/guide/index.html Or this for Spring but the official guides are only in Java for now so you'll have to convert to kotlin yourself if you want to: https://spring.io/guides/gs/rest-service/
I just checked, the tag is indeed bad, but unfortunately it is immutable. I suggest following thorugh with the [article](https://hexworks.org/posts/tutorials/2018/12/28/how-to-make-a-roguelike-views-screens-inputs.html) instead of using the tag.
Thanks. Sounds like 'passing parameters' rather than 'injection' then :-) DI is useful for mocking when testing, other than that I'm not particularly fussed about DI as a concept, but everything else Spring does is very useful. Whatever you want there's either a Spring module for it, or it has an integration with Spring, or there's documentation explaining how to integrate it with Spring.
I would suggest you https://hexagonkt.com (disclaimer, I'm the author) which is very easy to learn (it feels like Express JS or Javalin). Another more mainstream option would be Vert.x https://vertx.io which has first class Kotlin support (among other languages). Happy coding!
Spring does a lot more than DI.
-&gt; Sounds like 'passing parameters' rather than 'injection' then :-) That's branding for you! In regards to both design and testing, DI is essential - but once again, you also obviously do it without a container. In fact, one of.my last straws with spring when I used it was a hideous multi layered spring "test mode" monstrousity which was almost impossible to unpick - but I suppose you can do bad shit with anything, so it's not completely fair to attribute direct blame. It's just that we find it's easier to see when it's right in front of you than hidden. üôÉ I get that spring is very popular and convenient. But actually a lot of things aren't actually that complicated, or you're already doing most of the work already, just in another form (be it annotations or otherwise). You could potentially even try hand-wiring spring components in your app just to see what it would look like - of course you might just find that the design hiding under there actually isn't very nice at all! üòâ
I have introduced and used Kotlin for on new and existing Java codebases at a major investment bank in the US and also a fast growing early stage. No issues really. Java interop is seamless and I havent seen a NPE is a couple of years
DI is more than just branding... Passing a parameter is not 'injecting'. DI is much more complex. That's why the internet has no references to DI that don't mention a library like Spring/Dagger/Guice etc.
Sorry - but Wikipedia somewhat disagrees. üôÉ https://en.m.wikipedia.org/wiki/Dependency_injection Doubtless the machinery required to put and retrieve all the stuff in the giant mega-hashmap behind the spring application context is complex, but that is just an implementation detail.
Sorry - but Wikipedia somewhat disagrees. üôÉ https://en.m.wikipedia.org/wiki/Dependency_injection Doubtless the machinery required to put and retrieve all the stuff in the giant mega-hashmap behind the spring application context is complex, but that is just an implementation detail.
Basically concurrency means being able to do stuff on more than 1 thread and parallelism means being able to do stuff at the same time.
Per that definition aren't they the same?
At Target (currently Fortune 39) most of the backend teams around my area are moving or have moved to Kotlin for new projects. The eight-person team I'm on is using it serve up many many thousands of requests per second. I was a heavy server-side Groovy/Java user for about 10 years, but I can't think of any project that I'd favor picking either of those over Kotlin on these days.
I work for a company with about 25k people. Traditionally we have used Java, but recently gotten into Kotlin. That said we have developers all around working with all sorts of tech. We work with banking, thus especially during Christmas is hammered with massive amount of queries that needs to be answered (we're talking for payments). I can't remember the exact number, but we're talking a lot of queries per second. So, we have to be on our game and have an efficient enough system to respond to all these queries. Our switch to kotlin hasn't impacted us performance wise. It is still running on the JVM which is doing its thing. The big benefit of kotlin is being able to write good code faster and maintain it, something we've done with Java for years, it just seems easier with Kotlin. In the beginning we had a few issues with the more seasoned developers which did not enjoy going to kotlin after xx number of years with Java though. We already had a micro-service like architecture, so the process of moving to a new technology is a bit more feasible than your regular monolith. So our approach has been doing one component (service/whatever) at a time and translated it to Kotlin, and doing some cleanup and re-writes at the same time. I don't recommend to use the Intelli built in converter. It is good, but if you have the chance I would recommend to clean up as well, which requires you to be hands-on. My team is about 8 people now, but we do work with several other departments and development teams.
Concurrency doesn't mean using more than 1 thread. Parallelism does. In other words Parallelism is concurrent while concurrency is not parallel.
You might want to edit the article anyway.
So it does! I assumed it required a context/container because they're always mentioned.
The Spring project is a collection of useful libraries. When people just say spring they're typically referring to spring DI otherwise they'll say spring data or spring jdbc template etc.
I did Scala for 8 years before Kotlin and you don't see spring there.
EventBus has its uses but it can quickly lead to overly complicated spaghetti code if you're not careful.
Which part do you mean?
Regarding the tag, that it doesn't quite work?
Working at a startup that does our services and some other tools in Kotlin and use coroutines very heavily. Ktor is nice for http, only issues revolve around having to wrap or reimplement blocking Java apis with coroutines, though the Stdlib does a lot of it and serialization which seems will be solved with the new Kotlin serialization library. Overall I‚Äôve really enjoyed it. Structured concurrency in Kotlin is pretty fun, albeit confusing at first.
I started working on an article enumerating the categories. I'll post it in this subreddit when it's ready.
having seen it in action at a large scale, event bus architectures are a really good way to get a bunch of separate (business) processes acting quickly on a large stream of incoming data. However, once those processes start putting messages back into the stream to talk to each other, all hope of ever debugging what happened is lost. Imagine if you had a centralized database in which you can't query old data because the schema and available indexes of each table is changing over time and at varying rates. Fun!
These are the slides from Kevin Most's KotlinConf talk last year. You can also watch the video [here](https://www.youtube.com/watch?v=w-GMlaziIyo)
Uber removed event buses from the Android codebase during the app rewrite(s) for precisely the reason you mentioned.
For anything like Uber the "event bus" is Kafka and the subscribers are completely separate processes.
Is that on the new backend compiler? I'm really interested into those compilers but not sure it's worth the investment till the new API will be published
The contents in the article work, you can try it out. I can't really change the tag because that would mess up the whole thing. I'll add a note to the article that that specific tag shouldn't be used.
You have 0.5MB by not utilizing Kotlin, because you don't need to bring in the std-lib. It seems like a reasonable piece of advice to me. That said I'd be surprised if proguard couldn't do a lot of work here to decrease that extra bit of bloat. (Does Proguard work for WearOS?)
When you are interested in an example compiler plugin, you might want to checkout my project [https://github.com/Foso/JK\_KotlinCompilerPluginHelloWorld](https://github.com/Foso/JK_KotlinCompilerPluginHelloWorld)
Cannot upvote enough. What's wrong with the `new` keyword anyway (and with kotlin, you can even skip the `new` :P).
What can be done with those? Is it in practice something like macros for code?
Yes. And Yes. If size is a concern, you should enable shrinking with permissive rules.
Why the hell would you want the ternary operator? It's exclusion from kotlin in favor of if-expressions was a great choice.
PREACH IT, SIBLING! And if it doesn't make sense lexically, then just DSL-ize it.
I think the OP also misused ternary operators in their post. Ha Intellectual ? will : understand Perhaps: basic_programming_xp ? ‚ÄúWill understand‚Äù : ‚Äúwhoosh‚Äù
While a rather funny post, it actually isn't a correct ternary since the case `true \`?\` "X" / ({ println("side effects") })()` evaluates the right hand side (which it shouldn't)
I'M DECEASED
Also pls post on /r/mandroiddev
I wonder if this could be used to make a real language server for Kotlin?
BURNary
So. This isn‚Äôt _the_ ternary operator. Sure. As far as ternary operators go this is pretty much the only one you see. It is the ‚Äúconditional‚Äù operator. It‚Äôs a ternary operator because it operates on three values (condition, true result and false result). But calling it ‚Äúthe ternary operator‚Äù would be like calling addition ‚Äúthe binary operator.‚Äù
Is this feature at top of your wish []
I got dizzy trying to read the code in OP
Can you tell my why you believe it was a great choice? I'm always sad when I want to write a `flag ? optA : optB` and instead have to write the long ass `if (flag) optA else optB`. Even if you personally prefer the second form, why the exclusion of the less verbose form? Esp. considering one of Kotlin's strength is the terseness.
1. In Java right hand is evaluated for true. 2. Your "Ternary" has to return string as well
Well the it is much more descriptive. I prefer readability over verboseness.
Can you elaborate why it was great choice? It always pains me in situations where I would have used ternary operator in my Java times. If there is a good reason behind this choice, it would make me appreciate it more.
Ohh I would LOVE some []
Imo it's a lot less cluttered without a bunch of mandatory keywords and the mandatory parentheses - often in a real world setting where a ternary/conditional operator would fit the entire thing on one line, with the keywords it would go over the 80 characters so I have to split it into like 3 lines and it's just... Unnecessary clutter. Especially if it's used as a parameter or sth. I guess if you've never really used the ternary operator you won't know why it's convenient. Still baffles me that people _celebrate_ the omission instead of just keeping both ways and letting whoever doesn't like the ternary operator use the long version.
I disagree that it's more descriptive. Operators can be just as descriptive as words, and often times are preferable to their wordy counterparts. Take equals for example. Java does string equality comparisons with .equals(). Kotlin could've easily made the equality operator in Kotlin `equals`, or just embraced the Java idiom, but both would be unnecessarily verbose compared to ==. &gt; &lt; == / * are all examples of this. Some other languages will use words sometimes in place of these operators (div, greaterThan, etc.) but that move from operator to word isn't an objective improvement. In many people's view (including my own) it can be a bad thing. If/else vs ternary is the same thing. And especially since Kotlin is supposed to be the Java+ language, it makes sense that a lot of potential Kotlin developers would already know the ternary operator as much as they know any other operator.
.equals() is not an operator and it is not just for strings. In java == will tell you if two objects are literally the same object in memory. Equals() is a method to use on objects that tells you if they contain the same values as member variables.
Well I have used ternary expression a lot, I just feel now that we have if else, why use another way of doing the same thing. But I admit that ternary is clean.
I can agree with what you are saying. I just feel that it makes more sense to use if else everywhere. Especially if you have longer expressions like: val x = flag ? // Bunch of code : // Bunch of code Compared to: val x = if(flag) // Bunch of code else // Bunch of code I find the second example easier to follow.
I am contracting for the largest e-commerce company in Holland and we're using Kotlin. 100% happy with it, nothing that doesn't work the way it should.
Honestly I'm 10x more excited that you are building your app without a runtime DI framework than hearing that you are builiding it in Kotlin. If I were given the choice between writing an app in Java with no DI framework and just about any other programming language but with Spring, I might still pick Java. The world would be a better place if the Spring framework flat out didn't exist.
Dependency injection is just parameter-passing. There is nothing more complex about it.
I'm missing this also. I'm currently using more `when` not `if else` as if else sometimes feel awkward when auto formatted ``` DataClass( property = when (expression) { true -&gt; "X" false -&gt; "Y" } ) ```
The new backend compiler is supposed to fix a lot of those issues. There was talk from one of the devs in the slack kotlin/js slack channel that wrappers around libraries like React would no longer be needed, instead just type definition files like with Typescript.
OP (Endtest) is spamming up tech subs, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus), [6](https://www.reddit.com/user/sa_vina_werner), [7](https://www.reddit.com/user/ihavelepower), [8](https://www.reddit.com/user/viorica_presedinte), [9](https://www.reddit.com/user/werner_sclavul), [10](https://www.reddit.com/user/basist_infect), [11](https://www.reddit.com/user/felix_presedinte), [12](https://www.reddit.com/user/werner_la_puscarie) ultimately in an attempt to make you pay money for the service he runs (endtest). [This is the kind of person you're dealing with here](https://imgur.com/xyfZ59P) Still want to give endtest money? **Vote and report accordingly.**
I agree for single conditionals. Chained ternary is the devil.
It'a kind of a poor name. It tests equivalence rather than equality. Kotlins === does the same thing. I think "equal to" and "exactly equals" makes more sense than the other way around.
What the fuck are you posting this blogspam for?
Within reason.. Variant returns on a generic function threw that for a loop... üòÇ Took a bit to fix it and ended up using a reified online.
Kind of rude to say that people would only disagree with you if they haven't used it. I disagree with you and I've used ternaries a **lot**. The vast majority of the time someone puts a one-liner ternary that wouldn't also be a one-liner if-else, it's sacrificing actually being able to understand what the hell is being checked/returned. Why are you doing so much logic in one line? Almost always there's an intermediate variable that should be there, or some other work that should be done on a separate line or in a separate function. That's why its celebrated that the ternary is not part of the language, because it follows the main point behind a lot of Kotlin's design decisions: to push you towards better, more understandable, more correct code. Also, fyi, the parentheses aren't mandatory. `val greeting = if(boolValue) "hello" else "howdy"` is perfectly valid.
I personally like it as it's just the language following it's own rules, rather than adding unique syntax just to save some space. Like, when I started Java I had no idea what these statements were that had a colon and question mark until I looked it up. In Kotlin, I see `return if (myVar) thingOne else thingTwo` and I already know what that does.
1. Both sides are evaluated. Because the operator is `&lt;T&gt; T.div(rhs: T)` rather than `&lt;T&gt; (() -&gt; T).div(rhs: () -&gt; T)`, both arguments are evaluated eagerly. 2. Function return types are covariant, so this compiles but the type of ``bool `?` "' / { Unit }`` is ~~`Any`~~ `Any?`, because OP has nullable everything. There's also the issue that for types that have their own `div` operator, e.g. ``bool `?` 1 / 2`` doesn't typecheck. Here's my shot at a fixed version: typealias Thunk&lt;T&gt; = () -&gt; T typealias Ternary&lt;T&gt; = Pair&lt;Thunk&lt;T&gt;, Thunk&lt;T&gt;&gt; infix fun &lt;T&gt; Boolean.`?`(tern: Ternary&lt;T&gt;) = if(this) tern.first() : tern.second() operator fun Thunk&lt;T&gt;.div(rhs: Thunk&lt;T&gt;) = this to rhs val tmp = true val w: String = tmp `?` { "is true" } / { "is false" } val x: Any = tmp `?` { "1" } / { 0 } val y: Int? = tmp `?` { 1 } / { null } val z: Boolean = tmp `?` { true } / { throw Exception() } // subtyping with Nothing type works too
Post discriminates against females. Down-voted
Ehhh, it's six characters difference. If that's the make-or-break for whether your expression is readable you're *probably* abusing the ternary operator.
You'd be surprised, a bunch of control flow statements (and therefore indentation levels) in, especially in the parameters to a function call or a constructor, the 6 characters is often what decides whether the expression can fit into the 80 char guideline or not.
It is more consistent with the language and it is easier to read. In cases where the difference in length matters, you should reconsider using a ternary in the first place.
Ya chained ternary is not a great use of the feature, I don't really even consider it because I've barely used it and if you do use it, its on you. The same way that people can put while(true) in places it doesn't really fit, but don't. As for the confusion, the elvis operator is pretty well understood, and AFAIK the language's grammar could support the ternary operator. That wasn't the case before but it's been like that for a while.
I gotta be honest, a bunch of control flow statements in the parameters to a function call raises an eyebrow, although I will concede I haven't seen the code so it could make sense in context. I usually actually assign these to variables though. Same result, and makes debugging easier if nothing else.
There's triple equal in kotlin? Never knew that, never needed it.
Ah you're right. I thought he meant it returned the wrong side. Both are actually evaluated. Did not notice that
I had a Java test last week and my ternary expression thingo was 144 characters lol. The teacher didn't mark it as wrong, but he might have been on the verge of killing me.
I once inflicted a multi-level nested ternary complete with elvis operators (just because the language had them) on some poor coworker who inherited my code. I mean, it started out as a sane expression, but after a while... well... did you ever see Akira? Sorry Kaneda. :(
Not sure about the line 1 but to understand line two you'll have to understand nullable type Try this[https://kotlinlang.org/docs/reference/null-safety.html] It's a 5 minute read
Line 1 is assigning the myName var to the myName var referenced in your databinding enabled xml layout, without doing this the var declared in xml will not be initialised. They don't need to be named the same and this is probably where the confusion comes from. You might use this convention to bind your viewmodel to your layout so you can access its public members in xml. Line 2 is just a nullable type which is covered in the basics of every kotlin guide, this is equivalent to if (myName != null) myName.nickName= foo
Pretty much.
Also, the \`nickName\_edit\` variable, which is not defined anywhere here, comes from kotlinx.synthetic plugin, which does the findViewById automatically for you and names your view by it's xml ID.
What are you talking about? Did you even read the entire post before making such a comment? I think the women employee should get more paid than man!
nickName\_edit was an editText view, how findViewById() is automatically done ?
Nested ternary is the most beautiful thing in the world
Thank you.
Reported I recommend others to esport this post too.
Positive discrimination is still discrimination and this post is is still positively garbage
I was hoping this was a joke, but it seems that it's not. Reported also.
Kotlin Android / Gradle automatically generates property extension methods that implement these. You should be able to find these somewhere.
The magic happens in your imports at the top of your file. You should have an import that starts with "import kotlinx.synthetic". This is what creates the binding.
Looks like it's a sponsored post.
OP (Endtest) is spamming up tech subs, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus), [6](https://www.reddit.com/user/sa_vina_werner), [7](https://www.reddit.com/user/ihavelepower), [8](https://www.reddit.com/user/viorica_presedinte), [9](https://www.reddit.com/user/werner_sclavul), [10](https://www.reddit.com/user/basist_infect), [11](https://www.reddit.com/user/felix_presedinte), [12](https://www.reddit.com/user/werner_la_puscarie) ultimately in an attempt to make you pay money for the service he runs (endtest). [This is the kind of person you're dealing with here](https://imgur.com/xyfZ59P) Still want to give endtest money? **Vote and report accordingly.**
The comments here are making me jealous. Can't seem to get my coworkers to budge away from Java.
I dislike this solution because it isn‚Äôt very idiomatic. Why not something like (free handed, excuse typos): fun &lt;T: Number&gt; List&lt;T&gt;.findDuplicates(): List&lt;T&gt; { val seq = asSequence() return seq.dropLast(1).flatMapIndexed { i, curr -&gt; seq.drop(i + 1).map { it to curr } }.filter { (a, b) -&gt; a == b } } // usage: someList.findDuplicates() You could single line and make expression this, but I don‚Äôt know if it would be more clear or not.
That can be drastically simplified using the standard library. I believe my solution is even faster (memory footprint should be similar) since it goes through the array twice, one after the other, instead of nesting the loop and causing O(n^2) in the worst case. fun IntArray.countDuplicatePairs(): Int { return this.groupBy { it }.values.sumBy { it.size / 2 } }
This is inefficient. The time complexity for your given solution is O(n + (n-1) + (n - 2) + ...) = O((n* (n - 1) / 2) - it searches through the given list and decreases its size by 1 on each iteration. You only need to iterate through the source list once. You can instead use a set to calculate the size difference: fun &lt;T&gt; getNumDuplicates(source: Array&lt;T&gt;): Int { return source.size - source.toSet().size } fun main() { val example = arrayOf(1, 2, 2) val numDuplicates = getNumDuplicates(example) assert(numDuplicates == 1) } On top of being faster with a time complexity of O(n), it is generic and will work for any `Array`.
How about making a new set of the collection, and return the difference in size? Am I missing something? fun duplicates(array: IntArray): Int { return array.size - array.toSet().size }
Because I may have misunderstood the prompt and thought that you wanted a list of duplicated numbers in the order they appear.
That produces a different result because the original groups the duplicates in pairs. If there are three duplicate items your solution removes one at gets a result of 2 while the original only gets 1. On the other side if a value is repeated four times you get 3 and the original gets 2 for two pairs. The method name "duplicates" is confusing I think because it actually works with pairs.
Maybe I misunderstood the requirement and they want the number of numbers that have duplicates, in that case, it's /u/TimtheBo's solution below
The one posted is O(n^(2)). This is more idiomatic and O(n). fun duplicates(array: IntArray): Int = array.asSequence().groupingBy { it }.eachCount().count { (_, n) -&gt; n &gt; 1 }
I think you're right. The fact that **it.size / 2** works even for odd numbers of duplicates 'feels' hacky but it works!
It's true, but it's also *really* common to just call it *the* ternary operator since it's often the only one in most programming languages
Yeah, this is more what I'd be looking for in a code review. (Unless we're looking for the total number of \*possible\* pairs, in which case the \`sumBy\` should be \`n!/(k!(n-k)!)\`) I can get us O(n) following the above logic, though! (sorry, I don't mean to flex, I just like \`fold\`) fun IntArray.countDuplicatePairs2*()* = this.*fold((*0 *to emptySet&lt;*Int*&gt;())) { (*numSeen, seen*)*, curr **-&gt;** when *(*curr*) {* in seen -&gt; *(*numSeen + 1*) to (*seen - curr*)* else -&gt; numSeen *to (*seen + curr*)* *}* *}*.first
&gt;fun duplicates(array: IntArray): Int = array.asSequence().groupingBy { it }.eachCount().count { (\_, n) -&gt; n &gt; 1 } This returns 4 for the array \`\[3, 2, 3, 3, 4, 4, 4, 5, 5, 5, 1, 5, 2, 5, 4\]\`, and the answer should probably be 6 or 20.
I do like clever fold usage! As for doing it in O(n): I think mine is already O(n), since groupBy and sumBy are both linear. The docs for groupBy doesn't state that, but I'm pretty sure that's the case. In your solution you have the Set minus and plus operations. Are you sure they are constant? Because if they are linear, your solution drops to O(n^2 ). That's maybe easily solved by using mutable sets that don't need to copy. It gets quite hard figuring out the complexity when you have to dig through implementation details to find it for each used function.
Ooh! Good catch! Yes the `+` causes a potentially n^2! (I‚Äôm usually more concerned about immutability problems over efficiency!) I‚Äôll leave it as an exercise to the reader to swap out the mutable list version like you suggested. Also your point about sum is valid, since you‚Äôre using arrays and not potentially linked lists, so yours is 2n at worst, which those keeping track at home can easily see is equivalent to n.
r/unexpectedfactorial
 fun duplicates(array: IntArray) = array.map { x-&gt; array.count { it == x } }.toSet().map { it / 2 }.sum()
Okay, I misunderstood the task. Others contents here have sufficiently covered how it could be done shorter, faster, and more idiomatically though.
Nothing to do with Kotlin.
You're experienced with Java or with game dev? Kotlin is probably not a good choice to learn game dev. It's not a popular game language and as such, there will be much less material than other languages. I'd stick to Java/libgdx and transition to kotlin once you've figured out the library. Or look for Java resources and figure out how it applies.
Tim Buchalkas company has a libgdx Kotlin course on Udemy taught by Goran Lochert , I'm sure there a few others on there as well. Goran is one of the makers of libgdx so he is very knowledgeable.
There is a good course on edx.org by the Harvard CS50 people that takes you from a simple game in Lua to building games in the Unity engine. As a ex-Android dev, you don‚Äôt want to be writing games in Kotlin. You will waste a ton of time optimizing your animations and doing things that are inherent in a game library.
It‚Äôs pretty common to do that because most people are taught by people that don‚Äôt know this fact. And then others reaffirm the name because they also either don‚Äôt know or fell into bad habits or don‚Äôt care.
You can use LibGDX and all of the java gamedev ecosystem on Kotlin just fine. It's super comfy. But OP, the JVM does have the annoying feature of GC, leading to GC pauses from time to time. If your game is reliant on high, consistent framerate, you might want a language like C++ instead. Probably overkill to think about that now though.
I've written a tutorial on the topic if youare interested. It is [here](https://hexworks.org/posts/tutorials/2018/12/04/how-to-make-a-roguelike.html).
&gt; Kind of rude to say that people would only disagree with you if they haven't used it. You reversed the implication there, if you read what I wrote that's not actually what I said. &gt; Also, fyi, the parentheses aren't mandatory. I meant the parentheses around `boolValue` in your example.
I would not say it's a great choice. While it's one less cryptic operator for the beginners, which I do think is better for everyone in general, it's just the same thing using english instead of symbols. Regardless of which option one prefers, I find the nagging for ternary instead of a-different-set-of-character-for-ternary petty.
&gt; You will waste a ton of time optimizing your animations and doing things that are inherent in a game library. Saying that like there aren't any solid JVM game engines / libraries? LibGDX, LWJGL, for one? The JVM isn't optimal for high performance games for other reasons (mainly the memory model) but that's a different discussion and not really a factor for most hobby projects.
You can use any game library from Kotlin so it makes no sense to choose Java over Kotlin if you can choose Kotlin.
Yeah I probably didn't express myself correctly, the thing is I'm not experienced with either, so I literally didn't know where to start. I think I'll just do the Tim Buchalka course.
Thanks a lot! I only read the first part and I know it's gonna be good.
I would take a look at Unity which had great platform support and Blender for creating models
That's great to hear! Feel free to join us on our [Discord Server](https://discordapp.com/invite/vSNgvBh) if you have questions!
Clean code should never be more that 2-3 levels deep anyway. If you have a bunch of nested control flow statements, you certainly need to extract some pieces of it into functions.
Add "android:importantForAutofill="no" if you don't want your EditText to support AutoFill (and don't use autofillHints at all). My app has minSdk = 21 and I don't see any warning with that.
It depends on his skill level. If he's a beginner, which I suspect is the case, he's gonna add a bunch of frustration around the tooling of he jumps right into it with Kotlin.
Kotlin uses the same tools as Java.
How is this related to kotlin?
Garbage language. Garbage IDE. Shills paying for awards. Nothing to see here people.
Okay, thanks.
Thank you.
Thank you.
Who pissed on your keyboard this morning, Mr. Grumpy?
Just look at his username. It‚Äôs not just this morning...
Refrain from looking at his history if you don't wanna have an aneurysm
Nice to near I really like all these static vm languages like kotlin java c#. I honestly think this is the future we should go. All have there strength and weaknesses. Still it's good to hear that one day maybe people will use decent languages not dynamic ones like js.
I'm using Koin for DI on a small/medium sized server backend, and Pippo for general REST routing.
it's a troll account
What a dissappintment of a person. Not surprised by your comment history.
üÖ±Ô∏èernary
Can someone link other award winners ? I'm interested but can't seem to find article other then from previous years...
Let's Encrypt won most impactful. PostgreSQL won the lifetime achievement. Source: was there.
FYI, here's the talk Abstract Kotlin was designed as a general-purpose programming language and with coroutines writing server-side code is a easy as never before on JVM. We'll dissect scalability and reliability problems of a traditional thread-based stacks and discuss the process of mitigating those issues by introducing asynchrony with Kotlin coroutines. We'll see how coroutine-based design naturally avoids common pitfalls of traditional asynchronous programming such as resource management, error handling and request cancellation, producing safe and reliable code using a concept of structured concurrency.
First meeting went well, now we need more people as we didn't manage to finish the beer last time and even though we didn't make it clear enough that there was a GF/V option pizza, it still got deleted. &amp;#x200B; Links added to the description, come along. Also looking for speakers, workshop/activity runners. Get in touch.
I can wait to get hand-on it, hands all over it...
I can't wait to get hands-on it, hands all over it...
Will the talks be in French?
It's literally in the post.
Most of them yes, around 80% french and 20% english
https://discuss.kotlinlang.org/t/kotlin-1-3-50-early-access-preview/13525
Can you show me the code that @Provides DatabaseCoroutineScope?
 class DatabaseCoroutineScope @Inject constructor( @Named("databaseCoroutineDispatcher") override val coroutineContext: CoroutineDispatcher ) : CoroutineScope and class DatabaseCoroutineDispatcherProvider @Inject constructor( @Named("databaseExecutorService") private val executorService: ExecutorService ) : Provider&lt;CoroutineDispatcher&gt; { override fun get(): CoroutineDispatcher { return executorService.asCoroutineDispatcher() } } and class DatabaseExecutorServiceProvider @Inject constructor( @Named("databaseThreadPoolSize") private val size: Int, @Named("databaseThreadFactory") private val threadFactory: ThreadFactory ) : Provider&lt;ExecutorService&gt; { override fun get(): ExecutorService { logger.info { "Creating database executor service with $size threads..." } return Executors.newFixedThreadPool(size, threadFactory) } private companion object { private val logger = InlineLogger() } }
That's awesome, thanks!
&gt; KT-21422 IDE can't import class from root package Thank goodness
&gt; ~~[KT-31826 Gradle clean task causes IDEA to lose kotlin scripting configuration](https://youtrack.jetbrains.com/issue/KT-31826)~~ Thank fucking GOD
I have simply ditched almost jpa framework. There is a library called Jdbi3. All it does is map your row from and to to your kotlin data classes. And I have different models for in and out. For example someTableInput and someTableOutput. For input Data class there is no id field. My colleagues say that it‚Äôs a bit too many models, but imo, makes my layers very clean. Other advantage is that I have control over my sql queries.
We use JPA with Kotlin. Our ids are setup as non-nullable vals with 0 representing unsaved entities and we have yet to hit an issue with it. JPA knows how to handle that setup just fine, so the only way you'd get a row with ID 0 in the DB is if it came from another source. I personally think any cost of not being able to represent a row with ID 0 is outweighed by the benefits of not having to deal with the nullability everywhere.
This is were I hope that Kotlin contracts might help. You could make id not null when the entity has been saved and keep it null on initialization.
Thanks for reply. I agree with you and always been using it this way. Tried to explain my team that we are owners of DB so we can choose the way we handle it and there should not be 0 id in db. Also they mentioned if new member come to project he would not understand why there is default id value 0 in entity..
&gt; if new member come to project he would not understand why there is default id value 0 in entity That's why comments exist
When I use JPA I use a non-nullable val long id. I rely on JPA using field reflection to set the correct value. No real for using 0 as an id in the database, and any real business logic operating on it would require the id to be set anyway.
Gradle build.gradle/kts use?
Unfortunately I'm only familiar with maven :/ But if someone familiar with gradle plugins wants to port it, it should be easy to do so.
I'd treat an id of zero is an unsaved value or an error if saved to the database. You could add a check constraint on 0 if you want to make sure nothing is saved as 0. I make every property either immutable or provide a default value in the constructor. Example: https://gist.github.com/proteus-russ/e0b3786bd79ccd82a509a129355d73ce
Cant wait for 1.3.50 officially, its annoying to lose script config!
Would a lateinit var with a private setter be an option?
[removed]
Good to know. I actually did not know it was aware of how to handle zero. I‚Äôve always used nullable.
I think it's great you're learning Kotlin and I hope these criticisms don't come off as harsh. * Kotlin has top level functions, which means you don't have to wrap functions in a class. Your class is just wrapping a filter method, which means it shouldn't be a class. * Where you *should* actually use a class, instead you are using a map. Using a data class for the concept of a book would make the code much more readable. * Any time you have a comment that says what a variable is (like \`// sales tax\`), it means you should actually have a named variable. * You should generally never use floats or doubles for money. They can't represent values exactly and errors will accumulate. * Kotlin typically uses camelCase and no underscores. Here's how I would refactor your code with all of the above in mind: ``` import java.math.BigDecimal data class Book(val title: String, val price: BigDecimal) fun main() { val books = listOf( Book("Kotlin", BigDecimal("20.0")), Book("Kotlin is really great", BigDecimal("10.00")), Book("Other Program", BigDecimal("26.00")) ) val totalWithTax = books .filter { it.title.contains("kotlin", ignoreCase = true) } .totalWithTax(BigDecimal("2.9")) println("Total price is $%.2f".format(totalWithTax)) } fun List&lt;Book&gt;.totalWithTax(percentage: BigDecimal): BigDecimal { return this .map { it.price } .reduce { total, price -&gt; total + price } .times(BigDecimal.ONE + percentage.divide(BigDecimal("100"))) } ``` I'm still learning better ways to do things in Kotlin myself, and I'm sure someone here could make this even better. Hope you continue on the journey!
One more thing that actually related to this article: " **Puppeteer** and [**Selenium**](https://www.seleniumhq.org/) are both popular, powerful and widely used solutions for automating web applications." Its like saying Ubuntu and Windows are both popular desktop OS's. Give me a break.
thank you very very much for your advice!
I think this could be improved a little bit: * the first book's price should have two decimal places but I guess this is a typo. * since `totalWithTax` is a single-expression function you can remove the curly brackets and the return keywork, replacing them with an equal sign * map actually creates a new list which isn't very good for performance. I suggest to replace the `map`\+`reduce` with a single `fold` which does the job better while maintaining readability. Alternatively you could add a simple `asSequence()` after `this`. The use of operators/functions of BigDecimal is instead a big mess. You're using: * a kotlin operator overload (`+`) * a kotlin operator overload, but as a function (`times`). The `BigDecimal` one is `multiply`. * a normal BigDecimal function (`divide`). The kotlin operator is `div`, but the implementation for BigDecimal is actually different and gives a different result for the current input. To be coherent you should either: * Use kotlin operator overload, but the normal function for dividing &amp;#8203; fun List&lt;Book&gt;.totalWithTax(percentage: BigDecimal): BigDecimal = this .fold(BigDecimal("0.0")) { total, book -&gt; total + book.price } * (BigDecimal.ONE + percentage.divide(BigDecimal("100"))) * Use kotlin operator overload only. You will have to either rewrite the extension function for `BigDecimal.div` using `divide` only (without any `RoundingMode`) or add a two zeros to the end of the percentage (e.g. "2.900" instead of "2.9"). The second one looks a bit tricky and also bad (what if you forgot the two zeros? no errors will be thrown and it will be difficult to debug) &amp;#8203; private operator fun BigDecimal.div(other: BigDecimal): BigDecimal = this.divide(other) fun List&lt;Book&gt;.totalWithTax(percentage: BigDecimal): BigDecimal = this .fold(BigDecimal("0.0")) { total, book -&gt; total + book.price } * (BigDecimal.ONE + percentage / BigDecimal("100")) * Use BigDecimal functions only. &amp;#8203; fun List&lt;Book&gt;.totalWithTax(percentage: BigDecimal): BigDecimal = this .fold(BigDecimal("0.0")) { total, book -&gt; total + book.price } .multiply(BigDecimal.ONE.add(percentage.divide(BigDecimal("100"))))
I thought my use of BigDecimal was messy, thanks for cleaning it up. I noticed when I tried using the \`/\` operator, it gave the wrong output but didn't actually dig down to find out why. Also I don't usually think about performance when I'm using list operations, so thanks for reminding me that it's important. I remember reading (this excellent article)\[[https://typealias.com/guides/kotlin-sequences-illustrated-guide/](https://typealias.com/guides/kotlin-sequences-illustrated-guide/)\] on \`asSequence()\`, but you're right that \`fold\` is the best option here. Thanks again for the input!
All the **super early bird** tickets are sold. Thank you ! We still have **early bird** tickets though. If you want your company to be part of the sponsoring, or if you wish to be speaker it is still possible. See you soon !
Why use this instead of parsing manually using JSONObject?
You should really probably use Jackson (or maybe Kotlinx): [https://github.com/fabienrenaud/java-json-benchmark](https://github.com/fabienrenaud/java-json-benchmark)
From a quick look, those benchmarks could benefit from reading this article to learn how to use Moshi properly. Notably absent is using the select API to avoid key allocation and using an actual Okio data source instead of just adapting an InputStream of bytes which requires extra copies.
 Better raw fx because I don't think tornado is keeping pace with openjfx
&gt; Singleton is very popular among the Kotlin programmer and unless it is necessary to create the Kotlin class we should stick to the Singleton object instead. If you use a singleton-object to calculate prices, and store a calculated value inside, you *clearly* don't know what you're doing, and have no idea about professional software development. Maybe do something with wood instead, and spare actual developers from having ever to see your code (and eventually having to fix it). At the very least, don't promote your shitty ideas of software development practices.
FYI, here's the talk Abstract So you know Kotlin, but you aren‚Äôt sure you‚Äôre utilizing it to its full potential across platforms? If you‚Äôre not sure about what Coroutines really have to offer or if you want to share your business logic between Android and other platforms, this session is your next step to becoming a Kotlin expert and your lesson on how to thrive in a multi-language world. In this session, you‚Äôll learn how to write a multiplatform utility class that can be shared between platforms.