A couple of quick ideas: (a) own subreddit for the bot, (b) only repost announce threads, ... (more ideas wanted).
I think your bot got shadow-banned at HackerNews, at least I don't see any postings: https://news.ycombinator.com/from?site=dlang.org I am actually impressed that the bot didn't got banned on reddit yet.
I don't actively use D, although I have played with it on a few occasions over the years. I'm still interested in following D, and (as qznc put it) since I'm using reddit anyway, it's convenient to be able to follow it here. But I don't care enough about it to set up an RSS client just to follow D.
For the record, I'm not one of the people who have complained. If the bot ends up being disabled, so be it.
First beta for the 2.071.2 point release. We've prolonged the 2.071.x releases to fix all outstanding bugs related to the 2.071.0 import and lookup changes before moving on to 2.072.0. http://dlang.org/download.html#dmd_beta http://dlang.org/changelog/2.071.2.html Please report any bugs at https://issues.dlang.org -Martin 
Check out the implementation of Node on a linked list: https://rosettacode.org/wiki/Doubly-linked_list/Definition#D
Now there is also in Munich a D Meetup Group. [1] We recently had an orga meeting with already 15 D-evelopers and decided there to do a monthly Meetup. Cannot be, that Andrei is visiting Munich and couldn't find any local D Meetup group over here. :) Today we announce our first official Meetup on Wednesday, the 21ths of September. [2] Topic is "D's Gems: Ranges" Speakers are Mario (Author of dunit and duml) and Dragos (Author of asynchronous). Would be awesome to meet some of you guys there as well. [1] Meetup Group: https://www.meetup.com/de-DE/Munich-D-Programmers/ [2] First Meetup: https://www.meetup.com/de-DE/Munich-D-Programmers/events/233057880/
I'm fine with giving it a try to disable the bot and see if activity here increases.
Hi all, There are two first [1] benchmarks for upcoming ndslice.algorithm [2]. Recent LDC alpha based on LLVM 3.8 and recent Mir v0.16.0-alpha3 are required. @fasmath syntax may be changed a little bit and will be simplified anyway. Dot Product: ndReduce vectorized = 3 ms, 314 μs ndReduce = 14 ms, 767 μs numeric.dotProduct, arrays = 7 ms, 260 μs numeric.dotProduct, slices = 14 ms, 782 μs zip &amp; reduce = 74 ms, 280 μs Euclidean Distance: ndReduce vectorized = 3 ms, 668 μs ndReduce = 14 ms, 595 μs numeric.euclideanDistance, arrays = 14 ms, 463 μs numeric.euclideanDistance, slices = 14 ms, 465 μs zip &amp; reduce = 73 ms, 678 μs [1] https://github.com/libmir/mir/tree/master/benchmarks/ndslice [2] https://github.com/dlang/phobos/pull/4652 Best regards, Ilya 
I wanted to run D on 3DS, but I ran into basically the same issue with the runtime. I was mostly confused with what the actual requirements were to run the runtime, since for the most part it looked like the 'Linux' portion was mostly stdlib code which would compile fine for 3DS I think.
https://code.dlang.org/packages/unit-threaded What's new: . Mocking support. Classes, interfaces and structs can be mocked (see README.md or examples) . Shrinking support for property-based testing, but only for integrals and arrays . Bug fixes Enjoy! Atila 
Hi, there is a new feature with the recent windows 10 update. You now can compile and run your linux apps (console only) on windows. The build script is working fine: curl -fsS https://dlang.org/install.sh | bash -s dmd The only thing you need is to install the build-essential package &gt; sudo apt-get install build-essential A simple hello world application is running fine. Network functionality not tested so far. Kind regards André 
You can probably use X, you will just need an X server for windows.
I decided to write up a think on untrapping exceptions this week: http://arsdnet.net/this-week-in-d/2016-aug-07.html Next week I'll prolly talk about calling D from Ruby. Last week, we had a status report from Stefan Koch on his CTFE engine. If you aren't already following this, every Sunday night or Monday morning, the little newsletter comes out with a snapshot of forum activity and about half of them have some kind of longer article or tip or other such educational content. The RSS feed (linked on the page) is also a single-page archive so you can search for old things there too!
&gt; I'm fine with giving it a try to disable the bot and see if activity here increases. Ping @ /u/qznc
That's probably a good thing, I only ever see bot posts here and there is almost never any comments. I wish more discussion happened here, voting could really help focus the discussion. 
I believe this will just kill the subreddit. At least with the bot running there's a chance.
Maybe the bot should do something different? Not scrape the announce forum, but the blog and "This Week in D"?
I guess encoding is just not a fancy/trendy topic to work on?
D is a great language for scientific programming, but based on forum postings, few new D users are aware of this project. Offers lots of functionality.
Yep, it's pretty awesome. I'm writing a library for molecular dynamics analysis (it's still a couple years from being presentable; it's just a hobby at this point) and I'm so glad I'm doing it in D. There's the performance when you need it, and the convenience of Python when you don't need to write something fast. The lapack bindings in scid have been very helpful! Really, for scientific programming, D is just about perfect. The memory management in particular is really smart. You can go ahead and leak the little things like ranges and format strings. You just have to worry about using that gigabyte array properly. The concurrency model is awesome, too. You can share (with some casting magic) that gigabyte array between your threads and they can all chew on it at the same time, but the actual communication between threads is very clean. Plus, when it comes time to move up to MPI, your algorithm is already thinking that way. And then there's the performance. `gdc` makes some pretty nice machine code, I assume because scientific code spends so much time doing floating point math on large arrays and that's what the C optimizer likes. I've been fighting a C++ library to solve the minimum bounding sphere problem, and the level of indirection is just astounding. It took me the better part of an hour to figure out how to iterate over a container for points. My solution required *two friggin typedefs* and a while loop that looked desperate to walk off the end of the container. In D, it would be `foreach(pt; pts){`. All I want for Christmas is a plotting library that works smoothly with D. Heck, I'd even take something as clunky as matplotlib. 
Why don't you combine use matplotlib then? It's really easy to call with pyd. Have a look at this simple [example] (https://github.com/libmir/mir/pull/261/files) - I really use this bridge intensively, so I have a lot more examples in case you are interested ;-)
I've also got my own project linking R and D. It's much more than just passing data between the languages, as it provides loads of statistical/numerical functionality, but unfortunately I don't have the time to turn it into a real project with Dub integration, Windows support, good documentation etc. Nonetheless it works great and I use it all the time. Here's the link in the event that anyone's interested: http://lancebachmeier.com/rdlang/ I would be very happy if someone were interested in helping with Dub integration, Windows support, etc.
I posted this because some users would like guaranteed TCO but may not know anything about this proposal. Discussion here: https://github.com/dlang/DIPs/pull/6#issuecomment-239691809
A few other options: [ggplotd](https://code.dlang.org/packages/ggplotd), [plotd](https://code.dlang.org/packages/plotd), and [matplotd](https://code.dlang.org/packages/matplotd)
Minor comment: Plotd is only the CLI interface to ggplotd
It's a shame that project management isn't one of D's superior skills - at least imho it's really hard to follow such long threads :/
&gt; Since the qznc's bot has been put in the basement I use Reddit as a vote system.. Nice idea! I like it, but you may have to modify the current options in Dscanner as it only has enabled, disabled,skip-unittest and if I understand correctly you probably want the user to define their own cutoff?
Seems nifty. So this is like a `std::unique_ptr` enforced through static analysis?
Afaik it is mostly inspired by Rust
Thank you! I'm sure these will come in useful. As for getting started, I have some follow up newbie questions: - Do I just download libraries then use dub to include them in the projects I make? (Still haven't tried dub yet, not at home) - Do I download the runtime binary or development library varieties, and what are the differences between the two? - What is JSON, what is it used for and do I have to worry about it yet? - Do I download bindings so I can use them in D? And I have the Visual-D plugin but honestly I've preferred running stuff from the command line and using Notepad++. I might look for a nicer text editor unless an IDE is strongly recommended.
You continue to be a well of knowledge, thanks. Do you mind if I ask for a bit of hand holding? I've been messing around, trying to get things to happen, but I'm going nowhere fast. Tried using dub, editing the dub.json and app.d files and building but it doesn't seem to be so easy. Let's say I'm trying to get [Tutorial 1](https://github.com/d-gamedev-team/opengl-tutorials/tree/master/ports/opengl-tutorial.org/tutorials/01_window) to work. I've downloaded the [dependencies](https://github.com/d-gamedev-team/opengl-tutorials/tree/master/ports/opengl-tutorial.org#dependencies) (at least I hope I got the right ones). Which files do I need to place and where? Does dub automatically download other things I need? Sorry to sound so helpless; this stuff isn't too accessible for those without prior experience.
This is not really my area, so unfortunately I cannot offer any help. The community for this subreddit is somewhat smaller than the official D forums. I'd recommend posting your question in [d.learn](http://forum.dlang.org/group/learn), which is very active. (No registration is required.) And yes, things could be made easier for the beginner, and they slowly are. Providing information about what you are struggling with will clarify which parts need more work.
Walter Bright is the creator and first implementer of the D programming language. He was an early developer of C++ compilers starting from the mid-’80s, including the first C++ compiler to translate source code directly to object code without using C as an intermediate, and has written compilers for ABEL, C, Java, and Javascript. He believes he is the only person to have written a full C++98 compiler by himself. Empire, one of the first computer strategy games, was written by Walter at Caltech.
Sorry, can't spend that much time on helping around :) Also you seem to be using Windows and I have literally zero knowledge how dependencies are supposed to be handled there. Try asking on http://forum.dlang.org/group/learn if you have more specific questions - folks are quite active there.
Oh, it's fine! It's nice that you've provided stuff I should be able to use soon. :)
Looks like there's no "other discussions" link provided here because the r/programming link is https and this one is http.
Actually, just finding any material on libraries is really hard. How does anyone learn this stuff! A lot of it seems to be using IDEs in C/C++ and linking libraries that way. I'm not sure what I'm downloading, where I'm putting it, etc. I'll be willing to buy a book at this point just to find out!
[removed]
UPDATE: I figured it out! I think? :P In case anyone else struggled like I did, here's a quick guide: 1)Make a folder where you want your project to be. 2) cd to that folder in a command prompt, and type "dub init", and enter what you want, but leave dependencies blank for now. 3) Download the library you need. To make it easy, download the (32-bit) binary. I went for glfw. Extract and inside is a lib-mingw folder, go into that and copy the glfw3.dll file and paste it in the folder of your project. 4) Edit the dub.json file and add the following: "dependencies":{ "derelict-glfw3": "~&gt;3.1.0" } 5) Then you want to edit the app.d file for whatever you're trying to do. In my case I just wanted to get a window up and running, so here's some example code for that: import derelict.glfw3; void main() { DerelictGLFW3.load(); glfwInit(); auto window = glfwCreateWindow(640, 480, "My Window!", null, null); glfwMakeContextCurrent(window); while (!glfwWindowShouldClose(window)) { glfwSwapBuffers(window); glfwPollEvents(); } glfwTerminate(); } 6) From command prompt, when you're in the project folder, type "dub" and DUB will build and run the project. Hope this helps someone. I think I will start a blog soon and try and have up-to-date tutorials. Wish I had more experience to be a real help but it's better than nothing!
This release has an epic story behind... (not less than __6__ alpha !)
Apologies if anyone thinks this is not sufficiently important to post here. I personally found it interesting and think it is a nice example of GtkD and creating a Dub project.
&gt; if this D array is not added to the GC and if this D array is no managed with expand / skrink, then soon or later the GC will eat it, leading to really weird bugs. This only happens for objects or arrays allocated with GC (`new`, `dup`, built-in array concatenation, etc.) - the GC needs to be manually informed about them by one of the methods on the [core.memory page](https://dlang.org/phobos/core_memory.html). That's what these containers do unless you disable it with the `supportGC` template argument. If you allocated the object/array with Mallocator, the GC will *never* delete it. It's mainly an issue when you want to use a library that allocates things with `new` instead of letting you pick the allocator. There's other reasons these containers can't be fully @nogc anyway: Exceptions and the `destroy` function.
http://forum.dlang.org/group/learn is what you're after.
I always found the [learn forum on dlang.org](http://forum.dlang.org/group/learn) to be really supportive and helpful. That's where I would go first.
about the 16 bit error: maybe you should use ldc instead of dmd
Agreed, there's a lot of things this ignores. Unfortunately I ran out of weekend.
Nice. Will have to give this a try. 
Forum announcement is [here](http://forum.dlang.org/post/owsuyantjedwudygfijq@forum.dlang.org).
Awesome, thank you.
Have a look at tkd (https://github.com/nomad-software/tkd). Works cross-platform and use tcl/tk under the hood. Also big plus is, that the source is pretty straight forward and easy to follow. The look&amp;feel out-of-the-box uses the native L&amp;F for each system, which is what I want. I had a bit of an issue on Mac OS X with the linking/building against a newer installed version of Tcl/Tk (8.6.x from homebrew; had to add some additional linker flags and a symlink) but otherwise no issues so far. Although, to be honest I haven't done much yet. Still learning and experimenting.
The SList can be used as a stack. Here's the [documentation](http://dlang.org/phobos/std_container_slist.html).
Thanks, If I'm understanding correctly "front()" is basically Peek(), "insertFront" can be used as Push() and "removeFront" can be used as Pop(). The other piece my C# code checks quite often is the size of the Stack via the .Count property. I didn't see a similar one on SList. I can track the length in a seperate integer variable easy enough but was wondering if there's something I've overlooked.
You can use EMSI containers. Their Slist has a length member. It's probably a flaw not to include it in phobos's one since counting with walkLength is not efficient.
[Github repo](https://github.com/libmir/mir-glas) [Dub package](http://code.dlang.org/packages/mir-glas)
that's impressive! i did not know D was capable of writing C libraries yet; when did that happen?
Since very early on D has had the ability to interface with C directly. Looks like they have gone the extra mile to ensure limited usage of druntime as possible so it doesn't even need that to operate.
[Forum thread](http://forum.dlang.org/post/bxuduoksgxmbjuwumumh@forum.dlang.org) [Background information](http://forum.dlang.org/post/nu8qq8$2i1a$1@digitalmars.com)
what does "HTTP server" feature or improvement means?
In case someone else comes upon this, the answer on the forum is [here](http://forum.dlang.org/post/mailman.42.1478858729.9448.digitalmars-d@puremagic.com).
Nope. It is of very limited use. For a lot of protocols and existing applications, you need to have a bit more than that. SHA2-256 and AES-128 are much more common (and better tested, and more performant) than selected ones in SecureD. SHA-1 and MD5 are also very common in many existing applications. True, this is very simple library, but I wish it would be better designed to support maybe object oriented (with well defined and documented interfaces) approach to different crypto components, so it is easier to swap them in application without touching everything everywhere. It is going to be a major pain to switch the code and stored data to something else in the future in compatible manner. Shouldn't the encrypted files have some sort of headers (preferably in 3 copies, 2 at the start and 2 at the end of the files, just to make it possible to receiver partial data in case of corruption). Also more importantly, it looks that the library doesn't support streaming, i.e. for encryption / decryption, or hashing. Docs are rather sparse, no documentation to speak of, or example applications. That can be fixed easily tho. But I am just cautious with crypto software. 
[Forum announcement](http://forum.dlang.org/post/o0d4g7$caf$1@digitalmars.com)
Assuming this talk will be recorded, I'd love to hear comparison of D's approach to memory safety vs. Rust's. I've been learning Rust lately and I'm finding its memory safety a lot more reasonable. For example: In D, I would always run up against shared vs. not-shared. I want to make a threadsafe Foo that implements Bar, but Bar didn't implement any `shared` methods so I'm SOL. In Rust, there's no need for that duality. If your interface declares const (&amp;self) methods, it's threadsafe. Mutable (&amp;mut self) methods can easily be used via a shared mutex. In D if I wanted to bypass the "shared" business and just send my objects to other threads to do some work, I had to resort to weird casting to/from immutable to do the send. In Rust, if I own an object and it implements `Send` (which most objects do automatically) then I can just send it through a channel without dealing w/ that. (Please correct me if I'm wrong or missed simpler ways of doing this in D.) :) 
the project isn't mine, you can ask majiang on Github
[Forum announcement](http://forum.dlang.org/post/hbyrabczrpjaeyspdntc@forum.dlang.org) - you can communicate with the creator of the library there [Documentation](http://docs.random.dlang.io/latest/index.html)
Rather a good thing, considering the amount of regressions that affected the 2.072 version.
There seems to be an emphasis on more frequent releases, but I'm not sure that's a good idea in the absence of a stable release. Regressions need to be rare.
[Forum discussion](http://forum.dlang.org/post/o2psvk$1m96$1@digitalmars.com)
Is it better than DLangIDE?
[removed]
[Forum discussion](http://forum.dlang.org/post/o4ji1p$p3r$1@digitalmars.com)
Very very good! 
I can't upvote, I'm again victim of a compiler regression. The 2.072.X front-end has been a nightmare for me. 
Why not use a perfect hash function like CHD? http://cmph.sourceforge.net/papers/esa09.pdf
At the beginning (made since almost a year) it was just a D script, I needed something simple, that worked. It's neither especially a fancy tech demo nor a portfolio repository or something else in this vein. Actually I've read very few about the topic, I'm not even sure to be able to found again the pdf where I've found the idea of using coefficients !
[removed]
[removed]
[removed]
[removed]
Thank you. I don't work at orange, why?
[removed]
`unittest {}` is good
[removed]
[removed]
[removed]
Forum thread regarding submissions for D talks at TopConf.
[removed]
[removed]
You shouldn't rely on the order of evaluation of the arguments in a function call: &gt; Order Of Evaluation &gt; Binary expressions and function arguments are evaluated in strictly left-to-right order. This is similar to Java but different to C and C++, where the evaluation order is unspecified... &gt; But even though the order of evaluation is well defined, writing code that depends on it is rarely recommended. **Note that dmd currently does not comply with left to right evaluation of function arguments and AssignExpression.** https://dlang.org/spec/expression.html So while there is a specified order, the reference compiler doesn't guarantee it will be honoured!
Got it. Thanks
[removed]
[removed]
404s now :(
WebFreak's code-d is a wonderful extension that I use on VS Code. I would highly recommend it for beginners. It uses the killer tools from HackerPilot in the backed. From the same author, there's another extension for vs code that supports native debugging on Linux. I've not tried it though.
the debugging extension is called native debug (id: webfreak.debug) which is also by me.
Yes, current D leadership seems to focus mostly on the language, and expecting that some other champion(s) might develop the infrastructure. But for some reason that is happening very slowly. Almost like we need another BDFL for that :)
Beautiful, thank you for sharing. I thought it was a great transparent look at the state of things and the future. I especially appreciated the desire to redo that one comment! I resonated with it - communication can be difficult, especially when under strain from life.
That's a bit harsh, but I see your point. I suspect all those esoteric (in newbie's perspective) features are to make library writing easy and fun. A "end-user" might not use all those features directly, but makes it possible to have more user friendly libraries, I guess. But yes, the infrastructure hasn't improved to a more polished level in the last 10 years. Makes people wonder if they have to wait another 10 years? That's like waiting a lifetime :) 
There's nothing wrong with difficult features that are necessary for things like library writing but the reaction to the suggestion of adding 'print' that worked like Python's print was ridiculous. That's the sort of easy feature newbies need along with guides to make starting with a language pleasant.
My preferred solution is to have a dscript mode for the compiler that adds things like that print function automatically, and adds other things when you import them, but doesn't require that you specify where they come from. Kind of a modified rdmd. It wouldn't be worth doing unless it were distributed with dmd, and I doubt that such a proposal would go anywhere.
Here ya go: http://pastebin.com/ArD9DXBq edit: oops, copying over to code-d's repo
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
This is the video I am referring to - https://youtu.be/4oDK91E3VKs (around the 34 minute mark).
&gt;The base language and standard library should work without the GC Precisely. I completely agree with your comment. In fact that is why I am quite excited about this announcement, but finding relevant resources/discussions/roadmap etc. is quite difficult (searched on forum.dlang.org), so I'm looking for some references where I can follow this news further!
&gt; if the same exact set of functionality and performance could be provided to non-GC code as for GC, then it would be awesome My understanding is that there is a little bit of functionality in the standard library that cannot reasonably be used without the GC (I don't remember which parts, but it has come up on the forum). My honest opinion is that GC-free Phobos is unlikely to happen soon. It will continue to be done piece-by-piece as individuals such as yourself contribute PRs. As with anything D related, folks will work on things they use for themselves, so progress will be uneven. I'm just a user of D and have no special information though.
This was a nice read, and I never realized that GC can only happen at allocation (I had always imagined it as a separate, temperamental thread that sometimes just interrupts your program for a while). It makes sense now, and now I'll write better code. I think this series will be very helpful for me as I use D to write code when I need performance (gdc works pretty well). I'm not interested in embedded, and I'm almost always working with a machine with &gt;64GB of RAM and using &gt;100MB of data (sometimes up to 50 GB of data). Knowing how the GC will handle my use case will be great!
There's [Andrei Alexandrescu's book, *The Day Programming Language*](https://www.amazon.com/gp/aw/d/0321635361/ref=mp_s_a_1_1?ie=UTF8&amp;amp;qid=1491618324&amp;amp;sr=8-1&amp;amp;pi=SL75_QL70&amp;amp;keywords=d+programming+language), which has been well received. Andrei is one of the language designers and joined Walter Bright pretty early in the process of designing D2, the current version of D. I haven't read it (I prefer online documentation and forums), and I'm unfamiliar with the book you mentioned (I'm mostly familiar with K&amp;R's C). Anyway, hope this helps!
It looks like two votes for Andrei's book. I think that helps a lot. I've read some blog post and seen conference lectures by him, and I think he'll help me on my way. This is far from my first language, but I'm looking for something C like, more expressive, but without much of the cruft in C++. I have high hopes for D. If this makes any difference, I'm a big Scheme/Lisp/Smalltalk fan, and I wrote my most recent serious code (Slackware customization tool) in LuaJIT with custom libraries in C.
You may want to also look into Go and Rust. I use both and find them to be nice. D is also nice, just find the one that fits your use case best.
Here a list of books about d. https://wiki.dlang.org/Books Ali's book is free, you can download and read. For the others you can check online previews!
I'm not sure I understand this... hasn't the complete source for DMD always been available for download? Is this just a licensing change and nothing more?
It's a licensing change for the DMD backend. It couldn't be included in Linux distributions and folks wouldn't contribute to it for that reason. It has no practical implications for the average D programmer.
Other posts answer things pretty well but I just read these posts that are more recent than both this post and its comments so I wanted to share as they are relevant: - https://dlang.org/blog/2017/04/28/automem-hands-free-raii-for-d/ - http://forum.dlang.org/post/lakqzdptnkohwiiekyhj@forum.dlang.org 
This subreddit is mostly for announcements. You may want to post at https://forum.dlang.org
From the [forum announcement](http://forum.dlang.org/post/axacgiisczwvygyefhwy@forum.dlang.org): &gt; I am pleased to announce the Lubeck linear algebra library for Dlang. It is very easy to use and it has been tested in real world. &gt; &gt; See the dub project example [9] to start. libblas, libcblas, and liblapack should be installed and defined in user's DUB configuration. Alternatively, user can install and link OpenBLAS, Apple Accelerate, ATLAS, or Intel MKL libraries. [Examples](https://github.com/kaleidicassociates/lubeck/tree/master/example)
From the [forum announcement](http://forum.dlang.org/post/cwnrtflamnmyatjwviad@forum.dlang.org): &gt; The site https://codefights.com is a place to test and improve your programming skills. The challenges include interview-type problems, shortest code contests, duels with other coders, monthly tournaments, and more. If you perform well, you can opt in to get connected with partner companies for job opportunities. &gt; Among available languages, there are C++, C#, Go, Java, Python, Ruby, Swift, and others. A few days ago, D was added to this list. &gt; After a problem is solved or a contest is over, others' solutions in all languages can be seen. To me, the major appeal of the site is that many of the problems are easy. So they take only a few minutes to solve, and the others' solutions are short and readable, often showcasing different approaches and language features.
This does appear to be for linux only?
I'm using windows (although I don't need this program). I didn't mean my post to sounds in any way negative, it's still interesting, it was just an observation that wasn't obvious from this post or the readme :) Thanks for posting!
This is a really good article, thank you. My problem with GC isn't GC as such, it's that it works 'by magic'. What I like about C as a programming language is that all of the language constructs compile to something where you can understand exactly what the machine does to implement your code. The same problem I have with "modern c++" is that too much of it works by magic and requires a clever compiler that hopefully generates some code that is efficient. In D it's GC that gives me that feeling. That I don't really understand how my code works in detail any more. This article helps with that :)
I'm currently on windows XD but i was using eOS before, so I wrote something quick. It served as a quick eye fresher when i leave the terminal.
That's pretty sweet.
w00t!!
thank you! You are welcome to send bugs to my eMail i wrote in the "read me.txt" added in the download package.
i don't have any installation routine. i'll consider one if more user stumble on this. :-)
btw you might want to look into ffmpeg library if you would want to encode visualization output to h.264 or something
The theme is a customized version of the naut theme. You can download it [here](https://u.teknik.io/Ahda3.zip). To apply it just upload the images and the css file on https://www.reddit.com/r/d_language/about/stylesheet/ I hope you will apply this theme so this sub looks more welcome to new users (changing the content of the sidebar would also help).
nnnnice!
There's more to it than that, as I uploaded the main.css file and the headerimg.png, and the result is as you see. Also, on the top of the right sidebar, the text is all messed up. The main.css file contains no image references. I think you sent the wrong one.
Does your main.css contain any references to the png files, for example? The one I downloaded does not. The zip I downloaded also contains headerimg.jpg which has nothing to do with anything, etc.
You're not measuring what you think you're measuring. If you examine the [assembly output](https://godbolt.org/g/JU24kr), you'll see that LDC managed to turn the second and third functions into no-ops, but wasn't able to do the same for the first. Force the functions to actually do something, and you may get a different result (e.g. have them each return a count of their matches; print each result outside of the timing code), because the compiler can't eliminate the function bodies in that case. Then you'll have a more honest test.
Thanks, I updated the OP.
I'm glad you did that. Still a decent result for the high-level code -- just not miraculously fast any more :)
Without Derelict i wouldn't have started with D, thanks so much for these user friendly bindings!
"Writing unit tests is easy with Dlang. The unittest block allows you to start writing tests and to be productive with no special setup. Unfortunately the assert expresion does not help you to write expressive asserts, and in case of a failure it’s hard to find why an assert failed. The fluent-asserts library allows you to more naturally specify the expected outcome of a TDD or BDD-style test."
This is an interesting example of D that's almost like natural language programming
coming this summer with version 3, update 3. Also available right now if you build the development version.
Zero cost abstraction in D would rather be static inheritance, compositions with structs and alias this, template mixin etc. because they give a kind of OO structure whithout the cost of virtual calls (vtable digging + implicit no inlining)
Also Non Virtual Interfaces (pre implemented interfaces methods)
Fantastic! Now all I need is a built in terminal so I can quickly jump to and from the editor. 
What do you need a terminal for ? The custom tools are a way to do what you would do in a command line, but with facilities to operate on any project or document thanks to the symbolic strings... (note that actually i may add a widget that has the ability to host external GUI applications, such as a terminal)
Passing custom arguments, giving input from stdin at different times, examining stdout, build instructions etc. Being able to interact with shell gives you great freedom imo. I always find myself switching to the terminal. It also reduces the chances to take your hands off keyboard to use the mouse. 
I see and actually there are already things that are possible. But initially Coedit was really made for me (and still). I actually added very few things on request but i'll try for the terminal 1/ It's the issues for a while 2/ A few years ago i found this to be useful in Geany for example.
yes
I asked admin rights to W.Bright yesterday, i 'd like to try to design the sub a bit like dlang.org
just the dman please
I think that the antenna on the head is required.
Other idea. upvote: __D__ downvote: __C__ 
yes but the default stylesheet is good as it is
No, you don't see the errors ?!
revert it to default
Look at this...http://imgur.com/TqVwOhh, this is how it looks right now.
It's aaaaaaaaaaaaaall fucked up man !
yes that's why revert it to default
if you'll take time to understand the problem instead of joining, proposing to ban me in irc and quitting before reading an answer because we can't seem to communicate properly, you'll understand it. i meant that if you didn't change anything, then why is it broken, shouldn't the all default style sheet be, you know.. default and working?
https://www.reddit.com/r/d_language/comments/6js5q9/custom_reddit_theme_for_this_sub/
&gt; Coedit was really made for me (and still) Oh. Okay.
Has anyone ever tried making an OSX build of Coedit at all?
A long time ago yes. It would require hardware + time to do it properly ( == money)...or a volunteer.
are datetime parsers coming to standard library?
It supports ISO formats but as far as custom formats goes, I believe Jonathan Davis has posted some ideas for how he wants to do it but as far as I know he hasn't done any implementation yet. I'd mention it on the mailing list so he gets reminded.
There's a post on the wiki of companies that use D. You'll probably have more luck on the actual D forums which are a lot more active than here. The amount of companies that use D is pretty small though unfortunately.
You are probably referring to [this](https://olshansky.me//gc/runtime/dlang/2017/06/14/inside-d-gc.html). It's a new development, so I doubt that there are any updates right now.
The link is [here](http://dlang.org/orgs-using-d.html). There is a "hiring" link for those companies with openings. Based on forum posts, there are other employers hiring D programmers that aren't listed there.
[Forum announcement](http://forum.dlang.org/post/osjrlfsfslmkivumdeoy@forum.dlang.org)
very nice
I thought it was time for a modern GC as well. Or is the GC going to be tossed?
The latest info about the GC is probably [here](https://www.reddit.com/r/d_language/comments/6j46ju/inside_ds_gc/). The GC will never be tossed, but it turns out that it's a hard problem to solve. A bigger priority is to make D usable without the GC. One of the three main goals listed in the document is &gt; 2\. @nogc: Use of D without a garbage collector, most likely by using reference counting and related methods Unique/Weak references) for reclamation of resources. This task is made challenging by the safety requirement. 
I just wish D would toss out the GC completely. Safety is way overrated in my opinion. I would certainly use Dlang all the time if GC were completely removed/the whole language made usable without GC.
Random side thought: I wish D was designed with `@unsafe` instead of `@safe` so not only would the programmer not have to remember to do extra to ensure safety, it would serve as a warning to others that the code in question is not bullet proof. But of course there is probably a good reason for this design thought up by people much smarter than me.
Nope, just able to compile legacy code if @system is the default. In this situation heading each module with @safe: is reasonable enough, just to bad it can't be done with nothrow or pure.
It's something that's clear in hindsight but wasn't at the time it was first implemented. Many D users, including the principals, would agree that @safe would make a better default. So would immutable for variables. But it's too late to change anything now so we have what we have. DIP 1012 aims to alleviate things a bit, at least for attributes, by making it easy to set default attributes for a module and to enable/disable attributes. Even if this particular proposal isn't accepted, something will be at some point.
You probably want to delete this post and try again. You've reversed the title and link.
http://forum.dlang.org/post/mnootvaiikmavypbghwa@forum.dlang.org
I have just posted my own experiences using GDNative using D. The focus is more on GDNative itself than in D, but people here might find it interesting anyway: https://stackedboxes.org/2017/08/20/trying-out-gdnative/
Tjgfjgfmyopr
Why is D subreddit quieter than the D forum?
dsfargeg
/r/ggggg
Uh sorry you are wrong here, C# has her own forum. And please stop locking the glass window. Thank you.
You need database client library to extract data from a database. Select [client](https://code.dlang.org/?sort=updated&amp;category=library.database) for your DB server and learn examples from the documentation. 
 double subtract() { double a = (Average_rating - Your_rating); return a; } this worked for me had to change column names to have no spaces and reingest
(You can use a function pointer or a delegate)[http://ddili.org/ders/d.en/lambda.html]
I seem to get cannot deduce function from argument types !()(void)
Not entirely sure what you mean particularly, sorry. Did you mean that the arguments look like they aren't functions? import std.exception; int[] binaryAlgorithm(int function(int, int) func, const int[] slice1, const int[] slice2) { //.. } 
It's the error that I get. I tried to make "&lt;" into a lambda function, and get "cannot deduce function from argument types !()(void), candidates are: file.g(int ..."
For that, you have to overload the `&lt;` operator I guess.
bool g(int[] list, bool function(int x, int y) f) { return f(list[0], list[1]); } void main() { g([1,2], (a,b) =&gt; a&lt;b); }
Essentially you need to wrap the `&lt;` in a lambda function
H or E?
D!
You can use D! ? How does it work? like this? : auto BusinessSolution = d!(WhatWasAgreedOn,Wishes[][],"noGC");
Anyone agree with me ? :)
It is pretty nice. GC could be better. One "issue" with D is that it kind of ruins you for bad languages, and it itself isn't *perfect* so I feel like long-time D users have a more skeptical view of it and programming in general because it makes you aware how much nicer programming *could* be, then doesn't *quite* 100% deliver. Still the nicest language I've ever used (that wasn't a language I made myself).
I'm interested a lot on language design and implementation. I wrote an extremely small language (like it didn't do much besides some maths and input and output - that's it; really basic) using D. I wrote a transpiler in it that would generate Pascal code (because why not). And then, because it was a "spurr of a moment thing" and not properly planned I then invoked, by hand, the free pascal compiler to compile the generated code into machine code. So that was fun. I also really enjoyed the data structures I created for doing the code generation. It was very fun.
No language is perfect. But I still like D :) hehe
What languages have you designed? I'm interested :)
Coding in the car was my challenge today.
My own thing is [Neat](https://github.com/FeepingCreature/fcc), though it's pretty much personal use only. It's basically a grab-bag of every syntax I could think of on top of a D-lite core. Good language intro is the [cheat-sheet](http://feep.life/%7Efeep/neat.pdf). Most significant feature that I wish D adopted is expression aliases, ie. `alias x = y+z;`.
Wow, expression aliases. I can see how that would be handy. Maybe you use a formula a lot all over your code like (calculating the mass or weight of something) and you don't want to repeat yourself. Now that's neat-0!. If I may ask. What is a "D-lite core"? What does that mean? By the way, that is such sexy documentation. How simplistic yet readable (yeah I know there ain't such a word but that documentation made my jaw drop (in a good way) - just like D's did so too).
Yay :) D-lite meaning that I copy the basic syntax and data types of D while staying away from some of the more involved features like the overpowered templates, contracts, ctfe... The really cool thing is that you can use expression aliases in structs. struct Rect { int x, y, width, height; alias area = width * height; } Also handy sometimes: int* pointer = new int; alias i = *pointer;
Ah I see, the pointer dereferencing one is pretty handy if you don't want to `*` your pointers all the time.
&gt;GC could be better. Can you elaborate a litte? I've come across a few murmurings of this, but no details yet.
There's been some work on fixing this but I don't know it's in the language yet. Last I checked, D uses a conservative mark&amp;sweep GC, meaning all threads have to be stopped to scan the memory and programs are vulnerable to false pointers keeping memory alive, ie. the compiler can't tell the difference between "an int member of a class" and "a pointer member of a class", so an int that happens to have the address of a garbage collected area of memory will keep that area alive indefinitely. The solution to this is to keep a complete runtime type map of every piece of data in memory so you can objectively tell pointers from nonpointers, which is entirely *doable* but afaik hasn't actually been *done* yet. (And may also allow for memory compaction, at least for data that isn't referenced in non-gc-visible memory.) At least int[] arrays aren't scanned as pointers.
yup. I'd love it if [automem](https://dlang.org/blog/2017/04/28/automem-hands-free-raii-for-d/) gets into the standard library though.
Ah, thank you.
&gt; and it itself isn't perfect so I feel like long-time D users have a more skeptical view of it and programming in general because it makes you aware how much nicer programming could be, then doesn't quite 100% deliver. Could you please elaborate on what in D you think could be better? What is stopping these parts from being improved? 
Next to Clojure, I feel like D is a glimpse of what languages *could* be, and we're just weighed down by so much inertia from established languages that we may not see a world of great languages in production for some time. That reminds me, a Clojure spinoff implemented in D with the D runtime might be great, if the GC were tidied up into a generational model...
Clojure is somethint I want to try out. As a Java user I really like that it uses Java bytecode as the compilation target as know the Clojure generated Java bytecode means the existing Java libraries and/or Kotlin can interoperate. I'm putring Clojure back onto my todo list.
But yes. D really does aim at being prettu much brilliant in my eyes. I recall watching a video where Andrei made a remark about Walter - saying that he had an eye for language design and hell yes was he right.
I agree that we are being wayed down by inertia of the current languages that follow the _standard formula_. D is beautiful.
Clojure is like the perfect counter-point to D: Bytecode-compiled, a Lisp descendant, dynamically typed, runtime metaprogramming (as opposed to D doing it at compile time), code as data, data as code, and my favorite feature which I miss in D due to static typing: Arbitrarily nested heterogeneous data structures. It turns out, representing the world - project configs, server configs, user files, save games, program states, calculation results, test data - as arbitrary nestings of lists and hash-maps and sets of all kinds of mixed data types is so natural that you long for that ability when you move back to static typing. I'm sure that there's research to be done in this area: Using D's metaprogramming and templating, I'm sure somebody can implement very natural and simple-to-use arbitrary data structures. But that would take a lot of runtime type checking, as std.json already has to do.
Fuck off !
You only discovered D a few hours ago. I'm glad you're enthusiastic but why don't you... You know... Write a few programs first? 1 program isn't enough to form an opinion on a programming language and just because something looks good doesn't mean that it's the best tool for you. I enjoy coding in D but I've been using Julia more often just because it works better for what I'm doing right now (physics simulation for my thesis). By all means add D to your tool kit but keep an open mind and never stop learning.
I might have discovered D a few hours ago, but I was looking for it since a couple of years. It might seem like I am over exaggerating, but it's amazing what you can create from the simple constructs of logic/code. Corporations have millions of lines of COBOL which is still running after 50 years. My application domain is pretty straight forward and I did browse through the documentation of D. For someone who learnt programming ten years ago, the changes in the programming eco system are immense, but sometimes you just want to have a programming syntax that works for you. Corporate Interest has turned programming into a circus!
What is your use case, by the way? Also, I am a filthy casual so I apologise if I sounded condescending
Just basic data processing and custom report generation. I can be a bit of an OCD in terms of picking things, but I blame it all on the times. Also, I was surprised that D has been existing since 2001 and it has less visibility in the market than C++11. I doubt any engineering schools focus on teaching it.(though I might simply be out of touch).
Maybe it's just too good to be true syndrome. People see D, see how amazing it seems to be and instantly get very suspicious. There's no way it can really be that good, there has to be something wrong with it. So they don't give it a chance.
I think it's more of a kid in a candy store scenario where the focus doesn't move away from what academic and corporate institutions use.
&gt; I was surprised that D has been existing since 2001 and it has less visibility in the market than C++11 I started using D in 2013, and it's been a great experience compared to the dozens of other languages I've used in the past several decades. I'm not sure it's useful to refer to the 2001 start date. My understanding is that for a long time it was mostly just Walter Bright working on it, and it would have been difficult to gain traction against languages like Java and C#. I've read that it didn't have the ecosystem (no IDE, for instance), the compiler was buggy, there were many breaking changes, releases weren't managed very well, the documentation was bad, there was a D1 vs D2 transition, Tango vs Phobos standard libraries, .... When I read all the things that happened in those years, I wonder how the language managed to survive. Now it is picking up momentum. Companies are starting to use it and it's getting a lot of use elsewhere (for instance, researchers using it for numerical work).
You could share this on the forum also.
Instead of "C:\Users\lance\prog\ldc2-1.4.0-win64-msvc\bin\ldmd2.exe", it is typically recommended that you would add "C:\Users\lance\prog\ldc2-1.4.0-win64-msvc\bin\" to the system path and then just call ldmd2.
Very nice work. I want to work on my own language but so many other things I want to do first :( Plus D is 95% good enough for me.
Loving DLANG to the point where I have to write in C++ for work and find it frustrating now. GC is great, it makes the code smaller, safer, sometimes faster and much easier to read and reason about. It's not always suitable though, and D does need a better story as a system programming language for when you need consistent latency and custom allocations. (But you don't need any of that most of the time). I like having the syntax for slices and the way string works, and being able to iterator over a tuple. And if I ever have to write a compile time expression in C++ I think constexpr.. ugh.. and give up but in D it mostly just happens automatically. And templates for anything but the simplest case in C++ are like writing in some alien language but in D it looks much more like regular code. And modules just work. And thread_local stuff has advantages and disadvantages but you can choose not to use it and probably it's the best default. I hated the distinction between class and struct at first as a C++ programmer but now I really appreciate the difference between value and reference classes. I like the copy and postblit thing too. And being able to assume variables are initialized to zero (or whatever) means that I can write code that doesn't need a constructor because I can design it so that zero values work for that. And writeln that can write anything out, and has a sane syntax unlike std::cout, oh and in fact being able to NOT prefix everything with the namespace to write safe code but being able to when you need it. unittests, static initialization blocks. Small things but they make things so nice. So many small things. It's like C++ done right.
It is like C++ done right. It is like the next C (in someway) (what C++ was meant to be).
I was originally going to talk about that, but it's not a straightforward task, and some R users may not know how to do it. Rather than get sidetracked on that (changing the path depends on the version of Windows and having admin rights) I decided to leave it in this form. My thought is that most readers will already know about setting the path and the rest are better off with a working example that doesn't require them to dig into those issues.
No worries.
Have you looked at [this project](https://github.com/SiegeLord/Tango-D2/)? I've never tried to use Tango and I've never done XML parsing in D, but looking at the repo, I see that at least some of the XML porting is done.
It looks like `subject.put(...)` blocks in the example on the readme. I don't understand why that would be desirable behavior.
&gt; SublimeLinter-contrib-dmd [1] is a plug-in for the Sublime Text 3 editor [2]. Unlike linters that are based on DScanner, it actually invokes dmd on the file that is being edited, as you edit. If dmd finds anything to complain about, an annotation is shown in the editor: warnings and deprecations in orange, errors in red. If SublimeLinter (a plug-in dependency) is configured to show tool tips, the error message pops up after a click on the annotation (see screen shots [1]). SublimeLinter offers shortcuts for jumping to errors and it is possible to postpone on-the-fly linting or lint only on request.
Has this repo been suggested to move under the ReactiveX group?
That's pretty neat. I'll have to play around with the restrictions of -betterC
Additional discussion on [the D forum](http://forum.dlang.org/post/lpzwgfoeukxmhtvdjgog@forum.dlang.org)
[Forum post here](http://forum.dlang.org/post/ipwuebubjeretprlgnpd@forum.dlang.org) Related: [Dub packages](http://code.dlang.org/) [Awesome D](https://github.com/zhaopuming/awesome-d) [Libraries and Frameworks](https://wiki.dlang.org/Libraries_and_Frameworks)
Sounds cool, but what does it do to binary sizes? 
Contract programming? Time to wikipedia!
Can someone describe to me what this paradigm is?
nice
Question is... does the car's internal computer use D?
Highly recommended update if used under Windows, but also two small additions for the Linux version.
Is there an instructional video on how to set things up for this ide? Tried it couple of times before, but couldn't get it working.
- setup [DMD](https://dlang.org/download.html) - under linux verify that you have the gtk2 runtime libs setup, + some gtk2 themes - run the program packed in the setup.zip - run Coedit (a shortcut is created on desktop for win in menu/devel for linux) - check [the compiler path](http://bbasile.github.io/Coedit/options_compilers_paths), correct if necessary - start making stuff... and [RTFM](http://bbasile.github.io/Coedit/)
Take a look: https://github.com/PhilippeSigaud/Pegged Also, it's a bad idea to call language or library as something else and very common, like a light-emitting diode.
will libled work?
&gt; libled If you mean 'libled' as name - yes, I think it's much better, than 'led'.
thanks will change it
Using DMD taught me to not be impatient.
DMD should be fast, how are you running it? Try replacing ld with gold to improve linking times.
I just ran "DMD main.d" from the console. I'll look into gold. Makes sense if it's the linking that takes time. Compiling hello world shouldn't take more than a second even for a horribly slow compiler.
or if you are on windows try compiling with -m32mscoff or -m64
There must be some relevant information you've not provided. On every computer I've used, including those 10+ years old, hello world compiles much faster than that. I just did a timing right now: real 0m0.186s user 0m0.152s sys 0m0.028s Even with a bunch of templates, which slow down DMD considerably, I can compile a several thousand line program in under 10 seconds.
I'm the exact opposite. I learned D and Go around the same time, and they both have insanely fast compile times. I'm now building some things in Rust and the compile times really suck (like 30 seconds to make a change when all dependencies are already compiled; 5 minutes with nothing compiled).
Oh damn. That is shit.
D is one of the faster to compile languages out there. If you want some humility, try using LDC or GDC, both of which are quite a bit slower (last I checked) than DMD.
const is used to declare constants, enum is a different kind of constant, it is confusing. In D the enum keyword does ~~two~~ three things, it either defines an enum type, defines a "manifest constant", or forces a function to be evaluated at compile time. These things are all secretly the same concept applied to different things. A "manifest constant" is a constant that only exists at compile time, the expression you use to initialise it is evaluated at compile time and it's value is basically pasted into every place that the constant is used, sort of like C's `\#define`, but with sane rules about scope. E.g. enum int x =5*3; //Later, in some function int y = x+ 7 //=&gt; int y = (15)+7 An enum type can be thought of as a list of manifest constants, only inside it's own scope with it's own type. e.g. enum dog_breed { LAB, SCHNOWZER, //... } // Later dog_breed doggo = LAB; // note that doggo can still a muttable type An enum function is evaluated at compile time, sort of like a manifest constant, but in a way that makes sense for functions E.g. Enum double times2(int x) { return 2*x; } //Later int y = times2(35); //=&gt; int y = 70 `enum` variables are one of the three kinds of constants in D: `enum`, `immutable`, and `const`. const is your usual "treat this thing as a constant", so for instance you can pass a variable as a `const` parameter. `immutable` means "this thing is really constant". This is functionally the same thing as `const` for value types, but for reference types it guarantees that neither the reference, nor the thing it's referring to can change.
yeah I've looked at some functional programming Aspected in F# but I think I like the look of D better
It's been a while since I've used D, but I don't think I would call it functional. It's pretty much "c+= perspective". You still write a lot of imperative code, even if D has accepted some functional ideas
well it's called it self a multi-paradigm language like F# is, this seems a lot more readable to me than F# 
ah, I always assumed F\# was mostly functional, TIL. 
&gt; The DUB package manager for the D programming language doesn’t yet support dynamic library dependencies. How do you roll your own while waiting for this feature to land? Let’s take a look! &gt; &gt; Let’s choose GtkD as our example.
I'm aware of two projects providing vulkan bindings for D ([erupteD!](https://github.com/ParticlePeter/ErupteD) and [dvulkan!](https://github.com/ColonelThirtyTwo/dvulkan))
RAII for betterC! Hurray! 
Words cannot describe my excitement for this
Looking back at 2017 on the D Blog -- what was new, and how the stats shook out.
I'm using erupteD and it has worked fine, no complaints.
If you're on Windows, try LDC instead. It's not exactly super-fast either, but in my experience DMD has been incredibly slow on Windows for some time now. I'm unsure if it's Dub (the version bundled with DMD) or DMD itself that's the source of it, but a build with Dub will typically hang for 5+ seconds on every dependency even if they're already up to date. With LDC, it's only 1-2 seconds, so it's much more bearable.
Instead of reading through that whole list of issues, I'll just try to briefly point out some of the shortcomings that _I've_ noticed with C++, and whether D solves them. 1. Standard Library * D's standard library is far better than C++'s standard library in terms of useful utilities. D seems to stray away from the madness that C++ has devolved to where everything is a template of a template that could just as easily be a single `for` loop, y'know? 2. Classes * It's been a while since I read up on the details of how D implements classes. Instead of speaking from memory and hoping it's true, I'll just implore you to read up on how they're implemented yourself. That said, the way that classes work in D seems much more pleasant to use than they are in C++. As someone who uses a mix of procedural C-style programming and a small bit of OOP here and there, D's classes just get out of the way, whereas C++ classes always seemed rigged. If you've ever used C# or Java, D's classes operate in a very similar way. * Another handy thing that D does with data types, although it's not restricted to classes, is that you can add a "method" to anything. `void test(int x) {}` ... `int a;` `a.test();` is valid D code. 3. Libraries * D has a package manager that takes all the pain out of libraries. Nuff said. 4. Metaprogramming * Metaprogramming in C++ is miserable. Metaprogramming in D is... okay. It's not JAI levels of madness, unfortunately, but it's pretty damn good. It all looks good. So let's talk about the downsides of D compared to C++. 1. Garbage Collection. 2. That's about it.
- speed of compilation. - type safe variadics. - modules. - value semantic for structs (postbliting)
Hmm.. That is worrying. I'm not a fan of GC, especially in game development
I'd recommend that you check out the options yourself instead of relying on what I said; I haven't used D in a year or more. That said, with engines like Unity dominating the gamedev scene, it seems that GC doesn't matter nearly as much as most would assume.
No prepreocessor, compile-time code is in normal D and declared using `static`. Module and import system, and it just works. Use it in any scope. Universal dot (`.`) accessor for namespaces and references. No `::` and `-&gt;` scattered everywhere obfuscating code with visual noise. The language is aware of iteration. One can define how `foreach` moves through a collection (or any data type) very cleanly and concisely, both in the definition and use. Overloading in general is much cleaner. Operators simplify to functions with well-defined parameters. UFCS (universal function call syntax). The first argument of a function can instead be dotted before it, as if it were a method. The parentheses can even be omitted if it’s the only argument. One can write `[12, 245, 9, 87].sort.writeln` and it will print `[9, 12, 87, 245]`, similar to piping or chaining in functional languages. As an added benefit, this allows one to simply define plain-old-functions that can look like methods of existing types. Over other OO languages, not necessarily C++, classes are not a requirement. You can have files full of simple functions and sum/product data types. Addition of `immutable` and `pure` takes a lot of the guess work out of knowing what is and is not stateful code. The compiler can help you enforce it, instead of having to use `const` as a crutch and work around its finicky behavior and exceptions. And as a huge advantage, a built-in GC. I find it a terrible complaint against the language; unless one is working in millisecond-critical real-time systems where collections are bad (in which case, disable GC and use smart allocators), the vast majority of applications developed today are not performance-bound by GC collections. Tilix is a great example of a GTK GUI program that performs so flawlessly, most people have no clue it was made in D.
As long as you have control over how memory is provided, you can completely avoid using GC in specific threads or regions of code. I've done projects with real-time audio processing on a dual-processor system running Python and a patched Linux kernel. Requirements were no latencies of more than a few milliseconds because it needed to do duplex processing. If things like that work in Python, I don't see why they should not work in D. Of course, controlling a massive, dangerous industrial robot or an air plane with such a soft-realtime system is a different thing. For things like that, I'd prefer Rust running on bare metal. 
&gt; Overloading in general is much cleaner. Operators simplify to named functions with well-defined parameters. Messy overloading seems to be one of the worst pain points the author of the linked post described, as well as buggy and messy interactions of different features of C++. One suspicion I have is that the "close to the metal, all mechanics exposed" approach of C++ works well with C and its pointers etc. But it does seem to work by far not as well as soon as several complex features (like, say, virtual functions, and constructor initialization, and exceptions, and RAII) are combined. Dealing correctly with these cases requires to deal with a lot of edge cases. A language like Java or Python does this without that the users note it. C++ can't, because it is too low-level, so it requires the developer to work around the edge cases or avoid them. That's how you get to things like the move operator and when to use std::move and std::forward, or when to use rbegin and rend and when rather pointer arithmetics on indices in loops, and so on. And at some point becomes knowing and dealing with the edge cases more complex than doing it all by hand. I haven't seen such serious problems but I have definitively seen large C++ codebases where even the lead developers were wary to change too much because they were afraid to run into a mess of inextricable issues. 
&gt; One can write [12, 245, 9, 87].sort.writeln and it will print [9, 12, 87, 245], similar to piping or chaining in functional languages. [ ... ] &gt; Addition of immutable and pure takes a lot of the guess work out of knowing what is and is not stateful code. The compiler can help you enforce it, instead of having to use const as a crutch and work around its finicky behavior and exceptions. Ah, that's something I wanted to ask - is it possible to define and use purely functional datastructures in D, like the ones Clojure has? These are containers, vectors or maps that are immutable, but elements can be added or removed by creating a new structure which just references the data common with the old structure. Of course, this has uses and abuses - it won't be a good idea to write a video codec based on that. For the specific use case of Clojure however, which is things like web applications, this works extremely well.
Persistent data structures back by tries? Possible, yes. It’d take some work, but D’s template syntax could potentially make using them very clean. The biggest hurdle is static typing. Data structures in Clojure are heterogeneous; that’s at least VERY difficult to do in D. There are some JSON libraries that attempt to make this work; I’d look at those.
&gt; No preprocessor, compile-time code is in normal D and declared using static. I wouldn't consider this an advantage, though. CTFE is awesome, but I'd like to have the preprocessor *on top of* that.
[I get this upon the first build with that command](https://pastebin.com/QDjW85TP) Hmm. I just noticed something weird. Release buillds are *moderately* fast. Like, about on par with a comparable project in C++. It's just debug builds that take forever.
Is it the first time doing release build? You can see it builds gtkd first. Dub init another project and it will be faster.
No, the first release build took like a dang year. I think it's a dmd thing, because even ldc2 builds the debug project at an acceptable speed, compared to the ~15s for a debug rebuild on dmd.
The #dbugfix campaign aims to bring more community involvement in selecting which issues get closed with each major DMD release.
The two main issues of GC with languages like Java or C# is that they produce a lot garbage in the first place and that the it runs in a separate thread that can kick in at any time. In D it is quite different, it is easy to write code which doesn't generate mcuh garbage. Secondly, the GC doesn't run in a separate thread and can only collect if an actual allocation is made, this means that if you write your program correctly, i.e. avoiding allocation the hot loops as is best practice even on gc-less languages, the gc will not be a problem. 
mixin, mixin templates and static if (and modules of course) make the need for the C preprocessor completely unnecessary. CTFE adds to that something that is not even possible in C/C++, using the same code during compilation and during runtime.
They don't though. They can't fundamentally change the language like the preprocessor can (unless you feel like spamming `mixin`). Look at comething like [libcello](http://libcello.org/). Yes, it's hackish and error-prone, but you *would not* be able to create something like that in D.
I looked quickly at cello. The thing is, you don't need this contraption in D, period. To say it quickly and provocatly, D is cello done right. Furthermore, changing fundamentaly the language with the preprocessor is not a feature it's a bug. It's not that I don't know the preprocessor, on the contrary, I used it a lot and introduced in old projects with other languages than C like in dBase III &amp; Foxbase DOS and in AutoLISP, the limited LISP language used inside AutoCAD. All these uses were to overcome limitations of the host language, i.e. there lack of manifest constants, modularity etc. The pre-processor is there to introduce meta capabilities, i.e. it is a pure compile time project feature. But its biggest shortcoming is its limited capacity to understand the underlying language it is applied to. Something so fundamentaly simple and usefull is not even possible: #if sizeof(long) == sizeof(int) the compiler has to pre define some magic macros or the project build tools have to define externally some other magic to get even this simple thing. 
Also import std.path : extension; if (args[2].extension == ".d") { 
I didn't see it for months because my deps are registered in a widget called the libman. It could have been broken for months, and now i'm 100% convinced that nobody use it ;). A few weeks ago there was also a serious REG discovered under window (click on message to go to source kaput).
[Documentation](http://jmdavisprog.com/projects.html) [Dub package](http://code.dlang.org/packages/dxml) [Forum post](https://forum.dlang.org/post/mailman.3481.1518413821.9493.digitalmars-d-announce@puremagic.com) [Forum post announcing the project](https://forum.dlang.org/post/mailman.3346.1518210956.9493.digitalmars-d-announce@puremagic.com)
This might result in a range violation if args[2].length &lt; 2
The sort of language features that you would use that require the GC are not the sort of language features you should be using in performance-critical parts of the code, which is the exact scenario where you would want the GC off. You can always turn it back on when you're done. Personally I haven't even run into a scenario where the GC was even a performance concern, let alone a bottleneck.
Granted, it doesn't do the *same job* as the preprocessor in that regards but seemingly changing the language like that is exactly the sort of thing that the D language designers were trying to avoid when they decided to use mixins instead of a preprocessor.
I wanted to use D for gamedev, but it seemed that the entire class system and string library were dependant on GC. Not sure if that's true still, or if it even was when I tried D out, but it certainly seemed to be the case. And, true, I've never seen D's gc have any performance impact, that's because I've never tried to do anything that requires performance in D. I know from experience that pretty much any GC will cause pauses when you're on a tight instruction budget to hit 90fps.
As far as I am aware, the way D does things, the GC will only ever attempt to run during a memory allocation, which is already something that takes a non-deterministic amount of time. I will say that I have programmed a (admittedly basic) game engine in D and that involved a lot of heavy particle effects that were created and destroyed rapidly, and it didn't seem to have any stutters or anything even when running at ~120FPS. Perhaps if you have tens of thousands of objects destroyed/created per second I could see this being an issue but I would hope whoever is designing the program would roll together some other sort of solution to account for that. Are we sure that the standard library is "dependent" on the GC, anyway? It sounds like you'll get memory leaks (which I assume would resolve once you turned the GC back on) but I'm not seeing anything stating that the functions won't work at all. Do you remember what happened when you tried it?
Nice. Small bug in section 8 documentation. In several places you're missing the % sign in the string "%(s, %)" =&gt; ""%(%s, %)". Also might want to point out that if you don't want strings to be quoted you can use the following format "%-(%s, %)".
Thanks. I'm not the author. I posted in the forum so that the author is aware of your comment: https://forum.dlang.org/post/svcknofqmtvwpncugmri@forum.dlang.org
Thanks!
[I made this](https://media.giphy.com/media/3o7WIywRo30JFsxVu0/giphy.gif) Pretty simple, it's just perlin noise, colour regions and a bit of vector magic.
In a moderately recent past i worked on a GUI library + a special runtime extension for it. In a more recent past i worked on a PL. Since the beginning i always work on the D tooling and i still do this, although, since my personal projects are dead, it's a bit strange to get on with enhancing something for which i won't get any benefice.
Trying out the new IR-PGO support in the [LDC 1.8.0 beta release](https://github.com/ldc-developers/ldc/releases/tag/v1.8.0-beta1).
Mostly: * no gc things (lifetime of GUI elements is deterministic) * RTTI based serialization (in order to save load the GUI from a script)
Nice read. nit: `--build=release` can be added to last command dub build --build=release --single allthepythons.d
What kind of statistical analysis? Have you been writing everything in D or calling existing libraries?
Just personal stuff as we don't use it for work, sadly :( Currently building a low level library on top of opengl so I can use it in a game I have floating around in my head. Should probably use an engine or someone elses bindings but this is the part I enjoy :P
Thanks for sharing this!
&gt; Going to via C99 made it so much easier to see that D took a different and offten better direction when it evolved from C. I came to D from C, not C++, and I think that's why my transition was so smooth. For year I avoided D because I wanted a version of C with useful features (like a garbage collector) not C++. Then I tried it out and realized it was quite a different beast from C++.
I started using D primarily from C++ and I gave myself a crash-course in the language by converting one of my existing C++ projects into D. I was shocked by just how much more readable the new D code was even without changing the overall structure of the code, and the resulting end-product was shaved down to 3600 lines of C++ code plus 926 lines of headers, down to just 3200 lines of D. 
Hm... reading your code, I can't see how thread1 should ever write to thread2.txt. I tested the same code on OSX, and it runs perfectly for many iterations. To answer your simple question, no you do not need to synchronize opening files. Looking at your code, I don't believe I see any bugs in there, it should work as you expect. My theory is that DMD 32-bit on Windows uses DMC libc, which may have a race condition bug or something in opening a file. I actually have seen the DMC libc source, and I can tell you that it's not my favorite. All the file descriptors are stored in a large array. Opening a file should be thread-safe, but a possible race condition could have both threads grabbing the same file descriptor slot. This would explain the exception as well, as both threads may try to close the same file descriptor, the second one will have an error. Try adding this in your code to see if both get the same descriptor: auto fd = fileno(file.getFP); This will get you the file descriptor (an integer) for the File struct. If they are the same, then you will see something like what you describe. I'll leave it to you to figure out how to prove this. You may have to play with where you put the "get the file descriptor" call (such is the nature of race conditions).
Hi yeah, thanks for answering. I also tried running it in WSL, and couldn't reproduce it there (although that was using ldc2). Seems you're right about them getting the same file descriptor: » rdmd abc.d 43ABB4 43ABB4 
I'm writing a highly-customizable GPU-powered software synthesizer where you can chain together different operations to get different sounds. The main core of the program is written in D while most of the mathematical heavylifting is written in OpenCL. 
It deserves much comments like your as well. Usually NG posts by guys who just have tried and want to share their summary or their "what-you-should-do" list, turn into huge, endless discussions and trolling (even if criticisms also lead sometimes to direct actions, i.e Pull Requests).
Maybe we can pull some of those discussions over here. The D development mailing list isn't really the best fit.
VST ? real time ?
&gt; VST ? I haven't done the necessary work to make this into a VST yet, but I can't come up with any compelling reason why it can't be done. Right now it is a standalone program that takes MIDI input and outputs an audio stream through OpenAL. &gt; real time ? I'm not knowledgeable enough to know what this means in this context, but it can certainly be played like a live instrument with an acceptably low delay (~4ms currently), if that's what you're asking.
yeah nice, 4 ms is good. Back to my audio time i remember i played with often between 5 and 11 ms latency in ASIO hosts (1000 / 44100 * 256 buff size). 512 buffsize for bigger projects.
Yeah, the synth is capable of playing 32 voices simultaneously at a 96Khz samplerate even on an Intel integrated GPU, when running by itself, but I'm still a little nervous about how nicely it will play alongside a DAW. I'll cross that bridge when I get there.
I understand, i made a VST synth once too (FM with FFT-based wavetable). 32 voices looks good. Also you'll probably have to setup a strategy for voice-killing and envelope generators (ie how to (or which) active voice to stole in case all are already active). 👍 Good luck 👍
Done! Thanks.
Yes, that would be great. I like the D forums. They enjoy an amount of cohesiveness perhaps due to their longevity. But reddit can be a good place to attract new users to D. 
Yeah, sure: https://gist.github.com/Morten242/a6af218e3f8aaf7fc765399dc01ac6a0 It's the same as reproducer.d with a couple of writeln's added. As you say, the file descriptors are the same when the error occurs and different when it does not. The hex numbers might be pointers to the handle given from Windows?
Oh, I see now that I somehow missed that you wrapped it in a call to fileno. Oh well. No problem, link me the issue when you create it. And thanks for the help. 
Well, with proper C++ knowledge u can do that with C++ too. The only difference is D comes with many batteries included: I mean I just completed a simple json based project with eaaaaaaaaaaaaaaaaaaaase (no external libs, and faster compilations of course) ! 10 glasses of smoothies for D!
A tentative PDF generation library https://github.com/p0nce/pdf-d with embedded fonts. Early. If someone wants to take ownership...
Very interesting work!
For live playing, 10ms is definitely something I can personally feel. It doesn't make it unplayable, but it feels awkward when you're playing something fast. The main problem with OpenCL calls in a separate thread is I heard rumors that on a Mac, OpenCL may not behave properly unless it is being run in the main thread of the program (or was that OpenAL??). The way the program is working right now I just have a ring buffer, and after we generate the samples, and we wait for the audio stream to be "ready" to accept more samples, we just feed them in and then loop. It doesn't get in the way as-is because there's no "callback", but I haven't looked into how the whole VST framework works so worst case scenario I can just rearrange a few tasks here and there.
You make valid points arguing about parts of your position but when your position is looked as a whole it makes no sense. 90fps is a target for VR games and to reach that level of performance you need data structures that are tailored to the use case then they are laid out in contiguous region of memory and used with algorithms that are friendly to modern CPUs. You would definitely not use run time polymorphism in that use case. D classes are designed for run time polymorphism so the fact that by default they use GC should not concern you at all because you wont use them in VR games anyway. The same can be said about most cases where D features use GC. You wont use them in high performance code anyway.
Right, my issue isn't exactly with the gc, although I take issue with it because it's inclusion allows for everything else. Really, the issue is that D encourages wastefulness. That's not always a bad thing, but for game development, it cripples the language. Sure, you can say that I wouldn't want to use D's class system if I wanted to hit 90fps, but then, why even use D? At that point, it's basically C but with a better module system, at the expense of having very limited integration with other high-performance C libraries.
The submission deadline for DConf 2018 is coming up on the 25th. If your talk is accepted, you may be eligible for reimbursement of travel and lodging expenses. Munich is a great city to visit for free!
http://dpldocs.info/experimental-docs/gtk.ApplicationWindow.ApplicationWindow.html seems to be down as of now.
its back now. I've been having a surprisingly hard time with this basic Apache setup... like it is serving static files, why does it keep stalling or going down? I need to check some stuff over.
This is a pretty nice. The default https://api.gtkd.org/gtkd/gtk/ApplicationWindow.html is very unintuitive in comparison. Bookmarked.
Very nice! Thank you for this. Am currently learning D and gtk ( coming from java/swing background). Documentation is always a wonderful fine thing!
There's a lot of things happening behind the scenes because everyone just pushes their own agenda and goals,so the idea is to know your biggest weaknesses and focus on them. What's wrong with this?
This is definitely a good step, no doubt about it. But knowing the poor management, I'm not tempted.
Things are changing! The survey is one of many more to come. The time it takes to complete it really will be well spent. 
Poor management in what respect? Things are definitely not perfect, but I don't see management problems, more a resource problem (money and manpower).
If you are interested in Dplug let us know what would be the challenge of making it work with it.
Right, but this is complicated by the fact that the "managers" are also the core contributors.
Something that is clear from the other discussions of this post is that C++ developers don't like guarantees. That may not be surprising. If they did, they probably wouldn't be using C++.
As it should. Reinventing basic wheels, while productive for new programmers, is ultimately wasted time and money for professionals. As many common idioms as is feasible should be included in standard libraries, and these days, build tools should have package managers besides.
The D Improvement Proposal process has undergone a revision to eliminate some of the inefficiencies and provide more clearly define the responsibilities of all involved. This post summarizes the changes and their motivation.
Does D really require a "DIP Process"? I don't know, but sometimes when I see D, it feels like Java, with absolutely not breaking backwards compatibility and DIPs being analogue of JEPs. I'm just saying it feels kind of super formal for a language that isn't being designed by a commitee and doesn't have tens of thousands of real life projects being deployed and maintained.
IMO it is necessary for several reasons. The most important is that the person proposing a language change has to figure out and then communicate what they are asking for. That allows discussion to take place. Once you know exactly what has been accepted, you know what needs to be implemented.
Not gonna lie but for a hot moment I thought DIP was Dual Inline Package and kept looking for the actual acronym in the article.
"In its work guiding the development of D and promoting its adoption, the D Language Foundation is driven primarily by donations big and small. The money comes in from different sources, the most visible being those listed on the website’s donation page, and is put to use in different ways. Today, the D Language Foundation is opening a new chapter in the donation story."
Cross post this stuff in /r/programming. We need more people to see the name D and say I'll guess I'll go look. If a cpp programmer spends 5 minutes on godbolt with LDC and looks a t the quality of the code it generates, he is going to come back for more. But he likely isn't following the D subreddit. 
So vibe.d didn't perform very well in the latest TechEmpower benchmarks. Have any of you done any performance testing with vibe in a web context? I would expect a D framework to perform in at least the top third, but i dont think it broke the bottom third. Which is disappointing because i love D.
Lol I was complaining about the new results. Didn’t even see those. 
I’ve been hoping this sub would catch on. Guess I gotta break down and get on the forums. 
I've done everything I can, but the forum is just part of the D community. Posting on the forum doesn't require registration. Maybe the forum is just too easy.
Welcome to the dark corners of this language :)
It's always good to see some traffic on this sub
It's actuallt copied from this [library](http://bbasile.github.io/iz/iz/sugar/SafeAccess.html), but D-Scanner is well suited for an experimentation (if you know a bit how are made an AST you should get).
This looks pretty cool.
DConf 2018 is coming up fast. The final pieces of preparation are soon to fall into place and then the day will be upon us. Already, we’re looking at what comes next.
That's great, thanks for sharing! :)
This is my solution for Windows support: https://github.com/yuce/droaring/blob/master/dub.json in case it's helpful to someone.
For a relatively niche language such as D, I don't see much point in fracturing the community between the [irc](irc://irc.freenode.net/d) and another discussion platform.
Someone could [setup a discord channel and plug irc into it](https://github.com/reactiflux/discord-irc/blob/master/README.md). I'd rather just use irc
I don't think it'd fracture the community -- I think you're underestimating the number of young programmers out there who don't use IRC. I think a D Discord server would do quite well for collecting those people in one place.
It's no possible to add actions and widgets for everything in an IDE. Coedit 3.6.7 for linux come with an integrated terminal that can be used for all the small things that miss and without leaving the development environment (remember the "distraction-less" fashion a few years ago ?)
I'm a die-hard IRC user, however "millenials" have asked me to host the support channel of #dplug in Discord and it has been a great experience. Think IRC + searchable history, multi-server builtin, corrections, etc. It all become documentation as you speak.
Awesome! Although I bet people can’t find it on listings because of the name.
I don't disagree, but the text does a good job explaining the situation.
The numerical table for the GUI section has me confused. A 5 means built-in and using native components? I buy that. 3 means you have to use external libraries? Okay, I'll buy that. But why does Go (which does not have a GUI toolkit or a de-facto standard) get a 4 when C and the JVM get a 3? I would have figured 4 means built-in cross-platform GUI, but without native stylings (which, sidenote, you can get).
Native cross-platform [Golang UI](https://github.com/andlabs/ui)
I've used it. It's third party via binding to libui. The question stands: why does Go get a 4 in that domain instead of a 3 like the other libraries that depend on external bindings?
Seamlessly integrated, maybe, but woefully incomplete. I tried it and had to give it up because I couldn't add an image to the UI (was building a gallery tool). I'm baffled that it can rank higher than Swing or JavaFX when libUI can't even display an image. I don't want to come off as a JVM fanboy. I like Go a lot, but I don't think it's reasonable to say that the UI support of the language is any better than C because if you want to do anything other than show a button and an input text you'll need to resort to GTK or some other toolkit. I would put Go at 3 for the GUI component because really, that's where it is.
[Forum announcement](https://forum.dlang.org/post/hwvhgikdduzsghrxctdc@forum.dlang.org)
Thank you for posting this.
[Link for Day 2](https://www.youtube.com/watch?v=0UZuRNujLGQ)
Will the recordings be available online somewhere?
[Link for Day 3](https://www.youtube.com/watch?v=e5HsyEnyvlM)
https://www.youtube.com/watch?v=e5HsyEnyvlM 
thanks!
More details in the [forum post](https://forum.dlang.org/post/rmqvglgccmgoajmhynogdldlang)
Nice. That is some serious magic there. How does compiler know what are the types of these lambdas, or are they untyped lambdas and compiler only instantiate them late ? Also, match_or_throw could be useful, that allows to pass less than all types, and throws if unhandled case is encountered. Also how is that different than variant types?
Author here. Thanks for taking a look at my project! &gt; How does compiler know what are the types of these lambdas, or are they untyped lambdas and compiler only instantiate them late ? `match` will accept both typed and untyped lambdas, and uses compile-time introspection to determine whether a lambda can be called with a particular argument type. For untyped (i.e., template) lambdas, it relies on the compiler's ability to deduce the template arguments based on usage. &gt; Also, match_or_throw could be useful, that allows to pass less than all types, and throws if unhandled case is encountered. This is definitely on my to-do list. &gt; Also how is that different than variant types? Conceptually, it isn't; "sum type" and "variant type" are synonyms. Practically speaking, `sumtype` has several advantages compared to `std.variant`, which are outlined in the README and the API docs.
&gt; How does compiler know what are the types of these lambdas, or are they untyped lambdas and compiler only instantiate them late ? For the lambdas where no types are specified, they're instantiated late, yes. The actual code is a bit more complex, but the basic behavior is this: switch (tag) { static foreach (i, T; Types) { case i: static foreach (fn; handlers) { static if (__traits(compiles, fn(value!T))) { return fn(value!T); } } } } &gt; Also how is that different than variant types? [std.variant.Variant](https://dlang.org/phobos/std_variant#Variant) and friends use RTTI (run-time type information), and doesn't always infer the right attributes for `@nogc`, `@safe`, `pure` or `nothrow`. `Algebraic` is essentially a thin skin on top of the much more powerful `VariantN` type, and that power comes at a cost.
So internaly these lambdas are actually template aliases?
 If (args[2][$-2:] != ".d") { Or just use ends with from library. As of why, string is basically char[] or ubyte[]&lt; once you take specific position out of a stringn it is a byte, not an array anymore. You cannot concatante it. You can do: if ([args[2][$-2]] ~ [args[2][$-1]] != ".d") { You might need to cast char[] because string is a bit different type actually.
Good version, well tested latest days with very long programming sessions. Comes with latest DCD too (released a few hours before Coedit).
A fun read, thanks :-)
Yes, you did a fantastic job as MC! Thank you!
Thanks :-)
Link is dead.
[https://iz.dpldocs.info/iz.sugar.SafeAccess.html](https://iz.dpldocs.info/iz.sugar.SafeAccess.html)
Brilliant! Although I do think that "just implementing" the C# syntax for this as a language feature would be better. It's less eye and mental strain if the syntax allows for easyer reading. It might also show up in the debugger and confuse the programmer. With this type construct it requires the programmer to unpack that the SafeAcess!T is a T which has a nullcheck on accessing. So I think a Nullable!T in combination with a ?. Is more usefull as an idiom. But this is the beauty of D and its community. Idiomatic solutions to fundamental software development problems which don't force the programmer to use one solution over the other. This is verry usefull and the real power of D.
I agree. D needs a true safe access operator, like C#, Swift and others. The D template i made is actually suboptimal in many cases. opDispatch is called for each element of the chain. Optimal code could only be generated with a new type of opDispatch which would pass the whole chain at once and then a true short-circuit could be generated.
Can you share a link to the video?
https://www.youtube.com/watch?v=kaA3HPgowwY
You should probably ask this on https://forum.dlang.org/group/general
Yes, the heavy burden of migrating from old to new while keeping the money flowing can become quite a journey. I also worked for a maritime company once, they used/ are still using C# for their projects. Needless to say the whole appliance runs slow as hell, every time I tried to optimise performance they 2nd level management criticised me for wasting my time. Now this pile of 'functional' code needs about 12 seconds to just start and present a login screen. One half of the problem lies in the programmers not taking performance into account when implementing yet another useless feature, the other in. NET sluggish virtual machine. Currently im porting my game engine from C# to D. In my case performance is not the reason for the porting. It's just that the way my engine works, It doesn't need the managed 'features' of the .NET framework, it's just useless bloat. 
&gt; Currently im porting my game engine from C# to D. In my case performance is not the reason for the porting. It's just that the way my engine works, It doesn't need the managed 'features' of the .NET framework, it's just useless bloat. I'm doing the exact same thing :D
The type of `peoples` is actually a hash table or dictionary with integer keys and Person valued. When you assign to the index you actually add an entry to a dictionary. If you declare peoples as a `Person[]` it will be an array.
holy shit im dumb, I forgot I did that to play around with the Hash Map (Dictionary as I know it in .NET land) now I get it. I thought it was legit Person[] peoples;, no key thanks!
No worries! Also if Person is a struct (as opposed to a class) I believe it will be on the stack unless you use new
another quick question - how do I convert an int to a string for string concat? override string toString() { return "Name: " ~ name ~ ", Age: " ~ age; } 
When in doubt use `to` from `std.conv`, e.g. `to!(String) (name)`
thanks, that was actually hard to google lol. I should fine a D lang IRC or something
https://discord.gg/7769Ruj
Yeah I've got that problem too when searching for D topics It's a google single letter thing It usually helps when I type 'D language &lt;topic&gt;' 
I believe that this issue was discussed in D community and the "proper" way to search for D content on google is using: dlang &lt;content&gt;
First place to go is [Ali's book](http://ddili.org/ders/d.en/index.html). Explicit conversions are discussed at the end of [this chapter](http://ddili.org/ders/d.en/cast.html).
Yo. First of all I strongly advice posting such questions on https://forum.dlang.org/group/learn since this subreddit isn't very active. For your question the answer is line 21: **Person[int] peoples;** (btw people is already plural, there's no "s" at the end). What you define here isn't a regular array but an associative array, also called hashmap or dictionnary in other languages. It takes a key (here of type int) and associates data to it (of type Person). So when you print its elements you effectively only have three because you have three keys: 1, 2 and 50. If you want to use an array you must use **Person[] people;** However, while arrays grow naturally if you append to it, it won't magically grow if you try accessing outside its bounds by doing **people[50] = me;**, you'll just get an error (and it wouldn't grow that way in C either, although you wouldn't get an error. You'd just get a bug). If you want to change the length of an array you can do the following: Person[] people; people.length = 100; people[50] = me; Hope that helps.
I like [std.conv: text](https://dlang.org/phobos/std_conv.html#text), it acts like `writeln` and is easy to remember. override string toString() { return text("Name: ", name, ", Age: ", age); } 
Point being a struct requires you to use braces to statically initialize it. Replace the two lines you suggested by: Point p1 = {[2, 1]}; Point p2 = {[1, 1]}; More info here: https://dlang.org/spec/struct.html#static_struct_init Note that above assignment works only in the same module Point is defined because double[2] p is private.
Ok, this is shorter than other solution, but it kinda is still annoying, that you need double braces. Would be awesome if you could implement something like an implicit cast on the Point struct for arrays of the matching type. I think I will go with a different solution for now. A constructor with 2 separate parameters should do the job.
You can get this behaviour by adding: this(double[2] d) { p = d; } But I'd probably advise against it - it's a lot less clear what's actually happening.
Personally I like the brackets. They signal Point is a structure, not an array. If you wish to get rid of them I would eschew using structures completely, going with `alias Point = double[2];` instead. https://hastebin.com/amitipolib
Actually that looks like a decent solution. I don't really get what is the purpose of the alias this thing, when you can call any function on them, that takes the type as first parameter, anyway. But would I be able to define operators like + for them that way?
Well, that is the default constructor anyway, isn't it?
``` foreach (i; 0..peoples.length) { write(i); } ```
It's not. The default constructor for a struct takes zero arguments and sets the struct to its `.init` value. [Source.](https://dlang.org/spec/struct.html#struct-constructor)
The alias this gets the compiler to say "Point" instead of "double[2]" in error messages. It is kind of nice when dealing with more complex types. No, unfortunately operators can be overloaded only for structures and classes. You could use one of the built in [array operations](https://dlang.org/spec/arrays.html#array-operations) which already do what one would expect but the syntax exposes Point as an array: Point p3 = p1[] + p2[]; Doing it the nicest possible way is not going to work: Point p3 = p1 + p2;
Ok, guess I'll just go with the struct way then. Two double parameter constructor should do the job. Thanks for the detailed explanation!
For a normal struct yes, but for an "alias this" struct? As soon as I introduce a different constructor manually, I have to provide the double\[\] constructor as well, as cast(Point) will no longer work otherwise.
`alias this` doesn't forward constructors.
Thank you very much, great work
Then why does `Point p1 = Point([2, 1]);` compile?
Awesome, really much better than the official documentation, when you are new to D!
It's a [struct literal](https://dlang.org/spec/struct.html#struct-literal).
Thanks so much for this. I am just getting into D, and I am looking forward to reading it. Update us when the print copy is ready, and I will grab a print one as well.
OK, that sounds right, but is this not internally using the constructor of the struct? Because when I define a custom constructor and try to do that I get an error.
It's more like a [compound literal in C](https://gcc.gnu.org/onlinedocs/gcc/Compound-Literals.html). You can't have struct literals of structs with constructors or static opCall overloads because the syntax is ambiguous.
Oh ok, I understand now, thank you!
Glad to help. :)
I believe this is a c++ issue. You got to implement the method like: ```cpp void wrapper::fun(int a, double b, double c...) {} ``` Do not delare and implement the method in the same location. Tip: use shared libraries and the tool `nm --demange &lt;my-shared-lib&gt;`. This way you see way better what symbols the compiler/linker exports.
Awesome, that solved it! Thanks a lot! (btw theres a typo, it should be "demangle" not "demange") I wonder why this is not stated in the docs, as not everyone who wants to use rust with C/C++ is a C++ expert. Additional tip for anyone who has similar problems: You have to link the libraries in the right order. From most specific to most abstract. For example if you want to use a certain library and also have a wrapper in C++ written on top of it to use with rust, then use these commands: [build.rs](https://build.rs): `println!("cargo:rustc-flags=-L lib_dir");` `println!("cargo:rustc-flags=-L wrapper_dir");` `println!("cargo:rustc-link-lib=wrapper");` `println!("cargo:rustc-link-lib=lib");` `println!("cargo:rustc-link-lib=stdc++");`
-i&lt;path&gt; is just a search path, you must also pass the sources located in the paths passed with -i (or the matching *.a / *.o)
Even if I run `dmd &lt;mainfile.d&gt; &lt;dependency1.d&gt; &lt;dependency2.d&gt;` it produce a segfaulting executable. Running it with `dmd -run &lt;mainfile.d&gt;` fails with code 11. The code is 100% correct as copying it all in one file does work fine. Syntax analysis does work as misspelling an identifier causes an error.
Sorry, my comment was related to the linking problem you ran into. I have no idea about the SEGFAULTs. For this you need to show code or try to reduce to a test case.
All fixed by now. TIL you can take the address of a method with the class-name and get back a function not a delegate which when invoking causes a segfault. This does only work with static methods. Was my mistake when renaming aliased imports.
Does coedit support dark (interface and editor) themes? I really can't find it anywhere.
editor yes, always, but full dark interface only on linux systems (depends on GTK2 theme).
BTW i take presets as PR without problem, considering that for now themes are a bit biased to what i like. Things happen [here](https://github.com/BBasile/Coedit/blob/master/src/ce\_d2synpresets.pas#L342]
The D Language Foundation hit its goal of raising $3000 to fund development on the D plugin for Visual Studio Code, code-d, and its supporting tools. This post explains where that money is going and talks about the future of the Foundation’s ecosystem funding initiative.
It's good to see that the rate of progress continues to increase. D is a good language on the technical side. We're now moving down the road of adding the polish that is needed for widespread adoption. Thanks to Mike for all the work he put into this. This administrative work is not fun (well, at least most people don't like doing it).
Huh... Two of my favorite hobby languages...neat
Is DPP new? First time I've heard of it.
It's been around for a few months.
There isn't much you can do about this for now, but you could create a temporary directory (/tmp) where these build files can get saved to. This eventually needs to be fixed in dub though :/
Ok, that sucks. But for now the temporary folder solution would be ok. How do I do it? Simply creating the temporary folder doesn't do the trick (obviously). Btw: In my project I have a .dub/ folder and a build/ folder in it, I guess that code-d created these? Can I use this folder as my temporary?
Symmetry Investments is funding three university students to work on D from September to January.
[Forum announcement](https://forum.dlang.org/post/ahrhaxthdppkubgwwakq@forum.dlang.org)
I never had that kind of free time in university but this sounds like a really interesting program. Props to your team for getting this going. I hope it's a success. 
Glad to see this program. Is there any chance for a graduate who is familiar with C++ but not having much production-level D experience to get involved? I have some free time this autumn.
&gt;The lucky student will also be eligible for **a free pass to DConf 2019**, with travel and hotel expenses provided. Since the committee chooses based on the work, shouldn't this be "the most eligible student" or of the sorts?
I'm not involved with this. Just saw it posted elsewhere and thought it was relevant on the subreddit.
I ran into some difficulties getting things to work, so I decided to post my writeup here, in the hope that someone might find it useful.
They mentioned mentors. I think they will accept c++ as much of it is translatable to D
Yes, there's a chance. We expect the project to be primarily in D and will give preference to those with strong D experience, but that does not automatically disqualify those with less D experience.
SAoC is now open to anyone 18 or older, with caveats. Please see the forum announcement in the link above for details.
There are numerous companies that use dlang in production. There is a display of them on Dlang.org There are still "problems" with the language and the standard library as they currently exist, but so does every language. If you want to know how good or bad it is in D, You might have to do some research. The forum.dlang.org forum is a very mature place to get started with that. As far as language capabilities, D offers quite a few features in such a way that it is a nice productive language if it fits in in your development environment. Although it can be difficult to get a DE to your liking up and running.
I wax able to set up d and use it with vs2017... and it was very easy 
D is fine for production. But my advice is that when you start developing your project, select a specific release of D (say 2.081.1), and ensure that you keep a copy of that compiler version along with your other project files. I have one D application in production. (It's not a huge-scale project, but D and the vibe.d Web framework were an excellent fit for the problem, and the project has been a great success.) One year in, I found that when I updated my D compiler version, I had difficulty building the code (which depended on several third party packages, including the vibe.d packages). Minor version changes in D can propagate very easily into build errors in third party libraries. You can keep a copy of the D compiler toolchain in any subdirectory; it doesn't have to be "installed" in an official location in order to work. So to simplify the maintenance of your project, I suggest adding a "compiler/" subdirectory, putting your approved D version in there, and using that to build your project. You can always test your code on newer D versions, but at least this way you can still build your project with a single "make" for years to come without any headaches.
What you describe was unexpected and unfortunate. Vibe is tested for each new DMD pull request (in something called the project tester, a CI that builds and tests dozen of 3rd part projects) but for some reason Vibe had to be deactivated and the breakage was not detected.
That's a shame. To be clear, my project is a couple years old, it's not using 2.08x. I don't recall for sure whether the breakage was in vibe-d or another package... I just think that being prepared for breakage is a general principle that anyone deploying a D application should be mindful of. D is great language to work in, but the pace of change needs to be considered in your maintenance plan. It's not like dusting off a 10-year old Java or C program, and being pretty confident that everything will still compile on the latest toolchain.
It depends on what you define as "serious large scale project". There are a lot of projects that are built in D and work very well. Some shortcomings of D. The standard library depends on the garbage collector. You have very good control over it and you can write critical code without it. But you will have to learn some special traits about the garbage collector anyways. So I would guess this may become an obstacle in any serious project. On the other hand the same is true for any other environment. D has a very vibrant open source community, that created a huge ecosystem of libraries. But not all of them are very well maintained. So there is a chance you cannot find a good library you need or you may have to maintain it yourself anyways. Depending on the type of project you are planning, this might or might not be a show stopper. The other big downside for large scale projects is lack of experts available. You will have to fight for the few experts that know D very well. I would not bet a million dollar projects to developers that just learned D. On the other hand if you a willing hire such experts, you can be sure they love D and will push your project through any rough situation. Even a Walter Bright or Andrei Alexandrescu are not very far. But if you need to scale your project to 100+ developers, you will have a hard time to find enough experts to mentor them all. If you really benefit from the advantages of D, that no other mature language provides, and you can live with the caveats, go ahead and use it.
&gt;dusting off a 10-year old Java or C program, and being pretty confident that everything will still compile that assumption is very optimistic ... the languages might not have changed that much, but the libraries do change a lot in 10 years D is not special in this respect; in any language you work you expect some trouble when upgrading to a more recent version: that includes Perl too after 5.20 anyway, I have code from 2015 which compiled fine in early 2018 if node/javascript code is ready for production then D v2 is ready for production too, and also Dv2 compiles faster too ;-)
&gt; I would not bet a million dollar projects to developers that just learned D. yeah, but your company bets more money on developers that just learned ES6 or Python 3 D v2 is easy to pick up. You might know Java and you'll use it like you used Java with lots of classes and static methods, or might be a Perl developer and you'll abuse pure functions because you always dreamed you had them in Perl, or might be a C++ dev and go crazy with the templates, but there is space for everybody. 
I don't think that it is wise to use D in production currently. My problem with it is that * debuggers are hard to find and/or buggy - I didn't manage to confige one debugging eclipse plugin so it uses external d libraries (stored as files) in a project. I know that this is a failure on my side but it's not a good sign. It is just not well usable like debugging in IDEA(ide) or Visual Studio from Microsoft. * The compiler stills seems to be buggy - I had a case of some internal crash when using a combination of string mixins and templates - but I lost my code Just do your research (how to debug, how stable is the compiler for the setting, etc). I really really like the language but there are still so many shortcommings, since years without end. It doesn't help if "small" people are using the language just for hobby purposes - it doesn't cut it!
[Forum announcement](https://forum.dlang.org/post/wpobpyqbckwypjduvbux@forum.dlang.org)
Please stop bringing up library changes. You're not at all getting what I'm saying. Take a C codebase at a particular version, including all of its dependent libraries *pinned at specific versions*, such that it compiled fine on a 15-year old toolchain. Now take the same, identical codebase (including the *same, identical pinned library versions*), and compile it all with a modern C compiler on the same architecture. Chance of successful compile: extremely high. Repeat this experiment with a D codebase, and the specific, pinned library versions it depends upon. Chances of successful compile: significantly lower. And this is why I suggested that the OP stick with a specific compiler version. I don't see why this is do difficult to understand.
Summary: Introduce a bottom type which is a type that has no values. The primary purpose is to specify the return type of a function that does not return. Rationale: Being able to specify that a function does not return has advantages: * Smaller/faster code - no stack cleanup code has to be emitted after such calls, no registers used on that branch need to be preserved, variables not used on that branch will not be marked as 'live', variables reassigned on that branch will not affect other branches. * Makes it easier to reason about the code by simplifying control flow. * It's necessary to be competitive with other systems programming languages. * RAII cleanup, scope, finally, and catch clauses need not be generated for such branches. 
Oh I see. Thanks! :)
A slice is a (pointer, length) pair, that's all. It doesn't imply anything about allocation: the slice can reference memory on the heap, stack, or a static region.
Oh ok, so doing **a\[\] + b\[\]** is really the same as what you would expect from **a + b?** Still it feels kinda weird to have pointers involved when performing an addition with a value type.
You can create a struct or class template depending on if you want them to be value or reference types and the do operator overloading. To better optimization give AVX instructions a try when implementing.
That makes sense. The C++ analogy really helped me, thanks for that. However I guess there is no way to 'optimize away' the unnecessary syntax clutter (the \[\]), right? 
This sounds like a good option imho, but I am not sure how to do this. Would it be something like this? `struct vector3D { double4 coordinates; alias coordinates this; }` That would mean that the 4th element is unused, but that doesn't really matter, does it? 
Hah! Got it! When I use double4, then I can write a + b like I want to, no need for any struct or slice at all! That's awesome!
UPDATE: I am now using double4 from core.simd. With this I can write **a+b** and it works just like I want it to. I am just a bit worried about this compiler message: **Deprecation: 32 byte vector types are only supported with -mcpu=avx** But why would 32byte vectors be deprecated, while 16byte types are not?
Another update: What the heck is wrong with core.simd.double4? `double4 a = [1.0, 2.0, 3.0, -1.0];` `writeln(a);` gives \[1, 2, ***0, 6.95336e-310***\] What the hell is going on here?
Update: Seems to be a dmd issue. With gdc and -mavx everything works as expected.
That looks pretty nice. I'll give it a go.
I don't know what you are talking about. Article looks ok on Chrome. Note that I use a very immature blogging platform though, this might be the problem. Can you send screenshot ?
Should work now. It was a bug in the publishing platform, fixed by the author a few mins ago.
Make an array of entity then you cast to know the derived type
This is basic OOP, nothing speicifc to D: [https://run.dlang.io/is/y6sd5r](https://run.dlang.io/is/y6sd5r)
Also with virtual methods, cast are often not useful, e.g in the case the method exists in the base type. The most derived overridden method is automatically called, even if the variable is not of the most derived type.
I see three approaches you can take here: 1. Create an array of Objects. This is more quick and dirty style. 2. Create an (abstract) base class for all your game objects so you can have direct access to a common set of attributes directly. Might be pretty good but depending on how your class hierarchy looks it can get difficult as D *only* supports single inheritance (restructure your class tree?) 3. Make all your game objects implement a common interface. This is like 2 but you have more flexibility with your types but ofc no access to attributes (only methods) and you expose internals.
You can use all C/most C++ without overhead. So there is less need to **rewrite in xxx**.
I need to talk to mssql. How do I do that in D ?
There are plenty D, C and C++ options. I would look at DUB first https://code.dlang.org/search?q=mysql.
Because very few people use it. The language is great but a small community can do only so much. Why is the community so small? I don't know. I guess alternatives like Rust/Go have saner defaults and corporate support to push it forward. Nim has a small community as well. But D vs Nim, I don't know.
I'd say that it fails to attract a younger generation that's almost fully turned toward web devel. As an observer since 2013/2014 i can clearly say that it's not decaying at all... maybe the growth is a bit more shy than the one seen in the PL you quote (Nim for example got attractive very quickly).
I would need to read on how to use a C/C++ library in D to use mssql. Thanks!
Yeah many.
Essentially you write `extern (C++)` in front of a function. There are some other quirks here and there. Please refer to the official documentation https://dlang.org/spec/cpp_interface.html.
Well, here's what's been showcased on the blog: [https://dlang.org/blog/category/project-highlights/](https://dlang.org/blog/category/project-highlights/)
Hey, just as I've started implementing my own pet language project in D... However, I'm not relying on pegged for my lexer/parser, but still have the parsing code generated from a grammar by a generator written in another language. Each grammar rule is translated to a method that just matches the input in a recursive descent style, for instance the rule: suffix-lexeme: ( mark-affixable ! ( lr-affixable-char-first | l-bracket-char ) ) is translated to this code: bool matchSuffixLexeme() { return (mixin( ctMatchAndCapture( Intrinsic.Suffix, "constructLexeme", q{ mixin( ctMatchSeq( q{ this.matchMarkAffixable() }, q{ mixin( ctMatchNeg( q{ mixin( ctMatchAlt( q{ this.matchCharset( &amp;isLrAffixableCharFirst ) }, q{ this.matchCharset( &amp;isLBracketChar ) } ) ) } ) ) } ) ) } ) ) ); } I think the generated D code is still fairly readable, even after mixin expansion. So it's possible to modify the generated code by hand and replace some methods with more efficient ones. And so far, the compiled code seems to also run sufficiently fast for my purposes. All in all, without D's meta programming capabilities this would not be as clean.
My little mssql thing (linked) just calls the ODBC functions. Really simple code, works on its own and its source is an example for how to use the C library.
nice ;)
DConf ?
I can't promise. But the language is gonna be open sourced.
okay i just tried to clarify what &gt; I'll have something ready next year meant
I'd shill for my own but that won't be out for one or two years. It's interesting if you're a game dev, I'll say that much.
The kids are being taught easy non-C-like web languages like JS. I'm taking an AP computer science class and even then it's JS. The rest of my class just last week finished learning about loops and functions.
F, I just got the old copy a couple months ago.
I recognize the total mistake of defining a const with a variable, but I only fixed it after. Don't worry, it bothers me too.
That is Vista which is basically the same. 
[Forum post for the announcement](https://forum.dlang.org/post/pqrtclsulsaxjrgjninx@forum.dlang.org)
**_local** is not static that's why you cant call memberFunc as a function pointer. The segfault you get is not a bug it's because in **memberFunc** there's an access the **this._local** while **this** is null. The lambda way is actually a smart way to do what you want. There would more solutions but more verbose.
&gt; I'm not sure why getting the address like this Metaprog.
That _local is non-static is intended.
I really liked this. &amp;#x200B; For some reason it reminded me of the metaclasses proposal for C++.
I would suggest you ask at https://forum.dlang.org
[Learn D in Y minutes](https://learnxinyminutes.com/docs/d/) is great for initial learning. [Tiny-Redis](https://github.com/adilbaig/Tiny-Redis) is a fairly short project, and at least has a TcpSocket from the std.socket module. I pulled this project from [awesome-d](https://github.com/zhaopuming/awesome-d).
2.082 was actually released on September the first the blog-post is just a bit late. Here is the full change-log: https://dlang.org/changelog/2.082.0.html
I have a "minimalist wiki" that I use to store notes inside directories (normally a repo). https://bitbucket.org/bachmeil/minwiki The main file is wiki.d, and it's only 72 lines with comments. I pulled in a markdown processor written by someone else and Adam Ruppe's web tools. It's meant to be run on localhost inside a browser. It doesn't do much other than create, edit and display markdown notes (and that's the goal) but I made it public so others could see an example of Adam's web tools being used.
I haven't really touched rust. Looking at the site, syntax is a bit iffy for me, but that's mostly because I'm so used to the wonderful C-like stuff. Adding in extra words like "let" just seems pointless to me. I think where D really excels is with the combination of Phobos and the C/C++ bindings. The greatly-reduced number of functions I was writing was wonderful as D seemed to have everything. Combine that with some really good cross-compatibility with what are essentially the two biggest languages is the cherry on top. D can do anything C or C++ can do, only with greater ease. There were a lot of comments on the rust thread about rust running much faster than D, though at least with everything I've done with it, speed hasn't ever been an issue. I imagine it could make a difference on a truly huge project, but if you've got good programmers working on something like that then they can make just about any language work well. I'd only really be bothered about that if it was a really performance-sensitive project. The key with D is that it's not really supposed to be another lower-level language in the region of C++. It's much higher-level than that, but at the same time doesn't go as far up as your dotnet and jvm stuff to the point of bloat and sluggishness. It hits a sweet spot in the middle of easy use and great performance. It's not the best at either, but it's definitely good at both. The place I know Rust is better is with popularity. D's existed for nearly 20 years now and it has the fraction of the user-base as the much younger Rust that's less than half the age. It's difficult to find any resources on D outside its own documentation, which can make it a bit more challenging to get into - especially if you're quite new to programming.
I'm at home with D syntax too, although I am not a fan of annotations like @safe @nogc, I'd rather have the built-in ones without @. Also I am not a fan of ! for template instantiation. I find Foo&lt;Bar&lt;Baz&gt;&gt; cleaner than Foo!(Bar!Baz), especially when templates get crazier. But that's nitpicking.
&gt;sigils, | | in foreach Looks like the last time you looked at rust was version 0.1x ;) 
Perhaps, but they could be referring to the lambda syntax: let arr = vec![1, 2, 3]; arr.for_each(|val| println!("{}", val); But yes, they fixed some of the syntax for 1.0 so you can now do the more familiar for loop: for val in arr { println!("{}", val); } And good riddance to `@T` and `~T` (and maybe more, I can't remember them all).
Well, I googled "rust syntax" and looked into google images ;)
Dunno, I'm using Visual Studio for years without too much problems.
D used to have a slogan with 3 pillars: Modeling power, Modern convenience, and Native efficiency. Watch this video for an elaboration (https://www.youtube.com/watch?v=Kn88228KSpQ). Rust also has Native efficiency, but definitely not the other two. I remember one D user commenting in a chatroom that he was frustrated with D and was going to try Rust. He was back less than 48 hours later with the comment "Rust has the modeling power of a brick". If you've never used D before "Modeling Power" may not make much sense to you, but after you've used D you'll understand precisely what it means. Rust achieves much of its safety features by constraining the programmer. Not so in D. Not too long ago D has a "State of D" survey and asked respondents to describe D with three words. One of the most commonly submitted words was "Fun". D is definitely fun to program in. Rust always feels like work. What Rust has that D doesn't, however, is resources. D's progress is slow, frustrating, and unfocused because there simply aren't enough people contributing to it, and the leadership is very poor at managing the effort. IMO, D has more potential than Rust, but Rust has much more velocity. 
They went with ! because greater than and less than lead to some ambiguous parsing situations where the compiler doesn't know if it's a template or an inequality.
I've written a fair bit of D (https://github.com/cristicbz/scid) and Rust (https://github.com/cristicbz/rust-doom). On the other hand, I haven't really touched D in about 5 years. I just wanna answer some of the syntax stuff that you bring up. &gt; syntax is a bit iffy for me, but that's mostly because I'm so used to the wonderful C-like stuff. Rust is mostly C-like. It's curly braces `{}`, `&lt;&gt;` for type params (where it's more C++-like than D if anything), `&amp;` for references, `::` for scope resolution etc. You'll see a lot of `mut`, but that's just because the `const` is the default in Rust, but syntactically it's analogous. This is a bit like C++ having `virtual` which `D` has `final`. I'd say `D` is closer in semantics to `C++` and can therefore recycle more syntax, especially when it comes to OOP stuff: like `class` and `override` and some TMP stuff, hence `template`. Where it comes to overlapping concepts, IMO the biggest (in the sense of most prevalent) syntactic difference is in types coming after names, rather than the other way around: `foo: i32` instead of `int32_t foo`. This one does stand out. &gt; Adding in extra words like "let" just seems pointless to me. `let` is a lot like `auto`. If you rely a lot on local type inference (like modern C++, D and Rust), you need some keyword to distinguish between an assignment and declaration. C++ and D use `auto`, Rust uses `let`. `fn` kinda fits the same purpose. I think Compare the C++ auto sum(int32_t t1, int32_t t2) -&gt; int32_t { auto sum = t1 + t2; return sum; } with the equivalent Rust code: fn sum(t1: i32, t2: i32) -&gt; i32 { let sum = t1 + t2; return sum; } (yes, in idiomatic Rust you'd drop the `return` keyword, but whatever)
Turbofish tho. Rust even has a poem about it in the compiler.
What's the state of, say, GPU support in both (ie CUDA or OpenCL or whatever)?
Actually allocations at compile time are all malloc. The front-end doesn't use the GC for now. All what you do in CTFE is de facto _nogc_. Would you have a small sample to share so that we can see more concretely what you mean ?
For a contrived example: import std.stdio; import std.experimental.allocator; int test(int c) { int[] numbers; if (__ctfe) { numbers = new int[c * 4]; } else { numbers = processAllocator().makeArray!int(c * 4); } foreach (i, ref number ; numbers) { number = cast(int) i * 2; } return numbers[c]; } void main() { enum int test1 = test(15); auto test2 = test(25); writefln("Hello D %d %d\n", test1, test2); } In CTFE you cannot use allocators (static / runtime data access) nor can you use malloc (casting rules void \* -&gt; int\[\] not allowed). So I have to use the GC via the new call. This works just fine and all is good, I don't have to write twice the code so I can have a CTFE version... until you add `@nogc`. That `__ctfe` check is not static, it's a runtime check that gets optimized out by the compiler. But because it's not static, it doesn't count as conditional compilation and using the GC violates the `nogc`\-ness of the code even though it will never be used at runtime! You can't make it static either, because `__ctfe` itself cannot be read at compile time. D allows me to invalidate the `@nogc` invariant at compile time otherwise, though, as long as it's down in CTFE it has never complained before (and it rightfully shouldn't). So if I want to use test as both a CTFE and a runtime function, I have to write two functions that are almost entirely identical except one uses the allocator (which may even be the gcAllocator, which still doesn't work in CTFE) and one that uses new. So I was wondering if there was something I was missing or if there are any plans to allow `__ctfe` to be used for **real** conditional compilation so that this behavior can be achieved?
Someone below posted [some numbers](https://www.reddit.com/r/d_language/comments/9844dx/why_is_ds_ecosystem_so_small/e52g1qb) that may be of interest. 
No you miss nothing and this problem cannot be solved with the current features of language. 
Glad to see someone at least tried. 
&gt; Oh, and I'm doing it all on Windows, so it's much harder for me, because most of the community is sitting on and testing for Linux only. There are plenty of D users on Windows and Windows is part of the test suite. I've been using D primarily on Windows since 2003. And I'm not a vi/emacs user. VS Code is just fine. I do understand the benefits of an IDE because I used to be a Java developer. I just don't need one in D. Never have. Even if the core team had more resources, I wouldn't expect IDE support to be a core project. There are too many IDEs out there to which people feel strongly attached. Better to support none than one. As it is, there are several community-driven options out there under development, and as part of the D Foundation's upcoming funding initiative they will be among the projects that receive support at some point.
There’s a lot of gotchas, but still a great experience and mostly enjoyable to use paradigm of choice!
The biggest gotcha at the start for me was how all the utility was not on the object itself, but scattered around a lot of standard library modules. E.g. finding the first occurrence of a value is std.algorithm.countUntil, checking whether a string is numeric is std.string.isNumeric, and counting the actual characters in a UTF8 string is std.utf.count.
I gather "gotchas" here: [https://p0nce.github.io/d-idioms/](https://p0nce.github.io/d-idioms/)
neat! I'll have to add that to my reading list!
this seems to work `char*[] sources = [cast(char*)source];` `glShaderSource(res, 1, &amp;sources[0], null);` is there a more idiomatic way to do this ?
That function allows non-zero-terminated strings like D's (surprising for a C API). So you don't need to do any conversion if you pass the length as well. You can avoid additional allocations by using static arrays, unless you need to pass more than 1 source string. Finally, I'd use `ptr` for clarity instead of `&amp;sources[0]`, but they do the same thing. ```d const(char*)[1] sources = [source.ptr]; int[1] lengths = [cast(int)source.length]; glShaderSource(res, 1, sources.ptr, lengths.ptr); ``` The only bug in your example is that `source` is *not* zero-terminated like a C `char*`, so OpenGL will read past the end unless you pass the length. If you do ever need to make a D string zero-terminated, use `std.string.toStringz` instead of a cast - it's a pain to use though, since it allocates by GC.
Maybe this ``` import std.string; auto sources = "&lt;some pix shader code&gt;".toStringz; glShaderSource(res, 1, &amp;source, null); ``` You have plenty of d usage [here](https://github.com/search?l=&amp;o=desc&amp;q=glShaderSource+language%3AD&amp;s=indexed&amp;type=Code) toStringz is required so that the code length doesn't have to be specified.
Here's a link to the answers I got on stack overflow when I had this problem myself. tostringz() basically solved my problem. https://stackoverflow.com/q/36227324/5219269
BTW this is an array of pointers to strings not just a string....
Any recommended repos, blogs, videos, newsletters, etc?
I really like the ideas behind this language, but I don't have a real chance to use it anytime soon, because I'm working in a .NET environment. 
Unfortunately, no. `rawRead` is best used for reading things in one go, not a single element at a time. You don't need to be explicit with the template parameter, however: uint[1] nv; f.rawRead(nv); // compiler deduces uint[] uint nVerts = nv[0]; If you're willing to trade @safety for saving one line of code, this can be rewritten as: uint nVerts; f.rawRead((&amp;nVerts)[0..1]); Even somewhat shorter, but way less efficient: auto nVerts = f.rawRead!(new uint[1])[0]; // well... Another option is to wrap the above code in a helper function: T rawReadOne(T) (File f) { T[1] buffer; f.rawRead(buffer); return buffer[0]; } ... which from then on can be used like so: auto nVerts = f.rawReadOne!uint(); Also, ages ago, the standard library did include a `std.streams` module, but it's been removed from phobos. It can still be found at &lt;https://github.com/dlang/undeaD&gt;. 
ah ha I like rawReadOne, so much so that I might bring myself to use templates! thanks
if i add &gt;"versions": \["DerelictODE\_Single"\], I get the error Non-optional dependency derelict-ode: of physics not found in dependency tree!?. &amp;#x200B;
From what I recall, it started as a "better successor to C" rather than "better C++", if that makes sense. i.e it's what they would have done if they were in the position to make a C++ without the circumstances surrounding C++. I'd say C++ accomplished what it set out to do at the time. I could be wrong on all of that though; I don't even remember where I (may or may not have) even heard this.
argh nash managed to mangle the dependency for derelict-ode... all working now... "dependencies": { "derelict-glfw3": "\~&gt;4.0.0-beta.1", "derelict-gl3": "\~&gt;2.0.0-beta.7", "imageformats": "\~&gt;7.0.0", "derelict-ode": "\~&gt;3.0.0-beta.1" }, "versions": \["DerelictODE\_Single"\] &amp;#x200B;
I like the language, just not how it is used. I stopped using D, because it seems like the way the community writes it is like C or C++: with a lack of abstraction and an obsession for performance and implementation details. 
Nicely done!
Now that is an awesome hello world :)
Dont write classes unless you really need runtime polymorphism. What you really want is struct.
Looks nice. I am [working](https://www.youtube.com/watch?v=83VLtTEv8Ao) [on](https://www.youtube.com/watch?v=0U93Wl_a_GQ) a [3D](https://www.youtube.com/watch?v=1L3rVhZ1ZoM) engine in [D](https://www.youtube.com/watch?v=5xfHTaXHYpI) myself. I have some things I don't like about the language/ecosystem, but I don't really have any alternatives. Except maybe for Java, although it feels a bit limited when it comes to math libraries and bindings to stuff like ODE.
I've basically discovered D because of a dissatisfaction with the way Java is heading...
Hmm. Opinions may vary. I think D is going in the wrong direction, although people will disagree. Personally, I think D is spreading itself too thin, especially on the memory management story, between betterC, nogc, allocators and GC. And it feels like that in every aspect. Chasing features, without thinking about language complexity. And then these features are painful when interacting with each other. Java at least has a tight language core and has a direction it's going towards, and any experiments are done out of sight in projects and JEPs. But D has a strong niche of working for C/C++ usecases without being any of those languages. Only Rust and maybe Go (Nim is too niche to mention for me) could fit that niche too, but I don't like their syntax and they feel a bit too foreign for me.
thats what I tried at first, alas it doesn't work saying : Performing "debug" build using /usr/bin/dmd for x86_64. lib-example ~master: building configuration "application"... Linking... /usr/bin/ld: cannot find -llib/mylib.a collect2: error: ld returned 1 exit status Error: linker exited with status 1 /usr/bin/dmd failed with exit code 1. 
Chuck it into sourceFiles, should work.
alas not... I'm wondering if I wouldn't be better off using make....
I've previously done this with a vendor-supplied library so the binary didn't need it installed at deployment. The dub file looked like this: { ... [ elided ] ... "mainSourceFile": "src/main.d", "targetType": "executable", "targetPath": "bin", "libs": [ "usb", "pthread" ], "lflags": [ "-Bstatic", "/path/to/vendor/lib/libvndr.a", "-Bdynamic" ], ... [ elided ] ... } It's explicitly passing arguments to the linker, in this case the GNU linker `ld` (so do `man ld` to get details). 
yeah, i got that, but didn't want to make it linker specific (kinda the point of using something like dub I thought ??)
I don't believe dub has the system specifics to do that for you. I quickly skimmed the source and examples since it's been a couple of years since I did this and while I see support for pkgconfig and passing through different compiler and linker flags, I don't see anything or directives for controlling the linker. My guess is it's "patches welcome" and those of us who run into it already know or can find the incantations.
I feel that. As I understand it, you can still call methods written in D with P/Invoke and kin; but I haven't tried it, and it's hardly the same as working simultaneously with D and .NET.
&gt; handle the whole Ethernet Packets Are you asking about TCP or UDP handling libraries or both? Or something different? Can you provide a more specific use case?!
layers 2 and 3 are below TCP and UDP. It is ethernet frames and IP header stuff. As far as I know, D doesn't have something specifically for accessing these, but you can just call the relevant C functions directly (might require defining the extern(C) bits yourself for different OSes, just copying the function prototypes/const values.).
Ok Like &amp;#x200B; `Extern C {` `libnet_ptag_t libnet_build_arp(u_int16_t hrd, u_int16_t pro, u_int8_t hln, u_int8_t pln, u_int16_t op, u_int8_t *sha, u_int8_t *spa, u_int8_t *tha, u_int8_t *tpa, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag);` `}` &amp;#x200B; and then to compile linkin with gdc -llibnet some.d
Lisp and D -&gt; A man of culture.
yeah basically. you might need to define the types too (eg `alias u_int16_6 = ushort;`)
[Andrei Alexandrescu - best text editor](https://www.youtube.com/watch?v=qzC5H5xrr-E)
Error: use . for member lookup, not -&gt;
Hm. IMO the name is a better fit, but it's not unique.
Yeah there's a DX7 editor that has it too. 
auto value = typeof(X).init;
Yeah i should have put this one in position 2.
I'm not familiar with the aliasseq syntax.
You have a list of type. Between brackets there is a compile time expression that returns the index of the type in this list : \`is(X == long)\` gives a compile time \`bool\` that gets implicitly converted to \`0\` or \`1\`, i.e the index in the type list.
I think D is commonly overlooked because of its name and partly because of it's mascot. D just makes it seem like a slightly different alternative to C IMO and it isnt very memorable (especially compared to things like kotlin, rust, go, etc). On the mascot side of things, I love dman the same way you might love an ugly painting you did as a kid. He is certainly meme worthy, but kind of off-putting to new users. All of that aside though, I am so glad I started using D. It has become my favorite systems language by far!
Your example, with a little bit of context, compiles here on Linux so it's likely not the problem and there problem is in some other part of your code. First, don't copy things around. That's not going to help. Next, it looks like you're using `dmd` as your compiler on a unix-like system so try getting verbose output from the linker by passing `-L'verbose` and collecting the output. IIRC, the `core.sys.*` lacks documentation, being a thin layer over the system details. If you're interested in seeing what is actually in there you have to look at the source https://github.com/dlang/druntime/tree/master/src/core/sys 
I'm using rdmd on Arch (sorry, forgot to add that bit). The following commands give the following output: $ rdmd main.d /usr/bin/ld: /tmp/.rdmd-1000/rdmd-btuilib.d-2BD645D221C6B63E05D9804F071D8506/objs/btuilib.o:(.data._D1b7btuilibQi7__ClassZ+0x88): undefined reference to `_D1b7btuilibQi6__ctorMFZCQxQxQz' collect2: error: ld returned 1 exit status Error: linker exited with status 1 $ rdmd main.d -L'verbose' /usr/bin/ld: /tmp/.rdmd-1000/rdmd-btuilib.d-2BD645D221C6B63E05D9804F071D8506/objs/btuilib.o:(.data._D1b7btuilibQi7__ClassZ+0x88): undefined reference to `_D1b7btuilibQi6__ctorMFZCQxQxQz' collect2: error: ld returned 1 exit status Error: linker exited with status 1 $ dmd main.d -of=main /usr/bin/ld: btuilib.o:(.data._D1b7btuilibQi7__ClassZ+0x88): undefined reference to `_D1b7btuilibQi6__ctorMFZCQxQxQz' collect2: error: ld returned 1 exit status Error: linker exited with status 1 $ dmd main.d -of=main -L'verbose' /usr/bin/ld: cannot find verbose: No such file or directory collect2: error: ld returned 1 exit status Error: linker exited with status 1 Part of me thinks I'm just missing the druntime altogether, even though I have `community/libphobos` installed which supposedly includes the runtime.
Try to compile with just `dmd` rather than using the `rdmd` tool. The linker flag obviously didn't get used, put it immediately after the `dmd` command before the rest of the arguments. You should get something like this: GNU ld (GNU Binutils for Ubuntu) 2.30 Supported emulations: elf_x86_64 elf32_x86_64 elf_i386 ... elided ... SEARCH_DIR("=/usr/local/lib/x86_64-linux-gnu"); SEARCH_DIR("=/lib/x86_64-linux-gnu"); SEARCH_DIR("=/usr/lib/x86_64-linux-gnu"); SEARCH_DIR("=/usr/lib/x86_64-linux-gnu64"); SEARCH_DIR("=/usr/local/lib64"); SEARCH_DIR("=/l ib64"); SEARCH_DIR("=/usr/lib64"); SEARCH_DIR("=/usr/local/lib"); SEARCH_DIR("=/lib"); SEARCH_DIR("=/usr/lib"); SEARCH_DIR("=/usr/x86_64-linux-gnu/lib64"); SEARCH_DIR("=/usr/x86_64-linux-gnu/lib"); ... elided ... attempt to open /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o succeeded /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o attempt to open /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crti.o succeeded /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crti.o attempt to open /usr/lib/gcc/x86_64-linux-gnu/7/crtbeginS.o succeeded /usr/lib/gcc/x86_64-linux-gnu/7/crtbeginS.o attempt to open ioctl.o succeeded ioctl.o attempt to open /usr/lib/x86_64-linux-gnu/libphobos2.a succeeded (/usr/lib/x86_64-linux-gnu/libphobos2.a)object_7_32e.o (/usr/lib/x86_64-linux-gnu/libphobos2.a)object_8_522.o (/usr/lib/x86_64-linux-gnu/libphobos2.a)object_9_66e.o (/usr/lib/x86_64-linux-gnu/libphobos2.a)object_a_58c.o ... elided ... Which will show what the linker tried to use.
 $ dmd -L'verbose' main.d -of=main /usr/bin/ld: cannot find verbose: No such file or directory collect2: error: ld returned 1 exit status Error: linker exited with status 1 Still not what we're expecting. I get an identical message trying `-L='verbose'` too. My current theory is that I'm just missing some package, but I can't figure out what.
Sorry, I keep typo-ing. It's `dmd -L'--verbose'`
Aha! Now it's working. Here's the output: GNU ld (GNU Binutils) 2.31.1 Supported emulations: elf_x86_64 elf32_x86_64 elf_i386 elf_iamcu elf_l1om elf_k1om i386pep i386pe ... skipping ... SEARCH_DIR("/usr/x86_64-pc-linux-gnu/lib64"); SEARCH_DIR("/usr/lib"); SEARCH_DIR("/usr/local/lib"); SEARCH_DIR("/usr/x86_64-pc-linux-gnu/lib"); ... skipping ... attempt to open /usr/lib/gcc/x86_64-pc-linux-gnu/8.2.1/../../../../lib/Scrt1.o succeeded /usr/lib/gcc/x86_64-pc-linux-gnu/8.2.1/../../../../lib/Scrt1.o attempt to open /usr/lib/gcc/x86_64-pc-linux-gnu/8.2.1/../../../../lib/crti.o succeeded /usr/lib/gcc/x86_64-pc-linux-gnu/8.2.1/../../../../lib/crti.o attempt to open /usr/lib/gcc/x86_64-pc-linux-gnu/8.2.1/crtbeginS.o succeeded /usr/lib/gcc/x86_64-pc-linux-gnu/8.2.1/crtbeginS.o attempt to open main.o succeeded main.o attempt to open /usr/lib/libphobos2.a succeeded ... skipping ... attempt to open /usr/lib/libpthread.so succeeded -lpthread (/usr/lib/libpthread.so) attempt to open /usr/lib/libm.so succeeded opened script file /usr/lib/libm.so opened script file /usr/lib/libm.so attempt to open /usr/lib/libm.so.6 succeeded /usr/lib/libm.so.6 attempt to open /usr/lib/libmvec_nonshared.a succeeded attempt to open /usr/lib/libmvec.so.1 succeeded /usr/lib/libmvec.so.1 /usr/lib/libmvec.so.1 attempt to open /usr/lib/librt.so succeeded -lrt (/usr/lib/librt.so) attempt to open /usr/lib/libdl.so succeeded -ldl (/usr/lib/libdl.so) attempt to open /usr/lib/libgcc.so failed attempt to open /usr/lib/libgcc.a failed attempt to open /usr/lib/gcc/x86_64-pc-linux-gnu/8.2.1/libgcc.so failed attempt to open /usr/lib/gcc/x86_64-pc-linux-gnu/8.2.1/libgcc.a succeeded attempt to open /usr/lib/libgcc_s.so succeeded opened script file /usr/lib/libgcc_s.so opened script file /usr/lib/libgcc_s.so attempt to open libgcc_s.so.1 failed attempt to open /usr/lib/libgcc_s.so.1 succeeded libgcc_s.so.1 (/usr/lib/libgcc_s.so.1) attempt to open /usr/lib/libgcc.so failed attempt to open /usr/lib/libgcc.a failed attempt to open /usr/lib/gcc/x86_64-pc-linux-gnu/8.2.1/libgcc.so failed attempt to open /usr/lib/gcc/x86_64-pc-linux-gnu/8.2.1/libgcc.a succeeded attempt to open /usr/lib/libc.so succeeded opened script file /usr/lib/libc.so opened script file /usr/lib/libc.so attempt to open /usr/lib/libc.so.6 succeeded /usr/lib/libc.so.6 attempt to open /usr/lib/libc_nonshared.a succeeded (/usr/lib/libc_nonshared.a)elf-init.oS attempt to open /usr/lib/ld-linux-x86-64.so.2 succeeded /usr/lib/ld-linux-x86-64.so.2 attempt to open /usr/lib/libgcc.so failed attempt to open /usr/lib/libgcc.a failed attempt to open /usr/lib/gcc/x86_64-pc-linux-gnu/8.2.1/libgcc.so failed attempt to open /usr/lib/gcc/x86_64-pc-linux-gnu/8.2.1/libgcc.a succeeded attempt to open /usr/lib/libgcc_s.so succeeded opened script file /usr/lib/libgcc_s.so opened script file /usr/lib/libgcc_s.so attempt to open libgcc_s.so.1 failed attempt to open /usr/lib/libgcc_s.so.1 succeeded libgcc_s.so.1 (/usr/lib/libgcc_s.so.1) attempt to open /usr/lib/libgcc.so failed attempt to open /usr/lib/libgcc.a failed attempt to open /usr/lib/gcc/x86_64-pc-linux-gnu/8.2.1/libgcc.so failed attempt to open /usr/lib/gcc/x86_64-pc-linux-gnu/8.2.1/libgcc.a succeeded attempt to open /usr/lib/gcc/x86_64-pc-linux-gnu/8.2.1/crtendS.o succeeded /usr/lib/gcc/x86_64-pc-linux-gnu/8.2.1/crtendS.o attempt to open /usr/lib/gcc/x86_64-pc-linux-gnu/8.2.1/../../../../lib/crtn.o succeeded /usr/lib/gcc/x86_64-pc-linux-gnu/8.2.1/../../../../lib/crtn.o /usr/bin/ld: main.o:(.data._D1b7btuilibQi7__ClassZ+0x88): undefined reference to `_D1b7btuilibQi6__ctorMFZCQxQxQz' collect2: error: ld returned 1 exit status Error: linker exited with status 1 The files that fail are all [`libgcc.so`](https://libgcc.so), so I thought I might be missing gcc or something, but checking shows them already installed. Checking the directory though shows libgcc.so is indeed missing. Asking around, nobody seems to have this file, and we can't find any package that it's supposed to belong to. The closest files are `/usr/lib/libgcc_s.so` and `/usr/lib/libgc.so`.
Nothing there suggests an environment problem. I'm wondering if it's related to this... https://issues.dlang.org/show_bug.cgi?id=19291 Try moving imports one at a time to module scope and see if that fixes it.
No change. It still fails to find the same files.
It doesn't but should compile anyway (it does on my desk). The OP is doing something they haven't explained nor shown code that demonstrates the actual bug. 
&gt;I'm not exactly sure why your get\_size needs to be extern(C). If get\_size is supposed to be a wrapper function implemented in D TIL things in C don't need to be in extern(C) if there's a D library providing the functions from the C library. I fell like I've wasted loads of time.
The code in the OP, surrounded by a void main *is* my entire source.
No probs, and thanks for the summary. I'm sometimes late to the party b/c of CET timezone.
\`bool\` being converted to \`int\`? I thought D didn't allow that. How about vice-versa?
yes, the other way too... if (int i = 1000) writeln(" != 0"); if (int i = 0) writeln(" == 0"); Which is handy for pointers and reference types... no need for `is null`
It's actually not exactly an implicit conversion, it's rather that integral types and pointers types can evaluate to bool.
It's basically your iterateForward (or Backward for opApplyReverse) that allows your list to be used like `foreach(element; yourList){...}`
It's basically your iterateForward (or Backward for opApplyReverse) that allows your list to be used like `foreach(element; yourList){...}`
Here is one with a working opApply (and opOpAssign, which allows \~=): [https://pastebin.com/tpcnRLzY](https://pastebin.com/tpcnRLzY)
that's really generous thanks so much! I assume that the string compare is for the benefit of the compiler and that the compiled code doesn't do a bunch of string compares every operation! What does the delegate actually call and how does it get the return value ?
Yeah, the compare only happens at compile time and won't affect runtime performance. The delegate wraps the code block given to the `foreach`, and the return value is modified by `break` and such, if you don't handle it correctly in opApply a break wouldn't stop the loop :)
[Dub](https://code.dlang.org/) is the package manager for D. The simplest case is to create a dub project with `dub init` and then have each file you have be its own module (something like 'projectname.whatsInThisFile'). Then each file imports what it needs from the other modules. To compile you just issue `dub build`. Check out the dub documentation for more details and advanced usage.
There is a very recent post on the D-blog about modules and packages in D. You may find it helpful: https://dlang.org/blog/2018/11/06/lost-in-translation-encapsulation/
This version of D was released November the first. Link to the full change-log: https://dlang.org/changelog/2.083.0.html TL;DR: D: - Cpp runtime version check - New less conflicting way of declaring C++ linkage via a string - New trait isZero - New trait getTargetInfo - New pragma linkerDirective Phobos: - std.algorithm.iteration.each is now capable of early-stopping Dub: - betterC build option has been added
Looks like it's still using gtk2 .
Just look at [how other people do it](https://github.com/topics/d?l=d&amp;o=asc&amp;s=stars)
You can compile it for qt5, qt4 or gtk3 too. For now i still build for gtk2 (and use too) because the terminal emulator is based on libVTE, which is a gtk2 widget.
Yup, that worked! Kinda weird that one has to do that, but thanks!
i agree. furthemore let's say if you had only ldc2 or gdc setup this would be confusing. &amp;#x200B; make -f posix.mak DMD=gdc // not good make -f posix.mak DMD=gdmd // ok make -f posix.mak DMD=ldc2 // not good make -f posix.mak DMD=ldmd2 // ok
Will there be Mac support?
I made a small donation and look forward to making many small donations to useful projects in the future.
there's a new way in more now lol: struct Foo{ alias MyInt = int; } __traits(getMember, Foo, "MyInt") someInt; [since this)(https://github.com/dlang/dmd/pull/8938)
Lol
Awesome. Thanks!
Donated!
&gt; the D compilers are written in C++ if I remember correctly. not any more https://forum.dlang.org/thread/psaekt$tah$1@digitalmars.com
Thanks!
It can be done in D-Scanner, i bet you're the person who recently opened an issue about this ?
;)
For development I recommend DMD just because of the fast compile times. For your production binary it depends on how much you care about performance. Try both GDC and LDC and pick the faster one.
Full text of the post: The time has come to start thinking about GSoC 2019. The application deadline for mentoring organizations is on February 6. I'd like to get a solid list of project ideas for potential student applications. I've set up a new page at the Wiki to collect ideas and seeded it with two from the GSoC 2018 page: [https://wiki.dlang.org/GSOC_2019_Ideas](https://wiki.dlang.org/GSOC_2019_Ideas) I invite everyone to add ideas to the list. Please be as descriptive as you can in your summaries, and be explicit about the goals the project should achieve. We want projects that are both necessary and challenging. Anyone who is interested in participating as a student or a mentor, please contact me (see the linked post for email address). Be sure to visit the GSOC FAQ for links to details about what both roles entail: [https://developers.google.com/open-source/gsoc/faq](https://developers.google.com/open-source/gsoc/faq) I'll be putting out more information in the coming weeks, here and on the blog.
In case someone wants to provide their thoughts here rather than clog up the D development mailing list...
I've long felt that going after the C++ crowd is a lost cause. D's a good language. I wish attention were put on making it easier to do things with the language as it is, rather than on "beating C++".
Fuck yeah!
It does if you feel that C had just the right amount. Otherwise I think C++ takes the crown for too many. It's so disjointed and inconsistent that it's honestly impressive. I say this as someone who likes and uses C++ regularly.
Try suggesting specific features to remove and see how many D users scream. There will always be dedicated users of pretty much all features.
The creators of the language [had the same doubt](https://forum.dlang.org/thread/jnhe1i$2vcm$1@digitalmars.com) and looking at all the answers you're not alone feeling the language may have too many features. Also wanted to mention Go as another, younger language (vs C) that favors language stability to additional features. It's a complex tradeoff and my 2c is that one of the important factors is how much the language and its ecosystem's growth are dependent on attracting developers from other languages (therefore needing that "sexyness" factor) vs having strong corporate backing and internal use cases to begin with, like Go.
C++ tries to please everyone. It just ended up becoming a monstrosity like the human blob of [Inside](http://i.imgur.com/BnncQHA.gif).
That's a pretty good representation! lol
Go's not a terrible language, but its C FFI is a definite barrier in terms of performance...
The problem is everyone has different opinions about what to remove.
That may be the best description of C++ I have ever heard.
rather than what to remove, better to call a halt on adding stuff because you can!
It's more or less inevitable that, as a language matures, it will grow in size. If you want to understand why, I recommend the talk ["Growing a Language"](https://www.youtube.com/watch?v=_ahvzDzKdB0) by Guy Steele.
If I were to design a better D, I would remove a few features, and add a few. If you've used C, Rust, and Zig, you'll notice that none of them have classes. C's lack of classes is limiting; Rust and Zig's lack of classes less so. What I have realized over the past few years is that with the right mix of other features (mixins, type introspection, compile-time execution, templates, uniform function call syntax, (multiple) \`alias this\`, \`static if\`, \`ref\` etc...) classes become unnecessary and even a hindrance. Right now classes in D are causing all kinds of problems as D tries to engineer it's way out of relying on the GC and figure out the transitivity of attributes on inherited members and destructors. And that's not to mention the heavy weight classes require from the runtime, limiting Ds portability to other platforms and new problem domains like systems programming and embedded systems. It's actually quite the mess, which is why Andrei Alexandrescu has proposed a [new type of root object](https://forum.dlang.org/post/pa1lg6$1lud$1@digitalmars.com) and why Walter implemented -betterC (a.k.a -worseD). So, yes, in a way, D does have too many features, but it's D's most innovative features that I would like to keep. Instead I would prefer to see how those new and innovative features could render some of its more troublesome features, like classes, obsolete; somewhat [like this](https://theartofmachinery.com/2018/08/13/inheritance_and_polymorphism_2.html).
C has too little. It is weakly typed and unsafe in a variety of ways. By the time you make it safe by extra coding, you lose the same amount of speed checking for safe conditions that you would never have had using a safe language. Why put yourself through the hassle? Let the language be safe and do it for you. C needs to be banned.
It's not terrible but it's not great either. It's a big improvement over C but C was 50 years ago and language advancement has been greater than what Go is over C.
There is nothing wrong with adding features, as long as they are optional and not part of the core language. If you can't implement the new feature outside of the core language, then you're doing something beyond what you originally designed for and adding it will be an ugly wart. Time to bring out a major version number that breaks compatibility or create a new language altogether.
I never saw/played that game before. Was that a major spoiler?
If I said no, should you believe a stranger online? I haven't played the game either.
Yes, I think it has. But fortunately you don't have to use all features all the time, and there are smaller subsets of D that are "functionally complete". As a user of the language, I'd rather have too many features than too few. If I had to work on the language itself, I'd probably lament this a lot more.
I don’t understand why a feature you don’t use troubles you. Personally I can’t have too many tools in my toolbox assuming that they are all quality. 
I suspect users just don't that much perspective to decide what should be in or out.
bloat, and sometimes confusing code when looking at other peoples code, I much prefer explicit code....
But every line of code has the potential for an error. 
I think it's because there are many kinds of programmers in D. Most seem to come from C++ backgrounds, so they want to implement everything with templates. I come from more of a Java background, so things that simplify OOP are more important for me. I agree on the fad chasing though. I'd rather D have a stronger story and design, rather than just trying to half-bake whatever is needed at the moment. We use GC, wait no, you don't have to use GC, you can use @nogc, wait no, half the stdlib doesn't work, well, you could always use betterC, yeah, half of the language doesn't work, but yeah you can do it. It's like that with everything. Now it seems with dip1000 we're chasing Rust. That's nice, but we won't be as good at Rust as Rust, and GC gives us most of the guarantees we want anyway. The latest fad seems to also be C++ interoperability. While noble, I doubt it will ever work beyond simple examples, and in the worst case will cause D to adopt most C++ features just for the interop capability.
More tools = more surface area prone to bugs. Language features might work well on their own, but break when used together. This creates awkward corner cases, which need to be worked around with new language features, which break with other features.
Updating Vagrant VirtualBox in case that matters. But I really don’t have time for this kind of bull.
No. This is a regression it should "just work". We need to figure out what is causing it and report it.
No wonder, considering it uses a linker from DOS times.
&gt; And can you name two D features that break when used together? Function attributes (`@safe`, `pure`, `nothrow`, `@nogc`) and `Object`'s `toString`, `toHash`, `opCmp`, and `opEquals` methods.
I found the bug report, good googling. Doesn't that crash even if @safe isnt used?
downgrade glibc
Thank you for clarifying! I’m curious what part of glibc broke backwards compatibility.
Archlinux doesn't like downgrades so I had to find a better solution see the second edit.
So how quickly can we turn this flag on by default in the Debian and Arch packages?
Not going to happen for GCC. Someone needs to tell the DMD devs or distributors to make it compile PIE code by default.
or make DMD pass the `-no-pie` flag to GCC.
I don't understand. Why would it change? You're not doing anything to it. You're just looping through it and printing it. If you want it to do what you want you need to popFront inside the loop.
popFront is where the code is that generates the next number, so I assume the foreach loop must be calling popFront on "range". If it's not then how can it be generating the number?
I think you're confused about how they work. It's looping through it like an array. It's not changing anything. Foreach does not automatically popFront a range.
Not when [compared to Nim](https://github.com/timotheecour/D\_vs\_nim). ;-)
 struct Fib { int current = 0; int next = 1; enum empty = false; @property int front() const { return current; } void popFront() { const nextNext = current + next; current = next; next = nextNext; } @property FibonacciSeries save() const { return this; } } I'm just following along with an example from [this book](http://ddili.org/ders/d.en/ranges.html). Something is calling popFront or else I wouldn't be getting the proper numbers for the Fibonacci sequence. 
Yes...you still need to call popFront on the range you create if you want to create a pyramid output the way you describe. popFront is called to create the original range. You still need to remove the numbers somehow one by one if you want them to be printed as a pyramid. Simply looping through the range won't do that....
I thought the whole point of ranges is that they're lazily evaluated. If they aren't then how can infinite ranges work?
Adding range.popFront(); after write(n, " "); gives me this output: 0 01123 1 1123 1 123 2 23 3 3 Maybe try and see before you argue...
What I am trying to figure out is how the range object is getting used. What I assume is happening is that foreach will call whatever range it has been passed until the range's empty function returns true. Otherwise it stores the result of popFront into the other argument in foreach, in this case "n". Calling the save method on "range" is supposed to create a copy of it with the same position in the sequence, but it's not. I don't understand why it's not saving properly.
Take a look at this: https://tour.dlang.org/tour/en/basics/ranges That is not how ranges work. Internally it will create a copy that is destructively iterated but your original range is not. If you want to print your range in a loop and have the first value removed each time you need to put it in your loop.
Don't worry about it, that is what the GC is for!
Depends. Literals are rvalues, so `""` and `[]` are safe to use as default arguments. For lvalues on the right hand side, it's better to use immutable.
In D, literal expressions like `[...]`, `"..."`, or struct literals are rvalue expressions. When a default parameter is initialized with a literal, there shouln't be any lasting side effects. If the right hand side of a default parameter is an lvalue expression (like a global variable), I'd say it's a good idea to add immutable.
foreach DOES automatically popFront ranges - that's how it advances. I think the confusion though is that the range is passed by *value* to foreach, not by reference. So it is popFronting its own copy of the range.
Ya i've gotta be honest I don't think i've ever used foreach over a range that was a reference type before. I knew a copy was created for value types but I didn't know it would destructively iterate over a reference type range. So just out of curiosity, if the fib range was implemented as a class instead of a struct or the struct was passed by reference would it have worked the way op wanted it to?
It is because the range object is a struct so it is being copied by value into a temporary variable. The range variable is not actually being altered. Look at std.range.refRange it should likely solve your problem.
yes. (well, not exactly, there is still a bug in it, but it is a lot closer). though note that `save` with a class range must construct a new class.
And anyone using it shot on sight.
[Project homepage](http://rainers.github.io/visuald/visuald/StartPage.html)
It's an informative read but I would say that these are advanced features and relatively minor. Having them is surely nice, but not having them does not make D less popular than other languages.
Some might argue that autodecoding was a mistake, though given the number of times that has been discussed, maybe yet another discussion isn't needed.
&gt; @property getters &gt; What are these for given the optional parentheses for functions with no parameters? They affect `typeof(foo)`. With a function, this is `int()`; with a getter, `int`.
GC. Everything else is irrelevant. GC.
I agree it's more "connoisseurs" wishes (template UFCS and template lambda). But i like the concept, having written a hand of non trivial template metaprog stuff.
More good work sponsored by Symmetry Investments [GitHub Repo](https://github.com/kaleidicassociates/autowrap) [DUB Package](http://code.dlang.org/packages/autowrap)
I had the same problems: Suddenly, a while ago and it ended with an upgrade to 64BIT. Where upgrade is little misleading...
&gt; I think there’s a general consensus that @safe, pure and immutable should be default. Which leads me to: This seems crazy. While immutable by default might work, @safe and pure by default sounds crazy. I don't want D to become Haskell, where you have to do crazy workarounds just to add an equivalent of printf to a function :(
&gt; If you update the definition of a struct and change its size or layout, and that struct’s used in another file, that other file needs to be recompiled. If you change a template and that template’s instantiated in another file, that other file needs to be recompiled. But Meson doesn’t figure out those relationships, and neither does Ninja, so it doesn’t rebuild everything required. Only the compiler can figure out these dependencies precisely and quickly. Ninja [can read this information from any compiler that emits it in makefile syntax](https://ninja-build.org/manual.html#ref_headers). In general: if a language has its own native build tool, don't try to avoid it. Only use Meson for things that tool doesn't do well. A good example is [Fractal](https://gitlab.gnome.org/GNOME/fractal/blob/b4dc4d2b6f987808d15c53dfb78e50b1b2b7b3b0/meson.build): the binary is built with cargo, Meson just calls cargo to build it, and builds gresources/gschemas/i18n/.desktop/etc.
C is still the king of embedded, though. Or is D capable of the same, and it's just a mindshare issue?
turns out after looking through the sdl parsing source of dub, its quite straight forward... &gt;name "runz80" &gt; &gt;targetType "executable" &gt; &gt;lflags "libz80/libz80.a" &amp;#x200B; &amp;#x200B;
&gt; C is still the king of embedded, though. That doesn't mean C is safe. Eventually there is going to be a HUGE screw up and thousands of people will die and the politicians will step in and legislate and C will be thrown on the trash heap along with 90% of the currently used languages.
C has been very successful thus far, so I don't think your worries will hold.
Its better to ask questions on [D forums](https://forum.dlang.org/group/learn).
I'm not worried about it. I'm looking forward to it.
[Forum announcement](https://forum.dlang.org/post/iaefhtaievdlkklrsjwl@forum.dlang.org)
Personally I would recommend against it if you're not an experienced programmer, because setting up a D environment isn't the most straightforward thing (depending on your technical aptitude outside of programming, which operating system you use, etc). For a novice I would recommend any of those other languages since they are a lot more beginner friendly with orders of a magnitude more tutorials and resources online, and just less cognitive overhead overall (for a non-programmer). I would only recommend D if you're already a bit familiar with C and another language. I know there have been great strides in making D accessible to even beginners, but in my personal opinion, unless you want a trial by fire, go with Node.js or Python for now.
Trial by fire is a stretch. VSCode with the combined plugin, and the normal D distribution is not super hard to toss together. That being said, I do think for his specific project type that node.js will be the fastest option from start to finish.
Keep in mind, node.js basically specializes in web clients and servers. I would suggest typescript and parceljs if youre going to use node though. D could certainly be an option. If you like the language go for it.
D would work alright. I wouldn't use the phobos sockets or networking stuff though. Something like vibe-D would be a better way to go. https://code.dlang.org/packages/vibe-d https://code.dlang.org/?sort=updated&amp;limit=20&amp;category=library.network
D will just make you hate future languages you try to pick up, while things like Node have actual job openings and tutorials and such. D is an awesome language, but not a beginner language.
https://dlang.org/articles/cpptod.html
[rosetta code](http://rosettacode.org/wiki/Category:D)
https://dlang.org/phobos/std_socket.html#.Socket.accept https://dlang.org/phobos/std_socket.html#.Socket.receiveFrom https://dlang.org/phobos/std_socket.html#.InternetAddress.this.2 https://dlang.org/phobos/std_socket.html#.Socket.send
I've come to the opposite conclusion. D meets or exceeds the getting started complexity, with the exception of a lot fewer doc/articles to help learn the basics. Seriously the world outside D is just as messy, people are just use to it and push through it because they've been told it is easy.
Are you specifically trying to recreate this code, or are you trying to create a HTTP server? If 1), then /u/youstolemyname has the right answers, if 2), [vibe.d](https://tour.dlang.org/tour/en/vibed/web-server) is a very nice way to set up a HTTP server.
TcpSocket inherits from Socket. Socket is at the bottom of the docs. Here's [isAlive](https://dlang.org/phobos/std_socket.html#.Socket.isAlive). 
Just google "dlang &lt;topic&gt;", for instance "dlang isAlive", "dlang bind", etc.
Tip. Ask questions on [forum](https://forum.dlang.org/group/learn) because it has more users than reddit
I don't really get the obsession with benchmarking, as long as its reasonably comparable (speed wise) with other compiled languages, then features like (for example) robust memory management (without too much pain) are for me far more important...
Well, to tell if they are reasonably comparable you would need to compare them
Sure, but the "speed tier" each language tends to belong to is fairly well known. If I were to run a benchmark and it found that the C version was faster than the Python version, how many people would find that surprising? How many would consider that new, useful information?
It's time for the annual retrospective at the D Blog. What went right, what went wrong, and the stats.
I really enjoy the articles about real-world projects. I'm sure those are the most time consuming to write, but they're really informative. Great stuff, Mike!
As far as how useful the numbers are to me in everyday work, they're pretty useless. There are many factors to choosing languages and libraries, speed is only one piece. But as to the obsession, it's an easily measured and easily compared metric for people that aren't familiar with internals of a language. For example, C is faster than pretty much anything but most of the time a language with memory management is a better choice for programmer productivity.
If you use duckduckgo, you can type something like `!dlang writeln`and it will search the dlang documenation and forums for you. I use it all the time.
It's not bad. Note that there is also a quick start (somewhere) on the dlang website which might be worth checking out. I'm on mobile, so I can't conveniently get the link for you.
https://tour.dlang.org/
This article is poorly-written and full of inaccurate statements and bad advice. A much better resource for getting started with D is [the official Dlang Tour](https://tour.dlang.org/), which includes [instructions for setting up a D development environment on your computer](https://tour.dlang.org/tour/en/welcome/install-d-locally).
Thank you! I'll be sure to check it out!
Will check out thank you for input!
It's not too bad but people might think that it's OOP language after reading your post. Maybe try to add a sentence like the one I add here _But keep in mind that D has some quite neat features: D is object-oriented like java and still makes memory access available like in the C-family. In addition other programming paradigm are supported : template meta programming, functional, contracts._
I will thanks!
You can _sort of_? There's `-betterC` flag, which removes the entire D runtime, including the GC by extension, but you quickly notice how many subsystems still use it by the fact that they want to do GC calls and run into undeclared runtime functions.
Thank you for your response. By “rest of the runtime”, do you mean the standard library as a shared library? Otherwise I’m not sure what else the runtime would entail. Either way, ‘void main() @nogc’ seems like a good option for me, so thanks! I’ll have to give it a try.
&gt; By “rest of the runtime”, do you mean Module constructors, exceptions, unittests, the main wrapper, stuff like that.
Oh, right, duh. Ok thank you
Pardon my late response, but I think the point is that @safe, pure, and immutable would go away as keywords and become the default and instead *when necessary* functions could be annotated with new alternative keywords @unsafe, impure, and mutable as needed. So the D language should support all the same features it does today, including printf. It's just that safer options are the default and you have to make it clear to the reader (and the compiler) when you're doing something else.
Well ok, I'd agree about @safe, but making pure the default sounds like a fantasy of a functional language programmer. Printf isn't even pure. Imagine you wanted to drop a printf call somewhere in your pure code. You'd have to make unpure all the calls along the method call chain. I think pure is nice for a small methods where you want additional guarantees, but I don't see it working as a default.
I see. Yeah, that's a hassle for good old print-debugging. 
The TODO list widget was broken in yesterday'd release.
I feel rust was won the battle at this point in terms of being a systems language. But it could lot more from D expressiveness
I agree with this. I’ve tried Rust, but I go back to D because of its metaprogramming. I also have learned C++ in the last two years, and can get by with it and the new constraint constructs but I still prefer D. Maybe I can make my fantasy a reality with a bit of legwork now, though. 
Adam Ruppe brings his 'This Week in D' chops to the D blog for a look back at D in 2018.
Is there a good resource for the C++ interior story?
you mean interoperation? but actually, no, it looks like the docs are a bit out of date https://dlang.org/spec/cpp_interface.html#cpp-namespaces That still gives you 80% of the view though, so better than nothing.
In general it is frowned upon because it is noise and adds nothing (unless you have messy imports). The preferred option is to use selective imports instead of renamed ones. Which make it very explicit.
Hey, it's why I use it. Now if only I could convince all my employers to...
When GC gets truly optional, then it's gonna be nice.
You can also use imports in your functions/methods/nested scopes, so that they are more targeted to the place where they're being used. void someFunction() { import std.stdio: writeln; writeln("hi"); } 
At the moment, I use D like I would C ~ except that with D, I get bounds-checking features, modules, no header mess, superior macros, etc. Might use templates at some point, but rarely. :)
There's stuff that C++ gets unequivocally better than D. (Lambdas being template parameters is idiotic and doesn't work right - try to make a function that takes lambdas and is a struct member function...) And there's stuff in D that's just a garbage fire, like synchronized and invariants, or perennial cringe favorite 15984. That it is nonetheless the best C-like language out there is a scathing indictment of the ecosystem more than anything.
Yes i know that. I actually started to contribute to DMD last year and i'm involved in the tooling. We sometimes speak on irc#d when you're at work... So i definitively seen ² at some point. About ¹ i think there's a PR, right now, that's related. I've myself have or had a few bugs reports that i could qualify as "emblematic" and fortunately managed to fix a couple of them.
-betterC i presume ;)
Nah, just plain D. :)
It depends on what your motivations are for learning the language. I learned it because no other language that I could find allows me to express my ideas exactly as I think about them (i.e. Modeling Power), can target multiple platforms including resource-constrained microcontrollers, can produce optimized native binaries (i.e. Native Efficiency), and also offers the convenience of modern programming languages like C#, Java, etc. (i.e. Modern Convenience). Watch [this video](https://www.youtube.com/watch?v=Kn88228KSpQ) for the references I made. I didn't learn it because I thought I'd be able to get a higher-paying job, or to expand my skills. I learned it so I could enjoy programming more. In 2017\~2018, there was a "State of D" survey. One of the questions asked respondents to describe D with 3 words. One of the most common words used to describe D was "fun". Beware, there's a catch. You'll often hear on the D forums how D ruins some careers. That is, after learning D, they like it so much, they no longer enjoy the language they must use at their place of employment. D is not without its frustrations, however. Often D can inspire one to see just how much better programming can be, and the student of D will quickly see that D has not yet reached its potential. After learning D, it became apparent to me that D was not created to improve on C++, but to improve on Java. I have a love-hate relationship with D because, although I love the power and convenience it offers me, it has a lot of historical baggage that the powers-that-be are not willing to shed to unleash its potential (e.g. `@safe` by default, `final` by default, decoupling the language from the runtime), and instead resort to workarounds (e.g `@nogc` and -betterC). Unfortunately, it is that unwillingness to polish the language that will always keep D down as an eccentric language with a cult following. I believe, at least at this moment, that D will only become mainstream if it is forked and placed under new management that is willing to drop the historical baggage and technical debt and provide a more progressive stewardship of the language. Until then, it can still be an enjoyable language to use for those who truly love the craft of programming. So, should you learn D? Only if you write software for the love of it, and don't expect to actually have a career using D (though there are some D opportunities out there for a select few).
Completely agree on D's problems, which is really hard to say because I have so much respect and admiration for Walter and Andrei. D is so held back by its legacy; there's this amazing Hope Diamond of a language with all this cruft keeping it down.
Rust has the [edition system](https://rust-lang-nursery.github.io/edition-guide/editions/index.html) that allows for introducing most types of breaking changes on a crate-by-crate basis. It probably wouldn't work for something like decoupling the runtime, but it would do fine with changing defaults and such. 
80% of people just need to know a scripting language like Python, in addition to things like SQL, HTML, CSS, etc. You can use that for almost everything. 15% of people also need to know a highly scalable modern [systems language](https://en.wikipedia.org/wiki/System_programming_language) with (optional) GC, like D, Go, Nim, etc. (Old-school corporate thinking says Java or C#, but I think native languages now have the advantage.) You can use that for lean apps, high-performance Web APIs, etc. 4% of people also need to know C/C++ to contribute to high-brained projects like OS kernels, highly optimized database engines, etc. 1% of people need to know languages like Haskell, so they could tell us how super-smart they are...
&gt;80% of people just need to know a scripting language like Python funny you say that, D is easier to use than Python using only basic template features but then many other languages are easier to use than Python ;) 
I understand that you like D and are good at D, so for you it might be a more productive tool than Python. I'm a Nim fan myself, with D coming in second. But that is subjective. My post was a "bird's eye view" response to "Is the D programming language worth learning?" Scripting languages simply involve fewer concepts for beginners to learn, and less code to do the same thing. Python is understood by tens of millions of devs, and is increasingly taught to all students from grade-school to MIT. PyPI has 112 times [more modules](http://www.modulecounts.com/) than DUB. There are hundreds of high-quality books on applying Python to specific domains: home automation, data science, game dev, office scripting, IoT, blockchain, robotics, biochemistry, ML, etc, etc, etc. Python even has [some Web frameworks](https://www.techempower.com/benchmarks/#section=test&amp;runid=ab8299fb-ed96-4601-9461-b1c837409582&amp;hw=ph&amp;test=json&amp;l=zhb187-7) benchmarking better than D... So my point is: D isn't for everybody. But it's a good "modern systems language with optional GC".
I'm pretty bad at D so my familiarity with it is not the reason I say it's easier to use than Python. I am quite familiar with Python and have used it in production and banged my head against its limitations, that's why I say D is easier :) . For example did you know that in Python if you declare a variable in a loop it is visible outside the loop ? The smallest scope Python knows is the function. Take a look at the answers here [https://stackoverflow.com/questions/41573587/what-is-the-difference-between-venv-pyvenv-pyenv-virtualenv-virtualenvwrappe](https://stackoverflow.com/questions/41573587/what-is-the-difference-between-venv-pyvenv-pyenv-virtualenv-virtualenvwrappe) to have an idea about the complete chaos in the Python ecosystem, they're trapped into an endless September . The Python people tied their fate to the AI hype. When this round of AI hype will be over Python will join LISP in the "how do we make fun of students"-toolkit of the academia. 
That's a perfectly valid use of conditional imports. It's neither "bad" nor "good". Nor would I say it's "frowned upon". It's a tool in the toolbox. Use it if it makes you happy.
One day D will be recognized God damn, it's such a nice language and still no one uses it. It kinda proves the old adage of 'build it and they will come' is not really true. 
I love D, and i contribute money to the foundation here and there. That being said, it does give a feeling of having unfinished edges. And it's a bit old to be giving that look. Particularly the language-team/foundation needs to directly provide: * One, fast compiler -- the fact that the fast compilers are produced elsewhere and lag behind reference makes the user immediately make an uncomfortable decision when coming to D. * A solid, featured build tool that enabled (and documents the process for) highly-customizable builds. Custom build steps, offline usage, custom in-house tool support, RCS integration, etc. * A solid code editing environment -- the user has to string a few tools together to get this, and it can be an error prone process. If the user has to hunt around the web to get those 3 things -- a significant number of them will pick something else. They can't convince their teams to take up D if they have to make excuses for decisions made in these 3 categories - the competition is just too good.
D is great! Unfortunately, TIOBE's programming language popularity index is garbage. I hope the increase is true.
Your third point is where I almost dropped D myself. I not even sure D has anything close to the experience I have with eclipse writing Java code. No idea why this isn't talked about more. If c/c++ had a forward referencing and garbage collectors I'd be using them instead of D, due to the idea situation.
Visual Studio Code and Atom and their portable, pay-as-you-go modularity are a better model than the monolithic IDEs. To be honest, if the VSCode plugins were better documented and worked a bit more stably we would be getting close to acceptable. I personally had to dig thru a number of stack overflow articles to get configured properly, and my DCD integration often just stops working, requiring a restart. Also added dub dependencies don't seem to get DCDs attention without a restart. And I don't think C++ needs a garbage collector, modern c++ memory management is not that bad. It's real problem is how headers/templates are handled and the resulting compile times.
What is D's most direct competition in your view?
Modern C++
memory safety one reason I really like D !
It's not "garbage". It's a reputable and often-cited index that's based on one way of measuring language popularity: averaging together rankings from multiple search engines. **There are of course other ways of measuring proglang popularity, and reasonable people can disagree on which is best.** * [PYPL](http://pypl.github.io/PYPL.html) omits D entirely. It's based solely on Google Trends. I think this is worse than TIOBE, because it strengthens Google's power monopoly. It could just be that more D devs use DuckDuckGo or another search engine - which is a good thing! * Many studies, like "[GitHu*t* 2.0](https://madnight.github.io/githut/#/pull_requests/2018/4)", are based on GitHub usage. D didn't make the Top 50 in last yearly quarter for "Pull Requests" or "Pushes"; and it ranks #46 in "Star" events, and #50 in "Issues". IMHO, it is unfair to punish a community for not contributing to GitHub's power monopoly, but for hosting some of their code in independent repositories instead. * [IEEE's yearly ranking](https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018) puts D in 30th place. It averages together many things, including the unfair measures I've mentioned above. Here D could also be being unfairly punished for using a self-hosted forum more than Reddit, not being as active in social media, etc. No popularity test is perfect, but I'm yet to see one better than TIOBE. 
Oft-cited doesn't make it reputable, it just means lots of people believe it has some merit, but doesn't mean it does. Yes, Google Trends may be as bad as TIOBE but at least it has a time component to it, which TIOBE doesn't outside of the sampling they do each month, but that sampling doesn't distinguish between old and new results. Github could have merit, depending on which definition of popularity you are using. StackOverflow could have some merit, depending on which definition of popularity you are using. RedMonk uses both GitHub and StackOverflow. Reddit user count is garbage. &gt; No popularity test is perfect, but I'm yet to see one better than TIOBE. I think job listings are useful, again depending on what definition of popularity is being used. Job listings also have geographic data making it useful for certain countries or other geographic areas. To know whether any of this data is relevant to ones definition of popularity, you have to know what question you are trying to answer. TIOBE doesn't really know what question it is trying to answer. What does popularity mean? Some good questions might be: * How much demand is there for each programming language among employers? * How many open source projects are hosted on GitHub for each programming language? * How many programmers are working on improving the language? None of the surveys are very accurate. Job listings are probably the best of those listed, assuming it fits the definition of popularity one is using. Github and StackOverflow aren't useless. Google Trends is next. Search engine results have the least merit of the bunch, therefore TIOBE is garbage, relative to the rest.
Everything is relative. My choice is often between D and [Nim](https://nim-lang.org). I prefer Nim's syntax and portability, but D's IDE / editor support is far ahead. Nim gives the user a lot of control in the trade-off between minimal compilation lag and maximum code optimization (by choosing the C compiler), but D does as well (the choice between dmd and ldc). You need a good computer to made decent optimized binaries quickly (or rent one from the cloud on demand). 
I say it's [Nim](https://en.wikipedia.org/wiki/Nim_(programming_language)). * D and Nim are close in their [performance](https://github.com/kostya/benchmarks), with the ability to produce lean optimized binaries consistently ahead of Java, C#, Go, Haskell, etc. (Nim has the edge on some platforms by using any specialized C compiler as backend, including proprietary specialty compilers like [icc](https://en.wikipedia.org/wiki/Intel_C%2B%2B_Compiler) or [xlc](https://en.wikipedia.org/wiki/IBM_XL_C/C%2B%2B_Compilers), which are ahead on their specific hardware.) * Both languages are compiled [systems languages](https://en.wikipedia.org/wiki/System_programming_language) with **[GC](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)) by default**, but are evolving toward making it optional. * Both offer **less verbose syntax** than other safe languages like Rust, Ada, or even Java. Nim takes many things from Python (including the "[off-side rule](https://en.wikipedia.org/wiki/Off-side_rule)", which I like), while D remains closer to the curly brace traditions of C / Java / JS (which more programmers are used to). The growth of Python as the most popular introductory programming language is in Nim's favor. * Both offer many advanced features, including early support for [**UFCS**](https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax) and metaprogramming features (although Nim is [said](https://forum.nim-lang.org/t/1779) to be [ahead](https://github.com/timotheecour/D_vs_nim)). * Both languages started as **grass-roots** hobby projects by a single person - without corporate, university, or government support. A lot of people are starting to dislike certain corporations, and see their pet languages as their PR, which is an undesirable foundation on which to build genuinely free software. * Both have permissive [(**copyfree**)](http://copyfree.org) licensing for the compiler (unlike Java, Perl), stdlib (unlike Python), major tooling (unlike C#, NodeJS, Rust), and the [majority of the module ecosystem](https://archive.fo/YShGX) (now D=80.772%; Nim=85.982%). 
&gt; Oft-cited doesn't make it reputable, it just means lots of people believe it has some merit, but doesn't mean it does. And it doesn't make it "garbage" either. &gt; RedMonk uses both GitHub and StackOverflow. Not everyone uses those corporate mega-sites. I for one was boycotting GitHub (for pushing certain politics) even before they were acquired by Microsoft. Regardless of their politics, having GitHub control code that everyone executes on their machines gives them tremendous centralized power. There could be cultural patterns in users of certain programming languages being more likely to be hipsters, or users of other languages more likely to be old-school tin-foil libertarians who even run their own mailserver and VPN, much less public repositories for their code. &gt; I think job listings are useful, again depending on what definition of popularity is being used. There's selection bias in favor of business languages (Java, C#, R, even COBOL!) and against languages uses by startups and hobbyists. Not everyone uses GitHub, SO, Google, Twitter, etc. Not everyone gets a salary. Not everyone writes on dead trees for sale on Amazon. Etc. **But everyone uses the WWW!** And that's [what TIOBE measures](https://www.tiobe.com/tiobe-index/programming-languages-definition/) - number of pages mentioning a given language.
Rust
&gt; I not even sure D has anything close to the experience I have with eclipse writing Java code. I don't think you'll ever have it. Java is a simple language to parse and everything is done in OOP style. As a result, IDEs know everything about what's going on in the code and you can add OOP specific IDE features like "extract this code into method" "extract this method into interface". With D you can't really have that. A lot of the code is only generated at build time, often through some arcane mixin/template magic. On top of that, a big part of the community doesn't do OOP at all, so such features would be no use to them. Most D IDEs even get confused by foreach (foo; foos), not being able to tell what type foo is. Still, I believe D IDE support is on par with C++ for the most part, it's just that Java and C# are a different league.
&gt; And it doesn't make it "garbage" either. Yeah, but I didn't claim that, while you claimed it was a reason it was reputable. &gt; There's selection bias in favor of business languages (Java, C#, R, even COBOL!) and against languages uses by startups and hobbyists. Certainly but if you're looking for a job then I think that would fit a job seeker's definition of popularity. &gt; But everyone uses the WWW! And that's what TIOBE measures - number of pages mentioning a given language. Yeah, but most of the web isn't indexed and as I already mentioned, TIOBE has no way to determine the age of any of those search results so their numbers are reflecting the entire life of each language and not each year, let alone each month. All of these ranking algorithms are severely flawed because they are trying to index something that is very difficult. There is no one place to go to poll everyone. They each tally it up in different ways and even when aggregated together, it is a poor picture, but it's slightly better than nothing. TIOBE on it's own is next to worthless. Another good question would be, "Which language should i use for my project?". Again, TIOBE is useless for that.
D is just as portable as Nim if you use dmd. I'm not sure what Nim's performance looks like these days, so i can't say if dmd makes faster or slower code. But if you are on linux/macos, it seems silly not to use gdc/ldc. They simply utilize the hardware better at this point.
Java definitely is easier to write an idea for. But I still see a fair bit of improvement for D ides given the compiler can build a full AST of my code with sematic anlaysis in seconds, and my current ide can't tell me my code fails syntax checks or figure out what function overload I'm calling, or as you pointed out figure out types in foreach loops.
&gt; D is just as portable as Nim if you use dmd. DMD is only still [being ported to my favorite BSD](https://forum.dlang.org/thread/hpauduyizitshugjjbfa@forum.dlang.org?page=3) (not there yet), not to mention even less common Unix OSes. [Nim works everywhere](https://github.com/nim-lang/Nim/blob/af0c497f5dd375b83ab2f51ab4619e2843b846b5/compiler/platform.nim#L22) C works, including MS-DOS. &gt; I'm not sure what Nim's performance looks like these days, so i can't say if dmd makes faster or slower code. [Kostya's benchmark](https://github.com/kostya/benchmarks) shows LDC slightly ahead of Nim+Clang (possibly it had a different version of LLVM), but both are far ahead of DMD. Nim lets you choose an ideal C compiler for the platform and whether you want fast compilation or better optimization. In my experience, Nim+[ICC](https://en.wikipedia.org/wiki/Intel_C%2B%2B_Compiler) (Intel's proprietary compiler) resulted in much better performance than either Clang or GCC.
&gt; After learning D, it became apparent to me that D was created not to improve on C++, but to improve on Java. Haha. From my perspective, D is trying too hard to be a better C++, when it should have went full on Java route. I guess that's part of the fun D brings - it's a jack of all trades, you can use it procedural, functional, OOP style.
&gt; For example did you know that in Python if you declare a variable in a loop it is visible outside the loop ? The smallest scope Python knows is the function. This isn't surprising. Many languages have function scope. It's useful actually because you can for example break early and still keep the loop counter to know when did you break. &gt; Take a look at the answers here https://stackoverflow.com/questions/41573587/what-is-the-difference-between-venv-pyvenv-pyenv-virtualenv-virtualenvwrappe to have an idea about the complete chaos in the Python ecosystem, they're trapped into an endless September virtualenv + pip seems to be de facto standard for the moment &gt; The Python people tied their fate to the AI hype. When this round of AI hype will be over Python will join LISP in the "how do we make fun of students"-toolkit of the academia. Except it's the most popular scripting language at the moment. Most people who want something more powerful or crossplatform than Bash usually migrate to Python.
https://www.phoronix.com/scan.php?page=news_item&amp;px=GCC-9-Merges-D-Language We should see D as a GCC language front end any time now. Hopefully that means portability for you too. I certainly know I'll use it more if I can drop it in with GCC. I think Nim macros and cpp interop both have way too much noise in them. There also seems to be a lot of odd deviations with ramifications that you need to understand like how they handle dynamic dispatch, that I would prefer not to reason about. I suppose most of those are artifacts of needing C compat on the back end. I also find python syntax to be the least attractive of all the syntaxes in popular use today. D just has a really pleasant mix of cool features, performance, and familiarity. As far as JS, I think using anything but typescript and node for that development is a waste of time. The JS tools are just too good. Parcel is like magic. And the editors just work. 
I've used this a little bit: https://code.dlang.org/packages/sumtype 
Thanks! I'm actually just trying to learn but I checked the library anyways and it looks cool! Thanks again
... all functions have function scope, most of them have scopes smaller than the function useful ? how about "it was easier to write the compiler that way" why bother with scopes there is no standard in Python for the moment, only lots of competing standards "most popular" because you ask for Python when you want fresh graduates when all the undergrads were doing was Java, Java was "the most popular" despite the fact that most of the code that got written was PHP and indeed BASH ;) 
Javascript is also function scope. If you don't have RAII, having smaller scopes is not such a big advantage anyway.
no, javascript has scopes smaller than the function, at least since const/let were introduced 
There’s also the `Algebraic` data type in the standard library, but IIRC the `sumtype` library is quite a bit nicer.
I think you meant variant, not variadic. Tagged union is common term also.
It wouldn't work because it isn't a single letter. See [https://dlang.org/phobos/std_getopt.html] (https://dlang.org/phobos/std_getopt.html) under the section "Short versus long options".
you assume right.
BTW there's no bug to report, it's just that it tries to parse `s` as `-r` argument.
&gt; it's just that it tries to parse s as -r argument That makes sense. So -pt is parsed the same as -p=t, causing getopt to try and fail to convert "t" to a bool. &gt; BTW there's no bug to report Wouldn't defaultGetoptPrinter incorrectly displaying &gt;=2 letter short opts be a bug? Despite -rs being invalid it's still shown in the help menu and getopt didn't throw any warning or error about being handed a long short opt
https://twitter.com/D_Programming/status/1098581207095246849
Meh. As far as I know forums are hosted on a home server. I think it'd be better if it was hosted on a VPS :/
D’s nutz
no it's a server rent at OVH, administrated remote from Moldavia, and a bit of space and CPU is given for free by the guy who rents for his hosting activities.
The March update [(snapshot)](https://archive.fo/aISH1#selection-2085.0-2090.0) shows D at 0.618%, a small downward correction... 
I can't really speak much for .net, but I have had to emulate COM stuff for a virtualization thing I was doing. It's somewhat of a pain since the method is just WhateverInterfaceCreate(guid, ...), get your interface alloc, and then that alloc just has a bunch of C function pointers you can call. I think for D you would need to have a shim to sorta translate between a usable D class and the underlying COM objects themselves. Not sure how callbacks would work though.
&gt;It´s so easy with .Net... Well that's because both of those are MS technologies, and they needed those things to work together seamlessly for their own software, hence the ease. If you're in a hurry, I'd recommend just using Visual Studio / C++ to create a wrapper with a C API that you can use from D. Yes, in theory COM should be accessible anywhere, and if the interest/funding were there, no doubt D would have something easy to work with.
I haven't looked into it for a long time, but the usage side tends to be simpler - define the interface, CoCreateInstance, cast to the interface, and start calling. What specifically do you want to use?
I wanted to connect to an ERP system, which exposes its business objects as COM. Much work to do the interfacing manually. So I looked for a way to import the type libraries. Juno seems the only way, but Juno does not compile with current D.
You tried this version right? https://github.com/JesseKPhillips/Juno-Windows-Class-Library lemme fork that and update it. I don't have a COM test bed here tho, I haven't actually used it for a long time (and when I did, it wasn't actually for much), but if I can get it to compile maybe you can try it. I got it building, the message beep example worked https://github.com/adamdruppe/Juno-Windows-Class-Library so let me know if it works for you.
Borrow the borrow checker!
Works like a charm. Great!
First attempt at code golfing -- same output as your example, 119 chars: ``` void main(){import std.experimental.all;iota(1,100).map!(i=&gt;either((i%3?"":"Fizz")~(i%5?"":"Buzz"),text(i))).writeln;} ``` Another version with line-by-line output, 118 chars: ``` void main(){import std.experimental.all;foreach(i;1..100){writeln(either((i%3?"":"Fizz")\~(i%5?"":"Buzz"),text(i)));}} ``` Both versions import just about everything in phobos via "std.experimental.all", and both versions make use of `either` and the fact that empty strings are considered null, so that when the first argument in `either` is null (instead of "fizz", "buzz", or "fizz"~"buzz"), the second argument (the text of `i`) is returned. These are probably not the shortest possible versions, but I'm out of ideas.
&gt; and the fact that empty strings are considered null Huh! I did not know this! I enjoyed your use of ```either```!
Managed to get solution of 116 characters using array indexing: import std.conv,std.stdio;void main(){foreach(i;1..101)[i.text,"Fizz","Buzz","FizzBuzz"][!(i%3)|!(i%5)*2].writeln;} This nets me a runner up. Second solution by /u/rolandHD can be reduced to 114 characters by removing braces around single statement inside foreach, then applying UFCS to writeln() and text() calls.
```!(i%3)|!(i%5)*2``` I love the use of bits to calculate the list index. Amazing!
Has anyone used this? I've been pretty happy using Dlang IDE with D. How does this compare?
There are a lot of tasks in the D ecosystem waiting for someone to complete them. This D Blog post introduces two new initiatives aimed at making that happen.
&gt;Finally, you’ll soon be able to support D through the DLang Swag Emporium, where you’ll be able to purchase D-themed t-shirts, coffee mugs, and more. I can't wait!
Can’t wait for stickers!
Classes add a little overhead - they are fields + vtable pointer (in all cases!) + a monitor pointer. structs are sum of fields + padding though. The ldc and gdc functions inline and optimize very well, dmd does only inline well in simple cases though. But really most of D's things optimize very well.
Godbolt supports D. You can probably get a definitive answer there pretty readily.
D has the [`extern(C++) class`](https://dlang.org/spec/cpp_interface.html#using_cpp_classes_from_d) that does not have the minor overhead of D classes. It's meant for [interfacing to C++](https://dlang.org/blog/2019/04/08/project-highlight-dpp/), but there's nothing stopping you from [using it in ordinary D code](https://run.dlang.io/is/tjPveI). Using D's fantastic metaprogramming features, you can also [roll your own classes out of structs](https://theartofmachinery.com/2018/08/13/inheritance_and_polymorphism_2.html) There's lots of power with D.
With powerful templating, classes become a lot less important. All your data types should be classes. If you allocate it during every unit of work, it should almost certainly be a struct.
What’s the difference?
Classes have a vtable and support subtyping and Liskov substitution, ie. you can assign a subclass to a variable or parameter of the parent class type. Structs and templated functions work more like duck typing - the type doesn't declare its behavior by inheriting from a superclass, the function checks the type directly and errors if it's incorrect.
If struts actually have duck typing, like python and JavaScript, that’d be a big plus in my book.
"Compile-time duck typing" iow templates.
Oh, lol, dang. Although I know d templates are more powerful (symbol arguments), so that’s worth something.
[std.container.array.Array](https://dlang.org/phobos/std_container_array.html) might suite your needs to some degree.
[https://github.com/caraus-ecms/tanya](https://github.com/caraus-ecms/tanya) [https://github.com/gecko0307/dlib](https://github.com/gecko0307/dlib) These might be of interest, there are a few similar things tootling around on GitHub/dub.
int.
That still a thing?
Thank you all for your suggestions; tanya looks very promising.
Hi there! I'm sorry, I know nothing about Meson, but I'd like you to know that the D community isn't very active on reddit. You'd have much more answers if you post on https://forum.dlang.org/group/learn
Incidentally, I've been slowly working through the *actual* stl containers. Keep an eye on `core.stdcpp`, simple ones are in now, PR's are in advanced stages for `string` and `vector`. You can use these containers in conjunction with `extern(C++)`, and they will interact with C++ code seamlessly. They use C++ `new`/`delete` for default allocation, and support custom allocators as usual stl containers do.
Hi, you can have all informations here: https://forum.dlang.org/thread/rvhtqcbwsicbvwbpclzd@forum.dlang.org?page=1 tl;dr: it's available through webex now, they're working toward a youtube stream but there are issues. Aside from that it's recorded and should be available a few weeks after the event.
excellent, thank you
http//deez.nuts
No problem. However I think you should go see the [Meson build system](https://mesonbuild.com) just so you know about it. 😊
I cannot answer for Meson, but for what it’s worth, I managed to find a working configuration for Dub. Example project: https://github.com/mcandre/dale
DMD is the reference compiler; it's the "official" implementation of the language and the one that is most thoroughly tested by the developers. It uses its own backend, so does not interface with other established toolchains like GCC or LLVM. GDC is the D frontend that interfaces with the GCC toolchain. Likewise, LDC is the D frontend that interfaces with LLVM. So if your toolflow is heavily invested in either GCC or LLVM, you'd likely use GCD or LDC respectively. They're not as rigorously tested and sometime lag behind DMD on new features. So if you want the latest and greatest features, you use DMD but take a small penalty in that it might not integrate into your toolflow as well, and lose out on some of the optimizations you might get from GCC/LLVM. If you care more about those optimizations and your toolchain, you use GDC/LDC and possibly lag a bit behind the bleeding edge of new D language features.
Refer to jrallen for the description of all 3 compilers. DigitalMars is a company indeed. DMD was never sold. For some time only its frontend was Free but the backend is completely Free too now (it's always been open-source but there were issues with redistributions due to some symantec involvment IIRC). Anyway, that's all in the past now, everything's Free and good. But due that situation may be why GDC and LDC were created in the first place: not only do they benefit from the powerfull GCC and LLVM backends but they had less licensing issue. Today it doesn't matter as much anymore. I believe DigitalMars still has some revenue from its C++ compiler (which was a commercial product) and consulting work. However DigitalMars isn't the entity behind D, the D Language Foundation is (https://dlang.org/foundation_overview.html). DigitalMars is only the company that Walter Bright created where he created D, it doesn't have any decisionnal power (although as far as I can tell it only has one employee which is Walter Bright himself, and he personnaly has lots of decisionnal power as Benevolent Dictator). I do not believe any company owns the trademark, but to be fair I don't know if the foundation itself registered a trademark for it. D is still changing relatively fast. At the moment there is in particular lots of work done toward enabling more memory management strategies. There are allocators in std.experimental that are very exciting but not stable yet and Walter works on enabling reference counting and having more features work in betterC (ie: without the D runtime that includes the garbage collector). There's also an ongoing effort of specification since some parts grew organically so we need a real "standard" (putting quotes there since I don't thing going ANSI or anything is the goal at the moment). Andrei Alexandrescu, the other person making decisions for D at the top level, has been in the C++ comitee a long time so he has a clear vision of the kind of structure he'd like for D to grow in a well-defined manner. On that note a process was setup about a year ago to manage D Improvement Proposals and avoid any chaotic growth of the language without proper debate and justification. D has its issues, but I think it's going in a good direction right now. I don't know that it'll fit your need but I see potential.
On your first bullet point the 3 different compilers actually share a front end between the 3 of them (vid on the D comipler: https://www.youtube.com/watch?v=l_96Crl998E). And at-least 2 of the backends aren't d specific. And for the 3rd point the spec is still changing. Doubt they'll break a ton of old code on purpose tho.
I feel that Zig is looking like the best C replacement, purely from what I’ve seen and not from any first hand experience.
Would also add in terms of code generation, LDC almost(?) always produces faster executing code than DMD. I do not know how GDC compares, but assume it is also faster than DMD.
&gt; Is the D language design/specification still changing - or has it been fixed/stabilized? Stabilized: yes. Fixed: not fully. Things are corrected or enhanced casually by a formal process called the D improvements Proposals [DIPs](https://github.com/dlang/DIPs), just like many other languages. &gt; Why are there three separate compilers? Complementary to the other comments, I'd like to add that all share the same front-end (to a few differences such as the driver, obviously, or the inliner, which, particularity of DMD, is done at the AST level, not the IR one, so LDC and GDC don't use it I think).
&gt; There must be a reason why D has not gained much traction, and being an neophyte/outsider - I'd really like to understand why. Because it's not managed well. There's no one prioritizing bugs and other issues. For example u/WalterBright, probably the only one that has the ability to fix some of the difficult bugs in the compiler, is [more interested in doing trivial refactorings](https://github.com/dlang/dmd/pulls?q=is%3Apr+is%3Aclosed+author%3AWalterBright) than reviewing pull requests of others doing real work and fixing bugs and other issues that he is uniquely qualified for. Also, I think u/WalterBright and Andrei are a bit out of touch with the rest of the community. u/WalterBright and Andrei have a habit of discouraging people [Exhibit A](https://forum.dlang.org/post/pffvdn$v2$1@digitalmars.com) [Exhibit B](https://forum.dlang.org/post/qbfnq6$ed7$2@digitalmars.com) from working on small, but valuable, problems with the language. As a result, many that were once quite active working on D have left in frustration taking much of their knowledge about the language and expertise with them. D has a pretty bad turnover problem. There's much more to it than that, but it would take a long time to thoroughly describe it. See the "Big Forum Thread" section [here](https://dpldocs.info/this-week-in-d/Blog.Posted_2019_04_01.html#big-forum-thread) for a pretty good summary of the problem. [It was announced](https://youtu.be/cpTAtiboIDs?t=3049) that there will be some management changes. I hope that will result in improvements to much of the above.
&gt; Is the D language design/specification still changing - or has it been fixed/stabilized? D has some technical debt and some that work on D are trying to address it. Part of that is [deprecating features](https://dlang.org/deprecate.html). The deprecation process is... 1. Deprecation warning from the compiler for 1 year 2. Compiler error for 1 year 3. Feature removed from the language and the specification So, change happens gradually, which is good, because it allows users invested in D to gradually evolve with the language. D has evolved a lot over the years. For example templates, compile-time evaluation, user defined attributes, etc... were all added after the fact. The features are awesome, but they can interact badly with other, older, parts of the language that were not designed with those features. Therefore, old features are being deprecated, and new features are being added. Some of the upcoming features are copy constructors, reference counting, [rvalue references](https://youtu.be/nIXvs3mIg-E?t=4190), [a new object hierarchy](https://youtu.be/Vj6jNAlv03o?t=27948), etc... But those are all mostly additions to the language. So, for example, when the new object hierarchy is merged, the older object hierarchy will still work fine, but the preference will be to use the new object hierarchy. Perhaps after several years, the old object hierarchy will have fallen so much out of favor that it can be deprecated D will only need to support and maintain the new object hierarchy going forward. I guess what I'm trying to say is it's a living language, but change is gradual enough that it can be considered quite stable.
So would is this correct for running test in D? &amp;#x200B; \# test/test.d import core.stdc.stdlib : exit; /* * Prototype functions for setup and teardown. */ unittest { assert(2 + 2 == 4); exit(0); } /* * Main unit test function */ void main(){}
I initially thought you were harsh, but after reading (well scanning) the links, I think you are being firm but fair. I can buy the argument that D needs different stewardship. Andrei and Walter are tech maestroes. Their time is better spent thinking about hard problems and overseeing the "soul" of the language than get mired in day to day decisions. Language creators too get burnt out (eg: see Guido) because of daily acrimonious interactions.
Pardon me. Did you consider this may be a case of bad workman blaming his tools? Walter makes a nice comment. Andrei responds in the spirit of his Good Work/Great Work post which nails it. All languages get better by growing not changing. Are you sure your ideas are amazing and they are bad for not seeing them your way? I visit the D forums once in a while and it's always the same. Captain W struggling to resist wave after wave of bad ideas. Latest proposal is a guy wants to define his own bool type because he does not like some overloading rule.
&gt; As a result, many that were once quite active working on D have left in frustration taking much of their knowledge about the language and expertise with them. D has a pretty bad turnover problem. There's much more to it than that, but it would take a long time to thoroughly describe it. See the "Big Forum Thread" section here for a pretty good summary of the problem. Gossip. That blog post, too. I don't keep very close tabs on D but from where I stand most conference speakers and major contributors git/forum seem to go many years back. Many companies would be thrilled to pay for that commitment. You say others (such as you?) do real work but Walter is doing trivial work. That's odd, as an outsider I'd bet on Walter. Some detail to that? What real work is being ignored?
&gt; Good Work/Great Work post What is that?
Main has nothing to do with the testing and exit is unnecessary.
Ok removing exit functions ran the test it works but when I remove main an error is printed. &amp;#x200B; FAILED: test/test_exe dmd -of=test/test_exe 'test/9f86d08@@test_exe@exe/test.d.o' Undefined symbols for architecture x86_64: "_main", referenced from: implicit entry/start for main executable ld: symbol(s) not found for architecture x86_64 clang: error: linker command failed with exit code 1 (use -v to see invocation) Error: linker exited with status 1 ninja: build stopped: subcommand failed. Could not rebuild What should I do?
If your project is supposed to produce an executable it requires a main function, but when you build with the -unittest command-line option it doesn't execute main, only unittest blocks. If you build a library you wont need main.
Any examples for projects with unit testing D libraries and or executable applications? I keep seeing ones for executable projects where some include "exit(&lt;exit code value&gt;)" as part of the example and some don't. The main function seems to be there too more so than the unnecessary "exit" function. What's up with that?
This is incorrect. When compiling sources which also contain unittest blocks with dmd with the "-unittest" flag, when running the resulting binary, first the unittest blocks will be executed and after that main will still run. The claim that a main function is needed in some way to link a binary is true. There are different ways to deal with this: 1. Be fine with that and just ignore it. 2. Make sure the main is not run by simply excluding the file containing the main function from your build command when building for unit testing and provide the "-main" commandline switch to dmd (which will basically create a dummy main). 3. Prevent the real main from being called by excluding the file containing it from your build command and provide another file containing a dummy main. This is basically what dub does by default: It excludes the file configured as "mainSourceFile" (if not manually configured, this will be "source/app.d") from its unittest configuration and provides another source file which contains a main function. In this case it is not a dummy main however, but basically a custom unittest runner. 4. Use a custom unittest runner like https://code.dlang.org/packages/trial or the one provided by https://code.dlang.org/packages/unit-threaded which deal with this in their own way. Just follow the documentation in this case. 5. Use version blocks the version out the regular main in your unittest build: ``` /* * D test case */ unittest { assert(2 + 2 == 4); } version (unittest) { /* * unit test main function */ void main() { } } else { /* * Regular mmain function */ void main() { /* Do all the regular stuff here */ } } ``` This is basically necessary if you want to have unittests in the file that also contains your regular main function. So, what should you actually do now? I don't actually have a clue about how meson works with D, but since your question is about using either dub or meson, I'll answer for dub: I suggest you stick with the way dub does things by default unless you have an explicit need to deviate from that. i.e. do not include any unittest blocks in the file containing your main function (usually "source/app.d") because they will not be executed. Include unittest blocks in other sourcefiles and simply run `dub test` to run them. About all of this `exit` nonsense: You don't need this at all. No idea where you read about it... If you want examples of how other libraries / applications do it, just have a look at the packages listed in the dub registry: https://code.dlang.org/ I hope this answers your question in a satisfying way. If you need more information about how to do things with meson, I'm afraid I can't help you because I simply don't use it. You might have better luck asking in the learn forums / newsgroup (https://forum.dlang.org/group/learn) than here because there is way more activity over there.
Ah, darn it. Wishful thinking I guess. I just think that when I want to run the tests, I don't want it to also start the program...
&gt;Custom unittest runner So is there a way to run the test in the test from the main in "test/test.d" not the one in "src/main.d"? I am mostly trying to make a version based on an existing C template but in D language syntax using whatever tools D provides. [Example exe](https://github.com/squidfarts/c-project.git) and [Example Package/Library](https://github.com/squidfarts/c-package.git).
Of course this is possible, but how to do it depends on the technologies you want to use. There are several projects on the dub registry that do something very similar. I also created a small example project doing this by using DUB with no additional dependencies: https://github.com/ghost91-/tests-in-seperate-directory-demo
Hey, johannesloher, just a quick heads-up: **seperate** is actually spelled **separate**. You can remember it by **-par- in the middle**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Hey BooCMB, just a quick heads up: I learnt quite a lot from the bot. Though it's mnemonics are useless, and 'one lot' is it's most useful one, it's just here to help. This is like screaming at someone for trying to rescue kittens, because they annoyed you while doing that. (But really CMB get some quiality mnemonics) I do agree with your idea of holding reddit for hostage by spambots though, while it might be a bit ineffective. Have a nice day!
delete
delete
'delete'
For the type of technology I was considering was using [Unity](https://github.com/ThrowTheSwitch/Unity.git) so I would know that if I was running the test runner that it was definitely the [custom test runner](https://github.com/squidfarts/c-project/blob/master/test/test.c) returning the value of all test ran and not a mistake of running the main executable. But I am not sure if that would insulate the D programming community by not using the provided unit testing functionality in D. &amp;#x200B; Still trying get around the JSON syntax so that's something to put on my list of things to learn, probably going to ignore unit test main for now.
For the type of technology I was considering was using [Unity](https://github.com/ThrowTheSwitch/Unity.git) so I would know that if I was running the test runner that it was definitely the [custom test runner](https://github.com/squidfarts/c-project/blob/master/test/test.c) returning the value of all test ran and not a mistake of running the main executable. But I am not sure if that would insulate the D programming community by not using the provided unit testing functionality in D. &amp;#x200B; Still trying get around the JSON syntax so that's something to put on my list of things to learn, probably going to ignore unit test main for now.
For the type of technology I was considering was using [Unity](https://github.com/ThrowTheSwitch/Unity.git) so I would know that if I was running the test runner that it was definitely the [custom test runner](https://github.com/squidfarts/c-project/blob/master/test/test.c) returning the value of all test ran and not a mistake of running the main executable. But I am not sure if that would insulate the D programming community by not using the provided unit testing functionality in D. &amp;#x200B; Still trying get around the JSON syntax so that's something to put on my list of things to learn, probably going to ignore unit test main for now.
For the type of technology I was considering was using [Unity](https://github.com/ThrowTheSwitch/Unity.git) so I would know that if I was running the test runner that it was definitely the [custom test runner](https://github.com/squidfarts/c-project/blob/master/test/test.c) returning the value of all test ran and not a mistake of running the main executable. But I am not sure if that would insulate the D programming community by not using the provided unit testing functionality in D. &amp;#x200B; Still trying get around the JSON syntax so that's something to put on my list of things to learn, probably going to ignore unit test main for now.
For the type of technology I was considering was using [Unity](https://github.com/ThrowTheSwitch/Unity.git) so I would know that if I was running the test runner that it was definitely the [custom test runner](https://github.com/squidfarts/c-project/blob/master/test/test.c) returning the value of all test ran and not a mistake of running the main executable. But I am not sure if that would insulate the D programming community by not using the provided unit testing functionality in D. &amp;#x200B; Still trying get around the JSON syntax so that's something to put on my list of things to learn, probably going to ignore unit test main for now.
For the type of technology I was considering was using [Unity](https://github.com/ThrowTheSwitch/Unity.git) so I would know that if I was running the test runner that it was definitely the [custom test runner](https://github.com/squidfarts/c-project/blob/master/test/test.c) returning the value of all test ran and not a mistake of running the main executable. But I am not sure if that would insulate the D programming community by not using the provided unit testing functionality in D. &amp;#x200B; Still trying get around the JSON syntax so that's something to put on my list of things to learn, probably going to ignore unit test main for now.
For the type of technology I was considering was using [Unity](https://github.com/ThrowTheSwitch/Unity.git) so I would know that if I was running the test runner that it was definitely the [custom test runner](https://github.com/squidfarts/c-project/blob/master/test/test.c) returning the value of all test ran and not a mistake of running the main executable. But I am not sure if that would insulate the D programming community by not using the provided unit testing functionality in D. &amp;#x200B; Still trying get around the JSON syntax so that's something to put on my list of things to learn, probably going to ignore unit test main for now.
For the type of technology I was considering was using [Unity](https://github.com/ThrowTheSwitch/Unity.git) so I would know that if I was running the test runner that it was definitely the [custom test runner](https://github.com/squidfarts/c-project/blob/master/test/test.c) returning the value of all test ran and not a mistake of running the main executable. But I am not sure if that would insulate the D programming community by not using the provided unit testing functionality in D. &amp;#x200B; Still trying get around the JSON syntax so that's something to put on my list of things to learn, probably going to ignore unit test main for now.
For the type of technology I was considering was using [Unity](https://github.com/ThrowTheSwitch/Unity.git) so I would know that if I was running the test runner that it was definitely the [custom test runner](https://github.com/squidfarts/c-project/blob/master/test/test.c) returning the value of all test ran and not a mistake of running the main executable. But I am not sure if that would insulate the D programming community by not using the provided unit testing functionality in D. &amp;#x200B; Still trying get around the JSON syntax so that's something to put on my list of things to learn, probably going to ignore unit test main for now.
For the type of technology I was considering was using [Unity](https://github.com/ThrowTheSwitch/Unity.git) so I would know that if I was running the test runner that it was definitely the [custom test runner](https://github.com/squidfarts/c-project/blob/master/test/test.c) returning the value of all test ran and not a mistake of running the main executable. But I am not sure if that would insulate the D programming community by not using the provided unit testing functionality in D. &amp;#x200B; Still trying get around the JSON syntax so that's something to put on my list of things to learn, probably going to ignore unit test main for now.
For the type of technology I was considering was using [Unity](https://github.com/ThrowTheSwitch/Unity.git) so I would know that if I was running the test runner that it was definitely the [custom test runner](https://github.com/squidfarts/c-project/blob/master/test/test.c) returning the value of all test ran and not a mistake of running the main executable. But I am not sure if that would insulate the D programming community by not using the provided unit testing functionality in D. &amp;#x200B; Still trying get around the JSON syntax so that's something to put on my list of things to learn, probably going to ignore unit test main for now.
For the type of technology I was considering was using [Unity](https://github.com/ThrowTheSwitch/Unity.git) so I would know that if I was running the test runner that it was definitely the [custom test runner](https://github.com/squidfarts/c-project/blob/master/test/test.c) returning the value of all test ran and not a mistake of running the main executable. But I am not sure if that would insulate the D programming community by not using the provided unit testing functionality in D. &amp;#x200B; Still trying get around the JSON syntax so that's something to put on my list of things to learn, probably going to ignore unit test main for now.
For the type of technology I was considering was using [Unity](https://github.com/ThrowTheSwitch/Unity.git) so I would know that if I was running the test runner that it was definitely the [custom test runner](https://github.com/squidfarts/c-project/blob/master/test/test.c) returning the value of all test ran and not a mistake of running the main executable. But I am not sure if that would insulate the D programming community by not using the provided unit testing functionality in D. &amp;#x200B; Still trying get around the JSON syntax so that's something to put on my list of things to learn, probably going to ignore unit test main for now.
For the type of technology I was considering was using [Unity](https://github.com/ThrowTheSwitch/Unity.git) so I would know that if I was running the test runner that it was definitely the [custom test runner](https://github.com/squidfarts/c-project/blob/master/test/test.c) returning the value of all test ran and not a mistake of running the main executable. But I am not sure if that would insulate the D programming community by not using the provided unit testing functionality in D. &amp;#x200B; Still trying get around the JSON syntax so that's something to put on my list of things to learn, probably going to ignore unit test main for now.
For the type of technology I was considering was using [Unity](https://github.com/ThrowTheSwitch/Unity.git) so I would know that if I was running the test runner that it was definitely the [custom test runner](https://github.com/squidfarts/c-project/blob/master/test/test.c) returning the value of all test ran and not a mistake of running the main executable. But I am not sure if that would insulate the D programming community by not using the provided unit testing functionality in D. &amp;#x200B; Still trying get around the JSON syntax so that's something to put on my list of things to learn, probably going to ignore unit test main for now.
For the type of technology I was considering was using [Unity](https://github.com/ThrowTheSwitch/Unity.git) so I would know that if I was running the test runner that it was definitely the [custom test runner](https://github.com/squidfarts/c-project/blob/master/test/test.c) returning the value of all test ran and not a mistake of running the main executable. But I am not sure if that would insulate the D programming community by not using the provided unit testing functionality in D. Still trying get around the JSON syntax so that's something to put on my list of things to learn, probably going to ignore unit test main for now.
For the type of technology I was considering was using [Unity](https://github.com/ThrowTheSwitch/Unity.git) so I would know that if I was running the test runner that it was definitely the [custom test runner](https://github.com/squidfarts/c-project/blob/master/test/test.c) returning the value of all test ran and not a mistake of running the main executable. But I am not sure if that would insulate the D programming community by not using the provided unit testing functionality in D. Still trying get around the JSON syntax so that's something to put on my list of things to learn, probably going to ignore unit test main for now.
For the type of technology I was considering was using [Unity](https://github.com/ThrowTheSwitch/Unity.git) so I would know that if I was running the test runner that it was definitely the [custom test runner](https://github.com/squidfarts/c-project/blob/master/test/test.c) returning the value of all test ran and not a mistake of running the main executable. But I am not sure if that would insulate the D programming community by not using the provided unit testing functionality in D. Still trying get around the JSON syntax so that's something to put on my list of things to learn, probably going to ignore unit test main for now.
For the type of technology I was considering was using [Unity](https://github.com/ThrowTheSwitch/Unity.git) so I would know that if I was running the test runner that it was definitely the [custom test runner](https://github.com/squidfarts/c-project/blob/master/test/test.c) returning the value of all test ran and not a mistake of running the main executable. But I am not sure if that would insulate the D programming community by not using the provided unit testing functionality in D. Still trying get around the JSON syntax so that's something to put on my list of things to learn, probably going to ignore unit test main for now.
For the type of technology I was considering was using [Unity](https://github.com/ThrowTheSwitch/Unity.git) so I would know that if I was running the test runner that it was definitely the [custom test runner](https://github.com/squidfarts/c-project/blob/master/test/test.c) returning the value of all test ran and not a mistake of running the main executable. But I am not sure if that would insulate the D programming community by not using the provided unit testing functionality in D. Still trying get around the JSON syntax so that's something to put on my list of things to learn, probably going to ignore unit test main for now.
Zig is cool in some ways, but I can't bring myself to use it as long as its attitude regarding undefined behaviour is as retarted as it is currently.
You might want to look into the [std.variant](https://dlang.org/phobos/std_variant.html) module, which defines both the Variant and Algebraic types
Agreed, Algebraic + visit where required.
The May update [(snapshot)](https://archive.fo/k8woQ) shows D at 0.857%!
https://code.dlang.org/packages/sumtype
This: http://ddili.org/ders/d.en/index.html Along with the official docs is what I used.
Thanks, that looks like exactly what I want, but do you know when it was last updated?
Not sure exactly. I read through it about 2 years ago. Nothing seemed inaccurate then. I don't think the fundamentals of d have changed that much since D2 I think it should still be good. I use it as a reference still sometimes as the official docs are somewhat technical and a little bit difficult to understand at times.
It remains a very current and up to date resource. There are printing online additions; the online edition is updated. Not sure about latest update, but the content is all still accurate. The only things missing will be the newest changes like DIP1008
The PDF states that its latest update was on 2019-02-01
[ddili.org](https://ddili.org) is the best tutorial for D except for this one [https://github.com/PhilippeSigaud/D-templates-tutorial](https://github.com/PhilippeSigaud/D-templates-tutorial) which is better for templates, but only for templates
Thank's for the pointer to this tutorial :)
The way I'd write it is something like `void printMembers(T)(string label, T a)` First, pass the label of the item from the outside next to the value. Variable names are not carried along with values or types, so doing them separately gives you something to print there. For the outer laer thing, you might leave it blank or whatever. Then, once inside, check the type of T to decide what to do further, and if it has members, consistently use `.tupleof` or `allMembers` - don't mix because the indexes won't line up if there are any methods in the middle of the data members. I would suggest checking just if it is an object, an array, or a basic type, and adding more later if you need them. Now, remember, strings are technically arrays, so probably check that first. To get you started, here's a skeleton of code. I'll leave adding type info, commas, and formatting and other details to you: ``` void printMembers(T)(string label, T a) { if(label.length) writef("%s: ", label); // is(T: anything) means if T will convert to it. Since all // basic numeric types convert to double, it is a fair approximation // of it T is some kind of int, float, short, etc. // note this just checks if it CAN be converted, it doesn't actually do it. // also checking string here as a basic type static if(is(T : double) || is(T == string)) { writefln("%s", a); } else static if(is(T == E[], E)) { // in here, we know it is an array of E // print the bracket, then loop through the array and print its members writeln("["); foreach(item; a) { printMembers(null, item); // no label on individual items } writeln("]"); } else static if(is(T == class) || is(T == struct)) { // and now for classes and structs, we will tupleof descend. writeln("{"); foreach(i, v; a.tupleof) { printMembers( // trick to get the name out of a tupleof reference // is to slice the aggregate name off the stringof. // i prefer to use traits(allMembers) etc but this is simpler here a.tupleof[i].stringof["a.".length .. $], v ); } writeln("}"); } } ```
Thank you! I really love dlang template meta programming!
In response to concerns raised at the AGM which took place prior to the Hackathon during DConf 2019, I've revised the DIP documentation to clarify the responsibilities and expectations of reviewers and streamline the review process.
Yes, It is very strong. D is an excellent language in many way.
Funny the Dexed editor is written in Pascal ;-)
funnily indeed.
[Copyfree](http://copyfree.org)-dom among several programming language module ecosystems: Lang Ecosystem|Copyfree :---|---: Nim Nimble|85.005% Lua Rocks|83.372% Haskell Cabal|79.368% **Dlang Dub**|**79.267%** Chicken Eggs|77.168% Rust Crates|75.485% Tcl Gutter|73.729% Dart Pub|66.212% Ruby Gems|46.659% (Ruby is especially penalized here because [their gems metadata](https://rubygems.org/pages/data) often omits a license.) So if someone concerned about license freedom was choosing a safer-than-C systems programming language for a BSD-type project, Nim would currently have the advantage. Nim is also in the ports for all major copyfree operating systems ([FreeBSD](https://freshports.org/lang/nim), [OpenBSD](http://openports.se/lang/nim), [NetBSD](http://pkgsrc.se/lang/nim), [DragonFlyBSD](https://github.com/DragonFlyBSD/DPorts/tree/master/lang/nim), [HaikuOS](https://github.com/haikuports/haikuports/tree/master/dev-lang/nim)), while D has some omissions. Finally, the relicensing of LLVM to Apache2 will eventually make LDC uncopyfree, while Nim can use any backend like [pcc](https://en.wikipedia.org/wiki/Portable_C_Compiler) or an older version of clang. I am wondering to hear from the D dev community if they think this situation will improve in the future.
Boost is our "standard" license. The most active projects should fall under this license.
GPL v2 survived the courts a few times. Was "copyfree" tested that way ?
That is very good. But, as shown in the original post, many Dub modules remain under (L)GPL and other restrictive licenses - in many cases including dependencies for modules that are otherwise copyfree themselves. There are also core Dlang tooling and infrastructure components: [DCD](https://github.com/dlang-community/DCD) is GPL3, [Dfeed](https://github.com/CyberShadow/DFeed) is AGPL, hunt is AL2, some [DlangScience](https://github.com/DlangScience) projects, etc. **I was wondering if there's any policy of *encouraging* D module and tooling authors to (re)license to Boost.** Having a higher percentage of Dub modules change their license has multiple advantages, like making it possible to copy / refactor code into other modules or promote it into the standard library. The standard library cannot include uncopyfree code without losing its copyfree status itself. It's easy for developers to become dependent on restrictively licensed modules without giving it much thought (especially if it's a dependency of a dependency), and you can literally end up in "we can no longer ship this game in time for Christmas" situations when it's discovered that those dependencies have to be rewritten. Having stricter license purity practices would make D more competitive in many industries, both proprietary and for example copyfree projects building on top of BSD Unix.
Copyfree refers to [a set of licenses](http://copyfree.org/standard/licenses) that pretty much say "do whatever you want, just don't sue me and don't pretend you wrote it". (Some copyfree licenses like BSD &amp; MIT have that latter attribution requirement, while Boost does not.) They are in practice [almost equivalent to "public domain"](http://copyfree.org/policy/public), except less problematic in some legal jurisdictions where "public domain" isn't recognized. So your question doesn't make sense. If there are no restrictions, there's nothing to "test" in court. We are arguing that those restrictions are harmful, especially in modules of a programming language that's trying to appeal to as many industry segments as possible (including, for example, a better-than-C language for the further evolution of BSD Unix).
To get something into Phobos is a much bigger issue than just licensing. We are trending away from this now that we have dub. With regards to DCD I hope that we will eventually replace it with something actually built with the frontend instead of built from scratch (and with that incomplete and not that great). DFeed does have secondary installs, but they are set to mirror mode. I am unaware of anyone who is modifying it or using it with another mailing list. It's not meant for that. Lastly DlangScience makes sense, a lot of those repositories are bindings and hence must match the libraries license.
Oh, but there is something very important to test in court: if somebody uses my code and hurts himself, am I responsible ? What you agree to online and what the laws are don't always mash. True, this was not tested for GPL either, but GPL v2 went through courts a few times and at least this was not used against the license holders ... so far, though I expect this to happen when IOT fridges running the Linux kernel will spoil food or blow up.
The June update [(snapshot)](https://archive.fo/mWAlX) shows D at 0.911%!
A look back at how DConf 2019 came together.
Did you left your stuff in the room during the evacuation ?
Yes.
Haha sorry I watch too much movies, but I couldn't imagine a better way for stealing data, i.e "the fake fire alert", people forget their stuff due to the panic.
I don't know of a single case that the GPL was taken to court by someone downstream; it seems like that only happens from upstream, suing recipients of the code who violated the license. The reason for that is simple: Copyleft licenses like the GPL are designed to enable suing recipients of the code. Copyfree licenses are designed to protect recipients of the code from lawsuits. In short, the fact copyfree licenses don't end up in court as often is a *feature*, and is evidence of the fact they work. ***Pay developers, not lawyers.***
The disclaimers attached to many copyfree licenses are generally recognized as legally effective, from what I've seen, so I don't see where you have a meaningful point here -- especially when you then go on to say nobody has sued in a way that brings GPL disclaimers into play, anyway.
The Human Resource Fund is currently the D Language Foundation's top fundraising priority. Follow the instructions in the blog post to get a DConf 2019 t-shirt, a DMan t-shirt, and/or a discount on DConf 2020 registration.
VSCode with D Lang extension works pretty well: [https://marketplace.visualstudio.com/items?itemName=dlang-vscode.dlang](https://marketplace.visualstudio.com/items?itemName=dlang-vscode.dlang)
this one is outdated and is bad this one is much better: https://marketplace.visualstudio.com/items?itemName=LaurentTreguier.vscode-dls native vscode LSP for debugging i use: https://marketplace.visualstudio.com/items?itemName=webfreak.debug
Do people think the D foundation moved too slowly in trying to raise money? Should something like this have been started earlier ?
The D Language Foundation has been raising money since it was first set up.
The [**July update (snapshot)**](https://archive.fo/RsNH8) shows D at 0.822%. That's down a bit compared to [last month](https://archive.fo/mWAlX) in absolute terms, but up relative to other languages, from 23rd to 21st place. Looks like D will soon be back in the Top 20. (Related posts here from [three](https://www.reddit.com/r/d_language/comments/4mszc4/tiobe_index_again_now_5_month_in_top_20/) and [five years ago](https://www.reddit.com/r/d_language/comments/23zdu9/d_breaks_on_to_the_tiobe_top_20_list/).) Given the increased competition in systems languages since then, this recovery is a very noteworthy achievement.
I created a repo to provide an example of how you can write a CGI program in D. It uses the editor from [Gollum wiki](https://github.com/gollum/gollum) (used with Github and Gitlab) to edit and view files. I thought I'd share in case it helps anyone. It's small (the main program is around 60 lines) so it should be easy enough to follow by reading the editor.d file.
nice, i do love anything that uses cgi.d :P
There's also [https://marketplace.visualstudio.com/items?itemName=webfreak.code-d](https://marketplace.visualstudio.com/items?itemName=webfreak.code-d) which I find working better than vscode-dls for me personally.
[removed]
Hi y'all, &amp;#x200B; This week's first post is entry #8 in the MVC series and covers loading up a TreeView with a decorated list of system fonts. Decorations include varying the size, weight, and style as well as the font face. \[You can view it here\]([https://gtkdcoding.com/2019/07/23/0055-mvc-viii-dynamically-loading-a-treeview.html](https://gtkdcoding.com/2019/07/23/0055-mvc-viii-dynamically-loading-a-treeview.html)).