Type systems take features from the term language, what's done at runtime, but gives features to the type language, what's done at compile-time (minus any macro system, like template haskell or lisp macros.) The term language stays turing-complete so you've not lost any power there, only a bit of expressibility such as the ability to express `sqrt "Hello"', but the type language has gained the power to tell you lots of interesting properties about the program just by looking at it.
I read it as the composition of the various monads proved unwieldy, and unnecessarily complex. This actually seems like a genuine problem to me, is there some simpler way of composing monads I am missing?
Those are very cool slides. I'm most likely going to be trying CHP for an upcoming project; I wish I could have seen this talk.
Depending on your choice regarding safety and freedom, both Haskell and (Common) Lisp are worth learning.
Too bad I completely missed the announcement and the registration deadline :( 
There is no general way to compose any arbitrary pair of monads, but here is one nice alternative to transformers which I am a fan of and wish had more visibility. As a bonus, it's a quite easy read: http://web.cecs.pdx.edu/~mpj/pubs/composing.html
I've put up a version of the slides with added notes on [my blog](http://chplib.wordpress.com/2010/03/11/upcoming-talk/) ([direct PDF link](http://chplib.files.wordpress.com/2010/03/slides-notes.pdf)) which should help to follow the talk a bit more clearly. (I've also sent them to dons, so the version with notes may end up on the Galois blog too)
I've written two solutions to this problem (one easier to implement than cdsmith's one, and one that needed some thinking specific to the problem, but doesn't need any boilerplate). I have to polish up the code and write a lot of text (unfortunately, all those witty jokes don't write themselves:) and I'll probably post it on my blog before the weekend.
I've been seriously kicking around a web framework based on CHP; I want something different from what I've seen in any other Haskell project, or, for that matter, any other web framework. (Except maybe Seaside, but even then I don't want a straight ripoff.) CHP isn't necessarily the core idea driving me to build it, but I would want that as the modular component interface as processes like that are a powerful abstraction for components (as Erlang has taught me).
Agreed. Given the execution speed of GHC, it's excellent support for parallelism, the amount of research put into it, combined with well thought out modules and hackage would certainly deserve more widespread usage.
I for my own must say that it's a very steep learning curve. Unlike many other programming languages it's one of those where you really have to understand most of it's syntax AND idioms to get productive. Reading only the first chapters of whatever Haskell book or tutorial out there, then think about a problem you feel like to solve and continue reading as needed will get you nowhere. Looking back, the only thing you need not understand (for easy problems) at the beginning are monads. Simply start using the IO monad and think about how the bit's and pieces fit together later.
Saying Monad implies it is also a Functor, and Applicative, and Monoid. But I think people should just say the X type, too.
Well, that's why I was careful to also mention MonadPlus :-) Also, there are multiple ways to make a Monoid given a monad -- unlike Functor/Applicative...
I've been working on using CHP with wxHaskell recently, and the experience has been very positive. They integrate well (same basic approach as with the OpenGL examples on Neil's site - I have a blog post about this on my todo list), CHP's very well documented, the blog's very helpful, and Neil's very helpful. I'd encourage anyone curious to dive right in. [Edit: slide 77 mentions CSP and points to a short introduction on Neil's blog; if anyone wants a (slightly) more detailed introduction with some complete examples, may I plug chapter 3 of [my Master's thesis](http://www.cs.swan.ac.uk/~csmarkus/ProcessesAndData/Papers/gimblett08.pdf) :-) ]
&gt; 19. A language that doesn't affect the way you think about programming, is not worth knowing. -- Alan Perlis Haskell will most certainly change how you think about coding. It has a number of nice features that make math very nice in it - list comprehensions come to mind as an example. Also, Haskell has a REPL (read-eval-print loop), which is a nice change from C and Java. Basically, you type Haskell expressions into ghci, and it evaluates them and spits out the answer. It has some limitations compared to a Lisp REPL, mostly because Haskell is compiled. 
Yeah. I was just going on reading "more powerful" in terms of Formal Power(tm). Of course, as a linguist and language designer, I think formal power is given more weight than it deserves. Just because TAG and CFG have equivalent weak generative capacity (i.e., recognize the same sets of strings) doesn't mean they aren't worthy of studying separately; linguists are generally more interested in the *strong* generative capacity (i.e., the sets of recognized parse trees) of their formalisms, because we care about the underlying machine! Similarly, while most programming languages are Turing complete, what programmers really care about is expressive power, not formal power. And often we get more expressive power (or faster programs) by having less formal power, due to the metalinguistic properties you mention. (Frex, webpage layout rendering should not be Turing complete!)
First thing to note is that Monads are actually far less important in Haskell than you might think.. they're just an incidental and useful feature of the language. Second thing is, [You could have invented monads](http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html).
See http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf at page 29.
"do" blocks are syntax sugar for composing monadic values with (&gt;&gt;) and (&gt;&gt;=). The reason they are awesome is because they capture a recurring pattern in seemingly completely different things, and allow you to re-use the same combinators/abstractions with all of these different things. For example, you can use "sequence" to compose together lists of side-effecting actions, or Maybe values, or parsers, or continuations, or anything else that happens to be a monad.
...but that'd be like the C standard calling "unsigned int" "array index"
Although I like Haskell as a language, I'd rather type all of the Java boilerplate (or let IDE do it for me) then type something like this: pureOperation &lt;$&gt; maybeVal It's just so ugly that I don't want to see functions with names like this.
The translation rules are simple: do x &lt;- m; bar == m &gt;&gt;= (λx -&gt; do bar) do m; bar == m &gt;&gt; do bar do e == e Another way to translate do into explicit &gt;&gt;= is by appeal to visual patterns. Compare: do x &lt;- foo bar y &lt;- baz return (x, y) with its desugared variant: foo &gt;&gt;= (λx -&gt; bar &gt;&gt;= (λ_ -&gt; baz &gt;&gt;= (λy -&gt; return (x, y)))) If you replace `&gt;&gt;=` by `;` and drop the parenthesis, it doesn't actually look that bad: foo; λx -&gt; bar; λ_ -&gt; baz; λy -&gt; return (x, y) 
So just use `fmap`. f &lt;$&gt; x = fmap f x
Oh, I won't disagree at all that there's is commonly a gap between the theoretics and the practice. :-) 
I encourage you to use the desugared notation until you feel comfortable enough with &gt;&gt;= and &gt;&gt; to not get lulled into a false sense when you use do-notation.
[Even harder to sell.](http://shemesh.larc.nasa.gov/images/humor-hard-to-sell.jpg) Personally I'd have hard time betting on a C programmer who can't learn Haskell. 
Read the typeclassopedia everyday. It's the bible of any haskeller
If your script takes a few days to write in any language at most, then what's the big fuss?
What's so ugly about it?
All those %#$%@#$$%^#$%&lt;&gt;?&lt;+=-_ characters used in random function names. I know it is a matter of personal taste, but I just hate to see it.
That doesn't help when looking at code written by others.
i don't accept this logic. pursue this line of reasoning and your whole codebase will be in php oh yes children, it can happen. my current employer even writes offline data crunching scripts in php because no one here can be bothered to learn anything (else). you only live once. if you want to write haskell, do it. damn the torpedoes. 
well said sir. have an upvote
I think the high turnover and the risk of a team coming on board with nobody knowing Haskell is the real problem point for them. An employer can either mandate incoming programmers know the language their code is based on, or pay to have them trained. At a university with volunteer students, the only way you can guarantee this is if the comp sci department starts requiring that all CS majors learn Haskell or another functional programming language. Though I suppose an argument for "they should be able to hack the language" could still be made if the CS department at least made students not only understand recursion inside and out, but completely understand lambda functions and their role in a procedural based programming language.
Testing with QuickCheck and GHCi is usually fine. Have you encountered any problem with that ?
I usually have two terminals, one vimmng my current file, and another with ghci. ghci's :re command will reload the current file. I'm not much of an emacs guy (slime/swank is awesome though). but you can get a nice editor/interpreter flow going with ghci. also, do you know about undefined? it'll let you compile without actually implementing things, foo 'a' = 1 foo _ = helper helper = undefined Undefined a nice trick for letting the typechecker know not to worry about this part right now. Even better, the typechecker will tell you what type you need, so in ghci ":t helper" will give helper :: Int or whatever you need to get the types to work out 
I think this has to be the attitude. It's simply impossible some places, but if it's at all an option for you, then just go for it.
Perhaps you could try out something akin of http://github.com/nominolo/scion I never use such stuff though. I tend to build my software in larger batches, get the type checker happy and then run some tests.
$ is well known as "apply". angle braces are idiomatic these days for "lifted version of". So &lt;$&gt; reads very clearly as "lifted apply" once you get used to it.
&gt; in the worst case, people may crack open the code, say "what the fuck is this" and rewrite it in another language. If that's the worst case then definitely write it in Haskell.
Emacs with (at least) 3 windows: full-height on the left is a source file, half-height on the top-right is an org-mode to-do list, half-height on the bottom-right is GHCi. Use undefined as a placeholder, and you can start framing out a module very quickly. It is not as fluid as slime -- you lose the ability to develop code while preserving some dynamic state of your program -- but it does allow for quick sketching, ad hoc testing, etc.
I will note that large portions of your code should be pure, so you can simply stick the relevant declarations in the source file you're doing development in.
Generally the recompile cycle is better as folks have noted. You can keep all the modules that you're not working on fully compiled, and only work with the bytecode-compiled version of whichever you're currently editing. Basically, Haskell is a statically typed language, and a compiled language, so it makes sense to play around with things at the REPL, but the serious code should be written directly into the source file.
This is a common question, by the way, and a good faq on it on the haskell wiki would be excellent -- we have the capacity to pick up lots of creative lisp and smalltalk types, but the slime issue seems to put people off. I should also note that ghci is super cool and powerful on its own. Readline + great completion + user defined commands + :t + :info + :browse take you very far, and especially when hoogle is thrown into the mix. Also haskell-tags. In some ways, by virtue of sticking to command-line tools and readline interfaces for its core functionality, haskell's toolchain is at the moment arguably more unixy than the big environment provided by smalltalks and lisps. This is, i know, arguable.
What exactly is your problem? 
In Emacs C-c C-l loads the current file in GHCi (the REPL).
Most Lisps (are|can be) compiled too. Don't confuse interactive with interpreted. 
Well, the trick that persistent environments like Slime, or even things like Matlab, let you do is incrementally build up a stack of potentially slow functions for processing some data. Say you know that eventually you're going to have (h.g.f) x so you work on *f*, trying it out on *x* periodically as you go. Then, when you want to work on g, you can easily stash x' in your dynamic environment and not have to evaluate (f x) for this particular x each time you want to try out (g x'). It's a totally different development style than that which Haskell encourages/requires, but it is not entirely without merit!
You can do something fairly similar in Haskell. Remember, :r in ghci will reload the current modules... so typically, the workflow I use is to stub out some methods (using undefined for most!), then start working on one, :r-ing a ghci prompt repeatedly. When I'm done with that, I can work on the next one. If, like you say, you want to store a result, you can just let x = f x or whatever in ghci. So, &gt;&gt; :l MyModule -- l being short for "load" &gt;&gt; f x -- fails .. make changes &gt;&gt; :r &gt;&gt; f x -- desired response &gt;&gt; let x' = it -- "it" is the result of the last evaluated call in ghci I am reasonably new to Haskell, but that seems to be what you're describing :) - and I personally feel at my most comfortable developing like that (if I could make Python reload/re-import modules in ipython or bpython the same way, I'd be an extremely happy chappy).
Once you reload the module, ghci will lose x'
I miss how easy it is in Lisp to have some random data structures lying around and knock them into some new shape real quick for use as test data. You can cram some new fields in, redefine classes, perform list surgery to move things around, or whatever. I love Haskell, but I miss the convenience of just squishing data around as-needed during development and testing. Inspectors and similar things are also really handy.
In my Emacs (Aquamacs) readline support is broken for inferior ghci. Any idea how to make it work?
"%#$%@#$$%^#$%&lt;&gt;?&lt;+=-_"? Oh come on, now you're just being ridiculous. I mean, really. Underscores aren't legal in operators. On the other hand, this is perfectly valid: infix %#$%@#$$%^#$%&lt;&gt;?&lt;+=- x %#$%@#$$%^#$%&lt;&gt;?&lt;+=- y = fix (fmap x y) See? Much more sensible.
My mistake sorry, evidently it does :&lt;.
Interesting. I suppose that I would never test my code on large datasets initially, so running "show" on the result should give me an intermediate piece of data to use. I will admit that this is something Haskell doesn't make easy.
You can find Haskell'98 language specification online, and it both gives an example and an explicit desugaring for the *do* notation. http://www.haskell.org/onlinereport/exps.html &gt; A *do expression* provides a more convenient syntax for monadic programming. It allows an expression such as &gt; putstr "x: " &gt;&gt; &gt; getline &gt;&gt;= \ l -&gt; &gt; return (words l) &gt; to be written in a more traditional way as: &gt; do putStr "x: " &gt; l &lt;- getLine &gt; return (words l)
I use vim with [SHIM](http://www.vim.org/scripts/script.php?script_id=2356).
Hmm. I think that for 90% of time you don't need to understend monads. Just remember 'wired' syntax which works for IO (and lists, parsers...)
Most CS courses have a couple of de facto languages that are used throughout, making them effectively required knowledge. One of them ought to be haskell/ml/lisp or the students are missing out. I've seen sml+cpp+java and haskell+c+java.
I'm going to echo most of cdsmith's sentiments but I want to add that Haskell has a reputation for being difficult _among programmers_. I only know one mathematician personally who has learned it, and he knew a few other languages going in (at least Python, I think also some Java or C) but he found it to be much easier to learn Haskell than I have found. It will help that the parts of Haskell that are hard for programmers aren't particularly important to you. I doubt you'll be much concerned about the lack of an excellent web framework or that the database interaction is still at this point mostly SQL (a factor I like, but it isn't for everyone). If you wind up doing visualization, you won't find it harder to do GL in Haskell than anywhere else but the rest of the program will be simpler and clearer to you. I recommend Haskell to you because you will find that you fit in better to the Haskell community than to any other language community. You probably could find a fair number of like-minded people in some niche of another language, but Haskell's core group are mathematically and scientifically inclined folk. Kin, if you will. So you will find that the things that you get stuck dealing with are things that others are likely to get stuck dealing with, and things that you don't need explained are the kinds of things that aren't over explained (except for monads, of course). You should learn Haskell because, like cdsmith said, you will find it a great scratchpad for your research. Writing a large-scale physical simulation is a daunting task in any language. You have to ask yourself if you'd rather deal with optimizing performance at the end or slogging through mud through the whole process. Even if you embark on a large coding project and can't finish it, using Haskell for a prototype will help make the core of the system clearer. You will probably also find it easier to get help from the Haskell community on the subject of optimizing a program than from another language community for holistic help, if for no other reason than that it will be less help you'll need. Because Haskell is a rising star in the math and physics world, I think you'll also find yourself at the forefront of a positive trend. If the Fortress project were a little further along I might suggest taking a look at it, but I think it's stagnated somewhat and the Sun/Oracle situation has probably slowed development.
Worst case scenario, you could use M-x shell or M-x term.
I was put off by this at first too, especially because the last language I was using heavily for my hobby was Clojure and I had a nice setup with SLIME. But I found that doing what others are suggesting--emacs the file in one window, ghci in the other--is quite workable.
yes, this is the same way i look at it: monads are a way to overload the semicolon (or the newline!) inside a do construct. if i was teaching monads, i'd skip over all the &gt;&gt;/&gt;&gt;= stuff, until the do-construct sunk in deep into the students. a nice imperative break, i'd say.
This obviously has to happen in general, because the definition of things that x depends on could change. However, if x is defined in module M1, and you finish working on M1 and start working on module M2, this could work. Of course in real life things are rarely that linear...
Yes, that's exactly how I develop in GHCi. It's a good workflow. I'm not familiar with the Lisp environment. What do they have there that's different?
Sounds exactly how I work in GHCi. I suppose there could be other styles in Haskell, but I don't know what you're talking about. And what does Lisp have that's different?
Press up-arrow a few times, enter, and it's back. Don't like those couple of extra keystrokes? Write yourself a little :def script so that you can easily define variables and everything is still there after you reload. :def is extremely powerful. I don't bother with that though - I don't mind a couple of up-arrows.
I usually put `x'` in the source file and I often name it `test`.
I use TextMate for Mac OS X. One can script it piecemeal in any language one likes. I keep ghci open in a terminal tab, but my usual development cycle is to compile and run the entire current project, which is acceptable quick. There's an extra layer of mental overhead to routinely using ghci; I only resort to using it when I am deeply confused.
I thought the point was that computing x' is a slow computation
I thought the point was that computing x' is a slow computation - not that you have to type it in.
I have the same problem. Pressing the up arrow just moves the cursor in the buffer.
Fantastic
Looking forward to it! What platforms will be supported?
True that. But reloading also removes it from scope. Concerning the slow computation, I wouldn't use large examples on the REPL anyway. In any case, there is always the option to ghci&gt; writeFile "x_tick" $ show x' ghci&gt; x' &lt;- read `fmap` readFile "x_tick" :: IO Sometype 
I think that's the core objection. I've never used Smalltalk but I've used other incremental development environments, and losing all your state makes it hard to do that style. That said, after a few years of that I've come to be on what I think is Haskell's side, which is that all your data is actually invalid once you make a change to the underlying system. You've changed the semantic context (for lack of a better word), and thus your `User "bob"` before the change is not the same as the `User "bob"` after the change. But it does mostly work most of the time... and I think that sentence encapsulates the problem Haskell has with this style. "Mostly work most of the time" is not really Haskell's goal here. Eventually I realized that these environments are just papering over real problems and got tired of fighting with that problem. I'd rather do what you said. Erlang does have an interesting counterpoint: When you load a new code context, you have the opportunity to run a conversion function to deliberately (and hopefully correctly) transform your old code's state to your new code's state. Of course, it's a lot easier in a weak type system like Erlang's, and this is meant for deployments, not incremental development, but it's still an interesting idea.
Sounds really great! 
nice slides.
next time, I'll put "comments are mandatory". 3 days ago, there were plenty of comments on the same topic and now nothing? anyway, what happened to jfredett and his weekly news?
Took me a second to figure out why I couldn't use ghci's `:t` command!
Did I hear you had an x86 to OMAP cross compiler working with the LLVM backend? Or perhaps my mind is optimistically inserting that "with the LLVM backend" part?
Sorry about that. It takes me a while to work through these things. As an aside, it should be noted that the problem with mandatory type annotations in cdsmith's solution can be overcome, but results in even worse error messages. Behold (and wince): wackystuff.hs:212:20: Couldn't match expected type `If (IsFib (NumParams ([Char] -&gt; Result String)) ) Int String' against inferred type `[Char]' I suppose it would be better to print the reduced type in the inference error and the type instance as an aside, the same way errors in expressions are currently reported.
Use M-p and M-n to move through the history.
I've never heard of that, so I think it was your vivid imagination. :)
Oops, my mistake. It was alpheccar.
what was the query/expression? And it's not that bad, at least this error results from the use at the call site (it mentions things that matter), not from some subexpression from three modules down the call stack. I've seen way worse:) I've seen errors so huge, that I had to copy-paste them to emacs and write macros to clear them up, pretty-print things a bit before I even tried to understand them. Usually I could only laugh though:)
My uni had c+java. :(
At the moment, it supports x86 and x86_64 and it has been tested on Linux and Mac OS X, but there is currently some issue with FFI callbacks or so on Mac OS. Once it is in the tree, we will also look at support for Sparc/Solaris (for the T2 box). Alpheccar has got it to run on the OMAP (ie, ARM), too.
Do you know what alpheccar's general process was? Did he somehow leverage parts of blackh's GHC IPhone work or did this use purely LLVM components?
Am I missing something? According to slide 46, it seems like all they showed is that all the parallel approaches in Haskell are a waste of time for this problem.
He already had a previous port based on the C backend, which he describes at http://www.alpheccar.org/en/posts/show/94
1: {-# LANGUAGE UndecidableInstances #-} -- and probably more class (Foo a, Bar a) =&gt; FooBarP a instance (Foo a, Bar a) =&gt; FooBarP a (the trailing "P" signifying that it's merely a predicate class) For all those of you who are afraid of UndecidableInstances: Using it like this is safe, unless you add instance (FooBarP a) =&gt; Foo a instance (FooBarP a) =&gt; Bar a , which doesn't make sense, anyway. 2: {-# LANGUAGE PackageImports #-} import "mtl" Control.Monad.Trans 3: I feel your pain
Sshh. 2. is supposed to be secret!
&gt; I'm lazy and I didn't feel like translating regular algorithms to the type level, so I've assumed, that there are no prime/fib numbers bigger then 20, that way, it's possible to enumerate the positives, and choose all the other numbers as negatives. I think you missed the point :-)
OT, but I used to use Aquamacs too and found it had lots of little idiosyncracies like this which made it annoying. I had thought it was the best emacs for OSX, but then I found this: http://emacsformacosx.com/ - and haven't looked back...
I didn't know the second one. Thanks!
what point?
I've started kicking around a web framework based on CHP, and this is one of the reasons why. I'm still well in the "kick ideas around" phase, but one of my major goals is to see how I can get useful typing out of the framework. Stuff that flows across channels is one place to get that. After some pondering as part of this kick-it-around phase, I actually disagree with the last header of the post, "Type-safety + MVC ~= peanut butter &amp; chocolate", at least to the extent we're talking about Haskell-type-safety. MVC is a fundamentally OO abstraction, and IMHO it doesn't even work all that well there. Trying to jam it into functional programming seems unlikely to work without giving up type safety or something else very important (simplicity being the other obvious potential issue). This is turning into something I'm tentatively planning on turning into a blog post, but here's a practice run since it's been hard to work out how to express some still-fuzzy conceptions: OO and functional have two different approaches to complexity. Consider the problem of trying to map some data that is stored in three related tables in a database to a custom data type in your language. The naive approach (not necessarily _bad_, naive in the sense of "simple") is to simply write the SQL: `SELECT a.a, b.b, c.c FROM a INNER JOIN b ON a.b_id = b.id INNER JOIN c on b.c_id = c.id` and deal with the results directly. Doing this a hundred times results in repeated boilerplate: * collect arguments * fire query at database and handle errors * extract the parameters back out of the query results * finally use it in the desired application This repeated boilerplate offends good programmers of both the OO and functional paradigms (and indeed all other major paradigms), and both will seek to abstract away the complexity. OO people will wrap everything behind classes, and after iteration will generally end up with an ORM here. The ORM will contain defined types for the database and allow you to define more. It will handle SQL generation. If it wants to be a total database access layer, it starts running into problems around joins (hard to deal with) and SELECT parameters that aren't simply the name of columns. In practice you often end up with a powerful abstraction, but one that is a radical subset of the original database's capabilities; once you leave the ORM design space, you are either on your own or quite possibly actively fighting the design. A functional programmer starts by writing the code in the four steps above. Then he starts refactoring away the parts he actually uses into other functions. Perhaps something like LINQ that makes SQL generation easier (and composable in a way that raw SQL isn't). A general function that takes "what should be done in the DB" and adds the top-level error handling the applications needs. Various combinators for handling type conversion in and out of the database. After various iterations we get a collection of combinator libraries, some powerful functions-that-take-functions that wrap away the database manipulation concerns, and a collection of types necessary to enable this. In the end you end up with the programmer still doing those four steps above, but it's OK because it is just as concise as the ORM, while ultimately leaving it all under the programmer's control. If the programmer needs to replace a column reference with an SQL function (`SELECT x FROM y` =&gt; `SELECT COALESCE(x, 0) FROM y`), it's just a matter of putting it in the right place in the combinator stream, rather than rewriting the OO library that has completely taken over the SQL generation process. Basically, OO produces designs that want you to tell them what work to do then do the work for you, and functional strikes me as producing designs that want to make it easy for you to do the work. I actually think that there are serious arguments to be made in either case's favor; there are times when I kinda do want my designs to do the work for me. But that's a debate for another time. Getting back to what spawned all this. MVC is a design where the controller wants to be told what to do, then do it, and the view wants to be told what to render. It seems to me a functional design would be to have something that helps the programmer do what they need and then render what they need to render, in a way that will make the OO programmer claim "There's no separation of concerns here!", when in fact the separation has occurred in the combinators. Mmm, I still don't feel like I've got this quite right. But my upshot is that I really don't think you can do MVC in a strongly-functional language without the language type system fighting you and basically requiring you to just subdue it. Anything you do that actually uses types will be something other than MVC, even if there's an MVC-flavor of design embedded in it. One of my hopes is that I can create something much more natively functional, and one of the aspects of that is that I think the first thing that will happen with a web request is that it gets processed into some sort of strongly-typed value before getting passed along a process. (Part of what may make that work is that I don't intend to rigidly wire the type in, it will be something users can affect.) Passing around HTTP headers directly around the program as some sort of "environment" is not very functional. Further consequences of this ripple deeply into the design; I don't know where I will end up but it will definitely be different than anything I've seen (which is of course not everything). Feedback welcome; I'm trying to drag a fuzzy impression kicking and screaming into the real world and that always takes a bit.
I think this is one of the indicators of how much scaffolding you actually need to do meaningful benchmarks, and how well Criterion has hit the sweet spot.
That's some really nice handwriting. :-) Looking forward to pairing these notes with Awodey's textbook.
It wouldn't take that much extra code to actually implement the fibonacci and prime number computations, right?
right. but I've always disliked implementing prime numbers for some reason.
Your answer is absolutely the right one from the perspective of an environment that doesn't allow for that style of incremental development :) But, while I do almost all my development in environments that don't have persistent dynamic state (e.g. GHC[i], DrScheme, C++), I think that this reason for not having it is a bit hollow. While it's certainly possible to dig yourself a hole with Slime as your shovel, there are plenty of occassions where you are writing pure functions one at a time, and there is minimal (if any) danger of finding yourself in an inconsistent state. I actually think a great example of the different perspectives on this matter is the above suggestion to save intermediate values to disk (which is what I typically do when writing Haskell): this would be a fairly ridiculous way to do Matlab development, for example, but seems reasonable to a Haskell developer. 
No, it's not at the same at all. If you reload your module in GHCi, you lose your temporary variables. In Slime, it is common to reload a single function at a time while everything else remains the same. If you've never used it as a development environment, then it might seem totally chaotic, and indeed it has the potential to be so. The benefit is when you do anything that might take enough time that you'd notice, even loading a large file into memory, for example. In Slime, and other environments with persistent dynamic state, you can keep whatever working set you'd like in memory while individual functions are recompiled and reloaded.
It's not just that you can "dig yourself a hole", it's the _type_ of hole you can dig, pun intended. What was a `User` one moment ago is now something else. Languages like Erlang where there is no such thing as user types can handle this by just holding on to the old data. Languages like Python where objects are just barely typed hashes/dictionaries can hold on to data. Matlab probably falls into the same basic category. Languages that are really, really, _really_ into types like Haskell can't do that; _even if_ the type _appears_ to match there's no guarantee the user didn't switch the meaning of the order of two of the "Int" parameters or something.
That approach to the REPL is exactly the point, though. In Matlab, for example, I might load an image, run some processing on it that takes a few seconds, then keep trying variations of some other function on that intermediate data as I work. As long as you take some care with what you're doing, there is very little danger in this persistent state, and you don't have to fiddle with temporary files at every step. I actually do exactly the things you've mentioned in GHCi: I have a variable called test in my module, and I serialize expensive data to disk.
You are right, but I'm not sure it's so stark as that. If I use several library functions to compute an Int, and it takes a good long time, and I now want to run some of my own functions on that Int, is there really a type system-level reason why this temporary value must be discarded?
I thought you were kidding, but that is really nice handwriting!
THANK YOU!
Apologies for the pithy comment. I'm not convinced that the "functional" approach you've described isn't just doing away with encapsulation. "OO produces designs that want you to tell them what work to do then do the work for you." One of the nice things about combinators is that combinators look declarative but actually are indeed doing the work.
Bah, I wish I'd heard of this event before, I'm booked up for that week now and it'd be tricky to free it up :( I don't quite understand the MGS, is it free to attend as a phd student? 
Define "encapsulation". Due to good PR by the OO folk, most people end up meaning "OO-based encapsulation" without even realizing it. Encapsulation-by-combinator or encapsulation-by-Haskell-module or encapsulation-by-typeclass is every bit as "encapsulated" as anything else. It just cuts in a different direction than OO-encapsulation. Which I think is actually isomorphic to my point but it defies me how to show that. In a process-based design, you get encapsulation-by-process, too, which is both very powerful and not at all OO. (Well, if you go all the way back to the _very_ beginning, Alan Kay describes something that actually sounds more like process-based encapsulation than modern-day OO to me, but that's not where OO ended up.)
Arguably, even Int is redefined and it's not the same Int anymore. Haskell is fairly all-or-nothing. I say "arguably" because, well, you could argue the other way. But you would be arguing about what constitutes the exception list, and in light of "import Prelude hiding (...)" even that would be trickier than it first appears. Very little of Haskell is truly constant, if you really get down to it.
Thank you.
&gt;David will be on an internship at GHC HQ at Microsoft Research Cambridge in the second quarter of this year, specifically to work on the GHC LLVM backend. Damn, haskell has pretty good financing. 
Registration was £350 with accommodation, £150 without. But it no longer seems to be possible to register on the web page, so I guess the event has now reached capacity.
Java's package naming policy is often ridiculed for its verbosity and overengineering, but to its credit it handles these cases well. Yes, I'm talking about that java.lang.foo, com.sun.bar rigamarole. The problem with Java's approach is that it makes difficult things doable but simple things difficult. With better language support for package and namespace management, this should go away. On my personal top three would probably be Haskell's underpowered record system. You can emulate record subtyping with typeclasses but that is hardly a perfect substitute.
Is it possible to make videos available ? Thanks for posting this.
Right, but when you're going and "adding it to the proper place in the combinator stream", you're going and reaching your hand into the box. 
You maintain type-safety by using continuations. They naturally express URL/form parameters and session state. I'm working on an ASP.NET web framework using this exact approach, and it works very nicely.
You seem militantly against MVC, but Haskell's own IO monad enforces a certain brand of MVC, and I certainly would not want to argue against its benefits. :)
Should point 1 and point 3 be exchanged?
Most of point 3 is solved by my solution to 1, what's left are a) ML functors would be nice (There's gotta be some common abstraction lurking behind modules, records and type classes), and b) the vanilla typeclass hierarchy sucks. So, yes and no.
&gt; Your first point seems utterly wrong to me. People use lists as defaults generally with small amounts of data where performance is not at issue. Haskell has great syntax for adts and data types of all sorts, although, granted, with view patterns it could be even better. Your rebuttal seems utterly wrong to me. The problem is not only with lists but with the general neglect of data abstraction. View patterns (what is currently in GHC is an abomination) must be a beautiful and fundamental part of not only the language but the culture for this to change. As long as structural recursion over concrete data types has a significant aesthetic advantage, programmers will continue to prefer elegance over performance unless pressed. It is the task of every programming language to lead programmers toward code with a balance of elegance and performance. Haskell's favoring of concrete data types is a violation of this principle.
Awesome!
If you want to just *write the damn code and be done with it* just put what you had first of all. That's fine and totally unambiguous! The next reasonable alternative I can see is the arrows combinators from `Control.Arrow`. foo (x,y) = bar x &amp;&amp;&amp; bar y At this point you might want to ask yourself if it's worth a named function at all. ETA: I am using "better" to mean "clearly written", rather than "non-leaky" or "fast" or any other definition of "better" that you may have been thinking of.
Is one better for memory and one for time? I haven't run any tests. I was kind of hoping that there would be a simple answer that was correct in every case.
The second. But then, you shouldn't generally be using tuples, in the first place. Using them to return a fixed number of results is fine, but passing them into functions is quite often an indicator of code smell. Better curry, or use a quick data type. When using tuples to return things, I almost always keep the expressions it's made of as short as possible. So, number three: foo (x, y) xs = (x', y') where x' = bar x xs y' = bar y xs (this gets more and more important the bigger your where clauses/return tuples/data types are) There's a thing I can't tell from your example code, an that's whether x and y actually have the same type; using one function on both merely suggests it. In that case, I'd do something like data Foo a = Foo a a instance Functor Foo where f `fmap` (Foo x y) = Foo (f x) (f y) foo x ys = bar ys `fmap` x
What the hell happened! Why did the author switch to plain typed text at the end?
Thanks, that sounds like good advice
Well, that's one of MVC's problems, it hardly means anything anymore. Everyone's sure you should have it, nobody actually knows what it means. Diluting MVC to the point where Haskell IO "is MVC" takes it to full-on meaninglessness; which part is the model, again? If MVC was three typeclasses Model, View, and Controller, what would the instance declarations for IO look like?
Again, it depends on your definition of "the box". There's more than one. "Encapsulation" is like the word Monad; it isn't a concrete noun you can point at, it's an adjective , and just as there isn't a "THE Monad" there is no "THE encapsulation". In functional, combinators *are* "the box"; violating encapsulation there involves cracking open the (possibly sealed) module that implements the base combinators and mucking about with them. Your top-level code uses them, and as long as you don't do what I just said you can no more violate encapsulation that you can in conventional OO with "private". (Assuming correct combinator design.) Twiddling with the combinator stream you own is not an encapsulation violation.
This is a strawman argument. I don't think type classes are at all appropriate for MVC.
Thanks, that helps.
B...but people generally only use structural recursion over lists for things that are in lists!? Otherwise there's a culture of using efficient abstractions, like maps and folds, and traverse, and etc. The one place where lists are used more than they perhaps should be, and I'm as guilty of this as anyone, is in Strings. But that's largely because Data.Text is a relatively recent development. I really don't think that structural pattern matching is so much more seductive than "case uncons s of (h,t)" that people are going to forego better data structures. Lazy lists are also, remember, really great data structures anyway! For lots of cases, which involve streaming production as a way to structure control flow, its hard to imagine better ones.
I'm not saying they are. I'm saying, if IO is MVC, what's the M, V, and C? If you prefer a less concrete version then by all means do some other split up. Bear in mind an OO advocate would probably say right off that the mere fact that there is not a pre-existing M, V, and C that you can point to right now (without me having to even ask) is enough to render it not MVC. Full-on spaghetti code can in principle draw lines around M, V, and C, they're just really complicated lines; the entire point of MVC is to gather all the pieces together. If you've got MVC going on you shouldn't have to say "Well, here's a V and if we bundle these three things together it's a C, unless you pass this argument...", there should be things to point at, ways of subclassing the View to get a new view (or composing something on top of it) without having to manually split it off yourself, etc. Either you're using the term MVC in a useless way, in a way _extremely_ specific to Haskell/functional languages, or IO is not MVC. There really isn't a fourth choice that I can see. (On the other hand, I'm _not_ an MVC purist; for instance I observe in practice you often end up with M(VC), that is, a distinct model but blended controller/views, which in practice is often sufficient and useful. Show me M(VC) or (MV)C or anything else like that and I'll concede defeat. The best interpretation I can see you might be trying to get at is something to do with the monadic separation away from pure code, but that seems to me to be at best a blended VC with effectively no Model to be found at all, stretching the term MVC so far it just isn't useful.)
What are the system requirements for hawitter? Running it on my Macbook yields the following error: "http://api.twitter.com/1/statuses/home_timeline.json?" Dynamic session lookup supported but failed: launchd did not provide a socket path, verify that org.freedesktop.dbus-session.plist is loaded! Is there a way to use hawitter under OS X? (My Japanese is not yet good enough to check on the website.) Good logo, btw!
It seems that there is no dependency to any existing twitter library on hackage. Did yo investigate using an existing one or did those libraries not offer what you wanted? If the second, I suppose you refactor the twitter API functionality into an additional library and provide it on hackage. (Given that it is reasonably feature-complete)
The first three lectures are given using OHP slides, the last two interactively at the whiteboard (as they work better this way), and the text files are my working notes for this.
Why do you say that? I'm yet to see any Inquisition action. These are all things that many committed Haskell programmers will have thought at some point.
&gt; Maybe I should get into some GHC hacking? And write the class aliases extension? Yes! Please do!
Haskellers would typically have their own set of criticisms of Haskell. My pet peeves are lifted type products, the resulting N-tuple fiasco (type ":info Show" in ghci), lack of class aliases (as he mentions) and a few more I'm bound to forget at the moment :)
&gt; We are closer than we think to a language in which an entire program could be considered perfect I agree with most of his points, but I think this is kind of silly, though. "Perfection" is not a unary function, but a binary one, and it also takes a set of goals for which it is perfect. There's always a set of trade-offs, and perfection is the optimal point in all the trade-offs, for a given purpose. I think even when the purpose is known, it is extremely hard (to impossible) to really know whether some code is optimal at achieving those purposes. IOW, I think "perfection" will forever remain unattainable.
So it's finally possible to get GHC on Snow Leopard? Sign me up
Man, I've been out of the Mac/GHC loop for a while. GHC didn't work on Snow Leopard?
Anyone tested ?
At first, it didn't work, but a little hack to force 32-bit mode quickly fixed that. This release seems to be the right way, allowing full 64-bit binaries. (Still building for me, so I can't confirm first hand yet, though I can confirm the &gt;1.5 hour build time on a "reasonably fast MacBook".)
Well, it just finished compiling, and seems to work: sarpedon:~$ cat foo.hs f ::Int -&gt;Double -&gt;IO () f x y = do print (x * x) print (y / 4) main ::IO () main = f 3 4 sarpedon:~$ ghc foo.hs ld: warning: -read_only_relocs cannot be used with x86_64 sarpedon:~$ ./a.out 9 1.0 sarpedon:~$ file a.out a.out: Mach-O 64-bit executable x86_64
On Snow Leopard: ~% cat &gt; tmp.hs main = putStrLn "Hello, World!" ~% ghc -o hello tmp.hs ld: warning: -read_only_relocs cannot be used with x86_64 ~% ./hello Hello, World!
&gt; B...but people generally only use structural recursion over lists for things that are in lists!? What about Data.Sequence? There are right-leaning (cons) and left-leaning (snoc) sequence views which let you do this efficiently, in amortized O(1) time per element. It's true that combinator abstractions obviate some of the need for this, but far from entirely. &gt; I really don't think that structural pattern matching is so much more seductive than "case uncons s of (h,t)" that people are going to forego better data structures. Often by the time they are aware of performance issues, the code is already written in an idiomatic, usually list-heavy style. Lisp has historically also had this issue. Common Lisp has always had high-performing hash tables and arrays, but you still see a disproportionate use of a-lists and p-lists because of the special status of lists. Haskell is not quite so specifically wedded to lists; it's more wedded to the general idea of concrete algebraic data types. &gt; Lazy lists are also, remember, really great data structures anyway! For lots of cases, which involve streaming production as a way to structure control flow, its hard to imagine better ones. They are! No question. Anyway, I don't think this is a fatal flaw in Haskell; I do think your dismissal of the original poster's point was overly glib and uncritical.
I really like your idea. Even more, I've already "invented" the same thing for Lisp - I think Lisp will be easier to translate into image. If you are going to start the project, let me know, I'll be glad to help you
I don't really see what lifted products have to do with n-tuples. One can easily define: data P a b = P a !b to get rid of the extra bottoms if one wants (in Haskell 98, even). But that doesn't get rid of O(n) vs. O(1) behavior which is likely to crop up in various places, regardless of whether products are lifted.
This seems like a pretty cool idea. One question I have is what if the functions produce results that are too big to be reasonably represented, like trees. It seems we run into space considerations on the diagram. I like your idea of embedding the function diagrams though, especially zooming to different function levels. A nice option might be to combine recursive calls, since those could get messy. Another interesting feature may be to add checks for invariants and such.
hmm... I'm a bit excited by this too. I'd love to help implement it if anyone else is interested.
While it's an interesting idea I'm worried that it's too ambitious (and experimental) for a GSoC project.
every first-order value is just a tree, it could be represented as a root node only, with the ability to unfold some more upon a mouse click.
this is awesome! it could also scale to monads, e.g. drawing value of state in top-right corner of the box.
Strict fields are not really the same as unlifted products. I want pattern matching of type products to always be a runtime no-op and always succeed. This essentially boils down to all product pattern matches being lazy (irrefutable) patterns, and not the product fields being strict. Then, (a,b,c,d,e) would be isomorphic to (a,(b,(c,(d,e)))) so the first could be sugar for the latter. I don't think this would introduce O() issues. Also, I think since one can use tuples for anonymous products, there's really no reason to be able to declare new anonymous type products. For anonymous product, use tuples, for named type products, use records. 
The graphical plan seems like a good one (although persuading something to work neatly in a cross-platform way is notoriously tricky). There has been quite a lot of work on tracing and debugging (buzzphrase "declarative debugging"), involving this idea of zooming in on the region of the call graph where the outputs are not those hoped for, given the inputs. Using these debuggers is a bit like playing a text-based adventure game: a first-person shooter would be more fun. Check out Freja (Henrik Nilsson), Buddha (Bernie Pope), and Hat (Colin Runciman, Malcolm Wallace, Olaf Chitil). This prior work may help make the case for the project. These debuggers and tracers all took years to build, but if you're in a position to adapt or even interface to an existing technology, you might be able to argue that the GUI and the interfacing with QuickCheck give significant added value and are achievable in one summer.
I think that would be great! Jonathan Edwards has already done it with their own cooked pure functional language: http://subtextual.org/demo1.html I wish someone would do it for Haskell.
I still have a bunch of G4 and G5 boxes, running Leopard. I wonder if they will ever run GHC again. What are my chances of installing HP via MacPorts on my G5 desktop? I'm too stupid to fight the library dependency problems when building from source by hand, especially given the total pig's breakfast MacPorts has made of my setup. I know, I know, buy a new computer...
Upvoted simply because of &gt;&gt;Since a few days ago a little idea is bugging me: what if debugging Haskell programs would be reduced to a graphical interface and some clicks here and there to spot the problem? Haskell, better said the respective implementations, really require better debugging tools, especially for newbies as I am. As soon Haskell Plattform with GHC 6.12.x is out I will look again into leksha, which looks promising.
hatwitter, for talking out of your hat! /me has studiously avoided getting a twitter account as he wastes enough time on Facebook as it is.
&gt; What are my chances of installing HP via MacPorts on my G5 desktop? Try this: old-g4$ sudo port selfupdate Password: 123456 ... old-g4$ sudo port install haskell-platform If this works then there is a good chance that the chance is probably like a 100% give or take. 
I think pure functionality should really make debugging a snap (at least of pure functional code), and yet debugging it in practice in Haskell is a pain. This project is exactly what's needed to make it *easier* rather than harder to debug pure functional code.
What's non-incremental development?
First look I thought I read 'Saliva'
Some combination of the ideas behind hat and vacuum seems important here. hat: http://www.mirrorservice.org/sites/www.haskell.org/hat/ vacuum: http://www.reddit.com/r/haskell/comments/87v5v/use_vacuum_to_graph_your_heap/ edit: this could maybe be done as a necessarily slow instrumented interpreter for the bytecode already produced by ghc?
Fair enough. I just really haven't seen this problem "in the wild" in any serious code, so I'm not so sure how real it is. I think that once people learn Haskell moderately well these days, they've familiarized themselves with trade-offs among the major data structures.
It's still an unfortunate name, [Salvia divinorum](http://en.wikipedia.org/wiki/Salvia_divinorum#Immediate_effects) is a plant most commonly associated with junior high students trying to get high.
wow this article is not really interesting
I'll use `*` instead of `P`... Using my definition, `(a, b, c, d)` is already isomorphic to `a * (b * (c * (d * ())))`, precisely because the strict field annotation eliminates extra bottoms that would normally be in the latter in Haskell. If isomorphism is what you care about, then strict fields work. If lazy pattern matching (for tuples) is what you care about, then that's just a matter of how you desugar `(a, b, c)` style pattern matches to the underlying representation (since, presumably we won't be using the underlying stuff directly much). It needs to be `~(x, ~(y, ~(z, ~())))` essentially, but that doesn't dictate that all products in the language must be unlifted, which has other implications. And the big-O issues are in the size of tuples. Presumably a Haskell-style 60-tuple can be represented directly as some structure containing 60 + k pointers, and getting any component out is just a matter of dereferencing the right pointer directly (loosely speaking). By contrast, a 60-tuple built up from binary products has a pointer to the first component and a pointer to a 59-tuple, and so on. So it likely takes up something like `60*(k + 1)` pointers (since each sub-tuple presumably needs the `k` pointer overhead). And, of course, projecting out the 59th component requires us to walk down the spine. Making products unlifted doesn't automatically fix this. What is needed is for the compiler to unpack tuples of statically known size into a flat representation. So, for instance, the following might work: data t ::: ts data Tup ts where Nil :: Tup () Cons :: t -&gt; {-# UNPACK #-} !Tup ts -&gt; Tup (t ::: ts) but that's a big "might"; I'm skeptical that GHC will actually unpack that correctly, since the second component of Cons may well be considered polymorphic, and not able to be unpacked. The compiler could certainly be made sufficiently smart for this, but it doesn't require unlifted products. &gt; Also, I think since one can use tuples for anonymous products, there's really no reason to be able to declare new anonymous type products. For anonymous product, use tuples, for named type products, use records. I don't really know what this means. Are you suggesting that data Foo = Foo Int Float Char | ... shouldn't be possible, and instead it should be: data Foo = Foo (Int, Float, Char) | ... (unless I can come up with names for each of the components?) That's how ML does it, but I can't say I'm a fan. It means that the `Foo` constructor is no longer curried.
I highly doubt it was unintentional.
Salvia is the genus for all sage plants. 
It's hawitter not hatwitter.
Just installed it with MacPorts on 10.6.2, works like a charm !
Well, considering the wiki portion of the software is called Orchid, I think there is a very good chance the choice of name is perfectly innocent.
Hadn't noticed, you might be right.
This does not appear to have anything to do with Haskell.
It doesn't, especially because of the implicit global state necessary to make it go, but I thought it'd appeal to the FP crowd.
Hmm.. The windows download still goes to the previous version.
The real story here is that I can now install GHC on 10.6 with macports! port install haskell-platform EDIT: Whoa, in my excitement I missed the 64-bit support part. /That/ is the story!
This is known as a "debugger" in other languages. ;-)
Point taken. The point was strongly worded, because sometimes my strongly worded points make an emotional impact, which is my intent. Other times they are criticized for being silly. Gotta take risks :-) The point of that paragraph, besides an emotional call to action, was about incrementality. The freedom to change code after the fact without affecting its users -- i.e. the essence of encapsulation -- enables perfection. It means you can make the wrong choice and later correct it to the right choice, while allowing the users who were affected by the wrong choice a method of incrementally converting their usages to the correct one. Keep in mind that throughout this discussion, "right choice" and "perfection" are taken to be subjective terms, according to the author. Module abstraction means that you can make code more general while controlling who notices. While type synonyms *may* help, generic parameters still need to be declared explicitly. Moving that generic parameter into the module that is being imported localizes, and together with re-exports it can be erased (from the user). To understand the purpose of free module naming in perfection, consider now that if you thought the perfect name for your package were mtl, you would be wrong. Not because mtl is a terrible name, but because there is already a package of that name. As the number of packages grows, the number of perfect names shrinks, and the effort to find perfection increases. I feel the discussion in the article covers the refactorable typeclasses case well. Hopefully that gives some greater context to my silly quote :-)
I've finally got some free time that I haven't managed to squander. I really like the type signatures. I also like that you've indexed the arguments from left to right. I think you're too pessimistic about how general this approach is. Actually, it really threw me for a while, until I realized what you did. If you inline the second instance of `Overlap`, which is instance (Foo' HFalse n result) =&gt; Overlap n result where overlap n acc = foo' (undefined :: HFalse) n acc with its definition, which is instance (IsFib (S n) flag, Generate flag n result) =&gt; Foo' HFalse n result where foo' _ n acc = generate (undefined :: flag) n acc then it should be clear that the instance heads and constraints are a hand-compiled form of this: foo n result = {- Foo' -} case isPrime n of False =&gt; generate True =&gt; {- Overlap -} case result of X =&gt; X _ =&gt; generate where generate = case (isFib (n+1), result) of (False, String -&gt; result') =&gt; String -&gt; (foo (n+1) result') (True, Int -&gt; result') =&gt; Int -&gt; (foo (n+1) result') which a more expressive language would allow a more direct encoding of (Any Agda people in the audience? Epigram?). It's sad that such a mess is made of such a simple program. 
It doesn't produce 64-bit binaries - but the platform now functions on 64-bit CPUs on Snow Leopard.
Thanks for the feedback and the links. Can this project be proposed for a Haskell GSOC? Or it is too hard / done already / not useful?
yup, I intend to scale it to monads too. Though, not really in this summer (if it will be accepted)
I am teaching Haskell at my Uni (student &amp; teaching assistant) and I've seen that a lot of people have problems with debugging functional programs.
This was the answer I was going to give above :)
It will be splitted in many chunks such that what can be done in one summer will be done.
Thanks for the links. I'll look into them. As for the question, it depends on how I will manage the project
Thanks for the suggestion of other debuggers (and for the `first-person shooter' analogy :P) It will take years to build but a starting point as a usable project can be done in one summer, I think
 Glguys-iMac:~ glguy$ ghc -e 'maxBound :: Int' 9223372036854775807 EDIT: This is using the macports version of 6.10.4
Yep, still waiting on the Windows maintainer to upload. Sorry for the delay -- should be soon. cabal-install needs a patch for Windows.
Please comment on the usability of the site. Also, a request: would someone like to prepare "buttons" or widgets for linking to the platform page? Here's an example, but its my crappy effort, http://hackage.haskell.org/platform/icons/button-110.png See e.g. http://www.spreadfirefox.com/affiliates The goal would be an easy "Get Haskell" or similar button to help spread the word.
http://dl.dropbox.com/u/3468290/gethaskell.png
Luckily the plant is its own deterrent, for its high is not what most would call enjoyable; "scary yet intriguing mind-fuck" is a more apt description of its effects.
So many comments and nothing about actual subject...
&gt; The real story here is that I can now install GHC on 10.6 with macports! That's still the old ghc (6.10.4) and platform (2009.2.0.2) though... When I think of all the efforts that went into making macport's ghc 6.10.4 finally work (I think they finished last week, or something)... and now ghc works OOTB? That must hurt a bit for the macports maintainers.
Greg will likely update to 6.12.1 -- the more ubiquitous the HP is, the better.
So by perfect, you meant retroactively improvable - which implies good encapsulation. I agree with those points :-) &gt; While type synonyms may help, By the way, the fact one can import: "import Blah.Type(..)" will break (I think) if "Type" becomes a synonym, too. Also, open unqualified imports (the default in Haskell) encourage breakage, conflicts, and make adding new exports to a module backwards incompatible. I wish Haskell not only made them a non-default, but completely banned them. If "M." prefix to names is too much work, maybe they should get a new qualification syntax.
Well, this sure isn't working for me, and I've just reinstalled the platform's ghc three times, and made sure it is the ghc being executed. Compiling and running this program: module Main where main = print (maxBound :: Int) prints: 2147483647 
I really like this approach of creating new types for custom views, instead of overriding a generic view (or worse, modifying generated code).
Excellent work! When can you start?
Slightly baffled by the Ubuntu Karmic link... a blog post linking to another blog post linking to a third blog post about Jaunty?
OK, a few usability comments, but only after saying: great job! Neither of the two places where Cabal and Hackage are mentioned make it clear to a newcomer that they are about installing software. s/uni testing/unit testing/ Aesthetics: * The corners on the box on the front page still need to be rounded. * Can't we do better than yingyang for the Mac? * It would be nice if someone good at graphics would redo those batteries.
This is really good. Thanks Graham. I second the request for video if it is at all possible.
The fact that building from source is available for Mac OS X is only mentioned on the Linux page.
Minor comments: the "Learn more" button is displaying too close to the blue ribbon in Firefox for me: adding a little space will make it look better. The "Learn more" and "Problems?" buttons aren't aligned, again adding a space above the "Learn more" button will make it look nicer, and bring the two into alignment. In fact, looking at it, shouldn't the "Learn more" button be *inside* the blue ribbon under the "Cutting Edge" item?
same here
I already have.. Had a couple votes earlier.. someone's been downvoting my artistic genius.
Are you keeping statistics on the number of downloads per OS? I'd be interested in seeing that!
True genius is never understood in its lifetime. :-( I am sorry for the life of poverty and misunderstanding by the establishment that you face. Have you considered signing Van Gogh's name in the corner? ;-)
I've rewritten the "Learn more" page, and added source builds to the Mac landing page. The yingyang is what Mozilla uses -- if someone can find out what Apple actually approves of, we could use that. Re. graphics and design -- help is sorely needed!!
Yes, we have google analytics on the site. I'll publish data once the full system is live (e.g. windows installer is updated).
It seems that the macports version of ghc (6.10.4) is now 64 bit (magically? :o) which you can hopefully use to build a 64 bit 6.12.1
Is there any better resource for the HP - and Haskell- on Ubuntu? It's the most popular Linux distro, but seems to have no champion other than the awesome Debian team... What should we link to?
The YingYang is specifically used to refer to Universal Binary formatted applications that can run on either Intel or PPC based Macs. Since the download link specifically says i386, I assume that this build on HP cannot run on PPC, so the YingYang is not only poor fit, its actually incorrect. All nitpickery aside, great work, very much appreciated!
I don't know, I was just surprised and confused by what I got when I clicked the link. :-) I will try out the Karmic solution when I get home and see if I can clean up the instructions, at least.
Oh, that's useful. We misread the icon. I wonder what icon we should use then...
[mac logo usage guidelines](http://developer.apple.com/softwarelicensing/agreements/maclogo.html)
Minor aesthetic: I think there should be more blue underneath "learn more" --- the bottom padding there is smaller than the top. Other than that --- awesome!
Same here
While I think the model you're describing can be a helpful one in some cases, I don't think it should be wielded as such a stark limitation. GHC doesn't recompile all your dependencies every time you run your code; it doesn't have to. No exception list is necessary. Imagine an emacs command that reformatted a function from a haskell buffer to keep GHCi happy and just pasted it into the GHCi buffer. When you type a function into GHCi, is there really an issue of "not the same Int anymore"?
&gt; Is it as simple as deleting /Library/Frameworks/HaskellPlatform.framework ? I think so. You probably have to trash and reinstall all packages in `~/.cabal` that you installed as a user as well.
Use the [smiling Finder](http://devimages.apple.com/softwarelicensing/agreements/images/logo_maclogo.jpg).
Macports, not the platform version.
I would strongly suggest that you take a more random sampling of real functions in the wild and draw the diagrams manually before going too deeply into this. Graphical approaches always look awesome when you apply them to three nodes that operate on single-digit numbers. Apply them to a 50-node function operating on, say, Text.XHtml values that are themselves already fairly significant trees on their own, and you may reconsider the virtues of this approach. My experience and opinion is that the graphical approaches like this scale horribly in practice and break down long before textual serialization does. I have a hard time envisioning the debugging problem I might have where I'd rather stare at a massive circuit diagram than text. I say this in the spirit of making sure you know what you are getting into, not in the spirit of "don't ever do it never never never!" I strongly believe you should be aware of the long and storied history of this approach before taking it on. If after learning about that you still think you have something to add, go for it. I have my own windmill I'm jousting with myself in my spare time. But know what you're getting into. This is well-explored territory. If you don't realize this is well-explored territory, it's because the explorations usually fail so hard that you never even hear about them.
The new installer does this for you when you upgrade. But yes. Normally you'd have to "ghc-pkg unregister" all of the packages but we operate under the assumption that you want to blow your old GHC install away.
Well, I guess that I can make it scale. SVG looks promising
Actually, by "scale" I don't just mean graphical scale, though that is an issue, I mean it in the fuzzy-programmer sense of the term "scale". As the number of nodes grows the whole thing just stops working, it stops making sense to the programmer anymore. IMHO. In fact, if you do manually make one of those diagrams, I suggest posting it to haskell.reddit or something to get more feedback. Having just manually constructed it, you may understand it more than you would if your program spit it out at you. Actually, you'll get good feedback if you do that no matter how you slice it, both straight to yourself and from others if you post it.
I just noticed that the favicon.ico for the HP is only on the front page - all of the landing pages have just a lambda.
I think your download button is fine. I would just make the "fine print" a tiny bit bigger, so you won't have to squint so much to read it.
I agree, this approach has a lot of potential. Look forward to seeing more stuff from Chris in the future :)
so nice! i was waiting for that! other than the fact that the download for the mac os installer is currently damn slow (max 20kb/s) it's awesome. by the way...is there a way to force the installation of profiling enabled libs? kind of a pain to do it for all packages afterwards...
Some IRC comments suggest that it wasn't a very good idea to put the download on the fragile Hackage host. I suppose the solution would be to get a grant from somewhere for more bandwidth… Or a torrent would help, too.
The installer is 32 bit GHC 6.12, and only works on Snow Leopard. Macports has 64 bit GHC 6.10. 
well, thanks for reading (and understanding):) Just like after staring long enough at matrix code, I only see ifs, cases and other functional constructs when I look at these kind of classes. Haskell has one advantage over dependently typed languages - haskell has separated "hard" code from "easy". Hard code - code that depends on types, is made up from classes, which more or less means that you have to put type signatures over it. easy code - code that doesn't depend on types doesn't need any sigs. If you read the zipwithn paper (from my previous post), there were two versions of agda code, both needed types at the call site - how is that more powerful than haskell? I'm pretty sure that checkList from this post is also impossible to write in any dependently typed language without any type sigs.
http://d.hatena.ne.jp/xanxys/20100321/1269137834 is in English, but doesn't answer your question.
The idea is good, but the implementation is not. There is an implementation that's much simpler and faster.
go retro, start a trend: http://bit.ly/97Eic5 (sorry for the multiple posts, was having connectivity issues)
Ugh. Thanks for saving me a few hours. ^C
Would you care to elaborate? I'd love to be able to point people to a better implementation of this concept.
Well, for starters, you use the lazy state monad but don't use any laziness; so you can make it faster just by changing to the strict state monad. (Although if you spend a lot of time in expensive GD calls, it might not make much difference... but if all you do is set single pixels, the difference would probably be fairly dramatic) You could probably move from the strict state monad to a writer monad with difference lists or a continuation-based writer monad, and avoid the reversal. This may or may not be faster. Or you could avoid constructing a data structure to represent the computation altogether. Something along these lines should work: newtype GD a = GD { runGD :: IO a } deriving (Monad) setPixel = ((GD .) .) . GD.setPixel **Edit:** I just realized that you need some kind of environment monad to keep track of the image, so the above idea won't work exactly as desired. But still, there should be much better implementations here.
Can you think of better implementations then? This seems a sound implementation to me. How do you see it implemented? 
That paper is 12 years old, but even the Agda code in [this one](http://www.seas.upenn.edu/~sweirich/papers/aritygen.pdf), which is only two months old, needs to be told how many parameters to expect. It's been a while since I last looked at the language, so I don't really know what shape it's in.
I'm planning to write a larger tutorial with some examples soon.
This is handy in the context of corpus-based natural language processing. Instead of using a bunch of regexes to strip markup out of wikipedia entries, for example, I can just walk the tree and say things like "ignore footnotes" and "rewrite URLs to just the textual bits". One could also imagine using the tree structure of Pandoc to somehow process the text in some sort of regions (maybe doing something special in quotation blocks, for example). 
The implementation should be sound, but it creates intermediate structures that aren't used in any interesting way. (Although maybe you could find an interesting way to exploit/rewrite them...) This should be much faster, assuming a large number of cheap operations such as setPixel: newtype GD a = GD { runGD :: GD.Image -&gt; IO a } instance Monad GD where {- The definition from Control.Monad.Reader, aka an "environment monad" -} return a = GD (\\_ -&gt; return a) m &gt;&gt;= f = GD (\\img -&gt; runGD m img &gt;&gt;= (\\a -&gt; runGD (f a) img)) setPixel = (GD .) . GD.setPixel This avoids creating any intermediate structures; however for the full library in the repo, it looks like that you'd need some way to modify which image is being referred to, as the C library appears to be a little inconsistent whether or not it mutates the image you pass it or creates a new copy. So you could use a state monad of some kind to hold the reference to the image; however the lazy state monad would not be a good choice for performance reasons, and that you aren't really making use of the laziness. 
A nice tutorial. Pandoc rocks. I wonder if it could be made to understand cabal files, to insert/extract docs, version numbers etc.
Will do it in the next 24 hours.
There are some problems: * Some stuff fail complaining "mmap() returned memory outside 2Gb". This issue seems to be solved in GHC 6.12 according to http://hackage.haskell.org/trac/ghc/ticket/2063. (specifically doing "cabal haddock" for http://github.com/yairchu/peakachu failed) * I had a segfault when using ghci/runhaskell. Crashing program worked fine when compiled. 
One doesn't really solve Luke's problem, as he's dealing with three (or five) different variables, whereas you only deal with one. Thanks for #2 though!
MultiParamTypeClasses? It's not like those aliases have to be semantically sensible or usable in other programs using the same libraries, they just have to abbreviate type signatures.
Are you still following the discussion on URLT? I think Jeremy will be releasing a very nice package soon.
That idea did occur to me, still, using multiparameter type classes would seem to reduce the typing by a constant factor, whereas your solution (in the case of a single variable) reduces the typing to a constant.
what I don't get about ubuntu community, why do they always post instructions? why can't they just put working app in deb package and distribute that?
Elegant &amp; useful tool! I think the extracturls example could be done with interact also: main = interact (concat . extractURLs . readDoc)
I've more or less adopted a Java-style package naming convention for my own packages. (e.g. com.foo.bar) Since I have no current plans to publish any of them, nobody else has to deal with the names, and there are no name conflicts with anything on Hackage. I strongly agree about records. So far they're my #1 annoyance with Haskell.
Thanks, you're right. I changed it to: main = interact (unlines . extractURLs . readDoc) 
Great little article. I didn't realize pandoc had such a nice module and API. It looks like half those things I've been writing Parsec parsers for could have been done in about a quarter of the space and a hundredth of the time with Pandoc. My future self thanks you.
Interesting blog, but why no feed?
&gt; The way to resolve the problem of how much buffering to introduce is quite simple in retrospect: don’t introduce any buffering, anywhere. Then there is no issue of adding or removing it with the laws. No buffering also means no real concurrency. In practice wouldn't it be better to relax the laws? Processes differ from functions (and apparently arrows in the strict sense) in that their internal state (such as buffering) in passing from input to output is more or less observable. That's why they aren't simply a funny notation for functions but a genuinely new and different concept.
The host isn't really fragile. We recently upgraded to a quad core. It didn't go down during the deluge either -- it just has a finite amount of bandwidth. We're setting up mirrors now.
&gt; No buffering also means no real concurrency. How do you figure? What's "real" concurrency? I'm presuming you have something specific in mind that you think is important, but that statement itself isn't valid.
You have a point about this removing concurrency. There is nothing stopping us using processes with buffering where we want them, but for the arrow laws I think that it is best to leave out the buffering to fit better with the rearrangements the laws imply. There is still a clarity benefit to writing each process separately (even if it removes any performance gain).
Mea culpa. Parallelism, not concurrency.
Check out LabView for an example of a commercial circuit-like programming language.
delink can use a "concatMap" using a: Inline -&gt; [Inline] function, instead of manually recursing...
I personally prefer [graphics-drawingcombinators](http://hackage.haskell.org/package/graphics-drawingcombinators-1.3.1). It's a purely functional image interface, and has fast OpenGL-based rendering.
They often post scripts. The scripts often install a bunch of other packages. They could in theory create meta-packages that use dependencies to do this, but this would create a lot of clutter. So instructions/scripts that install/manage various packages are a simpler solution.
Thanks to danderson, we now have torrents for the Haskell Platform, and the plan is to keep these going. * Mac: http://hackage.haskell.org/platform/mac.html * Windows: http://hackage.haskell.org/platform/windows.html * Source: http://hackage.haskell.org/platform/linux.html And an RSS feed: http://hackage.haskell.org/platform/hp.rss
What about using the Haskell Platform logo for the download of the Haskell Platform? http://haskell.org/haskellwiki/Image:Platform-Logo.png
Mac package doesn't specify arch, but it's i386-only. It should specify arch.
The batteries don't look "strong". Something about the single-pixel lines at the positive end feels unsatisfying. I think it's a good concept though, and I'd love to see a next version... (BTW I'm nothing to do with Haskell Platform, or the buttons, or anything official; just passing by.)
Fixed.
Be warned, the Windows link is still to the old version of the Haskell Platform.
The idea is that for the general public, the Haskell Platform *is* Haskell. For someone new to Haskell, the concept should be as starkly simple as possible. Let's not start out by trying to explain the difference between the Haskell Platform and other ways of installing Haskell. So we use the icon for Haskell itself. Also - I agree with gimboland that the Platform icon is not ready for prime time. Whereas quite a bit of time and effort was invested by the community as a whole to achieve the Haskell logo.
Using wiki markup, I centered the logo and the caption inside a box, and added mouse-over text to the icon.
I think klodolph meant "Intel only", not "i386 only". Isn't "including 64-bit" and "i386 only" a bit of a contradiction?
Because people get really confused that "C" and "gcc" are different. Then they pass CS 101.
Sigh. I'll put up the repo link so people can send me *patches* in future.
Beta installer for Windows now available for testing: http://www.haskell.org/pipermail/libraries/2010-March/013299.html
Nice post, even if only to make me aware of the functions in import Statistics.Sample (mean) import Statistics.Resampling (resample) import Statistics.Resampling.Bootstrap (bootstrapBCA) import System.Random.MWC (create) Also, the practice of importing only the names you use really helps when reading code. Anybody know if there a utility that takes care of this? 
&gt; A straightforward way to form a 95% confidence interval would be to arrange your sample times in order, and pick the 2.5% mark (roughly the 25th highest mean) and the 97.5% mark (roughly the 975th highest mean). One nice thing about lazy languages is that when you do this you don't actually have to complete the sort of your samples. When you grab the top and bottom 2.5% of the sequence the sort will only do enough work to compute these values. The work needed to sort the middle of the sequence need never be completed.
the source torrent isn't working
That wasn't my point. Certainly you still get parallelism as well? No buffer only means that A will block sending to B if B is currently busy. Nothing stops A from spawning 100 idle processes and sending them all messages.
Here is a minor bug. Clicking help (the icon with '?') in WinGhci fails. It is looking for &lt;install folder&gt;\doc\index.html The correct path seems to be &lt;install folder&gt;\doc\html\index.html 
Removed. I don't think we actually need a torrent for the src, it's only 1.9M bundled anyway -- mostly a binary file in the OpenGL/examples directory.
I'd love to see this work some day, emacs is full of great ideas, crappy code and people used to low quality, we do need alternative.
My favorite bit about Yi is the power of its parser. It's the only editor that I've found that's in the right place between regex/keyword highlighting and going to the compiler for syntax checks like an IDE. It can really shine here, I think.
I really really miss something like http://www.emacswiki.org/emacs/InteractivelyDoThings (ido) for yi.
Wow, this is the first time 'cabal install yi' has worked for me. Everything looks and feels in order for the vim keybindings, so I'm excited to make the switch!
Awesome! I encourage you to subscribe to the (unfortunately relatively quiet, usually) mailing list and check out the source code.
I noticed it says the Haskell Platform is in MacPorts. Perhaps someone should write a [homebrew](http://github.com/mxcl/homebrew) formula for it as well?
Ditto + its nice that it uses a sane scripting language. Bravo!
By crappy code I suppose you mean random packages you found on the internet rather than emacs itself? Wait til you get countless hordes writing extensions to yi and check back on the quality. (Except that will never happen, of course.)
wow! it installed on freebsd from cabal seems to have a .js mode, emacs keybinding support...i'm really impressed at how far this has come
just check emacswiki, every article has "this works except" or other workarounds. emacs has built-in terminal mode, great idea (you can switch between using it as a terminal and regular text buffer (finally comfortable copying output from programs)) and no one uses it as a default terminal because it sucks and it's full of bugs.
I'll kick it off. I'm using Haskell at work and at play. I work at [Galois](http://galois.com). We use Haskell for everything: kernels, systems, networking, servers, clients, compilers, offline and online tools. I'd like to see: * Hackage 2.0 (social voting on libs), * the full LLVM backend * data parallel arrays * combined heap profiling and thread profiling * epoll-based threads * markdown in haddock comments * prettier haddock documentation * a new haskell.org website design * a high profile, highly concurrent multicore web server * more high profile apps in general ...
I don't really use it for anything in particular. I'm more of an interested observer from the C++ camp.
I'm a student at Chalmers university and try to use Haskell in as many courses as possible (unless it makes more sense to program in Agda :) ). Currently I am using it in my bachelor project (we are writing an interpreter that can optimise functions in runtime using partial evaluation and similar techniques), also using it for writing a smart editor in another course. Since I have programmed in Agda what I really would like to see (except from mixfix operators, parametrised modules etc.) is Agda-mode for emacs (although I'm a vim guy). Working with holes and doing case-splits and refines are really cool. During next week I'm going to test out Scion and see if maybe I can do something with it as a summer of code project, that would be awesome. 
I don't see the reason for the sarcasm tags? C++#s syntax is clunky and hard to understand, map&lt;int, map&lt;int,int&gt;&gt; - that's the natural syntax, and that means bitshift a type. How dumb...
import Data.IntMap type MyType = IntMap (IntMap Int) Don't look at hash table, the IntMap/Map class is likely to be much better. 
Sorry, that was possibly a bit harsh - I just have been doing way too much C++ programming lately, and hate it with a passion
* A working network package on Windows * Cabal.exe bundled with GHC * All the latest hackage packages to fit together seamlessly I realise the Haskell Platform intends to deliver on most of those, so I look forward to it. 
I'd love to use Haskell at work, but don't see this in the near future. As a hobby i try to replace an untyped Python/Processing/Asymptote/TikZ visualization stack with a pure-Haskell framework: http://www.haskell.org/haskellwiki/Chlor
I use it for programming puzzles (Facebook puzzles, project euler, etc.) I also try to sneak in little bits of haskell into everything I do (hadoop reducers in my internship, geometry mesh processing for my research) I'm a senior undergrad at UC Berkeley.
Our company (factis research GmbH, Germany) is using Haskell for network servers, SQL generation and a Gtk2Hs based "CRM" system, we're using internally. We'd love to have good Email libraries for IMAP and Maildir with a really good parser that parses all real world messages. Hackage 2.0 with voting, usage statistics, comments and release notes would be of great help for finding the right libraries.
Watching the Haskell camp to get an early view of the pipeline (What appears in Haskell today *may* be in Scala in a year, in C# and badly programmed Java in two, well programmed but still clunky in Java in three years). Watching to see other ways of thinking, like categories and laziness. Trying to use it as a tool for thinking: modelling in a clear and concise way. (work/play) Worked on the netflix contest using Haskell. (play) What would help? Haskell Platform smoothly and consistently loadable in all three main OSes. Haskell Big Platform with IDE and GUI libs, maybe GUI designer, smoothly and consistently loadable. Idea that I am currently working on, but feel free to grab it and run: XMLSchema-to-Haskell converter. If well done, could be an awesome addon to an IDE: take the XSD file, generate a Haskell data/classes/types library, an XML parser/validator/unpickler, an XML pickler, other structures like GUI, DB, Happs , and then you manually add business logic. This would allow you to generate a SOAP/UDDI/BPML++/LolcatXML frame easily. 
I use Haskell for teaching at Caltech and for my personal programming projects, many of which are experimental language implementations. My medium-term goal is to evolve some of my projects into courses. I'm also interested in Haskell for web applications, but I'm just getting into that area. I also like programming games for fun. The thing I wish for the most is for cabal to work better, with some kind of reasonable dependency control and uninstall functionality (say, at the level of apt-get). As it is, whenever I try to install a non-core package I'm as likely to see a mysterious failure as not. This happened just today with the upgrade of yi, which initially failed because I had versions of alex/happy installed from the Haskell platform where cabal couldn't ascertain which version they were. Once I manually installed alex/happy through cabal everything worked, but why should I have to go through that? At a language level, I'm pretty happy. I wouldn't mind some kind of subtyping support, but I'm not sure what that would consist of. Frankly, there are so many GHC extensions that I need to learn about that I feel like I'll have my hands full for quite a while ;-)
I think GHC can be prompted to spit out the correct import header for a file but I can't remember the incantation.
Any interest in collaborating with the leksah team? Afaicr they expressed interest in making yi the underlying editor
The website is messed up; the phrase "Get the Haskell Platform" overlaps the phrase "The standard Haskell development environment". This would not be a confidence-builder if I had never used Haskell.
* work: prototyping applications for my PhD project on natural language parsing * play: solving programming exercises (http://bonsaicode.wordpress.com/) * play: I've recently started on making a Civilization-like game * play: various other small programs What would help? * A gtk2hs installer that works with the latest (or, better yet, all) ghc versions so I can run criterion and leksah * Making sure all cabal libraries work on windows out of the box (i.e. they don't run perl scripts or rely on linux-only commands) * not vital, but would be nice to have: existentials in GHC (e.g. exists a. Show a =&gt; a)
I see that you're a fan of the "anger and sarcasm" approach to getting your questions answered. It's an unfortunate necessity in a lot of communities, but I think Haskell is a notable exception. Stop by `#haskell` on FreeNode sometime; a friendly question is likely to get a friendly answer in a couple of seconds. Also, `HashTable` isn't a typeclass. You *can*, in fact, tell that from the autogenerated docs in a hurry. Maybe you should brush up on the basics before complaining that you can't understand reference documentation. &gt; Oh, ignore the obvious solution! Ok! More sarcasm? Just going by names, `Data.Map` seems like a more obvious substitute for `std::map` than `Data.HashTable`. Especially since `std::map` isn't usually implemented with a hash -- it's a balanced binary tree, same as Haskell's `Map`. Of course, names can be misleading -- the best approach is to ask any experience Haskell developer, or read some good Haskell code to see what the common practices are. Which is what you did, but with a little more attitude than the average beginner.
I use ansi-term quite a lot, not as my default terminal but I don't see what difference that makes. The emacs infrastructure is immense and, in particular, the packages that are bundled with the editor are very reliable in my experience. I am used to high quality: erc, AUCTeX, ido, org-mode etc etc. Whether or not yi takes off one day it's very hard to imagine it becoming an alternative to emacs other than perhaps for editing haskell. 
I'm learning Haskell recently. It's almost make me feel happy and excited. For daily work, I'm mainly doing C#/.NET and RoR. So I'd to see some improvement in large-scale web development area by using Haskell (it's still complicated for beginner like us).
So it's your job to take something simple like the [Maybe](http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/base/Data-Maybe.html) type and reimplement it in [a thousand lines of C++](http://www.boost.org/doc/libs/1_42_0/libs/optional/doc/html/index.html)? I'm so sorry...
I'm using Haskell for iPhone projects, and am plotting to get it used at $work (which uses Ruby) by trying to get Hubris production-ready. As to what would help me: more robust Cabal, including * testing hooks * as mvanier said, uninstall/dependency control * continuous integration of hackage packages (it'd be particularly nice to have a build farm that could tell developers when new versions of their dependencies are out, and whether their apps compile &amp; pass tests with them.)
There are some great suggestions here regarding tools and implementation stuff. As a counterpart, here's my wishlist for the language itself: * Overhaul the record system; choose one library for first-class labels (from among the three or more available) and make it the standard solution, with good compiler integration * Overhaul the standard typeclasses. Get `Functor` / `Applicative` / `Monad` into the right hierarchy. Get rid of `Show` and `Eq` constraints on `Num` -- better yet, split `Num` into several classes by operator, with context synonyms to ease the verbosity. Get `(.)` and `id` into `Category` and break up `Arrow` into smaller parts. Make `map` a synonym for `fmap`. * Split the `IO` monad into finer-grained monads for different sorts of imperative tasks: concurrency, exception handling, mutable state, file IO, networking, etc. This has benefits for privilege isolation and general ability to reason about code. * Make binding and scoping of typeclasses and instances less special, by integrating them into a more general scheme for implicit arguments. Consider [this proposal](http://lambda-the-ultimate.org/node/3837), the similar mechanisms in Scala, and the (little-used) implicit-argument extension that's already in GHC. * Better type-level programming. Let's see a widespread adoption of type families / associated types and a general purge of fundeps where possible. Work out the kinks as it becomes more widespread. Choose one standard library for type-level programming and put it in Platform (if it's not already there). * Parametrized modules. * Import a module overriding its own export list, for testing / evil hacks. * Agda-style mixfix operators. Get rid of the special syntax of `if ... then ... else ...`, tuples, and lists. * Dependent types. Really, it's not that bad compared to the pile of type-system hacks in GHC. Or as a compromise, integrate some of the ideas from [she](http://personal.cis.strath.ac.uk/~conor/pub/she/) or [Omega](http://web.cecs.pdx.edu/~sheard/Omega/index.html). * No subtyping, ever :D
Not that I know of, but you can call Python or C code from Haskell code. The latter is explained quite well in [Real World Haskell](http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html). 
Upvote for record system suggestion - one of my first pain points.
I use Haskell as a student (for almost every course in the last 2.5 years). I have used Haskell to build (commercial) web applications (mostly using Happstack), and plan to use Haskell for my next startup. I would like to see: * High-level libraries for data storage, preferably in a purely functional way * Good bindings with Cocoa * Client-side scripting that allows you to write components in a composable way, inspired by JavaServer Faces * A way to execute Haskell in the browser. E.g. via an LLVM browser plugin * An IMAP library (either by binding to a c-library or by implementing one in Haskell)
I use Haskell for various types of fun: * useful fun - my [blog software](http://bitbucket.org/spookylukey/haskellblog/) and scripts on my computer. * marginally useful fun - like a [phone2word application](http://bitbucket.org/spookylukey/phone2word/) * useless fun - programming puzzles (though I guess they may help long term) * programming language elitism :-) I'd like to see libraries that use strings (whether String/ByteString) become much faster and use much less memory. Controlling memory usage/space leaks etc is a black art which I'd really appreciate help with.
In what way do you use Haskell for iPhone projects? The two approaches I'm aware of are to use Haskell with the FFI to implement the "business logic" of the app, and to use something like HOC to bridge the two languages. However, iPhone apps tend to be very UI-heavy as opposed to logic-heavy, so the former approach would mean very little of the app is written in Haskell and a lot of work would have to be done for bridging all the data between the two worlds. And the latter approach means using HOC, which the few times I've looked at seemed to be both technically impressive and something I'd never want to actually use. tl;dr: I'm an iPhone programmer by day but I like Haskell, and I'm curious how you combine the two.
I think there are two things that can be done to improve cabal: A. Separate version dependencies specification so it can be independently and retroactively specified for packages. A package cannot predict the future, so packages putting upper bounds on their dependency versions is bound to be either overly conservative or overly lenient. This causes lots of breakage when packages update, or splits - where 2 packages cannot coexist because they specify narrow version ranges but they aren't actually that narrow. B. Get rid of unqualified open imports in cabal packages -- then, a tool could automatically generate a signature of imports/exports of each module and each package. Then, these could be used instead of versions. If semantics change, one can mandate the change of a name too. This would have the added benefit of getting rid of unqualified open imports, which make code significantly harder to read, too.
I'd like to see out-of-the box working * rich and platform indpendent GUI framework * rich and platform indpendent database framework * rich and platform indpendent XML framework In general less dependency problems with Cabal/HackageDB
At [typLAB](http://www.typlab.com) we [use Haskell](http://blog.typlab.com/2009/09/why-we-use-haskell/) for our web backend. We use happstack on the web side, and the BerkeleyDB XML bindings as data storage. We also use Haskell for a few development tools we've written. As for what I'd like (pony!): a more mature, clean, modular web application ecosystem would be very nice (we worked on [Salvia](http://hackage.haskell.org/package/salvia) at the Hackathon). Some more sanity in the relation of the Functor, Applicative and Monad type classes would be nice. Hackage 2.0, as dons mentions below, would also be welcome now that it's growing so much.
What would help me get the job done is other Haskellers (chicken and egg! but I hear hatching sounds...). I use [Haskell for NLP](http://projects.haskell.org/nlp/) and find that one thing that makes it tricky to make a case for Haskell is a dearth of Haskell hackers. Folks get nervous about doing it in Haskell because "but then what happens if you leave?"
work: Trying to convince my coworkers to switch to Haskell :-) Some scripts and tools are built using Haskell (Working on replacing our build system with Haskell). play: Working on LUI - an alternative user interface paradigm to Qt/Gtk+/etc. A UI that combines modern widgets with keyboard usability. I want to later use LUI to build a non-textual code editor and revision control. I believe previous such editors have failed because of their use of various UI toolkits that are simply unusable with the keyboard, which meant they couldn't compete with various text editors in terms of user efficiency. 
I'd like to see: * cabal use module signatures rather than versions for dep. spec. * class aliases implemented and used to clean up old messes (like the Num, Monad class issues). I'd really like a class hierarchy that looks more like the math definitions of numerals. * N-tuples gotten rid of in favor of 2-tuples. This could require unlifted product types -- I like that :-) * a working FRP implementation with continuous time (This rules out Yampa which exposes discrete sampling). * a solution to passing optional keyword arguments to functions. Using records with defaults requires a lot of boilerplate. * a macro system which can be used with a nicer syntax than $(..). Heavy-weight syntax discourages use. * A purely functional compiler implementation. GHC is highly imperative, and compilation is just a pure processor - I think a functional model would be easier to hack on and nicer.
I'm working on a GNU coreutils/BusyBox clone in Haskell called [HusyHox](http://patch-tag.com/r/merehap/HusyHox/snapshot/current/content/pretty/src). The biggest annoyance I've had with Haskell is getting cabal packages to build properly and work together. I'd love to be able to install all the packages I need without tons of dependency issues. Another thing that would have helped me is having much better template haskell tutorials. Template Haskell allowed me to cut down on a significant amount of repeated syntax/architecture, but learning it was like cracking open and reading an ancient tome.
I use xmonad. I wrote a class project in haskell because the class was easy and I needed a challenge so I did it in a language I didn't know. I don't really use it for anything at the moment other than configuring my xmonad.hs file.
That depends on the sorting algorithm. Taking the first element of a selection-sorted list is exactly the same as extracting the minimum directly. But taking the last element (the maximum) requires the whole list to be sorted.
Good catch. My brain has been mired too much in pipeline concurrency recently.
* out-of-the box working remote framework, similar to Pyro/RMI * out-of-the box working, feature-rich EclipseFP Currently for EclipseFP you have to install Scion via git from source, which in addition fails with the hacked ghc 6.10.4, necessary on Snow Leopard
I use Haskell to pad my reddit karma. oops, thats someone else here. In all seriousness, I use it for a my short term, quantitative financial trading business. I built a real-time trading system, from scratch in 99.9% Haskell - including OMS, FIX engine, risk etc. Only non-haskell components are wrappers around annoying Java or C data provider APIs. - Better records, to echo the earlier comments, pick one of the labels libraries and standardize it. - Better Windows support. This isn't really the core haskell team's fault, but HXT has a sorta unnecessary libcurl dependency which makes running it on windows impossible. If anyone has done this successfully and as a step by step guide, I'd love to try. Nothing I've found on google will work. I can get curl to compile, but then have linker errors and all sorts of fun stuff. - More monad tutorials. kidding. - A sequel to Real World Haskell focusing on advanced topics. I'd happily contribute to that and buy a hard copy as I did with the original.
I use haskell in ipwnstudios.com for opengl iphone game development. I fully agree with all the points fouechoruchru wrote. Oh and a nice IDE please.
I'm using it at work for a "compiler" converts [FAST](http://www.fixprotocol.org/fast) templates into C++ code for decoding and encoding messages in the template.
To anybody who downvoted this comment already - you have no imagination whatsoever if you can't tell what I'm getting at. Charly: “Are there any... questions?” More silence... Charly: “Did you enjoy the film?” More silence, then... Scientist 1: “How do you feel at the present moment about your development?” Charly: “Grateful, sir.” Scientist 1: “You’re happy about it?” Charly: “Yes, sir.” More silence, then... Scientist 2: “Why?” Charly: “Because it has allowed me to see.” Scientist 2: “To see what?” Charly: “The world.” Scientist 2: “And what do you see in that world?” Charly: “Well,... my eyes are new doctor... I...” Scientist 2: “And what do they see Mr. Gordon?” Charly: “Things... as they are.” Scientist 2: “And?” Charly: “And what they are becoming.” Scientist 2: “Can you give me an example Mr. Gordon?” Charly: “No sir, you give me one.” Scientist 2: “Very well.” Charly: “Very well.” Scientist 3: “Modern science.” Charly: “Rampant technology, conscience by computer.” Scientist 4: “Modern art.” Charly: “Dispassionate draftsmen.” Scientist 5: “Foreign policy.” Charly. “Brave new weapons.” Scientist 6: “Today’s youth.” Charly: “Joyless, guideless.” Scientist 7: “Today’s religion” Charly: “Preachment by popularity polls.” Scientist 8: “Standard of living.” Charly: “A television in every room.” Scientist 9: “Education.” Charly: “A television in every room.” Scientist 10: “The world's future, Mr. Gordon.” Charly: “Brave new hates, brave new bombs, brave new wars.” Scientist 11: “The coming generation.” Charly: “Test tube conception, laboratory birth, T. V. education, brave new dreams, brave new hates, brave new wars, a beautifully purposeless process of society suicide.” Silence... Charly: “Any more questions?” 
http://hackage.haskell.org/package/HaskellNet &lt;-- It's a start.
http://tutorial.happstack.com/ http://hackage.haskell.org/cgi-bin/hackage-scripts/package/salvia
I use Haskell in many aspects of my work (as a lecturer at the University of Strathclyde). I teach Haskell and I code quite a bit. My colleagues and I use Haskell (+SHE) to implement Epigram. I also use Haskell to write validation and marking software for student work, often to very short order. Sheer bloody productivity is why I love Haskell. The message that software that does useful stuff can materialise in no time flat is not altogether lost on the students. I'd like to see...much of the SHE functionality (data lifted to type level, pattern synonyms, idiom brackets) make it into the language proper: it's not at all gratuitous. I'd really like to be able to write nice web apps directly in Haskell: it would really transform the way I mediate assessment. I've been using Network.CGI, but it's a struggle. Oh, and I'd also like good cross-platform UI kit, and the moon on a stick.
I only use it for play. I don't really know the language, but I am learning.
I think we've applied a few patches from them to help make it easy to integrate Yi, but I don't think any Yi developer (does anybody still consider themself a Yi dev?) uses Leksah, unfortunately.
I use Haskell for as much as I possibly can. Many small open personal projects. I have used it at my last two consulting jobs. One of those for a fairly sizeable project where some long-running daemons communicate via SQL db to perform email and XML parsing, analysis and email generation. I'd like to see: * Uninstall with cabal-install * Ability to build native bin for Android on Arm hardware. I understand this is already doable, but it seems like a prickly process at the moment. Or maybe LLVM fits into this somewhere. * Aforementioned overhaul with respect to Functor / Applicative / Monad, including MonadPlus reform * Myself get better at advocating for Haskell in the workplace Someone here mentioned the lack of Haskell programmers being a barrier. I had this come up at one company and I told them that the community is dedicated and bigger than you think. Let me hire and I'll get people. One thing companies need to do is embrace telecommuting as an opportunity, not something to be feared. We're out here, just not clustered in large groups everywhere software needs doing. 
I do software testing for multimedia applets. I use Haskell to general XML files that contain the manual tests for each product. It's mostly just a way to refactor the test sets and add some random selection. I'm trying to move into the world of independent game development and Haskell will play a key role in that. I'm currently working on getting GHC to play nice with [Unity](http://unity3d.com/) via Mono on Mac OS X. I also want to explore the options for bidirectional communication between Haskell and Tcl to support microscripts for things like flexible input input device configuration. (I realize that I have a lot of research to do in these areas; pointers would be great.) The biggest problem that I've run into is that GHC 6.10.4 is a square peg forced into the round hole of Mac OS X frameworks; linker fun galore. I'm very grateful for what has been done but there may be a lot more work needed (I haven't had time to look at 6.12 yet). The second biggest problem is getting XCode and the Mac OS X installer to do what I want. (Part of my problem is that I came to Mac from Linux and Solaris and part of it is that Apple's developer tools are stuck in 2002 when it was amazing that anything on OS X worked at all.)
I'm just trying to learn it, slowly but surely. I think it's an amazing language. I'd like to use it more for experimenting with small programming languages, etc. Unfortunately I can't use it much for my actual work because it involves a lot of real-time programming, which basically limits me to C/C++. One of my goals in life is to eventually make it nicer to write real-time friendly programs. ;)
I use Haskell for play and study. I did my thesis in Haskell and now I'm looking for a library to wrap (and learn ffi in the way). Sometimes I use Haskell for simple tasks at work. For example, to manipulate code when the emacs-macros fall shortly.
This. &gt; Separate version dependencies specification so it can be independently and retroactively specified for packages. A package cannot predict the future, so packages putting upper bounds on their dependency versions is bound to be either overly conservative or overly lenient. This causes lots of breakage when packages update, or splits Another thing which might help is if hackage would detect the breakage on its own. Mock example: * Joe builds "CoolPhotoEdit" v1.0 which depends on the "content-aware-fill" (v3.2) package by Jane. * Jane creates a new and improved version (v3.3) of "content-aware-fill" where the API changed slightly. * Hackage builds the reverse-dependencies of "content-aware-fill" to see what gives. It finds that "CoolPhotoEdit" gets brokens by the new version so it modifies its dependencies to require "content-aware-fill &lt;= 3.2" 
Haskell for any of my personal projects and where I can, at work. Haskell IRC is awesome. Cabal needs to get better, though.
Mostly play. "cabal install DefendTheKing" to see my game (playable but it's work in progress) Most pressing issue: [hackage breakage](http://www.reddit.com/r/haskell/comments/bhygx/there_are_more_than_4000_people_in_the_haskell/c0muy4s) 
That could be cool, though it might require quite a bit of building power on the hackage servers...
Haskell is my goto language for any miscellaneous task. It has replaced: Perl, Ruby, Java and Erlang for me. I use it for anything from text processing to web apps to data modelling to concurrency.. I also use it at university as part of my research.
Type inference is a major selling point of haskell. Type inference + dependent types means your type inference requires alot more user prompting.
I'm using Haskell in my spare time for solving small puzzles and playing with it. I also use it for configuring xmonad on my netbook (which I still have to fix since yaourt broke a few Haskell packages). I've also assisted a Haskell lab course for first years at the Delft University of Technology a few times.
We still continue to have a disproportionate ratio of windows downloads (&gt;50% of all HP downloads) and windows developers. I wonder if we can do something about that.
&gt; * Hackage 2.0 (social voting on libs), Not only some kind of voting/rating, but I'd also like to see some kind of wiki-like support for the documentation of packages. Perhaps something like suggested [here](http://www.reddit.com/r/haskell/comments/8bylw/ask_haskell_reddit_how_can_we_improve_the/c08tc0q).
Hmm.. I use Haskell for two things, mainly. First, I'm an algebraist, and I use Haskell for research. I tend to focus, a lot more than others in my particular field, on building constructive results and explicit descriptions of things, and having a nice mathematical programming language is a huge help. Second, as a developer (and, more recently, owner and technical support and accountant and... yikes! Being "your own boss" is overrated.) of a web application, I use Haskell most of the time for whatever I can. That doesn't (yet? who knows...) include the application itself; but it does include a growing collection of support software, monitoring, etc. What would I like to see? Honestly, I like what I see now. I don't that there's anything "big" that's missing. A single, mature, and successful web application framework would be great, but I think we're getting there, and it would be a mistake to try to unify or collapse down to one at this point. Which one? How would we know when so many people are experimenting with different ideas?
Aside from the main topic: I'm interested in learning about quantitative financial analysis, but I'm having trouble nailing down how to learn it either independently or through curriculum at my university. I've got a nice math background, but I'm at the stage where I can't even do a good search because I most of the terms I know are buzz words. Any tips? Textbooks? How did you learn about it?
No, the core code of emacs itself sucks. And elisp is a pretty crappy language, too.
I use Haskell for "recreational programming" because of the sheer pleasure of writing in a language this elegant. I've been working on a Go playing robot for sometime now. I've also used Haskell for my entries in Project Euler. In my work life I program in Java. Bleh!
I'd really like to see whatever custom Yi config files people are using -- I can run it with emacs keybindings and it seems just dandy, but there's still not any functionality that seems beyond what I can get in emacs' haskell-mode (and I'm not sure that I'm even getting all that). One or two "killer app" features would really help me switch.
I'm using Haskell at work (PhD in metallurgical engineer). I've made some small programs to deal plot and analyze data. Now I'm going to use it in a big project about 3D microstructure generation and simulation. I'd like to have more info and example about Data Parallel Haskell.
At work, I have a few scripts written in Haskell which I use constantly during my day-to-day work in C, and occasionally give out to others as part of a gradual campaign to get my coworkers hooked. I also sporadically hack on [Bustle](http://willthompson.co.uk/bustle/) on work time. A lot of people are pretty keen on it, but are reluctant to contribute because they don't speak Haskell. I was hoping it would be a gateway drug—particularly since most of it is just Gtk+ and Cairo, and I think the Haskell APIs are sufficiently similar to the C ones to let people already familiar with those libraries get stuck in—but oh well. I'd really like to have a GUI library that feels more functional than gtk2hs does, but is also actually usable for real applications. I end up slinging application state around in IORefs or jumping through hoops to reconstitute my state monad in callbacks, and it just clutters the code. But this seems better than the alternatives at the moment.
I use Haskell to improvise music, having a lot of fun writing FRP-like musical pattern combinators. Here's slides for a presentation I gave the London HUG about it in September, although it's come on a little bit since then: http://docs.google.com/present/view?id=ah2x4mkf2fx_112gwnffpck 
This could be in part because of Linux users relying on the package management system of their distro...
I think getting gtk2hs to be installable by cabal would be awesome. Just recently I tried installing the haskell platform on rhel 5.4, with ghc 6.12.1, and gtk2hs won't build (even with –disable-split-objs as I found in a blog entry). Looks to be due to mismatches between the gtk version and that expected by gtk2hs, and I don't particualrly want to fart around with compiling non-standard gtk versions etc. The upshot is that some of the sexy attention grabbing things, imho like threadscope and the criterion library with charting, are a pain to get running. Things are easy on my home machines where I have the latest and greatest fedora etc, but at work we're more conservative about distributions. Having more solid straightforward support on distros like rhel would make life much better for industrial users imho.
In particular my pattern representation is now this, a Maybe stuck in the period so I can represent infinite patterns (I think this was inspired by a question I got at the HUG). data Pattern a = Pattern {at :: Int -&gt; [a], period :: Maybe Int}
Perhaps there could be a syntax+type-check only build mode which is quicker for this purpose (or maybe even it exists?)
Well, Linux is certainly underrepresented in downloads (&lt;10%), while they're around 25% of the visitors to the site.
There are a few developer configs in src/Yi/Users/, and I encourage you to contribute your own if you figure out how to do something neat!
I see, well I'd have funding for this, but sadly don't have time. A problem of being a student and a parent at the same time I suppose... No matter, I've learnt much from your book anyhow. Have fun!
I use Haskell for play, I'm working on some kind of Computer Algebra System (like [GAP](http://www.gap-system.org/) but in Haskell). And in a way, I use it at work to keep my sanity and challenge myself after all the day-to-day Java stuff. What would make Haskell even nicer: - A solution to the standard Num annoyances. - Some built-in solution to the restricted monad problem, although [the rmonad package](http://hackage.haskell.org/package/rmonad) seems to help. - Bring back monad comprehensions. - a cross between hslogger and Debug.Trace, for tuning loglevels interactively in Ghci. - I have a gut feeling GADTs have not yet reached their full potential. - Class context inference and/or class context aliases. And a way to to reify dictionaries. In short, first-class contexts, I guess. - Variants of the containers-types where the (Ord or Eq) dictionary is explicitly passed in. - And I'd like to understand when to use Incoherent/Flexible/Undecidable Contexts/Instances in a predictable way (that's more my shortcoming though :)
I use Haskell to experiment with high-level (denotative/functional) means of generating interactive graphics &amp; UIs and fun ideas that arise in the process. Continuous time &amp; space usually play a central role. I'm currently focused on generating graphics processor code and GUIs from a Haskell-embedded DSL. By far, the most helpful improvement for me would be a base, cross-platform GUI library that is easy to install, looks great (native on mac os x), and plays friendly with ghci. wxHaskell kills its host (e.g. ghci). gtk2hs doesn't have native os x support that supports opengl, and so looks ugly, and needs tons of stuff from macports. I prefer the elegance of wxHaskell to gtk2hs, but of secondary importance, since I mainly want something on which to build functional libraries. Second, I'd like an OpenGL library that allows sharing of context-attached graphics resources. And automatic garbage collection of graphics resources (textures, buffer objects, gpu programs), so that one can program in a much more functional style. Taking these two wishes in another direction, I'd like a solid &amp; elegant cross-platform GUI library that is built on OpenGL rather than legacy OO libs like wx &amp; gtk. Take advantage of modern graphics hardware to do beautiful widgets. Oh, and multi-touch friendly.
I work at [Bluespec](http://www.bluespec.com), where our high-level hardware synthesis tool is written in Haskell. This is a large Haskell code base (&gt; 100K LOC) which is very actively developed. My most wanted Haskell tool would be a really powerful code refactoring framework.
Well I was the last developer of the Eclipsefp project (Haskell plugins for Eclipse). I haven't worked on it lately for mainly two reasons: 1. Not a lot of feedback so I don't feel people are really interested 2. I develop in Java full time at work, so working on Eclipse during my free time instead of hacking Haskell code didn't exactly feel like improving or discovering something new. So I guess I should just join the Leksah project... But I kinda like enjoy tinkering with Haskell: games, little AI algorithms mainly.
Yes, yes yes. A functional library to do both UI development for apps and more graphic works for say games? That installs like a charm on Windows? OK, I'm sold. If only I could get the tao of FRP...
What sorts of issues have you run into writing webapps? Since you've got other fish to fry besides web development, I'd imagine that you mainly want a simple, straightforward way to build relatively straightforward apps, and don't have the time to play around with this and that new toy or feature. So maybe the question would be, better phrased, what would the API of your ideal web lib look like for the types of tasks you need to do?
I am using Haskell to build PcapStitch. A tool that correlates packets in packet capture files recorded simultaneously at different points in a network. I am new to Haskell (&lt; 1 year) and I would love to have more blogs from the seasoned veterans in the format of "to solve this problem using [c,python,c++,java,...] you would do [something], you can do the same with [fancy Haskell construct here] and they are related because [something]".
* [not so popular iphone apps (e.g. lyric viewer)](http://itunes.apple.com/us/app/icy-lyrics/id351989184?mt=8) * [work in progress, recreational game engine](http://jinjing.funkymic.com/2010/03/11/Colorizing-Miku) and more ... I'd like to see more LLVM stuff :)
I use Haskell for my work in mathematics research, specifically in order to easily code algebraic algorithms of various sorts. The large power in Haskell, to me, is the flexibility in the type system, and the ease with which mathematical concepts can be translated into Haskell code. And on that note, my wishlist would contain: * Replacing Num with a sensible algebraic hierarchy. * Dependent types.
yeah eshell seems oddly flaky compared to the rest of emacs.
I am a middleware developer at a large european telco. I use haskell to solve problems on projecteuler and otherwise screw around.
I'm learning Haskell for fun. I'd never heard of functional programming before Haskell, and I was getting tired of Python and C#. Recently I've switched my focus to Erlang, but I think I still prefer Haskell. I don't have many useful Haskell projects done, mostly just project Euler stuff but I'm hoping to start work on a notepad clone soon. EDIT: Forgot to include what would help me. A bigger brain, mostly, and maybe a little more time and motivation. Also finding tutorials/books that go a bit further. I'm not really sure how to get from currying and tail-recursion to a full fledged application, you know? I still feel like I'm missing some basic concepts, but I often feel it's my imperative, OOP background holding me back.
I use Haskell for university coding, for fun and for most data mangling tasks at work.
I use Haskell mainly for learning math and to "expand my mind" ;-) On a more practical side I played with Haskell for some simple Cocoa test applications (on the Mac). Now I am thinking about using it for iPhone apps, but I am not sure if this is a wise choice in the light of Apple's app review process. 
Actually, gtk2hs is on a track for inclusion. wxHaskell's already cabalized as well. We could imagine both being in the HP in say, a year.
I use Haskell mainly at work on projects that have and are continuing to ship to customers embedded in some control/management systems. What I'd like to see most would be a guide or a book or something helping people to spot resource allocation issues in lazy programming languages in general, or targeted at Haskell. Optimization of Haskell is quite an art at this point, and while I'm impressed by people using genetic algorithms to optimize code via compiler passes, I'm not so sure that's what I want to be doing in a production environment so much. I think Hackage and the Haskell Platform are very important, as well as companies getting involved with the community. 
I'm just using haskell for fun at the moment. my wishlist: a native haskell rdbms for a haskell programmer who isn't a regular user of windows, an easy way to distribute applications written in haskell for windows users, e.g. start with a cabal package and create a zip file containing a standalone exe which will run without any extra installers needed (no ghc, gtk2hs, etc.) a recommended reading list of haskell programs or libraries, e.g. a list of the top 20 packages on hackage with source code that isn't too difficult to read that you can learn good haskell style/ techniques from, preferably large codebases 
I think much more downloads are uncounted due to installations from AUR or Gentoo's portage or maybe somethings other distribution-specific repositories.
eshell isn't a regular terminal mode. See http://www.emacswiki.org/emacs/CategoryShell .
Indeed, even the exciting new async/event-driven IO development is targeted only towards *nix platforms :( Windows and IOCP get no love. 
&gt; And on that note, my wishlist would contain: &gt; [...] &gt; * Dependent types. Wouldn't bolting dependent types on to Haskell be in the spirit of C++? Many worthwhile dependently types languages are being implemented in Haskell (Eprigram, Agda). That makes using something like Attoparsec (for example) from inside them more straightforward than it would otherwise be. The absence of a real FFI in these languages is a problem but a much smaller one than bringing dependent types to Haskell.
I use Haskell for work and play at [Portland State University](http://hasp.cs.pdx.edu/). I use Haskell for the range of things - from simple programs using [Chart](http://dockerz.net/twd/HaskellCharts) for graphs, to networking/comms, to [kernel modules](http://haskell.org/haskellwiki/Kernel_Modules). Ordered from most to least likely, I would like to see: * GHC to support cross compiling to OMAP3 or OMAP4. (go [alpheccar](http://www.alpheccar.org/en/posts/show/94)!) * A more feature rich network library that doesn't use exceptions. * MTL to go away and leave the transformers library to reign in a new day. * Cabal support for c2hs * Fast "[safeCoerce](http://osdir.com/ml/haskell-cafe@haskell.org/2010-03/msg01075.html)" allowing bytestrings to be transformed into properly sized unboxed arrays of flat types (WordX, IntX, etc). * Flexibility in calling convention. If the FFI could formalize a system like gcc's __attribute__((regparm X)) that would be good. * Partial evaluation in GHC * Improved [c2hs](http://www.cse.unsw.edu.au/~chak/haskell/c2hs/) by adding a method to call macros (auto-generate a function for macro "calls"), allow getting the address of structures via {#get &amp;struct-&gt;field#} * Hackage to be based on a distributed system with packages signed by the central server. * Resource-aware tools (ex: memory) * Axiomatic semantics for the Prelude and support for specifying package deps by numbered axioms. * "sum" to be defined via foldl'
you could try CQF program. (It's way cheaper to just read the reading list though).
&gt; Overhaul the record system; choose one library for first-class labels (from among the three or more available) and make it the standard solution, with good compiler integration Several people have said that; what are people's favorites right now? (Consider it a poll.)
Interesting idea, I don't think it exists
I was at that stage in the first 4-5 months of using Haskell... Then, later, I suddenly realized I'm much more productive in the ghci REPL than in the Python one...
Toyed with it for play a few times. To use it for work, mainly it would have to be embeddable as basically a scripting language for Java. This is how I have been able to use Tcl (Jacl), Python (Jython), and Clojure at work.
Emacs has certain fundamental limitations, like that it will probably never be multithreaded which severely limits the amount of semantic analysis that can be performed without impacting usability. Yi might not be the editor to replace it, but I think Emacs' days are numbered. Once a year or so, I survey the alternatives and return to Emacs because nothing else I try is bearable for editing text, or offers sufficient semantic analysis without being overbearing about the definition of a "project". But I don't expect it to stay this way forever, and every year my desire to have concurrent analysis goes up.
I'd love to see that, but I think it'll be pretty hard. Getting gtk, much less gtk2hs, working on a Mac is a royal pain (MacPorts is stunningly broken wrt anything graphical).
I strongly agree with this. On a nice 6.12.1 install, I've fiddled around with little luck on Gtk2Hs. It's too painful for something that important.
Dependent types make it nearly impossible to have a fully automatic typechecker (as I imagine you know), so this would be a gigantic change in the language that I don't think would get the go-ahead from the core developers. If there was a pay-as-you-go strategy (fully automatic typechecking if you don't use dependent types), it might work, but this seems like a topic for research. Right now, it seems like Haskell's philosophy is to push fully automated typechecking to its limits.
In this spirit, I'd love solid and complete Qt bindings as part of the platform - it'd make life very pleasant indeed.
Multithreading is coming in v24, apparently, along with bundling the package manager elpa and lots more. You won't escape that easily :-) 
Do you have a source for how multithreading will be implemented in v24? My concern is that the semantics of elisp, upon which all the code that makes emacs great relies, as well as the primitives for inspecting and manipulating buffers, depends on mutating global state. This seems very much at odds with concurrency. If the language and standard library changes in such a deep way, it will be a monumental effort to renovate all the existing code, and stability is likely to suffer for a long time. I would be pleasantly surprised if someone has come up with a design where existing code can run safely, without taking a global lock.
You can run `ghc -ddump-minimal-imports` I believe.
I think all of the current HP packages are now available as debian packages in Debian Testing and the upcoming Ubuntu 10.04 release. For users of these systems, downloading HP from hackage is probably less attractive than just using the debian tools. 
I've no idea how it's implemented. Isn't it the case that if every buffer runs in its own thread and takes a global lock on everything the worst-case scenario would be no worse than it is now, and maintainers of individual modes can then gradually implement a smarter strategy case-by-case?
Just some fun stuff. Lately i have been playing with HAppStack and trying to make a simple L-System. Wish list: * better REPL [ it would be awesome if GHCi was like bpython] * every thing cabal installable and uninstallable * a better dependency system for cabal. * more simple examples of monad transformers, TH or SYB in use etc, * the remaining chapters of Learn you a Haskell for Greater Good 
I use the GHCi as a calculator.
Cabal packages for gtk2hs are being tested right now. Drop in to the gtk2hs mailing list and join in!
I use Haskell in the field of robotics. This includes lots of networking, lots of data processing (I mostly do image processing), control, behavior/algorithm development, and a fair bit of graphics for visualizing real and simulated systems. My main wishes are: - An improved GUI story. I use wxHaskell and it's quite nice, but doesn't work well with GHCi, and isn't the easiest thing in the world to install unless your point of comparison is gtk2hs. - Better record support. This one is just annoying because it seems as though it should be a slam dunk for Haskell to figure out. - Parameterized modules. I use Units in PLT Scheme quite a bit and have used functors in SML in the past. These things are missed. - Class constraint aliases. This is somewhat related to the previous issues. I have, on occasion, had very long types, due in part to a lack of parameterized modules, that I wished to reduce. I have a pile up of classes due to the module problem, and a pileup of parameters that isn't helped by a reluctance to define new records for fear of name collisions. If the other issues are addressed, maybe this one fades away. - For the Haskell Platform to evolve. I'm not able to currently rely on it as it isn't supported on one of my older development machines. More generally, it seems like the right way to cut through some of the inevitable clutter and confusion that Hackage brings with it, but it doesn't yet seem to be there yet (where "there" means that 95% of the time, you already have the library you want). That said, cabal-install, in conjunction with hackage, is just fantastic, which actually makes me somewhat less certain about emphasizing the rigidity of the Platform over the flexibility of hackage. Basically, I wish the Platform was more of a one-stop shop, I wish it were easier to choose among the options on hackage, and I think everyone contributing is awesome. :)
I use Haskell for fun, mostly for prototypes that never go anywhere. As such, there isn't much that I really need. What would most help is: * make Cabal install all packages as user by default. UAC isn't going anywhere. That doesn't stop me from having a wish list, though. What I would like to see is * allow instance declarations in `where` blocks. This should partially eliminate the need for implicit parameters. * finite type quantification, i.e. `forall a in (Int, Char, Bool). t`. This should make types involving GADTs more precise, and hopefully make type inference for GADTs more decidable. * closed kinds for phantom types. And kind-level polymorphism, since type families wouldn't work well with closed kinds otherwise. 
AUR is not a good example here -- it uses pristine URLs. Yet the claim holds for almost every other package management system.
I use Haskell to write my [presentation utility][tkhs] and several small projects for fun. [tkhs]: http://hackage.haskell.org/package/tkhs What I'd like to see: * bulk module imports ala scala that allow import Control.{Monad, Applicative} * implicit or generic newtype wrapping and unwrapping * it's about ghc for Mac, dynamically linked libraries and 64 bit binaries support 
Haskell has become my default go-to language for almost everything: * Data processing, transformations, analysis * Database operations that require more than SQL * Web crawling and parsing (via the excellent HXT library) * Small, low-level networking tools I would like to see: * A culture of including actually working getting-started samples with any library published on Hackage. I can't possible overstate the importance of this as the community grows. Working examples reduce time wasted in the learning curve significantly. Much can be learned from Python/Ruby communities in this aspect. * Improvements to Hackage (as suggested by others). Much can be learned from GitHub here. I also wouldn't mind if a greater portion of the community started using Git. * A strong environment for developing web applications in Haskell. There should be a good set robust, vetted, documented and mature libraries for web servers, html rendering, data back-ends, etc. * A book on developing web applications in Haskell with best practices in producing robust production-grade applications. * An advanced Haskell book with best practices on developing larger applications, using typeclasses effectively, etc. 
&gt; a cross between hslogger and Debug.Trace, for tuning loglevels interactively in Ghci. I am working on something along those lines.
(Disclaimer: I'm wxHaskell maintainer) I use Haskell as my 'go-to' language for most scripting and tools tasks - and have some success persuading others in my group to do the same. It's peripheral to our main business, which is mobile phone chipset OS software - and at least for the moment I don't think Haskell has a 'story' for this type of work, although I'm hopeful for the future as we have more cores to work with. Interesting how many people are keen to see a solid set of GUI bindings. I originally took on wxHaskell maintainership because I had just that need in some of the tools I have worked on, and gtk2hs didn't meet my needs (windows-centric, no LGPL allowed). Problem is that wxHaskell (and I get the impression that this is pretty much true of gtk2hs and qthaskell) are 1-2 person efforts, and at that, mainly people who have day jobs and try to squeeze development into limited spare time. It would be great if the community could agree on a single GUI binding for Haskell, but I suspect that pride, installed base and licensing wars (I would be unable to use any library that introduces a GPL or LGPL dependency, for example) may make this impossible. I'd love to fix the many (some serious and long-outstanding) bugs I know about in wxHaskell, do more advocacy, improve the documentation etc, but all I can find is about 4 hours a week :-( Doesn't help that the day job is hard-core embedded C and C++, so I have a *big* mental shift when I go into 'Haskell mode'. So my other 'wish' would be a good set of higher-level tutorial material to introduce me (a.k.a. experienced softeware engineer, clueless mathematician) to some of the more complex topics. There's a definite need for something which goes to the next level after RWH (which I bought twice - once as ebook and once as dead tree ;-)
there's ghc -fno-code, but nothing for cabal.
nothing super-clever - just FFI work. It wasn't actually my project, and I haven't contributed to it in a while, but it was a game with reasonably complex logic, so I think it did make sense.
There is an [alpha-level cabal release](http://sourceforge.net/mailarchive/forum.php?thread_name=87bperrxyr.fsf%40ubuntu.domain&amp;forum_name=gtk2hs-devel) available right now! Try it out and let gtk2hs-devel know how it went.
Right now, I'm using Haskell to calculate the average running time of some asynchronous adder circuits. For example, an asynchronous version of the classic ripple-carry adder is, on average, about 5 times faster than the synchronous version, because you hardly ever have to wait for the carry to ripple through the whole thing. Next I'm going to work out how fast asynchronous carry-lookahead adders can be. It's exciting! I think that if I apply these to hardware acceleration of the [Threefish](http://en.wikipedia.org/wiki/Threefish) encryption function (the foundation for the Skein hash), I may be able to outdo everybody in speed. Hopefully.
I use Haskell mostly for hobby projects: a ray tracer [1], a web site running on HappStack [2], and my most recent project is a sort of simple planet simulator that is something like Conway's game of life, but wrapped around a sphere. I hope some day I have an actual job where I can use Haskell regularly. Some things I wish Haskell was better at: * I'd like to see an erlang-style message passing API for writing distributed applications. * Better floating point performance would be nice, as well as some sort of low-level access to SSE instructions. * I think "Real World Haskell" needs a sequel. There are a lot of technologies that seem like they're generating plenty of excitement, but I don't understand them well enough to know why: GADTs, FRP, type families, zippers, arrows, various IO models, etc.. * The LLVM backend sounds very cool, I'm looking forward to trying it out. [1] http://www.haskell.org/haskellwiki/Glome [2] http://lists.bootlegether.net/
&gt; A culture of including actually working getting-started samples with any library published on Hackage. I think this would be really great.
[ExistentialQuantification](http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types)
"the remaining chapters of Learn you a Haskell for Greater Good" I'm looking forward to those as well. The applicative functor chapter was very good. 
Is there an up to date review/comparison of the currently available alternatives and/or any plans for the future? On [http://haskell.org/haskellwiki/Extensible_record](http://haskell.org/haskellwiki/Extensible_record), many of the links are to pages or papers which haven't been updated in some time.
Markdown in haddock seems like a fantastic idea. Also I would love to be able to write Bird-style combination of code and markdown.
I use Haskell for fun, and Ruby for profit. I've mostly used Haskell to solve Project Euler problems, so that I could get familiar with the language. I hope to write some robust real-world applications with it some day.
I use haskell for application development (for personal use). I like it that it is multi-platform (windows, linux). It helps me focus on the problem and create the solution from the start "not too dirty" what allows me to share results (e.g. wikipedia4epub). At work I use it for some helper tools or parsers (parsec is pleasure to use, the same xml-light). anyway, haskell allowed me to be "isolated" from all that "nice frameworks" everywhere and really focus on solving the problem (defining the data, some kind of domain, abstraction of the problem and than operations...) I'm not at the stage to say that there is something missing, except I like to see haskell platform with ghc 6.12 also for windows :) I want to see some cross platform GUI library within the platform (e.g. wxhaskell) so after installation of platform I can compile my app without need to download of something else. 
I had not seen Agda's mixfix operators before, thats pretty nice looking.
Wow, I didn't even know it was possible to write a Haskell program that large. Given how dense and compact Haskell code usually is, wouldn't that much of it be self-aware?
Thanks; I definitely will!
Yeah. for a while now i have been recommending this instead of RWH to many new comers to Haskell. Wish the author [ or any one else who can write in a similar style] is listening :)
Thanks, -ddump-minimal-imports works great.
The standard typeclasses overhaul is at the top of my list, but I don't have a giant pile of legacy code to worry about holding me back.
Agreed!
&gt; a native haskell rdbms I'd be for this too, if we're thinking more like an in-Haskell relational library and less like an embedded SQL system.
Could you plese blog about Salvia or any thought about haskell web development.
I had used Haskell for my website with happstack and sqlite, but ended up switching over to LAMP with wordpress so I could focus what little hobby coding time I have to stuff I enjoy. I've started to toy around with a writing multiplayer realtime roguelike in Haskell, but it's currently in prototyping. I might also write a board game using SDL. More blog posts, not white papers, that are readable by non-mathematicians would help me the most. I'm trying to blog about Haskell as well, but the goings are slow. To people like me, RWH was a step in the right direction.
One of the ideas I've had was to take some projects off of Hackage and write blog posts essentially mapping out the source code and explaining how things work. I think being able to read a dissection of a code base would be very helpful while trying to learn Haskell and its idioms.
This is on a RHEL 5.4 box. I could have done things the daft way since I don't know these tools at all. cairo: I had to edit Graphics/Rendering/Cairo.hs and comment out the include of cairo-version.h on line 8 because I'm using cairo 1.2.4 and the file doesn't exist. pango: I had to comment out line 64 of pango.cabal ("includes: hspango.h") to make error about not finding it go away added --extra-include-dirs=`pwd` to help find it in the local directory. Also I tried to add a configure flag telling it where to find gtk2hsTypeGen even though it was in the haskell platform install directory (rather than /usr/local/share). Eg. me@here ~/Desktop/pango-0.10.5$ runhaskell Setup configure --user --prefix=/home/foo/tools/haskell-platform-2010.1.0.0/ --extra-include-dirs=`pwd` --with-gtk2hsTypeGen=/home/foo/tools/haskell-platform-2010.1.0.0/bin/gtk2hsTypeGen Still insisted for looking in the standard places for other things, and worked around by adding a link in /usr/local/share for gtk2hs-buildtools-0.9. This is not really a solution, but its late and I wanted to see if things would otherwise work- need a way to not touch /usr/local. Had to hack hspango.h to add major, minor and micro defines for 1.14.9. gtk: Setup.hs:25:0: warning: #warning Setup.hs is guessing the version of Cabal. If compilation of Setup.hs fails use -DCABAL_VERSION_MINOR=x for Cabal version 1.x.0 when building (prefixed by --ghc-option= when using the 'cabal' command) Configuring gtk-0.10.5... Warning: 'include-dirs: dist/build' directory does not exist. Setup: The pkg-config package gtk+-2.0 version &gt;=2.12.0 is required but the version installed on the system is version 2.10.4 Couldn't figure out the right way to pass configure flags that would get accepted. I hacked the cabal file instead to make progress. Having got that stuff installed, I tried installing criterion, it failed on packedstring. Solution: cabal install packedstring --preference="base&gt;=4" Next it failed on template-haskell wanting an old version that doesn't compile: [6 of 6] Compiling Language.Haskell.TH.Quote ( Language/Haskell/TH/Quote.hs, dist/build/Language/Haskell/TH/Quote.o ) Language/Haskell/TH/Quote.hs:31:12: Not in scope: data constructor `StringConstr' Language/Haskell/TH/Quote.hs:33:12: Not in scope: data constructor `StringConstr' cabal: Error: some packages failed to install: template-haskell-2.3.0.1 failed during the building phase. The exception was: ExitFailure 1 Trying to install ThreadScope also fails: Resolving dependencies... cabal: cannot configure threadscope-0.1.1. It requires glade -any There is no available version of glade that satisfies -any glade and glade-devel packages are installed via yum. There doesn't seem to be a cabal glade package? 
I will forward this on to the gtk2hs folks, thanks!
&gt; Haskell for Maths: Transitive constituent homomorphism As much as I may like the language, sometimes, posts about Haskell make me want to kill myself.
I'm re-writing an aviation GPS application called FlightMaster (that was written in C on PalmOS) to run on Windows and Linux. Next week or so will see a beta-version, and I'm hoping to have a basic release by June. It will be mainly closed source, but I will want to release the OpenGL-based GUI framework I've implemented (which looks like a dog's breakfast for now ;-) Having Haskell fully supported in Eclipse would be excellent, as I'm just using GVim and Cygwin command lines right now.
Hm, I feel a bit like an inefficient reddit-to-email gateway. Here's [Axel Simon's response](http://sourceforge.net/mailarchive/forum.php?thread_name=E1F6198F-43F3-4022-963E-2AB6AD012088%40in.tum.de&amp;forum_name=gtk2hs-devel).
I favor [fclabels](http://hackage.haskell.org/package/fclabels) now, but in the past also had good experience with [data-accessor](http://hackage.haskell.org/package/data-accessor).
I am learning Haskell for the fun of it and because it has a very friendly community. My wish-list of 1 item would be: * Small code block showing how to use a library function along with the documentation of the library function. 
And where can one find this reading list? Google doesn't seem to be helping here.
I had to do a lot of rapid shallow learning to get my early stuff off the ground. What I wanted was a cheap way to wire up a function (String -&gt; String) to a text area, so that the submit button replaced the contents of the text area by whatever the function did to it. I got there in the end. It left me wondering if there was a good way to manage typed web dataflow. I'd start by asking what a (Client s t) might be, rendering an s from the server, delivering a t to the server, and how to combine such things in parallel to describe a page and in series to script an interaction. The challenge is to model the structure of the data and documents, abstracting away from html (or whatever: I quite fancy generating javascript; ok, I want to run Haskell in the browser, but I don't want to make strong assumptions about the browser). I also need to work within some significant limitations. I can and do put cgi programs up on the departmental server. Running my own server would be a much bigger ask (of me, as I'd need to learn a bunch of new stuff, and of the sysadmins, who like to be helpful but need to be careful; ha ha, I'd need a lot more of a clue even to start that conversation). Basically, I want to make smart web pages that talk to a back end programmed in Haskell, preferably maintaining the illusion that it's typed Haskell data going up and down. I expect I'll think more about the API I need as I prepare for October's classes. I'll be trying to mediate a bunch of exercises in digital logic, assembly language programming, and other low-level stuff, all splendidly finitary. I need to make lots of toys (typically testing the students' ability to simulate some computational process, rather than simulating it for them). I don't need a fancy database backend.
a haskell relational algebra library would be a good start, I would like the dbms bit too
&gt; licensing wars (I would be unable to use any library that introduces a GPL or LGPL dependency, for example) I have this problem as well. Haskell seems to essentially defeat the purpose of the LGPL. Maybe with 6.12 and dynamic linking it'll become possible. &gt; So my other 'wish' would be a good set of higher-level tutorial material to introduce me (a.k.a. experienced softeware engineer, clueless mathematician) to some of the more complex topics. There's a definite need for something which goes to the next level after RWH (which I bought twice - once as ebook and once as dead tree ;-) I need something like this as well. I understand RWH well enough, but I'm having a lot harder time with going past it.
Interesting approach. But wouldn't this go beyond the scope of a "Pearl"?
I'd like to see a new version of your WowWiki app :) With: * Landscape viewing * History * Find in page * Remember current page on app close 
It would help if we all agreed to give "Haskell" two different names: one used when you're writing about typical workday stuff, and another when you're doing theoretical work. Then readers could self-select which articles they wanted to read, without any unfortunate brain explosions. I propose we use röck döts for the workday name. That way we can show how hardcore and badass the language can be for workday stuff. Haskell: Commutative zygomorphic histotransification on the n-plane vs. Häskëll: Web server performance -- cranking it up to eleven It's like a pair of eyes. You're looking at Häskëll, and Häskëll's looking at you. 
This is not a bad idea. The problem I see with it is that blog posts can get "lost," and aren't integrated with the library documentation on Hackage, which is where this sort of thing is really needed.
What is it about them that doesn't "do it" for you: the intense "mathi-ness," the of it, the ubiquitousness of dons, or the way they make you feel like you're back in HS? ;) 
&gt; So my other 'wish' would be a good set of higher-level tutorial material to introduce me (a.k.a. experienced software engineer, clueless mathematician) to some of the more complex topics. There's a definite need for something which goes to the next level after RWH (which I bought twice - once as ebook and once as dead tree ;-) I am thinking about starting some kind of "modular online book" along these lines, but I have the same "1 person effort" problem. For mathematics and proofs, I can recommend Bird's [Introduction to Functional Programming in Haskell](http://books.google.de/books?id=ypNQAAAAMAAJ). What are the "more complex topics" that you have in mind?
The obvious solution to this is to include the required libraries with the HP for Windows and OSX. Writing a "simple" native graphics module that works cross platform isn't simple at all.
It took me 2 full days to install gtk2hs on MacOS X. Unfortunately, I forgot how I did it and it's partially broken (some programs segfault more often than they should, like for example threadscope).
Yes, we currently have forall and we can simulate exists with an extra datatype, I know. But the extra datatype is inelegant: you have to put a constructor before every value in your list plus you have an essentially useless datatype lying around. That's why I listed it as nice to have but not essential. It's already implemented in the Utrecht Haskell Compiler, but not yet in GHC, which of course is the one virtually everyone uses.
I appreciated seeing this here. * Documentation: This is the single most important bit of releasing a library to the community. While reading the code is important, most people just want to use the library for what they're doing. Taking an hour long diversion into reading someone else's source, quality aside, is frustrating when you're trying to get something done. It's much worse if the code is of poor quality or you have a tight deadline. * Github: l'm a huge github fan * Advanced Book: I'd buy that book
This is completely unfair, and completely misrenders the purpose of DavidA's wonderful series of essays (and the associated Hackage library). The general topic of the series is contained in the title: "Haskell for Maths" -- not "Maths for Haskell". So it has nothing in common with, say, a monad tutorial. In a word, the post is not about Haskell - none of them are - it is one of a several recent posts about groups, permutations, etc. aimed at *anyone* interested in those topics, and a computational and algorithmic approach to them. Haskell is the language he uses for this purpose, so of course it has potential interest for a Haskeller; thus dons sensibly linked it. 
I use Haskell for fun, and to solve Project Euler problems. I would like to see ghci either go back to using gnu readline, or have haskline have better vi support. I also would like to see a RWH part 2.
I think you meant Haskell: C͈̤̞͇̠͉̭ͬ͂̾̽̏͗o͉ͩ̐ͨͬͨͯ̅m͚̯̄̋̽̎ͣ͆ͮͅm͍̳̲͊ͅũ͖̯̪̼̙̫̮ͥ̂̀̋͊t̯̪̳̜͚̠͖ͤ̉ͫ̔a̹̘̯ͩ͆ͧ͗ͥ̉ͅt͇̼̩̥͔̩͔̍ͪ͋̊ͤͤ̉iͮ͊ͣ͆ͩ̇̚v̼̰̝͉ͭ̉ͮ̐è̱̮͓͓͕͈ ͍̝̥̺̰ͭz̝͚̉ͭ̚yͨ͊ͭͭ̿̎̽ġ͔̲̠̜̻͐̋ͦ͆͛o̗̝̿̽ͫm͓̫͗͆o̺̭̞̪͊̋ͧ̇ͦ̓ͬr͍̈́ͅp̥ͣh̳̫͕̟̱͎̔i̻̼͕̩̘̞̒ͪ̂ͩc͎̼̈̐ͪ͒̾̏ ͙͉h͉̜̭͖̖i̼̺͔̟̼̝̪̋ͥ̎s͊͂̈́̑̃t͇̝̬̂ͪȏ̤̪̦̪̾̚t̲̅̓ͣ͐̔̿̍r̤̼̗̗͙̊͗̆̔a͎̖̠̦ͅns͉̮͉̣̬̎͐i̓̾̈́ͭf̘̯̹̫̭̤̜̂͂i̱c͉̣̩̏ͮa̼͔̞̺̾̓̓̏ͅt͉̠̳̼̙̮͗̄͋ͦ̀̔i͖͑ͯŏ̪ṇ͇̘̞̒ͩ ͬo̬̫͓͎̘͓̣ͨͧͪ̔̒̒n̺̬ͮͮ̅ͣ̄̎̈ ̇͌́̈́̅ͫͯt̜̘͓̗͗ͥḫ͇̋ͮ͛ͮ͆e̹̬̫̊̄͒ ͈̦̗̆͛̉̒n̮̟̦̫͚͕ͅ-͍͖͉̽ͦ̌ͣͫpl̮a͓̪̭͇̣ͤ͗͐̂͒n͍͈͌̊ͩ̓̊ͯẽ̯̙͈̟͎̘͔
I'm using Haskell and its ecosystem to build a [personal finance toolkit](http://hledger.org), where I'm pretty sure it's helping me to deliver more, and more correct, features with lower bugfixing and maintenance costs. It's definitely delivering clarity, execution speed and (relative) ease of cross-platform deployment. I started with Haskell's Parsec, which is a joy; real parsers were too mysterious/expensive for me before this. I've also used Haskell in - building tools for client and community projects, such as a [reliable feed-announcing irc bot](http://hackage.haskell.org/package/rss2irc), and a [command-line program tester](http://hackage.haskell.org/package/shelltestrunner) - [converting the darcs wiki to gitit](http://joyful.com/darcsweb/darcsweb.cgi?r=pandoc;a=headblob;f=/src/Text/Pandoc/Readers/MoinMoin.hs) - throwaway scripts, such as summarising a code tree, cleaning up profiles, extracting blog content from vox, ... - clarifying and communicating more clearly the data types of legacy apps in ruby/php/python - fooling around with [web](http://demo.hledger.org) [apps](http://paste.hledger.org) I've upvoted a bunch of wishlists I agreed with. Here are the top three missing things that would help me Get Things Done: 1. really pervasive and effective documentation aimed at library users and app developers 2. more reliable package dependencies and installation 3. easier, more effective debugging/testing/profiling tools and processes 
[Edit: why epiphanies are important] If I'm honest, there's not so much of a clear road-map after a basic understanding of monads (which I understood just fine once I started to think of a monad as an API with a set of rules, rather than as a bomb factory, spaceship, sack of potatoes or whatever strange analogy Yet Another Monad Tutorial suggested I try to use). I feel like understanding the relationship between functors, monads, monad transformers and arrows would probably help me to create better architectures in Haskell (I can *use* monad transformers, but don't really understand *why* they work, and this bothers me). Probably more advanced, but more useful, would be to see practical worked examples of using the type system to ensure program correctness - I realise that this falls somewhat into the 'proofs and mathematics' area. There are small areas which I haven't really seen covered well e.g. use of 'forall' in type signatures (and why I would want to do such a thing), fixpoints (which I didn't understand from the explanation in The Haskell School of Expression), use of type witnesses to model hierarchies etc. A criticism of RWH for me is that some of the worked examples were fairly lengthy, and sent me into some unnecessary diversions (e.g. the 'Hpodder' example required Curl which doesn't build easily on Windows - I think there were a couple of similar problems elsewhere). Simpler but fully cross-platform examples (or equivalent code where cross-platform is not realistic) would have helped. RHW was a bit Linux-centric in places. In fact, I feel (and this is somewhere where LYAH is well judged) that very complex (admittedly 'real-world') examples sometimes detract from the basic principle which is being demonstrated. I think a good approach would be an explanatory chapter followed by a chapter working through the use of the ideas developed in a practical (but not too large) application. I should add, where the maths is concerned: the main barrier I have found to understanding mathematical explanations is the lack of clear explanation of the terms and symbols used. While I understand that they are an essential shorthand for mathematicians, they also serve to make papers very inaccessible for those who do not 'live' in mathematics (I was an engineering undergrad more than 20 years ago, which is the last time I formally studied Mathematics, so I have forgotten much of the little I ever knew). Spending a couple of paragraphs introducing mathematical notation before it is used would make all the difference to me (and then by all means use the formalisms once properly introduced - this is absolutely the right thing to do). Going back to my comments on how I got to understand monads, I think this is where the formalisms are essential. So-called simplifying analogies can really impede understanding if they do not hold water for all cases (as happens in most monad tutorials), so please *don't* shy away from the necessary explanations I'd also add that I will be very happy to serve as a guinea-pig for anything you write. I think one of the keys to this type of work is getting feedback from members of the target audience (i.e. those who don't know this stuff, but are motivated to learn). Experts sometimes forget that it often takes an epiphany to understand a complex topic...
Oh no, big words!
[Paul Wilmott on Quantitative Finance](http://www.amazon.co.uk/Paul-Wilmott-Quantitative-Finance-2nd/dp/0470018704) [An Introduction to the Mathematics of Financial Derivatives](http://www.amazon.co.uk/Introduction-Mathematics-Financial-Derivatives-Academic/dp/0125153929/ref=pd_sim_b_4) Start with these.
I feel weird posting my own blog posts here, but occasionally I have something i think people might find interesting, or have interesting responses to. so here ya go!
Whoa.
| An IMAP library (either by binding to a c-library or by implementing one in Haskell) I would generalize this to "a complete e-mail operations" library.
&gt; I often feel it's my imperative, OOP background holding me back. I hear this a lot, and I think it's subtly backwards. Haskell is a great imperative language, because we can abstract over imperative actions, and use functions to compute them. So you can turn every boilerplate pattern of control flow or thread communication into a reusable function. And we use OOP techniques too, though not as pervasively -- for example, the standard exceptions library uses typeclasses and existential types to form something very much like an OOP class hierarchy. So it's not that "imperative" or "OOP" are the antithesis of Haskell. I think it's more that people come from languages where these are the *only* ways to solve a problem, whereas the Haskell community sees them as more specialized tools. If your problem is cleanly represented as a sequence of steps, or a hierarchy of subtypes with implementation hiding, you can code it that way. And if it's simply a set of functions applied to some values, you don't have to force it to be something else. 
The Haskell language specification doesn't specify the precise algorithm with which the trig functions are computed for Float and Double. As far as I know, what GHC does is just the sane thing: ask the CPU for the result, using the relevant floating point instruction. You'd expect the same from most language implementations. You could ask Intel, say, how their hardware implementation of the sine function works, but they might not tell you. --- edit: I just checked the 6.12.1 source for the native codegen on x86, and it indeed does generate an fsin instruction. There's a little extra code surrounding trig operations which it generates, because the trig instructions are picky about what range the input value is in, so in some cases, an appropriate multiple of 2pi must be subtracted from the input to the instruction. Other than that, it's pretty straightforward.
&gt; Dependent types make it nearly impossible to have a fully automatic typechecker Do they? They make it impossible to have automatic type *inference*. And you have to be careful if you allow general recursion and partial functions. In that case, you can write a program that makes the compiler diverge, though this is an issue common to LISP macros, C++ templates, Template Haskell, GHC's typeclass extensions, etc. More significantly, you can't have a full type-erasure implementation, since for safety reasons you've got to actually compute type-equality proofs before you use them to justify coercions. Still, I don't think it's fair to say that dependent types make it impossible to do automatic typechecking. Indeed, the automated proof checkers built into tools like Coq are typecheckers for a dependently-typed lambda calculus.
I believe haskell uses the GNU Multiple-Precision Arithmetic library [libgmp](http://gmplib.org/) for all its arithmetic. On x86/x86_64 processors, libgmp most likely uses the hardware floating point units to calculate trignometric functions like sin and cos.
&gt; Haskell is the language he uses for this purpose, so of course it has potential interest for a Haskeller; thus dons sensibly linked it. Say someone implements an efficient IIR filter in C. That wouldn't really make it relevant as a submission on a C reddit, given how most people wouldn't even know what an IIR filter is for. I'm not against posting articles like this sometimes , but I find it a bit annoying how there's often no background, it's bam into the math. Interesting to the mathematician, but not to a regular Haskell programmer, unless you explain what could be useful about it. Compare to, say, the primes library, which is mathematical in nature but a lot more accessible. If anything, it could be interesting to post it on a math group. A generic mathematician is much more likely to find this useful in his work than a generic Haskeller, and might even convert himself ;)
It uses GMP only for arbitrary precision Integer arithmetic, so no trig stuff.
If enough of them caught on, I suppose they could be added into the wikibook or something similar.
As most of the “real” work I have ever (not just in Haskell) done was bugfixing other people's code, I would welcome more debugging features, for example a possibility to stop a program at any given point and print out the cost centre stack, heap profile, etc. (either by a signal, or by some introspection of the RTS using gdb or something).
Be aware that Haskell's classes are not the standard OO classes. They are somewhat similar to OO interfaces, but extremely different in some fundamental ways. Haskell's has "instances of classes" that in this rough analogy correspond to classes implementing interfaces. Float and Double are the two relevant built-in instances of Floating.
We just let the CPU do what it is going to do. If you really want to see a hand-implemented Haskell version of trigonometry there is always David Lester's "CReal" module for arbitrary precision computable reals. http://darcs.augustsson.net/Darcs/CReal/CRealI.hs
Oh yes, I think I did -- obfuscated zygomorphic histotransifications for the win!
* I thought there is landscape viewing, doesn't rotating the screen work? or is it only on my debug device? * rest should be done in a few days, update receive in a week after that 
I apologize `fapmonad`, my remark was intemperate. I think, though, that even if your basic point of view was right, it would be sensible for `dons` and co. to link that particular post, since it is the first in a long time, so the news is: "DavidA is back, for those interested" Still, I think it's not 'bam the math'. On the contrary, if you start with the first posts, it's all rather teacherly (`BMeph` may be latently dissing this aspect below?) -- as it sort of has to be since he's got to give detailed accounts of why this or that concept can be represented in Haskell notation thusly. The thing is, it's not a blog in the usual sense, since each post presupposes *all* the others, read in sequence. Maybe its the blog form he is using that is leading to the misunderstanding. Things will look quite different to you, I think, if you start with the first substantive post: http://haskellformaths.blogspot.com/2009/06/simple-graphs-with-mathcombinatoricsgra.html
Thanks. This is indeed palatable when read from the start. Also: &gt; I apologize `fapmonad`, my remark was intemperate. That made me smile. Only on the internets :)
Thanks for your reply! I have two remarks; in particular, I'm wondering whether the medium "book" is actually effective at addressing the issue. &gt; I feel that very complex (admittedly 'real-world') examples sometimes detract from the basic principle which is being demonstrated. Yes, I agree; examples are best stripped of most complications that do not contribute to the main point. However, this will automatically make them less "real world", though this is not necessarily an issue. &gt; Experts sometimes forget that it often takes an epiphany to understand a complex topic... Yep! Though, as Brent Yorgey [put it so brilliantly][1], the epiphany is not necessarily a product of simply *reading* a text or book, but of *practicing* the material. For instance, you can learn a lot simply by implementing different monads (state, writer, reader, maybe, list, ...) on a blank piece of paper *from memory*. In other words, what I'm saying is that getting your hands dirty is an essential part of the learning process. Virtually every Haskell expert ultimately learned it this way. It's difficult to suspend these years of practice for the purpose of teaching, but more importantly, there is also a fundamental limitation to the medium "book", namely you can't "force" the reader to accumulate this practice. In that light, I never quite understood the benefit of RWH compared to say, the Haskell School of Expression. Both contain a wealth of material and you learn equally much if you study the exercises diligently. Maybe RWH takes more of a "cookie-cutter" approach, and sounds more relevant to day-to-day problems, thus reducing the need to practice exercises and providing more motivation to do those that remain? In short, I'm wondering whether it's really a book that's needed, or whether some other form is more effective. [edit:] I'd like to find out! :-) [1]:http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
the content/behaviour of `actionURL` seems a bit peculiar; I have my doubts that the arrow law `first f &gt;&gt;&gt; arr (id *** g) = arr (id *** g) &gt;&gt;&gt; first f` holds. Otherwise this is an interesting article. 
I think this law would hold, since `id *** g` is pure, so the `actionUrl` field would be `Nothing`.
Ah, concerning fixpoints, could you tell me which page of the Haskell SOE you are thinking of? Section 9.3, exercise 9.9? The Haskell wikibook has a chapter on [Fix and Recursion](http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion).
Do you have a function called 'main' (of type IO ()) in filename.hs? That's the entry point for your whole program, and it seems GHC can't find it.
Oh right.
Yes, I do. I've declared it main::IO() main = do putStrLn "TextHere" printAll (runsim args) where runsim is of returns [[Float]] and printAll is of type [[Float]] -&gt; IO().
I think I've got it: your main function should also be in a module called 'Main'. See the second paragraph of [The Haskell Report on Modules](http://www.haskell.org/onlinereport/modules.html). It worked for me at least, on Windows though, so YMMV.
That does seem to have worked. Thank you very much for your help. 
I use Haskell mostly as an escape. I find Haskell provides the right power-to-weight ratio between having complicated things expressible at the type level, and yet being able to use type inference in all but the most pathological scenarios. This has a nice Sapir-Whorf effect; I can think thoughts in Haskell that are very difficult or impossible for me to articulate in another language. There isn't another language that I can use to express my thoughts as densely as Haskell, with anything approaching the chance that the thoughts so expressed are correct. I use Haskell to explore * compiler and language designs * category theory * software transactional memory * alternative ways to tackle parallelism * parallel/incremental parsing techniques mostly by trying to see how fast something can be made by applying a bit more theory. What would help me the most or which I would like to see? I think some notion of package mounting support in GHC/cabal would be ideal, because the current hierarchical namespace set is only really a stopgap, witness the profusion of classes in 'Data' for instance. Beyond that, most of dons' list applies.
When 6.12.1 HP for Windows goes up, will there be a 64-bit version?
As an aside, if you add the option "--make" it should work itself out as well. 
Actually, it doesn't! I'm learning lots of new and practical stuff in the course of this discussion, so put module Test main = putStrLn "Hello, world" into Test.hs, did a 'ghc --make' and all I ended up with was a .hi and .o file, not an executable in sight. I wonder if there is a way to tell GHC that the main function lives in a module other than Main?
There is. RTFM.
OK, then I'm overlooking something in the GHC docs. It says (in section 4.4.1 of the users guide): &gt; It will then attempt to compile each module which is out of date, and finally, if there is a Main module, the program will also be linked into an executable. If I enter 'ghc -o Test.exe --make Test.hs' I get the following error message: &gt; Warning: output was redirected with -o, but no output will be &gt; generated because there is no Main module. What am I missing?
You need to pass the flag `-main-is` to specify which module contains the `main` function you want. Without that flag, GHC assumes `-main-is Main`.
`main` is not a function.
taylor series my friend
A Main module, apparently. Your module is called "Test", not "Main". Try with winterkoninkje's suggestion.
Even if then else and case of are functions. Just with special syntax. Main is a function which does not take any arguments, so you _may_ call it a value instead.
That seems to do the trick (after removing the old Test.o file). Thanks, I learned something today!
Always use -fforce-recomp when trying to get rid of linking problems: The recompilation checker is not clever enough to notice changes in compiler flags.
That's an odd way of looking at it, seeing as function refers specifically to the type constructor (-&gt;) which produces a *value* specifically of the type (-&gt;) a b
but... every morphism and value is an object in some category, and every object in some category is actually nothing but an identity function. But you're right, it's odd nonsense.
Fantastic idea. Unfortunately, as I've already mailed to the author, it doesn't work out of the box on Windows yet, since the cairo package depends on pkg-config.
I'm not using Haskell at all! Well, not at the moment. I can't use it at work, but I do use it for all my home programming these days. I just haven't been doing any of that in recent months. Instead my spare time has been spent re-investigating the game of Tenjiku Shogi (see http://colina.demon.co.uk:5001/ - when it's up - I'm going to have to shut it down for a week in a few hours time - it's powered by gitit BTW). And I'm currently pondering writing an internet server (in Haskell of course) for the game. Probably I will generalise the software (if i get round to writing it) to two-player turn-based games generally.
The instance code is teasingly close to fitting standard pattens, and hence perhaps disappearing (replaced by type definitions). For instance, the `(.)` method uses `(.)` on the Kleisli arrow and `mplus` on the other two components. Similarly, the `first` method uses `first` on the Kleisli arrow. Over &amp; over in my own libraries, when I've teased out these patterns, I've been able to progressively shrink my code. Often until it disappears altogether. A beautiful moment. 
You misunderstand. Since it is a binding to C libs, it needs the C headers etc installed. The current gtk2hs monolithic build system needs the Gtk+ C SDK on windows. That SDK has pkg-config and all the C headers etc. Switching to a modular cabal build system does not change that fact. This is not as hard as it seems, it's just one zip file bundle. The sourceforge download page has the zip bundles you need, both for building gtk2hs from source and for binary deployments. There are also scripts in the darcs repo (tools/win32) for preparing new version of these bundles.
Ah, ok. I was hoping this was an effort to reduce the steps required to install gtk2hs on any platform to "cabal install gtk2hs".
why not put the whole gtk into cbits/ ?
Excellent idea!
I tried installing this on Snow Leopard with GHC 6.12.1 installed. Installing glib-0.10.5.tar.gz fails with this error: setup: The pkg-config package glib-2.0 is required but it could not be found. I tried port install glib2, but that fails with this error: gconvert.c:55:2: error: #error GNU libiconv not in use but included iconv.h is from libiconv This might be because I renamed the libiconv files to get GHC 6.12 to install. I renamed them back to no avail.
I'm using Haskell for play, and for applications/scripts to manage my personal data. I don't yet have the opportunity to use it for work. Two things I'd love to see: * I'm interested in writing android apps and would love to be able to use haskell. This would need decent ARM cross-compilation and some interfaces to link haskell native code to the dalvik VM and access android APIs * Java VM support for haskell. If lambdaVM were integrated and in usable form it would greatly increase the chance I could use it for work as well as play 
If you mean sources, that'd be a bit much. Gtk+ and its various dependencies are pretty large (I'm guessing around 50Mb of compressed tarballs). There are many versions. It consists of dozens of components using complex autotools build systems. As for binaries, well that's kind of what they do. There are zip files of all the stuff needed to build on windows. In addition there are pre-built installers of gtk2hs and gtk combined.
For platforms with the Gtk+ development files it would be just that. That means an extra step on OS X and Windows.
Is the Snow Leopard 6.12 compiled with --enable-shared? Can I use to build shared libraries?
For Linux it makes sense to have gtk2hs use the distro repos gtk library.
In category theory land, you're right. In Haskell land, perhaps.. not.
About that "CT fucks you up" thing... Yes. And no. The trick is to realize that what your mind tells you and how it's steered is not a bijection, at all. The brain is also by no way total (it's inconsistent but complete. Think about Russels paradox and you'll see that you have quite good heuristics to detect -- at least obviously -- inconsistent terms) and, at least in my case, still confuses thinking about some problem and being meta-programmed. Just give it the rest it needs and insist on strictly separating those levels of abstraction when done thinking. Oh, and lisp does the same, btw. Anything general enough to trick you starting to think solely in terms of it. While yes, the mind actually forms a monad (I won't go into detail here), it's still best to think about society in terms of hug density.
Please avoid further CT and rest in bed for a while. We hope you recover soon :(
Visit the commercial users of Haskell programming site: http://cufp.org Or the Haskell in Industry page: http://haskell.org/haskellwiki/Haskell_in_industry Galois, for example, hires "juniors" with strong CS background, as well as PhDs with extensive Haskell skills. Generally, the Haskell job world is pretty high end still, but that's changing as the employment base broadens.
You could always do a startup. Haskell is very high on the [blub continuum](http://www.paulgraham.com/avg.html). (Higher than Lisp, I contend.)
Hi dons, does Galois have internships for CS students ? 
just like I said, strong CS backgrounds, so you probably have to be someone who goes to a lot of programming contests and does research in CS to get a Haskell job... any other way to do it ? any way to get Haskell job without being a genius(whatever that means) ?
If you're in it for the money, stop now and learn C#. If you're in it for intellectual stimulation, on the other hand: smart and self-motivated people are good candidates for technical jobs regardless of particular choice of technology, and showing that your interest in programming goes beyond what's necessary to obtain employment helps you show that you're smart and self-motivated.
cut me some slack, learning Haskell properly would require me reading about 3 books and solving a lot of problems and if I waste that time with no gain(and there is no gain if I get no job) then it's basically a waste of time(and indirectly a waste of money from my side). I'm not in it for the money per se, I'm in it for getting an enjoyable job(which writing Haskell would be in my oppinion). besides, I don't like C#.. at all, I don't like Java. I barely like C++ for the lambda stuff in STL , functors and stuff like that.
doing a startup is a very big risk for me, I'm just one guy,and I don't have the resources and honestly applying for a grant at ycombinator or whatever is not an option for me, I honestly don't know anyone else that writes Haskell professionally, actually I don't know anyone doing so in all of my country, and there is no company over here that writes Haskell professionaly. so I'm completely disconnected from any Haskell community
If you think that would be a waste of time if learning Haskell didn't directly lead to you getting a different job than you would have otherwise, then I reiterate my comment.
I'm sure it won't lead me to a different job. How can learning a language lead you to a different job ?! can you explain , maybe I don't see your point and if you put more detail I will understand. UPDATE: I was interested in getting a job with Haskell , not a *different* job.
I read your original post as implying that you were interested in learning more about Haskell if doing so would improve your job prospects. Did I misunderstand it?
I have never heard of anyone learning Haskell for the money
Let me reformulate: I want my time investment in Haskell be directly proportional to my chances of getting a job with Haskell(and by time I mean maybe a couple of months, up to half of year of learning it, considering I'm not new to programming). Am I realistic or idealistic ? I don't think I'm asking too much, I am interested in a practical result out of learning Haskell, what do you think ?
Yes, we have a small number of internships. Send a resume, and outline what kind of work you're interested in doing.
After reading the various comments you have posted here, there isn't going to be a position for you. You appear uneager, unwilling to apply yourself, and focus on ways you can fail while asking how things can be made easier for you. Were I in a position to hire, I would not want you for any development position, let alone one that involves Haskell. You may want to reconsider your career choice and/or attitude.
I think that's unrealistic, not realistic or idealistic. As dons mentioned, places like Galois hire people who weren't necessarily Haskell committee members, but there are a zillion reasons why any particular company might choose not to hire any particular person (that is, reasons independent of merit or skill set) and your pool of companies is going to be pretty small in the first place if you want to find a job programming in Haskell. So I don't see learning Haskell as a good time investment *if* you see it solely as a vocational training process. If you want to think harder and get better at expressing your ideas in code, then learning Haskell will probably be a delight for you. If you just want to be a better job candidate, there are many other things you could study instead. tl;dr: I find this line of questions a little like "I want to get a job as a musician; should I learn how to play the cello?" Sure, a few people who learn to play the cello find jobs as musicians, but very few, and it's challenging enough that the only good reason to do it is because your desire to learn is stronger than your desire to use your time in ways that pay the rent.
&gt; I am interested in a practical result out of learning Haskell, what do you think ? Learning Haskell will make you a better programmer in any language, because it will expose you to new ways of thinking about things -- real substantial differences, not a different coat of syntax on top of the same old concepts. It will also make you bitter about programming in all these "mainstream" languages that are stuck in 1960's concepts, with disastrous results for real-world maintainability -- copy-pasted code due to weak abstraction, race conditions due to poor threading models and pervasive mutable data, etc. It will make you despair at the fact that some of the most fundamental concepts in computer science, ideas that were explored *literally before anyone had built a computer* are today considered advanced techniques for wizards only, and often forbidden for fear that your co-workers won't understand them. &gt; I barely like C++ for the lambda stuff in STL , functors and stuff like that. Oh, C++. A C++ "functor" is what any other language calls a "function". And the functional programming support in STL is some kind of joke, an elaborate parody of FP designed to sour people on the whole idea. I realized this the first time I had to use the Class Template Declared In Anonymous Namespace Copies Free Variable To Become List Membership Filtering Predicate Functor Pattern, or as we'd call it in Haskell, `filter (&lt;x)`.
valhalla_coder does have a bit of a point. the intellectual work required to learn and become proficient with the language is not trivial. there are plenty of other languages that have a smaller semantic gap and a higher reward of payment. personally I'd suggest that if you had that much time to dedicate and wanted to be rewarded in some financial sense, you would be better off learning enough math to become an actuary or something. it's a different semantic model than what software people are used to and it pays pretty decently.
as far as I can tell, Galois hires PhD candidates from top schools, not necessarily random dudes that like to code in Haskell.
No, that's not so.
so you're telling me I should learn Haskell for fun and learn a different thing to pay the rent right ?
I don't think you're disagreeing with me. It's true that the intellectual work required to learn Haskell is not trivial. That's why the only good reason to do so is because you intrinsically enjoy that work. If you're asking whether it's remunerative, then that's not true for you.
What are you talking about ? I just came here to see what the job market for Haskell is and if I can get a job with it or not. I'm practical and very pragmatic, what's wrong with that ?
here's a tip: learning how to write proofs is harder and more rewarding than learning Haskell. but no business software manager would dream of making proofs a requirement for hiring (although they will always ask that you be a critical thinker or whatever) because bugs aren't big on the list, marketing is. learn how to solve discrete math problems on paper and maybe even publish a thing or two, then pick up Haskell on the side to solve some of those problems in software. (I hope that doesn't sound condescending, since you may already be down that path. but that's just the way I see it)
If you enjoy expanding your mind, then yes, by all means learn Haskell for fun. Thinking that it might *ever* pay the rent is a sure fun-killer.
first of all , thanks for taking my side. &gt; there are plenty of other languages that have a smaller semantic gap and a higher reward of payment. I was actually asking if it can pay *at all* , not higher. &gt; you would be better off learning enough math to become an actuary or something the thought of money itself disgusts me, but you need it nonetheless.
&gt; If you're asking whether it's remunerative of course I'm asking whether it's remunerative, this is the whole point of this thread , please check the title of the thread again, it says in big letters **Haskell Employment**
really ? counter-examples please, or do you know for a fact that what you're saying is true ?
Well at least 4 out of the top 12 people on their company list has publications or a degree beyond bachelors. The few others that do have a profile seem to have well enough experience on their own. Perhaps being well educated is not a requirement but it's probably what they're looking for more than language experience.
I'm not trying to dis Galois, but they have a lot more than 12 employees and not all have graduate degrees or graduate degree work.
Then you don't intrinsically enjoy that work. QED.
I'm not going to call anyone a "random dude that likes to code in Haskell" unless we're having a beer. I'll just point to what I said in reply to robinhoode.
I think the OP's position is more like "I want to get a job as a musician, preferably as a cellist. Should becoming a cellist be my goal, or should I just learn an instrument that is in demand?"
&gt; Thinking that it might ever pay the rent is a sure fun-killer. Why?
ah ok, so you have a counterexample but wouldn't want to divulge it, that's ok
so basically if you're looking for a job with Haskell the only place you can work is Galois ? it seems the only serious company hiring Haskell people
please, read the title of the thread again, and get it together, the title is **Haskell Employment** , not **Haskell Un-employment and only for fun** !
there are probably more.. but you might never know. i bet a lot of companies use it internally without telling their bosses. you're best bet is doing some tech talks at a local user group selling the language in some way and hoping the hiring managers come crawling out of the wood work looking for you.
It would require a lot of dedication and effort; certainly more than "up to half a year" as the OP mentioned.
if you already know C#, Java, etc, I'd stick with that for the time being, at least until the recession clears. if Java is your day job you won't be doing a lot of really hard thinking and can probably reserve your grey matter for other, more interesting problems on the side. if you have the right kind of discipline to keep your skills sharp while you're busy with boring work, you'll probably have a better chance at that Haskell job you're searching for, whatever the economic climate.
It can pay. It absolutely can. On that, I'd be amazed if there was any debate. The problem is, getting that pay will require substantial work. You'd need to find a development house that works in Haskell (of which I imagine there are few), has some projects in Haskell (maybe a few more), or fire off your own successful startup using Haskell yourself. All of these things will require a lot of experience. For the record, I work in Java and Python in my dayjob; during my education I also used Lisp, Ruby, Tcl/Tk, C and C#. All of these I picked up with relevant ease, due to the time available. I'm learning Haskell in my spare time now, and in the 6 months I've been doing so I've learnt nowhere near enough to even consider calling myself competent. Admittedly, I work 9-5 and spend my evenings doing other things, so it's not been a huge priority... but the point being it's not an easy language to learn, and because of the relatively few people you could market your skills to, you'd need to be damn sure you were well skilled to get a job in it. If you're looking to learn Haskell purely because you want remuneration for it, you're looking at the wrong language. Like everyone else has said, yes you can get employed, but the work required vastly outweighs the benefits. Learn something more mainstream with some functional nods - Python, Ruby - and try and find a job in those. Learn Haskell in your spare time to improve your abilities with those languages (my Python has got considerably better since I started; my Java has got considerably worse :p), and look for a job in it later down the line. If you're looking for experience to put on your resume, work on open source Haskell projects, or make a large Haskell library you maintain in your spare time.
&gt; although they will always ask that you be a critical thinker or whatever what exactly is a critical thinker ( but I digress.. ) ? what do they mean by that ? &gt; learn how to solve discrete math problems on paper and maybe even publish a thing or two sorry I'm not a researcher. I like math a lot, but in order to research and publish papers someone needs to fund you so you can do that, otherwise you end up with crappy stuff that people have thought about already and are already written in books(which you haven't read because you didn't have enough time because **again** you didn't have funding). &gt; then pick up Haskell on the side to solve some of those problems in software. I'm already doing that with some language (not Haskell). But nobody cares about you solving math problems in whatever language. When you go to some interview you need to tell that guy stuff that will convince him you can perform well on his job not on implementing **"Galois groups of arbitrary polynomials over finite fields"** or whatever
you're joking right ? I'm not [on this list](http://www.haskell.org/haskellwiki/User_groups)
And I find that question just as ghastly.
Let me put it like this. People with PhDs or who have worked on PhDs are typically researchers. Software companies tend to have a certain percentage of work that's appropriate for researchers (which is often zero) and a certain percentage of work that would bore a researcher's brains out (which is almost always nonzero). The latter category of work needs to get done, and hiring researchers to do it will end in tears.
In order to research and publish papers and not write crappy stuff that other people have thought of, you need to talk to other researchers (unless you're the rare lone genius). Everything else is helpful but optional. I really like the following quotation from Seymour Papert: "Many more people have not completely given up on learning but are still severely hampered by entrenched negative beliefs about their capacities. Deficiency becomes identity: 'I can't learn French, I don't have an ear for languages;' 'I could never be a a businessman, I don't have a head for figures;' 'I can't get the hang of parallel skiing, I never was coordinated.' These beliefs are often repeated ritualistically, like superstitions. And, like superstitions, they create a world of taboos; in this case, taboos on learning."
ok that's reasonable, I think you're almost the same as me(except I'm 6 months behind you since I haven't seriously started learning Haskell yet). I have some OSS on my resume but I don't think someone really looks at the OSS experience, and you need to make heavy contributions in order for them to notice you in the commit history I would guess... which is normal.
that was known to me before starting this thread, but re-reading it is re-assuring :) thanks
Actually, I'm not ready yet , my university doesn't allow me to go on internship until I have completed certain amount of credits, although, when the time comes I will for sure apply to Galois :).
We are hiring, but that comment alone makes me not want to hire you.
&gt; what exactly is a critical thinker ( but I digress.. ) ? what do they mean by that ? Usually that you can solve problems without having to rely on a book of equations or other cookbook solutions. &gt; sorry I'm not a researcher. I like math a lot, but in order to research and publish papers someone needs to fund you I could be talking out of my ass (since I've never actually done research) but from what I understand by browsing physicsforums.com and /r/math, you don't really need a lot of money to do math research, unlike physics where experiments cost $$$. you just need to be connected and have time / experience enough to know the solution. compsci research isn't far behind although lack of the right data or computing power could be the problem, but often isn't what makes good research good &gt; When you go to some interview you need to tell that guy stuff that will convince him you can perform well on his job not on implementing "Galois groups of arbitrary polynomials over finite fields" or whatever well then that's your answer right there.. it doesn't matter if you learn Haskell or not, it all depends on how you market (or in less dirty terms, present) yourself to your potential employer. if you really think Haskell is the right tool for the job you'll be able to show him why. if the language excites you but you merely enjoy it for it's own sake then you'll have a harder time convincing him or her and as for the last bit, I've seen abstract algebra show up more and more as I try to reach beyond my standard undergraduate math texts. last I remember, I was reading up on the Risch algorithm, which can determine if a mathematical expression has an anti-derivative or not. apparently you need to find the Galois group of certain polynomials in order to find their anti-derivative. if you had this tucked under your hat, you might be able to write the software to solve some tricky engineering problems that required this.
I'm not looking for employment in Haskell though. I enjoy programming in general; I enjoy learning Haskell because it's making me better, and it's exposing me to some of the core concepts of Computer Science (category theory, for instance) that my SE degree didn't look into very deeply. I have no intention to exploit that for employment in any immediate future available to me; I just want to learn it because it interests me. As to OSS on your resume; yes, you really should be a major contributor to count that.
it doesn't have to be a haskell group.. maybe a general fp group or the local linux group.
&gt; but from what I understand by browsing physicsforums.com and /r/math comeon , that's not research, it's just a bunch of guys excited about some stuff they've learned at school or university of whatever.
&gt; you need to talk to other researchers (unless you're the rare lone genius). Everything else is helpful but optional. yes, and researchers are mostly studying abroad on grants or on research projects with their peers. they also need to reserve their time for their own projects. anyone in their right mind would collaborate if they had similar interests, but since their interests are very specific in some field that is hard to penetrate without serious time spent on studying(which again requires funding so that you can spend that much time just studying) it's very unlikely a non-researcher gets attention from one. but let this fact aside. what you're basically suggesting is that if I want to get a Haskell job I need to be a researcher and publish a couple of papers. am I getting this right ?
what exactly upset you in my comment ? was it that I'm trying to collect oppinions and get an overall feel for what the opportunities are before engaging in consuming time and resources for one year(or however it will take me to learn Haskell) so that when I finish I'll be left with no marketable skills from the whole experience ? I'm pretty serious about my question, I'm also serious about the results of the time I spend on something and the outcome, I'm pretty sure I won't do something if I get no outcome(this is perfectly logical). If this is what you don't like then you're probably looking for dreamers who don't know what they want and don't know how to perceive reality and your ideal candidates would probably have blind faith in learning something regardless of the fact that apparently only PhDs get hired with it. So please, keep your vacant position.
I think the analogy is completely broken. Let's stick to programming analogies. Musicians have enough of their own particularities that are none of our(actually my) business.
so there are no Haskell jobs because of recession. that would make sense :)
[Disclaimer: I do not work predominantly in Haskell] In my day job I'm a software manager in a role which requires primarily high-performance embedded software development in C and/or C++, depending on project. I have been developing software for nearly 30 years, and, like any professional, I have worked hard to keep myself ahead of the curve, learning new languages, programming paradigms and development environments as simply 'part of the job'. Haskell is, far and away, the most difficult thing I've done. It has made me reconsider everything about the way I construct software, and has expanded my mind. While I write a little Haskell in my work, these are mainly 'scripting' tasks which could be done in Perl or Python (although I do them faster and better in Haskell...). The three years I've spent working with Haskell (in very limited amounts of spare time) could never be justified on a purely financial basis... And yet I look at the gains: my mind is expanded, I'm a better and more productive software engineer, I've received support and encouragement from what I firmly believe to be the most diverse and welcoming programming community in the World. IOW, my life is intellectually and socially enriched and I'm a better engineer because of it - and being a better engineer *definitely* pays off financially! Every language (C#, C++, assembler, Python, Lisp, Haskell) has its wrinkles, but in the end, if you love solving problems, you live with the language - it's simply that some are better tools than others - and Haskell is an *awesome* tool. When I hire someone, what I'm looking for most is an open and quick mind, the flexibility to see the interest in many different tasks and a love of solving problems for their own sake. While my team members spend 90% or more of their time working in C or C++, I would absolutely choose a candidate with Haskell (or Ocaml, or Lisp) or some serious open source involvement over one who has none of these things [obviously they may not choose me if their main motivation is to work in their language of choice most of the time - I can only let them do so maybe 10% of the time]. The problem is that you are looking for a direct payback, and that's rarely the case in life (certainly in my experience). As an aside, your proposal that you will spend about 6 months learning whatever you choose is far from the mark. You could not become a competent C developer in 6 months (assuming no prior relevant knowledge), and C is about the simplest language there is. As far as I can see, if your main objective is seeing a direct financial payback for the time you put into learning a language, the three best options are Java, C# and PHP. If you want to make your self more employable by being a better software engineer, you should definitely learn Haskell, even if most of your time ends up being spent doing something else.
That was the one - I think that part of the problem (and occasionally an issue with SoE) is that it's obviously meant to accompany an undergraduate level lecture course, and in this case fixpoints are thrown in as an aside - the kind of thing I'd have gone to ask the lecturer about in my undergrad days.
You get attention from a researcher by showing them that you have something to contribute. The bar is higher if you aren't someone's grad student, but it really is possible to collaborate as an independent researcher. Yes, there's a bit of a chicken-and-egg problem as to how you get to the point where you can make that kind of contribution, and that's where intrinsic motivation is absolutely crucial.
In my experience, nothing beats a tutorial approach with a knowledgeable lecturer/teacher and a well thought out set of 'homework' exercises. Not for nothing has this been the approach of institutions of higher learning for hundreds (if not thousands) of years. In my situation, however, I'm very unlikely to have such an opportunity, and I find that working carefully through a good book can be a reasonable substitute. The difficulty comes where, for whatever reason, a roadblock is reached (e.g. my example of fixpoints in SoE - the explanation given just didn't click with me). Perhaps there is an opportunity for an online 'Haskell university' to cover this sort of material. The only downside I can see is that, at least for me, Haskell is a hobby, and the cost and regular time commitment required by such an approach might be difficult to justify. In the end, however, I'd still note that most advanced courses require textbooks, and something which brings together some of the more advanced ideas discussed in this thread would be a very useful introduction - at least to me. My ideal 'outcome' from such a book would be that I would feel equipped to start to explore these higher level subjects for myself in more detail. tl;dr; A book is not the perfect medium, but it is one which is highly accessible to many people, especially those for whom a postgraduate level course is not really an option (for reasons of location, time, age, other commitments or whatever)
I think there's more similarity than you think. Some people have read your comments as asking what you can *get* out of Haskell, whereas some of us view functional programming as art: something we do for intellectual and emotional satisfaction. When art coincides with making a living, as it does for some lucky people, that's a wonderful coincidence, but to ask how it can pay the bills is to deny its intrinsic value, and that's why in this thread you've managed to piss off some people who might otherwise have been interested in hiring you someday.
I happen to know a researcher in algebra. From what I've noticed he knows a hell of a lot more than I know. He has read tons and tons of stuff and solved tons of problems. This is what he does. As a programmer writes code or reads some programming books , a researcher solves problems, reads books and maybe write articles. In the extremely improbable case that I would work on a problem with him, he knows extremely much more than I do so I would just be lagging him behind. So becoming a researcher to get a Haskell job is not possible.
Maybe you can get employment as an Internet troll.
FP is an art, but reality is cruel and rent is not very artistic. My conclusion is that Haskell is a niche language, where employers are interested in hiring mainly PhDs so basically it's not a choice for me. 
Maybe you won't comment on my thread if you don't have anything to say about what I asked, thanks.
You are a tremendous douchebag.
Isn't Ruby the language to learn if trolling is your core competency?
ok
"Lisp is still #1 for key algorithmic techniques such as recursion and condescension."
Haskell might not be your cup of tea. The Haskell motto is "Avoid success at all costs.” .
many of the people that frequent those forums are grad students or phd/post-doc researchers.. the actual repercussions of research are brought up all the time. I wouldn't be on them otherwise :P
This is great work! I'd love to know what primitive(s) is/are missing that would allow the use of the under-the-covers mutation tricks that the clojure data structures use in Haskell data structures. It would A) be good and worthwhile research and B) give us some awesome options for improving speed.
I'm also curious about an immutable hash built over an intMap for e.g., Strings, as opposed to either a trie or a standard map.
&gt; I happen to know a researcher in algebra. From what I've noticed he knows a hell of a lot more than I know. &gt; In the extremely improbable case that I would work on a problem with him, he knows extremely much more than I do so I would just be lagging him behind. The best way to remedy this problem is to stop moping about how you lack his knowledge and begin trying to catch up to his level in some way. If you do pursue Haskell as your default language, you're going to need a large mathematical vocabulary to even know how to utilize the various features it provides, let alone to make headway in becoming proficient with it. Secondly, it makes it more difficult for others in the Haskell community to accept of you if you have an attitude like this. Even if it's not true, just vocalizing the fact that you're "not smart enough" to catch up with the various category and type theory papers that prominent FP people are talking about makes you seem uncool. Its like the Ruby people who said they didn't like whytheluckystiff.. You just get dirty looks. As it turns out, many who believe they aren't smart enough are usually just selling themselves short. So maybe you should start there. &gt; So becoming a researcher to get a Haskell job is not possible. Personally, I think it's the best way.
from what I knew research papers are on [arXiv](http://arxiv.org/) or [CiteSeerX](http://citeseerx.ist.psu.edu/) or [journal of integer sequences](http://www.cs.uwaterloo.ca/journals/JIS/) or [journal of combinatorics](http://www.combinatorics.org/) , [journal of combinatorial number theory](http://www.integers-ejcnt.org/pvols.html) and many other places I didn't know physicsforums.org was a place where research is done or presented in the form of articles.
&gt; just vocalizing the fact that you're "not smart enough" I didn't say I'm not smart enough. It's a question of time here. And I think it's safe to say that spending time without getting results that interest someone other than myself leads to a waste of money. IOW, Doing nothing is a waste of money. &gt;&gt; So becoming a researcher to get a Haskell job is not possible. &gt; Personally, I think it's the best way. :) that would seriously limit Haskell's user base
it's .com.. and it's mostly a forum to discuss physics, but many of the mature accounts are held by phds or grad students.. even a few professors on there helping students with home work. occasionally real research and it's funding gets brought up, as well as math research, and that was the general vibe I got from those discussions. as far as academic papers, their not exactly a high-ranking peer-review organization, but they do have a forum dedicated to it: http://www.physicsforums.com/forumdisplay.php?f=146 One thread in particular that might be sort of referencing here is this one: [who wants to be a mathematician?](http://www.physicsforums.com/showthread.php?t=122924) I'm not 100% sure but there was a few mentions about physics research being mostly experiments and their analysis while math research is mostly just juggling symbols on pencil and paper and seeing what you get.. 
There are jobs out there. They are uncommon and there is quite a bit of competition from skilled and enthusiastic people. Unless you have a lot of experience with another functional language, reading a few books will not make you skilled. You also don't seem very enthusiastic. At this time, pursuing a career in Haskell would not be a pragmatic decision for you.
It definitely can pay - if you're in academia, you can get a paycheck while coding haskell fairly easily.
Pursuing a career in academia is the easiest way to get a job writing haskell code.
&gt; UPDATE: The conclusion is that Haskell is a very niche language so if your goal is getting a job, do not learn Haskell. Wow, you had to ask Reddit to figure this out?
Most applicants for a Haskell job will have learned the language as a pure intellectual exercise, and therefore are more intelligent and motivated than the average career-only programmer. This has nothing to do with the actual properties of Haskell as a language; Paul Graham wrote [the same thing](http://www.paulgraham.com/pypar.html) about Python when it was a niche language many years ago. It does mean that you'll be at a serious disadvantage with respect to the rest of the applicant pool, competing for the relatively small number of Haskell jobs.
There are plenty of things that I could do that I would enjoy if I had the time. But I don't plan my life around doing what I enjoy maximally in the sort term.
Is this true? With imperative programmers just about everywhere and all the tools that make C# like a child's play, I would expect haskell employment to pay much higher.
You're right -- some Haskell jobs pay extremely well. valhalla_coder just ruined their chances of getting a specific job in that category for life with one of the comments they made in this thread. However, people who learn Haskell *just* to try to get such a job are about as likely to achieve their goal as are people who take intro physics in college just because they want a Nobel Prize. People who learn Haskell for intrinsic reasons tend to be interesting and smart and that's one of the reasons why they get jobs -- but learning Haskell doesn't make you interesting or smart.
Well, it is unfortunate that you would find the nature of reality ghastly.
Cynicism isn't smart or sophisticated.
&gt; but to ask how it can pay the bills is to deny its intrinsic value, and that's why in this thread you've managed to piss off some people who might otherwise have been interested in hiring you someday. This seems incredibly immature.
Most people in modern societies are expected to contribute something of use to that society order to remain members. 
So?
It's just the nature of reality.
So it is natural to ask around to see what the people around you desire when planning for your future.
There are lots of ways to make a living. You can deliver mail, grow food, teach kids, take care of sick people, etc. All of these are things that almost everyone desires; all would be good, stable career choices. Another way to make a living is to do something you think is really, really fun, like making art, or playing a sport, or writing Haskell code. That's perfectly good, too, if you can make it work. But valhalla_coder doesn't seem to think Haskell is any fun, or else why would they have started this conversation? And so I have to wonder why they would want to make a living off it when there are so many other ways to make a living that other people are much more likely to desire.
Well, based on the amount of downvotes that valhalla_coder has received, I suppose your point of view is the dominant one within this community. This is surprising to me, and makes me wonder if I should reevaluate my own point of view. Is this simply a view of anything done for money is base?
It's not obvious to me what primitives one would introduce to let Haskell take advantage of these tricks. Clojure has a "transient" primitive, but this only makes sense because the underlying language Java is mutable-by-default, so that's just disabling a few runtime guards and ensuring thread coherency. If GHC is keeping track of frozenness/thawedness on all boxed values, there's no way around it; you have to change the flag everywhere. This suggests there should be a way to hierarchically specify this, but once again I'm not a GHC dev and wouldn't know how it would work under the hood.
That's not difficult: there are many simple hash functions that map strings into integers, which you can then use to stuff into an IntMap. And, of course, you can use a trie to store string keys too (although I don't recall off hand what usage characteristics make this a win).
abuiles: Are you an American student? That sounds like a pretty ridiculous requirement.
&gt; Is this simply a view of anything done for money is base? Not at all. I get paid to write Haskell code and I don't find it base just because I'm getting paid (I do find it base because of who pays me, but that's a different matter). I, and I think a few other commenters, am expressing a combination of bafflement that Haskell would occur to somebody thinking, "I need a job! ...but I have no idea what... ...what should I do?", and concern for valhalla_coder's welfare in that going through the effort they propose to go through with no pleasure is likely to lead to neither wealth nor happiness. (And in any case, if you *do* want a highly paid job programming in Haskell, it's unwise to flame one of the few people who might be able to provide that, as valhalla-coder did, unless you're being clever about it, which valhalla-coder wasn't. I am not one of those few people, just to avoid any confusion.)
&gt; valhalla_coder doesn't seem to think Haskell is any fun I think this is a baseless assumption. Most people plan their future careers taking into account some degree of minimizing failure. Is this a reason to look down upon them?
Have you read their comments?
Maybe I haven't read them with sufficient comprehension, or maybe I am taking away a completely different tone from them.
Right -- my question was about performance characteristics and benchmarks, not if it was possible.
Well, in the IntMap case, the only overhead you'd have was the string hashing function. It might be fun to compare that with http://hackage.haskell.org/package/bytestring-trie
I'm not sure where you're getting "highly paid" from. I think valhalla_coder was specifically addressing entry-level positions. Personally, I would probably work for half of what I work for now (which isn't that impressive) if I could work with Haskell.
how is it that after so many back and forth replies you are still missing my point ? also, the guy just told me he would not hire me based on my reply, I would think that's a bit weird since my original question is legitimate.
Learn Ruby, its fun to hack with and you can get a great job that pays extremely well doing web development.
I'm not upset by your comment, I was just giving you my opinion. The people we are looking for would have more of the attitude "cool, I'll have the opportunity to read 3 books and learn more". You seem to think knowledge is a necessary evil to get a job, and that's just not the kind of people we're looking for. It's not at all true that you need a PhD to get a Haskell job. I helped find and hire a person for a Haskell job who had a BSc (I think, possibly MSc) in Computer Science. He had mostly learned Haskell on his own and then set up some web site using Haskell. But he didn't learn Haskell because he was looking for a job; he got a job because he knew and liked Haskell.
I'd like to see Haskell library documentation look more like [this](http://cpan.uwinnipeg.ca/htdocs/Closure-Loop/Closure/Loop.html) , to pick an example at random. Integrating examples into the documentation makes it much easier to learn to use libraries.
again, please keep your vacant position, you were not paying attention to my question(I don't think I want to have you as my boss), I was asking about an entry level junior position and what are the possibilities of getting one, I do not waste 1 year or more of effort for no reason. good luck with your company
having physics people review math papers is a bit stretched don't you think ? also, you can't take a forum seriously for a place where research-level mathematics is discussed, that would be ludicrous. again, having to be a researcher to get a Haskell job is silly but apparently true.
You could of course, juts use a mutableByteArray# internally with unsafePerformIO to read/write pretending to be pure, but that moves a lot of the consistency guarantees onto you.
&gt; You'd need to find a development house that works in Haskell (of which I imagine there are few), has some projects in Haskell (maybe a few more), or fire off your own successful startup using Haskell yourself. dev houses that use Haskell are non-existent from what I've seen , or are the kind of companies that get washed out after a recession
It worked for me. I took a Haskell programming job and got a 30% pay raise over my previous programming job that already paid pretty well. UPDATE: Of course, I should emphasize that I did not originally learn Haskell for the money. I learned it for the intellectual stimulation like catamorphism mentions above. It just so happens that in general, society tends to reward those who pursue excellence.
The Cabal library necessarily already includes a cabal format parser, no? Just use that.
You seem to be assuming that augustss objected to only the content of your comments rather than the tone as well.
I think augustss understood your question just fine. If you don't think that (as he said) "knowledge is a necessary evil to get a job", why would you say (as you said in this comment) that learning Haskell would be a "waste" and would have "no reason" if it didn't lead directly to a job?
because the topic of this thread is **Haskell Employment** and not **Haskell Un-Employment**
So let me answer your questions: &gt; What exactly are the Haskell employment opportunities for an entry level junior programmer ? There are not many entry level jobs, and if you don't know any Haskell you'll have little or no chance of getting a Haskell job. If you are good at something else you might get hired to do that, and then end up doing Haskell "by accident". For instance, if you have a PhD in stochastic maths, please apply. &gt; Can one get a job with this language ? Yes, as many people have attested to. &gt; Or is it just for building spaceships on your private time ? No. &gt; P.S. I've already read this , there are maybe 20 companies there, is that all there is ? No. &gt; How exactly do you get a job with Haskell if there are no junior positions nowhere ? Sometimes there are junior positions and then you might get a job by being the best candidate in terms of Haskell knowledge and by having a good attitude.
And we are trying to tell you that to have a chance at **Haskell Employment** you need to already know a fair bit of Haskell and enjoy learning more.
Like augustss said, the answer is that Haskell Employment does exist, but only for people who think learning Haskell would be a fun thing that you're curious enough to want to go ahead and do without asking reddit for permission. Does that answer your question? If not, why not?
yes, pretty much settles it
&gt; Also I would love to be able to write Bird-style combination of code and markdown. Well, there's always Pandoc &amp; Gitit.
&gt; You're expected to be a PhD to write code in Haskell. Troll much? This has been debunked repeatedly in the comments...
We're getting ready to release a site for gamers that's written completely in haskell. I can't really give out too many more details about the site specifically other than haskell has definitely proven to be a complete dream to work with, especially with regards to concurrency. Once the inevitable fires have died down after release, I'm going to write a post up on planet.haskell.org about our experiences. I can't really think of anything that would have made things easier. If I didn't have it, I'm confident that I would have said 'flymake mode for haskell'. That has definitely been a boon to our productivity. 
The trick is to get a perfect hash function or to have an efficient way to resolve conflicts. And anything you can layer on top of IntMap you could also layer onto bytestring-trie (which is effectively IntegerMap, modulo GMP representations and word-size differences). I'd welcome the competition. I'd love it if someone came up with a *good* benchmark suite for me ;)
Paywall.
Related: http://www-ps.informatik.uni-kiel.de/~sebf/haskell/dp-overview.pdf
https://acrobat.com/#d=f*cFyHkdNuCwqCmFVJId5w Let me know if it's against the ACM policy.
darcs' UI is simply unparalleled in the open-source world. Its authors should definitely be recognized for that achievement.
I still would miss git-gui and gitk.
I love both git and darcs, but this entire series seems to be made up of. "Darcs has this". "Git does things differently". "Wah I like darcs."
Well - I think it is a bit one sided. It has a valid points (I already like darcs more ;) ) but it has only 'why darcs is better'.
He should have run this by a git expert for review, as his git commands have some extra unnecessary fluff that could be removed for clarity. 
I think that's a great idea!
For me, I'd add "magit" to that list, which is a fabulous git mode for Emacs; arguably, the best Emacs mode available for any SCM. 
Agreed. I'm not a git expert, but I think this is where a "git porcelain" could help, to provide a simpler (Darcs-like?) interface over the rather complex git command-set.
Yes, though I took Roundy's caution about Iolaus' alpha-state seriously, and haven't studied it in detail. I was hesitant to state outright that "git porcelains can address the git UI problem" because I haven't had any direct experience with them.
I thought this one on the "dry run" entry was precious: &gt; Uhm, it told you exactly what you need to know: b233f62..1eb8888 
Or, you could use a decent-but-imperfect hash, and use `IntMap [a]` to store collisions in lists?
I think that it is interesting that we need git experts. Something about the tool prevents wide expertise.
Thanks for your thoughts! I did not mean to replace the book by a tutorial with its main drawback of unavailability; rather, I'm wondering whether the internet could allow for a third form that combines the advantages of both. &gt; A book is not the perfect medium, but it is one which is highly accessible to many people, especially those for whom a postgraduate level course is not really an option (for reasons of location, time, age, other commitments or whatever) Yes, absolutely; I intend to preserve the essential "self-service" nature of books ("whenever I want, wherever I want"). It's just that since the internet offers many more possibilities than printed paper, I'm wondering whether a form that 'transcends' the book could be more effective. Many things come to mind, like for example audio, video, interactive exercises (like the [SPOJ](http://www.spoj.pl/) programming problem archive), wikis and so on; many of them not necessarily a good idea for the purpose of learning. I don't expect any such form to match the time-honed tutorial approach, but maybe it can come a bit closer to the effectiveness of a tutorial than ordinary books currently can. For one, I at least aim at a 'non-linear' book, were subjects are presented as small, self-contained chapters, linked by an explicit dependency graph ("read this before you try to read that"). This way, the reader is free to choose his own topics of interest, not unsimilar to an encyclopedia. Furthermore, as I understand it, 'homework' exercises are an essential part of effective learning, that's why I would like to see them incorporated somehow. They can alleviate roadblocks that are otherwise unsurmountable; few explanations just 'click' like that. This appears to be one of the main difficulty with learning monads, as Brent Yorgey has put so eloquently. If the "book" (or whatever it becomes) were to offer automatically graded exercises (clever multiple choice tests, quickcheck on 'student' programs,...), would you find them useful and work on them?
Even speaking as a Haskell partisan, I find darcs unusably clunky and slow and prefer git and hg in this space.
Exactly what you need, but none of what you want, eh?
Worked for me, on Ubuntu!
I think it's a bug if you need to consult an expert to get basic things done. 
What's the best UI for git?
I use a darcs-like git porcelain, and it's clear by definition that it can't be a good mapping. darcs doesn' t have local branches which are practically required with git, and git doesn't have the cherry-picking logic which makes darcs indispensable. 
Its not to "get things done", it's to "get things done with the simplest possible commands". EDIT: btw, I personally think git is great, but it's simplicity is hidden behind a huge/complex CLI.
speaking from the ignorance and being totally fanatic, surely this is a great post... I'm not going to check every post but simply looking at: http://mark.stosberg.com/blog/2008/11/darcs-vs-git-annoyances-pushing-specific-patches.html I see he doesn't know about tags or interactive staging. *(btw I love how he goes into fanboy-rage when he's told he's wrong as in the comments here: [http://mark.stosberg.com/blog/2009/04/darcs-vs-git-annoyances-getting-to-know-you.html](http://mark.stosberg.com/blog/2009/04/darcs-vs-git-annoyances-getting-to-know-you.html))* this was a different person, as noted by mithrandi. this is just a blog to say "hey I'm an raging nerd" what's next? vim vs emacs?
I'm always interested to see what people mean when they say this. Is it fetching repositories over a network in particular (darcs get)? Darcs pull/push? Daily operations like darcs record? Is this interacting with others' repos or your own? Which repos? Have recent versions of Darcs been improving for you? Sorry for the barrage of questions! If you could provide some details, that'd be great. Helps us track our progress in the on-going performance work.
Yeah, what's needed is a guy as smart as good (at crafting CLIs) as the Darcs guys, and who'd be able to express Git's ways and tools into a UI worth using.
&gt; Almost every SCM has a better UI than darcs. What drugs are you on and are you available over the counter?
&gt; I see he doesn't know about tags or interactive staging. How do tags and interactive staging help pushing specific revisions out of band after they've been commited, exactly? In git, you'd have to break apart the whole branch (using pretty damn low-level history-edition tools) in order to split the changesets out of the other branche(s) to be able to push them and only them to a remote. And you better not have shared them with anyone. Tags do *not* help. And interactive staging... what's the relevance?
Yes, magit is cool. There's a few darcs modes for emacs, but at least one of them doesn't work with recent versions of darcs - something to do with haskeline, I think.
git follows the GNU philosophy I suppose - lots of commands with a large number of options - but most options are ones that you will never need. And there are a fair few commands that you won't ever use, too, probably.
Well, as I said "or have an efficient way to resolve conflicts". It's the same old story with hashtables, which also typically scan a linear list when the hash conflicts. Another interesting solution, which I've not seen anywhere, would be to use a family of hashing functions a la Bloom filters, thus using a hashtable(n) to resolve conflicts in the hashtable(n-1). Of course the memory overhead would kill you if you had more than a couple layers, which is why most hashtables degenerate to singly linked lists.
the tags are for this: &gt; First, I don’t see a way to use the human readable patch name. A separate step is required to review ‘git log’ to find the SHA1 hash, which must be copy/pasted, because there’s no way you remember it like a human-friendly word or phrase like darcs allows. and the interactive staging is to avoid editing the patch, you make changes and interactively decide what to commit and then push. edit: you may also use rebase if you want to alter the order of the commits.
It doesn't tell you what you don't ask for... It's simple enough to run git log b233f62..1eb8888 on it afterwards if that's what you want, but the default behavior is to do exactly what you told it to, push but don't actually change anything.
I remember it feeling clunky too, mostly because it was always dropping to interactive and prompting me for things I think. Most of the time when using git, I type the command and it just runs, unless I tell it I want interactive, or it opens vi for commit messages, etc.
tldr; I haven't learned git yet so I don't get it and can't use it properly, therefore darcs is better. Pick just about any useful development technology and you'll get someone who feels this way about it.
&gt; the tags are for this: Oh, so you have to tag every single commit. Great. &gt; and the interactive staging is to avoid editing the patch, you make changes and interactively decide what to commit It doesn't help. We're talking pushing post-commit here, otherwise you could just create a separate branch and commit in *that*. &gt; edit: you may also use rebase if you want to alter the order of the commits. I already covered that in the comment to which you replied.
&gt; &gt; the tags are for this: &gt; &gt; Oh, so you have to tag every single commit. Great. you tag things you consider relevant, from which are certainly not every single commit ever. &gt; &gt; and the interactive staging is to avoid editing the patch, you make changes and interactively decide what to commit &gt; &gt; It doesn't help. We're talking pushing post-commit here, otherwise you could just create a separate branch and commit in that. yes, that's an actual useful usage, not like the example (which can also be accomplished). &gt; &gt; edit: you may also use rebase if you want to alter the order of the commits. &gt; &gt; I already covered that in the comment to which you replied. no you don't, rebase wasn't even mentioned and if you change a shared history you're doing it wrong, be it on darcs or whatever. in any case my point is not to extend the pointless comparision, I couldn't care less about the tools you use but same as the author of the blog I don't know enough about both to even consider comparing them. a post talking about what he actually knows would been much better.
&gt; or have an efficient way to resolve conflicts Ah, I missed that. I've heard of the family-of-hashes approach too, but don't think I've ever come across one in practice.
That's really helpful, thanks. If you're willing to try an experiment for us, please put the following into ~/.darcs/defaults and use Darcs for a while: pull all record all Is it a better experience for you? (I doubt Darcs will ever switch to non-interactive by default, but it'd be good to see if this really affects the perception of performance...) **EDIT** Yikes! I had initially suggested 'all ALL' but luckily mithrandi caught the dangerous aspect of my recommendation. Whoops! :-)
My specific beefs (and I haven't used darcs in awhile, and never very heavily, maybe you've fixed some of them): * darcs assumes you have a VT-100/ANSI terminal, if I try to run any of the interactive stuff (record, etc) within emacs shell it usually sends me to escape character city. Actually, I just tried this with the most recent version and it seems to be fine now. * daily darcs operations (get, pull, push, record) are much slower than git/hg counterparts, and deluge you with questions ("Shall I make you some toast? [yNwsuqejxkce?] Buttered or unbuttered? [bU] What kind of bread would you like? [wHbrf?] How brown should the toast be? [lbwp?]"). "Darcs get" has historically been so slow that the GHC guys provide tarballs of the repository rather than forcing you to wait days for it to finish. * git/hg have better history viewers available, and even on the command line git ships with "git log --graph". Git also has tons more available tooling (gitweb, github, gitosis, etc), but that's hardly your fault. * I like being able to refer to specific patches by unique ID, rather than a regexp search. Getting a diffstat of a specific patch is pretty awkward. I mean, I like darcs well enough, and it's certainly gotten faster lately, but git and hg are more-or-less equivalent products that are substantially speedier.
I can second what masterpi said. I am a Darcs fan now, but I at first found it clunky in part due to the interactive interface, which I now love. The other reason, though, was just because it was Darcs 1.
&gt; you tag things you consider relevant, from which are certainly not every single commit ever. Well the point is that in darcs you don't have to do that, because you can just pull any patch (and its dependencies) via its name. &gt; yes, that's an actual useful usage, not like the example The example is an actual usage, actually. &gt; no you don't, rebase wasn't even mentioned Rebase is history rewriting. I covered history rewriting. Thus rebase. &gt; and if you change a shared history you're doing it wrong, be it on darcs or whatever. But that's very much the thing, in darcs you can cherrypick already recorded patches without changing history and without blowing up repos compatibility. In changesets-based systems, you can't.
Thanks! I particularly find it encouraging that you find the recent speed improvements to be noticeable. &gt; daily darcs operations (get, pull, push, record) are much slower than git/hg counterparts, and deluge you with questions ("Shall I make you some toast? [yNwsuqejxkce?] Buttered or unbuttered? [bU] What kind of bread would you like? [wHbrf?] How brown should the toast be? [lbwp?]"). Interactivity is one of things that I think a lot of Darcs fans like. I think there are good bits and bad bits to this. The good part about Darcs gives a consistent set of choices across a lot of different commands (shall I X this patch?). This means that if you know how to use darcs record, you pretty much know how to use darcs revert, pull, push, obliterate, etc. As for the bad part, I hope we can fine tune this in time; small changes in this department can make a big difference. Confirmation prompts could be pared down. One that makes me particularly grumpy is that we ask the user if they still want to record a patch if they say yes to editing the long patch comment but they don't actually make any changes. Perhaps another prompt to eliminate is the one that asks for the patch name and later if you want edit the long patch comment (we could just dump the user straight into the text editor). That's just my POV, though... I could be very wrong! Less controversial is that we should introduce a small tweak to our interactive prompting is print the help text as: Shall I make you some toast? [yN...] (? for more) The idea here being to present the key choices but provide an indicator (the ...) that there are more options ahead for power users. &gt; Darcs get" has historically been so slow that the GHC guys provide tarballs of the repository rather than forcing you to wait days for it to finish. Yes. Darcs get is the first impression people get about Darcs performance and it's something we need to address. I'd like to give an idea about the progress we're making. We've finally gotten our support for hashed repositories fast enough to be used by the GHC team. This means that if you can now darcs get --lazy http://darcs.haskell.org/ghc without going through the tarball hoop. Without any caching, this takes 7 minutes (6 seconds if fetching a second time due to caching). It's still unacceptable but it's progress. Future work for early 2011 (I hope) is to introduce some optimisations that will make the darcs get operation faster (eg. producing "snapshots" of the pristine cache at the last tagged state so that we need only fetch the one snapshot and some small files on top of it) a smart server which I think will bring some dramatic improvements to the darcs get case. &gt; I like being able to refer to specific patches by unique ID, rather than a regexp search. Getting a diffstat of a specific patch is pretty awkward. You want --match 'hash XXX' (see darcs help patterns for details). Right now the hash matcher requires an exact match on the hash string, but it should be a fairly trivial change to make it accept a prefix of the hash. We're planning something of the sort anyway because we'd like to deliver a much more readable version of darcs annotate which would use these hashes to identify patches. I'd also like for these hashes to be more discoverable in the future, maybe as part of darcs changes output (although the danger here would be people mistaking them for versions)
&gt; btw I love how he goes into fanboy-rage when he's told he's wrong as in the comments here: http://mark.stosberg.com/blog/2009/04/darcs-vs-git-annoyances-getting-to-know-you.html I don't see a reply from Mark in the comments there at all. What, exactly, are you referring to?
I've been tweaking darcsum mode, it's working well for me with current darcs. http://joyful.com/darcsweb/darcsweb.cgi?r=darcsum
I enjoyed this post. As a longtime darcs user switching to git (which I've been using for over a year now), I find that the git cultural attitude seems to be, "If you don't instantly understand how our conceptual model works without needing good documentation or a UI that fosters learning, you're wrong, stupid, misguided, and should quit computer science right now and consider an exciting career in multilevel sales." The attitude comes through explicitly through mailing list posts, semi-explicitly through almost all (direct and third-party) documentation for git I've been able to find, and implicitly through the design of git's UI. You can see this even in the comments on this very post. The git people sneer at anyone who has the temerity to admit they find the software confusing (the problem must be with *you*); the darcs people say "we see that you had a bad experience; how can we make it better for you?" Finally, I've watched people with Ph.Ds in computer science struggle for hours with both darcs and git, but the difference was that with darcs, the problem turned out to be due to a bug, whereas with git, the problem was there by design.
&gt; &gt; you tag things you consider relevant, from which are certainly not every single commit ever. &gt; &gt; Well the point is that in darcs you don't have to do that, because you can just pull any patch (and its dependencies) via its name. as I've said, you can but you use the hash. what git lacks is automatic tagging but it's not necessary. just out of curiosity, where does darcs gets the names from? &gt; &gt; yes, that's an actual useful usage, not like the example &gt; &gt; The example is an actual usage, actually. no it's not, it's something you can do but not something you will in normal circumstances (being abnormal only examples on ranting blogs). &gt; &gt; no you don't, rebase wasn't even mentioned &gt; &gt; Rebase is history rewriting. I covered history rewriting. Thus rebase. no you don't, rebase can be used in many different ways it does not necessarily rewrites other's history. but again, we're discussing based on a random weird example from a person who doesn't have much idea, I challenge you to give me a real example of the need for this feature. &gt; &gt; and if you change a shared history you're doing it wrong, be it on darcs or whatever. &gt; &gt; But that's very much the thing, in darcs you can cherrypick already recorded patches without changing history and without blowing up repos compatibility. In changesets-based systems, you can't. you can create new tiemlines with changesets from everywhere else, as I've said on the previous item rewriting history isn't strictly necessary.
Note that this suggestion is a little dangerous; for example, "darcs unpull --all" will leave you with an empty repository. it would probably be better to specify all only for certain commands. EDIT: It actually currently only unpulls back to the last clean tag; but either way, that's probably not what you want if you run "darcs unpull".
oh true my bad it wasn't him, I assumed he was the author replying.
&gt;I see he doesn't know about tags or interactive staging. Yes, he is stupid because he doesn't already know something he hasn't learned yet.
I use [tdl](http://www.rpcurnow.force9.co.uk/tdl/) to manage this stuff, but hsgtd seems really more expressive with tags.
Really? Whenever I work with darcs I feel like I need a darcs expert. It's all about what you're used to. You're used to darcs, and you know other darcs users, so you feel comfortable there. I'm used to git, and I know other git users, so I'm comfortable there.
It'd be nice if 'darcs changes' piped its output through $PAGER by default, like 'git log' does.
&gt; just out of curiosity, where does darcs gets the names from? From magical ponies covered in fairy dust. No, oh actually, I meant commit messages.
Darcs is good, but Bzr's UI is at least as good while Git's is actively user hateful. 
Here (macbook, darcs 2.4, residential broadband) "time darcs get --no-cache --lazy http://darcs.haskell.org/ghc" reports real 2m14.721s.
well d'oh! if you're going to write not only an article but an entire series of posts to compare two technologies you better **know** them don't you think?
so you put them on every commit :) I wonder what the other guy was so surprised about with tags then...
git workflow: git commit -m "Munged some crap" git tag "crap-munged-march-15-2010" git push --tags git commit -m "Hacked up some kludges" git tag "hacked-kludges-march-17-2010" git push --tags [repeat *ad infinitum*] darcs workflow: darcs record -a -m "Munged some crap" darcs push -a darcs record -a -m "Hacked up some kludges" darcs push -a [repeat *ad infinitum*] So git gives you the exact same effect with three commands, instead of two, per changeset. Or am I missing something here?
Do you think you need to learn a technology completely before writing about what it's like to learn that technology?
yes that's it, then you can use the tags in place of the hashes for every other operation. you can complain about git not automatically tagging for you but it's not as the author of the blog claims that "there’s no way you remember it like a human-friendly word or phrase like darcs allows" it's just an extra step and even that could be put into a script to call both for you right? so my point is that while darcs may or may not be vastly superior to any other dvcs known to man, this person isn't qualified to tell me; it would been better for him to write an article saying "hey guys, darcs allows me to reference commits by their commit message" and let git, mercurial, bazaar and any other user benefit from it instead of pointlessly and mistakenly difamate every other's work.
he's not writing about what it's like to learn git or darcs, he's writing about how in his mind git sucks because it doesn't work as darcs and he doesn't even care to find out that it does.
Is your desire not to pointlessly defame others' work why you began your original comment in this thread by calling Mark Stosberg "ignorant and totally fanatic"? Why should I have to remember an extra step or write a script to do both commands together when I have the option of using a program that does it for me? I thought computers were supposed to do work so people don't have to.
hi git user here, I know nothing about darcs so I won't compare them (I think the author of the post doesn't know about git and shouldn't be comparing either) but besides that I agree with you that git's logic is confusing. I think the problem is that in order to be productive with git you need to understand how it works -not because you need to know that in order to use it- you can be told specific commands and be able to use it but when you understand even roughly how it works things start to make sense so you can think your way out of situations. the [progit book](http://progit.org/) does a good job explaining that, it really helped me to get around.
I've called him that in the context of this discussion because that's what he demonstrates by his own claims, I won't debate which of the two systems is better because I don't know both well enough to compare. in any case you can say that darcs is better for your particular usage because with it you type two commands while on git you type three but that's way different than claiming that git has no way to do it, that's ignorance.
I can tell you that you've misunderstood Mr. Stosberg's point (which, IMO, you have), but that doesn't change your subjective reaction to his writing, which is that you found it ignorant and fanatic. Similarly, you, as a git expert, could tell Mr. Stosberg that he is stupid because he found it difficult how to do something in git, but that doesn't change his subjective experience trying to name changesets in git: he experienced it as being difficult. He is the only person qualified to comment on what goes on inside his own head. The difference is that software writers have an incentive to care how their users experience their software, even when those users may sound ignorant or fanatic: it's better to have ignorant or fanatic users than none at all. Bloggers, though, don't generally change how they write based on one person thinking they're stupid.
Thanks for the link to the book; I didn't know about it. There is a UI design principle that says that a well-designed user interface doesn't need documentation. I think I agree with that; I didn't have to read a book to learn how to use darcs. I could get started right away, though of course I needed to look at the manual occasionally. The great thing about software is that it's so plastic: we *can* design it so that it can teach us how to use it while we're using it, so why shouldn't we? Software should change to fit how people work; to me, git screams "change yourself in order to fit how our software works." 
Heh, for sure. It's good to have the vote of confidence for hg, too. So far I've felt like if I talk my group into switching from git to anything else (darcs isn't an option because I've been bitten by too many bugs involving too much code or too many developers), it's just going to be even worse. (I was one of the guilty ones who advocated for git in the first place; that was before I knew better.) And that remark also reminded me of how much I miss Perforce... it made sense and I actually can't *ever* remember it sending me into conflict hell, even in a 10- to 20-person group.
I think the main problems are: * git reset does a *completely* different thing when given filenames (take out of index) or just revisions (set current branch to point somewhere) * The staging area complicates a *lot* of the git UI for little benefit. If you want a UI to aggregate a bunch of patches for a commit, it should not interact with *each and every* command in git. * git checkout does a *completely* different thing when given filenames (overwrite files from revision) or a branch (set current branch to a new branch) * git reset, checkout and clean all irreversibly delete uncommited work and non-interactively. The first 2 commands do so when their purpose does not even make it necessary (Could back up in a side revision or special stash). * git pull and git push are not symmetric. Both pull and push do sensible things, it's just the names that are not sensible. * git rebase and friends do not have facilities to warn you about others who still refer to the old revisions, and they do not merge nicely when you screw up. * One of the most common operations I have to perform is convert my branches to track remote branches. This has no command in git, and I have to use obscure configuration commands, or delete/recreate the branch. * git's initial state (lack of ANY revision) makes a bunch of commands not work, which is confusing immediately after "git init". This is silly. "git init" should make an empty initial revision. 
This is tricky because sometimes you want it, sometimes you do not. When I'm doing a query that gives me half a screenful of results I do not want a pager; I want the results to stay there so I can refer to them in subsequent commands. Of course when the results are pages and pages then using a pager makes sense. The difficulty is doing the right thing by default and not confusing everyone with inconsistent behaviour.
They seem to allow full access to the [digital edition](http://mags.acm.org/communications/201004/?pg=76)
On most terminals, less -FX behaves exactly like this. For example, I've set LESS="-RSFX -x4" in my .profile.
I successfully installed this but on my system (ibm x40 running arch linux) the backspace key does not work as expected in emacs mode (it registers as C-h, but does nothing). I can mimic the backspace funcionality with C-? but I don't really want to have to do that, and trying to bind C-h to what I thought would be backspace (docs are nearly non-existent) did not work. If I switch to vim emulation mode it works, but I'm not about to switch to vim shortcuts just to use Yi. Any advice? (tried IRC, no one was there).
Cool, this should have that data leak bug fixed for System.Timeout (actually one of the dependencies).
Who did the buttons? I'm sure the creator could do way better than my quick-and-dirty [ad for ghc that's running on Stack Overflow][1]. [1]: http://meta.stackoverflow.com/questions/31913/open-source-advertising-sidebar-1h-2010/38029#38029
&gt; I want the results to stay there so I can refer to them in subsequent commands. Git sets $LESS to 'FRSX', so it works that way by default. 
Is CLDouble planned for 6.12.2? Lack of it breaks a lot of things (c2hs to begin with) while presence (even broken) does not seems to be a lot of problem.
I made a mistake assuming it was the author and corrected my initial statement based on it, the original point still remains valid. also I don't consider git to be best than anything, that's you assuming/trolling :)
I know it might violate the anti-success principal, but I for one would enjoy it.
my point is that he doesn't know well enough, the rest is up to you. also why bother sending several comments and deleting them? are you afraid that tohers may see what you're saying?
you can see the same on his posts
&gt; git doesn't have the cherry-picking logic which makes darcs indispensable git has cherry-pick but maybe it's a different thing in darcs, is it? on git you do `git cherry-pick &lt;commit&gt;` and it'll apply that commit's changeset on your current branch, what is on darcs?
that person is Linus Torvalds and yes, he made git simply because he didn't liked any of the alternatives, it isn't surprising that it looks like that. so I'm agreeing with you on this.
:-) for the postcard. Glad to see our limited edition Darcs thank-you notes are starting to arrive (we sent 8 of them). I wonder if me being in the UK (or on a Mac) have anything to do with the discrepancy...
I appreciate the feedback. I'd encourage you to file a ticket on http://bugs.darcs.net, but before you do so, please have a look at this history of [darcs output and pagers](http://bugs.darcs.net/msg9030). There's also [issue875](http://bugs.darcs.net/issue875), which asks for darcs changes -v output to go to the pager. For what it's worth, I personally am part of the anti-pager backlash (bias alert!). Things were better in the old days when Darcs sent nothing to the pager :-P unless you explicitly asked it to, or used a pipe. Actually, I probably could be persuaded that we actually only just need to do it right and then it won't be so annoying. Right now, the way we've introduced this change that sends some output to pager and some now just makes it feel really [random and unpolished](http://bugs.darcs.net/issue1660).
Haskell Platform on Windows was a godsend; It's so painless now to get a decent Haskell set-up with emacs, haskell-mode and haskell-package. Just click through two installers and add the (load "haskell-mode/haskell-site-file") line to your .emacs. Done and away you go!
I always much preferred the term value-oriented programming for FP.
I've come to strongly agree with the paper that principled composition is the single most important thing a language can offer. So, I can't really agree with "value-oriented programming" because it doesn't point any more strongly at that emphasis. Perhaps we should cut to the chase and start calling it composition-oriented programming. It also solve the "functional programming"-as-name problem of "OK, immutable variables, closures, strong type system, so why am I wearing this hair shirt again?" Instead of the emphasis being "Hey, wear this hair shirt and you can have the following!", it's "Hey, we offer you this, but we have found you need to wear this to get it." What you metaphorically open with matters and FP has a long track record of people talking about the what for a _very long time_ before eventually wandering around to the why after 97% of the audience has left. Well, to be fair I can say that about programming in general, but still, getting away from it is a good idea.
Yay, funroll-loops for us too! :D
That's good, but I'm not sure what it has to do with the GSoC...
Oh, not much. Just pointing out that anything done by GSoC students that lowers the barrier to getting shit done would be much desired. That debugger suggestion is a fine example
Composability was exactly what got me into FP. So yea, I would agree with you whole-heartedly. Composition-oriented programming it is. Now lets pick a logo...
I propose [this](http://haskell.org/sitewiki/images/a/a8/Haskell-logo-60.png). :)
&gt; git reset, checkout and clean all irreversibly delete uncommited work and non-interactively. The first 2 commands do so when their purpose does not even make it necessary (Could back up in a side revision or special stash). The key problem i see people have using git is they resist committing changes. Commit early, commit often. With git a commit is not a permanent thing until you share it publicly. Git makes patch editing a breeze so you don't have to be too concerned about making perfect patches; you can easily go back and clean them up when you're finished. (long term, having clean patches make everything much easier) If you do this, you now have "git reflog" which can be used to immediately find, inspect and restore the previous state of HEAD or branches. Working this way, reset and checkout are completely harmless and incredibly handy. You'll also find that "git stash" provides no extra value and makes it possible to loose work since you have no hashes and no reflog to go with it. 
You can see [part 1](http://www.animal-machine.com/blog/2010/03/taking-a-look-at-lambdahack-a-haskell-roguelike-part-1/) and [part 2](http://www.animal-machine.com/blog/2010/04/taking-a-look-at-lambdahack-%E2%80%93-a-haskell-roguelike-%E2%80%93-part-2/) of my exploration of LambdaHack. I'm still a newbie when it comes to Haskell and, while I mapped some control flow out, I didn't try to explain the syntax too much.
Ooo, very nice! Looks strangely familiar though.
I'm really looking forward to hackage 2.0
How about this: (.)
I'm probably going to ask a stupid question and I'm prepared for the well deserved wave of downvotes, but.... Why would it be a bad idea ?
[single page version](http://projects.tmorris.net/public/what-does-fp-mean/artifacts/0.3/html/index.html)
 [Conal's Beautiful Differentiation](http://conal.net/blog/posts/beautiful-differentiation/)
As someone who's still sending out resumes and getting nil, I'm so fucking jealous of you right now.
Sure, but if I commit before each git reset --hard, I'm going to either have a mess, or get really cumbersome.
That might not be exactly what he's looking for. Beautiful differentiation isn't a symbolic math system.
It could probably just popup the [Try Haskell](http://tryhaskell.org/) prompt, so it wouldn't be terribly difficult. 
I'm guessing you'll be wanting books on numerical computing... I just ordered Applied Numerical Linear Algebra, for other purposes. Maybe there's a similar book on Calculus?
Summation is a really interesting one, because it's so close to fold. foldr (+) 0 [1,2,3] what's great about this? it's a gateway to algebra. foldr (++) "" ["a","b","c"] this wordnumbers series was really eye opening for me. http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers1/ 
* [Libraries at Haskell.org](http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics) is a general list * ERA is a library for arbitrary precision reals. Try: cabal install numbers, import Data.Number.CReal and showCReal 400 (pi + sin 1). * [Exact numerical integration by Conal Elliott](http://conal.net/blog/posts/exact-numeric-integration/) - how to use denotational semantics to compute integrals to arbitrary precision. * [Functional Pearl on Power Series](http://www.cs.princeton.edu/courses/archive/fall05/cos318/precepts/pearl.ps) - how to use streams as power series. * sigfpe's blog: [Taylor Series for Types](http://blog.sigfpe.com/2006/06/taylor-series-for-types.html), [Small Combinatorial Library](http://blog.sigfpe.com/2007/11/small-combinatorial-library.html), [Formal Power Series](http://blog.sigfpe.com/2005/07/formal-power-series-and-haskell.html), [Practical Synthetic Differential Geometry](http://blog.sigfpe.com/2006/09/practical-synthetic-differential.html), [Eleven reasons to use Haskell as a Mathematician](http://blog.sigfpe.com/2006/01/eleven-reasons-to-use-haskell-as.html); his whole blog is worth reading.
&gt; But almost any real number you can describe is computable, so that's not a serious limitation. There are, however, plenty of numbers aren't computable from the description you'd want to give: (if cos(0) == 1 then 1 else 0)!
From the wiki article: &gt; Although the set of real numbers is uncountable, the set of computable numbers is countable **and thus almost all real numbers are not computable**. Why doesn't this matter?
Since we're talking about continuous functions, we need only talk about Cauchy sequences, which can just be sequences of rational numbers since they are dense in the reals. Rational numbers are clearly computable. Good question though.
* [PDF](http://projects.tmorris.net/public/what-does-fp-mean/artifacts/0.3/pdf/index.pdf) * [Postscript](http://projects.tmorris.net/public/what-does-fp-mean/artifacts/0.3/ps/index.ps) * [RTF](http://projects.tmorris.net/public/what-does-fp-mean/artifacts/0.3/rtf/index.rtf) * [Multiple PNG](http://projects.tmorris.net/public/what-does-fp-mean/artifacts/0.3/png/)
If you meant symbolical computing, I put up a little [example for derivatives](http://pastebin.com/raYnqUSa).
This is a good start and easy to develop into limits etc. http://xnotequaltox.blogspot.com/2010/03/bad-and-slow-numeric-integration-in.html
if you're considering a general method, go for numerical derivatives and numerical integration. if you're more of a perfectionist go for symbolic integration/differentiation where you'll just consider the expression a word in some grammar and apply at each step a rule in your differentiation grammar until you finish differentiating the expression.
"But almost any real number *you can describe* is computable." Emphasis mine. The point is that none of these almost all real numbers have a description, in particular not one suitable for computation. They will never be the result of some integration formula or anything like that. They're mainly a result of finicky axiomatics.
How is this a post-mortem debugger? I would expect a post-mortem to take a core dump and provide potentially useful information about it. In contrast, Hood is a tracing facility. This still can be useful, but it requires manual instrumentation.
No, I'm not American and I totally agree with you.
why not put the system call under forkIO ?
well, I've tried using it (I've never used threads before btw), but since the system call isn't IO (), it doesn't like it very much. Basically, I have a list of commands, and I map a function to it that brings up another window as a prompt, then runs the commands. I've tried using forkIO on that, but since it calls another Gtk+ window, it complains there too. I'm scratching my head over this
Humm, wake me when transformers beat mtl.
Getting there: * "mtl",3271 * "transformers",1711 A bit of advocacy + a tutorial on how to migrate would change things pretty quickly, e.g. as we did for vector. A little known fact: you are allowed to promote the use of your favorite tools.
&gt; I've never used threads before btw Check out the last few chapters of [Real World Haskell](http://book.realworldhaskell.org/read/), particularly [chapter 24](http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html). Threads are really the right solution here, and GHC Haskell has one of the simplest and most flexible threading libraries I've seen. &gt; since the system call isn't IO () Because it returns `IO ExitCode`? If you don't care about the exit code, it's easy enough to ignore: -- Run a process asynchronously asyncSystem :: String -&gt; IO ThreadId asyncSystem cmd = forkIO (system cmd &gt;&gt; return ()) (Edit: fixed wrong type signature) If you care about the exit code: -- Run a process asynchronously. Result is an IO action which produces the exit code later on demand. asyncSystem :: String -&gt; IO (IO ExitCode) asyncSystem cmd = do v &lt;- newEmptyMVar forkIO (system cmd &gt;&gt;= putMVar v) return (takeMVar v) -- Example main :: IO () main = do getCode &lt;- asyncSystem "pwd" threadDelay 1000000 -- sleep for 1s putStrLn "getting exit code" code &lt;- getCode putStrLn ("exit code was: " ++ show code) Note the return type on `asyncSystem`. It's an IO action which spawns a thread (and an OS process), and produces another IO action, which when executed will give you the exit code (and block if the process has not exited). This is higher-order imperative programming at work.
I tried the first one because I don't care about the exit code, but I still ran into a few problems. First of all, the type signature is incorrect. Instead of IO () it returns IO ThreadId since forkIO returns IO ThreadId. Second, even with the type signature fixed, it still tells me that since I'm using Gtk, I can't have multiple threads, which I know is silly I probably should mention that I'm still mostly a newbie, I haven't been using Haskell for even a year yet, and it was my first real introduction to programming. =P
&gt; it still tells me that since I'm using Gtk, I can't have multiple threads, which I know is silly Hmm. I know that Gtk is unhappy if you make Gtk calls from more than one thread; that's why there's a function to send an action to the special Gtk thread for execution there. But I don't know why it would object to a totally unrelated thread that just calls `system`. If you want some realtime help I recommend you stop by the IRC channel `#haskell` on Freenode. &gt; First of all, the type signature is incorrect. Instead of IO () it returns IO ThreadId since forkIO returns IO ThreadId. Sorry about that, I spotted it a couple minutes after posting and fixed it.
Why would you advocate transformers over mtl? I've used mtl a bit, but not enough to become familiar with it's warts.
For threads, you need to use unsafeInitGUIForThreadedRTS and then not use Gtk stuff from another thread, or use the postGUI or postGUIAsync functions if you really want to do something to a widget in a thread.
Sounds interesting, but you could transform this idea as a "Let's make Haskell Programs Literate" project, where your goal isn't so much to post tours but change hs -&gt; lhs. I write all my programs in literate haskell, I think more people should do so.
Gives a nice understanding of syntax and optimization, since most libraries are pretty optimized.
what exactly is functional logic programming ?
I think the effort would be better placed in contributing documentation patches for the projects you like.
I've been trying to get into Haskell, and I think those are great! Thanks! My preferred way of learning new technologies is reading real source-code. I find it much more instructional than the simplified, theoretical examples most tutorials use. However, you can rarely get a "bird's eye" view of the code by just reading the comments, and posts like yours fill that gap nicely. 
If you have (x :: IO a) and you want (y :: IO ()) you can just use (y = x &gt;&gt; return ()) like uotc used above, or in a do block: y = do x return () Or you can use (from Control.Applicative): (&lt;$) :: Functor f =&gt; a -&gt; f b -&gt; f a like: () &lt;$ yourAction But that might be less readable to the casual reader :-) 
Awesome idea.
There may be other reasons, but one point in favor of transformers is portability and modularity. mtl uses functional dependencies and requires a few other GHC extensions, while the transformers package itself is Haskell98, with supplementary packages to replace the rest of mtl's functionality using either fundeps or type families (monads-fd and monads-tf).
What would you say are the advantages of writing in literate haskell. Do you think it forces you to structure your code better? How do you think it affects the rate you produce code at - how about the quality?
The advantages of literate programming are the same as the advantages of pair programming and rubber duck debugging. You have to explain the problem in clear, concrete terms, and question all of your assumptions. No matter how much we think otherwise, we make tons of mental shortcuts when writing code. Yes it takes a little longer to do, but suprisingly little additional time is spent, and quality is vastly improved. The structure of the code needs to be good for the paper to make sense, but lhs2tex can be a bit annoying in this regard.
Anyway to see the alltime stats?
That makes sense - but I still worry it would force an unwieldy structure on my code. Would it make sense to code core module in lhs and leave utility modules in hs. Or do you lose value if everything isn't in one coherent document (or documents)?
I think more work needs to be done on lhs2tex to make structuring code with your document easier. Donald Knuth's CWEB does this brilliantly. Still, for my projects I tend to just write each file as a seperate little PDF. I rarely have small utility modules that don't really have substance.
The bird's eye view effect is what I was trying to achieve with these posts. Glad it was useful.
Is there any community preference on Bird or Latex format? All I could find is an opinion that Latex is used for white papers and Bird for everything else.
I recently had the pleasure of taking some existing Haskell code and hacking on it to change the behavior into something that I wanted. I was pleased to find this was astoundingly easy: all of the changes I had to make were local, the abstraction layer had easy patterns to recognize, the type system caught me when I made stupid mistakes, and by the end of the exercise I had a good understanding of the overall conceptual organization of the module, even though I may not have known all the details. Haskell purports to increase maintainability: we should exercise this feature!
I use bird, but I'm not aware of any preference.
I'm still ignorant of why transformers is better than mtl.
Turn optimization on. This fixes the problem, and you don't have to change the code.
What guarantees do you think programmers should have about the space usage of their code based on language semantics alone (if any)?
I use mtl because it's the only result when searching with Hoogle: http://www.haskell.org/hoogle/?hoogle=runreader
foldl is almost always a bug, it should be enabled explicitly, rather than be the default.
There's a classic example like this (I don't remember where it came from, but I didn't make it up myself); consider: (\ xs -&gt; head xs + last xs) [1..n] where n is large. Evaluating this code should execute in constant space (even with a naïve compiler!) because after (head xs) is evaluated, there is no longer a need to hold onto xs and so last can just traverse the list, with each cell (conceptually) GCed after it is examined. Now consider: (\ xs -&gt; last xs + head xs) [1..n] Shouldn't this code behave exactly the same way, because plus is commutative? It evaluates to the same value, but it runs in linear space instead of constant space, because during the evaluation of (last xs), xs remains live because of thunk for (head xs) points to it. Am I assuming a left-to-right evaluation order for plus, unjustifiably? Yes, but the same problem occurs in reverse if the compiler chooses a right-to-left evaluation order (and it probably won't flip a coin). Could a smart compiler turn the second piece of code into the first? Of course, but it's hard to imagine anything other than an *ad hoc* optimization strategy doing so. Haskellers love to hold up referential transparency as an aid to reasoning about program correctness, and rightly so, but it just doesn't hold in Haskell when you're reasoning about performance. (And sure, it probably doesn't hold in any other language either, but this particular example illustrates how laziness can complicate reasoning especially impressively.)
&gt; but it just doesn't hold in Haskell when you're reasoning about performance. (And sure, it probably doesn't hold in any other language either I think that last point deserves more than a parenthetical mention. Almost without exception, formal reasoning about programming languages (i.e., compiler theory) only discusses the final resulting value, and completely ignores issues of time or space complexity. Often there's a nod made to distinguishing terminating and non-terminating, but that's it. A formal theory for complexity and resource usage in languages is still fringe research with countless open questions.
Awesome! I wrote myself a little script to accomplish something similar with symlinks, but it always felt like a bit of a hack. I use it to keep installations of software separate; each program and version has its own program/bin, program/lib, program/include, etc. hierarchy, then I keep a directory in ~/links filled with symlinks to the various places. The upside relative to funion is that the files are writable (if the thing they're linking to are), but the downside is that "uninstalling" involves walking the entire ~/links directory hierarchy looking for links to the program's directory. It seems like funion would make this much easier -- uninstalling would be just removing that directory from the union! I really like it. Somebody should tell the GoboLinux folks, too (who turned me on to the whole separate-directory-for-each-installation idea).
The completely gratuitous Dune reference by itself would be enough to make me use this.
Winner: best package name.
Found more information at http://www.doc.ic.ac.uk/~tora/irulan/
What cabal bug does this fix, exactly?
Left versus right fold has nothing to do with it. Try it with foldr, you'll get the same message.
&gt; Turn optimization on. This fixes the problem, and you don't have to change the code. [Not always](http://hackage.haskell.org/trac/ghc/ticket/3404)
dons was referring to foldl versus foldl'
`unamb` ftw!
Sledgehammers to the rescue! ;-)
The implementation is a sledgehammer... the denotation is a scalpel.
Does not work for me... same error: $ cabal --help dyld: unknown required load command 0x80000022 Trace/BPT trap 
It is well known that Haskell can operate on countably-infinite lists like [1..]. [The powerset of a countably-infinite set is uncountably infinite](http://en.wikipedia.org/wiki/Cantor%27s_theorem). Therefore, this proves that Haskell can operate on uncountably infinite sets (in the form of a list) as well. Bravo, lpsmith. Of all the infinite advances to the state of Haskell's art I have seen, truly this is the _most_ infinite.
does it rely on mhddfs? unionfs-fuse? 
ARGH.
It's supposed to fix a couple of things: * symlinks not being put into /usr/local/bin * cabal/other executables don't work on Leopard Unfortunately I think I have to go back to the drawing board on both fronts. The OSX installer system is very very frustrating!!!
no
haha, well, it produces only the finite subsets, and those are countable :)
Coincidentally there's also a [thread](http://old.nabble.com/Hughes'-parallel-annotations-for-fixing-a-space-leak-td28100952.html) on haskell-cafe discussing space leaks. The story is that some programs inevitably leak however you write them when run on a lazy sequential machine. John Hughes solved them via parallelism. Wadler's and Sparud's papers mentioned in the thread are good reading on this issue.
is there a good example of when foldl is not a bug?
There's already the widely used [unionfs](http://www.filesystems.org/project-unionfs.html). It supports multiple stacked branches and relatively fine grained control on which branches should be writable. Most distributions should have it as a standard package at least and a lot of Live CDs use it. EDIT: Nevertheless, I'll check out funion, too, to look at the source code at least.
http://hackage.haskell.org/packages/archive/infinite-search/0.12/doc/html/Data-Searchable.html
lazyPowerset returns a list! Lists are either finite or countably infinite.
I believe that jerf was using a bit of absurdist humor. I myself joked to copumpkin about using this function to troll one of the cranks that was posted to /r/math. :-)
Does it still fail to install on Windows or what? I spent 2 weeks trying to build it from source and almost murdered my family in frustration.
gtk2hs is cross-platform. I'm not sure what dependencies are required, but many people have used e.g. ThreadScope on Windows. You might want to make a specific request on the gtk2hs mailing list?
I did and on Haskell Cafe. The maintainer just said that none of the developers have a Windows machine and that the installer fails because it's not compatible with the GHC version from the last year or two. (The real problem is that an exact GHC version number is hardcoded into the Windows installer) Tried to build from source and edit the Windows install script with the help of someone on #haskell who had attempted the same thing before, but we didn't have any success. I believe I saw a post on HC recently about finally making it Cabal friendly so we'll see.
Which does not guarantee constant space at all. ;)
Excellent work **Christopher**.
A joke explained is a joke destroyed, but, yes. Call me a math nerd, but upping the ante of misnomer from "infinite list" to "uncountably infinite list" tickled my funny bone. No Haskell list will ever "actually be" infinite, either. But we all know what it means.
`Back to the Czech republic, please.`
foldl (flip (:)) []
Yet another record system. Looks good, but I really wish we had better records as a language feature.
o_o
@mattcox: I'm glad someone finally realised it's a dune reference :) (I'm the author - happy to answer questions etc.)
Agreed, this seems like a much smarter version of Debug.Trace. Quibbles aside, it looks great.
Excellent! Liam, please keep going!
Not a waste of time; great stuff. The use of SourceGraph and whatever other tools you might find adds spice.
damn, so many smart people in one paper.
but why would you use foldl over foldl' ? I cannot conceive of an instance where you would want laziness in a left-fold.
&gt; I wrote myself a little script to accomplish something similar with symlinks, but it always felt like a bit of a hack. I use it to keep installations of software separate; each program and version has its own program/bin, program/lib, program/include, etc. hierarchy, then I keep a directory in ~/links filled with symlinks to the various places. This sounds like the implementation of [nix](http://nixos.org/nix/).
I haven't used NixOs, so I can't say the relationship there for sure, but it was _meant_ to be an implementation of [SymlinkProgram](http://gobo.kundor.org/wiki/SymlinkProgram).
Thanks!
People apparently want it. Grepping through my local repos for " foldl " turns up 2198 hits. While some portion is comments and compiler libraries and similar spuriousness, the rest is real.
Does anyone know what's the deal with SaC? It's seemed really promising but never quite ready for 5-6 years now. 
&gt;Introducton
I would hope that Haskell's evolving design is not driven by "People apparently want it." I've been assuming that it is ignorance on my part that does not allow me to see the usefulness of foldl, but the lack of any explanation so far makes me think that prelude should simply be changed to say foldl = foldl'
How does it compare to the HList library? I've found HList to be a monster to debug. 
Chars!
That's some pure evil right there. Just looking at it, I don't see why all of them wouldn't be a -&gt; b. The where bindings _shouldn't_ change the type of y, only the type that it is used at there. This, is of course, not correct, but damned if I know why. 
one quote is wrong
What's more interesting is that you can force both the signatures to (a -&gt; b) and it works just fine. In this case, the typechecker isn't inferring the most general type possible. I'm not sure why.
Since f and y is mutual recursive in the first example the constraints are solved at the same time for them. So f put the constraint y :: Int -&gt; Int and y put the constraint f :: Int -&gt; a' since x :: Int by previous constraint.
I thought this was the monomorphism restriction kicking in, but adding -XNoMonomorphismRestriction didn't generalize the types. I'm confused. :-)
Both functions take arguments, so the monomorphism restriction doesn't apply.
the tricky bit is of course the second example then, where without the second where binding, the type of y is freely generalised again.
Feel free to provide 2198 explanations of how people are stupid and are using `foldl` when they ought to use `foldl'`.
HList is more substantial than records. At least one useful thing that seems absent from Data.Record is the following trick to improve error messages: class Fail a data Expected a data Inferred a data NotFound a class Lookup label rec result | label rec -&gt; result instance (Fail (Expected want,Inferred there)) =&gt; Lookup label (HCons (label,there) xs) want instance Fail (NotFound label) =&gt; Lookup label HNil Which makes mismatches in types (you lookup something and see something else), or the label is missing, you get a sensible error message listing relevant types: no instance for (Fail (Expected Int,Inferred Double)) =&gt; likely hundreds of lines of garbage or no instance for (Fail (NotFound Label)) =&gt; more garbage Maybe it's just a question of adding those overlapping instances though. But that being said, I think that records might be a bit prettier to use since at least some of it uses type families, which should lead to less unnecessary type variables in typeclass contexts.
Damn, and here I thought it was a programming language. How could I have gotten so confused?
Type inference on mutually recursive definitions is undecidable... unless you _don't_ allow type variables to be quantified until after the definition of that mutually recursive block. (i.e. the type checking rule for 'letrec' is very different than the type checking rule for lots of lets.) I want to attribute this result to Mycroft, but don't quote me on that. You usually don't notice this in Haskell because it goes behind your back to try to re-order the nesting of definitions to make mutually recursive blocks as small as possible. (Called 'dependency analysis'.) Someone else pointed out that if you give an explicit type signature to y in the first one, that everything works fine again just like the second example. This is an extension to dependency analysis that allows things with explicit type signatures in mutually recursive blocks to be broken out of the block. I was very surprised by this when I first discovered it, too.
I code with my monitor at an angle
Yeah, when I showed Job that adding the type signature made things _more_ generic, he was a tad bit flabbergasted. After asking -cafe about it, everything is cleared up. :) Thanks for the good answer.
&gt; In this case, the typechecker isn't inferring the most general type possible. I'm not sure why. Because, in general, it wouldn't be sound to do so. For the same reasons that Rank-N polymorphism isn't inferable and that let-binding is more general than lambda-binding.
Oops, can't load a module...
This symmetrical version is a little easier to grok for me. f = id where _ = g :: Int -&gt; Int g = id where _ = f :: Int -&gt; Int 
webkit bindings alone would probably be a perfect cross platform gui for haskell. canvas, svg, openGL, audio support, even html nice layouts.
Yup, I'm sure the devs would love to hear from a Windows person about how building the [attempted cabalization](http://sourceforge.net/mailarchive/forum.php?thread_name=87bperrxyr.fsf%40ubuntu.domain&amp;forum_name=gtk2hs-devel) went!
I don't want a mind-fuck anywhere near my critical business application this and that. Not a super name.
Nix is a software package manager that can be used on any linux distribution and is subtly different from NixOS.
I think this would be a useful function: toOptional :: (Default a) =&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
You can compose the function with fromMaybe def :: (Default a) =&gt; Maybe a -&gt; a so it's liftM (fromMaybe def). Edit: that's wrong, composition should be inwards: (. fromMaybe def).
Only 2 more days to submit your proposal to work on Haskell this summer and make $4.5k US.
&gt; toOptional :: (Default a) =&gt; (a -&gt; b) -&gt; Maybe a -&gt; b toOptional = maybe def Edit: This doesn't actually work. Apparently my mental type checker is on the fritz. Thanks, dmwit.
I had a great mental dialog going on as I read this, in brief: "Oh, I see, they're having an issue with a strict signature without named optional parameters. I bet there's either going to be some crazy Haskell wizardry I haven't heard of yet or they're going to use a struct-like construct, like I do in C. Oh look, they chose to use a record like you would use a struct." I'm kind of disappointed it wasn't crazy Haskell Wizardry.
I really have to play around with the (-&gt;) Monad more
Looks like a really interesting series. It's a shame the actual site is so obnoxious. I'll vote you up AFTER I have read the freaking article. Not before. Also.. I can't get any other page to load because of I assume more javscript obnoxiousness. Shame :(
downvoted for 'haskell'
Your powers of deduction are remarkable.
yeah I thought it was obvious myself, but evidently not..
Also apparent in Java constructors and this() constructor calling.
http://okmij.org/ftp/Haskell/polyvariadic.html#keyword-args
Ha! Neat It's subjective, but I think the record syntax is easier to read, especially with partial mutation. Ie: my_foo = some_bar $ some_record { one_value_of_many = "baz" }
Oh yes. God yes. It's many times worse in Java-land.
Hey guys. I'm glad to see that you like Funion. I didn't realize that dons had posted the link to Hackage. I came here to post a link to my official announcement on my blog about it: http://nathanwiegand.com/wp/2010/04/introducing-funion/ This is my first largish Haskell project and I'm glad that you like it. If you decide to use it, please let me know! Also, bug reports are gladly accepted.
I see where you're going with this, and I agree, but I think you're wasting your time. It's worth taking a look through the future of Haskell slides from 2008. http://blog.well-typed.com/wp-content/uploads/2008/09/batteries.pdf Bullet point on slide 2 reads "Haskell (the language) is done". Slide 5 suggests that publication in academic proceedings is equivalent to being "lost to the world", and slide 13 makes the analogy GHC : Haskell Platform :: Linux Kernel : Linux. You can argue against this world-view, but within this world-view it doesn't make a lot of sense to nit-pick about the difference between Haskell and GHC. Sure, the language definition might not have caught up with the compiler, but as long as there's exactly one of each and the only important thing is what code I can build on my system right now, why worry about the difference?
**ffffffffffffffffuuuuuuuuuuuu**
GHC : Haskell (Platform) :: Linux Kernel : Linux, as Trevion points out, from the 2008 Haskell Platform manifesto. *Edit: would love to know why I'm downvoted*, I believe if we're going to gain wide adoption, making this small simplification is an easy step.
These may not match your criteria exactly, but look at Scheme and Liskell.
Cool. I think this is pretty much what I was looking for. I knew it had to be out there. Thanks a lot :)
Haskell is difficult to parse if you write a parser for it, however if you just use haskell-src-exts it's trivial to parse Haskell. Then you can write a minimal Haskell-like language in 100 lines or so.
As an academic PL researcher, I thought this was a valuable clarification. Doing PL research in a commercial language raises challenges with addressing both the academic and professional communities---for example, consider the continuing controversy over the introduction of closures to Java, or the concepts proposal for C++0x. You can begin to see the same thing happening in areas of the Haskell language, like the long-standing class aliases proposal, or the failure of at least GHC and Hugs to implement improvement correctly. The 2008 manifesto helped me realize that my research isn't on Haskell, and this was valuable for focusing my work. Up to that point, I'd had some of the concerns mentioned above: how do you present new language features in a way that's both publishable and accessible to the general audience? How do you improve language features while preserving backwards-compatibility for a collection of 2000 libraries? For me, these concerns are now gone. This isn't to say that the Haskell community can't be a valuable resource for a PL researcher, or that there isn't interesting work in areas supported by GHC. I do think, however, that if your interest is in Haskell-the-language instead of Haskell-the-compiler-and-implementation-and-library system, then probably your interest isn't really in Haskell any more.
These problems are now well-known within the community, see for example: * [Abstraction, intuition, and the "monad tutorial fallacy"](http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/) * [Explaining Haskell IO without Monads](http://neilmitchell.blogspot.com/2010/01/haskell-io-without-monads.html) * [Introduction to IO](http://haskell.org/haskellwiki/Introduction_to_IO) &gt; On that note, you’ve got to stop treating I/O in general as a red-headed stepchild. I absolutely agree here. Haskell (as implemented by GHC) is the most powerful imperative language I know, especially when you consider its support for concurrency. Looping and control-flow structures, resource bracketing, exception handling, and concurrency primitives are all represented as ordinary functions, and you can define your own. For example, here's an asynchronous logging system: type Logger = String -&gt; IO () startLogger :: IO Logger startLogger = do ch &lt;- newChan forkIO $ forever (readChan ch &gt;&gt;= putStrLn) return (writeChan ch) This IO action `startLogger` creates a message channel and spawns a thread to listen to this channel and print messages it receives. It then returns a partial application of the "write" function for this channel. This presents the user with a simple API: to log a message, call a function and execute the result. The details of message channels and threads are hidden from the user; they are "closed over" in the value returned by `startLogger`. Powerful imperative programming requires powerful functional programming, and vice versa. Haskell integrates the two very nicely, and Haskell evangelists should be more vocal about this point.
I just wish people wouldn't "explain" abstract concepts with concrete analogies. Either give concrete *examples* and then show how the structure can be generalized, or give the fully abstract mathematical definition and then show how it's used, but please don't conflate the abstract concept itself with the examples and analogies. Functors aren't containers, monads aren't for sequencing, and monoids are not about "appending" no matter what the Prelude says, even if those are all good and useful examples of where the respective abstractions are naturally useful. Also, IO is corrupted with malevolent magic powers and probably shouldn't be used as an example of anything. I suspect people with inclinations similar to the author of this post would benefit most from an imperative-style, no-nonsense, no-abstractions, how-to-just-do-it guide on IO combined with a quick practical tutorial on the proper idiomatic use of standard data types, followed up by a discussion of how the standard type classes tease out and unify various behaviors. Really, none of that *has* to be terribly difficult, and once you understand some underlying motivations the abstractions are almost breathtakingly elegant--especially Monad, but when people spend weeks reading about burritos and wondering why it seems to be impossible to do anything with I/O, it's no wonder that they don't see it!
Seconded. I recently used Language.Haskell to do source code transformations and it worked like a charm. Use these tools!
It should be noted that many beginners to Haskell attempt to learn monads before they have a solid understanding of higher-order functions or typeclasses. This is doomed to failure. Discarding all of the analogies about spacesuits and burritos, "Monad" is just the name of an API supported by various types. The API is a typeclass, and its most important method is a higher-order function. So these are crucial prerequisites.
Yes, this is exactly right. It's not about dumbing it down for the plebes, it's about getting in and experiencing the language first-hand in an accessible way. 
The links you provide are all great, but when they even mention Monads, it's a bit like stepping into a conversation midstream. I know there are many tutorials, but that in itself is a problem, since the beginner is not equipped to know which one will be of most benefit. There needs to be a metatutorial to help you pick the best one. ;)
Uh... the first link is a blog post explicitly about the proliferation of monad tutorials and why it happens. The second two are IO tutorials but they're not monad tutorials (indeed, IO would be an exceptionally poor choice for a monad tutorial). You can confirm this by searching for the word "monad" on either page. So I'm not sure what you're objecting to.
Not quite; that has a `(Default b)` constraint rather than a `(Default a)` constraint. Or my mental type-checker could be broken again.
I actually like it better written as "`(fromMaybe def .)`".
Criticism noted. What do you mean by you can't get other pages to load - what links are you clicking on?
Well, I don't pretend to speak for other redditors. However, I know some of my then-colleagues were disturbed or offended by some of the points in your 2008 talk. This can't entirely be a surprise---Haskell has a 20-year history in the PL research community (longer if you include Miranda and the various lazy MLs). For some people, the Haskell community was a research community, and the transition from "Haskell serv[ing] as a basis for future research in language design" [1] to the idea that Haskell only needs the contributions of a select group of researchers would have to be a little jarring. Presumably, though, this was expected in the transition to focusing on wide-scale adoption. [1] Hudak et al., Report on the programming language Haskell: a non-strict, purely functional language version 1.2. SIGPLAN Not. 27, 5 (May. 1992), 1-164. 
&gt; were disturbed or offended by some of the points in your 2008 talk It was meant to be provocative :-) But you're misrepresenting the talk, anyway, which was really more about focusing on issues beyond language semantics -- such as package semantics, soundness of distribution systems and so on. And we've sure achieved a lot since then, so I'm comfortable. Meanwhile, people keep adding things to GHC -- and e.g. UHC has been released since then, the GPH people having started pushing to integrate with GHC and more. The talk nowhere says anythiing about "a select group of researchers" either... The community is thriving, and some researchers have begun to look at packaging and library issues.
Oh, I didn't meant to suggest that you and your coauthors intended to offend, just that I knew people who were offended. The "select group" thing is probably similar---I assumed that the future of Haskell included more work from (e.g.) Simon PJ and Tom Schrijvers. I didn't mean to imply that you shouldn't be comfortable with the growth and development of the community or tools either---simply that, given the history, perhaps you shouldn't be surprised that some people react negatively. That's a by-product of any significant change, whether the change was worthwhile or not.
I'm sorry I didn't realize it was a joke. It seemed plausible as a mistake to me, since I've seen many people much more confused about cardinality than that.
I'm a Haskell beginner, if even that. I haven't had a chance to give it that much of a try. So that's where I'm coming from here, maybe this could be a useful perspective. I'm interested in Haskell because of the fact that it's supposed to be pure, save for IO. So when I see things like this "do" structure, and I'm told not to worry about what it does behind the scenes for now, it sortof seems like a copout, since it looks like it's changing state. Maybe it's just me, but I feel like if I'm to appreciate Haskell for what it is, a language as purely functional as possible, I'd like to understand why what I'm looking at is still purely functional. Is there a way of explaining that without getting into monads? Or maybe it's just that I'm curious about what this monad thing is.
I'm also a beginner. I found a good tutorial that I can't find right now (sigh). It explained that "do" is syntactic sugar for applying a bunch of higher order functions. Each statement in a do-statement yields a function which takes the next statement as a parameter. This syntactic sugar is explicitly expanded in [IO Inside](http://haskell.org/haskellwiki/IO_inside) from [uotcguyeoncieohp's post](http://www.reddit.com/r/haskell/comments/bnudr/stop_trying_to_simplify_monads/c0nostl) in this thread.
But when learning C does someone ask what is going on behind the scenes as far is IO is concerned? The answer is generally no, and should also be no in the case of Haskell. Neither C nor Haskell instructors are copping out by not explaining the intricacies of their respective IO systems. Also, I would suggest trying to avoid thinking about IO as purely functional in Haskell. It just isn't helpful at all, and I'm convinced that it isn't true anyways. Others [agree](http://conal.net/blog/posts/is-haskell-a-purely-functional-language/) with me. By making monads sound interesting, Haskellers are dooming themselves to obscurity. Good thing articles like this one are trying to undo some of the damage. Make sure you look at the [link](http://neilmitchell.blogspot.com/2010/01/haskell-io-without-monads.html) that Neil Mitchell posted in the comments as it describes what you need to about IO in Haskell without referencing monads. 
You may or may not already know this, depending on how much of a beginner you are, but the "do notation" really is 100% syntactic sugar: it's not doing anything behind the scenes you couldn't also write without it. A quick summary: Monads are combined using the "bind" operator `&gt;&gt;=`. The first argument to bind is a monadic type, and the second argument is a function that takes an argument of the type held by the monad. So if you have a list of `Int`s, and a function `Int -&gt; [Bool]`, you can combine them with `&gt;&gt;=` to get a list of `Bool`s. Bind is basically function application written backwards, with the special structure of the type (like multiple values in a list) being automatically carried along. Since most of what you want to do with monadic values will involve bind, it'd be annoying to create a bunch of functions for everything. Instead, the usual pattern is a bunch of nested lambdas, like this: `[1,2] &gt;&gt;= (\\x -&gt; [x, x*2] &gt;&gt;= (\\y -&gt; [y, 0]))`. Of course, that would get ugly really fast. So, do notation puts each layer of the nested lambdas on a separate line, flips the order around, and replaces `&gt;&gt;=` with `&lt;-`. So, the nested lambdas above are equivalent to: do x &lt;- [1,2] y &lt;- [x, x*2] [y, 0] Try running both versions to see; they're identical. Also note that there's no "state" changing at all here--in the list monad, bind means "try everything", mapping the function over each value and then concatenating the resulting lists. The Haskell Wikibook has some [similar examples](http://en.wikibooks.org/wiki/Haskell/do_Notation#Example:_user-interactive_program). If you want to get the hang of it, try looking at the base types for various monads and writing code using the base types. For instance, `(State a)` is really just a function `(s -&gt; (a, s))`.
Well I'm not really talking about IO, like I said it's the one thing I recognize isn't purely functional. I'm talking about the "do" structure at all, which I understand is somehow related to monads, which I understand are purely functional, again save for IO.
But, why over-specialize your code by using `(.)` when you could use `fmap` instead and have it work for any Functor, not just `((-&gt;) r)`?
Sorry, I guess I sort of misread what you said. I would strongly suggest not delving into monads until much later. After perhaps 3 months of writing semi-practical programs in Haskell, then start thinking about them. At this point you will realize that monads clean up your code and they will actually come naturally to you (rather than artificially trying to cram an abstraction into your head). Everything in Haskell is possible without monads, so I wouldn't worry about them for now as they will just serve to confuse you.
&gt; if you hope to win converts from the programming world at large (and I really hope you do) we don't. avoid success at all cost!
readability
Here's what I wish someone told me when I was learning about Haskell IO. Hopefully it will demystify the subject somewhat, while avoiding use of the m-word. There is nothing magical about `do` notation or even the `IO` type constructor really. What *is* magical is the identifier `main`. A value of type `IO a` is fundamentally just like a value of any other type. In particular, **evaluating it does not have side effects**. That is the sense in which IO is treated purely functionally in Haskell. What does have side effects is **executing** it. How do you execute a value of type `IO a`? Well, there are basically three ways: * Bind the identifier `main` to it, e.g., `main = print "Hello, world!"`. * Using the `&gt;&gt;=` operator (or the equivalent `do` notation), build it into a "larger" value of an `IO` type which is then bound to main or part of yet a larger value, etc. * The evil way, which shall not be named. A silly yet useful mental model for a value of type `IO a` is that it is a string containing a C program which when run will return a value of type `a`. `do` notation is a fancy syntax for specifying how to build strings out of simpler strings, but one is still just manipulating strings, not anything more magical. The magic happens when one writes `main = whatever`, which causes the Haskell runtime system to compile and run the C program in the string `whatever` (not actually, of course, but in this model). Exercise: What does the program `main = seq (print "Hello, world!") (return ())` do? Intermediate Haskell programmers are confused by this surprisingly often in my experience.
Not many programmers have a advanced degree in math, and so don't KNOW the theoretical underpinnings to monoid, monad, etc etc. What is it good for, why is it important? So they use lots of math lingo, and most computer scientists DON'T get it. The fact is, while Functors/Monoids/Monads may have a fancy mathematical basis, 90% of the time their use in Haskell involves simply containing/appending/sequencing.
I don't see this mentioned yet, but I found [this blogpost](http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html) quite helpful. It walks you through the intuition and abstraction processes of why Monads are useful, as a programming tool, without getting too esoteric. As a beginner, I find this much less intimidating. 
&gt; It should be noted that many beginners to Haskell attempt to learn monads before they have a solid understanding of higher-order functions or typeclasses. This is doomed to failure. Exactly! And I'll add "type constructor" compared to "type" to the list. I have a theory why they're expecting to learn monads before they're ready, too: the concept has is *unfamiliar* and has an *exotic name*. If you read a text with the words "higher-order function" and "type constructor", you can still somewhat understand the text by replacing them with "function" and "type". However, the part of understanding that you can only acquire with practice is skipped. Monads are the first concept that cannot be skipped that way, and they're stuck. Generally, programming in Haskell is not a collection of facts that can be read up somewhere, it's a skill that has to be trained, and many people struggle with this distinction.
&gt; making monads sound interesting Monads *are* interesting, because of the number of useful things that have monadic structure -- parsers, transactional concurrent systems, logic programming, code generators, nondeterminism... That's why Microsoft is adding similar features to C# and F# -- of course, they've replaced the scary name. Monads *for IO* are not that interesting. They're just a way to build first-class values representing actions. &gt; Also, I would suggest trying to avoid thinking about IO as purely functional in Haskell. It just isn't helpful at all, and I'm convinced that it isn't true anyways. Others agree with me. No, it is really important to understand that `putStr` is a *pure function* that returns an IO action. `IO` is *not* a tag attached to functions to indicate that they're impure. It's a first-class type of its own, and this fact is directly responsible for a lot of useful and practical things.
&gt; I'm talking about the "do" structure at all, which I understand is somehow related to monads Yes, the clearest concise definition of "monad" in Haskell is "a type for which the 'do' notation is supported". "Monad" is the name of an API and the "do" notation is just sugar for the methods in that API.
Great mental model, new to me.
While it is true that they are interesting, all of the things you listed are not beginner topics except IO. This is why I stated that one should wait before learning monads, there is no purpose to learning them upfront just like any other advanced language feature. Monads aren't going to revolutionize a beginner's code and shouldn't be advertised as such. With a better grasp of the language yes, they become quite useful as I stated before. Also, monads don't have a terribly privileged status in the world of Haskell. Arrows and applicatives are used in the same kinds of ways as you listed. The community's overemphasis on monads' importance isn't useful. Arguably the useful properties of IO in Haskell come from values being first class, rather than being pure. For example, compare [these](http://www.reddit.com/r/programming/comments/bh7ky/how_to_and_not_to_give_a_talk_on_f_or_any_other/c0mratv) two programs in Haskell and C#. They do the same thing and it would be completely legitmate for them to be compiled to identical machine code. And yet somehow the Haskell one is pure and the C# one is not? At least in this case your distinction can't have a practical realization.
&gt; I stated that one should wait before learning monads, there is no purpose to learning them upfront just like any other advanced language feature. I agree. That's why we need to emphasize these "doing IO" tutorials that skirt around the m-word, and deemphasize all of the burrito spacesuit nonsense. &gt; Also, monads don't have a terribly privileged status in the world of Haskell. Arrows and applicatives are used in the same kinds of ways as you listed. The community's overemphasis on monads' importance isn't useful. Arrows are barely used (or understood) by anyone. I've run into many things that were "almost arrows" but it was always either impossible or pointless to use the actual `Arrow` typeclass. They are not pervasive the way that both `Monad` and `Applicative` are. Applicatives are quite useful, and have caught on quite a bit in the past few years. However, they have no special syntax (arguably one is needed) and are not mentioned in the Haskell 98 standard libraries, unlike `Monad` in both respects. And the integration with `Functor` and `Monad` is awkward for historical reasons. So yes, `Monad` has a privileged role, though I'd like and expect to see it reduce in the coming years. There's no denying that monads play a large role in the structure of complex real-world Haskell programs. I think that's quite a different issue from when beginners should learn about them. &gt; it would be completely legitmate for them to be compiled to identical machine code. An irrelevant implementation detail. GHC's implementation of the IO monad is fantastically impure, but this does not leak through to the semantics of ordinary user code. &gt; Arguably the useful properties of IO in Haskell come from values being first class, rather than being pure. But a value is not usefully first-class if forcing its evaluation has a side effect. The whole point of first-class values is that you can pass, store, and use them freely. If evaluation is tied to execution, then you have to reason about the reduction semantics of the functions and containers you use in order to make sure your actions don't fire too early or too late. That's difficult and error-prone, especially with lazy evaluation. Better that the value should be a totally inert description, safe to handle any way you like, and that we use a separate mechanism to decide when to carry out the actions so described. That's the essence of first-class actions. And they're not the exclusive domain of monads -- first-class actions are commonly seen in other languages. Every time you wrap an expression in an extra layer of function calls to defer its evaluation, you're explicitly making a *pure* value -- since a function still waiting on arguments will not have any side effect. It's really a question of defaults. Should applying `putStr` return an action, which you then execute? Or should it print the string, and require you to wrap it specially in order to get an action? Both designs let you express the same things, but the former is a more natural fit with functional programming style.
good work. ( you should put the source on github, many people are likely to be interested, some may even help you ...)
For a start the mtl has a broken version of StateT Cont.
I stand corrected.
Can you (or parent) give examples of functors which aren't containers? This sounds interesting. :-)
Functor ((-&gt;) b) , obviously. I don't think Joe R. Hacker would call IO (or most other Monads) a container, either, and every Monad is a Functor. To the extent that code isn't data, of course. Functors are defined by the type of fmap and the law fmap f . fmap g = fmap (f . g) . I think it's detrimental not to mention non-container examples when presenting them as the abstraction is all about types, not about any concrete implementation.
Farther along than I am. Looking good.
Hey, actually.. it seems all the problems I was having were tied the browser I am stuck with on my worklaptop. I came back later with a real browser (Chrome) and everything was fine. I actually then read all 10 parts. Good stuff :) To be more specific: When trying lo load a page with IE8: If I clicked on the link on the main Haskell subreddit I would a blank screen with the chance to vote/submit and be redirected back to this page. Clicking on the link from within the commetns gave me access to the article. Clicking on any other link on you blog would cause the page to load, then get covered by what I can only assume was a blank div. The javascript error was something about Delicious not being a defined object. I forget what the line number and context was (I was just having a look whilst something was compiling...) Lastly, I've got to stop checking reddit at work. It's making me into a complete butthole. Your blog is interesting, and certainly palatable in Chrome :)
It appears to have been on github, but then removed. it is still somewhat accessible through google's page cache. The search i used: site:github.com riza
It's a classic post. [He made a list of various post he has written here, the first section links to his best monad articles](http://blog.sigfpe.com/2010/03/partial-ordering-of-some-category.html).
For me the best intro was [Typeclassopedia](http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf). It's not meant as a tutorial. But I thought the flow of the article where he goes over functors, applicative functors, monoids and monads in a logical manner really tied all the pieces together for me. I think a lot of the problems with monads, come from a lack of understanding of the Haskell type system especially type classes.
People who program "bottom-up" should go do something else. Top-down is far more efficient. When someone claims they can only learn one particular way, what they mean is they are too stubborn to do anything different than the way they are use to doing it.
You are certainly correct about that. Getting the tone right on the Internet for this sort of thing is a challenge; there's such a delicate balance between "so blindingly obvious it's not funny" and "giving small subtle signs that you do in fact get it" that you end up getting it wrong for somebody no matter what you do. But sometimes I can't resist.
Okay, I don't really think about them as *not* being containers (in the whole code as data sense) so it didn't really occur to me.
Huh? The source code looks to be either C or C++, not Haskell...
The code you're looking at in the video is shader code, not C or C++ it's GLSL.
Oh, I wouldn't call it an objection per se. I think the articles in question are great. But the title of the first tutorial muddies the waters just a bit. 
 The distinction between evaluating and "running" is huge, and I totally didn't get it until this thread. Thanks. &gt; The evil way, which shall not be named. This just guarantees I'll try to go figure out what you mean. 