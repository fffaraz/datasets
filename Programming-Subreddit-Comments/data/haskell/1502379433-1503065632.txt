I think it stems from not wanting to feel like a novice in areas where you are otherwise an expert. Learning Haskell is sort of like learning a whole new language and dialect to express concepts that you already understand in other contexts. It's not so mysterious. It just requires a very strong value proposition, the good fortune to learn Haskell early on, or a specific disposition.
I'm curious what your programming domain is. I think it varies a LOT by domain.
Woah, I like how this paper talks about sparse stuff a little bit :) will you be at ICFP? 
Ok, I'm dumb. Completely forgot that it was a shared folder. I was bumping against a path length limit. Thanks!
How is that file relevant? I can't see any functions of type `Living -&gt; Animal` or anything like that.
In terms of facets of development, Haskell really shines at *ease of refactoring*, it's completely normal to make huge invasive changes to haskell code bases and have everything go fine the first time. It's also totally reasonable to take complex single-threaded code and make it multi-threaded after the fact, which is incredible error-prone in most other languages. This is is driven by two things: purity and the type system. Purity means that you can locally reason about any chunk of code, if you understand the inputs and outputs of a function, you understand the function and you don't have to reason about how it interacts with the program as a whole. The type system makes it very easy to reason about the inputs and outputs of a function, because they are usually explicitly labeled with significant detail. Since you can independently reason about small chunks of the program, you can introduce abstractions post-hoc and expect them to not cause problems and the type system gives you the ability to build really nice abstractions. Finally, since the whole thing is statically typed, if you have taken advantage of the type system in the production of your program and want to move things around or change the abstractions you are using, the compiler can verify that all of the inputs and outputs you don't touch are still the same which is very strongly correlated with your refactoring not breaking your program.
&gt; Another example which makes working with records a nightmare -- UI sends a PATCH request containing only those keys that it wants to change. How do you update them in an existing record without writing tons of boilerplate? This one's "easy". You use the "parametrise by a type constructor" trick. It's completely typesafe and boilerplate free (assuming you can deriving the apply function) but there are two downsides * You have to "parametrise by a type constructor". I suppose it's not too bad. * For a "naked" type you have to parametrise by "Identity", which might involve some wrapping and unwrapping. So, {-# LANGUAGE Rank2Types #-} {-# LANGUAGE StandaloneDeriving #-} {-# LANGUAGE FlexibleContexts #-} {-# LANGUAGE UndecidableInstances #-} import Data.Functor.Identity data Foo f = Foo { foo :: f String , bar :: f Int , baz :: f String } -- The show instance seems not to be derivable maybe because it needs -- undecidable instances. That's a bit sad. deriving instance (Show (f Int), Show (f String)) =&gt; Show (Foo f) -- This is a "generic function" that could be derived with Generic, -- TH, etc.. applyFoo :: (forall a. f a -&gt; g a -&gt; h a) -&gt; Foo f -&gt; Foo g -&gt; Foo h applyFoo f (Foo a b c) (Foo a' b' c') = Foo (f a a') (f b b') (f c c') -- Write your patch function using `applyFoo` patch :: Foo Identity -&gt; Foo Maybe -&gt; Foo Identity patch = applyFoo (\(Identity x) y -&gt; Identity (case y of Nothing -&gt; x Just z -&gt; z)) -- The original value. foo1 :: Foo Identity foo1 = Foo { foo = Identity "Hello" , bar = Identity 1 , baz = Identity "world!" } -- The patch foo2 :: Foo Maybe foo2 = Foo { foo = Just "Goodbye" , bar = Just 1000 , baz = Nothing } -- Applying the patch foo3 = Foo Identity foo3 = patch foo1 foo2 main :: IO () main = print foo3 &gt; Foo {foo = Identity "Goodbye", bar = Identity 1000, baz = Identity "world!"}
This is literally all the help I needed. Thanks for figuring out the `ApplicativeDo` connection. I now have a minimal example which I shall submit. :-)
for the `x :: Foo Identity` is there any way to access individual fields without having to call `runIdentity` on each one individually? eg. how would you write the following `Text.concat [x ^. foo, " has ", x ^. bar, " incomplete orders"]`
You could do this with [anonymous records](https://www.athiemann.net/2017/07/02/superrecord.html). The library mentioned in the linked post currently only supports `combine` (that's your `merge` function), but writing extract should be straight forward. (Disclaimer: I'm the author)
Thanks!
I would also like that. I like the idea, and I just ran into a situation where it would help eliminate some boilerplate in my code.
&gt; Most common case is when you have a DB row with many fields, all of which, are not required at the time of record/row creation. The first and most important thing to note is that you do not have to lose (much) ease of implementation compared to Ruby. You can just represent all your records in a `Map String Dynamic` and everything is as easy as Ruby (except you have to unwrap `Dynamics` explicitly). It's not typesafe but you get the benefit of typesafety in the rest of your Haskell application that's not using this hack. If you want to be typesafe but still have ease of implementation then there are two general approaches that you could use. You can also mix the two. 2. Use "subvalues" (for want of a better word) 1. Add some polymorphic fields For the "subvalues" approach, build your records up by constructing them out of other records. data NewOrder = NewOrder { ordCustomerName :: String , ordCustomerEmail :: String , ordCustomerPhone = ... ... } data Order = Order { newOrder :: NewOrder , orderStatus :: ConfirmationStatus , ordCreatedAt :: Time , ordUpdatedAt :: Time } Then you can write `NewOrder -&gt; ExistingOrder` with no boilerplate. For the "polymorphic fields" approach, just make some of your fields polymorphic data Order' confirmationStatus Time = Order { ordCustomerName :: String , ordCustomerEmail :: String , ordCustomerPhone = ... , orderStatus :: confirmationStatus , ordCreatedAt :: time , ordUpdatedAt :: time } type NewOrder = Order' () () type ExistingOrder = Order' ConfirmationStatus Time Again it's easy to write `NewOrder -&gt; ExistingOrder` with no boilerplate. I'd recommend playing around with those two ideas. They can be made more polished than I've presented them.
What have you used that's better?
As I said, that's the downside. You could do Text.concat [x ^. foo.i, " has ", x ^. bar.i, " incomplete orders"] i = to runIdentity if you like.
We are already used to polymorphic records (due to Opaleye, heh!). How does one write `NewOrder -&gt; ExistingOrder` in the polymorphic approach without boilerplate?
 time &lt;- getCurrentTime createOrder (json { orderStatus = OrdUncorfirmed , ordCreatedAt = time , ordUpdatedAt = time }) You do have to have some "boilerplate" to insert the `()`s into the new order, but it's pretty light as boilerplate goes.
&gt; I assume that GHC is smart enough to realize this and not go through h twice. Expect to be disappointed.
You can solve the `runIdentity` problems using type family. One way is to pass a "stage" type instead of a functional r or having a type function (type family) deciding of which type to use depending on the stage. The other way is to create a type of to remove Identity. Basically you do something like type family EraseIdentity f a where EraseIdentity Identity a = a EraseIdentity f a = f a And use EraseIdentity in your type declaration. Another option is to use my package [Metamorphosis](https://github.com/maxigit/Metamorphosis) which has been exactly to solve this problem. You can generate from a type it's parameterized version as well as converters. It also allowed to generate subtype or extend or merge types into other (with again generated converters). 
If defined like that can `EraseIdentity` actually be partially applied?
 -- This is a "generic function" that could be derived with Generic, -- TH, etc.. applyFoo :: (forall a. f a -&gt; g a -&gt; h a) -&gt; Foo f -&gt; Foo g -&gt; Foo h applyFoo f (Foo a b c) (Foo a' b' c') = Foo (f a a') (f b b') (f c c') Indeed, this is a special case of [`Rank2.liftA2`](http://hackage.haskell.org/package/rank2classes-0.2/docs/Rank2.html#v:liftA2) that can be [automatically derived](http://hackage.haskell.org/package/rank2classes-0.2/docs/Rank2-TH.html). 
Cool!
LTS9.0 for Stack includes the latest version of `testy-discover`; you might want to consider rewriting your guide to use LTS9.0 and take that into account. The first post is mostly acting as a tutorial for beginners to follow, so it seems weird to me to be using a depreciated library when the main reason for doing so was fixed in the latest LTS. Great post overall; I'm looking forward to seeing the rest of it!
[Disclaimer: I haven't clicked through, and I'm on my lunch break.] This looks a little awkward to me. Perhaps a bit too… narrow? The fundamental goal here is declaring an instance where the new dictionary is a safe coercion of another one, right? Something like: instance Monoid (Apply Foo a) =&gt; Monoid (Foo a) where &lt;the new dictionary&gt; = Data.Coerce.coerce &lt;the old dictionary&gt; If I recall correctly, there was a discussion/proposal of being able to name the type of a class's dictionary. That seems relevant. The reason this approach seems less narrow than the deriving-clause is that the "other dictionary"'s type could be arbitrarily sophisticated (e.g. multiple and nested newtypes, MPTCs, etc), as long as the Coercible machinery can solve for the coercion between the underlying dict types.
Web applications, with ML and CV pipelines, and what you might describe as "data engineering". I agree that it probably varies a lot by domain, and for very large projects in any domain I think Python is probably not the best choice (a (micro)services model might be okay, though, if that's an option). At the scale I've been working at ( 10K &gt; LOC &lt; 50K) it's been okay, but certainly refactoring and discovery can be problematic. 
I never tried to partially apply type family. Also the problem with this approach, is the type checker can't infer `f` (in `Order f`) which might be solved using injective type families. This is why I prefer the Metamorphosis approach. I get plain data type, which are easier to work with (in term of type inference and instance derivation).
Manual recursive descent, I guess. (I've only written such parsers in imperative languages though) It's not very nice to write, not quite declarative - but at least it runs fast :-)
&gt; Here's my question though. On the wikipedia, it says that Haskell is used in Academia. While it's really, really awesome, I don't understand why. Haskell is relatively young, and much of its development came from Academia. &gt; For instance, if I were to look at computational physics which relies heavily on computational power, then Haskell would be practically worthless because (I've heard that) Haskell is extremely resource hungry (probably from all that recursion) That's not really true. Numerical libraries that have existed for a long time in other languages are going to be faster. Haskell is well suited for certain tasks, but not all. Also, if you do your recursion correctly, it should be no different than a while loop or the like.
&gt; Actually, if you do need performance, Haskell can be optimized quite well. Much better than Python for sure, and at least good enough to filter spam at Facebook. Part of why Facebook uses Haskell is that it makes concurrency easy. Concurrency is hard enough that rewriting code that works to squeeze of the last bit of performance doesn't always make sense.
&gt;The dedicated IDE is immature at best, the plugins for editors/IDEs (ST3, VSC, IntelliJ) are in different state of readiness I think is an unfair expectation. IDEs for other languages cost money. They're simply a lot of work. &gt; I respectfully disagree with the point "Haskell tools are exceptional". In my experience, the ecosystem is still lacking. Maybe a better description would be that Haskell has some truly great tooling/libraries (such as hoogle, haddock, criterion, QuickCheck), even if it's lacking in other ways. &gt;Cryptic error messages both from the compiler and the libraries Certainly haven't gotten many cryptic compiler errors. &gt;Even a simple "rename a function" can become difficult You might be interested in HaRe. So far it has an Emacs plugin + a partial vim plugin. The vim plugin can in fact rename a function across modules, which is nice. &gt;The debugging is not really different from debugging with gdb I'd recommend two things: * Break things down into small functions, and test those with hspec. * Use the `Debug.Trace` module, and its `traceShowId` function. &gt;To my knowledge, the incremental compilation/incremental linking still have some issues I've actually found that stack handles this better than e.g. Rust does. Admittedly I've only ever used Rust, Python, and Haskell so that's my only perspective. &gt;"cabal-hell", "lts snaphots", "dependency resolving" anyone? cabal new-build actually does a pretty great job of this. Stack is also good, and much more ergonomic.
&gt; Yet take a "non-complex" refactoring Well, the thing is, it *is* complex. If it were easy, you could make the plugin yourself! Something like "move this function from this module to that one" is actually quite complex.
&gt; "replaceAll" for Haskell looks like a step back to 90s (and don't forget to rename module names in .cabal! =) ). I have an unsupported command-line tool [here](https://github.com/vmchale/hask-replace) that can be used to move modules as well as whatever HaRe could do.
&gt; what this language is REALLY good at. is it speed, ease of development or what? All of the above! Haskell is fast (not as fast as Rust), its expressiveness far exceeds anything I've worked with, and its maintainability is best-in-class. Some Applications: * Languages. Haskell is best-in-class for compilers/interpreters. This is partly due to some really good libraries, and partly due to first-class support for monads (which makes writing parsers pleasant). * Web services. Haskell makes concurrency easy. I don't know as much about this topic. * Correctness. Haskell is the only mainstream language that can offer the such guarantees about correctness.
Ah, I misunderstood what you were suggesting. Yes, `EraseIdentity` can work reasonably well. It's the approach used in Beam: https://tathougies.github.io/beam/tutorials/tutorial1/
This can play particularly well with `RecordWildCards` or `NamedFieldPuns`. Just remember that you can't expect coherence!
I think these weekly summaries are great! I hope you keep doing these
I posted something like this recently, but called it a type level `$`. https://www.reddit.com/r/haskell/comments/6jllya/using_in_types/ Briefly, change the fields of `Foo f` from e.g. `f String` to `f $ String` and then normal `* -&gt; k` types such as `Maybe` or `Identity` work correctly, but it is also possible to supply `Id :: IdK`, a special symbol which is removed (i.e. `Id $ String` is identical to `String`).
Can you give an example where this doesn't work? I just tried this, and it appears to work fine: {-# LANGUAGE ScopedTypeVariables #-} {-# LANGUAGE TemplateHaskell #-} module Foo where f :: forall a. a -&gt; a f = id :: $([t| a -&gt; a |])
Laws certainly add value to typeclasses but they are not the only reason typeclasses have value.
Thanks for your explanation! The phrase "stateful computation" is from LYH. Its used a lot in the section "Tasteful stateful computations". &gt; stateful computation is a function that takes some state and returns a value along with some new state. That function would have the following type: &gt; &gt; `s -&gt; (a,s) ` I may have meant the function that the state monad wraps, and not stateful computation. I don't understand what you mean by this &gt; `(L.State h) &gt;&gt;= f = ...` is pattern-matching on the `L.State` value constructor I find the term `(State h)`, or rather `(L.State h)` confusing. Its a type right? Why would a type *alone* be used in a bind expression?
Yes, but only the second half of the week.
When this happened to me that hardest part was coming up with a minimal example. My best advice (and this is way easier said than done) is to start to narrow by strategically sub'ing `undefined` until you get to the expression that's causing the problem, then remove all the extraneous deps and code, turn it into a self-buildable package and link to that in your ticket. It's a lot of work but I do recommend reporting, unlike some other languages my experiences reporting has bugs been 100% positive. The GHC devs are very approachable and responsive.
Thanks! I plan to keep going :) 
&gt; I find the term (State h), or rather (L.State h) confusing. Its a type right? No it's not! But now I understand what's causing your confusion. In the definition newtype State s a = State { runState :: s -&gt; (a,s) } the name `State` is used twice: once as a *type* constructor, and once as a *value* constructor. It wouldn't make sense to pattern match on the type constructor `State`. In fact, type constructors aren't even in scope at the value-level, so there is no ambiguity as to which of those two `State` is meant when it appears in a pattern: the `State` in `State h &gt;&gt;= f = ...` is definitely the value constructor, not the type constructor. It would probably be less confusing if the names were different, I'll use the following names in the rest of this comment: newtype TyState s a = MkState { runState :: s -&gt; (a,s) } &gt; Why would a type *alone*... I don't undertand what you mean by "alone" here. &gt; ...be used in a bind expression? The `State h &gt;&gt;= f ` on the left of the equal sign is not an expression! It's a pattern. Recall the following instance from [chapter 8](http://learnyouahaskell.com/making-our-own-types-and-typeclasses#a-yes-no-typeclass): instance YesNo (Maybe a) where yesno (Just _) = True yesno Nothing = False This gives a definition for the `yesno` method of the `YesNo` type class. It does so by pattern-matching on `Maybe`'s two value constructors, `Just` and `Nothing`. Similarly, instance Monad (TyState s) where (MkState h) &gt;&gt;= f = MkState $ \s -&gt; let (a, newState) = h s (MkState g) = f a in g newState gives a definition for the `(&gt;&gt;=)` method of the `Monad` type class. It does so by pattern-matching on `TyState`'s single value constructor, `MkState`.
To narrow it down like that in the future, try searching GHC's source code. That might sound scary, but the hits for the specific part of the "isStrictPattern" panic message are usually enough to get a sense of what's going wrong (e.g. ApplicativeDo is involved). Great job opening a ticket! Edit: I usually use github.com/ghc/ghc for the initial attempt, though those search results seem less-and-less complete nowadays.
Thanks for the heads up! I'm going to forge ahead with the new posts and can make a note letting readers know that tasty-discover is updated in recent LTS versions.
`let listl = [1, 2, 3]`
Recent versions of GHC let you omit it.
That's new in GHC 8.something.
This looks like something that could work. Let me give it a shot.
I like this direction the most (the subvalues). Instead of trying to please the database layer and web api layer at the same time, it simply breaks down things. And the result is even more clean (and more domain (regardless of the simplicity of the domain at hand) focused).
Had it not been for /u/alexbiehl's tip that this is probably related to `ApplicativeDo`, I would not have been able to come up with a minimal example so quickly.
&gt;I think is an unfair expectation. IDEs for other languages cost money. They're simply a lot of work. There are paid versions and limited free versions (take, for example, Idea/Idea CE). I agree that at the moment none of the big companies has invested into a commercial feature-rich IDE that can sponsorise a free community edition. However, any newcomer to python world is greeted by PyCharm/jedi/Anaconda. What is a Haskell acolyte greeted with? &gt; Maybe a better description would be that Haskell has some truly great tooling/libraries (such as hoogle, haddock, criterion, QuickCheck), even if it's lacking in other ways. Agree &gt; Certainly haven't gotten many cryptic compiler errors. Depends. Try to make a rookie mistake with `foldr`, the compiler exposes with mention of traversables and other stuff. For a newcomer this would be daunting - they need to fold a list, not decipher the what traversables are. &gt; You might be interested in HaRe. So far it has an Emacs plugin + a partial vim plugin. The vim plugin can in fact rename a function across modules, which is nice. I'll take a look, thank you. &gt; Break things down into small functions, and test those with hspec. That's why we need a "extract method" refactoring tool... 
 makeClassyPrisms
Does GHC really spend a whole word on the `C#` constructor even though it's the only possible one for the type? It's because of `undefined`, right?
There are times (eg when trying to work out kinks with a production build, etc) when long build times can be a pain, but I've never found it to be an issue in the course of usual development activities... eg when I compile in emacs the changes are loaded into the REPL instantly.
The compiler / build system is ususally smart enough (and this is the case for GHC) to only recompile the modified bits, not the whole beast :)
No, in fact I rarely compile my code (usually less than once per day). Rather, you can simply type check your code (without compiling it) which happens quickly. You can also evaluate functions in the repl to try them if type checking doesn't give you enough assurance. However, if you're in a situation where the type checker and repl are unable to help you and you need to compile frequently (e.g., building a native UI where you need to compile to see how it looks), then probably yes.
Cool, please report back!
Trying to calculate odds of Redmonds being able to have its cake and steal it too, but keep getting an overflow.
Nope - doesn't work. You can't mutate a `NewOrder` to `ExistingOrder` by just defining the extra fields. You have to copy existing fields all over again!
Can you post your code? Works fine for me. data Order' confirmationStatus time = Order { ordCustomerName :: String , ordCustomerEmail :: String , orderStatus :: confirmationStatus , ordCreatedAt :: time , ordUpdatedAt :: time } type NewOrder = Order' () () type ExistingOrder = Order' String Int newOrder = Order "Foo Bar" "foo@bar.com" () () () existingOrder = newOrder { orderStatus = "Unconfirmed" , ordCreatedAt = 100 , ordUpdatedAt = 200 } 
Check also this trick with RecordWildCards and DuplicatedRecordFields extensions (don't know if it qualifies as good use or abuse, but still): newtype Encrypted = Encrypted String deriving Show data UserApi = UserApi { name :: String, password :: String } deriving Show data UserDb = UserDb { userId :: Int, name :: String, password :: Encrypted } deriving Show toUpdate :: Int -&gt; UserApi -&gt; UserDb toUpdate key UserApi{..} = UserDb{userId = key, password = Encrypted password, ..} And then: λ toUpdate 1 $ UserApi "bart" "Hunter123" UserDb {userId = 1, name = "bart", password = Encrypted "Hunter123"} 
That's kind of cool. I wouldn't recommend it, but it is kind of cool!
I like `f &lt;$&gt; a &lt;*&gt; b` more than `liftA2 f a b`.
I do tend to write the first completely out of habit but I remember this advice from the base source &gt;Some functors support an implementation of 'liftA2' that is more efficient than the default one. In particular, if 'fmap' is an expensive operation, it is likely better to use 'liftA2' than to 'fmap' over the structure and then use '&lt;*&gt;'. an example of this I couldn't tell you though. Anyone else?
Haskell can be interpreted! That's what happens when you work in GHCi (the interactive shell), or use `runghc` to run your programs. It's so much faster than waiting for a full compile to native code. Also, there's a thing called 'incremental compilation' that allows the compiler to discover what changed and only recompile its dependencies. See [this article on using the REPL (GHCi is one](http://chrisdone.com/posts/haskell-repl), and [this one on balancing incremental compilation with bytecode interpretation](http://chrisdone.com/posts/making-ghci-fast)
As someone just getting started with Haskell: Thank you! That is a great help! It would be cool however to have the type signatures so that one could have a more complete mapping from the java world into the Haskell world.
Boxed types can often end up unboxed after optimization if you're careful. Particularly when you don't put them in boxes fields and the strictness analyzer finds them to be strict.
WSL is certainly a work in progress. As others have said, the GHC you've installed is an old version, 7.10.3. If I recall correctly, programs compiled by later GHC versions don't run properly on Creators Update WSL - their startup time is very slow. I believe the next release of WSL will fix that. What's your use case for ghc on WSL?
Where did you see that? `liftA2` is not a member of the `Applicative` class, and cannot be overloaded. The only way that could be true is via rewrite rules. I wouldn't expect that to hold very often at all.
This was my reaction as well. `liftAn` has to be magically rewritten for each hardcoded `n`, whereas `a &lt;$&gt; b &lt;*&gt; c &lt;*&gt; ... &lt;*&gt; z` works for any `n`.
[Here you are!](https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#liftA2) Is it not? Seems to be in base, where I've read that.
Oh! That appears to be new! [I was looking at the second most recent version](https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#liftA2), where it was not a member. Looks like this changed in the GHC 8.2 release.
This is 100% user error. Everything is working as it should.
NewOrder will come from a Servant endpoint eventually, right? At that point it's not possible to keep it polymorphic in certain fields. You will be forced to pick concrete types for every field. Hence the problem I was referring to. 
I've never used Servant. What sort of types do the Servant endpoints have?
I'm quite surprised to see a degree as a qualification for a position in an Israeli startup. At the startups I've worked at most people didn't have a degree, and even at Google where most people did have degrees, not having one didn't get in my way. Anyhow, good luck!
I don't think it really matters, what matters is that you can write a function: updateOrder :: NewOrder -&gt; ExistingOrder updateOrder newOrder = newOrder { orderStatus = "Unconfirmed" , ordCreatedAt = 100 , ordUpdatedAt = 200 } no?
Yes, ideally. I don't know enough about Servant to understand if or why that wouldn't be possible.
The final endpoint code looks like a regular function. But before your endpoint (function) is called, Servant runs FromJSON on the request before passing it to your function. -- endpoint definition for /lambda/campaigns/client/:clientId/subuser/create :&lt;|&gt; "lambda" :&gt; "campaigns" :&gt; "client" :&gt; Capture "ClientId" ClientId :&gt; "subuser" :&gt; "create" :&gt; (Post '[JSON] Subuser) -- actual function definition campaignAddSubuser :: ClientId -&gt; AppM Subuser campaignAddSubuser clientId_ = runForSystem $ createSubuser clientId_ 
Can't your `FromJSON` instance work with the record with some polymorphic fields? 
`Char` is treated like any other datatype with respect to code generation. But GHC has a small optimization for `Char` in the garbage collector: If the garbage collector finds a `Char` and this char is in ASCII range it gets replaced by a statically allocated one (c.f. https://github.com/ghc/ghc/blob/598472908ebb08f6811b892f285490554c290ae3/rts/sm/Evac.c#L677). The same optimization happens for `Int`s in the range [-16, +16]. 
Cryptonite is the go-to cryptography library in Haskell. Generating a salt is trivial, all you need is to to generate a random bytestring of a certain length (see `getRandomBytes :: ByteArray byteArray =&gt; Int -&gt; m byteArray` at [Crypto-Random](https://hackage.haskell.org/package/cryptonite-0.24/docs/Crypto-Random.html). Make sure you generate a new salt each time you hash something - reusing salts reduces security. With that being said, with the [BCrypt](https://hackage.haskell.org/package/cryptonite-0.24/docs/Crypto-KDF-BCrypt.html) module, a salt is automatically generated when using `hashPassword` and is embedded to the hash output, and the `validatePassword` checks that salt. So I'd recommend BCrypt for maximal simplicity. (Other KDFs require generating a salt and storing it manually) 
I would say cryptonite is the defacto library for cryptography. pwstore-fast uses the [cryptohash](https://hackage.haskell.org/package/cryptohash) library which has been merged into cryptonite and deprecated. [This example stack script](https://gist.github.com/brynedwards/48aee3cd7f5bc739283a17e4576da6c7) should output the same hash value as [this python snippet](https://docs.python.org/3/library/hashlib.html#hashlib.pbkdf2_hmac).
&gt; In the definition &gt; &gt; `newtype State s a = State { runState :: s -&gt; (a,s) }` &gt; &gt; the name `State` is used twice: once as a type constructor, and once as a value constructor. Now I see what you mean! As the `State` in `State h` is a value constructor the latter is a pattern match for "extracting" `h`. (I understand pattern matching but was thrown by the nature of `State`. Its almost as confusing as the way `s`is used. Why didn't he just use `s'` for the lambdas? ) As for _alone_ I meant that if `State` were a type constructor `State h` would be a just a type and this type _alone_ would appear on the LHS of `&gt;&gt;=` .. but that's no longer important as the confusion has been cleared up. Thanks a bunch for patiently helping me sort though this. 'Much appreciated.
&gt; Cryptonite is the go-to cryptography library in Haskell. I'd also point out the [more recent `raaz` library which recently published its 0.2 release candidate](https://www.reddit.com/r/haskell/comments/6qpaw3/raaz_020_package_candidate_up_on_hackage/) which is a very promising alternative to `cryptonite` with a strong focus on strong typing to avoid common errors and good API documentation.
&gt; uses the cryptohash library which has been merged into cryptonite and deprecated. Shamless self-plug: There are non-deprecated stable, maintained, API-compatible &amp; improved forks of the `cryptohash` package for the more popular hash algorithms used in network protocols and which are heavily used (read dogfooded) in Haskell's infrastructure: - [`cryptohash-sha256`](https://hackage.haskell.org/package/cryptohash-sha256) - [`cryptohash-sha512`](https://hackage.haskell.org/package/cryptohash-sha512) - [`cryptohash-sha1`](https://hackage.haskell.org/package/cryptohash-sha1) - [`cryptohash-md5`](https://hackage.haskell.org/package/cryptohash-md5) Which may be more advisable if all you need is the primitive for a single hash function [which takes up around 40KiB rather than dragging in a monolithic 14MiB kitchensink crypto lib which does more than you care for and keeps evolving quickly](https://www.reddit.com/r/haskell/comments/5lxv75/psa_please_use_unique_module_names_when_uploading/dbzegx3/).
Thanks /r/hvr_ for the advertisement ;-) but raaz does not yet have a password hashing scheme like argon2. So as of now no `raaz` is not an alternative and I do not think `cryptonite` has either. It is another matter that you can implement some salt+password hashing scheme using the primitives in raaz. We have hashing and CSPRG. But there is nothing like argon2 yet. That said high level interface of things like password hashing etc are in the todo list. https://github.com/raaz-crypto/raaz/issues/276
I don't think you can "summon the constructors for standalone deriving" in the way you're thinking of. That being said, you can emulate what standalone deriving does quite easily with Template Haskell itself, and there are several libraries which accomplish this: * [`deriving-compat`](http://hackage.haskell.org/package/deriving-compat) emulates deriving `Bounded`, `Enum`, `Ix`, `Eq`, `Ord`, `Read`, `Show`, `Functor`, `Foldable`, and `Traversable` * [`generic-deriving`](http://hackage.haskell.org/package/generic-deriving) emulates deriving `Generic` and `Generic1` * [`th-lift`](http://hackage.haskell.org/package/th-lift) emulates deriving `Lift`
I like https://hackage.haskell.org/package/scrypt
fwiw, `cryptonite` does have an implementation of [argon2](https://hackage.haskell.org/package/cryptonite-0.24/docs/Crypto-KDF-Argon2.html) but it’s pretty barebone and last I tried it I ended up using /u/ocharles’ argon2 package (I’m also not super found of the cryptonite API).
Though my library is deprecated in favour of crpytonite's implementation. I might change it to proxy to crpytonite's with a nicer API, rather than building phc-winner
Why did you deprecate it?
Yeah seeing that it was deprecated made me a bit sad :( The thing that I was missing the most from cryptonite’s API was a way to use the textual encoding.
Well, the pointer might also lead to an unevaluated function. Or weird runtime things like black holes when running multi threaded, I guess. GHC tries to pass it unlifted on the stack or in registers when used strictly, though.
Last time I run into this it really surprised me but I figured I was just missing some api. Is there really no builder equivalent for strict text that uses ST internally? 
I doubt it's a hard requirement
problem exists between keyboard and chair :)
There is no Builder equivalent to my knowledge. Spoiler: Strict text ST is coming in a later post. :)
I've met some of these guys a few years ago. They were pretty cool. I hadn't heard anything about them again until now. Tel Aviv is also a cool place to live!
Oh my goodness. I have never realized ghc had a flag for this. This just speed up my code-build-debug cycle a bit. For the benefit of others, this can be done with: cabal build --ghc-options=-fno-code
I've actually implemented this, and it's sitting on a branch. Now that you reminded me, I'll try to get it cleaned up and merged in this weekend! *EDIT*: by "this", I mean upcasting based on just types between arbitrary products, as long as the casting is unambiguous.
&gt; Another option is to use my package Metamorphosis which has been exactly to solve this problem. You can generate from a type it's parameterized version as well as converters. It also allowed to generate subtype or extend or merge types into other (with again generated converters). After a **lot** of brainstorming we were *about* to write something on the same lines as Metamorphsis! Thank you for beating us to to it. It's good to know that we're not the only ones facing these pains. Would you be open to feedback on the library? Currently the [usage examples](https://github.com/maxigit/Metamorphosis/blob/3b67935c44eecc87bf42e72e58be5e5556049679/test/ExampleSpec.hs#L41-L53) seem too complex and can probably be simplified for common use-cases. Also, is it necessary to use `DuplicateRecordFields`? Can the library be extended to do the same thing by simply dropping prefixes from record fields? 
I don't use it directly -- it's just a normal part of the [interactive Haskell mode for emacs](https://wiki.haskell.org/Emacs/Inferior_Haskell_processes#Interactive_Haskell_mode). I just type `C-c C-l`! It's basically a split-screen view, with one half being your code and the other being a smart repl which will display warnings/errors and let you evaluate expressions.
&gt; focus on strong typing to avoid common errors and good API documentation. We now have type-level guarantees to prevent good documentation!
I believe you're thinking of the [class-based reflection proposal](https://github.com/ghc-proposals/ghc-proposals/pull/69). I hadn't previously considered the potential overlap between the two, but I think you're right. It seems like the `deriving via` syntax could just be sugar over the coercion you described above.
When they said fmap is expensive they didn't mean more expensive than `(&lt;*&gt;) . pure` because that isn't a thing that happens. 
This could also be written as: origami' :: (s -&gt; l -&gt; s) -&gt; (r -&gt; s -&gt; s) -&gt; s -&gt; [Either l r] -&gt; s origami' fl fr = foldr (\a s -&gt; either (fl s) (flip fr s) a) Just thought I would add this for kicks.
I'm very confused by what this does. Maybe this will help: data T = T :-&gt; Int | Int :&lt;- T | Nil deriving Show calculate = origami (:-&gt;) (:&lt;-) Nil display = mapM_ (\x -&gt; print x &gt;&gt; print (calculate x) &gt;&gt; putStrLn "") [ [ Right 1 ] , [ Right 1, Right 2 ] , [ Right 1, Right 2, Right 3 ] , [ Right 1, Right 2, Right 3, Left 4 ] , [ Left 1 ] , [ Left 1, Left 2 ] , [ Left 1, Left 2, Left 3 ] , [ Left 1, Left 2, Left 3, Right 4 ] , [ Left 1, Right 2 ] , [ Right 2, Left 1 ] ] &gt; display [Right 1] 1 :&lt;- Nil [Right 1,Right 2] 1 :&lt;- (2 :&lt;- Nil) [Right 1,Right 2,Right 3] 1 :&lt;- (2 :&lt;- (3 :&lt;- Nil)) [Right 1,Right 2,Right 3,Left 4] 1 :&lt;- (2 :&lt;- (3 :&lt;- (Nil :-&gt; 4))) [Left 1] Nil :-&gt; 1 [Left 1,Left 2] (Nil :-&gt; 1) :-&gt; 2 [Left 1,Left 2,Left 3] ((Nil :-&gt; 1) :-&gt; 2) :-&gt; 3 [Left 1,Left 2,Left 3,Right 4] 4 :&lt;- (((Nil :-&gt; 1) :-&gt; 2) :-&gt; 3) [Left 1,Right 2] 2 :&lt;- (Nil :-&gt; 1) [Right 2,Left 1] 2 :&lt;- (Nil :-&gt; 1) 
Is there a good reason for the Int range being so small there? I feel like going an order of magnitude or two bigger would be beneficial.
Careful, John! mary :: String mary = origami (&lt;&gt;) (flip (&lt;&gt;)) mempty $ [ Right "sight" , Left "she" , Right "on" , Right "code" , Left "can" , Right "skip" , Left "read" , Left "a" ] 
Are you sure? The recursive call in the `Left` case doesn't look like it follows the `foldr` pattern to me.
Ah, now I'm a bit less confused. data T = T :-&gt; Int | T :&lt;- Int | Nil deriving Show calculate = origami (:-&gt;) (flip (:&lt;-)) Nil display = mapM_ (\x -&gt; print x &gt;&gt; print (calculate x) &gt;&gt; putStrLn "") [ [ Right 1 ] , [ Right 1, Right 2 ] , [ Right 1, Right 2, Right 3 ] , [ Right 1, Right 2, Right 3, Left 4 ] , [ Left 1 ] , [ Left 1, Left 2 ] , [ Left 1, Left 2, Left 3 ] , [ Left 1, Left 2, Left 3, Right 4 ] , [ Left 1, Right 2 ] , [ Right 2, Left 1 ] ] &gt; display [Right 1] Nil :&lt;- 1 [Right 1,Right 2] (Nil :&lt;- 2) :&lt;- 1 [Right 1,Right 2,Right 3] ((Nil :&lt;- 3) :&lt;- 2) :&lt;- 1 [Right 1,Right 2,Right 3,Left 4] (((Nil :-&gt; 4) :&lt;- 3) :&lt;- 2) :&lt;- 1 [Left 1] Nil :-&gt; 1 [Left 1,Left 2] (Nil :-&gt; 1) :-&gt; 2 [Left 1,Left 2,Left 3] ((Nil :-&gt; 1) :-&gt; 2) :-&gt; 3 [Left 1,Left 2,Left 3,Right 4] (((Nil :-&gt; 1) :-&gt; 2) :-&gt; 3) :&lt;- 4 [Left 1,Right 2] (Nil :-&gt; 1) :&lt;- 2 [Right 2,Left 1] (Nil :-&gt; 1) :&lt;- 2 
I use the ghc-mod package for atom, and it's great. Every time I hit save it type checks my code, and highlights errors and warnings inline. It seems to run decently fast.
In general we can show fr b (origami fl fr (fl nil a) cs) = origami fl fr nil (Left a : Right b : cs) = origami fl fr nil (Right b : Left a : cs) From which I claim origami fl fr nil xs = foldr fr (foldl fl nil as) bs where (as, bs) = partitionEithers xs or origami fl fr nil = uncurry (foldr fr . foldl fl nil) . partitionEithers
Actually I think you are right. I really would like to be able to write this type of fold in terms of foldr (if it is even at all possible).
*Main* {-# LANGUAGE TemplateHaskell #-} module Main where import Derp import Data.Typeable (Proxy(Proxy)) main :: IO () main = print $(derp (Proxy :: Proxy Int)) *Derp* {-# LANGUAGE TemplateHaskell , ScopedTypeVariables #-} module Derp where import Data.Typeable (Proxy) import Language.Haskell.TH import Language.Haskell.TH.Lib derp :: Num a =&gt; Proxy a -&gt; Q Exp derp _ = [| 123 :: a |] Errors Main.hs:9:8: error: • Ambiguous type variable ‘a0’ arising from a use of ‘print’ prevents the constraint ‘(Show a0)’ from being solved. Probable fix: use a type annotation to specify what ‘a0’ should be. These potential instances exist: instance forall k (s :: k). Show (Proxy s) -- Defined in ‘Data.Proxy’ instance Show Ordering -- Defined in ‘GHC.Show’ instance Show Integer -- Defined in ‘GHC.Show’ ...plus 23 others ...plus 57 instances involving out-of-scope types (use -fprint-potential-instances to see them all) • In the expression: print (123 :: a_a3V5) In an equation for ‘main’: main = print (123 :: a_a3V5) | 9 | main = print $(derp (Proxy :: Proxy Int)) | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Main.hs:9:16: error: • No instance for (Num a) arising from the literal ‘123’ Possible fix: add (Num a) to the context of an expression type signature: forall a. a • In the first argument of ‘print’, namely ‘(123 :: a_a3V5)’ In the expression: print (123 :: a_a3V5) In an equation for ‘main’: main = print (123 :: a_a3V5) | 9 | main = print $(derp (Proxy :: Proxy Int)) | ^^^^^^^^^^^^^^^^^^^^^^^^^ I've never used template haskell before, so if this is a blunder, my apologies!
Is bcrypt no longer the gold standard for password hashing?
Dammit I love Emacs 
Does cryptonite, raaz, or some other library work for client-side JavaScript (GHCJS)? /u/ryantrinkle What crypto library is normally used with Reflex?
I've suffered* for a long time with this in haskell. I've put up with 1-2 minute compilations on some of my larger codebases. It put a huge dent in my usually tight feedback loop of iterating on code. Especially since I come from a JIT-compiled language, which ran in a matter of seconds on larger codebases as well. &gt; _\* Suffer may be a strong word, as it is only a minor annoyance every time it happens. But after a while it started to build up quite a bit of frustration for me, as if it's a death by a thousand papercuts._ And on one day I found [`ghcid`](https://hackage.haskell.org/package/ghcid), which was a godsend for me. Suddenly I can have a ~1 second feedback loop again. Traded for about 500MB of constant increased RAM usage in the background—but for me that's worth it.
Good to hear the issue was resolved. Kinda reminds me of how I waited so long before becoming a tinkerer with efficiency. So so so many hours of programming where I used the mouse, no keyboard shortcuts, nothing. Now I'm freaking addicted to shortcuts to the point where I'll spend hours of configuring to... not even save time, but just for comfort. Thanks for sharing :-)
This is the expected behavior of `ScopedTypeVariables`. If you look at: derp :: Num a =&gt; Proxy a -&gt; Q Exp derp _ = [| 123 :: a |] You'll notice that you didn't declare the type variable `a` with `forall a` in the type signature. Type variables only scope over the bodies of functions under `ScopedTypeVariables` when an explicit `forall` is used, so if you leave off the `forall`, GHC assumes you are referring to a fresh `a`. Changing the type signature to: derp :: forall a. Num a =&gt; Proxy a -&gt; Q Exp Should do the trick.
I'm not sure I understand what the relationship between these proposals is at all. To me, they accomplish very different things: 1. The class-based reflection proposal would give you a way to reify an explicit dictionary value as a class constraint. 2. The derive-through-newtype proposal would give you a more flexible way to use GND. What am I missing?
Generally, in-browser crypto is seriously problematic, even if you have good algorithms for doing it. The crux of the issue is that any attacker who can compromise your browser, connection, or server can generally also modify the JavaScript being run, which allows them to exfiltrate whatever data they want in a variety of ways. On the other hand, an attacker who *can't* compromise the connection or server is dead in the water, regardless of any client-side crypto. That being said, I'm sure there are situations where it's helpful, and in that case I'd strongly advise using browser builtins if possble, such as [WebCrypto](https://www.w3.org/TR/WebCryptoAPI/) (though I haven't evaluated it specifically), rather than anything running in JavaScript. Timing attacks are no joke, and I wouldn't at all trust interpreted/jitted languages to avoid leaking secrets through that channel. Not to mention, I would expect builtins to be much faster than anything that could be written in JS.
Oops, that was a mistake in translating to reddit. I get the same errors with the forall!
Although I agree with everyone else's reassurances, I myself have exactly that negative experience: compile times on a fresh machine are about 1-2 hours, compile times with a cached snapshot but a clean checkout are about 20-30 minutes, and incremental recompiles are typically 10 minutes. The reasons I'm in this bad case include: * frequent changes that need testing and not just typechecking * changes to a part of the project with many reverse dependencies (i.e. deep in the module/package hierarchy) * code that uses Template Haskell * code that can't run in GHCI due to its use of Haskell internals Not all of these apply for every change, but enough apply often enough. The feeling of latency is also made worse by comparisons to a Python project that I'm working on, where the edit-test loop is measured in seconds. Even so, I still prefer working on the Haskell and still feel that I'm more productive in it because I need that many fewer loop to get correct Haskell code.
Yeah that sounds kinda.. unfortunate. Wonder why these issues are happening for you, and if there are any solutions? Also, How does any C, C++ developers not go insane? Do they have the same type of workarounds mentioned in this thread so far? I use Gentoo, so I get to watch compilations often (Although I don't lol. I just put it in a different workspace and do other stuff) and I'm shocked at how long Chromium takes to compile. No way people wait so long, or they do shit tons of changes before compiling. I personally am used to saving &amp; checking the browser very frequently, although I've only ever done web development.
bcrypt is still just fine, I'd even say PBKDF2 is fine, in the sense that "If you're correctly using PBKDF2 (or better) to store passwords, then password storage is likely not the worst of your issues at all." The main advancement is that PBKDF2 can be computed very efficiently by GPUs. bcrypt is much better against GPU like attacks, but still fails from attacks that involve things like ASICs or FPGAs. Advancements like scrypt or argon2 go a step further, and are both generally hard[1] on GPUs and ASICs/FPGAs, so they resist the full gamut of modern attacks. They also add a lot more functionality for various use cases. Basically: if you just want good password storage, yes, bcrypt will serve you well for a long time to come, most likely, and all you need to do is increase the number of rounds occasionally to keep up with hardware. [1] This is a big oversimplification, because in practice argon2 and scrypt can be used for things like cryptocoins where ASICS *are good*. But this is because they use different parameters/configurations in these modes; the "cryptocoin parameters" are far too weak for secure password storage, so you wouldn't use them anyway.
You're right. They do accomplish different things. I was kind of imagining a different world where haskell had more facilities for working with typeclass dictionaries. I imagined something like treeowl's reflection proposal but strengthened it in the following ways: (1) it works for typeclasses with multiple methods and (2) you could somehow write a typeclass instance using a reified dictionary like in [nifr's example above](https://www.reddit.com/r/haskell/comments/6stsxz/looking_for_the_derive_through_newtype_proposal/dlfuuo1/). If the reified typeclass dictionaries were first-class values that could be coerced, then both GND and the "Deriving Via" proposal (which I sort of view as GND in reverse) could be implemented as syntactic sugar for these coerced instances. Obviously, this isn't how GND actually works in GHC, but that's the trail my thoughts were headed down.
Wow and this API looks really clean and simple to boot!
Well, the entirety of https://protonmail.com uses JavaScript to encrypt/decrypt locally (because even ProtonMail don't want access to your encrypted emails). Their site is quite responsive. I was just wondering if we have such local browser crypto functionality available yet through some GHCJC-compatible Haskell libraries. I'm looking forward to a widespread browser support for WebCrypto.
As always: shoot comments or questions and I'll do my best to answer! :) 
Anything written in pure Haskell should work just fine; libraries based on C would need to have [shims](https://github.com/ghcjs/shims) written. JavaScript-based libraries can be bound to quite easily using [GHCJS's JavaScript FFI](https://github.com/ghcjs/ghcjs/blob/master/doc/foreign-function-interface.md). My guess is that almost everything you'd want from a crypto library will either be totally pure or require IO (to get entropy, e.g.) - very little will probably need reactive bindings (i.e. reflex-specific bindings).
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [ghcjs/ghcjs/.../**foreign-function-interface.md** (master → ee742e0)](https://github.com/ghcjs/ghcjs/blob/ee742e015edb8ba8bc443d7869361f312ddb4cd7/doc/foreign-function-interface.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dlhceja.)^.
Sorry, I didn't read the call site carefully enough. This, too, is expected behavior. The quotation `[| 123 :: a |]` creates a `Q Exp` value, and it only quotes types that are present at `derp`'s definition site. So when you splice in `derp` elsewhere, you will *always* get `123 :: a`, regardless of the argument you pass in to `derp`. This explains why you get the error message in `Main`, as `a` is free in the definition of `main`: λ&gt; main = print $(derp (Proxy :: Proxy Int)) &lt;interactive&gt;:24:16-40: Splicing expression derp (Proxy :: Proxy Int) ======&gt; 123 :: a_a1Pj &lt;interactive&gt;:24:16: error: • No instance for (Num a) arising from the literal ‘123’ Possible fix: add (Num a) to the context of an expression type signature: forall a. a • In the first argument of ‘print’, namely ‘(123 :: a)’ In the expression: print (123 :: a) In an equation for ‘main’: main = print (123 :: a) This is in contrast to quoted *expressions*, which can be supplied via arguments. For instance, you can do this: f arg = [e| arg |] The inferred type of `f` is: λ&gt; :t f f :: Language.Haskell.TH.Syntax.Lift t =&gt; t -&gt; ExpQ Where `Lift` is: class Lift t where lift :: t -&gt; Q Exp That is, `f` "lifts" its argument `arg` to a `Q Exp` using its `Lift` instance. So you genuinely can splice in different results from `f` depending on its argument: λ&gt; $(f 2) &lt;interactive&gt;:19:3-5: Splicing expression f 2 ======&gt; 2 2 λ&gt; $(f "hello") &lt;interactive&gt;:20:3-11: Splicing expression f "hello" ======&gt; "hello" "hello" However, there is not an equivalent trick for types, as types are quoted syntactically.
I would love to get some feedback from this library and even some helps. What do mean by the examples is too complex ? Is it too complex as an example (I mean for pedagogical view) or too complex to use ? Metamorphosis is still experimental (I haven't put it on Hackage) yet, but I'm using it on production. `metamorphosis` is at the moment a big function which does everything and could do with some wrappers for common usage. Basically, you can thing of Metamorphis, as a big `sed` on types. You get a type description as a table, given for each field, it's type, contructor, field name, type etc and you can modify everything, and it will create everything needed (new types, new class, etc .. ) with the field you need. It doesn't need `DuplicateRecordFields`, you can just modify the `fdFieldName`. For example, You can add a prefix "pf" by adding ` fdFieldName %~ fmap ("pf"++)` or a suffix 'F' with `fdFieldName %~ fmap (++"F")`, or remove the two first letters with `fdFieldName %~ fmap (drop 2)` etc .. In fact you can pass any function you want to transform a field name. You need the `fmap` because the field name is actually a `Maybe String`, because metamorphosis also works for non record type, which don't have named field. I use pointfree style, but you can of course use lambda. You can use function if there as in a separate file (TH limitation). The main feature of Metamorphosis, is that it really allows to map many types to many types and manage all the conversions (even if some fail). It doesn't work for Enum yet, but I'm planning to do it at some point .
I have no idea. A wider range sounds reasonable though.
I'm still having difficulty seeing how your proposed idea would be a generalization of `deriving via`. Can you give a concrete example, using pseudocode, and explain how `deriving via` would be syntactic sugar using that example?
I know it might seen to complicated to use TH for that, but the main reason I've gone that way is that, if you need to do real stuff with your types, then it's much cleaner to use plain types that parametrized ones and only use parametrized ones when you actually need it (i.e. validation). Once you have a valid value, you can forget about the complicated type and use the simple one. Before doing Metamorphosis, I tried the generic way. You can (in theory) for example convert a plain record to an extensible record, do your validation, "sequence" it and then go back to your record. However, In practice, I ended up spending literally hours to try to make validation code to type check (mapping a function with constraint over fields is a nightmare and need a few extensions to be activated). Metamorphosis can also generate that type of function which type check without any extension (other than TH obvioulsly). 
Wrapping computations in functions is one method of doing it. for example, instead of returning an `Int`, return `Unit -&gt; Int`. also https://pursuit.purescript.org/packages/purescript-lazy/3.0.0
I do try to document as much as possible the code base for raaz. Not just the haskell code but also the C code within. For me good documentation is as important as all the other goodie.
Unlikely as raaz uses C for the primitives.
It was just a joke on his ambiguous phrasing. I'm actually quite content with the documentation available on Hackage for the majority of packages I use.
Just a note: Be careful not to use a GHC 8 onwards with WSL, because the memory manager of WSL doesn't cope well with huge amounts of unmapped memory yet. The GHC 8 RTS will reserve 1TB of uncommited virtual address space, both for itself and for compiled programs. It's possible to build GHC 8 without that functionality ([bindist here](https://github.com/sgraf812/ghc-dlas)), but that requires somewhat unergonomic installation steps. As long as you stay with the official (somewhat outdated) Haskell Platform package, that shouldn't be a problem, though. Happy hacking :)
Yeah, well, the error message is less than helpful. Glad that newer GHCi versions don't have that weakness.
 &gt; quickCheck (\(xs :: [Either Int Int]) -&gt; origami (flip (:)) (:) [] xs == origami' (flip (:)) (:) [] xs) *** Failed! Falsifiable (after 7 tests and 4 shrinks): [Left 0,Left 1]
Sorry for being so dense. 
As /u/gilmi points out, there is a way to get laziness locally in a PureScript program. This works out well for many things, but you lose a lot of the benefits of having laziness everywhere and all the way down to the leaves of your data. Actual lazy evaluation probably would require some sort of runtime. Or maybe we could try something like CPS, but without tail calls in the runtime, it's going to get unpleasant quickly.
Nice reasoning!
&gt; `undefined` [Exactly](https://stackoverflow.com/a/39985957/388010). It's lifted, which implies it is boxed, thus represented by a pointer. Strictness analysis can identify a binding as strict in its scope (e.g. `let` body, body of the lambda), which allows to change evaluation order from call-by-need (lazy evaluation) to call-by-value (strict evaluation) without changing semantics. E.g., those strict bindings can be unlifted before entering the body. This then allows further unboxing through the worker/wrapper transformation (which applies to more cases than just `data Char = C# Char#`).
http://hackage.haskell.org/package/crypt-sha512 is an option too, but I only know that my Ubuntu uses that algo...
Very cool.
Thanks very much for the help! I should be able to get something working using that
&gt; Does anybody else feel this way? Yes. I resigned. A few months ago. Because of the same situation. After years of the agony that i feel from your text. Though i was in a much better situation than you, because my languages were C++, C#. But still. My management also did not give a fuck. I think you should resign too. Find a Haskell job. It is possible nowadays. With Haskell we will : * Get back some of the fun in programming. * Learn programming idioms. Improve as programmers. * Build software a few times faster than with the current popular languages. This also must imply salary increase in the long time. We have a limited time in our life. To be happy and to build our carrier. Currently no production language other than Haskell deserves this time.
Any project of any reasonable size doesn't compile and link in the same sequence. It's the principle of Single compilation. https://en.wikipedia.org/wiki/Single_Compilation_Unit. What this means is that if your project has for instance 5 c files, these 5 C files can be compiled to object files at the same time and completely separate, unless of course you have a dependency between them. later all these object files are then linked into the final executable. So if you've only changed 1 file, only that file and it's dependencies have to be recompiled. This is usually done by having a build system which takes care of tracking these for you. For instance when GHC itself is compiled, the build system (make) compiles most Haskell files with `GHC -c` and all C files with `gcc -c` which means stop after generating object files. Compiling is really quick, since it doesn't have to do dependency resolution. It's just producing code. This increases the amount you can build in parallel and also decreases the amount of work you have to do when you recompile. when you use GHC on a list of files at a time, GHC tries to do a similarly smart thing. For instance I frequently work on GHC rts code or GCC codegen or mid-end code. but partial rebuilds take seconds instead of the hours for a full build. A lot of long builds on projects can be solved by having a slightly smarter way of building instead of giving all the files to the compiler in one invocation :) 
What is this for? It seems complicated.
That simulates call by name, not call by need. The performance characteristics are completely different, and there are things you simply can't do (like amortized data structures).
purescript-lazy gives you ~~CBN~~ call by need though.
Insanity has less to do with the tooling and more to do with the quality of management. For instance, when something is particularly costly, having an investigative mindset can, at least, improve awareness of more trade-offs. So for example, in the case of Chromium, why does it take so long to build? Are the costs acceptable in terms of the value they offer for the time spent? Is there room for improvement, and at what costs to process? (etc) 
Nicely written. I just reread all the articles in the serie and I have question. First, in the `LMonad` article, you said that the interface for `LMonad` is: (&gt;&gt;=) :: m a ⊸ (a ⊸ m b) ⊸ m b (&gt;&gt;) :: m () ⊸ m a ⊸ m a First of all, you explained that the first argument of `(&gt;&gt;)` should be `m ()` because the value will be discarded and that's incompatible with linearity. You said: &gt; Therefore it only makes sense to blind something that does not produce results, namely values of type m (). However, as far as I know, `m ()` produces a result, of type `()` were there is only one inhabitant (i.e: `()`). So from what I'm reading there is no reason why `()` could not be linear and why the compiler will not complain about no usage of `()`. Is this a special case implemented in the compiler? Is there any possible issue involved by this special case? Or did I missed the point? The second thing is about the type of `(&gt;&gt;=)`, you explain it with : &gt; One of my first hunches here was to use (&gt;&gt;=) :: m a ⊸ (a -&gt; m b) ⊸ m b which would make the superclasses a lot less constrained, but unfortunately we need to take in account that the a here may also be some monadic value (e.g. a ~ Maybe Int, and particularly a ~ Stream f m r). Allowing this unrestricted continuation a -&gt; m b would allow freely duplicating those monadic actions. I understand the issue, but now I wonder the limitations of this approach. Can I write something such as: f &gt;&gt;= (\x -&gt; pure (if predicate x then x else -x)) the involved function is clearly not linear for `x` because it uses it two times (or three ? each branch of the if account for one or two uses?). By the way, thank you for your work, I'm really exited about it.
Let's start with the reflection proposal. I'm going to change it by adding an `unreify##` method. So, we end up with this: class s ~ ConName c =&gt; Reflectable (s :: Symbol) (c :: Constraint) where data Reflected c :: * type ConName c :: Symbol reify## :: (c =&gt; r) -&gt; Reflected c -&gt; r unreify## :: c =&gt; Reflected c Now, I have to take another leap and make up some syntax for instantiating a typeclass using a dictionary. I'll invent a `using` keyword for this: class Foo a where ... intFoo :: Reflected (Foo Int) intFoo = ... instance Foo Int using intFoo Now, let's define `WrappedApplicative` and get `Monoid` from it: newtype WrappedApplicative f a = WrapApplicative (f a) deriving (Functor, Show) deriving newtype Applicative instance (Applicative f, Monoid m) =&gt; Monoid (WrappedApplicative f m) where mempty = pure mempty mappend = liftA2 mappend Now, the coercion part: data Maybe a = Just a | Nothing instance Applicative Maybe where ... x :: Monoid m =&gt; Reflected (WrappedApplicative Maybe m) x = unreify## y :: Monoid m =&gt; Reflected (Maybe m) y = coerce x instance Monoid a =&gt; Monoid (Maybe a) using y So, the derivingVia desugaring would just produce `x`, `y`, and the `instance using` clause. You could just inline `x` and `y`, but I made them top-level bindings to make what I'm envisioning more clear. 
To add tangentially to the SCU point: General C++ code still suffers by its C roots where compiling and linking must be from token streams rather than abstract representations that preserve shared structure. (The inclusion of modules and gradual trend toward a standard AST can't come soon enough.) 
Can I have a flat piece already? https://i.imgur.com/AO6BRQH.png
Addictive!
&gt; However, as far as I know, m () produces a result, of type () were there is only one inhabitant (i.e: ()). So from what I'm reading there is no reason why () could not be linear and why the compiler will not complain about no usage of (). If I understand correctly `()` is ok because it is very easy to use a value of type `()`: you simply pattern match on it. Thus satisfying the linearity condition. Regarding your second point you are correct: that is not a linear use of `x`. It feels like there is space to explore something like `(&gt;&gt;=) :: m a -o (a -&gt; m b) -o m b`. Maybe a class SlightlyLinearMonad m where (&gt;&gt;=) :: m a -o (a -&gt; m b) -o m b ... would make sense for some monads? Maybe there is a monad where we need to make sure that the side effects happen only once but we are free to reuse the return values however much we want? (Does `IO` fit that description?)
And if you use stack, you can make bitrot-free, executable [scripts](https://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter) and GHCi samples!
Reminds me of [this](https://youtu.be/Alw5hs0chj0). I like that miso doesn't depend on any external libraries. Also helps that you don't have to deal with React.js's problematic license.
A-ha! Thank you for patiently explaining that all to me. You're right that this would require quite a lot of extra machinery. I think I'll pile on some extra ingredients that you'd need to bake this pie in the sky ;) In particular, this part: y :: Monoid m =&gt; Reflected (Maybe m) y = coerce x Is *really* sketchy: 1. Currently, data family type parameters are all required to have nominal roles, so `coerce` wouldn't typecheck. But let's suppose they *could* have representational roles. 2. The other sketchy part is that the `c` in `Reflected c` is a type class parameter! In other words, to coerce `c`, you'd need to have a *class* type parameter be at representational role, which is another can of worms. GHC requires that you enable `IncoherentInstances` to do this, since this threatens class coherency. That being said, the "derive-through-newtype" proposals has its own can that we'd need to de-worm. But I think that would be far more manageable, personally :)
I absolutely agree that the derive-through-newtype proposal is more manageable than what I have suggested. I think what I have suggested might be more expressive, but more expressive is not always good. Plus, GND already doesn't work this way, so it would be sort of silly to do it at this point. I had not even considered the problems you brought up with representational roles, but those do seem really sketchy. I'm just glad that what I was describing actually made some kind of sense.
Typos: * In definition of liftA2, it should be `given(func, list1, list2)`, not `given(func)`. * In "Sequence on Maybe with List", it should be `r.add(list[i])`, not `list.add(i)`. I'm also not a fan of using `list` as both the name of a variable/value and the name of a "class" (when creating an empty list via `list.empty`). Other than that, good stuff!
Once it starts to speed up I noticed lag, could me my computer, not sure. It's a nice project regardless, good job!
Cool, but unfortunately it's very unresponsive. It takes maybe a quarter second to react to my keypresses. Is such delay unavoidable with GHCJS?
Hi! Thanks, that means a lot. I'm glad that you find it interesting. :) All constructors are consumed simply by pattern matching, so getting rid of the `()` is easy. More types can be nuked like this, like you probably read in the post on `take`, so I guess any `Destructible a` could work but the types get unfamiliar and I'm not sure how it would mesh with the rest. You could also extend it to any `Unrestricted a` but again, it gets messy. Your example is incorrect because the `x` is consumed already when you feed it to the predicate, the variable is therefore not available to any of the branches. I guess it wouldn't type check anyway because you feed the `x` to a probably unrestricted function `pred :: a -&gt; Bool`. There is no issue with implementing a linear `ifThenElse` in general; you check that both branches contain the same linear variables (and that they are free to use). So in the following example, `i` _appears_ twice, but is used exactly once (since you can never take both paths). f :: Bool -&gt; Int -o Int f b i = if b then i+1 else i-1 Makes sense? Did I answer your questions? :D
The issue here is that you implicitly allow copying of side effects. Indeed not the side effects of the incoming `m a`, but if that `a` is in turn monadic you can replicate whatever effects it does freely in your continuation. As you pointed out in the IRC though, the arrow will never allow any linear `a` anyway so maybe this is not a practical issue, so we can produce unrestricted monadic values in the linear monad, and do whatever we like with them in the continuation. I'm not saying it is _never_ going to be useful, but I haven't figured something out. :) 
I'm reexamining the parts of the definition of the State monad instance, in particular the bind, and comparing it with the type declaration(?) &gt; (&gt;&gt;=) :: m a -&gt; (a -&gt; m b ) -&gt; m b It seems to me that `h` corresponds to `m a`, yet in `(a, newState) = h s`, `h` acts like a function. This is odd because shouldn't we have to use `runState` to extract the function wrapped by `h`? If this is so, why doesn't `runState` appear in the definition? Also why do does `h s` return a `newState` in the tuple and not `s`? (i.e. `(a , s )`. Must the application of the function wrapped by a State monad return a new state? Next, I think `f` in `(State g) = f a` is `a -&gt; m b`. This part is clear, less I'm wrong -- please correct me if I am. Lastly, I'm guessing `g newState` is `m b` and if `g` is a monad why is it necessary to extract the function that `g` wraps and apply it to `newState`? i.e. `g newState` Thanks for your patience. 
 (&gt;&gt;=) :: m a -o (a -&gt; m b) -o m b would at least be able to ensure some correctness properties of the implementation of `&gt;&gt;=` itself, ie no using `m a` or the continuation twice. I don't quite buy your argument about `a` being monadic being a problem, but I think I'll have to play with it to make my ideas clearer. Could you share an example of wonky stuff you'd be able to do with this other definition?
No delay here on Chrome :P
Hm, as /u/thedevbrandon mentioned, it starts to lag after a while, when the screen it mostly full (at least in Firefox and Edge, on Windows). The original Flatris doesn't have this problem. Is the source code of the Haskell version available somewhere? Is their implementation similar?
&gt; React.js's problematic license. I don't use react, but I was curious and found this: https://github.com/facebook/react/issues/7293 Their FAQ pretty much claims it's not problematic: https://code.facebook.com/pages/850928938376556 Could they lie about it not being problematic and legally be okay?
I've always had more issues with Elm and Purescript as a Firefox user. I would run the same programs on Firefox and they'd be fine. A wild guess is that spidermonkey doesn't deal with more garbage and V8 isn't as affected.
Is the code for this available?
In any case, [switching to Preact](https://preactjs.com/guide/switching-to-preact) seems pretty straightforward 
Here's the source code, haven't looked through it tho https://github.com/ptigwe/hs-flatris
I prefer `f &lt;$&gt; a &lt;*&gt; b` for everyday use as well, but I think `liftA2` has some value here. I saw Tony present some pieces of code that are in this blog post while he was running a couple of sessions of the NICTA / Data61 FP course, and it seemed to really help people get a handle on what `Applicative` is for. I think presenting these examples in terms of `liftA2` did well at getting the concept across. It was followed by a note on the operator based version, and folks seemed pretty comfortable with the whole idea after it was presented in that order. I don't know how the opposite order would have gone, since explaining it to people's satisfaction during the course required a bit of "zooming in" involving the associativity of function arrows at the type level and function application at the term level and cranking the handle to see that the types all worked out. I would have been worried that presenting that first would have broken people's flow when it came to picking up the general idea behind the abstraction.
yes use the repl as you would with python or other "interactive" languages...
&gt; If GHC does not know what `a` is at compile-time, it has to look up which method dictionary to use at runtime. That could be confusing. The function does not need to *look up* for the dictionary, as in from a table or something. Rather, the function in question will *also* take a dictionary as an (invisible) argument, corresponding to the `(HexShow a) =&gt;` part of the type. The caller would need to pass in either a dictionary from one of the instances, or pass on the invisible argument *it* got. Not really looking up. It slows your program down because it will inhibit inlining and other optimizations.
Please help in spreading this URL to anyone who's attending ICFP and its attached conferences and wants to have a bit of fun during the talks!
" some python code monkeys of the street" lol I can totally relate. Learning Haskell and other similar languages really open your eyes and changes your perspective on what is "good code" 
Brilliant. But is it provably winnable in a finite number of ICFP talks?
Rust sounds right up your alley.
Looking at one of the generated samples I'd say it's probably winnable in 1 talk. 
To generate C code from Haskell, look at the [Atom EDSL](https://hackage.haskell.org/package/atom). Rust would probably also be a good solution.
The problem is that the `a` cannot be _linearly_ monadic if the arrow is unrestricted, so the monad kinda becomes incompatible with itself. This is my reason for defining it that way. Your use case is indeed different, and may be useful for other stuff! 
I've struggled with Generics as well and had the same experience. I wasn't able to make it work. I think TH is the only pragmatic choice here. It's not that the TH is bad (I don't share that dogma). IMO the library API, as it stands currently, seems complicated. It would make sense to provide simple one-liners for the most common use-cases in the API itself.
&gt; For example, You can add a prefix "pf" by adding fdFieldName %~ fmap ("pf"++) or a suffix 'F' with fdFieldName %~ fmap (++"F"), or remove the two first letters with fdFieldName %~ fmap (drop 2) etc .. This is a very common use-case. And IMO, should have a top-level API function to make this a one-liner for users.
Yes, *probably*. But that ain't no formal proof.
I previously used ghc-mod in emacs and now use intero in emacs.
It's funny because it's true.
I think using `-XQuasiQuotes` for generating SPECIALIZE pragmas is overkill. Every Haskell beginner which will find this post will suffer from this unsubstantiated usages of some compile-time generation. It can be done easier in a way like this: specPragma :: String -&gt; String specPragma t = "{-# SPECIALIZE xbuildStorable :: " ++ t ++ " -&gt; Builder #-}" and then used like this allPragmas = unlines $ map specPragma ["Int", "Int8", "Word32", ... ] I want to say that `QuasiQuotes` are cool. But I just don't like usages of some complex Haskell stuff when there's no reason for this. Especially in such beginner-friendly tutorials. Well, for me this series of post seems to help mostly Haskell beginners. I could understand usage of `-XQuasiQuotes` if proper quasi quoter was used which checks correctness of generated SPECIALIZE pragmas and code just won't compile when your template is incorrect. But quasi quoter from this blog post doesn't perform such validation.
I use [spacemacs](https://github.com/syl20bnr/spacemacs/), which is a curated set of emacs plugins, with the haskell layer. I'm currently very happy with the usability, but it took me a while to learn the idioms of the included plugins. Sometimes it was a bit unstable, as well. Learning vim obviously takes a while, but that's optional (although it's an investment for life)
I am a vim user can you suggest how can I set up for Haskell
A constructive joke.
&gt; Phil Wadler asks a question &gt; SPJ, from the audience, answers a question 
Just good old `TemplateHaskell` is also fairly simple for stuff like this. TH only really gets brittle/verbose/etc when you have to use `Language.Haskell.TH.{Lib,Syntax,...}` e.g. $(let spec ty = [d|{-# SPECIALISE xbuildStorable :: $ty -&gt; Builder #-}|] in fmap concat (mapM spec [ [t|Int8|], [t|Int32|], ... ])) granted TH syntax is really noisy even without having to manually mess about with one of the AST types.
Let x = Set of all possibles fields in this bingo. Let t = "Hi! In this talk I will tell you whether you can prove that a talk that contains the words &lt;speak all the words in x&gt; will satisfy any ICFP Bingo 2017. Well it can: Since any possible field in the bingo is in x and hence was mentioned in this talk. Thank you for you attention, live long and prosper!" Let f = The fourth sentence of t. f is obviously true. Since t can be delivered in &lt; 10 minutes and f is true, any ICFP Bingo 2017 can be won by 1 talk. Hence, any ICFP Bingo 2017 can be won in a finite number of ICFP talks. QED.
Can you paste your code in code tag or paste it on some resourse? Because indentation is broken and it won't compile. If it is the way your code is in your file then that is your answer.
In a case expression, use `-&gt;` instead of `=`. Definitely don't use `==`. The error message is not terribly helpful here :(
sorry I'm new to Reddit also and didn't know about the code tag. Fixed it! :)
I changed them to `-&gt;` but still got the same error :(
I don't have the time to maintain a project of potentially such importance.
The indentation makes it hard to tell what is wrong. You seem to try to mix case analysis with guards. Try to use case analysis until you are sure how it works, then make sure you know how guards work and then try to tackle more complicated examples. The function could be written like this: totalPrice BaseBall y = baseballPrice y totalPrice Basketball y = basketballPrice y baseballPrice y | y &gt;= 1 &amp;&amp; y &lt;= 15 = 10 | y &gt; 15 &amp;&amp; y &lt; 40 = 9.5 ... baseballPrice y | y &gt;= 24 = 11 .... The pattern matching on the product type happens on the left hand side of the function definition. The pattern matching of `y` happens in the gaurds. There are several places where pattern matching can happen, this makes it a bit confusing at the beginning.
Ah, I see I wasn't clear enough. While this is interesting and all, I'm sure practitioners would be much more interested in a, well, *practical* result. That is, whether attending actual ICFP with an ICFP Bingo card in hand is guaranteed to result in a win in a finite amount of time (we'll assume that attendants who are unable to win in one ICFP run will immediately travel to the site of next ICFP and wait there for a full year as if that's nothing much of note).
I don’t get it. As I understand it, all types must be known at compile-time. Otherwise we get an “ambiguous type” error, right? I really wish GHC had some sort of “AUTO SPECIALIZE” pragma, that would just create unique functions for each type, rather than carry around a dictionary at runtime.
Thanks!! but isn't the output is different, I need them to be `y*10` not only `10`
I am not a vim user, but I believe this is a good resource: https://github.com/sdiehl/haskell-vim-proto
You’re mixing up case expressions and guards. Read the following, specifically the sections on guards and case expressions, and you will realize what the error is: http://learnyouahaskell.com/syntax-in-functions
There are basically three variants of a function ignoring inlining: - The one you wrote - The generic optimized one - The specialized optimized one A function will be automatically specialized for a type if your original code is available, the function is used at that type and you are compiling with -O or higher. By default the original code is only kept around in the definition module. You can mark a function as `Inlinable` to keep your original code around. If you are a library and never call a function you can also manually `Specialize`, mostly so it doesn't have to be recompiled every time the library user compiles. If it is `Inlinable` you can `Specialize` the function outside of its definition module as well.
Yes, it read `y10` before and I dropped the `y` because I didn't understand what it should mean.
I understand now. Please disregard the last sentence (I was in a bad mood that day).
Plain vim, stack, ack, zsh, hlint, hoogle, hayoo, hasktags, and a few handwritten shortcuts in .vimrc.
yes I also tried that but I always get the error from mod-ghc ghcmod.vim : the current buffer has been modified but not written and several other issues like can't guess the type .. etc I was wondering how to cope up with these issues.. or I am distracting myself in wrong way... as the post is 1 year older.
You are absolutely right. I'll see what I can do. In the mean time PR see welcome ;-)
The problem with TH is you end up using code or type you actually can't see (or that your editor can't see : grep and crags etc ... Won't work) which sometime I even plain generation to TH. I wish one could just bake TH into file and use the code as normal code.
1. Install spacemacs: `git clone https://github.com/syl20bnr/spacemacs ~/.emacs.d` (backup your .emacs.d before if you have one) 2. Start emacs, wait for spacemacs to set up 3. Press `SPC h SPC` (spacebar, then 'h', then spacebar) for the spacemacs help. 4. Type in `haskell` to search for the haskell layer, press enter to open the haskell layer documentation 5. Follow the instructions My haskell entry in `dotspacemacs-configuration-layers` is: (haskell :variables haskell-enable-hindent-style "johan-tibell" haskell-enable-ghc-mod-support nil haskell-completion-backend 'intero )
That's no problem at all. 
One of the reasons I held off on uploading this was to avoid someone hacking their talk to include extra bingo-able terms.
I feel like my talk will trigger a bingo Just from the abstract http://icfp17.sigplan.org/track/hiw-2017#program
Would it be possible to couple the a with the continuation? I guess I am thinking of something like (&gt;&gt;=) :: m (a:p) -o (a -&gt;_p m b) -o m b
&gt; Session type that receives a list I gather that this is a commonplace example with session types? Could someone unpack this a little?
&gt; All types must be known at compile-time Not really. More like 'all constraints must be resolved compile-time'. Whether it comes from the context or some instance. No constraint, no problem. Try for yourself: length []
Thanks - that is confusing wording. I'll clean that up. -- Edit 08/12/2017, 3:50pm: Updated the post.
&gt; `Destructible` So `(&gt;&gt;)` could be defined (&gt;&gt;) :: (LMonad m, Destructible a) =&gt; m a -. m b -. m b ma &gt;&gt; mb = ma &gt;&gt;= \(destroy -&gt; ()) -&gt; mb 
A classical one too 😂
GHC 8.2.1 says: parse error (possibly incorrect indentation or mismatched brackets) | | | y &gt;= 1 &amp;&amp; y &lt;= 15 = y*10 | ^ There are no brackets around here, so this must be incorrect indentation. Should this be indented more, or less? Guards are used to add extra side-conditions to a pattern-match, and in this case you're clearly trying to add those side-conditions to the `Baseball` pattern, but GHC doesn't see that because your guards are indented at the same level as your `Baseball` pattern, so GHC sees them as sibling clauses, not as parent and child clauses. Let's indent all of the guards, to make it clear that they are specializing the `Baseball` pattern, and similarly for `Basketball`. GHC now says: parse error on input ‘=’ Perhaps you need a 'let' in a 'do' block? e.g. 'let x = 5' instead of 'x = 5' | | | y &gt;= 1 &amp;&amp; y &lt;= 15 = y*10 | ^ It still doesn't work, does it mean that indenting the guards was not the right fix? No, it was the right fix, but your code has more than one problem to fix! The fact that GHC is now giving us a different error message means that we're making progress. Usually. It could also mean that we have introduced a new problem. It's usually easier to start with a small program which you know compiles and to make small changes one at a time, this way you should only get one new error at a time. So, GHC is complaining about the equal sign. An equal sign is used to define the value of a variable or a function, but we are in the middle of an expression, so GHC recommends using a `let` in order to define temporary variables or functions in the middle of an expression. GHC is trying hard to guess what you're trying to do, but this time its guess is incorrect: I can see that you are not trying to define anything new, you simply want to specify which value to use when the guard expression is true. The correct syntax for this is `-&gt;`, not `=`; but only because we're in a `case` expression. If you had written your code as follows instead data Product = Baseball | Basketball totalPrice :: Product -&gt; Float -&gt; Float totalPrice Baseball y | y &gt;= 1 &amp;&amp; y &lt;= 15 = y*10 | y &gt;= 15 &amp;&amp; y &lt;= 40 = y*9.5 | y &gt;= 41 &amp;&amp; y &lt;= 150 = y*9 | y &gt;= 151 &amp;&amp; y &lt;= 400 = y*8.5 | y &gt;= 401 = y*8 | otherwise = error "Something's wrong" totalPrice Basketball y | y &gt;= 1 &amp;&amp; y &lt;= 7 = y*14 | y &gt;= 8 &amp;&amp; y &lt;= 14 = y*13 | y &gt;= 15 &amp;&amp; y &lt;= 23 = y*12.4 | y &gt;= 24 &amp;&amp; y &lt;= 40 = y*11 | y &gt;= 41 = y*10.3 | otherwise = error "Something's wrong" Then the correct symbol would indeed be `=`, not `-&gt;`. Moving on, let's replace those `=`s with `-&gt;`s. GHC now says: parse error (possibly incorrect indentation or mismatched brackets) | | Basketball | ^ We're making progress! But this time the problem is neither indentation nor mismatched brackets. GHC is surprised to encounter this unindented clause because the previous clause is not finished: the previous line, | otherwise == error "Something's wrong" does not have a `-&gt;` to indicate what to do when the guard expression `otherwise == error "Something's wrong"` is true. Clearly, you meant to use `-&gt;` instead of `==`; I'm not sure why you used `==` here and `=` everywhere else, but in any case, both are wrong, you want `-&gt;` everywhere. And with this third problem fixed, the program compiles!
the horrorrrrr
IntelliJ with Haskforce is quite nice The Rust plugin is also close to perfect (if you code in Rust, too)
Such a fun type signature (s -&gt; l -&gt; s) -&gt; (r -&gt; s -&gt; s) -&gt; (s -&gt; [Either l r] -&gt; s) (l -&gt; s -&gt; s) -&gt; (r -&gt; s -&gt; s) -&gt; ([Either l r] -&gt; s -&gt; s) (l -&gt; Endo s) -&gt; (r -&gt; Endo s) -&gt; ([Either l r] -&gt; Endo s) **Edit**: This has different semantics than the original function foldMapOrigami :: Monoid m =&gt; (l -&gt; m) -&gt; (r -&gt; m) -&gt; ([Either l r] -&gt; m) foldMapOrigami fl fr = foldMap (either fl fr) foldOrigami :: Monoid m =&gt; [Either m m] -&gt; m foldOrigami = foldMapOrigami id id origami :: forall l r s. (l -&gt; s -&gt; s) -&gt; (r -&gt; s -&gt; s) -&gt; ([Either l r] -&gt; s -&gt; s) origami = coerce (foldMapOrigami @(Endo s) @l @r) for `Foldable`, `Foldable1` import Data.Semigroup.Foldable1 import Data.Semigroup foldMapOrigami :: (Foldable f, Monoid m) =&gt; (l -&gt; m) -&gt; (r -&gt; m) -&gt; (f (Either l r) -&gt; m) foldMapOrigami fl fr = foldMap (either fl fr) foldOrigami :: (Foldable f, Monoid m) =&gt; f (Either m m) -&gt; m foldOrigami = foldMapOrigami id id origami :: forall f l r s. Foldable f =&gt; (l -&gt; s -&gt; s) -&gt; (r -&gt; s -&gt; s) -&gt; (f (Either l r) -&gt; s -&gt; s) origami = coerce (foldMapOrigami @f @(Endo s) @l @r) foldMap1Origami :: (Foldable1 f, Semigroup s) =&gt; (l -&gt; s) -&gt; (r -&gt; s) -&gt; (f (Either l r) -&gt; s) foldMap1Origami fl fr = foldMap1 (either fl fr) fold1Origami :: (Foldable1 f, Semigroup s) =&gt; f (Either s s) -&gt; s fold1Origami = foldMap1Origami id id origami1 :: forall f l r s. Foldable1 f =&gt; (l -&gt; s -&gt; s) -&gt; (r -&gt; s -&gt; s) -&gt; (f (Either l r) -&gt; s -&gt; s) origami1 = coerce (foldMap1Origami @f @(Endo s) @l @r) generalize `Either` to anything `Bifoldable` foldMapOrigami :: (Foldable t, Bifoldable p, Monoid m) =&gt; (a -&gt; m) -&gt; (b -&gt; m) -&gt; (t (p a b) -&gt; m) foldMapOrigami fl fr = foldMap (bifoldMap fl fr) foldOrigami :: (Foldable t, Bifoldable p, Monoid m) =&gt; t (p m m) -&gt; m foldOrigami = foldMapOrigami id id origami :: forall f p l r s. (Foldable f, Bifoldable p) =&gt; (l -&gt; s -&gt; s) -&gt; (r -&gt; s -&gt; s) -&gt; (f (p l r) -&gt; s -&gt; s) origami = coerce (foldMapOrigami @f @p @(Endo s) @l @r) **Edit 2**: The final `foldMapOrigami` is like [`foldMapScope`](https://hackage.haskell.org/package/bound-2.0.1/docs/Bound-Scope-Simple.html#v:foldMapScope) foldMapScope :: (Foldable f, Monoid m) =&gt; (b -&gt; m) -&gt; (a -&gt; m) -&gt; (Scope b f a -&gt; m) foldMapScope f g (Scope s) = foldMap (bifoldMap f g) s **Edit 3**: The oddly named [`Tannen`](https://hackage.haskell.org/package/bifunctors-5.4.2/docs/Data-Bifunctor-Tannen.html#t:Tannen) from *bifunctors* is defined as a `Bifunctor` wrapped in a `Functor` newtype Tannen f p a b = Tannen (f (p a b)) whose `bifoldMap` looks eerily similar bifoldMap @(Tannen _ _) :: (Foldable f, Bifoldable p, Monoid m) =&gt; (a -&gt; m) -&gt; (b -&gt; m) -&gt; (Tannen f p a b -&gt; m) and it is indeed coercible to `foldMapOrigami` coerce (bifoldMap @(Tannen f p) @m @a @b) :: forall f p a b m. (Foldable f, Bifoldable p, Monoid m) =&gt; (a -&gt; m) -&gt; (b -&gt; m) -&gt; (f (p a b) -&gt; m)
I was going to say Idris, since it is strict. But, you also want to avoid GC, so I'm going with the rest of the thread and say Rust.
But that would be fixing the problem of the editor itself, whereas the real fix would be for editor to use compiler API and have access to all the things compiler knows...
*CBN* probably isn't a useful acronym when discussing *name* and *need* :)
Spacemacs when I need/want help with types or when I'm cleaning up code, sublime text for scratchpad dev or or scale text editing. I'm not as productive without multiple cursors, so I lean on sublime text heavily. Spacemacs copies enough of vim for me to not feel totally lost in a forest of Emacs, but can feel a little slapdash at times.
I'm using plain Emacs (just syntax highlighting), with a separate terminal (for stack ghci and build). I tried setting Intero up, but it didn't work. Before that I was using Atom's ide-haskell. It worked alright, sometimes, but I wasn't a fan of the editor myself.
I use vscode with the haskero plugin.
One thing I'm looking forward to is some improved tooling in the near future as the HSOC projects finish up. People have been working on LSP integration for Haskell, interactive-haskell-mode, and so on. By this time next year, I expect the tooling integration for Haskell to be in a much better state (although it's already way better now thanks to things such as intero, Dante, Stack, and such)
Additionally, there are functional data structures (okasaki's book is the famous resource). Learning about those is also quite illuminating as sometimes they require laziness, almost all require a GC, and the analysis of their runtimes, complexity, performance, etc, is illuminating for insight as to how functional languages work. But if all op wants is the nice type system, rust would be great for that (although the borrow checker will likely get in the way of implementing traditional algorithms and data structures "as is". They might end up wanting to use C for some of those? Not sure.)
yea I am also waiting for that day ...as of now we have stack for builds ...a good IDE is in need
[haskell-ide-engine](https://github.com/haskell/haskell-ide-engine) with vscode is already pretty usable, but only for GHC 8.0.2 projects at the moment.
&gt; A function will be automatically specialized for a type if your original code is available, the function is used at that type and you are compiling with -O or higher Is this always true? I don't think it is. I believe that if the function is in a different module, it is **much** less inclined to specialize it. Thus the need for `-fspecialize-aggressively`
This is what in most excited about, honestly. Once the LSP is finished, every editor will have Haskell features to hook into. Honestly, it's always bugs me whenever I see massive duplicate of effort on such trivial things like this and I'm glad LSP seems to be the new standard going forth for things like this. Hopefully it'll get even more features so languages such as rust, Haskell, or other "non traditional" languages can get the most benefit out of it.
Well, the [list of implementations](https://github.com/Microsoft/language-server-protocol/wiki/Protocol-Implementations) is getting pretty impressive, so its clear that it has definitely hit a critical mass of some kind.
[removed]
Is it the type of all *expressions* that must be known at compile-time, then? 
I am mostly basing this on the [SPECIALIZE for imported functions](https://downloads.haskell.org/~ghc/7.8.1/docs/html/users_guide/pragmas.html#idp25319520) section in the ghc users guide: &gt; Moreover you often don't even need the SPECIALIZE pragma in the first place. When compiling a module M, GHC's optimiser (with -O) automatically considers each top-level overloaded function declared in M, and specialises it for the different types at which it is called in M. The optimiser also considers each imported INLINABLE overloaded function, and specialises it for the different types at which it is called in M. Do you have a link on hand that explains -fspecialize-aggressively? I can only find &gt; -fspecialise &gt; On by default. Specialise each type-class-overloaded function defined in this module for the types at which it is called in this module. Also specialise imported functions that have an INLINABLE pragma (Section 7.20.6.2, “INLINABLE pragma”) for the types at which they are called in this module. 
`-fspecialise-aggressively` [can be found next to `-fspecialise`](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-optimisation.html#ghc-flag--fspecialise). The fact that it mentions size makes me think that `-fspecialise` won't specialize imported inlinable code that is beyond some heuristic size.
Rust kicks you from worrying about garbage collection (which, realistically, most programmers do not need to do) to worrying about how to make your code compile past the strictures of the borrow checker. I imagine that many of the people who are suggesting Rust haven't yet tried it for themselves. Its enlightening to do so. It's surprisingly fiddly in a way that reminds me of originally struggling with Haskell, but with a payoff that is much less rewarding. Haskell transforms how you think, while Rust transforms you into an accountant.
OCaml (or Standard ML, if you can find a compiler that works for you) is a good fit for this. Supports functional programming just fine, memory safe, and with a simple operational model (it's strict). You even have mutable references, which are nice if you want to implement classical data structures, as these often make use of mutation. If you want to implement *purely functional* data structures, however, then Haskell is a better fit, I think. The OCaml compiler is also much less aggressively optimising than GHC, so you generally more or less get what you write, whereas GHC has more elaborate techniques based on rewrite rules and such.
Interesting, apparently the docs I looked at were too old. In [specialize.hs](https://github.com/ghc/ghc/blob/ghc-8.2/compiler/specialise/Specialise.hs#L790) &gt; Note [Specialise imported INLINABLE things] &gt; What imported functions do we specialise? The basic set is &gt; * DFuns and things with INLINABLE pragmas. &gt; but with -fspecialise-aggressively we add &gt; * Anything with an unfolding &gt; templateTrac #8874 has a good example of why we want to auto-specialise DFuns.We have the -fspecialise-aggressively flag (usually off), because we risk lots of orphan modules from over-vigorous specialisation.However it's not a big deal: anything non-recursive with anunfolding-template will probably have been inlined already. So I think `-fspecialise-aggressively` is mostly relevant in combination with `-fexpose-all-unfoldings`. Apparently there is a difference between using those flags and adding `INLINEABLE` pragmas to everything, though. [From here](https://ghc.haskell.org/trac/ghc/ticket/12963): - -fexpose-all-unfoldings has no effect on the optimisation pipeline; it just arranges that, at the end of the pipeline all the unfoldings for all functions are put into the interface file. - INLINABLE is quite different. It says to snapshot (essentially the source code of) the RHS of the function, and make it available for inlining and/or specialisation at call sites. So it could have a major effect on the optimisation pipeline. (I'd prefer that it was called SPECIALISABLE.) So I guess INLINABLE keeps the original code so it can do the optimization passes after inlining, potentially allowing for additional optimizations but at the expense of duplicate work?
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [ghc/ghc/.../**Specialise.hs#L790** (ghc-8.2 → c850aed)](https://github.com/ghc/ghc/blob/c850aed3221a1811f60a0c794ea813fe1220e55f/compiler/specialise/Specialise.hs#L790) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dlix1oh.)^.
me too! Its really great for me (I am not a vim/emacs guy [yet])
Thank you for the research! It's good to know that anything marked with `INLINEABLE` will always be specialized. Now if only there were a flag or pragma to make everything in the module marked `INLINEABLE` =P One thing I'm curious about is whether there's some kind of global database of specialized versions of functions, or if every module that does the same specialization duplicates that work. Also, I'm assuming an `INLINEABLE` function doesn't *need* to end up inlined to be specialized?
Neovim with intero-neovim. It works great for small projects and multi package large projects, though sometimes it uses too much ram. You can get really far with plain editor and ghcid. 
Have you looked at, e.g. Foldable, Traversable, or Generic?
have you used HIE how are the reviews about it compared to present state vim integrations 
How does the time to derive instances compare to handwritten instances?
&gt; Depends. Try to make a rookie mistake with foldr, the compiler exposes with mention of traversables and other stuff. For a newcomer this would be daunting - they need to fold a list, not decipher the what traversables are. Definitely, but that's a "learning curve/documentation" issue, I think. And also partly due to the Haskell2010 spec. 2020 will bring good things! &gt;That's why we need a "extract method" refactoring tool... You can use HaRe to move functions in e.g. a `where` clause to top level, so that it could be tested later. Part of it is "write the clean, compact code that Haskell allows you to do" - Haskell admittedly doesn't *prohibit* you from doing the wrong thing, but it does make it possible to do the "right" thing, i.e. adopting a functional style.
/u/ryantrinkle 
IIRC it's not the "deriving", but compiling (and optimizing?) resulting code. E.g. The Ord for records with many fields, or Show. https://ghc.haskell.org/trac/ghc/ticket/9557
I am biased, as one of the authors. Yes, I have used it, but have not switched to use it for my day-to-day work (yet). This is mainly because the [emacs-lsp](https://github.com/emacs-lsp/lsp-mode) work has paused while the main developer concentrates on their (unrelated) GSOC project. The work that Zubin Duggal has done on LSP support for haskell-ide-engine for his HSOC project is astounding, and it is already very usable with vscode. But it is still an early stage project, so ymmv. From the vim side, I know that some people are making use of the [neovim](https://github.com/autozimu/LanguageClient-neovim) support, with some success. 
I didn't look at `Foldable` or `Traversable` because they can't be derived for arbitrary data types. I did look at `Generic`; its performance is roughly between `Eq` and `Show`. I didn't include it in the post because deriving `Generic` requires a language extension that doesn't work all the way back to 7.0.1. Same story with `NFData`. You can see more extensive notes here: https://github.com/tfausak/tfausak.github.io/issues/127
Cool!
Thanks for sharing I will try HIE ...it looks nice !!
I currently use vim, ghc-mod, HaRe, hask-replace, hoogle, hspec-vim, ripgrep-haskell, pointfree, and stylish-haskell. I also user weeder and hlint at work. Two of my colleagues like ghcid rather than ghc-mod. It's not exactly "state of the art", but they are comfortable to me. I advise you find something similar that works for you. I wrote a couple of those tools myself, and you shouldn't be afraid of doing the same!
I didn't compare hand-written instances for things like `Read` because they're extremely tedious to write. For other type classes like `Data`, `Generic`, and `Typeable`, it doesn't really make sense to write them by hand. I would like to see how much of the time is spend generating code, compiling it, and optimizing it. I had to draw the line somewhere, though; the benchmark was already enormous :) 
Have you looked into recursion schemes? I think that might generalize what's here.
thanks for sharing ... I am also a vim fan .. and would like to stick to vim as it suits me ... can you share more details how to do setup ...I am not familiar with these Tools but want to improve the productivity with their help.
I use [haskell-vim-now](https://github.com/begriffs/haskell-vim-now).
This was a great post for a lot of reasons, but I especially appriciate your use of nix. By providing a default.nix, you make it super easy to follow along. I wish everyone did that! Now if I can get it to work..
I currently use [vim-plug](https://github.com/junegunn/vim-plug). Here are the lines from the `.vimrc` that install Haskell-related packages: Plug 'eagletmt/ghcmod-vim' " ghc-mod Plug 'Twinside/vim-hoogle' " hoogle plugin for vim Plug 'jremmen/vim-ripgrep' " ripgrep support in vim Plug 'vmchale/ripgrep-haskell' " Ripgrep Haskell helpers Plug 'nbouscal/vim-stylish-haskell' " stylish-haskell Plug 'vmchale/pointfree' " pointfree wrappers for vim Plug 'vmchale/hask-replace-vim' " hask-replace to makes things a lot nicer here. Plug 'glittershark/vim-hare' " vim-hare wrapper You'll also need to install various tools in their binary form, so install [stack](https://docs.haskellstack.org/en/stable/README/). Then install all the tools written in Haskell: ``` stack intsall ghc-mod hlint weeder HaRe hoogle pointfree stylish-haskell ``` Then generate the db for hoogle: ``` hoogle generate ``` Then, optionally install the tools written in Rust (ripgrep isn't Haskell-related at all, but ripgrep-haskell requires it): curl -LSfs https://japaric.github.io/trust/install.sh | sh -s -- --git burntsushi/ripgrep curl -LSfs https://japaric.github.io/trust/install.sh | sh -s -- --git vmchale/hask-replace
Which aspect of it are you having issues with? If it's a problem with my `default.nix` or the IHaskell `release.nix` do let me know and I will do my best to fix it!
Thanks for your feedback. Using plain functions is great for cases where I only have one type to replace. It starts to feel fiddly/less readable to me though with the double-quoting and string appending when I have more than one spot to replace: specPragma :: String -&gt; String specPragma t = "{-# SPECIALIZE buildWordAtBase :: " ++ t ++ " -&gt; (Int -&gt; Char) -&gt; " ++ t ++ " -&gt; Builder #-}" vs. with an inline mustache template, I paste in the type signature, remove the typeclass constraints, and wrap type parameters for replacement in double curly brackets: {-# SPECIALIZE buildWordAtBase :: {{a}} -&gt; (Int -&gt; Char) -&gt; {{a}} -&gt; Builder #-} I debated including the script or not. Went ahead and kept it in case it is useful for anyone. I hope it doesn't distract away from the point of the post. Maybe some links for further reading on QuasiQuotes would help?
When I run nix-build, I get a compiler error from stack trying to build Geom2D.CubicBezier. It's a dependency of diagrams, which is a dependency of IHaskell plotting. It looks like the maintainer of CubicBezier has fixed that issue but forgot to push it to Hackage. I posted an issue: https://github.com/kuribas/cubicbezier/issues/7 Edit: I was wrong, it wasn't stack building CubicBezier, it was nix's ghcWithPackages running tests with cabal and failing. So actually building this with stack doesn't cause an error because stack doesn't run the tests. Huh.
Isn't a bingo card normally 5x5 with a free space in the middle?
Indeed. You can implement it with the bind, and call `destroy` on the argument because that consumes it. :) 
Something like that should be possible indeed, don't know exactly how it would mesh with the rest but seems reasonable.
&gt; it doesn't really make sense to write them by hand. But it would be useful to know whether it's the deriving that's slow or the compiling of the derived code.
You'll want to read the [tutorial](https://github.com/ChrisPenner/selections/blob/master/tutorials/Basic.md) to get a sense of how it works; cheers!
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [ChrisPenner/selections/.../**Basic.md** (master → 819d52c)](https://github.com/ChrisPenner/selections/blob/819d52c965cbc60131694f3f3347386dffa34669/tutorials/Basic.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dlj0smg.)^.
Right, I agree. I meant that specifically `Data`, `Generic`, and `Typeable` don't make sense to write by hand. In fact, you *can't* define `Typeable` by hand: Class `Typeable' does not support user-specified instances
Thanks a lot !! I am trying to follow the steps ....nice!!
If by chance you are using PostgreSQL then use the 'pgcrypto' extension (https://www.postgresql.org/docs/current/static/pgcrypto.html). It has a number of standard functions that helps with salt and hashing.
It looks like this might be because I didn't pin `&lt;nixpkgs&gt;`, which is bad practice anyway. Let me change that in my `default.nix` and see if that gets rid of the issue.
When did you try intero? It's really good now.
Aha! That's why I was seeing the issue, my default nixpkgs is unstable. When I built against 17.03 everything goes smoothly.
Vim, neco-ghc, neoformat, hlint, hdevtools, stack ghc Plug 'eagletmt/neco-ghc' let g:necoghc_enable_detailed_browse=1 Plug 'sbdchd/neoformat' augroup Neoformat autocmd! BufWrite *.hs silent! undojoin | Neoformat augroup END Plug 'w0rp/ale' let g:ale_lint_on_text_changed='normal' let g:ale_linters={'haskell': ['stack ghc', 'hlint', 'hdevtools']} 
`-ddump-deriv` will show the code it derives.
GHC also chooses to include some unfoldings if it believes they are very likely to be inlined. In that case `-fspecialise-aggressively` is useful without `-fexpose-all-unfoldings`.
Okay, I've updated `default.nix`, can you try again?
Sadly `-ddump-deriv` doesn't produce code that you can actually copy-paste into the module. It can certainly be used as the basis for a non-derived instance, but not without some work. For example: instance GHC.Classes.Eq body_a2PO =&gt; GHC.Classes.Eq (Deriving.Eq.Section body_a2PO) where (GHC.Classes.==) (Deriving.Eq.Section a1_a2PS a2_a2PT a3_a2PU) (Deriving.Eq.Section b1_a2PV b2_a2PW b3_a2PX) = ((((a1_a2PS GHC.Classes.== b1_a2PV)) GHC.Classes.&amp;&amp; ((a2_a2PT GHC.Classes.== b2_a2PW))) GHC.Classes.&amp;&amp; ((a3_a2PU GHC.Classes.== b3_a2PX))) (GHC.Classes./=) a_a2PY b_a2PZ = GHC.Classes.not ((GHC.Classes.==) a_a2PY b_a2PZ) That references `GHC.Classes`, which exists but isn't documented. It also uses `Deriving.Eq`, which doesn't exist. 
You mentioned Rabbit-holing to validate SHA-1 hashes. Can it just be written like this? parseHexRef = do bs &lt;- AC.take 40 guard $ all (inClass "0-9a-n") bs return bs 
Works!
I wrote rust code every day this week. The borrow checker isn't too insane to get a grip on. Mostly it just gets you to write the code you should have written in the first place.
Sorry, should've written the recursive version: productA [] = 1 productA (x:xs) = x * productA xs productS [] = 1 productS (x:xs) = if any (==0) xs then 0 else x * productS xs Here productS is n^2 I believe 
which is better hdevtools or ghc-mod 
I think that would work! Most of the rabbit holes are things I implemented in [duffer](https://github.com/vaibhavsagar/duffer/blob/187364012ef7fc5a6a771e37c6772e256e401345/duffer/src/Duffer/Loose/Parser.hs#L44-L48), so you should be able to see my solutions there.
I've been using Atom with ide-haskell. Not too sure about how scaleable it is since Atom is an Electron app, but the recent performance update to Atom made things a bit more bearable.
a good answer is here: https://stackoverflow.com/a/40139436/314392
Thanks
https://github.com/ptigwe/hs-flatris
Nice, I added the function body to my comment
Nice list. But ripgrep is in there twice :)
Can you even do that? :o Never seen that arrow-in-pattern-match thing. 
&gt; All constructors are consumed simply by pattern matching, so getting rid of the () is easy. Does it means that the guarantee that our value is used once can easily be fooled by using `destroy` or by a pattern match? So library author should be careful to design their type with these constraint in mind. It also means that the discarded result is strict? &gt; Makes sense? Did I answer your questions? :D Yes, and actually you gave me the motivation to reread the linear type paper, and I understood new things.
I haven't had a chance to try with 8.2 yet, but I know there are some modules on 8.0.2 (ones that just declare the type and derive type classes) where I've disabled optimizations during active development just to improve compile times.
Wow! 
I guess so! I guess it shouldn't be too hard to write a type abstraction for something indestructible either, so maybe that would be a nice addition. I think this is a necessary consequence of being able to pattern match; how useful would the extension be of that was unavailable? Well hooray for your insights, the purpose of my project kinda. :) 
Yesterday, haha. [Relevant issue](https://github.com/commercialhaskell/intero/issues/381). EDIT: my comment in that issue is actually 5 days old, so not exactly yesterday, but yeah.
I'm not sure anyone would write it like that. Maybe like: productS [] = 1 productS (x:xs) = if x == 0 then 0 else x * productS xs ... But, yes, your bad implementation would be O(n^(2)).
Yeah, compiling with `-O1` is 6 times slower than `-O0`. https://twitter.com/taylorfausak/status/896454753684729857
Thank you for taking a data driven approach to illuminating the issue. I'm also grateful that 8.2 seems to be faster again.
Yes using view patterns, you can even create a pattern synonym to destroy a value pattern Destroy :: Destructible a =&gt; a pattern Destroy &lt;- (destroy -&gt; ()) ma &gt;&gt; mb = ma &gt;&gt;= \Destroy -&gt; mb
The only FP language I know of that doesn't use a GC is rust. Also, rust has Mozilla backing it, which is really helpful.
Currently using Vim with [this setup](http://sillybytes.net/2016/08/vim-haskell_11.html).
Dang, this is nice! Thanks for the tip :) 
Looks like lenses with more readable names and more intuitive interface. I wonder how this selection from tutorial would look like with `lens`: adjusted :: [Account] adjusted = newSelection accounts &amp; select ((== USA) . country) &amp; exclude ((&lt; 0) . balance) &amp; mapSelected (addInterest usaRate) &amp; select ((== Canada) . country) &amp; exclude ((&lt; 0) . balance) &amp; mapSelected (addInterest canRate) &amp; forgetSelection
The filtered traversal provides a lot of this functionality, but it has the caveat that you shouldn't break the predicate with the operation. This package isn't terribly novel, but it is clear and IMHO quite easy to use.
Yesssssss! Works perfectly, you're a miracle 😍😍
Can instance Destructible a =&gt; Destructible [a] where destroy :: [a] -. () destroy [] = () destroy (x:xs) = destroyRest $ destroy x where destroyRest :: () -. () destroyRest () = destroy xs from your [*Take &amp; Zip*](https://m0ar.github.io/safe-streaming/2017/08/08/take-and-zip.html) be written as ..? instance Destructible a =&gt; Destructible [a] where destroy :: [a] -. () destroy [] = () destroy (Destroy:Destroy) = () or destroy [] = () destroy (x:xs) = destroy (destroy x, destroy xs)
Cool, it has jump to definition. Can't seem to find this anywhere else...
Indeed this is generally true. Note that there are a number of similar tickets [summarized here](https://ghc.haskell.org/trac/ghc/wiki/Performance/Compiler#Derivinginstances).
Currently using the Yi editor in VIM mode, but sometimes use geany or notepad++. The latter's auto-indent feature is incompatible with Haskell so needs to be turned off.
Yes, but I don't have 8 more quality squares.
Hahah the irony. Well, best of luck in future attempts.
 accounts &amp; traverse . filtered ((USA ==) . country) . filtered ((&lt; 0) . balance) %~ addInterest usaRate &amp; traverse . filtered ((Canada ==) . country) . filtered ((&lt; 0) . balance) %~ addInterest canRate
Thanks a lot for sharing !!
`Destructible` is actually half a typeclass that seems potentially useful when we get to Linear Haskell, and I'll be calling this class `Comonoid` because that's the mathematical term for it. While a monoid (at least in linear land) has (effectively) the functions class Monoid a where mempty :: () -o a mappend :: (a, a) -o a The `Comonoid` would have the functions created by reversing the arrows: class Comonoid a where destroy :: a -o () duplicate :: a -o (a, a) This class doesn't exist in regular, non-linear Haskell because every type is a `Comonoid`. But the existence of `Comonoid` would give a pleasing symmetry to the reader and writer (aka `(,) e` and `(-o) e`) functors: Currently, `(,) e` is a `Monad` when `e` is a `Monoid`, and is a `Comonad` all the time; while `(-&gt;) e` is a `Monad` all the time and a `Comonad` when `e` is a `Monoid`. In Linear Haskell, `(,) e` would only be a `Comonad` when `e` is a `Comonoid`, and `(-o) e` would only be a `Monad` when `e` is a `Comonoid`.
&gt; I'm not as productive without multiple cursors, so I lean on sublime text heavily. https://github.com/magnars/multiple-cursors.el doesn't provide similar enough functionality for Emacs?
What's your use case for multicursor ? Spacemacs has a few features baked in which are equivalent to mult or alternative to multicursor. (Some are well hidden though) - iedit - vim like block - Swoop edit - Helm-ag-edit - yas auto template
It would be fantastic to have a *copy / paste*-able `-ddump-deriv`
It's a session type that describes a protocol where you can send one piece of data and then continue with the same protocol, or you can signal the end of the communication. It is a very basic but nontrivial communication protocol. 
Indeed! Well put in the last paragraph, haven't thought of this relationship. However, the usefulness of `dup` is in my option questionable in the subject of linearity, where I have found a dire need for `destroy`. 
I use neovim with: - eagletmt/neco-ghc - eagletmt/ghcmod-vim - neovimhaskell/haskell-vim - enomsg/vim-haskellConcealPlus - Twinside/vim-hoogle - itchyny/vim-haskell-indent - metakirby5/codi.vim - neomake/neomake - sbdchd/neoformat and the hasklig font
Previous threads about this topic with the comparison chart: https://www.reddit.com/r/haskell/comments/5wkx3l/haskell_editoride_support_chart https://www.reddit.com/r/haskell/comments/6n8mg9/can_someone_give_me_a_summary_of_haskell_plugins
This, a thousand times. A suitable comparison would probably dump the derived code somehow and compile that instead. I bet this suffers from quadratic blowup for something like `Ord` instances for types with 29 constructors.
[ghcid](https://github.com/ndmitchell/ghcid) works for me. No kidding.
That's a nice idea, but stating relationships to C, of all things, is confusing. &gt; is a language (similar to C) to describe declaratively In which way C is a declarative decription of something?.. &gt; .plan file using a simple C-like language Can't find any reasonable support of that statement in the grammar.
Me too. Works fine 
Me too. Works fine 
Big thanks for this 
...Then I fail to see how that matters. I hope your more concrete question was answered by others.
The algebra is similar to process algebra.
Dude you are my hero ! I'll try this out as soon as I am finished moving. If it works well then I'll start using it at work!
I wonder if this can be combined with [org-mode](http://www.personal.psu.edu/bam49/notebook/org-mode-for-research/), which is also based on the idea to use plain text files to encode your tasks and project planning.
As I mentioned elsewhere in this thread, the derived code can't be used directly. Also, compiling without optimizations is more than 6 times faster, so it doesn't seem like a significant amount of time is spent generating the instance code. 
Wow, it is indeed! &gt; Beside the original use in describing concurrent systems, the π-calculus has also been used to reason about business processes^[citation ^needed] and molecular biology^[citation ^needed]
Do you mean . filtered (not . (&lt; 0) . balance) in both cases?
It's a language you can use to describe things declaratively. It has C-like grammar, where C-like means `f(x);` is the unit of syntax.
So the headline would be more accurate as "derived instance code is slow to compile"?
No big news yet. We're continuing to work on it, and little bits are making it upstream, but it'll still be a little while until we have something that's streamlined enough for general use. We'll make an announcement when it's available!
Nice! Thanks for the reference. I wasn't aware
As an avid org-mode user I was also pondering whether it could replace or augment org-mode.
Thanks for the info! A friend and I were planning to do some app development and were considering getting good at reflex on the web and then jumping into making the app in reflex the second it is possible to do so. Do you have a ballpark estimate of when it would be available? I really like reflex but will probably have to look into an alternative platform if it is going to be in the year or more range. 
Definitely not a year - even half a year would be surprising.
That's fantastic news! Thank you!
Nice ! As an aside: it would be nice if somebody fixed [haskell-emacs](https://github.com/knupfer/haskell-emacs), so that you could write elisp functions in Haskell.
dead link
Oh, yeah! Good catch.
Haven't attempted any profiling, but [the `collide` function](https://github.com/ptigwe/hs-flatris/blob/9dd888c86c91197773525befafaa0f2c01d548ec/src/Grid.hs#L35) seems to have very bad asymptotics. Maybe it is too much for GHCJS.
Whenever you give up fighting the borrow checker, you can often copy the data instead of borrowing it. Of course, copying comes with a performance cost, but you can optimize it later if it turns out to be important. How much time did you invest learning Rust? I find it changed the way I think about programs (specially regarding concurrency), but this only happens after you get used to the language idioms and the borrow checker fades to the background. The borrow checker is supposed to be a janitor, not the protagonist.
Sure, compiling more code is always going to be slower. I focused on deriving these type classes because almost every data type derives them. It feels like you should get them "for free" since they're so mechanical. In particular, deriving both `Eq` and `Show` is *4 times slower* than deriving nothing. (And that's *with* `-O0`!) There's nothing interesting in those instances! 
I know it's not necessarily helping the OP but if you might be interested in [TaskJuggler](http://taskjuggler.org/) which seems usable from org-mode (with an export to task juggler plugin). There is a tutorial [there](http://orgmode.org/worg/org-tutorials/org-taskjuggler.html). (DISCLAMER I've never used it) 
works again.
Are the equivalent handwritten instances slow to compile?
I don't know. I haven't written the equivalent instances. I'll see about writing a program to generate modules with "handwritten" instances for benchmarking. 
&gt; algebra of tasks You know you're writing in Haskell when...
syntax is similar to C. semantics is very different.
thanks for this reference, I didn't know about TaskJuggler. It has some intersection. Will definitely serve as inspiration.
It would require a new frontend to parse org files, but also, recognize some standard way to represent the relations and properties (via Drawers or Categories, maybe) 
people talk about the type system but i don't think it's easy for non-haskellers to understand what the fuss is about since for most people the type system gets in the way. the key is that haskell let's me express what i'm thinking. that translates into programs that execute more consistently with intent for less work. only _after_ learning haskell did i realize that wasn't true of other languages like python or java.
I've tried many setups and so far this is my favorite. It also works on Windows!
So true :-)
Who knows, Maybe it will?
&gt; I'm guessing `g newState` is `m b` and if `g` is a monad [...] Wait a minute. If `g newState` has type `m b`, it does not mean that `g` has type `m` and that `newState` has type `b`! In fact, `m` is not even a type, it's a type constructor, so no value can have type `m`. Also, the `m` only appears in the type signatures of the class definition: class Monad m where return :: a -&gt; m a (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b Here, we are giving an instance definition beginning with instance Monad (State s) where ... and so within the instance definition, `m` is specialized to `State s`. The type signatures of the methods we are defining is not instance Monad (State s) where return :: a -&gt; m a return x = State $ \s -&gt; (x,s) (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b (State h) &gt;&gt;= f = State $ \s -&gt; let (a, newState) = h s (State g) = f a in g newState but rather instance Monad (State s) where return :: a -&gt; State s a return x = State $ \s -&gt; (x,s) (&gt;&gt;=) :: State s a -&gt; (a -&gt; State s b) -&gt; State s b (State h) &gt;&gt;= f = State $ \s -&gt; let (a, newState) = h s (State g) = f a in g newState Also, it doesn't make sense to ask whether a value like `g` is a Monad. What we can ask is whether a type constructor is a Monad, or more accurately, whether it has a Monad instance. For example, thanks to the above instance declaration, the type constructor `State s` has a Monad instance, a fact which is sometimes abbreviated as "`State s` is a Monad". Or sometimes, less-accurately, as "State is a monad", or more confusingly by needlessly calling it "the State Monad" instead of just "the State type". Okay, with that out of the way, on to the questions. &gt; It seems to me that `h` corresponds to `m a`, yet in `(a, newState) = h s`, `h` acts like a function. This is odd because shouldn't we have to use `runState` to extract the function wrapped by `h`? If a value has type `State s a`, you can indeed call `runState` on it in order to obtain the function of type `s -&gt; (a,s)` which the `State` value constructor wraps: getFunction :: State s a -&gt; (s -&gt; (a, s)) getFunction sa = runState sa But there is another way to obtain this function: you can pattern-match on the value-constructor `State`. getFunction :: State s a -&gt; (s -&gt; (a, s)) getFunction (State f) = f This is exactly what the implementation of `(&gt;&gt;=)` does: (State h) &gt;&gt;= f = ... So `h` is not the argument of type `State s a`, it's the function of type `(s -&gt; (a, s))` which was wrapped by the `State` value-constructor, and has now been unwrapped by the pattern-matching. &gt; Also why do does `h s` return a `newState` in the tuple and not `s`? It's just a variable name, you could just as well have called it `oldState` or `grampa` or whatever. You could call it `s`, but then you would shadow the other `s` bound the by the lambda a few characters earlier. It's already confusing enough having the type constructor and the value constructor both named State, let's not make matters worse by also using the same name for two different variables! Speaking of duplicate names, I should probably mention that the `s` and `a` variables bound at the value level aren't the same as the `s` and `a` type-variables at the type level. The value level `s` has type `s` and the value-level `a` has type `a`, which is why they were given those names. &gt; Must the application of the function wrapped by a State monad return a new state? A function of type `(s -&gt; (a, s))` must return a pair of type `(a, s)`, and so yes, the function must return an `s`. If it so chooses, the function can return the same value of type `s` as the one it has received, the "old" `s` if you will, or it can return a modified value, say `s + 1`, or a completely different value, say `42`. Whichever value is chosen is now the "new" state, which we want to use as the input for the next function of type `(s -&gt; (b, s))`. This is why the implementation of `(&gt;&gt;=)` calls `g` on the new value `newState`, not on the old value `s`. &gt; Lastly, I'm guessing `g newState` is `m b` No, the function `(&gt;&gt;=)` must return a value of type `State s b`, so whatever is on the right of the equal sign must have that type. That is, the entire expression State $ \s -&gt; let (a, newState) = h s (State g) = f a in g newState is the `State s b`. The `g` is the function of type `(s -&gt; (b, s))` obtained in `(State g) = f a` by pattern-matching on the value-constructor `State`, and so `g newState` has type `(b, s)`, not `State s b`.
Classical jokes should also be funny if they aren't not true, important distinction 😜
I guess some IDE integration here could help. Given a Haskell file which compiles and a TH expression, it should be able to expand the TH splice and insert it into the current Haskell file. Probably /u/chrisdoner can chime-in on this.
Can GHC not cache the compiled/optimised code (Core)?
My quick take on the example in the wiki: https://gist.github.com/wiz/fd7249de5485f52e3102c0773fc1daff I tried very hard not to make just another haskell EDSL and get over it (:
Why no `do` notation? startPhantomJS = getRandomPortForPhantomJS -- just picks a port in a predefined range &gt;&gt;= \p -&gt; spawnCommand (makeCmd p) &gt;&gt;= \ph -&gt; threadDelay phantomStartupWaitInMS &gt;&gt; return (p, ph) 
There is already a few haskell package parsing org-mode file (but I don't know how well they work). Also, you could have a look at how org-mode deal with TaskJuggler format.
Wouldn't that with the arity be something for dependent types?
Sweet! I'm going to set this up now. 
Is this useful for anything practical?
I think `Template [String]` would be more meaningful if split apart in a number of fixed-arity constructors, like `BinaryTemplate String String`, etc. More in general, what logic system do you want to represent? " _ _needs_ _ to _" seems to point to some resource-aware system
Also submitted in /r/programming: https://www.reddit.com/r/programming/comments/6t8gpq/timegif/?ref=share&amp;ref_source=link I liked [this exchange](https://www.reddit.com/r/programming/comments/6t8gpq/timegif/dlj2lkv/?context=5), where people noticed that the author added compression in a few hours and were impressed.
What about ATS (http://www.ats-lang.org/)? I never used it myself but these points from the main page look like a fit: ATS can greatly enforce precision in practical programming. ATS can greatly facilitate refinement-based software development. ATS allows the programmer to write efficient functional programs that directly manipulate native unboxed data representation. ATS allows the programmer to reduce the memory footprint of a program by making use of linear types. ATS allows the programmer to enhance the safety (and efficiency) of a program by making use of theorem-proving. ATS allows the programmer to write safe low-level code that runs in OS kernels. ATS can help teach type theory, demonstrating both convincingly and concretely the power and potential of types in constructing high-quality software. 
So I find that do notation often encourages me to write imperative code and think imperatively, so the more I've used haskell the more I've refactored do blocks into just function/bind chains. It's like in any other language, yeah you could write it the imperative way, but if the language has the function chaining syntax that gives you those warm fuzzies, you get better looking code, and you get to force yourself to think about the problem as a set of flexible data transformations and not you carefully manicuring some piece of data into something else. These days I usually start in do notation if a function is particularly complex and I want to slow down and do things in a really step by step way. Usually functions that I really understand/thought about/factored well are written in point free style or as function bind chains. Here's an example: changeJobActivityForCompany :: Bool -&gt; Auth.WAISession -&gt; CompanyID -&gt; JobID -&gt; WithApplicationGlobals Handler (EnvelopedResponse (ModelWithID Job)) changeJobActivityForCompany active s cid jid = getSessionInfoOrFail s &gt;&gt;= ensureUserIsAdminOrCompanyRep cid &gt;&gt; changeJobActivity_ active jid Before I got into this habit I would write `do` notation and use `when` to do things like throw errors, rather than putting that right in the function. I reformatted the "get the session, then check if it's not Nothing and throw a specific error" thought into one logical block (a function), rather than 1/2 imperative lines. The great part is, if I write the pieces modularly I can re-combine and not loose all the flexibility of a regular `do` block. Back to the piece of code you mentioned: I think that particular piece of code isn't very good (when I look at it now especially), I think I wrote it before I was better at recognizing how the let bindings worked. I'm pretty sure that I didn't actually need to make the step that does the thread delay indented, it was perfectly fine in that outer chain, and `p` (the port) would be accessible. Another reason this code is probably not the best is that I use super short variables when I could have just used good ones (If I did I wouldn't have had to explain what `p` was in literally the last paragraph), and I could have passed the p right through with a bind for something like: getRandomPortForPhantomJS &gt;&gt;= \p -&gt; makeCmd p -- just so can keep the p &gt;&gt;= spawnCommand &gt;&gt;= \ph -&gt; threadDelay phantomStartupWaitInMS &gt;&gt; return (p,ph) This code actually doesn't exist anymore in the codebase, but I saved it for the blog post while I was getting my raw thoughts down. 
Here is a little introduction to the library, in case you are still interested in documentation. https://github.com/lehins/massiv/blob/master/README.md
I wrote up a quick introduction, in case you are still interested: https://github.com/lehins/massiv/blob/master/README.md
I thought work last decade on ontologies established the (subject, relationship, object) triples are the canonical arity. (Gotham, needs, (Batman, how, hurried)) seems as good as the variable-arity encoding.
&gt; Sorry Because of its privacy settings, this video cannot be played here. :(
When's the library going on hackage? ;)
Interesting. Thanks for the detailed explanation. For what it's worth, and I say this as a statement of fact with attempt at persuasion intended, I prefer the `do` style, and I'm pretty sure Don Stewart said the same thing in [his 2016 Haskell eXchange talk](https://skillsmatter.com/skillscasts/9098-haskell-in-the-large-the-day-to-day-practice-of-using-haskell-to-write-large-systems).
Can anyone give an executive summary of what this provides that we don't already have on Hackage?
Oh no problem -- that response was kinda long. I can't say that I've worked with any large haskell codebases that I didn't write, so I definitely appreciate knowing your preference. I'd love to watch that video, is there a link that isn't behind a login? 
&gt; is there a link that isn't behind a login? I don't think so, although it ought to be free to sign up. 
Rust is easier and has the community momentum, for better or worse.
It seems like a lot of incremental refinements over the current crop of HAMT data structures. HAMTs have been popularized by Hickey and Bagwell of Clojure fame, but have got pretty good uptake in the java world. I dug around Hackage and I do find HAMT libraries, but I didn't find many that were not either experimental or old enough to be missing out on some key new ideas listed here. I am quite the novice compared to many here, so maybe I just missed them or I'm uninformed, but I don't think this design is the default (and by my reading represents some fundamental steps forward from popular but older references). It'd be great to see this work its way into hackage, with care to performance and attention to compatibility with discriminators, lenses and recursion-schemes. 
I had to turn Privacy badger off for the video to play. Skillsmatter is a terrible website.
I use nix on my mac, and I'm getting: &gt; error: Package ‘python3.5-bleach-2.0.0’ in ‘/nix/store/s72xmza5v5snzifi37rf3p3bhj0pv7i2-nixpkgs-81628ce54f703fd518432ec3b429083cb183d747-src/pkgs/top-level/python-packages.nix:2953’ is not supported on ‘x86_64-darwin’, refusing to evaluate. It suggests setting `nixpkgs.config.allowBroken = true`, which I have not tried.
love it. much better. Let me know if want to further your contribution and submit a PR to change the parser :)
&gt; I think Template [String] would be more meaningful if split apart in a number of fixed-arity constructors, like BinaryTemplate String String, etc. I agree, it needs more semantics. A multitude of constructors would mean having to handle each case separately. I used to make the arity one of its arguments -- Template Int [String] -- but that leaves the possibility that the [String] and Int could be inconsistent. So now I use a function called "arity", which counts the length of the [String]. &gt; what logic system do you want to represent? I want a human-friendly system. Flat graph syntax is hard; you have to be a programmer, or a person conversant in a scheme like RDFS, or both. And flat graphs have limited expressivity (described below) and limited readability. &gt; I thought work last decade on ontologies established the (subject, relationship, object) triples are the canonical arity. Indeed, such triples are canonical, and well suited to a flat graph, in which each edge (relationship) connects exactly two things. But what if you want to say "not X" or "maybe X"? You would need an edge with one member. Given the two relationships "babies need calcium" and "babies make bones", how would you express "babies need calcium because babies make bones"? You would need an edge from one edge to another. What if you wanted to express that the `_ needs _` relationship has sometimes been misused by a particular author, when they should have instead written `_ wants _`? That knowledge would have to be outside of a flat graph. It only takes one extra symbol (as described [here](https://github.com/JeffreyBenjaminBrown/digraphs-with-text/blob/master/Hash/the-hash-language.md)) to transform ordinary English into a DSL for reading and writing an RSLT. The examples from the previous paragraph become simply "#not X", "#maybe X", and "babies #need calcium ##because babies #make bones". (The # symbol is inspired by Haskell's $ symbol.) And because Templates are Exprs, they can be talked about as easily as anything else. 
Maybe? Processing ...
&gt; I've disabled optimizations during active development just to improve compile times As you should! This isn't an attempt to excuse slow compile times, but disabling optimizations is definitely a common practice for getting rapid feedback cycles during development.
What's different in this case is that I had to add a pragma to the file in question to disable it. Cabal isn't like rust's cargo tool that has a `check` option (just does type checking) and builds a debug build by default (no optimizations). As much as I can, I use `cabal new-repl` because that gives a fast turn around on dev stuff. But sometimes I have to `build` instead to find out what is going on. And it's those cases that were taking too long.
I didn't realize we had a HAMT on hackage, much less something using the CHAMP layout. A cache-oblivious HAMT could make dealing with large datasets nicer -- vectors are fine, unless you need to make small (relative the the dataset) changes that are index-localized but time-separated. Sharing is bad.
Hmm... I think I'll just skip this video then. (Not that I really strive for privacy online -- if you really care you can find my phone number and address...)
&gt; I want a human-friendly system. Okay, but that doesn't really answer the question. I think your best off starting with a well-established logic and then layering "syntax sugar", rather than deciding on a "human friendly" surface syntax and hoping that corresponds to a consistent logic. I see analogs to the invented vs. discovered language separation. https://www.youtube.com/watch?v=IOiZatlZtGU
&gt; Cabal isn't like rust's cargo tool that has a check option (just does type checking) and builds a debug build by default (no optimizations). Am I mistaken in thinking that `--disable-optimization` (or `-O0`) accomplishes this?
Ah, perhaps I'm mistaken. I've never used that flag before. I'll have to try it out in the future. Thanks for pointing that out.
[unordered-containers](https://hackage.haskell.org/package/unordered-containers) uses a HAMT. It stores values in leafs, whereas CHAMP stores them directly in internal nodes. The latter approach could save some indirections and some memory. However, to implement CHAMP you would need to use type casts, which java programmers have no problems with, but which are much less common in Haskell code.
ELI5?
Yes! That is a distinction I think about all the time. RDFS is invented and incomplete. "Bob has-wife Mary" implies "Mary has-husband Bob", but that can't be encoded in the graph. The "has" relationship has something to do with "has husband", but that's outside the graph too. What about "had husband between 1999 and 2007"? The RSLT gives the user all those relationships for free. "Bob ##was married #to Mary ###from 1999 ### to 2007" doesn't require the user to learn anything they don't already know, except how to make explicit the tree relationship they already implicitly know when they speak. And it makes clear the relationship between was-married-to and was-married-to-between_-and-_ for free. The nature of information is nested relationships of arbitrary arity. That's my "discovery". The user has merely to say what things are; they don't have to invent some weird procedure like "Gotham needs (Batman variety hurried)". It's very much like the distinction between functional and procedural programming.
Node layout shuffled around; keys and values contained in the same array as node children, hashes optionally in a separate contiguous array in each node. I think this removes the need for tagging "constructors", since array nodes represent all that's needed (I don't know whether OP considers hash collision nodes though). Also, I see a chapter on specialization (to different key/values types, I presume). We can try the same in Haskell, although I think the results would depend heavily on how unsafe one's willing to go.
I'm pretty sure unordered-containers uses HAMTs, and it's pretty popular. No idea if it has the latest and greatest tricks folded in or not. 
There's a summary at https://blog.acolyer.org/2015/11/27/hamt/ under "A new CHAMP" but not quite executive.
This [link](https://fpdl.vimeocdn.com/vimeo-prod-skyfire-std-us/01/2272/8/211364180/725555289.mp4?token=1502768997-0xf2d9470d8d8ed062d3a8f3231ae1122b92b78c04) should work. Edit: Did work until the token expired. Sigh. Paste `player.vimeo.com/video/211364180` into [savevideo](http://savevideo.me).
Speed is actually one of the biggest reasons you wouldn't want to use a Haskell crypto library, but not for the reason you think. While fast crypto is nice, it's actually more important that it's consistent in terms of timing. Compiler optimizations are actually a big problem when implementing cryptosystems [citation needed], because they can make operations take a variable (hah) amount of time depending on the variable values. This can cause the implementation to leak information, and opening up [timing attacks](https://en.m.wikipedia.org/wiki/Timing_attack). Imagine if your compiler made a shortcut so that a certain operation took 1% less time if a bit in your key was a zero, or something to that effect. By measuring the time it takes for that operation to complete, I can deduce information about your key that I wouldn't have otherwise. Many cryptography implementations will have critical bits written in inline assembly, or have specific pieces of code written to disable or work around compiler optimizations. TL;DR Haskell is actually too high level for its own good here, you probably don't have enough control to make a secure implementation. 
**Timing attack** In cryptography, a timing attack is a side channel attack in which the attacker attempts to compromise a cryptosystem by analyzing the time taken to execute cryptographic algorithms. Every logical operation in a computer takes time to execute, and the time can differ based on the input; with precise measurements of the time for each operation, an attacker can work backwards to the input. Information can leak from a system through measurement of the time it takes to respond to certain queries. How much such information can help an attacker depends on many variables: crypto system design, the CPU running the system, the algorithms used, assorted implementation details, timing attack countermeasures, the accuracy of the timing measurements, etc. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/haskell/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Non-Mobile link: https://en.wikipedia.org/wiki/Timing_attack *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^101067
Good bot
Thank you zoells for voting on WikiTextBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
I would point you toward Austin Seipp's Haskell Cast on security. In it he talks about various Haskell implementations, which he prefers, and why. He mentions both pure and FFI packages. Austin is a main contributor to the Haskell security ecosystem. I agree with him on timing attacks, though: timing attacks against a non-local server is not a threat vector for most code. He said (and this may come off as an attack, but I think it's a learning experience) that someone on some internet forum may complain, but that ought not to discourage you from trying to make security protocols. These areas are underdeveloped in Haskell, and we ought not let perfect be the enemy of great. 
There are no Oleg squares in the generated boards, he's usually good for a curly question or insightful answer.
Sorry to respond again but I wanted to play with linear types and check that my rough intuition isn't completely off before getting tangled up: If I understand this correctly `a:w` is a subtype of `a:1`, a is contravariant in `Monad m =&gt; m a` and covariant in `(a -o m b) -o m b`. So that is why `Monad m =&gt; m a -o (a -o m b) -o m b` is invariant in the weight of a and not a supertype of `Monad m =&gt; m a -o (a -&gt; m b) -o m b`? Anyway, thanks a ton for your work on this and the super interesting posts! 
I'm curious; can you or anyone else give me any other keywords to Google that might lead to more discussion of this? Those are, alas, a bit generic, even in combination.
In GHC 8.4, we'll be able to reliably pass plain old `ByteArray#` and `MutableByteArray#` (even when unpinned) to C code. Skip to the bottom of [this issue](https://ghc.haskell.org/trac/ghc/ticket/8281) for more details.
I wouldn't say I'm one of the major contributors. :) I just did it a lot for a job (many moons ago) and as a pastime. If anything Vincent Hanquez deserves a lot more credit than me -- he did a lot of the hard work I never had time to do myself. (Maintaining a TLS stack and libraries like cryptonite is a lot of work no matter how you slice it. I mean, I put *hundreds* of commits and many hours into my 'nacl' library before I was roughly happy with it, and I never even finished it!) That said, I definitely think there's huge amounts of room for spicing up cryptographic software design, especially with careful use of PLT and FP. And I also think the typical regurgitation of "don't roll your own cryptography, because that's the internet folklore" is fairly misguided, yeah. Not because it's 'wrong', but because it's an empty, meaningless statement that gives no understanding or insight into the problem. Cryptography is not excruciatingly hard, everyone just fears it (somewhat needlessly) out of self-enforced social stigma. --- As to the OP's question: it would be extremely difficult, if not near impossible, to get native Haskell code on the performance level of something like OpenSSL directly (in many cases, it's actually hand-tuned assembly). But I think you could definitely use Haskell as a *tool* to help design and certify extremely high speed ciphers that could be on par with OpenSSL (or even better!) Cryptol is a good example of what something like this might look like. On the other end of the spectrum, for a long time, I have very much wanted a typed low-level assembly language (maybe an eDSL) that can essentially do register allocation and scheduling for me, but not much more, for high speed primitives. 99% of all cryptographic primitives do not need a complicated programming language model. qhasm by DJB is something like this but it has a ridiculous implementation (classic DJB code) and is 100% undocumented. And recent work like [Unison](http://unison-code.github.io/) makes me think it would be feasible to pair this design with a high-powered code generator that takes detailed machine scheduling models into account. The pieces are all there, it's just a matter of fitting the square blocks into the round holes...
I don't have access to a Mac to test with, unfortunately. If you manage to get it working, let me know and I'll update my `default.nix`.
I am unstickying this as I need the space for a different announcement.
Just as an aside, I think when people recommend against rolling your own crypto I think what they usually mean (or how I interpret it) is don't "invent" your own crypto. I'm somewhat more likely to trust J. Random Hacker's implementation of AES than the stream cipher they cooked up over the weekend...
Using Haskell for crypto is both good and bad 1. Strong typing can be used to avoid a lot of bugs like buffer overflows and things like that. However 2. Writing the primitives like implementing AES for example is better done in a low level language like C or even assembly which is what /u/zoells is pointing to. I have been experimenting with this for some time in the raaz cryptographic library. For primitives, we had some pure haskell implementation which was supposed to be used for testing the other implementation. The hope was that the Haskell implementation will be easier and safer to write so it is good to use for testing other primitives (It is definitely not good for production both due to speed and other issues that /u/zoells already refered to. In the long run we found that the haskell implementations of primitives was not adding much to the readability of the code. So we abandoned it. Now we use portable C for the reference implementation. 
&gt; Error 410 Gone
I was never super interested, but ontology and RDF would be where I would start, maybe pick up some jargon from some of their documents / communication.
Can't say I understand the invariant/contravariant reasoning, but do explain if you feel like it. I'm not sure I agree `a:w` is a subtype of `a:1`, not even that there _is_ a subtype relationship. This gets particularly apparent when it comes to higher order functions, where dropping linearity constrains in the function argument changes a lot. 
You are talking to C. All bets are off. C functions may not be pure.
Of course. But the issue here is that after calling a C function, a Haskell function starts returning different values. Theoretically of course, a C function could have rummaged through the Haskell heap and wreaked havoc but I think people would not expect that. This is about raising awareness really.
How does it work?
This is not a safe Haskell program. Haskell doesn't have a keyword-delineated safe/unsafe split like C# or Rust, but C FFI is unsafe in all 3 languages. I think you can make the compiler warn/error on unsafe code (some libraries on hackage are marked "safe Haskell").
It is already bad enough that same pure code can return different numeric result at different hardware.
Theoretically that shouldn't be the case at all, and all hardware should ideally implement the same IEEE754 standard. Unfortunately not all hardware is standard-conforming. 
It's not just about whether the language makes such a distinction though. It's global state embedded in the processor beyond just languages. You can quite easily cause this behavior just by *linking* to a misbehaving C library. Yes an arbitrary C library can set a function to have the attribute of a constructor and cause code to be run at dynamic link time. EDIT: Found a discussion on HN that illustrates my point: https://news.ycombinator.com/item?id=9972521
Ok, so what do you want the GHC devs to do about it? I may be too much of a pragmatist but this doesn't look like much of a problem for real-life programs. Floating-point shouldn't be relied on to give precise answers either way, this is only as much of a footgun as all floating-point maths is a footgun, but this is a lot harder to hit your head against than, say, NaN or signed 0 or 0.1 + 0.2 =/= 0.3 or whatever 
I'm a pragmatist too. I'm not saying GHC devs should do anything. I see it more of an education problem. Yes floating point is unintuitive at times but it's also pervasive. I find that generally programmers, especially those working in higher-level languages aren't aware of the low-level machine-level details, and most of the time that's just fine, until it's not. Abstractions are leaky.
It sets the DAZ ([denormals](https://en.wikipedia.org/wiki/Denormal_number) are zero) bit (bit 6) in x86's MXCSR register, which makes the CPU treat denormals (like `1e-320` in the example) in the inputs as zero. So the floating point operation `1e-320 + 1e-320` becomes `0 + 0` (`= 0`) rather than `2e-320`.
**Denormal number** In computer science, denormal numbers or denormalized numbers (now often called subnormal numbers) fill the underflow gap around zero in floating-point arithmetic. Any non-zero number with magnitude smaller than the smallest normal number is 'subnormal'. In a normal floating-point value, there are no leading zeros in the significand; instead leading zeros are moved to the exponent. So 0.0123 would be written as 1.23 × 10−2. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/haskell/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Has the author actually benchmarked that using primops makes a difference in this case? I think that in most cases GHC can simplify things on its own.
Here are some key terms I pulled from Joshua Shinavier's PhD thesis: Knowledge graph, (personal) knowledge base, RDF, Sparql, Semantic Web, linked data, Web Ontology Language ("OWL"). I could do that because he and I share a knowledge graph using [Semantic Synchrony](https://github.com/synchrony/smsn/wiki) -- a program we very much [want to Haskellize](https://github.com/synchrony/smsn-why/blob/master/invitations/to-coders.md)!
This may help: https://cs-syd.eu/posts/2016-04-09-typesafe-polyvariadic-functions-in-haskell In short: It's possible, but you probably don't want to do it.
A very interesting observation.
[Feeling vindicated](https://www.reddit.com/r/haskell/comments/6kink5/welcome_the_new_moderators_on_rhaskell/djn2ttf/)!
You don't even need C. If you have IO, you can use safe Haskell functions to write random bytes to the memory of the Haskell process. That would change things too. Safe only verifies that when you say you're not using IO, you're not lying. Nothing more. *edit: I can't words*
I don't think that's what /u/Ford_O is trying to do.
I used to want something like this, until I realised _ . _ . _ . _ . _ .... (where `_` indicates argument placeholder) *is* a polyvariadic function in mixfix style.
Except that J. Random Hackers who try and implement standard algorithms mess them up *all the time*. See, e.g., the [Sony PS3 ECDSA failure](https://arstechnica.com/gaming/2010/12/ps3-hacked-through-poor-implementation-of-cryptography/). Or even when they implement the algorithms right they very often go on to misuse them. Most any homegrown crypto code you'll ever see will have things like unauthenticated CBC encryption with a fixed IV. Or a homegrown `hash (secret ++ value)` that's vulnerable to length extensions. And so on.
&gt; Haskell is this pure garden where the vulgaries of the machine are irrelevant to us. I hope no one seriously believes that 
I think the point here is that `anotherDenormal` is a pure function. The two print statements should print exactly the same value.
Yep, I consider to use infix operators instead of poly variadic functions, although they are not homoiconic.
Sure thing. I can write you a safe `f` such that main = do let s = "Hello, world!" f print s executes to completion but in the meantime, `s` has been changed to `"Houston, we have a problem"`. (Although it may only work on -O0 and on Linux.) 
You could avoid `FlexibleInstances` and `FlexibleContexts` by adding a new typeclass: class SumArgsArg t where enumArg :: t -&gt; [Int] instance (SumArgs a, SumArgsArg t) =&gt; SumArgs (t -&gt; a) where sumArgs is i = sumArgs (enumArg i ++ is) instance SumArgsArg Int where enumArg i = [i] instance (SumArgsArg a) =&gt; SumArgsArg [a] where enumArg is = is &gt;&gt;= enumArg
The standard doesn't require reproducibility as far as I'm aware though.
The standard is fully deterministic and of course results are reproducible.
I can write such a function too. But the reason for my post is that I think a lot of people don't really know about it. Like GP here we kinda assume `IO` values have localized effect, not realizing they can in fact change the behavior of pure functions. So this post is really to raise awareness. 
I just saw you made the exact same remark above and I just didn't read very well. Oops!
Here you can find solution for variadic composition: https://stackoverflow.com/questions/9656797/variadic-compose-function
 instance World `Has` Position where getStore = System $ asks positions First time I see infix usage of type class inside instance. Never thought earlier that it's possible =\
I am not sure what your invariants are but you can express a lot with [`dependent-map`](https://hackage.haskell.org/package/dependent-map). {-# LANGUAGE DataKinds, GADTs #-} import Prelude hiding (Word) import Data.Dependent.Map import Data.GADT.Compare type Graph = DMap Key Node data NodeKind = Word | Template | Relationship data Key a where WordKey :: Int -&gt; Key Word TemplateKey :: Int -&gt; Key Template RelationshipKey :: Int -&gt; Key Relationship data Node a where WordNode :: String -&gt; Node Word TemplateNode :: [String] -&gt; Node Template RelationshipNode :: Key Template -&gt; [Some Key] -&gt; Node Relationship instance GEq Key where geq _ _ = error "TODO" instance GCompare Key where gcompare _ _ = error "TODO" main :: IO () main = do let graph1 = insert (TemplateKey 0) (TemplateNode ["needs","to"]) empty graph2 = insert (WordKey 1) (WordNode "Gotham") graph1 graph3 = insert (WordKey 2) (WordNode "Batman") graph2 graph4 = insert (WordKey 3) (WordNode "hurry") graph3 allWords = [This (WordKey 1), This (WordKey 3), This (WordKey 3)] graph5 = insert (RelationshipKey 4) (RelationshipNode (TemplateKey 0) allWords) graph4 return () Here we do not statically encode template arity but it should be possible too.
Have a look at typed racket, which allows typing some variadic functions: https://docs.racket-lang.org/ts-guide/types.html#%28part._varargs%29
I haven't even finished reading the blog post but got stuck on a question. Why is it runText :: (forall s. (A.MArray s -&gt; Int -&gt; ST s Text) -&gt; ST s Text) -&gt; Text instead of runText :: (forall s. ST s (A.MArray s, Int)) -&gt; Text ? Edit: finished the article, thanks for making a beginner friendly guide like this! Agreed with mrkkrp that the explicitly unboxed math surprised me but testing that probably falls outside the bounds of this article. Finally (and this is probably more of a style question) are two lines per instance enough to jump to default signatures? I have been trying to reduce my trigger happiness for language extensions in code other people have to read but that one doesn't seem too bad.
Good bot
You are the 4310^th user calling /u/GoodBot_BadBot a good bot! He definitely is awesome.
Wow. Started off thinking "But why though" and finished thinking "That's a neat introduction to Haskell". Glad to see someone showing off how different paradigms approach problems
They use tokens to make sure the urls are ephemeral... Ok, I think I'm going to refrain from posting anything they're hosting.
Speculation: the `unsafeChr` part could be doing its job, but the comparison before it is unneededly unboxed.
The [State Monad](http://www.michaelburge.us/2017/08/15/how-do-i-modify-a-variable-in-haskell.html#state-monad) section has a couple of typos. First: &gt; Here is the above code written to use `State Int IntArray`: But the code uses `State LoopState IntArray ` instead. Second: &gt; [example code] &gt; &gt; Or the shorter: &gt; &gt; [exact same example code]
I admire the author's enthusiasm, but there's a fair amount of unnecessary work in some of these articles, so they're of unpredictably fluctuating value as how-to advice. Most glaring in this one is the use of primops, which GHC would take care of entirely by itself. This could have readily been spotted by reading some simplifier output or a little benchmarking. The simplifier (-dump-simpl) is a much better tool to use in easy cases like this, as with benchmarks you can stare at measurement noise enough to convince yourself that you're making a difference, when in fact nothing is happening.
I've had this idea of a general `Has` typeclass for a long time! Nice to see it in action (although in my mind it was more simply `w -&gt; c`). class w `Has` c where getStore :: Monad m =&gt; System w m (Store c) https://github.com/jonascarpay/apecs/blob/282e4b46743d327b3da63e35b471f92dca9e9dcd/src/Control/ECS/Core.hs#L14
Thanks for reading! I've corrected these.
It seems nice. What do you get by manipulating entities through the system instead of having them first class?
I quite enjoyed this, I especially like the writing style.
I'm a bit puzzled by this, because the mutable code that's not supposed to work because "we run into trouble when we realize there’s no built-in mutating assignment" is almost exactly correct. I fear that non-Haskellers are going to misinterpret this blog post as a reason to believe Haskell is far too complex to even consider, as happened [on Hacker News](https://news.ycombinator.com/item?id=15017542). import Data.Array.MArray import Data.Array.IO size = 10 (!) = readArray main :: IO () main = do -- 1. Declare the array arr &lt;- newArray ((1,1), (size,size)) undefined let _ = arr :: IOArray (Int,Int) Integer -- 2. Initialize the array to 0 sequence_ $ do i &lt;- [1..size] j &lt;- [1..size] return $ writeArray arr (i, j) 0 -- 3. Set the diagonal to 1 sequence_ $ do i &lt;- [1..size] return $ writeArray arr (i, i) 1 -- 4. Print the array sequence_ $ do i &lt;- [1..size] j &lt;- [1..size] return $ do arr_i_j &lt;- arr ! (i,j) putChar $ if arr_i_j == 0 then '0' else '1' if j == size then putChar '\n' else return () &gt; main 1000000000 0100000000 0010000000 0001000000 0000100000 0000010000 0000001000 0000000100 0000000010 0000000001
Good bot
Maybe a scan of "Ask HN: Who is Hiring" for Haskell, although most of the posters there also post here if there is a Haskell job.
&gt; lest we be under the illusion that Haskell is this pure garden where the vulgaries of the machine are irrelevant to us So far, the only two examples I see here of what is claimed in the title of this post are the following. I don't think either one of them justifies the need for that exaggerated warning. 1. One of the many well-known warts of IEEE FP is that it depends on external mutable state, although in normal straightforward usage this does not matter. 2. Carefully constructed malicious FFI operations can interfere with the operation of the running program itself. The fact is that these kinds of "vulgarities of the machine" are really irrelevant to us when programming in Haskell, in the vast majority of cases.
I don't think so. For example, [read this.](https://github.com/rust-lang/rust/pull/43554) There's [also this.](https://blogs.msdn.microsoft.com/shawnhar/2009/03/25/is-floating-point-math-deterministic/) This is a concern in many programming languages, and I don't think it's as simple as saying that the hardware is non-conforming. Rather, it appears that the standard is not detailed enough, leaving some room for interpretation.
In modern game engines like Unity or UE, your world generally consists of gameObjects that hold components. Those components collect state and have methods, together defining the objects behaviour, [see here](http://gameprogrammingpatterns.com/component.html). In an ECS, an entity (analogous to a gameObject) also consists exclusively of components, but those components do not have any associated code or methods. The behaviour is captured by so-called systems like the `mapR stepVelocity` system in the example. If we were to store entities as just a vector of components, each system would have to iterate over all entities in order to run. The key insight is that instead of doing it this way, we store each component in a specialized store along with the ID of the entity it belongs to. This way, an entity is just an integer and becomes mostly implicit. An entity with some ID exists as long as there are components that associate themselves with that ID. Systems are now * expressive, as they clearly define what operation they perform on the world * fast, as they only operate on the data structures that hold their relevant components, which also allows for easy parallelization * extensible, as systems can be composed atomically
Besides an upvote for what /u/aseipp wrote, a special upvote for the work of Vincent Hanquez /u/vincenthz.
You'd be surprised at the people you sometimes meet.
&gt; you can use safe Haskell functions to write random bytes to the memory of the Haskell process Can you? Which safe Haskell functions are those?
Nice real-world practical example of `StablePtr` and pinned byte arrays. Thanks!
By the way, I think ever calling into C has to be considered implicitly marked "unsafe". You have no guarantees whatsoever about what the C will do including writing all over your own memory.
Paper! ✋ We drew
I don't know about that rust PR, but the MSDN article is badly informed. &gt; Modern processors have vector math units that support advanced instructions such as dot product and fused multiply-add. Yes but compilers aren't allowed to make use of them automatically unless `-funsafe-math` or similar. &gt; Not every CPU supports denormalized floating point values. That's an implementation issue, not standardization issue. &gt; a smart optimizer might rearrange this to move the common subexpression outside the loop A conforming compiler isn't allowed to do that unless `-funsafe-math` or similar. &gt; The x87 FPU used by Intel can be switched between 32, 64, and 80 bit internal precision That's another problem in the implementation. In fact now the internal precision can be inspected using [a C macro](http://en.cppreference.com/w/c/types/limits/FLT_EVAL_METHOD).
Looking in from the outside, this title is a joke. People really need to stop slapping "IDE" on tools that don't do the "integration" part of the development environment, if you use something like NetBeans you rarely if ever need to leave NetBeans to achieve something you want to do, that's why it is an IDE. That said, Leksah has continually improved and is quite decent now. I recommend giving it a try if you do not need need any form of compatibility with stack. So long as you're not planning to have your code used by other people, this is actually not so bad, especially if you're not on windows. You could manually manage a cabal sandbox (which does somewhat defeat the purpose of an IDE, but oh well). There are also now several IntelliJ plugins that can manage your Haskell code, but as far as I remember there is no support for project management in those so you may as well just stick to a text editor. At this point I have given up on IDEs for Haskell. I use Visual Studio Code when working with plain Haskell, and I use emacs when working with lhs2tex. I highly recommend Visual Studio Code as a text editor, it is a fork of the Atom text editor and behaves much like a graphical emacs.
Regarding the two types for `runText`, it's a quick and easy exercise to try them both yourself, where you'll quickly spot the difference if you look at -ddump-simpl output.
There's also the approach of getting it right at initialization: array ((1,1), (size,size)) $ do i &lt;- [1..size] j &lt;- [1..size] return ((i,j), if i == j then 1 else 0) That is obviously a really simple example, but once you know that arrays are initialized lazily, it makes more complex examples easy. Want to determine the edit distance between two strings? dist = array ((0,0), (length xs, left ys)) $ concat [ [ ((0,0), 0) ] , do (i, x) &lt;- zip [1..] xs return ((i,0), insertCost x) , do (j, y) &lt;- zip [1..] ys return ((0,j), insertCost y) , do (i, x) &lt;- zip [1..] xs (j, y) &lt;- zip [1..] ys let cost = minimum [ dist!(i-1,j) + insertCost x , dist!(i,j-1) + insertCost y , dist!(i-1,j-1) + mutateCost x y ] return ((i,j), cost) ] How about a spreadsheet? λ :m +Data.Array λ :set -XGeneralizedNewtypeDeriving λ :{ ⋮ loeb :: Functor f =&gt; f (f a -&gt; a) -&gt; f a ⋮ loeb x = go where go = fmap ($ go) x ⋮ ⋮ newtype Row = Row Int deriving (Ix, Ord, Eq, Num, Show) ⋮ newtype Col = Col Int deriving (Ix, Ord, Eq, Num, Show) ⋮ ⋮ cell :: Row -&gt; Col -&gt; Array (Row,Col) a -&gt; a ⋮ cell row col = (!(row,col)) ⋮ ⋮ instance Num b =&gt; Num (a -&gt; b) where ⋮ (+) = liftA2 (+) ⋮ (*) = liftA2 (*) ⋮ (-) = liftA2 (-) ⋮ negate = fmap negate ⋮ abs = fmap abs ⋮ signum = fmap signum ⋮ fromInteger = const . fromInteger ⋮ :} λ :{ ⋮ loeb $ listArray ((0,0), (1,1)) ⋮ [ cell 0 1 + cell 1 0 , cell 1 1 + 1 ⋮ , 2 * cell 0 1 , 0 ⋮ ] ⋮ :} array ((Row 0,Col 0),(Row 1,Col 1)) [((Row 0,Col 0),3),((Row 0,Col 1),1),((Row 1,Col 0),2),((Row 1,Col 1),0)] 
While unfortunate, isn't this once per data type? I would hope that actual code bases introduce new data types very sparingly.
What's you're point though? That we should annotate all learning material with "* pure up to modifications to the behavior of the CPU"? I think that's a given =P
&gt; Started off thinking "But why though" ... and ended thinking the same damn thing. This is a great example of asking an XY question, and then solving the wrong problem. :P At least pick a problem that properly motivates mutation. Something where you get logarithmic slowdown, or where it's unclear was parts need to be mutated, or something! The proper way to get an identity matrix in Haskell is NOT to first generate a pointwise-0 matrix then modify it!
I regret that I can only upvote you once. If you'd surrounded your examples with a bit more prose, it would be better than TFA.
This won't be especially helpful for you, but problems like this are one of the reasons I proposed this: https://www.reddit.com/r/haskell/comments/6s4rjz/suggestions_for_deferring_errors/
Some systems expose the process's memory as a file (/dev/mem).
Aha, cunning!
&gt; The proper way to get an identity matrix in Haskell is NOT to first generate a pointwise-0 matrix then modify it! That's what I was thinking the whole time :)
Yes I am satisfied with your answer .. I started using vscode ...and found it nice with Haskell plugins.
A *fun* way to get some randomness for your Haskell program: {-# LANGUAGE MagicHash ... #-} import GHC.Types import GHC.Prim ... I# (unsafeCoerce# 3) ... [don't do this, thankfully it's not safe]
I found that flycheck auto check behavior can be check by setting the `flycheck-check-syntax-automatically`.
It might be a waste of time, but could you avoid timing attacks by having an algorithm wait around after it's done with the calculation until a fixed amount of time from the beginning? For example, if sometimes my algorithm ran in 200 ms and sometimes it ran in 400 ms, but in all cases the algorithm would just wait around until 500 ms had passed before returning a response, would this be enough to avoid timing attacks?
This may be too complex, but you could use compile-time dependent types. If you have a list of types `[a -&gt; b, b -&gt; c, c -&gt; d, ..., y -&gt; z]` then the type of a function that composes them all together is `(a -&gt; b) -&gt; (b -&gt; c) -&gt; (c -&gt; d) -&gt; ... (a -&gt; z)`, which you could compute with a type-level fold: (.&gt;) : Chain (Compose fs) fs type Chain z fs = Foldr (-&gt;) z fs type Compose fs = Foldr1 (\ (a -&gt; b) (c -&gt; d) -&gt; (b ~ c) =&gt; a -&gt; d) fs This resembles how C++ handles variadic templates, although in C++ you probably wouldn’t bother to actually compute the type—you’d just let the template expand and raise a compile error if the types don’t match up afterward. As an aside, I miss functions with a variable number of type arguments in Haskell—type-level lists of types are good enough, though.
Just gave it a try now, very nice and helpful --- thanks!
There're some crypto libraries on hackage by pure haskell, but the performance suck, likely it would be 10-30x slower than C/FFI counterpart. Many crypto algorithms use heavy mutations on a memory blocks, haskell isn't good fit in such cases because of it's immutability, boxing/unboxing data, and also GC. The C compiler can often do aggressive optimization so the assembly code may don't even copy registers, not to mention with inline assembly you can also use HW crypto extensions.
Late to the party, but let's try. I'm wondering about fine-adjusting the knobs here, consider the snippet: data UserQuery = AllUsers | UserById UserId | UserByEmail Email class Monad m =&gt; GetUsers m where runUserQuery :: UserQuery -&gt; m [User] Here we have the `UserQuery` acting as a descriptor of a query we want to perform, and the `GetUsers` typeclass acting as, sort of, effect descriptor (when I see `GetUsers` in constraints, I see that this function can access users). However, nothing stops us here from just dropping the datatype and having three methods for the typeclass instead. Also, how many typeclasses do you typically end with? Following the example, it implies it's pretty granular (`GetUsers`), but I wouldn't have any idea what would be the best way to lay them down (separate by read and writes? by entity type?). I know I should probably use my own judgement here, but I do wonder how it ends up in the codebases you've been working with.
&gt; He is using Haskell. If god would have had Haskell back then he would have banged the earth with sky, lights, animals and all that shit in less than one hour. But real programmers use C he said, and it took him the whole week. My favorite comment I've seen in ages.
re: hand-tuned assembly. How does that code perform on these new multicore (8, 10, 12, 18) processors? Does Haskell's vaunted "easier to parallelize" features help here? 
this hybrid of "vagaries" and "vulgarity" intrigues me
What is different in haskell 2020?
The "Basis" section of https://en.m.wikipedia.org/wiki/Strictfp explains why floating point operations might not be reproducible. My understanding is that the standard is also vague about certain edge cases. 
Non-Mobile link: https://en.wikipedia.org/wiki/Strictfp *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^101429
The crypto core functions are stateful, usually computation on a block depends on outcome of previous block, parallelism or concurrency does not help in this case.
It's not all that well framed, granted. But it's an interesting journey. Fair point
Which data structure are you using when you want a "vector-like" structure which support efficient modification ? `vector` is too slow (i.e.: it copies everything), or need the use of `IO` or `ST`. I'm looking forward for linear types to get zero copy updatable vector, but for now I'm using `unordered-containers`: it is less efficient than `Data.Vector` for access, but it offers persistence, efficient modification, growing / shrinking of the structure. It is more efficient than `Data.Sequence` (except for delete / insert in other places than in the middle). I'm wondering if it may be possible to special case an HAMT to create a really efficient persistent vector? No need to store the hashes, the index can be considered as hashes, and the locality can be really great.
Most algorithms aren't easily parallelizable at the level of shared state, they tend to require mutable state. So you won't get anything from that. (They *are* often parallel at the level of the instruction-level-parallelism, inside the processor), but assuming you mean "multicore server that responds to a lot of requests and does lots of encryption" -- like a TLS server, even then.... In terms of overall throughput (gigabytes-per-second), yes, it would help. In terms of clock-for-clock speeds ("cycles-per-byte-encrypted" or "cpb"), multicore will not help you, and it will still be impossible to compete. This is what really matters. The fastest, hand-tuned ciphers can get close to 1cpb on a modern machine, on a single core. Assuming you have a 3ghz CPU, that's ~3bil bytes per second provided you can feed the CPU fast enough.[1] That's 3GB/s *per core*. Let's say a Haskell implementation was 10x slower, so 10cpb (extremely optimistic). Then you'd need roughly perfectly linear scalability up-to 10 cores to get close to what a hand written cipher can do on one, with no extra overhead. Even assuming it was only 2x slower, and parallel -- at 1cpb vs 2cpb, assuming you have 20 cores, that's a difference between pushing 60GB/s vs 30GB/s. That's huge. For many things, whining about 1-or-2 cycles difference is meaningless. But for stuff like this it matters a whole lot, and absolutely every optimization counts. It's a restricted enough problem where it makes sense to do this trade-off. (Fast cryptography is also good because it means it's very cheap/easy to add it where it makes sense.) [1] There are a billion factors that could mean this aren't true like cache access patterns, or your overall bus bandwidth, or network card, or or or or... but just go with me here.
A weekly "New Haskellers: Ask anything" would probably not hurt as well, on this sub.
I love this idea. I submitted an [issue for FGL](https://github.com/haskell/fgl/issues/70).
Can new apps open anyways?
They likely will, there aren't a ton of folks in the TZs I want. Just a matter of me finding time to clean up the response sheet.
I'd be interested to see if rackets magic `...` can handle pairs of bindings. `(a -&gt; b) (b-&gt; c) ...` Or if not, then how one might go about typing OP's function in RT.
This is great feedback. I did some more testing and yes, the use of primops results in no performance difference. The implementations of these functions using primops came from base's [`Data.Char.intToDigit`](https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Show.html#intToDigit) so I went ahead and kept the primops in the initial version of the post. Updated the post to remove usage of primops and `MagicHash`. The content feels much clearer now to me. Thanks!
Did some more benchmarking, and yes, the use of primops was unnecessary. They have been removed from the post. See [this](https://www.reddit.com/r/haskell/comments/6trxhs/writing_performant_haskell_5_of_6_dive_into_text/dlnenit/) reply. Thanks for the feedback!
I don't know about your LISP, but you can accomplish poly-variadic composition in Haskell by splitting it into two functions: λ :t (unWrap $ compose succ) (unWrap $ compose succ) :: Enum b =&gt; b -&gt; b λ :t (unWrap $ compose succ succ succ succ succ succ) (unWrap $ compose succ succ succ succ succ succ) :: Enum b =&gt; b -&gt; b λ (unWrap $ compose succ succ succ succ succ succ) 0 6 The type signatures aren't too horrible: newtype Wrap a b = Wrap { unWrap :: a -&gt; b } class PVC a b r where compose :: (a -&gt; b) -&gt; r instance PVC a b (Wrap a b) where compose f = Wrap f instance PVC a c r =&gt; PVC a b ((b -&gt; c) -&gt; r) where compose f g = compose (g . f) (you could parameterize `Wrap` to get variadiac composition for all categories, but I left that out since we're going for easy-to-understand) However, a type-class is more open than `compose` needs. If we could instead express the constraint as a recursive sum (in pseudo-haskell or your LISP), that might help clarity: type PVC a b r :: Constraint type PVC a b r = (r ~ Wrap a b) || (r ~ (b -&gt; c) -&gt; r', PVC a c r') So maybe you want to define your type as a recursive sum? (&gt;.): (a -&gt; b) -&gt; (a ~&gt;&gt; b) where (x ~&gt;&gt; y) = (x -&gt; y) | ((y -&gt; z) -&gt; (x ~&gt;&gt; z)) 
That's describing how to write an operator `(...)` that satisfies: (...) :: (b -&gt; b') -&gt; (a -&gt; b) -&gt; (a -&gt; b') (...) :: (c -&gt; c') -&gt; (a -&gt; b -&gt; c) -&gt; (a -&gt; b -&gt; c') (...) :: (d -&gt; d') -&gt; (a -&gt; b -&gt; c -&gt; d) -&gt; (a -&gt; b -&gt; c -&gt; d') whereas OP's talking about a function that takes a variable number of arguments and composes them: (.&gt;) :: (a -&gt; b) -&gt; (b -&gt; c) -&gt; (a -&gt; c) (.&gt;) :: (a -&gt; b) -&gt; (b -&gt; c) -&gt; (c -&gt; d) -&gt; (a -&gt; d) (.&gt;) :: (a -&gt; b) -&gt; (b -&gt; c) -&gt; (c -&gt; d) -&gt; (d -&gt; e) -&gt; (a -&gt; e)
But really, how do you write Haskell like C. You don't.
Thanks! As for the `DefaultSignatures`, I like this extension but wanted to keep the public API as simple as possible. Those one-line [instances](https://gist.github.com/jship/43f7e6d1cedf64cce22581b111123eb9#file-hexywithdefaultsignatures-hs-L42) are definitely appealing though!
Would you say it's necessary to be able to read -dump-simpl output to quickly and efficiently improve Haskell programs performance? Thinking aloud, it kind of sounds like a high bar compared to profiling in other languages. Though, in other languages I suppose that measurement noise you're talking about exists as well and people just look at assembly output. [ghc-core](http://hackage.haskell.org/package/ghc-core) also generates very readable core so the problem is somewhat mitigated. My questions mostly stem from "How can I effectively sell 'Haskell in the real world'", and how much that is affected by requiring "read core" to produce (very?) performant Haskell.
Hopefully, they'll adjust the standard to that `foldl` isn't defined in a way such that its use is verboten.
&gt; Would you say it's necessary to be able to read -dump-simpl output to quickly and efficiently improve Haskell programs performance? I wouldn't say that. I've found you usually only need to look at core when you're dealing with things that GHC itself is proving to be bad at. Otherwise, just use the profiler, understand how laziness affects your performance (usually not hard), and remember that most optimizations in most real code (regardless of language) come from minimizing asymptotics.
From my own personal experience: I avoided looking at core for a long time due to intimidation factor, until Felipe Lessa convinced me to do so. I realized I'd been almost as foolish as when I was intimidated of trying out STM: reading core is tedious, but in no way *difficult*. I don't believe you need to profile at the level of reading core all the time. But the times when you need to do it, in a different language (like C or Rust) you'd instead be looking at assembly. I personally find it much easier to read and understand core than assembly. Maybe this is just me with rose-colored glasses, but I think Haskell wins this round on "makes it easy to make code fast." How often do I end up reading core? Not very. It mostly only applies to writing a library that's going to be used in dozens to hundreds of other projects. text would clearly fall into this category. My personal examples are things like conduit optimizations. I've rarely needed it on application-level code.
&gt; Yes but compilers aren't allowed to make use of them automatically unless -funsafe-math or similar. This is untrue. `-funsafe-math` is only required when the operation can produce incorrect results, vectorization or widening operations do not in general do this. GCC has no problem generating for instance dot product instructions without `-funsafe-math` for CPUs that have a proper FPU. This is very implementation dependent. &gt; A conforming compiler isn't allowed to do that unless -funsafe-math or similar. What exactly about this hoisting makes the operation unsafe? The compiler may choose not to do this for a number of reasons but I can't think of any that would be due to correctness. I'm sure you can come up with very contrived examples of where the compiler doesn't do this. But in general, it does try even without `-funsafe-math`
Apart from wasting time, the problem with getting such estimates, i.e. wait for 500 ms is almost impossible given the diversity of machines. So that is much more difficult than writing inherently timing safe primitives. If you are thinking of adding random pauses, remember that the adversary can run the process multiple times and use statistical methods. It is know (citation need) that such statistical attacks can even be mounted over network where there is an inherent non-determinism. 
I don't understand what's the issue here, and why is it advertised in these hostile terms.
The issue is that there's a group of individuals that have been trying to put obstacles in u/snoyberg's way whenever they see an opportunity. This time they're hang up on the wording &gt; The typed-process package is a more recent take on a process API, &gt; which uses this package internally. It features better binary &gt; support, easier concurrency, and a more composable API. You can &gt; read more about it at haskell-lang.org/library/typed-process which [rubs them the wrong way](https://github.com/haskell/process/issues/100#issuecomment-318975016) and in their mind violates some imaginary policy. And then going on to file a PR giving notice that if it isn't merged within 48h, it *will* get merged, barring any discussion, period.
This thread ain't happening. **LOCKED**
Agreed, and I would also recommand looking at stg dump i.e. -dump-stg. For me it's easier and cleaner. 
&gt; response times could be better for off-hours. What are "off-hours" (in GMT)? What sorts of content do mods usually remove? Mostly just spam bots advertising hot singles in my area? I don't really see much of that anyway. (spam, that is)
You are technically right that `-funsafe-math` is not required to produce FMA and similar things. But the actual flag necessary to ask GCC to produce FMA instructions is `-ffp-contract=fast`. It's in the same vein as `-funsafe-math`. EDIT: Sorry I didn't realize that flag is the default! That hoisting is unsafe because as the article mentioned, `(foo.Y + Bar) + Baz` is different from `foo.Y + (Bar + Baz)`. Unless instructed to by a flag, the compiler will never consider them to be equivalent. Examples are easy to construct: ghci&gt; a = 1.0 ghci&gt; b = -1.0 ghci&gt; c = 1e-320 ghci&gt; (a + b) + c 1.0e-320 ghci&gt; a + (b + c) 0.0
ATS is a very interesting and powerful research language, leveraging a blend of dependent types and linear logic. On the other hand, it's a rather complex language with a lot of not very ergonomic syntax and conventions. It has very small ecosystem to learn from and it seems to have worse tooling than Rust (I am not sure how many C tools like profilers and debuggers can be reused by ATS directly).
To elaborate from a different angle: It's basically the array of structs vs. struct of arrays distinction, where an ECS models stuff as the latter. This is mostly beneficial because not all game objects share *all* components. E.g., where the object modeling the `Player` needs components `Position` and `Health`, a `Rock` will only need a `Position`. You *could* model this kind of sparseness with `Maybe` fields, but that would be rather wasteful.
SublimeText3 + SublimeHaskell (be careful if you are on win10 + stack, some of the default settings of SublimeHaskell won't work) or VSCode+intero.
&gt; For instance, crypto on the client side would be too slow. It's also a bit easier to mess with. Could anyone explain me why you would want client-side crypto instead of server-side + https? EDIT: thanks!
End to end encryption means you *have* to do encryption on the client side. If the server ever sees unencrypted data, that's not end to end. It's useful for communication systems.
You might want to store data on the backend in an encrypted format and only decrypt it on the client side with the user's private key(in a case of a breach/leak this would add an extra layer of security). I've did something similar a few years ago using SJCL.
Not that I know of, something similar for Haskell would be great
This really seems like one of those areas where the browser/JS interpreter should expose some primitives. Edit: Looked it up https://www.w3.org/TR/WebCryptoAPI/ is in progress and https://developer.mozilla.org/en/docs/Web/API/SubtleCrypto seems to exist already
If you're going to Strange Loop I'm scheduled to [talk](https://www.thestrangeloop.com/2017/a-not-so-gentle-introduction-to-systems-programming-in-ats.html) about it.
Sounds like a lot of work! Just editing [one video a month for Montreal's FP meetup](https://www.youtube.com/channel/UCbLK7HM5Ox2tvFZbQ2ytT0Q) is already taking me a lot of time. Is ClojureTV ran by volunteers?
This is what I was about to say. Modern browsers have a fair number of crypto primitives available. Also, fwiw, web RTC provides e2e encrypted data streams. EDIT: Although upon investigation, WebRTC encryption is [kinda crappy, as RTP packet headers are not encrypted (!)](http://webrtc-security.github.io/).
What is the DataHaskell project?
:D It depends; it's a loose community of people interested in Haskell and data science/machine learning/numerics (https://gitter.im/dataHaskell/Lobby), an open-source organisation that reviews libraries and discusses how to use them in combination (https://github.com/datahaskell), a website with a knowledge base (www.datahaskell.org/docs).
Asian/European TZs are where we're lacking, we've got a lot of American TZ coverage, but only one in the non-American zones. Mods do two things, primarily. 1: Remove spam that gets past the filter, 2: Approve false-positive spam. I'd say #2 happens more than #1. There is also 3: Deal with situations involving community drama in a fair and de-escalatory way, that's the hardest job. It happens fairly rarely, but it's what I strongly select for when looking at candidates -- if folks have a history of being antagonistic, they're not going to be able to handle those situations appropriately. 95% of the job is boring, but the 5% of unboring stuff means that selecting through folks is not just "Yep, they're a warm body in the right TZ."
This is awesome, I've been waiting for this to happen for a long time! Can I make a suggestion about the order of things in the library - it would be good to start out with the main functions people are likely to need to get started; put `newHttp2Client`and `sendData` first, and then follow these with the data type definitions. Those functions give you enough to understand the API at a high level. I may just not be familiar enough with HTTP2, but I can't actually tell how to make a GET request with this library. This seems kinda fundamental, so could you add some docs explaining how to do this?
We had "Hask anything" for a while. I think it stopped just because someone needs to create a post every week. Seemed pretty popular while it was going on.
There was a recurring thread of that form last year, they were called ["Hask Anything"](https://www.reddit.com/r/haskell/search?q=HaskAnything&amp;restrict_sr=on&amp;sort=relevance&amp;t=all). They were quite popular, I don't know why /u/dagit stopped making them. You're welcome to start such threads if you want, I bet they would be as popular as they were back then.
I know lots of subreddits have bots to make weekly and monthly threads like that. So next time someone is looking for a little programming project, here's an option...
Ah, it didn't even occur to me that #2 happens (despite the fact that I've had it happen to my own posts in other subs). As for #3, I'm content with how things are run now. I know people have on occasion called for stricter mods, but the only time I'd be in favor of strict moderation is when drama is coming from sources who have little or no participation prior to the drama.
Meant as inspiration for what DataHaskell could become, allow me to link https://github.com/ryanrhymes/owl. It's OCaml and for good reason (and like most scientific computing code) OpenBLAS math routines. It has a nice API and interactive plotting.
A lightweight environment (not cpu and ram consuming embedded browser) for interactive numerical computing, not necessarily as fancy as HaskellForMac, like OCaml's Owl would be a major step in winning over users NumPy. I say lightweight because when I do scientific computations, the last thing I need is occupying big pieces of RAM and CPU for the interactive environments graphical shell. Haskell is predestined for this because it would allow more precisely encoding rules and invariants about the computations, giving you more confidence in the computed results. If we add Haskell's EDSL libraries for GPU offloading or ASM or C code generation, we could advertise another Haskell-only feature. A secondary motivation is that I'd like to see something like this in Haskell getting wide use so that maybe someday I can try to reproduce the computations from papers. Right now it's either no code published or code published that needs very specific environments hard to recreate in your environment.
When a function is specialised the `IdInfo` which exists inside an `Id` records that a specialisation exists. This information is serialised when interface files are written so when `f` is potentially specialised in another module, the `IdInfo` is consulted to see if the specialisation already exists and is used if it does. 
Yes! \o/
How is this scoped? If a module exports a function unspecialized, and two other modules that don't import each other both import that function and want to specialize it to the same type, I'm assuming they wouldn't be able to see each others' specializations?
I can't explain anything then, though. :P
&gt; Haskell is predestined for this because it would allow more precisely encoding rules and invariants about the computations, giving you more confidence in the computed results. Could you please give some examples? I was under the impression that Haskell's type system was less helpful for numerical computations than in other domains, because everything is a number so we don't get the usual advantages of precisely modelling the domain using algebraic datatypes. &gt; A secondary motivation is that I'd like to see something like this in Haskell getting wide use so that maybe someday I can try to reproduce the computations from papers. Right now it's either no code published or code published that needs very specific environments hard to recreate in your environment. Build reproducibility is now an advantage of Haskell? Wow, we have really improved over the last few years!
This'll probably make other people grumpy, but in the interest of serving your needs rather than theirs - the best odds at a fast resolution to your problem is to uninstall Haskell Platform and [install Stack](http://haskellstack.org). I made [a tutorial video with my coauthor](https://www.youtube.com/watch?v=sRonIB8ZStw), but the documentation on Stack's official website gets most people going. Good luck whatever direction you pursue, it frustrates me that the early experience is this rough for people.
Possibly relevant: https://hackage.haskell.org/package/reddit
Is it ok for people who aren't new? If so, here's mine: what's the current story/prognosis for compiling dynamic libraries? I know GHC itself has some support for this, but when I tried it before, it was a huge pain--I had to recompile the runtime with PIC, link everything manually, etc.. Is there anything on the horizon for simply marking your project as a dylib in your cabal file and having everything "just work"?
Don't worry about that. &gt; The best way to get the right answer on the internet is not to ask a question; it's to post the wrong answer. https://meta.wikimedia.org/wiki/Cunningham%27s_Law
Cool, interesting, thx. What about GPU, FPGA, ASIC? what's the highest cpb yet recorded?
I would really appreciate it.
Sure, it's for everyone who has a question. I'm setting up a bot atm to post a thread every saturday.
I'm setting up a bot at the moment to post a thread every saturday. 
I'm on it.
That... might be a fun machine learning project. :D
OP, you can also use [this get-started guide](https://haskell-lang.org/get-started) and the next steps after that if you prefer text over video.
`#`3 is always a case-by-case thing. We try to make it possible for everyone to have a say, while keeping things civil and avoiding letting the discussion derail. /r/haskell is pretty good overall at avoiding major drama, so the class of problems `#`3 covers make up a vanishingly small amount of the actual work, which is just tedious maintenance of the spamfilter and other errata.
I want to learn Haskell as my first language, would I be doing myself a disservice?
Thank you, I think video is generally less accessible/scannable than text.
I'm taking a course on functional programming next semester, and Haskell is the language we'll be using. Coming from an AI background, I am somewhat experienced in logic (FOL &amp; Fuzzy logic) and imperative languages (Python, C). As far as I'm aware, Haskell is not very widely used in the field of AI, but I'm interested in learning to think in the functional programming perspective. Are there any particular topics that are worth studying beforehand, or topics that are generally pitfalls in courses like this?
No. Maybe if it would be your only language. 
I think Clojure itself is backed by a company, it would make a lot of sense for that company to sponsor a YouTube channel.
I didn't stop for any particular reason. I think automoderator bot can do it automatically and that is perhaps the correct way to do it. I'm not a mod so I can't set that up. I pinged the mod team about it back then and no one responded. The mod team recently expanded. So maybe it's time to ask again.
Why?
Learn you a Haskell is a great resource for beginners, and it teaches it for someone with imperative experience but none in functional programming. You can read it free on the website.
Actually for ghcjs it is relatively easy to get high performance crypto primitives. The javascript engines will optimize a subset of javascript more or less directly to assembly, so you can simply write a macro language that "compiles" to javascript text instructions, `eval` the expression, and get near assembly performance. The code will also be much tighter and smaller than the equivalent OpenSSL-code. I implemented blake32s like this and it's several times faster than, say SHA1 in OpenSSL.
Thank you! I will check it out!
Somehow I forgot that linearity was only a property of functions. Also realized while reading the newer version of the paper that Hask-LL doesn't have subtyping which makes the whole thing a bit moot. Anyway, this was my thought process: `(a -o b)` is a subtype of `(a -&gt; b)`. For a rank2 type this would be reversed, so `(a -&gt; b) -&gt; c` would be a subtype of `(a -o b) -&gt; c` since the first function accepts strictly more arguments than the second one. Alright, now lets use `m p a` as linear monad where p is the multiplicity of the output a. Then we get something like (m p a) -o (a -&gt;_p (m q b)) -o m q b In the second argument p is contravariant. However the variance also depends on how we can use a type, so if we look at `m p a` as `((a -&gt;_p (m q b)) -o m q b)` then we see that the p is covariant in the first argument. That means (m 1 a) -o (a -o (m q b)) -o m q p (m w a) -o (a -&gt; (m q b)) -o m q p are incomparable. Anyway, the correct notation for the bind I meant probably would be data Multiplicity = One | Omega type family Arr (t :: Multiplicity) a b where Arr 'One a b = a -&gt; b Arr 'Omega a b = a ⊸ b class LMonad m where return :: Arr p a (m p a) (&gt;&gt;=) :: m p a ⊸ Arr p a (m q b) ⊸ m q b But I think that would require multiplicity polymorphism for function arrows to work which doesn't seem to be implemented yet. Edit: class LMonad m where return1 :: a ⊸ (m 'One a) return :: a -&gt; (m 'Omega a) bind1 :: m 'One a ⊸ (a ⊸ m q b) ⊸ m q b bindW :: m 'Omega a ⊸ (a -&gt; m q b) ⊸ m q b class SelectInstance p where mkBind :: (m 'One a ⊸ (a ⊸ m q b) ⊸ m q b) -&gt; (m 'Omega a ⊸ (a -&gt; m q b) ⊸ m q b) -&gt; (m p a ⊸ (Arr p a (m q b)) ⊸ m q b) instance SelectInstance 'One where mkBind f _ = f instance SelectInstance 'Omega where mkBind _ g = g (&gt;&gt;=) :: (SelectInstance p, LMonad m) =&gt; m p a ⊸ (Arr p a (m q b)) ⊸ m q b (&gt;&gt;=) = mkBind bind1 bindW compiles but apparently some bug makes it possible to use multiplicity ω functions in linear contexts.
Isn't that exactly what the [Shadowing](http://www.michaelburge.us/2017/08/15/how-do-i-modify-a-variable-in-haskell.html#shadowing) section's third example demonstrates?
The user query datatype would more appropriately be a more complex query dsl, otherwise you're right, a type class with three methods works fine. Generally, I only introduce this technique when the need is great. As an example, if I want to use redis, I'll abstract the service instead so I can run in process for dev and test. 
Most Haskell resources assume familiarity with imperative programming, but I believe [Haskell Book](http://haskellbook.com/) doesn't.
It sounds like you implemented blake32s directly in JavaScript. And sure, there are crypto libraries available on JavaScript. It also sounds like JavaScript can directly call the SubtleCrypto API that many browsers support, as [mentioned by /u/sigma914](https://www.reddit.com/r/haskell/comments/6u1fn0/we_know_that_pure_haskell_no_ffi_cryptography_is/dlp5hno/). WebCryptoAPI will also be available in the future. So, we have established that crypto is indeed available in JavaScript. The question remains how to get this into GHCJS. Isn't it just a matter of doing FFI from GHCJS? If that's true, this begs a question: Would the community benefit from a Haskell library that does FFI to JavaScript crypto libraries? Such a library would, I presume, only work with GHCJS—*not* GHC.
I read it as well for my course and it's pretty nice.
Are you familiar with the [singletons](https://hackage.haskell.org/package/singletons) library?
A "What are you working on this week"-Thread would be interesting aswell
Indeed. I mean, I have the bot already... 'what are you working on monday'? 'What papers are you reading wednesday'? :P
 I think I have seen videos recorded at various Clojure conference on ClojureTV, so I think it's either a channel where any Clojure related videos can be listed, or it is affiliated to a few conferences that post their stuff there. Not sure who runs it, but looks like they play more of a 'curator' role, rather than producing actual content. 
I don't think we should tiptoe around telling beginners to use Stack. I say this as a big proponent of Cabal new-build and especially Nix. Our goal for beginners should be to get them through the door and starting to learn as quickly as possible, and Stack is objectively better at this than any tool I may prefer for more serious use.
I'd say that's a fair bit more complex than introductory datakinds usages...
I get the following error when building: Warning: Couldn't figure out LLVM version! Make sure you have installed LLVM 3.7 ghc: could not execute: opt
 Compiling Control.ECS.Storage ( src/Control/ECS/Storage.hs, .stack-work/dist/x86_64-osx/Cabal-1.24.2.0/build/Control/ECS/Storage.o ) on osx
Hmm, indeed. I thought it was simply using TH haskell to generate singleton datatypes, but it looks like it's doing a lot more. In that case: OP, are you familiar with the singleton pattern? It looks like this: data SingHappy happy where SingYes :: SingHappy 'Yes SingNo :: SingHappy 'No SingNotSure :: SingHappy 'NotSure data SingThing thing where SingThingOne :: SingThing 'ThingOne SingThingTwo :: SingThing 'ThingTwo SingThingThree :: SingHappy happy -&gt; SingThing ('ThingThree happy) now you can write data Complex thing = Complex (SingThing thing) and the type of `Complex SingThingOne` will be different from the the type of `Complex SingThingTwo`, etc.
And then I'll write a slack bot to auto-post our standup notes to that thread, and someone else will write a bot which automatically upvotes comments which mention the libraries they care about, and then the cycle will be complete! /r/haskell, the subreddit for bots, by bots
You will be learning a better way of doing things that you can translate to other languages to a limited extent. The downside is anytime you work in any other language you will bemoan the lack of Haskell features.
Don't forget to share the source code.
Ok, i'm fine with that :P Nah, this kind of thread is very popular in the rust world: https://www.reddit.com/r/rust/comments/6tk648/whats_everyone_working_on_this_week_332017/
Well, I mean I can open a thread and ask if that's okay or too much.
It's a horrible Python hack... you don't want to see that.
Are you mocking me? I feel like you're mocking me. 
Other reasons to have client side crypto 1. Client side proof of work to prevent server from DOSed 2. Challenge response based authentication instead of sending password over the SSL pipe. 
The easiest fix is just removing the `-fllvm` flags from the cabal file; the difference in performance is maybe ~~10~~30%, and most of the time the added compile time is not even worth it. Alternatively, you could try `brew install llvm@3.7`, but I'm not sure if it's that easy. edit: I removed them from the library altogether; afaict they only matter on executables but I'm not 100% sure
My apologies! It was intended to be funny, but you were not intended to be the butt of the joke. The idea of having a recurrent discussion about what we're currently working on simply reminded me of standup meetings, which in turn made me realize that since our meetings are done via slack, I could reduce duplicated work by having a bot repeat the contents of the standup meeting in such a thread, which in turn made me think that having a bot reply to a thread created by another bot was a pretty funny situation.
I wasn't being serious either. :D The idea isn't bad though.
You might also have a client-only application that just needs to do crypto internally. Eg. a tool for manipulating certificates or just to store data in local storage encrypted, etc.
Sounds like a plan :D
&gt; Could you please give some examples? I was under the impression that Haskell's type system was less helpful for numerical computations than in other domains, because everything is a number so we don't get the usual advantages of precisely modelling the domain using algebraic datatypes. I think there is certainly a place for types in numerical work. I have done a great deal of numerical work in Python and will attest that the lack of a strong type system there makes the process of writing correct code incredibly painful. Being able to talk statically about, e.g., in which vector space a vector lives is remarkably helpful. I've done some exploration into strongly-typed approaches to linear algebra in Haskell in the past, but it has always been in the context of specific problems. Moreover, I have generally avoided using Haskell in cases where non-trivial linear algebra (e.g. matrix decomposition) is necessary as this really requires binding to a real linear algebra library which complicates an otherwise straightforward story.
IOHK people should consider having their company sponsor this.
&gt; How do I move my Haskell code out of the .bkp file and into separate .hs files? You can take a look at [str-sig](http://next.hackage.haskell.org:8080/package/str-sig) and [its](http://next.hackage.haskell.org:8080/package/str-text) [various](http://next.hackage.haskell.org:8080/package/str-bytestring) [implementations](http://next.hackage.haskell.org:8080/package/str-string) in hackage.next. I don't know if you can upload "abstract" packages to regular Hackage yet. As a learning exercise, I'm creating a [multi-package project](https://github.com/danidiaz/streamy) which tries to abstract some common streaming functions over the streaming / pipes / conduit packages. I'm building it with Cabal 2.0. The [test suite cabal file](https://github.com/danidiaz/streamy/blob/master/streamy-testsuite/package.cabal) contains an example of how to instantiate the same library in several different ways in a component.
http://blog.ezyang.com/2017/01/try-backpack-cabal-packages/
Why IOHK in particular?
Well, I'll post the thread until someone sets up automoderator.
The first thing to investigate is probably whether some of the crypto libraries can use conditional compilation like what is done with some of the base libraries that work well with GHCJS.
I second this. That thread is really useful to have a general idea what other people do and get some inspiration for your own work.
Hook me up!
Hi, happy it helps! Thanks for these suggestions; I've opened two bugs to track them. They should be easy enough to be fixed soon. If you have a GitHub account I'd appreciate if you could review my changes. For the "how to make a GET" request, do you expect to see snippets or a fully-working example (which needs imports, TLS params as well)? So far the best example currently is the binary I use for testing and that I've (annoyingly) attached to the library at: https://github.com/lucasdicioccio/http2-client/blob/master/app/Main.hs .
Certainly looks like it is run by Cognitect, the company behind Clojure. "ClojureTV brings together talks and presentations from the community, major Clojure conferences, and Cognitect. Here you can find Clojure/conj, Clojure/west and EuroClojure talks, as well as custom video tutorials and presentations from Rich Hickey and the Cognitect team." [https://www.youtube.com/user/ClojureTV/about](https://www.youtube.com/user/ClojureTV/about)
Depends on the algorithm and many implementation specifics. (Not every algorithm is well equipped for GPUs; FPGAs are more flexible but harder to design for). But dedicated hardware will smoke consumer CPUs easily. For hash functions like SHA-2 for example, GPUs can do hundreds of millions or billions of hashes per second, dominating CPUs. 1cpb on a 3Ghz CPU is ~3 gigabytes/s. Sounds impressive on paper, but a clever FPGA implementation of something like AES can do e.g. 32 bytes *per cycle*, for an effective rate of (1/32)cpb. Assuming your clock is at 400 Mhz that's 12.8GB/s, so that's 4x the speed at 1/6th the clock frequency. Intel's latest FPGAs are at 14nm and have 1Ghz clocks -- that's 32GB/s But consumer CPUs are vastly cheaper, smaller, generally very energy efficient for their features, and everyone has one. (Economies of scale mean consumer off-the-shelf hardware can compete in terms of overall performance/power/availability for many scenarios. Only extremely small numbers of people tend to go for hardware acceleration like this.) So in practice, software implementations are vastly more important for the majority of people. A 20 core xeon will be *less expensive* than that 1GHz FPGA for example.
I met one of their developers from Berlin briefly. They seem to be investing heavily in Haskell, and across Europe. It seems like a natural fit for them to give back and grow the Haskell community.
I'm currently reading Haskell Programming from First Principles and I'm finding it to be too long for me (~1000 pages). Would LYAH be good alternative? Given that I read LYAH instead, what would be a good book on "practical" applications? I've looked into Real World Haskell but I heard that it's outdated.
Since we are talking recurring threads: how about a quarterly hiring thread? The netsec community is [doing that](https://www.reddit.com/r/netsec/comments/6nveri/rnetsecs_q3_2017_information_security_hiring/), and it seems quite popular.
Thanks!
I want to learn haskell, I use mostly python and I know some Erlang, Elixir and Elm, but very basic stuff. What do you recommend, learn you a haskell or the haskell book. That the haskell book is not free is not an issue because my company has a learning budget, and they can buy the book for me. 
Well, crypto algorithm designers very often pay close attention to parallelism, but they tend to think of it in *intra-core* terms—they design their algorithms to facilitate modern CPUs optimizations like pipelining, out-of-order execution, SIMD and so on to achieve the most parallelism possible. Basically, with crypto you often *know* that squeezing the very last bit of performance out of your hardware is going to be very valuable, so they tend to design with that in mind. One recent example is that there's been a little bit of talk lately that Intel's AVX-512 SIMD instruction set may make software ciphers competitive again with hardware-assisted AES performance.
I've read LYAH and I'm planning to read the Haskell book (if they answer my emails) - so far I would prefer the Haskell book based on the recommendations I've gotten on here. It's supposed to be the best resource but I can't afford 70$ for a Haskell book... that's three weeks worth of food.
Check out the ghcjs-dom module GHCJS.DOM.SubtleCypto. The JSFFI version of the module is [here](https://github.com/ghcjs/ghcjs-dom/blob/master/ghcjs-dom-jsffi/src/GHCJS/DOM/JSFFI/Generated/SubtleCrypto.hs).
Papers would be good as long as there is some kind of specification of how heavy the maths contained is (e.g. the linear types paper was a work of art that was a fairly good introduction to the topic but others have required a very good understanding of catagory theory). Hiring would be awesome, I'd love a Haskell job, hopefully my work will let me do more Haskell soon! Questions/Noob thread is also worth doing, there is r/haskelltil but it isn't quite mainstream enough. 
Maybe a categorisation of Beginner, Intermediate, Advanced, Expert would help.
Have you tried org-mode (babel) with R and ESS (Emacs speaks statistics) ? You can get Haskell working with babel, but having the full ESS working would be great (even though In bit sure what ESS brings compare to normal Babel org-mode)
I've used ob-sh in the past. Are you sure scientific computing would be fine with the static nature of org-babel? It's okay for producing a final paper for print, but aren't we talking interactive data playgrounds? I mean when you plot the result of computations in 3d space, I think you might want to interact with the mouse. Same goes for 2d plots, simplest action being scaling stuff interactively without recomputing anything. org-babel could support this if you generated maybe HTML frames for it to execute in an embedded browser, but browsers are clunky, bloated and a nightmare to program content for. The number of different interactive visualizations for scientific computing is finite and manageable to support explicitly, without embedding a WebGL or HTML canvas view. Mozilla servo is built very modularly and pieces of it could be reused, if you insist on browser API.
&gt; requires binding to a real linear algebra library which complicates an otherwise straightforward story But it isn't it worth it that you can bind those math primitives into Haskell in a way that helps you catch more errors than you would in Mathematica or IPython? Common C++ scientific code will make mistakes because it's all just an int or a float but if you can enforce that it must be of type Velocity and not just double, you will have a very narrow set of functions that produce and consume the value. This is very basic and you can go further. You might be able to pull this of with C++, but with Haskell this is just the beginning and doesn't require language gymnastics.
Probably a good start at the least. Certainly makes sense to me.
Valar morghulis.
Are you on Windows Creators Update? If so, you ought to grab the 8.2.1 release (or find the applicable binary). I don't believe stack will solve your problem if you are on Windows Creator
Real World Haskell is also good. It's old, which is a pain because some examples don't compile anymore, but it's vastly easier to swallow than LYAH, imho. And it wasn't that hard, as a novice, to do some googlefu and learn what's changed, fix it, and get on with the lessons. LYAH is a good introduction to basic principles, but you don't come away from it with much in the way of practical knowledge. 
I dunno about a weekly recurring papers thread, but a stickied 'Papers translated into programmer nomenclature' thread would be absolutely brilliant. People could post translations (or link to blog posts) for various different influential papers, and the community would have a really valuable resource for prospective Haskellers who'd like to learn about techniques or concepts, but aren't from an academic background.
&gt; It starts to feel fiddly/less readable to me though with the double-quoting and string appending when I have more than one spot to replace: In that case I think I'd simply put one chunk per line: specPragma :: String -&gt; String specPragma t = concat [ "{-# SPECIALIZE buildWordAtBase :: " , t , " -&gt; (Int -&gt; Char) -&gt; " , t , " -&gt; Builder #-}" ] But then again I don't know anything about quasiquotes so I can't really judge one vs. the other.
Correct me if I'm wrong but the y combinator is similar in nature to the fix function?
Also be aware that [it is documented in the manual](https://downloads.haskell.org/~ghc/master/users-guide/ffi-chap.html#floating-point-and-the-ffi).
No. Imperial College London runs a world-class Computing course and does Haskell as the first language for all undergraduates for a long time by now. It usually turns out quite well for them. Some even become Haskell consultants and make a living from writing Haskell code every day.
Thanks for the pointers! In parallel with this, I'm going to work through Edward Yang's original tutorial (which was very instructive, by the way) again to try to remember what I got stuck on.
Yes. Actually weekly would be very often. I love the translation idea. It would be great to get to the point where average developers feel confident with the theory behind ghc, I'd love to participate in bug fixing and ironing out some of the peculiarities of ghc but don't feel confident with all of catagory theory etc.
This absolutely. You SHOULD NOT use bkp files if you actually want to put together and distribute Backpack to other users in Cabal. It's just for playing around with examples.
noo learn you a haskell is terrible from a pedagogical standpoint. the monkey-see-monkey-do style tricks people into thinking they're learning only to have them get stuck when they actually try to build something. start with: http://haskellbook.com/ it costs a little money, but that's worth the 1-2 years of your life you save.
I wrote this post two years ago, but for one reason and another I haven't been able to put it up until now. Better late than never I suppose! Incidentally, the two packages mentioned, z80 and zxspectrum, are up on my GitHub but not on Hackage. I don't have time to maintain them any more, unfortunately, so if anybody wants to take them off my hands and put them up on Hackage, etc, I'd be grateful! If there's a fork that's being actively maintained I'll update the post to point at that one instead. If you just want to play around with them without committing to maintaining them that's cool too :-) 
Why what?
Except the y combinator doesn't require your language to support recursion like fix does. So the y combinator proves that more things are nonterminating than it might have initially seemed.
Why python? That seems somewhat incongruous.
&gt; Also, you have to quantify things like "lots of Haskell enthusiasts" and "not many Haskell jobs" for it to be meaningful. There are typically 0-1 Haskell jobs advertised in my city and &gt; 1000 .NET jobs. For example. &gt; You say it's "simple supply and demand" but you didn't account for the fact that not all enthusiasts are qualified for Haskell jobs. How does this work with new programming languages like Go? At some point companies do take on staff that are smart and can learn new languages. Especially if they already know the language and merely lack commercial experience *in that* language.
What algorithms did you use in the client side? Any recommended libraries? Is it safe?
Learn LISP/Scheme from SICP first. Learn how to express yourself using computer programs first. Then pickup Haskell to learn how to express yourself *correctly*
you're doing yourself a service. e.g. definitions are simpler: like the the fact that "f x = x + 1" means "f is defined a function that adds one", instead of "... = ..." meaning "this statement of assigning/updating something is executed by the machine at some point". fwiw, one of my friends is learning haskell, and ranted about how confused he was being taught java in a class a few years ago, and how much more understandable haskell is. 
I think "what are you working on?" threads are a good idea. I kinda got the impression that Haskell folks aren't really working on open source projects that aren't general Haskell libraries and I'd like to know if there are more oss written in Haskell.
Are you attempting to fold over the `Set`? If so, use either [`foldr`](http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Foldable.html#v:foldr) or [`foldl'`](http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Foldable.html#v:foldl') from the [`Foldable`](http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Foldable.html) type class. It's best not to deconstruct the data-structures from the `containers` package directly . For this reason, the module `Data.Set` does not export it's constructors.
I am generally trying to compute a connected component, remove it from the set, and then continue (so there are more parameters, etc), but I attempted to abstract to the main pattern I needed. Often, I use a List instead of a Set, because I can't quickly think of a constant operation to remove one element and split off the rest of the Set, even though a Set would semantically model the data I am dealing with better.
At least with `Data.Set`, there simply is no constant time access to the minimum element, since it necessarily exists down a tree. But `log n` time really ought to be good enough for most things, realistically. If you don't care about it being the minimum element, and just want *any* element, I still don't think you'll have much luck. Two sets that are "equal" may only have constant time access to different elements. The amortized algorithms used in `Data.Set` mean that two sets that were constructed in different patterns can have different internal states, despite having equal elements. So there's no way to gain constant time access to anything without exposing that internal state as part of the contract. The `splitRoot` function is probably the closest thing to that that you'll get, but of course it only exposes further sets. I don't know about other Set alternatives though. But anything you would want to do recursively, you can probably encode with a `foldr` one way or another.
To add a bit to my previous reply, for some applications like proof of work, side channel information is not a problem. So even if we do not have the full crypto stack in place as preventing against such side channel attacks are difficult in a JavaScript setting, it might be a good idea to have some such restricted crypto applications. For example assume the following REST app which has a set of users with argon2(salt, password) stored in the database for authentication. When an genuine user tries to authenticate via password, the server will have to do a relatively expensive argon2(salt,password) which can be DOSed by sending a lot of spurious auth requests. If every auth request involved a proof of work this will prevent the adversary from mounting such attacks as it would cost him resources. I am not so familiar with what current webframeworks do about this problem. 
While it's not _great_ you could something like so: f :: Set Int -&gt; Int f st = -- Use lazyness to get the "first" element of the set in probably O(1) time -- Haskell won't create the whole list, just the first element you need. -- Worst case this is O(log(n)) and the same as using 'Set.lookupMin' case toList st of [] -&gt; 0 x:_ -&gt; let q = process x st -- make sure 'process' handles the case where x is in st st' = (st `delete` x) \\ q in (compute q) + f st' Without knowing more about the operations involved, I probably can't be of much more help.
Yes. The Y combinator is the fix function. The one notable thing is that in the simply typed lambda calculus, Y and fix are both ill-typed. 
We do that every 2 months in /r/ProgrammingLanguages because things tend to move slowlier over there. For /r/haskell I figure every 2 weeks would be a good balance between frequency of updates and actually having substantial work to show between updates.
Does that render one of the `Unboxed`/`Storable` array/vector variants redundant?
We used the SJCL library and I think the algorithm was AES with some key stretching applied to the users password. It's relatively safe but there are few problems with [crypto in the browser](https://tonyarcieri.com/whats-wrong-with-webcrypto).
The [thesis](https://github.com/ezyang/thesis/releases/tag/final) is another good resource, and quite readable.
IMO, if you want to experiment with Backpack, you'll have a *way* better experience if you just use the tool it was co-developed with (i.e. `cabal-install`), and thus has had native Backpack support for several months already, rather than trying to use Stack at all costs. While at it, you can use the opportunity to try out the [Nix-style local builds](http://cabal.readthedocs.io/en/latest/nix-local-build-overview.html) and help us improve it by providing feedback.
Someone's ought to write a "LYAH considered harmful" article.
Haskell book. Maybe the haskell wikibook instead if you have a mentor or something like that.
paging /u/bitemyapp
Get well soon
Some just configure Automoderator to do it.
The threads inspired me to make the [Hask Anything!](https://haskanything.com/) website some time ago. It's been a while since I could work on it, but the functionality to add stuff should still be working.
Yes, timing attacks against Haskell crypto are a problem. But browser based crypto [has its own set of issues](https://tonyarcieri.com/whats-wrong-with-webcrypto). The main issue is that securing web applications is a really hard problem - and if you're including the website operator in your threat model (i.e. you are trying to provide end-to-end encryption) then it is basically impossible.
&gt; ghcmod.vim : the current buffer has been modified but not written Save the file before running it. Though [intero-neovim](https://github.com/parsonsmatt/intero-neovim) works much better for me, if you're willing to switch to neovim.
Hi, thanks for your comments. In this case, will `Complex (SingThingThree Yes)` be different from the type `Complex (SingThingThree No)`?
The fix function doesn't require *syntactic* recursion. In Haskell it's implemented with Haskell recursion, but could just be a primitive. The fix function does require *semantic* recursion, because it provides it! For these reasons it is indeed similar in nature to the fix function. 
I asked the question on SO and found the answer really interesting.
Is signletons not made largely redundant with TypeLits, etc. part of GHC now?
I'm currently trying to get out of the Gold league in [Coders strike back](https://www.codingame.com/multiplayer/bot-programming/coders-strike-back) from CodinGame. For those who don't know, this is a (pod) racing game where you battle other peoples bots. They support a large number of programming languages, one of which is Haskell :) This is part of my "learning Haskell" project. It's much more practical than doing Project Euler challenges, though those are nice too. At the moment I've hit a wall with manually optimizing the trajectories, and I've been trying my hand at some neural networks in Haskell. I'm happy to report that I got back-propagation working last week, though I'm still struggling with reinforcement learning. I found a [real nice lecture series by David Silver](https://www.youtube.com/watch?v=2pWv7GOvuf0) and I'm almost finished with those, and can start implementing it in my bot.
I'm sure we already had this discussion, but is `splitRoot` a function which breaks referential transparency? I mean, `a == b` does not imply `splitRoot a == splitRoot b`. Prelude Data.Set&gt; (splitRoot (fromList [1,2]), splitRoot (fromList [2,1])) ([fromList [],fromList [1],fromList [2]],[fromList [1],fromList [2],fromList []]) This really annoy me ;)
&gt; (Aside: at first I thought the `Con` pattern synonym would be useful here, but on deeper inspection it seems entirely useless. You must use `eqTypeRep` instead.) I can't verify atm but there should be pattern synonyms that make this pattern Dynamic (App (eqTypeRep (typeRep :: TypeRep Delayed) -&gt; Just HRefl) a) x nicer
Because I know Python and don't know much Haskell. 
I thought the provided answer was very complicated. My answer. Why not define {-# LANGUAGE ExistentialQuantification #-} data Delayed' = forall a. Delayed' (Delayed a) and then store than in the `Dynamic`? You can then `cast` it out of the dynamic, case on it, and pass the result to `cancel`. (Depending on what your use case is you may no longer even need the `Dynamic`.) 
That would be interesting. That's a task for a mod though.
Maybe you could write the servant bits in some Reader monad that takes the authenticated user, and use [`enter`](http://haskell-servant.readthedocs.io/en/stable/tutorial/Server.html#using-another-monad-for-your-handlers) to provide all the handlers with user data. Not sure exactly what the code that ties a servant app and a yesod one looks like, but that sounds like something that should work. Feel free to ask questions if I'm not making any sense here and if more explanations would be needed.
Are you sure you want the 32bit version?
You can only change this by writing horrible Haskell hacks. It worked for me!
This kind of discussion comes up from time to time. I find the behaviour annoying but there's not a lot we can do about it. Functions like `splitRoot` are too useful to omit. I guess you could technically put it in `IO` or a `Nondeterministic` monad. If you can get away with fold :: Monoid m =&gt; Set m -&gt; m instead of `splitRoot` so much the better, because if `m` satisfies the monoid laws the result is deterministic.
Mondays? I just decided for thursday.
That's why I'm in this sub. But it's so easy with Python - there is [praw](https://praw.readthedocs.io/en/latest/).
In the actual use case I need the Dynamic as well as keeping the type `a`. Delayed is basically equivalent to `Async a`, but actually doesn't start the computation until asked. It has mainly three functions : + `start :: Delayed a -&gt; IO ()`, start the computation if needed. Could work on `Delayed'`. + `cancel :: Delayed a -&gt; IO()` cancel the computation. Could also work on `Delayed'`. + `getDelayed :: Delayed a -&gt; IO a` return the computed value. This is the main function and needs to know the `a`. Then there is a cache, which is roughly `Map String (Dynamic, UTCTime)`, which keeps cached values and expiry date. The Dynamic is only there to store and retrieve the value (and it's somehow hidden to the user). The combination of two (which is the main use case), is to actually PRE-cache values between requests. By pre-caching I mean, process a HTTP Request, send a response, and THEN compute and cache some value which I think the user will need in it's the request. There are lots of usages. For example if someone create a resource with a post request. The response is a link to the view of the created resource. Often, the user then follow the link to view the resource. After created the resource, I can pre-cache the view resource page (or at least its database access). Another case, is I can display the same resources with different view (tabs). It is more likely that the user will actually browse the different tabs, so I want to calculate and cache the result of all the different view. However, the first time the user view the resource, I want to only render the current tab, send the response , then calculate the other tab, and cache them so there are available to the next requests. The basic pattern (in pseudo haskell) looks like : do delayeds@[a,b,c] &lt;- mapM preCache (computeA, computeB, compute C) resp &lt;- case tab of 1 -&gt; render a 2 -&gt; render b 3 -&gt; render c mapM_ start delayeds -- start everything return resp Everything works fine, I get super snappy response time but for debugging purpose, I want to display the content of the cache (which stores everything as dynamic). For that I need to cast the dynamic to *ANY* `Delayed` to be able to display the blocker status. 
Thanks, that does help, for the servant side of things. I'll have a play with the example of `enter` in the tutorial.
Having looked through the code for `WaiSubsiteWithAuth`, I'm thinking I might need to create a new type of subsite and write my own instance of `YesodSubDispatch` for it. Can anyone confirm if this is a sensible approach?
I think a "what are you working on thread" would really help with visibility for smaller projects.
Time for you to write hraw!
&gt; Then there is a cache, which is roughly `Map String (Dynamic, UTCTime)` Are you sure you don't want `Map String (Delayed Dynamic, UTCTime)`?
God no. :P
Well, I'm not only caching Delayed. The cache is a general cache which I could package independently. I could indeed cached `Delayed Dynamic` instead. I didn't do it because I prefer to hide the Dynamic and I only encounter this problem when I tried to display the cache, which is only for debugging purpose. Also, the code (even though complicated) works now, so I don't really need to change the cache API. 
And by the way /u/MagicMurderBagYT thanks for all the great ideas about improving this channel.
No idea what's happening on that website, but I hear the worst noise ever. Even if I mute the tab within firefox.
Gladly. I have some time to spare to do this atm.
That's a good tip, I think. SICP is great.
Excellent idea! Multiple categories\tags will be of great help.
Monday is good - ideas are still fresh after weekend "diving" into pet projects :)
&gt; a quarterly 'Hiring' thread Monthly? Post As You Go? Just thinking of hypothetical situation when my dream job opportunity appears a week after quarterly hiring post...
I can post them monthly as well, if there's enough activity.
I just posted it. :( That's a really good point, tough, I didn't think of that... I will have to postpone it then.
Yeah, not enough activity is the problem. On the other hand, someone just has to break this magic circle :)
It's not *technically* violating referential transparency, since `Eq` is not a statement that if `a == b` then `f a == f b`. Like I might write a data type to represent the sum of a pair of numbers `data SumPair = SumPair Int Int` where my `Eq` instance just checks that the sums of each pair are equal, not the individual numbers. Stuff like this is ultimately the reason `Set` couldn't be a functor even if we did allow the `Ord` constraint to sneak in somewhere.
&gt; I bet this suffers from quadratic blowup for something like Ord instances for types with 29 constructors. It's pretty awful if it's the case. Couldn't the derived instance use unsafe features (in OCaml you can access a constructor's representation via functions in the `Obj` module) to quickly compare constructrors?
Ah, I just tried it out for a simple enum with 30 fields. GHC seems to be smart enough to use `tagToEnum#`, so at least for the enum case things are fine. In the presence of some fields, GHC still uses `tagToEnum#` when appropriate. Nonetheless, `Ord` instances seem to contribute [significantly](https://ghc.haskell.org/trac/ghc/ticket/9557#comment:8) to the amount of derived code.
No that doesn't sound right. The whole problem seems to stem from the way the "yo dawg" example dealt with the persistence model: &gt; What we’ll do, for simplicity, is rely on the models present in the servant-persistent app and delete the model code out of the Yesod repository. In order to get this running, we’ll need to delete... &lt;bunch of stuff including&gt; ...the authentication code... Well, in your case don't do that. What the author did in real life, before cutting it down to this simplistic "yo dawg" demo, was: &gt; At the day job, I factored the models out into their own package. That’s an option that has worked well, though it’s a little more labor intensive. You don't need to go as far as a separate package, but share the same model between the two parts of your project. Just make sure that only one of them does auto-migration at app start-up. I'm not sure if `servant-persistent` does auto-migration at all, but if does and you want to use theirs, it's easy enough to turn it off in a Yesod app.
Nice!
Not really. GHC 8.4 makes the guarantee that GC will not happen during an unsafe FFI call. But if you want to use the safe FFI (so that your C code can still be preempted and not block the bound thread it's running on), you'll still have to use pinned byte arrays, a.k.a. `Storable` vectors.
It can be also some sort of "developers exchange" - asking for or offering participation in projects...
I have a question myself. I just decided to have a look at Haskell again, although I can't afford haskellbook.com. What's a good working environment on Win10? What do I need to install to have the most pleasant/easy to setup/productive setup fora beginner? Are there good articles or posts or packages?
Yes I'm on Windows Creators Update, which is also excluded in the GHC 8.2.1 support..... I think I will just try use linux instead, thank you and thank anyone who helpe me.
Yes: the type of `Complex (SingThingThree SingYes)` is `Complex ('ThingTree 'Yes)`, while the type of `Complex (SingThingThree No)` is `Complex ('ThinkThree 'No)`.
Not yet. The `GHC.TypeLits` module defines type-level strings and positive integers, but doesn't do anything for custom datatypes such as `Happy` and `Thing`. I remember (but cannot find the link) a talk in which /u/goldfirere says that his work on adding dependent types to GHC should one day make his singletons library obsolete, as the compiler will do the work for you. *edit*: [found it](https://www.reddit.com/r/haskell/comments/3hlck0/planned_change_to_ghc_merging_types_and_kinds/cuakw2d/), it was a reddit comment not a talk.
Sorry, I should have been more specific - I didn't actually follow those instructions to the letter - I'm not using any of that `servant-persistent` stuff at all. I have the models defined in Yesod, and I can access the database from Servant using the Yesod scaffolded `db` function (which runs in IO). That seems OK for now, but I want to be able to access the Yesod authenticated user (ie call functions like `maybeAuthPair` from servant).
I believe that 8.2.1 does indeed support creators: https://mail.haskell.org/pipermail/ghc-devs/2017-April/014131.html Why do you think it doesn't?
These digests are always awesome, keep them coming!
It mostly stops once you start playing the game
As always, I've been working on my concurrency testing library, [dejafu](https://github.com/barrucadu/dejafu). I recently implemented a new feature allowing users to throw away some dubiously-helpful debugging data in order to gain [significant performance improvements](https://www.barrucadu.co.uk/posts/relnotes/2017-08-16-significant-performance-improvements.html). Currently I'm adding beginner-friendly issues to the issue tracker and putting together some higher-level documentation than just the haddocks, at which point I'll post a thread to the subreddit, as it's been a while.
I'm taking upon the challenge to create a coding environment which can compete with text editing.. :)
Working through the Haskell Book :)
Email us with your situation and we'll make sure you get a copy of the book. See here: http://haskellbook.com/support.html
&lt;3
The best language to get started in is the one you can at least get excited about and do *something* in. The rest comes later.
[Hacking on Hackett](https://github.com/lexi-lambda/hackett/pull/34).
Shameless self plug. I wrote this relatively beginner article, but it might be interesting to someone so I figured I'd post it here. Worst case scenario, I misunderstand something and Cunningham's law will prevail.
I've been working on my project Smooch, which is a Kisekae Set System implementation for the web. You can see a demo here: http://emhoracek.github.io/smooch The Haskell app (which I just run locally now) turns the original format into HTML and JSON. Eventually I want it to be a publicly accessible app that people can use to view any set, but I haven't really figured out the security or legal/ethical aspects of that yet. And anyway it's still in pretty early stages. I also have an update to Fn that I need to upload to Hackage but I can't figure out how -_- I also want to expand the tutorials and docs...
Oh no! I didn’t think to test that on any other configurations. I’ve added a button to toggle the sound. Does that help?
Hey, with Snoyman's help I was able to put together `WaiSubsiteWithAuth` and add it to Yesod. I can't remember exactly what I added but here are the pieces I could find. routes `/api ServantR WaiSubsiteWithAuth getServant` Foundation.hs getServant :: App -&gt; WaiSubsiteWithAuth getServant = WaiSubsiteWithAuth . servantApi data App = App { ... , servantApi :: Application } `YesodSubDispatch WaiSubsiteWithAuth` is already here: https://github.com/yesodweb/yesod/blob/602d1ff06a437ffd1bbef91a75837e17f43c4b80/yesod-core/Yesod/Core/Class/Dispatch.hs#L31
Working on [hslua](https://github.com/osa1/hslua). I took over maintenance half a year ago, it already was a really cool package back then, and I'm trying to make it even better. It's now safer, faster, and has a more haskelly feeling to it. I'm currently writing docs and preparing a talk; generic instances to get haskell data to lua and back are the next points on the agenda.
I'm working on my thesis (Property Discovery): https://github.com/NorfairKing/easyspec At least until September 9th (thesis deadline). There's a talk about it as well, see https://cs-syd.eu/thesis
Even with a toggle, it caused the speakers on my Android device to make a horrific pop on loading and closing the page.
Ah ok, thanks.
Thanks - I meant to say that I think I need to implement something similar to `WaiSubsiteWithAuth` myself, as I thought that `WaiSubsiteWithAuth` does not actually provide a way to provide the authentication details to the subsite? But perhaps I'm wrong about that? I'm using `WaiSubsiteWithAuth` currently.
I am currently taking over the [Haskell implementation](https://github.com/NinjaTrappeur/wireguard-hs/tree/RPC-Refactoring) of [Wireguard](https://www.wireguard.com/), a user-space VPN. I have been mostly focusing on the RPC part so far. Mostly by updating the code according to the latest spec and writing units/integrations tests. I should be done before next Tuesday. Any kind of help/review would be much appreciated when I'm done :)
Oh dear, thanks for letting me know! Unfortunately I won’t get another chance to look at it until tonight now. I might have to try another emulator, or failing that just a screenshot and a download link if you’re on a mobile device — you can’t play it without a keyboard anyway.
Done. Thanks!
An [OpenStreetMap data parsing library](https://github.com/fosskers/streaming-osm) for the `streaming` ecosystem, and a repa-based [Map Algebra library](https://github.com/fosskers/mapalgebra) for GIS (web cartography) work.
My few in-progress projects are: - [Following a compiler course](https://gitlab.com/gilmi/nyanpasu) - I'm up to chapter 7 which is defining functions. I want to continue this soon. - [A chat server](https://gitlab.com/gilmi/massage/tree/master/src) which kind of works but I still need to write a client for it. Any ideas how to do this easily? - Adding an RSS feed to [hablog](https://github.com/soupi/hablog) - Toying with the idea of concatenative proglang interpreter. [a gist of an experiment](https://gist.github.com/soupi/86effe7a8dd5554555eeef8ec357d9b9)
When Bagwell published on the HAMT he also published about a vector-like structure. At least Clojure already have implementations of it. Not as fast as a raw array though.
I am working on a [compiler for a functional language that compiles to GPU code](https://futhark-lang.org), which comprises about 45000 lines of Haskell. I don't use very advanced Haskell features - nothing more complicated than monad transformers and type families.
Understood. I think you might have to. As far as this: &gt; What I can't figure out, though, is how I can get Yesod to "pass on" the details of the authenticated user so I can access this in the Servant API. I have not looked into that yet, but if you find a way to do that, please share!
I'm trying to merge some of my code to [primitive](https://github.com/haskell/primitive/pull/64). This code is written originally for my new I/O library [stdio](https://github.com/winterland1989/stdio), which is also a focus of mine right now. This patch is very big, but i think it will greatly improve haskell's array interface: after merging it, we will have a unified boxed/unboxed array interface with all the prim-ops RTS offer.
Hi, I am using Win10 with no issues! My setup: * VS Code (not a vim/emacs guy [*judgment intensifies*]) * Haskero plugin for VS Code * Stack as the build tool the only thing I need to repeat is the "stack build intero" every new project I start. VS Code is really good for an easy setup IMO
Thanks! I don't quite like Emacs and Vim myself. Spacemacs on the otherhand looks pretty promising... Strangely enough, I'm getting some error messages with VS Code and haskell plugins. I will have to investigate further.
Can you talk more about this? Is it something visual like http://luna-lang.org?
I'm just got the Haskell Book and will probably spend my weekend working through a couple of chapters. My other project, together with 3 colleagues, is a machine learning powered document recommendation system for chat contexts (not in Haskell though...)
And what about equational reasoning? *Main&gt; quickCheck (\x y z -&gt; splitRoot @Int ((singleton x &lt;&gt; singleton y) &lt;&gt; singleton z) === splitRoot (singleton x &lt;&gt; (singleton y &lt;&gt; singleton z))) *** Failed! Falsifiable (after 2 tests and 2 shrinks): 1 0 1 [fromList [0],fromList [1],fromList []] /= [fromList [],fromList [0],fromList [1]] By the `Monoid` laws, `((a &lt;&gt; b) &lt;&gt; c)) = (a &lt;&gt; (b &lt;&gt; c))`. Am I correct to think that, by equational reasoning, if `a = b`, then `f a = f b`? Or there is something bugged in my reasoning? What really annoys me here is that it is possible to write something on which equational reasoning does not work, without using any `unsafe` / `IO` / magical trick. I'm now wondering in which other context the equational reasoning breaks. Actually, I think here that there is no equational reasoning issue, only that the `Monoid` instance for `Set` is broken in this context, but ensuring that it is not only for a special case for `splitRoot` is too costly for a really small reward. Do you know any other couple of class/instance for which the class laws do not hold in a particularly rare context? 
He continues on for a couple of minutes in part 5 about (future) Haskell use in the industry 
What an unfortunate name for this software
I’m a little curious why you included [my blog post on user-programmable infix operators in *Racket*](https://lexi-lambda.github.io/blog/2017/08/12/user-programmable-infix-operators-in-racket/) (though I’m not complaining)! I’d be curious if people on this subreddit would care about Hackett-related (but not really Haskell-related) things, since I opted not to post that blog post in this subreddit for that reason.
Yea if `Data.Set` did not export its internal structure in the form of `splitRoot`, there would be no way to observe the monoid laws being broken. This tactic is used occasionally in Haskell, where we say that some laws hold "up to observation," meaning they'd break if you looked at internal state, but not if you only look at the public API. There are some free monads that do this. `pipes` and `streaming` both approximate the Monad transformer laws, but break them internally for performance reasons.
Two `inline-X`'s I would love to see: 1. `inline-bash` 2. `inline-LISP` (i.e., `inline-clojure`, `inline-racket`, ...)
You called the Good Good Bot Bad Bot Bot Good
I'm immensely grateful to Manuel for `c2hs` without which my own project would have been impossible and I agree with most of he says here but I do push back a little. While `inline-*` solves the problem of calling a function in language X unless I'm missing something it does not help with {un}marshalling datastructures which is about 80-90% of the work. So if you have an function like `ObcA func (ObjB b, ObjC c, ObjD d)` you still have to do the work turning all those `Obj*` into some Haskell datastructure. In large APIs (especially in OO) these objects can be incredibly deep and furthermore in non-GC languages like C++ you have to figure out ownership. 
Professionally, I develop [hsevm](https://github.com/dapphub/hsevm), an Ethereum smart contract evaluator, test runner, and debugger. I'm also experimenting with ways of doing formal verification of smart contracts, especially using symbolic execution. On the side, I'm currently participating in the 2017 GF summer school, learning how to use [Grammatical Framework](http://www.grammaticalframework.org/) to implement multilingual application grammars. My [chosen project](https://github.com/lessrest/maze.land/blob/master/kosmos/README.md) in the summer school is to make a text-based adventure game engine driven by natural language facts and rules.
I didn't edit this week's issue (Alexey Zabelin did), but I would've featured that post too. Hackett is a Haskell-like language, which I often feature in Haskell Weekly. (See also: PureScript, Elm, Eta, and so on.) Your post showed how to implement infix operators in the presence of a macro system, which is way different than the way Haskell does it. (I don't know the specifics, but I'm assuming it involves parser combinators, new keywords, and compiler support.) I think the contrast is valuable. It makes me wonder: What would Haskell look like if Template Haskell (or some other macro system) was more integrated? I imagine it would look a lot like Hackett. 
Try to build upon Unison or join it?
That's the point. &gt; We’ll name it The Daily Stormer, since a good domain name has recently opened up.
I think it was deliberate https://twitter.com/TaurineAndCode/status/897884704426270720 https://twitter.com/Pinboard/status/897591628025561089
Interviewing and hackerrank exercises! It's been fun though. I generally love algorithm problems and sessions on hackerrank. I just wish there were fewer adversarial whiteboard/live coding sessions, and more talking about technical interests and fit overlap. To most people who can't figure out from my resume and Github what my current technical level is, I challenge them to hire better resume / Github readers and commit to either the interview loop or screen me out altogether. Besides that, when I get time and inspiration, I try to work through understanding and reimplementing Arora's Euclidean TSP algorithm (https://github.com/kanishka-azimi/C---TSP-Arora-Implementation mirrored from the original implementation), Babai's Graph Isomorphism algorithm, and zcash's fork of libsnark. I have been chipping in unit tests for Databrary. I occasionally try to drive-by tutor strangers in Elm, when they express the sentiment that Haskell is cool, but hard.
As soon as TweagIO finishes linear types, I really want to try to make an `inline-rust` package. I have a hunch that it may be possible to avoid copying back and forth from Rust to Haskell land, all while not having to worry about memory leaks. Even if under the hood there will be some unsafe stuff, the API should be entirely safe. Imagine being able to use snippets of safe Rust instead of C in your code...
This is an interesting and ongoing phenomenon many places. Traditionally controversial shared names are being repurposed for absurdly banal information points. I'm not sure if it does harm or good, yet. But it certainly does infuriate the folks who lose the domain names and subreddits.
I'm doing a bot to "shuffle" the names of the participants in a conversation between them. I'm trying to output a diagrams of the resulting transitions with the "diagram" library
(2013) Old but good.
I'm working professionally on [Fames](https://github.com/maxigit/Fames) a sort of add-on to [FrontAccounting](http://frontaccounting.com) (an ERP written in PHP). I've been working recently on an interface to create (easily) new variation to products - FA doesn't have the concept of variation only plain product. At the moment I'm extending the interface to also create new variation for our website (using Drupal commerce : PHP). The project is opensource, any help will be appreciated.
Is Hackett a new language ? Why not trying to expand Haskell itself (via TH or preprocessor, a like SHE). In other words what type of macros would like to implement?
he nor anyone else has really stepped up since this talk though.. I'd say nothing really has changed in game dev since then
bash or merely sh?
This is just great. Thank you for posting!
I love Haskell and use it as much as I can, but I will say (as an amateur gamedev) that it seems unlikely to catch on for no fault of the language. It seems like people who successful create a game tend to focus on the task at hand instead of having optimal tools/languages/etc. Being able to grab Unreal, CryEngine, Unity, Godot and start making the game is a HUGE advantage over picking Haskell. All of those engines allow you to get started without paying a single dollar, all have been used to make complete games, and all of them are about as close to the final product as you can get without starting from an existing game. I think if someone really wanted Haskell to catch on for gamedev they would have to make a competitor to one of those where users can develop in Haskell or use the FFI system to make it so Haskell works with them. There's other inroads, but the vast majority of people won't want to pay the start up costs. 
Either would be great; Since bash is more powerful I suppose bash would be preferable.
Is there no way currently to use Haskell with Unreal, Unity, etc? Through FFI perhaps?
There are definitely ways using the FFI system. Writing the bindings is not trivial and requires a decent bit of low-level Haskell knowledge.
Carmack is not exactly an amateur game dev -- he writes the engines that said devs use. That said, there are some other big blocks to basing new game engines on Haskell -- lack of deterministic GC latency being a big one. Haskell may never become the primary implementation language of AAA game engines, but likely some functional hybrid language will. I'd be betting on Rust.
Yeah, Carmark is one of the most expert engine developers alive. I didn't mean to imply that he's amateur. I wanted to address the point that there is a long tail of developers most of which are "indie".
[Grafted-In](https://www.graftedin.io/) uses Haskell internally and for some clients. We do marketing and custom software. We are not currently hiring. P.S. I already added to the GitHub repo based on this.
Is it worth the trouble? Could you not use, i.e., inline-C to help out with those bindings?
I'm in the early stages of developing a conformant Haskell interface to [FHIR](https://www.hl7.org/fhir/overview.html). 
Perhaps the way to get a sense of how big the task is, is to look at the JavaScript binding to Unreal: https://github.com/ncsoft/Unreal.js Even if you use something like inline-C++ you'll still have a lot of functions and types to write and then you'll also want to make an abstraction on top of that direct binding to make it more idiomatic from the Haskell side.
&gt; I'd be betting on Rust. I forgot to comment on that bit in my previous reply. That's where I've been focusing my amateur gamedev efforts. Rust's type system gets me most of what I want in this domain from using Haskell. Meaning: Memory safety, parametric types and functions. Plus, if performance ends up mattering (it really doesn't for a good lot of simple but fun games), then Rust gives me lots of really good options (Haskell can have good performance too, so I don't want to over emphasize this point). The main downside I've experienced to picking Rust over Haskell is that I have to think a lot more up front about ownership and representation than with Haskell. The way I've addressed this is to use systems like Unity/Godot/RPGMaker/etc for prototyping and using Rust to implement the real thing. In terms of library support for gamedev I find Haskell and Rust to be on surprisingly equal footing. This is not the case for other development tasks where I've tried using both. I find Haskell has much better libraries if I want to make an interpreter or compiler, make a TUI program and that sort of thing.
Actually, I guess you would only need open source data type definitions (`File` in your example).
I'm trying to implement an [OWL2 reasoner](https://github.com/agnantis/hsReasoner) as part of my learning process of the language. It used to be part of my PhD but I had to abandon this project because of subject shifting :( Now (3-4 years later) I'm determined to continue and complete the implementation :). The current version already supports most of the concepts of the OWL2. However this was my first large Haskell project and most of the code is based on imperative algorithms and is implemented using a simple State monad. This means that it needs to be heavily refactored, optimized and tested in order to be satisfied with the result.
I'm reverse engineering Android Banking Apps and developing a service that will provide Banking APIs and a QR code based direct payment system (via bank transfers).
I think he's refering to [Lamdu](http://www.lamdu.org/).
seems like a very serious project. thanks for sharing and good luck!
@gilmi's right It's not a visual programming language. I think text programming (and also textual markup language like Latex markdown and wiki) are quite good in their editing experience. So Lamdu is very similar to text and tries to take the good sides of text editing, so that it feels like you're simply "entering text" but the code is stored and edited as a structured AST, so making syntax errors isn't possible, and the code also always type checks (type errors are automatically entered as "length (_ 5)" in case 5 doesn't fit the input of "length").
Stack is really pretty much plug and play on win10. I use sublime text for most editing, and pull out spacemacs (which is also a near 0 config experience) for when I really want more interactive information. In general, most tooling on windows runs into trouble intermittently, but it's not so bad. Also, my experience may be slightly atypical as there is some rogue application somewhere on my machine that keeps updating my PATH that I have yet to track down. A clean box without a bunch of other dev-sandbox stuff would probably be quite painless.
Me and @Peaker had been working on Lamdu much before Unison started.. It's taking us a long time but it's already quite nice imho. Still missing some important features like type classes and UI for editing nominal types, because we first focused on nailing the structural editing experience.. But these critical features will come too in time..
&gt; Is Hackett a new language ? Yes, see previous discussions of Hackett on this sub: * [Rascal: a Haskell with more parentheses](https://www.reddit.com/r/haskell/comments/5lrdcm/rascal_a_haskell_with_more_parentheses/) * [Rascal is now Hackett, plus some answers to questions](https://www.reddit.com/r/haskell/comments/5m715d/rascal_is_now_hackett_plus_some_answers_to/) * [Realizing Hackett, a metaprogrammable Haskell](https://www.reddit.com/r/haskell/comments/6dqf1n/realizing_hackett_a_metaprogrammable_haskell/) &gt; Why not trying to expand Haskell itself (via TH or preprocessor, a like SHE). In other words what type of macros would like to implement? Macros which can collaborate with, interact with, and modify the type checker. See [this section](https://lexi-lambda.github.io/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/#fusing-haskell-and-racket) of the first post.
A DSL for writing konnakol and realizing it on various instruments. Konnakol is a south Indian spoken rhythmic language. It's interesting because it describes the structure and phrasing of various compositions, but is abstract enough that there are many possible ways to play a single score.
Yeah, I've played around with stack and it seems to be really well made. Definitely a pro and something that will make me consider using Haskell.
Perhaps https://hackage.haskell.org/package/reddit is already sufficient?
I'll be your user.
i'll probably be doing some unrelated mathy hackery some parts of icfp week and happy to share cool bits with those who are up for fun hackery :) 
Maybe, but I really don't see this bot as a learning experience for Haskell.
Started to work on [Kontiki](https://github.com/NicolasT/kontiki/tree/hack) again, a Haskell implementation of the Raft distributed consensus protocol. Started from scratch using a different approach. Trying to be fully parametric where applicable over e.g. message types ([example](https://github.com/NicolasT/kontiki/blob/f7a336d03da6147f217c98584e1ed32eeb72279a/kontiki-raft-classes/src/Kontiki/Raft/Classes/RPC/AppendEntriesRequest.hs#L23)), using monadic layers for effects ([example](https://github.com/NicolasT/kontiki/blob/f7a336d03da6147f217c98584e1ed32eeb72279a/kontiki-raft-classes/src/Kontiki/Raft/Classes/State/Persistent.hs#L24)), and an indexed state monad to be able to transition from one node state into another (no example code yet). Unlike the original library, the intent for this project is to also include an actual application (likely some kind of key-value database, nothing too fancy). I'd also like to explore to which extent the implementation can be tested or formally verified. Dejafu could be a lead. Also having an 'interpreter' which generates e.g. a Promella model out of the implementation for validation with Spin (or generate a TLA+ spec and test with TLC, whatnot) could be an option. Not sure yet.
If I'm understanding your point, [Spock can do this](http://www.spock.li/2015/08/23/taking_authentication_to_the_next_level.html), ie: requiring that a value is produced before calling some handler. Of course, you could still lie and return `undefined`, but it's much harder than just forgetting.
Cool, forgive the ignorance on my part.
This talk is what inspired me to learn Haskell. No regrets :)
It's understandable, we haven't done a lot of blogging/outreach etc so the project isn't well known. We're planning to announce more when it's a bit more useful..
Rust in that context would already be a huge step forward for FP.
I'm trying to implement a neural net in Haskell. Using `linear` and `ad` and a terrifying indexed variant of the `TardisT` monad transformer, it works out really neat!
Wow. This may be exactly what I was looking for. I'll look into it. Thank you. Have you tried this out personally?
Optimizing [grammatical-parsers](https://github.com/blamario/grampa/grammatical-parsers), testing it on a language-WebIDL fork, preparing some slides to present it at Haskell Symposium. 
Lately i've done a little tutorial work with roguelikes. First I did a bit in Haskell, and then I did the same segment again in Rust. If you stick to the simple end of Haskell it translates quite well to Rust. So in some situations you might prototype in Haskell and then move to Rust for speed if you need it (you might not). Haskell is unfortunately a little on the weak end of things with gamedev. Rust isn't the best because it's so new, but Haskell is in a worse position than that even. There's ogl and sdl but every other language has those just the same as we do so there's no advantage there. What "framework" style libraries we have don't seem particularly well documented with tutorials and the like. They also seem a little aimed towards "smart" Haskell stuff, which is cool and that, but makes them even less beginner friendly.
* http://chrisdone.com/toys/duet-delta/ * https://github.com/chrisdone/jl * https://github.com/chrisdone/riker
Also me
There are JS bindings for... oh boy.
I see. I can understand that s-expression can be more powerful, but I found all the parentheses really, really noisy.
I can't tell you. I work for X.
Have you tried Gloss? It's a neat wrapper around Gl
I can confirm that I’ve run into this in the past couple days, too. I looked at stack’s issues on GH, but I couldn’t find anything related, so I thought it might be an issue with my local configuration, and I didn’t have the time to investigate. This sounds like it may very well be an issue with stack, though, and someone should probably open an issue.
For the past couple of years I've been keeping [unbound-generics](http://hackage.haskell.org/package/unbound-generics) going. It's a library that gives your abstract syntax trees fancy (or non-fancy) binding structure. (Some [examples/](https://github.com/lambdageek/unbound-generics/tree/master/examples); I'm particularly fond of [this fancy names example](https://github.com/lambdageek/unbound-generics/blob/master/examples/Nanevski.lhs)) It's been mostly in maintenance mode for the last year or so, but my long-term goal is to add an opt-in way of representing explicit renaming AST nodes which should amortize the cost of repeatedly going under and out of binders. (Similar to how [bound](https://hackage.haskell.org/package/bound) is basically a representation of an AST using explicit substitutions to "make DeBruijn succ less") At work I spend a small part of my time on [Centrinel](https://github.com/lambdageek/centrinel) and help a little bit with [Ward](https://github.com/evincarofautumn/Ward) with /u/evincarofautumn
I have been able to compile gloss every once in a while. Looking at the top level API it seems okay for some forms of game where you dont need to personally have precise control over the main loop. I've never given it a complete go through with a project and all that. But when i say "been able to compile" it brings me to Haskell's other problem regarding game dev: some parts of haskell, particularly the FFI end of things (which is where all the graphics libs bind to) are just not as good an experience on windows. If haskell wants to be big in games, we're gonna a have to give Windows better support. Stack should be able to grab the C libraries and build against them automatically (right now you have to fiddle with pacman yourself and pray that the moon is right). It should be able to tell you what folders it puts in the "stack exec" path contain dlls so that you can figure what to distribute with your game's exe. It's just little things compared to the rest maybe, and i know it takes work to add those features, but they're important to making haskell good for games, because most game devs are targeting windows, so they expect to develop on windows.
Ahh, that's a shame. I'm a bsd/Linux guy and so haven't seen stack on windows. I honestly didn't know that it ran at all. Is it better on WSL?
I think the GC latency is a less of an issue than you think. Unity devs have to deal with GC issues (I can't say if it's way better than Haskell's or not, I haven't used it for long enough), and they manage to get by. I think the bigger problem is the lack of stable, well-supported libraries for game dev.
Well, don't want to start another flame war here, but [haskell-lang.org](https://haskell-lang.org/get-started) provides the best getting started guide I could find. I'd recommend using stack anyway, mostly because it frees you from having to worry how and which GHC version (and compatible libraries) to install.
As a `zsh` user, I staunchly disagree. :)
As a `zsh` user, `zsh` &gt; `bash` &gt; `sh` → `bash` &gt; `sh`.
I think, this is largely an orthogonal issue and it depends on the sophistication of the respective inline library. For example, `language-c-inline` has a similar concept of marshallers as c2hs (yes, I shamelessly stole that from c2hs ;) — see https://github.com/mchakravarty/language-c-inline/blob/release/0.7/tests/objc/marshal-array/Main.h just above the `go` function at the bottom. Moreover, it has support for sophisticated marshalling of compound structures, here illustrated at a simple record data structure bridged to an Objective-C class: https://github.com/mchakravarty/language-c-inline/blob/release/0.7/tests/objc/record/Particle.hs In Haskell for Mac, I use all this to marshal the in-memory representation of Cabal files between Haskell and Objective-C. The main limitation here is simply the comparatively poor expressiveness of Objective-C. I’d really like to do this for Swift, where you can use proper algebraic data types to back up the Haskell data structures. (If only there were more hours in the day...)
This is true, but it's relevant to point out: many of the massively successful games out there are written without these guarantees. There is an implicit assumption that the principle value of an environment is to offer outrageously advanced graphics simulations. But very few of the most profitable games are in this category. Most of the big profits are around games with MUCH softer technical constraints, but much greater pressure on constantly turning out new content. In that environment, Haskell COULD thrive. I'm positive Haskell could do a good job of the engine duties for, say, Minecraft or one of the many strategy games.
Carmack proposes a possible solution to non-deterministic GC latency in the video: force garbage collection every frame (excluding assets etc.).
Oh I see, so you don't bind (i.e provide a Haskell function that delegates to ObjC), instead you just call the function directly. Neat! Do you have a mechanism for propagating exceptions/callstacks across runtime boundaries?
I dont have windows 10, so i have not tried it myself, but from what i understand the linux subsystem is totally unable to access the computer's windowing environment. 
Honestly it's pretty reasonable. The heavy lifting is done by C++ and the game logic or scripting can be programmed in js. This means not everyone has to be a C++ guru and if you want to allow mods it's easier for modders to distribute a bundle of json and js (and likely safer for the gamers) than distributing dlls or what have you.
No, at the moment exceptions are a pain point, especially were I use Haskell from Objective-C. On problem here is, again, that Objective-C lacks support for exceptions and for exceptions-as-values abstractions. And again, this could be handled much more nicely when dealing with Swift instead.
We're working on a terminal based mail user agent based on notmuch and [brick](https://github.com/jtdaugherty/brick) (great library btw). We called it [purebred](https://github.com/purebred-mua/purebred) and develop an [e-mail parser](https://github.com/purebred-mua/purebred-email) and a library integrating with [notmuch](https://github.com/purebred-mua/hs-notmuch) as well. I'm currently figuring out a way to write user acceptance tests using a terminal multiplexer like [tmux](https://en.wikipedia.org/wiki/Tmux) ...
In my free time, I’ve been working on [**Kitten**](https://github.com/evincarofautumn/kitten), which I’ve mentioned here occasionally—it’s a statically typed concatenative programming language with effect types, designed to offer some of the nice compositional style of programming you get in Haskell, but with a more predictable performance model and an emphasis on zero-cost abstractions like C++ and Rust. Lately I’ve been doing some refactorings, which you can see on the [reorg](https://github.com/evincarofautumn/kitten/tree/reorg) branch, to unblock the last key features (generic trait instances, unboxed closures, linear &amp; affine types, finishing codegen) before a release later this year (Christmas-ish?) Recently I also started prototyping project called **Epist** (not online yet), which is an interface for distributed data stores, including a query language called **Episode** based on dynamic epistemic modal logic. The idea is that you use Epist to wrap a storage layer (sqlite, log files, other services) and it handles communication between the storage and your application, providing a content-addressable, authenticated, immutable, message-based interface that can statically enforce constraints about the tradeoffs between consistency, availability, partition-tolerance, and performance. At work I’ve been working on [**Ward**](https://github.com/evincarofautumn/Ward), a static analysis tool for C inspired by the permission system of Kitten—albeit implemented very differently, owing to different constraints—with some assistance from /u/lambdageek as he mentioned. 
Hmm, I've been able to share files between them (had to borrow a win10 laptop for a bit). The drive interface / path structure is weird but it's not bad (as I see it). Not sure it's what you want but might be worth a try?
Upon looking it up some more, it seems that because microsoft has no _direct_ support for graphics with WSL, the only way to get WSL to run a program that shows graphics is to install an X server on windows, ssh into the linux subsystem, and then have it x-forward to your X server on the windows side of things. Fun, but clearly unacceptable. WSL is intended for command-line dev tools and that's about it.
&gt; Have you tried this out personally? Nope, but if you have any trouble getting it to work file an issue on ghcjs-dom and bug me if I don't respond in a timely fashion. There is a good chance you will be breaking new ground (I don't recall anyone else using it either). From looking in Types.hs it looks like IsBufferSource has three instances: ``` instance IsBufferSource BufferSource instance IsBufferSource ArrayBuffer instance IsBufferSource ArrayBufferView ``` Make sure you share what you find as I am sure others will find it useful.
[FLTKHS](https://hackage.haskell.org/package/fltkhs) builds [easily](https://hackage.haskell.org/package/fltkhs-0.5.3.9/docs/Graphics-UI-FLTK-LowLevel-FLTKHS.html#g:8) on Windows 10,8 &amp; 7 and supports [OpenGL] (https://github.com/deech/fltkhs-gl-demos/tree/master).
Unity uses Mono to provide C#, and it's been used to piggyback other CLR languages, including functional ones such as [Clojure (via Arcadia)](https://github.com/arcadia-unity/Arcadia) and [F#](https://forum.unity3d.com/threads/f-kit.411420/). If Haskell has something like [Eta](https://github.com/typelead/eta) for the CLR, that would probably be the easiest way to make it happen. I don't know enough about Haskell's alternate implementations to know if there's something that would make that a viable option, though. Edit: I should add that, based on [Arcadia's documentation](https://github.com/arcadia-unity/Arcadia/blob/develop/USAGE.md#programming-in-arcadia), it looks like some significant trade-offs could be needed due to the need to interact with the Unity APIs (highly mutable and stateful) and the scene graph (single-threaded, unlike the Mono VM that can run multi-threaded code). Might be easier to just work with F# as a way to stay in the ML family.
YOOO that is sick!! Please let me know when you finish!
I've been meaning to look into that, but not had the time.
Could you compile in WSL (for windows) and then run the compiled binary in Windows?
Migrating the frontend of SlowNews [from Elm to Miso](https://github.com/srid/slownews/pull/10).
I'm working on a talk about implementing an extensible record library 
What would be a solution to the problem he talks about around 21:50?
Python's type checker is better than nothing and can be used to enforce some simple static checks. Don't get me wrong, I would love if a strongly typed linear algebra library were to exist but at the moment one does not and it just so happens that most times when I am working with numerical data I am time-constrained and need to focus on the data and analysis, not tools.
Doubt it. I think you end up with linux binaries. To be clear: you can use ffi with haskell on windows, its just currently a lot harder to set up, and it could probably be easier.
I would use inline-posix-sh :)
I would love to see his Haskell code. Quick google search turned no results, so I guess he has not published it.
Right, thanks michaelKlumpy and zagaberoo for those details... for now I've taken the embedded emulator out of that page and put it on a separate page, so that you actually have to click through to get it. I'm afraid this won't solve the problem for you, but it does mean you can read the post without that annoying sound playing!
Also see: https://github.com/github/linguist/pull/2298#issuecomment-90150424
Maybe: runIfPermission :: (EatAllType t, MonadIO m, t ~ m a) =&gt; Permission -&gt; (Permission -&gt; t) -&gt; m a runIfPermission perm f (ps :: t) = do liftIO $ putStrLn "Getting database permission" if perm == WritePermission then f WritePermission ps else eatAll ps Plus appropriate `MonadIO` instances? Though, I'm not sure how you would write a MonadIO for "`(r -&gt;) . m`" without the `Compose` or `ReaderT` newtype wrapper. --- Your current signature only has one argument before the `IO`, and you need to allow multiple.
I've had the same issue. I tried regenerating the haddock documentation and the hoogle index in N different ways. I also notice that some of the same packages are missing documentation, e.g. 'abstract-deque' was always missing. Would you like to file a bug?
Already did: https://github.com/commercialhaskell/stack/issues/3362
thanks!
I had already been considering it, but this talk inspired me to focus my career exclusively on Haskell and FP.
Do you develop Lamdu in Lamdu yet?
I've spent more time debugging memory leaks in languages with deterministic GC than I have in languages which required manual memory management. Also; there are tracing garbage collectors which don't trigger pauses, but the GHC runtime doesn't have one yet.
I actually made an attempt at a minecraft clone in Haskell, but kind of got stuck at the "one cube, not even drawn in the right place" stage. I guess actually understanding OpenGL would have helped a lot.
as nice as gloss is for teaching, you will never get beyond very simplistic proof-of-concept games with it.
will never see the light of day most likely due to zenimax fallout. too bad since zenimax has zero use for a haskell implementation of wolf3d.
&gt; t the Haskell Book which book is that referring to, The Christopher Allen one?
That definitely works, we did that for pretty much any phone/game combo back in the j2me days. (and we did that *even though* our own code preallocated at least the whole current level and generally looked more like C than java. It was the API calls which piled up garbage). If the VM thinks "nah I'll ignore your request, the amount of garbage is not yet big enough to cause a frame drop when I finally decide to allow myself to clean up" then you're SOL, though.
Does this mean that Haskell has a method to implement reflection (that survives compilation)
I still don't understand why this isn't just passing the fully saturated function. Are the variadic arguments doing anything more than preventing a $ or some parens? 
Darn, I have only had the chance to implement proofs of concept in it. Is performance the main restriction or is it library scope?
I kinda wish that `TypeApplications` would imply `AllowAmbiguousTypes`.
I spend a few hours every week working on a Web UI Framework that's sort of midway between FRP and elm-architecture - https://github.com/ajnsit/concur. Trying to find the right balance of flexibility and structure.
Yeah I was thinking that myself.
I'm working on [so: a terminal interface to stackoverflow](https://github.com/SamTay/so), keeping in trend with my other little CLI apps. This one will be awesome once it's finished, as it's pretty configurable and offers two different interfaces: prompt || custom brick interface, where the prompt is what you'd expect and the brick interface will have a few panes and some vim keybindings. Just need to finish up the brick interface and a limited markdown parser. Also spending some time with reflex tutorials in preparation for a new job.
I asked for something similar a few days ago (got no reply) on slack for me stack hoogle -- generate [package] for example stack hoogle -- generate aeson works (of course this will download the content probably again - but at least I can use the local `stack hoogle` functionality afterwards)
It does, but this isn't it. Checkout typeable. 
&gt; Unity devs have to deal with GC issues Are you sure that's GC on the game engine itself? I don't think anyone is worried about GC on the high-level game logic (which is often written in scripting languages like Lua or Ruby). The concern is having a GC on the engine.
Every haskeller goes through a phase of making everything pointfree. A piece of advice, resist the temptation in production code. Your coworkers will hate you immediately and you will hate yourself the next time you look at the code. Only transform something into pointfree style if it definitively improves readability.
It's under client hold.
It has had this a method for a very, very, very long time; TypeApplications just makes it a little cleaner.
Very cool projects. And I really like kitten!
Can't you just use a class in this case?
I tried going to their site directly, rather than through an extension, and the button on the bottom-left says "Choose files" (Plural), so maybe that'll work? https://texviewer.herokuapp.com/
I'm working on translating the code in my [Git workshop](https://github.com/vaibhavsagar/git-internals-workshop/tree/haskell) from Python to Haskell.
Parallel and concurrent.. by S Marlow is excellent as a textbook and contains plenty of both foundational and applied insight 
Could you clarify? Does it permit incorrectly typed programs?
Very nice! Looking forward to use it
Wow! Will this be alternative to `vector`?
I don't know much about the internals of unity, or where the problem comes from. I know that people struggled with this in the past, but it wasn't anything you couldn't handle in Haskell.
It most certainly does not! I'm not sure where this misconception is coming from. [Here is a recent SO answer I wrote explaining `AllowAmbiguousTypes`](https://stackoverflow.com/a/45664950/3072788).
I just had quite the same use case, but refrained from turning on `AllowAmbiguousTypes`, which sounds quite dangerous, but really isn't. Time to refactor and get rid of `Proxy#`! Edit: https://www.reddit.com/r/haskell/comments/6ufnmr/scrap_your_proxy_arguments_with_typeapplications/dlsfxj4/, of course. Also, I don't think I can get rid of the proxy argument anytime soon, because I need it to [`SPECIALISE`](https://stackoverflow.com/a/45737382/388010) on. 
At work I'm writing glue for interfacing local and cloud services. Haskell is great for systems programming ^^ At home I'm refactoring [plot-light](http://hackage.haskell.org/package/plot-light) to give the user a more "turn-key" experience (i.e. sensible defaults and a more compositional API) 
Why do we want this non-first-class business?
My bad; I had this popping up when (ab)using typeclasses. Great SO answer!
There's work being done on the GC. It's not a trivial issue to deal with but it's not insurmountable, linear types, compact regions etc all go some way to resolving this. Indeed I expect a lot of ideas to come across from languages like Rust into Haskell. It's an exciting time to be alive!
Just for interests' sake, `DependentTypes` would allow you to do the following: f :: forall t -&gt; String f = ... .... let str = f Int Notice the use of `forall t -&gt;` instead of `forall t .` This makes the type "visible", meaning that callers have to provide it as a parameter. In his doctoral thesis, /u/goldfirere calls the `TypeApplications` syntax a "visibility override", allowing you to make type variables visible at the call site even though the callee has them as invisible (and currently, in Haskell, types can only be invisible since there are no visible quantifiers which support anything besides concrete values). Almost all uses of `TypeApplications` are really just instances of dependent-types-envy.
`genvalidity-hspec` uses this all over the place, it's great! type: monadSpec :: forall a. Monad a =&gt; Spec usage: monadSpec @[] 
nah, the Moronuki one ;)
This looks really interesting! When do you think this will be ready to use by others? Also, [this challenge by lexi-lambda](https://gist.github.com/lexi-lambda/701f1f1282401059f13a4220e8178ba4) might be a good way to test your model if you are interested.
Not yet, we are currently developing it in Haskell
What's the simplest way to recover an indexed traversal for a Representable? Is `lens` necessarily required for this?
In the [paper](http://cs.brynmawr.edu/~rae/papers/2016/type-app/visible-type-app.pdf) it says that TypeApplications implies AllowAmbiguousTypes. I wonder why that didn't make it into the actual implementation.
Interesting article! The last example is, I think, a pretty strong argument against using point free style in all circumstances. 
maybe it's easier to just use [`purescript-bridge`](https://hackage.haskell.org/package/purescript-bridge) ?
I tend to avoid making something point-free if in by doing so, we lose clarity. In this situation, these functions are so general that they were just as unreadable in either form. I also went through the phase where I tried to make everything point free until I got to: f a b = g a &amp;&amp; h b Which pointfree becomes f = (. h) . (&amp;&amp;) . g EDIT: In the span of a few minutes I decided that my statement "these functions are so general that they were just as unreadable in either form" was wrong and the non-point-free implementations (when written correctly) look much nicer.
&gt; But for bonus points, I decided to see if I could write this in point-free style. *Cunningham's law activated*
Actually, I kind of agree, contrary to my previous comment above. The most readable form is probably mfmap f x = x &gt;&gt;= return . f
Yes.
I remember the reasoning, will find it shortly
I was really hoping this was a new development on this front. It's a great video, but it would have saved me some disappointment to put "(2013)" in the title.
Well, it actually provides a lower level interface than `vector`, which are just arrays operations, not slices like `Vector`. FYI, I'm writing a new vector library based on this new design here: https://github.com/winterland1989/stdio/blob/master/Data/Vector.hs . This patch is a kind of low-hanging fruit of my project.
How is that going for you? Did you find a job where you use Haskell exclusively?
Not necessarily, I am ultimately looking for functions indexOf :: Foo i xs x -&gt; xs -&gt; (i -&gt; x) tabulateOf :: Foo i xs x -&gt; (i -&gt; x) -&gt; xs not caring what `Foo` is, the cool part about using [`traversed`](https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Traversal.html#v:traversed) is that deriving `Traversable` is enough to give us a default index
It requires a caret `let str = f ^Int` I believe
I'll be interested to see the rationale when you find it 
you can try, but I think it's going to be hard to get performance and polish that would be expected of a full-blown game. maybe go with sdl2. gpipe always seemed promising, for some reason i haven't seen much promotion about it: https://github.com/tobbebex/GPipe-Core there's a full blown quake viewer written with it: https://github.com/csabahruska/gpipe-quake3
Have you read "APLlicative programming with Naperian functors"? I wonder if it's mentioned in there, I only skimmed it.
My bad! Yes, the thesis says &gt; **Type names in terms** It is sometimes necessary to go the other way and mention a type when writing something that syntactically appears to be a term. For the same reasons we need `'` when using a term-level name in a type, we use `^` to use a type-level name in a term. A case in point is the code appearing in Section 3.1.3.2. It isn't more convenient *syntactically*, but it obviously much more powerful (at the very least, you don't need to enable `AllowAmbiguousTypes`). 
You would need a typeclass for tensors, and possibly a multi-parameter typeclass to relate Tensor and AccReal. If you don't control the implementations, you would probably need some orphan instances or newtype wrappers. Generic "self-contained" utility functions (read from file, do some ops, write result to file) would require some kind of proxy argument to select the implementations used inside the functions. 
This `TypeName` example can be considered a poor man's version of `Typeable`, right? It's a form of reflection, a reification of types in the value world.
&gt; non-first-class business What do you mean with 'non-first-class business' here?
it is essentially Typeable. Typeable returns something more rich than a String, though, of course.
It won't entirely solve the problem because you need `AllowAmbiguousTypes` in the typeclass definition site but `TypeApplications` in the use site.
[Rope making](http://imgur.com/a/l2Rhk) Just experimenting with GPipe and Haskell a bit, just to see what I can make with those. Turns out quite a bit. 
Type applications are not first class, meaning that I can't pass them around, abstract over them, etc.. Moreover it's a special case. Passing `Proxy`s is first class and fits in fully with the rest of the language. Is the only reason to use type applications because they are slightly less syntactically heavy?
Not off topic at all! Walking ASTs is one of those topics where Haskell really shines. Obviously there a many many ways of doing it. Let's say you have a simple expression language with constant numbers, addition and multiplication: data Expr = Num Int | Add Expr Expr | Mul Expr Expr deriving Eq Walking the AST to update all constant numbers for example can easily be done with a specific recursive map function: mapNum :: (Int -&gt; Int) -&gt; Expr -&gt; Expr mapNum f (Num i) = Num (f i) mapNum f (Add a b) = Add (mapNum f a) (mapNum f b) mapNum f (Mul a b) = Mul (mapNum f a) (mapNum f b) Or you can create a function that applies a local AST transformation recursively to the entire structure - bottom up: mapRec :: (Expr -&gt; Expr) -&gt; Expr -&gt; Expr mapRec f ex = f $ case ex of Num i -&gt; Num i Add a b -&gt; Add (mapRec f a) (mapRec f b) Mul a b -&gt; Mul (mapRec f a) (mapRec f b) Now you can simplify an expression with something like this: simplify :: Expr -&gt; Expr simplify = mapRec $ \ex -&gt; case ex of Add a (Num 0) -&gt; a Add (Num 0) b -&gt; b Mul a (Num 1) -&gt; a Mul (Num 1) b -&gt; b _ -&gt; ex Or recursively fold an arbitrary expressions into a single value: foldExpr :: (Int -&gt; a) -&gt; (a -&gt; a -&gt; a) -&gt; (a -&gt; a -&gt; a) -&gt; Expr -&gt; a foldExpr f g h ex = case ex of Num i -&gt; f i Add a b -&gt; g (rec a) (rec b) Mul a b -&gt; h (rec a) (rec b) where rec = foldExpr f g h eval :: Expr -&gt; Int eval = foldExpr id (+) (*) Usually a few generic walker functions (maps/folds/traversels) per AST are enough to fulfill most of your needs. If you get the hang of specific recursive functions like this you can start playing with generic functions working for **all** recursive data structures. That'll open up an infinitely interesting world of Haskell though, be carefull! ;) 
https://mail.haskell.org/pipermail/ghc-devs/2016-March/011600.html My fault :) Well, enough people agreed with my argument that it got changed.
Ok, thanks for the link.
See https://ghc.haskell.org/trac/ghc/ticket/5296#comment:29 also
&gt; Type applications are not first class True, but the same is the case for normal value application. Not really a big deal for most Haskell users. I've never used type applications myself (in Haskell that is) and I don't see a ton of pain in passing a few proxies around, but... I don't think explicit type application is a conceptually weird thing. 
It really is that good ;)
I'm not an expert but I think this is the problem plates are designed to solve. I think this is "the" paper https://arxiv.org/pdf/1103.2841.pdf but you can see a "simple" example by John Wiegely [at 35:55 in this video](https://youtu.be/QZy4Yml3LTY?t=35m55s) where he's demonstrating the lens library's `biplate`. You can imagine your AST in place of his ugly nested structure and a specific type of AST Node instead of `[String]`. He talks about this point specifically at 41:45.
I'm really glad to see that Hackett isn't dead, Type Systems as Macros is one of my favourite language design papers and it's great to see somone with the time to work out the kinks involved in implementing it in a real-life language that's more than just a toy. Another language which tries to port some of Lisp's best ideas to a Haskell derivative is [Lux](https://github.com/LuxLang/lux), which isn't quite as interesting as Hackett but certainly another project to watch.
I usually start with the TypeApplication syntax, but when things get hairy (e.g. with existentials) I often end up rewriting everything in terms of proxies because they work in more cases. I hadn't realized it was because they weren't as first-class as proxies, thanks for putting a name on the problem. It's unfortunate that the two approaches are incompatible: if a function chooses to require a proxy argument, a type application might make it spurious but I still have to provide a value for that argument, and if a function chooses not to require a proxy argument, then in those circumstances where a type application doesn't work, we need a workaround which is syntactically costlier than proxies would have been in the first place. Perhaps `@a` should have been syntactic sugar for `(Proxy :: Proxy a)`? In the meantime, let's continue using proxies everywhere, and rejoice in the fact that at least we can now type `Proxy @a` instead of `Proxy :: Proxy a`.
It's interesting to reflect on the role that lazy evaluation plays here. If you naively translate `foldExpr` into a strict language, it appears that before calling the functions `g` and `h` you would have to first recurse on the subtrees of the `Add` and `Mul` nodes. However, this can lead to inefficient execution in cases where you can ignore certain nodes or otherwise short-circuit the fold. For instance, in Haskell you could use `foldExpr` to determine if an `Expr` contains an `Add` node somewhere like this: hasAdd :: Expr -&gt; Bool hasAdd = foldExpr (const False) (const (const True)) (||) and the fold will stop at the first occurrence of an `Add` node. So `foldExpr` embodies both efficient top-down traversals (like `hasAdd`) and bottom-up traversals (like `eval`) in one definition. In a strict language I'm pretty sure you'd have to write specialized traversal functions to handle these different situations. 
&gt; &gt; Type applications are not first class &gt; &gt; True, but the same is the case for normal value application. What do you mean? Value application can be and is abstracted as `$` and the values themselves can be passed around. Neither can type application be abstracted into an operator nor can something of the form `@MyType` be passed around on its own. &gt; I don't think explicit type application is a conceptually weird thing. It's just another grain of sand in the standard syntax and semantics of Haskell. 
&gt; Perhaps `@a` should have been syntactic sugar for `(Proxy :: Proxy a)`? Neat idea! But it wouldn't work for the typeclass contexts in this post. &gt; In the meantime, let's continue using proxies everywhere, and rejoice in the fact that at least we can now type `Proxy@a` instead of Proxy :: Proxy a. We could already type `Proxy :: _ a` with `PartialTypeSignatures`. Standard Chartered's Mu made `(:: a)` mean `id :: a -&gt; a`, which was pretty neat when used as a proxy argument. 
The other thing which is really ugly about it is that you have to be aware of the order in which the type variables are bound. I really think it should have been disallowed for anything that doesn't already explicitly bind its type variables... or require a different syntax on the declarations altogether. You now have to be careful if you're adding an explicit forall to a type signature (e.g. if you wanted to use ScopedTypeVariables all of a sudden), that you list the type variables in the correct order, because if there are explicit type applications in the world somewhere, maybe you'll break someone's code.
&gt; But it wouldn't work for the typeclass contexts in this post. Why not? Obviously the method would need to take an extra proxy argument, that was the point of my proposal, to make sure that both approaches are compatible. import Data.Proxy class TypeName t where typeName :: proxy t -&gt; String instance TypeName Bool where typeName _ = "Bool" instance TypeName () where typeName _ = "()" -- | -- &gt;&gt;&gt; main -- Bool -- () main :: IO () main = do putStrLn $ typeName (Proxy :: Proxy Bool) putStrLn $ typeName (Proxy :: Proxy ()) 
For matrixes you could just do (or something, don't have a typechecker): tabulateI :: (Num a, Traversable t, Applicative t) =&gt; IndexedSetter' i s a -&gt; (i -&gt; a) -&gt; s a tabulateI setter f = iover setter f identity
There are many generics libraries with the automatic driving of various traversal functions, but I would highlight http://okmij.org/ftp/continuations/PPYield/yield-pp.pdf paper, as an alternative to Visitor pattern using generators. It simple to run, a few passes are composed with just a function composition. They can either run together or wait some date from some former pass. All these are possible with Visitors too, but with much more efforts. And it is not the only question of performance. There is a port https://effectful.js.org/posts/simple-transducers-javascript.html to javascript I use at work to implement a type checker. We split the type checker into a few stages, and since they run together information calculated in the later stage is available for some former. On the other hand, binding analyses must be finished before type checker, in JavaScript this just a matter of inserting Array.from in the passes pipe. The same way I suppose the original Haskell implementation may be used. And in fact, can be used in Rust too because it has coroutines. I suppose the code will be much simpler and more flexible comparing to Vistor based traversal. 
Having ADTs and pattern matching at their disposal, why do Rustaceans still choose to use visitors? Implementing a fully custom JSON conversion in `Serde` with visitors seems much less comprehensible than relatively simple pattern matching one has to do in `Aeson`.
an example of classical closure conversion transform in JS but the idea should be clear https://github.com/awto/estransducers/blob/master/src/samples/closConvPass.js
You're correct. You can't write a Windows game on WSL. Or at least, no easier than you can develop it on Windows.
Yes, that will work. When I said "it wouldn't work for the typeclass contexts in this post" I really did mean *contexts* as opposed to arguments.
So this refactoring will break: main = print (tuple @String 1 "Hello") `main` breaks when tuple :: Int -&gt; b -&gt; (Int, b) tuple = (,) changes to tuple :: a -&gt; b -&gt; (a, b) tuple = (,) I didn't read the original proposal because I already had a bad feeling about it at the time. I have a worse feeling about it now and get the impression it really hasn't been thought through.
Maybe some tooling to allow users to explore or automatically search through possible configuration values for timeouts, etc, to allow end user to select correct parameters. I don't know raft specifically.
Btw, if you don't want to write the traversals specifically for the AST and want to use more generic combinators you can look at using the generic type `Fix`-point operator. Just for fun I've rewritten the example above in this style **[in this gist](https://gist.github.com/sebastiaanvisser/30a9eb5cc47e8a5cebe8c8248ce23c40)** Of course there are probably plenty of existing over-engineered libs to do this stuff in the most generic way thinkable, but i highly recommend playing around with these style combinators yourself a bit first, because a) **it is so much fun** and b) a very nice learning experience.
No, the types are still erased at runtime. The type is known statically at compile time, and it must use the ordinary static instance solver to find the implementation of `TypeName`.
True enough, rearranging arguments makes things much simpler, and give us a semantic newtype: `newtype PermissionCheckWrapper = ReaderT Permission IO ()`. printFoo :: Int -&gt; String -&gt; Permission -&gt; IO () printFoo i j perm = do putStrLn "Foo" putStrLn $ show perm putStrLn $ show i putStrLn j main :: IO () main = do runIfPermission ReadPermission (printFoo 5 "Mary") 
`SomeNat` constructor can potentially contain any natural number. It's not guaranteed that when you you call `someNatVal` you will receive just exact `k` from type. In other words, it can't be proved at compile time. Thus you should compare `k` with number inside `SomeNat`. This can be done using [`sameNat`](http://hackage.haskell.org/package/base-4.10.0.0/docs/GHC-TypeLits.html#v:sameNat) function. So instead of case someNat of SomeNat (_ :: Proxy k) -&gt; do ... you should write case someNat of SomeNat (_ :: Proxy n) -&gt; case sameNat (Proxy @k) (Proxy @n) of Nothing -&gt; Nothing Just Refl -&gt; ... After pattern matching on `Refl` equality between `k` and `n` is in the context. Full code (which can be prettified a little for this case using `Maybe` monad) can be found here: http://lpaste.net/357793 