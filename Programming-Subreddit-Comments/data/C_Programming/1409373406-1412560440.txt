Can I give you gold?
For what?
PM me.
No. I'm not going to do your homework for you. Do your own work.
When I was working with a phone's OS, we used asm(nop) inside a while(1) loop to trigger a watchdog interrupt.
Yes it was, but you are advising them to put paging in inline assembly when that's not really the best idea. But my point is, you really should avoid using assembly whenever possible, but when you do have to use it, to avoid inline assembly whenever possible. 
It arranges windows on systems that use the X11 display server. Take a look at the example gifs to see what I mean. C can do a lot of things- not just communicating with a cmd window. I use a library called xcb to allow me to communicate with the X11 server.
I see, and what is x11 server? I mean what does it do?
I hate to just send you links, but these two are the best ways to learn about X: http://en.wikipedia.org/wiki/X_Window_System http://magcius.github.io/xplain/article/ The last article has some particularly cool demos in it- the author implemented an X server in JS!
You won't get any worthwhile offers with so few details and so little money. You need to share more to find somebody with your vision who doesn't actually care about the money or offer substantially more. 
Declare a global variable to be `static` if you want internal linkage (confined to the current file). Without the `static` modifier, a global variable has external linkage by default.
&gt; I was under the impression that the only way to share a variable across multiple source files was to extern it from a header that is included by said source files. No. Variables defined at file scope have external linkage by default, unless they are `static`. External linkage means the symbol exists across all translation units. So merely *defining* it makes it global. It's necessary to *declare* the variable using `extern` in other translation units in order to access it, but that is not what made it global, that just gives you access to it. &gt; There were no warnings about multiple definitions in the compiler output (gcc) but the variable was being treated like the same location in memory in my program! Is this standard behavior? Or the product of some undefined behavior? You violated the standard, but the compiler is no required to issue a warning. In fact most compilers do a thing where they put global uninitialized variables in a common section which allows for multiple definitions to be coalesced into one. This does not violate the standard, since any time you define two clashing variables you're in undefined behavior territory. But anyway, you can disable this with [`-fno-common`](https://gcc.gnu.org/onlinedocs/gcc/Code-Gen-Options.html#index-fno-common-2654) and you will get an error when you try to do that. 
I looked into it. tcme just wanted to pay someone to complete a fairly simple undergrad homework assignment from August 22 before it was due date last night before midnight (August 29). He didn't want any help, just someone [to do it for him](http://www.reddit.com/r/AdviceAnimals/comments/2dopis/after_virtually_cheating_my_whole_way_through/). 
&gt; for(LOOP=1;LOOP&lt;2;LOOP++) This loop will execute only once. The value of the variable `LOOP` begins at&amp;nbsp;1, and therefore at the beginning the loop condition `LOOP&lt;2` is satisfied, so the loop will execute. After that iteration, `LOOP++` is executed, which makes the value of `LOOP`&amp;nbsp;2, so then the loop condition `LOOP&lt;2` is false, and the loop terminates. Also, it is bad style to name non-constant variables in all caps.
&gt; scanf("%d\n", &amp;n); Why do you have `\n` in the format string? That probably doesn't do what you expect it to do. You probably just mean scanf("%d", &amp;n);
&gt; system("pause"); Don't do this. This is non-portable code. If you are doing this because your IDE closes the window when your program terminates and you don't want that behavior, then you need to configure your IDE differently. Don't write broken code to compensate for the fact that your IDE is misconfigured.
"Write a complete C-program that uses a FOR-lopp to read in 10 integers. For each of the 10 integers, the program first multiplies the integer by 10, if the result is obtained is greater than 85, the integer should be added into a sum that was initialized to zero. After the loop is completed multiply the sum by 100 and the print out the answer. For example, if the input from the keyboard is: 1 2 3 4 5 6 7 8 9 10 we expect to get the final outputted answer to be 1900." I wrote it originally for ten and shortened it to 2 to find out why it wasn't adding the 10 to the sum.
&gt; I confused why it lets me input twice Because you have `\n` in your `scanf` format string. Whitespace in a `scanf` format string, including the `\n`&amp;nbsp;character, means "read and discard whitespace characters from the input stream until the next character is a non-whitespace character." So when you say `scanf("%d\n", &amp;n)`, what you are saying is, "Read an integer from the input stream and store it at the memory address&amp;nbsp;`&amp;n`, and then read and discard whitespace characters from the input stream until the next character is a non-whitespace character." Therefore, the `scanf` function will continue reading and discarding whitespace characters from the input stream until the next character is a non-whitespace character, which will not happen until you enter a second number (or any non-whitespace, really). Now, `scanf` won't read that second number, but those non-whitespace characters will cause it to stop reading and discarding whitespace, and that is the point that the *first* `scanf` call will terminate. So it isn't "letting you input twice"—it's just waiting for the end of the whitespace in the input stream that you told it to read and discard. All of the behavior you are seeing is from the first `scanf` call. The `scanf` function is called only once in your code.
Habit from earlier lessons, didn't realize it'd do nothing in that case. Thanks.
&gt; it'd do nothing It doesn't "do nothing." Whitespace in the `scanf` format string, including the `\n`&amp;nbsp;character, means "read and discard whitespace from the input stream until the next character is a non-whitespace character."
You're a god. Thank you so much for the help.
No, I'm not a god. I just understand how `scanf` format strings work. You can understand this too.
&gt; If you change the port SSH listens on 99% of the login attempts will disapear. That's a temporary solution. &gt; If you disable root logins, then attackers will need to know your user password and the root password to do any damage. That's a temporary solution. &gt; If you enable key based logins only, and disable password logins, it's extremely unlikely that anyone will be able to get in anyway. That's a more permanent solution. But, doesn't help you at all when someone loses a passwordless laptop with a key file on it and doesn't tell you for several days. 
I'm not sure what you're trying to say here... you can bind any process to any port... (assuming you have root privs. when trying to bind below port 1024). You don't need to muck about in the kernel at all. So, you're most certainly not out of luck. 
OP, you're getting some bad advice here... I think because people aren't quite clear on what you're trying to do. Firewall rules won't help you unless you can create "accept" rules that don't require constant modification. If you can, just use a firewall. As others have suggested... there are simple ways to cut down on login attempts dramatically... but, I consider them temporary (in particular, I run sshd on a non-standard port, but port-scanners will eventually find them). You should consider installing a port-knock daemon in front of your ssh. Also, enforce very long passwords. Make them 25-30 characters. Even an English-language sentence of sufficient length is MUCH harder to brute force than some tricky-dicky stupid ass password with caps. and punctuation that is only 8 characters. Most implementations of "strong password" checking force you to use caps., punctuation, numerals, etc. which does basically nothing, because the length minimum is still usually something like 8 characters. Increasing the length is much more effective. Lastly, two-factor is pretty hardened, particularly in combination with long passwords that people don't store locally on their devices. http://www.blackmoreops.com/2014/06/26/securing-ssh-two-factor-authentication-using-google-authenticator/ If someone loses both a laptop and a phone, as long as the long password isn't on the laptop or in the phone, you're still good. 
Yeah, when I write assembly, its never inline. Its always a file that I access via a function. Calling convention is usually a defined standard (but not always, grrr), and I worry one compiler version to another, the inline assembly I write could break.
The daemon he's talking about is actually a packet filter. He wants to block access to specific ports given specific criteria. That requires kernel-level priviledges.
The relevant clause in the C99 spec is §6.9/5: &gt; An *external definition* is an external declaration that is also a definition of a function (other than an inline definition) or an object. If an identifier declared with external linkage is used in an expression (other than as part of the operand of a **`sizeof`** operator whose result is an integer constant), somewhere in the entire program there shall be exactly one external definition for the identifier; otherwise, there shall be no more than one. 
Sadly, with our ISP, we have a rotating IP, so using accept rules wouldn't be ideal. I changed the port that ssh connects to, but like you said, they'll find it eventually. As for not using root, yeah I know that's one of the big things, but I guess I'm too lazy to disable root access (as that's all I log onto). I'll take a look into a port-knocking daemon, would love to be able to make one myself (which is mainly why I posted this in the C sub =P). Current root password is 16 characters, so that's decent for now, and has never been cracked, though over time it may be. I will take a look into two-factor authentication, though storing anything on another site makes me wary, even though sites like google have never wronged me. Thanks for the suggestions!
Your `insert` function has problems. &gt; void insert(char aword[MAX_NAME_SIZE], struct node* leaf){ &gt; node* temp = NULL; &gt; if(leaf == NULL) &gt; { &gt; temp = (node*) malloc(sizeof(struct node)); &gt; strcpy(temp-&gt;word, aword); &gt; leaf-&gt;left = NULL; &gt; leaf-&gt;right = NULL; &gt; &gt; leaf = temp; &gt; } For one thing, notice that inside the block of code that is executed when `leaf == NULL`, you are attempting to set the values of `leaf-&gt;left` and `leaf-&gt;right`. You can't do that if `leaf == NULL`. For another thing, the pointer `leaf` that is passed in is passed by *value*. (All function parameters are passed by value in&amp;nbsp;C.) So changing the value of `leaf` inside the `insert` function will not change the value of the pointer in the calling code. The call `insert(word, root)` cannot possibly change the value of `root` in the `processInput` function. If you want a method to change the value of a variable that is passed in, then you need to pass a *pointer* to that variable. In this case, if you want a call to `insert` to be able to change the value of the pointer `root` in the calling code, then you need to pass a *pointer* to `root` (and therefore the type of the second argument should be `struct node**`).
I updated it according to what you said, changed how I pass the pointer in and fixed the problem of me assigning values to leaf instead of temp But I still have the same problem :(!
&gt; I'm getting memory issues. What do you mean? &gt; Running under valgrind says that something is going wrong Well, you never free any of the memory that you allocated, because you never call your `free_tree` function. Valgrind will complain about that. Is Valgrind indicating another problem?
So I get a Segfault when I run it. Valgrind reports: Invalid read of size 4 ==2653== at 0x4EA607B: fgets (iofgets.c:50) ==2653== by 0x40082B: processInput (q2.c:34) ==2653== by 0x4009F8: main (q2.c:80) ==2653== Address 0x0 is not stack'd, malloc'd or (recently) free'd ==2653== ==2653== ==2653== Process terminating with default action of signal 11 (SIGSEGV) ==2653== Access not within mapped region at address 0x0 ==2653== at 0x4EA607B: fgets (iofgets.c:50) ==2653== by 0x40082B: processInput (q2.c:34) ==2653== by 0x4009F8: main (q2.c:80) Freeing the memory isn't a problem at this point because I think I have bigger issues.
Notice that Valgrind says that the segfault is happening on line&amp;nbsp;34, in the `processInput` function (which was called on line&amp;nbsp;80, in the `main` function). What is going on in line&amp;nbsp;34? &gt; char* cp = fgets(word, MAX_NAME_SIZE, input); Hmm, `fgets` isn't working right for some reason. Why would that be? Are you giving it the right arguments? Do all of the arguments have the values that you expect? What is `input`? Oh, that's the file handle returned by `fopen` three lines up, right? Could `input` be the problem? Remember that `fopen` returns a null pointer if there was an error opening the file. You never test for such an error, do you? You just blindly assume that `fopen` succeeded and pass the returned pointer straight to `fgets` without testing to see whether it's a null pointer. What if an error occurred when `fopen` tried to open the file?
&gt; I must have the root node there with no word and printing 1. Well, it's probably not the *root* node, because that will print somewhere in the middle, right? And "no word" looks like an empty string. Why don't you try printing each word as you read it from the file? Print the word between brackets or something so that you can tell if you are reading the empty string as a word. This way you can see whether the problem is in the part of your program where you are reading the words from the file or the part of your program where you are storing and retrieving words from the tree.
Why don't you print each word between brackets, `[...]`, as I suggested?
 The word is: [hello] The word is: [hello] The word is: [this] The word is: [is] The word is: [aabbcc] The word is: [test] The word is: [] So it is getting an "empty" string, but doing strlen(word) &gt; 0 didn't work, so it must just be a character that isn't being displayed? Sorry If I'm not following correctly here
Turns out my input had a blank line at the end, which was being read in. All fixed now I removed that. Thanks for putting up with my questions, I learned a fair bit about debugging through you. I think I need to debug more before my program gets too big !:(
Maybe just start off using netcat to both send and receive UDP messages. Then grab and peruse the netcat source, and use that to start looking into writing your own client/server.
[Beej's Guide to Network Programming](http://beej.us/guide/bgnet/)
How about something like Trivial File Transfer Protocol (TFTP), since there are lots of simple UDP implementations to compare: * [RFC 1350 The TFTP Protocol (rev 2)](http://tools.ietf.org/html/rfc1350) And here's a random code example, from Debian's netkit-tftp, with client (tftp) &amp; server (tftpd): * http://sources.debian.net/src/netkit-tftp/0.17-18/ Browse around for other implementations, none need much code, so you'll quickly get a feel for the different approaches. 
I think some platforms will happily discard your transmitted non-tcp packets if the transmit rate is higher than the mediums ability to transport. Of course there are buffers in the NIC itself (TX rings) but limited in amount. And that's a good thing actually for network traffic as buffers lead to latency. Timing, or rather, excellent use of time, is the key to maximizing throughput. Full duplex networks can in theory communicate both ways at the same time but on many NIC's the MAC or sometimes PHY has limited processing ability so RX and TX at the same time isn't always true. Dont assume that contents of TCP or other packets are not corrupt if the UDP/IP/TCP/Ethernet checksums are correct. Lots of network equipment out there (especially broadband routers) might check frame on RX, but some will completely ignore inbound checksums, and of course must recalculate for TX so happily will be silently updating your packets with new checksums instead of discarding them. This is a very real thing and happens all the time, so verify messages by additional means. Occasionally your app might receive unexpected data when it's generally only transmitting (icmp error messages and suddent TCP RST). Sometimes it's better to general message latency and bandwidth to transmit redundant bits of information to increase the odds of packets being able to received with errors but recovered using the redundant bits. Generally when there are low quality conditions you might receive corrupted frames, multiple of the same frame (duplicates), packets reordered or sometimes a any frame matching a certain bit/byte pattern will never be be received due to silent but deadly firmware bugs. EDIT: Routers do not all behave the same nor even correctly. Cant expect similar error messages on two different networks or even paths inside the same network. No two networks are a like and some will even go so far as to actively block icmp error messages or other important bits of information. Path MTU is not always the same, so if packets over path mtu might just disappear or might be fragmented correctly. And path mtu can sometimes change throughout a "conversation". BPF is probably going to be your best friend in both debugging and complete network freedom.
Notice that if the count of the root node does not meet your threshold, then *nothing* gets printed, even if other nodes do have a sufficiently high count. You need to rethink your logic in the `printOrder` function.
Misleading Title 
Very misleading. The submitter took the title from the SO post, but the person who wrote *that* was deeply mislead into thinking that this was an operator when no such thing exists. Next time, rewrite the title to something more descriptive, like "Digraphs and clever code obfuscation". 
That said, the title does remind me of the lovely --&gt; "operator". Used as follows: int i = 10; while (i --&gt; 0) { /* do whatever */ } or even: for (i = 10; i --&gt; 0;) { /* do whatever */ }
[That one also has a Stackoverflow post with the same misleading title](http://stackoverflow.com/questions/1642028/what-is-the-name-of-the-operator).
&gt; I will take a look into two-factor authentication, though storing anything on another site makes me wary, even though sites like google have never wronged me. Nothing gets stored in two-factor. 
&gt; Changing the port is, for all intents and purposes, a permanent solution. I don't think you know what "for all intents and purposes" means. Port scanners will find this. It's nowhere near permanent. A site that is under actual attack is not under attack from script kiddies. &gt; It can prompt for a password to deencrypt the file before loging into the server. It can... and it's also trivial to defeat the password once you have the key file, since brute forcing it with rainbow tables is not at all difficult. If you're serious about access to a bastion host, you'll be doing something more sophisticated than these measure. It's common to use two factor auth. 
I'm not sure how to tell you any other way, but you're wrong. 
Shouldn't this be /r/shittyprogramming?
&gt; cannot get a proper output That is not a helpful description of the problem. What input are you providing? What output are you expecting? What output do you get instead?
Any input of a salary between 10000 and 70000 is outputting a salary of 0 and a tax rate of 0. Also how would I format the code in the question better?
Indent every line of your code with four spaces, and put a blank line at the beginning, so that Reddit formats it properly as code.
Done. Thank you!
You should turn on all warnings in your compiler, and pay attention to what they say. This is what I get when I try to compile your code: $ clang -std=c99 -Wall -Wextra -pedantic -O3 -o program program.c program.c:13:2: warning: implicit declaration of function 'scanf_s' is invalid in C99 [-Wimplicit-function-declaration] scanf_s("%f", &amp;salary); ^ program.c:14:10: warning: implicit declaration of function 'FindTaxRate' is invalid in C99 [-Wimplicit-function-declaration] MyTax = FindTaxRate(brackets, TaxRates, salary); ^ program.c:6:6: warning: unused variable 'i' [-Wunused-variable] int i = 0; ^ program.c:21:7: error: conflicting types for 'FindTaxRate' float FindTaxRate(int *brackets, float *TaxRate, double salary) ^ program.c:14:10: note: previous implicit declaration is here MyTax = FindTaxRate(brackets, TaxRates, salary); ^ 3 warnings and 1 error generated.
Put a blank line at the beginning.
i think if you turn on errors in your compiler you will see how to fix this pretty easily... /u/zifyoip gave you some clang that looks good. if you use gcc try: gcc -W -Wall -Werror -pedantic -o taxrate taxrate.c
Indeed it should. I wonder how many more years it will be before I manage to forget all about digraphs again.
Has it faired better than GTK+? I'm a bit out of it since I haven't used linux much for about 6 years. It looks like cross-compiling for windows makes Qt a better choice since it supposedly will work with the dependencies that Windows ships with.
QT is constantly updated (for some definition of constant) and has faired quite well. If you want to cross compile for windows, QT is great. However, cross compiling can be a bit of a pain. However, QT is about as modern and ubiquitous as you can get for cross platform C++ GUI development. It is C++, not C, though. If you were looking to get back into C++, I would also recommend checking out the new standard (C++11/14).
Qt also plays much more nicely with OS X which GTK+ has spurned. Additionally, http://www.wxwidgets.org/ is an option. It's also C++ based, but I'm not certain that it has C bindings.
No, its just written in C++. It also works for C (and is really nice to boot. (also, really really nice IDE (I use it for everything, not just QT programs.))).
It's not even C++, really.
This project provides C bindings for wxWidgets: [http://wxc.sourceforge.net/](http://wxc.sourceforge.net/) I haven't used it myself, so I can't vouch for its completeness, stability, or ease of use. But it seems to have been successfully used as the underpinning for other language bindings, e.g., Haskell.
autotools, it's not as complicated as it might looks like.
[GNU libtool](http://www.gnu.org/software/libtool/) is the normal way of handling that, but it's not exactly what anyone would describe as lightweight. Technically you can use it standalone outside of autoconf and automake, but it's rarely done that way. It's used because it solves problems that yours doesn't. For example, if you have a project that contains both libraries and executables which link against them, it would be nice to be able to run those executables in the build directory without first installing them, either for debugging or to run a testsuite. But on many systems that's not possible because ld.so only searches certain locations, so you run into this thing where everything needs a `LD_LIBRARY_PATH` adjustment. Some systems don't have such an environment variable, and require linking with rpaths, which requires relinking when the library is installed, and ... Blah blah blah, there's tons of edge cases. The point is that libtool solves a bunch of problems that you probably don't know even existed. Maybe that means you don't need libtool, or maybe you just haven't run into those platforms or those situations yet. But that's why it's widely used. 
Today it is fashionable to write a program without GUI. And then write a web-GUI
This is not portable, and it isn't really even&amp;nbsp;C. It's just executing an external program.
In 3 words: It is not. Selection sort is also running in O(n^2 ) just with another constant factor. The difference is that the _best_ case of bubble sort is O(n) and with _best_ case of selection sort is O(n^2 ). But the average and worst case of both is O(n^2 ). Edit: Power notation
As i mentioned, the constant factors that are not described in the O() notation play a huge role. The O() notation only tells you very roughly how well an algorithm will perform given a change in input size. It does not tell you however what constant factors the given algorithm carry with it. Just think about two O(n^2 ) algorithms. One algorithm uses 100000*n^2 comparisons, the other uses (1/2)*n^2 comparisons. They both lie withing O(n^2 ) but the second one will obviously outperform the first one. Regarding the statement in Wikipedia: It's just wrong, although Selection sort will outperform bubble sort on random inputs because of different constant factors, on already sorted inputs, bubble sort will be faster because it just needs to look at every element once. Edit: Power notation 
See the top answer [here](http://stackoverflow.com/a/25613679/1505939) for a visualization of complexity vs time. (Of course your question title is wrong; selection sort and bubble sort both have O(n^2) complexity)
autotools is archaic cruft that no developer should be forced to use. 
Again, if it was that simple, libtool would not exist. `$ORIGIN` is not a cross platform solution. 
Yeah, bells go off when people refer to shell commands as 'tricks'.
True, but it will work on any platform ld runs on, which is probably every platform you are porting to. 
It doesn't work on Mac OS or Windows, both of which have an `ld`. (Also, `ld.so` != `ld`.) 
&gt; Executables load DLLs from the executable's current directory in Windows Yes, and what if they aren't in the same directory? A project could have many components, and it's not guaranteed that everything will wind up in the same directory. On Windows, libtool builds wrappers for executables that adjust the PATH, just as it builds wrappers for executables on Unix platforms that adjust the `LD_LIBRARY_PATH`. (Only in the Windows case it has to build wrapper executables not wrapper scripts, because the Makefile rules need to depend on a filename that ends in `$(EXEEXT)`. See how it's just weird corner case after weird corner case?) I'm not trying to convince anyone to use libtool, or the autotools in general. I'm just saying that before you slag them off for being huge bloated messes, perhaps consider that they are solving problems that don't immediately come to mind but which nevertheless do occur. Nobody sets out to write gargantuan build systems, they spring out of necessity. 
Is there a list of platforms which support these atomic operations? x86 and x86_64 are mentioned in the article. Do ARM, AVR, MSP430, or PPC processors have the necessary instructions? 
I don't understand the question. Why is 10000 &gt; 100?
Nice article, thanks! It's sad to see so little support still for C11 features like these across the board, you have to wonder what the point of the specification process is if it's still being ignored three years later .... 
Support is coming in slowly, so it's not hopeless. If it weren't for C++11 getting adopted so rapidly, I'd just assume this was a normal pace. I suspect the reason we haven't really seen C11 threads.h support yet is twofold. 1) The sole advantage advantage over Pthreads is portability, but that advantage isn't materialized until there's solid C11 thread support on Windows, which will take even longer. 2) The C11 threads specification is broken: it's [not possible to implement purely on top of Pthreads](http://gustedt.wordpress.com/2012/10/14/c11-defects-c-threads-are-not-realizable-with-posix-threads/) because it has looser constraints. 
I'd like to know if there's a detailed list somewhere, too. From my fumbling online research, it seems Alpha, PowerPC, MIPS, and ARM all provide LL/SC instructions, though I don't know what the various limitations are. x86 went with the CAS paradigm. 
Hasn't Microsoft stopped supporting C in favor of C++?
Ahh, thanks.
MSP430 processors aren't available in multi-core; I wouldn't worry too much, the compiler can emit code that temporarily disables interrupts.
In some applications, temporarily disabling interrupts can cause unacceptable jitter.
Even for one or two instructions at a time?
C99 wasn't widely accepted for 10 years at least. Three years is 'chicken feed'. 
What is `%z`? (Did you mean `%zu` ?)
The `z` is a modifier for a specifier which specifies an integer type; `%z` by itself is undefined.
yes. e.g., software UART implementation. You don't want the compiler messing with interrupts. 
Do you have any examples of this?
What kind of license does QT have? 
It can be trivial or really hard and mainly depends on the way the data is stored and a little bit on how the GUI accesses the data. Anyway, it might be more productive to ask the maintainers of your system instead of us.
Could you export the data as text and use regex to find what you want?
That depends on how much data the search function is supposed to search through. For “ten pages of discounts” that shouldn't be very difficult.
What? :-)
similar like this: https://www.ruby-toolbox.com/ or this: http://mvnrepository.com/ or this: https://pypi.python.org/pypi
No. C libraries are archives containing object files. That's it. On *nix systems these are designated .a or .so.
There's no central repository for C programmers in general. However, Linux and BSD distributions package up tens of thousands of C libraries in the way you're asking. You just use the system's package manager (apt-get, yum, pacman, etc.) to install them on your system. For example, you want libblas and libxml2? `apt-get install libblas-dev libxml2-dev`. Done. 
Pick any random linux distribution and look at the packages in their repositories (oftentimes start with "lib")
Check out the comprehensive c archive network at http://ccodearchive.net/. It has a lot of well written, small and modular c libraries.
-Wall is the most descriptive of all, so (personally) I do -Wall -pedantic -std=c99 (or gnu99 if I need to compile SDL, which uses some GNU constructs).
Wextra contains checks that Wall doesn't.
A reliable way to do this is to make the buffer volatile in the first place: volatile uint8_t key[32]; Then you roll your own volatile memset (the standard library functions all only accept non-volatile pointers). I'm unconvinced that the solution in the article is reliable - as noted in the comments, at the end of the day you are still entering `memset` with a non-volatile pointer. Maybe this is sufficient to trick the author's compiler but the C standard doesn't guarantee it to work, as far as I can see. 
You can do it with dynamically allocated memory using malloc() and friends (calloc(), realloc(), etc.). If you want to grow a buffer you might look into realloc().
http://en.m.wikipedia.org/wiki/C_standard_library
Hmm...he said this assignment wouldn't require us to use anything specific to c, as our java knowledge should suffice. Maybe the intention is for the 0 to drop. I'll have to ask the TA. Thanks! I'll check those out. 
Yeah, it seems a little iffy. Whether or not the compiler knows the function pointer’s address, the compiler can still make assumptions about the buffer the function takes as its parameter. IMHO this is an excellent case for including compiler fences in the C standard. In GCC or Clang, you can do a fence with `__asm__ __volatile__("" ::: "memory")`, at least, and I *think* doing one of those after the call to `memset` should force the write.
Allocation is the responsibility of the caller according to the description, so there's no reason to do heap allocation in `insert`.
I saw a comment on the article which suggested assembly code. Do C compilers also optimize calls to asm functions? 
in addition to what /u/nerd4code said, making the buffer volatile just to ensure a single function call gets executed, seems a bit overkill, because you're now disallowing any possible optimizations the compiler _could_ have made in the body of that function.
Cast the buffer to non-volatile for the body operations, if that is actually an issue.
Wouldn't it be enough to wrap memset into another function and put it into another compilation unit? The compiler can't know about side effects of an unknown funciton and therefore can't eliminate the call. Or am I missing something?
Link-time optimisation will notice and optimise.
Reading the replies makes me realise how shitty I really am at programming. 
I ran into a similar problem the other day with a old compiler. You can usually trade off space for speed in programming. If one was inclined, you can do manual loop unrolling fairly easily. At the extreme end he could unroll the loop 256 times and completely eliminate the loop overhead. Although a macro would probably be better way of doing it. if (compareVal == *array_ptr++) { validFlag = true; } else if (compareVal == *array_ptr++) { validFlag = true; } ... etc But maintaining the code wasn't worth the extra complexity. If you really are that performance conscience, the ASM is the way to go because you'll take advantage of the hardware better. Also, as other stated, I would consider an algorithm change before going to ASM.
test test `coding sucks` thanks
You could keep it semi-maintainable with a generalized repeat macro in a separate header. PoC: // repeat.h #define REP1(x) x #define REP2(x) REP1(x) x #define REP3(x) REP2(x) x ... #define REP256(x) REP255(x) x #define REP(n, x) REP##n (x) // source.c #include "repeat.h" .... if (compareVal == *array_ptr++) validFlag = true; REP(255, else if (compareVal == *array_ptr++) validFlag = true;) EDIT: Slightly more generalized if you use ____VA_ARGS____ instead of x. 
Well, I guess it is because you're trying to store an floating number in the "int" type variable.
Thank you very much that got it to work perfectly!
Now if N (256) is dynamic. You can do some crazy switch statement, change the else ifs to if that fall through and use a GOTO (ugh) to terminate . But at that point the code starts looking more like ASM than C and is a maintenance nightmare. switch (N) { case 256: if (compareVal == *array_ptr++) { validFlag = true; goto exit; } // Fall through case 255: if (compareVal == *array_ptr++) { validFlag = true; goto exit; } .... } exit:
One does simply not just include the relevant headers in your source with the c preprocessor
Casts are nothing but polite lies. Why must number1 and number2 be ints? Why not take in floats?
I would change the array lookup to be a hashmap and eliminate the need for looping over 256 entries entirely. Also, move the array and code to tightly coupled memory space to eliminate the need for slower dram accesses. Edit: hash table might not be the best given its worst case lookup. Still changing the algorithm instead of trying to optimize the loop is worth a thought. If the value bound is somewhat reasonable, a bitmap could be used to set the flag whether or not the value is valid. This would result in a constant runtime at the expense of more memory usage.
&gt; Thanks for that. The binary search option is the one I have chosen. See also an earlier comment in the first post. This does the trick very well without using assembly. – wlamers Ironically, the OP just ended up changing the algorithm :P
Scanf can scan floats directly IIIRC, so you're right.
I have this problem as well. At least it's worth some karma over in /r/shittyProgramming
If it helps, I'd say that 75% of the strange material on here can be covered in any basic System's Architecture course that focuses primarily on assembly programming. It's definitely not as complicated and involved as it first seems. 
That macro isn't nearly gross enough - you at least need a static assert macro in the mix to make sure that "n" will never be greater than 256. ;)
In all honesty, you shouldn't use anything in that thread as a measuring stick for how "good" of a programmer anyone is. Not saying the knowledge there is uninteresting or unnecessary, but it has incredibly high diminishing returns. i.e., the fraction of the time it can make a measurable difference in performance is effectively zero. It is also pretty easy to argue that it is even harmful and not just in a premature optimization sense. Convoluted code is more bug prone, harder for others to read and can make some optimizations unavailable to the compiler. 
Heh, true. Though, it was just a proof of concept. Besides, the only thing an assert would do is perhaps give a more meaningful message than "Unkown identifier 'REP300'", compiling would fail either way.
I love that eventually the algorithm complexity reduction win against assembly code I mean this answer http://stackoverflow.com/a/25676849/128629 which looked like preferred by OP
Use [modulo](https://en.wikipedia.org/wiki/Modulo_operation), the % operator. You should: 1. get one character 2. get its [ASCII](http://www.asciitable.com/) value 3. subtract 65 so you get 0 for A, 1 for B... 4. add 3 5. % 26 6. add 65 and print that ASCII value For X you would have ASCII value of 88, subtract 65 and you get 23, add 3 you get 26, 26 % 26 = 0, 0 + 65 = 65, which is the ASCII value of A.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Modulo operation**](https://en.wikipedia.org/wiki/Modulo%20operation): [](#sfw) --- &gt; &gt;In [computing](https://en.wikipedia.org/wiki/Computing), the __modulo__ (sometimes called __modulus__) operation finds the [remainder](https://en.wikipedia.org/wiki/Remainder) of [division](https://en.wikipedia.org/wiki/Division_(mathematics\)) of one number by another. &gt;Given two positive numbers, *a* (the [dividend](https://en.wikipedia.org/wiki/Division_(mathematics\))) and *n* (the [divisor](https://en.wikipedia.org/wiki/Divisor)), *a* __modulo__ *n* (abbreviated as *a* mod *n*) is the remainder of the [Euclidean division](https://en.wikipedia.org/wiki/Euclidean_division) of *a* by *n*. For instance, the expression "5 mod 2" would evaluate to 1 because 5 divided by 2 leaves a [quotient](https://en.wikipedia.org/wiki/Quotient) of 2 and a remainder of 1, while "9 mod 3" would evaluate to 0 because the division of 9 by 3 has a quotient of 3 and leaves a remainder of 0; there is nothing to subtract from 9 after multiplying 3 times 3. (Note that doing the division with a calculator won't show the result referred to here by this operation; the quotient will be expressed as a decimal fraction.) &gt;Although typically performed with *a* and *n* both being integers, many computing systems allow other types of numeric operands. The range of numbers for an integer modulo of *n* is 0 to *n* − 1. (*n* mod 1 is always 0; *n* mod 0 is undefined, possibly resulting in a "Division by zero" error in computer programming languages) See [modular arithmetic](https://en.wikipedia.org/wiki/Modular_arithmetic) for an older and related convention applied in [number theory](https://en.wikipedia.org/wiki/Number_theory). &gt;==== &gt;[**Image**](https://i.imgur.com/ctddz8F.png) [^(i)](https://en.wikipedia.org/wiki/File:Divmod.svg) - *Quotient \(red\) and remainder \(green\) functions using different algorithms* --- ^Interesting: [^Modular ^arithmetic](https://en.wikipedia.org/wiki/Modular_arithmetic) ^| [^Remainder](https://en.wikipedia.org/wiki/Remainder) ^| [^Division ^\(mathematics)](https://en.wikipedia.org/wiki/Division_\(mathematics\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ckaqv17) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ckaqv17)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I have written this: But I am stuck now #include &lt;stdio.h&gt; int main(void) { char ch; do { scanf("%c",&amp;ch); if('A' &lt;= ch) ch = ch + 3; printf("%c",ch); } while (ch='\n'); }
 if('A' &lt;= ch){ ch = ch + 3; } if(ch &gt; 'Z'){ // if, after adding 3 to ch, ch is greater than 'Z', // then handle the special cases here // ... } printf("%c",ch); Also, if you want to show code in a reddit comment, add four spaces ~~in front~~ at the beginning of every line. Also, `(ch='\n')` is an assignment, but you need a comparison.
It still wont work. Its impossible. ive been trying for 5 hours. 
pay me $20 in bitcoin and ill make it work for words and lowercase letters.
Dude cmon man I just want to be finished with this and smoke weed. Help a brother out and please continue from my code. 
just make it ignore spaces
What do u mean
here some great sites i recommend. The first two are the best imo. http://en.wikibooks.org/wiki/C_Programming http://www.cprogramming.com/ I find this one useful for find bits of information, although it isn't my main source of information. http://www.tutorialspoint.com/cprogramming/index.htm This next one is really good, but you will be bouncing around questions a lot since it assumes you have programming experience. http://c.learncodethehardway.org/book/
its closing after newline 
Ye and thats the problem, I want to keep writing it. I think its called a loop if im not misstaken.
yes what is the condition to end the loop?
My first text editor was vim; i didn't find it that hard to pick up. 
You're in the wrong subreddit for one thing.
Yes; branches aren't awfully fast, especially when the branches aren't "well-behaved" (predictable), as with the `bitcount` function. It's a common optimization to replace branches with bit twiddling when possible.
the first one is way more readable though.
What are you passing to the functions?
If this problem interests you, chapter 5 of [Hacker's Delight](http://www.hackersdelight.org/) is devoted to bit-counting algorithms. Here is the code, if you'd like to time it with your test setup: http://www.hackersdelight.org/hdcodetxt/pop.c.txt 
Try it with x set to all 1s. I expect you will see the second one being about the same as the first. Then try it with x set to all zeros. The second one will be even faster. The reason for this is that int the first one routine the loop executes once for every bit up to the most significant bit. In the second routine the loop executes once for each set bit.
Agreed. This kind of task is why scripting languages like shell or perl were invented.
If you are familiar with the "trick" in the second one then the second one is more readable! 
That's the same as his second version, just refactored a bit. 
I'm a bit disappointed that the compiler didn't optimize the first one to do what the second one does!
To eliminate the branch try this variant as well: int bitcount2(unsigned int x){ int b; for (b = 0; x != 0; x &gt;&gt;= 1) b += x &amp; 1; return b; }
Thanks for the suggestion. Just tried it, 10.395 usec, certainly faster than the first.
If you look at the assembly on http://gcc.godbolt.org/, some compilers optimise the branch into a conditional move.
I got this book as a gift and it's awesome. I've used a few of the snippets in production and the unused stuff is still fascinating.
AKA: [Duff's Device](https://en.wikipedia.org/wiki/Duff%27s_device) Note that you don't need `goto`.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Duff's device**](https://en.wikipedia.org/wiki/Duff%27s%20device): [](#sfw) --- &gt;In [computer science](https://en.wikipedia.org/wiki/Computer_science), __Duff's device__ is an [optimized](https://en.wikipedia.org/wiki/Optimization_(computer_science\)) [implementation](https://en.wikipedia.org/wiki/Implementation) of a serial copy that uses a technique widely applied in [assembly language](https://en.wikipedia.org/wiki/Assembly_language) for [loop unwinding](https://en.wikipedia.org/wiki/Loop_unwinding). Its discovery is credited to [Tom Duff](https://en.wikipedia.org/wiki/Tom_Duff) in November 1983, who at the time was working for [Lucasfilm](https://en.wikipedia.org/wiki/Lucasfilm). It is perhaps the most dramatic use of [case label fall-through](https://en.wikipedia.org/wiki/Switch_statement#Fallthrough) in the [C programming language](https://en.wikipedia.org/wiki/C_(programming_language\)) to date. [*[citation needed](https://en.wikipedia.org/wiki/Wikipedia:Citation_needed)*] Duff does not claim credit for discovering the concept of [loop unrolling](https://en.wikipedia.org/wiki/Loop_unwinding), just this particular expression of it in C. &gt; --- ^Interesting: [^Loop-switch ^sequence](https://en.wikipedia.org/wiki/Loop-switch_sequence) ^| [^Tom ^Duff](https://en.wikipedia.org/wiki/Tom_Duff) ^| [^Rc](https://en.wikipedia.org/wiki/Rc) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ckcfogx) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ckcfogx)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
As others have pointed out unpredictable branches, or even just branches, can have a relatively high cost. Anyway, the traditional solution to this is a table based solution: // c[x] = number of '1' bits in the byte x static const char c[256] = {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8}; int super_fast_bitcount(unsigned int x) { return c[0xFF &amp; x] + c[0xFF &amp; (x&gt;&gt;8)] + c[0xFF &amp; (x&gt;&gt;16)] + c[0xFF &amp; (x&gt;&gt;24)]; } The times I get for the three variants are 50.7 ns average per run for bitcount, 9.28 ns average per run for fast_bitcoint, and 1.43 ns for super_fast_bitcount.
It's a suprising bit of sytax to say the least.
You can do information hiding in C. struct Button; void Button_click(struct Button* self); is fine. `struct Button` doesn't need to be defined in the header file. So object-oriented programming is nicer in C than in C++ in that regard. What I don't like: C has no closures. That is a pain in the ass, what with all the damn passing around `void* userdata` everywhere. So this doesn't officially work either (though it doesn't give any warning): int (*Counter(void)) (void) { int x = 0; int inc(void) { ++x; return x; } return &amp;inc; } int main() { int (*counter)(void) = Counter(); (*counter)(); return (*counter)(); }
thanks for great point of view 
Your while loop on line 6 goes haywire and i ends up going beyond the bounds of word[]. Check the condition of the while loop. In general I think the entire function could be simpler though.
They don't get compared to zero though do they? Edit: Unless you mean null. I've made this kind of loop work before for other pointer things so I'm not sure why it wont work now.
LariscusObscurus explains part of it. Also look at the logic -- do you need OR or AND?
Incrementing i isn't the problem, it is that the logic in while() makes the loop go on until word[i] is out of bounds. Concentrate on the condition in the loop.
I assume Or because it might be that one word is longer than the other, in which case I need to append the remaining word to the string. I guess this is wrong but thats just how it's working in my head.
The null character is represented by the char value 0, also written '\0'. The null pointer is represented by 0 and also the token NULL. (Although actual pointer value may be different, but generally isn't). C is quite happily casting between them for you.
Ahhhh okay I got ya now. Need to be looking at what P is pointing at rather than the actual pointer itself. Just changed it, had a few more instances in my code with a similar problem and it almost works, except I'm not appending the remaining string on, it just null terminates when both strings are at null. Eep.
For the dereferencing part, a pointer at a memory level is pretty much just some number and '\0' is equivalent to 0. In your loop as you pasted it, you keep incrementing that number until it's equal to 0. It's like doing int i = 4; while(i != 0) i++; By dereferencing it, you're instead comparing the char stored in each slot of memory and seeing if it's 0/null instead of whether the pointer is 0/null For the second part, step through what's happening inside the loop when you've hit the end of one string but not the other. You use i to go alternate which string you're currently appending to the result but what would happen given inputs "the" and "spaceship"? 
Yes, of course you can do that. However, there's not defined order of evaluation of functions in a statement, or parameters of a function call.
he knows the order that the results will be used in though, so unless the function has static/persistent variables it's a non-issue.
Why not try it and find out for yourself?
The whole point of my statement is that he does not know what the order will be based only on his exemplar code. It is not knowable in what order resultOfFunction(a) and resultOfFunction(b) will get evaluated, in general.
I did and it worked! :)
Really? So it will get evaluated based on BODMAS(Brackets, Orders, Division, multiplication.....) rules? I did not know that. So it can be an issue in certain implementations i guess. 
int main() { float number1, number2, quotient; printf( "number one?\n" ); scanf ("%f", &amp;number1 ); printf( "number two?\n" ); scanf ("%f", &amp;number2 ); quotient = number1/number2; printf("they equal %f\n", quotient); return 0; }
http://www.exforsys.com/tutorials/c-language/c-expressions.html
~~That's because when you push the enter key, the newline character is added to the input buffer. On the second scanf call, you tell scanf to parse an integer, but it finds the newline character instead and concludes that it is not a valid integer, so it returns straight away.~~ ~~Instead, you should have your scanf calls ignore any leading whitespace, simply by putting a space before the first `%i`. A whitespace character in a scanf format string is actually a directive, telling scanf to skip all whitespace characters up until the first non-whitespace character.~~ And, you should *always* check the return value of `scanf`. It will return the number of items successfully scanned. In your case, both calls should return 3 if there was no error. printf("Enter first date(DD/MM/YYYY): "); if (scanf("%i/%i/%i", &amp;d1.date, &amp;d1.month, &amp;d1.year) != 3) { printf("Invalid input\n"); return 1; } printf("Enter second date(DD/MM/YYYY): "); if (scanf("%i/%i/%i", &amp;d2.date, &amp;d2.month, &amp;d2.year) != 3) { printf("Invalid input\n"); return 1; } printf("\n");
No, what he means is, if resultOfFunction(a) affects b and you expect resultOfFunction(b) to return a result that is calculated on the modified b, then you cannot rely on the order of execution. Kapish?
&gt; That's because when you push the enter key, the newline character is added to the input buffer. On the second scanf call, you tell scanf to parse an integer, but it finds the newline character instead and concludes that it is not a valid integer, so it returns straight away. That's not how scanf works. Most specifiers (everything except `%c`, I think?) will discard any leading whitespace. Writing `" %i"` is redundant. The space is only useful for `%c` which would actually read a newline if the buffer held a newline. 
Running your code (or the `main()` part of it anyway, ICBF fixing all the formatting) , the `scanf` input works properly. Using `scanf` like this is not very resilient towards input errors though, so if you typed anything except the exact format required, the the scanning would fail (and appear to skip the next `scanf`, because when it fails to match, it leaves the failed characters in the buffer and they would also fail to match when you tried again). For example if you went `12-12-1234` it fails because it expected exactly `/` as a separator. In any case, you should **always** check the return value of `scanf`. It returns how many items were successfully matched. In your case, if it doesn't return `3` you should take some error handling action. NB. no idea why reddit is giving my post a horizontal scrollbar that makes the post disappear when clicked...
Oh of course, right you are. I knew something sounded off as I wrote that... only `%c`, `%C`, `%n` and `%[` need a space for skipping any preceding whitespace.
Association is not the same as evaluation. BODMAS describes association, and C has its own operator association table that it adheres to. That only tells you how the operands are grouped together, not in which order you should evaluate each operator and operand. If I have `3 * 2 + 2 * 4`, association tells me that it's equivalent to `(3 * 2) + (2 * 4)`, but it doesn't tell me whether I should work out `3 * 2` first or `2 * 4`. In this case, it doesn't matter, but if the operations have side effects on shared objects, there's a problem.
I really wish /r/C_programming had actual moderation, so we didn't get constantly bombarded with /r/learnprogramming content. It really makes this whole subreddit far less useful.
i'm not familliar with it, maybe adding a comment what it does helps. I once did character swapping with bit operations at work and people told me not to do that.
Well, understand why you were "told not to do that". Some bit operations are well-defined and some (mostly, operations on signed values) aren't. On an unsigned int, going `x &amp; (x-1)` toggles the lowest `1`-bit. (It's probably better for you to figure out why for yourself by trying some examples, than for me to try to explain). 
Note that you're not actually putting a function inside a statement; you're putting a function *call* inside a statement. The function itself lives elsewhere. Or, to put it differently, you're calling a function inside a statement.
Sounds like you got it working. Here is how I would have done it: char * intl(const char *s1, const char *s2) { char *rc = malloc(strlen(s1) + strlen(s2) + 1), *cur = rc; /* Interleve strings and stop when the end of either string is reached. */ for ( ;(*s1 != '\0') &amp;&amp; (*s2 != '\0'); cur++, s1++, s2++) *cur = *s1, *(++cur) = *s2; /* Copy the remainder of the longest string and terminate the result. */ strcpy(cur, *s1 == '\0' ? s2 : s1); return rc; } 
&gt; You probably should be using the secure versions, but this should help you get started. Unless it needs to be portable. The _s functions are MSVC only.
I think it's only a warning. Some of the functions in the C stdlib are insecure if used incorrectly. To mitigate this Microsoft introduced the _s family of functions which do the same but are harder to misuse. This happend around the time when Windows XP had big security problem and MS started to take this issue more seriously. Some of those functions such as `memset_s` and `get_s` even made it into into the C11 standard. So you can just ignore the warnings or use the more secure functions if the compilers you target support them.
i was told i should comment it and only use it if profiling showed it was an issue (it wasn't), it was a swap of unsigned chars to generate a permutation. My previous comment was a bit rushed, sorry.
Probably disabling Security Development Lifecycle (SDL) checks would help too. (It's enabled by default when creating new projects.) It marks C4996 as an error rather than a warning.
gets(),scanf(),strrev() sorry to enter in the thread, but what are the safe similar functions instead of gets, scanf, etc
this is like the good old c64 days :)
That is a huge improvement over my code, jesus. Going to study this and try figure out how it works, thank you.
I don't know about an improvement. It is pretty ugly -- I wouldn't try to replicate it. I was trying to see how few lines I could do it in. Can you post your final solution? Maybe we can give you pointers.
maybe you have warnings treated as errors enabled.
Read the rest of the OPs question. He gives you the answer. That warning has been there since VS2008 from what I remember. Its just a compilation warning and you can choose to ignore it, add a preprocessor definition to never warn of unsecure methods or use the secure method. Regardless of what method you choose, it will still compile and run. When i write code in VS, normally i set the project properties to make warnings cause compilation errors. And if i have to use the unsecure functions, then i add the preprocessor def. Method=function. Same shit in C
The ICPC has an archive of all of their past problems, and it looks like they still have a feature for upload of your solution and automatically score. These are *general programming challenges*, using *basic features*, *not* things like network communication, drivers, threads, syntax minutiae, etc -- C just happens to be one of the languages accepted -- but they vary widely in difficulty (there is some indication of the difficulty of each in the % solved statistic). https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8
http://eudyptula-challenge.org/
[Build Your Own LiSP](http://www.buildyourownlisp.com/)
If you are interested in tests, then also see http://todayscoffees.com/quiz?lang=c. It's a good way to read real code examples. 
Project Euler are math challenges first and foremost. Unless you find mathematical peculiarities of e.g. prime numbers interesting, it probably isn't something you'll stick with.
You are invoking undefined behavior by modifying x multiple times between sequence points. The result of both of these statements is undefined.
Well, why is it undefined behaviour? 
Please give an example of the text file contents. 
 10111010100 00000101001001010 1001010101000 1001010101000
Oh, I see, you meant *literally* binary as text. I won't ask why ;) Well, `fgets` will read each line/number into a buffer, and you can just iterate through that. 
Homework time! Yay! But I would read in each line as text, then use the fact that it's, y'know, *binary*, to turn it into numbers. From there, it should be obvious. If you can't figure it out from the clues I have up there, you may not be cut out for this field :/ 
I can always tell a new semester starts, because newbies ask typical homework type questions in the hope that other people can do their homework
You can't really convert a number to an array. You can populate an array with numbers, but not convert a number to an array.
noobs gonna noob. Convert integer to array lolwut?
Wow, this is like 5 minutes work. Read each char form source, check if it is 1 or 0. Then use bit shifting/setting to add it to an integer/long. Then add that to an array of them when you encounter a new line (though you may need to calculate the number of lines ahead of time to allocate enough heap space, assuming you are using the heap).
Sure you can. You just shouldn't. int number = 42; char *array = (char *)&amp;number;
Yeah, rule of thumb is to only modify a variable once per expression. Which avoids all kinds of fun side effects.
because the C standard doesn't specify a left to right order of precedence. Mainly so that the compiler can order compiled instructions in a more efficient way.
&gt; temp-&gt;data = string; You aren't copying the string, you're only copying a pointer to the string. You need to allocate space for a copy of the string and use `strcpy` from `&lt;string.h&gt;` to make the copy. Remember to free the space when you are done.
Here's an "exercises" dump from my bookmarks: * http://www.spoj.pl/ * http://uva.onlinejudge.org/ * http://www.gotw.ca/gotw/ * http://www.reddit.com/r/dailyprogrammer * http://www.reddit.com/r/learnprogramming/wiki/index#wiki_programming_challenges * https://www.hackerrank.com/ (I haven't tried this one yet, so it has not earned my accolades) * http://usaco.org/ Not a challenge site, but a principle: http://c2.com/cgi/wiki?DoItAgainToLearn \* missed one.
*p* always points to the same bit of memory. Therefore every *NodeT*s data points to the same string. When you call *sscanf*, it modifies the string that every *NodeT* points to. You probably meant to allocate a new string for every node. NodeT* temp = malloc(sizeof(*temp)); temp-&gt;data = strdup(string);
Yeah, it's legal. One more thing that is not directly connected to your question, but is important to understand, is called 'sequence point': http://en.wikipedia.org/wiki/Sequence_point http://c-faq.com/expr/seqpoints.html 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Sequence point**](https://en.wikipedia.org/wiki/Sequence%20point): [](#sfw) --- &gt;A __sequence point__ defines any point in a [computer program](https://en.wikipedia.org/wiki/Computer_program)'s [execution](https://en.wikipedia.org/wiki/Execution_(computers\)) at which it is guaranteed that all [side effects](https://en.wikipedia.org/wiki/Side_effect_(computer_science\)) of previous evaluations will have been performed, and no side effects from subsequent evaluations have yet been performed. They are often mentioned in reference to [C](https://en.wikipedia.org/wiki/C_(programming_language\)) and [C++](https://en.wikipedia.org/wiki/C%2B%2B), because the result of some expressions can depend on the order of evaluation of their subexpressions. Adding one or more sequence points is one method of ensuring a consistent result, because this restricts the possible orders of evaluation. &gt; --- ^Interesting: [^C ^\(programming ^language)](https://en.wikipedia.org/wiki/C_\(programming_language\)) ^| [^Feynman ^point](https://en.wikipedia.org/wiki/Feynman_point) ^| [^Comma ^operator](https://en.wikipedia.org/wiki/Comma_operator) ^| [^C99](https://en.wikipedia.org/wiki/C99) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ckgen39) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ckgen39)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Guess we'd better not tell the kid about big and little endian order; he might blow a gasket.
Definitely this one, written by the creators of the language: http://www.iups.org/media/meeting_minutes/C.pdf It may be a little difficult as it assumes you have a technical background but it's the best reference out there in my opinion. What I would recommend is to start reading the book and Google any questions you may have, no matter how small. I find this a very good strategy for self-teaching. Also for your assignment, look into for loops and the pow function in math.h
If you're in a hurry to learn you probably won't get far, even if you have the best of learning materials. Anyway... You can go with the materials on the side-bar, specially the "The ANSI C Programming Language - Second Edition", but from what I've seen lots of people have difficulties with it. So don't expect it to be easy. It could be that you have no troubles with it. It's just too much to ask for: finding it easy and actually understanding what it says. That book is known as K&amp;R2 (Kernighan and Ritchie, 2nd edition). Ritchie is the inventor of the language's name. For most people I've seen, C is surprisingly difficult. They are easily misled by C's features and rules. To learn it, you generally have to pay attention to a level of detail you normally don't deal with in popular languages today. The major issue is that this isn't just a problem with students. As it turns out, it's common to find C teaching materials full of mistakes too. And the ones which are correct don't tend to be easy to read (as I've noticed from observing other people). As unfortunate as this may be, it's also likely that your professor will make several mistakes while teaching C. And to make matters worse, it seems it's pretty difficult for people to see they got some parts of C wrong in case they did. If you're just starting to program, you could consider another book. Like Deitel's C How to Program. I don't know if it's correct, but Deitel's books at least tend to be beginner friendly (and it's probably correct enough for a programming 101 classes and forward). Just as a final note, I am __not__ saying "I know C and everyone else is stupid." It may look like I am, but I'm not. =D
Thanks!
Write a BASIC interpreter
/r/dailyprogrammer
&gt; I don't know if it's correct Seems to have a lot of [endorsements](http://www.deitel.com/Books/C/CHowtoProgram7e/tabid/3635/Default.aspx) from people on the C standard committee. Must be decent. Also, never heard of the book before so thanks for introducing it.
Well that doesn't apply here, as you are bit setting, endian is automatic. endianness applies to bytes, but we are dealing with bits. If we converted it to a byte array, then endian would definitely apply, but I am just converting it to integers/longs into an integer/long array.
The algorithm: 1. Attend class. 2. Comprehend the material being taught. 3. Ask your instructor for assistance.
Anything else?
I have but it printed result the other way...shall I post the code?
You may but... 1. You haven't defined the problem. You just said "how to print the pattern for any number like for 5678". So any number has a pattern? What is this pattern? What is the input and the desired output? Be specific. 2. You can paste code make sure it is somewhat readable and conveys the intent.
And the [code](https://gist.github.com/anonymous/17eab3d0d188e9de74c7 )
&gt; the output pattern is here! So any number has a pattern? What is this pattern? What is the input and the desired output? Be specific.
I just posted the link.
for a number like 5678 this should be the [ouptut](https://gist.github.com/anonymous/d9be4cbab3a2dde1a672)
Fine, forget it. Crucial hint: you need to know the number of digits in n. Knowing how to determine the number of digits numerically lends itself as the algorithm to generate the desired "pattern."
From what he has said, that might be a bit over his head. Maybe a brainfuck interpreter might be a better/easier start for a beginner. But that is still something of a longer term goal.
From the code you posted: int l(int a,int b) { for (int i = 1; i &lt; b; i++) a = a * 1; return a; } What is returned by calling l(3, 3)? What is returned by calling l(3, 42372)?
l is a function raising a to the power b.here a is 10,and b will be the number of digits in the number after the truncation.
From [this book on the side panel](http://publications.gbdirect.co.uk/c_book/chapter10/arguments_to_main.html): When a program starts, the arguments to main will have been initialized to meet the following conditions: argc is greater than zero. argv[argc] is a null pointer. argv[0] through to argv[argc-1] are pointers to strings whose meaning will be determined by the program. argv[0] will be a string containing the program's name or a null string if that is not available. Remaining elements of argv represent the arguments supplied to the program. In cases where there is only support for single-case characters, the contents of these strings will be supplied to the program in lower-case. Based on the above `argv[0]` is definitely not the argument you want. [Here's information on how to use fscanf](http://publications.gbdirect.co.uk/c_book/chapter9/formatted_io.html) (see the very bottom).
l(3,3) should return 27. l(3,42372) should return the value of 3^42372. it is just the power function.
Got it...Thanks!! I happened to be little confused between how % and / works!!(Any comments?) Solved the problem though!
Glad I could help.
In addition to all the suggestions herein, check out http://learnxinyminutes.com/docs/c/ for a quick overview.
The physical version of this book is well worth it, in my opinion. Comparing the PDF to my copy, the PDF is very poorly laid out (typesetting?). I'm also aware of a PDF version of K&amp;R 2nd edition that has some errors, but I don't know if this is that particular PDF (can't recall the specific mistakes off the top of my head to check). That said, it'll still be worth reading the PDF. Also check out this recent C_Programming post for exercise resources: http://www.reddit.com/r/C_Programming/comments/2g2aye/what_are_some_good_websites_to_look_for_c/
 frequency=sqrt(1/(L*C)-(R*R)/(4*C*C))
&gt; it is difficult to compare anything with floating point values(so the compiler says!) That is not what the compiler is saying. $ clang -std=c99 -Wall -Wextra -pedantic -O3 -o program program.c program.c:3:1: error: 'main' must return 'int' void main() ^~~~ int program.c:7:16: warning: format specifies type 'float *' but the argument has type 'double *' [-Wformat] scanf("%f%f", &amp;L, &amp;R); ~~ ^~ %lf program.c:7:20: warning: format specifies type 'float *' but the argument has type 'double *' [-Wformat] scanf("%f%f", &amp;L, &amp;R); ~~ ^~ %lf 2 warnings and 1 error generated.
The rest of your code looked a bit more complicated than I would expect for the problem you're being asked to solve. You shouldn't need a power function in the first place. I only commented on that because that was a very obvious mistake, and I thought if I could get you to see it, the rest might fall into place. I would also encourage you to take such debugging steps, like printing stuff out in loop iterations, before you resort to asking for help.
is there any way to rectify it?
The first step is to understand what the compiler messages mean. Do you understand what the compiler is saying? If you read carefully, the compiler output I pasted above tells you not only what the problems are, but exactly how to fix those problems.
I would encourage you to take some debugging steps on your own first. If your code isn't doing what you think it's doing, you need to find out exactly what it **is** doing. At this stage, that means printing out the values of variables at various points in your program, to see if they are the values you would expect them to be. Don't be afraid to have your program be verbose when debugging - you can always remove that stuff once you have it working. If and only if you have taken such extra debugging steps, and you see certain values but don't understand why they're happening, then consider posting here with only the relevant information. So, instead of posting your entire program and saying "it doesn't work, help", you need to post: * What it is you're trying to accomplish with the operation or series of operations - this may be a small function, or a few lines of code. * What you would expect the result to be, given a specific set of input value(s) (e.g. "I'd expect the result to be 3 when x is 6 and y is 7, but the result I'm seeing is 8").
OH MY GOD MY CAPSLOCK IS BROKEN
indent by four spaces for monospaced formatting.
may i know what compiler is yours? i am using visual studio.
I am using Clang, as you can see from the first line I pasted above (the command line in which I invoked Clang).
The first error is the compiler being picky. In most environments your main function must return an int and cannot be void. Under some windows compilers like visual studio(?) it can be void. The second two issues are type miss matching. "%f" is for floats yet the variable "L" and "R" are type double. 
Check out the Lua source code. It's one of the best C source code that out there http://www.lua.org/source/5.2/
If you're using Linux or OS X, try using valgrind. It is invaluable when programming in C. The code you gave raised 16 on my machine.
So I changed the code to currentTask = gui_data-&gt;tasks + x; and in parse_toDo I have also removed the multiplication of sizeof but alas I get corrupted data as soon as I print it. I am waiting for my coffee which should help. EDIT: My coffee is delicious.
That's exactly my problem. I can't free.
On a side note I agree with you. -Wall and valgrind is a must.
Even after drinking this wonderful beverage I'm unable to understand why I get corrupted data. I am unsure if I need another level of abstraction with a double pointer to gui_data (something like parse_todo(Gui_Data **gui_data)) or if the problem resides in my shitty dates and time parsing algorithm or if it's something else.
Is the problem with the task body?
It seems like only the first task data gets corrupted. I'm unsure why and am investigating with a second coffee.
Well the first task is written as: ||[09/09/2014 21:43 10/09/2014]Faire une marche avec mes chiens Which means the start date is 09/09/2014, the start time is 21:43, the completion date is 10/09/2014 and there's no completion time. It also means the body is "Faire une marche avec mes chiens". But instead I get 09/0(0 80 H0 21:4X0 as of the date value and it is constantly changing value as I run the program.
So here's two things I saw: The Gui_data pointer passed to parse_toDo is uninitialized, thus when freeAllTasks is called nbtasks may have an unexpected value. And second: the memory allocations use sizeof(ToDo_Task*) instead of sizeof(ToDo_Task), meaning the program allocates for a pointer, not the whole structure.
I'm not too sure I understand what you mean uninitialized. I allocate the memory for it in my main function before sending it to parse_toDo and in parse_toDo I set nbtasks to 0 and allocate my memory for todo_task.
Oh Allah I'm an idiot. I only reallocated the pointer array tasks but didn't actually malloc the task after. I'm so stupid! I added this: currentTask = malloc(sizeof(ToDo_Task)); I will fix the parsing code and post it. Thanks!
Saend found the problem [here](http://www.reddit.com/r/C_Programming/comments/2gbbhu/how_do_i_modify_the_content_of_an_element_inside/ckhghkh). Thanks a lot for the pointer arithmetic though it helped.
parse_toDo() calls freeAllTasks() at line 70 before you initialize gui_data. freeAllTasks() in turn uses gui_data as if it was initialized. This may not cause any problems on your computer, but is undefined behavior, and it makes valgrind complain quite loudly.
Well I got excited too fast. After running parse_toDo two times I get seg faults. I will valgrind the shit out of my program and will get back to you if my 2 watts brain can't process my spaghetti code. By the way [here it is](http://pastebin.com/SXL9fCbg).
Then you have to change gui_data-&gt;tasks 's type to ToDo_Task \*\*tasks, or malloc for ToDo_Task instead of ToDo_Task\* as I mentioned before. EDIT: Battling formating
When you do currentTask = malloc(sizeof(ToDo_Task)); line 93, you overwrite the pointer you computed line 92 with one pointing to new memory, but which you don't store.
It sounds like you want to be a better C programmer. I think the first step is to [go through these slides](http://www.slideshare.net/olvemaudal/deep-c) from Olva Maudal and Jon Jagger. This is not C specific but look at some of the prominent open source C projects in [The Art of Open Source Architecture book](http://www.aosabook.org/). If you want to look at some ugly C code take a look at [OpenSSL](https://www.openssl.org/).^1 The problem is actually not so much the C code but the lack of documentation, tools, being able to perform analysis (like run Valgrind), etc. If you want to know how to write some professional C, [read the libavl documentation](http://adtinfo.org/index.html). You might be wondering why I suggest you read the documentation of a library you may or may not use. Stop wondering and just do it. I now work on C on a daily basis (formerly a network/systems admin/operator/engineer/architect/designer/esquire/etc.^2 ). We follow coding standards but are much more relaxed than [MISRA](http://en.wikipedia.org/wiki/MISRA_C) and [JPL](http://lars-lab.jpl.nasa.gov/JPL_Coding_Standard_C.pdf). It is worth looking through their coding style and adopting *some of it.* Also look at the references. As for projects there's a few that you can do. I would first identify a domain that interests you. For example, I work on writing a bignum library due to my interest in algebraic number theory &amp; cryptography. I can take a professional approach, write tests, make it easily instrumentable for performance measurement, etc. but at heart it is a hobby project (and probably a bad idea to use for cryptography). Others mention DSP, HTTP server (network programming), etc. There's plenty of domains, just pick one that would keep you engaged. [1]: I've used OpenSSL extensively. You'll find the documentation is insufficient, barely any comments, etc. [2]: We have big egos :). 
&gt; Media manipulation almost absolutely needs to be done in C I read that as we need to revive C as a popular language by tricking journals (such as DrDobbs) to write good news about the language.
I'm not anywhere near a pro in C, but this advice applies to any language: * Sit down and assess your current skill level * Determine one of your weak points (certain language features you don't understand, for instance; or comp sci concepts you've not grasp but find interesting) * Look for software that uses what you're weak in and read its code for inspiration or learning * Try to mimic a subset of that software's features as a proof of concept * Branch out and see if there's a corner case you can satisfy and write a program to handle that case (better if you hack on the original software so you can provide it as a patch) * If you hack on the other project, submit a patch and see if you can get support added for the corner case. If it gets in, you just earned yourself some FOSS credit! :D * If you opt to satisfy it with a standalone program, just bang out the code, try to write tests for it if possible, write up some documentation and a Getting Started guide (if needed). * Publish somewhere (GitHub, Bitbucket, your own `cgit` instance, doesn't matter) and post it to relevant communities. For instance, you develop a plugin for a project that covers a previously absent use case. You'd post about that on that project's community somewhere, assuming their rules facilitate plugin promotion (see /r/vim for a great example). * ??? * Profit!
Totally unrelated to the OP's question, but where would I find the library do you work on? I would love to check it out.
Ok, so you mostly got it right. Here's my [diff](http://pastebin.com/yvtbDvyq). First, the pointer gui_data-&gt;tasks was still uninitialized, but free'd at the end of freeAllTasks(), raising "Conditional jump or move depends on uninitialised value" in valgrind. Second \*(gui_data-&gt;tasks) = malloc(...), tries to change the value pointed by tasks. But tasks is uninitialized (or NULL after my first change). What you want to do is change the value stored in tasks so that it points to the first element of your array of pointers. Same problem when using realloc. BTW, the malloc line 82 is not needed, since realloc will be called with nb_tasks = 1 next, and calling realloc on a NULL pointer is ok. And third a simple off-by-one error: when you allocate for nbtasks elements, the last is at nbtasks-1. EDIT: [unified diff](http://pastebin.com/wFWeBG8E) may or may not be clearer.
I've found as I've been looking at it recently that [openbsd](http://cvsweb.openbsd.org/cgi-bin/cvsweb/)'s source is quite easy to follow.
Wow. I had no idea literate programming had been used anywhere other than Knuth's own code. Should be damn near ubiquitous IMO.
Glad I could help, don't hesitate to pm me if you have other questions =) On an unrelated note: you speak french?
Yes I do! In fact it's my native language so I always use that as an excuse for my poor English. Parles-tu français aussi? (Do you also speak french?) On a side note, if you ever go to Gatineau or Ottawa, the beer (if you drink) and the green cigarette (if you smoke) is on me.
Well, you read a single character from the file handle `cp12int`, and then you do something with that single character 32&amp;nbsp;times, and print the result. That seems like the wrong thing to do, doesn't it? Shouldn't you be reading 32&amp;nbsp;characters and operating on each one once, rather than reading a single character and doing something with it 32&amp;nbsp;times? Also make sure you understand the difference between the **characters** `'0'`&amp;nbsp;and&amp;nbsp;`'1'` and the **integers** `0`&amp;nbsp;and&amp;nbsp;`1`. You are reading *characters* from the file, not *integers*. The character&amp;nbsp;`'0'` does not equal the integer&amp;nbsp;`0`.
I would recommend starting with 2a, specifically the summation one. What I'd like to know is if you have any ideas (at all) on how to start this. Doesn't matter if you think they're ridiculous!
&gt; How would I convert a character to an array? What do you mean? Can you give an example of "converting a character to an array"? &gt; Also how would I get my n[i] to be an array of 32 characters Do you want `n[i]` to be an array of 32&amp;nbsp;characters, in which case `n` is apparently an array of arrays? Or do you want `n` to be an array of 32&amp;nbsp;characters, in which case `n[i]` is a single element of the array?
I don't exactly think it's ridiculous. I get confused about how looping works but I know that you use while, do while, and for. This is my first time ever using loop and mixing summation (another thing I know nothing about) with it doesn't really help :/ 
I get the gist of it, however mixing summation and fractional problems kind of mix me up. This is my first time programming. I'm two weeks in and the book I had to buy for the class was meant for Java. The code you told me to "output" for you looks like it will go up by 1 every "loop" until it reaches 10. Essentially it loops 10 times right? 0, 1, 2, 3 etc and ends at 9?
Oh and I tried using an example to set up my equation but I have to keep on putting in numbers until I purposely put something in that's negative /* input/sum numbers as long as they’re positive */ int sum = 0, number; printf (“Enter a positive number please “); scanf(“%i”, &amp;number); while (number &gt; 0) { sum = sum + number; printf(“Enter the next number “); scanf(“%i”, &amp;number); } printf(“The sum is %i\n”, sum);
&gt; Convert the character "0" to the integer 0. You need to be careful here. * `"0"` is not a character. That's a string literal. * `'0'` is a character. * `0` is an integer. The difference between these is very important. To convert a character that is a digit (`'0'`&amp;nbsp;through&amp;nbsp;`'9'`) into the corresponding integer, subtract the character&amp;nbsp;`'0'` from it. &gt; And n to be an array of 32 characters or better an array of 32 integers after converting them. Declare `n` to be an array of 32&amp;nbsp;`int`s like this: int n[32];
Yeah, that's right. So can you take a stab at 1? What kind of loop would you use that would stop looping upon receiving a negative?
So I suppose now I'm partially confused as to how your code is set up. Can you copy paste all your code into [pastebin](http://pastebin.com/) with C syntax? Since to me it sounds as if what you just pasted here is in a loop and so I'd like to see all the code you have so I can help walk you through some of it.
I'm so confused on how this all works that what I have it practically nothing int main(void) { int num, total = num; do { printf ("enter a number here "); scanf ("%i", &amp;num); total = total - 1; } while (total &gt; 0); return 0; } I've seen how some loops automatically go up from whatever number you put in, however like you said summation is when you take all the numbers from the countdown and add them all together. I thought what code I put up there might be the start of that.
Well in order to stop one loop, wouldn't I use do-while?
Focus on the summation for now, it's the most straightforward one to understand I think. So, first things first, do you understand what a summation is? In this context, a summation is everything before a number added together. For example, the summation of 3 would be the same as 0 + 1 + 2 + 3 = 5. What I want you to do is to step away from the code and think about this purely from a logic standpoint. Can you write out, step by step, in plain english, what you need to do in order to calculate a summation? Show me what you figure out.
Hmm, well I was given 5 numbers. And if that's the way summation works (thank you) then 4 would be 1+2+3+4=10, 7 would be a basic countdown but you add all the numbers that you announce. Whatever the sum of those is the summation. Am I getting the picture?
Yes you are, but I still want you to write it out, step by step. If I gave you the number 23 and asked you for the summation, what would be every explicit step you take to reach the answer? Don't leave out or skip any steps, every little step.
Alright: well we would start with 23 and begin to count down. 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0. Now that I have all the numbers I just add them up: 0+1+2+3+4+5+6+7+8+9+10+11+12+13+14+15+16+17+18+19+20+21+22+23. All of that adds up to being 276 right? Now the way I did it was slightly tedious. Is there a better way?
There is, but it's not a concern right now. In fact, what you did is exactly right: It might seem tedious but what you did is a very important concept in programming: Computers need specifics, and they don't understand things unless you tell it *exactly* what to do. Lets start with the first part here."We would start with 23 and begin to count down" is something that can be represented as a loop. Any ideas how you'd set up a loop that starts at a number, and counts down (or up)?
You've got the right train of thought, but we do know how many times we loop, remember? The user passes us a number and asks us for the summation of the number. How many times do we loop? Look at how you worded it above. "We would start with 23 and begin to count down." With that in mind, we do indeed use a for loop for something like this. Of course, a while loop is totally applicable, but a for loop is the best fit. In C, the syntax for a for loop goes as follows. `for( `**initialization**` ; `**truth condition**` ; `**post-operation**`)` Where: *The initialization is what happens once when the loop first starts. You'll often see people set variables to an initial value here: One you'll see really often is `i = 0`, which sets the variable `i` to 0. The key thing to remember here is that this only happens *once*. * The truth condition is something that's evaluated once per iteration (cycle), and it's very straightforward: If this truth condition evaluates to `false`, then the loop stops. If it evaluates to `true`, then the loop continues. Often times, you'll see something that involves the variable in the initialization: Something like `i &lt; 10`. This truth condition would evaluate to `true` when `i` is anything 9 or lower, and `false` if `i` is 10 or greater. * The post operation is what happens when you reach the end of each iteration. Typically, this modifies the variable in the initialization in some way: One you'll see very often is `i++`. With all this in mind, how do you construct a `for` loop that will count down from any number that the user gives us?
Alright, but what the assignment wants according to you and multiple others you need to be able to get the numbers that make up your num. For example: If I put in 4, how would that count down from 4 and give me 4,3,2,1,0.
By using a for loop since I know how many times I'm going to be looping right? I'd say for (i = 4; i &gt;0; i--) /*you can use i-- to replace i=i-1 I believe*/ right?
You are correct about i--. Instead of i = 4 though, what would you replace 4 with to make it work for whatever you inputted? Once you get that, you can sum and do the factorial for any inputted number fairly simply.
There's also the if loop, which I find is about 90% of my loop usage.
Dude nice! That's totally correct, I'm impressed! So now we just need to expand it a little bit. Lets stick with what you have for now and pretend the summation we want to calculate is 20 (Just like you got above). Each loop, the variable `i` is going to go from 20, to 19, to 18... and so on, right? Looks just like our summation. The trick is, now we just have to add them all together. Any ideas on how to do this?
I can't tell if you're being sarcastic, are talking about while(true) { if(boolean){ break; } } , or are talking about loop: // Code stuff if(boolean)[ goto loop; } 
Well, when I compile and run the program i-1 turns into the whole countdown. I'm not sure how I could take all the output and add them together though.
I didn't mean to come off as sarcastic whatsoever. I'm sorry about that, but in my class we learned about the first one you put up there using boolean.
The idea is to create another variable, and then you add the value of `i` to the variable each iteration. If I were to do it in a really stupid way, it'd look something like this: int value; value = value + 20; value = value + 19; //... value = value + 1; How do we do this better with the loop?
&gt;I don't think you can do i = %i and do a scanf Who says you can't? Set-up a simple for loop such as this: int i = 0; for(scanf("%i", &amp;i); i != 0; /*empty*/) { ; } Type in 0 and watch it break. Now note it's better to have the scanf outside, but it works inside the for loop as the first part is the initializer. Basically the for loop looks like this: for(INITIALIZER; CONDITION; STEP) So for your initializer, you set your previously declared i to whatever you type in. However the initializer is **only done once at the start of the for loop** so you will not be asked to input anything again in this dumb loop I gave you. But the point is think about what you could do if you, say, input 4 in the scanf, and then changed the loop around that.
would I say something like: int value; value = value-- by the way it how do you make the code come up like that? Whenever I hit enter it just decides to keep it all on one line on reddit.
Put a minimum of 4 spaces in front of each line to get it to show up properly. And not quite on that one. Remember, we want to know what we get when we add up all the numbers, right? So we want to know what 20+19+18+...+1 evaluates to. We already have a number that decreases like we want it to in our loop: Each iteration, `i` will first be 20, then the next loop it'll be 19, and so on. We have our variable `value`, how do we use it?
Oh, I got it to do a full countdown from 4 saying: 3 is 4, 2 is 3, 1 is 2, 0 is 1.
Well it seems like another countdown for (scanf("%i", &amp;i); i != 0;) { printf ("%i is %i\n", i, i--); } I figured out how to use whatever number I want though? I tested out 4, 16 and a few others 
what is the control string for double type data?
For now just focus on getting 4 to sum and factorial using a loop. Basically just get it working on one number, then make it work on whatever number of input. But you are definitely on the right track on the idea of using multiple loops. currentNum = 4; for(i = currentNum; i != 0; i--) { //sum and factorial } I will say I'm surprised a beginner course would start with C and factorials and overflow as those can be some heavy concepts early on due to the amount of knowledge involved.
That's good, and it's better than your original one since it now takes user input. What about actually obtaining the summation result? Any ideas?
Would you do this? int variable = i, i--;
Odd, usually most people teach Java first as it's close enough to C that the move to it isn't painful until you get to the solely C concepts such as a lot of the memory business. Anyway, if you're summing up that sequence, how would you keep track? The answer is in what you first posted [here](http://pastebin.com/UVLrpD7s).
would I create a new int that would take what I got from my answer. Like this? int variable = i, i-- 
Well think of it like you have 4 and your countdown. As you counted down, how would you save the number you just got to, i.e. save 4 somewhere. And then once you got to a new number, what would you do? Think about how you would sum things by hand in a calculator. I'm going to sleep but since you posted that you got a countdown, I know you can do this. Write down the sum sequence in a comment in the file and make the loop do that. Then factorial is just changing the sign.
Alright, thank you. You've been awesome. I'll try my best :)
 for (i = 1; i &lt;= inputNumber; i++)
That's your loop, yeah, but we need the summation part of it. Nothing in there gets you the final result of the summation.
Am I trying to get the final result of (say I input 4) 1+2+3+4 in this step?
Yep, that's right.
I'm completely lost then :(
so if I put in 4, would it be something like this? value =4; value = value+1; /*or value++*/ 
Not quite. We need the summation of every number leading up to four. If you were to write out each iteration, it'd look like this: int value = 0; value = value + 4; value = value + 3; value = value + 2; value = value + 1; And the idea is that a loop simplifies the tedious process of writing out each of these. Any ideas?
I'm sorry, no :(
Hmm. What part isn't making sense?
I don't know how to simplify this using a loop int value = 0; value = value + 4; value = value + 3; value = value + 2; value = value + 1; 
Okay, here's what we have so far (Pretend `n` is the number the user gives us): int value; //We want the final summation value in here at the end of the loop int i; // Our increment variable for(i = n; i &gt; 0; i--) { /* What goes here? */ } Any guesses as to what goes inside the brackets? Remember, we want to add up all the numbers to get the summation.
printf ("%i is %i\n", i, i--);
No, not at all 
I don't know how long you plan on staying on reddit friend, but if you ever plan on getting off I would appreciate the code if you wouldn't mind. I just feel so defeated right now.
Sorry, I don't do people's homework assignments for them. I think you need to do some serious review of everything you've learned so far, there are some basic concepts you don't understand yet.
Alright, I'm just going to go to bed then. But seriously thank you for all your help.
So if I check the return value of scanf - will that clear the buffer as well? 
Okay. Thanks buddy :)
&gt; If you want the second scanf to not see the erroneous input, call `fflush in between, that will clear stdin's buffer. Please don't give this advice. `fflush()` is *only* designed for use with output streams. Calling it on an input stream is undefined behavior. C99 &amp;sect;7.19.5.2/2: &gt; If **stream** points to an output stream or an update stream in which the most recent &gt; operation was not input, the fflush function causes any unwritten data for that stream &gt; to be delivered to the host environment to be written to the file; otherwise, the behavior is &gt; undefined. Some platforms may support passing an input stream, but it's not a good idea to rely on that.
`atoi` operates on strings, not characters, so you need to build a string from the character first.
Oops, you are right. But please, when saying "don't do that because it's bad", also give an alternative if possible. Like [this one](http://c-faq.com/stdio/stdinflush2.html): while((c = getchar()) != '\n' &amp;&amp; c != EOF)
My alternative would be that whenever writing code that will deal with interactive input, always use `fgets()`. This eliminates the need to drain any buffers. You can then use `sscanf()` to further process the line. 
Care to elaborate? :)
 char line[1024]; ... fgets(line, sizeof(line), stdin); if(sscanf(line, "%ix%i", &amp;yardL , &amp;yardB)) != 2) { // invalid input } 
not really no.
It's needlessly complex and error prone. See [The Good, the Bad, and the Ugly: The Unix Legacy](http://herpolhode.com/rob/ugly.pdf ) by Rob Pike.
/r/titlegore
Yup.
Generally, it's a super stupid idea to give your library the same name as a system library on a common operating systems (i.e. `-lsocket` on Solaris). Build scripts might test if a library linkable with `-lsocket` exists and throw it into the linker invocation when compiling network software without checking if it is the right library. Please do research on what names are taken before developing a library.
Got it. Will keep in mind. 
Some more thorough reading needed. Will go through it. Thanks.
Will do. New to the community. Still trying to figure out the functionality and usage.
No, I'm serious. I am a beginner tho so maybe that's why? is it bad practice to use if loops so much?
With that title I was expecting a portable implementation resembling the [`dial(2)`](http://man.cat-v.org/plan_9/2/dial) interface...
Thanks. I'll try to make it work. 
It is bad practice to use anything that makes it hard to read. But it is also bad practice to make something that results in inefficient code (speed, memory, i/o's, any potential bottleneck). Pick one of the two as they are very often mutually exclusive. What is bad practice is up to your employer, most of the time, unless it's up to you. Just for the love of Code, stay consistent in the same project!
&gt; It's needlessly complex and error prone. That is what I'm thinking of the BSD sockets API and why I started this little project. Can you explain further why you think that of the library? I'm always open to suggestions and constructive criticism.
The point is not that it won't work on Solaris. The point is that many configure scripts check if a libsocket exists on the system they are running on and try to use this library for socket stuff if it does. They don't check if it's the "real" libsocket, they just asume that nobody would be stupid enough to call their own library after a system library. Do you really want to make compilation of software that compiled before fail on systems that have your library just because you dislike Solaris?
Uhh... there are three hard things in computer science: Naming things and off-by-one errors... Here is a list of suggestions: * libqdsocket (quick-and-dirty sockets) * libssock (simple sockets) * libquicksocket (quick sockets) * libesel (easy socket enabling library, esel is German for donkey) * libsocketer While you are at it, you might want to change the symbols your library exports to have a common prefix so name collisions are less likely—remember, there are no name spaces in C. For instance, if your library is called `libesel`, use names like `esel_unix_stream_socket_create`. Also, do not use argument names in header files. People might use the name you use for the argument for a different purpose (e.g. a macro or type name), which might render your header files unusable. You can do something like this: extern int create_unix_stream_socket(const char* /* path */, int /* flags */);
It's not being sent to the system per se, you're building a byte array, setting up a function pointer, and executing it.
You need to declare your function before you call it. 
As someone who has never used C what does that mean/entail?
Putting the function above main would do it. (Although in the special case of ints you get away with it.) More troubling is the scribbling over the end of remainder in line three of division(). Even in Java, I think foo[20] is invalid for an array of length 20.
There is nothing wrong with passing the values the way you're passing integers in right now. $ gcc x.c x.c:9: warning: conflicting types for ‘division’ x.c:5: note: previous implicit declaration of ‘division’ was here $ ./a.out 85 in Base 4 is 1111 The compiler has made some assumptions about the function prototype here, which works, but is trying to tell you that that's bad, you should be explicit about your prototypes. try adding this line before main(): void division(int, int); this will tell the compiler that the function exist and what arguments it should take (in this case, two integers). Alternatively, you could just move your function above main.
Thank you! That worked.
Yeah the program is dirty but it works. Now I'm going back and cleaning it and making it proper.
Please note I haven't actually improved any of your code, [I just fixed the spacing because it annoyed me](http://pastebin.com/cvWQg1hw) (although I guess I did add the prototype as well...). --- It's recommended you follow the [Linux Kernel Coding Style](https://www.kernel.org/doc/Documentation/CodingStyle), although feel free to use your own style, as long as you're _consistent_ with it.
1. Building with gcc, I get an error (plus warnings related to gets() being deprecated) 2. Even better, build with gcc -Wall. You will get other helpful warnings (such as unused variables etc,.) 3. On the segfault: You don't check at the start of get_entries() whether parts pointer is null. If it is null, you will get a segfault 4. I am getting another segfault ;) To hunt for them easily, ou can do: &gt; $ gcc -g foo.c -o foo &gt; (gdb) run &gt; /* Once you get the segfault, get a backtrace */ &gt; (gdb) bt &gt; $ gdb -q foo 
I guess because `*data` is a pointer to a union that you don't initialize anywhere. Your current `malloc (sizeof(struct node))` only allocates enough for the pointer ...? 
Check if that pointer is null?
Ah yes that was it!
Just for future self-help, imagine that the C compiler can only read your code in one pass through the text. (I’ve never met a compiler where this is true, but pretend.) This means that any information the compiler can pick up with regards to variables and functions must have been given to it via a declaration or definition before you make reference to them, or else it’ll either guess wildly (what it did with `division`) and generate potentially wrong code, or throw an error outright. Java doesn’t work that way at all, of course—anything can reference anything else in any order and the compiler won’t care. But in C, you can actually use the declaration-vs.-definition mechanisms to very effectively manipulate what can be seen by outside programs and libraries (e.g., to lock down an API). Also, *always* return a value from any function that doesn’t return `void`, or else the caller will see whatever garbage value happens to be left over in the accumulator register(s). In the case of `main`, return 0 if you haven’t encountered an error. (The program that runs your program, which is usually a shell of some sort, can see this exit code and make decisions about what to do next based on whether the exit code indicates success or not.)
Valgrind is your best friend with these types of errors - it will show you right where you're illegally accessing memory. 
Hey, please don't use `gets()`. This function is super insecure and will make your program vulnerable regardless of how you use it. For an excercise like this it should be fine though, just remember to not use it in real code.
If loops (the first one) are fine, it comes out to the same assembly, with a little less optimization. I'd suggest `while(boolean)` instead, though. Easier to read. You really don't need to be sorry. I come from a land of sarcasm known as polandball, and therefore I think everything is sarcastic unless it is obviously not. Edit: Also, just for future reference, that would be a "`while` loop with `if` condition checking". Edit1: Meant to reply to /u/anonagent. Sohry!
fyi: Though it may feel like overkill, it's a good idea to make a "make_xyz" or "xyz_constructor" function for each struct you make that initialises it, even if it's simply doing a memset(0) or something.
I was also talking about the BSD sockets.
It's good to exercise with the same habits you would use in real code. This makes you less likely to slip up when you are actually writing real code.
Yeah the linker keeps warning me about it pretty harshly. Would fgets (stdin, etc) work?
Functions like `gets` are never fine. Other than that, well said. 
I usually go with 4 different functions for each bigger structure; *foo_alloc()* to allocate and initialize all members(and submembers) of a foo. *foo_free()* to free/uninitialize all members(and submembers) of a foo. Both of those take one argument (foo*) which is a pointer to the foo instance to work on. These are to be used on stack instances and where you want more control. *foo_new()* to allocate a pointer to foo and also call foo_alloc on them automatically. Returns said pointer. *foo_delete()* to free both a foo pointer as well as it contents (using foo_free()). foo_delete takes one argument (pointer to foo again to work on), foo_new returns a pointer to the created data. foo_new() and foo_alloc() can be made more useful to take more struct-related arguments.These last two are to be used on heap instances and for most usage. Only use new/delete in conjuction and alloc/free in conjunction, or suit yourself. Example heap usage: foo* myheapfoo = foo_new(); ASSERT_NOTNULL(myheapfoo); /* Do stuff to myheapfoo */ foo_delete(myheapfoo); Example stack usage: foo mystackfoo; ASSERT_TRUE( foo_alloc(&amp;mystackfoo) ); /* Do stuff to mystackfoo */ foo_free(&amp;mystackfoo); 
Yes. The reason is that [fgets](http://pubs.opengroup.org/onlinepubs/009695399/functions/fgets.html) imposes a size restriction (the second parameter) on how much data is read meaning that you can (and should) set that value to the size of the buffer you are reading into. `gets` will read indefinitely until a `'\n'` or EOF is read making it trivial to overflow buffers.
Consider how you might reduce the amount of code/variables/complexity required if you were to use a pair of nested for-loops instead of a single while-loop. Also, for swapping a variable, it's really not necessary to use two temporaries. For example: one = values[c]; values[c] = values[cc]; values[cc] = one;
#include &lt;stdbool.h&gt; Then you can declare "sorted" as a bool, and use true and false instead of 1 and 0 You don't need one and two, just a swap. Instead of one = values[c]; two = values[cc]; values[c] = two; values[cc] = one; you can have swap = values[c]; values[c] = values[cc]; values[cc] = swap; 
Can you give an example of what you call an "if loop"?
Interesting. We haven't learned about stdbool.h yet, so I didn't know about it. Thank you. I'll look this up for more info. I also changed swaps to a bool. It's really only kept track of to see if I swapped anything that run through. So it being true or false is fine. Also makes things a little easier to read imo.
Yeah...I kind of didn't catch that I guess. I derped and didn't even use the one/two at first, and just had the values...then realized that, hey...It won't work like that. Lol. Going to go look and see if I can find what you're talking about with the nested for loops.
What exactly is going on in this code? I'm sure it makes sense, but I'm very inexperienced with C, and it doesn't make much sense to me! If anyone could explain, I would be really grateful!
 if (i = 0; i &lt; Something; i++) { return Something + SomethingElse; }
&gt; Then you can declare "sorted" as a bool, You don't actually even need to declare "sorted" as a bool and compare it to true/false to use it effectively as a boolean. Without a comparison value, pointers evaluate to logically true if they are not NULL, and false if they are. Non-pointers evaluate to logically true if they are non-zero, and false if they are zero. So: while (!sorted) // This is the same as while (sorted == 0) or if (swaps) // evaluates to true if swaps is any non-zero value.
That's... Not valid code. 
The purpose of the code is to take a number in base 10 and convert it into base x where x is whatever base is set as. It does this by dividing the value by the base and then dividing that quotient by the base and so on until it's 0. It stores all the remainders in an array in backwards order which results in the new converted value in base x.
My code is also very sloppy at this a point and has some unnecessary parts.
Agreed. In general if you are going to branch on a boolean somewhere else... move the branch to where you create the boolean, or move the boolean expression to where you branch. 
Do your own homework. 
Sorry :P I hadn't read the link when I wrote thad comment.
If this is programming homework, I urge you to open your terminal (or IDE) and play around with the language, it's the best way to learn by far. that being said. **I** - Yes, booleans in C can be thought of as integers, where FALSE = 0, and TRUE = 1 (or any other integer that is not 0). so the expression (3 &lt; a &lt; 10) is really, ((3 &lt; a) &lt; 10), since we can only do one comparison at a time. since (3 &lt; a) it becomes ((1) &lt; 10), and since 1 &lt; 10, it becomes (1), which is equivalent to true. The correct way to check bonds would be if (3 &lt; a &amp;&amp; a &lt; 10) **II** - yes, a = 5, is an assignment, and if that assignment was successful it will evaluate to true. The correct way would be a == 5 **III** - placing in the appropriate swirly braces it becomes clear why. if (a &gt; 3) { if (b &lt; 5) { printf("A"); } } else { printf("B"); } printf("C"); If you omit the swirly braces, the compiler will try and guess where they are. It will place the '{' as soon as it can, and the '}' as soon as it can. While you are still learning i would suggest always including the swirly braces. **IV** - the semicolon ends the statement so.. if (a &lt; 8); is equivalent to if (a &lt; 8) { ; //do nothing } 
I do need a power function because the Divison requires various powers of 10 and the return value must be integer to keep the output integer otherwise the library function returns double type data which will distort the output.
Recently I found ASan to be an even better friend :) 
Yeah, it was an example...
atoi() is not safe, and is not relevant to the question considering it is only useful for converting base-10 integers, unlike strtoi or strtol. atoi() produces undefined behavior if the function fails, while strtol() or strtoi() return 0 and set errno to the appropriate value.
So when you say if loop do you mean for loop?
No. The program should need at most one variable (int n) and at most 3 lines of code to loop and print out n. My guess is that this assignment was to teach you about how C (and many other languages) handle integer division.
Yes, I'm terrible about doing that so far. I go into a new file called 'testing' to work out things like this, it helps me concentrate better for some reason...and then I just make short and simple variables, and I sometimes myself get confused as to what I put them there for originally. I did end up changing some of the variable names. I posted a new version in a comment reply to someone else. Also, thank you for the c++ thing. I should have thought of that, I learned it...just forgot and have only used it in for loops. Definitely a lot shorter and easier than what I was doing.
Everyone has to start somewhere! I remember wishing I could get feedback from people when I started.
You need to do: printf("%d", my_numb) or: printf("%f", (double)my_numb)
You are lying to `printf()` and not upholding its contract. Using `%f` in a format string means that the corresponding argument will be a `double` (or a `float`, since they are promoted to `double` for vararg functions), but you're passing an `int`. The function has no idea that you did that, nor is there any way that it could know. It can only assume that you didn't lie to it, and try to interpret what you passed as a `double`. Since you didn't do that, you invoke undefined behavior and anything can happen. You can have no expectations of a working program at that point. 
Poor `printf()`, always so gullible. Be nice and don't lie to it.
I am still not getting your point. I am done with the problem...it worked. I can post the code so that you can point out what has to be rectified? Just a suggestion...I totally understood what you said about posting the code(s).
Allways compile with enabled warnings (-Wall flag). That will warn you if you have errors in your printf formatting.
Now that makes a lot of sense. Thank you!
I know that using %f for an int isn't right. But I happened to do it by mistake and I was wondering why it is zero, not the number itself as a float. :-)
It is the way floating points are interpreted. You can have a look at the [definition of a floating point](https://en.wikipedia.org/wiki/Single-precision_floating-point_format#IEEE_754_single-precision_binary_floating-point_format:_binary32). If you represent 25 in binary you will get 0 00000000 00000000000000000011001 Here you see that the exponent is all 0. Which means you will be calculating a small number multiplied by 2^(0 - 127) = 2^-127 which is basically 0. Change my_numb to something big like 1000000000 (or 2000000000) and you will get an actual number because for 1000000000 in binary you get 0 01110111 00110101100101000000000 Here the exponent is 119, so you will multiply by 2^(119 - 127) = 2^-8 which is not that small anymore and you will get a float of 0.004724. For 2000000000 the exponent will be bigger and you will be multiplying by 2^111 and get a huge number
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 1. [**IEEE 754 single-precision binary floating-point format: binary32**](https://en.wikipedia.org/wiki/Single-precision_floating-point_format#IEEE_754_single-precision_binary_floating-point_format:_binary32) of article [**Single-precision floating-point format**](https://en.wikipedia.org/wiki/Single-precision%20floating-point%20format): [](#sfw) --- &gt; &gt; &gt; &gt; &gt; &gt;The IEEE 754 standard specifies a __binary32__ as having: &gt; &gt;* [Sign bit](https://en.wikipedia.org/wiki/Sign_bit): 1 bit &gt;* [Exponent](https://en.wikipedia.org/wiki/Exponent) width: 8 bits &gt;* [Significand](https://en.wikipedia.org/wiki/Significand) [precision](https://en.wikipedia.org/wiki/Precision_(arithmetic\)): 24 bits (23 explicitly stored) &gt;This gives from 6 to 9 significant decimal digits precision (if a decimal string with at most 6 significant decimal is converted to IEEE 754 single precision and then converted back to the same number of significant decimal, then the final string should match the original; and if an IEEE 754 single precision is converted to a decimal string with at least 9 significant decimal and then converted back to single, then the final number must match the original ). &gt;Sign bit determines the sign of the number, which is the sign of the significand as well. Exponent is either an 8 bit signed integer from −128 to 127 (2's Complement) or an 8 bit unsigned integer from 0 to 255 which is the accepted biased form in IEEE 754 binary32 definition. If the unsigned integer format is used, the exponent value used in the arithmetic is the exponent shifted by a bias – for the IEEE 754 binary32 case, an exponent value of 127 represents the actual zero (i.e. for 2^e − 127 to be one, e must be 127). &gt;The true significand includes 23 fraction bits to the right of the binary point and an implicit leading bit (to the left of the binary point) with value 1 unless the exponent is stored with all zeros. Thus only 23 fraction bits of the [significand](https://en.wikipedia.org/wiki/Significand) appear in the memory format but the total precision is 24 bits (equivalent to log10(2^24) ≈ 7.225 decimal digits). The bits are laid out as follows: &gt;[](https://en.wikipedia.org/wiki/File:Float_example.svg) &gt;The real value assumed by a given 32 bit __binary32__ data with a given biased exponent __e__ (the 8 bit unsigned integer) and a __23 bit fraction__ is where more precisely we have . &gt;In this example: &gt; &gt;* &gt;* &gt;* &gt;thus: &gt; &gt;* &gt;The single-precision binary floating-point exponent is encoded using an [offset-binary](https://en.wikipedia.org/wiki/Offset-binary) representation, with the zero offset being 127; also known as exponent bias in the IEEE 754 standard. &gt; &gt;* Emin = 01H−7FH = −126 &gt;* Emax = FEH−7FH = 127 &gt;* [Exponent bias](https://en.wikipedia.org/wiki/Exponent_bias) = 7FH = 127 &gt;Thus, in order to get the true exponent as defined by the offset binary representation, the offset of 127 has to be subtracted from the stored exponent. &gt;The stored exponents 00H and FFH are interpreted specially. &gt;The minimum positive (denormal) value is 2^−149 ≈ 1.4 × 10^−45. The minimum positive normal value is 2^−126 ≈ 1.18 × 10^−38. The maximum representable value is (2−2^−23) × 2^127 ≈ 3.4 × 10^38. &gt;In general refer to the IEEE 754 standard itself for the strict conversion (including the rounding behaviour) of a real number into its equivalent binary32 format. &gt;Here we can show how to convert a base 10 real number into an IEEE 754 binary32 format using the following outline: &gt; &gt;* consider a real number with an integer and a fraction part such as 12.375 &gt;* convert and [normalize](https://en.wikipedia.org/wiki/Normalized_number) the integer part into [binary](https://en.wikipedia.org/wiki/Binary_numeral_system) &gt;* convert the fraction part using the following technique as shown here &gt;* add the two results and adjust them to produce a proper final conversion &gt;__Conversion of the fractional part:__ &gt;consider 0.375, the fractional part of 12.375. To convert it into a binary fraction, multiply the fraction by 2, take the integer part and re-multiply new fraction by 2 until a fraction of zero is found or until the precision limit is reached which is 23 fraction digits for IEEE 754 binary32 format. &gt;0.375 x 2 = 0.750 = 0 + 0.750 =&gt; b−1 = 0, the integer part represents the binary fraction digit. Re-multiply 0.750 by 2 to proceed &gt;0.750 x 2 = 1.500 = 1 + 0.500 =&gt; b−2 = 1 &gt;0.500 x 2 = 1.000 = 1 + 0.000 =&gt; b−3 = 1, fraction = 0.000, terminate &gt;We see that (0.375)10 can be exactly represented in binary as (0.011)2. Not all decimal fractions can be represented in a finite digit binary fraction. For example decimal 0.1 cannot be represented in binary exactly. So it is only approximated. &gt;Therefore (12.375)10 = (12)10 + (0.375)10 = (1100)2 + (0.011)2 = (1100.011)2 &gt;Also IEEE 754 binary32 format requires that you represent real values in format, (see [Normalized number](https://en.wikipedia.org/wiki/Normalized_number), [Denormalized number](https://en.wikipedia.org/wiki/Denormalized_number)) so that 1100.011 is shifted to the right by 3 digits to become &gt;Finally we can see that: &gt;From which we deduce: &gt; &gt;* The exponent is 3 (and in the biased form it is therefore 130 = 1000 0010) &gt;* The fraction is 100011 (looking to the right of the binary point) &gt;From these we can form the resulting 32 bit IEEE 754 binary32 format representation of 12.375 as: 0-10000010-10001100000000000000000 = 41460000H &gt;__Note:__ consider converting 68.123 into IEEE 754 binary32 format: Using the above procedure you expect to get 42883EF9H with the last 4 bits being 1001 However due to the default rounding behaviour of IEEE 754 format what you get is 42883EFAH whose last 4 bits are 1010 . &gt;__Ex 1:__ Consider decimal 1 We can see that: &gt;From which we deduce: &gt; &gt;* The exponent is 0 (and in the biased form it is therefore 127 = 0111 1111 ) &gt;* The fraction is 0 (looking to the right of the binary point in 1.0 is all 0 = 000...0) &gt;From these we can form the resulting 32 bit IEEE 754 binary32 format representation of real number 1 as: 0-01111111-00000000000000000000000 = 3f800000H &gt;__Ex 2:__ Consider a value 0.25 . We can see that: &gt;From which we deduce: &gt; &gt;* The exponent is −2 (and in the biased form it is 127+(−2)= 125 = 0111 1101 ) &gt;* The fraction is 0 (looking to the right of binary point in 1.0 is all zeros) &gt;From these we can form the resulting 32 bit IEEE 754 binary32 format representation of real number 0.25 as: 0-01111101-00000000000000000000000 = 3e800000H &gt;__Ex 3:__ Consider a value of 0.375 . We saw that &gt;Hence after determining a representation of 0.375 as we can proceed as above: &gt; &gt;* The exponent is −2 (and in the biased form it is 127+(−2)= 125 = 0111 1101 ) &gt;* The fraction is 1 (looking to the right of binary point in 1.1 is a single 1 = x1) &gt;From these we can form the resulting 32 bit IEEE 754 binary32 format representation of real number 0.375 as: 0-01111101-10000000000000000000000 = 3ec00000H &gt;These examples are given in bit *representation*, in [hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal), of the floating-point value. This includes the sign, (biased) exponent, and significand. &gt;By default, 1/3 rounds up, instead of down like [double precision](https://en.wikipedia.org/wiki/Double_precision), because of the even number of bits in the significand. So the bits beyond the rounding point are 1010... which is more than 1/2 of a [unit in the last place](https://en.wikipedia.org/wiki/Unit_in_the_last_place). &gt;We start with the hexadecimal representation of the value, 41c80000, in this example, and convert it to binary &gt;then we break it down into three parts; sign bit, exponent and significand. &gt;We then add the implicit 24th bit to the significand &gt;and decode the exponent value by subtracting 127 &gt;Each of the 24 bits of the significand (including the implicit 24th bit), bit 23 to bit 0, represents a value, starting at 1 and halves for each bit, as follows &gt;The significand in this example has three bits set, bit 23, bit 22 and bit 19. We can now decode the significand by adding the values represented by these bits. &gt;Then we need to multiply with the base, 2, to the power of the exponent to get the final result &gt;Thus &gt;This is equivalent to: &gt;where is the sign bit, is the exponent, and is the significand. &gt;A fascinating example of how the floating-point format can be misused in a good way is shown in the [Fast inverse square root](https://en.wikipedia.org/wiki/Fast_inverse_square_root) implementation, where the complex calculation of square root and inversion are replaced (approximately) by a bit-shift and subtraction operated on the 32-bits of the floating point encoding as if it were an integer. &gt; --- ^Interesting: [^Double-precision ^floating-point ^format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format) ^| [^Quadruple-precision ^floating-point ^format](https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format) ^| [^Floating ^point](https://en.wikipedia.org/wiki/Floating_point) ^| [^IBM ^Floating ^Point ^Architecture](https://en.wikipedia.org/wiki/IBM_Floating_Point_Architecture) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ckk1x72) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ckk1x72)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
What do you think the output of the following would be: int n = 5678; printf("%d\n", n); printf("%d\n", n / 10); printf("%d\n", n / 100); printf("%d\n", n / 1000);
This looks like you're trying to retro-fit your first attempt with a shiny new loop to make it look more modern :) Step back from your first attempt, and look at the problem fresh. You have an array of size N. You want to put the smallest number in the entire array into position 0. What steps do you take to ensure that the smallest number in the array is in position 0? After you've done that, what steps do you take to ensure the next smallest number is in position 1? Position 2? And so on.
Instead of describing what it does, write out what it would actually look like on the screen. Is this the output your assignment was looking for?
[OUTPUT](https://gist.github.com/anonymous/db98a43956c214dbb492)
&gt; Even better, **always** build **all code** with gcc -Wall. FTFY. (Yes, occasionally GCC will throw silly pedantic crap with -Wall. That's fine. As long as you fully understand why it's complaining, let it complain. But if you're not sure why it's complaining... then you're in trouble!)
Whoops, I realize now I went the wrong direction (Another reason to actually post code/input/output in your actual post/comments intead of just a link to a paste somewhere else). Let me start over: What do you think the output of the following would be: int n = 5678; printf("%d\n", n); printf("%d\n", n % 1000); printf("%d\n", n % 100); printf("%d\n", n % 10); Write the output in your reply here. How does the output you write here compare to the sample output you gave in this original post?
Imho, you should always compile with `-Wall -Wextra -pedantic -Werror`.
It's because your factorial function returns 1*1 Think about where your ´return´ is
foo_alloc(), foo_free() are ambiguously named -- they don't actually allocate or free, only initialise? They're basically the constructor and destructor. (Though, they _could_ alloc something when initialising a member). 
But they do! They allocate the members and submembers (any pointers), and frees them too! Sorry if I didn't get that across. It's kind of their meaning, while new/delete does that but also allocates and frees the pointer itself! struct foo{ char* allocateme; }; foo myfoo; foo_alloc(&amp;myfoo); /* &lt;- Allocates allocateme and any other members */
My eyes hurt trying to read that. Here ya go! Oh, you're really close though. :D #include &lt;stdio.h&gt; int facNumbers(int); int main() { printf("What number would you like the factorial of?\n"); int facN; scanf("%d", &amp;facN); printf("%d! = %d\n", facN, facNumbers(facN)); return 0; } int facNumbers(int operand1) { int c; for(c = 1; c &lt;= operand1; c++){ int result = 1; result = (result * c); return result; } } 
Thanks for the help! I moved my return just out of the for loop and now everything seems to be in order.
Nope normally you should still have a problem with the ´result´ variable 
What functions are in math.h ?
We haven't went over math.h yet. Literally all we've done in class is #include stdio.h, and stdlib.h. I have no idea what that is :O Once again, sorry
Using pow/math.h is a bit advanced/overkill for this problem - just multiply the number by itself 2 times to get the cube: int cube = n * n * n;
Why do you even need additional dependency to calculte cube?
In what universe is `math.h` even close to necessary to find the cube of a number?
 #define cube(x) ((x)*(x)*(x))
 1 #include &lt;stdio.h&gt; 2 3 #define cube(x) ((x)*(x)*(x)) 4 5 int main(void){ 6 7 for (unsigned i = 5; i &lt; 16; ++i) 8 printf("%d\n", cube(i)); 9 10 return 0; 11 } gcc -std=c99 -W -Wall -Werror -o ctest ctest.c EDIT: thanks for the DV guys, to what do i owe this honor?
I think C would make a poor *scripting* language for a game: it's quite unsafe and too low level for the task.
Lua might make a good choice. It's small, fast, easy to sandbox and easy to interface to C, and a lot of existing games already use it. 
Do you even math, bro?
Okay just curious, what does the ++ mean? I haven't made it to it in the book yet, and I've seen that a lot. 
I think that, judging by the answers in this question, you're going to get a lot of philosophical answers discussing the computational accuracy, the cleanliness, and implementation of such a operation based on the nature of this subreddit... and perhaps if you're just looking for AN answer, you may want to check out /r/learnprogramming or one of the homework help subs or just google around a bit. Because, inevitably, you're going to ask a question and we're going to answer it with something your professor hasn't gone over yet which will either lead him to think something questionable is going on, or that you're out of your depth with might result in more difficult assignments. But it's fun to learn about all the philosophical stuff too :)
Well my professor said if we learn ahead and implement it, it's fine, just make notes explaining it. So I plan on just reading ahead to make it a bit easier
Unfortunately, a restricted libc gives you no protection as your "script" can just make [syscalls] (http://www.win.tue.nl/~aeb/linux/lk/lk-4.html) directly and so do anything the program it is in has permissions for. All you need under Linux is some inline assembler for the "int 0x80" instruction and some register moves. I don't know how windows works, but I imagine it is the same. The key point is that libc is not magical, its just utility functions and wrappers around syscalls, so hobbling it provides nothing more than cosmetic protection. Lua (suggested elsewhere in this thread) is a much better choice, as it is interpreted. You can whitelist exactly what functions a Lua script can call, and so [sandbox]( http://lua-users.org/wiki/SandBoxes) Lua programs.
This isn't necessarily a bad thing, as explained very well in this [stack overflow question]( http://programmers.stackexchange.com/a/206357) ; &gt; Lua claims that floating point numbers can represent integer numbers just as exactly as integer types can, and I'm inclined to agree. However, it is possible to customise Lua into using integers by default instead, which is quite common when used in embedded applications. The [Lua Manual] (http://www.lua.org/work/doc/manual.html#2.1)says: &gt; The type number uses two internal representations, one called integer and the other called float. Lua has explicit rules about when each representation is used, but it also converts between them automatically as needed (see §3.4.3). Therefore, the programmer has the option of mostly ignoring the difference between integers and floats or assuming complete control over the representation of each value. Standard Lua uses 64-bit integers and double-precision (64-bit) floats, but you can also compile Lua so that it uses 32-bit integers and/or single-precision (32-bit) floats. The option with 32 bits both for integers and floats (called *Small Lua*) is particularly attractive for small machines.
Please note that this is not the problem. The value that is printed is the current value in xmm0. This is the compiled code: mov DWORD PTR [rbp-4], 25 mov eax, DWORD PTR [rbp-4] mov esi, eax mov edi, OFFSET FLAT:.LC0 mov eax, 0 call printf If you look, it says "mov eax, 0", that is an upper bound of the xmm registers being used, that means that printf can assume that are xmm registers will be free, but then when it has to use them (because of the "%f" in the format) it will use an invalid value (because it may have overwritten it). If you change the code to look like this: mov DWORD PTR [rbp-4], 25 mov eax, DWORD PTR [rbp-4] mov esi, eax mov edi, OFFSET FLAT:.LC0 cvtsi2sd xmm0, rax mov eax, 1 call printf You will get the correct behavior (telling printf that it should expect ONE xmm register, and converting xmm to the value you want (25))
omg dude I just saw your inception pictures and had to say something. I'm 4 years late, but fuckin something!
You might want to try sketching a state machine on paper, then writing some really rough pseudocode/documentation in a text editor describing what sections of code should do, THEN go fill it in with code. Do you know what a state machine is? http://blog.markshead.com/869/state-machines-computer-science/ I'm in a C class right now in university and that was helpful for me. 
Oh, also I lied. I played with it some more. I didn't realize that there was a baremetal malloc like that! Pretty cool. Usually I've just statically allocated a crap ton of memory and just used it as my personal memory pool. I think you've complicated your task a bit, unless you're supposed to create your own string comparator and such... You should check out some reference pages on the [string library](http://www.cplusplus.com/reference/string/string/?kw=string) or just use F3 in the SDK to go to the actual declaration of string.h. I use that shortcut all the time to dig deeper into the code. It can lead you to functions in libraries, MACROS, and all sorts of cool stuff. Also, you should check out [scanf under stdio.h](http://linux.die.net/man/3/scanf). Just remember that you're in baremetal so these implementations might be a little different since Xilinx is trying to save on code size. I found that the xil_printf didn't support all the features that printf on my x86_64 had. Good luck!
Practically impossible, yet one of the BSDs does it, iirc. I don't remember which one (I'm pretty certain it's NetBSD), but it's something to aspire to. And, as a beginner not working on huge code bases, they should being using `-Werror`. There's no reason not to.
What does "location" mean in this context ? You have 2 function calls to myfunction(). And you probably have defined myfunction() itself somewhere. You want one of them to not call myfunction() but some other function ? In any case, this would be compiler specific - so, which compiler are you using ? 
IDK what you are talking about. The linker sets the addresses; if you want to manually specify the address for a particular symbol then you're going to have to do it by editing the linker script. If you just want to redirect all calls to one function to another function, you can use *weak symbols* and link in the strong symbols when you choose.
What you could do is #define'ing `myfunction()` in the header file to a different name, depending on where you want it to end up: #ifdef CONDITION_FOO # define myfunction myfunction_foo #elseif defined(CONDITION_BAR) # define myfunction myfunction_bar #else # define myfunction myfunction_generic #endif Apart from that, you could try to do some trickery with linker scripts but this is generally not portable and might stop working if you expand your program in unforeseen ways.
Cant you define a macro? Like #ifdef BUILD_VER40 #define FOOFUNC function_40 #else #define FOOFUNC function_fallback #endif EDIT: Removed arguments as FUZxxl suggested. 
I completely agree, I haven't done a lot of macro aliasing for functions before, so I didn't even think about this being possible. It's quite obvious though. 
5678 678 78 8
yes,the output is the same but I was looking for a more generalised form. As you can see that first we have to do n%x where x=10^n , n=number of digits after printing each step. I have also tried the positional weight method.
You might be able to do #pragma section code address=0x1234567 int myfunction(int bar); Though it's for placing the implementation of a function in a certain address, I havn't tried if it actually creates a symbol just from a prototype - so that probably won't work, Other alternatives are to use the linker flag - R=myfunction=myotherfunction To rename the myfunction symbol to whatever you've called the alternative function in your linker map. Of you'd just use the preprocessor to rename the use of myfunction to your alternative implementation. #ifdef USE_MYOTHERFUNCTION #define myfunction(x) myotherfunction(x) int myotherfunction(int bar); #else int myfunction(int bar); #endif You still need a liker map to set up the location of myotherfunction in both these cases.
Here is another example of how it runs: http://imgur.com/Y2nDQ5N this time, it sorted the first 4 words, but left out the last one. sometimes it returns no words at all.
Afaik no toolcahin i have used could do exactly what you want. There are things like weak functions and aliases, so maybe you can somehow use those but I don't really see how. Also pragmas are very toolchain specific, so you should at least mention which one are you using. What are you really trying to do? I can't think of a real usecase for this. Also, i 
At line 30 you allocate memory to store n pointers to strings. But nowhere do you allocate memory for the actual strings itself (array[i] = malloc(...)). The size that you allocate can be either 'big enough', or you can realloc byte per byte ([example](https://pay.reddit.com/r/C_Programming/comments/2gml9o/c_word_sorting_program_for_fpga_board_issues/)). Also: don't forget to allocate and write the NULL byte to terminate the c string. PS: When you hardcode the strings "this" and "that", you don't need to do this as these strings are already in memory as part of the binary. That is why it works in that case.
The correct way to do it is via linker scripts. To give a real world example, consider the case where you want a fast function to be placed in onchip SRAM and not DDR. In such a case, you want the function symbol to be in its own section and that section is placed in SRAM.
I assume for writing it out? Not sure.. Just curious, what does the gcc -std=c99 -w wall ect. mean? 
They were sent to this grasshoppa as guidance from the mastah
for one, on assignment the entire right hand side (RHS) is executed before any of the LHS. so: num = num*num*num makes perfect sense. it says take three copies of the current value of num multiply them and then put the result in num. for your other question i would just check the value before you do the calculation. you should also check if scanf succeeded. hint, most functions in c return some useful info when they return. you should almost always catch and inspect what comes back, for excample: int res = scanf("%d", &amp;num); shoudl give you a clue about what happened in the scan. then assuming what you want to happen did, you can just check to see if the number is in the range you are expecting, or print a "sorry, error" message if it's not
Thanks a lot! Not sure if you saw the most recent edit, but I think I got it pretty solidly. ;) thanks for the help
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Seccomp**](https://en.wikipedia.org/wiki/Seccomp): [](#sfw) --- &gt;__seccomp__ (short for __secure computing mode__) is a simple but solid secure-computing facility ([sandboxing](https://en.wikipedia.org/wiki/Sandbox_(computer_security\)) mechanism) for the [Linux kernel](https://en.wikipedia.org/wiki/Linux_kernel). It was added to version 2.6.12 of the [Linux kernel mainline](https://en.wikipedia.org/wiki/Linux_kernel_mainline) on March 8, 2005. It allows a [process](https://en.wikipedia.org/wiki/Process_(computing\)) to make a one-way transition into a "secure" state where it cannot make any [system calls](https://en.wikipedia.org/wiki/System_call) except exit(), sigreturn(), read() and write() to already-open [file descriptors](https://en.wikipedia.org/wiki/File_descriptor). Should it attempt any other system calls, the kernel will terminate the process with [SIGKILL](https://en.wikipedia.org/wiki/SIGKILL). In this sense, it does not [virtualize](https://en.wikipedia.org/wiki/Virtual_machine) the system's resources but isolates the process from them entirely. &gt; --- ^Interesting: [^Sandbox ^\(computer ^security)](https://en.wikipedia.org/wiki/Sandbox_\(computer_security\)) ^| [^Google ^Chrome](https://en.wikipedia.org/wiki/Google_Chrome) ^| [^Time ^Stamp ^Counter](https://en.wikipedia.org/wiki/Time_Stamp_Counter) ^| [^Comparison ^of ^operating ^system ^kernels](https://en.wikipedia.org/wiki/Comparison_of_operating_system_kernels) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ckkzsns) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ckkzsns)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Alright learned something today. Not that familiar with floats or [ABI of x86-64](http://www.x86-64.org/documentation/abi.pdf) On 32bit my comment is still valid (where they mostly use stack instead of registers to pass parameters to functions). Except that I did not know that floats get promoted to doubles and you would need to pass an unsigned long long with value 0x40000000:00000000 to get a value of 2.000 printed (or you hack something like printf( "%f\n", int, int ) to get 8 bytes on stack).
Try looking at the Tiva C series example code from Texas Instruments. They store the peripheral driver library's binary file in a separate ROM area and then use linker script-generated addresses to call those functions. Really sweet code if you see their headers. 
C how to program seventh edition, halfway through chapter 3
Agreed.
You should try doing it on paper before coding. Some basic math to consider: How do you determine if a number is even or odd? How do you sum numbers? How do you average numbers? 
Don't even need the loop (though I suppose OP was told to use one).
𝕳𝖎𝖊𝖗 𝖌𝖎𝖇𝖙 𝖊𝖘 𝖊𝖎𝖓 𝖒𝖎𝖙 1 𝖑𝖔𝖔𝖕: while(0); printf("sum: %d, avg: %d", ((939*939 - 457*457)/4), (939+457)/2);
I wouldn't try to detect if a number is even or odd. Just pick only the even numbers.
Maybe put the functions into separate shared libraries, and then do a dlopen once you know which one you need? I suspect that fails your "cannot be a separate elf file" requirement though..
Carl Friederich, when did you learn C?
What do you mean where to get started? Have you done a C program prior to this? How complicated was it? Can you write a C program with a while loop? Have you done any programming prior to this? What is the part that gives you the most difficulty? The art of programming is all about breaking down the problem. Can you write a program that calculates the sum of consecutive numbers? Can you write a program that calculates the sum of consecutive EVEN numbers? How do you calculate the average of a set of numbers?
I have never used while loop and I'm confused how to use it. I have no idea how to calculate the average of a set of numbers
So have you done if statements before? A while loop is like an if statement but it keeps doing the true part of the if statement until it is no longer true. Try to construct a while loop that just prints the numbers from 457 to 939. Work from there to do the sum. Once you get the sum then only worry about the average.
You have to think of `if` as checking exactly one condition. You can't ask `if` to check multiple conditions, but you can combine conditions with `&amp;&amp;` (and) and `||` (or). Read up on formal logic to understand this. I would also highly highly reccomend that you post in /r/learnprogramming instead, as this subreddit is ideally for C-specific conversations and you're asking a very basic question. E: So reading through some other responses, if you still haven't grasped the concepts of if-else and while then you **NEED** to start reading your textbooks. These are some of the most fundamental constructs in programming and if you fall behind on these then you will not succeed. I may come across as harsh, but you *have* to understand these.
I think you want something like this, not 100% sure though. if(num &gt;=2 &amp;&amp; num &lt;=12) Basically if num is greater than two AND num is less than 12. &amp;&amp; is the logical AND operator.
Thank you! (I'm a new student, and couldn't find that anywhere :/) But it works perfectly now! Appreciate it!
It worked! Thanks! I'm writing another program using the while loop. I'm curious if you could explain how the while loop essentially works? (I need to find sum and average of the even numbers between 457 and 939). And also, I watched a video where he used total = 0, but total isn't recognized in visual studio for me. Would you know why? 
While is just gonna keep looping until it meets the set condition. while(i&lt;10) for example is gonna stay in the loop until i reaches 10 or higher. So if as the most basic of examples you ended your loop with i++ and started at i=0, it would loop 10 times. This can be used in much more creative ways though, once you get going with it ;)
Yeah i'm trying to figure it out.. This is what I have so far: int main(void) { int loopcount; int num1; int num2; int average; int sum; int total; loopcount = 0; total= 0; while(loopcount &lt; 939) { num1 = 457; num2 = 939; total = num1 + 2; loopcount = loopcount +2;} system("pause"); } I need to find the average and sum of all even numbers between 457 and 939. Extremely lost.
There is a huge amount of resource on the internet for this stuff. Thats basically how I learned all of it. But from a high level: while(condition ==true){ DoStuff(); DoStuff2(); DoStuff3(); } Basically, the while loop will "loop" until the condition evaluates to false. for example. int i =0; while(i&lt;10){ i++; //Increment i by 1. } This will loop until i is greater than 9. You should be able to take this and apply it to your problem. 
int i is just giving it a name right? It's nothing special? (Sorry only been using c for like a week now, still getting used to it).
So think about what you have here. When you start the loop loopcount ==0 First loop iteration yields: total = 1396 loopcount = 2 Second loop iteration yields: total = 1396 loopcount =4 Do you see whats wrong? Your not doing anything with your summation, 
So, if you ask me I'd use i=457 (I use i, cause that's how I was taught in school, you use loopcount, it doesn't make a difference what it's called), then use &lt;=939 to make sure you go through the whole cycle of numbers. Always check that your &lt;,&gt;,=,&lt;=,&gt;= get you the right number of cycles, it can be pretty bad if they don't! Though not in this particular example. Then use the number you're currently on in the operations you need. Example: total+=i; += means total=total+i; in case you weren't aware. for the sum you just need to save the total when you're done with the loop and divide it by the number of loops, so use int counter or something like that, set it to 0 before you start the loop, then add a counter++; line in the loop. If just throwing out some ideas isn't quite enough I could write it out for you, but I'd rather see you pull it off on your own!
Okay thanks! :D
You have the loop but there is nothing in it man, and when you are defining int total, why make it 457 + 2? Your stuff is all kinds of confusing! First off define total as 0, since it is 0 before you start adding stuff, then in your while loop, are you trying to stop it when your total is &lt;= 937 or when you have went through all the numbers from 457 to 937? Cause right now you're looking to stop the loop as soon as your added total is &gt; 937, which is like 2 steps in. If you want anything to add 2, make the part where you are adding 2 a step in the loop, right now you are adding 2 as you define it.
I'm confused what I do with the &lt;=. How do I know when to stop it? Do I do the actual math beforehand, and implement it in? Also, i'm not exactly sure how to add the 2 into the loop. This is what i'm at. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(void) { int num1 = 457; int total = 0; while ( num1 &lt;= 937) { total = num1 + 2; printf("%d\n", total); } system("pause"); }
Slowly increase the num1 in every step, your total is not the same as your current step. I pm'd you an example, similar thing but not for even numbers, so you're gonna have to grasp how it works and modify it. I gotta say though, that you're gonna have to do some studying up on the basics here to use them later, or like someone said above, you will fall behind. Be careful with this stuff, cause it starts off seeming really easy, but once it gets complex you need to have the basics down tight. I recommend you use the example I sent you and fuck around with it and make sure you know how and why it does what it does, ask any questions you have and I'll answer when I wake up in 7 hours. I was just about where you are 2 years ago, so just keep at it and you'll get it :)
Yeah I did, but it just came up in this one too. Sorry D:. I didn't wanna over crowd this subreddit :/
Is this homework? It feels like homework.
The latest version of Lua, 5.2, uses doubles for everything. It's Lua 5.3 (still in alpha) that has both doubles and integers (64 bit). 
That's one way to lose a customer with a market capitalization over $40B
why are you printing the address of gross_pay? Drop the ampersand on that line
Because I don't know what I'm doing and I don't know what it does. but that has fixed the problem, or at least *that* problem thank you.
You should post in /r/homeworkhelp. Or /r/learnprogramming.
That is a typo right?( using the assignment operator instead of the equivalence operator) #you need to use the equivalence operators of ==. Using assignment will just assign the value to a variable (if it can) and when the if statement pulls the value from the variable, any value greater than zero is considered true.
you're going to have to dumb down the terminology, I'm only two weeks into a beginners course with an *ok* teacher. The only problem I'm having with the output is trying to use tax bracket one, the last **else if** statement, it just doesn't use it for some reason. no typos, this is just copy and pasted from the compiler.
It needs to be two equal signs: else if (tax_bracket == 2) and else if (tax_bracket == 1)
Where you wrote `if (tax_bracket=2)` should be `if (tax_bracket == 2)` . Same thing with `1` just below. `==` means to compare, `=` means to assign. The effect of `if (tax_bracket=2)` means to set `tax_bracket` to `2` (and execute the following statement). 
that worked, thank you very much.
If you know what it does now would be a great time to let me in on the secret.
Also note that `&amp;&amp;` and `||` are short-circuiting operators, meaning that tests are run from left to right, and if one of them fails, the rest isn't even executed any more. They're very handy, but indeed very hard to Google for, because Google won't search for non-words. **Update** I found [this](http://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B) on Wikipedia. Looks useful.
Pointers are simply int variables that represent an address. * as a prefix says "use the memory location that this address refers to" &amp; as a prefix says "Give me the address of this location" In your scanf's you give the address so it knows where to put the value In your printf's you want to give the value, not the address of the value (except in the case of strings, but details...)
If you cannot teach yourself, then you are going to struggle in the future. * [Learn C The Hard Way](http://c.learncodethehardway.org/book/) * [Some pointers on pointers](http://boredzo.org/pointers/) * [Some help for Printf](http://www.codingunit.com/printf-format-specifiers-format-conversions-and-formatted-output)
In this instance, the `&amp;` means "the memory address of". Variables have to exist *somewhere* in memory. If you need a function to modify the contents of that variable, you pass in the address so that the function can directly modify the contents of that memory address. This is why `scanf()` has you pass in `&amp;hours_worked` -- it needs to modify the value stored at that memory location. You can display memory addresses and see the numeric memory location: int x = 5; printf(" x: %i\n", x); /* %i means "print value as integer" */ printf("&amp;x: %p\n", &amp;x); /* %p means "print value as memory address (hexidecimal)" */ If you have the address of a variable, you can modify it: int x = 5; int* ptr_x = &amp;x; /* ptr_x points to the memory address of x */ *ptr_x = 10; printf("&amp;x : %p\n", &amp;x ); printf(" ptr_x: %p\n", ptr_x); /* same result as the line above */ printf(" x : %i\n", x ); printf("*ptr_x: %i\n", *ptr_x); /* same result as the line above */ If you use the * character in front of a pointer variable (like `ptr_x`), that means "pretend this pointer is actually the thing it points to". If you set `*ptr_x` equal to something, you're writing directly to the memory address contained in `ptr_x`. This isn't useful in the above example, but *you can pass pointers to functions*. This is how `scanf()` puts its input into the variable you give it because you're passing in *the memory location of the variable*. void add_10( int* ptr_value ) { printf("Altering memory at location %p\n", ptr_value); *ptr_value += 10; } int main(int argc, char **argv) { int x = 5; printf("x is %i\n", x); printf("x is located at memory location %p\n", &amp;x); add_10( &amp;x ); printf("x is now %i\n", x); return 0; } Pointers and memory addresses are one of the bigger learning curves when just starting with C, so it's important you play around with them until you understand them. You can't use dynamically-allocated memory until you understand pointers.
USE MORE CAPS!!!!!!!!!!
AND MORE BANGS!!11!!!!!11!1!!!
http://www.catb.org/esr/faqs/smart-questions.html#code
Hacking is playful cleverness. The 'hacking' you mean is actually *cracking*, as in breaking into systems. You won't find anyone willing to take in a newbie for blackhat work. Beyond that, why do you want to break into someone's system?
Thanks man, it was actually an assignment that asked what was the output. Since all I had to do was type the code and run it it was easy to get the output; so I got an A. But I didn't understand why it was printing what it printed so thats why i asked. 
&gt;Pointers are simply int variables that represent an address. But don't assume that pointers are the same number of bits as an int, they may not be (especially in the 64-bit world). 
I changed the scanf format strings to %d and it all worked fine. 
Where is MIN_POSSIBLE_PRESSURE defined? Where is MAX_ABSOLUTE_TEMP defined? Where is MIN_TEMP defined?
All those are defined in compiler directives before the main function. (#define MIN_POSSIBLE_PRESSURE 0, etc.). I omitted that because all the errors that popped up were within the main function.
I just installed VS though, didn't even have the time to mess with any settings. Scanning in floats and storing doubles... I thought I fixed that but maybe I had accidentally undone it. Fixed it now, doesn't change anything though.
You need to use `%lf` instead of `%f` if you are scanning doubles. `%f` is only for scanning floats. If the macros are defined appropriately then there is nothing wrong syntactically ... it compiles fine in clang and gcc. The errors in your IDE must be false positives. What happens when you try and compile it anyway?
You **must** check the result of `scanf`. Not checking the result of `scanf` is a bad habit to get into. `scanf` returns the number of items that were successfully scanned, so in your case, you want it to return 1. int age = 0; int totalPeople = 0; int totalEligible = 0; printf("Enter you all's ages, when finished, type -1\n"); while (1) { if (scanf("%d", &amp;age) != 1) break; // stop processing input on first error if (age == -1) break; // stop processing when -1 provided totalPeople++; if (age &gt;= 65) totalEligible++; } printf("%d out of %d meet SS' age requirements\n", totalEligible, totalPeople);
I think you need to post the #define for MIN_POSSIBLE_PRESSURE. It sounds like it's wrong, and is expanding to something bad. If you can turn it into a minimum complete example, then we can compile it ourselves and find the error. 
A really common newbie mistake is #define MIN_POSSIBLE_PRESSURE 10; That semicolon shouldn't be there. My money is that's the problem.
So looking at that, I noticed that you included periods after the numbers in the #defines, which I hadn't done, and when I went back to check I noticed that MIN_POSSIBLE_PRESSURE didn't have a number... don't know how that happened or how I managed to miss that. Now it compiles and runs without any issues. Strange that it said there were syntax errors due to that. Anyway, is there any reason to include periods in your #define values? I didn't include them and it worked fine.
You might need to use as the list parameter the address of the list.
&gt; Strange that it said there were syntax errors due to that. The preprocessor is essentially a separate language from C; your source code runs through the preprocessor where `#define`s act like copying and pasting text, and then the C compiler gets to see the result. So with code like: #define FOO bar(1, FOO, 3); The compiler will only see: `bar(1, , 3);`. So the compiler can't really help you figure out preprocessor problems. That's one of the reasons that you should use the preprocessor as little as possible. &gt; Anyway, is there any reason to include periods in your #define values? I didn't include them and it worked fine. I did that simply so that the values would be `double`s instead of `int`s. There are automatic conversions, so it doesn't really matter, but I prefer to be explicit.
Try to connect those facts: You see nothing wrong in the code you are posting You are not looking at the #defines, because the problem obviously come from elsewhere You cannot see where the problem is Newsflash: the problem is with your #defines Info: #define are literraly replaced at the textual level. What the compiler see is not what you we are looking at if you don't include the #defs.
"The solution some one else handed you" FTFY To try to clarify what you have here... you first find the size of an in in bytes, lets say it's 4. you shift 4 left 3 positions to get 32 (not surprisingly, the number of bits in a 4 byte int). you then call a subtraction function, presumably to try to get around the fact that you can't use the arithmatic operators. then you shift this 31 places to compare the highest order bit. then finally you check to see if you have a one and then return 1 (?!?). This whole thing can be written more clearly with a single line: int is_negative(int x){ return [YOUR CODE HERE]; // requires only a single operator }
Correct, the ta edited my code and gave me it but didn't give an explanation. Thanks! I originally had: x &gt;&gt; (sizeof(int)*4-1) &amp; 0x0001 I thought that 1 byte = 4 bits not 8, so that was my issue. You are right, there was absolutely no reason for me to assign my code to an integer. 
~~One thing irks me: `sizeof(int)*4`. Why even do the `sizeof` if you're assuming it's 4 anyway...~~ edit: Talking bollocks.
Well, the *4 was to get the amount of bits. However it should have been *8 because there are 8 bits in a byte not 4. I forgot that there was 8 bits per byte, not 4. It's powers of 2. sizeof(int) gets you your implementation defined integer size in bytes, as I understand. you then multiply this number by the amount of bits in a byte (8) to get your total number of bits. so, if sizeof(int) is 4, then you get 4*8 which is 32. &lt;&lt; 3 is the same as multiplying by 8 because 2^3 = 8. So you take your signed integer and shift it to the right 32 times. But actually you want to shift 31 because you want your signed integer to be in the 2^0 position. If it is 1, then the number must have been negative. At least, that's how I understand it. Make sense?
That makes sense, yes. My bad.
The thing is, the problems weren't specifically with the defines, but rather with the syntax. Why would one incorrect define cause an "else" in a different line to be underlined as incorrect? That's what was throwing me off.
No worries, it clearly confused me at first as well
How long did you wait before coming to your conclusion? I'm asking this because the sleep function(at least the one declared in unistd.h) takes its arguments in seconds, not milliseconds. This exact code block performs as expected on my machine running OS X 10.9, compiled with clang-600.0.51.(I did reduce the argument to 1 second though)
I've tried with several different arguments for "sleep" (including 1 second) and it always prints the strings at the same time. I should also note that I'm compiling with gcc
Sometimes stdout can get buffered up, especially when not doing anything too exciting. fflush( stdout ); // Clear the buffer
Wow, adding a new line worked perfectly. Thank you!!
What I found interesting is that there seems to be many solutions given, but i'm guessing that a bunch of those don't work and a bunch that do are either written in an inefficient manner or are assuming an integer byte size of 4 which seems like a bad idea. &gt; All the more curious given that it's essentially useless in practice Why is that? For me, I care more about understanding the concept behind what i'm doing rather than pouring through google for possible solutions. Search engines won't save my ass during tests or interviews. 
I mean useless in the sense that you'll never want to use it in practice. Also it involves some subtle knowledge of different platforms, so the [bit twiddler's consensus](http://graphics.stanford.edu/~seander/bithacks.html#CopyIntegerSign) seems to be that this is the most portable way to do it: `sign = 1 ^ ((unsigned int)v &gt;&gt; (sizeof(int) * CHAR_BIT - 1)); // if v &lt; 0 then 0, else 1` Not exactly intuitive or easy to derive from deduction alone. But I guess that's C for you ;) 
Quick response from mobile, might be wrong, but in that code you posted wouldn't it need to be a signed int? An unsigned int would never be negative so no need to test. 
Because according to C89: "E1 &gt;&gt; E2 ... If E1 has a signed type and a negative value, the resulting value is implementation-defined", so you can't rely on it working the same for all architectures. So the cast to `unsigned int` gives better portabiliity. As I said, not very intuitive unless you know the ins and outs of the standard(s). 
Yes, the sign bit is preserved, although its meaning changes.
Seems I was wrong - I accidentally put a newline character at the end of the string. When I removed this, the code block behaved exactly as you described. But I learned something new today, which is always good! 
You can use `sprintf()` to put each block of 8 hex digits in the appropriate place in an output string buffer: uint32_t data[8] = { .... }; char output_string[sizeof(data) * 2 + 1]; for (int i = 0; i &lt; sizeof(data) / sizeof(data[0]); i++) { sprintf(&amp;output_string[i * 8], "%08X", data[i]); } I've used `sizeof(data)` everywhere so that if the size changes it only has to be changed in once place. Edit: the last `sprintf()` will terminate the whole string, so I removed the manual termination.
 src $ make gcc -std=c99 -Wall -Wextra -pedantic -c -o main.o main.c main.c: In function ‘main’: main.c:78:27: warning: pointer targets in initialization differ in signedness [-Wpointer-sign] uint8_t *h_todo_txt = exp_r.we_wordv[0]; ^ main.c:84:5: warning: pointer targets in passing argument 1 of ‘access’ differ in signedness [-Wpointer-sign] if (access(c_todo_txt, F_OK) != -1) { ^ In file included from main.c:37:0: /usr/include/unistd.h:287:12: note: expected ‘const char *’ but argument is of type ‘uint8_t *’ extern int access (const char *__name, int __type) __THROW __nonnull ((1)); ^ main.c:91:9: warning: pointer targets in passing argument 1 of ‘access’ differ in signedness [-Wpointer-sign] if (access(todo_txt, F_OK) == -1) { ^ In file included from main.c:37:0: /usr/include/unistd.h:287:12: note: expected ‘const char *’ but argument is of type ‘uint8_t *’ extern int access (const char *__name, int __type) __THROW __nonnull ((1)); ^ main.c:93:13: warning: pointer targets in passing argument 1 of ‘fopen’ differ in signedness [-Wpointer-sign] fp = fopen(todo_txt, "w"); ^ In file included from main.c:34:0: /usr/include/stdio.h:272:14: note: expected ‘const char * restrict’ but argument is of type ‘uint8_t *’ extern FILE *fopen (const char *__restrict __filename, ^ main.c:108:5: warning: pointer targets in passing argument 1 of ‘fopen’ differ in signedness [-Wpointer-sign] if (!(fp = fopen(todo_txt, "r"))) { ^ In file included from main.c:34:0: /usr/include/stdio.h:272:14: note: expected ‘const char * restrict’ but argument is of type ‘uint8_t *’ extern FILE *fopen (const char *__restrict __filename, ^ main.c:231:9: warning: pointer targets in passing argument 1 of ‘fopen’ differ in signedness [-Wpointer-sign] if (!(fp = fopen(todo_txt, "w"))) { ^ In file included from main.c:34:0: /usr/include/stdio.h:272:14: note: expected ‘const char * restrict’ but argument is of type ‘uint8_t *’ extern FILE *fopen (const char *__restrict __filename, ^ main.c:255:5: warning: implicit declaration of function ‘todo_free’ [-Wimplicit-function-declaration] todo_free(td); ^ main.c: In function ‘print_task’: main.c:315:18: warning: pointer targets in initialization differ in signedness [-Wpointer-sign] uint8_t *a = "✓"; /* sign: done */ ^ main.c:316:18: warning: pointer targets in initialization differ in signedness [-Wpointer-sign] uint8_t *b = "✖"; /* sign: undo */ ^ main.c:318:5: warning: pointer targets in passing argument 1 of ‘strlen’ differ in signedness [-Wpointer-sign] size_t a_size = strlen(a); ^ In file included from main.c:36:0: /usr/include/string.h:399:15: note: expected ‘const char *’ but argument is of type ‘uint8_t *’ extern size_t strlen (const char *__s) ^ main.c:319:5: warning: pointer targets in passing argument 1 of ‘strlen’ differ in signedness [-Wpointer-sign] size_t b_size = strlen(b); ^ In file included from main.c:36:0: /usr/include/string.h:399:15: note: expected ‘const char *’ but argument is of type ‘uint8_t *’ extern size_t strlen (const char *__s) ^ gcc -std=c99 -Wall -Wextra -pedantic -c -o buffer.o buffer.c gcc -std=c99 -Wall -Wextra -pedantic -c -o generator.o generator.c generator.c: In function ‘todo_generate’: generator.c:53:9: warning: pointer targets in passing argument 1 of ‘sprintf’ differ in signedness [-Wpointer-sign] sprintf(ptr, "- [%c] %.*s\n", t-&gt;state == done ? 'x' : ' ', (int)t-&gt;c_size, t-&gt;content); ^ In file included from generator.c:30:0: /usr/include/stdio.h:364:12: note: expected ‘char * restrict’ but argument is of type ‘uint8_t *’ extern int sprintf (char *__restrict __s, ^ gcc -std=c99 -Wall -Wextra -pedantic -c -o parser.o parser.c gcc -std=c99 -Wall -Wextra -pedantic -c -o todo.o todo.c todo.c: In function ‘todo_pop’: todo.c:144:1: warning: control reaches end of non-void function [-Wreturn-type] } ^ gcc -std=c99 -Wall -Wextra -pedantic -c -o utils.o utils.c utils.c: In function ‘colored’: utils.c:51:29: warning: pointer targets in initialization differ in signedness [-Wpointer-sign] const uint8_t *prefix = "\033["; // 4 char ^ utils.c:52:29: warning: pointer targets in initialization differ in signedness [-Wpointer-sign] const uint8_t *suffix = "\033[0m"; // 6 char ^ utils.c:61:5: warning: pointer targets in passing argument 1 of ‘sprintf’ differ in signedness [-Wpointer-sign] sprintf(ret, "%s%dm%.*s%s", prefix, color, (int)size, str, suffix); ^ In file included from utils.c:37:0: /usr/include/stdio.h:364:12: note: expected ‘char * restrict’ but argument is of type ‘uint8_t *’ extern int sprintf (char *__restrict __s, ^ utils.c: In function ‘space_join’: utils.c:86:17: warning: comparison between signed and unsigned integer expressions [-Wsign-compare] for (i=0; i &lt; len; i++) { ^ utils.c:89:9: warning: pointer targets in passing argument 1 of ‘strlen’ differ in signedness [-Wpointer-sign] sz = str_len = strlen(str); ^ In file included from utils.c:39:0: /usr/include/string.h:399:15: note: expected ‘const char *’ but argument is of type ‘uint8_t *’ extern size_t strlen (const char *__s) ^ utils.c:92:15: warning: comparison between signed and unsigned integer expressions [-Wsign-compare] if (i != len-1) sz += 1; ^ utils.c:98:9: warning: pointer targets in passing argument 1 of ‘strcpy’ differ in signedness [-Wpointer-sign] strcpy(p, str); ^ In file included from utils.c:39:0: /usr/include/string.h:129:14: note: expected ‘char * restrict’ but argument is of type ‘uint8_t *’ extern char *strcpy (char *__restrict __dest, const char *__restrict __src) ^ utils.c:98:9: warning: pointer targets in passing argument 2 of ‘strcpy’ differ in signedness [-Wpointer-sign] strcpy(p, str); ^ In file included from utils.c:39:0: /usr/include/string.h:129:14: note: expected ‘const char * restrict’ but argument is of type ‘uint8_t *’ extern char *strcpy (char *__restrict __dest, const char *__restrict __src) ^ utils.c:101:15: warning: comparison between signed and unsigned integer expressions [-Wsign-compare] if (i != len-1) strcpy(p + str_len, " "); ^ utils.c:101:9: warning: pointer targets in passing argument 1 of ‘strcpy’ differ in signedness [-Wpointer-sign] if (i != len-1) strcpy(p + str_len, " "); ^ In file included from utils.c:39:0: /usr/include/string.h:129:14: note: expected ‘char * restrict’ but argument is of type ‘uint8_t *’ extern char *strcpy (char *__restrict __dest, const char *__restrict __src) ^ gcc main.o buffer.o generator.o parser.o todo.o utils.o -o todo -I./
&gt;Does anyone know a convenient way to turn that output into a string? To directly answer the question, use functions like `sprintf` to print to a string, rather than to stdio.
&gt; What's the difference between `char* a = "blah";` and `char a[] = "blah";`? The first is declaring a pointer to `char`, and it is initializing that pointer to the memory address of a string constant. (The pointer&amp;nbsp;`a` should really be declared `const char *` here.) The second is declaring an array of type `char`, and it is initializing the values of the elements of that array to `'b'`,&amp;nbsp;`'l'`, `'a'`, `'h'`, and&amp;nbsp;`'\0'`, respectively. If `a` is declared in the first way, then an assignment statement such as a[0] = 'c'; is illegal, because you can't change the value of a string constant in memory. But if `a` is declared in the second way, then the same assignment statement is legal, because `a`&amp;nbsp;is an array, and you're just changing the value of an element of that array.
&gt; What is the difference between `strcpy` and `strdup`? Well, first, `strdup` is not part of ISO&amp;nbsp;C. The `strcpy` function copies a string from its second argument to its first argument. The first argument is a pointer, which must point to a block of memory that has been previously allocated; `strcpy` does not do any allocation itself. The `strdup` function allocates a new block of memory, copies the string from its argument into that new block, and returns a pointer to the new block.
So does this mean that when you say `char* a = "blah";`, you are assigning the pointer a value in the read-only section of the memory? (and is that why you say we must say `const char * a` in such a case?) In the second case, which section of the memory (read-only/stack/heap...) is assigned to the array `a`? 
&gt; So does this mean that when you say `char* a = "blah";`, you are assigning the pointer a value in the read-only section of the memory? The compiler is allowed to do that, yes. &gt; In the second case, which section of the memory (read-only/stack/heap...) is assigned to the array `a`? You are declaring an array on the stack.
Wow perfect thank you. This data array is coming from a sha256 hash, so I don't think the size will ever be different. Is there a way to optimize based on that?
So does this mean the only way you can make a character pointer like `char* a` point to something in 'modifiable memory' is by doing a `malloc`, like so- `char* a = malloc(10*sizeof(char));`---&gt; does this make `a` modifiable? After this we *can* do stuff like `a[0] = 'b';`, `a = "blah";`, right? Basically anything we could do with the second form of declaration. 
&gt;How is anyone ever going to be able to remember such rules? How do you remember that "summer" is the warm one and "winter" is the cold one? 
/r/coolgithubprojects
Your program would crash! **scanf** is used to scan the data of correct type, for example if you have defined your variable as **integer** and you input a **char**, it will return **0**. So to avoid program crash with wrong type of input data, you can just put a simple check to verify it in the first place.
Any reason you have chosen not to write a simple config parser? Its not really that complicated. Delimiter is the keyword you are looking for.
Take a look at minini https://code.google.com/p/minini/
- How about [INIH](https://code.google.com/p/inih/)~?
Thanks! It was perfect! Nice and small and tight and does exactly what I needed. 
I guess I didn't realize there was more than one way..
Well, how did you expect it to work? For example, if the `output` array is `{2674457814u, 3674388193u, 1569227836u, 427392383u, 1856407944u, 1772987226u, 3345594384u, 1868312246u}`, then what should the `key` array be? The first step here is to figure out what you want. If you don't know what you want, then you can't write code to do it.
Sorry C is not my speciality. What I figured was that each single element in the uint32 array could only be displayed as 4 smaller elements in the key array. The data should be identical just I guess split apart into smaller numbers. Or to put it another way if the uint32 array was converted to a hex string, and that hex string was converted into a char array, there could only be one output correct?
I see. Well, I'll have to try it both ways and check the output against a value I already know.. I'll work on trying to get an example. Is it easy to switch between big and little endian in the conversion method?
 uint32_t u; /* ... */ /* least significant 8 bits: */ unsigned char c0 = (unsigned char)(u &amp; 0xffu); /* second-least significant 8 bits: */ unsigned char c1 = (unsigned char)((u &gt;&gt; 8) &amp; 0xffu); /* second-most significant 8 bits: */ unsigned char c2 = (unsigned char)((u &gt;&gt; 16) &amp; 0xffu); /* most significant 8 bits: */ unsigned char c3 = (unsigned char)((u &gt;&gt; 24) &amp; 0xffu); Now do whatever you want with `c0`,&amp;nbsp;`c1`, `c2`, and&amp;nbsp;`c3`.
Escapes, invalid code points, encodings, line endings...
Just printf the value at 0 and the value at 9, seeing as you know how many elements there are?
So 0 and n-1?
Oh I got it now, I had to set Start to 0 and finish to c. Your comment helped me get it so thanks! 
the `&amp; 0xff` part is unneeded if you convert to `unsigned char` afterwards on all machines where `CHAR_BIT == 8` (i.e. all of them).
You can read the data in using whichever size type you want, although unsigned char would probably be the easiest. When you're done reading the data, you'll have to manually split it into 9-bit chunks by looping through the data and keeping track of the bit count. If you're unfamiliar with C, it will be helpful to learn about [bitwise operators](http://en.wikipedia.org/wiki/Bitwise_operations_in_C)
I've no experience with JNI but three things struck me initially: 1) this is a function, not a method &lt;/c-pedantry&gt;, 2) GetStringUTFChars should have a matching ReleaseStringUTFChars according to [1] and 3) to determine if this is the cause of the memory leak, you should provide a valid pointer to GetStringUTFChars as its third argument. If the string is being copied then that's your leak. [1] First result on Google: http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html
Yes, modulo any weirdness which happens with NewStringUTF. I assume that this function copies the string rather than just holding onto the pointer you passed in. (If this assumption is untrue you may experience weird corruption.) I'm also assuming that the jstring returned by the function is ultimately managed by the Java GC although, as I said, I've no experience with JNI so I don't know any of the more subtle memory ownership conventions.
I think you are correct about that, I read that Java will manage the memory for the NewStringUTF call. Thanks so much for your help, I hope to get a chance to test it soon.
 wptr += sprintf(wptr, "%02X", result[k]); BTW, this is either a very neat bit of programming or not doing what you think it is. I hope it's the former :). Irrespective of that, if `result` is a buffer containing 65 bytes and you are writing two hex digits of output for each character then `buf` should be 131 bytes long (130 characters plus NUL terminating byte). As written, you're scribbling over the end of `buf` in this code.
Oh wow good catch.. that snippet was written by someone smarter than me so I hope its the former too haha. Thanks for the code review!
I just ran a load test and its stable as a table. Thanks again for helping me diagnose, much appreciated.
I love how many pointers you use which you do not sanity-check at all. *cringe*
Well I'd love to hear suggestions since I mentioned that I'm a java developer and this is all new to me..
Ah, thought so. I was asking because fiddling with bitwise operators was precisely what I was hoping I wouldn't have to do :( Worked on it for an hour or so, ended up coming up with [this](http://pastebin.com/yK4i6FEU). Thanks
I'm sorry, it was an assy way to express myself. Pointers in C and C++ point to an address in memory, regardless of it's contents. If you try to access memory that isn't allocated, you will get a segmentation fault. Here's two tips: Always set any unused pointers to NULL (even when you free them or release them), and always assert that a pointer is not NULL before you attempt to use them.
Welcome to the darkside OP. Its a shame more people from java dont try out C. 
I think you got the arguments in strcpy in the wrong order in lines 58-60 and 65-67 [here](http://pastebin.com/m0NnJqUf). Destination comes first, then the source.
&gt; google on how to set up cmd so it's actually usable It's not usable by default? My vanilla install of Ubuntu seems to be treating me just fine while I code in C so far (1 month in). What kind of things should I look to change?
For future reference, anywhere where you are getting a new pointer (i.e., access to some arbitrary memory), you have to know whether or not you need to free that memory. In this function this could happen when calling NewStringUTF() and GetStringUTFChars(). The other functions hash(), encrypt(), and sprintf() can't return new pointers. Anywhere where you declare the variable directly (i.e., the memory is not being pointed at) then the storage is managed automatically. Notably, this is the case for the pointer input; the pointer memory for the pointer will be reclaimed, but the memory that is pointed to will not. 
It's irrelevant on Linux, disregard my comment. I somehow assumed you were on Windows. Tab completion used to be off by default, this and CUA had to be enabled at minimum. It required some changes in the registry that had to be googled.
Gotcha, thanks for the reply
You need a lot more error checking, this will go to hell if the text file doesn't contain lines with enough commas in them and the fields short enough. 
Oh I know haha, I was just trying to get the basic system to work, then add the error checking later. Thank you for reminding me however.
Seems a pretty straightforward loop keeping track of real position on the hill and actual distance run against the given variables, until pos == n. What have you tried so far? Post your code. 
Without error checking, and woefully unoptimized, but my first attempt at the problem. int total = 0, place = 0; int up = atoi(argv[1]), down = atoi(argv[2]), end = atoi(argv[3]); while(true) { if(end &lt;= 0){ printf("%d\n", total); return 0; } for(int i = 0; i &lt; up; i++){ total++; place++; if(place &gt;= end){ printf("%d\n", total); return 0; } } place -= down; total += down; } 
On the latter point, when x = 3, y = 2, n = 4? 
Without the loop: int runHill2(int x, int y, int n) { int distance, height; int diff = x - y; int div; if (x &gt;= n) { return n; } else { distance = x + 2*y; height = x; } div = (n - height) / diff; if ((n - height) % diff != 0) { distance += div * (diff + 2 * y); distance += (n - height) % diff; } else { distance += (div-1) * (diff + 2 * y); distance += diff; } return distance; } It's kind of weird. Possibly wrong too, but ... beer :) *Edit: corrected wrong language (c#)
I'm not sure I understood the question, but here is a simple if statement: If(n%2==0 || n%5==0) 
Use a for loop to increment the number and run the number through that if statement. Then do what you want with the number in the if statement. Edit: obviously if you need two totals, you need to split up that if statement. 
It will be exactly the same except instead of 2 you use 5. If you reuse X, you will need to put it back to 0.
For x=2, y=1 and n=3, it returns 7 instead of 5.
It has to be in a loop, and you need to use 5, not 7. You could use a single for loop and two ifs within the loop. 
Wouldn't this make you miss some even numbers and numbers divisible by 5? 
Ah, I though he was looking just for the even numbers between 1 and 20 that are divisible by 5 ... the question is a bit unclear. If so, it would just be: for (i = 2; i &lt;= 20; i+=2) { if (i % 5 == 0) { printf("%d is an even multiple of 5.\n", i); } } 
I wonder sometimes about the point of these homework questions if the OP can't even state the question clearly. Just doing that is 90% of the work ;) 
&gt; int CalcRun(int x, int y, int n) &gt; { &gt; int len = x + y; &gt; int dist = x - y; &gt; int whole = n/(dist + 1); &gt; int rem = n-(1+(dist*whole))+1; &gt; return (len*whole)+rem; &gt; } Hmm ... for x=2, y=1 and n=5, it returns 9 instead of 11 :) If you need it, here's the C# program I'm using to test these functions (it uses the "drunktard" proving method, i.e. test a bunch of cases and then cross thy fingers for the rest :P ): using System; namespace Tests { class MainClass { public static void Main (string[] args) { int x, y, n; for (x = 2; x &lt; 100; x++) for (y=1; y&lt;x; y++) for (n=x+1; n&lt; 100; n++) if (runHill (x, y, n) != CalcRun (x, y, n)) { Console.WriteLine ("\nNO!!! @ x=" + x + ", y=" + y + " and n=" + n + "\nWorkout distance: " + runHill (x,y,n) + "\nWorkout distance: " + CalcRun (x,y,n)); Environment.Exit (0); } else { Console.Write ("."); } } public static int runHill(int x, int y, int n) { int dist = 0; int height = 0; while (height &lt;= n) { if (height + x &lt; n) { height += x; dist += x; } else { dist += n - height; break; } height -= y; dist += y; } return dist; } public static int runHill2(int x, int y, int n) { int distance, height, div; int diff = x - y; if (x &gt;= n) { return n; } else { distance = x + 2*y; height = x; } div = (n - height) / diff; if ((n - height) % diff != 0) { distance += div * (diff + 2*y); distance += (n - height) % diff; } else { distance += (div-1) * (diff + 2*y); distance += diff; } return distance; } public static int CalcRun(int x, int y, int n) { int len = x + y; int dist = x - y; int whole = n/(dist + 1); int rem = n-(1+(dist*whole))+1; return (len*whole)+rem; } } } 
x=3, y=2, n=4 returns 12 instead of 8.
I'm stumped for now. I guess you need a few condition checks for some of the boundaries.
This will do the trick: #include &lt;stdio.h&gt; #include &lt;math.h&gt; int calculate_total_run_distance(double x, double y, double n) { double length = x + y, distance = x - y, iterations = ceil((n - x) / distance); return (int) ((iterations * length) + fmin(x, n - (iterations * distance))); } int main(void) { int x, y, n, total; fprintf(stdout, "Enter x, y and n: "); fscanf(stdin, "%d %d %d", &amp;x, &amp;y, &amp;n); total = calculate_total_run_distance((double) x, (double) y, (double) n); fprintf(stdout, "Workout distance: %d\n", total); return 0; } 
take a picture, clown.
nice!
Error checking will tell you exactly what's wrong with your code as your write it. Get in the habit early.
You are including a cpp file into another cpp file. This is a problem. Because of the way the C preprocessor works, you have the same function and variable declarations compiled twice. Source code splitting in C is different than in other languages. I would suggest having everything in a single file until you get comfortable with splitting C source among several files. 
C and C++ are actually different languages. There's a subreddit for each (/r/c_programming and /r/cpp). Your code is just C but your files are `.cpp` - strange! You should have a think about which one you want to learn. Here's a rule for you: never `#include` a `.cpp` file (or a `.c` file in C). To understand why, you have to know a little about how both C and C++ compilation works (I will discuss it in terms of C++). Each of your `.cpp` files is compiled separately. You have two, `Menu.cpp` and `Cantina.cpp`. Before they are compiled, the `#include`s are resolved, so the content of the files you're including are brought in. This is what your files look like after this inclusion has been performed: // Contents of &lt;stdio.h&gt; here void Menu() { /*some junk looking code initializing a couple bool, int, and char, printing a menu, getting input through getchar(), and calculating a total. I can show you if I need to.*/ } and: // Contents of &lt;stdio.h&gt; here // Contents of &lt;stdio.h&gt; here void Menu() { /*some junk looking code initializing a couple bool, int, and char, printing a menu, getting input through getchar(), and calculating a total. I can show you if I need to.*/ } void main() { Menu(); } Notice that both files, after performing the inclusions, contain definitions of the `Menu` function. Herein lies the problem. After compilation, the *linking* phase begins. This is when the results of compiling your files are joined into a single executable. However, once you join your two files together, you have two `Menu` functions defined. This breaks the "one definition rule". The linker is trying to find a function for `Menu();` to call, but it finds two - so it just gives up! If you want to be able to use the `Menu` function in `Cantina.cpp`, you're going to need to create a header file (some people use `.h`, some `.hpp`). Header files are *meant* to be included in other files, since they only contain function *declarations*. So what you need to do, is introduce a file `Menu.hpp` with the following contents: void Menu(); This a declaration of the function `Menu`. If you include this header in `Cantina.cpp`, it will look like this after inclusion: // Contents of &lt;stdio.h&gt; here // Contents of &lt;stdio.h&gt; here void Menu(); void main() { Menu(); } And this is great! `main` can see that `Menu` exists because of the declaration, but definition only exists once in `Menu.cpp`. The linker will now be able to connection the call to `Menu` in `Cantina.cpp` to the definition of `Menu` in `Menu.cpp`.
That's how the teach wants it done :/ Not sure why, I'm just a code monkey when it comes to C++. I went ahead and did what you said, and it's functioning properly, and probably won't get too much static about it, but out of curiosity, how would I go about doing it the way we did in class? On a low, semantic level, we did the exact same thing in class with 2 different cpp files, with one essentially just being #include header and "otherFile.cpp" void main() { printf(""); otherFile(); } and it compiled and worked. What could've been done differently? I cross referenced the two, and the main file, with the only difference other than naming was the print statement. I have no idea how the two were different and why one worked and why the other didn't. The following worked in class. #include &lt;stdio.h&gt; #include "Sum.cpp" void main() { printf("Hello world\n"); Sum(); } ---- #include &lt;stdio.h&gt; void Sum() { int num1 = 0, num2 = 0; int result; printf("Provide two numerals of thy choice."); scanf_s("%d %d", &amp;num1, &amp;num2); result = num1 + num2; //print results printf("The sum of thy numerals begets %d", result); }
I used The C Programming Language by Kerninghan and Ritchie
The casting seems pointless (it isn't. You're correct casting to `void*`), the following code compiles with no errors. In most cases if you can avoid casting, do. I wish I could help more, but it's proving more difficult to read code in another language than I thought it would be :) You seem to be doing a lot of pointer arithmetic (Which I believe causes the seg fault), I doubt that's what you want? [Working Code](http://pastebin.com/pmY2fmHs)
I think it's much more likely that she included a header file that contained prototypes for functions in another file. That is the correct way to split files in C. If she is seriously trying to include a C file in another, find out why. 
You want to create a `Menu.h` file, define your function prototypes in that. Keep your code in `Menu.cpp`. Then `#include "Menu.h"` in Cantina.cpp. Then compile like `gcc menu.c cantina.c`. This should work for you :) 
Well, perhaps you should ask your teacher this question first? I'm sure they have their reasons for asking you to do it this way at this stage. I assume they're being paid to answer your questions? This way of including files is actually a common solution to creating unit tests that need to test static functions. Just make sure when compiling your test executables that you don't link the separate files (perhaps using the linker flexibly is what she's trying to teach you currently). 
Learn C The Hardway. http://c.learncodethehardway.org
I completely forgot about -&gt; operator... Yeah I understand what you mean, between full time work, school, house and family, it's quite a mess learning another language into all of that. specially since I'm a sucker at learning from reading stuff, either book or other stuff. I've made I don't know how many tutorial to learn from scratch and to transfer from java, even those from my university, but still, some stuff aren't getting into my head. Seriously, they made C a hell to code compared to Java ;) (yeah I know, Java came after) Thanks for the help, I'll switch to the -&gt; field, that should do the trick. After, I'll work on the algorithm for factoring a number using 4 threads... funny thing, this exercise is about learning to use thread, not pointer or function...
just wanted to add, I understand the concept of pointer, which when you have a pointer, it refer to the memory address where the value is, not the value itself. When you have a variable and want the address, you use &amp;var and the value that it gave you can be use by a pointer at *var, if I'm not mistaken... I really have to read all of that about, doesn't help that my last C coding session is about 2 years ago.
No. You can't change the type of parameter of the function. It must take `void *`, because that's the signature needed by `pthread_create()`. It's undefined behavior if the function doesn't take that, even though it might work. 
You need to specify the pthread library. `gcc -o test test.c -lpthread`. If she wants you to use the void cast, then yes casting back should work.
Yeah, you're right. I didn't look up the function prototype TBH, but it does need to be `void *`.
Second. I think it's the best intro to the language.
ok, got it working and calculating the way it must be done by the homework. Thank you very much. I learn faster by doing some stuff like that then trying to understand books and tutorial online, even if I've done a bunch.
As denoted in the sidebar, I think it's important to specify that the second, ANSI C, edition be used. I've not read the first, though, so it's quite possible I'm missing out in some way.
Well, I'm a little afraid to recommend this book to you since it doesn't hold your hand if you're a first time programmer. But since you have a little Python knowledge in your head, try taking a look at a book called ["Head First C."](http://www.amazon.com/Head-First-C-David-Griffiths/dp/1449399916/) If you follow along with the book, do every exercise, and complete the labs, I think you'll come out ready to tackle the world like a 240-pounds football linebacker. 
I think the [Deitel C How to Program](http://www.amazon.com/C-How-Program-7th-Edition/dp/013299044X) books seem really decent. I have a friend that is learning with this book at the moment. There is a lot of emphasis on modern C programming and discusses common pitfalls that arise. I honestly wouldn't start with K&amp;R C but that's my own opinion. It is a dull read and the beginning exercises are incredibly dull. As a reference it is quite fantastic.
"Programming in C" by Stephen Kochan
aa a f
Try `scanf("%lf", &amp;epsilon)`, since you're using doubles? Same for x. Really you just want to forget about the loop for the moment and get the first part to work.
[C Programming A Modern Approach](http://knking.com/books/c2/index.html) I like this book far more than the K&amp;R C book. While K&amp;R is very brief, this one has thorough explanations. It is also more up to date. It's an 800 page tome and people may feel discouraged by that, but I prefer one solid introductory book over sifting through multiple books to find the information I need.
Thinking back on it now I think K&amp;R C needs to be coupled with [the linux programming interface] (http://www.amazon.com/Linux-Programming-Interface-System-Handbook/dp/1593272200/ref=sr_1_1?ie=UTF8&amp;qid=1411641367&amp;sr=8-1&amp;keywords=linux+programming+interface). It really helps flesh out the parts where K&amp;R leaves you hanging. It also shows you the internals of c programs and much more.
I used "Absolute Beginner's Guide to C" by Greg Perry. As the title suggests it is written for absolute beginners so you may find it a little too basic with your Python knowledge. C was my first language though and I found it pretty useful. As usual, K&amp;R is mentioned a lot by others. I would add I've always found this a good reference, but as a first book its pretty dry reading. 
[Head First C](http://www.amazon.com/Head-First-C-David-Griffiths/dp/1449399916/) is *very* good. It not only covers C but also valgrind, make, threads, sockets and networking, etc. It is a great introduction to C and commonly used tools. I was surprised at how much they covered as normally a beginners book in a lower level language do not cover the more complicated things such as networking and threads.
There are important differences between `#include &lt;math.h&gt;` and python's `import math`. When you use `#include` in C, it tells the preprocessor to put the contents of the targeted file in your current file at the location of the include statement. This is usually done with a header file (`.h`), which can contain anything a .c file contains, but usually contains things like function declarations (but not definitions) and structs. This is enough to allow you to use the names in your own code, and compile it to an object file, but a final executable will still need definitions for its functions, so you'll have to link them in one way or another. This could involve linking to static (`.a`) or dynamic (`.so`) libraries (`gcc -lm file.c`, to link to the math library), or it could involve specifying multiple `.c` files together in your compilation (`gcc -o myapp foo.c bar.c`). Python's `import`, on the other hand, executes the module it imports, which handles both declaring and defining the functions listed in it, so no further work needs to be done before you can use the functions and classes you've imported. Another difference is that `import math` adds the name `math` to the current namespace, while `#include &lt;math.h&gt;` adds all the names in that header file to the current namespace. Semantically, `#include &lt;math.h&gt;` is closer to `from math import *` than `import math`. 
I suppose you could be right. I was just freaking out that she wanted it two days from when she taught us how to do it, and I was already behind with getting VS to work. I'll talk to her about it. Thank you.
Thanks!
nice
There aren't any (if you disregard hacky ways to do it). Why do you ask?
The idea behind the C standard library isn't so much to make a collection of useful functions. The C standard library is mostly a set of portable interfaces to talk to the operating system and/or hardware. For example, memory management. The math library can use SSE on x86 and NEON on ARM to speed up certain calculations. This is invisible to the users of the library. I guess averaging is easy enough that it didn't find its way into the math library. You can implement an averaging function in two lines of C, after all... for (size_t i = 0; i &lt; n; ++i) average += array[i] / n;
it's not technically a comment but a preprocessor directive
Here's an obscure variation on your line continuation theme.. // Super sneaky single line comment ??/ that is continued on the next line or with slightly more confusing usage due to the context: // Is this a one-line comment???/ no it is not. 
Yeah, if you enable trigraphs in C you can get a bunch of weird comment syntax: /??/ * A comment *??/ /
Throw a digraph in there for extra confusion: %:if 0 comment %:endif
I don't think compilers allow trigraphs by default anymore. 
Look into arrays, and maybe malloc since you don't know how many miles you'll have.
Ahh okay I got it, now I am trying to figure out how I reference the array elements for the avg variable
yeah, it wasn't exactly what i expected - but def. interesting!
Of course. I was just showing how you can implement `average` in *two* lines of code :-)
are they going to write the time in whole seconds or minutes with a decimal point. one algorithm for average is: (a + b + c + .. + n)/n Since you are doing it in a loop you don't need to store more than one number at a time. look at the form: mynum = mynum + newnum; or mynum += newnum; 
Worth noting that // has only been valid since C99. I didn't know that until recently. All modern compilers will support it without complaining of course, but interesting trivia if you didn't know it.
 unsigned i = 0; while (something) { ++i; . . . }
It wasn't possible for you to copy-and-paste the text somewhere?
Agreed, it includes C99 and there are lots of gems in the Q&amp;A sections of each chapter, too. Well worth reading from cover to cover. 
If you want to reference elements of an array, use the following syntax: array[index]; Remember that array indices start off from 0.
Oh dear god...
That's how I did in Ti-BASIC, it was the only way.
really??
Didn't ti-basic have REM (for remark)? It's been a while though...
That's just wrong, and I feel dirty for wanting to do that now
1. Use imgur. Albums are very nice. 2. This is because you are lying to printf(). printf() is very gullible. Don't lie to printf(). 3. Also, it's because the bits for floating point numbers are _very_ _different_ to the bits for integers. If you want to print a float as an int, you must typecast it first `printf("%d\n", (int)f);`
 "please","don't","ever","use","this",":("; "this"-"works"-"too";
I assume you need to find the average miles per minute. If that is the case, you need to add up each time entered in the inner loop. I think the variable name "sum" would be a good choice. You'll need a temporary variable to store the input of "How long did it take..." as well. Something like: float m; printf("How long did it take you..."); scanf("%f", &amp;m); sum += m Then -- after the while loop completes -- you should have a total time it took to run. Divide miles by that time to get the pace.
AFAIK, K&amp;R book really isn't intended as a book to learn from, it's more of a manual. Since you're going straight for networks, you should get TCP/IP Sockets in C, which is a small but decent book with source code examples of most of the basic protocol methods. 
Many compilers will give you a warning, I think, but you can throw `(void)` in front of it and they should shut up.
&gt;Use imgur. Albums are very nice. Use pastebin or gist. It's code -- it's text. It is NOT an image. &gt; As you can see, my values for the double value 157.8962 look a little strange, or at least I think they do. Could I please get some clarification? You're essentially [type-punning](http://en.wikipedia.org/wiki/Type_punning), and in this case it's a bug as: a) a double is a 64bit floating point with IEEE 754 binary encoding b) an int is probably 32bit [(depends on compiler and system)](http://www.unix.org/version2/whatsnew/lp64_wp.html) with 2's compliment encoding. Printing a double as an int will result in nonsense, unless you want to know the exact bit layout. (In which case you probably want "0x%016X" (or is it "0x%016llX"?) as that's the most useful for seeing such things)) 
test.c:2:1: warning: return type defaults to ‘int’ [-Wreturn-type] test.c: In function ‘main’: test.c:4:5: warning: statement with no effect [-Wunused-value] test.c:6:1: warning: control reaches end of non-void function [-Wreturn-type] As void man () test.c:2:6: warning: return type of ‘main’ is not ‘int’ [-Wmain] test.c: In function ‘main’: test.c:4:5: warning: statement with no effect [-Wunused-value] As int main() test.c: In function ‘main’: test.c:4:5: warning: statement with no effect [-Wunused-value] test.c:6:1: warning: control reaches end of non-void function [-Wreturn-type] All this only when -Wall is passed as a flag to GCC!!
An unused label: void some_func(void) { why_didnt_I_use_a_normal_comment_here: do_stuff(); } The comma operator: void some_func(void) { char buf[32]; strcpy(buf, ("Copying hello into buf", "hello")); puts(buf); } Those might issue a warning though. Or place the text in an unused declaration void some_func(void) { void why_didnt_I_use_a_normal_comment_here(); do_stuff(); } 
If you have a fused multiply-accumulate you could multiply by `1.0/n` on each iteration instead of dividing, but that still saves you no time over just doing the one division at the end.
&gt; (void) in No, sorry, meant throw `(void)` in front of the bare string constant, which is what it’s warning about on line 4 there `[-Wunused-value]`. The other warnings are quite correct, though—always put a return type on your function (`main` should always return `int`), and always return a value from a function whose return type isn’t `void`. Hence the frequent advocacy for always using `-Wall`.
The comma thing you mentioned is very similar to something I’ve actually seen in practice in assertions: assert("x must be valid" &amp;&amp; (complicated check of x)); Since the body of the assertion usually gets printed out when the assertion fails, you can use that technique to include a message in the output. Sometimes the comma approach will get you an “unused value” warning for the LHS; this approach will sometimes get you a warning about unnecessarily testing something that’s known to be true. I think throwing `*` in front of the string should kill that in either case, as long as the string’s non-empty.
Very useful for commenting out larger code blocks.
Wow that is wacky. http://i.imgur.com/0MZkAKu.png
First of all because of curiosity, and secondly because I'm learning to program finite state machines and I decided to build one that removes C comments from a file. 
Sorry I haven't had time to learn much c if you wouldn't mind explaining what does that do? It sort of looks like a stack overflow idk
For those wondering: this is a simple implementation of strcpy() except the return value isn't consistent with what would be returned from strcpy(). 
Thank you, appreciate it! 
You already have a file called `14.o` in that directory, right? Since you didn't specify any makefile rules that say how to make&amp;nbsp;`14`, the `make` program will look at the files that already exist in the directory. Since `14.o` already exists, `make` applies [its default rules](https://www.gnu.org/software/make/manual/html_node/Catalogue-of-Rules.html) to create the executable.
oh. right. yeah. ^^this ^^is ^^awkward
The only way I see this working is if you don't compile the included file. 
No, dictArray is allocated on the stack, when the function returns it goes out of scope and is deallocated. Do something like this instead: char **strAlloc(int count) { char **dictArray = malloc(sizeof(char*) * count); return dictArray; }
No. when the function returns, dictArray will be undefined. Moreover, your dictArray is not an array of strings, but an array of pointers to strings. To return something from a function, you have to allocate memory for it: #include &lt;stdlib.h&gt; char ** strAlloc( int count ){ char ** dictArray = calloc( count, sizeof(char*) ); return dictArray; } The returned pointer will then point to an array of *count* null-strings, which should be free()'d when you are done with it. 
&gt; The returned pointer will then point to an array of count null-strings, which should be free()'d when you are done with it. No. The returned pointer will point to a chunk of memory big enough to hold *count* pointers to strings, and every one of those pointers will be set to NULL. OP will also need to allocate memory for each individual string. The function should look something more like: char **strAlloc(int count, int length) { char **dictArray = calloc(count, sizeof(char*)); for (int i = 0; i &lt; count; i++) { dictArray[i] = calloc(length, sizeof(char)); } return dictArray; } And when it comes time to freeing, OP should loop through and free each individual dictArray[i] before freeing dictArray.
&gt;No. The returned pointer will point to a chunk of memory big enough to hold count pointers to strings, and every one of those pointers will be set to NULL. Sure, but I think you misunderstand what i wrote; I didn't mean anything else. What the caller does with the returned array of null pointers is not up to the function itself. Passing *length* to the function assumes that every string is of the same size, which limits its usefulness.
I don't disagree with you about the limited usefulness of all strings being the same length in the example I gave. However, given the nature of OP's question, and this subreddit in general, I thought it should be made clear that OP will also have to allocate the memory for each individual string (assuming the strings don't come from another source). This serves as an example that OP can at least work from to work into their own code.
oh absolutely! also remember this only allocates the pointers themselves, not the strings! (also remember to free the strings you allocate)
Look up strtok
You've got it pretty much correct. 1- Allocate a chunk of memory 26 bytes long, 2- Iterate through the array storing the alphabet in it. 3- Deref C and set the value C points to to 'q'. So yes, first element in array is 'q' 4- c[7] = '8' //set the 8th element in the array to be 8. (0 based) 5- create a new char* that points to the location in memory that c[7] points to. You have it all right. good job mang
Thanks. I didn't think it would be that easy... Thought it was a trick question.
Yeah, it’s a way to loudly and proudly discard a value, using a sassy wrist-flip.
Are you working through K&amp;R?
Sure, as long as you remember that the *actual* values held are ASCII values 56, 100, 113, which you should to be aware of when, say, using printf like so: http://ideone.com/DMrUCI 
Not now, I did it this summer though. But that's where I got the inspiration to build this program, but this time with a much better implementation using a state machine and eliminating a few errors i did some months ago.
Beware of strtok. It's great, but read the warnings in the man page. Personally, I use glib for the more tedious problems like string splitting. C's default library isn't as extensive as the libraries for java, python etc. Glib gives you lots of extras like linked lists, string functions, file functions, balanced trees, config file tools etc. If you really want to learn C, leave the libraries aside and do it yourself for now. If anything, you'll learn the joys and pains of using pointers
Not to be snarky, but the awesome thing about code ... compile and try, it probably would have taken less time than posting. 
Yeah, it's only needed for C++ compatability, but a number of things in that sample code aren't idiomatic C, like `*` being in the wrong place. I'm surprised it was used in a test, tbh.
It's K&amp;R Exercise 1-23. You might want to check this out, it's code examples: http://web.archive.org/web/20130704154437/http://users.powernet.co.uk/eton/kandr2/krx123.html
You can verify your answers by compiling and running the code. Direct evidence beats conjecture.
You can install a terminal app and a GCC compiler on your phone. You can write the code in a text editor and compile via terminal shell.
Yeah, that'll work. It's not what you're asking for though, it's just a way to write C on your phone.
You can compile C with AIDE also, it seems. Otherwise a fully-featured IDE with code completion, debugger, git integration would be [C4droid](https://play.google.com/store/apps/details?id=com.n0n3m4.droidc) for a small price, though not with the kind of interactive tutorials you're looking for. AIDE is quite special in that respect. But there are *tons* of C reference &amp; coding materials in the Play Store like [this one](https://play.google.com/store/apps/details?id=nadsoft.cprogrammingreferencefree). 
Wait, really? I do have root, terminal emulator and BusyBox installed. How would I get apt-get or another package manager?
Oops sorry. Anyways, for anyone reading this it looks like I possibly violated something called the rule of threes. I didn't create a copy constructor... 
Hey man, I needed to do this alot on Android; my university courses almost exclusively require C. There are two options (that are free). 1. There is a fantastic app called 'Terminal IDE' on the play store. Really terrific, has its own GCC script and makes using the terminal on android a breeze. 2. Install Linux on a chroot environment :) its actually super easy, pm me if you ever get stuck. The app 'Linux Deploy' does all the heavy lifting for you. Both these options work well for programming C :D
the * being in the wrong place threw me off a bit as well. 
https://github.com/filefrog/ctap
You are correct. Thank you.
What do you mean it's in the wrong place?
I'm retaking the C class this year, I'm up for it. 
I'm learning C in school but also doing some learning on the side. If you PM me your email or phone # I could do this with you. I don't know how much help I'd be but I'm willing to give it a shot 
Thanks :) PM'ed :)
I'm up to it :)
Maybe try irc://irc.freenode.net/##c too
C study group? C study group. I'd be interested as well. 
me too
One hint: Do not join the ##c channel on Freenode. It's a place that is fairly hostile towards beginners. You'll loose your enthusiasm pretty quickly.
You should do that once you have a fairly solid grasp of the C language. People there become extremely hostile when you ask beginner questions, especially if you appear to be clueless or if it looks like you might have not exhausted all other means of finding an answer.
If there's a study group coming out of this post then I'm in.
It's not necessarily that they're hostile towards newcomers, the problems lies more in the fact that they are cunts 90% of the time.
I think freenode has a beginner c channel, but I can't remember what it is 
First of all, this is C++. Yes, the concepts can apply to both C and C++, but try to keep this sub C only. You will need to do some conversion step where you turn the chars FirstGrade and SecondGrade into their corresponding numeric values. I see you have the constants listed, but you never use them. 
I an not ++ coder, but I would make a function (on kindle so format will be off): float convGrade(char grade) { switch(toupper(grade)) { case 'A': return(4.0); .. default: return(0.0); } } 
I can help out as well if need it. I use c daily for work
Best way to alleviate?
I think you need to think carefully about what you want your program to do, and what it actually does. 
So, is it 4chan hostile or RTFM hostile?
Have you learned anything about control statements? Specifically 'if' expressions? If you want to do different things based on what the user is entering, you need to familiarize yourself with them. Also, does the code you posted compile? It doesn't look like it will. 
It compiled and ran, but I see now. I guess I was just over thinking the problem. I feel dumb.
Don't sweat it, we all get started somewhere. Also it would be helpful to explain the problem you are having when asking a question, what you think should happen, and what you maybe have tried instead of posting code and little explanation. My guess is that this is a homework exercise of some kind. If I am right, try to be careful with taking assignments to the internet. The goal is for you to really understand things, and not to have us tell you what you need to do. You won't get much out of these assignments that way, that doesn't help anyone. Anyway, good luck .
First time here, thanks for the advice!
different book, but what stuff have you covered so far? i'd be interested
I spent 4 hours on this problem tackling it in a completely wrong way. I gifted you some gold for helping me out of my slump. Had I done this problem a week ago it would have seemed so easy; after a couple lessons on characters I wanted to use them really badly to solve the problem.
I've been doing competitive programming for 4-5 years now and I'd been teaching people in my high school elementary C, as well as Discrete math, algorithms and data structures for the last three. If you need any immediate help or just want to chat, you can PM me whenever. I'm always open to help however much I can. 
I know how you feel I have been there. One of the best things you can do when something goes wrong is answer why. When you get a value you don't expect, investigate what has gone into creating that value. Make sure those component pieces are what you expect. Often times something is off there. I find that if you find yourself really unsure of why something is happening, and you feel yourself getting frustrated, get up. Make some tea, have some water. Sit back down, and try to answer why. Use print statements, or a debugger. Figure out what is wrong, and then why it is wrong. Once you know why, you can fix the problem. 
RTFM
Then I won't join that channel. I don't really want to be discouraged :( Thanks a lot for the advice :)!
Thanks a lot :D! P.S- Would you be interested in the study group(check the edit)? Your experience could help us beginners :).
Thanks a lot :)! P.S- Would you be interested in the study group(check the edit)? Since you use it daily,you must be quite experienced and could help us :)
I'm new too and I plan to make a career in this industry :) Would you be interested in the study group(check edit) :)?
I'm sure you'll be of great help :) Study group?(Check the edit) :)
Edit :)
Thanks for the link but as some people have pointed out,I might get discouraged there and I don't wanna take that risk. Maybe I'll join later, when I'm better at it :)
How about making a Facebook group so people can share code and problems? I'll send you my email through pm.
Sure, I'd love to help out as much as I can. My email is oselcuk@outlook.com
Haha well I'm already out of school but I'll give you some pointers (pun intended) if you have questions 
Also, this: GPA = (FirstGradeFirstCredits) + (SecondGradeSecondCredits)/TotalCredits; does not give you an average, due to how you parenthesised the expression.
Do you understand why the following work ? #include &lt;stdio.h&gt; int main(void) { int x,y; for (x=1;x&lt;=100;x++) { int dividerFound = 0; for(y=2;y&lt;x;y++) { if (x%y==0) { dividerFound = 1; break; } } if (!dividerFound) { printf("%d\n",x); } } return 0; } x==y basically does the same than divider Found (because if both are equal it means that the break branch was not take)
It checks, that x can be divided by y (in the second loop). If not, and x=y, then the only divider of the number is the number itself (and 1, of course), so the number is prime.
Your "if(x==y)" will only ever yield true if the y counter made it all the way up to x without tripping the break condition (which is that it divides x). If no y smaller than x divides x, what does that say about x? Why, that it's prime.
I would love to join this study group. I am slowly learning C from various stack overflow threads and blogs around the web :^)
 for (x=1;x&lt;=100;x++) { ... } Start a for loop that goes for 100 iterations, for(y=2;y&lt;x;y++) { ... } Start a second for loop that starts from 2 to the value before x, if (x%y==0) { break; } If x is divisable by y, then break from the current iteration of the loop. if (x==y) { printf("%d\n",x); } If x is equal to y, print the value of x.
How did you write it, if you don't understand how it works?
This is very helpful. Thank you.
That has made things clearer. Thank you.
I had a vague idea of why it works I just wanted a good explanation from some people who know what they're talking about.
Got it. Thanks for your help.
This is really useful. Thanks for taking the time to type it out.
you're better off learning the language from online material IMO. http://programming-motherfucker.com/become.html
This is not a `C` question, this is an `Algorithms` question. The part you are concerned with is a check to see if the nested `for` loop finished without executing the `break` statement. This is because the nested for loop terminates after `y++` where `y = x-1`, resulting in `y == x` deterministically unless `break` happens. According to the `C Standard`, `y++` (also known as `expression-3`) is **always** executed following the loop body. &gt; `The expression expression-3 is evaluated as a void expression after each execution of the loop body.` [Source](http://www.iso-9899.info/n1570.html#6.8.5.3) 
That is C++, not&amp;nbsp;C.
This is common in library code. It is a macro that expands to non-standard, platform specific decorations of the function. It's not a return type; it declares symbol linkage, visibility, dll export/import status, etc. Essentially it tells you "this declaration is part of the SQLITE API."
Thanks for the EILIF, I haven't got to macros yet since I still hose code I do every line of. 
a bst data structure isn't hard to make, and traversing the tree level order would need a queue.
This is asking you to construct a binary search tree. This is a standard data structure; you can find lots of information about it on the Internet or in any data structures book. The trick here is printing the elements of the tree in level order. This ordering of the elements doesn't seem to fit very well with the standard recursive techniques for iterating over the elements of a binary search tree. One way to do it (not the most efficient) is something like this: int print_level(struct node *n, int target_level, int current_level) { if (n == 0) return 0; if (current_level == target_level) { printf(" %d", n-&gt;data); return 1; } return print_level(n-&gt;left, target_level, current_level + 1) | print_level(n-&gt;right, target_level, current_level + 1); } void level_order(struct tree *t) { for (int level = 0; print_level(t-&gt;root, level, 0); ++level) continue; } EDIT: A better way is to use a queue, as /u/PhyterJet has suggested.
Storing a tree in a flat array, is probably the most efficient way to build a tree, but slower for traversals and prone to off by one errors. http://webdocs.cs.ualberta.ca/~holte/T26/tree-as-array.html A better (and more verbose) approach would be to use a struct to represent a single bst node. struct bstnode { struct bstnode *left; struct bstnode *right; int key; }; I'm not familiar with your skill level in C, so it's up to you. You can continue with the flat array approach, which is probably what the contest expects, or you can to adopt a more flexible approach. Either way I may be able to give some advice.
Those comments are extremely misleading. There's no "addition of pointers" going on here. The pointers are dereferenced (note the asterisk before the variable name), and the *values they are pointing at* are added. Same for the multiplication and division ones. The "subtraction of pointers" that's done in those `printf` lines kind of makes sense, but usually only if both pointers point into the same array, as is the case here. The result is the difference between the indices into the array, i.e. 6 - 1, or 5. 
It would really help if you could tell us what output you were expecting, and what output you're actually getting.
You aren't doing any the things that the text is referring to. `*i + *j` is not adding two pointers, it's adding what those two pointers point to. Similarly, `*j * 2` means "the thing j points to times 2." And so on. What is forbidden is expressions like `i + j`, `j * 2`, or `j / 2`. Anything with `*i` or `*j` is not operating on a pointer, because the pointer is being dereferenced, and you're working with what it points to, which is an integer that does support those things. 
Thanks to you, now I understood what the author meant. 
We aren't just going to do your homework for you.
That was not my intention but since that's what you think, I will delete the post.
What was your intention? You just pasted the text of a homework assignment. If you have a specific question, then ask a specific question. Show us what you have so far, and explain where you are stuck. But don't just paste a bare homework assignment and expect us to tell you how to do it.
See the differences: #include &lt;stdio.h&gt; int main(void) { int *pnt; //pointer declaration char *cpnt; int chme = 25; char *chmes = "This is a string\n"; printf("%d\n", chme); printf("%s\n", chmes); pnt = &amp;chme; //"changing" the value by pointing to the value CHANGED *pnt = 700; // and giving it a new value cpnt = chmes; // CHANGED cpnt = "You dun got a new string!"; // CHANGED printf("%d\n", *pnt); printf("%s\n", cpnt); // CHANGED return 0; } 
&gt; *pnt = chme; //"changing" the value by pointing to the value Your comment is wrong here. That is not what that line does. The expression `*pnt` refers to the `int` value stored at the memory address to which `pnt` points. If you are assigning to `*pnt`, then you are storing a new `int` value in that memory address. So the assignment `*pnt = chme` copies the `int` value stored in the variable `chme` and stores it in the memory address to which `pnt` points. But what memory address does `pnt` point to? Who knows! The pointer `pnt` is uninitialized—you have not previously assigned a value to `pnt`. So you are attempting to dereference an uninitialized pointer here, which yields undefined behavior, which means that you have absolutely no guarantees about the behavior of any part of your program. If you want to change the value of the pointer `pnt` itself (that&amp;nbsp;is, change the memory address to which `pnt` points), then you need to be assigning to `pnt`, not to `*pnt`. You want to store the memory address of the variable `chme` in the pointer variable `pnt`, right? To get the address of a variable, you use the `&amp;`&amp;nbsp;operator. So you want this: pnt = &amp;chme; === &gt; *cpnt = *chmes; You have the same problem here. This is not what you mean to say. You are attempting to dereference the uninitialized pointer `cpnt`. === &gt; *cpnt = "You dun got a new string!"; The types don't match here. The value of `*cpnt` is `char`, because `*cpnt` means the value that the pointer `cpnt` points to. But the right-hand side of the assignment does not have type `char`. It has type "array of `char`," which will decay to a pointer to `char` (i.e., the type `char *`) when you use it as a value. You mean to say cpnt = "You dun got a new string!"; But keep in mind that this assigns the pointer `cpnt` the address of a *string constant*. The type of `cpnt` is `char *`, not `const char *`, so this assignment does not respect `const`-ness, which is a sign of a logic error. Attempting to modify the string constant by assigning to `*cpnt` will result in undefined behavior, because it is illegal to attempt to modify a string constant. === &gt; printf("%s", *cpnt); The `%s` specifier expects a corresponding argument of type `char *` (i.e., pointer to `char`) that points to the first character of the string. You are providing the argument `*cpnt`, which has type `char`. That's the wrong type. You mean to pass the pointer `cpnt`, not `*cpnt`, which is the thing that the pointer `cpnt` points to.
Ok I had a feeling I was forgetting something.
Dang. Thanks. I guess I was thinking that that would tell it to take integers separated by a return.
well it does have some problems though now i read it back, the extern char iobuffer isn't needed and for read_word you'd have to make sure the provided char array is of MAXIOBUF length (maybe using ret[MAXIOBUF] as a parameter would be better... fgets is really needed for user input and if you want to redo input from a user i think though. fgets just reads input including a newline and sscanf is scanf but with the string from fgets as input. When you redo scanf only with a goto or something it leaves newline and other things it didn't parse and as a result your input might go into an infinite loop or have unexpected input. e: see the manpages for fgets and sscanf btw, they provide a lot of useful information, also of course, feel free to ask what you don't understand.
Your program does not have a `main` function. Your code *should* prompt for input 8 times because of the bogus trailing `\n` in your format string. However your screenshot only shows 7 prompts. My only conclusion can be that you didn't post your real code, and the first loop in Forecast only does `i &lt; 6`. Perhaps your program also does input before entering `Forecast` and you didn't post that code . But even if that code left integer junk or whitespace in the buffer, leading to only 7 prompts, it would not produce the result shown in your screenshot. The junk would be in the first position, not the last position. Please post a *complete program* that shows the problem. 
This is the meat of the code. I have another file in the same VS project with a main in it, and has the forecast function forward declared. That's how I run it. I think I did end up editing it as I entered it here, so that's probably why. Sorry for the confusion. This post is solved however. The top comment was right. mods should include [solved] flair.
so right
Damn, did i missed it ? :D The idea of study group is really neat.
He's using `scanf_s`, which is Microsoft's "secure" version of `scanf`. I changed it to regular `scanf`, compiled it with GCC, and ran it. In order to get it to accept the 7th input, I have to enter some non-whitespace, otherwise it continues reading input forever. Once I do, it parses the 7th input and generates the correct result. What I can't figure out is why MS's `scanf_s` is showing the behavior OP is seeing.
You didn't check the return value from `scanf_s`. If you had, you probably would have gotten a 0 or EOF, indicating that the last value wasn't assigned.
Why not use the [PGP word list](https://en.wikipedia.org/wiki/PGP_word_list), which is designed to use known words that are easily pronounceable and distinguishable?
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**PGP word list**](https://en.wikipedia.org/wiki/PGP%20word%20list): [](#sfw) --- &gt; &gt;The __PGP Word List__ ('[Pretty Good Privacy](https://en.wikipedia.org/wiki/Pretty_Good_Privacy) word list', also called a __biometric word list__ for reasons explained below) is a list of [words](https://en.wikipedia.org/wiki/Word) for conveying data [bytes](https://en.wikipedia.org/wiki/Bytes) in a clear unambiguous way via a voice channel. They are analogous in purpose to the [NATO phonetic alphabet](https://en.wikipedia.org/wiki/NATO_phonetic_alphabet) used by pilots, except a longer list of words is used, each word corresponding to one of the 256 unique numeric byte values. &gt; --- ^Interesting: [^Pretty ^Good ^Privacy](https://en.wikipedia.org/wiki/Pretty_Good_Privacy) ^| [^PGPfone](https://en.wikipedia.org/wiki/PGPfone) ^| [^Public ^key ^fingerprint](https://en.wikipedia.org/wiki/Public_key_fingerprint) ^| [^Phil ^Zimmermann](https://en.wikipedia.org/wiki/Phil_Zimmermann) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ckydpml) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ckydpml)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I think we'll need your code. 
Thanks for you for your help. I saw this when you posted but I forgot to reply. I got it all figured out though. Cheers
Sorry, it was in my link but here it is here: Here are the pastebins of each file that I've modified: Makefile: http://pastebin.com/T1LT0Y1Q Matrix.c: http://pastebin.com/8kqrNBQQ keymap_common.h: http://pastebin.com/yG2c6jV7 keymap_poker: http://pastebin.com/efQ6RRGs I used [this](http://deskthority.net/workshop-f7/how-to-build-your-very-own-keyboard-firmware-t7177.html) guide to determine which files to modify.
&gt; after I compile the header file Header files in C don't get compiled. When you compile a .c file, first the CPP (C Preprocessor) runs on the file, and does some textual changes. Whenever it encounters a `#include` statement, it replaces that line with the entire contents of the mentioned file. Once it's done, the result is a single file (usually tens of thousands of lines long) that contains no statements starting with `#` (all of which are CPP statements). Then that file is compiled as code. &gt; What I'm trying to do is create a header file with a function to use in another program This isn't what header files are for. Function definitions cannot live in header files, because if the header file is included from multiple .c files in the same program, you'll have multiple definitions of the function, which is generally not allowed. Instead, the body of the function should live in a .c file, and the .h file contains just the prototype. In your case, that's just `int getCost(double *cost, Flower flower, Color color, Arrangement arr);`. Note the semicolon at the end, instead of a function body. Your typedefs will also need to live in the .h file, otherwise the function prototype won't be legal. There is some other boilerplate contents that need to go in the .h file. Because they're processed with text subtitution, it's possible for a file to be included twice. If that happens normally, you'd end up with duplicate definitions within the same file, which is illegal. So header files always wrap their contents with something like #ifndef __MYHEADER_H__ /* if we haven't included this file before */ #define __MYHEADER_H__ /* then define a symbol so we know we have */ /* contents of header file */ #endif
Errors aside, I had a hell of a time figuring things out because your variable names are confusing. Even though it's just a dummy function to illustrate pointer usage, that's no reason to use obtuse names. `chme` and `chmes` were particularly odd. `intPtr` and either `strPtr` or `charPtr` would have been a little easier to follow than `pnt` and `cpnt`. Likewise, `intVal` and `strVal` instead of `chme` and `chmes`.
Alright, that makes sense. Following what you say, this is what the flowers.h header file should look like, correct? #include&lt;stdlib.h&gt; #ifndef typedef enum { RED = 1, WHITE = 2 } Color; #ifndef typedef enum { ROSES = 1, LILIES = 2, DAISIES = 3} Flower; #ifndef typedef enum { BOUQUET = 1, VASE = 2} Arrangement; #ifndef typedef enum { NO_ERROR = 0, INVALID_ARGUMENT_ERROR = 1, UNAVAILABLE_SELECTION_ERROR = 2, NULL_POINTER_ERROR = 3} Error; #define int getCost(double *cost, Flower flower, Color color, Arrangement arr); #endif To which then I'll do #include "flowers.h" at the top of the program that will use the getCost function?
Please indent your code with four spaces to make it appear in monospace. Your code is barely readable as-is.
No. You're really learning two different languages here: C, and C Preprocessor. The verb "to define" means different things in each one. In C, "defining" something means a typedef, or a function body. (Or setting a variable, but that's not relevant to this question.) In C Preprocessor, "defining" means using `#define` to create a symbol which will be textually expanded. So when you wrote #define int getCost(double *cost, Flower flower, Color color, Arrangement arr); what you actually did was created a symbol `int` which will be textually replaced with `getCost(double *cost, Flower flower, Color color, Arrangement arr);`. This will have a disastrous effect on your program. :-) What your header file needs to look like is more like this. (I'm not giving you the whole thing, just enough to convey the idea.) #ifndef __FLOWERS_H__ #define __FLOWERS_H__ /* Protect header file from being included twice */ /* Typedef some variable types */ typedef enum { RED = 1, WHITE = 2 } Color; /* Function prototypes */ int getCost(double *cost, Flower flower, Color color, Arrangement arr); #endif The point about the #ifndef at the top is that the first time the header file is included, the symbol won't be defined, so we take the #ifndef. The first thing we do is #define the symbol. If the header file were included a second time, we'd check the #ifndef again, but this time the symbol is defined, so we skip the contents of the #ifndef. &gt; To which then I'll do #include "flowers.h" at the top of the program that will use the getCost function? Yes.
Programming languages are not like human languages. They are very strict about syntax and grammar. They are also interpreted by computers, not humans. You *must* drill in to your head that when there's a syntax error, 1. *Nothing* that follows the syntax error can be trusted. It's not uncommon for dozens of reported errors to be caused by a single mistake. Fixing that one mistake fixes everything after it, because now the syntax isn't broken. 2. The compiler *cannot* always tell you what the real problem is. In this case, you're using a #define, which means the compiler doesn't even see it. It's done using textual substitution by the C Preprocessor before the actual compiler ever looks at the file. What the compiler saw was not if (machinePressure &lt;= MIN_POSSIBLE_PRESSURE) { but was actually if (machinePressure &lt;= 10;) { because the file had been run through the C Preprocessor. Given that input, the compiler was correct; there was a syntax error right where that semicolon was. The problem is, it didn't know the semicolon came from a macro. That's something that you, the programmer, need to figure out using your Mark I Eyeball.
&gt; a non-byte-aligned series of 9-bit IDs with data following each one that has a bit length dependent on the ID I don't see how your structure would work for this. Only the first ID in the file is guaranteed to be byte-aligned. After that, it all depends on the data that came before it.
Can't help with take home tests. That is cheating.
This is actually a pretty non-trivial question to answer. See [this](http://stackoverflow.com/questions/199333/best-way-to-detect-integer-overflow-in-c-c) stack overflow discussion for some possible solutions. That said, I personally think the best solution is to directly access the overflow bit of the host cpu with some inline assembly (this code was taken from the article above... it's not very good, but it should give you an idea). This will be the fastest and "most correct" solution IMHO. #define overflowflag(isOverflow){ \ size_t eflags; \ asm ("pushfl ;" \ "pop %%eax" \ : "=a" (eflags)); \ isOverflow = (eflags &gt;&gt; 11) &amp; 1;} This code pushes the x86 flags register onto the stack and pops it off into eflags. The overflow bit can then be trivially accessed. It should also be noted that overflow and underflow are *undefined* by the C spec. In practice, though, you should be fine.
You should keep in mind that there's no guarantee the overflow flag will actually get set, since there's no guarantee any overflow will occur. For example, in this case 'a' and 'b' are 8-bit ints, but the compiler could turn them into 32-bit ints (If for whatever reason it's faster on that CPU or architecture), avoiding the overflow while still giving the wrong result, and it would be within the standard.
I don't know what soapbox you are on, but you need to get off it. I didn't try running it: I took advantage of my "superiority" as you put it, and realized that it would fail compilation due to there not being a `main` function. I also tried adding the code `int main() { Forecast(); }`. As you say, it is perfectly obvious that 7 iterations of the loop run. However, it is also perfectly obvious to me that the user must enter 8 integers (or enter non-integers) for the loop to complete. (And running the program bore this out). And the 7th integer entered appears under the "SUN" in the output. I guess you either made a different modification to me, or you have the observation skills of a mole. OP's screenshot only shows 7 integers entered, and it shows garbage in the SUN column. Therefore either his code consists of something other than the posted code followed by `int main() { Forecast(); }`, or his compiler is buggy. (Or he falsified his screenshot, but I'd give him credit for not doing that). My goal in posting is to solve the OP's problem . In either case (code is different, or compiler bug), *it is required to see the exact code that OP is compiling*. This is a basic fact. Of course I could *guess* (as i did in my original post), but then my answer would also have the status of being a guess. **Update**: Seeing another post of yours: &gt;In order to get it to accept the 7th input, I have to enter some non-whitespace, otherwise it continues reading input forever. Once I do, it parses the 7th input and generates the correct result. It seems it did penetrate your skull that OP's screenshot does not match his code. Yet you still think it is a fine idea to get stuck into me because I request to see the real code. Kindly butt out and let the people who are trying to help try to help. 
OK, glad you have solved it. The change to the format string would not have any bearing on what appears in the last output column though, so it seems likely that the code you ended up posting wasn't the same code that generated the screenshot. For future reference it's a good idea to post a complete program so that someone else can try to reproduce what you are seeing, without having to guess at the code not shown. More often than you might think, a problem is in code that wasn't posted. 
Very true. Thanks for pointing that out.
sorry chme stood for change me and chmes stood for change me string. I guess at the time I wasn't thinking of how that could be confusing, sorry.
Well, there are 2 issues here: 1. Under what condition does the overflow flag get set? 1. What happens to the value under the overflow condition; for example, does the value saturate, or wrap around? Unfortunately, you haven't given these parameters, so it isn't possible to work out if your implementation is correct.
This solution is not portable. I disagree with you in that it is the "most correct" solution. The goal of writing a CPU emulator is to *abstract* from a machine, not to depend on a machine's features for me.
it's for the ids.
With a function
Your code looks fine to me. Let the compiler take care of the optimizing and be done with it. The compiler probably recognizes the idiom since it's such a typical case. Revisit the function later if performance matters. Personally, I'd remove the unused `tmp` variable and have the function return a boolean. To check correctness, code up a test harness that checks the whole 256 x 256 input space against the expected outcome. It will give you confidence that your code is bug free, it will let you experiment with different optimizations, and it will let you run timing/cache benchmarks.
As melevan said, this place isn't here to do your homework for you. Secondly, C and C++ aren't the same. There is a sub, /r/cpp, but the same idea applies.
Here's some code I ran to check correctness for your two functions: #include &lt;stdio.h&gt; typedef unsigned char byte; typedef signed char sbyte; int sub_overflow_a(byte a, byte b) { int sdiff = (sbyte)a - (sbyte)b; return (sdiff &lt; -128 || sdiff &gt; 127); } int sub_overflow_b(byte a, byte b) { int sdiff = (sbyte)a - (sbyte)b; return (sdiff != (sbyte)sdiff); } int main () { int a, b; int x, y; int expect, actual; for (a = 0; a &lt; 256; a++) { for (b = 0; b &lt; 256; b++) { x = a - 128; y = b - 128; expect = ((x - y) &lt; -128) || ((x - y) &gt; 127); actual = sub_overflow_a(a, b); if (expect != actual) { printf("fail a: %d - %d: got %d, expected %d\n", x, y, actual, expect); } actual = sub_overflow_b(a, b); if (expect != actual) { printf("fail b: %d - %d: got %d, expected %d\n", x, y, actual, expect); } } } } Much to my surprise, this code prints lots and lots of failures. Am I messing up my typecasting?
check out the sample program [found here](http://www.cquestions.com/2010/07/compound-interest-program-in-c.html). It should be very easy to modify that for your needs.
I'd assert the goal of a CPU emulator is to emulate a target CPU on a host system as fast as possible. While there are merits to portability, unnecessary operations on critical paths in your ALU is going to destroy performance... Especially if the thing you're computing is implicitly computed by the CPU for you. Depends on what you're going for :-P
Why are you passing `a` and `b` to the overflow functions? I am using two's complement, not a biased representation.
Because your functions take unsigned bytes as input, which implies a range from 0..255.
Because the registers are represented as values of type `byte`, which are interpreted as signed integers in two's complement representation for the sake of the overflow flag. Thus, [0..127] maps to [0..127] and [128..255] maps to [-128..-1]. Your code could compute `x` and `y` like this to get the conversion right: x = a &gt; 127 ? a - 256 : a; y = b &gt; 127 ? b - 256 : b; or, equally acceptable if your system uses two's complement representation with no pad-bits (most of them do): x = (sbyte)a; y = (sbyte)b; The cast to `sbyte` will just reinterpret the bit-pattern because both types have equal size. The second, implict cast to `int` sign-extends the `sbyte` value into an integer since both are signed.
I think you should write the entire procedure in assembly to be safe, like this (for i386 using cdecl): # C function signature: # int sof(byte a, byte b); # computes signed overflow .text .type sof,@function .globl sof sof: movzbl 4(%esp),%eax sub 8(%esp),%al seto %al ret The movzbl is used to zero-out the upper bits of %eax so we don't have to clear them out before issuing the `seto` instruction.
Signed integer overflow is undefined behavior in C, so you can't do `(sbyte)a - (sbyte)b`. You need to do the subtraction in a wider type that can't overflow, or else use unsigned types and adjust accordingly. 
Overflow occurs only when the inputs have a different sign, but the result has the same sign as the second operand. (This means that `(+) - (-)` resulted in `(-)` or `(-) - (+)` resulted in `(+)`.) const byte total = (a - b) &amp; 255; overflow = ((sbyte)(a^b) &lt; 0 &amp;&amp; (sbyte)(b^total) &gt;= 0); You might be able to fold the two `&amp;&amp;` operands, but the compiler should be able to figure that out.
That was pretty much my goals for a Motorola 6809 emulator I wrote (https://github.com/spc476/mc6809). The plain C version runs *much* faster than the actual CPU ever ran, so while it's not as fast as it could be, it's fast enough. You can check out the code for the 8-bit add (https://github.com/spc476/mc6809/blob/e9171a14194831a77e5b02b143f586a193fa9383/mc6809.c#L3338) to see how the conditional flags are set. 
It's actually trivial to answer - upcast to a larger type, do the operation, and check for the overflow in the larger sized register. That's exactly the same way you'd do it in hardware, only your overflow bit from the carry out of the adder might not actually be directed towards a larger register but instead some other register or just a general hardware exception handler.
 int table[5][10];
This initialises a 2d array 5*10 int arrayName[5][10]; You can then use a loop or something to put the data in.
(that's not actually initialized at all; its contents will be whatever was already there in RAM.)
yeah, good point. I'm not very good at C, iirc arrayName would be a pointer to some memory location, and you've got 50 * ints of memory set aside for you that the compiler won't use?
The syntax you are using is not C. It is more akin to C++ with the use of the `new` operator, but it is not that either as I don't think `int[,] xxx` is valid. In C the size of the array comes after, not before the variable, like `int arr[]` for a single dimensional array. Add another set of brackets for another dimension, noting that the size must be specified for all but the first dimension of arrays (otherwise the C compiler would not know how to divide the memory). If you need your array to be dynamic, typically one would use `malloc` in C, not new. But it does not seem that you do, so simply specify the size in the declaration of the array (i.e. inside the brackets). You can also make "arrays" from indirect pointers, like `int * arr` or double indirect pointers for multidimensional arrays like `int ** arr` or combine the two, like `int * arr[]`. Note their are subtle diffrences between these declarations which I will not describe in detail beyond saying that pointers do not initially (typically) point to anything (like how the `a` in the declaration `int a;` contains garbage until set) until you give it something to point to, like the result of a call from `malloc`.
pretty sure it's ascii to float (http://www.thinkage.ca/english/gcos/expl/c/lib/atof.html)
I create a 1d array, then do the math to get into it. Ive always found thats the easiest way to deal with things. 
I think you don't understand C. If you perform arithmetic on an integer type narrower than `int`, the compiler will implicitly cast it to `int` before performing the arithmetic. Thus, `(sbyte)a - (sbyte)b` actually behaves like `(int)(sbyte)a - (int)(sbyte)b` which is exactly what I need—no overflow occurs here.
Yep. Technicality: might be more if the compiler thinks things need to be padded.
That's actually C# syntax -- despite the familiar name, they're almost totally different except for rough appearance and very basic syntax.
Please indent your code with four spaces so it appears in monospaced font. This makes your code much easier to read.
Without good, strict moderation, it'll turn just into that, too.
Yeah. I've submitted [a request](https://www.reddit.com/r/redditrequest/comments/2i6fyx/request_for_rcprog_want_to_turn_it_into_a/) to become moderator, and I will delete uninteresting problems as they're posted. See [this post](https://www.reddit.com/r/Cprog/comments/2i6m2g/meta_help_me_on_rredditrequest_to_become/) for more details about my intentions as moderator.
Why did you misquote me? I wrote "... for me" and you spin that into abstraction being the general reason. I have the goal to abstract from the machine, which I stated clearly. I understand that others have other goals, but I never claimed anything in this regard.
In fact there is already /r/C_Programming and /r/C_Language. Now it is also /r/cprog. I think, it should be better to leave only one of those subreddits and create a new with a name like a "C_Learning", where all those homework questions should be. Any thoughts to do that? 
Actually, there is: /r/c_questions. But don't trip over the tumbleweed over there.
I think the "What is computer ?" type questions will always be dumped in the more popular subreddits, and trying to create containment zones is probably futile. Smaller subreddits are easier to moderate and are protected from cheese-heads by their obscurity.
Also if you're using GCC, you can use this instead of the 3 line header guard: http://en.wikipedia.org/wiki/Pragma_once
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Pragma once**](https://en.wikipedia.org/wiki/Pragma%20once): [](#sfw) --- &gt; &gt;In the [C](https://en.wikipedia.org/wiki/C_(programming_language\)) and [C++](https://en.wikipedia.org/wiki/C%2B%2B) programming languages, __#pragma once__ is a non-standard but widely supported [preprocessor directive](https://en.wikipedia.org/wiki/C_preprocessor) designed to cause the current source file to be included only once in a single compilation. Thus, #pragma once serves the same purpose as [#include guards](https://en.wikipedia.org/wiki/Include_guard), but with several advantages, including: less code, avoidance of name clashes, and sometimes improved compile speed. &gt; --- ^Interesting: [^C ^preprocessor](https://en.wikipedia.org/wiki/C_preprocessor) ^| [^Include ^guard](https://en.wikipedia.org/wiki/Include_guard) ^| [^Directive ^\(programming)](https://en.wikipedia.org/wiki/Directive_\(programming\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ckzmu64) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ckzmu64)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
[Pointer to an Array in C](http://www.tutorialspoint.com/cprogramming/c_pointer_to_an_array.htm)
But then what happens when the same thing happens to that sub? Go nomadic? Making it "obscure" and otherwise hard to find can really fragment a community and deteriorate content.
If you want the sub to be taken seriously you might want to pick a less immature subtitle for it than "touching your bits". What does that even mean?
That's true, I think there are trade-offs in the way reddit is structured and finding a balance can be tough. But when poor quality posts reach a certain volume, [the bad drives out the good.](http://en.wikipedia.org/wiki/The_Market_for_Lemons) 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**The Market for Lemons**](https://en.wikipedia.org/wiki/The%20Market%20for%20Lemons): [](#sfw) --- &gt;__"The Market for Lemons: Quality Uncertainty and the Market Mechanism"__ is a 1970 paper by the economist [George Akerlof](https://en.wikipedia.org/wiki/George_Akerlof). It discusses [information asymmetry](https://en.wikipedia.org/wiki/Information_asymmetry), which occurs when the seller knows more about a product than the buyer. A [lemon](https://en.wikipedia.org/wiki/Lemon_(automobile\)) is an American slang term for a car that is found to be defective only after it has been bought. Akerlof, [Michael Spence](https://en.wikipedia.org/wiki/Michael_Spence), and [Joseph Stiglitz](https://en.wikipedia.org/wiki/Joseph_Stiglitz) jointly received the [Nobel Memorial Prize in Economic Sciences](https://en.wikipedia.org/wiki/Nobel_Memorial_Prize_in_Economic_Sciences) in 2001 for their research related to asymmetric information. Akerlof's paper uses the [market](https://en.wikipedia.org/wiki/Market_(economics\)) for [used cars](https://en.wikipedia.org/wiki/Used_cars) as an example of the problem of quality uncertainty. It concludes that owners of good cars will not place their cars on the used car market. This is sometimes summarized as "the bad driving out the good" in the market. &gt;==== &gt;[**Image**](https://i.imgur.com/TLd5woP.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:Used_car_dealers_on_the_Industrial_Estate_-_geograph.org.uk_-_766208.jpg) - *Akerlof's paper uses the market for used cars as an example of the problem of quality uncertainty. It concludes that owners of good cars will not place their cars on the used car market. This is sometimes summarized as "the bad driving out the good" in the market.* --- ^Interesting: [^George ^Akerlof](https://en.wikipedia.org/wiki/George_Akerlof) ^| [^Information ^asymmetry](https://en.wikipedia.org/wiki/Information_asymmetry) ^| [^Adverse ^selection](https://en.wikipedia.org/wiki/Adverse_selection) ^| [^Lemon ^\(automobile)](https://en.wikipedia.org/wiki/Lemon_\(automobile\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ckzunng) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ckzunng)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
When I'm made moderator by the Reddit admins, I will direct people to /r/C_Programming for uninteresting questions and help with C programming. If /u/gthank wakes up and starts paying this sub some attention and decides he doesn't want questions here anymore, I will probably direct them to /r/c_questions (or maybe just StackOverflow; Reddit sucks for that sort of thing). But, yes, they'll keep popping up anyway because some people are really stupid. (ps: it's /r/cprog, not /r/C_prog)
I agree that larger subreddits will attract idiots anyway. I recognize that the subreddit will require ongoing attention to delete basic questions: I'm willing to commit to that. If I falter or if the sub grows to unmanageable activity, I will make someone else moderator as well, or hand it over entirely. I'm not afraid about /r/cprog growing larger -- if it's in good hands, it will be a great thing.
That page is wrong. You can't just assume some random page on the internet is gospel. "An array name is a constant pointer " - NO 
There's already /r/learnprogramming and people have no clue to post there, so we get an endless stream of BS. The problem is very simple: without moderation, this place turns into homeworkfest, period. If someone's willing to step up and take the moderator gauntlet, I don't care about the name of the subreddit.
could you let me know where I could find some notes on this? because I'm only repeating what I've learnt. In C when you pass an array into a function you don't even need to return it because the 'array' that you pass into it actually goes to that memory location where the information is stored, that's what I thought.
The C standard is the ultimate reference. You can also read high-rated questions on StackOverflow, or [the c.l.c. FAQ](http://c-faq.com/aryptr/index.html). C does not allow to pass arrays by value, and when you try, the array value is *converted* to a pointer value. This is the same sense as when you write `int x = 5.3;`, the double value 5.3 is converted to an int value `5`. 
104583 / 100000 = 1 --- 104583 % 100000 = 4583 4583 / 10000 = 0 ---- 104583 % 10000 = 4583 4583 / 1000 = 4 ---- 104583 % 1000 = 583 583 / 100 = 5 --- 104583 % 100 = 83 83 / 10 = 8 --- 104583 % 10 = 3 
Alternatively, `buf[0]`, `buf[1]`, `buf[2]` and so on.
Ah yes forgot about modulus. Thanks :)
Are you a freshman? If so, I'd say it is quite hard. Otherwise, I'm not sure, it is rather manageable. Assuming you already went over these things in the class, and had similiar homeworks, it wouldn't be too hard to hack something together within 90 minutes. Though complaining about the exam won't change anything :D You should talk with your teachers to get some tips and study more. Hope it will be better next time. :)
We know the basics of C from the past semester and now we are learning the use of pointers (This is the second test, we all did pretty well in the first one), the problem is they tried to teach us a lot about lists in 10-15 hours of class (100% theory, we don't use computers in this subject) so yeah, also the first and third problems where easy but the second is the one that noone could answer (seriously, 0 out of 75 students)
Yeah, it is about data structures (sorry, i'm kinda used to think they are teaching us C when is actually data structures implemented in C) 
Are you a time traveler from 1989? That was the last year Turbo C was updated. What you're writing is not C anymore, so you're not learning C by being in this class. I would just do it on your own. You've got the internet.
Not C? What is it then?
Try using an open source compiler like gcc or clang. Mingw uses a port of gcc anyway. When you are first learning how to code I recommend forgoing and IDE all together and using a good text editor with syntax highlighting like notepad++, vim or emacs. It will force you to learn the fundamentals without the crutch of an IDE and make you a better coder.
Well, it's Borland Turbo-C for MS-DOS, I guess. You can find the definition of C here: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf They just don't have conio.h or BIOS calls anymore, it's too bad really.
We learn the use of pointers in C and also an introduction to data structures, so two birds and one stone. I believe we start with java the next semester
You could read the filename with scanf and then use strcat to append the file type to the end of the string and then pass the completed filename to fopen
Alright, would it be like this to pass the file name? file=fopen(String,"method");
thanks! dude now I'm using emacs with the borland compiler meanwhile I'm in that class. I can't leave it its mandatory.
Once you get the concept of linked lists, it's not very hard at all. Problem is that linked lists are one of those concepts that can be difficult to wrap your head around even though they aren't that complicated (and it's really easy to explain them poorly). So if people don't understand the concept of linked lists, then it will be a bitch. 
keeping track of pointers is the most difficult part of C. Once you've got that down, the rest of it is trivial.
Are you familiar with any data structures using nodes? Linked lists would be the simplest. Binary trees would be another. Understanding those would give you some of the basic building blocks - allocating nodes using malloc, connecting the nodes up using pointers, traversing the data structure by following pointers to nodes. Once you have all that under your belt, it shouldn't be too hard to implement the trie. In your case it would be a tree where each node has 26 children (one child corresponding to each letter a..z). 
Thanks for the advice, pointers are going be the only thing i'll do on weekends
Wikipedia [says](http://en.wikipedia.org/wiki/Borland_Turbo_C#Freeware_release) they did rerelease a freeware version in 2006.
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 3. [**Freeware release**](https://en.wikipedia.org/wiki/Borland_Turbo_C#Freeware_release) of article [**Borland Turbo C**](https://en.wikipedia.org/wiki/Borland%20Turbo%20C): [](#sfw) --- &gt; &gt;In 2006, Borland's successor, [Embarcadero Technologies](https://en.wikipedia.org/wiki/Embarcadero_Technologies), re-released Turbo C and the MS-DOS versions of the Turbo C++ compilers as [freeware](https://en.wikipedia.org/wiki/Freeware). &gt; --- ^Interesting: [^Borland ^C++](https://en.wikipedia.org/wiki/Borland_C%2B%2B) ^| [^Turbo ^C++](https://en.wikipedia.org/wiki/Turbo_C%2B%2B) ^| [^Borland ^Turbo ^Debugger](https://en.wikipedia.org/wiki/Borland_Turbo_Debugger) ^| [^Borland](https://en.wikipedia.org/wiki/Borland) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cl0pffz) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cl0pffz)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I would really recommend MinGW (it's based on GCC, which is an active and widely used open-source compiler). Using &lt;conio.h&gt; is not recommended, as it is not standard C and is not guaranteed to be present on any given system. If you absolutely **have** to use &lt;conio.h&gt;, I **think** you can use it from MinGW if it is present.
Yeah, I'm familiar with Java and I know how to implement linked lists and trees. The dictionary file only has a few words in it, so at most it would start with 26 children I believe. An example of a dictFile: //foo)(|foOd,.DAn And an example of a dataFile: DAn likes%% foo when,.FOOD,,,Food So to my understanding, I would read in each character from the dictFile first like this: While current character isAlpha(), add it to the trie, and move to the next character. If it isn't, then I've reached the end of a word, so I mark the isWord part of the trieNode as true, and create a counter for that word (for the scanData function later). The issue is, as I'm adding, how to I differentiate between new words? So I run the program, '/' is not alpha, move to next char. '/' also not alpha, move to next char. 'f' is, add to trie. Trie looks like this: . | ( f ) next char, 'o'. Add to trie. . | ( f ) | ( o ) next char, 'o', add to trie. . | ( f ) | ( o ) | ( o ) OK, here is the issue. Next char isn't a letter, so I've reached the end of my first word. The confusion is in the trie. I guess in the struct I give each node an isWord portion, and in this case, I mark last node as true? I'm not too sure. I feel like my understanding of the trie is incorrect because it stops making sense here. 
If 0 out of 75 students were able to answer the second question, I'd say that's a teacher failure, not a student failure.
What's wrong with the freeware Microsoft stuff? C++ or C#?
Er. Even for compilers from that company, that's 25 years out of date. It might be time for you to ask the dean for an appropriate teacher.
It's C. Original speaker has confused that a C compiler can ship with libraries outside C with that somehow it's magically not C anymore because he says so.
Like I said above, My teacher WANT you to use a borland compiler. I know that this doesn't applies to the standards this days, but I need to pass the class this is only until december when the semester ends.
Well, if your interest is passing classes, rather than learning skills that have been relevant after Reagan left office, then you're probably doing the right thing. But, on your way out, please consider asking the dean to provide a teacher with relevant skills for future students, who might actually be interested in learning the material, so that the material they learn is relevant.
These are rudimentary questions. Merging two linked lists means setting the start and end pointers for the two lists' ends into one another. Someone with no highschool or college training and a year of experience could do this test in about five minutes. This was extremely easy. You're calling your teacher an asshole because you don't want to face the work you didn't do.
&gt; We know the basics of C from the past semester Apparently not.
Where does that number come from?
It's easy to say things like that. It's much harder to go to the dean, like an adult, and handle the problem.
OP's comment right before mine.
I use conio.h all day with mingw
&gt; 5 minutes lol
What's funny about that? Did you look at the actual problems?
Buddy, you just failed a test other people can do in five minutes, while downvoting people answering the question you asked politely because you don't like the answer they gave you. The thing you're saying you can't handle - the thing you're thanking other people for advice about - is pointer replacement. It's ***literally*** swapping two values. C doesn't get a whole lot more basic than that. If you downvote people for telling you the truth when you ask, and argue that you know the basics while failing a test about the basics, you're preventing yourself from seeing that you're just not putting in the effort, and that after more than a semester you can't swap two pointers. Here's a hint. Computer programming is full of a lot of really talented people that didn't go to college. They're not going to care one bit about your time in college, and they're going to out-compete you for those surprisingly rare entry jobs. If you keep acting like this, when you get out of school, you're going to hit a wall where you can recite order of complexity, you can talk about which sorting algorithm to use at any given time, you can opine at length about the benefits of functional versus imperative versus logical versus declarative. And you can't do fizzbuzz or merge two linked lists. This behavior right here is where those stories about college kids actually come from. Downvote me if you like. But maybe you should listen, instead, because you're more than a semester in, you're in a datastructure class, and you're failing to merge two linked lists. Maybe you didn't know this, but in college, the professors aren't teachers. They're not expected to teach you. You're expected to teach yourself. From here, it looks like you're not teaching yourself.
Yes, freshmen who fail tests are often pretty sure that people who say "that should be easy" are exaggerating. Best of luck in the workforce.
5 minutes, are you serious? Every here teacher from all the other subject take a little from their time to explain what they are showing on class, even the ones from data structures. Problem is that they try to explain a lot of stuff in little time and then this happens, there are 75 students divided in 3 groups and no one (seriously, 0 out of 75) could solve it, i gave 1 week only to doubly linked lists, and i know from people who spent even more time and yet, we all failed at it
Go ahead, show me how you make it swapping two values only as you say. 
&gt; 5 minutes, are you serious? Yes. . &gt; Problem is that they try to explain a lot of stuff in little time You're supposed to teach yourself. Therefore, this is not a problem. . &gt; i gave 1 week only to doubly linked lists Given that they can be explained in a single sentence, this probably isn't as impressive as you mean it to be. . &gt; i know from people who spent even more time and yet, we all failed at it Well, then either try harder, or get a tutor. It's not your professor's fault if you can't teach yourself. This isn't school. This is university. If you really think this is your teacher's fault, go to the dean. When the dean is done laughing at you, maybe he or she will explain that when you get into the workforce, nobody's going to teach you either. Part of university is making people sink or swim. Part of that diploma is showing that you swam. Complaining how the professor didn't swim hard enough for you won't get you that degree.
i gave 1 week, it is not impressive, it means i teached myself (i found some stuff i never saw on class, so yeah, books are my friends i know). I shouldn't have called them assholes, what i want to know if you guys think we, **students**, could solve the entire test in 90 minutes. I still don't believe you about the 5 minutes (we solve it in paper, not on a computer btw).
&gt; &gt; Maybe you didn't know this, but in college, the professors aren't teachers. They're not expected to teach you. You're expected to teach yourself. &gt; That's completely false. This is the defining facet of university, and is why so many universities have auditoriums with 500+ students being taught twice-weekly by a single professor who never even meets most of them. . &gt; The staff are there to ensure that you understand what's necessary to understand to move to the next level No. They're not. That's why most universities have freshman dropout rates of 50+ percent. . &gt; as a paying customer of the college you should definitely expect some reasonable assistance That's why they give you a syllabus, guidelines on expected materials, tutors, and libraries. . &gt; you certainly aren't expected to teach yourself. If that were true, what use are the professors in the first place? To gauge your productivity, to validate your thesis, to choose whom to admit into the faculty, and to do research. The purpose of the students is to fund the university. Many professors don't actually teach at all. The year I left campus, just over 15% of professors at my school had neither classes nor office hours. It's quite common for a professor to stop teaching for years at a time to write a book, to do a large scale study, or so forth. While making factual assertions about the structure of universities which do not fit many of their most famous and publically inscrutible characteristics, I would appreciate your considering offering any supporting evidence of your opinion. I expect you to say the same to me, at which point I'll point out that I already have, and that my claims don't fail to match the famous characteristics of our public institutions. Then I expect you to not actually provide anything.
Sorry, I don't do work for disrespectful sarcastic lazy freshmen who downvote things they don't like. Be sure to protest that it's not possible, while also insisting that you understand the basics of C.
Of course you don't
&gt; it means i teached myself I agree. That you failed on a test means you teached yourself. . &gt; I shouldn't have called them assholes That's correct. . &gt; what i want to know if you guys think we, students, could solve the entire test in 90 minutes. And then you downvoted answers you didn't like. . &gt; I still don't believe you about the 5 minutes That's nice.
Someone already called my worst, didn't downvoted him because he had a valid argument. You come here with the attitude of an asshole, claiming stuff (and refuse to prove it). I understand some stuff about C, but guess what, data structures aren't C basics
&gt; &gt; I shouldn't have called them assholes &gt; &gt; You come here with the attitude of an asshole My my, we have a pattern, don't we? . &gt; I understand some stuff about C You seem to have a great disconnect with your actual knowledge level. . &gt; but guess what, data structures aren't C basics Yeah, actually, they are. As a freshman, I'm not sure why you're trying to instruct others on things you recently found out you haven't learned. Enjoy the workforce.
Yeah, you can't make programs in C if you don't understand basic pointer work or datastructures. Stop trying to explain what programming is, freshman who just failed his test.
I can make them, but they are not memory friendly because i don't use pointers (i just started with the subject, if you haven't realized)
The fundamentals haven't really changed all that much, it is still all about values, functions and pointers. If you happen to learn about a Borland library for a couple of months that you're not going to use again, big deal, there are thousands of different C libraries, you're not going to just use one set forever anyway. If you're looking for transferable skills, learning how to pick up a library and then quickly get stuff done with it is a pretty important skill too. As is learning to read other people's code, which is always going to be code written at various times in the past. (But if you have time, have a play with clang too. There's lots of cool stuff happening on LLVM nowadays.)
www.pastebin.org or gist.github.com to share code. The problem is you're referencing result, so you're setting binary_address to whatever memory address result has.
That snippet doesn't make much sense. You are passing a `char` array as an integer to `binary`, the lower-case `c` you pass as well isn't declared (did you mean `C`?) and there's a closing parentheses missing in the `printf`line. I'm assuming your actual code has the missing parentheses, but if the types here are correct, your compiler should spew warnings at you, and for good reason. To answer your question about passing references, it depends on whether or not you really want `C` to be an array. If yes, passing just `C` will suffice, as it's already a pointer to the first array element. To pass a reference to the i-th element in the array, use `&amp;C[i]`. Note that `C` and `&amp;C[0]` are equivalent. If `C` is *not* supposed to be an array, you can reference it just like you did with `&amp;C`, giving you a pointer to the location of `C`. Anyway, the reason you get seemingly random numbers is not because you feed `binary` with the wrong arguments. It's because you give `printf` garbage, namely the "return value" of `binary`, which, for a `void` function, is whatever's lying on the stack when the function is done. Maybe you wanted to do something like this? binary(a, C); printf("%i", C[0]);
Your behavior is really confusing, given that you're yelling at the guy who got it right, and that your own response to the question asker explicitly says that ***the thing that turned out to be the problem*** isn't the problem. Have you considered that you might be being inappropriately hostile? . &gt; In either case (code is different, or compiler bug), it is required to see the exact code that OP is compiling. This is a basic fact. Actually, the guy you're saying this to was able to figure it out with the code provided. So were three other people. In the meantime, you looked right at the bug and said "this isn't the bug." . &gt; or you have the observation skills of a mole. Says the guy who looked right at the bug, said it wasn't the bug, then turned to the guy who found the bug and said "it isn't possible to find this bug without the rest of the code." . &gt; Of course I could guess You shouldn't need to. The bug is right there in the sample, and quite obvious to boot. Indeed, in my opinion, on the description, you should have been able to intuit the defect without seeing any code at all. You seem to be taking the role of the senior programmer, in telling others what basic facts are necessary to solve things. You seem to be telling people who get it right that they have poor observational skills and thick skulls, immediately after explicitly hanging a lantern directly on the bug and saying "this isn't the bug." . &gt; Kindly butt out and let the people who are trying to help try to help. The person you said this to not only tried to help, but succeeded. You did not. . &gt; Therefore either his code consists of something other than the posted code followed by int main() { Forecast(); }, or his compiler is buggy. Neither of these turn out to be true. What's really going on is that you printed an unbounded scan. I believe that you will reject this based on a comment from an earlier post: &gt; &gt; The junk would be in the first position, not the last position. Yeah, unless there were cursor control characters in the undefined scanned range. Which, you know, there very probably are. . &gt; I don't know what soapbox you are on, but you need to get off it. &gt; I didn't try running it: I took advantage of my "superiority" as you put it &gt; you have the observation skills of a mole. &gt; This is a basic fact. Of course I could guess &gt; It seems it did penetrate your skull &gt; Kindly butt out Please help us keep this place friendly and civil. There's no need for this kind of anger. Thanks.
Disassemble? Why would you do that for something you have the code for? And "the debugger"? What debugger? OP is asking for a very intuitive debugging application. Your comment is shit.
Yup, try http://tenaciousc.com/ Tiered pricing though :(
What is a "memory friendly" program?
One that uses the heap memory to work. But again i am just a lazy freshman who is pretending to know everything, so there is no point in you to ask me that. Unless you are looking for something to prove me wrong
Nope. I was trying to help you, but you kept swearing at me and making insults, so I gave up. You told me in private what your professors, plural, said to you. They're correct. Until you address that, you're stuck.
Ok
Learn C. No matter how rusty the compiler is. Tell the teacher that Borland C is not very good, buggy and lacks many standards and that there are better options. When she does not want... shut up and learn the concepts instead. You can do important and serious things with a reasonable compiler at home.
We never saw pointer in the first semester, it was more of an introduction to C
It's not very good for learning C.
I hate Borland. Ever since I bought a boxed compiler from them and hated the piece of shit. I ended up throwing it away. But: I'd go for Clang. You still need MinGW as the backend (at least on Windows; that or Microsoft Visual C), but Clang, at least, has wonderful informative error messages.
I'm not being funny, but you misquoted /u/StoneCypher. He actually said.. &gt;**Someone with no highschool or college training and a year of experience** could do this test in about five minutes. I am highlighting this because I fall into that camp (no university education, but had a job where I was required to code in C), and actually did implement a doubly linked list for a project. At that time I had much less than a years worth of experience in C. It was closer to 6 months, but it was 6 months of solid experience - 8 hrs a day, every day. It becomes very routine once you've have got the concepts in your head and practised it a few times. Wikipedia has a pretty good article on doubly linked lists... http://en.wikipedia.org/wiki/Doubly_linked_list There is also an example implementation on Learn C the Hard Way... http://c.learncodethehardway.org/book/ex32.html You can learn and understand linked lists with a few hours of study and experimentation. The concepts are quite challenging when you first look at them, but they become very easy, very quickly. A strategy I find really useful when confronted with a difficult programming concept is to write and debug a demo that implements it. They key part, for increasing my understanding, is the debugging. I will invariably get it wrong on the first pass, but the debugging step really embeds the *why* it works they way it does in my mind. The majority of my knowledge of different programming languages and concepts comes from debugging demo programs I have written. For me, this is the most effective way of learning. It is also extremely rewarding when you get something working (and understand why it works), after struggling with it for a while. Following this advice is what will make you stand out from your peers.
&gt; Merging two linked lists means setting the start and end pointers for the two lists' ends into one another. You fail. You spent 5 minutes coding a solution to the *wrong problem.* Read the question again.
I used to TA and grade for a data structures course (although taught in Java). These were the type of problems assigned with similar time limits. I found when grading the students that grasped the problems spent their time initially with diagrams, rudimentary test cases, etc. I would suspect for each problem that would take 10 or so minutes. The rest of the time was spent writing code. When grading we stuck to a strict rubric for correctness with no leeway for complaints. I encourage you to solve these problems, continue your studies, and forget about the grades. Grades are of little importance. The most important thing you can do is forget about the grades and focus on learning the material as best as possible. Grades absolutely mean nothing, especially when people learn at varying paces for differing reasons.
... What? You really cannot do an introduction to C without pointers.
Good reply. C is C. If you're learning systems programming the emphasis would be on things like optimization, processes, io, caches, low level networking, etc. GCC is a far better choice but what are you gonna do. 
So, if there's an actual mistake there, and you feel like pointing it out in a polite way, I'm happy to take a look, and maybe even to withdraw the position. Let me know if you feel like handling this in a fashion that's more likely to get a response. It's quite possible that my offhanded comment was wrong; I actually spent zero minutes coding, and only briefly looked over the question text. It's possible that I misread. I think maybe you might be confused what kind of public behavior gets you listened to, though. Reddit seems to lead to some really confused social behavior. Nobody listens to a rude stranger, even when they're right.
It still is an introduction to C
I agree, disassembling is probably too low-level for OP, as a tool for understanding what chunks of C code are doing. But I'm going to address this question of yours: &gt; Disassemble? Why would you do that for something you have the code for? I code for embedded systems, and sometimes there is no substitute for opening the disassembly view in the debugger. Why? The compiler is *very* smart. It knows it can re-order instructions in certain ways. It knows how to turn plain C code into special machine instructions (for instance, the processor we use has hardware loops). Just because C is "portable assembly" doesn't mean you know exactly how the compiler turned it into machine code. If you want to know what's actually happening, sometimes you must look at the disassembly. The compiler is *not* very smart (at least this one isn't, sometimes). It reorders instructions, but loses the ability to single-step over instructions (because they're out of order). It keeps variables in registers instead of memory, but loses the ability to show them in a Watch window using their symbolic name. If I want to trace through some code, I have no choice but to look at the disassembly and mentally reverse-engineer what the compiler is doing. Embedded systems are hard. Most of our code can run on desktop PCs, but when the code is talking to pieces of hardware like GPIOs, there is no way to replicate that. Stack overflows and corrupted pointers are also more common, because of limited memory and complex, unprotected interactions between all the components that are running. When these happen, assuming I can reproduce it, the only way to find the source of the problem is to stare at disassembly and judiciously use breakpoints and watches to figure out where the corrupted data is coming from.
As far as I can tell, that only applies for string inputs: the compiler will check the format string for any %s and make sure that they're size limited and written into a fixed-length array (or something like that). But apparently OP's screenshot is from a slightly different version that only ran the loop 6 times, so that would explain the difference.
&gt; Buddy, you just failed a test other people can do in five minutes I could probably type all of that in 5 minutes. I doubt I could write it in pencil that fast. :-P
-that is what I want. I need to have binary point to the address of the result. -no. Like I said above, I need binary ADDRESS to equal an addrsss. -typo. Assume I meant the same variable. I was nott trying to post my entire source code like someone else mentioned below. -how does this not make sense? I'm trying to pass a char array into a function the returns an int. 'B' would return 1010. In the function, (the code I left out, I deal with chaninging the ASCII to an int. That's why its an int.) -the return is void because I don't want a return value. I just want to change the value of C by having it point to a new address. 
It is important to present a valid piece of code to illustrate a problem. You cannot ask something like "orange + apple &lt; 4" and then complain that "4" does not work in your program.
Thanks, i'll check it out
I Know, I tried to talk to my teacher telling that some thing that we are learning are obsolete these days with updated compilers and update her code example but she replies with this "In this class we use conio deal with it"-the teacher. So I think I made a point in that SOME teachers don't want to update their skills. She have 30 year working as a teacher in my college. 
Exactly! As you said, when you add the second 'o' you mark that node as isWord - which puts foo in your dictionary. When you go to add "food" you'll won't have to add any new nodes for the first three letters, but when you get to the 'd' you'll add a new node and mark it isWord since it ends the word. Some things to point out: Your data file has a mixture of upper and lowercase letters - how you deal with this depends on if you want your dictionary to be case sensitive or not. If you want case sensitivity then you have to have 52 (= 2*26) children per node. If not, just convert everything to the same case. Internal nodes may or may not have isWord true. Leaf nodes will always have isWord true.
code::blocks, Dev-c++, MVS and many more IDE's are free. Practically all the compiler are free to, she uses turbo c because her code only runs on turbo c. She still uses thing like " delay(2000);" while "Sleep" and "sleep" are available. Don´t get me wrong she is a good teacher, she has explained arrays, pointers very well. It's just the old C code that bothers me. 
&gt; that is what I want. I need to have binary point to the address of the result. You have left out most of the code in the function *binary*, but presumably *result* is a local variable to that function. Setting a pointer to the memory location of *result* and referencing that memory outside the scope of *binary* would have unpredictable behavior, and won't accomplish what you want. Also, the pointer you're trying to set is a static array in *main*. The code you have is trying to re-assign *c* to point to *result* (with the side effect of forgetting about the original 1024 int array it pointed to). I'm guessing that what you really intend to do is copy *result* into array *c*, but you don't post any more of the code, so we don't even know what *result* is declared as. &gt; how does this not make sense? I'm trying to pass a char array into a function the returns an int. 'B' would return 1010. In the function, (the code I left out, I deal with chaninging the ASCII to an int. That's why its an int.) *a* is an array of 3 characters. *binary* takes a single *int* as its first argument. Passing *a* as the first argument to *binary* is unlikely to do what you want/expect (assuming you were even able to get this to compile somehow). &gt; the return is void because I don't want a return value. I just want to change the value of C by having it point to a new address. Then why did you declare *c* as an array of ints to begin with? Why not just declare it as int *c? But unless you're telling it to point to memory that you specifically allocated via one of the malloc functions, this won't work for the reason I gave above. Also, if *binary* does not return a value, then *printf* doesn't have anything to work with. printf("%i", binary(a, &amp;c)); This says, "Take whatever value is returned by calling the function *binary*, and print out that value using the %i formatter". If we assume that *binary* successfully stored the result in c[0], you'd probably want something more like: binary(a, c); printf("%i", c[0]);
Awesome. I'm glad I'm getting the jist of this. It is going to be case INsensitive, so when I take in a character, I will convert to lower case. When you say I will have 26 children nodes, do you mean that I have to make those before I even start taking in characters? Or at most there will be 26? Thanks for your help :)
sum is an integer and num4 also, when you divide integers you'll get an integer result, i assume that's what you're seeing? Also, what happens when my name is very long or i just type the eof character?
well, i used num4=2, as that was allowing me to divide sum by 2. therefore giving me the value avg1 (hence the float of avg). what im trying to accomplish is taking avg1 and raising it to the second power. what i'm not sure about is how to call avg1 into a function using exponents. Thanks for replying, though you can probably tell i have no idea what im talking about. I feel like I should use exp but im not sure how to declare the variables and place them into the last printf
The reported bug is that `temps[6]`, and thus the 7th output displayed, does not get the entered value stored in it. (If you disagree then re-read the original post). So far nobody has identified the cause of that bug. Your whole post is based on the idea that the bogus format string caused this bug, however that is *wrong*. The bogus format string is a different bug. Having X amount of people say something doesn't make it true. If you disagree then please post a program and input sequence which: * Matches OP's screenshot (except for the exact nature of which garbage appears, of course) * Is fixed by solely removing `\n` from the format string I contend that there is no such program. &gt;Yeah, unless there were cursor control characters in the undefined scanned range. What is "the undefined scanned range" or "an unbounded scan" ? The OP's screenshot can be reproduced by entering nonprintable garbage before the `7` (e.g. pressing left arrow key and then `7`). I guess that is what you are referring to. However that is not fixed by taking `\n` out of the format string. If you take `\n` out of the format string and re-enter the same input, you still get the garbage display. This bug is fixed by not entering garbage, or by adding code to deal with the possibility of garbage being entered. Based on the evidence so far, it still seems most likely to me that the sequence of events was: * OP notices 8 inputs prompted for (caused by the format string bug) * OP makes some other changes to try and fix this, not realizing that the format string was the problem; which introduce the bug of not storing `temps[6]` * OP posts screenshot from running this latest code, but posts the original code. &gt;Please help us keep this place friendly and civil. I give as good as I get. 
Each node contains an array of 26 node pointers for its 26 potential children. You don't actually allocate any of the child nodes until you need to. Obviously, having 26 node pointers when you have less than 26 children wastes space. There are other approaches, where you allocate space for the child pointers as needed. This requires either dynamically resizing the nodes or storing the child pointers in separate memory from the node. It complicates things. Using uniformly sized nodes, each containing 26 pointers, is the simplest and should suffice for your purposes. Note, you'll want those 26 pointers to be NULL when you initially create a new node. If you use calloc, as opposed to malloc, you get this for free. Otherwise you'll have to loop or use memset to NULL them.
you're looking for the 'pow'/'powf' function. I don't think avg1 is what you think it is though.
I don't quite understand the need to do that. I was going to have the trieNode const have a char value, a isWord, and a nextNode. I guess I just don't understand having an array in there as well. 
Got it! thanks for your help! i was supposed to put the pow function at the end of a printf printf("Don't you wish it was %lf?",pow(avg1,2)); 
Embedded programming maybe or Linux systems development. Sometimes you get enough freedom at a position where they don't really care as long as you document really well. 
It's very desired, but in smaller quantities. I have applied for a job as a C programer, they hired me, but since they don't have that much work in that department now, i'm working with xml files and php... The takeaway from that is that multiple skills are most desired, as a pure c programmer it must be harder to find a job, and i don't think it's getting easier, and even now, it's mostly work on legacy code. 
Agreed -- I know quite a few languages and tools. I guess most jobs require programming in a variety of languages to some degree. I'm just surprised by how few C/Unix Programmer job openings there are out there right now.
There is nothing wrong with using C for a data structures class.
To each their own. I think the complication of pointers and the lack of object-orientation will just make it harder to explain later. But what do I know? Some programs use python to teach Data Structures, and that's the real tragedy. 