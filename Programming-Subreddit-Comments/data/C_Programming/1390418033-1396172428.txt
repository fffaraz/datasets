The comments piece works better if you pretty much omit external documentation and use a documenting tool (granted I use C# mostly but I think the concept is universal and I'm sure there are good C documentation generators out there.) But I use the comments to generate my documentation because it forces me to keep up to date comments so my documentation is up to date and it also forces me to use common or business vernacular rather than code jargon that no one reading the external documentation will understand. 
Always check for null pointers. (M-C)Alloc and Free are a 1 - 1 relationship in your code. 
That would be really frustrating. I'm going to keep this in mind for future projects.
Grr. If you're on a desk top.... when malloc returns null, you are going to be so deep into swapping nothing sane will happen for several minutes (except maybe the dreaded OOM killer slapping you silly) If you are embedded... god forbid you try log a messages about it... since something (eg. printf) is bound to try malloc something to do the log! If you check for malloc returning null.... what are you going to do about it? And have you tested that code? Or are you just praying? Malloc is a broken API.
Point conceded about Malloc, I reckon if there's no more memory to allocate you most likely won't be able to do anything about it. The C implementation for which I program (and admittedly don't program very extensively) whenever I call a library or some such that someone else has written, a null pointer being returned can indicate several things, not just a bad allocation in which case it's important to check and log the error that the library sets. 
Just to add to what's been said: * Write code for others. Even if there are no _others_ always approach coding in this way and at the very least your future self will be happier. Try and make the code as clear and obvious as you can and then supplement that with comments. * Make it work, then make it pretty. Working software is always more valuable. Get it working, then keep it working as you make changes. * Unit tests. They give you the strength to move forward and confidence in the past. * Don't generalise too soon. The software needs to do X, write code to make X happen. Forget the fabulous Y's and Z's that could be great until you know you need them. Often by the time X works (and has already become X') you realise that you actually need A or B not Y or Z. * Don't optimize too soon. And only optimize after collecting data. Number of times I've been surprised that the bit I thought was slow, really wasn't. * Keep it simple. Remember the code is not the objective, it's the software that matters. Find the most obvious and concise way to achieve the goal and use it. * Read code, steal from others. There are a lot of good developers out there and they are not necessarily the "rockstars" who write seemingly clever code or bamboozle you with irrelevant CS. Simple things like neat indentation tricks can make code much more readable and thus understandable. Extras for the C developer: * 'printf' is the best debugging tool you will ever know. * Stay away from C++. It isn't a language but an opportunity for clusters of developers to define their own. I think it was Bertrand Russell who once observed that two sufficiently specialised mathematicians would think each other fools as they knew nothing of the others field. I suspect this might be true of C++ developers. * Lua is beautiful. * Java is far better than you think. And the JVM is remarkable. * Garbage collection is like sex. Once you have tried it you will never not want it in your life. (edited for clarity) 
1. White Space. Have some. Be consistent. Don't argue about which style, you have MUCH bigger problems. 1. Finest Grained Unit Tests. Yes, unit tests and C get along just fine. Being doing it for years. The smallest chunk of code you can throw at your linker is a single .o file. Test that and mock the rest. If the function call fan out from that .o is too high.... maybe that .o needs to be split. 1. Design for Test. Yes, you MUST alter your designs to make them testable. That's OK. Testable code is resuable code. Testable code is simple code. Testable code is understandable code. 1. Internal State (globals, statics, ...) causes you MUCH pain... Hard to test deeply, hides suprising cause and effect coupling between routines. Avoid if possible. 1. "const" is your friend. Use it by default, remove it only if you need to. 1. "-W -Wall -Werror" is your friend, always compile with maximum warnings turned on. Always keep your code clean. 1. Valgrind is a C/C++ programmers best friend. Never leave home without it. 1. Use size_t, uintptr_t, and sigh, PRI.... stuff from stdint.h and inttypes.h 1. A cast is a lie to the compiler. It claims you know better than the compiler what is happening. You had better be damn sure you _do_ know better. And that includes fine grained universal knowledge things like alignment of underlying object on all platforms. Often a union is a better solution than a cast. 1. Use a version control system. All the time. Commit very often. 1. The idea of "pure" functions without side effects may have no support from C, but there are lots of excellent reasons why so many modern languages insist on them. Extract as much code as you can into "pure" functions. They are easy to test deeply, easy to understand, easy to multithread, easy to write. 1. Use the Humble Function pattern. If you have an insane complex stateful I/O driven monster function.... extract every statement and expression you can out of it as a pure function. Leaving a humble small shell that does the hairy stuff -- but is obviously correct because it is so simple. 1. The more I write this stuff.... the less I use the I/O streams functions. (getc, putc, fprintf). They rivet everything you do to the I/O boundary of your process. I tend to work in RAM, (eg.snprintf not printf) and then if need be involve I/O. 1. Prefer processes to threads. That MMU provides some very very useful facilities. Use it.
I'm not a C developer (yet) but I like to apply the Unix philosophy to software development: *"...do one thing and do it well." ~D. Mcllroy* I think developers of any language would benefit greatly from your advice.
Will you still understand them after a month or two? What worked for me is using a short name first and then refactor it (automatically with an IDE) into a long descriptive one.
14: Why are processes preferable to threads? 
I read though all of your tips, and I'm going to be honest in saying that I don't know most of what you are saying. On that note I WILL be saving this for future use. Thanks!!
I was a bit confused by this one as well. Processes and threads serve different purposes and uses. As long as you use them correctly you'll be fine. Reference to [this SO thread](http://stackoverflow.com/a/5840902/1798577) about processes over threads and [this SO thread](http://stackoverflow.com/questions/617787/why-should-i-use-a-thread-vs-using-a-process) about threads over processes. Also [this talk](http://www.samba.org/~tridge/talks/threads.pdf).
**Note:** All code examples below are real. In addition to RumbincTheRadiant's comment, I think people over-comment when they don't need, and under-comment when other people need it. Most of the comments I read are useless - you can get the same information from the code in the same amount of time. For example: /* usb interrupt service routine. */ void handle_usb_interrupt(void) Some of the time they're quite harmful - because they conflict with the code. Only in a small number of instances they're useful. I find them most useful when: * They're used to describe non-obvious functions or API. Example: /** * usb_find_alt_setting() - Given a configuration, find the alternate setting * for the given interface. * @config: the configuration to search (not necessarily the current config). * @iface_num: interface number to search in * @alt_num: alternate interface setting number to search for. * * Search the configuration's interface cache for the given alt setting. */ struct usb_host_interface *usb_find_alt_setting( * They're used to translate hardware functions like: /* Enable USB host clock. */ writel(readl(CKENA) | CKENA_2_USBHOST | CKENA_20_UDC, CKENA); * They're used in file headers as a summary of what the code in the file does, how it works, or how it interfaces with the underlying layer or hardware. * They describe "magic." For example: static unsigned char root_hub_dev_des[] = { 0x12, /* __u8 bLength; */ * They describe the tricky parts of the code or "decisions" - why the original author decided to come up with a specific limit, variable, or extra state. For example: /* * Always service the USB devices irq not just when the input device is * open. This is useful when devices have a watchdog which prevents us * from periodically polling the device. Leave this unset unless your * touchscreen device requires it, as it does consume more of the USB * bandwidth. */ bool irq_always; There are probably other useful areas too but these are all the areas I can think of now. Regardless, I think comments are more useful at the API and "policy" level (i.e. explaining decisions) than they are when they're at the inline or mechanism level.
List which items in particular you aren't grasping, and I will expand on them.
Writing multithreaded programs is incredibly easy. Writing completely defect free (_under all loads, all schedulers, all numbers of multicores_) multithreaded programs is incredibly hard. I have found subtle 1 in a million sporadic defects even in the most mature of multithreaded code of super programmers I most admire. The MMU (Memory Management Unit) hardware provides some very strong guarantees against accidental inappropriate sharing of state. The IPC mechanisms provided by the operating system provide debugged and proven safe interprocess communication channels. Testing a multithreaded program is hard, have you tested every possible sequence of events at each and every place where state is shared?? Testing a multiprocess is easier in that the sequence points are usually much much fewer (per process). (Usually only a select or poll) Concurrency is excruciately hard... unless you impose some very very harsh discipline on your architecture. Erlang for examples does it by enforcing purity of functions. In C, the compiler permits you to do anything. Thus thread safety is entirely a matter of discipline on the part of a programmer (or more usually, the discipline of a large team of programmers of varying ability). The MMU and the kernel provide very strong proofs of appropriate and useful discipines.
Basically what franticreader said. Names should be short enough to quickly recognize/read/write but long enough to be clear and descriptive you can leverage context, but do that sparingly. 
right now 6, 9, 10, 12, and 13. I figured out the rest of what you were trying to say.
I agree on the fact that the author or editor must be able to update the comments as much as possible. 
&gt;Often a union is a better solution than a cast. Be carefull with that though. You are not generally well defined to access another member of a union than the previously written to: &gt; if a member of a union object is accessed after a value has been stored in a different member of the object, the behavior is implementation-defined (From the Ansi C standard)
8: Use off_t, not size_t, if you want to use the variable for file size.
Alas, the highest rank answer in the second SO thread is just plain wrong. &gt; Inter-thread communication (sharing data etc.) is significantly simpler to program than inter-process communication. So much so that no indication of or protection from inadvertant sharing is given. This is the major source of subtle and sporadic defects in multithreaded programs. All mechanisms available to threads and more are available to processes... http://man7.org/conf/lca2013/IPC_Overview-LCA-2013-printable.pdf &gt; Context switches between threads are faster than between processes. Perhaps in windows. But I suspect these days in linux the difference is minimal. Either way, thats a very premature optimization. &gt; multiple processes instead would result in slower performance and code that's tough to write and maintain. Actually easy to maintain and test. Every Web Interface on the planet is exactly that split. UI in browser process, business logic in a server somewhere else on the planet.
&gt; If you check for malloc returning null.... what are you going to do about it? Abort the program. You could have a handler set up that has preallocated all its memory just for this eventuality. Aborting the program is better than writing to random memory addresse (or address zero). 
&gt; Stay away from C++ kek 
If you really want to write your own device drivers, I recommend starting with some embedded programming, like a microcontroller or similar. I recommend the [MSP430 Launchpad]( http://www.ti.com/tool/msp-exp430g2) as its cheap ($10), quite simple, has open source tools like a [GCC port]( http://sourceforge.net/apps/mediawiki/mspgcc/index.php?title=MSPGCC_Wiki) and a good set of [training materials.]( http://www.ti.com/ww/en/launchpad/launchpad.html?DCMP=mcu-launchpad&amp;HQS=launchpad). With this you should learn enough hardware fundamentals (interrupts, registers, fifos etc) to be able to write device drivers for an OS. Linux is a good choice for this, as you can read all the code and its very well documented. So you don't end up constantly blow up your main computer, I would recommend you buy something like a [BeagleBoard](http://beagleboard.org) which is a small ARM computer (I wouldnt recommend the Raspberry Pi as the full processor manual is under NDA). Here is a [training course]( http://free-electrons.com/blog/updated-version-kernel-driver-development-training/) I found, with the slides etc linked at the bottom. Now, all of this seems like a lot of work to say, control an LED or read a switch from your computer. If that's actually what you want to do, then I wouldn't bother learning device driver development as a lot of different things exist to help you already do that. Something like an [Arduino]( http://Arduino.cc) combined with [Firmata](http://formats.org) will give you a nice [C interface](https://github.com/jdourlens/FirmataC) to the physical world. 
I would recommend git, mainly because it's becoming more ubiquitous daily, and mercurial seems bound to be confined to the Python world.
Why don't you start with writing a simple character device driver ? You wouldn't need any hardware for it and would be a lot easier to debug. When you get comfortable with that, working with external hardware would be a lot easier
Quality comment. In my opinion, your two strongest points are the ones about testability, and "pure" functions. You will do SO MUCH LESS debugging if you just follow those two things.
Well first off I already have an Arduino but that isn't doing it for me, I'm rather disappointed I didn't get a Pi instead back in the day but I guess it wouldn't have been as helpful anyway. I'll look into buying a BeagleBoard as it seems affordable but I feel like it will be a similar experience to my Arduino experience. Let's say I build a dumb box, with literally one button on it, and I want that button to open up facebook when it is connected to the computer (which I would never do), where should I begin?
&gt; "-W -Wall -Werror" is your friend, always compile with maximum warnings turned on. Always keep your code clean. This is true by and large, but there are times when squashing a warning can leave you with wrong code. &gt; Prefer processes to threads. That MMU provides some very very useful facilities. Use it. A thousand times this. It is far easier to debug intercommunicating processes than threads. It's also easier to understand the code. 
&gt;1. Use a version control system. All the time. Commit very often. This. Most of the other things mentioned are specific to low level languages, but this is a basic CompSci/Software Development principle. If you're not using source control, you're going to have a bad time. It doesn't matter what type of source control (he'll ever heavy handed manual backups of each source file is better than no source control), as long as you use source control. I was in the middle of committing changes to our bug engine, a few days ago. I'd asked that a branch be made before I started, so that the rest of the team could continue adding code around it. When I hit commit, I was informed that someone had made changes to my branch AFTER I'd started to make my (sweeping, huge, game changing) changes. Since I couldn't check in my changes, I had to take a manual back up, then roll back to the last change (after I'd started) and manually insert the changes. This would have been a nightmare situation, had we not been using source control. Hell, I use source control for documents and pictures too - not really what it was designed for, but it's handy to know that I have a backup before I start editing something. 
Do you know any other languages?
I find that I only need to write comments when I know that what I am doing is not the best way to do it, but I either don't know how to do it better or there's other reasons. Basically, a need for comment is a problem, not the lack of it.
Read [clean code](http://www.amazon.co.uk/Clean-Code-Handbook-Software-Craftsmanship-ebook/dp/B001GSTOAM/ref=sr_1_1?ie=UTF8&amp;qid=1390483025&amp;sr=8-1&amp;keywords=CleanCode)
To me it seems that you don't really want to write a driver at all. and i don't think that you need. Writing device drivers is not an easy task, and most importantly you really have to start with a NULL driver (that does nothing but it loads and can communicate with the kernel properly) . To wrie driver you really need to understand the Operating system that you are working on (and maybe/also what kind of driver are you doing, like an ALSA soundcard driver, or a framebuffer driver, etc). You don't need a driver to start a program when you press a button, you just need your arduino to send a byte down the (virtual) serial port to the PC, than have a simple C program on the PC that listens on that port and executes a command when it receives a specific byte.
I haven't done anything real world enough to say I know any language, but I have worked through the majority of a java, c++, and python books. 
Thats not enitre view though. Drawbacks of processes over threads: * Process parallelization is much slower - IPC is slower than shared memory, process scheduling is slower than thread scheduling (especially with process-level threads). * Large number of processes tends to steal CPU time. Scheduling fairness is based on rule that processes are (almost) unrelated, while threads are closely related. * Process parallelization is more error prone than thread paralleli - OS calls for OS level semaphores, mutexes and IPC requires use of difficult APIs, specialized structured and additional routines for allocation and deallocation. There is less consequences or error though. * Large number of processes may meet administrative restrictions placed on OS user. * Processes needs slow and expensive startups (avg. 6 000 000 processor cycles on x86 systems) and a lot of resources is initialized even for one line main() applications. Easier to hit machine physical limits. Ergo: every tools is suited for different task. Pick by needs, not by rules.
+1 for git, it's worth learning it even if just for http://github.com
Understand where a lot of the bad habits come from: bad management. No one wakes up in the morning wanting to write bad code, but business pressures demand a pragmattic approach to priorities. It's a question of "Will all this effort make more money? When?" If we had it our way, we'd refactor much of our code and enforce a coding standard, but that would stop production for months, and we have customers... Let the tools do the work for you. We have wonderful tools. Editors that color highlight and auto indent/format, make to manage building projects, there are generators that will write code for you. Speaking further on tools, always ALWAYS use revision control. Even for your first Hello World program. I recommend Git first and Mecurial second. Don't bother with CVS (first released in 1983 and archaic) or Subversion (which is CVS with atomic commits, whoopdy do...). I recommend *don't* track revision history in text documents or in code comments, put it in your revision system. That's what it's there for. Write your documentation and keep it up to date. The document should be written first. This is probably the hardest thing to do. It's especially hard in the field because management pressures usually demand output and features, not maintainability. If the project document is the first priority, then it will be accurate, useful, and people will use it, update it, depend on it, and have faith in it. If the document falls behind, people will immediately and completely abandon it. Doxygen is a tool that generates fantastic API documentation from metadata you write in your code. So that means you also get a standard code document format. You don't have to document everything; getWidget() and setWidget() are pretty clear on what they do, unless they also have some hidden side effects. "Sets the widget" is NOT good documentation. fargleTheGarsnap() is going to need a couple words on what it does and how to use it... Don't reinvent the wheel unless it's for the academic exercise or it's the thing you're looking to compete in the market. You don't need to write FFT methods unless you're in a class learning about FFT or you're selling your implementation as something better than what's out there. Use an existing library. If it's already been written, then it's probably going to be better than what you're going to write. If you're focus is on doing a thing to some audio data, don't get distracted by writing a FFT...
Go write a driver for an existing open-source operating system. I'm an OpenBSD kernel developer and, if you're interested, I could give you some pointers on what drivers we are lacking for the hardware we support.
No, not really. Not in OpenBSD at least. Some platforms have a projects section where they list work in progress or things to be done where you can get some inspiration from. Take [Loongson](http://www.openbsd.org/loongson.html) for example. There are also hints of stuff that are not yet working or supported in the INSTALL files for each platform. Look at newer ports (like the mips64 and arm ports). Lots of fresh things to do there. Also, as is the case for OpenBSD, a lot of things are missing that other operating systems have. So you can port over functionality. That's a good way of learning the hooks and how different BSDs work. My best recommendation is to start with something that annoys you with you BSD experience. And try to improve that. It's a great incentive that will give you satisfaction on all levels when you succeed in doing something about it.
For example. Never access a shared variable without synchronization. Which variables are shared? How do you know? C isn't going to tell you. In the presence of pointers not even code inspection of anything short of the whole program is going to tell you. For example. Never take an action on a shared variable unless you syncronize the variable AND the action. eg. if( itsOkSynchronize( variable) { doStuff(); } That's a thread race. You should always think of "unlock" has a command to the scheduler to "reschedule now!" (In more than one RTOS I have seen, that is precisely what happens!) So you doing "stuff" because it is OK, but quite likely you have been preempted and the variable changed and it's not long OK. You are doing precisely the wrong thing! ie. You always have to lock(); if( itsOK( variable)) { doStuff()} } unlock(); For example. If you have take two locks, you must ALWAYS, WITHOUT fail anywhere in your system, take them in the SAME ORDER, and release them in reverse order, else you risk deadlock. There is a largish bunch of other fine print that must be obeyed, and it depends on RTOS you are using.
gcc's warning system is very clean these days. I haven't met a case where squashing a warning would introduce a bug. For example. You can use the __ attribute __((unused)) to mark a parameter as unused if need be. (I wrap that in a macro) Especially with optimization on you will get nagged about potentially uninitialised variables which a full data flow analysis will show will never happen... eg. int i; if( someThingHorrid()) { i = 0; } if( someElseHorridThatIsOnlyEverTrueIfSomeThingIsHorrid()) doStuffWith(i); } Gcc will flag that. The solution is simple and robust. Initialise the name variable. Burn a cycle. You won't regret it. Especially if the code under SomeThingHorrid changes....
The single board embedded devices are fun... But have a bunch of baggage that makes learning a language harder. Learn the language on a desktop, then play with the gadgets. Yes, embedded devices are a MASSIVE growth area in future and well worth (career wise) learning. 
Not really, I use Ruby / C / C++ / D on a daily basis. Mercurial's pythoness only intrudes if I want to write a plug in. So have I have gotten away with writing a template to output log info to Json and playing with that.
Sigh! Deferencing NULL causes an segfault / trap / exception on every CPU I have used. Alas, malloc() is broken and there are no good answers that will port to every computer with every load on every OS. 
Hmm. Sounds like PBCAK. I have seen it several times before where instead of addressing the problem the warning is highlighting, programmers do insane convoluted stupid things to shut up the warning. 
Yep some oddball embedded thing. There's no reason to rely on the OS to abort your program rather than just doing it yourself, it's not difficult. The wrapper idea is sometimes good. 
The rounding question is wrong - it only works for positive values. Also there's a bad question in the experimental questions - it looks like a question from some other programming language found its way into the C test.
Just post the quiz text here, don't ask anyone to sign up for some crap. Requiring signup is one of the worst possible user interfaces for a website. Signup should be optional in 99% of cases.
You should indicate which C standard the questions are about (I guess C99). The code in the third question doesn't compile with -pedantic. It gives the following error: error: ‘for’ loop initial declarations are only allowed in C99 mode Move the initialization of the loop variable to the beginning of the function. Also, int main() shouldn't be used: write either int main(void), or int main(int argc, char* argv[])
Sorry. Won't try the test with the signin. Maybe I'm too hardline about this, but I remember the days of 200+ spam e-mails per *day*. My e-mail is *not* free.
agreed!
There's just no way I'm giving my email. Sorry, man.
I don't mean you need to know Python to use mercurial, just that the only community that is committed to mercurial still are in the python ecosystem. Everyone else is moving towards git
I don't want to use Arduino though, that's the point :P I understand the difficulty of the task, and luckily I've been learning some OS development for a few months (which is not enough for anything, but still) and have taken a closer look at Unix, and Linux specifically. I think I'm up for it, I just don't know where to directly begin
Upvoted this. Agree with most of it thoroughly, and all of it at least mostly. Thoughts on the above (Disclaimer, drinking as I post this, please forgive minor spelling/grammar mistakes): Points 1, 4, 5, 6, 8, 10, 11, 12: Pretty much fully agree in just about every scenario. Points 2, 3: I see a lot to like about TDD (Test Driven Development) and function/unit testing. I'm a really big fan of DBC (Design By Contract; see Object Oriented Software Construction by Bertrand Meyer). That said, I generally feel that C has piss-poor TDD/DBC testing support, as the language wasn't designed to embrace or support these concepts. (RumbuncTheRadiant, what function/unit testing framework do you prefer? Most of the ones I've seen are macro monstrosities that my preferred editor (vim) can't follow, which breaks syntax highlighting and throws off auto-indentation). I haven't written C on a team of programmers who had to edit each others' code in... 13 years now. If I had to do so again, I would certainly want tests all over the place. For my own code, with only me working on it, I tend to unit test things where I am not 100% certain I understand the solution and implementation completely, and anything else I leave alone. Very, very rarely bites me and saves me a lot of time in test case generation. (Although, I will admit that forcing oneself to think about test cases often reveals corner cases in design solutions and can improve design as a result, before the actual implementation is even written.) Point 7: *If* you have memory leaks, Valgrind is invaluable. If you have performance problems, Valgrind is invaluable. If you're working on a large C program with a team, you probably have both. Borrowing a page from point 11, try whenever possible to make memory management as self-contained as possible to eliminate memory usage errors. Also, spend your effort on choosing the correct algorithm for the problem at hand, not improving the implementation of it slightly through valgrind analysis (but do use valgrind to direct where you focus improvements). Hand vectorizing an ugly algorithm to achieve an 8x improvement may be worthwhile in certain situations, but if you can turn that (O)n algorithm into (O)log(n), you're way better off. 9: I dislike unions about as much as I dislike manual casts, for some of the same reasons. They are very easy to use incorrectly. I prefer to use typedef or #define (with careful preprocessor and autotools checks, if needed) to sort out the complexities, and then use my defined types where possible. Times when you should really be casting are pretty rare in C (and even rarer in C++, with templates). Point 11: I can't agree with this one enough. I've been using Python heavily for the last 5 years or so, and the list comprehensions it offers helped teach me this a bit, but when I learned Erlang a couple years ago and forced myself to write a couple of non-trivial programs in it (which was a big uphill climb for me, coming from languages where the for loop was a basic tool), this lesson really started to sink in. Personally, I feel that there are times when a non-pure function(-al) approach is by far the clearest, simplest, and easiest to troubleshoot approach. That said, I keep finding places where using a design based on pure functions is cleaner and more elegant. Sometimes this means two functions instead of one, optionally combined with a simple wrapper, but often a cleaner overall design. Point 13: If you have to do I/O, it has to get done eventually. Deferring and/or batching it, doing it in a non-blocking fashion, or doing it in a separate process/thread may all yield benefits, but ya gotta break eggs to make omelets, and snprintf won't show any output. Point 14: I could write a few chapters in a book on this one point. This is an extremely complex topic. If you are trying to maximize your programs for reliability, this is almost always a valid recommendation. (Hopefully OP knows what an MMU is... machine organization is increasingly an elective class for CS students.) Using processes automatically eliminates even the possibility of a large class of potential bugs. It also means that the scheduling is done by the OS kernel, which is likely to be more optimized than your own one-off implementation thread scheduling would have been, if you wrote such. Now, the ugly: on many platforms, the cost of a fork()/exec[pe/ve/etc] scales more or less linearly with the heap memory size of the parent process. I have seen this have *massive* impact on performance for programs that built up even a modest sized data cache over time, but needed to frequently "shell out" to exec subprocesses. Timing information would indicate that the fork/exec pair would be almost free when the parent heap was tiny, but rapidly scale up. If you are designing for large scale, you cannot ignore this effect, unless you know the implementation and performance details of the target platform, and are confident that these parameters will not change in the future (in my experience, this is almost never). Also, because the OS is handling the process scheduling, and every OS has a different scheduler algorithm... you end up with different, sometimes pathological, behaviors from platform to platform. If you absolutely must have full control over the scheduling behavior and timing of the executions of different pieces of the code, you may not be able to afford to delegate this out to code you don't control, and may be forced to write your own thread scheduling and synchronization. Similarly, threads can share a cache, while processes fight for memory (although, if you're talking for disk-based data, you may be able to obviate this by using memory-mapped I/O and leveraging a shared OS block cache). Also, processes can be helpful for ensuring security boundaries... take a look at the design for Postfix, for example. Sharing process memory can be a negative for threads as much as a positive. tl;dr; RumbuncTheRadiant had some really good points above that I largely agree with, with some minor technical footnotes.
why not? how else are you going to get a button? A driver is just a low level process that communicates with the hardware and provides an API for userland processes. There is no point to over mistify it.
It appears that many people don't share my view on C++.
Second the motion for reading that book. I'm not a huge fan of Microsoft, (and it's publised by Microsoft Press), but it's an excellent book. Some of the case studies can be a bit tedious to wade through (think Tolkien, if you've read the trilogy, taking 2 paragraphs to say that the wind is blowing over the hill), but they do add context. They really show the how and why, the science behind the recommendations given. I really only disagree with one of his recommendations in the whole book (I won't say which because I don't want to start a religious flame war in this thread.) Highly recommended... still trying to get my copy back from the coworker I loaned it to over a year later. Also, [The Pragmatic Programmer, from Journeyman to Master](http://www.amazon.com/Pragmatic-Programmer-Journeyman-Master-ebook/dp/B000SEGEKI/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1390601994&amp;sr=1-1&amp;keywords=pragmatic+programmer) is highly recommended. I've read through this book carefully twice in my programming career, and gotten a lot of value out of it both times. The first time, it helped me with some basics, and the second time I understood more of the advanced concepts and benefited further.
Your [comment](https://gist.github.com/mygnu/8610500#file-main-c-L62) indicates that the code segfaults -- this is usually due to following a null pointer or some other invalid reference. I'd debug it for you, but I can't compile your code because you don't supply xmlparsing.h.
It seems to be working now and printing without any issue but I have removed the malloc() from the xmlparsig.c my git repo is [mygnu!](https://github.com/mygnu/GNU_ISP_Stats). Unfortunately cant provide user details but the getcredentials.h, and itnernodeAPI.h can safely be commented out. Although credentials.h is only a temporary solution I will look into using gnome-keyring to store and retrieve credentials. (other suggestions are also welcomed) The .xml files in the temp dir should work. I'm looking for how can I get data such as the bytes used by date in the nodehistory.xml. With the current getElementContent() I am only able to get bytes from the first instance of the "traffic" element. I'm reading the tutorial on the libxml2 website but not really understanding it. I really appreciate your help. Thanks a lot 
Why don't you enjoy the Arduino?
Modern compilers (e.g. gcc) *specifically state* that you *should* use a union in this way to convert between representations. It's one of those things were compilers and the C standard are at odds.
I did my PhD in computer vision ( 20 years ago) and wrote all the code in C. However, then it was still regarded as a high-level language and we also had a significant amount of library code (http://www.tina-vision.net). People get hung up on the language when in many fields it's the library availability that is as important, you won't make as much progress if you have to write all the code yourself. So whilst you could do it in C today I would suggest you go where a lot of AI people are and start with something like Python and the SciPy project. A lot of the back end code is C so you can still work at that level but benefit from the skills of those around you.
In my experience, instructors in Computer Science have *way* worse programming habits that people in the field. They just don't see it themselves. I've seen them teach very strange design ideas (such as the ubiqutous but equally dreaded and braindead idea of "one return per function") that only leads to spaghetti code and/or code indented way too much. My tip is to follow a good and accepted coding style, such as the [linux kernel coding style](https://www.kernel.org/doc/Documentation/CodingStyle). If you do, your code will be easier to understand by others, and you can more easily participate in open source projects. That's important for your learning. Large open source projects tend to concentrate around real-world tested principles.
Thanks for pointing out. I have noticed that too, silly mistake. now I'm abele to iterate throug the code and return total for example. here is the [gist](https://gist.github.com/mygnu/8641855). now the question still remains that how should i extract the value of a particular element where the name is same but different attribute i.e. i the usage element has date associated to it in this [example](https://gist.github.com/mygnu/8641930) cheers
I have a hard time understanding your question, but you mean that you want to extract the value of the 'day' properties from the &lt;usage&gt; nodes? If I put this on line 77-78 of your libxml_parsig.c: xmlChar *prop_date = xmlGetProp(nodeset-&gt;nodeTab[i], (const xmlChar *)"day"); printf("%s\n", prop_date); and run it with: ./libxml /internode/api/usagelist/usage it prints the value of the 'day' property for each 'usage' node. Instead of printing it, you could parse it, return it, save it, whatever.
 const char* get_comment() { return "I bet I can guess which recommendation.\n"; }
Thank you :)
Thank you! :D This website looks very good!
A well designed multiprocess system will cope just fine with you poking gdb into the entrails of any one or more processes and stopping and continuing them individually. Writing a multithread or process system that depends on the real time behaviour of other threads/processes leads to madness. Personally I treat a multiprocess system dying in a heap because I have stuck a debugger into the entrails of some process as a defect... and I fix that defect first. As I have said, there is seldom any point in having many more processes than cores, so usually there is some "select" or "poll" at the core of whatever is juggling the processes in the process pool. Often it is just a matter of controlling that from gdb. Other techniques are... * Logging with timestamps. * Inserting "tee" into pipes. * Debugging processes individually. It depends a lot on your IPC mechanisms. Shared memory always makes things hard, whether with threads or processes. Pipes, especially named pipes, give you a point where you can capture and inject behaviour. If you have a cyclic tangle of inter process communication and everything only works if every event arrives at the right real time moment..... Then stop debugging and start redesigning.
Worth noting here though is you have to be careful when parsing what you read. Each command line argument is separated by a `\0` so you can't treat it naïvely like its a c string.
Well, among other things, its just a really weird loop. I'm too tired to find the error right now, but it probably has to do with the weird initialization, and weird way you assign i. Lets make a better loop. For the sake of simplifying the loop, lets initialize start with a dummy value that lets us know that its the first node, give `i` a real name, and strip off everything that isn't necessary for illustrating a linked list (ignoring checking null return from malloc etc). Also, I'll use a while loop, since using a for loop is just kind of trying to unnecessarily shoehorn the existing code into a for loop's structure (for the most part, they pretty much compile to the same assembly code anyway): struct node *last = NULL; start = create("Start"); last = start; while(fgets(name,80,stdin) != NULL) { next = create(name); last-&gt;next = next; last = next; } This loop is functionally identical to your loop, except I moved initialization of `start` and `last` outside the loop for clarity. It should work correctly, assuming I didn't do something dumb. The loop's entire job should be to a) create the next thingy, b) assign the the `next` pointer from the last link in the list to the new thingy, c) update the `last` pointer to point to the new last link in the list. That's it. This should clarify what everything should look like before you actually start creating new things, since you're trying to have the loop handle too many jobs. The old way also slows down the program, since each branch check in the loop body will always be the same result, except the first time through the loop. edit: you're wrong about what's going on when you step through the loop. `next` is never NULL. (i != NULL) is true so next = NULL; i = NULL; If you step through the loop (this is much clearer using a while loop): (i != NULL) is true i-&gt; next = next i = next It cannot be null in this loop (assuming that malloc does not fail), and in fact the ONLY time next is NULL in the whole program is between initialization and the first statement of the first loop. edit edit: found your problem, lines 39-40 should be: start = next; i = start; Or something. Again, it is much clearer what should be going on when you don't do more than necessary within the loop body. 
The code is not wrong. After the first iteration *i != NULL* is true every time. Basically *i* is the previous created node. So you have the following algorithm: current = create(node); if (start != NULL) // if a start doesn't exists, set it (only once) start = current; if (i != NULL) // i is set only after the first iteration (you don't have a previous node at the beginning...) i-&gt;next = current; // previous-&gt;next = current // now i will be set as the current one in the for loop 
I like it. I'm an embedded programmer and I work almost exclusively in C. I was once told by a web developer/software engineer that in the embedded world, C will be phased out and replaced by Java within the next few years. Ha! For all the reasons mentioned in that article C won't be leaving the embedded space any time soon. Direct control over memory and how things are layed out, extremely fast execution speed, the need to reduce code size and complexity are all extremely necessary in embedded design. Additionally, pulling in a bunch of libraries for Java or even pulling in &lt;stdio&gt; in C can easily double your code size. One of the main costs of a micro controller is flash and RAM. So much so that doubling the flash and RAM size can almost double the cost of the micro controller. C will be in the embedded space for a long time to come and this article highlights why
Python.
Great read!
It is, but with learning code, reading it helps a lot too to understand formatting and little "tricks." Thank you so much!
Thanks that's what I was afraid of. Coming from a java background makes what I learn about c seem error prone and scary.
It's telling that there are few if any functions in the standard library that allocate on your behalf, other than the ones for allocating memory (`malloc()`, `calloc()`, `realloc()`.) `fopen()` might qualify as one, but the memory allocation for the stream in that case is conveniently tied to closing the stream (i.e. `fclose()`) so there's more of an incentive to not forget. `strdup()` is probably the most widely known example but that's a BSD extension and not part of standard C, although it's widely implemented. In other words, when possible it's generally preferred to offload the responsibility onto the caller, and write functions that take pointers to existing buffers rather than allocating anything themselves. This tends to be especially true of library code, where you want to give the caller the choice of deciding on how to handle the allocation, and whether to use a static buffer, stack buffer, or dynamic/heap buffer. Of course, it's not always possible to write APIs that way, and there are certainly libraries that need to do allocation themselves, but if you look at the popular ones they always go out of their way to make it possible to hook into that logic, for example by allowing to register a custom allocator callback with the library (cf [libpng](http://www.libpng.org/pub/png/libpng-1.2.5-manual.html#section-5.1) as a random example.) 
Why don't you open the file in main and then use to create the pointer knowing its size? You could use the fileToString() just to copy the file to the string.
There really isn't any kind of convention. For example, reading a line from a stream is also something that can take an unknown amount of storage, and if we look to the standard library to see how it handles it, it merely offers `fgets()`, which takes a buffer of a given size, and if it's not big enough to fit the whole line it stops reading short of reading the whole line. This avoids allocation at the price of not being able to read lines of arbitrary length, which means that software that wants to do that has to write its own file parsing code. The GNU C library offers [`getline()`](http://www.gnu.org/software/libc/manual/html_node/Line-Input.html) which is much more sophisticated, but also a lot more complicated to use. You can either let it do all the allocation itself, or you can pass it an existing buffer allocated with `malloc()` and it will use it if it's big enough, or else it will resize it with `realloc()` if it's not big enough. In either case, the caller is responsible for freeing the result, just as with your `fileToString()`. There's not really a middle ground -- either you put up with fixed limits or you manage dynamic resources by hand and hope you have the discipline not to write a memory leak, double-free, use-after-free, etc. 
Can you tell why is that there is just 'one true' low level language? We have a handful of popular higher level languages such as Java, C# or Python.
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void fileToString(FILE *f, char *contents, int length); int main(int argc, char const *argv[]) { const char *filename = "testfile.txt"; FILE *f = fopen(filename, "r"); fseek(f, 0, SEEK_END); int length = ftell(f); fseek(f, 0, SEEK_SET); char *contents = calloc(length + 1, sizeof(char)); /*Remember that a string needs a '\0' in the end of it, so you have to allocate the length plus one, for the '\0' in the end, and calloc will initialize this array with all elements as '\0' */ fileToString(f, contents, length); fclose(f); printf("%s\n", contents); free(contents); return 0; } void fileToString(FILE *f, char *contents, int length) { fread(contents, 1, length , f); } But doing this, having a function like fileToString would be pointless. Also, you should try Valgrind to check memory leaks
You can open the file in the main function too, and use it in the function.
`getLine()` sounds like it might get around the issue. If I `malloc()` a size zero array in main, it will get resized automatically with `realloc()` then then can be `free()`d in main, so the allocating and freeing happen in the same logical space.
The typical pattern is something more like: ssize_t fileToString(const char *path, char **buffer) { FILE *f = fopen(path, "r"); fseek(f, 0, SEEK_END); int length = ftell(f); fseek(f, 0, SEEK_SET); *buffer = malloc(length); ssize_t nbytes_r = fread(*buffer, 1, length, f); fclose(f); return nbytes_r; } Then you'd use it like this: char *line; ssize_t nbytes_r = fileToString("filename", &amp;line); `nbytes_r` has a return value, the number of bytes read, 0 if nothing is read, -1 for error, etc, while line now contains memory holding the entire file. Remember you'll still have to free it though. This gives you the advantage of being able to return an error code while also tracking just how big the read was as well.
C has other competitors in the embedded space. They're just not as popular. Ada, Fortran, Pascal and lots more languages have overlapping capabilities with C at the embedded end of the scale. Ada in particular is used by a number of U.S. government and aviation companies. But C has the advantage that it's C. It links with C libraries. Every platform has a C compiler. Every low level programmer knows C syntax. Every major kernel is written in C. Every major device driver is written in C. In the embedded space, being able to integrate with the other components is probably the single most important requirement and that means being able to use C headers, C function calls and C linkage. Until a language comes along that is just as efficient as C but *much* better than C, the fact that C is already everywhere means that the easiest choice for integrating with everything else is always going to be: C.
I don't see how that really changes anything -- you're still on the hook for freeing the returned value, the same as with your `fileToString()`. What does having a dummy call to `malloc(0)` really add to the situation? The function is still doing the (real) allocation, same as with your `fileToString()`. (By the way, the behavior of calling `malloc(0)` is implementation-defined; it can either return a null pointer or a pointer that's unusable but distinct and which can be passed to `free()`. So you can't portably rely on it. Also, you risk leaking memory if you try to pass a size zero block to `getline()` as that indicates that it should call `malloc()` and not `realloc()`, but the documentation doesn't specify what it does when size is zero but the pointer is not the null pointer.) 
It makes slightly more sense to me because main is responsible for allocating and freeing the memory. If main didn't know anything about how fileToString worked or didn't care, they might not know to call free on what they got back.
Well the "true" low level language, if there is such a thing, would be assembly. It makes no sense to write in assembly for applications that need to run on several different platforms or may need to be ported later. C can be compiled for pretty much any target so people use that. Also, assembly doesn't have any nice constructs (structures, arrays, etc) to allow easy ways to organize data for readable code. Let the compiler keep track of the variables.
Thanks this helped a lot! And yes i just relized that next never becomes null. Haha, for some reason i read the i-&gt;next = next statement backwards, and thought that next was now equal to null because i-&gt;next was null... Guess i wasnt thinking! 
Learning the [functional programing paradigm](https://en.wikipedia.org/wiki/Functional_programming) can help with writing threaded code. If you've got the time, [SICP](https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs) is a decent teacher. As a general rule of thumb the closer a program is to stateless the easier it can be threaded without problem or complication.
C++ is C with a bunch of shit added; if you know C++ you already know C. Of course, that isn't entirely true, but it should get the point across -- you don't need to learn C unless you have a reason to. Years ago a central part of a project needed to be accelerated. It was written in Perl, so the solution at the time was to take the number crunching part and split it between Perl and C, primarily because C is faster than C++ in certain situations. In this situation manually making char arrays instead of std strings was faster. When the time comes you'll need to learn very little. I wouldn't worry about not knowing C if you already know C++.
Good point with assembly. However I had the low-level-just-above-assembly in mind. Something that is a real alternative to C. I must admin I'm not aware of anything like that, used widely. I also never searched for it so maybe I'm just missing some obvious languages (isn't Google Go an example?).
If you want to try real microcontroller programming, the Freescale Kinetis line is brand new and super cheap (dev boards range from $10 - $20 depending on the model). Way more rewarding than an arduino, because you actually learn real fundamentals of embedded development, instead of the dumbed-down arduino environment.
Oh great - I tried to help out and now I'm getting spammed by smarterer.com - so much for the "... I promise we don't send off any spam." Let this be a warning to others who might be thinking of taking the test to help out.
Create data structures. Start with something simple, single linked list. Use pencil and paper often to understand how the links change with insertion and deletion. This will get you comfortable with a lot of concepts in C, especially pointers. If you are feeling ambitious, try making it handle arbitrary data types. Then make a double linked list, stack and queue. Then binary search tree, heaps and hash table. Doing all this you will learn a lot. 
Thanks for the tips. I'm not quite at that level... I think I have a couple more chapters in this book before I get to linked lists or pointers. But I'll be sure to look into that! 
Have a look at the beginner challenges at codeeval.com, when you get better you can move on to the harder ones.
My go-to when I'm learning a new language is tic-tac-toe.
Thanks! I'll give that a look when I get home.
You'll spend an inordinate amount of time writing and debugging parsers. Handling text or strings is largely a manual process. Get some practice there.
/r/dailyprogrammer - for programming challenges of varying difficulty
I haven't seen that sub before. Thank you.
oh I didn't realize it wouldn't display like this but at the bottom where it says "quartersquarter" and such it should say quarters*quarter
 int penny=1; // &lt;- remove the int, the compiler thinks you are trying to declare 'penny';
&gt; It’s when I learned what may be for me the most important UNIX tool to date: strace. (Footnote points out it was actually Solaris and truss.) Okay... love strace and truss; both are great tools and have solved many problems with them. But... seriously? Even with DTrace out? Both strace and truss utterly pale compared to DTrace. 
There we go, does that look alright?
[This course](https://www.edx.org/course/harvardx/harvardx-cs50x-introduction-computer-1022) has 8 problem sets that involve C programming, you should try solving them. There's also [Learn C The Hard Way](http://c.learncodethehardway.org/book/) by Zed Shaw, it has many exercises and tips.
C does not have such a `//` operator. Instead C (the 1999 version) uses two consecutive slashes to indicate the beginning of a comment that runs to the end of the line. Basically the compiler is ignoring everything on the line after those slashes. Use a single `/` to do division and you can use `%` to get remainders: quarters = change / quarter; change2 = change % quarter; Though of course your original code for getting the remainder `change2 = change - quarters * quarter;` calculates the same remainder as `%`, as long as you do the original division correctly. 
The '//' you are using is not divide with remainder, its the start of a comment. quarters = change//quarter; Is actually seen by the compiler as: quarters = change As you can see, the compiler does not see the the ';' at the end of the line, which is exactly the compile error. Despite this mistake, the general code layout will work. qs = c / q // -&gt; this gives you the quotient. c1 = c - q * qs // -&gt; this effectively gives you the remainder, though % would work too. 
the "-i" option is probably my favorite
answer1, answer2 and answer3 need better names. It doesn't look like you're using "experience" why take it as input if you just comment out its use. Also, "How many months of experiece do you have?" is not a yes or no question. Always check what the user gives you. What happens if I enter X instead of y/n If you end up using "experience" you should make sure it's an integer rather than a character. char y and n aren't being used from what I see. you declare them but you're doing your comparisons against 'y' and 'n' not y and n. When you expect your input to be a 'y' or 'n' you might want to make them chars instead of integers Always test your program. With something like this, for a learning exercise, it wouldn't hurt to step through line by line with the debugger and inspect everything and see what is actually happening.
Just to illustrate my point, I haven't changed anything but whitespace: #include &lt;stdio.h&gt; int main() { int answer1, answer2, answer3, experience; char y, n; printf("Have you previously worked in a game store? (y/n)\n"); scanf("%c", &amp;answer1); printf("Do you have any experience in sales? (y/n)\n"); scanf(" %c", &amp;answer2); if (answer2 == 'y') { printf("How many months of experience do you have? (y/n)\n"); scanf(" %c", &amp;experience); } printf("Do you like video games? (y/n) \n"); scanf(" %c", &amp;answer3); if (answer1 == 'y' &amp;&amp; answer3 == 'y') printf("Congratulations, you are hired!\n"); // else if (experience &gt;= 3 &amp;&amp; answer3 == 'y') // printf("Congratulations, you are hired!\n"); else printf("I am sorry. Your credentials do not match what we are looking for.\n"); return 0; }
Yes i agree. I went through that book step by step and it really helped me. They handle pointers better than any book I've seen.
Do your own homework.
So what is the question you wanted to ask? Nobody is going to do your homework for you.
Do not take it as an insult, friend, but the people here will not do your homework for you. If you would've tried to do it yourself and asked us what you did not know, then we would have gladly helped... If you do this, how will you ever learn?
okay, some people have already solved this problem, but I think I might be able to also fix some other things. here's how I'd write that code: #include &lt;stdio.h&gt; int main(void) { //I split up the variable declarations to make it more readable, you should group //declarations by relevance, not by type int pennies, nickels, dimes, quarters; int change = -1; const int penny = 1; const int nickel = 5; const int dime = 10; const int quarter = 25; /* * use of consts is suggested if you want the value not to change, this is more of a * recommendation than a rule though, but it is good practice */ printf("Please enter the amount of change required between 0 and 99 cents:\n"); scanf("%d", &amp;change); while(change &gt; 99 || change &lt; 0) { printf("please enter a value between 0 and 99:\n"); scanf("%d", &amp;change); } /* * This while loop is to check if the value of change is a valid one, until * they enter a value &gt; 0 and &lt; 99, it will keep asking. */ /* * you set change to 0-99 in its initialization, I imagine in the language * you are used to this sets a range, however, in C this sets the value to -99 * (in which case -99 could be used instead) */ quarters = change / quarter; /* * note, if both operands are integers, division will return an integer; thus 76/25 * will return 3 */ change -= quarters * quarter; /* * the -= operator is allows you to simplify x = x - y to x -= y as they are * entirely equivalent, I imagine you use multiple variables because in your * "native" language you can't set variables more than once * (maybe a functional one?) */ dimes = change / dime; change -= dimes * dime; nickels = change / nickel; change -= nickels * nickel; pennies = change / penny; printf("The change is %d quarter%s ", quarters, quarters == 1?",":"s,"); printf("%d dime%s", dimes, dimes == 1?",":"s,"); printf("%d nickel%s", nickels, nickels == 1?",":"s,"); printf("and %d %s.\n", pennies, pennies == 1?"penny":"pennies"); /* * edit: split the original printf up into several statements, this was mostly cos it was * annoying me knowing that I'd written such a disgustingly long statement... */ /* * The %d strings in printf must have an extra argument for printf for each one, * thus your program will just print %d instead of the value */ /* * I've used %s here to insert a string, and the ternary if operator (which works * as &lt;condition&gt;?&lt;condition true&gt;:&lt;condition false&gt;) to choose the right string * for the occasion */ return 0; //unnecessary, but good practice to include a return 0 from main. } if you have any questions about this, just reply to this comment. Note the two different ways of using comments in C, the // comment, which extends to the end of the line (and is the cause of your "expected ; before ..." errors) and the /\* ... \*/ comment which starts at the /\* and ends at the first instance of \*/ after /\*
Thank you.
You're correct, this is how it should be: void callFun(int ***array, int *blocks) { (*blocks)++; *array = allocFun(*array, blocks); } And call it with: int **array; /* ... */ callFun(&amp;array, &amp;blocks); The problem is you're overwriting what is effectively a local copy of the pointer instead of the memory address that that pointer is located in. 
Don't over complicate this foo = realloc(NULL, size); And foo = malloc(size); Are equivalent statements. You do *not* ever need branching to know if you should use malloc or realloc. You can just use realloc with your array initialised to NULL.
Ok thank you, nice to know!
I'll try that and will give you an update… EDIT: OK, with the example I gave you here, it works like a charm, but in my longer code I can't get it to work. Pretty hard to figure out since it compiles without errors or warnings and on execution it just gives me a segmentation fault. I know it's because I want to write a 1 into a two-dimensional integer array in a place, which *should* be realloced by another function, but it still doesn't… I kinda want to give you my source code on that but I'm not sure...
Wow. First time I see a true triple star programmer on reddit.
This is the 'C' sub, not C++. The styles of the two programming languages and the people who use them are often different. There are small parts of the C++ project you linked which were written C-style, but most uses regular C++ constructs. I see some inconsistencies (comment styles, long lines etc.) but I'm really not a good judge of C++ style so I'd recommend trying /r/cpp/.
So it's possible that you're accessing memory that isn't assigned to you. Or dereferencing an uninitialized value. One of the values in the second dimension of your array would be my guess for the problem. Maybe an off by one index or something. Too many possible causes.
I'd normally try to find an alternate method before using a triple star... but it was the simple solution. The better way would have been to return the newly reallocated array from the function.
Yeah, you are right… I'll look into it more tomorrow, maybe I'll come back to you, but thank you until now.
I've looked briefly but I think it was written by someone who is used to write C++ based on the following things: - use of initializer list - use of const reference and const method - namespaces - operator overloading - class pre-declaration instead of include when possible - use of non-standard `#pragma once` (but supported on most compilers) - C++11 
You don't have hardware flow control on your RS-232 interface? That's what it's for.
The PDP-8 has no way to buffer but a single character. If that single character buffer is filled, everything else thrown at it will be discarded. The receiving loop on the PDP-8 has enough delay in processing characters that it will sometimes drop a character or two. The routine that does this reads in some number of characters fairly quickly, then returns back to the program when done. Thus, it can drop characters in between the character-handling routine. So yes, the baud rates are matched (9600 baud), but the character rates are very different. Without hardware or software flow control, I'm having to create my own by inferring what the PDP-8 is doing when I send a character.
Wow. That sounds like a pain. But it seems you have a decent grasp of the issue! What exactly is that hardware for? 
It's just for fun, really. I collect vintage computers, and this one happens to be my favorite for various reasons. My current project is building its operating system (OS/8) from scratch, which is tricky since it was intended to be built from certain devices like cassette tape and paper tape using a reader with that reader run control. I've made my own system device for it, which emulates a disk over a second serial port. It's all working now, but I still have some improvements to make. 
That sounds like a blast! Good luck man. I toyed with the idea of trying to get a OS set up on my own. I got as far as running a bootloader on a VM and that's about it haha. 
There is an online course here (https://www.edx.org/course/harvardx/harvardx-cs50x-introduction-computer-1022) that teaches generally computer science, but starts with C in the first few weeks. If you know enough C that you don't need to watch lectures etc. you can just do the problem sets. They also have "hacker" editions to provide more challenge. This course also has a subreddit at - http://www.reddit.com/r/cs50 -
Oh I just posted the same course without seeing it here :)
Hi, your question might do a little better in /r/learnprogramming however to get you pointed in the right direction I highly recommend the following books * C Programming: A Modern Approach, 2nd Edition by K N King * C Primer Plus, 6th Edition by Stephen Prata * Head First C by David and Dawn Griffiths * The C Programming Language, 2nd Edition by Brian Kernighan &amp; Dennis Ritchie (commonly known as K&amp;R) If you are on Windows then check out http://latedev.wordpress.com/2011/06/20/how-to-install-a-c-compiler-on-windows/ to get a C compiler installed. It is for C++ but it is just as valid for getting the C compiler installed too (FYI the C compiler is *gcc* and the C++ compiler is *g++*). Also if exclusively on Windows I highly recommend [Pelles C](http://www.smorgasbordet.com/pellesc/) which is a complete (free but not open source) C development environment. For good Windows text editors I recommend [Notepad2](http://www.flos-freeware.ch/notepad2.html) (free), [Notepad++](http://notepad-plus-plus.org/) (free), [Sublime Text](http://www.sublimetext.com/) (not free) and [UltraEdit](http://www.ultraedit.com/) (not free). Good luck!
That's a very clever idea! I ended up finding a delay that would work well enough for transferring data, but it did take about 30 minutes to transfer 8kB. For more details on what I was doing: OS/8 V3D can be built from paper tapes. First, you load the BUILD tape into the PDP-8, then you configure your system with the device drivers you want to use. Next is to start building the system. This requires writing some blocks to the system disk (in my case, a disk server I wrote on my PC that talks to it via a second serial interface) and then asking for the OS/8 monitor. This is a second paper tape. This is the one that it kept getting hung up on due to the buffer overruns. After modifying the device driver that operates the paper tape reader to slow down the timeout period some, I was able to find a suitable character delay to get that tape to load. Next tape is the command decoder, and then from there you have a fully functional system. I should mention that my paper tapes are just binary files that I send over the serial port. The paper tape reader handler just polls the serial port, since it (back in the day) assumed you had a Model 33 ASR teletype with punch and reader. [This](https://www.youtube.com/watch?v=YkqVJ6ShV5A) is the culmination of my efforts so far.
Pretty much. I don't have any parallel I/O boards (or else I'd try that with a microcontroller), but I did finally get it working. [Here](https://www.youtube.com/watch?v=YkqVJ6ShV5A) is a video of it in action.
Would like to add to my upvote with an endorsement for king's book.
[learn c the hard way](http://c.learncodethehardway.org/book/)? just to get you going.
You may have forgotten to `#include &lt;stdlib.h&gt;` . Also you are malloc`ing the wrong number of bytes. If you use this canonical form of malloc then you avoid the second error; and if the first one occurs the compiler will diagnose it for you: tracker = malloc( sizeof *tracker ); 
There are several issues in your code. First, your use of the size of malloc as seen here (you can find this error several times in your code) : root=(struct node * )malloc(sizeof(struct node * )); What you think you're doing is allocating a memory area of the size of your structure. What you're actually doing is allocating a memory area of the size of a pointer to your structure. What you actually want is this : root=(struct node * )malloc(sizeof(struct node)); Also there is a big memory leak here : p=(char*)malloc(sizeof(word+1)); p=word; First you're allocating some memory for 'p' to point to, then you reassign 'p' to point to the same adress as 'word' points to. So basically the memory you have previously allocated is lost. Also, I think when you wanted to do : p=(char*)malloc(sizeof(word+1)); You actually wanted to do this : p=(char*)malloc(strlen(word+1)); 'word' is of type "char *", so 'sizeof(word)' will return the size of the pointer (usually 4 bytes on x86 and 8 bytes on x86_64), not the length of the string it points to. So basically, since your allocations are wrong (smaller than they should since you allocate the size of a pointer instead of the size of the struct), after several allocations then content of your structures will get overwritten. 
Ho, after reading the way you use your 'ws_add_word()' function, I think you should use strdup(), so instead of : p=word; Use: p=strdup(word); If you don't dupplicate the string and just use pointers, here is what will happen: * You allocate some string on the stack ("char s[10];") and fill it. * Then you pass it to your function that just take the adress 's' points to and store it in your struct. * Then you overwrite what is stored "in" 's' and pass it to your function again. Well since you just used the same memory area BOTH element in your struct point to the same address so they point to the same content. 
 char *p; p=(char*)malloc(sizeof(word+1)); p=word; This doesn't do what you think it does. Word is `char *`, so `sizeof(word + 1)` is `sizeof(char *)` which will be (most likely) 8. Its the size of a **pointer**, not the length of the string. It is always the same size. (hint: `strlen`) Also this is C. We don't cast the return from `malloc`. Doing `p = word` now assigns `word` to `p`. Your malloced block of memory is thrown away. &gt; every time I try to add a new string to the tree, the root gets over written! Right, because you don't understand what you're doing with memory at all! So... lets start here: char s[10]; This is an array. strcpy(s,"d"); n = ws_add_word(s); Now you copy "d" into the array. Then call `ws_add_word`. Now lets look at this again: char *p; p=(char*)malloc(sizeof(word+1)); p=word; The end result of this mess is actually `p = word`, which is.... `p = s`. So then following lines get evaluated: tracker-&gt;word=p; ... root=tracker; And all is good (well, except for more useless mallocs; you outright threw away and leak all the memory allocated in `ws_init` which, hint, never needed to be allocated in the first place). But the hidden implication here is that: root-&gt;word == s As in, `root-&gt;word` points to the same block of memory that `s` is. So, when you proceed to then do strcpy(s,"abc"); You've now changed the contents of the memory of `s`, which also happens to be the piece of memory `root-&gt;word` points too. Which is why you now see "abc" even though you don't actually have code to add another node to the tree. 
Hey, I am a newbie, but I am currently in a Data Structures class in C, and I am loving it! I have an observation/question here with regards to this code. What I notice here is that you create a struct node named root in your init function, but the function returns a 0 or a 1, not a pointer to your new struct node, In the the ws_add_word function you do take a pointer to a character as an argument, but since you do not have a pointer to root in the previous function, so this would not be able to be passed to ws_add_word (not to say you would necessarily want to) In this ws_add_word function, you reference a root of struct node type, but have not declared a struct node root in this function. Wouldn't these be local to each of the aforementioned functions, you can use a pointer to mimic pass by reference, but since this is not present in the first function, it would not be possible here? Maybe I am bit confused, but recently I have created a similar set of functions, and in my initializer function I returned a pointer to my new created object, to be utilized. 
Worth noting that technically `strdup` is a BSD extension, it won't be available if the OP needs this to compile as pure C. Just in case.
Even so, root is a named space in memory for a struct in the init function, and even if you returned a pointer to it upon success, this root node would still be local to the init function, and would have no meaning in the ws_add_word function...?
This is personal, but the 3 IDE's/ editors I have liked and seen used successfully: Mac: Xcode Linux: Emacs Windows: Visual Studio (friend's use this one for C programming) Xcode is free on the mac, and emacs is free on linux :) 
I think it has been in POSIX for more than ten years and also appeared in SVr4, although the first one to implement it was 4.3BSD, but yeah you're right, it is not part of the standard library. It's not a big problem to implement your own if it is not present. 
Yup. It'll be hidden behind a feature test macro for either BSD, XOPEN, or POSIX 2009
Yep. If you are allocating a contiguous array rather than a single node, then multiply the `sizeof` expression by the length of the array.
Actually `root` is a global, which will work as long as OP doesn't need more than one binary tree.
Visual Studio is sucky for C as the support for C99 is crap and the support for C11 is non-existent. As I mentioned in my other comment [Pelles C](http://www.smorgasbordet.com/pellesc/) is pretty great on Windows for C development. I mostly use UltraEdit (I have a lifetime license from long ago) and TDM-GCC though if I can. 
So what is it you need help with? Rather than just giving us your homework assignment to solve, try solving it yourself first and ask specific questions.
When you just copy and paste a homework problem and ask no questions you leave little choice but to assume, as no one is just going to do your homework for you.
untested, i take no responsibility if this formats your hd const char* int2col(int col_index) { // lookup table static const char* col_table[] = {"dummy", "black", "red", "green"}; // make sure index is within table bounds col_index = col_index &lt; 1 ? 1 : col_index &gt; 3 ? : 3 : col_index; // return dat string return col_table[col_index]; } edit: or did you mean enums? enum { black = 1, red = 2, green = 3 }; 
Very interesting thanks for posting.
To my knowledge: &gt; I don't quite understand what a "literal" or "integer literal" is. I see sometimes in the book where variables are declared like long i; i = 5L;. Why is the L included? I looked it up, so I know that it is a suffix you can add to long ints, but doesn't C do this already? The suffices u, l, U, and L are used to prevent losing precision or to restrict what the compiler can do with your literal. An integer literal is basically a number. Any number. In your example, the L suffix doesn't really change anything but consider a case like this: unsigned long i = 5UL &lt;&lt; 20; If you don't specify UL, the compiler will pick whatever container it pleases for 5 (possibly unsigned short) and shifting that by 20 might cause a different result than what you hoped for. It is also used as a hint to the reader in some cases. For example: #define CMD_OPEN 0x1013UL Let's say CMD_OPEN is what we use to write to a register. In this case it tells the reader what the size of the command should be to use this definition. &gt; Is there a point to _Bool? All 0 values are already false, and non zero values are true, and C seems to operate on them as such, so why would I use it? There is a point but you're encouraged to use &lt;stdbool.h&gt; starting with C99. _Bool macro is hidden from you. &gt; I tried using splint, but all it seemed to want to do is dump errors, even though the program compiles and runs properly from 3 different compilers. I am also using "-Wall -Wextra -Werror" flags for GCC and get no problems. Is splint just old, and would there be a better alternative. My experience with splint and similar tools is 50/50. They're sometimes useful to catch hard-to-catch errors but they usually produce a lot of false positives. There are some commercial tools that are supposedly better but I usually just rely on common sense and gcc. &gt; I know from skimming through other C books and reading this one, there is another language that runs that operates on the text of the program. Should I avoid using this if at all possible? I don't understand this. &gt; Is there a good reference for stuff like string modifiers (%.2f, %d, etc)? man 3 printf ? &gt; When is a good time to start learning and using tools like doxygen, valgrind and other debuggers. When you need them. &gt; I am trying to learn only c99 and earlier features so that any programs I make will be compatible with as many compilers as possible. Is this worthwhile? Learn C99. Compiler compatibility, in my opinion, is rarely needed these days. That said try to stay with basic ANSI C constructs for the most part and use C99 features only when they have a clear benefit. &gt; If there was 1 book or website you could pick for C reference, what would it be? [Infrequently asked Questions in comp.lang.c](http://www.seebs.net/faqs/c-iaq.html) 
I can't comment on all your questions but here are a few that stand out (I'm treating your bullet points as if they were numbered from 1): 1. A literal is a bit of information you explicitly type into your program. For example if you said "strcpy(buffer, "Hello world");" then the text is a literal - it's not stored in a variable (until you copied it into the buffer). Regarding the "L" suffix - there are times when it is useful - for example if you are mixing longs and ints in an expression you might want to actively say to the compiler that this literal is a long and not just an int. 4. I'm not sure what you mean. Are you referring to the pre-processor? If so you can't ignore it - that's what adds your includes and macros. 5. I always just type "man printf" - either at the Linux command prompt or into a browser to remind myself of these 6. No time like the present! Valgrind can save you a ton of pain if you get used to using it now. Debuggers as well - get used to stepping through your code. 8. Everyone will probably say K&amp;R for one of the best reference books. There are easier introductory books though.
&gt;I don't quite understand what a "literal" or "integer literal" is. I see sometimes in the book where variables are declared like long i; i = 5L;. Why is the L included? I looked it up, so I know that it is a suffix you can add to long ints, but doesn't C do this already? It has been covered in other comments, but I want to underscore the comment. A literal (as in literary) is a value itself, written down; the value is literally what is written. Variables, by contrast, are names of or references to (varying) values. The confusion between the two is the fundamental source of many problems in programming and in life. [Magritte should have been a hacker.](https://en.wikipedia.org/wiki/The_Treachery_of_Images) Alternatively, [the map is not the territory.](https://en.wikipedia.org/wiki/The_map_is_not_the_territory) &gt; I know from skimming through other C books and reading this one, there is another language that runs that operates on the text of the program. Should I avoid using this if at all possible? I believe you are referring to the difference between compiled and interpreted languages. Given the source code text of a program, to run it must be converted into machine code for the processor. For compiled languages, the machine code is output, once, to a file, which may then be run repeatedly. For interpreted languages, the program is interpreted (compiled) and run at the time the program is run. However, this is more than just doing things in one step; the interpreter can reinterpret (recompile) while running using information from the running program. This allows many optimisations; for example, simply optimising the sections of the program that are running the most.
OK let me break down the first one again. **Literal:** Think of it this way. An integer literal is literally an integer. Like 5. Or 19. Or 203040. Pretty much any time you see a literal number, it is referred to as an integer literal. Same thing with strings like "Hello, world" or other types. The suffices: C allows u, l, U, and L for integers. The upper/lower case symbols are interchangeable. So let's go back to our example: int i = 5 &lt;&lt; 20; The &lt;&lt; operator means "shift left." You would represent 5 like this as a binary number of 8 bits: 0000 0101 Shifting left this means take every digit and move it to left. The left-most digit falls out, and the rightmost digit is filled with a zero. So shifting our 8-bit value 5 left by 1 to 5 would produce (in order) 0000 1010 # shifted left by 1 0001 0100 # shifted left by 2 0010 1000 # shifted left by 3 0101 0000 # shifted left by 4 1010 0000 # shifted left by 5 Now what happens when we shift it one more time? The left-most 1 will fall out. However, if this were a 16-bit number, the left most 1 would simply jump to the next available location: 0100 0000 # 8-bit value shifted left by 6 0000 0001 0100 0000 # 16-bit value shifted left by 6 If you were to print these numbers the first one would print 0x40 (64 decimal) while the second one would print 0x140 (320 decimal). Back to the u and l. When we add these restrictions to a literal, we're telling the compiler "store this value as an unsigned" and "store it as a long." If we don't, the compiler might likely pick the smallest possible container. Let's say in our machine the integers can be 8 or 16 bits. If we leave it to the compiler, the compiler will store 5 in an 8-bit register and will use 8-bit instructions to operate on it. Although the resulting container is a long (16 bits), the compiler will first perform the operation and THEN will store the result in a 16 bit register. In compiler's world, when we wrote: unsigned long i = 5 &lt;&lt; 6; We told it to: Create a value of your desired size that corresponds to 5. Shift this value to left by 6. Store the resulting value in a 16-bit container and call the container 'i'. But if we do this: unsigned long i = 5UL &lt;&lt; 6; We told it to: Create a value of 16 bits (unsigned long in our machine) corresponding to 5. Shift this value to left by 6. Store the resulting value in a 16-bit container and call the container 'i'. I hope this explains it better.
Okay, I see now. So if I got it right, the literal itself has no size associated with it, so if you want to operate on literals directly, you must specify type otherwise the compiler will do what it wants. If that is correct, then I think you explained it perfectly.
Hey, you might want to take a look here, it's the best list I've seen so far. http://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list
I think you might want to look at an established C libraries. If you do need to implement your own, you can at least get some layout/design ideas from them. They are probably more generic that you need right now. https://developer.gnome.org/glib/stable/ http://www.gnu.org/software/gnulib/ http://sglib.sourceforge.net/ 
Look into some unix stuff. Try finding an OS course from a decent university and do the projects (the first couple [here](http://homes.cs.washington.edu/~zahorjan/homepage/Tools/LinuxProjects/) are nice an teach you some nice concepts, especially using fork/exec). Also look into implementing some unix utilities, start with a really simple version of ls and add more and more features. 
[SDL](http://www.libsdl.org/) is most likely what you want :)
I'll check it out, thanks!
Since you've gotten good answers I think for everything else, here's why you have `bool`. Because it makes things explicit. 0 as false, not 0 is true isn't, arguably, even the most prevailing use int. For example, 0 success, values less than zero each represent errors. Or a positive return value returns the number of bytes operated on as well. So in order to encode these models more explicitly, I think its best to use bool, size_t or ssize_t as appropriate in type signatures. It makes for a richer more descriptive API.
SDL2 with a renderer does support rectangles (used it for a little snake game originally). For what op needs, it sounds like enough. SDL2_image will let you load a bunch of images as a surface that you can then convert to textures. The nice part is that SDL_RenderCopy will scale your texture to fit the destination space, so a single pixel color png file will fill a 20x20 space if needed.
If my predicted competence at this project is proportional to the amount I understand what you're saying... i'll be in for some 'fun'. My previous experience with graphics is drawing with Java's Swing libraries.
It says "There were build errors. Would you like to continue and run the last successful build?"
yaaaaaaaaaay I got it to work on my own. Had to use scanf_s instead.
that was just an error in copying the code. I noticed the missing semicolon already and fixed that but it still didnt work. I changed "scanf" to scanf_s and it worked...i really dont know why but it did
I don't know man. This is my first C programming class, and the error at the bottom said something about "scanf may not be safe" or something and then scanf_s worked...I'll see what my prof says I guess
https://code.google.com/p/cprocessing/
I thought so but it wouldn't run until I changed 
As far as 2D graphics APIs go, http://cairographics.org/ is extremely popular. Cairo won't actually create a window and set up a drawing context for you though. Typically a toolkit like Gtk http://www.gtk.org/ or Qt http://qt-project.org/ is used for that part.
As everything in Linux, it depends on what you want to accomplish. You could use low-level X drawing commands and make a really lightweight implementation. Or you could use OpenGL bindings and make a 3D world. If you just want a desktop application with a 2D screen with big pixels, check out [Cairo](http://cairographics.org) ([tutorial](http://cairographics.org/tutorial)): it's a 2D drawing API with the option to render to a canvas, SVG or PDF. It's pretty standard on Linux and also available on other platforms.
Write your own interpreter. Check out Bison and Flex. Alternatively, some historically relevant C is the [Lions Commentary](http://www.catb.org/~esr/jargon/html/L/Lions-Book.html). You should really check that out if you have any interest in Unix. 
Meh, once you understand the jargon of SDL development in makes sense. SDL1 used a system where the window had its own drawing surface (essentially a multi-dimensional array of pixel data), where you draw (or blit) pixels and other surfaces (such as loaded images). If you set the window up with double buffered rendering, you virtually had two surfaces and you 'flipped' between on update. SDL2 changed this. Instead of a drawing surface being tied to the window, they split it up into a window and a renderer. To draw, you set up the window to show a particular renderer (you can have a bunch, you can even have a renderer create textures pushed to another renderer, maybe for a minimap), then throw textures at the renderer. Why did they do this? Mainly because it was a huge PITA to get multi-windowed applications working correctly.
C not C++
&gt; You could use low-level X drawing commands and make a really lightweight implementation Can't personally recommend that, my experience with Xlib has been quite brain damaging. Cairo is great though, solid tip.
Both Cairo and Gtk are C.
qt is not
Wait...C can make stuff like a GUI? I thought I could only program console stuff! Edit: You guys really shouldn't downvote people for asking questions about the language. Some of us aren't here because we're experts on C Programming like you. Some of us subscribe to this sub so we can learn. It was a legitimate question...all I've ever done in C so far was Microcontroller stuff and programs that do work in the Terminal. Don't be bullies. 
Thanks for this. Bookmarked.
Pretty much everything that does graphics is programmed in C or C++, or in a language like Java or Javascript/web-browser that has a runtime that is itself written in C or C++. 
Jesus lol. I'm glad I'm a super noob, or else I'd feel bad for not knowing that! I started teaching myself programming when I was about 15 with Visual Basic, so I guess I just assumed that it and a few others like Java and stuff were the ones for GUI's. I never really knew C could do that stuff, except with directly instructing screens to display stuff like with text LCD's. 
I'm not certain, but I suspect that Visual Basic itself is written in C or C++.
If you don't feel like using a full GUI toolkit for this, cairo can also draw directly on X windows that you set up with Xlib (or xcb for that matter). However, this can become a little painful.
Thank you for your insightful reply..will consider this for sure
Yeah me too Thanks for the assist
SDL_ttf works best for roman script text. If you want complex text shaping, use harfbuzz for creating the text and render it with SDL.
I've done a few simple apps where I used Xlib to set up the window and event loop and then passed the surface on to cairo for drawing. Still, Xlib can be gruesome at times, especially when you ask it to actually draw things. Event-handling is somewhat sane though -- at least not more brain dead than in some of the GUI libraries out there.
Would you mind listing some of these cases? I can't think of anything right now that really *needs* inline assembler, on this side of some things in kernel programming. Making things faster by utilizing special instructions doesn't count.
It's not video based, but the Head First C book might be close to what you're looking for. It's very informal and leads you through practical examples without being a dry text.
This YouTube [Play List](http://www.youtube.com/watch?v=3CA1Su58SG8&amp;list=PLQndNexFjUWnRdVNiyFf9u2aO0o1CqS8G) has over a hundred videos. But I haven't watched any of them so I can't tell you how good they are. If they aren't your style, just look around on YouTube. You should be able to find somebody whose voice doesn't make you want to jump off a cliff. 
This looks good, thanks! 
Glad to help.
I had to drop down to inline once to write my garbage collector's stack iteration. 
Not only can C do GUIs, but you can do GUIs in basically every scripting language using GTK or Tk or another library.
Just knuckle down, buckle down, do it, do it, do it.
Bitwise rotation ("ror", "rol" assembler instructions) is one that comes up occassionally, particularly in crypto or checksum algorithms. C has bit shift operators ("&lt;&lt;", "&gt;&gt;"), but not rotation (where the bit "pushed off the end" ends up on the other end). It can be faked in C, but it's way more efficient to do it in assembler. Also, as noted, certain kernel-level operations ("sti", "cli", related to interrupt processing, etc) are best done at the assembler level.
Is it a GET request? If that is the case you can put it at the end of the URL, for example: http://httpbin.org/get?verbos=1&amp;count=10
I think adding something like the following statement before performing curl will do the job: curl_easy_setopt(easyhandle, CURLOPT_POSTFIELDS, "start=2014-01-01&amp;stop=2014-02-01&amp;verbose=1"); Source: http://curl.haxx.se/libcurl/c/http-post.html Edit: Actually, /u/tebexu is right, there is no reason that this should be POST request. For a GET request modifying the URL to contain the parameters should be enough.
&gt;I think adding something like the following statement before performing curl will do the job: &gt;curl_easy_setopt(easyhandle, CURLOPT_POSTFIELDS, "start=2014-01-01&amp;stop=2014-02-01&amp;verbose=1"); worked like a charm thanks guys
/u/OldWolf2 has excellent advice. *Always* use that form of malloc, i.e. never cast the return value as you did and always use sizeof(\*variable) and not sizeof(type). It will save you a *lot* of trouble. About casting: Don't cast the return value of functions returning void\*. It's just confusing and error-prone and adds no value. If you actually run into a compiler or static code checker that complains if you don't cast (and I'm only aware of slint in it's default configuration), it's broken and you shouldn't use it.
It will be hidden it you target -std=c89 or any other c standards. POSIX c isn't standard c
There is no such thing as "standard C". There's a bunch of dialects that are more or less standardized, and POSIX is one of the more standard APIs out there. The only reason to restrict yourself to ANSI C89 is if you're forced to use a crappy proprietary compiler that still doesn't implement specifications that came out 13 years ago (POSIX-2001) and you really have no way of throwing it out the window and use a proper one.
Nice link.
Read [Lua](http://www.lua.org/download.html), [Plan 9](http://plan9.bell-labs.com/sources/plan9/) and [SQLite](http://www.sqlite.org/download.html) source.
Those videos use Dev-C++ and the example code is correspondingly ancient. For example `main` gets defined with an implicit return type: main() { ... } This was a bad practice when it was legal and it was made illegal back in C99 (as in 1999, fifteen years ago). At the very least one should get a modern compiler that provides good warnings so that it can inform the user of problems in such ancient example code. Furthmore, C actually has changed a fair amount since that material was current; both C99 and C11 have introduce significant features that won't be covered by that material.
Type the three functions into your text editor, and type a main function too. Then fill them in. After that, compile the program with a compiler such as gcc, and run it to see if you did it right. Might need to repeat a few times. Once it seems to be working, turn in your homework. Okay seriously though -- do you, like, have an actual question? I don't know what "ensuring that prototypes actually relate to something" means.
You're going to have to give us something more to work with. The problem description is very explicit and unambiguous; what are you stuck on? If you have some code written already, post that. The most generic advice is to split the task into small sub-tasks. Get the 4 input numbers and print them out. Then write the max function, make sure it works correctly. Etc. What does "ensuring that prototypes actually relate to something" mean?
The variables (a, b, c, d and result) are addresses in memory. **a** might be 0. It is a pointer that points to that memory address. **b** might be 8, and **c** might be 16. These are all pointers. We can do **a + b**. That is syntactically correct, but what we get is 8. Because all we did was add 0 to 8. Remember that, you can perform arithmetic operations on pointers because they are in fact just a glorified number that the compiler knows points to a cell in memory. So let's say we want to add the values contained in **a** and **b**. We simply use the dereference operator (also known as the indirection operator or the value-of operator), an asterisk. Imagine that the chunk of memory that **a** points to (0) contains a 64-bit integer, 13, and the chunk of memory **b** points to (8) contains another 64-bit integer, 6. Remember, if we just add **a** and **b** we get 8, because 0 + 8 = 8. We want to take the values of **a** and **b** and add them. We dereference them. **\*a**, meaning value-of **a**, must equal 13. **\*b** must equal 6. So **\*a** + **\*b** = 13 + 6. You can also assign the value of a pointer, and it works the exact same way. If we do **b** = 16, **b** now points to the same chunk of memory **c** points to. But we don't want that, we want the value of **b** to equal 16 instead of 6. So again, we use the value-of operator. We dereference **b** and assign it a new value. **\*b** = 16. I suppose that with this implementing the above program should be a breeze, as all it requires is expansion of what I just described. Please, if you want me to elaborate, comment here or PM me :)
What you are complaining about is not in the C language itself, they are completely in the toolchain. The #ifdef of the first two are part of the C pre-processor, not the C language and autotools isn't necessary to use, but were written to simplify the configuration process. Header files are also not required, they just provide a convenience to allow you to collect external declarations in one file that can be reused. You can always put the declarations you need in every source file directly. Many existing IDEs completely hide the make tools details from you, and if you aren't worried about providing cross-platform configuration, then don't use the autotools. So if you don't like the C pre-processor, what would you suggest as an alternative to header files and conditionals that can be defined at compile time?
[An Alternative to PVS-Studio at $250](http://www.viva64.com/en/b/0228/). See: Table 1. Comparing features of PVS-Studio against CppCat.
dont know why that line of numbers is small, but thats just the top row labels.
Please use pastebin.com next time. Your final for loop does nothing. It is terminated by the empty statement - a semicolon. You need parenthesis. You don't need the variable 'c'. I first thought you were trying to print column by column but I think you're trying to print row by row, just not using the row variable. So: * First print the top header * for each row: * print the row step (i.e. -10, -8 etc) * for each column: * print column * row * print newline
your inner for loop has a ; on the end so the print statements aren't actually in a loop. If you consistently use {} and indentation it will make your life easier. Even if there is only one statement in the loop. for( ; ; ) { for( ; ; ) { } } Also, it doesn't make a difference to your output (because its square), but the row should be in the outer loop, and the column in the inner. This is because the inner loop prints for each column for a single row, then the outer loop advances the row and runs the inner loop again. 
The `4` is a minimum field width. If the number contains fewer than 4&amp;nbsp;digits, enough spaces will be printed before the number to pad it out to 4&amp;nbsp;characters.
Learn one now: https://www.kernel.org/doc/Documentation/CodingStyle. Like someone else mentioned future you will thank you.
ah right, nice one :)
Thanks!
Just register for the key. Express keys are free.
man 3 printf ?
Dido. Just do it in an iterative method. First make sure you can accept user input, then make sure you can produce some output (which can double as a debugging tool for the rest of your program), then write the logic portion to make it work as the assignment requires. Just write something. There is no way you will find the exact answer on the internet........just go one step at a time.
Looks like it works perfectly fine. Unless that multiplication table is not exactly what OP wanted.
You can rewrite the leap function without any if/else if you know what you are doing. Here is another tip: `if (a == b) if (c == d) {...}` is equivalent to `if (a == b &amp;&amp; c ==d) {...}`. You need to use the leap function at the correct place. I'm guessing the 'where and how' is part of your assignment. If you still have problems with the fundamentals of the language may I suggest taking a look at this [book](http://cm.bell-labs.com/cm/cs/cbook/)
I would also suggest learning ragel state machine compiler (and parser generator). It can dump code for other languages, not just C, so it's very useful.
In your main function, you should be returning 0, which is common practice for signaling that the program ran properly, instead of dayofyear. In your switch statement, you seem to mess up at case 11. I assume you're going for 303 instead. If you've learned about arrays, you can drastically shorten up that huge switch statement into something smaller, and more elegant. I'd recommend putting all your int declarations within the main function. (That would mean having to pass year into leap along with dayofyear.) Finally, I'm not sure I've ever seen an algorithm for checking leap years that involves checking if the dayofyear is over 59. Your leap function needs another else statement to go along with your second if statement. What happens if the dayofyear is greater than 59 and the year is divisible by 4 (goes past the first if statement), but is also divisible by 400 (failing the second if statement)? There's nothing there to catch that. It can't just drop down to the else from the if above it. (I'm learning C myself, so I don't expect my insights to be perfect.) 
A set of parenthesis would go around those two conditions! if( (foo &amp;&amp; bar) &amp;&amp; (blah || blahh) ). 
For those who don't want to login to download the paper: http://inf2270.at.ifi.uio.no/programmer/historien-om-C.pdf
pastebinned it. its in an earlier post reply. Like i said earlier, i have the code working exactly as i want it to now, I am just looking for pointers on good indenting and curly bracket placement. Also, redundancies or arbitrary things in my code, like how you said i dont need the "c" variable.
yea, thats some clean motha fuckin for loops. thanks for the tip
No, `const` and `restrict` mean different things. The `restrict` modifier means that the compiler can assume that the object to which that pointer points either is not modified or is not referenced in any other way in the function. If the object is modified, then all access to that object must be done through that pointer. So, for example, in your `mmul` function, since you have declared the pointers `a`,&amp;nbsp;`b`, and&amp;nbsp;`c` with the `restrict` modifier, you must not call `mmul` in such a way that any of these arguments point to the same object. Doing so results in undefined behavior. The `const` modifier, when placed to the left of the asterisk, indicates that the function cannot change the value to which the pointer points; when placed between the asterisk and the name of the pointer, it indicates that the function cannot change the value of the pointer variable itself.
Here is the article on dmr's page: http://cm.bell-labs.com/cm/cs/who/dmr/chist.html Also, please look at dmr's home page, there are some cool things on there: http://cm.bell-labs.com/who/dmr/
ah ok, i see. It's just like fortran then. Thank you! I'm not that into x64 assembler but i'll try to work out some examples to see when it uses reloads in both cases(static vs. dynamic allocation). I have a feeling gcc is quite smart in optimizing static arrays in this case in c89 mode. The arrays in the main program are allocated like this: #define N 1000 float a[N][N], b[N][N], c[N][N]; (and are global btw since stack space)
Well I made a couple of changes as I went along. * -var is now var * -1 * the for-loops are not exactly how he had them * made a comment on (var &lt; 0 &amp;&amp; var &gt; 10), can never be true
Look at the [coding style](https://www.kernel.org/doc/Documentation/CodingStyle) linked earlier. A couple of things specific to your code: * Closing curly braces should be on their own line. * Always use curly braces for nested for-loops. In your code not only have you left the curly braces off, but you haven't indented the lines correctly so you could easily be confused as to which line runs in which loop. * `c=c+inc` can be `c += inc` * Space out your operators. `col&lt;=max` is easier to read as `col &lt;= max` * It's a good idea with variable names to be descriptive. If you are too lazy to type out the longer variable name each time, then get a better development environment (gedit will just frustrate you when you write longer code)
First of all, this has nothing to do with C whatsoever, so this is the wrong subreddit. Secondly, you haven't used the proper formatting, so the code is being mangled by reddit. 
Subtracting 48 from each character will convert them to integers. http://www.asciitable.com/ The ASCII value for '0' is 48. '1'-'9' follows as 49-57. So if you have '0' which is really 48 then subtract 48 from it you get 0. This works for all digits as well. '1' is 49. 49 - 48 = 1, etc.
Please don't [repost](http://www.reddit.com/r/C_Programming/comments/1xrfss/im_a_beginner_and_i_need_some_help_i_have_an/).
it's not a repost it's a different problem :'(
In reddit markup, asterisk means *italic* so your post looks weird the way it is. You want this: int total = 0+2*8+3*0.... 9*9 In better words: 1 * digit_1 + 2 * digit_2 + 3 * digit 3 + ... + 9 * digit_9 Since I don't like doing anyone's homework, here's some pseudo code: * Loop until you reach end of string character which is \0 * Use sscanf() to read one "character" at a time from the string. Use the loop index as the offset to the string's starting position. * Add to total: (loop index + 1) * (digit - '0') There might be a simpler way.
What happens is that you have a variable called 'again' which doesn't have a value set. &gt;char shape, again; When you changed those lines as you mentioned above, you never changed this line &gt;while (again == ' y' || again == ' Y'); So because 'again' wasn't initialized and never had data assigned to it now, you get the warning about the variable being used but not initialized. The value of the variable is essentially random yet you check to see if it'll contain 'y' or 'Y' which it may or may not as its now random. 
You're checking the 'again' variable against 'Y' though? :D
I added char again = (1 || 0); and I do not get the error anymore, but it exits after the first prompt.
thank you i know exactly what you meant! 
It's cool man. lgauthie already said it but for C you want to use the [linux kernel coding style](https://www.kernel.org/doc/Documentation/CodingStyle). Most people writing C use either that, the style used in the [K&amp;R White Bible](http://en.wikipedia.org/wiki/The_C_Programming_Language) or something inbetween. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**The C Programming Language**](http://en.wikipedia.org/wiki/The%20C%20Programming%20Language): --- &gt;**The C Programming Language** (sometimes referred to as **K&amp;R**, after its authors' initials) is a well-known [computer programming](http://en.wikipedia.org/wiki/Computer_programming) [book](http://en.wikipedia.org/wiki/Book) written by [Brian Kernighan](http://en.wikipedia.org/wiki/Brian_Kernighan) and [Dennis Ritchie](http://en.wikipedia.org/wiki/Dennis_Ritchie), the latter of whom originally designed and implemented the language, as well as co-designed the [Unix](http://en.wikipedia.org/wiki/Unix) [operating system](http://en.wikipedia.org/wiki/Operating_system) with which development of the language was closely intertwined. The book was central to the development and popularization of the [C programming language](http://en.wikipedia.org/wiki/C_(programming_language\)) and is still widely read and used today. Because the book was co-authored by the original language designer, and because the first edition of the book served for many years as the de facto standard for the language, the book was regarded by many to be the authoritative reference on C. &gt;==== &gt;[**Image from article**](http://i.imgur.com/Kh4eCQH.png) [^(i)](http://commons.wikimedia.org/wiki/File:The_C_Programming_Language,_First_Edition_Cover_\(2\).svg) --- ^Interesting: [^The ^C++ ^Programming ^Language](http://en.wikipedia.org/wiki/The_C%2B%2B_Programming_Language) ^| [^C ^\(programming ^language)](http://en.wikipedia.org/wiki/C_\(programming_language\)) ^| [^C++](http://en.wikipedia.org/wiki/C%2B%2B) ^| [^C ^Sharp ^\(programming ^language)](http://en.wikipedia.org/wiki/C_Sharp_\(programming_language\)) *^\/u/PonderingGrower ^can [^delete](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cfe761i)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less.* ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 55240:%0Ahttp://www.reddit.com/r/C_Programming/comments/1xmyn7/lords_of_c_i_need_some_help/cfe75xc)
Yep, when you're using global arrays, the compiler can already tell that they don't alias. It's only when the compiler cannot tell on its own (like when you're using arbitrary pointers) that it makes a difference. If it doesn't know whether two arrays alias, it has to assume that they might, so it emits slower code that will work even if they alias. If however you promise that they don't by using the restrict keyword, then it will emit the faster code (which will silently fail if you then violate your promise by passing in aliased pointers.) Here's a great article with lots of examples to demonstrate how restrict works: http://cellperformance.beyond3d.com/articles/2006/05/demystifying-the-restrict-keyword.html Const, on the other hand, rarely if ever affects performance. It's a tool to help you catch errors at compile time, and not usually something the compiler uses for optimization.
It looks like a script to log into a remote host (ssh) and start in a directory passed to the script rather than the remote's $HOME. I haven't parsed it fully, mostly because I don't care to guess where the missing \*s go, but the "cd $t;$SHELL" pretty much gives it away. It's still nothing directly to do with C though.
Wow, that *is* a lot of old-timey spaghetti code. Don't worry about it though, that's how we all started. It's late and I had my first beer, so I couldn't bring myself to tracing down the flow through your code, but maybe I can help you by giving you a hint. This looks like the kind of problem that is easy once you find the right way of thinking about it. Since you asked for a logic hint, how about this: if you place a tab in a line somewhere, the tab will fill out the space till the next tab stop. Where are the tab stops? If your tab width is 4, they are at 0, 4, 8, 12, 16, 20, and so on. Let's work through some examples to get a feel for the problem. If you're at column 0, the next tab stop is 4. If you're at column 1, the next tab stop is 4. If you're at column 2, the next tab stop is 4. If you're at column 3, the next tab stop is 4. If you're at column 4, the next tab stop is 8. If you're at column 5, the next tab stop is 8. If you're at column 6, the next tab stop is 8. If you're at column 7, the next tab stop is 8. If you're at column 8, the next tab stop is 12. If you're at column 9, the next tab stop is 12. .... So assuming a 4-space tab, the next tab stop is always at the next multiple of four. (For a 5-space tab, it would be at the next multiple of 5.) Can we model this in a function? How do we find the next multiple of four for a number? Hint: the modulo operator is useful here. colnum % tabsize gives you the number of characters between the current position and the next tab stop. Taking the column above and assuming a 4-space tab: 0 % 4 = 0; 0 + (4 - 0) = 4 1 % 4 = 1; 1 + (4 - 1) = 4 2 % 4 = 2; 2 + (4 - 2) = 4 3 % 4 = 3; 3 + (4 - 3) = 4 4 % 4 = 0; 4 + (4 - 0) = 8 5 % 4 = 1; 5 + (4 - 1) = 8 6 % 4 = 2; 6 + (4 - 2) = 8 7 % 4 = 3; 7 + (4 - 3) = 8 8 % 4 = 0; 8 + (4 - 0) = 12 9 % 4 = 1; 9 + (4 - 1) = 12 .... The last column looks interesting...
I'm sorry, I don't follow your code. It seems overly complicated and also assumes lines will be shorter than MAXLINE chars. I'd suggest you don't read whole lines. Just read characters (like in detab) and emit a tab whenever possible.
&gt; So the difference is explicitly forbid aliasing then? Not explicitly. The compiler won't print an error (because to do so at compile-time through static analysis would mean solving the halting problem, etc), but will believe the programmer's contractual promise that the pointers will not alias, and optimize accordingly. It doesn't matter whether the source arrays were allocated dynamically or statically or are even the same pointer. C doesn't track that. `*restrict` only influences how the function body itself may be optimized.
Yeah, this program can be written to consume characters one at a time. Basically keep a count of what column number you're at on the current line on both the input and output. Then the main loop looks like: while (c = get character) { adjust the input column number if c is a blank then { do not output it and do not adjust the output column number. } else if c is a newline then { output c zero both input and output column numbers } else { output tabs and spaces until your output reaches the right column number to output c, adjusting the output column number as you go output c and adjust the output column number } } This above just happens to also remove trailing white space from lines, which I did just because it's easier that way.
It seemed interesting when I tried it (maybe three years ago) but it was rather instable. I had segfaults in a &lt; 100 lines application and was unable to debug it. The community being nearly inexistant, I just ditched the language.
so what have you done about it? what have you tried so far?
Read the purpose of the asterisk (*) in [this page](http://www.cplusplus.com/reference/cstdio/scanf/) Edit:by the way, if you want to get both the characters and the floats, you can simply scan them both in the same fscanf or one after the other.
This isn't "Do my C homework for me". You'll never get anywhere like that. I suggest you try asking a better question, but I'll try helping just in case you're mentally challenged and can't figure out the basics for yourself. You probably already know how printf and for loops work: int i; for (i = 0; i &lt; 3; ++i) { printf("%d\n", i); } Now what you want to do to print your triangle. You don't seem to know how to format reddit posts, so your triangle came out wrong in the example, however it's quite obvious that it doesn't need to be adjusted in any way so you can just print it out directly. Actually after typing all this I'm kind of insulted, so I'm going to give you the answer in hopes that you smack yourself in the head with a book and don't come back with such stupid questions. int i, j; for (i=5; i&gt;0; --i) { for (j=1; j&lt;=i; ++j) { printf("%d",j); } printf("\n"); } Now, don't come back until you have actual questions about C. And don't forget to understand the code snippet so that you won't get 0/10 for not commenting properly.
oh look! this IS "do my C homework for me"
Probably re-reading the first chapter of your text book will not only answer your question, but give you a better foundation to work from than having a stranger provide the solution.
Ok thank you. I am currently reading "THe C programming Language" by Kernighan, and practicing. 
the simplest thing that comes to my mind is why not to fork the server part of the code?
yes, i see, this is the same as fortran does it. i shouldn't have used explicitly. English is not my (and yours i think ;) native language, i have a hard time picking the right words sometimes. Assume it doesn't alias might have been better.
 fscanf( file_pointer, "%s %f\n", pointer_to_char_array, address_of_target_float ); 
this or threads. Forking is easier though. Threads will work better on non unix platforms.
Yes, the compiler can check whether they overlap, but only with handles directly to statically allocated arrays. If a and b aren't knowable at compile-time, then a+n &lt; b+n isn't knowable either, so the compiler has to emit code that works whether or not this is true. Restrict can also be used in more cases that can't necessarily be checked by the compiler even with global arrays. For example if a loop reads from an even-index value and writes to an odd-index value of a global array on every iteration, you could speed this up by using two different restrict pointers to the same array, because you know (and can therefore promise to the compiler) that reads through one pointer will not affect writes through the other, even though they point to the same address. In general this is not something that compilers can figure out on their own even with totally fixed addresses to global arrays. The important thing to realize about const is that it doesn't say that the data doesn't change; it says that *this handle* cannot be used to change the data. The data could certainly be changed in other ways because there can very well be (and often is) some non-const handle to the same data elsewhere. For example suppose my function has a pointer to some data, and it reads from it, then calls a function, then reads from it again. We'd like the data to be cached and re-used after the function call so we don't have to load twice. But is this safe? No, because the function could have changed it. Now suppose the pointer is const. Does this make it safe? Still no - because the function you're calling might have access to some other non-const pointer to the same data, so the function might still have changed the data. Just because our pointer to it is const doesn't mean all pointers to it are const. This is why const doesn't improve optimization; it only helps to catch bugs and design problems.
Thanks!
It's not a fad since it's been around for a while but IMO it has very low real world penetration. I've heard people use it in universities for research projects and stuff but don't know any major product that is written in D. So is it worth it? It depends on what's worth to you. Learning new things is always good and it forces you to think in different ways to solve every day problems. That itself might be worth it. But it probably won't be worth monetarily or career-wise. Could it replace C? No. There is just way too much experience and code in C.
Not a D guy, but a few coworkers are fans, and I've overheard them talking.. From what I gather, they (they as in the D developers) used D as sort of an experimental place for new C++ features. Several of the things that made D unique made it into C++11..So since C++11 came out, interest and development in D has slowed to a crawl. Keep in mind this is 'second hand' info I get from listening over the wall.
I don't know much about D, but from what I've heard it's C++v2. So no, it wont replace C.
Didn't Facebook start using D? that's a pretty big project.
I'm not a D programmer, but as I understand it, it's possible to use D without garbage collection, but it renders much if not all of the standard library unusable, which negates a lot of the attraction in the first place. There will always be people for whom GC is just not an option (drivers, kernels, real time systems, embedded systems, resource constrained systems, aerospace/avionics, etc.) so C isn't going anywhere any time soon. I'd say that D is competing with C++, not so much C. 
ok but when using const * const both the pointer and the array values should be 'static' and known at compile time when not called with volatile i think, or not so? const * or const * const is quite a difference. I says *both* data and pointer can't change (but maybe only for that value specified or so then?). So with another const index for looping.... but that might be to much for a compiler, i'll understand. The gsl however seems to perform adequatly with only const, i wonder how some functions compare to blas for instance.
That's a little tricky because D is really more an alternative to C++ rather than C - so the answer would largely be the same as if you asked whether to use C++ over C for a given project, just with further discussion about how D might be even better than C++. I suggest asking this in /r/d_language/ (after searching for similar questions to see if they satisfy you). A lot of D programmers are very seasoned C++ programmers (such as the designer [Walter Bright](http://en.wikipedia.org/wiki/Walter_Bright) and author of "The D Programming Language" [Andrei Alexandrescu](http://en.wikipedia.org/wiki/Andrei_Alexandrescu)) so they can comment on it vis a vis D. Incidentally those guys are both active on Reddit, so who knows you might even get an answer straight from the horses mouth. [Andrei's AMA](http://www.reddit.com/r/IAmA/comments/1nl9at/i_am_a_member_of_facebooks_hhvm_team_a_c_and_d/) might have some relevent information as well.
Been drinking a bit, so I am not in the state to comment on your program, but I did clean it up and move it to pastebin so other people can read it. Please use pastebin or a similar tool in the future, it helps a lot for people to help you! http://pastebin.com/9DtjUWn2
Gahhh! I was trying to think of the name of that site! Thank you very much kind anon!
Okay, Going to make some comments. See http://pastebin.com/tVSMbTRZ
The code needs to contain: max(&amp;value[0], &amp;value[1], &amp;value[2], &amp;value[3], &amp;answer[0]); min(&amp;value[0], &amp;value[1], &amp;value[2], &amp;value[3], &amp;answer[1]); mul(&amp;value[0], &amp;value[1], &amp;value[2], &amp;value[3], &amp;answer[2]); one of the requirements 
Ah, gotcha. I understand sometimes code assignments are not always "logical", and sometime ask you to do silly things for the sake of learning how things work. in that case, at least fix your function definitions to match your declarations at the top. Also, when debugging, printf is your best friend! try putting something like this at the top of each function: printf( "MAXDBG A: %d B: %d C: %d D: %d\n", *a, *b, *c, *d ); This will help you make sure everything is at least making it in as planned.
okay, here's my fixes: inefficiency with lack of returns and abuse of pointers aside, there are several things wrong with this. in the ternary operators to check for min/max you write (a &gt; b)? *a : *b; (c &gt; *d)? *c : *d; this is where the problem lies, because a, b, c and d are pointers saying a &gt; b tests whether the memory location's numeric representation for pointer a is greater than the one for pointer b, what you really want is (*a &gt; *b) which will find the ordering of the values stored inside that memory location, same with mul, you dereference some of the values, but not others. this is where your program is going wrong. these issues probably stem from the declarations of your functions which are ambiguous, I imagine they're supposed to take 5 pointers (as per the top declarations) but the actual definitions of the functions take a normal int followed by 4 pointers (int a, int *b, int *c, int *d, int *result) to (int *a, int *b, int *c, int *d, int *result) if you have any questions, just reply and I'll try to help
What do you mean by branching? Because I don't think it means what you think it means. And frankly, this is the second time we have this assignment posted here. Have at least the decency to understand your problem and the question you want to ask. I know this is an assignment, so I won't make a comment about the stupid signatures. But your errors show clearly that you don't understand what you are writing. First, the signatures don't match (The declarations are fine, but you ommited an asterisk when copying them...). Second, you forgot to use the dereference pointer in max and min (during a comparison). Third, your use of scanf is incorrect (hint: currently you are writing only one int and only at (&amp;value[0])...). -- #include &lt;stdio.h&gt; void max(int *a, int *b, int *c, int *d, int *result); void min(int *a, int *b, int *c, int *d, int *result); void mul(int *a, int *b, int *c, int *d, int *result); int main(void) { int value[4]; int answer[3]; printf("Enter 4 values:\n"); scanf("%d %d %d %d", value+0, value+1, value+2, value+3); max(value+0, value+1, value+2, value+3, answer+0); min(value+0, value+1, value+2, value+3, answer+1); mul(value+0, value+1, value+2, value+3, answer+2); printf("The max is %d. The min is %d. The mul is %d\n", answer[0], answer[1], answer[2]); } void max(int *a, int *b, int *c, int *d, int *result) { int temp[2]; temp[0] = (*c &gt; *b) ? *a : *b; temp[1] = (*c &gt; *d) ? *c : *d; *result = (temp[0] &gt; temp[1]) ? temp[0] : temp[1]; } void min(int *a, int *b, int *c, int *d, int *result) { int temp[2]; temp[0] = (a &lt; b) ? *a : *b; temp[1] = (*c &lt; *d) ? *c : *d; *result = (temp[0] &lt; temp[1]) ? temp[0] : temp[1]; } void mul(int *a, int *b, int *c, int *d, int *result) { if (*d == 0) { fprintf (stderr, "Dividing by 0."); exit(1); } *result = (*a * *b * *c) / *d; } --
No, C++11 is what I would consider to be a "2.0" version of C++. In summary: - 1.0: C++98 - 1.1. C++03 - 2.0: C++11 - 2.1: C++14 (planned) - 3.0: C++17 (planned) D in its current form is not a successor to C++ any more than Java is.
"2.0" is often used to mean a derivative but distinct product, e.g. Doom ][ vs Doom I. Similar mechanics but definitely a different game. So in the same sense, D is like an improved version of C++ (in the author's mind), it's not backwards compatible, it's a different language, but it is a progression of sorts. 
Id recommend taking a piece of paper and writing out just how each queue relates to each semaphore and that might help you see why it hangs.
&gt; just with further discussion about how D might be even better than C++. I think this is a good opportunity to remind that programming languages have a huge number of features and particularities. They are designed with certain purposes and even taste in mind. You can't simply say a language is "better" than other language without specifying some criteria. It's like saying a person is "better" than another in everything. It's a silly oversimplification that's never based on facts.
Yes, agreed. To be clear it was deliberate that I framed the discussion in the context of "for a given project" - since that clause directly precedes the "better" it should be understood that "for a specific thing" is implied.
You'll find people will be more responsive if you show that you've attempted to solve the problem, even if your attempt is wrong.
You have to analyse the input first. The file format is pretty simple: First line is the header, with info about the window geometry. Each subsequent line is made of 4 numbers. First two are the x and y coordinates in the console output. Third one is the filler character. Fourth is the length of the string of filler character appended. Your program will thus be pretty simple. First, find a way to read the file line by line, and to read each numbers separatly. Then, you need a way to control your terminal (write in it at a specified coordinate). I'm pretty sure the Windows API offers such capabilities, you only need to find documentation. The general program should be in the form of begin open file filename Loop Until EOF int x,y,filler,len; getline(filename,...,x,y,filler,len); for (int i = 0; i &lt; len; ++i) { console.put ( x+i, y, "%c", filler); } End Loop end I don't know the windows API for console control, but there should be a function that could do the trick nicely. Edit: Actually, maybe Windows does not offer such capabilities (with Linux, you would need external dependencies like n-curse). the solution would be to allocate a char array of the initial geometry and then to dump it all. That way : open file filename int height, width; sscanf(getline(filename), "%d,%d", &amp;height, &amp;width); char *screen = malloc ((height * (width+1) + 1) * sizeof(char)); // we fill the screen with space characters... for (int i = 0; i &lt; height; ++i) { for (int j = 0; j &lt; width; ++j) { screen[ i * width + j ] = ' '; } screen[ i * width + width ] = '\n'; } screen[ height*(width+1) ] = '\0'; Loop Until EOF int x,y,filler,len; getline(filename,"%d,%d,%d,%d", &amp;x, &amp;y, &amp;filler, &amp;len); for (int i = 0; i &lt; len; ++i) { screen[y * width + x + i] = filler; } End Loop printf ( "%s", screen ); free(screen);
I'm not expert here, but to me it seems, given the huge amount of freeing missing, that valgrind actually does not recognize the correct hook. I know that you have to specify to valgrind that you will be using specific GNU memory allocation for example, for it not to count those as memory leaks in GNU utilities. I guess it could be the case here. Edit: Actually, dismiss that. You are using valgrind on MacOS (would have been nice to say...). Valgrind is broken on this system, use another profiler (or a virtualbox).
Thank You so much!! I just needed the first half of your response, when you broke down the program into simpler terms.
Doesn't Windows have conio.h for more controlled console i/o ?
Why not? C is a great first language. It's very small and simple and you learn the basics.
Can't go wrong with K&amp;R. I also used 'A Book on C' for my course, I liked it, a bit more wordy but compliments K&amp;R well. 
I learned C in high school as a first language and I turned out just fine. Since you have at least some idea of Java syntax you should have very minimal trouble picking up C; Java syntax is mostly derived from C! The only trouble you might have is with pointers, but from skimming the chapter on pointers I think C Primer Plus does a fine job. It goes into a lot of detail about memory, and the diagrams should help a lot. As for the Head First books, I have found them to be helpful in the past as they make rather dense topics interesting and accessible. The C version seems to throw a lot at you very quickly, so definitely use it as a second book, or maybe even use it in parallel with C Primer Plus if you're having trouble understanding some topics. As always, feel free to ask for help here or in /r/leaningprogramming! 
K&amp;R is certainly on my reading list however I have had a read through the first chapter on Amazon and it seems that it might be a bit too much for me just now. I need my hand held a bit to build up some confidence ;)
I appreciate your reply but C is the language I want to learn first as I would like to work with an Arduino. I understand there are easier (perhaps better) languages to begin with such as Python but I learn best when I have a goal in sight and an Arduino is that goal. I would be interested to know your reasons a) why not C first? and b) what is, in you opinion, a better/best first language?
For sure. From my own experience with K&amp;R it might be a bit overwhelming but the concepts presented there are very clear and you should read it slowly and let it sink in. If not, Head First series tend to get a lot of good reviews. Good luck. 
Thanks for the info. I am certainly going to pick it up and read through it soon as I know it is *the* book for learning C. 
Yeah, I'd like to get vera++ setup in Vagrant, but there's no ppa or deb for Ubuntu 12.04 Precise.
C is perfect when studying compsci theory at the same time. In regards to the OP: The only real book your need is K&amp;R. There are other books on C (plenty); I have not found a book on C that eclipses K&amp;R -- why would you *not* want to learn from the authors. 
I highly recommend [C Programming: A Modern Approach by King](http://www.amazon.com/Programming-Modern-Approach-2nd-Edition/dp/0393979504). Try a library if you can't afford a copy. With that said, your other books should be fine.
Thanks. Do you mean Programming in C by Kochan? 
Yes. Sorry for not linking the book before. The book is definitely longer but it is more up to date and has very good exercises. 
Because C has dark corners. If you are unable to manage loops and array of arrays dealing with memory allocation and other things is not in your learning priority just now. It's not my view, I just agree with this old one. I don't like the python, but it is the standard for learning basic nowadays.
C programmer by trade for over 20 years. Without a doubt the most important book IMHO to have is C: A Reference Manual, Harbison and Steele. I don't even own K&amp;R anymore. 
Thanks for your reply, I understand C has a lot of "nasty" behaviour when you are not extra vigilant so I am going to try and learn the best practices (like using Valgrind from day one) and learn safe C design. I can see a lot of the standard library functions have newer more secure versions so I am have a search around for every new function I encounter to see if there is a newer/better function I should use in its place that some of the older books do not cover. Hopefully I can learn from the lessons others have learned over the past few decades! Cheers.
Thanks I have added it to my reading list!
I still suspect this whole 'lock-free' to be marketing bs. If you have true parrallel execution you need some sort of synchronization, and that means locking or stalling other writers.
&gt; If you have true parallel execution you need some sort of synchronization, and that means locking or stalling other writers Yes and no. While a thread writes to a shared resource, you obviously need to prevent other threads from writing there during that write interval. However, with a conventional locking scheme you basically interrupt all other threads and tell them to twiddle their thumbs until the lock is gone. The alternative I've successfully employed in some of my code is to use a series of multiple-read single-write state variables. Specifically, for every shared memory location you allocate a number of boolean variables (each padded to fill exactly one cache line) equal to the number of threads sharing said memory. Every thread gets exclusive write access to a different one of those booleans, whereas read access to them is shared among all threads. With this setup I use the following procedure whenever a thread wants to write to shared memory: if all booleans other than mine are zero: set my boolean to one to signify that I want to write soon do_something_unrelated_but_more_useful_than_thumb_twiddling() if all booleans other than mine are zero: write_to_shared_memory() set my boolean to zero to signify I don't need to write soon (or have temporarily given up on doing so given contention) If more than one thread tries to write to shared memory at the same time the first conditional above will obviously not catch that fact. The trick then is to spend enough clock cycles doing something else useful for the CPU to have synchronized any non-atomical writes to the boolean state variables by the time the (identical) second conditional is evaluated. If another thread wants to write too, that second conditional will fail, sets its booleans to zero, and execution jumps either back to the first conditional or elsewhere. The disadvantage to this approach is that writing to shared memory can be delayed quite a bit (so not suitable for urgent writes). The advantage again, is less thumb twiddling by non-writers, provided they have something else/better to do. Caveat: this is just the scheme I came up with and I have no idea if it resembles what is normally considered lock-free programming, but I suspect it to be something similar (albeit probably more sophisticated).
&gt; do_something_unrelated_but_more_useful_than_thumb_twiddling You just blew my mind! I was wondering, is the above simply a call to a different method, or executing some other code?
Focusing on the single cache line issue, does this imply the machine architecture determines some limits on the algorithm? I know that machine features largely determine the possible atomic primitives and it seems like that same thing is happening here, yes?
Actually, that cache alignment aspect might not be necessary. It's been quite a while since I read up on the gritty details (much of it indeed architecture dependent), and I can't remember why I vaguely recall it being needed (or faster). Sorry. I hope someone more knowledge than me can fill you in on that. Or maybe I'll edit this text after I've *refreshed my memory*...
&gt; I was wondering, is the above simply a call to a different method, or executing some other code? It could be either, but in my case it was event based server software I was writing, so I would just dump pending writes to shared memory on a thread-local FIFO buffer and handle the next incoming event (most of which don't involve writing to shared memory).
Enqueueing synchronized queues requires locking too, so you'd just be pushing the same problem down to square one, no? *edit*: Actually, you can create lockless queues too. They require similar trickery to what I mentioned above though, so they aren't necessarily any simpler. And if you can bear with another cop-out: Performance really depends on the data you're working with, so it's worth profiling any scheme that seems interesting.
Seriously, you used imgur and not a paste bin? I didn't even read it. My advice: run it in Valgrind.
Please never Post code as images. Use a pasting service instead.
strtok is not crashing. strcmp does not protect against NULL.
THANK YOU!!!! Much simpler than we thought. :D 
If this is an assignment for a class and strtok was hinted at by a teacher then please ignore my post but, strtok is really a very basic parsing function. It's something you really don't want to be using for a shell. For example with what you have now |||||| will be considered a delimiter, as will | | | |&gt; et cetera.
You can also buy the book [here](http://www.lulu.com/shop/axel-schreiner/object-oriented-programming-with-ansi-c/paperback/product-17561597.html).
I tried reading this book, and remain unconvinced. It seems like the whole idea setting up structs with pointers to functions, to emulate methods -- but you need to declare every method that a given datatype might use. This means either you have a single Class struct with every conceivable method, or have a separate ListClass, StackClass, etc., along with the associated functions to call the methods in the struct (NewList, NewStack, etc.). Is it only syntactic sugar or am I missing something?
If memory serves the usual reason for cache line alignment has to do with paging and how certain atomic operations, or possibly memory barriers, need to have their containing structures fit within a single cache line, but I could very well be mixing up topics concerning embedded application performance. Something like a lockless algorithm might as well have a per CPU lock if there might be a page fault in the middle of the execution of the shared resource access... it's been a while for me as well and I probably only read one thing.
Well, there is a reason that C++ quickly moved beyond simply being a C preprocessor. But the book does at least show how one could implement the mechanisms behind C++ classes. For a somewhat more ambitious take on extending C yet again with OO powers, you might check out this one: http://arxiv.org/abs/1003.2547 It is available here: https://github.com/CObjectSystem/COS It takes a very different approach, which borrows from the other lesser-known OO traditions such as Smalltalk and CLOS. It is also notable for insane CPP hacks; it'd probably make more sense to write a smaller syntactic translator in a reasonable language if you wanted to put it to real use. The CPP stuff is a neat hack, though!
Underneath of any OO system, you see these same basic structures. Whether they're coded in C or Pascal or have long since become self-hosting such as C++, it's still the same kinds of magic underneath. The language that goes on top of it is typically sugar added to make dealing with some of the pain that handwriting this code has. The book does a really good job about talking about some of the trickier aspects of implemented OO systems as well, such as dynamic dispatch and exception handling. It takes you through a complete implementation, so you can compare it to others such as the implementations you'll find powering [Vala](https://git.gnome.org/browse/glib/tree/gobject/gobject.c), [Python](https://github.com/python-git/python/blob/master/Objects/object.c), [Ruby](https://github.com/ruby/ruby/blob/trunk/object.c), [Objective-C](http://www.opensource.apple.com/source/objc4/objc4-532/runtime/NSObject.mm)*, etc. Hell, even the Linux kernel has [kobject](https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/linux/kobject.h). *: Objective-C is a compiled language, but its object system is largely mediated by a runtime library with an unholy mixture of C, Objective C, and C++.
It allows you to implement polymorphism, so you can hook in different implementations, while everything else that uses your struct does not need to be concerned about the implementation being different. Consider the standard `FILE*` glibc on linux allows you to set up your own read/write/close function pointers in a `FILE*`. This allows you to write an implementation of a `FILE*` that does something entierly different than a `FILE*` you get back from `fopen()`. However, existing code can just call `fread()/fwrite()` on your customized `FILE*`, without any concern that there's something special about it. This whole idea is used quite a lot in large C applications, and is heavily used in e.g. the linux kernel - it's quite hard to make general code if you need to care everywhere if the mouse driver is serial or usb, or if a file descriptor refers to a pipe/socket/tty, or For structures such as a Stack/List it's normally not that useful. Though, I don't particularly like the approach taken in that book, with a separate pre-processor and so on - it seems too convoluted. 
Just like you (as a person) do - by using context. The reference operator is unary, the bitwise and operator is binary. See here: http://tigcc.ticalc.org/doc/opers.html
Is [this](http://www.siggraph.org/education/materials/HyperGraph/video/mpeg/mpegfaq/huffman_tutorial.html) any help? Looks pretty promising to me.
If the numbers are truely random compression doesn't make much sense... why bother?
&gt; If the numbers are truely random compression doesn't make much sense... why bother? *truly _uniformly distributed_ and random. Huffman codes work best when the input *is* composed of random *and* independent input symbols but with a non-uniform distribution. If your input is non-random and/or exhibit input symbol inter-dependency there are better codes than Huffman codes. OP: what is *n* in this case? Input size, number of unique symbols or something else?
The same way it knows the difference between the 'negative' operator and 'subtract' operator even though both use the symbol '-'. "a = [SUBTRACT] x" and "a = x [NEGATIVE] y" are grammatically incorrect whereas "a = [NEGATIVE] x" and "a = x [SUBTRACT] y" are correct. The parser uses context to determine what the symbol means. Good Google-fodder would be "recursive descent parser", and "operator precedence" which should get you into the right bits of the interwebs to start reading around the subject.
n is input size...forgot to mention that. The reason why I'm doing this it that when you have a huffman codes for random integers then ordered sets become a subset of the random sets
hey thanks mate , this looks really promising.
And I take it we're including the time taken to generate the code book in the runtime? In which case one would expect a naive implementation to take around *O*(*nm* log *m*) time where *m* are the number of input symbols. Algorithm sketch: 1. Generate table of input symbol probabilities from input: *O*(*n*) time. 2. Insert each symbol as a leaf node in a binary tree balanced[1] by symbol probability: *O*(*m* log *m*) time. 3. Associate the symbol in each leaf node with the path taken to reach it in the tree e.g. with left mapping to 1 and right mapping to 0: *O*(*m* log *m*) time. 4. Scan input replacing each input symbol by the encoded tree path: *O*(*n* *m* log *m*) time. [1] By "balanced" I mean the sum of the probabilities for symbols reachable by the "left" branch of a non-leaf node should roughly equal the sum of the probabilities of symbols reachable via the "right" node. Some Huffman code algorithms construct the tree and balance it implicitly by means of a "priority queue". Google around the subject a bit.
That was awesome! Thanks for giving a blend of theory and practice. I'll try out the program at the very first opportunity 
It knows from the context of what came before the '&amp;' symbol. There is an unambiguous precedence to the order of the parts of a C program (types/keywords/numbers/operators/etc). The [lexer](http://www.quut.com/c/ANSI-C-grammar-l.html) breaks the input file into a stream of tokens (by grouping individual characters into sensible groups) and the [parser](http://www.quut.com/c/ANSI-C-grammar-y-2011.html) expects the tokens to appear in a certain allowed order based on the rules of the language. 
I think I glanced through this book before, when I wanted to do something like this (primarily as an academic exercise). I ended up using macros and includes (not terribly fancy, complicated, nor problematic -- anyone with a couple of weeks of C experience should have no problems with it) to get simple inheritance. I added a convention for function overriding (each child class creates a struct for retaining the parent's function pointers, only for the methods being overridden). The class constructor (*not* overridden) set the appropriate pointers -- call the parent's constructor, copy off the pointers to override, then set up local pointers, initial values, etc. It wasn't terribly complicated, nor did I find a use for it. I always thought that if I needed simple inheritance and I needed to use C over C++, I'd implement something like this. 
Context. Is the parser expecting an expression (in front of an expression), or an operator (behind an expression)? The parsing rule is basically something like: EXPR := TERM ( OP TERM )* where 'OP TERM' can be repeated zero, 1 or more times. It's the same kind of rule that prevents using 2 expressions in a row. Also, this produces the distinction between unary minus (like "-a") and binary minus (subtraction)
If there is an expression on both sides of the `&amp;` then it is "bitwise-AND". If there is an expression on the right but not on the left, then it is the address-of operator. An `expression` is something that can go here without causing a syntax error: int x = ________; 
I know it reads a file and prints out an image like this: http://apete23.imgur.com/all/ but I do not know how it works.
I never thought of it like a grid. That makes more sense. what is happening on this line. There's a lot going on that I don't understand. char *screen = malloc ((height * (width+1) + 1) * sizeof(char));
Uh, you could've asked on the original [answer](http://www.reddit.com/r/C_Programming/comments/1y0l3h/beginner_c_helpalgorithm/cfgk8sy). I will try to comment some things that may not be clear enough: // Just open a file using fopen for example open file filename // The geometry we want to use for the printing int height, width; // Reading the line to extract the wanted value. I didn't use sscanf in a long time, but IIRC the syntax is not far off // getline is C++ function actually... there must be fgets or something akin. // I wrote a String library in C that could do the job, maybe I will link it if it is of need. sscanf(getline(filename), "%d,%d", &amp;height, &amp;width); // Here, we are allocating memory from the heap (do not forget to free it before quitting, that's just bad form) // We want height * width charaters, +1 each new line to put '\n', plus one final char to end with '\0'. char *screen = malloc ((height * (width+1) + 1) * sizeof(char)); // we fill the screen with space characters... for (int i = 0; i &lt; height; ++i) { for (int j = 0; j &lt; width; ++j) { screen[ i * width + j ] = ' '; } // And we finish a line with '\n' screen[ i * width + width ] = '\n'; } // We finish the text with a null character, mandatory. screen[ height*(width+1) ] = '\0'; Loop Until EOF int x,y,filler,len; getline(filename,"%d,%d,%d,%d", &amp;x, &amp;y, &amp;filler, &amp;len); for (int i = 0; i &lt; len; ++i) { screen[y * width + x + i] = filler; } End Loop printf ( "%s", screen ); free(screen); Basically, accessing *screen* [ **y * width + x** ] could be rewritten *screen*[x][y], **if** we were using a char** as buffer. I used a single dimension matrix to avoid the hassle of double pointers (not really a hassle, but we would have had to use a malloc on each individual lines, and freeing them consequently). If you have further questions, ask away. Be aware however that I wrote this using approximate syntax and pseudo code for the simple parts (that did not require precision). It is not real, pure ANSI C. Also, you should check a tutorial on reading from a file in C, that could clear up some parts, maybe. I may write the real program, but later in the day, I'm heading to work now. edit: basically the screen should look this way: using a geometry of 7×2: | | | '\n' | |:----:|:----:|:----:| | | | '\n' | | | '\n' | | | '\n' | | | '\n' | | | '\n' | | | '\n' | '\0' | █ | █ █: not actually allocated (the '\0' char ends the buffer)
I do 15€ for 2hrs session, but that depends a lot on the place, country, etc... i think i'm quite cheap
You could probably find a competent undergrad CS student for $20/hr.
Don't pay a dime! Stick with it. Go through your textbook and type/run the code examples and tap online resources to understand concepts. Ask questions on freenode #c and stackoverflow. It will click, I promise. There is no better tutor than yourself and a well written book.
You're school may offer free tutoring, before paying someone, make sure that it doesn't. 
&gt; make sure that it doesn't. It would be more useful if he made sure it does and use that rather than sabotaging the school's tutor program and then paying a tutor.
It's so much nicer to be in a programming subreddit, where logic can prevail regardless of sense.
I'm confused. Isn't the point in attending a school of some sort to get them to teach you stuff? But I skipped university so maybe I'm missing something and they have some other purpose.
You are going to run into the issue of firewall blocking as well. Most peoples routers are going to block everything from coming in and only allow what was specifically set in the rules of the router. You would have to do some sort of upnp if you wanted to dynamically open ports in the router, this is kind of a pain in the ass (I've looked into it for a current project I have)
&gt; sabotaging the school's tutor program I can't stop laughing at this. On topic; I'd try the internet or school library before looking for a tutor.
I don't think that's a good idea - C is mostly mechanical, and paying someone to 'teach' you how it works is unlikely to work. It sounds to me like you just need a better process for accomplishing programming objectives, and I offer it here: 1. Do not write your program first. Write some psuedocode that should accomplish your objective. 2. Now figure out how to (a) write in C and (b) *observe the correctness of* your first piece of pseudocode. Do not attempt to implement the rest of it until you can verify that the first bit works properly. This piece of code should not be more than 5-10 lines of C (declarations et al aside), or you need to break it down further. 3. Repeat for each remaining piece of psuedocode, one at a time. I'm serious, *one at a time*. Yes, this will take 5-10 times longer than just writing the code for your final answer. It's worth it. If you pay someone to help you get your programs written correctly then you will, afterwards, *not be able to write correct programs*.
The C bible is your best friend, it seems like my C class was bundled together with your two classes. It took me until I got to embedded systems to really understand what the hell i was doing. My advice: practice, practice, practice. understand the lower level ideas, it's really important to grasp concepts and why C does what it does. I hated the language at first, now I see it as such an amazing and efficient tool.
I've seen both sides of this. I've worked as a python tutor in my youths with hundreds of freshmen students, so this is an experience account. There are three kinds of people: self taught, taught by communication and people who can not learn programming at all because it doesn't fit with their perception. I would guesstimate that a lot of beginners think that they might belong in the third category, but out of all the students I've worked with only two showed such disability. Both female, trying hard, but not getting it after many hours/days/months. The vast majority is in the second category, and benefit greatly by hours spent with a personal (1 on 1 time) tutor. Curiously it helps if the tutor is less experienced, but not a complete novice. Best results are obtained in bursts - spend 1 hour thinking about a problem on your own, then ask a tutor to help you for 5-10 minutes. You can probably multiply that out, but keep the proportion or you wont learn anything. The self taught students are 50/50 in terms of performance. I've seen these people slave away with tens of nested if-constructs where a loop would suffice, solving problems in the most ridiculous ways or golfing everything with point-free style. Conversely it seems that the best coders are always self-taught, though this may well be due to interest in the subject. At our university tutors were payed by the faculty, and worked at the data lab after hours and even during the day. 
First off, your teacher's program is not "obviously wrong" though it doesn't follow a lot of best practices. For instance, i have never seen anyone leave off the argument names for a function declaration like that. There are a few other best practices that are ignored. In any case, i'd read this to understand linked lists http://www.thegeekstuff.com/2012/08/c-linked-list-example/ and see if that helps you understand the example code. Beyond that, I can't help you much unless you provide specific issues you are having. So please narrow down your issues to more specific questions if you are still having trouble. I'll try to check back every few minutes since it is due so soon.
Did this as a new comment so you'd get a new message notification: /r/learnprogramming may be a better place for this post. They are more used to helping new programmers out than this subreddit.
From http://crasseux.com/books/ctutorial/Parameters-in-function-prototypes.html: &gt; You may include parameter names in function prototypes if you wish; this is usually a good idea when the function prototype is significantly separated from the function definition, such as when the prototype is in a header file or at the top of a long file of function definitions. In this case, I wouldn't consider it a bad practice since the file is rather short and the function arguments are fairly obvious from their types. But yeah, it sounds like the OP wants us to do his entire homework and that's not gonna happen.
Yeah, I knew it was valid per standard I just never see anyone do it. Probably personal preference, but I always prefer to have the argument names.
Yeah, agreeing with parent ^ not exactly impressed with his teacher's linked list library. If it was me teaching, I would've whipped up an abstract C++ class and had you impl the ops to the list. Or given you a list of fn's to impl and stuck them in a jump table. Give me a .dll or a .so and I'll plug it into my test harness. If it works, attaboy, if it doesn't I'll stand in your cube and make you miserable until you give me something that works. Edit1: It took me all of 5 minutes to fix the compiler errors in that code you pasted above. This is on linux using a relatively recent version of gcc. I'd suggest if you want this done, you're going to have to pay someone. And seeing as it's on a really short deadline, I'd offer some significant amount of cash for the work involved. 1 BTC ought to motivate most of the people who can do this work. Edit2: I ran it, it works as advertised. Although I'm not really QA, so I didn't really beat on it too much.
Same here, waaay too anal retentive to leave them out. 
Not really, those names make the code more readable to someone who isn't familiar with it. Ans that person might be you two years later. I have seen code that leaves those names out in a header file, but it's usually because they're targeting compilers that are ancient.
If you can't understand pointers in C, you're going to have a bad time, because it only gets worse from there. I will say that if I hadn't learned assembly and how the bare metal works, way back when I was a youngster, I would've had a hard time with C pointers too. If I hadn't learned how indirect jumps work before I knew about C, I would've had a hard time with function pointers. And nobody ever said anything about the difference between stack and heap memory, had to figure that out on my own. Most CS professors I've seen are shitty when it comes to teaching programming. 
I assume you're being asked for `printf` with `%s`, where the modifiers sit between the `%` and the `s` to specify which part of the string is printed. 
yep! I don't see a way where I can just print the last few chars in the array
You can, but you'll have to pass in the address of the first character you want to print , instead of the address of the first character of the string. There's no modifier to skip input characters. 
That's awesome, I didn't know that trick but in retrospect it seems obvious. GCC will let you define anonymous stack variables, such as this example where we initialize a nameless array on the stack *inside* a function call: #include &lt;stdio.h&gt; static void print_four_values(int a[]) { printf("%d %d %d %d\n", a[0], a[1], a[2], a[3]); } int main () { print_four_values((int[]){ 1, 2, 3, 4 }); } The link shows something that I hadn't realized but which is really cool: that you can also initialize an anonymous function pointer to point to some string of dynamically generated machine code on the stack, and *evaluate* that anonymous code in the same swoop by dereferencing the pointer. Mind blown. And yes, never use this in production!
Can you show an example? I'm not really sure what you mean like if its char example [] = "This is an example"; print out ple
 printf("%s\n", &amp;example[15]);
Those are compound literals and not really that obvious since they are a C99 thing.
I actually found this online printf("%.4s\n", &amp; example[strlen(example)-4]); printing out mple Do you know of this? Not sure what the &amp; sign does
printf("%s\n", example+strlen(example)-3);
can you explain how this works?
add library.o to runme's recipe: clang runme.o library.o -o runme
Thank you very much for your reply! I'm going to delete the thread now because the problem has been solved, but I wanted you to know that I appreciate the help!
I used the array name like a pointer and added the length of the string-3 giving me the address of the third to last element. 
As one of the comments mentioned, this only works if you're on an older PC/OS that lets anything readable be executable. Under normal circumstances, .rodata/.RDATA and .data are not executable, which means that you can't use this technique without explicitly forcing a section change (e.g., via `__attribute__((__section__))` under GCC/Clang). It *may* work on the stack if you're using trampolines under Linux, but otherwise your stack's not generally executable either.
If you are concerned about wrappers, consider the following things: * Do detailed error reporting. Try to return an error code from every function that could return with an exit status. With error code, I don't mean just returning -1, but defining an enumeration of possible errors and returning an error code that indicates what exactly went wrong so a wrapper / user of your library can easily implement their own error handling atop your error codes. If you include a function that makes a string out of an error, make it possible to pass an error code to this function. Some libraries only provide a function that generates a string for the error status of an object which is a major PITA to wrap if the language you wrap the code into has a different paradigm of error handling (i.e. a paradigm where the object may change its error status before you request an error string). * Try to separate allocation from initialization. Languages that wrap your code often provide custom ways of allocating memory. Allocating a structure from the language that wraps your library and then passing it to an initialization function is much easier than working with a pointer into the C world that you can't control. * Provide a function or global variable that returns the version of your library. This is important for figuring out, well, what version the program has just loaded. * Do not use global or static variables except where absolutely neccessary. Global and static variables make your library thread-unsafe (i.e. it doesn't work when multiple threads attempt to use it at once) unless you put major thought into them. Put all state into a structure that can be passed around. * Do not rely on macros in your public interface. Macros provide tons of problems when you try to wrap a library as they cannot be used from within other languages (except perhaps Obj-C and C++). Provide a function instead and if performance is a problem, read about how you can define small inline functions inside headers. * Do not register signal handlers. If absolutely neccessary, make registering them explicit and allow the wrapping code to register it for you. Some programming languages have their own abstraction atop the POSIX signal API which doesn't like it if you register signal handlers from otherwhere. * Document your interfaces well and keep them stable. This is very important. Do not remove any functions or change them *unless absolutely unavoidable*. If you change a function, a function that wraps it doesn't work anymore. The guy who wraps your code has to jump through all sort of hoops to support multiple versions of your library which is a major PITA. * Try to use uint8_t, uint16_t, etc. instead of char, short, long at any places where you need an explicit type size. Types that change their size over different platforms make porting more difficult. * If you serialize data, properly convert the endianess and make sure that your program creates the same output on any platform. Use textual representations where feasable.
It will depend a lot... i.e. would you pay someone $100/h for 1hour or 10$/h for 100hours? If one is a good teacher then he knows his stuff and will sort you out in hours, if not it might take longer... so it all depends. Based on your description, I would say that you are overly focused on the concepts. The concepts are irrelevant and mostly meaningless, they are not the important stuff you should be worrying about this moment. The most important thing you must understand is how to solve problems... and not solutions. You must know the process of solving problems, how to change it, how to improve it, how to break it, how to analyze it. How to move forward even if you are stuck. You need to get your mind switching between the abstract and concrete and back again. You need to understand how to derive generalizations and how to make generalizations concrete. You need to start realizing what you know, what you need to know, and how to know. Think about this way... when you see a woodworker make a chair. Let's say you wanted to make the same chair, with the same proficiency. Should you just measure the chair and just make the pieces and put them together? No, because wood is flexible and it changes, and when you try to put those together they will initially fit and then after drying they will get distorted. You need to understand the tools, materials and how the material reacts to the tools. I'm not saying that you don't need to know "how to build a chair", you do... but once you've got the process, tools, material down, it will be trivial. Only suggestions for reading I can give are [Learn C the Hard Way](http://c.learncodethehardway.org/book/) and [my own unfinished text](https://github.com/egonelbre/spark/blob/master/basics-of-programming.rst), especially pay attention to the last questions list. (If after reading those you still need help, you can find me on Skype "egon elbre", I believe I would be able to spare an hour or two; expect a weird time due to timezone difference).
&gt; Do detailed error reporting. My standard: &lt; 0 for errors = 0 for ok &gt; 0 for counts (written chars, ...) &gt; Try to separate allocation from initialization. How would that look like if should be nice? Define structures in header and let the user malloc? I already give the possibility to set your own malloc/remalloc/free at the lib_init function who will be stored in the lib instance struct. &gt; Provide a function or global variable that returns the version of your library. This is important for figuring out, well, what version the program has just loaded. Hmm, I will see how I can automate this with my autoconf setup. &gt; Do not use global or static variables except where absolutely neccessary. Eww globals. &gt; Put all state into a structure that can be passed around. All my libs are working this way. (Funny thing: Have u ever used BerkelyDB? The instance structs holds pointers to the functions of the lib. What is this? Java?) &gt; Do not rely on macros in your public interface. Eww Macros. Never! &gt; Do not register signal handlers. Don't know a case where a lib needs signal handlers in the first place. &gt; Document your interfaces well and keep them stable. I always use doxygen, to create man pages for my lib. &gt; Try to use uint8_t, uint16_t, etc. instead of char Normally I would go this way, but this lib works just only with text. I have to lookup at the moment which would be the best type for me at the moment. (I want to include a json lib and discount for the cli app and lib extensions) &gt; If you serialize data, properly convert the endianess and make sure that your program creates the same output on any platform. Use textual representations where feasable. Will probably work only with utf-8, which I think doesn't have an endianess. Ps: You did forget tests! As punishment write 10 unit tests for one of your projects. :-p
Thanks. I was thinking about 15-20 but didnt know what was a decent rate. I actually hope I can find a student I've helped in another class to help with getting me up to speed. 
The school unfortunately does NOT have a tutoring program. I've asked. We have TAs but unfortunately, none were assigned to this course. 
&gt;&gt; Do detailed error reporting. &gt;My standard: &gt; &lt; 0 for errors = 0 for ok &gt; 0 for counts (written chars, ...) If your negative exit status contains an error code instead of being -1 regardless of what error happened, (like in the fucking libfreefare) thats perfect. Using errno is also fine albeit a bit less flexible. &gt;&gt; Try to separate allocation from initialization. &gt; How would that look like if should be nice? Define structures in header and let the user malloc? I already give the possibility to set your own malloc/remalloc/free at the lib_init function who will be stored in the lib instance struct. The first way. A wrapper might want to embed the C struct into its own language dependent strict with extra information. Also, providing a custom malloc is not a solution. Some languages (e.g. Go) use garbage collection with a language-heap and a separate C heap. The garbage collector will not check the C heap for pointers; a One-size-fits-em-all custom malloc won't cut the mustard. Better let the user do allocations. &gt;&gt; Do not use global or static variables except where absolutely neccessary. &gt; Eww globals. &gt;&gt; Put all state into a structure that can be passed around. &gt; All my libs are working this way. (Funny thing: Have u ever used BerkelyDB? The instance structs holds pointers to the functions of the lib. What is this? Java?) &gt;&gt; Do not rely on macros in your public interface. &gt; Eww Macros. Never! &gt;&gt; Do not register signal handlers. &gt; Don't know a case where a lib needs signal handlers in the first place. Some libs use signals for IPC. &gt;&gt; Try to use uint8_t, uint16_t, etc. instead of char &gt; Normally I would go this way, but this lib works just only with text. I have to lookup at the moment which would be the best type for me at the moment. (I want to include a json lib and discount for the cli app and lib extensions) I think I did say "where appropriate" &gt; PS: You did forget tests! As punishment write 10 unit tests for one of your projects. :-p Fair enough. Let me write a couple of unit tests for my libnfc wrapper. Another thing I forgot to say: If you do syscalls, try to provide a nonblocking variant of your library or design the library in a way that the user can do syscalls (e.g. io) instead. This makes it easier to integrate existing abstractions (e.g. stream frameworks) with your code.
Unfortunately, we do not. We have Ta's but no tutors. No TA has been assigned to this course. 
I purchased this prior to last term when I was looking for good resources to help with the projects. I did very well and never had to open the books I bought. I looked at this and checked the date and completely wrote it off because it was published (2nd ed) in 88. Im actually on chapter 5 now. Its pretty damn good. 
I will look into that book. Im reading the KR book and working through the problems. 
Actually, the teacher makes it a point to show up exactly what each example is doing in memory. Unfortunatly he moves very quickly and does not stop. 
THANKS!!! Yes, I am focusing on the concepts at the moment. Here's why... I had a 2.5 gpa as an undergrad although I am pretty damn bright. I dropped out of the CS program and graduated with an easy Sociology degree. I spent the last 10 years working in human services always regretting not following what I was really drawn to...CS. I am almost finished with the master's degree and currently have a 3.9 gpa. I made it a point to prove it to myself I can do it. TBH, everything up till now has been a breeze. I get the concepts, I really do, Its the application thats getting, me. The fact that I have breezed through everything up til now kind of fed my ego and I really havent put a lot of effort into the class, especially since I did so well in the first class. Now I'm playing catch up. My school doesnt offer tutoring and noone there seems to know how to answer the same question I asked here. This is what my game plan is. I have read half of the K and R book and will finish tonight with completing the assignments. I will move on to the learn C the hard way website...I am also halfway through the Python tutorial there). I have some tutorial videos from Lynda.com and youtube I'll check out and will also check your site. I'll give you good feedback on your site when I'm done :) 
Unless you give him feedback that he's going too fast, he'll always go at that speed. A lot of us forget that it took some time to figure out what we now know.
that is the book i'm talking about ! keep grinding away at it.
&gt; The fact that I have breezed through everything up til now kind of fed my ego and I really havent put a lot of effort into the class, especially since I did so well in the first class. Yup, that can be somewhat problematic... You need to practice on the problems that make you want to constantly bang your head against the wall. That way you ensure that you learn the necessary stuff. Unless you get a rage quit moment, you aren't solving hard enough problems. K&amp;R book isn't that good for learning. Don't get me wrong, the book is good, but not just for learning. "Practice of Programming" is better for that. I'm not sure about quality of "Lynda.com" and I haven't seen any good youtube videos for beginners. IMHO, currently the best resources available on the internet are [LPTHW](http://learnpythonthehardway.org/), [LCTHW](http://c.learncodethehardway.org/book/) and [SICP](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start)... those are the books that get you thinking like programmer, instead of just teaching the syntax and concepts. &gt; I'll give you good feedback on your site when I'm done :) Any additional information regarding the beginners state would be welcome. Don't worry about the language/text mistakes; it's due for a rewrite anyway.
That's a bit more tricky. You can roll your own, which is interesting and hard work (but tiresome because C doesn't expose the carry, so you may need to dip into assembler), but you're better off hunting out an extended precision library such as [GMP](https://gmplib.org/).
Ive allways wondered about this, since the compilers now days do everything pretty damn good. Why has bitfields been left to rot? 
I guess because there's not much call for them, and doing it with shifts and masking is pretty easy if somewhat unsightly: // Returns bit mask for given bit field #define BIT_MASK(start, width) (((1 &lt;&lt; (width)) - 1) &lt;&lt; (start)) // Returns bit field from word. #define GET_FIELD(word, start, width) \ (((word) &gt;&gt; (start)) &amp; BIT_MASK(0, width)) // Returns word with specified bit field updated with value #define SET_FIELD(word, start, width, value) \ (((word) &amp; ~BIT_MASK(start, width)) | \ (((value) &lt;&lt; (start)) &amp; BIT_MASK(start, width))) (Warning: untested code)
This could be done a lot better in C++ where you can define a class and use operator overloading for the familiar math operations. Or better yet, use an existing library, http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic#Libraries.
A couple of reasons. First off, the C standards were intended to be attainable for the stupidest, simplest compilers as well as the more complicated ones; not specifying how bitfields are to be implemented leaves the stupider ones free to align each one to a byte/word and the more complicated ones to pack things properly and shift/mask in/out. The standards were also intended to apply to every architecture you might want to write a compiler on, which means that the layout of bits and bytes is up to the compiler writers. On the ABI (application binary interface) side of things, in general not enough people cared about bitfields to specify them all that tightly in the ABI, which means that compilers generating code to that ABI are pretty unconstrained in what they do. TL;DR: Nobody wants to use bitfields, because the compilers can do whatever they want with them, because nobody wants to use bitfields, etc.
[The Little book of Semaphores](http://greenteapress.com/semaphores/) could be useful.
One reads from a file stream, the other reads from a string. That's the only difference. If your input comes from a file stream, use `fscanf()`, otherwise use `sscanf()`. `scanf()` is just a special case of `fscanf()` with `stdin` as the stream. As to the rest of your questions, they don't make a lot of sense to me. Why would you want to convert from one to the other? Use whichever one makes the most sense in a given context. If you're reading from a file stream, use `fscanf()`. Why would you want to switch to `sscanf()` for that? You'd have to allocate a string, then populate it by reading from the stream into the string, and then pass the string to `sscanf()`, which is a whole lot of extra work compared to just calling `fscanf()` in the first place. And it's fraught with pitfalls, because you have to deal with what to do about the size of the string, and how to deal with overflows, and how much to read from the stream, and what to do about the extra parts that you read from the stream that weren't extracted by `sscanf()`, and so on. 
They are two completely different things. One scans out of a string and the other scans out of a file
&gt; They are two completely different things. No. They do exactly the same thing, with only one difference: &gt; One scans out of a string and the other scans out of a file That's it. That's the only difference. Other than that they are the same. They are not "completely different."
My bad, I did not mean to say two completely different things, what I meant to say what that they have two completely different purposes.
The file name that you pass to `fopen` must be a string. If you want to generate the file name automatically, then you must first generate the string, and then pass the generated string to `fopen` as the file name. Take a look at `sprintf`, which works the same way as `printf` except it writes into a string instead of to standard output. Make sure that you have allocated enough space for the string first, though.
Thank you, I will look into this!
You're making sprintf more complex than it is. This works: sprintf( filename, "hw05-data-%d.txt", count ); Make sure the "filename" array is big enough to hold the string, though.
Ahh, okay thanks! I was reading online and they had the %s for some reason. 
The people here commenting so far are right, the main difference is one reads from a file and one reads from a string. However, I'd like to point out a technicality with strings and files so you don't create weird behaviour. Say I have a file: &gt;one two It's just these two words. Now say we have a buffer and we're calling fscanf in a loop like this: char buf[4]; while (fscanf(file, "%s", buf) != EOF) { printf("%s\n", buf); } (the scanf family returns EOF when it matches nothing.) This program would print out the words one and two on separate lines as expected. But what about sscanf? char *string = "one two"; char buf[16]; while (sscanf(string, "%s", buf) != EOF) { printf("%s\n", buf); } This program will run forever and continuously print out "one" on new lines. Strings do not behave the same way as files. Be wary of this when parsing data. I just ran into this recently and thought I should share it.
%s means to substitute a string at that point, %d means to sub an integer.
You most likely want to take the files as arguments on the command line so that you can supply a wildcard expression that matches the input files. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { for (size_t arg = 1; arg &lt; argc; arg++) { fprintf(stderr, "opening %s\n", argv[arg]); FILE *f = fopen(argv[arg], "r"); if (f == NULL) continue; /* do stuff with open file... */ fclose(f); } exit(0); } Now you can run the program with the following arguments: $ ./homework *.txt
Yeah, I have it set up to take them in the function. I probably should have included that! Also, thank you for this, I will try this out. It looks like it would work well with how I want to do things! :)
Can you post the full assignment?
I know it's been a while, but thanks for your help. I've decided to take another crack at this, rewriting the program from the ground up. Here's my new program, following your logic: #include &lt;stdio.h&gt; main() { int i, incol, outcol, tablen, tabs, len; char c; printf("tab length? [0-9, default 4]\n&gt; "); tablen = getchar(); if (tablen &gt;= '0' &amp;&amp; tablen &lt;= '9') /* ascii 0-9 */ tablen = tablen - '0'; else tablen = 4; incol = 0; outcol = 1; while ((c = getchar()) != EOF) { incol++; if (c == ' '); /* do nothing */ else if (c == '\n') { putchar(c); incol = 0; outcol = 1; } else { tabs = 0; while (outcol &lt;= incol) { len = tablen - (outcol % tablen); outcol += len; tabs++; } outcol -= len; tabs--; for (i = 0; i &lt; tabs; i++) putchar('\t'); while (outcol != incol) { outcol++; putchar(' '); } putchar(c); outcol++; } } return 0; } Unfortunately, despite my endless tweaking, it seems to only do the job correctly *some of the time*. Take these examples from stdin (with tab length set to 8, the bash default): habs@marielle:~/c/1.10$ ./entab.o tab length? [0-9, default 4] &gt; 8 spaces at the beginning spaces at the beginning spaces in the middle spaces in the middle seems to be one off... seems to be one off... but not all of the time but not all of the time I can't seem to figure out what is causing these problems. Any ideas?
Try http://www.ioccc.org/
haha this is perfect thanks :) ..Man, Reddit never ceases to amaze me. You responded in 7 minutes!
Probably this http://ubuntuforums.org/showthread.php?t=1301856
"and a partridge in a per tree" -- a bug or a whoosh?
This is a well-known obfuscated program and the bug is, apparently, also well-known. Some quick Googling revealed [this article](http://www.samskivert.com/internet/deep/1997/01/08/body.html), which talks about the reverse-engineering process required to fix the bug.
It seems to me that the precise meaning of `incol` and `outcol` you've chosen are 'the column of the character we just read,' and 'the column of the next character we write.' So, if the logic for outputting tabs and spaces is correct, then when you do that final `putchar(c)`, `incol` and `outcol` should be equal. You can use an assert to check that and help find bugs: putchar(' '); } assert(incol == outcol); putchar(c); outcol++; Of course this assertion doesn't fire on your tests, so it doesn't help up find where that extra space is coming from. Understanding the precise meaning you're using for `incol` and `outcol`, and given your initial values of 0 and 1, it's clear you're treating column numbers as starting from 1. Given this, we know that the last column of a tab will always be divisible by 8. For example a tab at the beginning of a line will fill columns one through eight. And after a tab, the column for the next character to write will always be one more than a number divisible by eight. So we can use another assertion to check that: while (outcol &lt;= incol) { len = tablen - (outcol % tablen); outcol += len; assert(outcol % tablen == 1); tabs++; } outcol -= len; This assertion does fire, and we can see why. Printing a tab starting at the first column should take up columns one through eight, and should leave `outcol` at nine, to remain consistent with the definition you chose for that variable. Instead it's left at eight. So considering that you add `len` to `outcol`, `len` ought to be the total width of the tab. We'll just insert an assertion to make sure that tabs are always between 1 and 8 columns wide: len = tablen - (outcol % tablen); assert(1 &lt;= len &amp;&amp; len &lt;= tablen); outcol += len; Now let's look at expected tab widths given the starting column of a tab. On the following line I've written a digit from 1 to 8 in each column position, and that digit is the width of a tab starting at that position. A tab starting at column one has a width of eight, a tab starting from the second column has a width of seven, and so on. 876543218765432187654321... On the other hand if we were to take your program and write the tab width it calculates for each column we get the following ([for example](http://coliru.stacked-crooked.com/a/5c279a4314a69d35)): 76543218765432187654... Now it's clear that the calculated tab width isn't quite correct; It seems to be off by one most of the time. Note that you can't just change your code to: int len = tablen - (outcol % tablen) + 1; Because one eighth of the time it's off by seven instead of by one. Fortunately if you try this the assert on `len` ( which you added a moment ago) will catch the mistake. Still, we don't just want to change the code at random. We need to know what's gone wrong to produce these mostly off-by-one errors. --- I'll leave finding the actual solution up to you at this point, with a hint and some other comments on your code and tests. The hint is to go back to how you derived `len = tablen - (outcol % tablen);` and consider when this formula is correct. (And yes it's correct under the right circumstances.) Then consider whether it is exactly correct given your precise definition of what `outcol` means and in particular how you're numbering columns. You can make your code work for your tests by changing this one line of code. (And don't just try things at random.) --- On testing, you might have more comprehensive tests than you showed as examples, but if not then consider tests to more thoroughly exercise the different paths through your code. For testing the part of the code we're looking at you want a variety of widths of white space all starting at a variety of offsets. Here's the data I quickly made: a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a And of course there are other things to test, such as one thing that came to my mind: input that already includes some tabs. --- Your program starts with `main()`, without specifying main's return type. It's unfortunate that K&amp;R's C book uses that style, because it's not good practice and it's not even legal with newer versions of C. You should use `int main()`. --- char c; The result of `getchar()` is actually an `int`, and this is because it needs to be able to return any character read from the input, plus some value that indicates EOF. Thus it needs to be able to return a non-`char` value. If you assign to a `char` directly from `getchar()` then you will not be able to reliably detect the end of the input. (Although if the input is entirely ASCII or otherwise 7-bit data, then you will not see any problem.)
Ha, thanks! Yeah, I'd ogled at the source before, but that was the first time I tried running it myself, so the "typo" stuck out. Great to have some history/background.
Honestly, I was hoping this would be a question about [Duff's Device](http://en.wikipedia.org/wiki/Duff's_device).
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Duff's device**](http://en.wikipedia.org/wiki/Duff's%20device): [](#sfw) --- &gt; &gt;In [computer science](http://en.wikipedia.org/wiki/Computer_science), **Duff's device** is an [optimized](http://en.wikipedia.org/wiki/Optimization_(computer_science\)) [implementation](http://en.wikipedia.org/wiki/Implementation) of a serial copy that uses a technique widely applied in [assembly language](http://en.wikipedia.org/wiki/Assembly_language) for [loop unwinding](http://en.wikipedia.org/wiki/Loop_unwinding). Its discovery is credited to [Tom Duff](http://en.wikipedia.org/wiki/Tom_Duff) in November 1983, who at the time was working for [Lucasfilm](http://en.wikipedia.org/wiki/Lucasfilm). It is perhaps the most dramatic use of case label fall-through in the [C programming language](http://en.wikipedia.org/wiki/C_(programming_language\)) to date. Duff does not claim credit for discovering the concept of [loop unrolling](http://en.wikipedia.org/wiki/Loop_unwinding), just this particular expression of it in C. &gt; --- ^Interesting: [^Loop-switch ^sequence](http://en.wikipedia.org/wiki/Loop-switch_sequence) ^| [^Tom ^Duff](http://en.wikipedia.org/wiki/Tom_Duff) ^| [^Loop ^unwinding](http://en.wikipedia.org/wiki/Loop_unwinding) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cfnronm) ^or[](#or) [^delete](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cfnronm)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 69642:%0Ahttp://www.reddit.com/r/C_Programming/comments/1ysy63/does_anyone_remember_this_c_thing/cfnrod5)
&gt; The 4 is a **minimum** field width Just bolding this. I've seen code written where the coder expected it to be a *maximum* field width also. In fact there is no modifier for limiting how many characters are written for `%d`. 
this was it! You found it! Memories!
Update: http://blog.regehr.org/archives/503 More info: * https://www.kernel.org/doc/Documentation/volatile-considered-harmful.txt * http://blog.regehr.org/archives/28 * http://lwn.net/Articles/233479/ So basically, yeah don't use volatile. If you must use it, turn off optimizations and wrap them up in accessor functions.
Please explain to me what a struct is, and how is it different from a union? Once you can tell me that, you might have your answer. You need to go read up on those two things. 
Okay thankyou. I will do so! Do you know of any really informative links on the topic?
Just to double check.. what's volatile? That's for inline ASM that you don't want to get dinked with during compile, right? Like if I wanted to do some stuff in realmode instead of protected?
Here it is a bit more readable (just the first element) : spacegroup spacegroups[] = { { 0, 1, "P1", "", " P 1", 'P', 1, 0, 1, { { 1, 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 } } }, ... } spacegroup might be a structure like this: typedef struct { int a; int b; char *c; char *d; char *e; char f; int g; int h; int i; struct { int x[12]; } inner[2]; } spacegroup; 
`volatile` is a keyword that tells the compiler the "data" might be modified by an outside force. This (should) force the compiler to turn off certain optimizations when this data is accessed, and not make the standard assumptions. You can use the `volatile` keyword after `asm` to tell the compiler to keep asm code that looks to have no effect to the compiler. It also tells it not to move it around (i.e. loop optimizations). The typical example is if you're accessing a register that keeps track of seconds using a hardware device, the value you read will be different every second you read it. Using a dumb example: *a = 5; /* start from 5 seconds */ sleep (2); printf ("%d", *a); The compiler cannot assume `*a` is still 5 if it is declared volatile. However, as the links I posted explain, in some cases, it causes as many problems as it solves.
Ok thank you
`char *c` is a pointer to a character type. It is usually used to point to character arrays. You can initialize this using double quotes around a string (note: cannot be modified). `char c` is just a single character type. It is usually initialized with single quotes. There are other ways to declare spacegroup. This is just one of them.
I've detected a hexadecimal color code in your comment. Please allow me to provide visual representation. [#346541](http://color.re/346541.png) *** [^^Learn ^^more ^^about ^^me](http://color.re) ^^| ^^Don't ^^want ^^me ^^replying ^^on ^^your ^^comments ^^again? ^^Respond ^^to ^^this ^^comment ^^with: ^^'colorcodebot ^^leave ^^me ^^alone' 
Cannot is a strong statement...
Sorry, I will never reply to your comments again.
Thank you! 
If a compiler doesn't handle Volatile correctly, then its a piece of shit
What would you consider a non-piece of shit compiler? 
this is so sad!
That is C++ code, not C&amp;nbsp;code. You are in /r/C_Programming. This subreddit is about C, not C++. Try /r/cpp_questions or /r/learnprogramming.
I just took a quick glance and it looked pretty good. I'll give it the full scrutiny tomorrow and get back to you.
Given the requirements, I would *forward declare* `struct stack` and push the `stack_ele` and `stack` definitions into the C source. Similarly, even th Also, I would prefix the #defines, so that they don't collide with other header files that may define `SUCCESS`, `OUT_OF_MEM`, etc. Also, to really polish your code, add another source code which provides unit tests. This serves not only as real documentation, but continually ensures correctness and validity of your code. To start simple, work with using `assert()`.
I would argue it is not really worth the effort of making a copy of the data being passed in (of complex types like struct/ union) because you can only ever do a shallow copy. If the struct happens to contain pointers to other entities then the claim your library's memory is independent of user memory is false. You could mitigate this by providing different versions of your library. One for primitive and simple types, in which a direct copy of memory is appropriate. And one in which the user can either pass in a created copy themselves, or provide a pointer to a function which can perform the deep copy. This could be passed in as an initialisation variable for the data structure if you wanted.
Maybe add the size of the stack to the struct? Then you have constant lookup. Don't cast return values of malloc and check the success of _every_ malloc.
This might be just preference, but I like to have my function comments in the source file as well as the header file. I also lean towards one return statement per function, I find it makes tracing them a bit easier.
Looks like in 'stack_push' that you malloc without checking the return value (newItem-&gt;value = (void *)malloc(size)). Also, some folks like to set a pointer to NULL right after freeing it so that if it's used after freeing, it's likely to explode loudly and get your attention rather than failing silently or semi-working.
stack.h: * As others said, since you're designing this as a library, it would be useful to use your own suffix for function calls and error codes. You might also consider using errno.h for your error codes. * Small thing but I don't like the name NULL_STACK. NULL implies zero but the code is -1. Maybe INVALID_STACK? * Linus doesn't like this: typedef struct stack_ele stack_ele; See [Chapter 5 typedefs](https://www.kernel.org/doc/Documentation/CodingStyle). * I like how nicely commented your code is, but I generally don't like comments like this one: /** * The stack itself */ Too obvious. Also, stylistically, I like single line comments in `/* ... */` blocks but maybe that's just me. It makes things less cluttered. stack.c: * You sometimes check the return value of malloc and sometimes not (line 70). * You don't have to cast the return value of malloc. Especially casting to void* is quite useless (line 70 again). * IMO, stack_pop should have a size argument. You're doing a blind memcpy to a destination pointer. How do you know if the user allocated enough space for the data? If you're going to require the user to allocate space, they should also tell you how big of data they think they want to pop. Of course, this also means the user has to know how much memory they need to allocate. How do they find that out? Think about that. * This is a small thing but I prefer: stack_ele* newItem = (stack_ele*)malloc(sizeof(*newItem)); to stack_ele* newItem = (stack_ele*)malloc(sizeof(stack_ele)); In this case, it shouldn't really matter but in a different use case, it might have looked like this: stack_ele* newItem; /* initialization */ .... /* many lines of code */ newItem = malloc(sizeof(stack_ele)); If you change the type of newItem in the future (say, for an experimental stack_ele_exp type, you might forget to change the parameter to `sizeof()`. * As others said, thread safety is not guaranteed with this library, but considering your scope, it's probably not needed. * Adding size of the stack to the stack might be worth it. It depends on your use cases. * You might consider the visibility of struct stack_ele since the user will not be exposed to it. (i.e. put it in the .c file) That's all I have for now. Some of my arguments might be invalid or I might have overlooked something. So better make sure to get multiple opinions!
Thanks for the feedback! I've forward declared stack in the header to make it opaque and prefixed my defines with STACK_. Also I made a really basic test [here](https://github.com/evfrancis/Practice/blob/master/c/tester.c) in the testStack() function, but it likely has poor style. I'm a novice when it comes to unit tests, so I'll have to research them more.
Adding a size is a great idea, thanks! I've also made my malloc checks consistent. Out of curiosity, is there a reason for not casting return values of malloc? I did the cast because it was a convention I learned a few years back in school (this code isn't related to school, so I can use anything).
You don't cast it in C, because it is not needed and makes things unnecessary complicated. [More about that.](https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc)
Thanks for the feedback. I've made the following changes: * Prefix to all of my defines/functions (not sure if suffix is a better convention). * Fixed the define name and limited the typedef to the stack, which should be opaque. Also pushed stack_ele into the C source. * The stack comment was mostly so that Doxygen put a description for it. But I can remove it. * Malloc checks are consistent and casts are removed. * sizeof(*newItem) - I didn't know this could be done, but I like it a lot more than what I had! Thanks! * Size has been added to the stack, which simplified my code. * For the memory problem with pop, I've added a new function (stack_get_data_size) which returns the value that the user must allocate. I guess it was too much to assume the user knew the stack order :) I looked into errno.h but found all the values were positive, which would conflict with stack_get_size's functionality, so I've skipped implementing it for now. In terms of thread safety, I assumed it would be the user's responsibility to lock each stack if it is shared. Is this an invalid assumption?
&gt;Array of a variable size &gt;This is a back-port from C++ This is not true at all. VLAs are only available in C99 and beyond (optional in C11).
Thanks, I've added in your suggestions. This isn't a school assignment, just a random project to learn more about programming style, so I'll look into passing function pointers. Enums are a bit unfamiliar to me so I'll have to read up on them too!
How does this contradict the article? It says right at the top that this is a C99 feature. 
It claims that VLAs were back-ported from C++ ("This is a back-port from C++"). C++ has never had VLAs AFAIK. C++ has std::vector, which is essentially a type-safe wrapper over malloc(), i.e. freestore, rather than stack where a VLA is stored.
I remember my professor in college, John Potter, of comp.lang.c++.moderated fame and given thanks in the forward of many great C++ books from authors like Koenig, Sutton, and I really can't remember them all... Supposedly there are several others... Anyway, I digress... He showed us duffs device in our 2nd or 3rd year and blew our minds... It must have been Operating Systems (although it could have been Systems Programming) and blew our fuckin minds. Then again, he was excellent at making you figure it out on your own, very socratic. If you ever look this guy up, he was the C++ boss. To quote a classmate, You can't touch that, it's too hot. 
Ah, I misunderstood, thanks!
Ugh, the variable array size. Probably not a good idea in practice because large arrays will easily eat up the stack. I used to use these in CS problems but they caused issues in larger inputs.
Then don't use variable arrays on the stack with large data. Use them on the heap like a sane person.
The `volatile` example is questionable. It depends on the implementation, but this code is not thread-safe. There could be a context switch partway through writing the volatile variable. 
Windows? First glance im thinking scanf isn't giving you "abcd\n\0" but instead "abcd\r\n\0". Set a breakpoint on that line and inspect the memory scanf is pointing to and see if you allocated enough space.
If you use volatile variables for anything other than writing or reading hardware registers, you're doing it wrong.
I wouldn't qualify most (any) of these as "lesser known" for anyone who works with C on a regular basis. They're all fairly standard in well-written, modern C code (i.e. adhering to C99 or more -- I'm mostly working with gnu99).
No, I'm compiling and running it in Ubuntu. My professor, however, for whatever insane reason, uses Visual Studio. I tried using GDB, but I don't know if I was doing this right. I set a breakpoint at line 34, the line with the IF condition checking to see if side is NULL. I then used "p side" to print the value of side and it said something like: 0x804c308 "" I also used "x side" and it showed something like: 0x804c308: 0x000000 So does that mean it's NULL? Because I used a printf() call after checking if it's NULL to print the actual value of side, and each time, it prints the correct string that I just entered, such as "left" or "right". So if printf() is telling me that the variable is holding the correct string, then why is GDB seemingly telling me that it's empty? Also, if side WAS NULL for whatever reason, the IF condition I had in there right after using malloc() should have printed an error. Did I use GDB wrong or something? This was my sequence of commands. b main.c:34 r (at this point, I entered data until the breakpoint) (first breakpoint) p side x side Any ideas?
Sounds like a concurrency problem... Could you show us your socket creation/writing/reading code? Also, I think you would be better off with a single socket per program, where every other program can write to.
Why are you using `malloc` here in the first place? It seems easier to me just to declare char side[6]; An invalid write of size&amp;nbsp;4 is likely your assignment to the `int` that you read in the same line, not the string. It's weird that you are `malloc`'ing a single `int`, too: cl = (int*)malloc(sizeof(int)); Why are you doing that instead of just using an `int` variable?
Since you know the maximum length at compile time, I would simply have a static-length array : char side[8]; The few extra bytes won't hurt... Then you can also pre-fill it with a known sequence (like 0xFF's) and print it to the console after calling scanf, so you can see exactly what is being written to it. printf("0x%x\n", (uint64_t*)side); //kinda dirty, but will do for debugging
The example uses an ~~pointer~~ int for the `volatile`. On any practical hardware today word-sized values are written atomically. 
I'm on the phone so maybe I'm mistaken but it looks like you're double freeing side and setting it to null. While calling free on NULL is harmless, could it still be why valgrind is complaining? Which statement by line number is giving you problem?
Here's an interesting situation where `alloca` will give you (possibly unexpected) pain: void test(void) { for (int i = 0; i &lt; N; i ++) { size_t size = compute_size(i); char array[size]; // char *array = alloca(size); // This won't work as well process_array(array, size); } } As for running out of memory ... that's stack overflow. My man page says the following: &gt; If the allocation causes stack overflow, program behavior is undefined. Doesn't sound like letting me handle the error to be honest!
Just so.
Please, if you read into a buffer of known size, explicitly tell scanf how long the string you read may be: scanf("%d %5s", cl, side); If you don't do that, your program has a security hole that can be used for malicious purposes.
Could you provide us with the whole source code? It is very difficult to debug code you cannot complete see.
This probably will use fewer bytes. You don't have the overhead needed for memory management and it will fit in one word anyways.
The bug Valgrind is detecting is caused by this line: free(cl); You're freeing this pointer and then attempting to read with scanf a integer into the pointed location. That said, you shouldn't use malloc in this manner, it's supposed to help you with dynamic memory allocation which is completely unnecessary if your variables are always there and with the same size.
Indeed, these are all the sorts of things you'd see documented in a C reference. For fun, [here's something I've never seen in such a reference](http://gallium.inria.fr/blog/non-determinism-and-sequence-points-in-c/), save for the standard itself.
I spoke to my professor and he recommended the same thing. I guess the only reason I did it this way is because in the transition from C++ to C, I wanted to do memory allocation as much as possible to familiarize myself with it, but it just made it more complicated. I've since fixed the program.
Because I guess I was just trying to familiarize myself with C's memory allocation by using it as much as possible. I've changed it to an array like you suggested and it works now.
I've solved the problem. Don't worry about it. It had nothing to do with the other files which is why I didn't include them.
What hole would that be? Is that like an overflow kind of thing? Like somebody could write to unexpected memory and make the program execute commands? 
https://en.wikipedia.org/wiki/Buffer_overflow
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Buffer overflow**](http://en.wikipedia.org/wiki/Buffer%20overflow): [](#sfw) --- &gt; &gt;In [computer security](http://en.wikipedia.org/wiki/Computer_security) and [programming](http://en.wikipedia.org/wiki/Computer_programming), a **buffer overflow**, or **buffer overrun**, is an [anomaly](http://en.wikipedia.org/wiki/Anomaly_in_software) where a [program](http://en.wikipedia.org/wiki/Computer_program), while writing [data](http://en.wikipedia.org/wiki/Data) to a [buffer](http://en.wikipedia.org/wiki/Buffer_(computer_science\)), overruns the buffer's boundary and overwrites adjacent memory. This is a special case of violation of [memory safety](http://en.wikipedia.org/wiki/Memory_safety). &gt;Buffer overflows can be triggered by inputs that are designed to execute code, or alter the way the program operates. This may result in erratic program behavior, including [memory](http://en.wikipedia.org/wiki/Memory) access errors, incorrect results, a [crash](http://en.wikipedia.org/wiki/Crash_(computing\)), or a breach of system security. Thus, they are the basis of many [software vulnerabilities](http://en.wikipedia.org/wiki/Vulnerability_(computer_science\)) and can be maliciously [exploited](http://en.wikipedia.org/wiki/Exploit_(computer_security\)). &gt;[Programming languages](http://en.wikipedia.org/wiki/Programming_language) commonly associated with buffer overflows include [C](http://en.wikipedia.org/wiki/C_(programming_language\)) and [C++](http://en.wikipedia.org/wiki/C%2B%2B), which provide no built-in protection against accessing or overwriting data in any part of memory and do not automatically check that data written to an array (the built-in buffer type) is within the boundaries of that array. [Bounds checking](http://en.wikipedia.org/wiki/Bounds_checking) can prevent buffer overflows. &gt;==== &gt;[**Image**](http://i.imgur.com/x0NcAyH.png) [^(i)](http://commons.wikimedia.org/wiki/File:JumpToEsp.png) --- ^Interesting: [^Stack ^buffer ^overflow](http://en.wikipedia.org/wiki/Stack_buffer_overflow) ^| [^Buffer ^overflow ^protection](http://en.wikipedia.org/wiki/Buffer_overflow_protection) ^| [^Heap ^overflow](http://en.wikipedia.org/wiki/Heap_overflow) ^| [^Return-to-libc ^attack](http://en.wikipedia.org/wiki/Return-to-libc_attack) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cfr5z0k) ^or[](#or) [^delete](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cfr5z0k)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 74670:%0Ahttp://www.reddit.com/r/C_Programming/comments/1z5w65/problem_mallocing_char_pointer_string/cfr5yv1)
Behind your buffer, there could be * another buffer that holds a data structure * the end of your data segment In the first case, the data structure gets overwritten. Now imagine that you pass untrusted input into your program overwriting a file name. Now an attacker could suddently cause damage to your system. The extend of such a security hole is usually only seen once somebody manages to make an exploit. In the second case, your program crashes. This is not something you want.
More like a forward-port form FORTRAN 77.
Here's one not on the list: void foo(int array[static 5]); It overloads the static keyword strangely, but its effect is nice. An array passed to foo must be *at least* 5 elements or more longer, rather than exactly 5 without static in there. Passing a too small array is a compile time error.
Note that XDR *xdrs = &amp;clp-&gt;xdr_stream; .... if (clp == NULL) return RPC_FAILED; is not really an error regarding potential null pointer dereferencing. clp is not dereferenced before checking, as the `&amp;` operator does not evaluate its argument. 
yep, I can't survive in the embedded world without "volatile"
Structured, commented, error conditions checked, etc. Well done. Just one thing: always check if malloc returned NULL before using the pointer.
What's the header file for? Usually a header file is for any services a source file exports for others to use.
What you've written are *completely different things*. The fact that for (int i = 0; i &lt; N; i ++) { char array[size]; doesn't redeclare the array every time is an artifact in your compiler. A crappy compiler could very well redeclare it, but as that's probably not what you want it doesn't do that. The idea behind alloca() is to do a malloc() compatible implementation but for stack memory instead of heap memory. Variable length arrays and alloca() are two different things, but many people tend to mix them up. If you did for (int i = 0; i &lt; N; i++) { char *array = malloc(size); would you assume that \*array would be free()'d before re-malloc()ing it in the next iteration? Of course not. alloca() works in exactly the same way. You've specifically asked for it to be redeclared every time and then you act surprised when the compiler does exactly what you've said. If you don't want it redeclared, you should do: char *array = alloca(size); for (int i = 0; i &lt; N; i++) { ...
Variable length arrays are great for their intended purpose. Just as with handling any memory, you need to be wary of unsanitized and unlimited input data. Storing megabytes of data on the stack is obviously *not* a good idea. Storing a few kilobytes is perfectly a-ok, and will cause much less headaches (i.e. fewer bugs in your code) than allocating it on the heap if it's supposed to be a function local (i.e. automatic) variable, especially if your function is complex. It's also much faster. Heap and stack memory are different tools to be used for different purposes. Don't conflate them.
It seems you're a bit off. Passing a too small array is *not* a compile time error, but *undefined behaviour*. Some compilers (e.g. gcc) only use this for optimization and not type safety checking. See this gcc bug for example: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=50584 IBM states [in their docs](http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=%2Fcom.ibm.xlcpp8a.doc%2Flanguage%2Fref%2Fparam_decl.htm) (scroll to the last sentence): *If the caller of the function does not abide by these restrictions, the behavior is undefined.* **TL;DR**: This is an optimization and not a type safety thing. You should not rely on that your compiler outputs an error nor a warning, and you might introduce new bugs in your code if you do this.
No. On most hardware, writing values less than or equal to the *native* size is an atomic operation (i.e. 16 bits on a 16 bit platform, 32 bits on a 32 bit, etc.). Expressions such as "word size" are misleading, because different platforms, languages and implementations use different definitions for "word size". However, the volatile keyword is *specifically not* for thread synchronization. /u/OldWolf2 is correct, and if you don't run into this specific issue you might run into one of a hundred others, most of which are extremely hard to debug. Use proper thread synchronization primitives, that's why we have them! volatile is *only* to be used for accessing hardware registers. *Nothing else*!
You could move all the sockets into a single process and use the select() syscall.
&gt; You shouldn't store executables in your repository. You certainly *can*, but it's only compiled to work on a system similar to yours. Not only that, but its not in Git's nature. It can't difference binaries which means you'll actually lug around each version of the binary with the history. Not the difference between two the binaries… each binary for each version checked in in full. It makes the repo blow up in size very quickly.
&gt; Expressions such as "word size" are misleading, because different platforms, languages and implementations use different definitions for "word size". In any modern context "word size" *means* native size. The [very first sentence of the Wikipedia article](http://en.wikipedia.org/wiki/Word_size) states this. &gt; volatile is only to be used for accessing hardware registers. Nothing else! That's almost always the case, but not *absolutely* so. Here's one of the rare examples of Linux using `volatile` for thread synchronization: [include/asm/atomic.h](http://lxr.free-electrons.com/source/arch/x86/include/asm/atomic.h#L26). And [these people really do know what they're doing](https://www.kernel.org/doc/Documentation/volatile-considered-harmful.txt). `volatile` is specifically for optimization suppression. The `volatile` is necessary for correct operation in the example in the original article despite not being used for hardware access ([a fuller example](http://pastebin.com/W2jk9tyx)). It's the same situation as `jiffies` mentioned in the kernel.org link above. 
&gt; In any modern context "word size" means native size. The very first sentence of the Wikipedia article states this. I'd say that's not always true. For example, certain non-C languages such as Pascal have a word sized variable thats always 16 bits. This also applies to the Windows 32 bit API (IIRC). People tend to speak of qwords as the same thing as 64 bit types. Not saying that it's correct to do so, just that "word size" tends to mean different things to different people. &gt; That's almost always the case, but not absolutely so. Here's one of the rare &gt; examples of Linux using volatile for thread synchronization: include/asm/atomic.h. &gt; And these people really do know what they're doing. volatile is specifically for &gt; optimization suppression. That's not actually a very good example, because 1. It's x86 specific code andthe x86 memory model guarantees that memory changes are visible to all cores at the same time. Other platforms do not do this. 2. "volatile" is used, not because it's good, but because there's no other way of expressing what they want short of inline assembly 3. Calling atomic_read() (which uses a cast through "volatile") is not valid unless the variable has been consistently set using the other atomic primitives. It is *not* valid if the variable has simply been assigned a value, because that assignment might never propagate to the core you're running on on non-x86 platforms. Because "volatile" is designed for memory mapped access only, "volatile" does not affect CPU memory caching in any way. If you're actually accessing hardware, the CPU will know this and won't cache it. On platforms where special instructions are necessary to propagate memory changes between cores (e.g. MIPS, multicore ARM), volatile or not, changes in ordinary memory might never be propagated between cores. This is a feature. In C11, atomic and threading primitives are built into the language, so the atomic_* function *could* be rewritten using language primitives instead of platform specific code. EDIT: Rewrote the whole thing to make it clearer.
Malloc returns NULL if there are not enough memory, no? If yes what's the point to check, there's nothing you can do anyway.
 Yes there is. If a malloc(1MB) fails, your program can probably handle the error. Or you can at least throw a sane error message to the user. If malloc() fails, that also means the system has overcommit disabled, which means they bloody well has specifically instructed the system that they want that behaviour. Stop perpetuating bad programming behaviour.
I'm out of my depth here but I thought there was an issue that the UNIX kernel is allowed to reject a system call just because it occurred at an inconvenient time. So a program should always check. It could be that there is plenty of memory and a retry will succeed.
Im on mobile so ill be terse. Stdin is a relative term...its just the interface between your program and its environment. It is the default data source for programs and line buffered when stdin is pointed to a known interactive device (keyboard) otherwise fully buffered or not buffered. For example, "./myprogram &lt; myfile.txt" redirects the data in myfile.txt to stdin. Now I'm going from memory and may miss a detail, but when you press a key down, an electrical signal is sent to the computer (hardware level), which is understood by a device driver which translates to a kernel signal/message/interrupt; the kernel and OS manages the dissemination of messages of various programs, so eventually that hardware signal turns into a virtual keycode/scancode that can be processed by your program. Again, this is very rough, but hopefully increases your understanding. Edit: I should also mention more simply that your keystrokes goes into an OS construct called a keyboard buffer (I think this is essentially a file in memory), and stdin is a C construct-a stream. When you read from stdin, the standard library code is asking your OS for the contents of the keybuffer.
In unix, everything is a file. Not in the sense that it's a file on disk - but all devices real and imaginary have filenames. Standard input isn't necessarily tied to a keyboard either - you can pipe anything, including the standard output of another process, into standard input of your process. This works in every major OS. In the case of a keyboard, all that happens is that the key press gets sent into the kernel and stored in a buffer in memory. If that's connected to a program's standard input, a call to read from stdin will return that character.
Foreword: This is going to be a relatively POSIXish-specific explanation. `stdin` represents a stream on file descriptor 0, which typically points to a *device special file* that represents a *pseudo-terminal* (or PTY), a sort of quasi representation of a traditional TTY (*teletype*, a physical terminal). When you press a key on your keyboard, quite a lot happens in a modern, graphical OS: Your key press triggers an interrupt, either with a USB or PS/2 controller, which gets read by a driver and ends up in a buffer that is then read by your graphical environment (X, WindowServer, Wayland, whatever), which then creates some sort of event that is sent to your terminal application, which itself turns that into a character to be fed into `stdin`'s PTY. As far as `stdin` is concerned, the PTY can be thought of as a pipe: the terminal sticks characters in one end, and the program reads them out the other. While that process is happening, some other special things happen depending on the *mode* the PTY is operating in: it may be performing kernel buffering with limited editing (this is why backspace works by default when you read a line), it could be sending each character raw as soon as it comes in (this is the mode *curses* and other "text-mode UI" systems use), it could be catching special characters (`^C`) and interpreting them as interrupts, and while doing those it could be duplicating the inputs to the output side of the terminal (`echo` mode, which is why you can see what you type normally). You can read more about that [here](http://www.linusakesson.net/programming/tty/). At the end of the day, you read from `stdin` and get the results of this. Since `stdin` is a *stream*, there can be both a kernel buffer (used for that simplistic line editing) and a local buffer in the C library (which is why you can [unget](http://pubs.opengroup.org/onlinepubs/7908799/xsh/ungetc.html) characters - they end up back in the C library's buffer for that stream).
Adding to the other comments. In Unix, where all this comes from, there are two type of device drivers, character (stream) and buffered (random access) (C-switch and B-switch devices, names for the kernel-level switch statements handling them). Every process by default is generally connected to a terminal, a type of character device. Generally, character devices have buffering and some processing of the input stream from a keyboard. For example, echo is on be default. This means when a key is pressed, the key is repeated to the screen. You can suppress this behavior via an "ioctl" driver call to put the device into "RAW" mode, meaning suppressing echo (among other things). Programs like VI or Emacs would do this as they do their own echo. Drivers are part of the OS and run in kernel (aka supervisor mode), meaning they run in a privileged state of execution on the CPU. As another OP mentioned, drivers can field interrupts from HW devices. When you press a key, an interrupt is fired, and the CPU passes control to the driver which then reads from the interrupting IO device. At an application level, a user process typically makes calls into the C standard library. This library maintains three file handles (stdin, stdout, and stderr). These are nothing more than pointers to structs in the library. When you call getchar() for example, stdin is used implicitly. The library maintains a read buffer, a simple array of char. When you make a call to getchar() for example, if the buffer is empty, a read() system call is made to the device driver via file ID 0 (by default, an open file mapped to your keyboard). This fills characters from the device-driver-level buffer into the library buffer, and from there your application reads the keyboard. One of the things making Unix really powerful was the notion of pipes. An application can have its file handles 0, 1, or 2 (stdin, stdout, and stderr) mapped to pipes instead of devices. An application reading from such a pipe has no idea in general that another program is subbing for the keyboard (unless of course it attempts an ioctl() on the pipe). Even more cute, as introduced in the BSD versions of Unix was sockets. This is what enabled the idea of servers, i.e., processes listening on sockets waiting for a connection from a client. Overall, a simple, and in my mind, beautiful system.
This is Objective-C.
#1) I have no idea why you use the Objective-C here. Strip out the autorelease pool, swap NSLog for printf, fix some includes and use a pastebin for discussing code instead of pasting it into reddit where it will fail to parse and syntax highlight. #2) The simple answer is "noise." The more complicated answer comes down to explaining how and where all of that noise comes from (which is basically everything else the computer is doing while it's running your program). The way we mitigate that noise is through statistics - sampling multiple times and doing math to figure out about how long on average it takes. However, the clock() function isn't a very precise clock on almost all OSes, and the algorithm and the numbers you're using to test it are going to execute so quickly it will be very hard to separate out the noise from the measurements. In fact, those two logging statements are going to use significantly more time. For more information, Google is a great resource, and this question in its many various forms has been answered at least a hundred times on Stack Overflow.
&gt; Overall, a simple, and in my mind, beautiful system. Better than the crippled abortion called Windows.
These days, hardly any modern computer runs just one program. Your timing varies with the work load of the other software.
I know that it is objective-C but Obj-c is just a super-set of C. In order to be good at Obj-C you have to be good at C. 
You may want to check out this book: [The Linux Programming Interface: A Linux and UNIX System Programming Handbook](http://www.amazon.com/The-Linux-Programming-Interface-Handbook/dp/1593272200/ref=sr_1_1?ie=UTF8&amp;qid=1393834151&amp;sr=8-1&amp;keywords=programming+linux+interface)
I might be wrong... But as I know those calls are not for the user space... The TLPI also doesn't mention those calls... If you want to trigger something on exit, why wouldn't you use signal handlers? Or you might try using atexit()/on_exit() from stdlib..
&gt; For the program, I have actions that should trigger whenever the program itself exits. As /u/clutton mentioned, [atexit(3)](http://man7.org/linux/man-pages/man3/atexit.3.html) is what you seek.
The form of variadic macros shown is actually a gnu extension (named parameters): #define myfunc( A, B, ...) do_something( 0, B, A, __VA_ARGS__); C99 only allows ... in the definition: #define myfunc(...) do_something(0, __VA_ARGS__);
The problem with atexit()/on_exit() is that this is in a LKM and I am required to use only 3 functions as an interface.
LKM as in Linux/Loadable Kernel Module? Specifying that this is in kernel space (and a particular kernel at that) would've been a useful thing to do while asking the question :).
What about with setjmp and longjmp? That's the only time I ever use volatile.
This is C without the "++", you might want to ask on [r/cpp](http://www.reddit.com/r/cpp/). In any case, if you have programming experience I recommend to skip tutorials and just start programming. The only thing you really should understand beforehand is the C memory model which also applies to C++.
I think the if (get rid of var T) statement isn't needed and then change the condition on the do-while to N != 5 
Remove the "\n" in the scanf: #include&lt;stdio.h&gt; void main() { int N,T; do { printf("please enter an integer value: "); scanf("%i", &amp;N); if (N != 5) { printf("Please enter another integer value: "); scanf("%i",&amp;T); } } while(N != 5); } 
Thank you for the advice. I am aware of naming variables in all caps but it completely forgot until you reminded me just now; I'm using two different texts for the class I'm in, and the last one I just referred to to help with the assignment used capital letters for variables so it pretty much just leaked into my thinking. I was taught to use scanf instead of scanf_s but when I initally tried to use scanf on the compiler (MS visual studio 2012) it generated an error so I only use scanf_s when I'm using visual studio 2012. 
Jeez. You can do #define _CRT_SECURE_NO_WARNINGS 1 before any `#include` statements to turn those errors off, IIRC. (Or failing that, #ifdef _MSC_VER #define c_scanf scanf_s #else #define c_scanf scanf #endif and then use `c_scanf`, provided you're not doing anything involving a string buffer. Or `#pragma warning(disable:4996)` I think.)
You are reading into T, but checking N. 
Ah, thanks. Sorry for the mistake haha. and thanks for the advice, will give it a try this way.
&gt;Real-valued mathematical functions are about to be updated according to ISO/IEC/IEEE 60559-2011 If anyone else was wondering about this, the most recent draft is [here](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1790.pdf).
... and _hence_ the error. With the type signature to `main` in your original program, `argv[i]` is a `char` (the result of dereferencing a `char*`) and not a `char*` (the result of dereferencing the correct type of `char**`). So, when calling `strtol(argv[i])` you are trying to force `argv[i]` to be a `char*` (the type of `strtol`'s first argument). Or, in other words, you're trying to make a pointer type, `char*`, from an integer type, `char` without a cast. The error message is not some mystic rune, it is there to help. Explaining how the error message lets you find the mistake rather than just pointing out said mistake will hopefully teach you how to fish in future.
Thanks for completing the explanation. You're right, I should have given more detail.
Look at this line: #define ODD(X) ((X) &amp; 01) I think you meant `0x1`. Unless you intend to have an octal number which, to a first approximation, no one ever does. As for your question: a number which has the _n_ least most significant bits set is `(1&lt;&lt;n) - 1`. That should be the first hint.
[I've been fucking about with this for 3 hours and I had forgot the fucking square fucking brackets fuck!!!!!!](http://imgur.com/i5gWGRh)
No probs. I just wanted to give the student a bit of a hand about how to handle the next problem on their own. I think it's being a University teacher who gets the other side of these posts which makes me twitch about such things; I'm very glad students ask reddit about their problems but it makes my job a lot easier if reddit also explains how the students can fix their problems in future. It's just laziness on my part really ;&gt;.
Thanks for the help and insight guys, as a second year software engineering student, I'm completely embarrassed I posted this on Reddit having made such a simple mistake and missed the square brackets!
... or missed the second asterisk. The relation between arrays and pointers in C is somewhat special. I'd highly recommend reading http://cm.bell-labs.com/who/dmr/chist.html for some historical perspective on how and why they came to be the way they are.
I've already solved the problem with BITON, I'm working on the ALLON part right now. I'm trying... #define ALLON(X,S,E) (((X) &gt;&gt; (S)) | (~(0&gt;&gt;(E-S)))) == ((X) &gt;&gt; S)) but it's not working, any ideas where the flaw is?
Yup, my hint was aimed at ALLON. Second hint: if `x` has bits 2 to 5 inclusive all set then `x&gt;&gt;2` will have bits 0 to 3 set, i.e. the 4 least most significant bits. So, how do you test to see if the _n_ least most significant bits are set?
&gt; any ideas where the flaw is? What do you expect `0&gt;&gt;n` to be for positive `n`? What was your rationale for including it in the expression above?
Well, `0&gt;&gt;(E-S)` is `0` and so `~(0&gt;&gt;(E-S))` is not really what you want, since it's always `~0`. You probably want `(~0)&gt;&gt;(64 - (S))` or `(1 &lt;&lt; (S)) - 1`. To avoid debugging nightmares, you should, when you create difficult expressions like this, separately check that each piece of your expression works properly. I think you'll find that the `(X) &gt;&gt; S` part doesn't work well either. Also, don't forget to surround each use of a parameter (X, S, or E) with parentheses.
I'm relatively sure that octal 1 is the same as hex 1 which is also the same as decimal or binary 1. So I doubt that's a bug.
In addition to the comments above regarding right shifting 0, you may want to specify the constants in your macros as e.g. 0UL assuming you're working with 64-bit longs. I've run into the occasional problems omitting this on certain architectures.
But it's almost certainly not intended and it is very much non idiomatic. Best to nip it in the bud.
Just as the error message says, if you are going to declare a variable in the parentheses of a `for` loop (as you are doing with the variables `k`&amp;nbsp;and&amp;nbsp;`j`), then you need to compile your code as C99. Declaring variables in this way was illegal before C99.
Creating a variable inside the init-expression was not implemented before C99, so you have to tell the compiler to compile as a C99 source code. That's way the message error tells you to use -std=c99 or -std=gnu99, they're both parameters specifying the C version you want to use. edit: typo
Thank you for your response. So I'm pretty new to c. How can I fix this without using c99? 
Thank you for your input. How would I fix this without using c99? My professor has never used that term (c99) so I imagine I'm not supposed to use that. Pretty new to c. Any additional advice is much appreciated. Edit* clarification
Declare the variables `k`&amp;nbsp;and&amp;nbsp;`j` at the beginning of the function, along with your other variables (`pa`&amp;nbsp;and&amp;nbsp;`i`).
Since the main question has already been answered, I want to ask you a question. What is your intended purpose with char *pa? 
&gt; int i; int i, j, k;
Uh oh. I have a sneaking suspicion I'm going to get a "you're doing it wrong!!!". I'm supposed to be practicing with pointers. Using a pointer to print. 
Not wrong, per se, but certainly the hard way. First off, #define countof(array) (sizeof(array)/sizeof((array)[0])) will give you the number of elements in an array (not via a pointer, mind you) so if it changes size, you won't be left in the dust. Second, your loops can be simplified rather a bit: pa = a; for(i=0; i&lt;countof(a); i++) printf("%c", *pa++); or even for(pa=a, i=0; i&lt;countof(a); i++, pa++) putchar(*pa); depending on your mood and opinion of postincrement (++). And really, if you're going for proper C practice, you can just do something along these lines: static const char[] A = "Hello, "; static const char[] B = "world!"; const char *p; for(p=A; *p; p++) putchar(*p); for(p=B; *p; p++) putchar(*p);
C99 is just the version of the language, without using the -std options, you have to declare the variables outside the for loop, before it. I'm on mobile, so it won't be formatted, but it's something like this: int k = 0; for(k = 0; ... ; ...) { // code } edit: formatted
I'd probably use fgets to fetch each line, and strtok to split each line into its pieces. Then you can use sscanf to parse those pieces into numbers. 
Is it possible for you to give an example? I'm very new to C. Thank you.
first, show us your work
The '&lt;' operator redirects the input file to stdin. So your program should just treat the input as if you were typing it on the keyboard. Also, because you want to read integers, you should use scanf instead of gets.
In C, the standard input is exactly like a file stream. There's no difference at all between reading a disk file and reading `stdin`. `getchar()` is exactly the same as `fgetc(stdin)`, and so on. If you write your input-reading function to take a `FILE *` argument, then you could either call it with a file you opened, or call it with `stdin`. 
Why not just a simple fscanf? To get the first 2 variables the go of from there? 
You could also create a file pointer to open the file (FILE * matrices = fopen("input.txt", "r"), then use fscanf to get the contents line by line. This just removes the need for the extra command line argument, but make sure that your .txt file is in the current directory
The others already did answer your question, but let me point out that you should always terminate your strings ( or char arrays in this case). So char a[] = {'H','e','l','l','o', 0}; char b[] = {'W','o','r','l','d', 0}; otherwise bad things will happen. ^Bad ^things ^may ^include, ^but ^are ^not ^limited ^to, ^the ^rising ^of ^Cthullu.
I've generally found that operating line-by-line produces cleaner code, and more diagnosable errors. Using fscanf to read each value would work just fine, for such a simple problem I guess. It's just not really in my toolbox anymore.
Part 2: https://lwn.net/Articles/588300/ [x-post](http://www.reddit.com/r/linux_programming/comments/1zpv3d/c11_atomic_variables_and_the_kernel/) from /r/linux_programming
Oh, you're right. I glanced too glancingly at `main` and didn't notice it ending in the middle there.
There is a slight advantage in using [asprintf(3)](http://linux.die.net/man/3/asprintf) when available since it will allocate just the amount of memory required. Using snprintf requires the programmer determining and using the worst case memory requirement. As /u/bvanheu vanjeu pointed out snprintf and printf serve different purposes and so there's no efficiency comparison worth making unless for some reason you are a) opening a file, b) redirecting stdout to it, c) using printf and then d) reading the file back in or a) snprintf-ing to a buffer and b) fwrite-ing that buffer to stdout. In either case you're just doing it wrong :).
Another example might be dealing with filenames. Suppose your program is supposed to read or write to a set of sequentially numbered images in a given path, such as `/foo/bar/img000042.png`: char filename[256]; FILE *f; snprintf(filename, sizeof(filename), "%s/img%06d.png", save_path, image_number); if((f = fopen(filename, 'wb') == NULL) { ... } ... There's just no way to do that with `printf()`. (Well, there's an extremely roundabout and ridiculous way, but doing that would be incredibly silly and pointless.) Like the others said, it has nothing to do with efficiency, it's about whether you need the result as a string or not. 
Based on your edit, I'll talk a bit about `sprintf()` versus `snprintf()`. `snprintf()` is equivalent to `sprintf()` but with an extra argument `n`, the maximum number of characters to write. I like `snprintf()` better because it obeys one of my core C programming practices: If a function takes a buffer of unknown size as an argument, it should also take its size. There are a few exceptions to this, but in general it's a good rule of thumb to follow. In `snprintf()`'s case, the size n should not exceed the size of the destination + termination character. This prevents accidental buffer overrides. Note that snprintf itself won't prevent you from shooting yourself in the foot - if you pass a size that's greater than the destination buffer size, you can still cause havoc. See this link for a good presentation on formatted output vulnerabilities and coding practices: https://www.securecoding.cert.org/confluence/download/attachments/111083784/05%20Formatted%20Output.pdf?version=1&amp;modificationDate=1383078132000&amp;api=v2
aside that it's a gnu extension, it also performs a malloc. I prefer this in c99: int url_size = snprintf(NULL, 0, "http://%s/index.html", ip_addr) + 1; // 1 extra for zero terminator // if you want check if url_size is not too big for stack char url[url_size]; // yey, c99 varuable length arrays, no free required snprintf(url, url_size, "http://%s/index.html", ip_addr); // use url
Thanks for the info. I was under the impression it was a favoured way of doing things because someone mentioned working only in ram for their programs as opposed to using the I/O stream through printf and the like.
Great help thanks. Also thanks for the link. Reading through it now and its really useful :D 
That's some really nice code.
printf(), and related functions, already buffer their output, so don't use snprintf() just to delay I/O.
why the server is in python?
Minecraft was written in Java.
Thanks. Looks like this clone is a huge improvement then.
Is he trying to build a minecraft clone in as many languages as possible? I remember seeing his 500 line python minecraft clone. This is really cool!
does it go cross-language with his python clone?
I personally wouldn't want to cloud my implementation files with documentation stuff. The header files already act as an impromptu documentation so it would would make sense for me to put the Doxy stuff in there. That being said I have never used Doxygen and maybe I am misunderstanding what it does.
It's written in Java, OpenGL 1.2(Has now changed to 2.1), and isn't open or free software.
Here is how I like to see it. If you have a library and a user has access to the header then what would they be concerned with? What the purpose of the function is, what the parameters are meant for, and what the function could return. That's what a user cares about. They don't need to care about how. That can be in c file for the other developers who may need to refactor or understand when tests fail. That's where the extract all tag comes in handy. As long as you keep your header file documentation in step with code changes that occur in a header file then things such as a make file shouldn't be too big of an issue. But again, that is how I approach it.
Personally, I like to put "in-body" documentation (things like implementation details) in the .c file and documentation for things like functions and params in the header file. One reason for this is because this is how I like to document params: /** * Function documentation * * @return return value documentation */ int Function( int var1, /**&lt; documentation for var1 */ char * var2 /**&lt; documentation for var2 */ ); I find this style only clutters the already crowded .c file, so I tend to define functions like: int Function( int var1, char* var2 ) { /** * @internal in-body documentation */ ... } But as always, consistency is more important than whatever style you ultimately go with.
If it doesn't speak the Minecraft protocol it's basically irrelevant to the wider MC community. Boxel clones are a dime a dozen
I have documented and checked documentation of several projects. All used different styles - some with the docu before the fuction source, some inside of it. Doxygen doesn't care. If comments are in the header files as well, it just adds to the total amount available. It is not for now that you are writing the documentation, it is for later. I have worked on old projects that had no documentation or very poor levels, and first job was to go through the source and add Doxygen everywhere to make sense of the code.
Nice article, but the two examples are in my opinion extremely contrived. The first example: void f(void) { int x = 42; g(&amp;x); } is pretty self evident that it can't be tail called optimized. Whoever wrote that obviously did not care about TCO. The second example: void f(void) { int x = 42; global_var = &amp;x; g(); } is just hopelessly broken. Since global_var points to a variable on f()'s stack, it's value will be invalid as soon as x() returns. I mean, who writes code like that? You're just inviting wild pointer dereferences all over the place. However, tail call optimization is a quite misunderstood feature in C, and it would be good to get more insight into what assumptions normal compilers of today makes.
Nobody should care about that. If you're stuck in standard C89 you're going to have so many problems it's not even funny: Say no to inline, function attributes, named initializers, fixed size integers, 64 bit integers, size_t types, a lot of compiler optimizations, use of IEEE754 hardware floating point acceleration (hello software emulation!), among other things. All modern compilers (most of which implement their own C dialect which combines C89, C99 and C11) support it even in archaic modes, and C99 came out *sixteen years ago*. It's time to move on.
I use -ansi -pedantic, thank you very much ;). And point by point: inlining as an optimization technique can be applied to essentially any language (and there are always macros); function attributes are (and have always been) a compiler-specific feature; any specific exact-width integer from C99 is not actually guaranteed to exist; the size of C datatypes is implementation defined, and it's perfectly possible for a C89 compiler to have 64-bit integers (if you mean long long, well, C99 doesn't have bignums, so I guess we should all use Python); size_t is present in C89; there is no reason I can think why a compiler optimization in C99 would not work just as well in C89; the features of the hardware, again, are the responsibility of the implementation, and *not* the standard; and Visual Studio, notoriously, has only started offering C99 support a few months ago. Furthermore, [even some well-known compilers](http://en.wikipedia.org/wiki/C99#Implementations) fail to implement the C99 standard completely, and [some projects](http://www.lua.org/faq.html#1.1) consider their use of pure ANSI C to be a feature of portability. EDIT: I forgot to mention, at least one tool I use all the time, [Splint](http://www.splint.org/), lacks support for many C99 additions. If you try to, say, declare a variable in the preamble of a for loop, the parser will crash.
This will break gloriously if snprintf returns a length larger than your stack's size. If you're already using gnu extensions, you might as well use `__attribute__((cleanup(x)))` and have it automatically call free when you leave scope.
&gt; I use -ansi -pedantic, thank you very much ;). And point by point: Why? There is absolutely no reason to do that, if you don't like torturing yourself. &gt; inlining as an optimization technique can be applied to essentially any language (and there are always macros); The "inline" keyword appeared in C99. It only existed as a compiler-specific extension before that. &gt; function attributes are (and have always been) a compiler-specific feature; Yes, that's correct. You can't do proper coding without them, though. &gt; any specific exact-width integer from C99 is not actually guaranteed to exist; Yes they are. They are part of C99 and guaranteed to exist in a standards-compliant compiler. &gt; the size of C datatypes is implementation defined, and it's perfectly possible for a C89 compiler to have 64-bit integers (if you mean long long, well, C99 doesn't have bignums, so I guess we should all use Python); No, they are not. Their sizes compared to each other are specified in the C standard, and only C99 and later have a datatype guaranteed to be 64 bits or larger (long long). &gt; size_t is present in C89; I stand corrected, you are right. &gt; there is no reason I can think why a compiler optimization in C99 would not work just as well in C89; Then you haven't been reading the standards properly. There are a *lot* of optimizations that are not possible in C89 due to the lack of proper keywords (restrict, for example, and inline). &gt; the features of the hardware, again, are the responsibility of the implementation, and not the standard; You have no idea what you are talking about. C99 introduced hardware IEEE 754 floating point support. It only existed as compiler specific extensions before. &gt; and Visual Studio, notoriously, has only started offering C99 support a few months ago. That only tells us Visual Studio is hopelessly broken and shouldn't be used. &gt; Furthermore, even some well-known compilers fail to implement the C99 standard completely, "Completely" is a straw man here. C99 is very large, and some obscure features are never used and are (rightly or wrongly) not implemented in some compilers. All modern compilers of value implement the necessary feature set of C99 to make it useful. &gt; and some projects consider their use of pure ANSI C to be a feature of portability. Then they are simply wrong. C99 is just as portable and as much of a standard as anything else. Heck, nowadays people should be migrating to C11. It's been out for three years already, and gcc and clang has almost full C11 support now. &gt; EDIT: I forgot to mention, at least one tool I use all the time, Splint, lacks support for many C99 additions. If you try to, say, declare a variable in the preamble of a for loop, the parser will crash. splint is totally broken and outdated anyway and has been for a long time. The number of false positives it throws at you is staggering, don't use it. There are a lot of better tools out there, such as the static analyzer in clang which plays in a totally different division compared to splint.
Hi mowdownjoe, this problem would likely get more answers on /r/cpp. C and C++ programmers are not mutually exclusive groups, but we try to keep the topics limited to issues affecting C programmers here.
Thanks for the tip. /r/programming had no mention of that sub in their wiki.
They are a nice community, too. It should definitely be up there.
&gt; The "inline" keyword appeared in C99. It only existed as a compiler-specific extension before that. In my opinion, the compiler is better at figuring out when to inline than you are. Same reason we don't use register any more. And you still have macros and function attributes at your disposal. &gt; Yes, that's correct. You can't do proper coding without them, though. But it has nothing to do with the version of C. Function attributes are entirely supplemental to the C standard; you can use them with C89 as easily as C99. And bollocks to the "proper coding" comment, plenty of "proper" code can be compiled just fine without function attributes. &gt; Yes they are. They are part of C99 and guaranteed to exist in a standards-compliant compiler. They are not, as the standard doesn't specify the precise widths of any datatype (a char is not even guaranteed to be 8 bits). It is possible for a compiler to define all integral datatypes to be 64 bits, in which case int8_t, int16_t, and int32_t will not be defined. &gt; Then you haven't been reading the standards properly. There are a lot of optimizations that are not possible in C89 due to the lack of proper keywords (restrict, for example, and inline). I am not as sure about restrict, but any sufficiently smart compiler is capable of inlining functions without hints, and will probably do a better job than you or I could. &gt; You have no idea what you are talking about. C99 introduced hardware IEEE 754 floating point support. It only existed as compiler specific extensions before. I could be wrong about this, but that just prescribes *how* floating point is done, right? The interface is the same, and giving a cursory look at the relevant GCC documentation, it looks like there's no reason you can't tell the compiler to use IEEE 754 for floating point. Correct me if I'm wrong. &gt; Then they are simply wrong. [C++] is just as portable and as much of a standard as anything else. Heck, nowadays people should be migrating to [C++11]. It's been out for three years already, and [g++] and clang has almost full [C++11] support now. And look at how much more C++ adds to C compared to C99! (Based on a quick look, it looks like C++11 support might be even better than or comparable to C99). &gt; splint is totally broken and outdated anyway and has been for a long time. The number of false positives it throws at you is staggering, don't use it. There are a lot of better tools out there, such as the static analyzer in clang which plays in a totally different division compared to splint. I use both, and the number of legitimate warnings splint finds versus scan-build is ridiculous. In my experience, a lot of warnings that people assume are spurious are genuine. And while there are some false positives involved in splint, the vast majority of them can be solved through refactoring the code, which makes it clear not just to splint but to the user that you know what you're doing. Maybe you don't care about warnings like tatom.c:14:10: Test expression for if not Bool, type int: x Test expression type is not boolean or int. but I personally consider if ( x != 0 ) or declaring x as Bool x; to be better style, and you'd be surprised how many errors you might catch when it turns out you're using the wrong variable. If you still don't like the warning, pass the option -predboolint. Another helpful trick is catching any null variables that aren't annotated as such; again, you'd be surprised at the bizarre ways variables can become null without using static analysis. And these are just two examples out of dozens of classes of errors that scan-build doesn't catch for me. EDIT: Apologies that the formatting isn't optimal, I'm new to reddit.
The header file was mostly for experimentation with header files, but also because I didn't know what their use really was. Thanks!
This is a case where I'm sure lazy coding will come back to haunt me... I'll try to get in the habit, thanks!
Got it got it! I'm naively going to ignore your advice about separating repositories for now, however I will keep it in mind when it inevitably comes back to me in the future. I set executables to be ignored, however, thanks for the tip! and the encouragement! 
I think we've both made our points, but a couple comments: &gt; &gt; Then they are simply wrong. [C++] is just as portable and as much of a standard as anything else. Heck, nowadays people should be migrating to [C++11]. It's been out for three years already, and [g++] and clang has almost full [C++11] support now. And look at how much more C++ adds to C compared to C99! (Based on a quick look, it looks like C++11 support might be even better than or comparable to C99). &gt; They're different languages. It's like saying "you should go to Python instead of Perl". C99, on the other hand, is a later iteration of the same language as C89. The only actual C++ incompatibility I've found in C code in the wild (compiling with -Wc++-compat) is C++'s requirement that you cast void pointers. If you make sure to always cast your mallocs (I'm not suggesting you otherwise should), you'll have a program in the common subset of both languages. (I am only confident about this for C89). &gt; No I don't because that's coding style. It's what humans read. The static analyzer shouldn't complain about that, it should complain about things the compiler reads, i.e. the results of the tokenization of the language. In this case, they're identical. All static analyzers are ultimately style checkers, since any actual errors would prevent compilation. For example, here's a scan-build warning: memchk.c:200:31: warning: Access to field 'free' results in a dereference of a null pointer (loaded from variable 'block') block-&gt;free = freeList.free; ~~~~~ ^ Now this isn't actually an *error*, as the code compiles fine, but it thinks that the code isn't doing what you expect. In this case it turns out that block-&gt;free will never be NULL at this point in the code, but for every conceivable static analysis warning, there's a conceivable way for that code to be harmless. What we're really talking about is the level of verbosity we want, and I simply prefer more verbose. I don't run Splint because I think it should be required to cast every variable, but because I am willing to spend a minute looking at each implicit cast for the one or two I didn't expect. &gt; I'm not following what you mean by "annotating null variables". All pointers may become NULL at some point, but I guess that's not what you meant. There are plenty of times when you don't expect a pointer to become NULL, and plenty of times when your code can handle a NULL pointer without error, even when you know it shouldn't, making it difficult to track down. Splint will tell you if a pointer or function parameter or return value can become NULL, unless it's something you expect to happen and annotate it with a /\*@null@\*/ comment. I'm not saying people have to program that way, I'm saying there are legitimate reasons why one might want to. Same thing for which version of C to use. If you're writing code for GNU/Linux, go ahead and use C11 with all the compiler extensions and non-portable libraries you want. If you're writing code designed to be run on legacy hardware or different operating systems, be more circumspect with the tools you choose. &gt; Be realistic. A char is always guaranteed to be one byte by the Standard. Since no platform since archaic history has had bytes that are not eight bits long, and none will ever be created now, this is not a problem. A char is de facto guaranteed to be eight bits. And plenty of programmers in the 90s said the same thing about 32-bit IP addresses and 2-digit years. If your code will be in an environment that it doesn't have to worry about things like the size of a char, then don't. EDIT: If you think Splint takes it too far, check out [MISRA C](http://www.ristancase.com/html/dac/manual/3.12.02%20MISRA-C%202004%20Rules.html).
&gt; And plenty of programmers in the 90s said the same thing about 32-bit IP addresses and 2-digit years. If your code will be in an environment that it doesn't have to worry about things like the size of a char, then don't. Nobody does. It will never happen. A char will always be eight bits. If it actually wouldn't be, it'll be on a totally different platform, so your code wouldn't run without modifications anyway. This is a prime example of [premature optimization](https://en.wikipedia.org/wiki/Premature_optimization#When_to_optimize) (not performance, but flexibility): Deal with this if it ever becomes a problem, not before. &gt; EDIT: If you think Splint takes it too far, check out MISRA C. I've done MISRA C. It's horrible. Its insane coding standards must be made up by people who likely couldn't code themselves out of a barn if the door was twenty feet wide and right in front of them. Many of the rules, especially the one about always initializing variables when declaring them, *created* a lot more bugs for us because it counterintuitively (to MISRA, to us it was very intuitive) disables a lot of the compiler checks. For example, this function isn't valid MISRA C: int foo(void) { int x; /* code that by mistake doesn't modify x */ return x; } but it will, on all modern compilers, trigger a "variable is uninitialized" warning and you'll fix it. MISRA C, on the other hand, requires this: int foo(void) { int x = 0; /* code that by mistake doesn't modify x */ return x; } which never does that, because the variable is properly initialized. Proper dead code checks are harder to implement than uninitialized checks, so the compiler is less likely to warn about this scenario. The only way to code MISRA C is to have exceptions on every other line, thus not only defeating the purpose of making the code safer, but also making the code *more* buggy because you can't see the meaning of the code that's behind all the "MISRA C violation" comments. We've also strayed from the subject: It was that you can safely assume C99 functions are available when coding standard C today. You can safely do so. Especially for OP, as he/she is clearly a beginner at C and shouldn't have to deal with exotic C89-only compiler chains.
I wish I could keep my code this simple.
No it's not the solution to make smaller commits, but actually do some regression tests. How fucking hard can it be to test a TLS library if it can actually FAIL to accept a certificate? This is a basic function of the library. This is not a case of "it can happen". How can one trust a library dealing with security when it does not even test most basic cases? This is horrible!
There are multiple things you can do to prevent these kinds of problems from happening. Smaller commits is one of those things. `&lt;stdbool.h&gt;` and testing helps too. But, yeah, I was pretty shocked to read that GnuTLS didn't have tests for this kind of thing.
I have aliased 'gcc' to 'gcc -Werror' so that it automatically treats all warnings as errors.
 -Wall -pedantic -Wextra Plus whatever C version the project's in, mostly: -std=c99 followed by all the library linkage necessary. Maybe an optimization flag for the final build if I bother with that at all. I'm sure I'm missing out on a lot of neat stuff though.
-Wall -Wextra -Werror -std=gnu++0x -Wformat -Wformat-security -D_FORTIFY_SOURCE=2 -O1 -Wl,-z,relro,-z,now -D_FILE_OFFSET_BITS=64 and sometimes -g :)
 CFLAGS += -std=c99 -pedantic-errors -Wall -Wextra -Werror -O2 Static analysis tools (Sonar, Coverity) can pick up the rest later.
Sorry if this is a dumb question, but what is the purpose of -fno-exceptions? Why would there be c++ exceptions in a C program?
C language code that is expecting to interoperate with C++ should be compiled with -fexceptions. 
It's basically the same thing: my 'EntityPool' implementation (it's a sort of container) has an entitypool_foreach macro to make iteration easier to your eyes. Just wanted to see your thoughts on its readability and form. I guess it's acceptable if used in a simple and clear way. Thanks!
Some random thoughts: * If you're using C99 you can declare your variables in the loop and not have to rely on callers declaring any beforehand &amp; simplify your macro definition. * I generally make my macro names all uppercase - the idea is to make it super obvious they're macros. * I generally call pointers to one beyond the end, limits. E.g. in your case I would have named that fn entitypool_limit and my test would be something like sprite &lt; limit. The idea is to reduce ambiguity about what 'end' means. As for whether it's a good idea - it's hard to say. A few judicious macros can really clear things up. But, too many and your source becomes a funhouse. Sometimes you just have to try it out and see what your sources look like. And even then, there's a good chance you'll be reading this code a few months down the road and say "What was I thinking?"
/usr/bin/gcc -c -pipe -fPIC -Wall -Werror -DDEBUG -O41 -mtune=winchip2 -fjesus-saves-gretzky-scores -fno-sched-spec -fbranch-probabilities -fmerge-constants -fno-sched-spec -fprobation-officer -frubber-tommy-water-gun -ftruth-archaeopteryx -funroll-all-loops urine.c
-Wall -Wextra -Werror or go home -04 or feed mid.
The examples in [part 2](http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html) are especially good, where code that has potential undefined behavior effectively asserts that those conditions will not arise, thus allowing the optimizer to assume they won't occur in the code that follows. void contains_null_check(int *P) { int dead = *P; if (P == 0) return; *P = 4; } The initialization of dead with *P effectively turns into an assert(P) beforehand. 
That is C++ code, not C code. This is /r/C_Programming. This subreddit is for discussion about C code, not C++ code. Try /r/cpp_questions or /r/learnprogramming. Also, when you post code on Reddit, don't use bullets. Indent every line of code with four spaces so that Reddit formats it properly as code. 
compiling with -O0 will disable many warnings (because the compiler opts for speed rather than deep analysis), always compile with -O2 or -O3 to get all warnings. I can't recall which kind of warnings from the flags you're using are affected specifically, but I recall it biting me in the ass before.
&gt; (because the compiler opts for speed rather than deep analysis) I think it's actually because some warnings are run in the optimizer.
I'd recommend `-g3` which adds more debug information for macros which gdb can use and if you are using a recent GCC then you should give `-Og` a try. It adds some optimizations which shouldn't impact debugging. That way the debug version is at least somewhat closer to what your production code will be like (unless `-O0` is your production version of course). Oh and `-pedantic` or `-pedantic-errors` is great to get more stricter warnings about standard violations.
I use c99 -O because everything else is not portable.
`-ffreestanding -nostdlib -Wall -Wextra -Wno-unused-function -Wno-unused-parameter -Wstrict-prototypes -pedantic`
I'm sure that if you post a couple of the questions here you will get some answers.
yeah cheers dude - thought someone might have the lot tucked away. no worries :)
I tried to find a source for this claim. Can you point me to one? I was always under the impression that the different optimisation levels do not make a difference in language parsing.
Default: -std=c99 -Wall -Wextra -Werror -pedantic -pedantic-errors Then added (for debug builds): -g3 -O0 or (for release builds): -g0 -O3
Here's an example you can try for yourself. Download SQLite's source: [sqlite-amalgamation-3080401.zip](http://www.sqlite.org/download.html). # No warnings $ gcc -ldl -pthread -O0 -Wall sqlite3.c shell.c $ # Change to -O3 $ gcc -ldl -pthread -O3 -Wall sqlite3.c shell.c sqlite3.c: In function ‘balance’: sqlite3.c:57029:22: warning: array subscript is above array bounds [-Warray-bounds] pOld = apCopy[++j]; ^ $ 
 -funsafe-math-optimizations Is my favorite. 
I'm relatively new to C, so this might sound stupid, but everyone's flags are vastly fewer than mine. Is there a reason I don't want this? -ggdb3 -Wall -Wextra -Wdouble-promotion -Wformat=2 -Winit-self -Wmissing-include-dirs -Wswitch-default -Wswitch-enum -Wsync-nand -Wstrict-overflow=5 -Wtrampolines -Wfloat-equal -Wdeclaration-after-statement -Wundef -Wshadow -Wunsafe-loop-optimizations -Wbad-function-cast -Wcast-qual -Wcast-align -Wwrite-strings -Wconversion -Wjump-misses-init -Wlogical-op -Waggregate-return -Wstrict-prototypes -Wold-style-definition -Wmissing-prototypes -Wmissing-declarations -Wnormalized=nfkc -Wpadded -Wredundant-decls -Wnested-externs -Winline -Winvalid-pch -Wstack-protector -Wunsuffixed-float-constants -Wunused -Wunused-macros -Wsuggest-attribute=pure -Wsuggest-attribute=const -Wsuggest-attribute=noreturn -Wmissing-format-attribute -Ofast -fmodulo-sched -fmodulo-sched-allow-regmoves -fgcse-sm -fgcse-las -funsafe-loop-optimizations -fdelete-null-pointer-checks -free -fira-hoist-pressure -fira-loop-pressure -fsched-pressure -fsched-stalled-insns=0 -fsched-stalled-insns-dep -freschedule-modulo-scheduled-loops -fipa-pta -floop-interchange -floop-strip-mine -floop-block -fgraphite-identity -floop-nest-optimize -floop-parallelize-all -ftree-loop-if-convert -ftree-loop-distribution -ftree-loop-im -ftree-loop-ivcanon -fivopts -ftree-parallelize-loops=4 -ftree-vectorize -ftracer -funroll-loops -fvariable-expansion-in-unroller -freorder-blocks-and-partition -fexcess-precision=fast -fsingle-precision-constant -fpeel-loops -ffunction-sections -fdata-sections -fbranch-target-load-optimize -fbranch-target-load-optimize2 -fstack-protector -fsection-anchors -ansi -pedantic -freg-struct-return -fsplit-stack -ftrapv -fno-common -fstack-check -fno-omit-frame-pointer -fsanitize=address
or you can use -ggdb if you are using gdb for debugging. There are even *level*s, like -ggdb3 For details: http://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html
hmmmm, not a problem for me. $ $ gcc -ldl -pthread -std=c99 -Wall -Wextra -Werror -pedantic -pedantic-errors -O0 sqlite3.c shell.c $ echo $? 0 $ gcc -ldl -pthread -std=c99 -Wall -Wextra -Werror -pedantic -pedantic-errors -O3 sqlite3.c shell.c $ echo $? 0 $ gcc --version gcc (Debian 4.7.2-5) 4.7.2
The main reason you are getting 0 for every answer is that you define global variables **minuss** and **pluss** that you are printing out in the last 2 lines of **main** but you are never setting their values. Inside the **QuadraticFormula** method you have redefined those variables locally so you are not accessing the global ones. Also, I'm not sure how this code could be compiling with the line: int difference = 4b - ac; Because the **4b** and **ac** should should flag an error as they are not valid constructs. I'm assuming here that this is just a formatting issue with the way you pasted the code.
This particular case must be a recent gcc thing, $ gcc --version gcc (Debian 4.8.2-16) 4.8.2 I mentioned this example because I ran into it recently. 
I like the macro approach, for the reason that it abstracts away the underlying data structure (That way you're not exposing your array setup, and you could Ex. switch it out for a linked-list or rbtree or whatever in the future without breaking all that code). I would be against exposing your setup directly to all of your code, as it's more confusing then the macro overall, and really the macro is basically a comment saying 'loop over every sprite in the pool', and that's perfect from a readability standpoint since it explains exactly what you're doing. Lots of data structure setups look great at the beginning but quickly degenerate when you keep going, having generic macros for simple normal procedures like that can simplify things down the road. The only real issue with the macro is that it does hide the actual semantics of what happens in that loop (ideally you don't care about the semantics anyway. The expanded version doesn't really tell you much anyway). Someone below noted that you can declare variables in the loop. I would advise against that except for keeping state. Ex. This isn't really that clear: entitypool_foreach(sprite, pool) /* stuff */ Since, if say 'sprite' is declared in the loop, the variable's type is hidden. In general I consider that bad practice, the extra statement makes it much more obvious: Sprite *sprite; entitypool_foreach(sprite, pool) /* stuff */ However, if you have some stuff you need to keep track-of during the loop, hiding that variable by declaring it in the for statement is a good and useful idea. (Assuming you're using C99 or later). I have a macro like this in some code I'm working on. I can't say if I love it or not, but it does get the job done fairly well (For traversing rbtree structs - This is one of three for inorder, preorder, and postorder traversal): #define rb_foreach_inorder(tree, node) \ for (rb_trav_state _rb_state; node != NULL;) \ for (node = rb_trav_first_inorder(tree, &amp;_rb_state); \ node != NULL; \ node = rb_trav_next_inorder(&amp;_rb_state)) My initial version only had one 'for' statement, you had to supply the 'rb_trav_state' as a third parameter. This fairly ugly though, since nobody should even be bothering with that variable since I don't really consider it part of the API. The solution I came up with is that second for. Since it has the same condition as the inner for statement (And no increment), they both just exit at the same time (And GCC generates no extra machine code for that extra loop). It basically gives you another variable declaration to use. The downside is that I couldn't figure out how to make it work with break. I'd love to know if anybody has any ideas I didn't think of.
The type of the variable `fact` is `unsigned short`, right? What does "`unsigned`" mean? It means that the value of the variable cannot be negative, right? Now look at the condition in your loop: `fact &gt;= 0`. That condition will *always* be true. It is *impossible* for an `unsigned` variable to have a negative value, so it is impossible for `fact &gt;= 0` to be false. Therefore, your loop will run forever, because the condition of the loop will always be true. Make sure you have all warnings turned on in your compiler, and pay attention to what they say. I know that at least some compilers (`gcc`, for example) will warn you about mistakes like this one.
Thank you so much for your help. Your comments were very helpful to me and after you pointed all those things out I was pretty much able to complete the assignment, so thank you so much!
I'm on mobile so can't reply to your whole comment atm (lot's of good info there though). But on the last point -- I do what you're trying to do with a single for loop by using an 'if (1) { /* init */; goto label; } else label: for (...)' trick as shown in the bottom here: https://github.com/nikki93/cgame/blob/master/src/entitypool.h
I like that approach, unfortunately I can do that since I need to declare _rb_state in the first 'for' and then use it in the second 'for'. Hmm...
Almost all the optimization flags you provide are enabled in the generic option -O3. Why don't you use that instead? It's more portable across different compilers.
I hope its safe against Format string exploits, although you hopefully wouldn't use it on a productive system!
How are you reading/wrinting to the stock.t file? Because with the code you've posted, you're only opening a file handle and not doing any input/output from/to the file.
 struct inventory { int item_num; char item_name[25]; float item_cost; int item_inventory; }; //This one takes in the inventory information void function1( ) scanf("%24s",&amp;stock[count].item_name); scanf("%f",&amp;stock[count].item_cost); scanf("%d",&amp;stock[count].item_inventory... FILE *stockfile; stockfile= fopen("C:\\Users\\Varo\\Desktop\\stock.t... void function2() { char tempname[25]; struct inventory stock[20]; int tempquan; FILE *stockfile; stockfile= fopen("C:\\Users\\Varo\\Desktop\\stock.t... scanf ("%d", &amp;tempquan); stock[count].item_inventory = stock[count].item_inventory - tempquan; Apart from the fact that I am not really sure about what you mean by a global function (every function is "global" in the sense that as long as it has been declared, its symbol is accessible. There is no notion of private or local function, except with the static keyword, which is only dealing with the symbol...). You should read the documentation of scanf. I'm not sure exactly what you are trying to do here but if I understand correctly: function1() open a file, then write to it (I guess you mean write when you say display, otherwise I do not know what you mean by "display a value in a file") some value that should be stored somewhere, possibly in a preexisting variable. Then there is function2(), which open the same file and then tries to read from it, to store the value read in a local variable. Am I correct here? Because if that so, both of your use of scanf are incorrect. You want to write to a file, thus scanf is not useable in the function1. Try fprintf() . If you want to read from a file, a simple function to do so could be fscanf(). Here is a quick example of use of fscanf: FILE* file = fopen("pathToFilename", "r"); int quant; fscanf(file, "%d", &amp;quant); look into the documention of fscanf if you do not understand what is written here, then ask any question if you need.
Edit your post and put four space (plus indentation) in front of all your code, then it will look like this: struct inventory { int item_num; char item_name[25]; float item_cost; int item_inventory; }; //This one takes in the inventory information void function1( ) { scanf("%24s",&amp;stock[count].item_name); scanf("%f",&amp;stock[count].item_cost); scanf("%d",&amp;stock[count].item_inventory... FILE *stockfile= fopen("C:\Users\Varo\Desktop\stock.t... } void function2() { char tempname[25]; struct inventory stock[20]; int tempquan; FILE *stockfile= fopen("C:\Users\Varo\Desktop\stock.t... scanf ("%d", &amp;tempquan); stock[count].item_inventory = stock[count].item_inventory - tempquan; Also, posting actual code rather than chewed up snippets would help...
First, this is a subreddit dedicated to the C programming language (not C++). Second, you'll probably find more help over at /r/learnprogramming. Good luck!
it ate the line where I read the file in the second function but here: function 1 stockfile= fopen("C:\\Users\\Varo\\Desktop\\stock.txt","w"); function 2 stockfile= fopen("C:\\Users\\Varo\\Desktop\\stock.txt","r"); 
Again, this doesn't do anything but give you a file handle. Perhaps you're familiar with matlab, whose save and load commands writes and reads the variables for you?
You need to get your technic straight. You don't "call" a file, you open it, using a function. You don't "display" a value in a file, you write a value inside. A global variable is something completely different from a global function. As I said, a global function is not really a thing anyway. First, you open a file using fopen(). This gives you a handle of type **FILE**\*, in my example named *file*. This handle is way to access the file as if it was a buffer, like stdout, stderr are buffers. You can read, write and close a buffer. Just opening it and using scanf will do NOTHING to a buffer. scanf is used to read from the standard in buffer, **stdin**. You could use fscanf(stdin, ...) in place to achieve the exact same thing. You need to use fscanf on the file handle to manipulate it. I think that your mistake has been to think that once you open your file using fopen, the file handle replace stdin as the default target of scanf. It doesn't!
tl;dr: guy implements webserver by using special format-strings and calling shellcode, which is a method that highly depends on your system.
Oh dear I believe I get what you mean, I think I'll research file handling a little bit more and then try my code again. I'm self-tutoring so a lot of the technicalities aren't known to me Edit : Will the use of fscanf with the same variable name read the value of that variable that was stored by a separate function and take no input from the user?
i use it to write/port programs to rare/old platforms. There's even a c (cross) compiler for the c64! ;) It's also the reason i'm reluctant to use the newer standards though so that's a bit bad. These programs aren't that big, i'm currently porting the plan9 astro program to standard c, this is about 5000 lines. It's also a part of my job although not formally. I've written a couple of hacks for use at an isp. Last one was a way to trigger mail delivery for batched smtp. I didn't expect that (and even uucp which we also still support!) to last this long though.
&gt;Currently it's only a very small part of my job. At the moment I code Haskell for a living. I'm the opposite. Most of my work is in C at the moment, but every book I've read recently, and every side project I've done in the last several months, is in Haskell. It's such a wonderful language. Hopefully I plan on turning that into a career. No opportunities have popped up (yet!), but they will eventually, and I plan to be prepared.
They can be necessary when passing pointers to variadic functions. If a variadic function expects a pointer of type `foo *`, for example, and you want to pass it a null pointer, you need to cast the null pointer to `foo *`, because the compiler can't deduce the type automatically.
About 80% of my work is in C (the rest is mostly C++ and Perl) at a company that makes storage array management, data protection, and disaster recovery software. I personally work on userspace applications on physical or virtual Linux/UNIX servers. These servers typically run databases or other applications that store their data on SAN disks. It is the responsibility of my client applications to make sure the databases and filesystems are flushed and "quiesced" when the storage backend takes periodic snapshots of the disks. When explaining it to laypersons, I liken it to saying "cheese" and making sure everyone's standing still before taking a picture of a large group of people. The codebase is between 5 and 10 years old with probably several thousand lines of code (I haven't really counted) and has been worked on by a handful of engineers before I came along. It's a bit bloated because of various hacks and RPC changes over time, but that's the way it goes with large-scale enterprise applications: backward compatibility is paramount, and it doesn't matter how ungainly the code is as long as it works. 
My daily work is in C. We use it for everything from baseband signal processing (layer 1) to network layer processing (IP, layer 3); it's in base stations for your 2G/3G cellular systems. For 4G, we are moving towards C++ slowly.
I make embedded software for satellites, so mainly ASM and C (99% of the code, the closest from 100% the better). Applications on top of various RTOS, on old processors with various architectures and a lot of custom hardware surrounding them. Most of the time it's between 150000 and 300000 line of code (but it can vary quite a lot) But due to space software constraints, actual coding might be 20% of the job, the rest is splitted between review, meetings, tests preparation, and documentation (a looooooooooot)
I've been using C mainly to add or create low-level libraries to integrate with Lua, for personal projects. C is great for dealing with low-level access and can create fast and efficient libraries that can go anywhere. However, in my experience C can become cumbersome or even a liability when dealing with higher level issues. I tend to over think the solution that I can solve in a fraction of the time with Lua. As I said, it's for personal projects and they're all fairly small. Some are of a nice size, but lets face it, they're small projects. There's a few older code bases I've been working on adding Lua support to make extending easier and adding plugin support. However, they're mostly inactive projects that I've been tinkering with in my spare time. I work in userspace and the applications I write don't really need the features of a 64-bit processor so it really don't matter. If I need to account byte size in my program I will try to make it 32 and 64 bit agnostic. However, I have found a few bugs (bad macro define order for one) because of compiling for both architectures. I once needed to fix a kernel driver that wouldn't work with a pole display for a POS system but that was only a few line fix.
64-bit high speed recording systems, with about 150k total lines of associated code - about half of which is devoted to specific projects making use of the recording system with custom processing code. Some C++ for visualization. Everything from a custom kernel driver, to low level register banging, to a client/server for data distribution, to file utilities, to pulse-doppler processing with CUDA. Build system is based on Autotools - love it. Edit: Aside from brainstorming with other developers, about 95% of this is my own work since 2010.
I use it for personal projects and work alike. Personal projects are quite small and non-practical. Work projects are quite large (150k+ LOC) and are close to 25 years old. I use Java a little less regularly and python less so. I'm studying with Haskell hoping to find nifty uses for it.
i like these kind of scripting languages which allow an easy c backend. I've done this for scheme (gambit) to write images which worked very well.
I'm using C mainly with AVRs, hobbywise. I also program userspace programs for Linux. But at least for the computer stuff I am going to switch to C++ for the sake of OOP and not having to juggle with pointers. Oh and the codebase is rather small, about 5700 lines for my current avr project.
https://gitorious.org/ke2k-toolkit Please don't expect too much. It's a proof of concept, and I haven't done anything with it beyond the demo app. Some parts of it are a bit ... unusual, for example I should really use virtual function tables instead of that thing I did :)
Probably the most used place casts are used: The return value from malloc(). If you want to use the memory in any useful way, you have to cast it.
I design and develop 64 bit encrypted file systems for Linux and Windows. There are also user mode components for user interaction, monitoring and redundancy. All the code is in C. Code base is about 5 years old, hard to say how big the code base is. Each platform is ~50k lines of code. Also use C as a hobby, Arduino, Rasp Pi. Any kernel work I do in my free time. Change is inevitable, but I'll keep writing C for as long as somebody will pay me to.
Could you tell more stories of what you code? It sounds really interesting!
Yeah this really surprised me.
I do iOS programming both at my day job, and for apps that I work on after work. So C certainly isn't my primary language, but I drop down to C anytime I need the speed, or am simply working with C APIs.
Pretty solid list of reasons.
You wouldn't consider replacing macros with templated functions where appropriate?
I said, we don't use templated *classes*. We do use templated *functions*. Templated functions are probably the only sane use of templates in our codebase. (We use some bits from STL though. Mostly std::vector, std::map and std::algorithm)
Ah yep, early morning reading comprehension fail. That all sounds very sensible.
I actually just killed an hour reading and link hopping from DMR's page this week. Then I find this thread. I'm in your head. 
I use it everyday for my job doing firmware at Fitbit. Code base has grown but small MCUs mean small code space. Although I think our biggest constraints are power consumption. I definitely end up caring about 10s of uA. I love working right down on the hardware and making our hardware really do more than originally planned. 
High performance/volume graph analytics algorithms. Job, obviously. About 26kloc of C, and 11kloc of ruby (ffi layer plus lots of tests). All written in the last year, about 70% of it mine.
Your explanation of the what the function does and inputs/outputs should really just be in the header. That's where you'd look if you were reusing the code and including it in a new project. The documentation in the .c files should be an explanation of how the code works and maybe why particular design decisions were made.
&gt; uucp Reeeeeeaaally? People still use that? What the hell for? 
Perhaps that's where _you_ would look, but although I'm probably tainted by the fact that all the other languages I program in don't have header files, it's not the first place _I_ would look, and since the projects I work on are completely open source and I'm providing precompiled documentation, I don't think it makes a huge difference if I don't put them in the headers. I think I'm pretty much settled on documenting thing in the C source files. If I ever work on something proprietary in C where only the header files are going to be distributed, I would certainly change my habits for said projects.
So, "wild guess": how's life at Imagination Technology? Worth the US-&gt;UK move to take a job with them?
A substantial number of Reddit users (~30%) are actually Canadian, but let's not tell him that.
I use it for [a terminal emulator](http://qodem.sf.net). Codebase is about 80kloc now, started in 2003, userspace app supports both 32-bit and 64-bit, and compiles natively for Linux, BSD, OSX, and cross-compiles to Win32. It's not for work, though I have used it extensively at work. I used C because I wanted a native application and needed access to fork(), termios, and ncurses. I re-used the skills I learned for qodem on an oceanographic buoy system where Perl drove a lot of small C programs to speak RS-232 to science instruments. Now I use D for all new project work. 
Of what I'm currently doing at work? I'm working on a finite element software that calculates the flow of temperature in 2D regions. The temperature in a region is described by a set of partial differential equations that can be approximated using the finite element method. The whole calculation involves several steps, some of them are mandatory, some are purely for efficiency. In general, you're given a system with a boundary polygon (or a set of these) and a set of loads. The first step is to create a good mesh out of that polygon. This is also the hardest part (in my opinion of course) and it is what I'm currently working on. Right now I'm busy optimizing the mesh such that it provides a good basis for the numeric calculations that are then done on it. The output of that mesh generator is then a mixed mesh which can contain triangles as well as quadrilateral elements. For the purpose of calculation, we're really interested in which knots are connected to which other knots. The actual solving is then done on a (kinda sorta) adjacency matrix. The problem here is, that this matrix can be really really big. Consider a mesh with 10^5 knots. We'd end up with a matrix a magnitude of 10^10 elements. Using floats, this amounts to roughly 37GB of data (it's actually more than that, because we need to consider both spatial dimensions in the matrix, hence blowing it up by a factor of 2). Since this happens to be a sparse matrix, you can store it as a band matrix (i.e. instead of storing a n x n square matrix, you store a n x b matrix, where b is the bandwidth, from which you can fully reconstruct the original one), given that you can number the knots in a way, such that the bandwidth is small. When done correctly, this saves a tremendous amount of space and also allows you to adapt the solver such that it is *much* faster. The problem with this is, that bandwidth optimization is NP-hard and it's been proven that there is no approximation algorithm. However, there are a few heuristics (Cuthill-McKee for instance) that work rather well in most cases. After that, the actual system of linear equations is set up from the problem definition and the mesh. This system is then solved by a linear equations solver -- the one that I've mentioned in the other post. There's also a whole lot of other stuff going on around this "core" of the program. The input is text-based, hence there is a need for a parser. That's still a whole lot less work to write than a graphical interface for input though (especially since writing parsers in Haskell is like a walk in the park), and once the engineers get used to the format, they're usually more productive with it. At least, that's been our experience in the company. Results have to be presented in a way that makes sense. Since the resulting data sets can become quite big, they require smarter data structures to be stored in than just arrays and lists. For instance, to display isolines over the region to indicate the temperature, interval trees are used for fast lookups. My personal projects are much much simpler and there's really not much more to be said about them than what I already wrote. The spring simulation was just something I came up with on a sunday afternoon. It's basically a solver employing an Euler Method in order to simulate a system of interconnected springs. The front-end was written with Xlib and cairo and was really minimal. You could drag the endpoints of springs around and then watch them snap back into place and stuff. I think the whole front-end code was less than 250 lines of C code. The CMS was a little more serious. I got myself a Linode server to host my own emails because I decided that Google already had enough of my data. So I thought about running a small blog and had a look at the performance of popular blog systems and decided that it was abysmal and that I could improve on that; Mainly because I didn't need 90% of the features that they offered. So I started coding something up in C. It utilizes FastCGI to interface with the web server and SQLite as a DBMS. There's a caching scheme inbetween the database and the (very minimal) template engine, that provides roughly a 10x speed-up over the SQLite queries, once the posts have been fetched for the first time. For a simple template and some example posts, performance peaked at around 240k requests per second when running in standalone, i.e. without a FastCGI connection to a web server, so I was definitely a lot faster than the PHP based systems (not very surprising). However, it turned out that the web servers I tried were quite a bottleneck (down to around 1500 to 2000 requests per second). Or I just suck at setting up webservers. However, I ended up deciding that I didn't want a blog after all and now it's just lying around in some directory on my hard drive. *** TL;DR: I'm writing FEM software for temperature flow in 2D regions. In my spare time I sometimes write things that I never use.
I'm using C in embedded. It's my job. We maintain an RTOS that's targeted to automotive, and provide ports on various MCUs. There's is also some ASM involved ofcourse. I get to work with very different architectures (most of them i never even heard the names of :P (in my defense i recently graduated and have very little embedded experience ) ) and different toolsets. The RTOS itself is not very old, somewhere like ~2.5 years. 
Is any of your work with encrypted file systems open-sourced or publicly available? I've been leveraging some Linux-based encrypted file systems (eCryptFS and LUKS dm-crypt) for personal projects, but (apart from TrueCrypt) I didn't know of any for Windows.
the second if should be outside the 2nd for. the book is correct because the 2nd for is not using brackets, so only the 1st if is affected and the 2nd if is out.
Terrible formatting by the book, though.
Ah of course! I'm in the habit of formatting for loops like for (i = 1; i &lt; 2; i++) { some stuff here; } So I missed that.... I see loops formatted like for(i =1; i &lt; 2; i++) { some stuff here; } I'm not really sure if there's any consensus between the two.... or why I prefer / use the first version. Thanks though
Not sure if it's meant to trick me, I don't think so though as it doesn't say anything. The way it's formatted / indented implies (to me) that the if statement is part of the for loop... Something to check for in future I guess!
Some people put open brace on next line for functions and open brace on same line for everything else. It's a stylistic choice, not a clusterfuck. 
The indentation of the second `if` statement suggests that it is included in the body of the second `for` statement when it is not. That is what caused OP's confusion, and that is what I am saying is terrible formatting. I don't really care about brace placement, but indentation levels are crucially important for the comprehensibility of code.
Just to be nit-picky, but the "expected" output when using a limit of 10 should be: 2 3 5 7
Look at the run-down of indent styles [here](http://en.wikipedia.org/wiki/Indent_style). The second style you showed actually can help catch some syntax errors. For example, for (i = 1; i &lt; 2; i++) { stuff(); } If you added an extra semicolon at the end: for (i = 1; i &lt; 2; i++); { stuff(); } This is totally okay based on syntax. It would compile but the for-loop would not do anything. stuff() would be executed once. If you followed the second style: for (i = 1; i &lt; 2; i++) { stuff(); } And you added a semicolon: for (i = 1; i &lt; 2; i++) {; stuff(); } This would not compile and catch your error before you run it.
I must be blind. I totally missed that.
I inherited a large data recovery project at work that has a C backend containing code from about 20 years ago I'd estimate. The gui has gone from classic Mac OS to Carbon to Cocoa and now transitioning to Qt so we can go cross platform. I'm also slowly moving the backend to C++. Less code, safer memory management and C++11 are the main reasons.
Cheers I'll have a look.... So you prefer The second style? What about if the loop only has one line - do you still use braces?
How would that help wth memory usage, if it's only reinterpreting memory content?
;)
this is what tripped me TBH, I just presumed. Although TBF I didn't really think about the the one liner for loops either (as I write them out with braces!) 
Oh right, fair do's. Yeah I always use braces, though as I'm learning and don't really know wtf I'm doing I try to keep an open mind ;)
Sorry to be nit-picky, but adding a semicolon like in your second example does compile, it just doesn't change the behavior of the program (The semicolon just acts as an empty statement). It's subtle, but no compiler will give you a warning about that.
I can only imagine that you are invoking the `g++` binary on your C code...? Or use some `-std=` flag with `c++` in its argument? Really, on Debian squeeze with `gcc` version 4.4.5 and the following example code compiling fine without warnings or errors #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct vec { float x; float y; }; void func(void *p) { struct vec *t = p; printf("%.1f\n", t-&gt;x); } int main(void) { struct vec *v = malloc(sizeof *v); if (!v) return 1; v-&gt;x = 2.1; v-&gt;y = 0; func(v); return 0; } using the invocation `gcc -std=c89 -Wall -Wextra -pedantic &lt;file&gt;` or going by `-std=c99`, there must be something going on in the shadows unbeknownst to you.
Yeah. It is completely reasonable to misinterpret that code because of the bad indentation. I also misinterpreted it the first time I looked at it.
Cool, teach me to read more carefully I guess! 
My point exactly.
I asked his opinion on whether he thought the move was worth it. I guess I should have worded it "would be" worth it, because apparently that's how nationalist most redditors are.
Doubles use 64 bits of storage, ints tend to use 16 bits on embedded systems. If you have more than a couple local variables (like an array of past sensor values for a PID controller), you can run into the system's RAM limit relatively quickly. 
Yes, I'm aware, but what does this have to do with type casting?
Whoops. You are completely right. Thanks for getting that.
Nothing, I answered a question you didn't ask. I generally only used typecasting when I was programming microcontrollers and shuffling IO around. e.g int i = (int)IO_PORT Most of the ports on the chips I used were 8 bits and treated as chars by the compiler.
I work on low level drivers for an automotive transmission controller. Pretty much bare metal coding.
I'd have given that same reason as you gave....typecasting is not necessary (infact in C++ there is an implicit typecast available) but you must remember in C/C++ variables occupy different sizes which is what aterlumen said so succintly. 
How does the kernel know what buffer stdin points to? (IE how does it know where to read from if a read call to stdin is encountered?)
&gt; plan9 astro program to standard c I always been wondering if you encountered any issues because author assume that the astro is running rc shell
Personally I think C A Reference Manual is the #1 book to have. Not even a close call. That said, I have heard nothing of a 6th edition. 
There's plenty of literature on this topic, including this book: http://www.apuebook.com/apue3e.html and this wiki page: http://en.m.wikipedia.org/wiki/Standard_streams Basically the kernel provides your program a bunch of stuff, including a function to call (called read) to read some bytes from an opened file, and an already-opened file descriptor (number zero, probably), connected to stdin. So when your program calls read from descriptor zero, it's reading from there.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Standard streams**](http://en.wikipedia.org/wiki/Standard%20streams): [](#sfw) --- &gt; &gt;In [computer programming](http://en.wikipedia.org/wiki/Computer_programming), __standard streams__ are preconnected input and output channels between a computer program and its environment (typically a [text terminal](http://en.wikipedia.org/wiki/Text_terminal)) when it begins execution. The three [I/O](http://en.wikipedia.org/wiki/Input/output) connections are called __standard input__ (__stdin__), __standard output__ (__stdout__) and __standard error__ (__stderr__). &gt;==== &gt;[**Image**](http://i.imgur.com/SOrjNeI.png) [^(i)](http://commons.wikimedia.org/wiki/File:Stdstreams-notitle.svg) --- ^Interesting: [^File ^descriptor](http://en.wikipedia.org/wiki/File_descriptor) ^| [^Pipeline ^\(Unix)](http://en.wikipedia.org/wiki/Pipeline_\(Unix\)) ^| [^Redirection ^\(computing)](http://en.wikipedia.org/wiki/Redirection_\(computing\)) ^| [^Stream ^\(computing)](http://en.wikipedia.org/wiki/Stream_\(computing\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cg468s8) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cg468s8)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I don't know; can you point to an example? I must confess to having edition 3. (I learned to program on stone tablets with chisels. Very slow.)
That doesn't work. It says &gt; stringtest.c: In function ‘main’: &gt; stringtest.c:9:2: warning: format ‘%s’ expects argument of type ‘char *’, but argument 2 has type ‘int’ [-Wformat=] &gt; printf("%s", a[3]); &gt; ^ 
Yes it did fml thanks
Great. I remembered that from when I first started learning C long ago but never used the %c very often so wasn't too sure. 
You know, the way the text organized.
Luckily I'm a pirate and I haven't seen printed books for ages. I have 5th edition and it's a perfect book, except text organization.
You need a library or implementation of BigNum. C doesn't handle it natively.
Do you know anyway to start hard coding in a new data type or do I need to go to the assembly level for that.
You don't "hard code in new data types." Use the facilities that C provides: define a data type as a structure, say, and provide functions to operate on that data.
But it can be done, and there has to be a way to go about allocating more memory and managing it, I would rather learn how to create it and manage it myself rather than use some library, do you know anything about that or can you point me somewhere where I can read about that?
Learn how to use structures in&amp;nbsp;C. Any C book will discuss structures. Define a structure that stores the data for your data type, and then define a set of functions that can be used to operate on that data.
Can you explain one other thing? if you were to represent int as a structure what would you put in it? (or what happens when you tell a variable it is of type int)
The type `int` is a basic type. It is not a structure type. The basic types include `int`, `char`, `long`, `float`, `double`, and so on. A structure is a type that is built from basic types, not the other way around.
An `int` is almost certainly a type that is handled directly by the processor. The machine code, consisting of instructions for the CPU, specifies operations that are performed on values of type `int`. There is a CPU instruction to add two `int`s together, another CPU instruction to read an `int` value from memory, and so on. The type `int` in&amp;nbsp;C is meant to refer to whatever size of integer the CPU can work with most efficiently.
If you would like to store a large number you're gonna need a way to break the number up in to parts, that can be read by the cpu at one time. For example a 50 digit number would need, log2(10^(50) -1) = 167 bits. So on a a 64bit computer that's 3 long long (64bit integers). This could be implemented by a long long array of size three. You would need to read the large number in a certain order, most significant digit first or least significant digit. Then store it that same way. This would only store the number. Adding or subtracting would need their own functions that would iterate through your special data structure, 64 bits at a time. Keeping track of carry over would be needed, and gets a little complicated when it comes to division and multiplication.
Alright, thanks. Also I did this line int * ptr = (int)malloc(100*sizeof(int)) and I really have no idea what I did, I had no errors but do you have any idea what is executing? (coming from 4 years of C++ to C I'm a bit confused) *added code formating
ahh okay, I thought it would allocate (100*int(4)) bytes on the memory for me to work with not an array, thanks
It *does* allocate `100 * sizeof(int)` bytes of memory for you to work with. But you can view that block of memory as an array. An array is just a contiguous block of memory storing one or more data values of the same type sequentially—that's what an array is.
Even more vague. 
For this problem, the memory management actually isn't that complicated (Nor should it really be, memory management isn't to hard in most cases when you get used to it and get a good pattern down). The first task here is to figure out your data structures. Could you simply take two ints, put them one after another in memory, and have it work? Unlikely, since the system itself only knows how to deal with ints as single entities, not as combined values multiple ints long. Noting that, your idea has to be a bit more then just using multiple ints. Specifically, you're really going to have to figure out a new way of representing numbers in memory that doesn't have a specific size limit (Or at least is easy expandable), and then write functions for manipulating these numbers (Ex. 'add', 'subtract', 'multiply', 'divide' etc... functions). there are a few ways to do it that I know of to do it, none of which are very complex, but I will leave this to you to decide the implementation. If you're having trouble with it I'm sure I or someone else could give you an idea. You should go into it expecting a few things: You're probably at least have one struct that represents a number, and you're going to have a few functions to manipulate these structs. Thus an easy way to do it (Which involves very simple memory management): /* header file */ #include &lt;stdlib.h&gt; /* malloc, free */ #include &lt;string.h&gt; /* memset */ /* Number struct (ptr is just there for example purposes) */ struct big_num { void *ptr; /* Data members */ }; /* This function initializes a big_num, setting values to their defaults and loading any memory if necessary */ extern void big_num_init(struct big_num *); /* Say every big_num needs 5 bytes malloced into 'ptr' to start, and * also needs everything zeroed to set defaults. Init would look like this: * (Note this example code would go into a corresponding .c file with this header) */ void big_num_init(struct big_num *num) { memset(num, 0, sizeof(struct big_num)); num-&gt;ptr = malloc(5); } /* Now we also have a 'clear' function. This function clears the struct * and anything that it current owns. This could also be called Ex. 'finalize' * or something like that. Again the code would go in a .c file. * Note that the 'init' and 'clear' functions may not directly correspond * like these do as far as malloc's and free's do, but you should check * every pointer in your struct on whether or not it should be free'd * in the clear function. If you have *more* malloc's in init then free's in clear, * you almost definitely have a memory leak. Having more free's in clear * then malloc's in init is the general situation, which usually happens * because it's common to simply allocate memory into the struct as * you need it and know how much you need rather then upfront in * init like we did here. */ extern void big_num_clear(struct big_num *); void big_num_clear(struct big_num *num) { free(num-&gt;ptr); } /* This setup is similar to functions like 'strcpy' and 'strcat' * it takes a pointer to where to store the resulting big_num, * the 'result' parameter, but it also returns this pointer to allow * you to chain these functions to together if you wish without * having to return malloc allocated structs. */ struct big_num *big_num_add(const struct big_num *num1, const struct big_num *num2, struct big_num *result); struct big_num *big_num_sub(const struct big_num *num1, const struct big_num *num2, struct big_num *result); /* end of your header file */ Now, the header file there defines your entire implementation of your big_num module/library/etc.. You should take note that we *never* deal with actually allocating and freeing a 'struct big_num'. The reason here is that the caller using this struct can then allocate the big_num anyway they want (preferably on the stack), and simplify handling this memory. The only memory that we do have to manage is the memory used internally by a big_num (In this case, the memory allocated that's stored in 'ptr'). Because we don't handle allocating the big_num struct itself, it is never safe to call free() on a big_num pointer, so we don't do that. The point of the 'init' function is then to first take a big_num that's allocated somewhere and initialize it and put it into a usable state. The point of the clear function is then to clear out the struct such that it's safe to get rid of the memory holding that big_num, and we won't have any memory completely lost. If we allocated our big_num via malloc, then calling big_num_clear() on that big_num *most* make that big_num able to be freed via free() without creating a memory leak (And in this case, we do that big making sure the memory in 'ptr' is freed). In the case of a stack allocated big_num, the variable should be safe to go out of scope after big_num_clear() is called. Here is an example implementation using the header and a few differently allocated big_num's: #include &lt;stdlib.h&gt; #include "big_num.h" /* A file-scope declared big_num */ static struct big_num glob_num; int main(void) { static struct big_num num1; /* Static, stored similar to 'glob_num'. Stays for duration of program */ struct big_num num2, num3; /* Stack allocated */ struct big_num *num4 = malloc(sizeof(struct big_num)); /* dynamically allocated */ big_num_init(&amp;glob_num); big_num_init(&amp;num1); big_num_init(&amp;num2); big_num_init(&amp;num3); big_num_init(num4); /* since this is a pointer we already have the address */ /* (num1 + num2) - glob_num */ big_num_sub(big_num_add(&amp;num1, &amp;num2, &amp;num3), &amp;glob_num, &amp;num4); /* Call some printing method to display 'num4' * big_num_print(&amp;num4), or printf("%s", big_num_str(&amp;num4)); ... or something like that */ /* Clear numbers so they can go out of scope */ big_num_clear(&amp;glob_num); big_num_clear(&amp;num1); big_num_clear(&amp;num2); big_num_clear(&amp;num3); big_num_clear(num4); /* You didn't forget to free() num4 did you? (I did when writing this...) */ free(num4); return 0; /* Exit */ } That's the basic idea. You can see how letting the caller take care of allocating the struct makes things a lot simpler. If you didn't do this, then every big_num here would have to be a pointer to a big_num like 'num4' is, which creates more free() calls and mroe changes to screw up (Besides being a bit slower). How you implement the 'add', 'sub', etc. functions could be different so it's a bit less wordy, but since you really want to avoid returning a malloced big_num if you can (It's not necessarily a bad thing, but you're creating a new big_num to keep track of), giving it a big_num to store the result in is useful. You could also change the function so that it store the result in the first number sent to it (Ex. How strcat stores the result in the first string sent to it). That has the advantage of using less numbers (In this example, I wouldn't need 'num3' at all), but it also destroys your old numbers (And keep in mind, if you want to make a copy of your number, you need a big_num_cpy function, a simple memcpy will result in both of them having the same pointers, and then when you clear then you'll get double free issues.)
&gt; char operator; &gt; &gt; while (operator != 'E') &gt; { &gt; /* ... */ One error that you have is that you never initialize the value of the variable `operator`, but then you read the value of that variable in the condition of the `while` loop. Attempting to read the value of an uninitialized variable like this is a serious mistake that leads to undefined behavior, which means you have absolutely no guarantees about the behavior of any part of your program. If the user enters `'+'` before the value of `accumulator` has been initialized, then you have the same problem there too. You should initialize `accumulator` to some value.
Cheers zify - I've initialised the variables : float userNumber = 0.0; float accumulator = 0.0; char operator = 'S'; But it's still happening... Is that the correct way to initialise a `char`? I wasn't too sure about that one... 
Yes, that's how you initialize a `char` variable. Now, when the program runs, it asks you for an operator, right? So maybe you type S and press Enter. You are adding *two* characters to the input stream: the character&amp;nbsp;`'S'` and the newline character&amp;nbsp;`'\n'` (from the Enter press). So the first time you `scanf("%c", &amp;operator)` you get the character&amp;nbsp;`'S'`, and the second time you `scanf("%c", &amp;operator)` you get the character&amp;nbsp;`'\n'`. Read the following entry from the /r/learnprogramming FAQ. It's written about Java, not C, but the concepts involved are the same: * [The `readLine` method of my `java.util.Scanner` object doesn't get any input.](http://www.reddit.com/r/learnprogramming/wiki/faq_java#wiki_the_readline_method_of_my_java.util.scanner_object_doesn.27t_get_any_input.)
ah shit yeah I've heard of this, but don't think that I've encountered it before with C... Think there's something to do with scanning for int's using `scanner` then trying to pick up a string? or visa versa, or not that at all! I can't remember and probably wouldn't understand what I did recall anyway ha.... I'll read through this then and get back to you
I got it. It's like the other commenter said. So with that fflush(stdin) it works (at least for me). case 'E' : break; doesn't seem to do anything however, but the condition in the while works. try this while (operator != 'E') { // puts("Please enter a number : \n"); // scanf("%f", &amp;userNumber); fflush(stdin); printf("Please enter an operator (S or E) : \n"); //Prints this line twice? scanf("%c", &amp;operator); printf(" Test 1\n"); switch (operator) { case 'S': accumulator = userNumber; printf("\n=%.6f TEST \n", accumulator); break; /*case 'E': break;*/ case '+': accumulator = accumulator + userNumber; printf("%.6f", accumulator); break; } }
Type a character, such as&amp;nbsp;S, for the first question and then press Enter.
http://i.imgur.com/SIXFbpv.png Well it works fine for me.
doesn't seem to be working for me [here's a screen shot of the output](http://i.imgur.com/xXGp7ju.png)
&gt; fflush(stdin) The behavior of `fflush` when applied to a stream opened only for reading (such as `stdin`) is not specified by the C&amp;nbsp;standard. This might work for your compiler, with your libraries, on your system, but there is no guarantee it does the same thing anywhere else.
What you need to do is skip over whitespace characters. If the character you read into `operator` is a whitespace character, such as `' '` or `'\n'`, then you need to read another character with `scanf` *without* printing the prompt again.
I've tried stuff like ` scanf("%c "); ` adding a couple of spaces after the %c bit - but it just sends me to a new line, but it's just sitting there [here's a screen shot of the out put from that](http://i.imgur.com/oXSnHkI.png)
How are you compiling it? Also, does this behavior go away if you replace puts with printf? Edit: Nevermind. /u/zifyoip is right. If you put a default or a case '\n' in your switch statement, you'll see it's trying to do something with the newline character. The idea is that during your first scanf, you put two characters into stdin, so on the second time around, after entering 'S', scanf doesn't have to wait for the user since there is something in the stream already.
Add the space *before* the `%c` specifier so that `scanf` will skip over leading whitespace characters before it reads a character for the&amp;nbsp;`%c`.
Sure, of course. That `getchar()` call eats the `'\n'` character from the stream.
I should point out, the scanf line you _should_ be using, based on the problem description is: scanf("%f\n%c", &amp;userNumber, &amp;operator);
You're argument is basically, "I'm used to the Java way of documentation so I'm going to do that in C." C separates implementation(.c) from interface(.h), which is not the way Java works so documenting them the same way isn't appropriate. If you do this and give your code to a person or group of people who primarily work in C code it will likely frustrate them.
by eats do you mean t solves the problem or behaves in the same way? 
I mean that the `getchar()` call reads the `'\n'`&amp;nbsp;character and removes it from the stream, so that the next time you call `scanf("%c", &amp;operator)` the `'\n'`&amp;nbsp;character is not there.
Cheers sanjayer - why is that? So rather than having separate questions I should phrase it Please enter a number, followed by an operator Wouldn't that method be impractical for entering in lots of values, something such as name / age / birthday etc. 
&gt; * If there's a `scanf` function used, it will read everything that's entered into the standard input up until there is white space (**just one white space, or more than one white space?**) The various specifiers to `scanf` behave differently. You need to read about how the specifiers to `scanf` work. All of the specifiers except `%c` and `[]` cause `scanf` to skip any leading whitespace. But `%c` and `[]` do *not* skip leading whitespace. &gt; **I don't really understand why the cursor automatically moves on, if the `\n` is acting as the input, why doesn't the console wait for an additional enter key for the program to move on?** The program does not read from the keyboard. The program reads from the input stream, which is just a stream of characters, one after another. You add characters to the standard input stream by typing at the keyboard—but no characters are added until you press Enter, and then all of the characters you have typed, including the `'\n'` character, are added to the input stream at that time. When the program wants to read characters from the input stream, and none are available, it waits until characters become available in the input stream. If you type a bunch of characters and then press Enter, suddenly there are many characters available in the input stream for your program to read. &gt; * to avoid this problem, when using `scanf` insure a white space is entered before the format specifier. No, this is not necessary for most format specifiers. The `%c` specifier is different from most specifiers in that it does not skip leading whitespace. You need to read about the `scanf` specifiers in more detail.
&gt; You need to read about the scanf specifiers in more detail It seems so! I'll have a look :) I get the part about the input stream (i think...) and that because it's on the screen doesn't mean that it's in there, it has to actually be entered onto / into the stream. And that by the program assigning the numerics to the one `scanf` function the `\n` is left over. I don't under stand why the computer doesn't just skip on ahead as soon as it gets this input (from the stream...) *Or, thinking about it* maybe that's exactly what it was doing in examples [such as this screenshot](http://i.imgur.com/6YSZB0W.png). The program is taking the `\n` input, which doesn't match any of the `switch` cases, and then hitting the question again in the while loop?? If I had put a case that was : case '\n': puts("Check your scanf things"); break; It would have output that to the console? 
Why don't you try it and see?
My comment was based the project description in the comment in the source code. &gt;The program should allow the user to type in expressions of the form: number operator For some other project, you would use different format strings. They key is if you are using "%c", and you do not want the newline, you must included "\n" in the format string. 
ah right I get you, cheers dude
yeah that's what it does :) bit of thinking aloud there sorry... any suggestions on the best resources for `scanf specifiers`? cheers for the help though
You can always do it as two `scanf` statements if you think that's clearer. This: scanf("%f", &amp;userNumber); scanf(" %c", &amp;operator); works exactly the same way as this: scanf("%f %c", &amp;userNumber, &amp;operator); And `'\n'` in a `scanf` specification is equivalent to `' '`.
&gt; any suggestions on the best resources for `scanf specifiers`? I like C in a Nutshell as a reference: http://shop.oreilly.com/product/9780596006976.do
&gt; And '\n' in a scanf specification is equivalent to ' '. Nice... makes sense. Cheers zifyoip!
printf("%c", &amp;encrypt[i] + key); &amp;encrypt[i] - this is address; key is address, why are you adding two addresses? And print it as char? Edit: change int key[50]; to int key; then try using printf("%c", encrypt[i] + key);
And don't forget to change *scanf("%d", key);* to *scanf("%d", &amp;key);* 
Okay ill try when I get home 
What type of project are you interested in working on?
C Programming - Absolute Beginner's Guide by Greg Perry and Dean Miller.
I don't even...
WTF? You asked, I answered. And you downvoted me?
C is worth learning in my opinion. I'm a CS student so certainly not an authority on languages, but everything that's really cool I want to work on, and the problems that really interest me, tend to be in C. If you ever wanted to study operating systems then C is vital. You can go [download the entire linux kernel](https://www.kernel.org/) and read it's internals, study how it works and try to wrap your head around why certain things were done in certain ways. If you want to study algorithms and data structures, c is wonderful. Have you ever wondered how queues are actually structured in memory while you were using Java? Or lists, or strings, or objects in general? Memory management, how the stack works when a function gets called, how the memory alignment of certain structures can decrease cache misses... There's so many cool topics that you can really dig into with C that you don't have the freedom to really mess with in higher level languages. The downside being you have plenty of rope to hang yourself with, but man the problems you run into can be so much fun. Embedded systems are cool. Being able to take an Atmel or TI microcontroller and cobble together beautiful useful systems. This is what really invigorated me with regards to C when I was starting out. Snag yourself a cheap ATtiny AVR, a couple data sheets, a programmer and some [tutorials](http://www.ladyada.net/learn/avr/) and **dive in**. As far as an IDE, I really wouldn't recommend one. Just use a text editor of some sort. For instance I do a lot of my coding right now in Sublime Text. All I really use it for is the highlighting. Everything else is done in the terminal. gcc is free and works fairly well, and in regards to referencing I generally just use the man pages or google when I want to get a quick idea on how to use something. From what I've seen, and what I've heard from friends who are already working, if you can write good clean C it will help you in any other language you pick up. The language doesn't hold your hand. K&amp;R is one of those books you certainly want to have, but it isn't really what I'd start out with at first. I'm a little embarrased to admit it but I started with ["Absolute Beginners Guide to C" by Perry](http://www.amazon.com/Absolute-Beginners-Guide-2nd-Edition/dp/0672305100/ref=sr_1_1?ie=UTF8&amp;qid=1395118541&amp;sr=8-1&amp;keywords=absolute+beginners+guide+to+c). I didn't have any type of programming background though so you might be more inclined to something like ["Programming in C" by Kochan](http://www.amazon.com/Programming-3rd-Edition-Stephen-Kochan/dp/0672326663/ref=sr_1_1?ie=UTF8&amp;qid=1395118586&amp;sr=8-1&amp;keywords=programming+in+C).
Hello, Crussian.. Read carefully what I'm going to tell you: *Whatever* happens in your life, stick with it. Whatever path you choose in life, keep coding. I'm telling you this because I wrote my first BASIC program when I was 9. I first got introduced to C when I was 14. I touched BASIC in its different flavors (Q, GW, Visual Basic for DOS and Windows). I touched C. I touched Pascal. I touched Assembly language. I touched Python.. I'm 27 now, but I'm not proficient in any of these languages: My starting point should've led me to being a great programmer *if* I kept it. This is the sort of things you look back at, at 27 and say: Damn, if only I kept programming _consistently_. So, right now.. You have time to become great at a relatively young age *if* and only *if* you stick to it *whatever* happens in your life. If you have a book with 50 exercises, make an oath you'll complete them all. Even at 3 per day. That's only 17 days and a completed book. If you don't, you'll waste more on trivial things and say "I wish I used that time to complete that book". You have a finite amount of time. You never stop learning, but you have to start and _keep_ learning. That being said... Get "Learn C The Hard Way" by Zed Shaw. You just google it and you'll find a link for his online book (html format). Stay away from IDE's (that's an advice you find in a book, but coming from where I came, I found it to make sense - I used to disassemble binaries in high-school and tinker with them, but again, didn't keep at it-) His book is like 52 exercises. You can almost breeze through it in less than a week. It's a great book to read in order to read other great books (you'll find it easier that way). It makes you type code, consistently (that's what you need for now, to get over the fear of the beginner, the "where the hell do I even start"). You're blessed to start now. When I was a kid, I didn't have Internet and didn't speak English. I had to make sense of code by trial and error. Whatever you do, keep at it. You'll be 25 in the blink of an eye.. You can choose to have, at that point, 10 years of experience .. Or skip and then start all over again. And it's worse: Because you understand the concepts, and so, but you don't have any respectable code. Good luck, Crussian.
As most suggested, K&amp;R C and I'd suggest as a second book: Expert C Programming: Deep C Secrets. It's a great companion book that will help to tighten up your code and helps to avoid pitfalls. 
&gt; What books would you recommend reading and what should I use as far as an IDE? Books, no idea. IDE: I would recommend either "no IDE" (use Emacs + make), or use dosbox and run Turbo C++ in that ([Turbo C++ is a free download now](http://www.cprogrammingexpert.com/C/Tutorial/turbo_cpp_ide.aspx)). Turbo is _fast_ as hell, and for the basics of learning (data structures, branches, loops, file I/O) it works very well. Much easier for new learners than using gcc, make, and gdb. &gt; Is C even worth learning? Yes, absolutely. 
http://c.learncodethehardway.org/ 
Try EDX's CS50 thats what I'm doing, will link when I get home. 
Find a copy of [C Primer Plus](http://books.google.com/books/about/C_Primer_Plus.html?id=MsizNs-zVMAC) and work through the programming exercises at the end of each chapter. The problems build on top of each other, so you start simply and by the time you reach the last problem you've created something much more complex.
"`OR`" is not an operator in&amp;nbsp;C. The operator you want is `||`. Also, you must put parentheses around the entire condition of an `if` statement in&amp;nbsp;C.
You need braces if the body of the if/else statement is more than 1 line long. Also, the condition of the if statement needs to be in parentheses: if (Side_1 &lt;= 0) OR (Side_2 &lt;= 0) OR (Side_3 &lt;= 0) should be: if ((Side_1 &lt;= 0) || (Side_2 &lt;= 0) || (Side_3 &lt;= 0))
&gt; You need braces if the body of the if/else statement is more than 1 line long. You need braces if the body contains *more than one statement*. But all of OP's `if`/`else` statements have just one statement in the body. So technically the code is fine. However, I agree that braces would greatly improve the readability of this code.
WOW, thanks :D Ill fix it all now, I did copy and paste my algorithm, so didn't swap OR for the symbol 
1. `||` is the boolean OR operator in C, replace all `OR` with `||`. 2. Surround all your if expressions with (), like so: `if ((Side_1 &lt;= 0) || (Side_2 &lt;= 0) || (Side_3 &lt;= 0))` 3. Stop using the ancient Borland C++ compiler and install [MinGW](http://www.mingw.org/) (Windows port of GNU GCC), optionally by installing [Code::Blocks](http://www.codeblocks.org/). You don't need paretheses around every expression, this works fine: if (Side_1 &lt;= 0 || Side_2 &lt;= 0 || Side_3 &lt;= 0) EDIT: You could also save some horisontal space by compacting your "else..if" statements to "else if", which really is the same thing: if ((Side_1 &lt;= 0) || (Side_2 &lt;= 0) || (Side_3 &lt;= 0)) printf("You can not have a negative value for any of the sides. Your triangle is invalid."); else if ((Side_1 == Side_2) &amp;&amp; (Side_1 == Side_3) &amp;&amp; (Side_2 == Side_3)) printf("You have entered valid dimensions for an equilateral triangle."); else if ((Side_1 == Side_2) &amp;&amp; (Side_1 != Side_3) &amp;&amp; (Side_2 != Side_3)) printf("You have entered valid dimensions for an isoceles triangle."); else if ((Side_2 == Side_3) &amp;&amp; (Side_1 != Side_3) &amp;&amp; (Side_2 != Side_1)) printf("You have entered valid dimensions for an isoceles triangle."); else if ((Side_1 == Side_3) &amp;&amp; (Side_1 != Side_2) &amp;&amp; (Side_2 != Side_3)) printf("You have entered valid dimensions for an isoceles triangle."); else if ((Side_1 != Side_2) &amp;&amp; (Side_1 != Side_3) &amp;&amp; (Side_2 != Side_3) &amp;&amp; (Side_1 + Side_2 &gt; Side_3) || (Side_1 + Side_3 &gt; Side_2) || (Side_2 + Side_3 &gt; Side_1)) printf("You have entered valid dimensions for a scalene triangle."); 
Are braces brackets? ( ) or curly brackets {} Thanks
COMPILED! Thankyou so much :D
It doesn't matter if you hop languages every month as long as you are continually learning *how* things work behind the scenes. Greater proficiency in a language allows you to do things faster and more efficiently, but if you understand what you're truly trying to accomplish, the language doesn't matter as long as you have the ability to look up syntax. It is a good idea to continually learn to languages if just to see how people proficient in those languages approach problems. This doesn't mean you shouldn't be proficient in at least 1 language, as that definitely helps in finding a job and keeping it, but it is in your best interest to always expand your capabilities.
You should checkout https://gmplib.org/ for a dynamic library to include that will do and precision of float or int for you. It can be tricky to compile etc, but I've used it on a school project (physics) and it worked really well. EDIT: or check out the code to see how they did it if you are trying to learn how to do it yourself :)
 If ( cond1 || cond2 ) { /* things to do if more than 1 */ }
Also scanf("%d%*c", &amp;Side_1); should be scanf( "%i", &amp;Side_1 ); For all of them.
so they are chars, but its an int? Or is it a char array? How come if I create two int's and add them together it doesn't do ASCII maths if they're not ints? :? 
A pretty good book is. The C Language by Dennis Ritchie. Pretty old but still relevant.
I think you're confusing "code" with "data." When you type: int i = 0; in your editor, that's code. That zero is generally stored as a byte representing the ascii character for zero in the text file. However, it is converted to machine instructions and an actual zero after you compile and generate an executable binary. You input data to your program. When you run your program and read a bunch of numbers like '1234' from the terminal, that's data. The computer stores those as individual bytes and passes them to your program a stream of bytes (or characters, if you will). You can use standard I/O functions to read them into a char array or an integer if you wish. To accomplish what you're trying to do, the simplest way would be to read them as a stream of characters (aka a string) and print out the word equivalent one by one.
So... Which one of them is the "correct" indentation? `else if` is certainly very much used out there and I'd say it's correct. It is also demonstrated in [The C Programming Language](http://en.wikipedia.org/wiki/The_c_programming_language) (page 22 in the second edition).
That's not correct indentation. Else if is supposed to be on the same line. If statements only apply to the next line, unless you start a new code block by enclosing it in "{" and "}"s. Each of your else's are an else on your first if, so they should only be indented one line. I don't know if what I wrote made sense but I don't have time to write a better answer right now. But trust me, your indentation is wrong and implies the wrong thing about your code. /u/xevz's indention is correct.
cheers thunder, I guess my logic was out then :( I haven't used the `&lt;string.h&gt;` library yet though. * line 12 - You're taking the input as a string, not an integer. I'm still confused about this, so thats a string, not an integer. My example was using an integer, so the scanf function would have been : scanf("%i", number); I also haven't seen *words[] before, the `*` *looks* like it might be a wild card, though I don't really know what a wild card would be doing here. Your program works though. 
You could use `iso646.h`, though, which provides the [alternative token](https://en.wikipedia.org/wiki/C_alternative_tokens) macros `and`, `and_eq`, `bitand`, `bitor`, `compl`, `not`, `not_eq`, `or`, `or_eq`, `xor` and `xor_eq`. Not that I would advise such a thing. 
&gt; I haven't used the `&lt;string.h&gt;` library yet though. It's only for the `strlen()` function which you really don't need. You can replace strlen(number) with: number[i] != 0 which says run the for loop until you reach the string termination character. Note: I didn't do any boundary or error checking in this code to keep it simple and to the point. In real life, you want both of those. &gt; scanf("%i", number); I'm just reading it into a string (%s) instead of into an integer. That's basically all there is to it. &gt; *words[] That's not a wildcard. It's the declaration for an array of `char` pointers. In our case, a `char` pointer is a string. So words is an array of strings. Those strings are "one", "two", etc. If you don't want to use that, you can eliminate words array and write it out with simpler but longer switch() syntax like: switch(number[i]) { case 0: printf("zero "); break; case 1: printf("one "); break; .... and so on }
yeah, I'm starting to think this book is shit tbh, I've never done any of these thing's that it's apparently given me an exercise in.... but : Looking at the code, yes that's a nice way of solving that problem. Making an array whose elements correspond to the digits, kind of obvious I guess! 21 char number[10]; this has created an array of characters that has a maximum of 10 elements.... &gt; I'm just reading it into a string (%s) instead of into an integer. That's basically all there is to it OK cool - this is still confusing me [as the question asked for it to be an integer](http://i.imgur.com/AdvvWCs.png), so if you've used a string then I guess you've gone about it a different way, and it's not really the solution to that problem. Or am I getting confused between data / code here as well? 
Can you use Linux by any chance? It makes things a little easier.] As far as the actual language is concerned, Look up K&amp;R C.
I think what you're confused about is the word "integer" in the question. IMO, the author did not mean integer as a C type, he meant integer as a number with no fractional component. If you want to literally interpret that as "read an int type and print out each digit," then you can do one of the following: 1. Convert it to a string (see sprintf/snprintf function) and follow the logic we outlined above. 2. Write a reverse_int() function that does something like this: while (old_int != 0) { new_int = new_int * 10 + (old_int % 10); old_int /= 10; } This will reverse the int. You can then print it using division and mod operators like: while (num != 0) { printf("%d ", num % 10); num \= 10; } Please note that I didn't test any of the code above.
As someone who took some intro COEN courses because I was interested in learning programming, the best thing I did was make a 20GB partition for Ubuntu.
Much easier. C is a language that emerged from Unix. A lot of things are much easier to understand if you use a unixoid operating system. For instance, all the header files are present at a central place and the whole API to the operating system is just natural. Finally, you have tools like strace (Linux) or dtrace (Solaris) to debug your programs. Much easier than Windows.
Yeah your initial thought were on the right track **IF** integer literally means "C type int" in the question. Based on how I read this question, I'd do the way I recommended first. Then the sprintf() method. Finally the reverse_int method. BTW, the above logic doesn't handle the leading and trailing zeroes well.
Yeah, who knows what they meant, they don't give an answer so pfffffffffffffffffffffffffffffffffff &gt; BTW, the above logic doesn't handle the leading and trailing zeroes well. what leading zeros? say user enters `3665` - where would the leading zeros be? 
Ay, why are they there? Why would they be there when they weren't entered I mean... Google results are giving me a lot of stuff about padding with leading zeros. What would this come under? 
Find a good tutorial and just use a text editor and separate compiler to do the tutorials. 
I loved the bit about having just enough rope to hang yourself. While learning C, my first project was a binary search tree implementation. I finished it, it compiled with no errors but It kept crashing and I couldn't figure out why. After an egregious amount of debugging, I switched back to c# and wrote a quick example. While writing a utility method, the VS IDE yelled at me for doing something that the c compiler did not ( I think I assigned a variable to itself on accident because my naming conventions suck.) Immediately the gears started turning and I flipped back to my c implementation and after about 38 secs of searching, I found id essentially done the same thing but the c compiler had allowed me to do it. I fixed it and it worked like a charm. I wish that in school id been forced to learn c before c# or at least had been forbidden from using a fancy ide over a text editor. Intelligence is my bane now :(
Perhaps OP deluded himself into believing that real developers would flock to work with someone with no ideas and few skills?
27 is not that old. Start coding, approach it like a game, try different ways to solve the same problem. I started coding when I was 35, and I am 54 now. Read, read, read and code, code, code!
Really nice resource, thanks man.
Made me wonder... I had no idea how inconsistent the naming of such things is! http://en.m.wikipedia.org/wiki/Bracket
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Bracket**](http://en.wikipedia.org/wiki/Bracket): [](#sfw) --- &gt; &gt;__Brackets__ are tall [punctuation](http://en.wikipedia.org/wiki/Punctuation) marks used in matched pairs within text, to set apart or interject other text. Used unqualified, brackets refer to different types of brackets in different parts of the world and in different contexts. &gt;==== &gt;[**Image**](http://i.imgur.com/eexZnfP.png) [^(i)](http://commons.wikimedia.org/wiki/File:MediaWiki_logo_without_tagline.png) --- ^Interesting: [^Bracket ^\(architecture)](http://en.wikipedia.org/wiki/Bracket_\(architecture\)) ^| [^Bracket ^\(band)](http://en.wikipedia.org/wiki/Bracket_\(band\)) ^| [^Bracket ^fungus](http://en.wikipedia.org/wiki/Bracket_fungus) ^| [^Bracket ^\(tournament)](http://en.wikipedia.org/wiki/Bracket_\(tournament\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cg69ni4) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cg69ni4)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Here is what you can do. Use the atoi function build in Use the number , since it is a integer you mod 10 to get the last digit. get the original number minis the number you got from the mod and divid by 10 every time until you hit zero. And you concat the output string from the beginning.
thanks kohuan - i'll have a look at this when i'm back home later. 
TIL that people prefix their header file identifiers with underscores.
Isn't this saying the opposite? That underscore-prefixed names are reserved for internal preprocessor variables?
Yes, that why new language keywords have names like _Bool or _Generic. It's a typical case of cargo cult programming. We're doing it because everyone else does.
Yup! &gt; so that ... header files can define ... variables, ... for internal purposes 
Hmm thanks for pointing out some of the problems. For some reason I have 4*c and a*b in my code but it is shown as that here. I was able to complete my code with your help though :). This was the just the motivation I needed to reignite my drive to learn c/c++! Thanks!
Oh TIL. Thanks!
Personally I like the idea. It's not to crazy but it'll look fairly nice and simple overall. There may be better ways to do it as others have noted, but honestly I think it's more valuable to try and implement a solution you thought up rather then just implement the best algorithm possible. When you do create your new number, just check your math so you do actually get a number with the digits reversed. You don't need to use pow() or log10(). The only catch with your method is that a number like, say 79, will be reversed into 7, and then 9 will be added to 7 and you'll get 16 (Basically, your code currently just adds the digits together). You need to 'shift' the 9 over so it end-up in the next place before you add the next number. You already know how to do this, it just might not be immediately obvious. But, you basically need to figure out how to take 9, and then the value 7, and get 97. As for your switch(), there is an easier way to do it. Keep in mind, on your switch you're currently matching against char values. But, the value of 0 in your int 'number' won't match against the char '0'. One is the value 0, the other is the ASCII value for 0 (Which is something like... 40 something I think.). The distinction might not make tons of sense, but you should keep in mind that char's can hold any character you want, not just numeral characters. Ex. This make just as much sense as what you wrote: switch(number) { case 'a': ... case 'b': ... } Obvious, while C will let you match that number against the char 'a', from most prospective it makes no sense, and is definitely not what you want. For all intents and purposes for you, the actual values integer values that char's are converted to are basically random numbers. So, the char '0' actually corresponds to some random integer value that we decided a long time ago represents a zero in data. There's another random value for '1', and for 'a', and for '!', and etc.. The solution to your problem is simple though, simply change your case's to use the literal values: switch(number) { case 0: ... case 1: ... } Notice no single quotes. This matches against the actual value 0 and value 1, not for the char '0' and char '1'. When you write out your actual switch(), you'll notice fairly quickly that every case looks exactly the same. You might figure it out just seeing it, but there is a more generic solution you can get. The basic idea is that you'll want to map the strings "zero", "one", "two", etc.. onto the values 0, 1, 2, etc.. So that the values correspond to the correct strings. And mapping things onto values that start at zero is just a fancy way of talking about an array. Specifically, trying making use of this array in your code: const char numstr[][7] = { "zero", "one, "two", "three", "four", "five", "six", "seven", "eight", "nine" }; Don't hesitate to ask any questions.
even better, like plan9 no header guarding; include files should never include headerfiles. 
Yeah, you can standards lawyer this one all you want but nobody's listening. There are a bunch of other violations too, like types ending with _t, but nobody cares because it's pedantry.
So header files aren't allowed to depend on other header files, or you need to know all the dependencies when you add or remove an include?
&gt; you basically need to figure out how to take 9, and then the value 7, and get 97 yeah the code up there's probably not very clear, but I'm pretty sure that this works that out alright : reverse number order : int temp, number; do { temp = number % 10; printf("%i", temp); number = number / 10; } while (number != 0); &gt;One is the value 0, the other is the ASCII value for 0 (Which is something like... 40 something I think.). The distinction might not make tons of sense No I understand, is that because the format is `case '0':`. Should it be written `case num = 0: ` ? **AH I see, you went on to explain this ;)** I don't know how to append the numbers though, or where to put the numbers while I'm working on them.... I can reverse the numbers and print them to the console, but then they're out of my reach! I'm also struggling to think of a way to get the length of the users number, if they entered 3456 that'd be 3 (or 4 not counting from zero). There are actually a few thing's that I haven't encountered here : * The `const char numstr[][7]` part, I haven't seen the `const` word before. What I think has happened there is that you have made an array of 7 values, though I don't really understand how that can hold 10 elements. * appending numbers. As far as I can see I still have to : reverse the number (246 becomes 642) then use the same logic that reversed the number in a loop with a switch statement. so once the number has been reversed the program would : * start a for loop that ran the length of the users number... not sure how the length is figured, numlength() or something hopefully.... * perform the modulo operation * feed this modulo'd number (first one in the 246 reversed to 642 would be 2) into a switch statement * have the switch statement print out a word depending on the number, 0 = zero, 1 = one etc... 
So that the *compiler or C standard library headers* can define internal variables.
It *can* cause unexpected problems down the line if, say, a compiler or standard library implementation uses that particular name for itself. In other words, it compiles fine, but it's not the toolkit's fault if it fails to compile on a particular toolkit/compiler version.
You see, this I don't get. Why add the underscores? I remember a lecturer of mine back at uni publicly bashing someone's code (I don't think the author was a student, I think it was just some code he'd found in a tutorial) for having underscores at the beginning of identifiers, in a lecture: &gt; Never use underscores as the first character in an identifier, ever. He then went on to explain how they can, and are used in standard libraries and how it could lead to unintentional bugs because the compiler might think you where calling some library value or method when you meant to store some calculation.
 #pragma once 
Embedded programming is a great place to get your feet wet. MSP430 Launchpad is also a good starter. Using CCS has been a great tool for coding/debugging and a good starting point IMO. Cheapest as well I think.
what's so bad about delegating this to the programmer? Are people afraid to read documentation? This was one of the nice things of plan9 imho. e: i bet it's related to bitrot and refactoring cat to oblivion. I'm not a part of that and am glad.
Pike's rationale seems to involve old, slow compilers that don't remember header guards or support pragma once. What's the reason to do this *now*? So each header basically needs a block of includes, but as comments. (Or maybe it's not in the actual file, meaning it's more likely to go out of date.) Are they expanded to include transitive dependencies, meaning that you have to update all dependents when you change requirements, or do you require a person writing a source file to check recursively? Eventually you'll want to remove an include; do you keep a refcount for each file as you go or do you rebuild the whole dependency tree when that happens? It adds a bunch of manual labor that could be automated. Why not automate it? Why not automate it using the existing include mechanism?
&gt; Actually, the underscored names were introduced to avoid introducing new reserved words and breaking existing code which legally used those reserved words. That was my point :)
hey just got home - going to be able to go through this properly tomorrow. I'll get some code together and post back. Thanks very much :)
cheers DS, so I'm looking at what you've written and going through it. I'm not sure how to get the numbers into an array though. [here's a link to the error](http://i.imgur.com/5qMe3CL.png) 
Are you using 2.95? If so, I'm impressed. That's a 15 year old compiler. 
Oh, you mixed up your actual inputted int and the array to hold the single digits. Keep in mind what you're going to do. First you need a variable to hold what you read via scanf, and then you also need an array that will hold the single digits. In the code you have, you use 'number' to refer to the array *and* the variable holding the actual number. They should be separate, so if 'number' is your array, you need an extra variable to hold what you read from scanf. (The error you're getting is because you took the address of the array instead of the address of an int). If you haven't learned much about arrays yet, then you'll definitely want to read up on them. I apologize in that I jumped into this assuming you'd been exposed to them already. They're really not that complex but knowing them is crucial to the solution I'm kinda leading you in the direction of. (Basically arrays are just a way to access multiple variables via the same name and a subscript. So we can Ex. declare 10 ints with the same name 'number', and then access each one individually via 'number[0]', 'number[3]', etc...). You could do this solution without arrays if you wanted to (Via the original switch() statement you had before, and some interesting math to swap the digits.) You could also avoid the math entirely and simply read in single digits as characters, and then do a select() to print out the right string (Though personally I don't particularly like that approach). There are multiple ways to finish this problem. I would definitely argue figuring it out for yourself is much more valuable to getting the 'best' solution, so I wouldn't really focus to much on trying to follow what I or anybody else says if you have a different idea that may work.
 cheers DS - yeah as It goes on I realise how much there is for me to learn and I end up going off on big tangents when the stuff is probably in the next chapter of the book I'm reading :P I'm going to have a read and I'll get back to this post on Monday. Not sure why I chose Monday, seemed reasonable. thanks again. 
Wth is wrong with people who downvote this? Pragma once is faster, supported by almost every compiler and is just nice to use. 
Hey. C is worth it if you want to understand some fundamentals. I find its useful especially if you go into Electronic Engineering. If you're more of the hands on type and want to give it a go without any books- try this tutorial; http://gerfficient.com/2014/02/12/programming-c/
This is great for people (like me) coming into C from other programming languages. I don't need to be taught how to program, I just need to know the ins-and-outs of the language.
If you go the Unix/Linux without an IDE route, I highly recommend learning vim (vi), it's a terminal text editor with a lot of powerful features like syntax highlighting. There's a slight learning curve, but once you get comfortable in it you'll be able to sit down at any Unix/Linux terminal and start programming in any language that you know. And because it's a terminal program, you can easily SSH into a system and start programming.
You might also use any of Emacs, vi, vim, nano, ved, mined, ed, or ex, but this is mostly a religious question. Use the editor you can work best with!
Thanks for the hint! `numcmp` takes two `char *`s. It seems like changing it to accept two `const char*`s fixed that part of things. On the function pointer inside my_qsort, that strikes me as really dirty. In such a situation, since both strcmp and numcmp accept const char*s, wouldn't it be better to change the function pointer argument to reflect that as well? I'd like to stay away from undefined behavior if I can. I edited `my_qsort` to point to a function that accepts two `const char *`s, to make things more concrete. With your hint I was able to solve the exercise! Here's [the code](https://github.com/sporkbox/knr-exercises/blob/master/ch5/5-14_rsort.c) if you'd like to see it. `reverse_set` and a check for `-r` in `main` is my code; the rest was sourced from the book.
That was a pretty informative discussion! Thanks for linking it; it helped me wrap my head around things a little better.
But it doesn't work with a 15 year old compiler! 
A quick scan reveals lots of errors. The most major in the first tenth or so: It makes assumptions about the size of a short, and its overflow characteristics: // First you define the short short number; // Then you assign it a number (here the maximum) number = 32768; // And output it printf("Number: %d\n", number); // Now increase the value by one // Should give 32768+1 but that is too large number++; // So let's output it again printf("Overflowed number: %d\n", number); claiming this should output Number: 32768 Overflowed number: -32767 I don't know of anything that would output this. The author seems to have confused the limits of a 16-bit two's complement integer, which are actually -32768 to +32767. Assuming the author meant to assign 32767 to number, then increment it and have it overflow to -32768, this is still not guaranteed, because short isn't necessarily 16 bits. The author should have used int16_t, which is guaranteed to be 16 bits wide. Even so, overflowing a signed integer doesn't have well-defined behavior, so you could get anything assigning 32767 to an int16_t and then trying to increment it. The author has an erroneous table of integer ranges: 16 bit value short -32,767 to 32,768 unsigned short 0 to 65,535 At least 16 bit but on a 32 bit processor it is 32 bit long int -2,147,483 647 to 2,147,483,648 unsigned int 0 to 4,294,967,295 At least 32 bit, but usually both are 64 bit long long -9 223 372 036 854 775 807 to 9 223 372 036 854 775 808 unsigned long 0 to 18 446 744 073 709 551 615 long long -9 223 372 036 854 775 807 to 9 223 372 036 854 775 808 unsigned long long 0 to 18 446 744 073 709 551 615 All the signed ranges above are wrong; the minimums and maximums should all be reduced by 1. Also the C types aren't guaranteed to be these sizes. A short may be more than 16 bits. An int may be as small as 16 bits. A long may be as small as 32 bits. The code that prints integer sizes is non-portable, because it assumes that size_t (the result of sizeof) is the size of an int, whereas it's often the size of a long or long long: printf("short: %d Bit\n", sizeof(short)*8); printf("int: %d Bit\n", sizeof(int)*8); printf("long: %d Bit\n", sizeof(long)*8); printf("long long: %d Bit\n", sizeof(long long)*8); It should use %zd: printf("short: %zd Bit\n", sizeof(short)*8); The author invokes undefined behavior in the variables tutorial: int a, b=5, c, d; ... b = 1 - --b; // b = -3 This invokes undefined behavior, because it modifies b twice between sequence points. This isn't a good sign. 
K&amp;R C is a classic. There's a link to the right.
Missing a } before the second else 
You left out a '}' before the line where the error is indicated.
no It had one too many for this program.. or maybe it was missing, I'm confused now... It works anyway!
Let me try to explain what it's expecting here. I'm going to oversimplify some stuff to get this point across. I'm sorry if you're already familiar with all of this. The parser has categories of things that it knows how to deal with: statements, expressions, and so on. Statements are things like an if block, an expression with a semicolon at the end ( 1+1; foo(); etc...), or a curly brace block. So this is an example of an expression: foo() This is too: 1 + 1 == 2 This is a statement, with the way I've described: foo(); This is one too (curly brace surrounded blocks count as a single statement to the outside): { foo(); } So is this: if(1 + 1 == 2) { foo(); } When the compiler sees the "if" token, it knows that it's going to want an open parenthesis, then an expression, then a closing parenthesis, then a statement. if ( *expression* ) *statement* This whole thing counts as a single statement on its own. It also checks for an "else" at the end of that, so it works in the form of... if ( *expression* ) *statement* else *statement* And since if statements themselves count as complete statements, when you have a nested if block like that, you can do... if ( *expression* ) if ( *expression* ) *statement* else *statement* ... but it starts getting ambiguous as to which "else" goes with which "if", so I frown upon this. ps: Also you should never use floating point values for money, as it seems you're doing. Unless you want to start fighting with floating point precision errors, money lost due to rounding, and values like NaN, undef, and infinite popping up. A more complete list of reasons why this is bad is here: http://stackoverflow.com/questions/3730019/why-not-use-double-or-float-to-represent-currency edit: formatting
Try to be consistent with indentation to avoid errors like this. 
And once you've done a bunch of vim (say a few months or so and messing with plugins and whatnot) you should try emacs + evil. It's all the nice environment of emacs (code completion with company-mode, async code check with flycheck, integrated shell, magit, ...) but still with the text editing power of vim.
Use an online code formatter like http://prettyprinter.de/ which gives this for your code: if(found) { // Cleaner than if (found == 1) if (custBal[ctr] &amp;gt; 100.00) { printf("\n** That customers balance is $%.2f\n", custBal[ctr]); printf(" No credit!\n"); } else { printf("The credit is good"); } else { printf("** You must have the incorrect number ID"); printf("\n ID %3d was not found on the list.\n" , idSearch); } } The error is pretty obvious now.
I'd argue that all the different types of formatting used here, both in conjunction and individually, were the things that hid this error from you.
No way, also, don't indent your braces, keep them in-line with whatever delimits the block.
&gt;the part after this names[i][strlen(names[i]) - 1] = '\0'; replaces the new line character with the null char. I don't fully understand this, though I know that if it has the null char it's able to be read back as a string. [Get used to hearing this phrase](http://en.wikipedia.org/wiki/Null-terminated_string). The reason you're replacing the newline is because, I assume, you don't want to print a newline whenever you print one of the cstrings in the 2d array, since theyre accepted from what is probably a user in the fashion "myInput" ENTER(\n). fgets() will stop reading when it sees a newline, but it will accept it also, and append a null char after it. So that's why youre replacing it. Also, if you want to have names of at most 20 letters, make the size of each dimension 21, so it has room for 20 alpha characters and 1 null character. Other than that, I don't know what to look for you missing really.
[A general rule is if you have to ask about user input don't use scanf.](http://c-faq.com/stdio/scanfprobs.html) A more general rule is don't use scanf. He's putting \0 at the end to replace a the newline.
Okay, thanks.
make is a program that creates files according to rules and dependencies. You write a *Makefile* that contains rules in the form *foo depends on bar and baz and can be created with commands quux*. make figures out (from timestamps) which files are out-of-date (i.e. older than their dependencies) and rebuilds them using the provided commands. There is a little bit more functionality in make than this, but this is all that matters. CMake on the other hand is a program that *generates Makefiles* for you. Writing Makefiles is a tedious and repetitive process that can be automated with CMake or other tools. For CMake, you basically create a simple list of source files to consider and CMake analyzes them to create a fully blown Makefile for you. CMake can also do other things such as probing your system for certain bugs / features and writing the result of the probe into a configuration header that can influence how your program is compiled.
ha ffs... why don't fucking tutorial books just teach the right way first time??? They use shit like gets() scanf() etc. blah.... cheers though :)
Cheers dude, just read the Wiki page, don't think I really *got* it all... I don't know what I'd do differently as a result of reading it etc... &gt;The reason you're replacing the newline is because, I assume, you don't want to print a newline whenever you print one of the cstrings in the 2d array Hadn't actually thought about that... I copied that code, but I have encountered the problem before in different code. As far as I understood it it was the `\n` character being left on the input stream, and the next function call picking that character up. Because of this the function would just be skipped before I (the user) got chance to enter input (Because C thought that I just hit enter) When you say "cstring" do you just mean a string in C...? cheers though :) 
`scanf("%s"` will stop reading when it hits whitespace. `fgets` will get the whole line (up to the available buffer size). 
Null-terminated strings are sometimes called *C strings*, as their use was popularized in C. Likewise a popular alternative, length-prefixed strings, are sometimes called *Pascal strings*, as their use was popularized in, you guessed it, Pascal.
yeah makes sense... just having a little strop there! Glad I found some code that uses fgets() though :)
Would you happen to know how to install linux on a partition without using a disk?
Get your hands on a USB drive, format it, put the Ubuntu (in my case) ISO on it, go into bios and allow booting from USB, restart and Ubuntu will boot. Run GParted to make a partition and then install Ubuntu with its built-in installer. I haven't don't it in a while, but I believe that was how I did it.
Nooooooooo not Turbo C++! If you really *must* use a Windows specific IDE I would go with Pelles C although I would still recommend gcc over Pelles C although I do think the Pelles C environment is quite nice. 
I like to use YUMI for making bootable thumb drives.
that shits hard yo
Download: [Notepad++](http://notepad-plus-plus.org/) [MinGW GCC](http://www.mingw.org/) Buy/Borrow/Download: [The C Programing Langiage](http://www.amazon.com/C-Programming-Language-2nd-Edition/dp/0131103628) [The Standard C Library](http://www.amazon.com/The-Standard-Library-P-J-Plauger/dp/0131315099) Read: [Answers To Exercises](http://users.powernet.co.uk/eton/kandr2/) [Computer Science For Everyone](http://www.computerscienceforeveryone.com/) [C Tutorial](http://www.tutorialspoint.com/cprogramming/index.htm) Practice. Profit. [Got a Question?](http://lmgtfy.com/)
[Try this](http://cs50.tv)
it depends... do you know how to program in assembly? -yes: it's very easy -no: you're about to learn what control structures are about. also, if you have elechtronics background, buy a pic microchip and try this assembly tutorial: http://www.piclist.com/techref/piclist/cheapic/index.htm once you understand how assembly works, you will not have problem with pointers nor anything like that.
Depends on what you mean by "learn". The syntax is simple, and the standard library isn't very large. To learn how to use the language itself, I would argue there's less to learn than in a language like Java. But the simplicity comes at a price: the kinds of things that you could achieve automatically in Java, like memory management, you'll have to do manually in C. I think of it as: the language is easy, but principles of computer science can be complicated. Unfortunately, many tasks require a knowledge of those principles in C.
Worth learning.
One of my CS professors does this all the time. Drives me crazy.
cool looking assembly tutorial, thanks!
It's very easy to learn the language itself, but hard to learn how to use it properly.
True. I used C in school a lot but it was only after 2 years of professional coding that I started to actually understand how to use the language in a good way.
[Wikipedia](https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29#Hardware_stacks) does a good job at explaining
That's a really vague question. Start by reading [this wikipedia article](https://en.wikipedia.org/wiki/Call_stack) and then ask any specific followup questions about parts you didn't understand. 
It's okay. C isn't a terribly complicated language, but there are a couple of things that can really bite you: * Never expect C to do anything for you. It won't. * Never expect C to catch your errors. It won't. * Beware of undefined behavior. * Writing portable code is hard. Stick to the standards (C99 / C11, POSIX.1 2008). 
As a note, ways in which the stack act are implementation defined.
&gt; Never expect C to catch your errors. It won't. Further to this, you're going to learn that there are a *lot* of errors.
Trying to think of the things that will burn you. * Memory overwrites. * Writing `=` when you meant `==` (took me years to get out that habit) * Mystery crashes long after the real accident because you overwrote the heap. * Memory overwrites. * Running off the end of buffers. * Following null pointers * Memory overwrites. * Getting pointers wrong and overwriting the wrong memory. Actually, pretty well every important mistake that will wind you up will turn out to be due to writing to the wrong memory. After a few years of this you'll eventually figure out the bad habits that encourage memory overwrites. An excellent to help find the more obscure memory overwrites is `valgrind`. If you can't install it, try a different OS!
[The stack as a data structure](http://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29#Software_stacks): The stack is what's called a First In, Last Out data structure. Just think of it like a stack of books, for example. You don't take out a book from the very center, you take a book off the top. The stack is the same way, you push data to the top of it and pop data from the top of it. [The stack as in memory](http://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29#Hardware_stacks): *The* stack is kind of like a stack (data structure), but its units are the memory you're using. What happens is when a process is started, the OS gives it some memory, and that memory is split into two parts, the stack and the heap (both are physically on the Random Access Memory stick(s), if you were curious). The stack is where variables that are plainly initialized (`int side = 2;`, `Object o{};`) inside functions are allocated. It can be used to represent the scope of those functions as well- you enter the scope and a variable is initialized, then it's pushed to the stack. You exit the scope and the variable is popped from the stack (after everything else that was initialized after it, of course). It makes a lot more sense if you ever try to hand-write some ASM- some of the more frequent commands are `push` and `pop`, of course referring to the hardware stack.
It's just first in last out. As opposed to a queue which is first in first out. 
[This article](http://www.phrack.org/issues.html?issue=49&amp;id=14) has a short but good explanation to how the stack works. Assuming you meant memory stack and not the data structure.
Nowadays, the installation script automagically detects an existing Windows and guides you through the repartition with sensible defaults.
Very well written. Although this is *C*, not *C++*, so the `Object` example may not be applicable. I would also note that the stack isn't the only place to store things, there's also the heap. The stack is useful for very small amounts of memory (integers, pointers, etc). The OS only reserves a tiny amount of memory for the stack. So while it's nice for smaller things like integers and pointers and whatnot, it's lousy for big chunks of data (large arrays, binary blobs, etc). If the stack runs out of memory, the program itself will overflow the memory (write past the bounds set by the OS) which will most likely result in a segmentation fault, and the program will die (in a simple scenario). Aside from that, the stack is ALSO a lousy place to store things like long-term data. Let's say you want to have a function that creates an array of integers and returns it to the caller. int* makeAnArray(void) { int anArray[10]; // allocate it on the stack for (int i = 0; i &lt; 10; i++) { anArray[i] = i; } // At this point, anArray is very much alive and well return anArray; } int main(int argc, char** argv) { // Before the call, no memory has been allocated yet int* anArrayPointer = makeAnArray(); // Call the function // At this point, anArray has now been cleaned // up by the function that allocated it. Yet we're still // running somehow. What on earth are we pointing at? for (int i = 0; i &lt; 10; i++) { printf("Array[%d] = %d\n", i, anArrayPointer[i]); } return 0; } As soon as `makeAnArray` finishes, the `anArray` variable will be popped from the stack. What does this mean to the caller? Well the address it's getting back is pointing to a region of memory that *used* to contain an array. You actually can't know what's in it now, or even if it's safe to use. In other words, the stack makes it impossible to guarantee that data survives after it exits a function's scope. So how can we fix this? Instead of using the stack, we use the heap which will gladly store our data long-term without magically cleaning it up for us when the function exits. int* makeAnArray(void) { // allocate the memory on the heap int* anArray = (int*) malloc(10 * sizeof(int)); for (int i = 0; i &lt; 10; i++) { anArray[i] = i; } return anArray; } int main(int argc, char** argv) { int* anArrayPointer = makeAnArray(); // Because we used the heap, the array is still alive and well // now. We can safely use it without worrying that it might // get automatically cleaned up by someone. for (int i = 0; i &lt; 10; i++) { printf("Array[%d] = %d\n", i, anArrayPointer[i]); } // Since the data isn't automatically popped for us, we have // to remember to clean it up ourselves once we're done with it. free(anArrayPointer); return 0; } This second implementation will actually guarantee that the memory pointed to is still usable when `makeAnArray` exits. This kind of passing isn't actually possible using the stack, which is important to remember as you start writing more complicated programs.
Each time you run a function, the computer has to remember who ran the function, so it can return back to that place after the function is done. Also, most functions have local variables in them. And those local variables have to exist somewhere. The solution that compiler writers came up with for both these problems was to allocate a small amount of memory, just big enough to hold the return address and local variables, each time a function was called. This small amount of memory is known as a "stack frame" or just a "frame". As the name implies, these frames are stored on a "stack." The stack is just an area of memory that has been specifically set aside so it can be used to hold the function call frames. The stack is called that because it behaves like a stack data structure. When a function is called, a new frame is created and placed on top of the stack. When that function exits/returns, the CPU looks at the top frame to get the return address, pops that (now obselete) frame off the stack, and returns to where-ever the function was called from. Usually, the function you return to, was ALSO called by some other function. (Unless it's main() - that's a different story.) And that's the reason we need a stack. So you can call foo() from bar(), bar() was called from baz(), baz() was called by qux(), and qux() was called by main(). You have to be able to go backwards all the way back to main as the functions complete their work and return. That's what the stack is for - it's a record of what functions called the current one, so you can get back when the current function exits. HTH. HAND. YMMV. TANSTAAFL. SUSFU. FOADL. ETC, ETC, ETC...
POINTERS. Understanding pointers will really help you out! (with other languages too)
People do this..whut? 
I don't know any guide, but you could start with the [documentation](http://www.gnu.org/software/make/manual/make.html#Introduction) of GNU make. Notice that GNU make has a couple of features that aren't standardized and may not work on other platforms.
[The Linux Programming Interface](http://www.man7.org/tlpi/index.html) is a great resource for answering questions like this, and I recommend it highly if you're serious about system programming. I did a quick compare with your code against chapter 38, about secure privileged programs, and your code passes the smell test. My only comment would be that your're feeding UID's to setresgid(), which I don't think is correct.
i think you should close any open file descriptors too, like stdin,stdout and stderr. e: also don't forget umask when opening your own files instead of syslog, it means fatal should do something other than it does now.
You'll want [APUE 3rd Ed](http://www.amazon.com/Programming-Environment-Addison-Wesley-Professional-Computing/dp/0321637739) for something like this. I personally consider it a must-have. Other things to note, you may/may not want to *setrlimit* for core dumps if you have sensitive information in the daemon. Calling *fork*() and then killing the parent is considered standard as is calling *setsid*(), closing all file handles and opening 0/1/2 to /dev/null.
I really shouldn't be surprised by your reaction haha. :D 
-fmudflaps looks really useful, thanks! Though I [notice] (http://gcc.gnu.org/wiki/Mudflap_Pointer_Debugging) it isn't in later versions of GCC, I'll check which version I have.
I assume address sanitizer will work the same way, but I haven't tried it. It will be a while before I am on GCC 4.9 anyway. 
Strange. The glibc explicitly allows passing negative values to sbrk: /* Extend the process's data space by INCREMENT. If INCREMENT is negative, shrink data space by - INCREMENT. Return start of new space allocated, or -1 for errors. */ void * __sbrk (intptr_t increment) { void *oldbrk; /* If this is not part of the dynamic library or the library is used via dynamic loading in a statically linked program update __curbrk from the kernel's brk value. That way two separate instances of __brk and __sbrk can share the heap, returning interleaved pieces of it. */ if (__curbrk == NULL || __libc_multiple_libcs) if (__brk (0) &lt; 0) /* Initialize the break. */ return (void *) -1; if (increment == 0) return __curbrk; oldbrk = __curbrk; if ((increment &gt; 0 ? ((uintptr_t) oldbrk + (uintptr_t) increment &lt; (uintptr_t) oldbrk) : ((uintptr_t) oldbrk &lt; (uintptr_t) -increment)) || __brk (oldbrk + increment) &lt; 0) return (void *) -1; return oldbrk; } 
I wish someone would write a tutorial for automatic testing against the simulator built into msp430-gcc. 
They may be a major pain to work with, especially when it comes to tracking down errors, but pointers are one of the most powerful parts of C when used properly. UNDERSTANDING them is total mess to figure out, but it's worth the effort.
I'm currently using C, in addition to some assembly, for OS development, just a hobby project of mine. I love the low-level capabilities of it, but the lack of namespacing and lack of classes has become quite an issue while writing drivers, so I'll likely be translating to C++ for much of my work.
Why are you surprised that different libc-s on different OSes have differing implementations of sbrk? OS X kernel engineers highly prefer you to implement malloc() in terms of mmap(). sbrk() on OS X is basically vestigial, mostly there for the strangely large corpus of randomly reimplemented malloc()s that various projects happen to use. (I mean hell, have a look for yourself: http://www.opensource.apple.com/source/Libc/Libc-825.40.1/emulated/brk.c). As for the submitter: you should handle the case that sbrk(-int) "doesn't do anything" by just continuing. If you absolutely must return memory to the system with your allocator, switch to mmap() on this platform (e.g. by testing it in the first malloc() call).
Some folks might because their variable identifier begins with a number (which is illegal in C)
It doesn't make any sense. void function(Struct *foo, void (*bar)(void *baz)) * Struct -&gt; struct * *foo -&gt; foo *f * foo (actually, f) does not have a member called "bar." So you can't call foo-&gt;bar. Your code doesn't even come close to compiling.
Oh boy, homework. So you're taking about this situation, right: void function (Struct *foo, void (*bar)(void *)) { foo-&gt;bar(baz); } Your function is called `function` and your struct typedef is called `Struct`. Sigh. This assumes that `Struct` is some crazy typedef for a structure. Written this way, the function call inside the function called *function* (argh) never even touches the `bar` argument; it calls a function pointer within `Struct`, which is called `bar`. The `baz` argument is not defined anywhere and the code will thusly not compile. Head asplode.
This is one function from a larger program that I tried to make somewhat generic rather than post pages of code. I do grasp C enough to know that this function in and of itself will not compile. What I am trying to figure out is what one might be trying to do with a statement along the lines of (structure element)-&gt;(function pointer)(void pointer to some bit of data). But thanks anyway.
I suppose it is homework in the sense that it is a from a book on algorithms that I have been working on at home. Outside of my kid's school, I haven't been in a formal classroom for a nigh upon two decades. Sorry about your head asploding. I hope it didn't make too much of a mess. 
Sounded like a trick homework question to me. You never know with questions on this sub. Alright, I'll cut the snark. Sorry to say so, but the code as you posted it does not make much sense for the reasons mentioned elsewhere. First of all, is my code snippet above an accurate statement of the situation? If so, the `bar` argument to `function` is not used, and `baz` is not introduced into the function anywhere, so the code will not compile. However, if `baz` is a global variable and `Struct` has a member called `bar` which is a function pointer of some sort, then it *might* compile. It's just... there's not enough context to say either way.
Thank you. Your stab at the larger program is correct. That helps a lot.
Hm, but `baz` is not actually in the parameters. I'm going to be pedantic, but these two declarations are equivalent: void function(Struct *foo, void (*bar)(void *baz)) void function(Struct *foo, void (*bar)(void *)) Both declare a function called `function`, which returns nothing, and takes as parameters a pointer to `Struct` (called `foo` within the function body), and a pointer to a void function, called `bar` within the body, that takes a void pointer. The name of that void pointer is not important: it's called `baz` in the first example for documentation purposes, but is anonymous in the second example. The function above would be called as: function(foo, bar); // no baz!
If it's really just a simple counter, maybe you can use an atomic int type and call it a day. Incrementation should be atomic on virtually every platform (I think), but GCC has [some builtin types](https://www.gnu.org/software/libc/manual/html_node/Atomic-Data-Access.html) that may help. Be sure to declare the counter `volatile` everywhere so that the compiler won't optimize its fetch operation away. If things are more complicated than that, yeah, you can use a flag and check it in your mainloop occasionally. Or maybe you can [block signals](https://www.gnu.org/software/libc/manual/html_node/Blocking-Signals.html) when the other processes are vying for the semaphore, so that you know that your signal can only occur when the semaphore is released. (But that sounds hacky and race-y.)
As teringlijer as pointed out, the parameters are called foo and bar. However, the bar parameter is a function pointer that is completely different from the bar member variable that's part of foo. It's this member variable that will be used with foo-&gt;bar() baz is undefined. Why don't you post the actual code?
The way the OS kernel gets around similar things---and just about the only way to get around the semaphore issues---is to implement some form of critical section that either blocks or defers interrupts/signals. Basically, either static __thread unsigned inCriticalSection = 0; static __thread sigset_t origSet; void begin_critical_section(void) { if(!inCriticalSection) { sigset_t block; sigemptyset(&amp;block); sigaddset(&amp;block, ANY_SIGNALS_TO_BLOCK); //... sigprocmask(SIG_BLOCK, &amp;block, &amp;origSet); inCriticalSection = 1; } else ++inCriticalSection; } void leaveCriticalSection(void) { assert(inCriticalSection); if(!--inCriticalSection) { sigprocmask(SIG_SETMASK, &amp;origSet, NULL); } } or static void signalAction(int sig); // The body of the signal handler. static __thread volatile sig_atomic_t deferredSignals[MAX_SIGNAL_ID+1] = {0}; // Calculate MAX_SIGNAL_ID with a preprocessor #if/#elif // chain, if you have to, or dynamically allocate it before // setting the signal handler. static __thread unsigned inCriticalSection = 0; void enterCriticalSection(void) { ++inCriticalSection; } void leaveCriticalSection(void) { if(!--inCriticalSection) { unsigned i; for(i=0; i&lt;countof(deferredSignals); i++) { unsigned j = deferredSignals[i]; deferredSignals[i] = 0; while(j--) signalAction(i); } } } // This is what gets passed to signal/sigaction. void theSignalHandler(int sig) { assert(sig &gt;= 0 &amp;&amp; sig &lt;= MAX_SIGNAL_ID); if(inCriticalSection) { ++deferredSignals[foo]; return; } signalAction(sig); } The first of these uses signal masking to ensure that no signals occur while you're in a critical section, making the OS defer handling until the signal(s) are unmasked; the second does that manually, without the call into the kernel. Just make sure that, before you start using anything that a signal handler could access, you do `enterCriticalSection()`, and a call `leaveCriticalSection()` after you're done. It may be a good idea to wrap these in macros to start/end a `{`compound statement`}` when entering/leaving to have the compiler complain about syntax if you forget one side. W.r.t. accessing `stderr`, *do not access any `stdio` functionality from within a signal handler.* There's a pretty restrictive list of functions that are safe for use in `signal`, and just about the only way to access `stderr` is via `write` to `STDERR_FILENO`. Of course, that can still make your output interleave with the rest of the program's---there's no particularly satisfying solution for this sort of thing, unfortunately. About the best you can do if there's a chance of interleave is to provide a hopefully-big-enough buffer, write into that in the signal handler, and flush it from outside the signal handler.
scanf returns the number of items read, not the value of x.
 (scanf("%d", &amp;x)) != 0 It's not the return value of `scanf` that you want to compare to `0`. Instead, you want to do `scanf` to read into `x` and then compare `x` to `0`.
As noted by someone else already, the return value of scanf() relates to the number of values read from stdin (keyboard in this case). Since you're supposed to terminate when you hit zero, you have to do a separate check to see if you actually inputted a zero. If you're still confused about the return value for scanf, imagine the case where you input more then one integer on a line, Ex scanf("%d %d", &amp;x, &amp;y), or reading in a string: scanf("%s", str). When you consider these possibilities, having that value be returned in the return value of scanf doesn't make much sense. For this simple of a problem, you have no real need to check the return value of scanf at all, and are really free to disregard it. You do have a slight issue you're facing with this. You need to do your input and get that stored into x, and then after that you need to check the value of x and leave the loop if it's zero. There are multiple ways to do this and I'll leave that to you, but if you're having trouble on it feel free to ask. In general, you're going to have to have a check for 'x == 0' somewhere, and exit the loop if it's true (Or the opposite, check 'x != 0' and exit if that is false). I would suspect your average values are wrong because of the above (You're not terminating the loop correctly, so you might be accounting for extra numbers after when you should have already exited the loop). EDIT: Also, an extra note that's slightly off-topic, you should try to use getchar(); instead of using system("pause"). The reason I say this is that while getchar() is part of the C standard (and this is portable), system("pause") calls out to the system to run the 'pause' command/program, which may or may-not exist ('pause' is a Windows command, so your code won't work as-is on say Linux or OSX machines).
Thanks for the great reply! It turns out that by turning off the automatic restart of syscalls via sigaction I can check my call to accept() before I fork to see if it is == EINTR at which point I then check a flag I set in my sig handler and print to stderr from my original process and main function, then resetting the flag set in the sig handler. I'm a little worried about accessing that flag in main and in my sig handler, but after giving it some thought I don't think a race condition will be a problem(in terms of getting another signal which causes the flag to be set while I'm setting it to 0) .
Thanks for the links! I didn't know about these builtins in GCC, I will check em out. However I seem to have figured out a way to solve my problem which I've described in the response to /u/nerd4code edit: spelling
Change to: while ( 1 == scanf("%d", &amp;x) &amp;&amp; x != 0 ) 
So what is this basically saying? As long as whatever is entered and is saved to X is 1 value, and that value is not 0?
Yes. If you don't check the return value of scanf, then you will get an infinite loop if they type in words, or close the input stream. 
It's also possible to use separate stacks for function calls and automatic variables.
Thank you for the help everyone. By reading what you all said and rereading some info on scanf I understand my error. By fixing that and adding some if and else to the end in order to fix a divide by 0 error I was able to complete the problem. 
And an excellent idea it is too, for many reasons. Yet so few compilers seem to do it... it's very frustrating.
You need to figure out what your issue actually is. Not grasping the concepts is often code for I do not understand what I don't understand, so that means the first step is to figure out what is tripping you up. If you are completely new to programming, you might be having issues converting problems into logical steps or maybe logic into code? Perhaps your problem lies more with the language itself, and you are finding yourself confused at how to apply the language to handle those logical steps?
Roughly.. Now I've only learnt functions and getchar and putchar Hm User runs program, user has to enter programs name, program reads (..) And displays size in bytes.. You see where I get tripped up :/ 
remember this piece of advice: computers are stupid. they dont know how to do anything at all. So you have to do everything yourself, and just tell the computer to do the same. How would you know how many characters a text on a paper has? Pick up the paper, count the characters one by one, adding 1 to a total each time. At the end, you get the total. If you dont solve the problem in your head first (logic!), dont bother trying to code
Thanks man I'll always keep that advice. I guess I need to change my thinking method haha I might start KR2 again once I get my hard copy and try to really study itb
Honestly, 90% of learning to program is googling for "&lt;language&gt; &lt;problem&gt;" e.g. [C reads the size of a file](https://encrypted.google.com/search?q=C%20reads%20the%20size%20of%20a%20file). That's why it's so important to do exercises. Think of it as learning a new language; you aren't expected to know that the french word for horse is "cheval" without consulting a dictionary first.
Actually, that's a terrible analogy since it makes you oblivious to anything but the very most rudimentary functions (i.e. getc). You have to consider all the tools available to you instead of reinventing the wheel: Seek to the end of the file with fseek and ask for the position with ftell.
How about opening the file and seeing how many times you can `getc()` before it fails? 
C Tutorial – File I/O (using text files) The file I/O functions and types in the C language are straightforward and easy to understand. To make use of these functions and types you have to include the stdio library. (Like we already did in most of the tutorials). The file I/O functions in the stdio library are: fopen – opens a text file. fclose – closes a text file. feof – detects end-of-file marker in a file. fscanf – reads formatted input from a file. fprintf – prints formatted output to a file. fgets – reads a string from a file. fputs – prints a string to a file. fgetc – reads a character from a file. fputc – prints a character to a file.
hey Swole Im learning C also, check out •Higher Computing For Everyone located on the side. This has helped me out 10 fold at understanding C and programming in general. 
Do you understand loops?
Thanks so much for your advice guys ill take it all and build a upon it the best way I can :) to answer your question thus far I understand If and else if and else loop. For loops a bit and I understand that (I = 0; I &lt;= J; I++) Array{10} = 0; Sets the ten elements in the array to zero :) 
OP is just starting with k&amp;r and so he doesn't know about ftell. Moreover, ftell's output varies based on the particular text encoding of your file, the system you're using, the mode you opened the file in, and so on and so forth. Best not to use it in this situation. 
Im a big fan of "the hard way"-series by Zed Shaw, witch includes a "Learn C". You should check it out. While "The C programming langage" is a masterpiece of writing it might not be the best place to learn programming from scratch. Edit: I do think you are making the right choice starting with C.
Which exercise are you looking at?
Hmm. No. There's some things wrong with that, even in pseudo-code. In C: const int array_size = 10; int array[array_size]; for (int i = 0 ; i &lt; array_size; ++i) { array[i] = 0; } 
&gt; I can put up a link to myShell.c if that would be useful It would. Also link your code.
Ok, I think this makes sense. So before executing a command, I would do something like the following: // For each argument for (i = 1; i &lt; num_args; i++) { // If the first char is a $, replace it with the actual value if (arg[i][0] == '$') arg[i] = getenv(arg[i]); }
This is the correct way to do this.
This is wrong, as explained by ahminus. In regards to your problem about judging the size of the file, if we are judging the size of file by the number of characters it contains, you will need a basic understanding of fgetc() and loops. A computer reads through a file's text using a loop, examining each character individually every time the program executes the loop. How would you go about counting these characters?
Please post errors.
no errors, it compiles, but crashes on windows most times
compile with -O0 -g and run it under gdb(gdb a.out, then type run at the gdb prompt), if it crashes type 'bt' to see where and/or post that info.
You should get quite a few errors. For instance, there aren't any prototypes for your functions. If the prototypes are missing, the C compiler makes assumptions about what types are being passed that won't always hold.
it's separated in 2 files, I just put it together to put on pastebin. Here is crypt.h http://pastebin.com/Ruk4q99w and here is crypt.c: http://pastebin.com/uU6YvqtR Doesn't complain about anything when I compile.
to test it run under command line crypt -e [filename.txt] where filename is a file u create and put a some word on it to decrypt put crypt -d [filename], it will ask for a password, use the same to encrynpt and decrypt
I have no idea how to do that, sorry, I'm begginner and haven't messed with compiler params
Well, it's time to get your hands dirty! Don't worry, it's actually quite fun.
I have no idea how to do what he said
Alright, neato! I removed the reliance on getopt because it was causing way too many issues and parsing arguments is pretty easy. https://gist.github.com/wallstop/9865702 Everything's boiled back down to a single source, no OS-specififc libraries in use, I'm happier. So now, question time! What's with the sizeof &lt;pointer type&gt; in all of your mallocs? I'm not sure I really understand why those are being used instead of sizeof &lt;type&gt;, since the sizeof &lt;pointer typeA&gt; should == sizeof &lt;pointer typeB&gt; == sizeof &lt;pointer typeN&gt; So I went with the brazen assumption that you REALLY meant sizeof(type), and changed everything over to that. Onwards! In crack_the_code, what's going on in your inner-most for loop? (My line 145, specifically). You're indexing into apass, which should just be the password that the user put in. But... you're morphing the index by some gap value? So you can end up with apass[SOMETHING_RIDICULOUS_LIKE_NEGATIVE_701_MAYBE_IM_NOT_SURE_BECAUSE_THERE_ARE_TOO_MANY_TEMPORARIES_AND_NO_COMMENTS]. I especially don't follow what's going on with that chunk of code, or the reason for the constants in gap[]. Care to enlighten me? The main reason I ask is because that's where the heap-stomping error occurs and crashes my program. EDIT: Updated gist for proper parsing, updated comment to reflect line number changes 
alright, I'll try to answer all your questions, so here it goes: the malloc part, yeah that was dumb of me, I was working with structs alot lately and I cast structs like this: myStruct1 *name = (myStruct *) malloc(sizeof(myStruct1)); so I guess I went with something like that... Ok, now for the other part, that's the shellsort algorithm, as seen here: http://en.wikipedia.org/wiki/Shellsort the constants in the gap is the Ciura gap sequence as I've been told it's the one with the best performance. I'm going to sleep now as I'm really tired, will check again tomorrow and hopefully shed some more light on it, also thanks for being so helpful so far. Obs.: I really forgot to prototype my functions :'(
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Shellsort**](http://en.wikipedia.org/wiki/Shellsort): [](#sfw) --- &gt;__Shellsort__, also known as __Shell sort__ or __Shell's method__, is an in-place [comparison sort](http://en.wikipedia.org/wiki/Comparison_sort). It can either be seen as a generalization of sorting by exchange ([bubble sort](http://en.wikipedia.org/wiki/Bubble_sort)) or sorting by insertion ([insertion sort](http://en.wikipedia.org/wiki/Insertion_sort)). The method starts by sorting elements far apart from each other and progressively reducing the gap between them. Starting with far apart elements can move some out-of-place elements into position faster than a simple nearest neighbor exchange. [Donald Shell](http://en.wikipedia.org/wiki/Donald_Shell) published the first version of this sort in 1959. The running time of Shellsort is heavily dependent on the gap sequence it uses. For many practical variants, determining their [time complexity](http://en.wikipedia.org/wiki/Time_complexity) remains an [open problem](http://en.wikipedia.org/wiki/Open_problem). &gt;==== &gt;[**Image**](http://i.imgur.com/36YwC3f.gif) [^(i)](http://commons.wikimedia.org/wiki/File:Sorting_shellsort_anim.gif) --- ^Interesting: [^Sorting ^algorithm](http://en.wikipedia.org/wiki/Sorting_algorithm) ^| [^Comb ^sort](http://en.wikipedia.org/wiki/Comb_sort) ^| [^Vaughan ^Pratt](http://en.wikipedia.org/wiki/Vaughan_Pratt) ^| [^Paul ^Vitanyi](http://en.wikipedia.org/wiki/Paul_Vitanyi) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cgfdwys) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cgfdwys)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
on Linux, in a terminal, when compiling your source, add -O0 -g to avoid any optimization and insert debug flags to your executable. Then, use the command $ gdb a.out when gdb is launched, type the command *run* inside of it. It will launch your program. If it segfault, you can use *bt*, a shorthand for *backtrace*, to see where in the program you have a segfault.
Hey, thanks for the info! By the time you had replied, I had actually googled around enough to get all of the answers. After throwing in a bunch of asserts, I found your error. Or, rather, an error. In crack_the code, you're mallocing a couple things. This is all and good, because you're returning pointers. So let's see, what do we malloc? Well, we malloc an array of ints to return, and an array of characters that'll simulate a string. Cool. What sizes do we give them? Well, the strlen of our password * sizeof(storage type), where storage type is an int or a char. So far, so good. Then, right after that, we do a strcpy from our password to one that we're going to sort using shell sort. Neat! Let's go check out the docs for strcpy. "Copies the C string pointed by source into the array pointed by destination, including the terminating null character (and stopping at that point)." Hmm, let's go check out the docs for strlen. " The length of a C string is determined by the terminating null-character: A C string is as long as the number of characters between the beginning of the string and the terminating null character (without including the terminating null character itself)." Hmmmmm. You end up stomping onto ONE SINGLE BYTE of the heap with strcpy, because strlen returns the size of the string MINUS the terminating null. Ouch. This is fixable by either doing something like: for(int i = 0; i &lt; strlen(pass); ++i) apass[i] = pass[i]; Or simply: char *apass = (char* )malloc((strlen(pass)) * sizeof(char) + 1); The subsequent call to free was then complaining and causing the program to crash. ----------------------------- Edit: Some other stuff: You're relying on strlen(text_from_file) to determine how many characters to write in some methods. Throwing in some assertions revealed that fgetc(...) when decrypting an encrypted file would potentially return the 0 character. Remember, EOF != char(0). This is pretty important because if you ever write a 0 out to your chunk of memory and then call strlen on it, strlen will report the length from start to that 0 character and ignore the rest. strlen(big_ass_string) is not equal to ftell(file) in your set_string method, which is worrying, because it means that you're either allocating unnecessary bytes somewhere, or not reading something fully, orrrrr something. You're probably going to want to create some kind of tight structure coupling the memory you allocate and the size you've allocated for it. That way, you're not relying on strlen when dealing with character streams from files... I'm also not particularly happy that the program craps all over the file provided to it as input. As a user, it'd be super nice if it generated a new file for me for both encrypt and decrypt, but maybe that's just me? Testing the program with a cut from a wikipedia XML dump showed that encrypting the sample file changed the file size by about 25%. Is this intended? If not, it's a 25% loss in data... FULL DISCLAIMER: I'm a pretty awful C programmer, my main experience is in C++/Java/Python, where I'm used to RAII or garbage collection, so I may not be the best resource here. I've updated the gist link with a bunch of asserts to show you my train of thought, also with function definition changes to reflect better const-correctness. 
&gt; cross-platform ...capability? Compatibility? compile-ability? portability?
That's the one.
That's it. You have the basics down. :)
I do when using a C++ compiler!
You don't use a C++ compiler to compile C code. Please don't.