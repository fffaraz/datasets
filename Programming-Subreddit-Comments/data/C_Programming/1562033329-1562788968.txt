This is an excellent and light hearted guide to network programming in C, very easy to read with in depth explanations and examples for everything. Can't recommend it enough.
Love this book. Helped me so much in finally understanding C and pointers. Same with the [Crash Course in Computer Science](https://www.youtube.com/playlist?list=PL8dPuuaLjXtNlUrzyH5r6jN9ulIgZBpdo).
/u/p0k3t0: &gt;I wasn't suggesting using that data. Also /u/p0k3to: &gt; One trick you can use is to find the full file length, and stop reading once you get to the end. ‡≤†\_‡≤† &gt; So this silly idea that a linux program... "A proper [Unix program](https://linux.die.net/Linux-CLI/c1089.htm)". Linux isn't the only Unix. See, for example, OP's screenshot. The nuances of `stat` and `lseek` are not the same between Unix OSes.
Take a break, lads. I'm sure there's some other pedantry you can address. There's gotta be someone claiming that C can pass by reference.
&gt;One trick you can use is to find the full file length, and stop reading once you get to the end. Lest anyone read this and actually take your advice, let's quickly look at why it's a bad idea. If you recommend this to someone, they're probably going to write something like this: #include &lt;stdio.h&gt; long get_file_size(FILE * f){ long r = 0; fseek(f, 0L, SEEK_END); // pretty terrible error checking r = ftell(f); fseek(f, 0L, SEEK_SET); return r; } int main(int argc, const char ** argv) { FILE * f = (argc &gt; 1) ? fopen(argv[1], "r") : stdin; long len = get_file_size(f); int lno = 1; printf("%04d ", lno); for (long i = 0; i &lt; len; i++) { char c = (char) fgetc(f); printf("%c", c); if ( (c == '\n') &amp;&amp; (i !- len - 1) ) printf("%04d ", lno++); // only properly formatted for files that won't make /r/programminghorror recoil in shock } fclose(f); return 0; } You can also implement `get_file_size` by calling stat and using the `st_size` field. So what's wrong with this? First, you can't do this: $ cat file.txt | ./number_lines Or this: $ mkfifo foo; yes "banana" | head -n 9999 &gt;&gt; foo $ ./number_lines foo There's also a race condition: the file size is measured at one point and then trusted to stay the same. Sure, you say, it's the user's fault if the file is added to after the program is called. The program just won't get that additional information. Fine. But what if someone calls `truncate` on the file after `get_file_size` but before your program is finished? (This isn't hard to make happen.) Now your `for` loop is trying to read bytes of the file that don't exist any more and write them to stdout. Great job!
There's no shortage of people trying to teach people trying to learn programming "clever tricks" that are dead wrong, that's for sure.
Just because a practice is common doesn't make it good.
but I am passing address (call by reference) of s, so memory should be allocated to s and values should be assigned to that allocated memory. Yours eg uses call by value.
I don't know any fancy parsing framework library, but if I may suggest something: use libreadline for input. Command history and argument completion makes working in CLI much more comfortable. And you will have working movement and deletion (including backspace). It is a very useful library.
A whole new fad is out there for retro computing and retro computer simulation. CP/M ? Wow. Somewhere the fans of Gary Kildall are cheering. Very cool.
I don't think there is a framework for this. Can you give me an example of the sort of interface you want to implement?
as you wish.
They're aware of that, they say what you are doing is *like* passing by value. Does this example make it any clearer? #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void add(int *x, int a) { printf("add1: x points to %p\n", (void *) x); x = malloc(sizeof(int)); printf("add2: x points to %p\n", (void *) x); x += a; } int main(int argc, char **argv) { int i = 0; int *x = &amp;i; printf("main1: x points to %p\n", (void *) x); add(x, 7); printf("main2: x points to %p\n", (void *) x); printf("x = %d\n", *x); } When I run it I get: main1: x points to 0x7ffc457c1214 add1: x points to 0x7ffc457c1214 add2: x points to 0x5632e05e7420 main2: x points to 0x7ffc457c1214 x = 0
could u use a simpler example, this is difficult.
When you call your `add` function, `t` is set to the address of `s`, so it is pointing at `s`. However when you run `malloc`, `t` is then pointing at a new location. When the `add` function returns, that location is lost, as `t` is local to the function - what you have here is a memory leak. Passing pointers to functions like this is fine if you want to change the value that it points to, but if you want to change where it actually points you need to pass a pointer to the pointer. e.g. void add(struct student **t, int n){ // We dereference t and change where that points to. *t = malloc(n* sizeof(struct student)); // add the rest of the function here. Also I've noticed that you've declared `s` globally, so you don't need to pass it to `add` at all, but if you want to switch to not using a global variable (which should be avoided if possible) then the pointer to pointer is what you need.
I guess this is where the difference is. If I used your scenario I would define **salary** as a *component structure of an employee* and any functions that dealt with salary would receive a pointer to a **salary** structure versus a pointer to an **employee**. There may be different implementations of the salary function that vary based on the employee type but all would simply accept the **salary** structure as the input. So the employee type is simply the discriminator for deciding which salary function to choose. **Type** in this case could be something as simple as an enumeration that drives a **switch** statement or a function pointer owned by an **employee** structure but if I find myself going down that route I'd likely switch to C++ instead.
I want to enumerate my environment - I have printed some envp\[n\] where n starts at 0, but how can I tell when I run out of environment? - I tried looking for envp\[n\] == NULL, but that ended without listing out the whole environment.
¬¨¬¨A = A
Not only does OpenCL work on AMD and Intel graphics in addition to nVidia, OpenCL also works on Intel and AMD processors -- so your program can run without access to a graphics card, using the same code.
I have modified the code as per your suggestion but now getting segmentation fault.
I forgot about this video. It actually helped me understand how programs work. Now I'm fluent in several languages (albeit, high-level like Java, Python, and C#) because of it
Post the full code again please, we need more context.
It's the same link but here's it's again: [https://github.com/abcool/Training/blob/master/C\_Training/LetUsC/Chapter-19/b-c.c](https://github.com/abcool/Training/blob/master/C_Training/LetUsC/Chapter-19/b-c.c)
Being thread-safe and interrupt-safe (signal-safe) are different concepts. If a function might receive a request X while request Y is in process, it must be allowed to do at least one of four things: 1. Delay the processing of X until Y is complete 2. Suspend the processing of Y while it processes X 3. Nullify any work on Y that would conflict with X, and redo it after processing X 4. Cancel the processing of X in such a way that it can be retried after Y is complete. If a function only needs to be thread-safe, it can use approach #1. If a function only needs to be interrupt-safe, it can use approach #2. Approach #3 will generally require that an environment support some atomic operations, though the required set will depend upon the task to be done. Approach #4 will require the cooperation of the client code. No single approach will be practical in all cases. Tasks that can be accomplished efficiently using approach #3 can be processed without having to know or care about any relationship between X and Y, but there are many tasks for which approach #3 would be impractical unless an implementation knows about the relationship between X and Y, or might be impractical even then. And approach #4 will be useless if one needs to support an API whose clients won't be designed to accommodate it. If a library's API can be designed in a way that will fit approach #3 on all platforms of interest, such a design will avoid any need for the library to know or care about any threading or signalling mechanisms in the underlying environment. If that isn't practical, the library should generally let the client pick one of the other approaches or, failing that, at least document which approach it's going to use.
I remember reading the Network Guide in 2002! And I still refer back to it because it's easier to understand than stuffy Official Docs :P
Good clean succinct informative article, about something useful I didn't know existed! I'm so glad I came across this today.
The answer here (https://stackoverflow.com/questions/46073295/implicit-type-promotion-rules) is pretty thorough, in particular the section on "The usual arithmetic conversions" covers this. For any operator that takes 2 operands, (basically) the smaller one will be promoted to the size of the larger one. So in the case of the specific example you gave, because `n` is (presumably) an `unsigned long long` under the hood, the integer constants will be promoted to that type before the operator is evaluated. The problem with `(1 &lt;&lt; 32)` is that, by default, constants like that are `int`s, and if `int` is only 32 bits then left-shifting by 32 is undefined. (You should turn on the maximum warning level your compiler supports; this sort of thing should be flagged.) THAT said, if you find yourself doing this a lot you should probably write some macros that explicitly cast everything the correct way. So rather than `(n &gt;&gt; 32) &amp; 1` you'd have something like: ` #define UPPER_WORD_OF_UINT64(val) ((((uint64_t)(val)) &gt;&gt; 32ULL) &amp; 0xFFFFFFFF) #define LOWER_WORD_OF_UINT64(val) (((uint64_t)(val)) &amp; 0xFFFFFFFF) ... #define BIT_IS_SET(val, bit) ((val) &amp; (1ULL &lt; (bit))) ... void foo(const uint64_t n) { const bool flag_is_set = BIT_IS_SET(UPPER_WORD_OF_UINT64(n), 0); `
I was gonna recommend my own project, FoundationIO's CommandLineIO, but i'm never adding regex support.
std::String is an even bigger clusterfuck than C's strings. You're truly better off rolling your own.
Yup, then go ahead and use ShellCheck to make sure that no EEE bash-isms sneak in.
CP/M is still the best. ;)
Thanks!
Instead of writing `1ULL &lt;&lt; 32`, you can write: `(uint64_t)1 &lt;&lt; 32` or `UINT64_C(1) &lt;&lt; 32` both of which are more portable because they unequivocally *guarantee* a 64-bit result instead of assuming that an `unsigned long long` is a 64-bit type.
The ecosystem. Git, Make, autotools, testing environment, packaging, deployment, etc..
Note that the parentheses around `(uint64_t)(val)` are unnecessary, so you can simply just write this instead: # define UPPER_WORD_OF_UINT64(val) (((uint64_t)(val) &gt;&gt; 32ULL) &amp; 0xFFFFFFFF) # define LOWER_WORD_OF_UINT64(val) ((uint64_t)(val) &amp; 0xFFFFFFFF) Also, there's no reason to write `32ULL` when the shift amount is an integer. So, this can further be simplified to: # define UPPER_WORD_OF_UINT64(val) (((uint64_t)(val) &gt;&gt; 32) &amp; 0xFFFFFFFF) Finally, since these are returning a result not more than 32 bits in size, you could also cast the final result to a `uint32_t`, e.g.: # define UPPER_WORD_OF_UINT64(val) (uint32_t)(((uint64_t)(val) &gt;&gt; 32) &amp; 0xFFFFFFFF) # define LOWER_WORD_OF_UINT64(val) (uint32_t)((uint64_t)(val) &amp; 0xFFFFFFFF)
I tend to go for overkill with parentheses just for clarity, but yes. Same with specifying ULL on the shift amount (which will get promoted anyway due to the whole thing discussed above). I did consider casting the result back to `uint32_t` but it seemed excessive.
you mean when an entry level job is also looking for non-entry level amount of experience? yeah.... versioning like git or svn testing tools like vector cast, cxx, or similar complex building using make IDE's I mean a lot of this will be company-specific, but the main thing you want to get around is getting an interview by someone who isn't *really* looking for a fresh out of college candidate who somehow also has 4 years of industry experience as well..
Big endorsement for Beej's guide to network programming from me!! Beej rocks!
Well, we usually aren't hiring people who are "C programmers", we hire people who have experience in a given problem area and can write C. Someone who's spent a lifetime writing embedded microcontroller code might not be a great fit if we're looking for someone to help write a high-performance numerical library, or, say, write a compiler for a machine we've developed. As a good baseline, you should be familiar with a professional workflow - version control, build systems, testing, perhaps a scripting language like Python. Beyond that, it's more important to have experience relevant to the actual position.
&gt;For any operator that takes 2 operands, (basically) the smaller one will be promoted to the size of the larger one. That doesn't apply to `&lt;&lt;` and `&gt;&gt;`. OP's original code is perfectly fine and does not need obfuscation with a bunch of dangly bits or obscure macros.
Note: The `32` in `&gt;&gt; 32` doesn't get promoted to `32ULL` because the shift amount is an integer. In fact, if you write `&gt;&gt; 32ULL` it's gotta down-promote that 64-bit value of 32 to a 32-bit integer value of 32, somewhere under the hood, before it takes the lower 6 bits.
X=2 is an assignment. X==2 is a comparison. 2 is non-false, so you go into that ‚Äúif‚Äù (not the else).
I would suggest your not cut out for programming.
Thanks for the help! However I‚Äôm lost because I thought we were assigning x to 5, so when it says if x=2 then ‚ÄúThis is true‚Äù but it is false because it is actually 5. I need direction as to where I‚Äôm getting confused because I also don‚Äôt get why ‚Äúthis is all folks‚Äù gets executed as well. Sorry I‚Äôm a beginner with the whole programming.
It's an assignment not a comparison. After the code runs x will be equal to 2. &gt;‚Äúthis is all folks‚Äù gets executed as well This gets run because the if else block without brackets only refers to the very next line, and the rest of the code is executed.
Piece by piece: `int x = 5;` &lt;- assigns `5` to the integer variable `x` ` if (x = 2)` &lt;- evaluates the expression `(x = 2)` and continues to the condition if so. `(x = 2)` &lt;- assigns the integer variable `x` to the value `2`. Assignments are expressions, and will be evaluated to the result of the assignment. So this will perform the assignment and evaluate to `2`. `if (2)` &lt;- the result of the expression is nonzero, so we will continue to the `if`'s success case. Since no curly braces are used, the case may be composed of only a single statement. `cout &lt;&lt; "This is true!" &lt;&lt; endl;` &lt;- does what you'd expect `else` &lt;- since the `if`'s success condition occurred, the `else` case will NOT be executed. Since no curly braces were used, the else case may only be a single statement. `cout &lt;&lt; "This is false!" &lt;&lt; endl;` &lt;- this is a single statement, which belongs to the `else`. It will NOT be executed. `cout &lt;&lt; "That's all folks!" &lt;&lt; endl;` &lt;- the previous statement closed the else case. This statement is therefore NOT part of the else case and will be executed *regardless* of the result of the `if`.
Contrast: `if (x=2)` vs. `if (x==2)` As for your second question, if/else doesn't have curly braces around the blocks, and indentation isn't meaningful in C++ (unlike e.g. Python) so only the first line after the `else` is actually inside the `else` block. The next line is not nested under the `else` so it gets executed unconditionally.
I'm asuming one of the other options i This is true! This is all folks! which is the correct answer. The `This is true!` bit comes from the fact that `x = 2` is not a comparison, but an assignment (which evaluates to the assigned value), which is not-`false` in this case (usually values which are equal to zero are also equal to false) The `This is all folks!` comes from the fact that both the then and else statements portions of the if-else statements are not blocks (i.e. not wrapped in curly-braces: `{ }`), and so only cover the one statement in those branches. the `cout &lt;&lt; "That is all folks!" &lt;&lt; endl;` is part *not* part of the else statement, and is executed regardless of the condition.
= Is an assignment operator.. 'if' condition evaluates the statement within the bracket and will execute its corresponding block if the statement is non zero. x= 2 evaluates to 2 =&gt; Non zero. So the true block gets executed. Also in C, an if statement without { brackets can have one expression in its block at max.. Since the else block doesnt have a {}, "Thats all folks" part is completely outside the jurisdiction of if and else..
x = 2 is always true, because you're assigning 2 to x, you're not checking its current value. You could see it like the computer saying "x is 2. Ok". That "ok" is the return value, which is true. Therefore `if (x = 2)` is always true, and the program will skip the else statement. Had it been x == 2, then it would be different. == is the comparison operator, so in this case the computer's thought process is "is x 2? No". No means false so the execution would jump to the else statement.
"This is all folks" gets executed simply because it follows as the next instruction and it is important to note that it is not part of `else` because there are no brackets , therefore it will always print in either case. If "This is all folks" would be enclosed between brackets in the `else` alongside "This is false", then both of these would only print when the statement is false. Hope I was clear enough not to get you confused.
x is *initially* assigned the value of 5, but that is changed in the if statement, which sets x to 2, and then evaluates x in a Boolean context. Since x is nonzero, it is considered "truthy". This isn't the sort of code one should ever expect to see in the "real world", since it is misleading unless one pays close attention. It's used to point out two things: the distinction between the assignment and equality operators, and that only the first statement after a controlling statement (if, else, for, while) is associated with it (unless curly braces are used to group multiple statements together).
Thank you so much for breaking it down for me. I understand now that if no curly braces are used then the else statement is only the following line. üôåüèΩ
you're mixing the operators `a == b`, which evaluates to `true` if a and b are equal, or false if a and b are not equal, with `a = b`, which assigns the value of the left hand side (b, here) into the right hand side variable (a, here). The expression `a = b` also evaluates to a value: it evaluates to the value assigned to the variable. In this question, they are using the assignment operator (`a = b`) in the conditional expression *not* the equality operator (`a == b`). So here, the expression `x = 2` first assigns `2` to variable `x`, and then evaluates to the value `2`. In C and C++, any value other than '0' evaluates to true in a conditional. For example: #include &lt;iostream&gt; int main() { int x = 2; if( x ){ std::cout &lt;&lt; x &lt;&lt; " is a 'truth-y' value" &lt;&lt; std::endl; } else { std::cout &lt;&lt; x &lt;&lt; " is a 'false-y' value" &lt;&lt; std::endl; } } prints "2 is a 'truth-y' value" ([see on TIO.run](https://tio.run/##hYxBDoIwFET3PcUEF8CCjUus3qVpP9qkFEJ/icZw9trvAXQzyZuZPLuuw93aUtTJRxuyI2i/JN7IzDflI2M2PnY93goQfOKK80Vg6ir00gOJ3TjaJTO0rm2NBj7BoOUt82N4tdhNyNTI9D1TdEE0Bygkwj/NZOrrl0YdpXwA)) but #include &lt;iostream&gt; int main() { int x = 0; // Notice that x is now zero if( x ){ std::cout &lt;&lt; x &lt;&lt; " is a 'truth-y' value" &lt;&lt; std::endl; } else { std::cout &lt;&lt; x &lt;&lt; " is a 'false-y' value" &lt;&lt; std::endl; } } prints "0 is a 'false-y' value" ([see on TIO.run](https://tio.run/##hYxBDoIwFET3PcUEF8CCxDVW79K0H21SCqG/RGM4e@33ALqZ5M1Mnl3X4W5tKerkow3ZEbRfEm9k5pvykTEbH7sebwUIPnHF@SIwdRV66YHEbhztkhla17ZGA59g0PKW@TG8WuwmZGpk@p4puiCaAxQS4Z9mMvX1S6OOUj4)) Because of this, in the question, the expression `x = 2` evaluates to true, and so the then-statement (`cout &lt;&lt; "This is true!" &lt;&lt; endl;`) is evaluated, and not the else-statement.
So apparently the shift operators will promote operands smaller than `int` (which can do some "fun" things) but they don't compare the operands to each other like, say, `+`. Which makes sense when you think about it. Having worked for years in a large C codebase that did a LOT of shifting and masking, abstracting those sorts of operations with nicely named macros or functions makes a huge readability difference IMO.
If you're talking about a macro to , say , convert 4 chars to a 32-bit word, then yeah; but OP's code is simple and clear as-is whereas if it were a macro the reader would have to take extra time checking the macro definition to see what it actually does and verify that the macro isn't bugged.
Not only the else statement. This works with every if statement-else-loop-whatever. Generally the rule is this: you can put as many lines of code as you like between curly braces. If you don't use curly braces, then only one line of code is permitted
/r/cpp_questions
&gt;Is someone downvoting every comment here? No, just yours... try `if (x = 0)` to see the problem with your first paragraph.
Apologies if this isn‚Äôt the appropriate community to post C++ questions. Any suggestions where I should ask my questions? I‚Äôm a beginner trying to improve my programming.
&gt; OP's code is simple and clear as-is Again, having worked on a codebase littered with this stuff for years, we'll have to agree to disagree on whether clarity is improved. Replacing magic numbers/expressions with `#defined` constants/macros is almost always recommended as a good coding practice. &gt;the reader would have to take extra time checking the macro definition to see what it actually does ...no? That's why you name things so it's clear? Or, at worst, you check once and then you know? &gt;verify that the macro isn't bugged By this argument you should never abstract anything into functions or macros for readability because the implementation might be wrong. This is a very silly argument. What I'm recommending is also better for testability because you can write one set of unit tests for the macros/utility functions to prove to yourself that they are correct. Rather than having to test every place where you check or twiddle bits to be sure you copy-pasted/typed the code properly.
Strictly speaking, it might not even be the whole next line: if (0) puts("this won't print"); puts("but this will"); Statements are *usually* 1 per line, but the semicolon is the actual delimiter. Because of this, it's possible to spread a statement across multiple lines, or cram multiple on to the same line.
Line 2 Y = 1 + 1 3rd line X = 1 + 2
y = y (1) + z (1) so y = 2 x = x (1) + y (2) so x = 3 then you have a ternary operator. It checks the condition, here x &lt; y and if it is true, it returns the first expression, otherwise if false it returns the second expression. x &lt; y is false, so x is returned, and x = 3 so it will print 3.
It's not the right Reddit, sorry :) See the side bar. You will probably want to post in /r/cpp_questions
I think someone is. Both of mine got hit.
Thanks !!
Such as: #include &lt;iostream&gt; using namespace std; int main() { int x; if( x = 0 ){ cout &lt;&lt; "x = 0 triggers 'then' statement" &lt;&lt; endl; } else { cout &lt;&lt; "x = 0 triggers 'else' statement" &lt;&lt; endl; } } which prints "x = triggers 'else' statement"? and also: #include &lt;iostream&gt; using namespace std; int main() { int x; if( x = 2 ){ cout &lt;&lt; "x = 2 triggers 'then' statement" &lt;&lt; endl; } else { cout &lt;&lt; "x = 2 triggers 'else' statement" &lt;&lt; endl; } } which prints "x = 2 triggers 'then' statement"? Not sure what the problem is with their first paragraph...
I think a point of confusion is that given an expression like `short1 + unsignedLong1`, the left side will be *converted* to type `unsigned long`, but only *promoted* to type `int`. This confusion is compounded by the fact that the Standard specifies that `&lt;&lt;` and `&gt;&gt;` promote both operands, rather than just the left. So far as I can tell, the only situation in which promotion of the right-hand operand would have any effect would be if the right hand operand were an extended signed integer type which could represent a value that `int` could not, but had a rank lower than that of `unsigned int`, the value of that operand was negative, and the bit width of the left-hand operand was greater than the promoted value of the right-hand operand. For example, if `INT_MIN` was -32767 and UINT_MAX was 65535, but the minimum value of type `__xint` was -32768, and if type `__reallybig` was 65536 bits long, then given `__reallybig x = 1; __xint y = -16384;` the expression `x&lt;&lt;y` would be defined as shifting left by 49152 bits, despite the non-promoted value on the right-hand side being negative. Theoretically possible, but it's exceptionally unlikely that any non-contrived implementation meeting such criteria will ever exist. Are there any other situations in which the promotion of the right-hand operation would be meaningful?
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
I almost only ever use it with std::vectors and std::maps. It's fine with those. I have a reasonable facility with old school string handling using the C library. I usually have to use sprintf() anyway, to get things formatted in a consistent way :) This is all instrumentation data. One of my coworkers established a tail-recursive method for producing JSON from a data regime with a couple hundred struct declarations ( we'd have them as classes except for reasons I won't bore you with here ) and *that* uses the heck out of some of the advanced features. Now that was worth it - you can dump otherwise really ugly binary data to text files and grep them.
Maybe it just reflected common implementations; the integer promotions correspond to storing a value in an int-sized register.
According to their first paragraph `x = 0` would trigger `then` statement
\&gt; Maybe it just reflected common implementations; the integer promotions correspond to storing a value in an int-sized register. &amp;#x200B; Unless the left-hand operand has more than \`INT\_MAX\` bits, which seems unlikely, I would think that specifying that the right-hand operand is converted to an unsigned type whose precision is sufficient to accommodate values up to (bit size minus one) but is otherwise unspecified would be more intuitive. It would also make it very easy to support the popular extension of treating an exact word-size shift as, at worst, choosing in Unspecified fashon between the unaltered value of the left-hand operator, and the result of shifting the left-hand operator by one bit, (bitsize) times. No useful purpose is served by requiring that expressions like \`(x&gt;&gt;y) | (x&lt;&lt;(32-y))\`, which would work equally well under either interpretation, be replaced with more complicated forms that avoid the word-size shift. &amp;#x200B; Of course, it should be noted that the authors of C Standards have a term for actions which should generally be expected to be processed in consistent and efficient fashion, but that some implementations might not be able to handle efficiently and predictably. Since people writing quality implementations that could efficiently and usefully process them in normal fashion wouldn't need the Standard to tell them what to do, there was no need to have the Standard impose any requirements. Hence, such actions invoke Undefined Behavior.
Are you trying to parse command line options, or are you trying to create a console/shell for your router? If it is the latter, I would recommend using a parser framework like [lex/yacc](https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.bpxa600/bpxa613.htm) or [ANTLR](https://www.antlr.org/). As far as regular expression support, you can use grep as a library within your program.
Basically, you need to do this: 1 + 1 = 2 1 + 2 = 3 Since the last variable initialized with the last value is y.
For early level jobs, just focus on algorithms and general programming practices. Work on pseudo code and commenting so you can explain your thought process and what a chunk of code is supposed to do. Practicing unit testing (and maybe test driven development) will help too. Getting a basic understanding of GIT and SVN will be helpful, but I've never really had a job care going in. Makefiles and build tools might be useful, but it's not likely anyone is going to put you in charge of them starting out and you'll more likely just be using the existing ones that no one wants to change. Basically, focus on general programming. You'll pick up enough skills with the secondary stuff to be able to justify it on your resume and/or BS it in the interview. Pick up Python as well. Learning a second language will help make things click. Assuming "Fresher" is the same as "Frosh"/"Freshman" check out the career fairs and career center at school.
Instead of writing `1ULL`, you can (and I highly recommend that you do) write either `(uint64_t)1` or `UINT64_C(1)`, both of which are more portable because they unequivocally *guarantee* a 64-bit result instead of assuming that an `unsigned long long` is a 64-bit type. To answer your final question, the cleanest way to write it is: const uint64_t t = (n &gt;&gt; 32) &amp; (uint64)1; or const uint64_t t = (n &gt;&gt; 32) &amp; UINT64_C(1); Note that the shift amount is always simply an integer, so it's perfectly safe to write just `32`.
1. Your queue can hold only 32bit unsigned integers. 2. Your queue has fixed size. 3. Your queue silently discards element when full on enqueue. 4. Error handling is non-existent in your code. 5. Source tree is a mess, but I suspect it's just prepared for more stuff in the future. Generally, you have made a very limited and trivial queue, that most people won't have a use for. Things to consider: linked lists, void pointers, error handling. Linked list will allow you to create queues of any depth (that can be artificially capped). Void pointers will add support for any element type (users have to cast it to whatever they want), including structures. Error handling is pretty obvious and I can't stress that enough - HANDLE ERRORS IN C, especially in a library! :D Good start.
Except for `cout` everything else is valid C, so no worries. However, please direct your potential future questions to the correct subreddit. C++ is a superset of C and many things are different.
 &gt; `char delimiter[1] = "\n";` This is incorrect. The string requires two characters of memory &amp;mdash; the newline character and a null character &amp;mdash; but you are using it to initialise a single-character array. Use one of these instead: char delimiter[] = "\n"; const char delimiter[] = "\n"; const char *delimiter = "\n"; instead. Note also that `strtok` modifies the string being tokenised, so only the first of these forms would be appropriate for initialising `names`.
Good catch and explanation!
First of all, your code is C++, so you're in the wrong subreddit. Try /r/cpp or /r/cplusplus Second of all, you can't compare strings like this: Line 28: if (_character.substr(y, 4) == "....") You should be using the `strncmp` function from `string.h`
Ahhh ok cool üëç, and sorry for posting in this sub-reddit, thought it included c++ and other c based programs as well, will keep that in mind for next time
/r/cppquestions may be better. I think /r/cpp is more for news. Anyway you can compare strings that way in c++ =)
At a glance, I see a number of issues. Line 14 does nothing. It calls a function that returns a bool but does not capture the return value. That should be in an if statement. And the stream it self can be checked as a bool like this: if(!morseToAlpha()) /* error handling */ Also, a main issue is the order of you if statements. Think about it, L is ".-..", but before that, you check for "e" which is just ".". Since you are checking substrings, it will match that. I would say match longest to shortest, but i believe that is why you are aborting due to substring out of range. An easier approach would be to build a new string at the beginning when you are looking for a space and then just compare against full strings. Something like this for lines 20 to 27: std::string temp = ""; while(x &lt; _character.length() &amp;&amp; character[x] != " ") // [] is cleaner and faster than at function temp += _character[x]; Then you can just do `if(temp == ".")` and avoid substr.
I we'll take those suggestions into consideration. Linked list are the next data structor to be released but I should fix the queue first since you made a list of things for me to work on. &amp;#x200B; Can you explain the fixed size part? Can you explain the miss in the source tree? Is there anything wrong with the priority queue? &amp;#x200B; As for stuff in the future, this is my current map so far for the actual library: Library map for Collections: retro-squid/collections/list retro-squid/collections/map retro-squid/collections/array retro-squid/collections/queue retro-squid/collections/stack This may change.
Does that mean x = 0 returns 0, which is false? In that case, I stand corrected.
What does '?' and ':' do in C? It's been a few years since my classes and I never use C, l'am having trouble remembering.
`A ? B : C` is the same as `if ( A ) { B } else { C }`. Try remembering "ETF" - "expression ? true : false".
C++ is off topic in this subreddit. Post C++ questions to /r/cpp_questions instead.
C++ is not a superset of C and thinking about it that way generally makes you a poor C programmar and a poor C++ programmer.
&gt; This is incorrect. The string requires two characters of memory ‚Äî the newline character and a null character ‚Äî but you are using it to initialise an array of only one character. Actually it is correct. If the array is as long as the string literal without the trailing NUL byte, no NUL is appended. I use this all the time, for example, to translate hexadecimal to decimal: static char hextab[16] = "0123456789abcdef";
C++ is off topic in this subreddit. Please post C++ questions in /r/cpp_questions instead.
C and C++ are entirely different languages. While they share a common ancestry, the way they are used differs a lot and advice that is good for one is generally not good for the other. This subreddit is for programming in C, not for any other language.
Well, I never claimed to be good programmer in either of those languages. That does not change the fact, that C++ is a superset of C. No matter what you personally think about it.
Sure, but that's not going to work if you try to pass that so-called "string" to `strtok`. I scary-quote string because `hextab` can't actually be used as a string.
That is correct!
[No it does not](https://stackoverflow.com/a/31505447/417501).
Yes, it means that.
&gt; Can you explain the fixed size part? Your queue is created with a preallocated array and there is no function to change its size (it's not growable) . This can be a problem in situations, where you don't know what will be the enqueue and dequeue rates. Fixed queue depth is useful in some cases, but should be an option. &gt; Can you explain the miss in the source tree? You really only need one subdirectory for sources, with different file names for different things, like "list.*", "stack.*" etc. &gt; Is there anything wrong with the priority queue? To be honest, I haven't looked there yet. GitHub is terrible to read on the phone. I will check it when I'll sit in front of a bigger screen. &gt; [...snip... a portal to the future] Almost all you have listed as future plans is usually made with linked lists as a base. The exception is array... I think... I don't know what will be there, since arrays are part of the C type system already. Normal (unidirectional) linked lists are used for LIFO queues. Doubly-linked lists (bidirectional) are used for FIFO queues, maps (with collected collisions... I forgot how they were called), lists etc. I would start with lists :)
If you want to be **this** precise, then even if some things are slightly different, other remain the same and thus it's still a superset. I know what you want to say and I would agree with you if my comment was encouraging OP to write pure C in C++. It's not. But thank you for clarifying.
I was recently job-hunting and gave a few tests of companies requiring experience with C. These were the things they look for: - basic syntax knowledge - basic data structure knowledge - can use pointers properly - good grasp of arrays and string manipulation - familiar with advanced concepts like structs, unions, function pointer - knowledge of the underlying assembly and hardware is a plus This is just C knowledge, however you need to know more than that. Have a good grasp on version control, build tools like make and cmake, scripting languages like python or go. The requirement is different with every job profile, but all you need to show them is your willingness to learn and ability to grasp new concepts quickly.
I still have a soft spot for real-mode x86. The segmented architecture works really well if one uses a memory allocator which is based on ranges of 16-byte chunks, but otherwise has code treat each object as a range of up to 65536 consecutive bytes within a single segment. If one uses such an approach, relational operators on pointers won't form a global transitive ordering like they do on other most systems, but casting pointers to unsigned long and comparing those will yield a global transitive ordering (while a pointer to 0x1000:0x2FFF would compare below a pointer to 0x1100:0x1FFF, despite identifying the same storage, a chunk-based allocator wouldn't allocate any segments below 0x1300 if offsets up to 0x2FFF were used in segment 0x1000). &amp;#x200B; That having been said, CP/M is cool too, but MS-DOS provided the cleanest expansion I've seen of a 16-bit architecture beyond 65536 bytes (the 68000 is a 32-bit architecture).
I believe the /Za flag should do it. More info here: https://docs.microsoft.com/en-us/cpp/build/reference/za-ze-disable-language-extensions?view=vs-2019
\*t + i
I am amazed that \`expect\` is the top builtin in their corpus. \`libc\` or some other extremely popular library must rely on it.
please explain.
Some general things: * basic C style string manipulation functions like `strcpy`, `strcat`, etc should generally be considered harmful because they're so easily exploitable. `strn*` functions are better, but still suffer from being able to blow past your buffer sizes. `strl*` functions should be preferred if your C library supports them. * if you're passing array like things around (like c strings) you should *always* pass the length of the buffer as well so that you aren't operating past the end of the buffer. * more comments aren't necessarily better. They should generally tell why you're doing something, rather than what you're doing (unless it's very not obvious). F.ex, in `if(n &lt; 0) n = -n`, it's obvious what is happening and doesn't need the `/* make n positive */` comment, but without studying your code I don't know why it's happening. * You can refactor `compress` to not need the extra lines after the for loop which is more or less exactly what you're doing in the for loop * you only need one loop counter in reverse since `j` is just `strlen(s) - i` * This is a personal preference (but IMO objectively better), but you should *always* use braces for single line control flow statements even though they're not necessary. * you should test for corner cases. f.ex, you will segfault if the original string is NULL, or malloc fails (which is quite unlikely, but still possible). If passed an empty string, compress will act indeterminately because it's invoking strlen on uninitialized data.
still doesn't work even after replacing &amp;(\*(t+i))-&gt;roll\_no) by &amp;(\*t+i)-&gt;roll\_no) and (\*(t+i))-&gt;name) by (\*t+i)-&gt;name).
t points to pointer, so t+i does not reach into i'th record, but i'th pointer. \*t points to records, thus \*t + i. There's an extra s in the scanf format too, and a missing leading blank to eat previous newline.
found solution. made space between " and % and code works. C is strange.
You have an array of records, use dot. (\*t)\[i\].member would be easier for eyes.
Thanks for the \*t hint. It really worked. The book I am following doesn't use \*\* or \*\*\* approach.
I'm just going to comment on one issue - unnecessary calls to`strlen`: In `reverse` you call `strlen` repeatedly, in a loop, instead of calling it once and saving the value in a local. This is especially pointless since the length isn't changing. But even your loop was changing it, you should just update the length rather than call `strlen` again. `strlen` loops over the entire string looking for the terminating `Nul`. Doing this over and over again is how you turn an O(n) algorithm into an O(n^2) algorithm. And in the case of compression you'd be expecting to operate on large strings... (and while you're fixing `reverse` do what /u/ferraristealer said and use just one counter). Note: Less of a performance issue, but `compression` also calls `strlen`, in its loop, a second time on `buffer`whose length should be unchanged _and_ you've already got the value cached away in `lenbuffer`. And then the same thing again after the loop.
Pretty much. There are others (and a lot of C++ ones) but GTK is the go to. - [List if Wdget Toolkits](https://en.wikipedia.org/wiki/List_of_widget_toolkits)
I haven't used it myself yet, but [libui](https://github.com/andlabs/libui) looks promising.
Fixed the code. Thanks guys.
One more help. I have updated the code in the link. Now records are written in binary mode to a file. Now I want to sort contents of file by name using a function that takes only file pointer as parameter. There are two problems: 1. This function has to calculate number of records in file. 2. sort these records by name. How to proceed with this? Any ideas/suggestions?
I tried that, but it doesn't seem to work properly. It allows me to declare variables anywhere, when c89/90 only allows variables to be declared/defined at the start of a block, so their article is pretty much false, unless I'm doing something wrong.
I wonder exactly if they count the same lib being used over and over again, or what repos are being counted here. Did they count gcc and clang and it's myriad of tests? Did they count the thousand different libcxx and libc's? Did they count chrome?
MSVC doesn't conform to any strict C standard, it only really cares about conformance with C++ standards. So you're out of luck if you want something like -ansi -pedantic-errors
Depends on what you're doing. If you're looking for something where you want to match look and feel of the OS, yes, GTK is a good solution, though it's vast and complex. [libui](https://github.com/andlabs/libui) is a nice emerging alternative. At the other end of the spectrum, if you're doing something like a game where you need a completely custom UI and you just want something that can do the legwork of button events, text inputs, etc, I like SDL and [kiss_sdl](https://github.com/actsl/kiss_sdl).
For one, you've misspelled printf, so the compiler can't find the definition of that function. &amp;#x200B; In the future, please post actual code, not images of code.
&gt;strl\* functions should be preferred No they really shouldn't strlcpy as it's still a mess as it does strlen(src) for any len e.g. strlcpy(dst, src, 2) will read ALL of src and not just 2.
[nope](http://cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/lib/libc/string/strlcpy.c).
If I'm restricted to pure C, probably. &amp;#x200B; If you are not dogmatic about avoiding C++, I would consider Qt, which is my preference for writing cross-platform desktop UIs. It's quite well-engineered and the SDK and documentation are very solid, and it provides a lot of useful stuff for building your application aside from the GUI.
[IUP](https://www.tecgraf.puc-rio.br/iup/) for native GUI. [Nuklear](https://github.com/vurtun/nuklear) for non-native GUI. Both provide pure C APIs. GTK is best on Unix desktops, but not so good on Windows, Mac, iOS, Android, etc. IUP has a GTK backend for Unix platforms, but also has other backends for the other platforms.
OK, I looked into your prio queue. It looks OK (assuming it works), but few things are worth mentioning: 1. `#include "pqueue.h"` but there is no file `pqueue.h`. 2. In function `createPQueue()`: a) `SqdPQueue pqueue = (SqdPQueue)malloc(sizeof(* pqueue));` should be `SqdPQueue *pqueue = (SqdPQueue*)malloc(sizeof(SpdPQueue));` and don't typedef `SpdPQueue` to a pointer (pointers should be explicit); in C11 you may omit the cast, but many people still use it... including me :D b) `else` is not needed - `pqueue` at this point is NULL and next line is `return pqueue`. 3. In function `dequeuePriority()`: a) line `(*head) = (*head)-&gt;next;` does not need parens around left-side `*head`, b) `free((void *)temp);` does not need a cast. 4. In function `itsEmptyPriority()` the name should be `isEmptyPriority()` - it's more grammatically correct for a function returning "boolean" and this form is widely used. Also, comments like "end of ..." don't help and don't provide any relevant information, but make code look more messy. I suggest not making them. Keep it up! :)
Putting a struct in the .c file makes it hidden from things that include the header. Putting it in the .h let's outside code use it. It allows for hidden implementations.
What do you mean by "hidden"? As in only the source code file that declared the struct can use it?
They‚Äôre not equally valid, only one of them actually defines the struct. If your external code needs to use the struct as anything more than an opaque handle, it needs the definition.
Afaik libui doesn't have any accommodations for accessibility, which is something to keep in mind.
A too short example to give an answer. Could you give a code in which you're using this function? And please format it using the code tag.
How do I use the code tag. It's not too short. If I replace the message variable with a string literal it works, otherwise a segmentation fault.
It's too short because we don't know what input makes it fail
Good point. It crashed when the \n was in the string but it ran when it was absent
So it seems to crash whenever the delimited is actually found...what is up
In C's model of compilation, each source you build is compiled independently. Different compilation units have no idea about what's in the other compilation units, unless you tell it, usually by including its associated header. If your compilation unit only has an incomplete definition for a struct, you can have a pointer to it, but you can't instantiate the struct or dereference that pointer.
&amp;#x200B; You should use this button.
You should use 'Inline Code' button.
If newline character absences you get NULL as function return value, so I think that's a reason for crashing.
Actually using a pointer to said struct as a handle, no? Because using the struct itself would require knowing the size of the struct.
Start code block with a newline then indent each line by 4 spaces then newline to end the block
Screenshot the documents directory
If the struct is used in other source files or it is passed to or returned from the functions in the .c file, I put it in a header. If the functions in the .c file use a struct but don't take it as an argument or return it, the rest of the program doesn't need to know the details and I put it in the .c file. It will just get compiled into the object file and work and the linker doesn't need to know about the internal details to link the project.
Something on worked on recently. There is a standard set of functionality I want to include in my program, think of program wide settings or an "event" type of object that holds information of the event that is started/stopped in the program. So I create a .c file with how things will occur, what information I want access to, how I access that information, how information is returned - so on and so forth. Once I create that file, i do intend to have a need to go back and change anything (mainly because it's a very simple implementation). So I create a header file with the forward declarations of the structs, and function calls that provide a pre-defined level of access to the information. &amp;#x200B; This helps with the following situations: 1. You can provide the above file as an object and a header, protecting/obfuscating your code, and give a definition for what each function does. Someone else can use your library but cannot claim it as their own without admitting they don't have the source code for it 2. Someone else comes in to maintain/modify your code. You can either provide an environment where only certain parts can be worked on and need to be compiled with the object file as described above, or if they're working a bit more closely, you can let them known that the library itself should not be changed - which can help narrow the scope of the code to be maintained or prevent someone from modifying something that could break older/legacy code that currently works as intended. 3. Prevent yourself from shooting yourself in the foot. If you pre-define everything to a level where the library is robust and provides limited, but direct/concise access to the struct. You won't have to go digging through all of your library code to find a bug but rather the code that's using the library. 4. Organization &amp;#x200B; &amp;#x200B; On the other side of the coin, I'm also programming a GUI in which there will probably be a few different C files in the end all working with commonly shared data. There will need to be a shared struct for the current state of things spread between all the files, and there is no telling what level of access each file might require. Rather than write a function that allows access for every given situation, it might be better to allow direct access to all the information and instead make sure that each GUI file is going to make attempts to read/write to that struct in a safe manner.
Probably not what you want to hear but I sincerely reccommend using mingw if you want to use the command prompt. Nuwen's "distro" is literally a folder of binaries that you add a path to and then your done. No need for the complicated mess of making a Linux system in windows like the other mingw's.
I would have like to try Qt a bit more, but ended up with GTK on a raspberry pi. &amp;#x200B; The learning curve wasn't terrible and programs like Glade can help speed up the process a bit. I've not seen very good tutorials on GTK as a whole, but rather lots of tutorials on the finer aspects of it - so once you get past the initial part, it starts to make a lot more sense.
What does `dir /w` say in that directory?
With what arguments do you call `func`?
Staying in C? Use GTK. Willing to do C++? Use Qt.
&gt; Directory of C:\Users\myname\Documents &gt; &gt;[.] [..] &gt; 0 File(s) 0 bytes &gt; 2 Dir(s) 862,114,725,888 bytes free Idk if this means that the Documents file accessed by windows file explorer isn't the same as the one accessed through cd Documents, or what.
Well the message variable, its defined as char* message. And I supply it simply with a string literal...double quotes...
Yea, I'm going to stay in C for awhile, until I properly understand the language, syntax is not enough :) GTK it is!
I have a some GTK repos if you would be interested in looking at them
Well, that's your problem. `strtok` places a NUL byte into the string it receives to mark the end of the current token. String literals are not writable, causing a crash. For the next time, put the exact code you use to call your function in the question. This would have saved you two hours of waiting.
Sure thing!
Tonnes of projects use it for likely `likely()`/`unlikely()` that are supposed to improve code layout for static branch prediction. If the Linux kernel is part of their corpus then that's a gigantic number of uses already.
I think the bigger issue is addressing the non-null terminated "string" being passed to functions that (generally speaking) rely on the "string" to have a null-termination in it. Null terminate it, and you're not going to have a problem using these functions. That's why documentation states undefined behavior is the source is not a pointer to a null-terminated string. &amp;#x200B; If we're worried about overflow and such, we should be using `strcpy_s` or `strncpy_s`? as these will call `strnlen_s` which will ultimately be limited to the count parameter and not the actual size of the source string. But again.... that null-termination. &amp;#x200B; In regards to the program, it's not an issue because the source "string" is a constant, known source. If it was accepting user input, we would then have a problem. &amp;#x200B; If the requirement/constraint is to be accepting user input, or strings with unknown termination.... Then the solution has to change quite a bit to account for that. Given the original requirements, this is not an issue with the solution so much as it is a problem with the requirements.
I use the latter method of building compound types. The purpose is so that if I decide to reorder the structs or add new fields or whatever, I can without breaking the ABI. in order to support that form, you need to create setters and getters and init and deinit functions as well, but honestly it's not that hard it's really just tedious, but only takes a few minutes to do.
OpenMP 5.
Perhaps `rl_clear_history()`?
Tried it but no luck.
GitHub.com/tristan957 has 2 repos called tllt-cp and harvest-almanac. The second repo is the one I'm currently working in. It's my newest project.
I will say that GTK is a bit more difficult to work with. While I know you want to stay in C, I would recommend getting your feet wet with GTK using Python (PyGObject) first instead.
I don't think mingw makes a Linux system in Windows, I think that's cygwin. Mingw just installs tools like GCC etc. I already have gcc, but I wanted to use Microsoft's compiler since it's for Windows, but I suppose it doesn't matter right now.
`o_addr` is `static`. This means the `=0` is only applied the first time the function is called, and in future the variable will retain its last value from previous calls to the function.
&gt; o_addr was initialized to 0 Yes, but that initialization happens only once at program startup. It has `static` storage duration.
You could compile your code with multiple compilers for the extra diagnostics
I know it's not really a solution, but have you considered trying [linenoise](https://github.com/antirez/linenoise) instead? It doesn't seem to have any leaks for me, aside from being much smaller and cleaner than readline.
Have a look at this piece of documentation. Probably it is what you are looking for http://valgrind.org/docs/manual/manual-core.html#manual-core.suppress
Thanks for the answer. But how can it insert into fixed size arrays anyways?
Yep. Readline is messy. AFAIR it's because it uses terminfo, which does not clean after itself. However, the things left behind are supposed to live as long as program is running and their existence does no harm, apart from making Valgrind angry. They should never leak memory (if you didn't abused the library).
It doesn't insert, it overwrites the first seperator character after the token it finds and remembers what it was. When `strtok` is called the next time, the separator is written back and the cycle continues with the next token.
Thanks for your feedback, the source string is a constant but in case of user input I should watch the null termination char. Question that I will copy in the other answers of the thread: I'm using a char buffer\[20\] to memorize all the digits of an integer in the compression function: is it possible using the max integer to calculate the max length of the buffer like char buffer\[MAX\_INTEGER\_DIGITS \* 8 + 1\]?
Thanks for your feedback, I took reverse and itoa from KR exercises and I didn't note the strlen inside the for cycle. I will include the code after the loop in the same loop. Same Question I posted for the reddit users of the thread: I'm using a char buffer\[20\] to memorize all the digits of an integer in the compression function: is it possible using the max integer to calculate the max length of the buffer like char buffer\[MAX\_INTEGER\_DIGITS \* 8 + 1\]?
Thanks for your feedback, I have not considered to use strn\* for robustness. Normally I pass size of array as parameter but this time I haven't made it. I took reverse and itoa from KR exercises and I didn't note the strlen inside the for cycle and comments useful in the book but redundant in this case. I will refactor compress function and verify corner cases. Question that I will copy in the other answers of the thread: I'm using a char buffer\[20\] to memorize all the digits of an integer in the compression function: is it possible using the max integer to calculate the max length of the buffer like char buffer\[MAX\_INTEGER\_DIGITS \* 8 + 1\]?
Thanks for your feedback, I haven't thought about strn functions instead of str functions for robustness of program. I took reverse and itoa from KR exercises and I didn't note the strlen inside the for cycle and useless comments that in this case are not necessary . I will include the code after the loop in the same loop to erase extra lines. Normally I pass the length of buffer as a function parameter, this time , I haven't made it. Question that I will copy in the other answers of the thread: I'm using a char buffer\[20\] to memorize all the digits of an integer in the compression function: is it possible using the max integer to calculate the max length of the buffer like char buffer\[MAX\_INTEGER\_DIGITS \* 8 + 1\]?
I always enjoy this kind of problems so here's my solution. I would have used goto chains to remove error handling redundancy but that's tabu for a lot of people. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;math.h&gt; char * str_compress(char const * const ori_str) { if(!ori_str) return NULL; size_t const ori_len = strlen(ori_str); char * const char_lkp = calloc(ori_len, sizeof(char)); if(!char_lkp) return NULL; int * const char_count = calloc(ori_len, sizeof(int)); if(!char_count) { free(char_lkp); return NULL; } size_t lkp_len = 0; size_t dest_len = 0; char_lkp[0] = ori_str[0]; char_count[0] = 1; for(size_t i = 1; i &lt;= ori_len; i++) { if(ori_str[i - 1] == ori_str[i]) { char_count[lkp_len]++; } else { dest_len += (size_t)log10(char_count[lkp_len]) + 2; lkp_len++; char_lkp[lkp_len] = ori_str[i]; char_count[lkp_len] = 1; } } if(dest_len &gt;= ori_len) { free(char_lkp); free(char_count); return strdup(ori_str); } char * const dest_str = malloc(sizeof(char) * (dest_len + 1)); if(!dest_str) { free(char_lkp); free(char_count); return NULL; } for(size_t i = 0, j = 0; i &lt; lkp_len; i++) { j += sprintf(dest_str + j, "%c%zu", char_lkp[i], char_count[i]); } free(char_lkp); free(char_count); return dest_str; }
Remember: a static variable works like a global variable, but with local scope.
Thanks for helping but I've abandoned strtok and switch to c++ strings because it would not work no matter what I tried.
Oops, missed that. Thanks
Try /r/cpp_questions instead - this Reddit is for the C language :)
Ok will do
Although this doesn‚Äôt belong in the C sub, let me give it a shot. Just to be clear, the program successfully returns 0 and finishes, but you just don‚Äôt see any output? What may be happening is that the program finishes and closes so fast that you can‚Äôt see the output. Idk what platform you‚Äôre using, but put something at the very end to try and pause the program. You might be able to get away with a system(‚Äúpause‚Äù); at the end of your program (before returning 0) just to see if the program is doing what it should be. If whatever you‚Äôre using doesn‚Äôt allow for that, maybe just put a simple prompt at the end asking if you‚Äôd like to exit (input Y or N) and handle the input accordingly. This will at least stop the program so you can see if it‚Äôs working right before it exits. I‚Äôm not sure if this will help but I hope you get the answer you need!!
Okay thank you, and I‚Äôm using Netbeans. And there is output on the screen, but only the first outputs show up. Everything after the first cin either doesn‚Äôt happen or is invisible.
Does the program get stuck or does it get to finish?
It finishes
Try adding a newline to cans, e.g. ‚Äúcans\n‚Äù. If the compiler made some sort of optimization and turned the two consecutive cout calls into one, stdout isn‚Äôt being flushed. Just a guess. Or use stdbuf to run the program (use -o0 https://linux.die.net/man/1/stdbuf) to disable buffering.
I tried that earlier when I was searching the internet, I tried both the new line and adding a cout.flush() before and after the commands but neither affected it.
I don't know your cout problem, but (5/35) is 0, so lethDose will be 0 regardless of what value Mass has, since anything multiplied by 0 is 0.
 mCans = lethDose / artsweet; artsweet is 0, so the program is crashing here
Yea I remembered that later, my main issue is the missing output. It gives me nothing atm rather than the wrong answer.
Well there is nothing wrong with your code, so the problem is likely that your program is exiting before you can see it. So add a sleep(10); at the bottom before return 0; so it doesn't quit out asap.
/u/jedwardsol has your answer, you are dividing by 0. You cannot use int's to do the work of floats.
Okay thank you I just fixed it and it works. That was a dumb error on my part I knew that. I am curious though as to why it wouldn‚Äôt output the text rather than simply just giving me the wrong answer (aka 0).
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
The program was crashing &amp; terminating. The behaviour of integer division by 0 is undefined. Intel processors, for example, raise an exception which will crash your program.
I just rewrote your code and tested it myself. I‚Äôm getting an error with: mCans = lethDose / artsweet I think it has to do with the types you assigned your variables. I noticed that you assigned them almost all as integers, but are multiplying and dividing them as if they are float or double. You can have ‚Äúlbs‚Äù and ‚Äúcan‚Äù as integers. But ‚ÄúlethDose‚Äù, ‚ÄúMass‚Äù, ‚Äúartsweet‚Äù and ‚ÄúmCans‚Äù I suggest you make as float. In addition, I‚Äôd recommend changing: lethDose = (5/35) * Mass; To: lethDose = ((Mass * 5)/35); Because the original way it‚Äôs written keeps making lethDose equal to 0. The rewritten way basically does the same thing, but works. At least after doing all of that, I got a result (not an error) other than 0. I hope this helps!
It is not allowed to divide by zero; behaviour is undefined if you try. Anything can happen if undefined behaviour occurs, including d√¶mons flying out of your nose.
This, even Linus ditched C for C++/QT for subsurface because GTK was crap.
How would this do for a [linked list of](https://github.com/squidfarts/sqdlist.git).
What operating system are you programming for?
You load the DLL with **LoadLibrary** and get the function pointer with **GetProcAddress**. Then you can use the function pointer to call the function. typedef int(*function_t)(int, int); HMODULE some_dll = LoadLibrary("Some.dll"); function_t some_func = (function_t)GetProcAddress(some_dll, "some_function_in_dll"); int result = some_func(1,2); Check [LoadLibrary](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) and [GetProcAddress](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) on MSDN.
Just looked it over. It is very nice and easy to follow. Looks like you took a verbosity over LoC approach. I usually do the opposite, but I'm sure it all compiles the same. Interested to see your approach to "map of". You should do a "set of" as well since it is like a subset of map.
LoadLibrary(Ex) is for optional dependencies. sounds like OP's situation is just a straight up dependency, in which case /u/FUZxll's solution is more approperiate
Web sites that require JS to be enabled to show \*any\* content really grind my gears .... Anyway, since this sub is for C, not C++, your post might be better received over at /r/cpp.
That's part of the problem presented with this. If the data is known ahead of time, you wouldn't have to be concerned with it too much. If the data is unknown, then you'll run into problems. How may characters will you process until a null termination character is found? What if there never is a null termination character? Or... what if the string coming in is only one letter and there's more letters than you can store in a single `unsigned long long` (C99 data type, but you get the point). These questions and problems are probably not meant to be solved in the above exercise - but in an interview, rather than take the problem and start coding.... Maybe take a moment to point out the "holes" in the requirements first. (Gauge the interviewer and the process, but it just might be that they're curious as to how in depth your thought process is when it comes to problem solving. Rather than diving right in, you show an ability to first think about the problem in order to make sure the problem is solved right the first time and to the full expectation of the person who was looking for a particular solution) As to the second part of your comment, you could handle this a number of ways - the important part is not allowing your incoming string dictate how long the function runs. *YOU* want to be in control of the programs loop, not the incoming string. So you could handle 8 char's at a time and handle a maximum of 64 iterations of those 8 chars. You could handle a single run of char\[ULONG\_MAX\], then determine whether or not you process that again if you haven't seen an null terminator. You could even setup a separate thread to handle it all and check it every so often so as not to block the rest of your code from running. wrote this pretty fast, sorry if certain parts don't make sense
C++ is off topic in this subreddit. Please post C++ content to /r/cpp or /r/cplusplus instead.
I'm agree with you, the scope of the exercise should have involved a passable solution of the problem and after cover all the pitfalls in the primitive solution. In theory it should have been a basic exercise in a formal interview and instead yours contributes and contributes of other reddit users have covered other aspects I never thought before posting my solution. The idea of a separate thread for compression I think is the best approach. Thanks for your feedback
The unofficial motto of this subreddit is "never use `scanf` to read user input". Read an entire line (using `getline` or `fgets`, say), then parse that as required. Checking whether a fully-read line is exactly six digits is a reasonably easy test.
I used fgets but am running into the exact same problem. Example: ----jGRASP exec: /Users/togaquest/Downloads/jgrasps/homework/modeling/get6digits Enter your six digit account number: 123abc atoi 123 Account number accepted! ----jGRASP: operation complete. Also, how do you use the code formatting for just one words like you did in your comment? For example I cannot figure out how to highlight "fgets" in this post.
Use `fgets` to get the entire line and save to a buffer, then `strlen` to get the length before parsing it out to make it usable.
&gt; I used fgets but am running into the exact same problem. Yes, the _next_ step is to not use `atoi`.
Note that `fflush(stdin)` is undefined behaviour and usually indicates a defective program. There is no need ever to call `fflush` on an input stream and all programs that do so have design bugs.
C++ is off topic in this subreddit. Please post C++ projects to /r/cpp or /r/cplusplus instead.
Generally in C code, and especially in library code, there is a convention that you don't change errno unless an error just occurred. Having to set it to zero to make an API work properly at all flies against this convention.
New code using your concept but still running into issues. #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;ctype.h&gt; int main() { char buff[100]; char trash[100]; int accountno; int vall = 1; while (vall == 1) { printf("Enter your six digit account number: \n"); fgets(buff, 100, stdin); /* 7 because of the /0 char because fgets */ if (strlen(buff) != 7) { printf("Not 6 digits \n"); fgets(trash, 100, stdin); } for (int i = 0; i &lt; 6; i++) { if (isalpha(buff[i]) != 0) { printf("No letters allowed \n"); } else { printf("Account number accepted! \n"); vall = 0; } } } }
Hmmm... OK, but in that case, not resetting errno will propagate the error and can cause false triggers. I do understand why writing to errno may feel cringy, but it's perfectly fine if you know what you are doing :)
Also, check out strspn.
An alternative to looping through the characters would be to use a function to convert a string to an integer that gives some feedback about invalid input, such as `strtol`.
Can you post the code.
I get 0x7B4DB31A 0.1004392654 and 0x833575C3 22.6825008392 with E = value &gt;&gt; 24; The description looks kind of garbled, what's in bit23 and what's that tiny -23.
On POSIX it's correct though; POSIX time silently ignores leap seconds to make calculations easier. When a leap second is inserted, POSIX time essentially pauses for a second.
&gt; In C, for empty we just declare a tag name with typedef Right, but then what? In C there's no way to _do_ anything with that. You can't test whether a particular type has a particular tag.
Looks good. This is what I catched so far: 1. Macro `SQUID_BOOLEAN` enables custom boolean type. There already is a boolean type defined in stdbool.h. Usually a build system sets a macro `HAVE_STDBOOL_H` in `config.h` (or whatever you set it as configuration), which then can be used to either include stdbool.h or define your own implementation. 2. Do not typedef pointers. It is important for a user to know what is a pointer and what isn't (i.e. for `sizeof`). Let them be explicit. 3. In functions `iter*()` it is a good idea to allow users pass additional data to the callback function. This data may alter the behaviour of the callback or allow it to update information without the need for global variables. Example prototype: `iterEach(SqdListOf*, void(*)(void*,void*), void*)`. 4. Function `itsNullptrNode()` is not really needed (it's the same as `!node` or more implicitly: `node != NULL`) but it's inlined, so shouldn't be "harmful". Consider rewriting it to a macro. Same with `notNullptrNode()`. 6. In function `buildNode()` you are calling `sizeof` on a variable instead of type. Also `else` is not needed, because `newNode` is NULL at this point and it's returned in the next instruction. 7. In function `createList()` ternary operator is not needed (for the same reason as #6). 8. In function `getFrom()` (and all other functions using element position) type uint8_t limits the number of elements to 256. That's a short linked list. Go wild! Change it to unsigned long or unsigned long long! ;) 9. Functions `itsNullptrList()` and `notNullptrList` are not needed and can be rewritten to macros. 10. In function `insertNode()` consider appending element to the end of list if `pos &gt; dll-&gt;_size` instead of bailing out with error. Instruction `++dll-&gt;_size` does not look right, try `++(dll-&gt;_size)`. Use `insertAtHead()` and `insertAtTail()` functions to avoid code duplication. 11. In function `removeFromHead()` simplify top two `if`s to `if (itsNullptrList(dll) || itsNullptrNode(dll-&gt;_headPtr)) return NULL` and change the last `if` to just `return itsNullptrNode(removeNodeFrom(dll, 0))`. No need for additional variable. The same in `removeFromTail()`. 12. In function `findNode()`, result of instruction `currPos = (reverse ? (--currPos) : (++currPos))` is undefined. 13. in function `destroyList()` use `clearList()` to avoid code duplication.
One use for tags in C++ is to select different function overloads see std::piecewise\_construct. One example: struct AsInteger_t {}; struct AsText_t {}; inline constexpr auto AsInteger = AsInteger_t{}; inline constexpr auto AsText = AsText_t{}; void printBool(AsInteger_t, bool b) { std::cout &lt;&lt; (b ? 1 : 0) &lt;&lt; std::endl; } void printBool(AsText_t, bool b) { std::cout &lt;&lt; (b ? "true" : "false") &lt;&lt; std::endl; } int main() { printBool(AsInteger, true); printBool(AsText, true); printBool(AsInteger, false); printBool(AsText, false); }
C is a bit different, type erasure via void\* lets you pretty much cast anything to anything. But You can still have some useful hints by compiler. So yes, any function that accepts a pointer can accept pretty much any pointer you throw in it. However, you still get a compiler warning, try void f(Empty\* e) {} and pass it Object\* without explicit cast. Yes I am pretty aware that you can't have zero size structs in C, that is major reason why one have to typedef struct instead of declaring an empty struct in C. Thought it would be self evident to anyone why C and C++ examples are different. I was a bit hasty when I remarked that empty struct is zero in c++. Empty base class can be safely optimized away (and usually is in optimized build), something that is stated in the link you posted too. Usefulness? No idea, as I said, it gives you a modeling concept, probably just a mental tool due to type erasure in C. If it is useful to you or not depends on your programming style and discipline. If you expect compiler to provide some magical stuff for you, no idea. In that case I guess it is not very useful. Unless you use some compiler extensions and maybe use typeof stuff similar as how it would be used in Java maybe? No idea man, it was a reflection and question, more of a hope that someone will come up with some creative use of it.
The way I like to do something like this is to use non-canonical input mode to turn off input buffering and echo. You can then read input one char at a time and write logic to control which characters and how many characters you accept.
Indeed, and that in turn depends on function overloading which unfortunately is not avialable in C .
This seems like it may be my best option. Thanks for suggesting!
Do you really need to convert the number to an integer? If you're not going to do any arithmetic operations on it it should stay represented as a string (like with a telephone number). Also you'd lose any leading 0s if you convert the account number to an integer... &amp;#x200B; So just check length, and you could loop over each character and check if it's a digit with \`isdigit\` (from \`&lt;ctype.h&gt;\`)
I understand the idea, but the fact that you still cast means the C compiler can help you less. Why not use something along the lines of (code wont work, but maybe you get the idea): `objs[0] = &amp;o1.empty;` and `#define OBJECT(a) _Generic(a) ( Empty*: (Object*)((char*)a + offsetof(Object, Empty)) default: (void*)a)` `printf("a: %d\n", OBJECT(objs[i])-&gt;a);` see no casts, and the compiler will error if you try to work with incompatible types.
Why not simply provide two functions with different names: printBoolAsText/printBoolAsInt? What is acutally gained by using this pattern? Leave it to C++ to create a complex solution for a simple problem :)
Putting the mutex in your container is generally a bad idea. Most multi-threaded programs want to use more than one data structure, and in order to ensure that the relevant invariants are preserved, will use a mutex to protect more than one thing at a time. For example a set and some other associated data. In this case having a mutex in the collection adds unnecessary overhead.` Putting the mutex in the container also makes it difficult for the container's users to make changes to their locking strategy. It's often helpful to be able to do that, to manage lock contention levels. Your `bag_array_perror()` function is user-surprising (and that's bad) because it mutates errno, while `perror` does not.
The C way to tag your objects at runtime is either a tagged union or pointer tagging. I don't think OO patterns are suitable in this case. Even if you don't explicitly declare type storage, if you have type information at runtime, it's stored somewhere. With pointer tagging being the notable exception.
Use `man` to find out how they work.
I we'll make sure to fix the issues before publishing more.
When I'm interviewing C programmers, in addition to their programming ability, I'm also looking for their ability to diagnose problems in production, and how they build programs that are easier to debug in production.
But the compiler does not consider whether the object has the 'tag' or not, especially about pointer casting. I still don't get it...
If you‚Äôre trolling us. Then we‚Äôll played good sir.
No trolling here. These are the results of our independent survey where 19,000+ developers responded.
This is the C programming community. You probably meant to post this to r/csharp.
&gt; C/C++ Triggered.
Using a parameter let's you use the function in generic code: template &lt;typename T&gt; printGreaterThanZero(T t, int x) { printBool(t, x &gt; 0); } If you used two different names you would not be able to do this.
As usual, it means absolutely nothing. I STILL am not going to use JavaScript for system programming no matter how popular it is.
Nobody cares about C# here. This subreddit is about the C language only. Note further that there is no language called ‚ÄúC/C++.‚Äù
It stops when it hits end-of-file on the input stream. You can do that on a Unix-like terminal by pressing Ctrl-D or Ctrl-Z on Windows.
What are you giving the program as input? The program will loop until it receives the EOF character. Have you tried pressing CTRL+Z to give it an EOF character?
yup just figured have to press Ctrl+D for EOF. Thanks guys.
Thanks for taking the time to explain this!
I am almost there with working code. My problem is that it does weird stuff when error checking, like forcing me to hit enter multiple tiimes. Can you check out what I have so far and try to fix it? &amp;#x200B; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;ctype.h&gt; int main() { char buff[100]; char trash[100]; int accountno; int vall = 1; while (vall == 1) { printf("Enter your six digit account number: \n"); fgets(buff, 100, stdin); /* 7 because of the /0 char because fgets */ if (strlen(buff) != 7) { fgets(trash, 100, stdin); accountno = 2; } if (accountno == 2) { printf("Not 6 digits \n"); fgets(trash, 100, stdin); accountno = 0; } for (int i = 0; i &lt; 6; i++) { if (isalpha(buff[i]) != 0) { accountno = 1; } } if (accountno == 1) { printf("No letters allowed \n"); fgets(trash, 100, stdin); accountno = 0; }else { accountno = atoi(buff); vall = 0; printf("Account number accepted! \n"); } } } Console Output: ----jGRASP exec: /Users/togaquest/Downloads/jgrasps/homework/modeling/is6digits2 Enter your six digit account number: 123456 Account number accepted! ----jGRASP: operation complete. ----jGRASP exec: /Users/togaquest/Downloads/jgrasps/homework/modeling/is6digits2 Enter your six digit account number: 123e56 No letters allowed 123456 Enter your six digit account number: 123456 Account number accepted! ----jGRASP: operation complete. ----jGRASP exec: /Users/togaquest/Downloads/jgrasps/homework/modeling/is6digits2 Enter your six digit account number: www 123456 Not 6 digits 123456 No letters allowed 123456 Enter your six digit account number: 123456 Account number accepted! ----jGRASP: operation complete.
In Unix, control-D isn't really an EOF character. Instead, what happens is that when a terminal is in "cooked" mode, it normally waits for a newline before returning from a request to read whatever data is available, but control-D forces it to return immediately with whatever it has received to that point. Many programs will assume that if a request to read N bytes (for non-zero N) returns zero bytes, that it did so because of an end-of-file condition, but that doesn't mean that control-D is really an "EOF" character. If e.g. a program uses fgets() to request eight bytes from \`stdin\`, and if someone types ten characters, the \`fgets()\` call won't exit until they type a return or control-D. In either case, the first eight characters they type will be returned from \`fgets()\` and the last two will be left pending. If they typed a return, then a newline character will be left pending after the last two characters.
I had the same problem lol. It's not intuitive. So used to just smashing the escape key.
Is this how control-C works on Windows cmd as well?
Or by piping in a file cat file.txt | ./a.out
Putting structures in header files makes it possible for inline functions and macros to make use of their internals, even if client code is not supposed to do so directly. It will also allow client code to declare objects of the structure type that have static or automatic duration, and use the structure within other structures, unions, or arrays. The biggest downsides are that it may induce authors of client code to rely inappropriately upon the structure's internal details, and will make it necessary to recompile all client code if the structure definitions change, regardless of whether any of the changes would be relevant to the client code in question. Although some people view structure tags as deprecated in favor of typedef, they have an advantage in multi-part programs which I've not seen addressed. Suppose one has two modules, one of which defines a structure type, and the other of which includes--among its many features--a function to convert information to/from that structure type. Suppose further that many clients would have no use for that structure type, nor the functions to convert data to/from it. If the structure type is known only by its typedef name, then it would not be possible to prototype functions which use those structure types without having a declaration of their types available, and annoying gymnastics would be required to handle cases where code might include the header file for the module with import/export functions before including the header file that defines the structure types. On the other hand, C will, by design, allow a prototype to be specified: int export_to_foo(struct foo *dest, struct bar *src); whether or not any definition of `struct foo` (or `struct bar`) has been seen previously, and code can make use of pointers to those types without having to know or care about how they are defined. Additionally, in many implementations it is useful to have a header file define a public-facing type for a structure, while the associated module interprets pointers to that type using a structure that has the same size but different layout. The gymnastics necessary to validate that the two types have matching size and alignment requirements can be annoying, and some optimizers may be unable to deal with such constructs, but in cases where the size of a structure may be predictable (or one can afford to over-allocate enough to cover future needs) but its exact contents might not, such a design may make it possible to let client code declare static- or automatic-duration objects of the structure type, along with structures, unions, or arrays containing it, without making it necessary to recompile the client code if the structure's internal details change. If client code sees the struct as: struct woozle { void *public_detail1; uint32_t public_detail2; uint32_t public_detail3; uint64_t private_stuff[6]; }; and neither knows nor cares how the woozle-handling code uses the last 48 bytes of the structure, it shouldn't need to know or care if those things change.
Or by redirecting the file into it. `./a.out &lt; file.txt` But clearly OP is trying to run the program from an interactive terminal, because it's seemingly not working for him.
Implementations are free to define whatever behaviors they view as most useful for `fflush(stdin);`, and the authors of the Standard opted not to pass any judgment as to whether a behavior that might be useful for some purposes might be harmful or even dangerous in programs designed for other purposes. Given the lack of any other function to perform a non-blocking read of all pending keyboard input, it would be entirely reasonable for an implementation to implement `fflush(stdin)` to behave in such fashion rather than coming up with some other function name for that purpose. If users of a program frequently type data ahead of the program's prompts, and a situation arises where the program needs to ask the user something for which the previously-typed input would be unlikely to be appropriate, a program that calls `fflush(stdin)` would be more useful than one which doesn't on an implementation where that action would perform a blocking read of all pending input (discarding the result), and would be just as useful as one that doesn't on a platform where the action has no effect. In cases where input is redirected, the effect of having fflush() discard all remaining input may be good or bad depending upon whether the data in the file would match the program's expectations. If an input file was created with the expectation that the program was going to ask "Do you want to enter any data", but the program encountered a situation where it was unexpectedly able to read the database and had to prompt "The database file is not readable; do you wish to create a new database from scratch?", having the program hang at that prompt may be preferable to having it erase the database. BTW, it's too late now, but I think it would have been useful for C and Unix to have included separate "data input" and "operator input" stream designators, analogous to stdout/stderr, but with a proviso that implementations may map both to the same stream. Such a design would have been a perfect fit for programs like `more`, but also for any programs that might receive data from a pipe but occasionally need to ask an operator how to handle unusual situations.
Clearly.
It really irks me that the C Standard didn't include any standard way of enquiring at compile-time whether an implementation could always support such input, never support such input, or may be able to support such input based upon run-time factors, as well as a standard means of requesting that an implementation either process input in such fashion or report that it can't do so. Every hosted C implementation would be able to satisfy the requirements for such library functions if "report an inability to satisfy the request" was an allowable outcome, and such a library would greatly increase the range of tasks that could be performed on most platforms without reliance upon platform-specific functions or other extensions.
A few things I've noticed: For `list.h` * `boolean.h` is never included in `list.h`, so the check on line 48 is pointless. You could probably force C99 as a requirement and use `stdbool.h`, since you're already requiring meson it shouldn't be much of a stretch. * You can define the structures like `typedef struct { ... } SqdNodeOf;` to shorten the code a bit. See [this](https://stackoverflow.com/questions/1675351/typedef-struct-vs-struct-definitions#1675446) * There is no reason to make `SqdNodeOf` public. It is never used in the API. * I would personally not define the structures in the header file, and instead do that in `list.c`. That way, the inner workings of the structure remain anonymous. It depends on how you want the library to be used. * It is a common idiom to name an "is empty" function ``isNullptrList``, not **its**. I would also capitalize the **p** in this function. Note the funciton is equivalent to ``ptr == NULL``, so it could be removed from the API without issue. * There is no need for ``notNullptrList``. * I would rename the `iter` functions. They do not return iterators, but act like a `foreach` and should be named as such. For `list.c` * Your definition of `itsNull...` and `notNull...` are redundant. Just return `node == Null` or the converse. * Don't cast the result of `malloc` in C. * The purpose of this file is not to declare prototypes. Change the description in the header comment. * In `buildNode` and `createList` there is no reason to check if the result is NULL to return NULL. Just return the element. * You don't check if the list is null in many of your functions before trying to access them. This can lead to lots of nastiness. Either document in your API that these functions can only be called on non null lists, or check for nullity. * No need to check if `head` is null in `getHead` just to return null. Same for `getTail`. * Don't cast pointers in `free`. I'm sure there are a few other things, but that is what I see at a glance. Finally, as a note there are several grammar mistakes in the Readme which should be cleaned up at some point. Some things are also a little weird in there. For example, what does it mean to be "extremely generic"? I would also hope the library works out of the box... I really like that you outlined the install process and documented the API well! It is a common convention to write the function declaration *then* the documentation however. Overall, good job on the library!
In Unix, MS-DOS, and Windows console applications, control-C is handled specially. It's possible to perform I/O in ways that treat control-C like any other character, or in ways that will raise a signal, interrupt, or exception if a control-C is observed (I'm not sure about the exact details, but the default behavior of control-C in each platform is to terminate the program.
Control + D to input EOF through CLI.
Use \`getchar(0\` to read six characters into a buffer, exiting early if a newline is encountered. If no newline has been encountered, keep reading and ignoring input until it is. While others may suggest using \`fgets()\`, its design is really not suitable for interactive input. If the amount of input received on a line exceeds the supplied buffer size, \`fgets()\` will use any data beyond the buffer length to satisfy future input requests. Although there are ways to deal with such behavior when using \`fgets()\`, handling all corner cases properly ends up being more difficult than simply using a \`getchar()\` loop.
'C Programming: A Modern Approach' is fantastic and uses c99 (iirc) There's also '21st Century C' which is pretty good but requires prior C experience. Not to mention the millions of lines of C code that is free for you to look at on the internet ;)
In my opinion, you should start reading old books you found because C is really old programming language. Then, you should learn changes in 2018 year standard. I think it is the best way to learn C. Welcome to low level programming!
Thank you, where do you recommend I learn the changes from? Any links?
Thank you, I appreciate the suggestions! How do you propose I should approach reading code? It seems a little complicated
Do you have any programming experience? Regardless, just work your way through 'C: A Modern Approach' and then dive into whatever interests you. I am interested in systems programming, so I started out with C by installing OpenBSD in a VM and working my way through the source code for their command line tools.
https://en.cppreference.com/w/c/language I usually use cpp reference to study C and C++. It can help you to understand some functions that have been added recently. Don‚Äôt try to study them now. Firs of all, you need to understand basics of C. Enjoy!
https://en.cppreference.com/w/c/language I usually use cpp reference to study C and C++. It can help you to understand some functions that have been added recently. Don‚Äôt try to study them now. Firs of all, you need to understand basics of C. Enjoy!
I have none, I'll read the book and try out what you mentioned, thank you for you're reply! ‚ù§Ô∏è
Thank you! ‚ù§Ô∏è
Good luck!
Despite the fact that this is a subreddit dedicated to the C programming language is strongly recommend that you start with python. If you're unfamiliar with the basic concepts used in computer programming, this will help you get started.
I haven't yet used \_Generic (C11 for uninitiated), so I don't know if that would work. When I was thinking about the example, before I made my post, I was thinking about testing if I can use \_Generic in some similar way, but I haven't had time to test. I am not sure though what do you mean with this: objs\[0\] = &amp;o1.empty; What is empty here? It will work in C++, not in C. In C there is no o1.empty. Empty lives in typedef namespace only.
Yeah, there is usually no free lunch. In Java and .net it is in compiled bytecode. At least in Java's bytecode, there is a list of all interfaces a class implements in it's .class bytecode, as well as list of methods, variables and so on.
Gotcha, thank you for the rec!
Thank you!
carlh has(had?) great material on youtube but it's contentious to recommend him in light of his crimes. That said, his programming fundamentals are about as well communicated, straight-forward and building-on-knowledge as you'll get.
I‚Äôm a hobbyist programmer, for pass few decades. So maybe I am not super entitled to give you advice on modern approach to learning, but imho you should perhaps study manuals available on websites. First, you won‚Äôt pay a penny for it. Second these usually are down to the essence, it makes it easier to read and absorb it for beginners, and some are pretty exhaustive as well. You can even find C specs if you dare study harder, there is bunch of papers, studies available if you look closely. And I don‚Äôt think K&amp;R is difficult, it‚Äôs irrelevant to hear this from someone else - perhaps you read it and you judge if it is difficult or not? Maybe it won‚Äôt be for you? I started in early 90s, I don‚Äôt recall C ever being difficult, it was rather exciting. My first book was K&amp;R. You don‚Äôt have to understand everything, just read. So My suggestion to you is: read as much as you can from freely available sources. If your budget allows to get books, be so. Nowadays with github for example there is nothing in your way to read source code, say Linux sources for example are pretty interesting, packed with good stuff :) I like read it. K&amp;R is basically classic, you should read it. Then practice, practice, practice. Nothing will be clear to you at the beginning, don‚Äôt get discouraged. Understanding language is just top of the ice berg. There is far more to learn to be at professional level. Folks here could tell you best. Good luck to you.
[https://www.edx.org/course/cs50s-introduction-to-computer-science](https://www.edx.org/course/cs50s-introduction-to-computer-science)
This is valuable advice thank you!
Uhhh no thanks
Gotcha, thanks!
Yikes. Every time i write python, i want to puke. That being said, you're right. Just the general string handling in C isn't terribly difficult for an experienced programmer, but for learning, it's a distraction. A higher level language would be better to learn first, and python is very popular.
Agree 100% with this, Python made me a better C programmer. It will make you crave more elegant and adaptable data structures, which are only achievable by learning to manipulate pointers skillfully.
From another comment somewhere I wrote: People always struggle with C when they start from scratch or come from a higher to lower level of abstraction. I struggled with this for a long time till I did these 4 things: 1. Read [Code: The Hidden Language of Computer Hardware and Software](http://www.charlespetzold.com/code/) 2. Watched all 41 videos of [Crash Course in Computer Science](https://www.youtube.com/playlist?list=PL8dPuuaLjXtNlUrzyH5r6jN9ulIgZBpdo) 3. Grabbed a copy of [C programming: A Modern Approach](http://knking.com/books/c2/index.html) and used it as my main course on C. 4. Followed this [Tutorial on Pointers and Arrays in C](https://sourceforge.net/projects/pointer-tutorial/files/latest/download) until I fully understood pointers and memory management. The first two really helped by approaching C from a lower level of abstraction (actually the absolute lowest level and gradually adding layers of abstraction until you are at the C level which, by then is incredibly high!) The third is just the best tutorial on C. By far. The 4th is a deep dive into pointers and by far the best tutorial on pointers out there.
I well apply fixes after I get from work but I would like to let you in on the goal of the separate libraries. The linked list of is currently the only thing I have up at this time. That would make since for me to not try to include "boolean.h" because I did not write it yet. Out of curiosity why should I not cast "malloc" and know that the type returned is what I expected? Also why should I not cast free? It's not like i'm using the, and please excuse me "goto" keyword.
What crimes?
I feel attacked
I feel dumb
&gt; Out of curiosity why should I not cast "malloc" and know that the type returned is what I expected? [This stackoverflow question covers the topic well](https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc) &gt; Also why should I not cast free? It does absolutely nothing. Good luck with the rest of the lib!
If one recognizes C as being a collection of dialects, most of the questions will have different, but unambiguous, answers in most of the individual dialects. The only problem is that people refer to C when they're really only talking about certain dialects.
I feel enlightened
Don't get the book in 2019. Just do CS50.
I knew it from the first question, because I‚Äôve dealt with integers being different sizes.
I felt bad answering 'I don't know' to all of the questions (besides the last) but the test results did reassure me. I guess the moral of the story is try to never write code unless you know exactly what it'll do.
I feel smart.
I actually got all "correct," but was already pissed at the first question because I felt the author was forcing me to deduce type sizes for integral types, which I _hate_. But I caught on to the author's point 2-3 questions in.
I feel cheated.
Nice test, but you couldn't fool me, lol. I feel like I had seen a couple of these types of gotchas in "Deep C Secrets". It's a bit old, but still a good book in my opinion.
'I don't know' is a put-down, but if the wording was 'I think the answer is indeterminate' everyone would have score 100%.
That was an easy quiz.
I'm am attacked offended moron who apparently collects a paycheck despite knowing absolutely nothing about everything. Give me my beer back.
That was fun thank you.
Well that's a dishonest quizz, it forced me to click on "I don't know" even though I knew for certain that they were undefined behaviour.
I got #2 and #3 correct. ü§ï
So I went ahead and compiled these in gcc and clang. 4/5 of my answers were right in that sense. Needless to say, I got a zero on his quiz.
Ha, I didn't know how to answer any of those questions (since I'm not a C programmer at all) and hence got a perfect score. Does that mean that I can now call myself an expert in C? :P
Yea the wording is clearly steering people away from the correct reply. It title could have been 'how well do you know the C Standard', option C could also have been labelled 'implementation defined'. But where is the fun in that. My guess is that most people would get a good result for the compiler they use.
I got two out of five. I feel whelmed.
I feel like making love
I...did better than I thought? I knew about the struct padding and vaguely about the int promotions, and the last one for some fucking reason was a question in my year 1 exam because apparently no one's heard of undefined behaviour
That taught me not too assume shit. For the bit shifting part I knew if int were 16 bits like it was on the old days it will fail. But I assumed this would be for nowadays computers and that would have made the whole program machine dependent. Thank you, that was fun.
Whenever I see an article with a title like this one has, I always assume we'll be talking about undefined behavior. (It's only missing "and number four will shock you!!!") The author does make a good point about not making assumptions that you know things unless you truly do know them. That said, if you're doing things like... return sizeof(*(&amp;s)); ...whilst writing software to automate a nuclear reactor, I'd like a word with you after class.
This guy knows what I'm talking about * clinks glass *
I've met more than one self-professed "expert" that most certainly knew less than you, so I say go for it.
https://www.youtube.com/watch?v=tk1dd1D2Kts
Damn, I got all correct. üòé
5/5 ... genius level
Lol, same.. I decided on the first question to assume platform (because it was more fun that way), and then be really happy if the "right" answer related to undefined behavior. Was not disappointed :)
5 is UB, 4 is implementation-defined whether there is UB, and 1-3 are not UB
Use getchar and check each one is a numeric with each keypress.
I DON'T KNOW.
Is it possible to learn this power?
The moral of the story is never make assumptions about undefined behaviors or details left to implementations.
I know C, i just don't personally identify as a C compiler.
I called what what was gonna happen before hitting the button, plus I got everything correct for ia32, except for the last one, which is undefined behavior and not just implementation defined behavior.
sizeof(*(&amp;s)) is the same as just writing sizeof(s), right? Or am I missing something?
&gt; The third one is all about dark corners. Starting from that neither integer overflows, nor char type sign are defined by the standard. First one is undefined behavior, the second is implementation specific. But even more, the size of the char type itself is not specified in bits either. There were platforms where it was 6 bits (remember trigraphs?), and there are platforms where all five integer types are 32 bits. Without all these details specified, every speculation about the result is invalid, so the answer is: ‚ÄúI don‚Äôt know‚Äù. A char has to have at least 8 bits though. The real issue is that character encoding is not specified.
phew
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
What's a free parameter?
From my understanding and according to [cpp-reference](https://en.cppreference.com/w/c/memory/free) it's simply 'void \*'. No name at all.
Sometimes you need to cast the result of an allocation to a pointer of the appropriate type, also, sometimes the compiler can do it automatically for you (e.g some compilers might allow you to just `free(ptr\_to\_struct)`. I think you need to give a more specific example of what you are asking.
I think he is talking about the `void *ptr` [here](https://www.tutorialspoint.com/c_standard_library/c_function_free.htm) But with the info given I don't know if that's the case
This should be good for an example. [https://github.com/squidfarts/sqdlist.git](https://github.com/squidfarts/sqdlist.git). I know there are some things wrong with it and I am working on it. Just keep in mined that it's just about this question.
There is no need to ‚Äì pointer casts to and from void* are implicit per standard. Wikipedia lists some advantages and disadvantages: https://en.m.wikipedia.org/wiki/C_dynamic_memory_allocation#Advantages_to_casting
Desktop link: https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Advantages_to_casting *** ^^/r/HelperBot_ ^^Downvote ^^to ^^remove. ^^Counter: ^^265983. [^^Found ^^a ^^bug?](https://reddit.com/message/compose/?to=swim1929&amp;subject=Bug&amp;message=https://reddit.com/r/C_Programming/comments/c9rb8q/to_cast_or_not_to_cast_malloc_or_free/et1rzmo/)
Generally speaking, I wouldn't. It's mostly noise. But I have also been known to do things like: #define new(T) ((T *)calloc(1, T)) because "why not?", and at least the noise is hidden away in the macro.
You just linked an entire repository -- I don't know what to do with that. &amp;#x200B; If you are asking what I think you are asking, then /u/ZoDalek's answer is probably what you should take a look at.
Ty for the heads up!
Sorry the definition of "free((void \*)myPtr)" is what I was wondering about. I seen it in the Unity test framework.
I knew something was wrong with ‚Äòsize of int‚Äô type of question, but no architecture specified anywhere. I failed assuming it‚Äôs x86 though. Good job.
Practice makes perfume!
Yes. I‚Äôm guessing it was done to *obfuscate* the code, or to get your focus on something else
https://np.reddit.com/r/DeadRedditors/comments/2lbnl6/carl_herold_ucarlh_found_hanged_in_jail_cell/
Also, unless I‚Äôm mistaken, C does not specify that a comparison will return 1 or 0. Only that false is 0 and true is anything else.
I know as much C as I need :D
you should not cast the result of malloc for a [few reasons](https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc)
Great! I assume I can add your endorsement to my CV as well? :D
I started learning C last year and signing up for cs50 on edx helped me to get a good basic grasp of the language.
I can c sharp..
It's been 1 atleast since C89/C90. &gt; 6.5.8 Relational operators &gt; Each of the operators &lt; (less than), &gt; (greater than), &lt;= (less than or equal to), and &gt;= (greater than or equal to) shall yield 1 if the specified relation is true and 0 if it is false. The result has type int. &gt; 6.5.9 Equality operators &gt; The == (equal to) and != (not equal to) operators are analogous to the relational operators except for their lower precedence. Each of the operators yields 1 if the specified relation is true and 0 if it is false. The result has type int. For any pair of operands, exactly one of the relations is true.
Damn, I definitely knew some of these were undefined but ended up guessing anyway.
I feel confused and scared, mom come pick me up it's getting dark.
When I compile with gcc I get: test.c:7:14: warning: declaration does not declare anything Empty; \^ So its an empty declaration, is that the same as a typedef namespace only? I saw Empty as an unnamed element of zero size as the first in the struct so that it would share the same address. I see your point about making a special type, but if you still have to cast I dont really see the advantage. How does this help you or the compiler? You could just as easily casted to and from an incomplete type or even to/from void\*. It runs also exactly the same if you remove the Empty from the Object struct definition.
So many emotions going through me right now
But some of it is certainly undefined, not just implementation defined.
Don't! It's a trap!
Extremely practical and a great point, because you know, people code this way. It's always good to take decent developers and trick them into thinking they're dumb to feel high and mighty about yourself.
It doesn't. It was just a thought I had and wanted to see if someone else had more to say about it than I :-).
This is bullshit. There should be a score based on x86 vc/clang. Thanks for wasting my time.
Right on! Post your gcc+clang answers? I picked AACAA :)
I've had to deal with C code that was upgraded to C++ by just changing the compiler from gcc to g++, and have mainly dealt with issues in size of network focused structs. Although I'm a C++ programmer by trade, when dealing with non stdint types, there's just alot of historical baggage! Safest to just never make presumptions.
In pure C you don't have to, and may even be wrong to do so sometimes. But in C++ code you should cast the return of malloc or the compiler might bark at you (or better yet never use malloc in C++ code). As for free there is absolutely no need never, even on C++.
Note that gcc and clang are not platform-specific. You can get different answers by compiling for different platforms or with different options.
Absolutely! I mean, my expertise and four american dollars will get you a cup of coffee!
Did the same. I was like, well int can be 16 bit, but I guess I can just assume it's 32 bit.
Yeah, I figured that.
I don‚Äôt even know myself
&gt; #define new(T) ((T *)calloc(1, sizeof(T))) Don't do this BTW, if you're ever going to put this in a header and someone decides to use it from C++ it'll error since you've redefined new. Just don't use new as a macro keyword just in case it ever gets used in C++ because you'll have an error, make it like, cNew or something, just not a C++ keyword.
So many macros. I don't have a ton of c experience, so I'm curious: did you choose macros over void* for generality just to be header only or for other reasons as well?
If you don't need to do something, don't do it. Keep the code as clean and easy to read as you can.
I work in aerospace on safety-critical software written in C. If you care about safe, error-free software you absolutely should cast the result, I'll explain why by addressing each item from the Wikipedia page and Stack Overflow question others have posted. I'll note first that if you care about writing safe, error-free software then you must be using a static analysis tool. Your compiler has a set of warnings, and you should be compiling with all warnings enabled and treated as errors, but static analysis takes this a step further by disallowing many things that are allowed by the language but often lead to errors. Some good static analysis tools include PC-Lint by Gimpel and the LDRA toolsuite. There is no harm in running several properly-configured static analyzers, and none of them are perfect. Now on to the explanations, first from Wikipedia: &gt;Including the cast may allow a C program or function to compile as C++. I'm tempted to just leave this at "don't try to blindly compile C code as C++", but I'll explain further. First: think about the reasons you want to compile your C program with a C++ compiler. * Do you just want to use a module written in C in your C++ program? Great! Compile it with a C compiler and link it into your program that way. If necessary you could create a facade in C++ so that you don't have to have `extern "C"` everywhere. * Do you want to copy-paste the code into your C++ program, modify it, extend it, etc.? If you want safe, error-free code you'll need to do more than transliterate it into C++. There are several gotchas when converting C to C++ code, plus your organization probably has different styles and coding standards for C and C++. If you're lucky the naming convention will be in the same. &gt; Adding the cast may mask failure to include the header `stdlib.h`, in which the function prototype for `malloc` is found. Your static analyzer should not allow you to use undefined functions. There is a reason that implicit int was removed in later versions of the standard. &gt; If the type of the pointer is changed at its declaration, one may also need to change all lines where malloc is called and cast. Your static analyzer will tell you if this happens, and you should evaluate each instance to verify the new behavior is correct (tools such as Klocwork can help with this refactoring, but you should still be reviewing the output of any tool). Lets look at the reasons you might be changing the pointer type: * If the name of the type changed then go ahead and blindly rename everything. Your coding standard should prevent naming collisions by guaranteeing unique names across your entire code base. * If the intent of the code changed, e.g. you're now storing different data at this place, you need to verify line-by-line that the new behavior is correct. So thank your static analyzer for pointing out all the places an implict cast occurs. &amp;#x200B; Moving on to Stack Overflow: &gt; It is unnecessary, as void \* is automatically and safely promoted to any other pointer type in this case. I agree it is automatic, and agree it is "safe" in the sense that the compiler will assign the proper number of bits, etc. However no implict cast should be treated as safe. The most obvious example is where one of the types has changed, i.e. `MyType_t* foo = malloc(sizeof(MyOtherType_t));`. Furthermore if `MyType_t` and `MyOtherType_t` are different sizes your static analyzer should catch the case of assigning to an area too large/small, but what if they happen to be the same size? That means years from now when one of the types is changed some poor developer is going to have a mess on their hands. &gt; It adds clutter to the code, casts are not very easy to read (especially if the pointer type is long). This is subjective and I personally disagree with this: code editors have coloring to help with this exact problem. Most people are not printing out 80 columns of code anymore so your line lengths can be much longer. In any case I argue this is a small price to pay for safety. &gt;It makes you repeat yourself, which is generally bad. This is a good point, but I still argue it is worth it for the safety aspects. Writing good software takes time. &gt; It can hide an error if you forgot to include `&lt;stdlib.h&gt;` Already addressed above &amp;#x200B; I'll point out that not everyone needs safe, error-free software. There are lots of applications that could settle for something that works just 99.99% of the time, especially when developer hours could be better spent on actually improving the code and fixing known bugs instead of dealing with tedious refactoring and reviews. But for applications where many people will be killed if it fails there can be no shortcuts. &amp;#x200B; I welcome people's comments and criticism and will probably update this to further explain my opinion as holes are poked in it.
should we worry about how C is compiled by other language compilers?
Because C headers can be used by C++, if you do this and someone comes along and tries to compiler the project with a C++ compiler (don't ask me why) they will get errors, or maybe you do a C++ project and your header file is copy/pasted or is a header for a library so you include it, so you get errors...
*[laughs in BSD](https://github.com/openbsd/src/blob/master/sys/sys/tree.h)* Macros are usually used for performance and token pasting. Plus since it's processed before compilation it allows you to even create lots and lots of definitions if needed, and you don't suffer any penalty for function calls since it's just inline replacement at it's most basic.
&gt;A char has to have at least 8 bits though. The real issue is that character encoding is not specified. That's a very modern take. (Okay, by "very modern", I mean the 90s.) In C, `char` is an integer type that is meant to represent a byte. Stock C doesn't really have high-level support for strings or encodings and doesn't have a stock data type that corresponds to a Unicode code point. The `char` type not specifying its encoding isn't really a failing. It's just confusing that later languages (like Java) use that same name to describe a higher-level data type.
When used, 0 is treated as false and anything else is true. So `if (x) { /* thing */ }` fires for all values of x other than 0. When generated, though, 1 is always produced for true.
üëè
The same could be said about using functions like scanf_s vs scanf as not every C implementation provides scanf_s, so basically using scanf_s is a compile error same as assuming that my x86_64 program's int is 4 bytes long is undefined behavior
Exactly. I was like "What is the int size" so I picked "I don't know." I got that one right, at least.
True that. Even though we all like compatibility, not all computers are the same.
Yeah, I was thinking, well most compilers do this, so probably the answer they are looking for. On the last one I even thought &lt; that's undefined behaviour &gt;, but figured he was expecting some deep guru knowledge so I sat down and worked it out.
various language compilers can use C headers. if i write C code, i expect it to be compiled by a C compiler. i'm not going to worry about namespace collision with any other language compiler. if somebody wants to port C code to another language, they can figure out what to do with the namespace collisions.
Great comment! This was very interesting to read. On a related note, if I'm interested in learning what's involved in writing safety-critical C code where would I start? It's only a personal interest though so more accessible material at the cost of less depth of the material is OK.
Yes, the same rules apply to composite types as they do to primitive types.
You'd be correct in saying that you don't need to cast malloc. I'm just wondering exactly what you're getting at in your question. Are you asking if you need to cast malloc in a struct declaration? Because the answer is still no. If I had a structure like this: struct students_t { char name[50]; int id; }; You could initialize a dynamic struct like this (which is what I do): struct students_t *student1 = malloc(sizeof(struct students_t)); Or like this: struct students_t *student1 = (struct students_t) malloc(sizeof(struct students_t)); If you read the man page for malloc, you'd notice that malloc is declared as void *malloc(size_t size); Since malloc returns a void array, it's type doesn't matter. Casting it is just an unnecessary step and just causes you more typing.
DO-178C is the process document for avionics code, which is what I deal with. This is the governing document for most commercial flight software in the US. The key to know when reading about it is: DO-178 is a process, not a standard. You won't find things like "variable names shall start with a lower case letters" nor "use this version of a compiler" in DO-178. Instead you will find things like "you shall have a code standard and follow it" and "you shall have independence between your test and review teams". That's because writing code is the easiest part of writing safe code: the hardest part is proving to an auditor and, more importantly to yourself, that the code does no more and no less than exactly what it is suppose to do. So in short: safe code is written by following a process, and in that process a bunch of people review a bunch of things. But we are all still human, and mistakes can be made. Look up the recent 737 MAX8 crashes if you haven't already. Now the most interesting part for people new to safety-criticql code is usually code and design standards. I recommend looking up MISRA-C, a common "gold standard" for safe code. It prescribed exactly what you can and can't do. I'd hazard a guess that most code standards used for DO-178 compliance are at least loosely based on MISRA-C.
&gt;Manually casting it is just an unnecessary step and causes you to type more. Manually casting is a tell tale sign of a C/C++ programmer. Incompetent at both, fluent in neither.
I don't do C++ often, and have also heard that malloc'ing anything in C++ is bad practice (use the libraries instead); however, it seems as though ANSI C and C++ compilation disagrees about manual casting of malloc. C++ requires the manual cast for whatever reason, whereas C does not. Because I know C and it's a C sub, I like to stick by the C standard where possible.
About this declaration. ''' SqdQueueOf* queue = (SqdQueueOf*)malloc(sizeof(* queue)); '''
That's my point. Make a manual cast in C, and broadcast that you don't know the language. Using malloc in a C++ context is possibly just as bad, but I wouldn't know that.
Well two things: First, you wouldn't need the (SqdQueueOf *) cast, as it's redundant. Second, are you really sure you want sizeof(* queue) and not sizeof(queue)? In the example you provided, you're evaluating the sizeof the pointer of struct queue, not what it's pointing to. You might accidentally get the right answer if your struct had a size of 8 (assuming a 64 bit machine) or less, but otherwise will give you a segfault if your struct values total more than 8 bytes and you assign more than those 8 bytes.
sizeof(queue) will allocate the size of a SqdQueOf* -- not a SqdQueOf, which is what OP needs. His allocation of sizeof(*queue) is correct.
Ah good eye. I missed the * the first time around
It happens. :) Personally I don't like the syntax for that exact reason, but students I tutor use it frequently...
It's certainly not beginner friendly. However, in the undergrad CS program I was in, the first programming class was C and the teacher that taught it was awesome, really knew his stuff. I think he was thinking along the lines that if you could pull off doing C as your first language, you could put your best foot forward at other hard tasks down the road (algorithms, automata, etc).
Wrt `free` specifically or casts to `void *` generally: The only situations when you ever need to (or ought to) cast something to `void *` are for varargs or un-prototyped function arguments; e.g., int array[128]; printf("%p\n", (void *)array); The above cast is necessary because `%p` expects a `void *` but `array` has type `int *` after decay. On like 99% of ABIs in existence, the `int *` and `void *` representations are identical, so while you *could* theoretically get UB from this, you won‚Äôt in practice unless you have an absolute dick of a compiler. ‚Ä¶But of course a dick compiler can dick you over without regard to ABI.
It's the first language in the program at my University as well, though I started teaching myself a few years before I started there, and was able to get out of a couple of the classes and become a TA for them. Our teacher was a really cool guy, and I miss working for him.
&gt; Read Code: The Hidden Language of Computer Hardware and Software Well I didn't expect to spend my Saturday night reading about Morse code and Braille, but here I am - this is an interesting read, thanks for the recommendation!
I understand people saying "it's not necessary," but I'll never wrap my head around the people saying "You mustn't."
In C++ these‚Äôd be templates, but macros and header programming are as close as C gets to those. (For which I am usually grateful-ish.)
'I don't know' should really be split into 'implementation defined' and 'undefined'... because when 'implementation defined' wasn't an answer I thought I had to pick one...
Indeed. That is one of the reasons I don't do stupid stuff like that nowadays.
Are you referring to code doing exactly what it is suppose to do and nothing more? Think about it this way: some advanced cockpit displays allow pilots to configure their displays, for example where their attitude indicator is on screen. Let's say you (the developer) decide it would be nice to be able to save these settings to non-volatile memory so that the pilot doesn't have to reconfigure everything every time. You decide to save it once per hour. Sounds good, right? But imagine what could go wrong. Maybe it takes one second to store the settings to memory (maybe it is a very slow but reliable FRAM). In the one second it is storing perhaps that reduces available memory bandwidth, and the flight controller now doesn't get an attitude update on time. The plane hits turbulence at the same instant that your code is saving the settings, and it gets stuck think the aircraft is continuously pitching up, so it pitches the nose down suddenly. Best case scenario everyone is jostled around and it is uncomfortable. Middle case might be a flight attendant hits the ceiling and breaks his/her neck. Worst case is the aircraft isn't high enough off the ground to recover and it plows into the ground. That's why the code shall only do what it is required to do: only the required code goes through the process to verify it works properly as part of the system.
I'm on your side. I'm just talking about the explicit casting of the malloc() return.
check in len\[i\] the biggest number, thats the hight of the histogram. Then start to print spaces or # for each len\[i\] and count down every time you print #
Oh gotcha. So my comment doesn't make any sense but I'll leave it in case anyone has the question I answered :)
There is no portable way to do this. Different OSs may provide their own functions or interfaces to find this information. For instance, a process that examines `/proc/self/maps` or `/proc/self/smaps` will tell it about every memory mapping in that process.
I don't need it to be portable and I am using Linux so I will look into those. Thanks!
You're not supposed to cast mallocs in C, that's a addition from C++. Void pointers are automatically promoted and it's an unnecessary step. In addition, it can cause a problem if you get the cast incorrect or don't update it for a changed type.
C++ requires it because their type system is subtly different. In C, a void pointer is automatically promoted to it's target type. Or more accurately, it has no type and just points to a block of memory represented by the target's pointer. It's a moot point regardless as you should be using new/delete in C++; which are type safe and class-aware.
On linux I use this to see total memory allocated: void print_maxmem(void) { char buf[64]; sprintf(buf, "grep VmPeak /proc/%u/status", (uint32_t)getpid()); system(buf); } It works pretty decently.
Makes sense. Thanks for the clarification
Thanks for the input. What this did was print out: VmPeak: 4468 kB Is there a way to get addresses too so that I can manually put things into various locations?
What on Earth are you trying to accomplish? Unless you are debugging or doing some weird hacking stuff you don't need to specify your memory address locations.
This definitely falls in the category of 'what are you actually trying to do?" Anything dealing with what memory you "have" is not portable. For a particular platform, there is lots of information if you dig it up. But any answer is complicated. What does it mean, "have" memory? You can get the stack pointer, easily, but that will not tell you much useful about heap memory.
Ah gocta ya, makes sense to me, thanks.
I thought the stack pointer would tell you where the top of the stack is at and so if you had an absolute range of addresses you could figure out how much heap you had, i.e. I know that stack grows bottom up, or top down depending, the rest is heap, then if the stack pointer is at location x then from there to the other end of the range is how much memory in the heap.
It sounds strange but I want to treat memory like three dimensional space and have "entities" or "agents" move through it, i.e. acquire some block of memory, release it, acquire adjacent block, etc. and I want to have a set of rules which govern movement through memory, kind of like a cellular automaton. Again, I guess I can just create some structure that takes up a huge piece of memory and then just spits out pointers as needed, but I thought it would be interesting to do this "raw" right in the heap.
Just malloc a large block of memory and then you'll know exactly where it is and how big it is.
&gt;you don't suffer any penalty for function calls Oooh hadn't thought of that.
I only cast the result of calloc in one specific situation, and that's when I'm doing some semi-fancy runtime type info shit that involves the use of void pointers., and that's only so I can use regular array access syntax `[]` on the arrays.
That's not how memory works in practice.... In any modern OS, each process has its own memory map. The heap and stack are specific to the virtual memory for the process. If you want to treat memory like a 3d space, you can just allocate as much memory as you want from the heap and treat that space as a 3 dimensional memory of size X. Within performance bound limits, you can have a tremendous amount of space. If you just grab memory without allocating it from the heap, you will get segment faults, as the OS will not have allocated the memory to the process. The difference between the bottom of the stack and the "top" of the heap is not accessible or well behaved, even if it kind of works sometimes.
imho it‚Äôs misleading question within your quiz‚Äôs context. The language is finitely precise within its definition (specification). So knowing is equal to one‚Äôs familiarity with the definition. The context in which language operates is not constant, therefore results of its operations are not identical. That‚Äôs what low level programming is all about. By knowing context one could simulate portability perhaps, although I cannot tell if that‚Äôs possible to achieve in C.
addresses are dynamic and change everytime. you can use linked list to store data in a contiguous way.
A) [winsock](https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-socket) B) [Windows API](https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list) or [Directx](https://docs.microsoft.com/en-us/windows/win32/directx) Have fun studying. You'll have to do a lot of it.
It wouldn't surprise me if Valgrind does not care about `brk` or `sbrk` usage. The documentation for its leak checking only talks about `malloc` and `free`, so it may only look at that (and presumably `mmap`, along with `new` and `delete` under C++), especially since modern applications make little use of `brk`, and even less frequently decrease the `brk` to return memory to the system.
That's what I was thinking, well I suppose it serves me as an exercise to make use of mmap() and munmap() but I will write a small test program and pass it to valgrind before proceeding any further.
"C's errno is not something to emulate" Why not? I just want to provide the users of my library functions ranging from familiar ones such as errno emulation to complex ones such as thread-safety with reentrancy.
Use your own memory allocator aka call my_3d_malloc which calls malloc under the hood after your checks and alterations.
Putting macros in headers just seems like an all around stupid idea, that's not what headers are for.
Yeah, looks like I'll just malloc the memory and use it that way. In regards to your statement about being able to get a tremendous amount of memory; how much? If I have a run of the mill laptop with 4 or 8 GB RAM running Ubuntu could I malloc up to like 2 or 4 GB?
.Function\_Initialize is a pointer to a void \*fn(void). That's different than PNGOptions \*fn(void). I think the easiest solution would be to make each spesific function a void \*XXXOptions\_Init(void); also.
You can autoconvert void pointer to another pointer. But you can't convert ex. an array of void pointers (void**) to an array of another pointers type. The same way the returned type of a function pointer has to match. You can't convert a function pointer returning a pointer to void to another function pointer type. Because another pointer type alignments and sizeof may not match.
Scored 5/5, i must be good
The C standard library describes a very limited set of functions for I/O, which is what "accessing the web" and "generating pixels on the screen" are. If it's not simple file manipulation or interacting with streams, you're going to need to use external platform APIs. For Windows that's the Win32 API, and for *Nix it's mostly the POSIX API though there is some fragmentation there. For graphics you'll need to pick one of the many graphics APIs out there. On Windows there is DirectX, on Windows and Linux you can use OpenGL, and on Mac there's Metal. There's also Vulkan which can run on all three, but needs a shim (called the MutanVK layer) to run on OSX.
Couldn't you just call waitpid with the WNOHANG flag in a loop? If you go that route you should put a small sleep in there so that it isn't constantly checking.
&gt; In what way can I change the architecture of the program? Generally speaking you'll want to handle the `SIGCHLD` signal. The default action for this signal is for it to be ignored. If you install a signal handler for it, however, your process will be signalled when one or more child processes have terminated. The handler may be called only once even if multiple children have terminated. You can either use `waitpid` within the signal handler, or you can set some flag that will be examined elsewhere in your program to call `waitpid`. The latter option may be particularly useful if your program uses an event loop. One of the `wait*` functions _must_ be invoked to reap a terminated child process, unless you have previously _explicitly_ set the `SIGCHLD` action to `SIG_IGN`. Technically speaking this last option is only available since POSIX.1-2001, so if you want maximum portability you cannot rely on it. Note that you must take care within signal handlers to only call so-called "signal-safe functions".
Tell us more about the flow of your program and the purpose/job of the parent and child(ren)... along with what the `getArchivePreview()` function does and when it's called... otherwise we're left to guess..
Sounds like a job for signal handlers... try this: 1. Install a signal handler on the parent to catch the `SIGCHLD` signal. 2. Within the signal handler function, use `waitpid` with `wnohang` inside a `while` loop. 3. Break the loop if `waitpid` returns an error code. #include &lt;signal.h&gt; /* for signal() */ int main(int argc, char **argv) { ... if (signal(SIGCHLD) childHandler) == SIG_ERR) { exit(1) // signal() failed } ... } void childHandler() { pid_t pid; while(1) { pid = waitpid(-1, NULL, WNOHANG); if (pid &lt;= 0) { break; } } }
The C standard says that a char has to have at least 8 bit and that is consistent with historic practice. The question concerned the code point of `' '` which differs between character encodings.
You could use a thunk to fix this: void *v_PNGOptions_Init(void) { return PNGOptions_Init(); } and then use `v_PNGOptions_Init` in the table, since this function has the right signature for the table.
&gt; You can't convert a function pointer returning a pointer to void to another function pointer type. Because another pointer type alignments and sizeof may not match. You can do the conversion, as long as you don't try to actually call the function through the result. Furthermore if you convert back to the original type then it's guaranteed to reproduce the original pointer.
One option could be to use an intermediate process, that would fork again and alarm+waitpid, and either just return the exit code of the real child process, or terminate with SIGALRM after so many seconds. btw, O\_TRUNC missing from the open flags ?
Does your laptop have a hard disk or SSD? Hard disk setups may have a swap file/partition, which Linux will use to offload infrequently/least recently used areas of RAM when necessary. This is invisible to the program running, it just means you can allocate and use much more memory than your physical RAM can support. Even without a swap file, typical pc/laptop Linux setups will have overcommit enabled. This means Linux will happily provide (or at least appear to provide) memory for huge allocations, on the understanding that the program hopefully won‚Äôt actually try to use all of it. It‚Äôs only when areas of the allocated memory are *written to* that real RAM is used. For example, on a 4GB RAM 64-bit machine with overcommit enabled, you could allocate terabytes of memory fine. When you try to write to parts of it, real RAM is used, 4KB at a time typically. So if your program needs to have a big space to work in but only writes a few bytes here and there, widely spaced apart, you won‚Äôt need that much actual RAM to do it.
&gt;This is in C# And this is C subreddit :) `goto r/csharp;` maybe? ;)
Can you provide a draft of what the code should look like? And how it should work?
So you would like to do something like this? void function_b(); void function_a() { int i = 35; function_b(); printf("%d", i); } void function_b() { i = 643; } If yes, then that's not really possible (unless you do some dirty hacks with stack modification which are **not** a good solution at all). If you would like to modify a local variable of a function, you'd need to provide its address to another function using a pointer, or make it a global variable.
void initialize (int number\_case){ static int tos\[number\_case\]={0}; // this tos list should has 0 or 1 means full or empty &amp;#x200B; &amp;#x200B; } int searchFreeSector(){ int i; for(i=0;i&lt;tos\_length;i++){ if(tos\[i\]==0){ return i; } } printf("all sectors are full"); return -1; &amp;#x200B; } &amp;#x200B; i know it has a lot of errors , it's just to show a global idea of wut i want!
Hmm, maybe what you want is some sort of OOP? But then you might want to look at other languages, or at least C++ instead of C.
yeah i know it will be easy to do it with java but the project should be done in c
i see wut u did but i dont want to use function in another function i want to do smthing like this: void initialize (int number\_case){ static int tos\[number\_case\]={0}; // this tos list should has 0 or 1 means full or empty } int searchFreeSector(){ int i; for(i=0;i&lt;tos\_length;i++){ if(tos\[i\]==0){ // here is the prblm this tos\[\] is created by the function above!! return i; } } printf("all sectors are full"); return -1; }
Use global variables?
but the initialize function will has no sense?
It's still a good idea to separate init and processing. Depends on how big your program is going to be.
You can hack it a bit. Have a structure which contains the array and a function pointer. The first function return a instance of the struct, the function pointer accepts the struct as it‚Äôs first argument and you‚Äôve got poor mans classes.
tos\[\] could not set the size like that. Make tos and related variables static in that file. Something like static int tos_length, *tos; void initialize(int n) { tos_length = n; tos = calloc(n, sizeof (*tos)); if (tos == NULL) abort(); }
yess but pointers are not allowed
You can make `tos` a global variable
The main issue is that `errno` concept was invented before threading, and it's essentially incompatible with it. It requires some hacks to make it work correctly in the presence of threads. Let me elaborate. Functions in C can only return a single value, and there's not always an obvious way to communicate an error value in-band. So unix's designers came up with `errno`, a global variable, as a kind of second return value by convention. For example, `mmap(2)` returns a pointer. When it fails, it returns a special `MAP_FAILED` pointer (usually `(void *)-1`). Why not `NULL`? Because that's a legitimate successful return value for `mmap(2)` (address zero is page aligned). `MAP_FAILED` is an invalid address for the start of memory map, so it can never be returned by a successful `mmap(2)` call. Since `mmap(2)` already has to do something weird just to communicate an error, how is it supposed to indicate which of the 11 possible errors (according to my system's man page) occurred? Store the error in a global variable, `errno`, as a kind of second return value. In practice, the [Linux kernel *does* communicate errno values in band](https://nullprogram.com/blog/2016/09/23/), and the C library splits it into `errno` and the function's documented failure value. However, it doesn't necessarily have to work this way on other systems. What happens when two different threads use `mmap(2)` at the same time and both fail? If `errno` is a global variable, then they both receive their second return value from the same place. One of them will likely get the wrong error. Worse, there's no synchronization around accessing `errno`, risking a data race. And there's [no such thing as a benign data race](https://software.intel.com/en-us/blogs/2013/01/06/benign-data-races-what-could-possibly-go-wrong). In practice today, **`errno` is not actually a global variable**. It's only *like* a variable in order to emulate that old global variable interface designed before threading. The actual definition looks something like this: #define errno *__geterrno() The function `__geterrno()` return the address of thread-local storage (TLS), and the macro quietly dereferences it. Since it's thread-local, each thread safely retrieves its own error value. It's also valid as an *lvalue* ‚Äî i.e. you can assign `errno` just as if it were the global variable it pretends to be. TLS isn't free, especially if you use the pthreads version (dynamic) instead of via compiler extension (generally more static). That overhead is one reason why C library functions don't set `errno` to zero when successful: Don't pay the overhead cost in the common case. So, to emulate your own `errno` in this library specifically designed for multi-threaded programs, you'd have to set up TLS and then define a macro for accessing it. *Or* you could just modify your API to return error values directly, which is simpler, more efficient, and demands less from the run-time.
It will have the 'sense' of tos if it's global, because everything can use globals. You need either pointers or a global. Why can't you use pointers?
Have you read the sidebar of this sub? Lots of great resources.
In C, only cast when the compiler fails to compile because it's missing. It's as simple as that.
First hit on Google for C11 atomic: https://en.cppreference.com/w/c/atomic As far as lockless goes, lockless data structures aren‚Äôt necessarily faster. Depending on contention, locked structures may be faster. Even then, things like futexes further muddy what‚Äôs best.
yep i know that but the context of the project refuse dynamic allocation
So allocate a fixed size if it's constant.
Ah you see I‚Äôm a mobile user. (I rarely use Reddit on my desktop). I didn‚Äôt even know such thing existed. My apologies.
From another comment somewhere I wrote: People al... https://www.reddit.com/r/C_Programming/comments/c9le8b/hello_new_to_programming_i_was_pointed_to_c_any/et06306?utm_medium=android_app&amp;utm_source=share
Deciding on an API is the simple part. Writing a library that implements it is what is hard. I suggest you to change your use of the word API as it's a bit irritating.
do u mean: int \* tos = malloc(n\* sizeof (tos))
If you use reddit is fun as your mobile Reddit experience, you can access sidebars in subreddits! But if you're starting off a lot of people will recommend K and R, and rightly so, but my advice is start looking up YouTube videos by thenewboston as well. Great streamlined beginner series if you're new to C or programming in general. If you've experience feel free to skip ahead, but it does a good job of introducing the syntax of C.
No. I mean a statically sized array. #define TOS_SIZE 200 // or however big you need. int tos[TOS_SIZE];
Why does the cpp website has reference to C11 but there's no man pages .. I must have just ignore the hit by instinct
and then i point a pointer on that list , that's wut u are saying?
Then you don't need a pointer.
As a Dune fan, *using atomics* just keeps sounding so funny. -1 myself
Couldn‚Äôt tell ya, strange for sure, but I only use man pages if I don‚Äôt have an internet connection.
yes this is the first idea it's global variable but wut i wanna do is initialize the array with a function not manually and when that function initialize that array i want to use in other function, it's like when a function return a pointer point on the first element of the array but in my case i dont want a pointer i want a static array...!!! anyway thank alot
I'm so confused. You keep saying pointers aren't allowed, then asking about doing it with pointers. Why can't you use pointers? You haven't answered this yet. Are you confusing pointers and dynamic allocation?
handmade hero streams + his intro to c videos
This is kind of meta, but once you start learning from a book, digging into real code is a good place to see how production-level C is written. Browsing source code on github and reading through code trees of things like FreebBSD have been very helpful to me. For example, cat.c and echo.c in the FreeBSD source tree are well written and obvious functions if you‚Äôre familiar with command line tools. Also, reading style guides is helpful for seeing the kinds of conventions C programmers stick too (Linux kernel development has a nicely written style guide, as do the BSD operating systems). Digging through that code can be an exercise in frustration because it won‚Äôt all make sense, but it‚Äôs nice to see the stuff that does make sense, and it all starts clicking.
Ok I think all that is fixed. Did I miss something?
Most of the manpages of that sort are for POSIX (check the heading of the first page; e.g. &lt;stddef.h&gt;(P) POSIX Programmer's Manual ), not the C standards per se. POSIX includes C99 so the 7p manpages include most of that standard, but POSIX never adopted C11 fully because C11 threads were broken (i.e., defined sth they were unimplementable on top of pthreads) until C18, so any manpages for that stuff will be iffy and usually tacked onto something else (e.g., the manpage for `posix_memalign` includes info about C11 `aligned_alloc`). C11 atomics are also more of a compiler thing than an OS thing, since they were intended to replace the mix of semi-incompatible things like `__sync_fetch_and_whatever` on Intel‚ÜíGNU compilers and Microsoft‚Äôs `-Interlocked`- intrinsics. Because of that, the libc end of things doesn‚Äôt need to bother much with implementing atomics etc., just as they usually don‚Äôt have to implement `stddef.h`‚Äîeven an unhosted implementation should include those headers with the compiler. If you look at the [GCC infopages](https://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html), there‚Äôs a section on the `__atomic`- operations and `__ATOMIC_`- predefined macros, which were established so that C11 atomics can just `#define`-map things to those builtins. That‚Äôs probably the closest to an `&lt;stdatomic.h&gt;` manpage I‚Äôve seen. Otherwise, find a late draft of the C11 standard (e.g., [N1570](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf)) and work from that.
Might want to look at stuff like `pselect` also, which would let you wait for user input and safely (pseudo-atomically) unmask‚Üícatch‚Üíremask `SIGCHLD` without needing to do any especially crazy stuff in signal handlers.
From a language perspective, computers are more alike than in 1989. By any reasonable measure, more than 90% (and by most measures, more than 99%) of C targets could support a family of dialects which are alike except for endianness and the sizes of their primitive data types, but which would support "popular extensions" that would allow many tasks to be done efficiently without having to be tailored to a particular compiler. Unfortunately, compiler writers have been focused on trying to find ways to "optimize" the language without requiring any new syntactic constructs for that purpose, at the expense of requiring new syntactic constructs to exploit what used to be "popular extensions", with the net effect that they simultaneously throw compatibility out the window and make it impossible to pursue more useful opportunities for optimization. In many application fields, it will be necessary for programs to perform many calculations which will either be meaningful or irrelevant, without knowing in advance which ones will be meaningful. Letting compilers know that certain calculations may be treated as being or having been irrelevant if certain conditions arise (allowing a compiler to substitute whatever values are convenient) may allow more optimizations than would be otherwise possible, but *only* if behavior remains adequately defined to allow such constructs to be used in correct program executions. Requiring that irrelevant calculations be performed in such a way as to have *fully*-defined behavior at all times will negate most of the opportunities compilers would otherwise have to optimize out irrelevant calculations. In the 1990s, it was widely recognized that quality compilers should seek to efficiently support popular extensions, and be compatible with code that exploits them, without regard for whether the Standard would require them to do so. Unfortunately, judging from their support forums, some compiler vendors regard any code that uses such extensions as "broken", and view a refusal to process such code as "cleaning up" the language, thus creating a compatibility environment that's in many ways more dangerous than the one in which C89 was created.
I'm already familiar with Tcl/Tk so I'll often open a C program as a pipe within a Tcl/Tk script and use that. This has the advantage of forcing you to seperate the "guts" of the thing from the UI. The result may have a fairly 1990s aroma. It also means you can write a test driver for the C program as a peer to the GUI. If a pipe is inadequate connectivity, then there's always using sockets. You can spawn a thread within the "guts" program to handle UI asynchronously from the rest of the program. SFAIK, you can use Python with message queues to do the same but Tcl has both sockets and pipes as first-class citizens built in. It does not help that OO and async seem to often be at cross purposes.
I'm a big fan of Tk within Tcl scripts but I'd have to agree - GTK isn't my first choice.
yep maybe i'm confusing it cuz when i hear pointers my head automatically think of dynamic allocation! could u suggest all the answer (the initialize function with no dynamic allocation)!
CS50. Do it through edX. Please dont listen to "read K&amp;R book". They dont know what they are talking about.
Elaborate? K&amp;R is a great place to start?
Lol he must be trolling. "The creators of the C language don't know what they're talking about." What a laugh.
Right. When you write `' '` in your source code, it's well-specified (primarily by your compiler) how that will be translated into a number. As a separate issue, a `char[]` in C has no "encoding" and is not meant to. It is an array of 8-bit numbers. It may represent a string of text, subject to a particular encoding, or it may not. Between the name `char` and the fact that there's no high-level C data type for a string, it is confusing to some.
Elaborate?
How so? Is it the best option into getting into C?
This year, I've read a few books on C, mostly dealing with "modern C". I started with the older books, but realized that even though they are helpful, C doesn't look like that any more. All of these books disagree with, or contradict each other about what is "right", or what is "accepted". The old books (20+ years) are stuck using K&amp;R C, or C89, and even when they update them it doesn't get much better. One of these "newer" books said something that stuck with me though. Just get in there and start hacking. Make a library with good documentation, that's easy to use, and put it up on GitHub or somewhere. Use the modern standards. There have been some really nice improvements. Just start making something, and if it's useful then share it, because the more libraries we have to choose from, the easier things will be. C has so many tools. Some are really old, but super useful. `gdb` (or a GUI like `Kdbg`) for debigging, `make` for easy compiling, `automake`, `autoconf`, `libtool`, `pkg-config` for easy compiling on different machines (sharing), `doxygen` for awesome documentation built from the comments in your source code. They are all made to make things easier on you. Use them, and learn how to step through your code in a debugger when things go wrong. The books that helped me get pretty technical at times, but it's necessary to get things burnt into your brain. I think all of these are available in PDF format: **21st Century C** This is one of my favorites, it's from 2013. It introduces you to all of the tools I mentioned above, and has a "just start making stuff" message. **Expert C Programming (Deep C Secrets)** Very nice, shows you how we got here from the 60s-70s. It has real world examples and some light relief. **Modern C** Another good one, from 2015. It uses the C11 standard and introduces you to things like `_Generic`. **Object Oriented C** This is sort of an advanced book. It has a lot of good info in it, but it also showed me what C is "not". I read it because I wanted to understand the Cpython source code, and know how they are building "objects" in C. I haven't finished it yet, I had to take a detour and read the other books first. This is from one beginner to another. I'm still learning myself, making little header libraries and rewriting my scripts in C for practice.
It's the classic textbook. Written by creators of the language.
&gt; When you write ' ' in your source code, it's well-specified (primarily by your compiler) how that will be translated into a number. It's implementation defined what number corresponds to `' '`. Thus the only answer that can be given to that question is ‚ÄúI don't know.‚Äù
Programming in C by Stephen Kochan, then Understanding and Using C Pointers by Richard Reese
I hinted at something like this in my top level comment. Yes, it's full of great information from the creators of the language. It's also very old, like the language. If that book was written with modern standards in mind, I don't think it would look the same. Go ahead and read it, but also read modern source code and books. You'll see what they're talking about. I wouldn't say "don't read K&amp;R", but I would say "don't stop at K&amp;R, you need to get caught up to 2019".
The best and correct book for C is ANSI C by Dennis Ritchie(the person who created the C language). But don't jump directly to this book, it's no joke. First, do an easy book on C like Let US C by Yashwant Kanetkar. I have been trying to complete Dennis book from the past 4 years, that's how hard it is. But if you don't do Dennis book then you can't be sure whether you have mastered C.
continue;
As far as textbooks go I liked *C Programming: A Modern Approach* by Kang. This pdf was really helpful to understand how pointers work: https://pdos.csail.mit.edu/6.828/2014/readings/pointers.pdf
Really fast uninformed idea: have you tried wrapping the space by use of modulo operators?
That's not where the problem is though. The particles do "loop" to the other side of the universe. What I'm having trouble doing is temporarily "undoing" this relocation to compute the force applied to another particle that didn't get relocated. It should be a simple vector addition, but I'm trash at maths.
Which other particle? Do you have an article going alongside this project that explains in human language what it does in each step? I find that writing out exactly what it does, and why, as if explaining to a bunch of highschoolers, makes me realize a lot of mistakes.
Unfortunately the article isn't written yet - I'll try explaining what the problem is. The program loads a set of points (atoms), linked together by springs (bonds). They are in a cubic universe, and if an atom leaves from a side, it "loops" back to the other side. I tested it with systems that have no bonds, and it works GREAT. It's exactly what I want. There is a problem though. If an atom loops back to the other side of the universe but the one it is bonded to doesn't get looped, the springs gets extremely streched in a completely different direction. This creates insanely strong ghost forces and fucks up the system. The issue is that I cannot figure out how to temporarily "unloop" the atom to calculate the effect of the spring on the two bonded atoms.
I see the problem. What if you use the untampered, unlooped coordinates everywhere in your backend, and only when writing the xyz file do you loop them?
Another idea: keep track of how many times an atom has looped, or under/overflowed the world borders. Multiply this number with the size of the world (say you have overflowed the y axis once, you will then add the height of the universe*1) and add that to the coordinate the string/bond is acting on. The problem you have arises because the spring/bond makes a direct euclidean line to the atom. It does not know to loop around.
Unfortunately, the spring isn't the only interraction there is to compute (the main one being a more realistic version of colision), and some actually require to take into account the displacement. So I can't do that...
You'll want to change the for loop to `while (i &lt; with)`, and then inside the loop, increment i only if you have a valid withdrawal.
Have you read my other comment? The only option I see in this case is sometimes factoring in the overflow count, and sometimes neglecting it. Also, does this mean that a molecule that juuuuust fits when oriented diagonally will collide with itself when rotating to a more horizontal orientation?
Do not post pictures of code. I have removed your question so you can repost it with code as text instead of a picture. Please also post sample input and output as text instead of pictures.
Yeah I posted this just while receiving the other comment. I'm trying something right now - if the distance between the two particles is greater than half of the universe's length, it is shifted by the universe's length so as to get it closer. Otherwise it is left as is. For the collision, all particles are treated as points, but should they get too close a strong repulsive force is applied. A point can't interract with itself, so there is no such collision
If that distance doesn‚Äôt exceed the possible length of a bond I see no problem right now. I‚Äôm wondering why you chose to limit the space in the first place though. Things moving out of view?
It's limited because of thermodynamics: If the universe has no limit, the particles won't ever interract again. **There is no way around that**, the first law of thermodynamics clearly states that the system will progress towards maximum entropy. Another issue is that there is no concept of pressure if there is no limited volume, and if I simulate something I want to be able to tell the current pressure :) So, unless I want to see how things get away from each other, which is pretty boring compared to seeing how they behave with each other, I have no choice but to implement a way to keep the universe closed. My first take on this problem was to have a spherical universe, and if the particles ever left it, a strong spring-like force was applied pulling them back. The thing is, it introduced kinetic energy into the system breaking the thermodynamics (it's supposed to be a closed system). In a "looping" universe (=with periodic boundary conditions), the thermodynamics are OK. Linear momentum is conserved. Angular momentum isn't conserved, but since I am dealing with point masses and no solid objects, I don't think angular momentum has any physical meaning. ---- For the view, any software capable of visualising `.xyz` files has a movable camera, so it's not an issue. But sometimes the glitches are so strong that particles cannot fit in a 64 bit system anymore aha :)
Ah, I see. I recently made a particle simulator (not in C though) that just mirrored the velocities when it hit a boundary plane. That's probably harder to do with complex systems like molecules
Nobody really uses these macros. I think I can count the number of occurrences of the queue macros on one hand and I've never seen a single use of the tree macros.
Honnestly, it's not. If your system is Newtonian/classical, the only difference between my program and yours is the force computing system. I compute real-life forces using mathematical models, you compute forces based on your program's needs. ---- If you want some e x t r e m e realism for looks, you could instead of mirroring the velocity vector (which I suppose is just a quick-and-dirty `v = -v`), have the particle bounce off based on the angle it makes with the normal vector on the wall's surface ! That's how it's done with ray optics anyway.
There isn't a "correct" way to learn C. Pick an IDE with a good debugger, find a book you like the look of, work through it, then try to convert the code you wrote for AP CS to C. It's most important to get going without fretting. I'd also stick to writing command line interfaces. Don't worry if you don't deeply understand something right away. Just focus on knowing how to use it for now. What I didn't know when I started learning C when I was 16 is that just knowing C by itself isn't really all that useful. To really master C, you have to have some knowledge of how processors work, some knowledge of assembly programming. You also need to understand the process of compilation, linking, and dynamic loading. Virtual Memory and paging/page tables are important to understand too.
Is this the literal description you received? Because to me, there are quite a few ambiguities in it.
Nontrivial lockless data structures are very difficult to design and implement. Good luck!
You just need to do the first 6 (or 7) lectures cs50 from Harvard through edX. You don't have to look at K&amp;R book at all. CS50 is made by the teaching experts, it is a Harvard's signiture MOOC course and they have refined their introduction to computer science course over the years. They teach C for the first 6 lectures. They built the course from all sorts of good elements in teaching C including K&amp;R.
One of the best resources I've seen for atomics is Herb Sutter's \[atomic Weapons\]([https://herbsutter.com/2013/02/11/atomic-weapons-the-c-memory-model-and-modern-hardware/](https://herbsutter.com/2013/02/11/atomic-weapons-the-c-memory-model-and-modern-hardware/)) talk. It's really meant for C++, but the memory model is the same. Once you're familiar with that understanding the C11 atomic API is obvious. Learning about lock-free data structures is‚Ä¶ more complicated. I mostly just read papers for various techniques I was interested in (and anything interesting in their bibliographies), but Maurice Herlihy's *The Art of Multiprocessor Programming* is probably a good starting point.
Please don't post this kind of content.
The instructions given are always very bad, as they're badly translated from french. What seemed ambiguous to you? I'll more than happily edit the post to correct this.
I tried rewriting it to be a little bit more descriptive, but It may be just as bad, given that I'm unsure which part you're having trouble with.
Pretty much v=-v, but only on the axis normal to the reflection surface. That way you get the realistic reflection implicitly.
Some random ideas: - molecules are small. If the universe is large, any time you see a separation (along any one specific dimension) between atoms which is more than say 0.1 * the size of the universe, assume that the molecule straddles the universe boundary, and reduce the dx (or dy or dz) value by the wrapping delta - make the boundary of the universe fuzzy. Don't wraSome random ideas: - molecules are small. If the universe is large, any time you see a separation (along any one specific dimension) between atoms which is more than say 0.1 * the size of the universe, assume that the molecule straddles the universe boundary, and reduce the dx (or dy or dz) value by the wrapping delta - make the boundary of the universe fuzzy. Don't wrap a molecule's position until all its atoms are outside the boundary. For forces which apply between molecules, set these to zero for all interactions between molecules either of which currently spans the universe boundary (essentially as would happen if they had actually been wrapped already) ... but then I don't know anything about computational chemistry, so this could all be dangerous nonsense. p a molecule's position until all its atoms are outside the boundary. For forces which apply between molecules, set these to zero for all interactions between molecules either of which currently spans the universe boundary (essentially as would happen if they had actually been wrapped already) ... but then I don't know anything about computational chemistry, so this could all be dangerous nonsense.
Why not just have them bounce off the boundary of the spherical Universe? That would conserve kinetic energy, instead of adding it.
If I understand your programming problem - you need access to the atom's state in a previous iteration so you can calculate the spring? The easiest thing to do would be to create a global universe structure that you update (or over write) upon completing the current iteration. That way you can look back at the previous state and you don't have to add another parameter to all your functions. I'd consider making more use of global variables/data structures. Your passing references around a lot , and it looks like you are only ever instantiating one instance.
I haven't thought this through completely, but it would mess with the interractions, create localised points of high pressure/potential, prevent uniform solvent distribution, and ruin the "simulation" aspect of dealing with fluids.
is there a free version?
The Standard may not recognize any distinction between code which is portable to every conforming implementation that could theoretically exist, and code which is likely to be portable to all future implementations that don't use the Standard as an excuse not to support it. Given that an implementation can be conforming without being able to meaningfully process any useful programs (\*) I'd say focusing on making programs portable to implementations that make a good faith effort to behave in common fashion should be more useful than trying to write code to be proof against poor-quality implementations or those for systems upon which it will never be used. (\*) From the published Rationale for the C99 Standard: "While a deficient implementation could probably contrive a program that meets this requirement, yet still succeed in being useless, the C89 Committee felt that such ingenuity would probably require more work than making something useful." How many practical C compilers for commonplace platforms don't use ASCII for the C Source Character Set? Would one need any fingers to count them all?
A major weakness with the design of the C11 atomics is that the Standard offers no means by which an implementation can indicate whether or not they will be atomic with regard to anything that happens outside the implementation itself, nor does it offer any guidance as to when/whether a freestanding implementation should be expected to process atomics that aren't directly supported by hardware in a way which is thread-safe, interrupt/signal-safe, or both, despite the fact that many applications would only require one or the other, and the cost of implementing both will often vastly exceed the cost of implementing one without the other. If a complex atomic operation only needs to be thread-safe, then operations in process can be allowed to run to completion while conflicting operations are deferred. If it only needs to be interrupt/signal safe and a signal/interrupt handler needs to perform an operation when a conflicting one is already in process, it can take over the pending operation since its execution will be blocked until the handler returns. The C11 Standard, however, offers no way of controlling or inquiring which approach an implementation will use.
A big problem with locks is that they often leave one with no way of recovering if the owner of a lock gets waylaid. If a consumer of a lock-less data structure gets waylaid, all that will mean is that there's less contention for the resource.
Love this comment. The only thing I really disagree with is your acceptance of the clutter and DRY criticisms. While this is valid if you write `(Foo*) malloc(sizeof(Foo))` all over the place, I'd argue that you shouldn't be doing this anyways‚Ä¶ you should be using a macro. Something like #define ennew(T) ((T*)malloc(sizeof(T))) This removes the need repeat yourself but still preserves the type safety, and it's even easier to read than "normal" malloc without a cast: Foo* foo = ennew(Foo); I threw together [a header](https://github.com/nemequ/attic/blob/master/enmem.h) for this stuff a while back which you might be interested in. It basically takes this idea as far as I could figure out how, including dealing with arrays, resizing, etc. The code definitely gets a bit gnarly, but it's not *that* bad and I'd much rather move that complexity into a common location than have a bunch of ugliness spread all over the project.
I think you can find result by searching 'push_swap project'. I have done this exercice once, step by step : - Split the input data in the 2 lists - Sort the lists (bubble sort with shifting) - Merge the 2 lists That is quite simple, not really optimized, but it works.
Still no reason to suggest someone doesn't read K&amp;R. It's a historical primary source which undeniably helps people understand the language. Sure there is a lot you need to read afterwards to get caught up to modern best practices, but saying "don't read K&amp;R" is asinine!
I admit that I don't understand the problem domain completely, but it sounds like you're implementing some sort of ring buffer in 3D and having problems dealing with arithmetic around the wrap. If that's the case, I recommend [this article](https://www.snellman.net/blog/archive/2016-12-13-ring-buffers/) which rethinks circular buffer math.
You could potentially have an Employee struct, containing a Name variable, pay variable, and hours worked variable to store. Then, it's as easy as math and conditionals to figure out how much they owe, what their pay is, etc
Look at solutions for Towers of Hanoi problem
I‚Äôm guessing your more asking about how to break the problem down into programmable pieces, 1) data entry 2) processing 3) display results As already suggested you could do a structure to contain each employee, after all employees are entered run the math then display starting with the first (Or last or whatever order) employee
If input is your problem, take a look at (scanf)[https://computer.howstuffworks.com/c7.htm] If you are struggling with the language more generally, there are some good resources in the sidebar. If you have a more specific question I'm sure someone here would be happy to help.
What i usually do when faced with any kind of programming problem is to try and break the problem into smaller ones. I won't go into implementation details because this looks like homework but I will give you some guidelines so that you can reach the solution by yourself. &amp;#x200B; The problem can be divided into 3 parts: * Reading the input and (potentially) storing it somewhere. * Processing the data so it has the desired form. * Outputting the processed data. &amp;#x200B; Now that these are established, you should break each of the parts into even smaller ones, for instance: * How is input read? do I need to store the read values on a variable? Do I need to pay attention to the type of the data I am reading from input? Is there any type conversion going to be necessary? * What do I need to do with the data? Is any calculation over it necessary? If so, do i need to convert values from one type to another or are simple operations enough? How many variables am I going to need? * Do i have all the processed data stored in order for it to be outputted correctly? &amp;#x200B; Regarding your initial questions, reading different values is very simple, I suggest you read this very easy to understand tutorial on how to use the basic functions used in C to manage Input(reading values) and Output. &amp;#x200B; I feel these points are probably enough to get you started but feel free to ask any further questions. Have fun and code on!
I have become desensitized to the allocations because my company's coding standard does not allow function-like macros (i.e. macros that take parameters). The reasoning behind the rule is that it is easy to hide functionality in a function-like macro and thus possible to have code which doesn't trace to a requirement. All standards allow deviations of course, and if I could go back in time I would probably have my group submit a deviation for a macro like yours for our project. Ironically we do already have a deviation for a malloc macro which append the __FILE__ and __LINE__ macros to a custom allocator which add memory barriers and track allocations in order to allow memory-stomp detection.
Bear in mind I'm looking at this with tired eyes, but it looks like you're applying the PBC to only the coordinates and not the actual x, y, z distances (which is what I assume to_target is) at force.c:274. Essentially looks like you're checking for dx/dy/dz there and then just doing what you did at particle.c:172 again if the condition is true. PBC is not being applied to your interactions. At least, that's what I understand from your code. Let me know if I'm wrong.
(This is a friend‚Äôs project, not mine)
This is a friend‚Äôs project. The 5KB is ARM Cortex-M object code size with optimizations enabled.
Yeah, I know that's a pretty common restriction. In that situation I'd probably end relying pretty heavily on functions like `Foo* foo_new(Bar* bar) { Foo* foo = (Foo*) malloc(sizeof(Foo)); if (foo != NULL) foo-&gt;bar = bar; return foo; }`‚Ä¶ While I understand why people create restrictions like that, it's really a shame because well-designed macros can be a great tool for improving code quality and readability‚Ä¶ My code which uses [Hedley](https://github.com/nemequ/hedley) is so much better, and harder to misuse, than code which doesn't. I guess that, like a lot of things in C, macros can be abused pretty easily and people doing that have ruined it for the rest of us ‚òπ.
it's nice try, but it depends on many std libs, you can't get rid of libc on embedded devices.
It uses a few standard headers such as stdint, stddef, etc. but it doesn't call into libc. So, it's pretty embedded-friendly. The author is using it specifically for embedded systems.
What I usually do is pay attention in class, ask classmates questions or for help and ask my professor for help.
What are you trying to do? What is the output you expect? If you want to print a pointer you would call printf("%p\n", myptr); If you want to print the value that it points to you would write (assuming it points to an int) printf("%d\n", *myptr);
Just compile it with -nostdlib y link it yourself, then you see the point
Have to cast to the format argument to `void *` because `%p` expects that, but `...` won‚Äôt coerce the `int *` like a normal (declared) function argument would.
Correct, nice catch. Struggle-bussing typing code on mobile.
This will be really helpful - thanks!
what about this for every 'linked' object create a 'group' with a coordinate, so that all objects belonging to the group has their coordinate relative to this group. near a boundry, the 'render' logic would calculate the group coordinate + object coordinate and this 'may'result to appear in the other side of the universe. however, the physics only applies at group level, so there's no concept of 'other' universe inside groups
The C89/C99 boundary is of interest to me, that being the murky boundary between compiles on Windows / borks on Windows. Is nanoprintf tested with Visual Studio C++?
Might as well learn to use [fscanf](https://en.cppreference.com/w/c/io/fscanf) right from the beginning.
If you compile with arm-none-eabi-gcc using the `-nostdlib` option, you will get many link errors for missing math routines such as `__aeabi_ldivmod`; however, you can fix that by adding `-lgcc` to link with the low-level runtime library. It's possible I did something wrong, but I didn't see other linkage issues with `-nostdlib`.
I don't think the author is explicitly supporting Visual Studio yet, but you might give it a shot. According to the GitHub repo, the C99 requirement is for types such as uint64_t that you might be able to easily define if Visual Studio doesn't natively support them.
Here's a quick example in codepad. I hope it helps. [http://codepad.org/2qCrm6z4](http://codepad.org/2qCrm6z4) Notice how the address of x and x\_ptr are slightly different? It's because they're allocated right next to each other. Also, probably not helpful to print pointer values as decimals. You'll get used to seeing pointers in hex, eventually.
 #include &lt;stdio.h&gt; void test(int *x) { printf("%d\n", *x); } int main() { int a = 72; int *b = &amp;a; test(b); return 0; } should do the trick &amp;#x200B; void fooA(int *aptr) { /* overflow, because you try to print a 8 byte address with %d (4 byte) */ printf("Value2: %d\n", aptr); /* what's the reason to cast &amp;aptr as void * ? I hope your compiler drops a warning */ printf("Value3: %d\n", (void *) &amp;aptr); // } int main() { int val = 72; int *aptr; /* overflow on typical 64 bit systems, because the address has 8 bytes and an int is only able to store 4 bytes */ int x = &amp;aptr; printf("Value1: %d\n", x); /* that'll change the address the pointer is pointing to to the value of int val */ /* you need to give aptr some space to store a value or let it point on val (aptr = &amp;val) aptr = val; fooA(aptr); return 0; }
Well, he has done bad things it seems but that does not change the good things he has done. Just use his ressources. Remember, not a monster, not a animal, a human beeing. That is important.
Well, he has done bad things it seems but that does not change the good things he has done. Just use his ressources. You don't have to talk to him.
Try the Compiler Explorer: https://godbolt.org/ You can choose compilers on the fly or even have two or more simultaneously in the tabs. And if you get bored of x86, you can take a look at other architectures as well.
&gt; How many practical C compilers for commonplace platforms don't use ASCII for the C Source Character Set? The most common one is z/OS on z/Architecture (aka s390x, aka ESAME) which uses EBCDIC. The same likely applies to System i aka AS/400. It's not an irrelevant constraint.
Thanks for the suggestion. Godbolt gives the equivalent assembly code, but I need a \_learning material\_, not just code.
&gt; Solver can only modify the contents of either stack by doing one of 11 instructions. This is unclear. Do you have to pick one instruction and use that an arbitrary amount of times to modify the stack or can you pick any instruction you like each time you send an instruction? Also, can the solver look at the contents of the stack and if yes, which contents is it allowed to see? &gt; ra : shift all elements in stack a by 1. &gt; rb : shift all elements in stack b by 1. &gt; rra : shift all elements in stack a by 1, in reverse. &gt; rrb : shift all elements in stack b by 1, in reverse. I have no idea what these instructions are exactly going to do. &gt; it must also be done within n amount of steps, depending on the input What exactly is `n`? Is it just a random number you get or is it computed by some formula? If yes, what formula?
That's not going to be helpful at all.
On modern Linux, it is also possible to mask `SIGCHLD` and use `signalfd` in the rest of your event loop (whether it be based on `select` or whatever). This saves the developer from having to deal with the context switching of signal handlers. Still have to loop over `wait*` results though.
Can you please for the sake of all that is only stop with that header-only bullshit? It's absolutely useless for every non-trivial application.
&gt;molecules are small. If the universe is large, any time you see a separation (along any one specific dimension) between atoms which is more than say 0.1 * the size of the universe, assume that the molecule straddles the universe boundary, and reduce the dx (or dy or dz) value by the wrapping delta Unfortunately, interractions do occur at long ranges, and ignoring them is against the point of simulating the system as realistically as possible. I can't decide to wrap at a random cutoff distance, it has to be half the univer'se size (assuming a cubic universe)
You probably have to keep track of how many times the spring is wrapped around the universe, in both X and Y.
and why is that?
Could you please expand? I'm not sure I get it.
Why? I found stb single header library widely used
Your histogram only says "there were some words, five different lengths". It's more like a summary than a histogram.
Because you lose proper syntax errors and some stuff plays funny with the preprocessor like struct initialisations.
Try using it in a project with more than one compilation unit.
Sadly these single-header "libraries" keep getting posted and upvoted here and get starred a lot on github; many people who are starting to learn C are probably led to believe that this is the normal, correct way to write libraries.
I'll take a look at in a few hours :)
No offense but you're talking out of your ass. It's header only in name. You put the actual implementation in a .c file. It's functionally no different from a .c and a .h file. What more do you want? Are you afraid that a 1kloc header that is skipped over for the most part is going to slow down your build?
I'm [lead to believe](https://nullprogram.com/blog/2018/06/10/) that small single header libraries are good for simplicity and compiler optimisation. So instead of calling it bullshit, could you give a proper reason please?
The implementation is shared between compilation units. You need to create a .c file where the implementation lives. This library is perfectly fine to use in large projects. #define NANOPRINTF_IMPLEMENTATION #include "path/to/nanoprintf.h"
Why not supply the c file in the library itself? Code in a header file is an instant code review failure.
The actual implemention is in the header file. That's why it's a ‚Äúheader-only‚Äù library. That's why it's such a bad idea. Why not just provide a header file and a source file? I'm going to write a more detailed response in a minute.
like an spectrum vu meter
To all those asking why it's bad for this to be header only; Every time you add a header file you increase compile time by a bit (depending on how complex the header file is). Header only libraries put all their complexity in the header files, instead or split libraries where the declarations are in header files and most of the logic is in c files. During the build process, c files are only given once usually. Since you are only giving the header files multiple times, it will compile faster. This is a printf library which will be in almost every c file probably, so it will have a big effect on compile time. Nowadays with cmake, adding a library properly is much easier, so there is little reason to make it header only. Unless you manually create makefiles, which should only happen if you are doing something extreme or tying it in to some old build system.
Compilation time is only one reason. But for small header files, the difference in compile time will be negligible. Besides only in some cases will you include a single header library more than once in your code. I'm not sure how cmake is related. How is using a manually written makefile extreme? [It's pretty easy.](https://nullprogram.com/blog/2017/08/20/)
Why is it a code review failure? A lot of opinions in this thread and no actual fact.
Well you are virtually doing the same in header-only libraries by only having the implementation-part of the header file in one compilation unit, like you would in a "normal" static library. &amp;#x200B; Your cmake argument, while valid, doesn't apply to everyone since not everyone is using cmake for their project. Adding a header-only library to a project is as easy as it gets without relying on external project creation tools like genie or cmake.
Because sharing one file is easier than sharing two files for all the right reasons (versioning, ease of use, ease of distribution, etc)
Well here's some reasons: * Distributing a single file is easier * Because it doesn't matter from a technical point of view. This is a 1 kloc library we're talking about. * Review failure is purely subjective.
My opinion is based on 20 years of bug fixing other peoples code, aka,. 24/7 second level software support. I've actually been woken up at half past nausea more than once over people failing to utilize this particular anti pattern as expected by its creator.
&gt; Why not just provide a header file and a source file? Because distributing and updating a single file is less work. Because for small libraries like this it doesn't matter whether they come in a single .h file or in a .h and a .c file. Because the author felt like it. The point is that it doesn't matter, because from a technical PoV they're the same.
So you're saying that there's only one, true and correct way to write libraries?
I only read "This isn't a proper way to distribute a library". That there's only one and true way is more likely projection on your behalf.
True, but why disregard header-only libraries as non-normal and non-correct? We can argue about correctness if you want, but due to the fact that there are more and more header-only libs coming out, I think it has become a pretty normal way to distribute and develop a certain type of library. I certainly wouldn't develop a header-only library for a big project (they suck when having more than one developer actively working on them), but for small projects only maintained by ideally one developer, they work quite well.
After 20 years of bug fixing surely you would understand the use case for a single header library then? Here's a [decent article](https://en.wikipedia.org/wiki/Header-only) on Wikipedia where the advantages are listed: - Header-only libraries do not need to be separately compiled, packaged and installed in order to be used. - the compiler's optimizer can do a much better job when all the library's source code is available. Disadvantages: - brittleness ‚Äì most changes to the library will require recompilation of all compilation units using that library - longer compilation times ‚Äì the compilation unit must see the implementation of all components in the included files, rather than just their interfaces - code-bloat (this may be disputed) ‚Äì the necessary use of inline statements in non-class functions can lead to code bloat by over-inlining. The "longer compilation times" is a non-issue for optimizing compilers. Furthermore, the "code bloat" issue is only a problem if the programmer forces inlining instead of leaving that to the compiler, as far as I know. Look, I'm not saying that single header libraries are the best, but they have their uses.
There are a number of problems with this approach and if you work around them, you end up with more work to integrate the library than if you just used a a normal source file(s)/header file combination: ## where header-only libraries work If the header-only library (let's call it `foo.h`) is used in a single translation unit, then everything is fine. You include the header like this: #include "foo.h" and call the function. However, this is rarely the case. ## general issues One minor design deficit that appears here is that the header-only library cannot avoid polluting the name space with headers it needs to include for internal use, even if including these headers are not part of the specified interface. This can lead to maintenance problems and breakage if a future version of the library no longer needs to include the header. This can also cause a lot of headache if your code and the header-only library have a different idea of what feature-test macros to define before including system headers. This is a problem as some functions (like `getopt`) behave differently depending on what feature-test macros where defined when the header that declares them was included. Since the code is in the header file, every change to it leads to a recompilation of all files that include the header. If you put the code in a separate translation unit, only API changes require a full recompilation. For changes in the implementation, you would only need to recompile the code once. This again wastes a whole lot of programmer's time. ## multiple translation units if you have multiple translation units using the same header-only library, problems start to occur. Header-only libraries generally declare their functions to be `static` by default, so you don't get redefinition errors, but these problems occur: * the library's code is compiled into machine code for every use of the library and included in the binary. If you use the library from 10 different files, the code takes 10 times the time to compile, is in the binary 10 times and occupies 10 times the space it could need. That wastes programmer time as well as binary space, which is at a premium in embedded systems. * when debugging, it is very difficult or outright impossible to set breakpoints in the library. Debuggers generally assume that the combination of file name and symbol name is unique in the program. Since the library's code is included multiple times in the binary, the same symbol name appears from the same file name (`foo.h`) multiple times. Even if you manage to set a breakpoint on one copy of the library, the debugger is not going to stop on the other copies. This makes debugging a great deal harder. ## fixing code duplication Many header-only libraries provide a fix for the code-duplication problem: in one translation unit, you include the header with a special macro defined that causes external definitions to be emitted: #define FOO_IMPLEMENTATION #include "foo.h" while in all other translation units, you define another macro to only expose external declarations: #define FOO_DECLARATION #include "foo.h" While this fixes the code duplication issue, it's a fragile and ugly solution: * one source file is special in that it has to define `FOO_IMPLEMENTATION`. If you forget about that and delete the file, everything breaks and you have to figure out wtf went wrong. * if you ever forget to define `FOO_DECLARATION` before including `foo.h`, you are back at square one without any indication that you did so. The code is just silently duplicated. You are only going to notice once the binary size grows or once you have weird problems debugging the code. ## fixing the ugliness To fix the problems caused by the fix, the general approach is to create a new translation unit to dump the implementation. This translation unit (let's call it `foo_shim.c`) contains just the two lines: #define FOO_DEFINITION #include "foo.h" Now every other translation unit can include `foo.h` in declaration mode and you don't have to keep track of which one contains the definitions. However, the problem of accidentally forgetting to define `FOO_DECLARATION` remains. To fix this, you create a new header file (let's call it `foo_shim.h`) that contains the following two lines: #define FOO_DECLARATION #include "foo.h" and instead of including `foo.h` directly, you always include `foo_shim.h`. In a nutshell, we added two extra files to convert the fancy-shmancy header-only library into a conventional source/header pair so we don't have to deal with all the problems the header-only approach causes. ## what to do instead? Instead of putting code into header files, put the library's code into a C source file (`foo.c`) and the relevant declarations into a header file (`foo.h`). Distribute these two files. You can even split up the implementation into multiple source files and distribute them. Users of the library can add these files to their projects to use them. You can see an example of this in [one of my projects](https://github.com/fuzxxl/dobutsu/tree/master/xz) where I bundle a copy of the xz-embedded code. If you write an open source program, make sure it is easy to unbundle these libraries as distributions like to do that. Make sure to observe copyrights and to include license files. This is the approach taken for example by SQLite and many other professional libraries. This is the way to do if your library is sufficiently simple. If the library grows complex to the point where it needs configuration or a build system, use autotools and make it a proper library.
See [this comment](https://www.reddit.com/r/C_Programming/comments/cae52j/nanoprintf_a_tiny_headeronly_vsnprintf_that/et9amng/).
See [this comment](https://www.reddit.com/r/C_Programming/comments/cae52j/nanoprintf_a_tiny_headeronly_vsnprintf_that/et9amng/).
Header-only libraries have the source code in the header. That's the whole problem. See [this comment](https://www.reddit.com/r/C_Programming/comments/cae52j/nanoprintf_a_tiny_headeronly_vsnprintf_that/et9amng/) for some general criticism on the approach.
See [this comment](https://www.reddit.com/r/C_Programming/comments/cae52j/nanoprintf_a_tiny_headeronly_vsnprintf_that/et9amng/).
From a technical point of view, header-only libraries are both much more annoying to get right for the author (due to the need to write complex macros for different compilation and due to namespace issues) and more annoying to use correctly for the end-user. All version control systems these days support multiple files. Distributing single files is as easy as distributing a tarbal made of multiple files. I know a single person who still uses SCCS (which only supports single files) and even he would never follow this braindead approach.
&gt; After 20 years of bug fixing surely you would understand the use case for a single header library then? After 20 years of seeing the usage pattern leading to actual mission critical failures, I don't give a damn what imagined advantages people come up with. Code using this pattern will fail a code review I'm making, and my reasons are stated above.
&gt; I don't give a damn what imagined advantages people come up with. That's too bad. Goodbye.
&gt; True, but why disregard header-only libraries as non-normal and non-correct? Because any experienced developer will know that the hoop jumping needed to make this work with more than one compilation unit is error-prone and fragile.
That's a shame. I use them a lot in my own code (used Splay trees to store SDL textures/rects just the other day). It's in base and quicker than rolling my own.
I see your points, and the use of ``` #define FOO_DECLARATION #include "foo.h" ``` is, unarguably, pretty lame. However, most libraries I used and wrote do it a little bit differently in that they make the `#define FOO_DECLARATION` the default case when including them. Example: ``` //header only-lib foo.h #ifndef FOO_DEF #ifdef FOO_STATIC #define FOO_DEF static #else #define FOO_DEF extern #endif FOO_DEF int foo(void); #ifdef FOO_IMPLEMENTATION FOO_DEF int foo(void) { return 42; } #endif ``` ---- Your other point is, that the file that contains the line `#define FOO_IMPLEMENTATION` to include the implementation part of the library is special and deleting it will result in strange errors. Yes, that is true but the same applies if you delete the foo.c file of a foo.h and foo.c library. I don't see why you would treat the file that includes the implementation part of the library other than a regular *.c file?
I think the optimisation argument would mainly be relevant only if you were inlining those functions defined inside the header. For an embedded printf library that's probably not a good idea.
Could you elaborate? I don't know what you mean.
&gt; Yes, that is true but the same applies if you delete the foo.c file of a foo.h and foo.c library. I don't see why you would treat the file that includes the implementation part of the library other than a regular *.c file? What usually happens is that either you use a dedicated file to dump the implementation of the header-only library or you dump the implementation into some random file in your project (typically the first file that used the library). In the latter case, it can happen that that file is no longer needed due to refactoring and you delete it, having forgotten that it also carries the implementation of the header-only library. If the header-only library implementation is dumped into a separate file just for this purpose, you won't make this mistake. But the key question is: if you are going to add a source file to dump the implementation into anyway, what is gained from having all that code in the header?
/u/FUZxxl have stated the multiple problems to a much higher degree than I have the time to do now, so consult [the elaborate list of problems with single header libraries](https://www.reddit.com/r/C_Programming/comments/cae52j/nanoprintf_a_tiny_headeronly_vsnprintf_that/et9amng/).
The optimising compiler would be the judge of that surely?
Not really, the "optimisation" that the wiki article talks about is speed optimization. In a lot of embedded projects, space is also a concern. You don't save space by inlining the same function all over the code and optimizing each individual call separately.
An optimizing compiler very rarely decide whether to duplicate code across multiple compilation units. If that decision is made, the linker will be responsible for that.
&gt; Since the code is in the header file, every change to it leads to a recompilation of all files that include the header This is valid criticism. However, because you're a user of the library, the expectation is that updates are infrequent making this not an issue. About macros: is this too complex? void foo(); #ifdef FOO_IMPLEMENTATION void foo() { ... } #endif In my opinion it is acceptable. #define FOO_DECLARATION #include "foo.h" Nobody uses this. The header is in "declaration mode" by default.
Whatever your concern, you could use `-Os` or `-O2` for example and let the compiler do the work. An optimizing compiler can do more than simply inlining code. Using a single header library could expose more opportunities for the compiler to optimise as I said in my post above. Is speed optimization not more important than compile time? Do you want release binaries to run slower just so that the one time you produce a release build, it's slightly faster? And if you're testing your program, using `-Og` compiles very fast, so I don't understand the arguments with regards to the gains in compile speed. It's clear that nobody here is budging from their beliefs of how to write a library. Honestly, this could've been avoided if OP gave a proper reason single header libraries aren't good to begin with, instead of calling it "bullshit". This has been a waste of time for everyone, and where I thought I would learn something interesting by participating, I didn't.
&gt; About macros: is this too complex? No, but it's also absolutely useless. Just put the part beginning with `FOO_IMPLEMENTATION` is a source file and you are good to go. It's also missing macros for static functions, include-guards and all the other bullshit that's usually in these. &gt; Nobody uses this. The header is in "declaration mode" by default. That's not the header-only libraries I saw. The libraries I saw default to static function mode. And even if you defaulted to declaration mode, what is gained from just shipping a header/source pair?
This is not side by side, but rather Assembly and then C built on top of it. The book's called "Programming from the ground up".
You could also argue that (for example) code without any error handling, resource cleanup, thread safety, or buffer overrun checks works well for "small projects only maintained by one developer". But that doesn't mean that it should be respected as a "correct", reasonable programming style that others should learn from. The separation of header and source files has been an integral part of C and has been working well for half a century, and allows fast compilation, shared libraries with stable APIs, clean separation of interface and implementation for better maintainability, less dependencies, documentation. Why would anyone suggest to abandon all that, just to make it a little easier for some people who are too lazy to set up a proper build environment for linking a library?
And given that compilers are generally unable to inline vararg functions, there is no potential for inlining `printf`. The end.
No, but there are many wrong ways. And ‚Äúheader only‚Äù is generally a wrong way to do it.
&gt; The libraries I saw default to static function mode I agree that's stupid. But in this particular case, and in my general experience, most single header libraries are implemented like the stb_ libraries, which use 'declaration by default'. In any case, the discussion here is not *just* about the merits of each option (I agree that shipping a separate .h and .c is usually preferred), but about the usability of single header libraries in small and large projects. In my opinion, for small libraries like this, it is perfectly fine to put the implementation in the header file, and certainly doesn't warrant the "absolutely useless for every non-trivial application" descriptor.
Now you are talking out of your ass. From a technical point of view, header-only libraries are both much more annoying to get right for the author (due to the need to write complex macros for different compilation and due to namespace issues) and more annoying to use correctly for the end-user. All version control systems these days support multiple files. Distributing single files is as easy as distributing a tarbal made of multiple files. I know a single person who still uses SCCS (which only supports single files) and even he would never follow this braindead approach.
&gt; I agree that's stupid. But in this particular case, and in my general experience, most single header libraries are implemented like the stb_ libraries, which use 'declaration by default'. If you want people to use the library like this, again there is no advantage over shipping a separate source and header file like every normal library. &gt; In my opinion, for small libraries like this, it is perfectly fine to put the implementation in the header file, and certainly doesn't warrant the "absolutely useless for every non-trivial application" descriptor. A printf implementation isn't exactly ‚Äúsmall.‚Äù While there is a point in defining small inline functions in headers, this only makes sense if the function is realistically inlined everywhere. You also gain all the gotchas that come with inline functions. Now `printf` is not at all inlinable as it is a varargs functions and no compiler I know can inline these (not that it would generally make sense anyway).
Thank you very much. Pointers trip me up constantly.
Thanks for this!!
This helped a lot, thank you!
&gt;If you want people to use the library like this, again there is no advantage over shipping a separate source and header file like every normal library. The advantage is obvious: it's a single file. You don't have to mess with your build system(s) to use this library. You only have to update a single file to get the latest version. Pick any .c file you already had to hold the implementation and you're good to go. &gt; A printf implementation isn't exactly ‚Äúsmall.‚Äù I don't know why you're talking about inline functions, which is a completely orthogonal issue to single header libraries (which don't imply inline functions at all, and isn't the case in this instance).
&gt; You don't have to mess with your build system(s) to use this library. You only have to update a single file to get the latest version. Pick any .c file you already had to hold the implementation and you're good to go. I have written a long comment explaining why in practice, it's not that easy and using the ‚Äúsingle header‚Äù usually boils down to having to write custom shims anyway. &gt; I don't know why you're talking about inline functions, which is a completely orthogonal issue to single header libraries (which don't imply inline functions at all, and isn't the case in this instance). Having all the code in the same translation unit that uses it (as a sort-of poor man's LTO) is a big selling point for the header-only approach. Maybe we are talking about different things here.
&gt; You don't have to mess with your build system(s) to use this library. If adding a source file to your project is difficult for you, then maybe you should reevaluate your choice of build system or quit your job as a programmer.
Sorry, I should spell that out more clearly for you: It isn't "difficult" to add new .c files. It's just more effort. It is an advantage if I don't have to do that. Also thank you for your unsolicited advice about my career choice.
If you think that saving 10 seconds of time adding a file to your project is worth the headache of a jury-rigged header-only library, then you have interesting priorities. You probably also don't brush your teeth because it's just more effort and because it is an advantage if you don't have to do that.
Not the end of all single header libraries, just this one printf library.
ELI5 please !
No they‚Äôre not. They have their disadvantages yes, like any engineering choice, but they work, and they work fine! If you can‚Äôt afford to use a header-only library in your project, then by all means don‚Äôt.
You are surprised how rarely inlining is worth the effort. I haven't seen a single header-only library where inlining would have helped with more than one or two of the functions.
What part of the comment would you like to have explained?
What real advantage does this approach have over just providing a source file with the code and a header file with the declarations, as the linked comment argues?
Is inlining the only optimisation that an optimising compiler can perform when using a single header library?
It's pretty much the only extra optimisation that can be performed. And if you compile with LTO, even that advantage vanishes.
This is just bad code.
General and multiple translation unit, please!
&gt; You are surprised how rarely inlining is worth the effort. In most instances, I've used functions in a single header library once. For a small single header library, I would expect `\*_init()`, `\*_run()`, `\*_quit()` functions, and I would call them from only one place. I have a large single header library, however none of the functions are usually called in more than one place in the user code. &gt; if you compile with LTO Not all embedded platforms have a compiler with LTO, like XC8.
Okay! Here we go: ## One minor design deficit that appears here is that the header-only library cannot avoid polluting the name space with headers it needs to include for internal use, even if including these headers are not part of the specified interface. This can lead to maintenance problems and breakage if a future version of the library no longer needs to include the header. ‚Äúname space pollution‚Äù refers to defining identifiers (names) that should not have been visible to other code. This is especially annoying when you define identifiers that anybody else might want to use, such as by defining a global variable named ‚Äúerror‚Äù or a function named ‚Äúfail‚Äù. The other issue is that to implement its logic, the library might need to include some header files. For example, it might want to include `stdint.h` for fixed-size integer types or `stdatomic.h` for atomic variables. It is often the case that these headers are only needed for the implementation of the library but not to declare the functions implemented within. If a header is once included, this cannot be undone. If a header is included into a header-only library for internal purposes, it is also visible to whatever code includes that header. That code could accidentally assume that the header is always included and use identifiers from it without including it explicitly. Now in a future release of the library, the header might no longer be needed and thus might no longer be included. Then, the code that includes the header-only library breaks because the header it expects to be there is now gone. This is an annoying, although minor issue. &gt; This can also cause a lot of headache if your code and the header-only library have a different idea of what feature-test macros to define before including system headers. This is a problem as some functions (like getopt) behave differently depending on what feature-test macros where defined when the header that declares them was included. Feature test macros are macros like `_POSIX_C_SOURCE` or `_GNU_SOURCE` you define before including a header file. The header file checks for these macros and only defines those functions asked for by the feature-test macro. In some rare cases, the header defines functions differently depending on the configuration of feature test macros. Since you cannot undo a declaration and since most headers are not able to be included more than once (and especially not with different feature test macros), it is a problem if a header is included before all feature test macros are set up correctly. If the header-only library includes a system header, this can be the case. If the header-only library defines feature-test macros on its own, this issue can become rather hard to solve. &gt; Since the code is in the header file, every change to it leads to a recompilation of all files that include the header. If you put the code in a separate translation unit, only API changes require a full recompilation. For changes in the implementation, you would only need to recompile the code once. This again wastes a whole lot of programmer's time. Build systems track what translation units have to be redefined by tracking what files you include. A translation unit has to be recompiled if it has changed or any file it includes has to be recompiled. If you change a source file, generally only that file has to be recompiled. If you change a header file, all files that include it directly or indirectly need to be recompiled; this can affect large parts of the project. While annoying, header files are rarely changed and thus this doesn't occur too often. However, when you put all your code into the header, this occurs much more often to the point where you regularly need to recompile large parts of the project. &gt; multiple translation units A bit of jargon first: a *translation unit* is what the compiler compiled into an object file in one run. It's the source file you give to the compiler plus everything it includes (directly or indirectly) as seen when included. This term is often the same as ‚Äúsource file,‚Äù but some people like to include source files from other source files (don't do this), so a translation unit can contain more than one source file. A translation unit is also how far static functions are visible. &gt; if you have multiple translation units using the same header-only library, problems start to occur. Header-only libraries generally declare their functions to be static by default, so you don't get redefinition errors, but these problems occur: Remember: each external function (i.e. one that isn't defined as `static`) may be defined only once in the program. If you define an external function in two places, the linker is going to complain that you redefined it. Now exactly that occurs when you use a header-only library in more than one translation unit and that library does not define its functions as `static`. &gt; the library's code is compiled into machine code for every use of the library and included in the binary. If you use the library from 10 different files, the code takes 10 times the time to compile, is in the binary 10 times and occupies 10 times the space it could need. That wastes programmer time as well as binary space, which is at a premium in embedded systems. There is little I can add to this. Embedded systems such as micro-controllers often come with a few kB of RAM and a few 10 kB of ROM for your program to fit into. This space is quickly exhausted and wasting space including the same code again and again is generally a bad thing. &gt; when debugging, it is very difficult or outright impossible to set breakpoints in the library. Debuggers generally assume that the combination of file name and symbol name is unique in the program. Since the library's code is included multiple times in the binary, the same symbol name appears from the same file name (foo.h) multiple times. Even if you manage to set a breakpoint on one copy of the library, the debugger is not going to stop on the other copies. This makes debugging a great deal harder. Nothing to add here either. If you don't know how to use a debugger, I can't really explain this and if you know, I'm not sure how to expand the explanation.
What fraction of C programmers will ever write code that anyone would want to run on that environment? If one defines a "behavior" as a mapping between inputs and outputs, and a "language" as a mapping between source texts and behaviors, I think C served most usefully not as a language, but rather a recipe for producing languages suitable to various implementations and tasks. While "normal" C uses ASCII and has an 8-bit `char` type, someone targeting a platform where storage can only be written in 16-bit chunks would likely find it more convenient to use a language that was mostly like "normal C", but which used a 16-bit `char` type, than to have to learn a totally different language. BTW, I think that even in EBCDIC, `'a' ^ 'A' ^ ' '` equals zero.
&gt; What fraction of C programmers will ever write code that anyone would want to run on that environment? That is irrelevant. The only thing that is relevant is that the C standard does not specify what the character encoding is and thus such assumptions cannot be made. &gt; If one defines a "behavior" as a mapping between inputs and outputs, and a "language" as a mapping between source texts and behaviors, I think C served most usefully not as a language, but rather a recipe for producing languages suitable to various implementations and tasks. While "normal" C uses ASCII and has an 8-bit char type, someone targeting a platform where storage can only be written in 16-bit chunks would likely find it more convenient to use a language that was mostly like "normal C", but which used a 16-bit char type, than to have to learn a totally different language. And the C standard does exactly that. Both would be conforming implementations of C. &gt; BTW, I think that even in EBCDIC, `'a' ^ 'A' ^ ' '` equals zero. And? How is that relevant? (it is the case by the way; `0x81 ^ 0xc1 ^ 0x40` equals zero).
&gt; However, this is rarely the case. Your one positive is made meagre because of this subjective statement. &gt; Since the code is in the header file, every change to it leads to a recompilation of all files that include the header. ... This again wastes a whole lot of programmer's time This is a non-issue. How long does it take to recompile your average project? You running a Pentium II? Maybe it takes ages, but your blanket statement that this is the same for all projects is something I cannot accept. This is a non-issue for small projects, or for small header only libraries. &gt; multiple translation units I think I agree with everything written under that heading. &gt; fixing code duplication &gt; fixing the ugliness I either have never encountered these issues, or I don't understand them properly. There are a lot of tradition C libraries that I find online that piss me off. Such as a lot of Arduino libraries that are drivers for an external peripheral, like an LCD, but are implemented within a .c .h combo with platform dependant code. In that case I would have to go through both files and port the code to whatever platform I'm working on. I have a specific library in mind, but I will not link it in this negative context. However, a single header library like [bmp.h](https://github.com/skeeto/bmp) by /u/skeeto is brilliant, because it's platform independent and it's easy to add to an existing project. And the manifesto on [Minimalist C Libraries](https://nullprogram.com/blog/2018/06/10/) is great imo. A lot of single header libraries are written with platform independency and simplicity in mind, and that is a big positive for me. Traditional libraries may also be written like this, but most are complete garbage and scary for new users of that library. If you disregard this with a "hurp derp yer retarded for not reading library docs", then your argument simply isn't good enough. Header only libraries *typically* make it easier to understand what the library is doing. &gt; Why Header-Only Libraries Are a Bad Idea You're smart and we're all dumb for writing "header-only bullshit" libraries then, but thanks for your lengthy explanation which you provided after that comment.
If you want to do your own memory management in a raw block of memory, then you should imitate how memory management systems do it. I would avoid using `malloc`, since it has a layer of management already, and that's missing the point a bit. To get a usable block of memory on Linux, you can use `sbrk`. This is the closest to what you were asking for originally: `brk` and `sbrk` move the end of the program segment that is used as the heap. void * mem = sbrk(bytes_to_acquire); Alternately, you can use `mmap` with `MAP_ANONYMOUS`. This is what your C library's implementation of `malloc` would probably do anyway if you request a large enough block of memory, but if you're learning how to do things the hard way, you might as well do them the hard way. Given the description of your project, I'd check out [Core War](https://en.wikipedia.org/wiki/Core_War).
I think we've had this conversation before. This subreddit is neither your personal social media account nor your project's mailing list. While we do appreciate if people post their projects, please keep it to at most one post every few weeks. Nobody is interested in these frequent status updates. Instead, wait until you've hit a significant mile stone and until your code is polished and only then post.
Sorry. I meant to title this post "reimportation of queue structor". Because lots of problems where pointed out.
&gt; That is irrelevant. The only thing that is relevant is that the C standard does not specify what the character encoding is and thus such assumptions cannot be made. And what is the effect of making such supposedly-impossible assumptions? Will the C Language Police break down one's door? Or will the only "adverse" effect of such an assumption be that the program wouldn't work on platforms for which it was never designed to work in the first place? &gt; And the C standard does exactly that. Both would be conforming implementations of C. The C Standard doesn't really separate the concept of implementation and environment. If it did, and recognized the concept of "commonplace" implementations, one wouldn't have to add much more to allow most tasks that are done with freestanding implementations to be accomplished without relying upon "popular extensions" [or unpopular ones, for that matter]. For example, given `volatile uint32_t *p;`, the Standard only defines the behavior of `*p = 0x00010002;` in cases where `*p` identifies an object, but many tasks for freestanding implementations require the ability to generate stores to addresses that will trigger an action but not store the value, and are thus not objects. If the Standard were to recognize a category of implementations were a store to a volatile lvalue would synchronize the states of the abstract machine and underlying platform, perform a store to the underlying address *with whatever consequences result*, and again synchronize the states of the abstract machine and underlying platform, that would allow the Standard to fully specify the behavior of the language construct despite the wide range of purposes for which it might be used.
i think what, "header only libraries", can use only if want lite library ( without build )
If a function is declared inline but not static, implementations that are able to do so may treat all but one of the definitions as though they were external declarations. While I can understand why the Standard forbids inline functions from using modifiable objects with internal linkage, I don't see why it doesn't allow use of modifiable static-duration or thread-duration objects with external linkage, since all references to any such object throughout a program should identify the same object.
&gt;If you think that saving 10 seconds of time adding a file to your project is worth the headache of a jury-rigged header-only library, then you have interesting priorities. You're conveniently ignoring any other advantages I named which I don't care to repeat. I've already stated I prefer separate .c and .h files. My only opinion on this matter that I don't really care if libraries are single header or not if they're small libraries, because the pros and cons are mostly insignificant in the larger scheme of things. You're taking this way, way too far and out of context. &gt;You probably also don't brush your teeth because it's just more effort and because it is an advantage if you don't have to do that. Nice ad hominem. Literally everything you have said is laden with hyperbole and dogmatism. Take a step back and realize that not everything works according to your perfect world view. Pragmatism gets you further.
`printf("%p\n",myptr);`
``` printf("%d",(uint32_t)&amp;aptr); ``` ``` printf("%x",(uint32_t)&amp;aptr); ``` ``` printf("%p",aptr); ```
&gt; Because distributing and updating a single file is less work. But there *isn't* just a single file! This library also comes with 13 files of unit tests. If I were to use this in some project, I'd want to keep all of the files that were distributed with this project, and I'd like to use their unit tests (possibly with modifications to fit into my build system or environment). So when the author could have distributed 15 files and made this behave like any other library, they instead chose to distribute 14 files with an uncommon and problematic way of compiling it. There's absolutely nothing gained by that.
If .c source code can be logically separated from .h with no side effect, forcing them into a single header is often a bad idea. Having a pair of .c and .h is still convenient enough. However, for many generic containers and generic algorithms, putting everything in .h and instantiating code based on type is the only way to make generic code run as fast as type-specific code.
Honestly I'd say that cross-referencing optimized compiler output for a C construct with the documentation for the emitted instructions *is* the best way to learn how C maps to machine code. This guy wrote a pretty good introductory overview: https://github.com/0xAX/asm Here's a somewhat more in-depth take: http://www.egr.unlv.edu/~ed/assembly64.pdf But usually you write assembly when you're doing something that *doesn't* map to a C construct, so I question the value of learning this beyond a need-to-know basis. I'd say the most important references are the documentation for your assembler tool, and the reference manual for the ISA in question, and the platform ABI.
For that kind of situation, having the code in a header is not a bad idea indeed.
&gt; This is a non-issue. How long does it take to recompile your average project? You running a Pentium II? Maybe it takes ages, but your blanket statement that this is the same for all projects is something I cannot accept. This is a non-issue for small projects, or for small header only libraries. It *may* be a non-issue for you - for larger projects (especially if you have C++ and its glacial compile times in the mix), build times can be a major pain. For the project I'm currently doing on at work, a clean build takes about 5 minutes on my 6-core i7-8700k desktop. The difference between incremental builds taking several seconds or several minutes can make a meaningful difference in my productivity for the day. I think blanket statements are not very useful one way or the other. There are good reasons to put code in headers. But if the only value of making your library header-only is simplifying your build configuration, then IMO your priorities aren't quite right.
Build time doesn't go down if you put the source code into the header. If it changes at all, it goes up due to the larger source size.
* source build time, header not build without including you don't understand me source + header library - user source + lib source build time header library - user source + header compile small time mm, but this is only my opinion
I have no idea what your comment is trying to say.
&gt; There are a lot of traditional C libraries that I find online that piss me off. Such as a lot of Arduino libraries that are drivers for an external peripheral, like an LCD, but are implemented within a .c .h combo with platform dependant code. In that case I would have to go through both files and port the code to whatever platform I'm working on. I have a specific library in mind, but I will not link it in this negative context. &gt; &gt; However, a single header library like bmp.h by /u/skeeto is brilliant, because it's platform independent and it's easy to add to an existing project. This seems to depend on the implementation. Just because the`bmp .h` "library" is platform independent and libraries for Audrino are platform specific (Audrino to be specific), doesn't mean all `.h` "libraries" are platform independent and all `.h`+`.c` are platform dependent.
Agreed, if you actually need all those files. However, ideally the documentation and the license are in the .h file itself, there are no external dependencies, and you don't care about library internal unit tests (this is a fair assumption if the library doesn't depend on platform specific interfaces) if they exist at all. If all of the above is true, there's definitely (albeit marginal) value gained. If you do need all the extra files, nothing has changed in terms of integration with your project, except that you have to #include the file somewhere to create the implementation of the library. I'd say that this pattern is fairly common nowadays. Just to clarify, I'm talking about single-header libraries with a simple API that look like this: /* License */ /* Foo: Do the thing */ void foo(); #ifdef FOO_IMPL void foo() { } #endif
Yes of course there are large projects, and having each part of a large project in header file is bad. This is why I said "This is a non-issue for small projects, or for small header only libraries" in my post above. &gt; I think blanket statements are not very useful one way or the other. Of course. Single header libraries have their uses, and aren't always recommended. &gt; But if the only value of making your library header-only is simplifying your build configuration, then IMO your priorities aren't quite right. This isn't a priority, but sometimes an unintended consequence of using a single header library.
I did mention this in my post by saying "Traditional libraries may also be written like this".
I think your last paragraphs touches on an important point. There's a lot of garbage software out there, and when choosing what libraries to use you have to use heuristics. Sure, you could write e.g. a C++ library to parse JSON just as well as a C89 one - but all else being equal, what lib do you think is going to be more likely to be a bloated mess, or be a pain to compile, or care as much about API stability? Header-only libs fill a niche in that way - when I want to do some linear algebra and find e.g. [linmath.h](https://github.com/datenwolf/linmath.h) I can be fairly confident it's not going to be a bloated monstrosity.
I still don't understand why anyone would think that moving implementation into header files is a good idea. They may be some occasional macro templates or inlineable functions which make sense in header files, but why would you move everything into a header file for no reason? It's confusing how posts like [this](https://www.reddit.com/r/C_Programming/comments/cae52j/nanoprintf_a_tiny_headeronly_vsnprintf_that/) use "header-only" in the topic as if it was something positive that should be advertised.
&gt; There is little I can add to this. Embedded systems such as micro-controllers often come with a few kB of RAM and a few 10 kB of ROM for your program to fit into. This space is quickly exhausted and wasting space including the same code again and again is generally a bad thing. Also worth noting that this is a potential performance issue for less constrained systems as well, since repeatedly generating/inlining big chunks of code over and over for no good reason may increase the frequency of expensive cache misses.
&gt; ideally the documentation and the license are in the .h file itself, there are no external dependencies, and you don't care about library internal unit tests (this is a fair assumption if the library doesn't depend on platform specific interfaces) if they exist at all. None of those are the case for this project. And I disagree that those would be "ideal". Documentation in the .h file? Great, so any time the author updates documentation, I end up recompiling every file of my project that uses the library. No external dependencies? Don't care about unit tests? That doesn't appear to be true; it depends on the build system or the integrator to get the right definitions for a few typedefs (intmax_t, size_t, etc.). And if I were using this on both 32-bit and 64-bit platforms -- which I've done -- I'd definitely want to test it and make sure that, for example, `%p` and `%zu` are correctly handling my pointers and my definition of `size_t` on every platform. &gt; I'd say that this pattern is fairly common nowadays. Yes, it's more common than it used to be, but I've yet to see anything that isn't someone's pet project be distributed this way. &gt; nothing has changed in terms of integration with your project, except that you have to #include the file somewhere to create the implementation of the library. Well, then at least one thing has changed. That one thing alone makes the idea questionable. It's different from how C libraries have been written and distributed for decades, so us would-be users are forced to ask: Why the change? What makes this approach better? I've heard scant advantages in favor of it (it's possibly easier for the 5 seconds it takes to add it to my project), but numerous disadvantages. Look, I can't really say you're "wrong". As long as the code is correct and meets other requirements for performance and such, the choice of how to package and distribute it is largely a matter of opinion. However, other people already have strongly-held opinions, which they've formed based on a wide range of experiences over many decades, yet you seem intent on ignoring any lessons they want to share based on those experiences. It's a free world, I guess, so continue ignoring them if you want to. But when you come to a subreddit whose purpose is to *discuss* and *learn about* C programming, it seems foolish to waste the opportunity to expand your worldview.
Do you do any kind of professional development where C is the major part?
I'm struggling to figure out a scenario where header-only code would optimize better. Well, of course it could optimize better for the one translation unit that has the implementation part of the header-only library defined, but every other translation unit that uses only the declarations of the header would gain no advantage. (And if the compiler supports link-time optimization or whole-program optimization, it doesn't matter whether the code was distributed header-only or not.) So while it may technically be true, it's a very scant advantage that doesn't scale.
On many platforms, all "data" pointers have the same representation, but the Standard is designed to accommodate platforms where that is not the case. The Standard is also designed to accommodate platforms where function pointers are represented by indices into tables of compatible functions rather than machine-code addresses. Many implementations targeting platforms where all data pointers use compatible representations and function pointers represent machine-code addresses support, as a "popular extension", the ability to treat different function types interchangeably in cases where the argument and result types are representation-compatible, and such support facilitates some kinds of tasks, but the Standard does not recognize any means by which code can test whether an implementation supports such an extension, refuse to compile on those that don't, and safely make use of the extension on implementations that claim to support it. Implementations for commonplace platforms will generally support that extension when optimizations are disabled, but some optimizers' authors regard as "broken" any code that relies upon extensions, no matter how popular they have historically been on the target platform.
What's it like being this much of an asshole?
Why does a jerk thread need its own story?
Okay, I do feel compelled to interject here. &gt; Every time you add a header file you increase compile time by a bit Yes, this is technically true. However, I/O and CPU speeds on any remotely modern machine are so fast that this is no longer a factor worth taking into account. Thanks to the [Living Computers: Museum + Labs](https://livingcomputers.org/), I've spent some time writing C code on a PDP-11 and VAX. And on those platforms, yes, you can practically count the bytes in your input (.c and .h files) and see the difference it makes in compilation time. Even the tiniest program takes a few seconds to compile. This is why in old source code, header files didn't have guards against multiple inclusion, and header files never included other header files even when they were necessary. In order to save compilation time, it was up to the programmer to determine which headers were needed and include all of them exactly once. In today's computing world, that's absurd. Doing that kind of work costs valuable person-hours, while the compiler's preprocessor can go through massive amounts of data in the blink of an eye. Compilation times today are dominated by optimization and other translation steps, while the time spent in the preprocessor is minimal. You can see this by looking at [ccache](https://ccache.dev/performance.html), which (depending on the mode) works by storing the preprocessed input and the compiled-and-optimized output. The work done after the preprocessor takes roughly 28 times as long. I already had a lot of experience trying to wrangle large, complex sets and chains of header files. These two additional pieces of evidence have completely convinced me that the old Unix way of dealing with header files is, today, a ludicrous waste of programmer's time. At most, smaller or larger header files affect compilation times by only the tiniest fraction, but they can make an enormous difference in how much of the programmer's time is spent (or wasted) organizing, tracing, or debugging headers. Thus, I now insist that every header file have protection against multiple inclusion, and every header file include everything that's needed for its own dependencies; a user should never have to include some other header file before your own (not even some global config file; if it affects your header, include it from your header!). (I'm only talking about C here; the situation might be different in C++, because the compiler may have to re-compile templated and inlined code every single time.)
&gt; I either have never encountered these issues, or I don't understand them properly. I'll try to explain where that becomes a problem to help you understand the problem the quoted author was attempting to address. I believe you're genuinely curious. On the topic of duplication: Unless you're using bulkbuild/unity builds, every single source file in your program will duplicate the compiled code. In the example of nanoprintf, it can be expected that *almost* every single file in your code base is going to reference printf for debugging non-final builds. What ends up happening, then, is that every one of your compiled object files has duplicated versions of your printf compiled code. If you have 1,000 files in your codebase with that, it means your executable is now going to grow by about 5 MB given the assertion that nanoprintf claims 5KB of compiled ARM assembly. 1,000 files is not a lot. TuxRacer, a really really simple game, is composed of about 70-80 source files in their src directory. This doesn't include libraries or other dependencies, just tuxracer's specific code. Using 5KB as a metric, we're talking about adding at least 350KB to the executable size of tuxracer *just by using this header only printf*. Why's that bad? Shit, do you know what you're going to do to your caches if you printf a lot? Each one is *in its own piece of memory*. Every time you call into a different translation unit, it potentially clears a cache line that could've held a perfectly good version of printf in it to pull some other duplicated piece of the same exact piece of code. I mean, if two translation units are working together on two separate threads, they have their own printfs, that's that much less cache that gets reused all because you wanted a header only printf. Now, you might say, "AssKoala, what about LTO (Link Time Code Optimization), COMDAT folding, or other linker techniques?" Sure, those *might* remove all the duplicated code at link time when the linker is like "wtf is this stupid shit they're sending me". Or it might not. No guarantee. Your bmp.h example is actually a good one, but because manipulating a bitmap is something that likely only *one* of your translation units is going to do. At the very least, unless your entire program is dedicated to manipulating bitmaps, and therefore it would be inherently small, it should end up being a small part of your overall footprint. That's not the case with printf. One fix for this is to create your own Printf in your program whose source file includes nanoprintf. Then your printf is what the entire program uses. That's a valid solution and would be the way to prevent a header only library from screwing you. (I'll continue to the topic of "fixing the ugliness" in a subcomment below, because that's a whole different topic with its own ramifications)
Take a look at my sololearn. C is my main language and I post a lot of examples for beginners üôÇ https://www.sololearn.com/Profile/7356480/?ref=app
But the wording make it seem like single header libraries are always platform independent. Additionally, the "easy to add" can be extended to `.h`+`.c`-libraries with `#include "lib.c"`. The only maybe advantage is that you only have to copy-paste one file instead of two, but that isn't really a strong argument in my opinion.
I wanted to ask how to improve my project of a small header file to ease coloring the shell output of a program in c or c++ but this post scare me :(
Yep. Not that it really matters, but I design and implement embedded software for lab equipment as well as control (desktop) software for all kinds of industrial devices.
Your C recursion example needs to void that return if not being used ü§£
This was an excellent post. Thanks. &gt; is something that likely only one of your translation units is going to do. I think all of my uses of single header libraries has been for single translation units, which is why I didn't understand these issues earlier. So I guess a printf single header library isn't great, but a lot of single header libraries that I use, like bmp.h, won't usually have this issue. So there are uses for single header libraries right? There were blanket statements in that other thread which made it seem that they weren't good at all.
(continued from above) On the topic of "fixing the ugliness": Screwing with global defines is a great way to screw yourself. Let's say that there's this "IMPLEMENTATION" and "USER" macros that compile in or out pieces of the header. Well, you need to make sure they're all perfectly kosher, otherwise you'll get linker errors. That's fine though. Linker errors happen before you have a program. Linker errors are *good*. Not as good as compile errors, but I'll take a linker error over what happens next. struct ThingMyLibraryUses { int a,b,c; #if SOME_VARIABLE int d; #endif int e; } Now, let's say we have this code: // ... Stuff above #if IMPLEMENTATION &amp;&amp; SOME_VARIABLE myStruct.d = 5; #endif // ... Stuff below It should be clear that if you have inconsistent variables across your translation units, this is going to get really bad. You may be corrupting memory, either by writing e to where d is or by writing past allocated memory if the malloc call used the size of the struct not including d. You won't see this until runtime. If you're lucky, it'll crash right away. If you're unlucky, you'll get some random issue *some place way after the problem occurred*. By saying "hey, define this thing in one translation unit, *but not the rest*, you're inherently making your build system less robust. Ideally, all the build modules should share the same global settings -- otherwise you now have to track these differences. If you have many build targets across many platforms (let's say, pc64, xbox, playstation, iphone and you have debug, debug-optimized, optimized, optimized-profile, optimized-ship) *THEN* you add having to keep some random variable consistent -- you're gonna have to hire a lot of build engineers.
Just make a source file and a separate header file. Then remove all the macro trickery you had before to make it work as a header-only library. That's how it's supposed to be.
&gt;yet you seem intent on ignoring any lessons they want to share based on those experiences. I'm sorry if I've come across this way, that was not my intention. I'm only trying to inform people of why this way of distributing a library isn't inherently bad, if the library is a suitable candidate (which hopefully I outlined clearly in my many replies in this thread). I am however kinda annoyed that this way of packaging a library is labeled as "absolutely useless", which is not the case in my opinion. There are definitely merits to this system, however marginal. I've repeatedly stated my own preference for the normal .h .c split, but I understand why the single header approach is chosen and why it's sometimes useful. &gt; But when you come to a subreddit whose purpose is to discuss and learn about C programming, it seems foolish to waste the opportunity to expand your worldview. I agree completely.
It surprise me that you can have such a cavalier attitude in that situation. How do you maintain historic build environments?
&gt;however, the physics only applies at group level, so there's no concept of 'other' universe inside groups Which is a problem, since interractions have to be computed between every particle pair. But otherwise, it would have been an elegant solution.
I can't critique the concept of blanket statements without making one, but I will say that the other thread would be better worded as: "Header only libraries are, more often than not, a bad design decision". It's *rare* that a header only library is a good thing. The larger the library, the worse the idea is. The more often the library is intended to be used across a codebase, the worse the idea is. The bmp example is an example of a *good* header only library. It does *one* very specific thing that a program is going to abstract away, if its smart, or use in a small subset of the overall codebase. Here's a random thing I googled "header only md5 hash", came up with this: https://github.com/Chocobo1/Hash That's a good idea to be header only. If you're writing a program that needs to do some hashing, you want to build a class that does the hashing. In your source, you can include those headers and do your stuff. You won't suffer the problems because its likely your program is doing more than hashing and you've used good architectural principles to keep responsibilities separated. But, its very very specialized. My rule for header only libraries is that they need to be close to 100% vanilla standard C/C++ code. The moment someone adds a #define check or a compiler switch or the like, that code review is going to be blocked until its no longer header only.
In the paragraph you quoted, I wasn't suggesting that you _ignore_ the forces due to that molecule, I was suggesting you adjust the value used for the molecule's position. Will that idea work?
Yep, it worked - I fixed it yesterday by doing just that! There are still some problems though, but they are unrelated, I'll have to fix other functions
It entirely depend on macro unfortunately and I don't see how I could make it work with function only. Right now it's 160\~ lines and I only have one function of 2 lines.
Maybe you don't have to undo the wrapping to compute the forces. What if instead you manage the position information as being within a finite universe, but compute the forces as if the entire contents of the universe repeated infinitely many times in both directions along each dimension. The force calculation would become a sum of 12 infinite series (as each particle is repeated in both directions along the x-axis, the y-axis and the z-axis). There is probably a closed-form result for the total force due to the infinite number of particles. Then, because of this repeating "model", I think you meet the periodic boundary conditions as a matter of definition. The size of the effect due to the periodicity will fall off quadratically in the size of the universe, so you can set the effect as small as you like by adjusting the universe's diameter. And because of the way the forces are modeled, there is no spatial discontinuity at the boundary of the universe.
\&gt; This isn't a priority, but sometimes an unintended consequence of using a single header library.
Such constructs could also be the result of expanding macros that are written to accomplish things that would have been added to the language if macro-based kludges weren't "good enough".
Whether memory works that way or not depends upon the target platform. Modern desktop or server operating systems don't generally work that way, but many smaller embedded platforms can be configured to do so.
If it's a big macro, that's a good point to keep it in a header file. Perhaps try to refactor it such that it no longer needs to be a macro. Also, consider using termcap or terminfo to query the terminal's capabilities and to find out how to generate colour on the terminal used. While slightly more complex than just emitting ANSI sequences, this is way more portable and doesn't puke all over my terminal if support breaks at some point.
I get annoyed with Header-Only libraries as they mean if I want to use them with some assembly program I'm writing I would first have to create a small library program compile that and then use them. I'd much prefer to just call the relevant functions from a precompiled .dll.
I'm interested in what your thoughts are regarding my rather large [peanut-gb](https://github.com/deltabeard/Peanut-GB/blob/master/peanut_gb.h) single header library, which is a Game Boy emulator. The front-end program only needs to include peanut-gb.h, and define few a number of required functions. The library is platform independent, and functions are called from one translation unit, which I think is why it's suitable to remain as a single header library, despite its large size. Because if this, it's been used on embedded platforms like ESP32 without any changes to the library. I don't know whether my decision to write the library like this was a good one, so I would be interested to hear what you think, if you would be kind to give your time.
narp nothing to see here, doesn't fit into this guy's world view so it must be bad....
Well, the usual combination of virtual machines, and literally putting everything related to a build under version control. And being very conscientious about what external binary libraries we include. The biggest problem is actually hardware - you can't store that on a harddrive. Sourcing parts that are available for the next 5+ years can be a real problem. So in practice we need to upgrade our build environment anyway, if say a customer orders something particular that we built like years ago for the last time.
I am not using visual studio so I won't be able to refactor easily my code. The few project that are similar to what I'm doing uses functions that look like "std::grey" but I am not happy with the way it looks. Thank you for termcap and terminfo, I will dig into it ! If you are somewhat interested here's the [page](https://github.com/0pb/macroColor) (my english isn't great and i'm near beginner level)
\&gt; The code some people recommend seems to be pretty difficult to understand. &amp;#x200B; Keep in mind that for anything non-trivial, it's just \*hard\* to read other people's code, even when it's well-written in a language you are proficient in, so this doesn't necessarily mean it's above your level. Reading other people's code is not something you sit down and read casually like a book; it's something you meticulously pore over line-by-line, often with a debugger helping you trace the flow of the program, slowly loading it into your mental stack. &amp;#x200B; I'd say the easiest to understand for beginners would be simple implementations of standard algorithms and data structures, since it requires little domain-specific knowledge, the intended behavior is well-defined and the implementation is generally pretty self-contained. Here's a book that seems to have a lot of such examples (unfortunately old and not copy+paste friendly, but since these algos/structures are standard, it should be easy to google C implementations): [http://index-of.co.uk/Algorithms/Algorithms%20in%20C.pdf](http://index-of.co.uk/Algorithms/Algorithms%20in%20C.pdf)
lol
Yeah, I suppose that makes sense. You're not meant to just be able to skim it and understand. But it's just hard to imagine how they implemented the program, even if you did go through line by line, it's so hard to imagine where you'd even start with a large project. I'm currently stuck with the ability to make simple console programs, like tic-tac-toe etc. I don't really know where to go from there, a lot of recommended projects are either too easy and boring, or too hard and time consuming, I just can't find one in that sweet spot. And at the moment, algo's and data structures don't really seem that useful to me, at the moment. I'm a bit more interested a small, but complete program that does something useful. Data structures would be apart of that, but on their own they don't seem too useful, but I imagine I could learn good habits from them.
Very helpful.
Sorry, it's just that C is notoriously difficult to follow. My first professional C gig made me grow and stretch more than I ever had. If you're determined to learn, know that it will be both difficult and rewarding.
&gt; I am not using visual studio so I won't be able to refactor easily my code. The few project that are similar to what I'm doing uses functions that look like "std::grey" but I am not happy with the way it looks. I don't use an IDE either, I refactor my code with a text editor. It's not hard, you should give it a try.
Thanks, but what was up with your first comment? It comes across as a bit passive aggressive. If it was regarding asking for simple C code, then I'm sure there is some out there. I know the basics of C, it's just hard to find example projects in that sweet spot between extremely beginner code and hard to follow code.
Note that you've done the `do { ... } while (0)` trick wrong: you've added a semicolon to it in your macros which completely defeats its purpose.
&gt; What ends up happening, then, is that every one of your compiled object files has duplicated versions of your printf compiled code. That's not how it works. Only one translation unit has the compiled function body. The header is structured something like: void foo(void); #if BODY void foo(void) { body } #endif and you pick one of your C files to do `#define BODY` before including the header.
Yeah, you won't run into the bloat issues with your intended usage. I took a look, there's a few things I'll note, you may or may not agree and that's cool, but these are my main thoughts -- and I'd certainly be interested to know what you think about them. Overall, though, the code is very clean, in my opinion. **Maintainability**: Your #defines are too "wide". For example, "ENABLE_LCD", what if the program including your header has an ENABLE_LCD flag that means something else? I would prepend the defines with something more unique to your lib, it might not prevent everything, but makes it less likely. E.g. ENABLE_LCD becomes PEANUT_GB_ENABLE_LCD. I don't know enough about what you're doing to say whether ALL the defines should have these, I generally lean towards yes for consistency, but at least the sound and lcd ones should. **Maintainability**: Same as above, but for your types. E.g. audio_t is WAY too generic. pgb_audio_t would be better. For an example of a pure C library that does this, see flite: https://github.com/festvox/flite In their case, all types are prepended with cst_ to limit the possibility of collisions. **Maintainability**: Split your declarations and your implementation. Basically, declare all your types, with their documentation, and your functions, with their documentation, at the top. Define them at the end of the file. E.g. line 157 becomes struct cpu_registers_s; And then you actually define the internals at the end with everything else -- types first, then your functions. This also greatly increases readability -- I don't have to scroll through a bunch of stuff I don't care about (implementation) to see what I do care about (API). **Extensability**: If you do the above, then you can move all your files into a separate file that you include your header. To the user of your header, *it's still single header if they so choose*. E.g. Around your implementation you can do this: #if !PEANUT_GB_NO_SINGLE_HEADER #include "peanut_gb_impl.c" #endif Now someone can decide, at their own discretion, to make the library single header or traditional based on the build system their working in. You get the benefit of splitting the "public" and "private" API -- just because the build system sees it as all "public" doesn't mean you *need* to format your code the same way. **Maintainability/Readability**: Define your function pointer types as forward declarations, use them in the actual structures. E.g. typedef uint8_t (*pgb_gb_rom_read_func)(struct gb_s*, const uint_fast32_t addr); struct gb_s { /* ... */ pgb_gb_rom_read_func gb_rom_read; /* ... */ }; **Maintainability/Readability**: Lots of magic numbers. Bit shift on line 569, internal tick, everything in the __gb_write function, etc. I understand that this is all magic because you're basically copying a piece of hardware, but consider ways to make this more readable so someone who doesn't have the hardware spec in front of them can know what you're doing without tracing all of the code.
Only if you use the "BODY" / "DECLARATION" setup. If your single header is all static functions, then no. The static makes it static to that translation unit.
With a single file it's not possible to have a mismatch between versions of header and implementation files . With a single file you can "install" it to a shared include location on your development system if you want; whereas with a .c file as well then you have to have a shared source location and also muck around with the build system and object file location for this .c fil, which is time that could be better spent elsewhere.
Yeah, it is awful when you have to use some kind of terrible IDE like code composer studio and the build takes like an hour because someone was obsessed with header only. Or maybe it just crashes, who knows!
It makes dependency management much easier, to have a single file.
It was about the notion of any C code being simple
I will try to refactor my code then. Thank for the do while trick, It seems I got unlucky and didn't test it correctly. However removing the ; mean the user will add a ; after each macro. It's insignificant but if I am annoyed by this I suspect someone else would be annoyed too.
You ternary operator example is a bit weird, ignoring that it's actually an expression.
&gt; However removing the ; mean the user will add a ; after each macro. It's insignificant but if I am annoyed by this I suspect someone else would be annoyed too. The whole point of the `do { ... } while (0)` trick is that the user can safely add a semicolon after the macro regardless of where it is used. This is iirc not possible in all situations if you just use a normal block like this: #define foo(x) { ... } You should always require a semicolon after the macro if it is supposed to be like a statement. This makes it easier to later swap out the macro for a proper function.
I got you. There has to be something that's simple out there though. At least not too low level.
5min is a beautiful thing. 12c E5-1650 @3.2GHz takes our 80G C++ project 45m to compile.
I don't think anyone would be a in favour of large static functions in the header. Also I'd expect LTO to merge them all anyway.
I agree, but the original referenced post followed a "story" and part of that story was solving the bloat problem, which is what my post was about -- describing the "bloat" problem then the reasons why using the "BODY" define design could be unfavorable. As for LTO, yeah, it'll do it. I've had MSVC LTO combine multiple virtual functions that compiled into the same code (a C++ range for loop, a C++ iterator loop, and an index loop across a vector) into one single function that all three entries in the vtable pointed to so combining multiple definitions of a function is absolutely something it would do. But it's not guaranteed so can be a legitimate concern.
C is a rather simple language, so you will soon reach the point where you need to expand your study scope to cover *project management* also. Depending on your platform of choice and tool chain, the particulars will vary, but in the end you will need to get to grips with makefiles, projects spread across multiple directories, test suites and so on. If you happen to use a Unix-like platform, [GNU Hello](http://savannah.gnu.org/projects/hello/) might be worth a look. It's a over engineered version of Hello, World! with the bells, whistles and gongs normally exclusive to large projects. Use it to get a feeling for what's actual code and what's support scaffolding. At least in a GNU ish project on *nix.
I'm confused. You're on a C subreddit with C++ code and talking about Java. It's fine to learn multiple programming languages, but I think this is going a bit far. Whatever language you're using, you have to use the compiler for that language.
So you're mentioning that you are learning Java, posting in a C subreddit, with C++ code examples? You trollin'?
`getmaxyx` isn't a function, but a macro.
No, no... I am new to subreddit... And I am self-teaching myself Java... So, it's just a mix-up.... I honestly thought that Java has the "cout" code üòÖüòÇ I apologize.
Ah, I honestly thought that Java has the "cout" code...? I apologize. (I am self-teaching myself, so I had no idea) As for being on the wrong subreddit... I am new, and just thought that any programming thread would work. I apologize.
In your cout, you‚Äôre saying ‚Äúend1‚Äù when it should be ‚Äúendl‚Äù (short for end line). As for why you‚Äôre calling C++ code Java and putting it in the C subreddit....I want what you‚Äôre smoking lol
getmaxyx is actually a macro: #define getmaxyx(win,y,x) (y = getmaxy(win), x = getmaxx(win)) So no magic, just preprocessor expansion.
Ah, so that's what I did wrong. Thank you üòÖ Smoking air, if that works? üòÇ
No problem, I hope your code works now! üòÇüôè
Thank you üòÖ
Both C++ and Java are off topic in this subreddit (which is exclusively about C). Please post this questions elsewhere.
This subreddit is exclusively about programming in C. Generally, each programming language is its own thing and C++ code is not going to work in Java. Also note that ‚Äúcout code‚Äù is a weird use of terms. ‚Äúcout‚Äù is a variable, not a ‚Äúcode.‚Äù Code (uncountable!) is program text. Don't use this word to mean anything else.
Thank you üòÖ
I wish you all the best with your way to programming! I can highly recommend to start with a good tutorial and to actively avoid all online resources and forums until you have followed the tutorial to the end. It's only going to confuse you when a dozen different people explain something to you in 12 different wrong ways when the tutorial is going to do the same on the next page.
I feel your pain. I recently worked on a FFI for ncurses and (though I'm no C expert) you can tell it's an old library. I had a lot of fun tracking down what some functions were "actually" doing. The way it stores attributes (including colours) in bit-fields is pretty cool I think, but I get the feeling it just wouldn't be done like that these days, or at the very least it would be abstracted over in some way.
So, Java is Java... It's not C or C++ or anything like that, right? (I'm not trolling, I swear... I know it seems like a silly question) I am currently on the easy coder android app. Thank you for the advice, I will try to remain on one thing until I become a bit more advanced.
&gt; So, Java is Java... It's not C or C++ or anything like that, right? Exactly! Java is Java and nothing else. Though given your responses to [this comment](https://www.reddit.com/r/C_Programming/comments/carlh8/whats_wrong_with_my_code/etampn1/) it looks like you ended up with a C++ compiler somehow.
Somebody posted a "challenge" .. And I was curious to know if running the code would give me what I expected... I still don't know... üòÖ
That does the trick, and it's really easy to change that so I'll go with this option. Thanks for the help guys.
If you are confused about this, it might be a good idea to start at the beginning. You are trying to do step 5 before going through steps 1‚Äì4.
I figured it out... So, I guess I understood it üòÖ Basically, what it is is (different example that works in Java), but similar thinking): int a = 3; //sets variable to 3 int b = 4; //sets variable to 4 int result = a + b; //adds a and b int result2 = --a * b++ /*decreases a by one, then multiplies a with b*/ System.out.println (result1 + result2) ; /*prints out 7, then 8*/ So, cout is similar to printf() ... As I understand it... and the endl is to stop the program at that "print" (word, number, etc.) *printf() ; is for c, because c doesn't have the cout variable. (need to make this about C, somehow). Now, this makes sense. Thank you.
Pretty much. Note that if you post code on reddit, you need to format it as code. To do so, put your code into a paragraph on its own and indent it with four blanks in front of each line of code.
Thank you for the tip, I went back and edited my text to the right format üòÖ
I‚Äôll probably going to get downvoted for this but, compiling simple applications with debug on and the viewing them in gdb. Gdb‚Äôs disassembly tool will give you an assembly dump of whatever function you write, even functions in libc etc. The vast majority of basic buffer exploit tutorials go over this quite often.
Looks better now, but the comments need to be indented by four blanks, too.
Alright, fixed that, too. Thanks üòÖ
But this means that with every new version of the library, you have to update the library in every project that uses it, and do this for each of these libraries. This sounds like a maintenance nightmare, especially if you consider that without a clean API, there will likely be problems each time you update a library. Most people using these libraries probably never update them.
"The input string stops at whitespace or at the maximum field width, whichever occurs first." [man 3 scanf](https://man.openbsd.org/scanf)
okay, sorry, i mistaken
`scanf` isn‚Äôt reading the entire line, because that‚Äôs not what `scanf` does. (Not that you‚Äôre checking whether it‚Äôs read literally anything, and of course if it doesn‚Äôt, it‚Äôs UB.) `fgets` is probably more appropriate for this, although you‚Äôll have to handle the `\n` that ends the line and you won‚Äôt pick up all of a line longer than your buffer. Also, `int` should not generally be used for things like your string-length index‚Äîit‚Äôs signed, the fact that it‚Äôs signed makes it susceptible to UB on overflow, and `size_t` is the actual type for the size of an object in memory (usually but not necessarily compatible with `unsigned long`). (Although you‚Äôd need to make use of format `%zu` in the later `printf`, or run the `size_t` length through some explicit cast like format `%lu` with cast to `unsigned long`.) And your `stringLength` argument should probably be `const char *` rather than `char[]`, but I‚Äôm guessing you‚Äôre not up to pointers yet. If this is for an assignment and C99 isn‚Äôt explicitly permitted, put your length declaration up near the top of main, before any other kinds of statement. Oh, and misdocumentation: Your maximum buffer size wouldn‚Äôt limit it to 100 characters of input, it‚Äôd be 99 since there‚Äôs an extra `char` required for the NUL terminator.
Thanks! That is indeed causing the problem, but %c doesn't fix it. %c will count the number of words and spaces, returning 3 for "this word" and "this!word" alike.
Oh FFS they didn‚Äôt even bracket `x` and `y` in that. A proper wreckage of a macro on a couple levels.
Ah. My apologies. I glanced through the man page for the info regarding %s, and forgot to look up the proper conversion. Glad it's working for you!
I use header only libraries, and I like them. QQ moar.
That applies to all libraries; it's easier to update 1 file than 2
My understanding is that the optimisation is when you inline those functions. Say you have a complicated function that goes through a lot of steps to return something. Maybe in a particular call you are only using 10% of that complexity. Then if the function call was inlined, the compiler could optimize away the 90%. It wouldn't be able to do this if the function was in another translation unit because it can't make any assumptions about how its used. Similarly with LTO you can only optimize across all uses of that function. With inlining you can optimize to each specific call.
Could you elaborate on this a bit/give an example? I'm not sure I've seen the type of header you're talking about. Thanks!
It's less about copy paste and the fact that there is no packaging at all needed for a single file.
Yeah he's had a hate boner for header only for a while now. Spews nonsense on every post about any header only library. I personally love them and am glad most competent programmers understand why they are good.
I haven't check if it works, but the code looks OK.
I'd like to mention that if you use a unity build(single translation unit) then this is a non-issue. Compilation is already so ridiculously fast with a unity build that adding a bunch of small header only libraries won't even make a noticeable difference in compile time.
Agreed
C is C++ minus a lot of stuff. You're going to miss a lot of functionality and have to rewrite some things you take for granted in C++ (vectors and strings for instance).
If you know C++ you already know like 90% of the C syntax. Learn how to use the basic libraries and read about functions pointers, structures..
[khash.h](https://github.com/attractivechaos/klib/blob/master/khash.h) and FreeBSD's [tree.h](https://github.com/freebsd/freebsd/blob/master/sys/sys/tree.h).
&gt; whereas with a .c file as well then you have to have a shared source location and also muck around with the build system and object file location for this .c file `.c` files can be included as well. This will place the code in the same translation unit and simplify its compilation. By writing `#include "some/code.c"` it's not even necessary to set up include directories.
Have you single stepped it to see why it's doing what it's doing?
Don't assume that the C++ way of doing things is necessarily the C way of doing things; cf. [this Wikipedia page contrasting C with C++](https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B).
It seems to skip over the scanf for 'check' when I call it again.
By every particle pair, like literally every particle? in a sense of making N body physics? what about using a torus coordinate system? it's topologically the same as joining both the X and Y edge. it is continuous, so there's no problem with 'jumping' ie project all points to be on a donut apply physics in your torus coordinate system. granted, it's not a grid, but it'll be smooth then to render, reproject torus to your screen
Your problem is in main(). Note that you call checking() and then errorCheck(). When you compile this program, does the compiler give you any warnings? If check inside of main is 0, what do you expect the code to do?
You don't check the checksum at the end (all NMEA sentences have one as far as I know), and you don't do error checking the latlon to double function, so it is possible to get garbage out. I recommend implementing one or both of those. The code itself looks fine to me, but I into did a cursory look.
agree like list
Good eye! I plan on implementing CRC calculations soon. In regards to the latlon error checking, how do you think I should do that? atof returns 0.0 if a value can't be parsed, so should I do some checking before parsing the value?
I'm thinking more about large values: latitude should never be outside of -90:90 and longtiude should never be outside -180:180.
Yes, with Linux, you should be able to allocate ~2GBs. If you are using it sparsely, then the actual physical memory usage will vary. Linux tends to allocate on demand, so you can allocate tons of virtual memory, but performance will vary based on usage. If you used it all, you would get paging and lower performance, but if it is sparse, it might be good. I'd code it up to do what you want first, then optimize the performance via some profiling tools.
I still would not recommend an approach based on using a heap derived from a malloc and the stack pointer. Both would be dynamic. On an embedded system, even if a physical memory is directly addressable, you would only want to use it if you had carved it out in a memory map or scatter file prior to direct usage. In that case, you could be sure that the heap would not utilize it and a stack overflow would be required to intrude, assuming the system used stack from the same physical memory. Even on such a system, it is best to allocate a label for a swgment/section and have a size parameter tied through configuration and essentially have a manual alloc from the physical memory and programmatically get it. Nothing worse than debugging hard coded memory vs. Allocated memory bugs without strong fencing and allocation tracking....
You will need a lot more discipline to have clean and readable code in C. Have fun! Good luck!
Is the whitespace (e.g., `\n`) after the `scanf` input still in the stream? Try putting a space after the final format `s` or using something more appropriate like `fgets`. Also, you‚Äôre checking the return value wrong. It should look something like if(scanf(‚Ä¶) &lt; 1) { fputs("error: invalid or insufficient input\n", stderr); // 0 should indicate invalid, &lt;0 would indicate EOF. return ERROR; } Don‚Äôt use an entirely separate `errorCheck` function (which just falls off the end instead of exiting) for this one situation.
%\[1-9,+,-,\*,/\]s Commas and s are not needed.
get\_nmea\_type could return a pointer to the handler itself, if sentence tags and handlers were in a lookup table, a struct array. strstr also feels odd, strncmp instead?
agreed, and the formatting of it makes it very difficult to read
In this case brackets won't make much of a difference. At least I don't have the imagination to find a lvalue expression that behaves differently with or without brackets.
Might want to look at http://nmea.sourceforge.net/ for more examples on how to parse things.
When you actually do know the steps needed to have reproducible builds, I simply cannot understand why you still defend the perceived "ease of use" with these ~~SPA~~ header monstrosities.
Rust or Go. Rust is as powerful as C++, with zero cost abstractions and easy multithreading, but without all the old and dangerous stuff. Go is a language also designed for threading and networking; it was co-designed by Ken Thompson, friend and coworker of Dennis Ritchie, the creator of C As the others said, it might be worthwhile to think about Python. It's the swiss army knife of programming languages
x86 is the ugliest assembly ever created. I'd strongly suggest ARM or AVR assembly. You have far far less machine instructions (on some controllers about 120) and can learn it playing on bare metal. That really boosted my understanding of how processors work
You had a workshop at uni about Rust? Most professors I know don't even know what Rust is
Yeah, sad but true. I went to uni in Germany which has the largest Rust community compared to country residents atm. Also this professor had good connection to Mozilla/Rust foundation, I guess that's why he decided to teach it. I'm very glad that I took that course
Are you familiar with Unix-like/Linux systems and their general utilities? If so, maybe consider looking at the OpenBSD src code for utilities in [/bin](https://github.com/openbsd/src/tree/master/bin) and [/usr/bin](https://github.com/openbsd/src/tree/master/usr.bin) - they're mostly small-ish enough to wrap your head around and written in a clean/correct/secure manner.
wxwidgets, qt
Thanks, I just took a peak at one of the files and it seems quite nice. Taking a look at the mkdir program, it seems really short, and they've even commented it. Is there any reason to look at the openbsd source, as opposed to the freebsd source?
Absolutely. +1 for unity builds.
OpenBSD places emphasis on code correctness and security - *all* commits to the OpenBSD src tree are reviewed by at least one other developer. Not saying FreeBSD's is messy or insecure - it might be fine, but OpenBSD devs are practically OCD about code quality so you can expect it to be very good.
You might want to take a look at [minmea](https://github.com/kosma/minmea) before re-inventing the wheel ;)
If you wanted full control over the graphics, you could use SDL for drawing shapes, with SDL_ttf for text rendering.
Thanks! I think SDL might be exactly what I'm looking for.
Thanks u/dqUu3QlS! I think SDL is exactly what I'm looking for! I was just looking over the website and noticed it stands for "Simple DirectMedia Layer" so that's what I wanted: nice simple graphics and text handling/positioning abilities. I also noticed that it is based in part on a graphics library called "OpenGL" (which is itself written in C, interestingly enough!). I'm not very familiar with the concept of graphics libraries, but now I'm suddenly thinking maybe I should bite the bullet and learn OpenGL entirely, as I think it just might come in useful on some future projects? Do you think that might be a good idea to learn OpenGL? Or is learning OpenGL to a decent level a much bigger project then I might be anticipating? Also if I do want to learn in a graphics library in detail, do you know if OpenGL is the library I should focus on the most, or is there perhaps a better graphics library that might be used more widely and even be in higher demand jobs wise? Anyways, sorry for the bombardment of questions! But yes, for now, I think SDL is exactly perfect for what I need now, and what I'm looking for!
This is a great suggestion. Thanks for that.
I've always disliked testing other people's code and I never thought about it so I didn't know why. Your answer resonates me and makes sense. Thanks!
You could give IUP a try: https://webserver2.tecgraf.puc-rio.br/iup/ Contains plotting mechanism and extra canvas and image packages: https://webserver2.tecgraf.puc-rio.br/iup/en/ctrl/iup_mglplot.html
Your array is of length 5 not 6
You‚Äôre only doing 2 iterations in your swap loop, should probably loop from 0 to half the array length.
Oh yep I flew way over that one. Thanks !!
OMG Thank You for your quick response. Can't believe I made that error. Does that mean when I called for \[SIZE(5)\], C just used a random number as my array was only of length 5 (\[0\] to\[4\])?
Also try not to loop to &lt;= size because you will go beyond the bounds of your array. Do strictly less than the size, you cannot access element 6 if your array is of size 6. Lastly you want to change the reading[size-i] to reading[size-i-1] because otherwise you‚Äôd go out of bounds. I.e., 6-0 = 6.
Heres a good idea of what it could look like: [https://pastebin.com/pxaNpJZv](https://pastebin.com/pxaNpJZv)
The array `Reading` is declared to have a length of SIZE, and SIZE is 5, so it has indices from `[0]` to `[4]`.
C will access whatever is after the spot in memory. So if your array was allocated in memory at some address and you told it to get the next element but it was past the bounds of the array it'd try and access whatever is in memory after where your array is stored (causing a seg fault).
Although that code is mostly correct, posting completed code with no explanation won't help very much with the person's understanding of C.
The problem with the code under the heading 'What does this C program do?' is not that the call to printf() was replaced by puts(), rather that he is accessing argv beyond the end of the array. If argc == 1 then argv has exactly 1 element. Accessing argv[1] is going to give you garbage, sure it may be NULL a lot of the time but it's still undefined. You can't blame the optimiser for substituting a function call when you are breaking the language in another way.
Dude, literally just read the array backwards. Start your counter and offset at the end, count down to the beginning.
IIRC argv is required to have a NULL element at argv[argc]. So if argc == 1 then argv[0] is a string (usually the executable name) and argv[1] == NULL.
No deference at all, the ingrate millennial whippersnapper!
if you are into learnin opengl try this: https://learnopengl.com
Thanks!
A GUI is a "graphical user interface" not an interface for a program.
Yes. That part looked awkward to me too. I'd put a pointer to handler in a struct with the STR. `struct SUPPORTED_NMEA_TYPES {` }
This is excellent feedback, thank you. Regarding typedefs, I've typically avoided them after their use within the Linux Kernel was frowned upon, and it makes it clear what the type is if you don't typedef.
So yes, was typing too quickly: I should have said a "graphics library". Apologies for the confusion. Although, now that you mention it, GUI is something I would need included in the capabilities of that library as well. So basically a graphics handling, text positioning, and the ability for the user to point and click at objects, and have the objects respond, is what I'm looking for. Which as someone above recommended, SDL seems like it does all those things! Thus I think I'll go with SDL.
Well if I am an ingrate millennial whippersnapper as you say, why would I ask questions?
Interesting. Not a feature that would notable like better compatibility with C++17. Thats a shame.
Why are C Programmers arguing over the version number of C if there is no deference to make note of?
You're asking a question "Is there a difference" from a programmer, from an absolute point of view there's always a difference between two versions.
I would like you know that I appreciate your feedback and the fact that you are going out of your way to see if it works.
Anything other than a bug-fix release, fixing defects.
I agree that embedded systems should be designed with known stack usage, and that a mark/release or double-ended mark/release heap system is better than one based on malloc/free, but the approach described by the OP is one which some desktop systems (e.g. Classic Macintosh) used to use (yielding a System Error #28 if the heap and stack collided) and embedded implementations may still use if they want to try to automatically support programs that need a large stack and little or no heap, or a larger heap and little or no stack. A better approach would be to have a system which could statically compute maximum stack usage, but to make that work with recursion would require an additional intrinsic which would return 1 if the implementation could statically determine that doing so would not result in a stack overflow, as well as means of annotating what interrupts could occur when and the stack usage of anything outside the C implementation. Such an intrinsic could be processed by computing the maximum stack requirement for each function that would result if the intrinsic always returned zero (recursion would be forbidden in that case), and then using that to determine how much stack would need to be available each time the intrinsic was invoked for it to safely return 1. Note that such a construct could be supported on any platform, without user code having to know or care about how much stack space was required for anything controlled by the C implementation.
Use a counter and increment it until it reaches target number of intersects. If target not reached loop.. But also C != C#...
When the Standard was written, some implementations of \`printf\` were designed to treat a null argument passed for \`%s\` as an empty string, some would output the word \`null\`, some would deterministically force abnormal termination, some would print garbage, and some might have released nasal demons (I've not seen any that did that, though I have seen the other behaviors). Further, some existing programs relied upon such behaviors (some definitely relied upon the empty-string one, but some may have relied upon the forcible program termination as a crude means of shutting things down in response to invalid data). Rather than codify any particular practice, the authors of the Standard opted to allow implementations to process such cases in whatever fashion would best serve their customers. The Standards Committee had a mandate to avoid breaking existing programs, but allowing implementations to process existing code usefully or not as they saw fit was not seen as "breaking" such code. Instead, the Committee recognized that programs could be non-portable without being "broken". BTW, instead of having \`printf\` chain to \`puts\`, it would be more useful for an implementation to include an option that would define and/or produce references to various reserved identifiers based upon what forms of \`printf\` arguments are used. Situations where all calls to \`printf\` within a program use newline-terminated literals are rare, but situations where a program only uses only a small fraction of the \`printf\` argument forms are common. Having a choice of library printf implementations which define dummy symbols associated with the argument forms they support would make it possible to link-time validate a programmer's choice of \`printf\` function against the format strings that are used throughout a program.
So... You're asking how you get input?
What fraction of quality general-purpose implementations for commonplace machines do not support the popular extension of allowing any pointer type to be implicitly coerced to \`void\*\` in such circumstances? The requirement to manually cast pointers when passing as non-prototyped arguments was included in the Standard to accommodate the rare platforms in which different types of pointers had different representations; I don't think it was intended to pose an otherwise-needless burden when writing code that would never be called upon to run on such platforms.
Unixy OS ? One option, kind of crazy, could be to update the variable with debugger. gdb a.out PID set variable somevar=42 detach
I wouldn't say it's that crazy, it was my gut reaction too. It should be fine given the `while(1)` loop, but it does technically stop the program too
Thank you but Sorry I didn‚Äôt understand how can I combine counter and intersect together Let‚Äôs say I added counter and then If counter = 3 How can I combine the intersect condition with the counter condition
It's not really clear what you want. You can change the value of a variable in a huge number of ways. It's kind of what programming is about. With your examples, it sounds like you want to do it with console I/O. &gt; So i need a function like scanf but scanf breaks the program and then continue. This is called blocking. Typical solutions are: non-blocking `read`; `select` or `poll`; blocking I/O in a separate thread.
You're asking in the wrong sub. C and C# are quite distinct programming languages. Trying asking in /r/csharp instead.
/r/cpp and /r/cpp_jobs
Thank u very much !! Cause I searched for r/c# and I didn‚Äôt find anything so I thought here is ok , it‚Äôs r/csharp !! Thank you that‚Äôs helpful
Thank You.
&gt; frankly most low-level programmers shouldn't be touching it in 2019 I have had to use assembler when doing goofy shit like leveraging an instruction that the C compiler doesn't know how to use, but in these cases you must put the code behind an include guard and if you're not compiling on the target system, you must also write an implementation for that instruction in software. But all the same, it's a very useful skill to have when C doesn't support something, but there happens to be an arcane instruction on your target CPU that can be used.
Easily egged, I tried to script it. The time lost in an automated patch was around ten, twenty microseconds (comparable to normal delays in execution), and was nothing compared to, say, a page reload in firefox (tens of milliseconds). For some reason, gdb does not like here-documents? I had to put the commands into a separate file and gdb -quiet -batch -x patchvar.cmds ./a.out $1
Intersects just returns T or F. So you just need something along the lines of... while(1) //loop of some kind presumably already exists { if ( intersects ) count++ if (count &gt;= 3) { //run your exit condition } }
Fucking wow, you're not even in the right subreddit. C...C++...lol whatever they both have the letter C. I know your company is too cheap to take it a real ad, bit please don't forget this subreddit with your trash, thanks.
Read up on C99 and C11 both have things that aren't in C++
You could take a look at my [DNS encoder/decode](https://github.com/spc476/SPCDNS) project. It's primarily one C file and one header file (although there are a few other source files, they're not strictly necessary for using the code).
But why make it undefined behavior, rather than implementation-defined behavior, if the goal was to not break the code?
¬´ Good morning C++ community. ¬ª LOL.
If one were to use it in C++, then Something&lt;A, B&gt;::x would fit the bill, at least.
&gt; x86 is the ugliest assembly ever created. For some people, including myself, that was the attraction to it. I have done some thumb2 asm (iirc that is a variant of ARM) and some AVR (Arduino!), but they are pretty boring, and there is no real opportunity for optimizations over compiler-generated asm. RISC asm is too simple to be any fun. AVR+Arduino would probably be the easiest way to learn asm these days for embedded, especially since IAR Workbench can simulate the hardware in it's well-made debugger.
Especially these days
It went well thank u :)
There are two things that could pose problems here. If the compiler just emits the `printf` directly, then yes, it‚Äôs an ABI issue. I don‚Äôt know of any ABIs offhand where `int *` wouldn‚Äôt fit into a `void *`‚Äîin theory, an `int *` could have a smaller representation due to a larger alignment requirement, which is why the C standard leaves that as UB. So that probably won‚Äôt be a problem in practice, and IIRC POSIX requires the pointers to have the same representation under the hood. However, the compiler may analyze the `printf` statement before it gets to any code generation. Most compilers *do* do this to some extent to help check format strings vs. arguments when they can see both; e.g., GCC has `__builtin_printf` and `__attribute__((__format__(__printf__)))` that enable this behavior. If the compiler sees that an `int *` is being passed to a `%p`, it can throw an error/warning, or it can do any other thing it wants because it‚Äôs a UB hole. So the real reason to be wary of that sort of thing is so the compiler doesn‚Äôt dick you in the ear unexpectedly.
No problem. Keep developing :)
To be fair to the compilers I doubt you can write assembly more efficiently than the compiler does, but I'm willing to listen to a more detailed explanation. And sure, RISC is not complex, but it teaches you how loops and branches on the lower levels work and it has its pit falls, too. But I wouldn't even know where to start at x86, there are even two different assembly languages, AT&amp;T allowing you to use 16, 32 and 64 bit instructions at the same time. If the OP just wants to learn about low level stuff, he should stick with KISS
Username does not check out. Also this is not a C++ community.
"Deference" means "polite submission and respect". I was making a joke that C18 has no deference for C17, not insulting you. For future reference, you seem to have meant the word "difference".
Indeed, the printf's could atleast be vertical aligned, jesus christ. Some sugestions: age &gt;= 18 ? printf("Good.") : printf("Nope."); age &gt;= 18 ? printf("Good.") : printf("Nope."); age &gt;= 18 ? printf("Good.") : printf("Nope."); printf("%s", age &gt;= 18 ? "Good." : "Nope."); printf("%s", age &gt;= 18 ? "Good." : "Nope." );
And calling it callback_function when it's clearly not a callback_function is triggering.
If an action is characterized as having Implementation-Defined Behavior, that requires that all implementations define it, without regard for whether doing so would offer any benefit to their customers, or the fact that on some platforms it might be expensive to guarantee anything meaningful about the behavior. From the C Rationale: &gt; The terms unspecified behavior, undefined behavior, and implementation-defined behavior are used to categorize the result of writing programs whose properties the Standard does not, or cannot, completely describe. The goal of adopting this categorization is to allow a certain variety among implementations which permits quality of implementation to be an active force in the marketplace as well as to allow certain popular extensions, without removing the cachet of conformance to the Standard. Informative Annex J of the Standard catalogs those behaviors which fall into one of these three categories. For an implementation to define something that the Standard required it to define would hardly be an "extension". Until roughly 2005, it was pretty well recognized that when the Standard characterized an action as Undefined Behavior, the Committee was deliberately *refraining from passing any judgment* about which implementations should or should not be expected to process it usefully. One of the biggest tragedies in computing history was the failure of programmers to swat down the fundamentally-wrongheaded notion that the Standard intended implementations to draw inferences based on the notion that no situations involving UB will arise, rather than acknowledging that the programmer might be exploiting the "popular extension" of processing the action in a fashion characteristic of the environment. The result is that compilers spent more effort than should be required to produce optimizations that are less effective and more dangerous than they should be, and yet force programmers to jump through hoops to accomplish things that would otherwise be easy. Had that effort been spent working on directives to e.g. indicate that an array may be "filled" with arbitrary data if code reaches a certain point (often allowing compilers to process iterations of a loop in parallel or out of order even if it has an early-exit condition), the language could have been safer, more convenient, and more efficient than it is today.
Given that the Standard does not require that a conforming implementation be capable of *usefully* processing any programs (an implementation could be limited to processing one contrived and useless program and yet still be conforming), actions which might trigger fatal diagnostics should, from a practical perspective, be distinguished from those that could malfunction in other ways [IMHO, the Standard should make such a distinction as well, though it currently doesn't]. Contrary to what some compiler writers claim, the fact that the Standard doesn't mandate that all implementations process a construct usefully does not imply any judgment about whether an implementation that processes it usefully may be more suitable for some purposes than would be one that doesn't. If one is using an implementation for the purpose of identifying portability issues, squawking when they are discovered--even if their behavior would be fully defined on the present implementation--may be useful. If one is using an implementation for the purpose of code that is known to exploit a popular extension, however, processing such code according to the semantics of that extension would likely be more useful than doing anything else.
It's either C, which is on topic in this sub, or C++ which isn't. There is no such thing as a C/C++ language.
Which is fine and dandy, but the compiler‚Äôs still allowed to UB if you don‚Äôt cast because the standard defines passing arguments not matching the format spec to `printf` as UB. For the cost of typing `(void *)` you can avoid that and all other issues pertaining to this topic.
Use scanf_s this worked for me hope it helps!
You might want to check /r/cpp instead, C and C++ are separate languages and have different resources. The only suggestion I can offer is cppreference.com, they'll have more over at the other subreddit.
No; the user can always add the `;` if they want to. The point of do..while is to *force* them to.
Are there any purposes other than: (1) running on very unusual hardware, or (2) identifying potential compatibility problems with code that would need to be run on unusual hardware or on inferior implementations, for which an implementation that requires the cast should not be recognized as inferior to one which can behave usefully without it? Why should C be taken seriously as a twenty-first century language if it forces programmers to write extra verbiage purely for the purpose of accommodating the limitations and quirks of platforms that were obsolescent a quarter century ago \[or in some cases may never have existed in the first place\]?
You know how many withdrawals the user made. Adjust the conditions for the loop that prints them accordingly.
so if they originally thought they would make 5 withdrawals, and they withdrew all their money on first or second withdrawal, how do I make the recap loop which shows all the values of the array only print 2 values instead of the 5 they originally thought they would make?
You can add a variable that keeps track of how many withdrawals have *actually* been made, and use that to terminate the print loop at the appropriate time, ie `for (i=0 i &lt; actual_withdrawals; i++)`
Using Visual Studio with C++ is trivial, just open the "Get tools and packages" window and install the C++ desktop development package, then start with one of the templates MS provides. &amp;#x200B; Bjarne's book is a good C++ beginner resource: [https://www.amazon.com/C-Programming-Language-4th/dp/0321563840](https://www.amazon.com/C-Programming-Language-4th/dp/0321563840) &amp;#x200B; One you know what you're doing somewhat, this is a good resource for best practices: [http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines) &amp;#x200B; But personally I'd start by limiting yourself to C (or the C subset of C++) first, and wrapping your head around the basics of low-level programming (like pointers) before taking on C++. It's a big, ugly language that will hurt your brain.
&gt; Are there any purposes other than: (1) running on very unusual hardware, or (2) identifying potential compatibility problems with code that would need to be run on unusual hardware or on inferior implementations, for which an implementation that requires the cast should not be recognized as inferior to one which can behave usefully without it? You‚Äôd have to compare ABI, varargs implementation, and compiler implementation separately. But does it matter? Code without the cast is incorrect (or at least non-conforming) per the standards, just like `&lt;p&gt;&lt;b&gt;&lt;/p&gt;` is not valid XML, whether or not an XML implementation can fix it up to `&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;`. If your code is aimed at a specific implementation that disregards the incorrectness of passing an `int *` where a `void *` is expected, then go nuts. (Preprocessor-assert about that implementation beforehand, of course.) &gt; Why should C be taken seriously as a twenty-first century language if it forces programmers to write extra verbiage purely for the purpose of accommodating the limitations and quirks of platforms that were obsolescent a quarter century ago [or in some cases may never have existed in the first place]? I don‚Äôt personally consider C a 21st-century language. It‚Äôs a useful tool and has been for almost 50 years, but there are a lot of sharp corners and plenty of rope twisted into almost-nooses hanging around, and it‚Äôs certainly a product of its time. This is one of many weird or moderately-stupid rules that has to be remembered, just like `INT_MIN` possibly being ‚àí32767 or `-1 &gt;&gt; 1` possibly coming out as `INT_MAX`. Regardless, there‚Äôs no real point in attacking it. It is what it is, it‚Äôs used allthefuck over the place, that‚Äôs not going to change, and programmers who have some reason to use C would do well to learn it properly.
There's not really a tool for this, no. However, you can often make the compiler warn when return values from functions are ignored. GCC and clang have an annotation for this: `int erroring_function(void) __attribute__((warn_unused_result));` ...but then the user can shoot you in the head by using `-Wno-unused-result` (-Wunused-result is on by default).
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
&gt; But personally I'd start by limiting yourself to C (or the C subset of C++) first, and wrapping your head around the basics of low-level programming (like pointers) before taking on C++. Recognize also that the name C is used to describe the low-level language which became popular in the 1990s, and a subset which the optimizers of clang and gcc process, designed around the premise that if some parts of the Standard and an implementation's documentation describe the behavior of some action, but another part of the Standard allows an implementation to process that action in a useless fashion, programmers have no right to expect the useful behavior. The way pointers worked in the language processed by compilers in the 1990s was simple. The way they work in the language processed by the clang and gcc optimizer is much more arcane, since there's never been a consensus about what the rules actually mean. The authors of the Standard didn't think it would matter if it allowed compilers to do obviously-silly things, because nobody trying to write a quality implementation would do such things even if allowed. Unfortunately, the maintainers of clang and gcc have interpreted the failure to forbid silly behaviors as implying a judgment that such behaviors would be appropriate in any decent-quality implementations.
If the string is being read into a fixed-sized buffer, the length index is never going to get anywhere near large enough to overflow an `int` on any normal system unless other worse things are going on (while INT_MAX is only 32767 on some systems, the only remotely-modern systems where INT_MAX isn't at least 2147483647 are freestanding implementations whose RAM would be too small to make a 32767-byte line buffer practical. While there have been some popular platforms which could access more than 65,536 bytes of storage despite INT_MAX being 32767, such platforms have long been obsolete for any purpose other than retrocomputing. Unless I need the full range of unsigned types, I much prefer using signed types to represent quantities, since they behave in arithmetically-correct in the range near zero. If `x` is less than `y`, an expression like `x-y &lt; 3` will yield 1 if x and y are signed, but 0 if x and y are unsigned (because `x-y` would equal `UINT_MAX-(y-x)+1u`).
People downvoting you must've never heard of unity builds
The standard library is a vast collection of macros, functions, types etc.. defined in two dozen header files. For lots of programs it's the only way to do anything other than calculations. One of those header files is stdlib.h, which is defined as such by the official C standard &gt; The header &lt;stdlib.h&gt; declares five types and several functions of general utility, and defines several macros So it's just a confusing name, it's not *the* standard library, it's just a collection of functions they didn't where to put otherwise.
There is no such common extension. The UB happens to work as expected on common platforms because of the properties of the ABI (i.e. that `int *` and `void *` have interchangeable size and representation etc.)
People quoting the Standard is relatively new. I'd say I first started seeing it about ten or so years ago. In reality, for an implementation that's bizarre enough ( and they could get pretty bizarre ) from before GNU more or less became the baseline, you could see *anything* from a toolchain.
and then you have the stdlib, stdio, stddef, stdarg.... and then a bunch of other standard libraries that don't start with "std\*"... i mean....
Yes, the register size is the width of data processed at one time.
Thank you
What are you trying to do? If your code has any chance of needing to be portable and makes assumptions about struct alignment, it‚Äôs almost certainly misdesigned.
Hey thank you! I understand now, you truly helped me! 1 problem less! As a interesting note, I noticed in [https://www.tutorialspoint.com/c\_standard\_library/stdlib\_h](https://www.tutorialspoint.com/c_standard_library/stdlib_h) they seemingly made a typo! A little bit down that page, it says "Library functions" list, and it says they are in "stdIO.h" not "stdlib.h"! I'll email them I guess.
Alignment can be forced, though, using `__attribute__(__packed__)__`, if you're compiler supports it. This forces there to be zero padding between elements, which you can fill in with byte-specific-sized elements of your own to achieve the exact structure size, alignment, and padding you want.
Great answer! However I don't think I will rewrite my code but instead add functions with \_r suffix where error numbers are passed by reference instead of setting errno. I may also change bag\_array to be not thread safe, and create another structure where it provides thread-safety (e.g safe\_bag\_array).
 board.cells = malloc(sizeof(struct Color) \* board.columns \* board.row); ?
&gt;If this is for an assignment and C99 isn‚Äôt explicitly permitted, put your length declaration up near the top of main, before any other kinds of statement. Why would you default to a 30-year-old language dialect?
Just stick it up there with your other globals
Tried that, but I get an error on compile 'bouncing_ball.c:18:19: error: initializer element is not constant S2D_Sound * snd = S2D_CreateSound("bounce.wav"); //initialise sound'
Well that's weird. Did you try making it const?
Yeah, const throws more errors when i call S2D_FreeSound later might be something weird specific to Simple2D. This should work right?
Did you try declaring the pointer globally as null and then assigning its value in main?
Doesn't seem to want to let me do that either... bouncing_ball.c:18:17: error: invalid initializer S2D_Sound snd = NULL;
You left out the pointer asterisk
Ah yes, thankyou kind sir, compiles now &amp;#x200B; But something weird is going on as `S2D_PlaySound(snd)` called anywhere but inside `main()` simply doesn't play. Doesn't throw an error, but doesn't play the sound. I suspect that outside `main()` it sees `snd` as NULL, but I don't quite understand why as its declared globally and initialized in `main()`. Hmmm
You're freeing the sound before you show the window??? I don't know
From the point of view of the Standard, calling any function which is neither part of the Standard library nor the same source text program invokes UB. Likewise for any situation in which a function is called by anything that isn't part of the Standard library nor the same source text program. Many implementations extend the semantics of the language by specifying that a function calls will be processed by place the arguments at particular spots and invoking machine code at the specified address, with whatever consequences result from doing so, without regard for whether the Standard would require that behavior in any particular case, and also by specifying how C functions will behave when parameter values are placed in particular places, again without regard for whether the Standard would require it to do so. The authors of the Standard expected that in cases where some parts of the Standard or an implementation's documentation specify the behavior of some action and another part of the Standard categorizes an overlapping category of actions as invoking Undefined Behavior, the question of which should have priority would be resolved by the marketplace, with compiler vendors supporting "popular extensions" demanded by their customers. The made no effort to avoid characterizing as UB actions which they expected nearly all implementations to define usefully.
&gt; Code without the cast is incorrect (or at least non-conforming) per the standards, Code without the cast is not *strictly conforming*. The authors of the Standard recognize three situations where the Standard imposes no requirements with regard to how an implementation processes a program that receives particular input: 1. It is an erroneous program. 2. It is a correct, but "non-portable", program [i.e. one could have a conforming implementation which does not process that program meaningfully when fed that data, and doesn't process any other program meaningfully either]. 3. It is a correct program, but it was fed erroneous data. Some people seem confused about the difference between strictly conforming, perhaps because the category of "strictly conforming" programs is too limited to accomplish many tasks, and the category of "conforming" programs is so broad as to be essentially meaningless. Dialects of Ritchie's language are used all over the place. The dialect whose behavior is fully specified by the Standard, not so much.
Using global variables is generally a bad idea. Why don't you put (declare) all the global variables in a `struct { ... } BallState` at the top of your file, declare a BallState local variable in `main()` and initialize it there, then pass around a pointer to it in all the other functions so that none of them use global variables? Much cleaner.
Excellent suggestion, I knew there was a much cleaner way, thanks man!
Yes, in say the 1990s, I don't think people generally had access to an electronic copy of the standard.
This looks pretty reasonable, you sure the warning's coming from this code?
 ball_x, ball_y = ball_r; //set ball start point That only sets ball\_y.
Or have to deal with a project that produce a whole suite of executables, rather than one. The more ancient projects I maintain, do stuff like including c modules from elsewhere. In my experience, that makes for frustrating emergency debug sessions when things break down in the middle of production¬π. 1\. Literally. I make plant control systems.
Nope, the code is fine as is, the row is handled in the loop. There must be something the OP hasn't shared which is going wrong.
`stdlib.h` is a header file declaring functions in the standard library. Technically speaking, this file doesn't have to exist anywhere on the system. The compiler merely needs to make the declarations specified for it available when you try to include it. The implementation of the C standard library is spread over a bunch of files; there is no `stdlib.c`. Rather, there is typically one source file for each function in the standard library.
There are very few cases where this attribute is a good idea to use. Generally, it's a good idea to just forget that it exists.
All modern 32 bit processors can work with data of size 1 byte, 2 byte, and 4 byte. Some can also work with 8 byte and 16 byte data, for the others, the compiler emulates that. The same applies to 64 bit processors, these can generally work with 1 byte, 2 byte, 4 byte, and 8 byte data. Note that word-size does not imply that any of the C standard types have a particular size. This differs between platforms and some times compilers.
For a game, a global variable is absolutely not a bad idea.
Please show us your updated code.
C++ is off topic in this subreddit.
C# is off topic in this subreddit. Please post C# questions to /r/csharp instead.
TL;DR: the map file is very useful for embedded and firmware programming. For programmers who don't do those things the most interesting aspect of the linked article is that by reading the map file you can figure out why any particular object ended up linked into your executable. Here's an example from the article: Archive member included to satisfy reference by file (symbol) /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/lib/thumb/v7e-m+fp/hard/libc_nano.a(lib_a-exit.o) /usr/local/Cellar/arm-none-eabi-gcc/8-2018-q4-major/gcc/bin/../lib/gcc/arm-none-eabi/8.2.1/../../../../arm-none-eabi/lib/thumb/v7e-m+fp/hard/crt0.o (exit)
*Beep boop* I am a bot that sniffs out spammers, and this smells like spam. At least 100.0% out of the 4 submissions from /u/ShubhamPanchal9773 appear to be for courses, coupons, and things like affiliate marketing links. Don't let spam take over Reddit! Throw it out! *Bee bop*
A "complete" C course that "teaches fundamentals" and costs money but doesn't even include pointers and arrays yet? Have you thought about only asking people to pay you once you actually have something useful to offer?
Segfault will only be emitted if the area beyond the array bounds, that you are trying to access, was not allocated.
Oh, man! You started studying just in 2018. Do you really think that you can teach someone else when you're still studying at university?
stdio.h is another file that deals with I/O (input &amp; output - read it as ‚Äústandard input and output‚Äù). I‚Äôm pretty sure things like printf are there to help you read stuff into or write out of your program. Definitely not a typo.
Nope it is board.cells\[i\] = malloc(sizeof(struct Color) \* board.rows); giving the warning. &amp;#x200B; The warning says: Buffer overrun while writing to 'board.cells': the writable size is 'sizeof(Color \*) \* board.columns' bytes, but '16' bytes might be written. &amp;#x200B; I've shared everything relevant as well.
yes. The warning says: Buffer overrun while writing to 'board.cells': the writable size is 'sizeof(Color \*) \* board.columns' bytes, but '16' bytes might be written. &amp;#x200B; It points me to this line: board.cells\[i\] = malloc(sizeof(struct Color) \* board.rows);
That's doubtless true. At any rate, at some point the timbre of discussion shifted from "how can I get this thing to do what I want" to "what should I want this thing to do?"
That line doesn't do any writing. It must be a line nearby that's causing the error. Sharing the whole program would be helpful here. I'm afk for a while but I'm sure someone else might be able to shed some light on it.
[https://github.com/HOWZ1T/Pathfinding-Visualisation/blob/master/PathfindingVisualisation/main.c](https://github.com/HOWZ1T/Pathfinding-Visualisation/blob/master/PathfindingVisualisation/main.c) good idea, the code that is giving warning is in the main function starting at line 208.
Reading the title, I thought the article was about symbol map files aka version scripts.
&gt; if you help me solve this problem. Which is?
&gt;That line doesn't do any writing. It writes to `board.cells`. Specifically, it sets `board.cells[i]`. That's writing. Am I missing something here?
&gt;Buffer overrun while writing to 'board.cells': the writable size is 'sizeof(Color \*) \* board.columns' bytes, but '16' bytes might be written. What tool are you using that outputs this? There is something missing here. If `board.columns` is in fact 5 at this point in the program, `board.cells` can't be shorter than 20 bytes. As I understand it, that's more than 16 bytes.
I guess what is meant here is the way of applying operators in a nice syntax: varX = varX + 3; Can be written as varX += 3; ...Means operations with +,-,*,/ on a value can be written as +=, -=, *=, /= If that's what is meant with "shortcuts"
&gt; uses both the operators and shortcuts Can you describe what a 'shortcut' is? That's not a term I'm familiar with in the context of C programming.
I‚Äôm using visual studio 2019‚Äôs debugger. Yeah I think I‚Äôm misunderstanding how to allocate memory correctly, I‚Äôm still fairly new to memory management in C. If I figure out a solution in the meantime I‚Äôll be sure to update the post.
Sorry. I now updated the post with the example outcome
This is what it said on the "scenario" Scenario Take a look at the code below: it assigns two integer values, manipulates them and finally outputs the result and bigresult variables. The problem is that the manipulations have been described using natural language, so the code is completely useless now. We want you to act as an intelligent (naturally!) compiler and to translate the formula into real "C" code notation. It's the same code as the sixth lab about operators, but this time, try to use pre/post and short-cut operators - they fit perfectly into some of the steps. Test your code using the data we have provided. &amp;#x200B; Tbh, Idk what shortcut means either
btw you can use https://godbolt.org to see how code compiles on different platforms, for different processors, with different optimization settings. This is very helpful for checking if things you *think* will help compilers to optimize code are actually effective.
Make your program multithreaded. One thread does the infinite loop, another thread polls from stdin.
Jumping on this, wow malloc is a std library? How would you control memory otherwise?
That's not a typo. stdio.h is another one of the many headers in the standard library.
&amp;topping? You might also want to null terminate your char array for it to work properly as a string.
&gt;Well that's weird. It's not weird at all. Global data is "initialized" at compile time. Consequently, it can only be initialized using things that are constants.
Thank you! It's obvious that my book didn't cover that part. And by null terminate, how exactly could I do it? Thank you
&gt; i'm writing a structure and i'm trying to make it nicely align in data width The compiler is likely to take care of this for you. Beyond that, it's complicated. Why make it align nicely? But yes, a 32-bit processor has 32-bit registers and a 64-bit processor has 64-bit registers. Current 64-bit processors also have 80-bit and 128-bit registers, usually 256-bit registers, and sometimes 512-bit registers.
After you read in text to your char array you want to add a ‚Äò\0‚Äô after the last character read in. This is how strings are formed in c.
After you read in text to your char array you want to add a ‚Äò\0‚Äô after the last character read in. This is how strings are formed in c.
\#include &lt;stdio.h&gt; &amp;#x200B; int main() &amp;#x200B; { &amp;#x200B; char topping\[24\]; &amp;#x200B; int slices; &amp;#x200B; int month, day, year; &amp;#x200B; float cost; &amp;#x200B; printf("How much does a pizza cost in your area?"); &amp;#x200B; printf("(enter as $XX.XX)\\n"); &amp;#x200B; scanf("%f", &amp;cost); &amp;#x200B; printf("What is your favorite one-word pizza topping?\\n"); &amp;#x200B; &amp;#x200B; scanf("%s",topping); fflush(stdin); printf("How many slices of %s pizza\\n", topping); &amp;#x200B; printf("can you eat in one sitting?\\n"); &amp;#x200B; scanf(" %d", &amp;slices); &amp;#x200B; printf("What is today's date (enter it in XX/XX/XX format).\\n"); &amp;#x200B; scanf(" %d/%d/%d", &amp;month, &amp;day, &amp;year); &amp;#x200B; printf("\\n\\nWhy not treat yourself to dinner on %d/%d/%d", &amp;#x200B; month, day, year); &amp;#x200B; printf("\\nand have %d slices of %s pizza!\\n", slices, topping); &amp;#x200B; printf("It will only cost you $%.2f!\\n\\n\\n", cost); &amp;#x200B; return (0); }
Even in a game, handling global state in a cleaner less error-prone way can be a good idea
Ermm. Doesn't scanf do that automatically?
Yep you‚Äôre correct.
The only thing I can imagine they mean is stuff like: `x += 1;` or `x++;` instead of `x = x + 1;` But nobody calls those "shortcuts"; they are also operators. (In C++ you could overload them to do totally different things for custom structs/classes, although this is not recommended.)
Normally the OS provides one or several ways to request memory; `malloc()` would generally be implemented for your target platform using one of these mechanisms. But you can write your own memory allocator if you know how to ask the OS for memory, using either `system()` or `syscall()` or by writing ASM code. e.g. https://jameshfisher.com/2018/02/19/how-to-syscall-in-c/
Thank you, makes tons of sense!
Unfortunate that both have the same extension, especially since they both work with the linker. Version scripts aren't often used on embedded, so this didn't cross my mind.
Will do tonight, this is such a great sub, always so helpful!
 printf("(enter as $XX.XX)\\n"); scanf(" $%f", &amp;cost); Remove '$' from scanf. It should looks like this: scanf(" %f", &amp;cost);
&gt;using either system() or syscall() `system` is for executing shell commands, and `syscall` is also a standard library function. You can, however, implement `syscall` yourself in assembly. Apart from that, it's totally reasonable (though not common) to use the OS to allocate a memory region with `sbrk` or `mmap` and manage it yourself, instead of using `malloc`'s management, even if you're using the standard library.
Yes, you would get a tiny performance gain by using global variables (and not using function arguments), but that is not worth the inherent obscurity of the code that goes along with it, especially when the game is complex and there's a lot of code.
You're welcome.
What is the exact input you're entering?
It's not about performance. It's about global variables being fine when they actually represent global state that is going to stay global.
Removed `system()`, you're right and that wasn't what I meant. I did mean the `syscall()` library function. :-)
The problem with that is that all functions are then dependent on the existence of the global variables in order for them to work properly. If they got their input from arguments instead, they would be more versatile and easier to follow. What if there were *two* balls in the game? You would then have to create more global variables and change every function to access those. If you used local variables in main() instead, you wouldn't need to -- just call the functions with ball1, ball2, etc. Like I said, global variables are generally a bad idea.
int main() should be there if you are returning 0, it's ANSI C standard. return (0) is not valid on gcc compiler. use %\[\^\\n\]s instead of %s to handle spaces. you need to use if condition to have questions pop u one after another. You can enter date as string, separate it using strtok and then use time.h to get date input instead of separately asking user.
Finally solved the vertical histogram problem. Thanks, Medww, your hint of space was useful. Correct code at same GitHub link.
My biggest tip: when you‚Äôre tempted to do something in an OOP way, think about what you‚Äôre trying to do and see how you can simplify things as much as possible. Same with data structures. Do you really need a hash table? Can an array work instead? Etc
&gt; The problem with that is that all functions are then dependent on the existence of the global variables in order for them to work properly. If they got their input from arguments instead, they would be more versatile and easier to follow. That depends on what your mental model of the program is. If you think about the functions as changes to the state of the game, then a global variable is a good idea. If you think about them as methods on an objects, then a parameter is a good idea. Personally, I think that completely avoiding global variables often leads to overly verbose functions that take a handful of arguments, most of which are always the same. You can for example see this design approach in the Unix API: by endowing the process with a lot of state, system calls have very few arguments and are easy to use. This stands in contrast to the Win32 API where much more state is explicit and thus each system call is a confusing mess with a dozen arguments. It's a balance to strike and no strategy is always correct. &gt; What if there were two balls in the game? There are not, so it doesn't matter.
Thank you for your help! I get ahead everytime I'm helped :)
As a general recommendation: If you (or any reviewer) needs to look up precedence rules to be sure what your code does, use parentheses.
I often find myself parenthesizing things to death, by adding padding after and before open and closed then this often helps with readability too, one glance and you can see whats happening...
The precedence rules of C are very simple: 1. first, apply unary and postfix operators from right to left (function calls and array indexing are postfix operators, type casts are prefix operators) 2. next, recall that we do multiplication (and division, modulo) before addition (and subtraction). Both are left-to-right associative 3. then come bitshift operators, also associated left-to-right 4. then come comparisons for ordering. They are associated left-to-right, but don't ever make use of that. 5. then come comparisons for equality (because people want to do `a &lt; b == c &lt; d`) 6. then bitwise operators (since that used to be what you used for conditions as well). The precedence is again conjunction before disjunction with `^` binding stronger than `|` 7. then come logical operators as a retrofit with conjunction before disjunction again (different from shell-scripts!) 8. then comes the ternary operator which binds right to left 9. then assignments (which makes sense as the ternary operator does not produce an lvalue) 10. then the comma operator Every one of these decisions has a clear rationale and can be remembered easily.
I've had no formal training in computer science or programming. So this is learning for me
That's fine. Here's the same question a slightly different way: what do you think the benefit would be for making your struct aligned? What's going to be different about the way your program works?
Because you never assign to `word[3]`.
The correct UTF-8 encoding is 0xC3 0xB1. Here are some questions to explore: * Why do you use `+` to construct `tmp` instead of `|`? * Why do you have `0xff &amp;` when you printf `word[i]`? * Why do you get the expected result when you change `word` to be `unsigned char`?
Yep, integer tmp is never updated with 4th char of word.
Sorry, I forgot to put `word[3]`. I'll edit the code now. But this doesn't change the final output of the code
Not necessary in this case, it's basic math precedence. PEDMAS. You learn that shit in what, 6th grade?
Your chars are getting implictly promoted to ints and are being sign-extended.
&gt;Why do you use `+` to construct `tmp` instead of `|`? I think that in this case is the same. Or I'm wrong? &gt;Why do you have `0xff` &amp; when you printf `word[i]`? I use this to not show trailing `0xFFFF` on the output. More visible output. &gt;Why do you get the expected result when you change `word` to be `unsigned char`? That was the problem haha, I change to `unsigned char` and the code work as expected. Thank!
This is the correct answer, basically `+ word[1] &lt;&lt; 16` will in this case add `0xFFB10000` to the result, effectively subtracting one from the highest byte
In my original answer you will get memory for all the struct Color 'columns' and 'cells'; In your original solution you are assigning memory for 'columns' pointers to struct and 'cells' struct Color, which is different. I don¬¥t know if this is what you need...
To what do you think the authors of the Standard were referring when they used the phrase "popular extensions" in the following paragraph, if not situations in which implementations specify how they will process code in cases where the Standard would impose no requirements? &gt; The terms unspecified behavior, undefined behavior, and implementation-defined behavior are used to categorize the result of writing programs whose properties the Standard does not, or cannot, completely describe. The goal of adopting this categorization is to allow a certain variety among implementations which permits quality of implementation to be an active force in the marketplace as well as to allow certain popular extensions, without removing the cachet of conformance to the Standard. If the Standard requires that an implementation define something, the fact that it actually does so would hardly constitute an "extension". Likewise, if the Standard requires that an implementation perform one of several particular actions, the fact that an implementation happens to choose one in particular would also not seem like much of an extension. When the authors of the Standard use the phrase "popular extension" were they talking about Implementation-Defined behaviors, Unspecified behaviors, or behaviors which depend upon things that implementations aren't required to specify, but which many do anyway.