Yea but that malloc is called only once bc of the way the library is built and it will be freed automatically when the program has stopped running
If possible, please explain me with the line I'm missing. Not just straight explanation, I don't understand without examples. And of course sorry for my English, I am fully self-taught (English) and English is my 4th language. Have mercy, Huehue. Thanks a Bunch!
Around a dozen.
Yeah -- keeping your entries in an array and using linear search should be no problem.
You should try [raylib](https://www.raylib.com/).
You can try [raylib](https://www.raylib.com/) to do some simple game, there are [multiple games with source](https://www.raylib.com/games.html) that can be used as a base template.
This was the question in my job interview 20 years ago, to write out a function on paper .
I gooled a lot ... but eveeything seemed too complex .. so I thought only a real person can answer my questions.
Not sure why you're getting downvotes. As far as I'm concerned, this is practically question of the year. You post your code (not a screenshot of it). Your code is well-formatted and easy to read. You post your output and expected output. You explain why they're different. You explain pretty clearly what they problem is. Since your code is so readable, it only takes a minute to see find the problem. Nicely done. Incidentally, you would probably benefit a lot from learning how to use a debugger. Then you can see how your variables look step-by-step and it'll make it easier to find the problem. Your problem stems from how you're removing records. When you remove a record, all you do is decrement "new" and "count" (see lines 111 and 112) without doing anything else. If you have any records that come after the one that was removed, the last one will now lie PAST the end of the array. E.g., imagine you have three records with employee IDs 111, 222, 333. count is 3 and new is also 3. You remove record 222. Now your array has 111, 0, 333, but count is 2 and new is also 2. This means that the next time you try to add a new record, you will add it in position 2, overwriting 333!! You have two possible fixes to this: 1. Change your add code so that it completely ignores "count" and "new" and just searches for the first record it can find that has id 0 (an open position); or 2. Change your removal code so that, after it removes a record, it fills in the hole by copying a new record in its place. E.g., if you originally had 111, 222, 333, 444 and then remove record 222, you will have 111, 0, 333, 444. You can shift the trailing two records down to fill in the hole to get 111, 333, 444, 0. Your next add operation will then insert a new record at the end.
OMG I went with the second fix and guess what, it worked. You bruv deserve a HUGE THANKS FROM ME. I'm a bit sad lol, cuz I posted these question in 5-6 places (excluding this), only got reply from 1 but he/she replied with no answers, just random. been waiting for this answer for past 2-3 days. You my friend just made my day a whole lot better. Thanking you makes me feel sick, because cant thank you more. Thanks! I'll be using Debugger then from next time. I need to youtube about debuggers cause I don't know how they work. But no worries, as my code worked, now I'm super happy. So, knowing about how to debug and how debuggers work wont take long. Thanks again, I wish I can upvote you 30 times at same time. Sorry for my English tho, I'm self taught (English) and English is my 4th Language. Thanks again!
C doesn't require that the alphabet have contiguous character codes, so this prpgram depends on localization and character set.
If I have some time on the side, I may add cmake with some tests to your project. Would that be cool if I do a PR?
wrong sub
More specifically, the more appropriate subs would be /r/learncpp or /r/cpp_questions.
Your struct definition is not legal, of course, and not really sensical, either. The bigger question is, even if it were possible to store arrays like you have, why would you want to have a series of parallel arrays instead of just an array of objects? Surely this would be simpler (and has the benefit of also being legal C): struct CodecList { size_t NumCodecs; struct Codec { uint8_t *MagicID; size_t MagicIDSize; size_t MagicIDOffset; OVIA_CodecIDs CodecIDs; OVIA_MediaTypes MediaTypes; OVIA_CodecTypes CodecTypes; } Codecs[]; }; Then you can initialize it as: AIFDecoder.Codecs[NumCodes - 1] = (struct Codec *){ .MagicId = (int *){ 0x46, 0x4f, 0x52, 0x4d }, .MagicIDSize = 4, .MagicIDOffset = 0, .CodecIDs = CodecID_AIF, .MediaType = MediaType_Audio2D, .CodecType = CodecType_Decode };
I tweaked around the enum to get the indexing to work just right. I still need to add some function pointers to the struct, but it's working. I'm honestly amazed. typedef enum OVIA_CodecIDs { // We only support purely lossless codecs, not lossy + residual, nor lossless with optional lossy stages, JUST lossless. CodecID_Unknown = 0, CodecID_BMP = 2, // CodecID_BMP - CodecType_Decode = 0; CodecID_BMP - CodecType_Encode = 1 CodecID_PNM = 4, // CodecID_PNM - CodecType_Decode = 2; CodecID_PNM - CodecType_Encode = 3 CodecID_PNG = 6, CodecID_AIF = 8, CodecID_WAV = 10, CodecID_W64 = 12, CodecID_FLAC = 14, OVIA_NumCodecs = 7, } OVIA_CodecIDs; OVIA_NumCodecs is set to the number of codecs, each codec is a multiple of 2 for the fancy stuff I alluded to earlier. typedef enum OVIA_CodecTypes { CodecType_Unknown = 0, CodecType_Encode = 1, CodecType_Decode = 2, } OVIA_CodecTypes; OVIA_CodecTypes is where is magic happens, I'll show that magic next. typedef struct OVIACodecList { uint64_t MagicIDSize[OVIA_NumCodecs]; uint64_t MagicIDOffset[OVIA_NumCodecs]; OVIA_CodecIDs CodecIDs[OVIA_NumCodecs]; OVIA_MediaTypes MediaTypes[OVIA_NumCodecs]; OVIA_CodecTypes CodecTypes[OVIA_NumCodecs]; uint8_t *MagicID[OVIA_NumCodecs]; } OVIACodecList; OVIACodecList is just the variables to be set by each codec, as I said above, I've still got to add some function pointers and I've never had to use them before so it'll take me a bit to get everything to work with them. OVIACodecList AIFDecoder = { .MagicID[CodecID_AIF - CodecType_Decode] = (uint8_t[]) {0x46, 0x4F, 0x52, 0x4D}, .MagicIDSize[CodecID_AIF - CodecType_Decode] = 4, .MagicIDOffset[CodecID_AIF - CodecType_Decode] = 0, .CodecIDs[CodecID_AIF - CodecType_Decode] = CodecID_AIF, .MediaTypes[CodecID_AIF - CodecType_Decode] = MediaType_Audio2D, .CodecTypes[CodecID_AIF - CodecType_Decode] = CodecType_Decode, }; By indexing the array with the CodecID - CodecType I can use a constant to index the various arrays which is really the magic, it's so simple, but honestly I'm still impressed.
if you don't mind a few more suggestions... &amp;#x200B; make it more general purpose by taking out prints to stdout. instead have return values that indicate state. &amp;#x200B; i know it can be done in user code, but it would be nice to add a discard stack to the struct. &amp;#x200B; it can be useful for research type programs to have a shuffled deck pre-generated and move a pointer in memory as cards are drawn. then you can have a history of exactly which order cards were drawn and which cards are still to be drawn by traversing the memory up or down from the pointer. of course, one couldn't use card\_remove in this kind of deck. and this would require quiet a bit of refactoring. &amp;#x200B; tests!
I remember really enjoying these tutorials when I was at about your level: [http://nehe.gamedev.net/tutorial/lessons\_01\_\_05/22004/](http://nehe.gamedev.net/tutorial/lessons_01__05/22004/) I think the tutorials are in C++ but I would be surprised if most of it can't be written in C. The tutorials themselves are about the OpenGL API which is a C API, and they also deal with the Windows API in there too. SDL also is worth looking into.
&gt; Realistically though, you either know about ‚ÄúKernighan‚Äôs trick‚Äù, or, you don‚Äôt. And this is why I hated programming competitions. Either you knew the exact algorithm they wanted you to run, or you wasted your time trying to figure out a solution. Neat trick though. I'll likely forget it by the time I need it, but I do like it.
"which one" of what options? Your question is too vague to understand. On another note, for the first struct there's no typedef so it'd have to be declared as `struct Puppy* pup;`
Except that 99.9% of them are ASCII compatible.
I see roge- is suggesting the same thing. You already have the code needed, just look how you search in delete. Serach the same, but for a zero valued record.
Check out the concept of "linker set". You can make an object file insert stuff into an array automatically.
We can't just give you step by step instructions here, you really need to learn how to google for this kind of stuff. Well made tutorials exist for this exact reason. Things like SDL2, Raylib, and Allegro may be something to search for; they're good libraries for putting stuff on the screen without all the insane Win32 nonsense. Try looking up tutorials for one of those, and if you hit a roadblock, then try looking up whatever the problem is then. That's how you learn and it's how everyone does it.
First of all, (As /u/Calitre said) if you don't use a typedef your Puppy struct it has declared like this: struct Puppy *pup; Secondly and most importantly you can't initialize a member variable of a struct if you aren't declaring it on the stack or if you havn't aloccated memory for it on the heap. So if you really want to use a pointer you should allocate memory like this: ``` struct Puppy *pup; pup = malloc(sizeof(*pup)); if (pup == NULL) return ; pup -&gt; cat = 0; ```` And your question really is vague, do you mean like this ? ``` Ferrari fer = {4, 4, 1}; //or Ferrari fer; fer = (Ferrari){4,4,1} ```
Yeah, it's gimmicky. Also, this particular example is stupid-simple to do in hardware, which is the whole reason for the popcnt instruction in the first place. Failing that, ram is pretty cheap, so if you need to go fast use a lookup table. 16-bit boundaries might be a reasonable speed/storage tradeoff.
I‚Äôm sorry for the vague question this is in my practice exam, word for word. Thank you for the help.
I‚Äôm sorry for the vague question this is in my practice exam, word for word. Thank you for the help.
I've been to a lot of programming competitions, and I rarely felt that it was about knowing the trick. I mean sure, you need to know some basic algorithm patterns such as dijkstra, binary search and dynamic programming, but mostly it was about figuring out how to combine them in a clever way.
Yeah don't worry about it, for some reason some teacheds like to make incomprehensible test questions.
Sure, I‚Äôd love to!
It's not a declaration, it's a dereference (like you mentioned). p is declared earlier as a void pointer, it is later cast to a pointer-to-a-pointer-to-a-Class, then dereferenced. Another way to write this would be: const struct Class ** temp = (const struct Class **) p; *temp = class;
I understand what you're trying to do, but your code makes no sense. The correct solution is a separate struct for each codec. How you collect them is up to you: a static (fixed-size) array, a dynamic array, a linked list, a hash map, a sorted tree...
Thank you, It's starting to take hold in my brain. I'm gonna have to do a little detour from the book and play with this concept.
You might want to tone down the amount of advertisements on your site. They are really obnoxious to the point where I have trouble following the article.
C++ is off topic in this subreddit. Please post C++ content to /r/cplusplus or /r/cpp instead.
Noted!
I'll look into it, thanks. I am not placing any ads at all, so Wordpress must've started on its own.
REPL.it is extraordinarily poor on mobile, which makes it not very useful "on the go". The only time I've ever found it to be usable is when I need to test code in a language I don't know and don't have a compile/interpreter installed for it.
HTML and CSS arent programming languages so it really wont help you in learning C. If you already have a good grasp on Java than I would recommend watching a couple YouTube videos on lower level programming because its significantly different than the higher level languages.
Sometimes it can be useful to have code that can work in a truly free-standing context, relying on the client to supply callbacks for anything that would affect global state. Functions like \`sprintf\` can be invoked through macros that can either chain to a built-in \`sprintf\` (if one is available) or a minimal version included with your code that supports the functionality your code needs (and might yield a smaller program than the built-in sprintf if nothing else would need that function). &amp;#x200B; My favorite callback pattern in C is to have code receive a double-indirect pointer to a function whose first argument is the double-indirect pointer. Clients can then easily create a structure whose first element is a pointer to the function, but which contains any other information they need, and pass a pointer to that. This often works out a little cheaper than the other common pattern which is to receive a single-indirect function pointer and a \`void\*\` whose purpose is to be passed to the callback. &amp;#x200B; A library that relies upon the system freeing all memory when a program terminates may not be suitable for use in an application that uses the library briefly near the start and then needs to perform many other memory-intensive tasks. If memory allocation requests are wrapped in callback, however, the client may be able to keep a list of all the allocations it has performed on behalf of the library and ditch them once the library is no longer needed. One would need to ensure keeping any pointers to allocations in internal static-duration objects, but letting the client control the allocations may increase the range of applications for which the library could nicely coexist.
If one has a structure: &amp;#x200B; struct CollectionOfFancyThings { unint32\_t len; basicThing \*basicParts; extendedInfo \*extendedParts; }; &amp;#x200B; then one can pass \`basicParts\` to a function that expects to operate on a sequentially-stored collection of \`basicThing\`. If most actions that would need to operate on a \`basicThing\` would also need to act upon the corresponding \`extendedInfo\`, having them stored separately would degrate caching performance, but if most actions will operate only on \`basicParts\`, consolidating those may enhance caching performance. If e.g. \`basicThing\` is a third the size of \`extendedInfo\`, code that makes heavy use of \`basicParts\` could often run four times as fast--and in some cases orders of magnitude faster--than would be possible if the information were consolidated. &amp;#x200B; Unfortunately, having objects encapsulate data through pointers forfeits some advantages one could get by having everything contained directly in the same object. If all the information encapsulated by an object is stored directly within the bytes thereof, code which knows how big the object is can copy its state into a new object, write it to disk, or read it from disk, without having to know anything else about it. One could do something like: &amp;#x200B; struct CollectionOfFancyThings; uint32\_t totalSize; uint32\_t numBasicParts; basicThing basicParts\[\]; }; &amp;#x200B; and then have a macro: &amp;#x200B; \#define getThingExtendedParts(col) (extendedInfo\*)(&amp;col-&gt;basicParts\[col-&gt;numBasicParts\]) &amp;#x200B; but unfortunately some compilers lack any mode which would allow them to avoid redundant loads of \`col-&gt;numBasicParts\` while supporting the "popular extension" which waives the "strict aliasing rule" restrictions of N15706.5p7 in cases that don't actually involve aliasing (accessing an object via two means within a context where \*they are not visibly derived from a common root\*). Despite the lack of such a mode, performance should still be good if code that will access many extended parts computes the necessary address before entering any loop that would make use of it.
a, b, c, d, and e need to be on the left side of the basic assignment operators in the first picture. So: a = value_1 + value_6; b = value_2 - value_6; // etc.
So disregarding for a moment that you're using C++, and this is a C programming subreddit, the issue here is that you are assigning to an expression. \`lvalue\` means "left value", as opposed to \`rvalue\`, "right value". \`value\_1 + value\_6\` is an expression that evaluates as an \`rvalue\`. You are essentially saying \`1 + 2 = a\`, which is malformed C (and C++). Perhaps you meant to switch the left and right sides of \`=\`?
Thanks! And i couldn‚Äôt find a C++ subreddit but i didn‚Äôt look too hardüòÇ
Thanks!! I never wouldve thought of thatüòÖ
There's /r/cpp, but for stuff like this, go to /r/cpp_questions. You're welcome. :-)
Thanks!
You might want to install an adblocker.
A slightly more accurate way of reading \`=\` is \*is given the value of\* not \*equals\*. This helps when working with conditionals too (i.e. \`==\` )
Why do you say `popcnt` is stupid simple to do in hardware? On some architectures which act upon or skip objects based upon a bitmask, such hardware may be useful enough to justify the cost (e.g. it could be used to allow the ARM's `PUSH` instruction to compute the final value of the stack pointer immediately and write objects in increasing address order, which may offer some advantages). Unless new techniques have been developed since I studied VLSI design, however, it's hardly trivial. Further, many of the uses I can see for `popcnt` would categorize the results into "zero, one, or many". There are techniques of performing `popcnt` entirely in software using consistent O(lgN) steps for all input values, but if code is only interested in knowing whether something is a single bit or it isn't, such techniques would be inferior to one that simply tests whether the number of bits exceeds one. FYI, an example of a consistent-time solution: x = (x &amp; 0x55555555) + ((x &amp; 0xAAAAAAAA) &gt;&gt; 1); // Compute 16 sums with value 0-2 x = (x &amp; 0x33333333) + ((x &amp; 0xCCCCCCCC) &gt;&gt; 2); // Compute 8 sums with value 0-4 x = (x + (x &gt;&gt; 4)) &amp; 0x0F0F0F0F; // Compute 4 sums with value 0-8 x = (x + (x &gt;&gt; 8) + (x &gt;&gt; 16) + (x &gt;&gt; 24)) &amp; 0xFF; // Compute final sum with value 0-32
Original BASIC made this explicit. LET a=10
I know they aren't languages but as they are used like one I included it. I also never claimed it would help me so if we are splitting hairs, C isn't low level
HTML and CSS are definitely not used as a programming language. HTML is a markup language and CSS is a style sheet language. Comparing HTML and CSS is like comparing apples to oranges. C compared to python is low level and assembly compared to C is high level. The reason C is on the low level of high level languages is that it allows you to utilize the system hardware, which is why drivers and operating systems are written in C.
As I've already said; HTML and CSS aren't programming languages, I know. I said they are LIKE ONE never said you use them like one either. Also, your comparison between an apple and orange doesn't work considering there are similarities, they are both fruits for example -_- Google it. C is not a low level language https://queue.acm.org/detail.cfm?id=3212479
But makeup languages are completely different that a traditional programming language. When C first released it was a high level programming language because it was the bridge between human read able code and assembly. Since Java and python came around, they became a higher level language because they run on a VM meaning they cant interact with hardware. All these high level languages have tons of library's and data structures that are included, C doesnt, it's a barebone language and you need to do most things yourself. That's why people consider it a low level language when comparing with Java or python.
In computer science, you would write: ``` a ‚Üê value_1 + value_6 ``` Because arrows are not part of ASCII, this was written in ALGOL as ``` a := value_1 + value_6 ``` Then in B (precursor to C), the notation was shortened to ``` a = value_1 + value_6 ``` Personally, I would prefer if they chose `:` for assignment and kept `=` for equality operator but well, it's too late for that now.
I know markup languages are different, but they are both "programming" in a way so I merely merged them together, not hard to understand tbh. I suppose what you say makes sense but I will still go by what I've read, thank you
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions. Also, do not post pictures of code or error messages! If it's text, post it as text!
Alright! I‚Äôm sorry i couldnt find a c++ subreddit but i found one just a minute ago! Need me to take the post down?
I have already removed the post. The thing you should take away from this most is that you should never ever post screenshots of code. They are absolutely useless for diagnosing difficult problems in your code. Instead learn how to format code on reddit and post your code as text in your post.
That's a cool constant-time solution; I wouldn't have thought of that very quickly. I'm not a hardware guy, but if popcnt is just adding the bits together, then it's pure combinational logic. Put in the value, wait for propagation delay, read off the answer, no clocking required. You can do what your code above does, in a single cycle.
It's the only way I've found so far to get #include "myheader.h" to work from an Android platform. I have code that won't execute without it.
I'll look into it, thanks.
&gt; if popcnt is just adding the bits together, then it's pure combinational logic Also not a hardware guy, but it seems to me that you could easily implement `popcnt` with a lookup table. An 8 bit table (256 entries) seems like a sweet spot to me, but maybe it's bigger or smaller. Anyway, a lookup table is ridiculously simple to implement. Most HDLs will do it all for you.
Can someone explain what happened here?
If you actually need to count the number of bits set in an integer, you can do it in `O(log n)` time instead of `O(n)` time for n bits like this (assume 8 bit input is x): ``` x = ((x&amp;0xAA)&gt;&gt;1) + (x&amp;0x55); x = ((x&amp;0xCC)&gt;&gt;2) + (x&amp;0x33); x = ((x&amp;0xF0)&gt;&gt;4) + (x&amp;0x0F); ``` The answer is stored in x.
&gt; I'll likely forget it by the time I need it Yeah maybe forget the exact detail but now you can remember "counting bits" and associate it with "Kernighan's trick." Kind of like "weird shit" and "Duff's Device."
What you are needing is "[fscanf\(...\)](http://www.cplusplus.com/reference/cstdio/fscanf/?kw=fscanf)" . You need to open the file with fopen() first, using the input argument. Your main should look like int main (int argc, char **argv) { ... } argv is then a vector of all the argument inputs as strings that were used, one of them is your test.txt, which you can direct into your fopen() like so int main (int argc, char **argv) { ... FILE *file_pointer = fopen(argv[1], "r"); //argv[0] holds the application name //your stuff here fclose(file_pointer); } Here is also some example code further down: http://www.cplusplus.com/reference/cstdio/fscanf/ and its a nice documentation for looking up functions and how they work.
Now that's just stupid. You can't fix stupid. Instead of warning, gcc should probably uninstall itself if it detects code like this. To protect the rest of the world from this stupidity.
You aren't wrong there. But it's also not a problem that I need to worry about much. The other problem, and it doesn't come up here, is that sometimes those neat tricks end up not compiling well because the compilers are too used to verbose code. The easy example is the trick I love of running loops from the end to the beginning (eg: `for( int x = 100; x &gt; 0; x--)`). Originally it ran faster on select architectures because `DSZ` (decrement and skip if zero) would set the zero flag without the extra steps for the comparison. Last I checked, GCC won't compile it that way anymore though but I might be wrong. Note, that trick also got me in trouble in an interview because I used it but i couldn't remember why it was (maybe) better. It broke the interviewer's profiler and he hated it (my function ran in negative time :D)
His explanation makes sense, but, to be honest, it didn't make sense to me until i stepped through an example. given `x=6` and we'll pretend we have 4 bit code, so `x = b0110`. First loop... `0110 &amp;= 0110 + 1111` `0110 &amp;= 0101` (we subtracted `1` from `6`) `x = 0100` (we masked the bits) ret gets incremented to `1` along the way Second loop... `0100 &amp;= 0101 + 1111` `0100 &amp;= 0100` (we subtracted `1` from `4`) `x = 0000` (we masked the bits) ret gets incremented to `2` `x` is now `0` so the loop doesn't continue and we return `2` for the number of bits.
As a beginner, I don‚Äôt get it
`2^16` has magic constants in it that suggest the programmer is trying to do exponentiation. That's not what the `^` operator does. (It is bitwise xor.) Responses to that bug show that there is actual code where this error is in evidence. My really, really crummy C++ textbook from high school stated that `^` was the exponentiation operator. I wonder if there are a few bad, old instructional sources that helped to originate/propagate this mistaken belief.
In the examples listed, there are 2 basic errors. Firstly, an unsigned 32-bit integer can't represent 2 to the power of 32 - that expression would overflow to 0. Holds for any size integer, on any 2's complement machine. But more importantly, 2^32 means 2 XOR 32, which gives a very different number. There is no intrinsic operator for exponentiation in C or C++. These people mean pow(2, 32).
\^ performs an exclusive or, not exponentiation as one might expect. \^ is a bit-wise operator in C. You can test this out by compiling some simple code and printing out the value of an expression like 2\^16.
Wow, I didn‚Äôt know ^ isn‚Äôt exponential either. Thanks for the explanation!
I had no idea pow(n, m) is the way to write exponentiation, thanks for explaining!
Yea you‚Äôre right, thanks for explaining!
Yeah, search GitHub for "84600" as well. Lots and lots of seconds-per-day calculations are fairly wrong, but it's not the compiler's job to fix that.
How much common is that gcc doesn't catch run-time error?
The message should be `warning: if you see this in production code then your test cycle needs work`.
`popcnt` *is* stupid simple to do in hardware in a single cycle. It‚Äôs just a bunch of chained full adders, which essentially do the same thing as the usual constant time masking based algorithm. As far as hardware is concerned it‚Äôs about as simple as it gets, using only log n adding stages and takes a single cycle.
This is why I keep a copy of Hacker‚Äôs Delight handy. It‚Äôs good to know what *can* be done and to look up how when I need it.
The thing to keep in mind is that `x - 1` sets all the trailing bits to 1 and the first trailing 1 to 0. 00111000 - 1 = 00110111 Go back to primary school maths to see why: to subtract 1 from the zeros, they need to bow or from the bit one place higher, which repeats until we hit a 1 we can borrow from. Note that if you and those values together you get 00111000 - 1 &amp; 00110111 = 00110000 Repeat this process to remove the rightmost 1 until you have zero and you‚Äôre done.
What's special about 84600?
It's not 86400.
Well, ```pow(n, m)``` is just a function call, not a syntactic feature.
What do you mean?
Ah ok. Thanks for the clarification
Number of seconds per 24 hours.
They put this just before their source code: cmd : ./1 &lt; test.txt So they're reading the file via `stdin` so `scanf` should be fine.
&gt; Firstly, an unsigned 32-bit integer can't represent 2 to the power of 32 - that expression would overflow to 0. Holds for any size integer, on any 2's complement machine. &gt; What? 2 to the power of 32 can easily be represented with a 64-bit integer. Also, powers of 2 can easily be done with bitshifting. `1llu &lt;&lt;32` will do the job.
It's impossible to know without seeing the data file. That said, learning how to debug is an important skill. If I were you, the first thing I would do is determine what `scanf` is actually returning.
For future reference, what you want is: #include &lt;math.h&gt; int main(void) { double base = 2.0; double exp = 16.0; printf("Result: %d\n", pow(base, exp)); return 0; }
What you probably actually want is 1&lt;&lt;32.
gcc could add a whole -Wbeginner category. It could include -Wexclusive-or-as-pow -Wsizeof-pointer-declared-like-array -Wcasting-malloc and more!
Easy. It's actually 2^32.
&gt; 2**16 &gt; 65536 &gt; 1&lt;&lt;32 &gt; 4294967296 &gt; 1&lt;&lt;17 &gt; 131072 &gt; 1&lt;&lt;16 &gt; 65536
 &gt;&gt;&gt; 2**16 65536 &gt;&gt;&gt; 1&lt;&lt;32 4294967296 &gt;&gt;&gt; 1&lt;&lt;17 131072 &gt;&gt;&gt; 1&lt;&lt;16 65536
http://yourcalendricalfallacyis.com/
That's... 24? It's `24*60*60`.
While that works for a base of 2, for other numbers this won't work.
I would prefer -Wim-an-idiot
Should say 86400. Is 3600 x 24.
I don't particularly know if it will work across compilers, but you can hint the compiler the calling convention of a function pointer so I suppose that it should be stated, but looking at todays compilers, as long as you are using a major one I would expect them to generate perfect code. I will try it out on GCC and CLang and edit this with my results.
&gt; My really, really crummy C++ textbook from high school stated that `^` was the exponentiation operator. I wonder if there are a few bad, old instructional sources that helped to originate/propagate this mistaken belief. The only use that book could ever have is as kindling.
You mean 60*60*24 ‚ò∫Ô∏è
What if you could upload your entire thought process to GCC and it just gives you a warning every time code doesn't do what you want it to do, or what if you just learned the language you were using?
How could gcc catch run time errors without actually running the code? Besides, 2^16 isn't a run time error, it's bug brought on by people who don't know that ^ is actually the xor operator.
He clearly meant `60^2 * 24^1`. Oh wait, * precedes ^ `(60^2) * (24^1)`. C so tricky, gcc should have warned me I needed to put parentheses there. hurr durr
Yeah, C++ has this horrible legacy of not allowing common sense characters for math. Your book is another example of this bad legacy. If compiler people allowed for it, I think a reinvention of the language that allows you to actually write ¬≤ as the second power of something, and other letters to mean what they are supposed to mean, would really help a lot. Of course, the simple stuff like ¬≤ is on most people's keyboards, but some special stuff like ‚â° is not on mine...
So the exact convention (other than default) should be explicit for the compiler to behave correctly. Thank you for your answer, it does lots of helps.
Thank you tremendously for sharing! Also: https://youtu.be/-5wpm-gesOY
This is so sad :-(
Cool. Time to go hunting ^ on github C sources.
Da.
C++ is based on C, a language often used for OS programming. Bitwise operations and tricks have been used significantly more in this space than exponentiation, so it makes sense for the languages. C wasn‚Äôt meant to be a mathematician‚Äôs language (nor is C++), so this isn‚Äôt a legacy of negligence. Also, exponentiation is written in code sparingly, often at the beginning of a for loop or within one. So the value of adding a shortcut isn‚Äôt high. In addition, using special characters isn‚Äôt a good idea either, as many problems arise (editor restrictions, file formats, etc).
%9\[, not %9s ?
&gt; You should always use the Date and Time Services provided by the ICU Project. Of course! We should always use routines that are aware of abnormalities in the calendar. For example, when we start your radiation therapy for 10 seconds just before daylight savings time starts it's obvious that we should blast your head for an hour and 10 seconds because it would be silly to just run a timer for 10 seconds.
An important part of your comment that shouldn't be glossed over is that `-m32` ‚Äî i.e. targeting 32-bit. On x64 Windows there is only one calling convention and the annotations are essentially ignored. If you're testing out mismatched calling conventions, you won't see it on x64.
Maybe I am wrong, and I cannot find the reference. But I remember reading that the language director of the things before C deliberately did not use the equal sign correctly, and instead changed from the common assignment ":=" to the equal sign because it made more common operations easier to write. Which is perhaps fine, but it has left us with bad legacy. Like the fact that "^" has so many meanings. Anyways, this legacy is bad for understanding and creates bad overlaps with mathematical representations. C is much less bad than C++, which has "vector" as something that is not even a vector but a resizeable array.
Oh, now I see why it seemed fine in my test, where the target environment was x64...
Unlike you, people who understand timekeeping universally recognize dates and durations to be separate concepts which should be handled by separate APIs.
Many of the examples provided would be UB anyway, as per C11 6.5.7 ¬ß3 (shifting an operand by a value greater than *or equal to* its width). My personal favorite is [this](https://twitter.com/johnregehr/status/1139295920997068800): for (int i = 0; i &lt;= (2^32) - 1; i++) which, if amended to account for both issues, would be an infinite loop.
I vote for the latter, since the former is [undecidable](https://en.wikipedia.org/wiki/Halting_problem).
**Halting problem** In computability theory, the halting problem is the problem of determining, from a description of an arbitrary computer program and an input, whether the program will finish running (i.e., halt) or continue to run forever. Alan Turing proved in 1936 that a general algorithm to solve the halting problem for all possible program-input pairs cannot exist. A key part of the proof was a mathematical definition of a computer and program, which became known as a Turing machine; the halting problem is undecidable over Turing machines. Turing's proof is one of the first cases of decision problems to be concluded. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
`1&lt;&lt;32` is UB on most mainstream implementations, since, in the absence of evidence to the contrary, `1` is an `int`. You need `1LL&lt;&lt;32` to be safe.
I'm pretty sure that was the point I was making. I felt the comment in the linked page was overly general. However, you probably know best. I expect you have more experience than I do.
yup, I tought that was clear from the flags and context given(aka that OP was using these conventions in the first place) but you are totally right, thanks for the extra clarification.
C is always "pass by value". Think about things that you typically might pass in a C function call: ints, floats, chars, and pointers. All of those can be stored in a register or placed on the stack. When you pass an int, for example (this is platform dependent), the system might read the int from memory and place a copy of it on the stack. If you pass a pointer to something, the system does the exact same thing - place the pointer on the stack. Some systems place values in registers. You don't normally have to care too much about this unless you start writing things in assembler.
Is there a "101" level resource you can link me to that describes this process? If you did it in an intro course, I suppose it's not quite as harrowing as Linux's source code makes it look.
&gt; the language director of the things before C The what now? &gt; changed from the common assignment ":=" to the equal sign because it made more common operations easier to write Math is timeless and stateless and does not have a concept of assignment. The mathematical symbol sometimes written as *:=* has a different meaning, more akin to aliasing, or defining a constant, than to assignment. Most programming languages differentiate statements from expressions, and have no need for separate assignment and equality operators. Some have them anyway, for various reasons: purity (especially in languages with strong ties to mathematics), readability (especially in languages designed for use in education), or tradition. &gt; C++ [...] has "vector" as something that is not even a vector but a resizeable array The use of the word ‚Äúvector‚Äù to mean ‚Äúarray‚Äù predates C++ by decades.
Detecting run-time errors at compile time is [provably impossible](https://en.wikipedia.org/wiki/Halting_problem).
OP is redirecting the file to the program's standard input, so it should work fine. The problem is that the contents of the file does not match the `scanf()` format string.
Of course... if you want to write non-portable code, use `g_printf`... it's pretty simple! Nothing stops an implementation from defining a function called `g_printf` which has semantics that are completely different to what you expect. There are no legal requirements; there's no "false advertising" if someone does that. However in order for an implementation to define a function called `printf` which has semantics that are completely different to what you expect (and legally get away with calling itself C), it would need to refer to itself as a _freestanding implementation_... which none of our common implementations do. That is to say, if a comforming _hosted_ implementation were to define a `printf` that doesn't do things that the standard `printf` does, and this implementation were to cause _actual damage_, then the authors of the standard library could be taken to court. You don't get that guarantee from `g_printf`. Perhaps that's not important to _you_... but is it important to any employers? I'm willing to bet that kind of contractual guarantee is quite important to some businesses that don't want to end up in the gutter.
The icu project is a pile of shit lol
About 99% of the C code I write is for freestanding implementations which include some but not all of the Standard library. Ritchie's Language is great for such purposes, while so-called "portable C" would be totally worthless. On many platforms, every program whose behavior would be defined in "portable C" would be semantically equivalent to `int main(void) { while(1); }` since it would be impossible to do *anything* without accessing lvalues that do not identify objects or using other actions that were defined in Ritchie's Language but not in "portable C". Further, the Standard specifies that if there exists some particular source text that nominally exercises all the translation limits, the implementation need not process anything else without hitting translation limits. Further, implementations are under no requirement to document all of the situations that could exceed translation limits, nor the consequences if those limits are succeeded. This loophole isn't a twisting of the Standard authors' words. As they note: &gt; While a deficient implementation could probably contrive a program that meets this requirement, yet still succeed in being useless, the C89 Committee felt that such ingenuity would probably require more work than making something useful. A quality implementation should of course refrain from using the One Program Rule as license to jump the rails when given almost any source text, but I think the above makes pretty clear that the Standard makes no attempt to brand such capricious behavior as non-conforming.
Thanks for making my morning. You're usually so gentle and kind to newcomers that this truly had me cracking up. Bravo.
/u/megayippie is probably talking about this: https://www.bell-labs.com/usr/dmr/www/chist.html &gt;Other fiddles in the transition from BCPL to B were introduced as a matter of taste, and some remain controversial, for example the decision to use the single character `=` for assignment instead of `:=`.
At least when I was studying VLSI design, routing was often a bigger issue than transistor counts, and many approaches to doing things in O(Nlg(N)) transistors would end up taking O(N¬≤lg(N)) space. A barrel rotate unit, for example, should take NlgN two-way multiplexers, but implementing it as N, N-way multiplexers takes less space. Certainly the complexity of a popcnt circuit is less than the complexity of many other features of fancier microprocessors and microcontrollers, but given e.. a choice between a popcnt circuit or a circuit to cut the time for 32x32 multiply from 32 cycles to 17, I think the latter would be both smaller and more useful [BTW, I find it curious that Cortex-M0 offers synthesis options for a low-cost 32-cycle multiply or a high-speed 32-cycle multiply, but nothing between. The marginal hardware cost to cut a multiply from 32 cycles to 17 would be pretty minimal, but would for many purposes offer as much marginal benefit as the marginal hardware cost to cut it from 17 to 1.
Sure, but... ‚Äúlanguage director‚Äù?
On my phone so sorry for poor formatting: the ‚Äúresult‚Äù variable that is declared in your function is on the stack, meaning that it gets freed when the function ends. You think you are passing a pointer in that will be set in the function, but actually once the function returns the memory it points to will have been released. You want to either allocate memory within your function for the new result string, or do it outside your function. If you take the first route you could potentially leak memory, so I‚Äôd recommend the second route. You can just declare your result string before your function call and pass that pointer into the function. Then the memory will persist after the function returns.
Works well with "no" negation.
1. Your char pointer `ptr_to_result` is passed to `parseString` by value. Any change you make to it inside `parseString` will not propagate outside the function. 2. You are allocating the result string on the stack in `parseString`'s local scope and trying to return a pointer to it. This produces undefined behavior, the string is deallocated when `parseString` returns and even if you returned the pointer (which you did not, see 1), that pointer would be invalid. You need to either pass a pointer to an already existing buffer of sufficient size which you create outside of `parseString` and the function only writes to it, or you need to allocate it on the heap.
It could be useful despite C++: [http://utfcpp.sourceforge.net/#points](http://utfcpp.sourceforge.net/#points)
What is confusing you? A language cannot just be wished into existence. Someone has to direct its development. That "=" is poorly used is neither a controversial nor a strange way to view things. It is even discussed in the Wikipedia article on the subject as a common problem (search-term Assignment (computer science) subtitle Assignment versus equality). And, sure, "vector" has been misused by people for a long time. This does not mean that the C++ committee's choice of making it part of the language was particularly wise. As timeless as algebra is, it is quite common to replace parts of large statement by easier to write terms. "given x := sin(y), the integral becomes..." is the common way of expressing this. No one uses "given x = sin(y)..." Lastly, the only point I made was that if utf-8 ever gets support by compilers, we can just leave the mess that is ascii behind and we will have access to thousands of proper characters for writing the math. This will make codes appear closer to the things that they are describing, so that we can have proper power rules and whatnots. I don't even mind if they explicitly state that utf8-characters outside of the 127-ascii range are for syntax purposes only.
Thank you! This is indeed what I was thinking about.
Ah, I misunderstood your question as rudeness! I would say that a programming language's evolution is directed by whomever currently holds the reigns of said language. This person is therefore the language director. It is not like s/he can completely reinvent C or anything else, because that would mean no one would use the new version. C++ is generally very good at this because they have backwards compatibility with most of C. This is because the design by committee approach works for things that should mostly not change. With "vector" they made a huge mistake in my opinion, and several other mistakes have followed from this. I also believe they need to break with the math-module of C, because the flag-system is not nice with the possibility of "constexpr". But my horse is only in the game as a physics simulation builder and instrument hardware controller. So all I did was to agree with that there is confusion because of poor legacy names.
&gt;If you take the first route you could potentially leak memory, so I‚Äôd recommend the second route. There won't be a problem if OP remembers to deallocate it. There is however a problem with reuse, especially with parsers, where you use the result and proceed with the next data chunk. With memory allocated by the function, this may cause lots of allocations and deallocations. In this case it makes much more sense to allocate some buffer and use it to exchange the result with function - your second solution. There would be one alloc, one dealloc and possibly some reallocs if you need to tweak the buffer size on the go.
You could just use IBM's [ICU](http://site.icu-project.org/home). I think it's straight C.
Fuck off you dirty spammer.
He said: &gt;&gt;an unsigned **32**-bit integer
&gt;-Wcasting-malloc Do you mean something like: &gt;int* array = (int*) malloc(100); Sorry for the beginner question, but what is the problem with doing that? I don't do much C programming, so I don't know what the issue is.
I'll give you some TL;DR to try to clear up some basic concepts. **Unicode** is simply a big list of symbols representing characters in wold languages. One "code point" == one character, or character modifier. You can think of *any* string of Unicode characters as an array of integers. According to Wikipedia, there are 1,114,112 possible points, of which 137,994 are filled. That's the basic concept. Any string, any language can be represented by an array of Unicode code points. "Now", you may be thinking, "I would need 21 bits to encode such a code point. Wouldn't these 'strings' be super inconvenient and inefficient to store when I need only 7 bits to store English text and most text on the web in English?" You are correct. That is why we have *Unicode encodings*, the most popular of which is **UTF-8**. UTF-8 is a scheme by which we can encode any code point with a variable length sequence of between 1 and 4 bytes. Each byte encodes 7 bits, and the extra bit at the end is set to 1 if there's another byte following. There are other encodings that might be encountered, namely UTF-16, which is used in some Windows applications.
Why should it warn? What if you're using them as flags?
The cast masks the compiler's ability to diagnose errors and is unnecessary. That's why it should not be used.
That's because the name of the directory is different in the error than in your post. The folder says "C" in the error, but your post says "C Programs". Just change the dir name.
Place your files in a path that doesn't contain a space, such as `C_Programs`. It appears that Code::Blocks does not correctly escape the paths you give it. My recommendation for beginners is to avoid the use of IDEs until you are very familiar with C.
&gt; About 99% of the C code I write is for freestanding implementations which include some but not all of the Standard library. For you, neither `printf` nor `g_printf` are required to exist... though it is worth noting that if `printf` does exist, [its purpose is reserved by the standard](http://port70.net/~nsz/c/c11/n1570.html#7.1.3). It ought to be clear to you that this provides immensely useful guarantees to those who rely upon it. The rest of your post is irrelevant, but I'd like to see your compiler...
I recently saw this linked on HN, might come in handy as a practical starting point to you, too... &amp;#x200B; [https://begriffs.com/posts/2019-05-23-unicode-icu.html](https://begriffs.com/posts/2019-05-23-unicode-icu.html)
I'm so confused about how to find an environment to type in code, run the program, and see my result. Could you help me out with some advice?
It's *well-defined* when given a definition that causes it to be *well-defined*... that is *defined by the well*... right? What if `g_printf` is a moving target that changes in definition based on the version of GLib? What if in one particular version it causes your cock to shrink? Also, go fuck yourself.
You should get therapy.
I recommend you to use a normal text editor to write your C code and to compile and execute it in a terminal. To do so, navigate to the directory that holds the source code and then type: cc -o program program.c where `program.c` is the name of the source file and `program` is the name of the compiled program. Then execute the program by typing ./program
I've used mblen() to get the length of the next ASCII or multibyte character from an input string. From there you have a few options. You can just print that number of bytes to output if you want to print just that character. Or if t6he length is greater than 1 (i.e. not ASCII), you can use mbstowcs() to convert those bytes to a wchar\_t type, which can then be used an input for various functions that act on that type.
If a library calls an external function `acme_printf`, it will be usable with any application that does not use that identifier for some other purpose. While a name collision could make the library unusable with some applications, that would be true for any imported or exported identifier the library might use. A similar situation would exist if the library defines its own `acme_printf` function that calls `acme_puch()` or other similar function either directly, or via exported pointer. By contrast, a library that uses `printf` directly may be unusable with any applications where sending data to stdout would have undesirable consequences (e.g. because they use VT100-style escape sequences to control screen layout, replace lower-case letters with line-graphics characters, etc.). It would have been helpful if the Standard had defined a "generalized vprintf" which would format text and send it to any kind of output function, in which case client code could supply at run time an output function that was suitable for its purposes, but it doesn't. The best a library can do is either use `snprintf` to format output to a buffer and then call a user-supplied function to output the data, or else use perform the formatting using a function that is either client-supplied or that chains to a client-supplied function.
Why should I be expected to better myself when there are those making the claim who would judge me based on some text on a screen without placing the same expectation upon themselves? Again, go fuck yourself!
&gt; One "code point" == one character, or character modifier. This is simplified, but probably useful enough unless you're developing something like a text editor or a web browser. &gt; That's the basic concept. Any string, any language can be represented by an array of Unicode code points. ... and some arrays of codepoints are equivalent to each other. For example, the character LATIN SMALL LETTER U WITH DIAERESIS (one codepoint) is equivalent to the sequence LATIN SMALL LETTER U followed by COMBINING DIAERESIS (two codepoints); this stuff is handled by what are called [Unicode Normalization Forms](https://unicode.org/faq/normalization.html) and you can't really ignore it if you want to *do* much of anything with Unicode text.
&gt; Unlike you, people who understand timekeeping universally recognize dates and durations to be separate concepts which should be handled by separate APIs. Which is why durations are done in terms of TAI, so leap seconds don't intrude and make a mess out of our durations... *right?* Programmers know that UTC and TAI are different standards for time, and that TAI does not include leap seconds... *right?*
... and what about `_acme_printf`? Are there any restrictions on that? Wait, I already cited that section of the standard, and I quote... &gt; All identifiers that begin with an underscore are always reserved for use as identifiers with file scope in both the ordinary and tag name spaces. &gt; &gt; ... If the program declares or defines an identifier in a context in which it is reserved (other than as allowed by 7.1.4), or defines a reserved identifier as a macro name, the behavior is undefined. [Thus, you are wrong](https://github.com/GNOME/glib/blob/master/glib/gprintf.c#L197)... not only is `printf` more portable than `g_printf`, but `g_printf` invokes undefined behaviour. I know I keep asking this, and you keep dodging the answer for some reason... **Where the fuck is your compiler?**
I hear it's very good.
Do the names `g_printf` and `acme_printf` *start with* underscores, or do they match the form of any other reserved identifiers? If not, what relevance would the quoted text have? If you want my compiler, visit arm.com and you can download the MDK-Lite compiler for free. I use the paid version, but the lite version is basically the same.
Personal preference maybe?
This isn't a direct answer to your question, but I support some legacy code that refuses to compile in anything later than Visual Studio 2005. While I could go through and fix every issue one-by-one, I know that a workaround exists. I'd rather spend my time working on other bugs/features.
traumatized by the installation probably.
-WIntermediate would be cool too so you can learn enforced good style without having to dirty your hands with Java
If you want an IDE, you can use Xcode. It‚Äôs free from Apple on the Mac AppStore. It might be overkill for your purposes, but you can code in C/C++. It will do everything you‚Äôre asking ask for (code in it, run your program and get the output/interact with your program, debug with breakpoints and such, etc.). I personally prefer just a text editor and the native terminal app, but I ultimately started on Xcode since it is graphical and was easier for me to use at the time
If you want an IDE, you can use Xcode. It‚Äôs free from Apple on the Mac AppStore. It might be overkill for your purposes, but you can code in C/C++. It will do everything you‚Äôre asking ask for (code in it, run your program and get the output/interact with your program, debug with breakpoints and such, etc.). I personally prefer just a text editor and the native terminal app, but I ultimately started on Xcode since it is graphical and was easier for me to use at the time
If the question is about `_g_printf` rather than `g_printf`, that raises a different set of issues, most notably with libraries *that are supposed to act as part of the implementation*. If one has a library which is designed to allow a freestanding implementation to be used like a hosted one, it may need to define symbols for its own purposes, but the Standard does not specify any "namespace" suitable for that. From a pragmatic perspective, however, it's probably less likely that a freestanding implementation would have an identifier that conflicts with `_g_printf` than that a user program would have one that would conflict with `g_printf`, though perhaps a longer prefix would be better in either case. Note, btw, that according to the Rationale, one of the purposes of "Undefined Behavior" was intended to allow implementations to support "popular extensions" or otherwise process code in whatever manner would best serve their intended purposes. Most implementations' intended purposes are best served by extending the language to allow reserved symbols to be used like any other *when there is no particular reason to do otherwise*. The Standard allows implementations to treat any particular reserved symbol in any way they see fit, which means it imposes no requirements upon the behavior of any particular symbol (hence UB) but that doesn't mean that freestanding implementations shouldn't allow hosting libraries to define symbols in that namespace for their own purposes if they pick names that aren't particularly likely to conflict.
byte -&gt; defined to be 8 bits. "char" in C. When talking binary data, it's also usually unsigned, so "unsigned char". "character" -&gt; in the olden days, was the same as byte, so people used them interchangeably. In C, this is "char" - usually signed, since 127 is more than you need, right? We obviously need more than 127 discrete values, so what people think of a "character" - a single, printable squiggly that is usually a "letter" - but not always - became a "grapheme". Not to be confused with "glyph" - a single grapheme may be composed by one or more discrete glyphs, e.g. ƒû or »Ç. So a "code unit" is a single value that uniquely identifies a "letter" in Unicode space. Any letter in any language dead/alive can be represented by a unique value, say 20140. But how is that *encoded* into 1 or 2 or 3 or even 4 bytes? That's where Unicode encodings come in. UTF-16, UTF-8, etc. "wide character" -&gt; Now it gets really, really f***ed up. The C/C++ committees decided that 1 byte isn't enough, but 2 bytes should be plenty for everyone, or why not 4? Maybe even 8, why not. Basically, they said - "more than 1, but it's up to implementation to decide how many bytes are in a wide char". Just about then Unicode was becoming a thing and UCS-2 (now obsolete) said that 2 bytes was plenty, so Windows took that and ran with it. So that gives us 65,536 possible values and we, surprise - ran out of space. So UTF-16 was developed, which specified that multiple 16-bit values could be combined to describe a code point. Now we can go beyond 16 bits, and the "old" 16-bit plane became known as the BMP - basic multilingual plane. Seeing that Windows kind of fucked up with a 2-byte wchar_t (Java as well), the Linux people chose 4 bytes for wchar_t. This gives you more than enough space to encode a single code unit into a wchar_t, but also makes you incompatible with Windows and you waste a *lot* of space - strings are now huge. Basically - DO NOT use wchar_t for any "external" textual data. It's a horrible relic of the 90's and for manipulating strings in memory it's fine, but when talking to the outside world - char. So UTF-8 comes along and says that code point can be encoded into 1 or 2 or 3 or 4 individual bytes. Even better - ASCII values are still 1 byte and use the same numerical values, so UTF-8 is backwards compatible with ASCII, which saves your bacon. Which means you can still use good old "char" (yay) for everything. Well, for *storage*. The `&lt;string.h&gt;` functions that assume a single code point == single byte only work when dealing with ASCII. So - be *extremely* careful. The C std. lib **does not** provide any sort of sane, cross-platform way to manipulate Unicode text. Treat strings as bytes, and if you *must* manipulate them as text, use an external lib. I'm not aware of anything as feature-complete as IBM's ICU, but it's also huge and I bet $20 you won't need 99% of it. However - I feel most software doesn't need to treat UTF-8 encoded text as text per se. Most strings in a program are static or come from resource files or something. Unless you're making a text editor or something, the std. lib might be fine for you, as long as you treat your stings as dumb bytes. For Linux stuff, if you want to display text in multiple languages - look up `iconv()` various other mechanisms.
Thanks for the answer :) I actually do have a couple more questions: do you recommend any libraries? Reading around seems like widechars are to be avoided (they don‚Äôt exactly do utf-8 or am I misinterpreting?). Any good resource to deepen my knowledge of utf-8 in c? Books, videos, guides, tutorials all works but I prefer in-depth explanations if possible :)
While I don't think anyone can say for certain why different individuals would use &lt;insert version&gt; of &lt;insert software&gt; for development I would imagine a lot of it comes down to personal preference and required features. Having used different versions of visual studio I can say there was not anything in VS 2017 I needed that wasn't in VS 2015. Likewise there was nothing in VS 2015 that wasn't in VS 2013, etc. If you have a particular version of &lt;insert software&gt; that you have configured just the way you like, then I don't particularly see a reason to upgrade unless there are serious security issues with it. I really like default Vim with no plugins, and despite there being arguable better versions of Vim as well as "more powerful" editors I have Vim configured just the way I like it. I don't have a desire to upgrade to anything else because I see no need to. Maybe Sean Barret &amp; your friend don't want to fix what isn't broken for them? Just a guess.
Thanks, great explanation. I actually realized I can treat my strings as char[] (or char*) because I‚Äôm not doing text-y stuff with it. Nevertheless, I find this extremely interesting and would love to learn more. Python got me spoiled in this sense, I never had to concern myself with much (encode strings and decode bytes, that‚Äôs it). C is blowing my mind: everything is scary, fun and ‚Äúup to me‚Äù, down to the stuff I take for granted in other languages.
There is a video of Sean Barret explaining his reasons. Good luck finding it. From what I remember, they didn't sound very convincing to me.
I feel dumb. I've done loads of bitwise operations. I've toggled bits on microcontrollers with \^. And it still never clicked that this was why so many languages use *\^\^* or *pow(#,#)* for exponentiation.
Use the ICU libraries. They work with C99 and C11: http://site.icu-project.org Still, you need to know whether you have C11 for unicode string literals support or not. Here's a good place to start: https://gustedt.wordpress.com/2017/03/09/unicode-operators-for-c/
I use several tools that probably aren't the "best" objectively but I've been using them forever and muscle memory and familiarity make working with them effortless, and moving to something "better" wouldn't buy me enough to justify the productivity loss fighting the tools while re-learning everything.
I would strongly say that it‚Äôs because of legacy code. My company does this and it‚Äôs really annoying and makes things really hard. But that‚Äôs the primary reason: legacy
It's the first item in his FAQ: https://www.youtube.com/watch?v=3BYKiOHdCNg&amp;t=55s
Fuck yeah, I'd rather pull a nail out than go through the new installation stuff
I‚Äôll pile on: If `strlen` returned a large value, `len` might overflow‚Äî`strlen` returns `size_t`, which is twice the size of an `int` on many 64-bit systems. And if `len` were very large, then allocating `result` would crash your stack, if you‚Äôre lucky. Although if `len` were `SIZE_MAX`, then `result` would be allocated as zero bytes because `(size_t)(SIZE_MAX+1) == 0`.
Read this: https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/ It's a huge mess, honestly, not much you can do about it. Standard C is hobbled by backwards compatibility and committees. C++ is a *little* better. Microsoft long ago started doing their own thing by basically standardizing on a 16-bit wchat_t and making **two** copies of every API - one for ASCII, one for Unicode. There's no easy general, out-of-the-box solution here. Sorry. 1. Do you care about being able to compile your C code on Windows? 2. Do you absolutely need to handle text as text in C code? *Really* ask yourself this. My approach is: 1. I do not worry about Windows compat. If I need to have cross-platform code, I just pick Go and never look back. This leaves me with just Unix derivatives, which are more consistent. 2. I try to not worry about text. I treat strings as bytes. If I have to worry about text - again, this means run-time manipulation of it - *not* just storing/displaying, which is covered easily - I use some linux-specific GNU lib to handle that for me.
&gt;&gt; Holds for any size integer
&gt; byte -&gt; defined to be 8 bits. Not true (in C); this is a common situation but there are some specialized chips where Standard C is supported and bytes have other sizes (e.g. 16, 32 or 64; or even 9 and 18 in old hardware).
**How are your reading comprehension skills?** I think you might've misread `_g_vprintf`, which is used by `g_vprintf`, which is in-turn relied upon by `g_printf`... hence `g_printf` relies upon UB... &gt; a library which is designed to allow a freestanding implementation to be used like a hosted one You're not trying to defend such a library, though, are you? You're trying to defend a library that wraps elements of an _existing_ hosted standard library. If somehow you formed the belief that this library is for this purpose, then I wonder if you checked out the build scripts... because I did, and it's not freestanding. **You sure do spend a lot of time on reddit for someone who fantasises about working at Intel.** Perhaps you're retired, eh? That'll explain the reading comprehension issues. &gt; ... that doesn't mean that freestanding implementations shouldn't allow hosting libraries to define symbols in that namespace for their own purposes if they pick names that aren't particularly likely to conflict. Where on Earth did you get the idea that `GLib` is for freestanding implementations? Do you think gtk+ used to define `FILE` and `malloc` back in the day? Your brain must be degrading... **Perhaps the reason you're withholding your true identity** isn't because you don't have a C compiler with your name on it, but because you don't want your employer to know that you're going senile as you waste so much time in their payroll? You're not a very honest man, are you? **I won't hold my breath in anticipation for your C compiler, since I'm well aware... senile men don't think so well.**
Thanks! TIL!
FWIW, I was just looking at the build scripts, and... \&gt; project('glib', 'c', 'cpp', version : '2.61.2', meson\_version : '&gt;= 0.48.0', default\_options : \[ 'buildtype=debugoptimized', 'warning\_level=1', \*\*'c\_std=gnu89'\*\* \]) I may be a retard, but at least I'm not a cretinous, braindead imbecile.
Was going to post this. Joe is a great guy, and if you join his mailing list he will definitely give you some time to pick his brain: https://talk.begriffs.com/howto/
P.S. u/FUZxxl go fuck yourself bbeh ;) it seems like nobody here actually knows C, so I'm happy to be outta here... and your power^H^H^H^H^Hbabysitting is meaningless to me.
UTF-8 is just one Unicode Transformation Format (hence UTF). There's also UTF-16, and half a dozen or so other basically unused formats as well. both UTF-8 and UTF-16 store "CodeUnits", in UTF-8 a code unit is a byte, in UTF-16 a code unit is 16 bits. both formats decode from/encode to UTF-32 aka UCS-4 (UTF-2 does not support surrogate pairs/multiple code units, so keep that in mind when you read older sources on Unicode). so basically, there's CodeUnits, CodePoints, and Graphemes. a grapheme is a character. So yeah it's a bit complicated, the best place to read more about it is Unicode's Standard Annexes, that's where I learned this stuff. This is probably the best one to start with: http://www.unicode.org/reports/tr29/
No, ICU is shit. also, java is the main version, C is derived.
&gt; So a "code unit" is a single value that uniquely identifies a "letter" in Unicode space. Inaccurate. Where the shit did you learn about Unicode, cuz you've got some re-learning to do.
No, absolutely do not read that article. it's ancient and he really doesn't understand what he's talking about.
Except it really isn't, Graphemes are characters. CodePoints are Unicode Scalar Values. CodeUnits are type appropriate chunks of CodePoints.
Which is why I changed my comment.
I agree, it is encrypted, so hard to use.
&gt;I disagree. I have used it in past &amp; it is very reliable &amp; solid. Grated it is hard build on Systems like Solaris-sparc or HP-UX but on popular platforms like Windows &amp; Linux, it works like a charm. I would suggest to write your own wrappers around the library API's to get the work done.
This is assuming that he has knowledge of GCC. Which he should be getting IMO.
&gt; The Standard allows implementations to treat any particular reserved symbol in any way they see fit, ... I want to coin a term... "doing an /u/flatfinger"... means one or more of: 1. writing something that makes absolutely no fucking sense and is completely erroneous; 2. using a reserved keyword for purposes other than the reserved keyword is defined; 3. having the reading comprehension skills of a typical 13 year old haxx0r C cod0r. &gt; ... which means it imposes no requirements upon the behavior of any particular symbol In other words, an implementation can apparently treat `strncpy` as though it's `memcpy`, and vice versa... Now I really want to see your compiler.
&gt; DO NOT use wchar_t for any "external" textual data. So how should I approach the problem of parsing text resources character by character which can be any kind of non-ASCII value? Btw thanks for the explanation.
Have you ever used the command line before?
None of this is specific to gcc.
Are you rolling your own mutex implementation, or using an existing library? I would expect all mutex libraries would have some kind of "try to lock" function, which would immediate return with some failure code indicating the lock is already taken.
Which mutex implementation do you use?
I am using pthread_mutex_lock. Would you recommend to use pthread_mutex_trylock?
What does its documentation say?
What do you mean by "a field with of 12"? You can control how many digits you want to have after the decimal, before the decimal it will take as many as it needs. Do you want the number to be padded with something like zeroes or spaces when it's not long enough to fill 12 bytes?
pthread_mutex
In the case you're using the POSIX-compliant implementation of semaphores (the ones you have with linux and other unixes, inherited from System V unix), you're not supposed to have that problem : This implementation creates a set of semaphores identified by a external key and a process-internal identifier. You define a semaphore request by creating an array of specific structures that each contain one P, V or ATT operation on one of the semaphores of the set. When you call the operation defined by the array, all operations defined in the array are executed in an atomic manner : either all of them are completed, or none of them. This design, which might not be specific to System V unix heirs (and I must admit I don't know anything else than POSIX), was implemented precisely so that noone would have your problem : with this design, you cannot have the first lock only : Its either both, or none.
pthread_mutex_trylock try to lock the mutex and return EBUSY if not available and continue. So I tried to use mutex_trylock and if I get the errno i print a message and use mutex_lock
Uh, not really sure if this is what you meant, its based on how I understood it. &gt;%10.2f So its going to have 10 whole number and .2 float
That sounds about correct. Note that there is no guarantee that locking the mutex actually blocks if it failed the first time.
Yep, sounds like exactly what you need. Take care when working with multiple locks at once. It is quite easy to end up in a situation where you deadlock: thread 1 has grabbed lock A and is waiting on lock B, thread B has grabbed lock B and is waiting on lock A. A good rule of thumb is that there should be some "global ordering" to your locks and that they're always taken according to that order.
That's the goal of the exercise to write the function that no deadlock could happen. I tried to use pthread_cond
Thanks.
Sorry mate, exam question - posted word for word.
Thank you, this looks about right.
If there's never a situation where a thread first grabs lock A then attempts to lock B, it isn't possible for a deadlock to occur. That is, the following threads could happily coexist: 1. grab A; release A 2. grab B; release B 3. grab A; grab B; release B; release A 4. grab A; grab B; release A; release B But as soon as you were to add the following: 5. grab B; grab A; ... you've introduced the chance of a deadlock.
i need to randomly decide the order to lock the resources. I had no deadlock but I tried to implement condition variables but that doesn't work.
Yeah, condition variables solve a completely different problem.
Maybe you could have a look at the code https://gist.github.com/mosermartin09/a276bb98fdc119e676b453abfedcf18c
I think the code with the mutexes is correct because the program is working.
There's a fine line between "code is correct" and "tests are insufficient". :-p
No, it's `%12.2f`. The first number is the total width, including the decimal point and digits after it.
The halting-problem-impossibility proof doesn't directly say anything about detecting runtime errors, but [Rice's theorem](https://en.wikipedia.org/wiki/Rice's_theorem) would.
Thank you, i am not familiar with a lot of terms, but i managed to understand what you said. And i corrected my code in a day. Thats the reason late reply. #include &lt;stdio.h&gt; #include &lt;string.h&gt; void parseString(char string[], char b,char *output) { int i; int len = strlen(string); for(i = 0; i &lt; len; i++) { if (string[i] != b) { *output = string[i]; } else { *output = ' '; } output++; } *output = '\0'; } void main(void) { char result[20]; char *ptr_for_string; ptr_for_string = result; parseString("A-B-C-D-E-F",'-',ptr_for_string); printf("%s",ptr_for_string); } Now i need to find a new challange to improve and understand more.
Please put \`\`\` above and below your code so it is properly formatted.
Open the file with the extension appended to the name?
A deadlock/race condition could be very unlikely (maybe 1/10000000... chance of occurring on a single person), but the one unfortunate scenario is the one you're trying to fix. Determining if it is correct by whether or not it works on your machine (even for a few hundred runs) is not the way to go.
done. also, do you know what my error is? I'm not sure tbh, i searched it up on google and stackoverflow and don't understand what the replies mean for the error
I'm pretty sure you can't do this in C &gt; int addNumbers(int a,int b = 11.50);
so should i change everything to float or just change the 11.50 to 11? how should i change my code?
Remove the = 11.50
Where? Which line? Also this is my alt account
 char buf[4096]; int fd; sprintf(buf, "%s.out", argv[1]); if((fd = open(buf, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666)) == -1) die_err("open"); Something like this?
Yes I know. But I don't know how I could be sure that it couldn't happen.
It's an exam question, we haven't gone over sprintf or any of the above. I think they are expecting strcat?
You used the double quote symbol ", but you need to use three backticks \`\`\`. The result will look like below if you do it correctly: int main(void) { printf("hello world \n"); return 0; }
For the adding function, change the arguments to floats instead of ints. Going from a float to an int drops everything behind the comma, i.e. 11.50 becomes 11. float addNumbers(float a,float b) { float c = a + b; return c; } Something like this
At error 1.
Perhaps I have the name confused, but I thought glib was the name of a set of standard-library functions that could be used to make gcc behave as a hosted implementation \*even on a non-Unix system\*. On a Unix system, glib's printf may be able to simply link to the underlying system's printf, but on Windows systems it would not be able to do so. &amp;#x200B; When using gcc on a non-Unix system, where would functions like \`malloc()\` typically be defined if not in glib? Am I confusing that with some other library? &amp;#x200B; It's possible to use gcc as a free-standing implementation. In fact, in the first place I saw gcc it was being used in essentially that way, although the C Standard hadn't yet been published. When used without a bundled library, gcc isn't a hosted implementation. Either it's a freestanding implementation or it isn't any kind of implementation.
&gt;I thought glib was the name of a set of standard-library functions that could be used to make gcc behave as a hosted implementation It's not... and you've never written a C compiler, have you? So why the fuck am I engaging you? &gt;On a Unix system, glib's printf may be able to simply link to the underlying system's printf GLib is not to be confused with glibc, the latter of which is the GNU variety of libc. GLib supplies `g_printf`, but not `printf`. There are **no requirements** behind `g_printf`, even when GLib is used to define it. &gt;... but on Windows systems it would not be able to do so. ... and what in the blue hell makes you think Windows is a freestanding implementation? Why are you bringing up some other bullshit that is **off-topic (spammy) in this subreddit that you're a member of**? Can't you face the facts that you were wrong to begin with? **Do you need to keep changing the topic to appeal to your ego?** &gt;When using gcc on a non-Unix system, where would functions like `malloc()` typically be defined if not in glib? Am I confusing that with some other library? Research! Do you have an IQ of below 65? &gt;It's possible to use gcc as a free-standing implementation. Sure, but GLibs build scripts don't do that... you have done your research, right? You aren't just stabbing in the dark, here, right? &gt;Either it's a freestanding implementation or it isn't any kind of implementation. According to gccs manual pages, "By default, it will act as the compiler for a hosted implementation, defining `__STDC_HOSTED__` as 1 and presuming that when the names of ISO C functions are used, they have the semantics defined in the standard." In order to disable the hosted features, you would need to use the `-ffreestanding` compiler flag, which you would know if you've ever done any kernel development (you've not done that, have you?!)... You really should try doing some research and learning about your compilers... **Less guessing and more reading, right retard?!**
I like the fact, he calculated the day which the code will break.
If parsing text, you have to know the encoding. Full stop. You can try to guess what encoding a sequence of bytes is, but it‚Äôs heuristics and you can get false positives. UTF-16 has a BOM that helps. Nowadays, you‚Äôre lucky. 99% of text you have to parse is UTF-8. Even if your internal textual encoding is UTF-16 (Windows), being a ‚Äúgood citizen‚Äù means you write out in UTF-8. So. Write out UTF-8. Read UTF-8. In memory, convert to/from whatever you want.
Rice's theorem is an application of the halting problem, cf. the proof section in the article you linked to.
I guess this can be safely shared on /r/programminghorror
What's the point of this loop? It this meant to be some kind of "clock updating thread", or something? I'm also surprised your compiler doesn't complained about the lack of ULLLLLL on that 50gazillion
How about a shipping calculator where you can enter the name, quantity, and value of an item QQQ to end or something then gives total base price, asks for tax rate for final price
I actually thought it was r/programminghorror until I stumbled across your comment
"hotfix". "*two months ago*"
&gt;"hotfix". "2 ~~months~~ years ago" FTFY. It's sadly what I usually see IRL.
Microsecond resulotion, scaled up from second-level timer data. That's, uhm... an interesting choice. I take it clock_gettime() with CLOCK_REALTIME_PRECISE wasn't available for some reason?
Consider writing a program that takes the 'A', 'B', and 'C' coefficients for the standard polynomial form and solves both the real and imaginary roots using the quadratic equation, and displays them. Shouldn't be too hard, and might even be useful.
It's custom RTOS, so it isn't available. We had to implement atomic timestamp precision using PPS from GPS.
I suspected something of the sort, after seeing PPS in the variable name. (I'm an NTP, and clock source, nerd.) I don't run into a lot of custom RTOS solutions anymore. Even vxWorks and such deployments are seemingly disappearing. Everyone wants a virtualized docker stack hosted in someone else's cloud. Sometimes you actually need the RT in an RTOS though, especially for things like audio/video stream processing with correct behaviors. (I have no clue what your use is, I've dealt with it in that context.) It sounds like an interesting project. Anything else you could say about it would be interesting to me, but I understand if you can't say any more.
The K&amp;R standard C did not include enums. They were added in ANSI C89. My guess re: why they're not really covered is that they're more of a convenience rather than a core component of the language.
A great one to try is to make an expression evaluator that takes an expression from `stdin` and parses / executes it with correct operator precedence. So if the program was named `calc` you could do: $ echo '5 + 10 * 5 / 2' | calc 30
Yeah, this is fanciest. You can try going full AST ("too complex" is too vague to tell if that is allowed) to allow functions and whatnot. If not, try the [shunting yard algorithm](https://en.wikipedia.org/wiki/Shunting-yard_algorithm) for simple expressions.
**Shunting-yard algorithm** In computer science, the shunting-yard algorithm is a method for parsing mathematical expressions specified in infix notation. It can produce either a postfix notation string, also known as Reverse Polish notation (RPN), or an abstract syntax tree (AST). The algorithm was invented by Edsger Dijkstra and named the "shunting yard" algorithm because its operation resembles that of a railroad shunting yard. Dijkstra first described the Shunting Yard Algorithm in the Mathematisch Centrum report MR 34/61. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
That 5000000000000000 needs an LL at the end though. Or did you take that into account when calculating the failure date
Yeah, I was talking about the newer version of the book. I suppose they're just a convenience, but I'm sure there's plenty of things that are just conviniences that the book when into more detail on. They could've just cleared everything up with a sentence and one or two lines of code.
Ok that looks horrible. By the way, any chance you're serbian? Vlashka Magic? :)
Thanks!
Bosnian :D
Yeah, that works too
Do not spam.
Give a man a fish, and you feed him for one day. Teach a man to use the debugger and he can find segfaults for a lifetime.
I am using vim and terminal. debug not possible.
Thanks for the advice. I cross-posted it there and it received more attention.
Why not `while(1)`
Of course it's possible. Load up your executable in gdb. Run it and feed it some input. It'll tell you what line is causing the segfault. Work back your logic and figure out why it's happening.
A union has all possible values share the same memory, including structs which can hold multiple values. SDL2 simply exploits this by having all members of the union have `type` as it's first field, all of which have the same address.
The loop executes at least once until "passed" gets recalculated. Most of the time, it will run only once. If some malfunction in a whole system happens and `ticksSinceLastPps` return some crazy number for a reason i can not share (something about hwi interrupts and is specific for our board), the loop will loop again and try to recalculate "passed". The loop will loop more then one time in extremely rare cases. Luckily, the compilers are smart this days. Adding ULL as soon as I go back to work.
Type gdb or lldb into your terminal and boom debugging.
I would veto that in a code review, unless our code already did stuff like that everywhere. A preference for which side of an asterisk the space is on doesn't justify a needless layer of mental indirection to me.
I agree. What you‚Äôve done however is syntactically correct and will work as intended. Typedefs are only useful when the underlying type is fully abstracted imo. Otherwise, it‚Äôs just another layer someone has to go through to find out the underlying type.
You can get negative periods of time when there is a clock adjustment (e.g. from NTP). That is why when you measure sleep times you typically use a monotonic clock instead of a real-time clock.
By default, pthread_cancel() does not instantly kill threads - it will only set a "should terminate" flag on the thread which is only checked if/when the thread itself calls one of the functions that are defined by POSIX to be cancellation points. You can find a list of these functions here: http://man7.org/linux/man-pages/man7/pthreads.7.html You can use pthread_setcanceltype() - http://man7.org/linux/man-pages/man3/pthread_setcanceltype.3.html - to change the behavior of pthread_cancel() so that it will terminate the thread "instantly" (PTHREAD_CANCEL_ASYNCHRONOUS) - but keep in mind the caveats mentioned in the man page regarding this mode of operation. Either way, I'm pretty sure you need to call pthread_join() on the threads to make sure they are fully stopped before trying to serialize your state.
We are not using anything you mentioned. It's custom RTOS, so things like monotonic and real-time clock are not available. Also we are not getting time with NTP. We had to implement atomic timestamp precision using PPS from GPS.
Run the program through a memory debugger. I'm pretty sure you're invoking undefined behavior in some places. // ... char *output = NULL; // ... while (scanf("%s", tempWord) == 1) { // not touching output... while (cursor != NULL) { if (strcmp(tempWord, cursor-&gt;word) == 0) { char *tempWordStore = calloc(NAME_LENGTH, sizeof(char)); outputMallocedSpace += (strlen(tempWord) + 1) + NUM_LENGTH; output = realloc(output, outputMallocedSpace); // output should now point to heap memory, but its contents are undefined if (strlen(output) == 0) // undefined behavior { // ... } // ...
Ah thanks that is definitely what I am looking for: &gt; One of the few circumstances in which asynchronous cancelability is useful is for cancellation of a thread that is in a pure compute-bound loop. That's me! &gt; Either way, I'm pretty sure you need to call pthread_join() on the threads to make sure they are fully stopped before trying to serialize your state. I only need to save the state at specific points, so I cannot wait for jobs to complete before saving the state. I am just going to trashcan the current jobs and upload a previously saved state, I lose at most 1 minute of compute work.
Sadly? Hotfix just means you are fixing something urgent not a temporary hack (hopefully)
Is that because `output` starts as null and does not have anything in it before it is realloc-ed? Does it need to have content before it can be realloc-ed? I don't know why else it would have undefined behaviour.
IEEE 1588 / white rabbit?
Why not a `do while`?
Please use "e" at LEAST! 5e10 for 7 with 50000000000
https://www.geeksforgeeks.org/difference-float-double-c-cpp/ &gt; **float** is a 32 bit IEEE 754 single precision Floating Point Number1 bit for the sign, (8 bits for the exponent, and 23* for the value), i.e. float has 7 decimal digits of precision. &gt; **double** is a 64 bit IEEE 754 double precision Floating Point Number (1 bit for the sign, 11 bits for the exponent, and 52* bits for the value), i.e. double has 15 decimal digits of precision.
Cool, I thought so. It's actually quite smart of them!
There's one responsible programmer *and* they know what's up
Sounds like what they want you to do is implement a [hash table](https://en.wikipedia.org/wiki/Hash_table).
**Hash table** In computing, a hash table (hash map) is a data structure that implements an associative array abstract data type, a structure that can map keys to values. A hash table uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found. Ideally, the hash function will assign each key to a unique bucket, but most hash table designs employ an imperfect hash function, which might cause hash collisions where the hash function generates the same index for more than one key. Such collisions must be accommodated in some way. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Always keep in mind that the limited precision of floating point representation may result in behaviors that may not necessarily be intuitive. For example, (a + b) + c may not equal a + (b + c), two results you may expect to be equal may not not evaluate as equal, subtracting nearly equal values causes enormous loss of precision, and so on.
Check the branch that adds to an existing hash chain.
VxWorks is alive an well for the things that really need it. They actually support X86, though how RT it is is highly debatable :)
It's undefined behavior because its contents are random garbage and you don't know what they are. `strlen` expects you to pass a null-terminated string, so it knows when to stop counting, but for all you know there might not be a single 0x00 byte in the next 1000, so you'd reach rather far out of bounds.
National Instruments is slowly phasing out VxWorks. I know a lot of people are happy about that.
Array indexes do in fact start at zero. Therefore the code above leads to UB (undefined behavior) since there's an out of bounds array access.
Yeah, that solution doesn't look valid to me. `array[i]` is equivalent to `*(array+i)`, which as you can see will be outside the area of memory assigned to array. I think they forgot to offset MIN and MAX, e.g. for(i = MIN - MIN; i &lt;= MAX - MIN; i++ ){ (obviously `MIN - MIN` is 0 but they might want to do it that way to show their intent clearly)
Printing a and b separately with .100 precision could be educational.
Also, the array ought to be one longer, if it's to hold 'a' and 'z'. I'd named them FIRST and LAST.
&gt;Also, the array ought to be one longer, if it's to hold 'a' and 'z'. I'd named them FIRST and LAST. Ah thanks for the tip. I just tried their solution out and it seems like it works. It's pretty interesting, if you use 97-122 as indexes the terminal tells me it's out of bounds, but I am still able to retrieve the value stored at that location, whereas when I try to use indices such as 0 a weird number is displayed.
A book or video library will help you understand basic concepts pretty well, IMHO.
Because you'd still need to write the break condition based on the value returned by Timer\_TicksPas....()
Yup, that's because accessing elements outside of its bounds is undefined behavior, which means anything can happen, including looking like it's working. It not guaranteed to work though, which is why you're getting warnings about it.
So I think this is missing a crucial piece of information. After all, if someone were to read this they might think "OK, `float` can store 7 decimal digits" &amp;mdash; hopefully they recognize that should actually be significant figures, not decimal digits &amp;mdash; "so what's the problem? I only need 5." One of the big problems here is that the decimal number `8.743` simply _does not_ binary floating-point representation, no matter what size type you use. The nearest `float` has an error of approximately 3√ó10^(-8); the nearest `double` has an error of approximately 3√ó10^(-16). In fact, most decimal numbers can't be represented exactly as a floating-point number. This shouldn't be too surprising. It's pretty much the same reason most fractions (e.g. one third) have no terminating decimal representation. Calculations involving floating point values need to be accompanied with error analysis. This isn't just so that errors can be minimised; it also puts results into context. For instance, in the OP's problem the result _is_ 18.243, to within 24-bit accuracy, which is the best they're going to get In this particular example, the result _is_ 18.243, since only 24 bits of the result are actually significant.
Oh, I'm well aware. I have far more experience with vxWorks than I'd care for. I was trying to say that I saw fewer deployments of it these days, not that it had become defunct. (Also, whoever thought 'exit' should mean "exit the running copy of the OS and reboot it", instead of "logout" really should be slapped.)
Make a ToDo list. Everyone's doing it. It's all the rage!
Oh boy. I assume you found this solution on the [CLC Wiki](https://clc-wiki.net/wiki/K%26R2_solutions:Chapter_1:Exercise_14)? I went through that page and the only decent solution there is the [fourth from the top](https://clc-wiki.net/wiki/K%26R2_solutions:Chapter_1:Exercise_14#Solution_by_scopych), although I would have used character literals instead of magic numbers (which, in additional to clarity, would have the advantage of working with any character set with a contiguous alphabet, not just ASCII derivatives).
It can mean both
As someone who is currently attempting to implement ntp w/ GPS on a RTOS (QNX) that only kinda supports it.....T.T Hacked ntp source code Custom resource manager for nmea Hacked PPSAPI Multiple deployment cpu architectures Multiple deployment hardware configurations T.T
I think I have PTSD from reading this comment. (Kidding.) Kludgy hacked up NTP and PPS code is hard enough to do right on a single CPU and hardware platform, where you can test the living crap out of the hardware to get some idea how the undisciplined clock on the machine behaves, and have the ability to make some sane presumptions about which ways to bias the clock discipline. Trying to do it across diverse CPU and hardware platforms, with presumably different oscillators for the core clock... ugh. That's before you introduce GPS propagation delay variability based on cloud cover, etc. (Of course, it matters how accurate you need the time to be, but if you spent this much focus on the NTP part, probably a good bit, I'd figure.) Are you #ifdef'ing the crap out of the code base to tweak for different platforms, or are you trying to build a single code image that works on the diverse architectures and hardware in a limited RTOS environment? If the latter, all I can say is "ballsy".
I only need millisecond accuracy thankfully and the general treatment of the cpu clocks is "don't trust them at all" (there is no battery so we're in the 70's after every reboot). There aren't as many ifdefs as you might expect, but it was an ordeal figuring out their placement. This was/is my first assignment at my first job out of college :D I've had a complete "time" crash course the past three weeks.
Have you read all the lovely Alice in Wonderland docs in detail?
Regardless of the actual answer (yes), my first response is "what docs?"
Lol. All the stuff on [Dave Mills' site](https://www.eecis.udel.edu/~mills/ntp.html) (he invented NTP). Like [this article about leap seconds](https://www.eecis.udel.edu/~mills/leap.html). The info on that site is better documentation about the actual design and intent of how (at least the canonical "ntp" implementation) ntp is meant to work than pretty much anything else I've encountered. I'd never even heard of the "popcorn filter" before I was on his site. Trying to reverse engineer all the *intended* operation from the code itself is infeasible at best.
Ohhhh. I was wondering why the U Delaware site was the BEST resource. (Even though it still feels lacking)
I used to work with a guy who was one of Dave's university grad students when Dave was inventing NTP. That guy knew stuff about how it worked that I don't think is written down anywhere. I used to talk to him kind of before I did any important design work that I wasn't 100% sure about related to NTP. I wish I had recorded him speaking, so I could have captured it and put it into written record.
In the first one you allocate the object on the heap and in the second you allocate the object in a stack. Heap allocated objects can be used in other contexts - they stay allocated until you free() them. This also means if you keep creating them and not freeing them you get memory leaks - memory usage will keep increasing until it gets full. Stack allocated objects get destroyed when their scope ends.
Most cases I've seen, the hotfix was a really bad hack. But it worked, so they usually keep it around a long time.
"such" also being bad.
In C99 you can also Car c = { 5 }; or Car c = { .doors = 5 }; see [struct and union initialization](https://en.cppreference.com/w/c/language/struct_initialization)
&gt;I'm using a version of VC++ from 1998 ........*why*? https://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B : &gt;Visual C++ 6.0 (commonly known as VC6), which included MFC 6.0, was released in 1998.[21][22] The release was somewhat controversial since it did not include an expected update to MFC. Visual C++ 6.0 is still quite popular and often used to maintain legacy projects. There are, however, issues with this version under Windows XP, especially under the debugging mode (for example, the values of static variables do not display). The debugging issues can be solved with a patch called the "Visual C++ 6.0 Processor Pack".[23] Version number: 12.00.8804 &gt;Although the product originated as an IDE for the C programming language, for many years the compiler's support for that language conformed only to the original edition of the C standard, dating from 1989, but not the C99 revision of the standard. There had been no plans to support C99 even in 2011, more than a decade after its publication So sounds like C89, maybe with some extensions. You might be able to dig up more specific documentation about it on Microsoft's site somewhere.
**Microsoft Visual C++** Microsoft Visual C++ (often abbreviated to MSVC) is an integrated development environment (IDE) product from Microsoft for the C, C++, and C++/CLI programming languages. MSVC is proprietary software; it was originally a standalone product but later became a part of Visual Studio and made available in both trialware and freeware forms. It features tools for developing and debugging C++ code, especially code written for the Windows API, DirectX and .NET. Many applications require redistributable Visual C++ runtime library packages to function correctly. These packages are often installed independently of applications, allowing multiple applications to make use of the package while only having to install it once. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
My previous job had large industrial machines that were still used heavily by our clients for over 20 years which were still technically supported if software bugs came up. Which means having to recompile for original hardware. I can totally see why they would have to go back to the stone ages if they had a similar story.
Isn't that what I have? That is what I was going for but can't get the memory allocated properly.
Microsoft (and DOS/Windows in general) compilers were rarely standards compliant. It's Visual Studio 6, which was backwards compatible with microsoft C 6.0 (1990). The closest thing to a standard it followed was ANSI C, with a bunch of compatibility breaking extensions and #pragmas. Portability didn't matter - no one ran programs written in visual studio anywhere besides windows. Documentation here: [https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-6.0/aa261790(v=vs.60)](https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-6.0/aa261790(v=vs.60))
What is the difference to `wget --tries=inf` (and `curl --retry 1000000`, which at least doesn't infinite retries)? (Except that I think wget tries to redownload when the server doesn't support continueing downloads and http-dl not supporting HTTPS) I also briefly looked into the code. // strlen has a problem that tabs are not counted right Sure, because tabs are actually just one character, the terminal just expands it. BTW you can use something like `%8s` to print a string with e certain minimum width. Also, what are global variables `rr`, `r` and `f` for?
&gt; You might be able to dig up more specific documentation about it on Microsoft's site somewhere. they have missing docs for C# 3/4 stuff... i wish OP tons of luck and hope his google-fu is incredibly strong lol
Visual c++ 6 was the last release with support for 16 bit real mode DOS. It's the go to for maintaining code bases with the most modern tools possible (Microsoft C 7 isn't much better than qbasic). There are quite a few embedded applications where DOS or the 95/98 HAL are expected to run for another decade or two. Stuff like large HVAC systems, Industrial Controllers, church bell towers....
Oh, you sure do! I've missed your link to source code and assumed that you have a loooong linked list storing all the data. So, my advice for you then is: 1. The problem states that the 'number' part of a record is 8 digits, meaning an int would suffice - no need for a complicated char-array-storing-a-number. It would also mean that you don't need to convert the result of hashValue()! Just save the value itself! 2. Your input reading code seems waaay overcomplicated for what it's doing. All you need is a simple scanf("%s %d", ...); it recognised the space, and does the string to integer convertation for you. 3. You seem to have a **critical** error in collision handling! If you indeed find a collision - you need to *append* the new node to the end of the list, not make it the second item. In case of a collision you overwrite the second item in the list. But what if there already are two items (or more)? You need to make a use of a cycle here. 4. Not that important, but I would probably place the node creation code in a function accepting two fields as a parameter and returning the pointer to the node. Something like this: node *createNode(char *name, int number) { node *new_node = malloc(sizeof(node)); new_node-&gt;number = number; strcpy(new_node-&gt;name, name); return(new_node); } Good luck with the problems and good on you for tackling them in the first place!
Oh, you sure do! I've missed your link to source code and assumed that you have a loooong linked list storing all the data. So, my advice for you then is: 1. The problem states that the 'number' part of a record is 8 digits, meaning an int would suffice - no need for a complicated char-array-storing-a-number. It would also mean that you don't need to convert the result of hashValue()! Just save the value itself! 2. Your input reading code seems waaay overcomplicated for what it's doing. All you need is a simple scanf("%s %d", ...); it recognised the space, and does the string to integer convertation for you. 3. You seem to have a **critical** error in collision handling! If you indeed find a collision - you need to *append* the new node to the end of the list, not make it the second item. In case of a collision you overwrite the second item in the list. But what if there already are two items (or more)? You need to make a use of a cycle here. 4. Not that important, but I would probably place the node creation code in a function accepting two fields as a parameter and returning the pointer to the node. Something like this: node *createNode(char *name, int number) { node *new_node = malloc(sizeof(node)); new_node-&gt;number = number; strcpy(new_node-&gt;name, name); return(new_node); } Good luck with the problems and good on you for tackling them in the first place!
&gt; Visual c++ 6 was the last release with any support for legacy 16 bit real mode DOS. *shudders* It was bad enough trying to finagle autoexec.bat and command.com settings to get games to run and recognize my sound card. Does not seem like a fun platform to have to support indefinitely.
If you‚Äôre asking questions like this the night before the exam, you‚Äôre already a bit screwed.
To give context; if you don't allocate and assign to members of a pointer as is a) the pointer is null, you try to overwrite at address 0x00 which is "forbidden" and you get a segmentation fault b) the pointer has an arbitrary value, inherited from a previous function call/program, you destroy some part of your program and it shows unwanted behavior down the road and crashes.
Does it have to be that compiler? Because there are several [free C/C++ compilers](https://www.thefreecountry.com/compilers/cpp.shtml) that can compile to Win 3.1 compatible 16 bit programs. I've tried quite a few links, and the homepages it points to are all still online.
To give more context, it really is only hopefully that it crashes. I'd generally say the worst case outcome is that you silently corrupt data and then store it back to an output file or database, and that data gets used to generate a report that someone uses to make important business decisions based upon.
In the second one you allocate the object on the stack if the declaration is in a function. If it's outside of any functions, it's global, it's persistent and not on the stack.
wget fails at the socket level and shuts down under certain network conditions. strlen is a function in many libraries, I am aware of unicode you can read the code and figure out the variables, it's MIT and I haven't been paid a dime.
&gt; In C++ you should not allocate objects with malloc, you should use ‚Äônew‚Äô instead. Why? `new` just calls `malloc()` internally anyway.
Nice list! I use Pelles for my person projects.
Actual URL to the thing: https://www.humblebundle.com/books/programming-packt-books Why make folks jump through all those hoops just to get to the thing you're talking about? Is it because this is just more low rent, humble bundle "partner" SPAM, ubiquitous around these parts? Yes; this is indeed more low rent, humble bundle "partner" SPAM. Please report this user and carry on.
I see a Humble affiliate link in there. Also, they're not the books I would recommend. Where's KNR? Headfirst C? C in a Nutshell? I could honestly think of much better books and some lengthy reviews.
I'd say you'd almost never use C in a program that generates data, that has a big impact on business decisions. Currently, C is used in programs processing high volume/high velocity data. Packet processing, sensor data analysis/fusion, ... or other applications that procress data in high frequency, each data point has a very small importance alone, but is useful together. In these applications, if an error occurs, you see the problem right away? 98% of all packets are DNS? That can't be right. Gravity sensor shows 15 m/s¬≤? When did we move to Mercury?
OP could not care less about what's actually on offer here. They want to just scam as many people as possible to rake in that sweet, sweet "partner" bounty.
Setting aside that the majority of mainstream OSs are written predominantly in C, data corruption in an HFT implementation could be very expensive. Corrupting data in large ways is often fairly visible, fairly quickly, but I have seen cases where corner cases corrupted data that made the resulting number 7% off, and readily accepted. And costly.
Real-mode DOS is much more straightforward than segmented protected mode.
Could you use bash to set an env var and `test` that at the end?
It'd be a lot of work to switch. A lot more work than keeping a windows XP VM image around. &amp;#x200B; It's not just a compiler. It's a standards non compliant compiler, so there is no garauntee other compilers can compile it correctly or without error. It's also not just a compiler. It's a platform development kit. It has it's own make system, it's own source management system. People may have written unit tests targeting the toolchain. It's intermediary object files aren't very well documented and other compilers/linkers might have trouble linking them. Which becomes important if you have any .asm files.
The platform is less DOS and more the original IBM PC. DOS was just slightly more convenient than calling BIOS routines, which were just slightly more convenient than writing your own routines to drive the hardware.
Also the same spammer: * https://old.reddit.com/user/KristineDevore * https://old.reddit.com/user/PhyllisErrico
&gt; wget fails at the socket level and shuts down under certain network conditions. What kind of conditions? &gt; strlen is a function in many libraries, I am aware of unicode I never talked about unicode or libraries, I just told you that it's normal strlen counts tab as one character (since the terminal/display program expands it and a tab is otherwise just one "character") and you can use `%8s`-like printf-syntax to produce a similar "thing". &gt; you can read the code and figure out the variables, it's MIT and I haven't been paid a dime. Well, that makes maintaining it very annoying. You rather read the code more than writing it. If you come back in like months, you'll have to figure out first what those variables may do. Keep variables local, and name them appropiatly and it makes the code easier to read.
Microsoft only started adding C99 support in 2015.
That link refuses to work. Safari blocks it for security reasons, then the damn cisco dns blocks it too. got a more direct link?
Why not just use `gmake --keep-going`?
This might be of interest to you: http://mathworld.wolfram.com/SpherePointPicking.html
rand() does not generate very "random" variables outside of a simple scramble. If you want good random vars you'll need to either use a cryptographically strong generator, or PCG. http://www.pcg-random.org/
I don't need extreme randomness though, the system will chaotically evolve and after a few iterations will already be completely unpredictable. I am just trying to get the points distributed somewhat evenly across the sphere
Read PCG's website, it'll get you started.
`main.cpp.cpp` Ouch
I didn't get a chance to write code for DOS in any real manner, but it's basically the closest you can get to a real-time system without too much fuss. Single process, no pre-emption to worry about, full control of the hardware, no messy permissions - you just told the computer what to do and it did it. What is the "modern" equivalent of that? Single-purpose computer? I basically want a docker container but in hardware.
Marsaglia's method worked wonders! Computation time isn't a problem here so I went with something readable.
Hmm, that's a possibility. I'd prefer to manage this setting in the [GNU]Makefile itself if that can be done. And set this at a specific task level, as opposed to all tasks. Uh, I guess I could move all my linter tasks into a separate Makefile, and instead of using `include` to import the tasks, create a second shell call from the main Makefile to `gmake -f lint.gnumakefile --keep-going`, if I really had to.
the easiest and often fastest approach is to create random vectors on a unit-cube and then check that x^2 + y^2 + z^2 &lt;= 1. If not, reject the point and generate another one. (scale appropriately if you don't want a unit sphere) This is very robust (since the approach is so obvious) and even though it seems inefficient (because you might have to re-roll), generating another random triplet with a fast rng (like mersenne) is actually way faster than computing transcendental functions, square roots etc like you have to with marsaglia. One caveat though is that this becomes much less efficient for higher dimensions, as the volume of an n-cube grows much to be much bigger in high-dimensional space than the volume of a corresponding n-ball. The ratio of rejected points that need to be re-rolled (normally about 47.64% rejection rate) hence becomes much larger. You can read more about that [here](https://math.stackexchange.com/questions/894378/volume-of-a-cube-and-a-ball-in-n-dimensions) if you're interested.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Please post projects as link posts instead of self posts if possible.
All things considered, I wouldn‚Äôt be surprised if a lot of embedded devs today are running with `‚Äîstd=c89`, given the amount of Java 1.3 I keep hearing about.
`new` also creates an object. C++ has a different object model to C. That is offtopic for this sub anyway.
But it is my understanding that Cpp classes are just structs with function pointers behind the scenes.
Nah it means an "urgent fix" it is implementation dependant if it is also an "ugly hack that should be fixed better in the future"
I really wish the Visual Studio used a more recent (i.e made in the same century) version of C
Perhaps not what you ask for, but sounds like embedded/bare metal OS:s?
Use a variable: lint: EC=0; echo "task1"; false || EC=1; echo "task2"; false || EC=2; exit $$EC That runs both failing tasks, exiting with the exit code of the last failing one: $ make lint EC=0; echo "task1"; false || EC=1; echo "task2"; false || EC=2; exit $EC task1 task2 make: *** [Makefile:2: lint] Error 2 Replace "false" with your actual command, obviously, and split the command line using backslashes (it does need to be a single line, so it runs in a single shell instance).
You want "evenly across the sphere" then you want "randomness".
Just make the vector a unit vector and carry on.
You can't use typedef inside a struct definition at all.
You have to reject points beyond the allowed radius, otherwise the output will be biased.
I think you're confusing your goal with namespacing, you can simply declare the interior struct member without typedef
Maybe you want a union?
You probably want something like this: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct garage_s { int bays; } Garage; typedef struct house_s { int windows; Garage *garage; } House; Garage *init_garage(int bays) { Garage *g = malloc(sizeof(Garage)); g-&gt;bays = bays; return g; } House *init_house(Garage *g, int windows) { House *h = malloc(sizeof(House)); h-&gt;windows = windows; h-&gt;garage = g; return h; } int main() { /* Create a three car garage */ Garage *g = init_garage(3); /* Create a house with sixteen windows */ House *h = init_house(g, 16); printf("My house has a %d bay garage and %d windows!\n", h-&gt;garage-&gt;bays, h-&gt;windows); }
There's a lot more to it since there are features like constructors and inheritance in C++
What specifically in the article do you think is wrong? The only thing that stands out to me is that the author mentions 6-byte codepoints in UTF-8 which aren't really a thing anymore.
KISS principles !
If you have the online help for Visual C++ 6.0 it'll tell you. It's the last of the non .net compilers, with the last processor patch #6 applied from the looks of it. Unless you are trying to target crazy old stuff I'd use something newer. Visual Studio 2003 is my favorite old version at the moment. I picked up a retail copy of Enterprise Architect for $50 which includes all the server stuff as well. Granted it's stuff like SQL 2000 &amp; Windows Server 2003, but it's at least .net 1.1 ..... and a world better than Visual C++ 2002 (AVOID!). For 64bit stuff get at least 2005. Although newer is almost always better. almost.
just curious if there‚Äôs a memory leak in your code?
Yes, the house and garage are never `free`d. If you wanted to actually use this, you would want to also create `destroy_house` and `destroy_garage` functions to clean them up when you're done with them.
PellesC IDE is capable of running on a thumb drive. It‚Äôs pretty basic for sure.
This may be a GNUmake feature, but putting a minus sign before the commands causes it to ignore errors: lint: -splint ...
If you want to learn C, Windows is probably not the best OS to start with IMHO. A Unix system will make far more sense. I'd recommend "The UNIX Programming Environment" and "The C Programming Language" in that order to get started with Unix as your "IDE". You use `make` and `gcc` to do compilation, `vim` or `emacs` as your editor, and `gdb` for your debugger. The Unix operating system is really the absolute best "IDE" for C programming.
Dev C++ is a great IDE. Very simple and has its own compiler. The installation is Next Nex Finish Choose your theme and you can start programming. However I wouldn‚Äôt recommend windows for starters. Unix systems such as macOS, or any Linux distro are a good starter. You can use nano, vim or emac as editors and gcc for compilation. I personally use Atom as my editor with a bunch of plugins and compile with cc and debug with gdb.
Don't rely too much on a heavy IDE. I recommend just using vscode.
You can also use online compilers https://www.onlinegdb.com/ I will usually install visual studio c++ community edition but that might be too heavy for your needs. Haven't tried this one and I'm away from my computer: Maybe try visual studio code and see if you load a cpp file, maybe it will try to setup your c compiler.
This is the problem that I have with most CS curriculums... instead of throwing students one thing at a time and letting them master it they throw 80 new pieces of tech at them and let them sink or swim.
I assume you are on Windows (since you mention .exes) so you can actually install Visual Studio Community edition - https://visualstudio.microsoft.com/vs/community/ If you want something that is cross-platform I highly recommend QtCreator - https://www.qt.io/download-qt-installer Both of those come with everything you need for C/C++.
Not so long ago I also have problem with finding some good IDE for C. Then I found Geany: [https://www.geany.org/](https://www.geany.org/) Small and fast. You can read more about it in About section on Geany website.
OP, are you on Windows 10? Look at Windows Subsystem Linux, it‚Äôs a good little dev box. Previously, Cygwin was my go to for Windows work. Both can install gcc or clang (I prefer the latter, but it won‚Äôt matter when ya beginning), and it‚Äôs a good introduction to Unix platforms.
Not sure I understand your comment. Learning Unix is the surest way to C enlightenment. I'm not recommending he learn all the pieces at the same time; I'm recommending he read a short sequence of two books written by the masters of the language which together outline in order all the pieces he will need to have a full understanding.
This is the one true answer to all C-related environment questions. Every other language is one way or another have portability. C is not like them. It might have some portable functions that's been around since 80s but everything came out since then is implemented differently in every OS that it lost its portability. Unix (and Linux as it's spiritual successor) is the true environment C should be developed and run on.
I‚Äôd suggest using a Text Editor like VSCode or Atom. I personally use VSCode but Atom is just as good
I like CLion. I am really hooked to all jetbrains IDEs. Just easy to use and intuitive
I would honestly recommend Eclipse for c/c++. I was always sceptical of it as it is made fun of quite often but I have tried many other IDEs and none of them came anywhere close to Eclipse. I never had a problem with crashes but I use Linux Mint not Windows. All other IDEs (clion, kdevelop, vscode, codeblocks) I tried lacked something. I have more heavy duty needs hence I use Eclipse. For something more lightweight I would recommend vscode.
Oh that was a mini rant on teaching technique ignore me.
CLion is great, but it's sort of like recommending a space shuttle when he asked for a bicycle lol. For a professional, I'd agree this is probably the best way to go today, but for someone just learning it's not only overkill, it will obscure the details he needs to be aware of to understand what he's doing.
Use this www.sandbox.cs50.io Its online. Has both clang and gcc. Everything is setup and you can just start coding(just create a new .c file). If you like it you can make a proper account(for free) and start using www.cs50.io Both these websites are made by Harvard for their students in the Introduction to Computer Science course.
It's worth pointing out that you can definitely do anything you can do in Linux in Windows using C. But you're right in that the stdlib was shaped around Unix (POSIX, specifically) so it's the most orthogonal to writing C It was originally designed to code the original Unix kernel and associated software, after all.
&gt; i also know in the end of the day, the thing that matters its how fast i can do something with as few lines of code possible That's not really the case. Lines of code is an awful metric for rating code quality, and C++ is far from a simple and concise language.
109¬∞ called, it wants its recommendations back.
More lines of code means more time spending, that means the company which a programmer work needs to pay more money for the same thing. Am not saying that C++ is a bad language, i absolutely love it! I know that C++ can do things that other languages can't like excellent resource management (which is great for game engines). I say " its kinda bad choice for first language" because most people say its hard compare to the other languages. And yeah, C++ is way to complicated and this is one of the reasons i like it. If you have any tips just let me know :)
VS Code + your compiler of choice.
MS Visual Studio. Free and works great for me. I switched from Codeblocks, didn't really like it.
&gt; More lines of code means more time spending, that means the company which a programmer work needs to pay more money for the same thing. This just isn't true. Developers typically spend about 90% of the time thinking and researching and 10% writing code. It hardly matters if you manage to write a function in 5 lines or 15. What's important is that it be reasonably performant and maintainable, and sometimes more verbose code is easier to understand. That's the important thing.
My "IDE" for C in linux is a screen session, horizontally split, with the bottom 1/5 of the screen running a terminal and the top 4/5 running vi. The bottom terminal window handles building (make), debugging (gdb) and running the program.
I you want a "lightweight ide" qt creator is the best thing you can choose. It has all the features you'd expect from an ide but no bloated menus etc. Can highly recommend it.
In addition to the other considerations you might get a more uniform distribution if you convert `rand()` to double and scale by `M_PI/RAND_MAX`
How would that be useful? Are you suggesting that a house has a garage or windows but not both?
 you can read the code and figure out the variables, it's MIT and I haven't been paid a dime. Wow. Imagine posting a project, someone comments with a small question and you go: ‚Äúfuck you I didnt get paid so figure it out on your own‚Äù.
I think most beginners struggle a lot with typedef. Typedef is not necessary. You could live your whole live without knowing about typedef. What you want to write can be defined as this: struct host { int windows; struct garage { int bays; }; }; And then you use the whole name to use your house: struct house my_house; my_house.windows = 4; my_house.garage.bays = 2;
it's not good to saddle a beginner with learning linux, and a complex editor that requires configuration when he doesn't even know what a terminal is.
for learning c on a windows environment, i suggest you take a look at the pelles C IDE. [https://www.pellesc.de/](https://www.pellesc.de/) it's not the latest version of C, but it should do for everything that matters. &amp;#x200B; tcc is a compiler, not an IDE, while it is great, it does require some preexisting knowledge of how C works to get it working properly with sample source code you'll encounter in your learning travels.
learning unix is completely irrelevant to learning c.
Window is just a 0-length garage with glass for doors
I like how you nested parentheses in your question. Maybe you should learn lisp instead? ;)
Ive been using anjuta for ages, not tempted by anything else, has good recognition of autotools, and reasonably customisable, it can do mark on whitespace if you search hard enough. [http://anjuta.org/](http://anjuta.org/)
If you did that, you'd end up with a very uneven distribution that's highly biased towards the boundary of the ball
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
&gt; The Tiny C Compiler looks like exactly what I need, but the terminal windows its .exes generate dissapear too fast do a scanf before quitting your program, that way the console will keep open
that's not even close to true...
Horrible code: using global state to pass variables, long sequences of strcat, using sprintf rather than snprintf, a function that has more than 400 loc... we can only imagine how many vulns this code has. Using ASCII decimal values in conditions rather than char literals (10 instead of '\n', 13 instead '\r'): no it doesn't make you look like a haxxor, it just looks dumb.
Learning it and using it well is a tiny valuable skill, tho.
I was exaggerating a bit, it definitely has uses. But most of the time you don't really need them at all. Maybe you use size_t, which is defined using a typedef, but for your custom structures you don't really need them. What for, typing less? Nah. It's not worth the hassle.
VSCode
Microsoft still offers Visual Studio Express. If you want to keep the editor and build environment separate, there is Mingw - a toolchain that runs on Windows. I use an old copy of CodeWright and have no interest in IDEs.
It should be fine. Some of the parts of the C library ecosystem that expose Unix-specific constructs are missing but Mingw works.
&gt; the easiest and often fastest approach is to create random vectors on a unit-cube and then check that x2 + y2 + z2 &lt;= 1. If not, reject the point and generate another one. Or just generate x and y then solve for z....
Visual studio code in addition with the CMake tool addon
Given that many compilers for DOS and Windows preceded the publication of the C Standard, and can do things for which the Standard makes no provision, it should hardly be surprising that they're not fully conforming. Compiler writers at the time recognized that it was more important to let the programmer do what needed to be done than to obey the standard in cases that would conflict with that or worse, use the Standard as an excuse not to support "popular extensions" that would facilitate what needs to be done.
Visual Studio Express is easy to set up. You have everything in one place. Sure, it is a complex IDE in many ways but you don't have to enter all those areas at once. It's really easy to get a project set up via wizards, such that you pretty much start with an editor window with a blank main() function. I don't know how much easier it could get. You can learn how to use the debugger by and by; it really isn't difficult when you just use regular breakpoints and the watch window. Good luck.
... But a house has multiple walls which can be garages or Windows
you can deny it all you want. but it is objectively irrelevant to learning c.
Hmm, I don't think that'd work (I also suspect it'd not be very fast to do that, but that's another matter) -- you'd end up with a lot of (x, y) tuples for which there exists no z such that x^2 + y^2 + z^2 &lt;= r^2. Additionally, most of the time when the constraint can be satisfied, it can be satisfied with an infinite number of solutions (consider e.g. (.5, .5), for which any z \in [0, 1] would be a valid solution), so once you've figured out the space of solutions, you'd have to at least generate another random number in the range that you want to cover.
I've not used it on Windows, but VSCode is quite good and lightweight, but I don't think it's bundled with a compiler. [Visual Studio community] (https://visualstudio.microsoft.com/vs/community/) is a good free option too. That said, there is only one correct answer to this question: Vim. Jokes aside, learning Vim is a really smart thing to do if you ever expect to work in and around a Linux environment. (P.S. Don't let the Emacs weirdos tempt you. Before you know it you'll be using tabs for indentation.)
arr_pointer is one pointer so its size is 8. arr_dynamic is an array of 10 pointers so its size is 80.
Sizeof is evaluated at compile time (it's not a function but an operator) and returns the size of the variable. In the first case, you are asking the size of arr_pointer, that is a pointer to an int (it doesn't matter the fact that you assign malloc to it, that is evaluated at runtime), and thus sizeof returns 8, the size of a pointer in a 64bit architecture. In the second case, you are asking the size of arr_dynamic, that is declared as an array of pointer to int (and not an arry to an int, as you probably wanted, you must use int and not int* for this). Each element of the array is a pointer, that is 8 bytes, and thus the size of the array is 80. Note that it's not really true that an array is the same as a pointer. Decliring an array like: int arry[10]; puts the array on the stack of the function, and thus its size is known at compile time, and sizeof returns the correct result. The type of the arr variable is array of 10 ints. Declaring it like int *arr = malloc(10 * sizeof(int)) declares a pointer to an int and assigns to it some memory that mallocs allocates in the heap. The type of the arr variable is pointer to int. Even if you can use array and pointers in the same way it doesn't mean it's the same thing.
I suppose if you wanted him to _remain_ a beginner, what you say is true.
Your code quality needs some work j suspect the line is within your add function as I spotted a dangerous edge case that may cause the segfault try using gdb to add a breakpoint and walkthrough your code.
```int``` is ambiguous and can be many different sizes. 3 popular sizes are 2, 4, or 8 bytes. Compilers rarely follow the standard so never rely on the standard to be enforced. Even using special compiler arguments to enforce a specific standard is no guarantee the standard will be properly enforced, humans and compilers have made countless mistakes in the past and they will continue to do so into the future. If you want to know the size of an operator you need to either call sizeof() on it (and modify your code as necessary) or use stdint.h. I use stdint.h in every single project of mine and none of them ever use ```int``` unless it's a return variable from a system function or API that is not my own. When working directly with hardware, which is a typical usage case with C, using ```int``` is poisonous. Include ```stdint.h``` and change ```int``` to the proper variable ```int32_t```.
Fixed segmentation fault issue but the program doesn't work as expected. Any ideas?
so in perspective of my goal which is to print out the sizeof the array (10 elements, so it prints out 10) int * array = malloc(10 * sizeof(int)); printf("%ld", sizeof(array)); // Prints 8 because a pointer size is 8 on a 64 bit machine, but how do I print the size of the array (10)?
The best way to do it is to get the size of the array (in your case 80) and divide it by the size of the first element. Something like int n = sizeof(array) / sizeof(array[0]);
If you want to just get the number of elements in your array, you just simply have to divide its sizeof by the size of a single element, like this `sizeof(arr) / sizeof(arr[0])`. But if I understand correctly, you're not creating an array with the code you just wrote in your comment, but simply allocating memory.
In C, the pointer itself does not contain information about the total size of the data to which it points. The pointer type dictates the type (and thus size) of the elements to which it points, but not the number of elements. If you need to track the overall size or number of elements that you allocate, you'll need to put that in a variable or a #define and use that whenever you need to determine the number of elements or overall size. For example: ``` size_t const num_elements = 10; int *array = malloc(num_elements * sizeof(int)); printf("%ld", num_elements * sizeof(int)); ``` You can also avoid repeating `int` like so (which can help avoid errors if you change the type of `array`): ``` size_t const num_elements = 10; int *array = malloc(num_elements * sizeof(*array)); printf("%ld", num_elements * sizeof(*array)); ```
If you want the easiest thing to setup and use I suggest MinGWStudio which you can run right off a USB, it's small, fast, light, stable, etc... and was my go-to for a long time. The only catch is that it doesn't give you access to the compiler commandline stuff, so you're stuck with the included 32-bit version of MinGW/GCC. I had to switch to CodeBlocks so that I could start producing 64-bit builds of a piece of software I'm developing. If you're just beginning though then the 32-bit version will be just fine for you for a long time I imagine. http://vaultec.mbnet.fi/mingwstudio.php Use the IDE + MinGW download link and happy coding!
You‚Äôre on Windows and primarily comfortable with Windows? Just get MSVC community edition, install the C/C++ componenrs and you‚Äôre good to go. Really solid modern IDE. QTCreator would be my second choice. IMO there‚Äôs absolutely no need to also learn vim/make/etc when you‚Äôre trying to focus on the important stuff.
Many aspects of the behavior of `enum` types were processed inconsistently before the Standard was written, in ways that many existing programs relied upon. For example, many implementations where `int` was 16 bits would allow 32-bit enumeration values, but the Standard imposes a constraint that enumeration values must fit within the range of `int` or `unsigned int`. It would have been hard for them to say much about enumerations without being seen as either endorsing such constraints or criticizing the Standard. BTW, I suspect K&amp;R faced an even worse quandary regarding what has become the most contentious part of the Standard, which is probably why they ignored it altogether. They probably figured that while the Standard would allow compilers to behave obtusely, that doesn't mean that compilers should do so, nor that programmers should go out of their way to accommodate obtuse compilers.
Why do people keep recommending things like vim to beginners? What is the value? You can very safely get by without *ever* knowing vim and not be any worse off for it.
Cool, I haven't seen this one before.
there is a standard regarding the basic types though, int being 2bytes is perfectly fine, that's the least it's supposed to take. [Wikipedia](https://en.wikipedia.org/wiki/C_data_types) has a nice overview. But that said it's indeed wise to use stdint.h(if you can because it's c99) and exact sizes if you depend on that. Otherwise it was/is fairly common to define these types yourself and adjust for each platform you target.
**C data types** In the C programming language, data types are declarations for memory locations or variables that determine the characteristics of the data that may be stored and the methods (operations) of processing that are permitted involving them. The C language provides basic arithmetic types, such as integer and real number types, and syntax to build array and compound types. Several headers in the C standard library contain definitions of support types, that have additional properties, such as providing storage with an exact size, independent of the implementation. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt; so in perspective of my goal which is to print out the sizeof the array (10 elements, so it prints out 10) You cannot. sizeof is not a function, it is something that is calculated at compile time from the type information. Think about it: void f( int *array ) { print( "%ld", sizeof(array) ); } main() { f( malloc( sizeof(int)*10 ); f( malloc( sizeof(int)*20 ); } The same code would print both 10 and 20. You could use the undocumented functions [described here](https://stackoverflow.com/questions/1281686/determine-size-of-dynamically-allocated-memory-in-c) but it would give the size of the memory block, that is likely bigger than the memory you requested. The core issue is that, in C, as soon as you use an array name in an expression, you don't have an array anymore, you just ave a pointer to its first element (again, ``sizeof`` is special, it is not a function, it does not act on the object passed in argument, but on the ``type``). At the end, if you have an array (and ``int * array = malloc(10 * sizeof(int));`` is NOT an array, it is a pointer), you can use a macro: #define NUM_ELEMENTS(x) (sizeof(x)/sizeof(*(x))) int array[12]; NUM_ELEMENTS(array); /* This is 12 */ int *bad; NUM_ELEMENTS(bad); /* This is 2, as you can store 2 ints in a int *, but this is probably not what you wanted*/
`s/vim/nano/` ... Here you go buddy
``1&lt;&lt;7`` is one shifted 7 times to the left, ie: 00000001 transforms into 10000000. ``theByte &amp; 1&lt;&lt;7`` is ``theByte &amp; (1&lt;&lt;7)``, which is ``theByte &amp; 0x80`` It gives 128 (0x80 or 0b10000000) if ``theByte`` has its 8th bit set, and 0 otherwise. ``if (a)`` is equivalent to ``if (a!=0)``, it means the ``if`` statement is expecuted if and only if, the 8th bit of ``theByte`` is set. In you example, 01100011, it will not be executed. Hope that helps.
If theByte is 0b10000000 and 1&lt;&lt;7 is 1 left-shifted 7 times, then (theByte &amp; 1&lt;&lt;7) will be: 0b10000000 # theByte &amp; 0b10000000 # 1&lt;&lt;7 = 0b10000000 If theByte is 0b01000000: 0b01000000 # theByte &amp; 0b10000000 # 1&lt;&lt;7 = 0b00000000
Wow, like all of this is wrong. `int` is not ambiguous in the way you seem to believe; it supports at least the range ‚àí32767 through 32767, it‚Äôs defined as such by the standards, and all compilers have consistently satisfied that range since the mid ‚Äô80s. The fact that `sizeof(int)`, `_Alignof(int)`, `INT_MIN`, and `INT_MAX` vary from ABI to ABI has nothing to do with standards compliance, it‚Äôs (per the standards) normal variance of implementation details. And the big fucking problem with the C family of languages is not compilers disobeying standards, it‚Äôs that they follow every letter of the standards even if that results in bizarre, unexpected behaviors after optimization. Compilers follow the standards considerably better than programmers, in other words. ICEs and compiler bugs are relatively rare, and they tend to crop up around newer features in stress-testing, so a compiler is probably not going to suddenly come up with a 1-byte `int` unless you‚Äôve done something frightfully abusive to it. `sizeof` applies to expressions (normal and type), not to operators. As such, `sizeof(+)` is not a valid expression, even in C++ where it‚Äôs a free-for-all of blackjack, hookers, and operator overloading. `sizeof` yields a `size_t`, which is (or acts-as-if) defined by `&lt;stddef.h&gt;`. Nothing about OP‚Äôs question or answers to it requires or involves `&lt;stdint.h&gt;` in any way, and that header‚Äôs properly only a part of C99+ and POSIX so C89 beginners won‚Äôt necessarily see it or have it available. Even if you have `&lt;stdint.h&gt;`, `int32_t` isn‚Äôt guaranteed to exist. `int_least32_t` is guaranteed to exist for C99+ (either two‚Äôs-complement where `long` is big enough, or more generally when `long long` is a thing), but not all platforms can actually do a legit 32-bit access (e.g., there are some 40-bit microcontrollers still bouncing around) so the existence of the (`u`)`intXX_t` types is entirely ABI-dependent. And it‚Äôs lovely you use `&lt;stdint.h&gt;`, but that doesn‚Äôt even give you the format specifiers or `uintmax_t` support that `&lt;inttypes.h&gt;` (part of POSIX, not ISO C) gives you, so it‚Äôs really not appropriate to direct a beginner to always use `int32_t` regardless of actual needs, and regardless of their ability to actually `printf`/`scanf` an `int32_t` safely and portably. And if you‚Äôre working with hardware directly, then (a.) portability isn‚Äôt a concern, so you should know damn well how big your fundamental types are, and (b.) `int` and `char` are still perfectly reasonable in that context because they usually correspond to useful architectural types.
Thank you it does. I was doing the operations in my head in the wrong order. I thought they are doing an AND operations with a 1 then shifting it 7 times.
You are probably looking for Dev C++ or Visual Studio Code(cross platform) As starter and getting with C, I would recommend using a Unix (preferably Linux) and Visual Studio Code. Believe or not, it makes a difference. And on most of Linux flavours like Manjaro and Deepin, gcc C compiler would pre installed.
by op's point of view.... the bottle neck is a working IDE. So the recommendation is to skip that altogether. If notepad++ is easier because hotkeys/shortcuts aren't necessary then fine. But lets not pretend that a beginner should be faced with getting something like Eclipse configured properly only to crash once a week for no good reason. &amp;#x200B; The main suggestion here is to get a simply linux distro, and learn make/gcc/gdb.
Let's rewrite the expression to ensure the operator precedence is clear: (theByte &amp; (1&lt;&lt;7)). The left shift happens before the AND. Now 1 decimal is 00000001 in binary (showing 8 bits). Let's left-shift 00000001 seven times (1 &lt;&lt; 7): 00000010 00000100 00001000 00010000 00100000 01000000 10000000 So, 1&lt;&lt;7 results in binary 10000000 (80 in hex, 128 in decimal). That's an 8-bit number with the most significant bit set. Now, consider the truth table for AND (&amp;): 0 AND 0 = 0 0 AND 1 = 0 1 AND 0 = 0 1 AND 1 = 1 Consider a few cases of (1&lt;&lt;7) bitwise ANDed with various values of theByte (shown in binary): 10000000 AND 00000000 = 00000000 10000000 AND 11111111 = 10000000 10000000 AND 10000000 = 10000000 So, it appears that the (theByte &amp; 1&lt;&lt;7) will return binary 10000000 (128 decimal) if the most significant bit of theByte is set and 00000000 (0 decimal) if it is not. The rest of the bits are effectively ignored, being set to 0. In C, `if (128)` will evaluate as true and `if (0)` will evaluate as false. So, the expression can be read as "if the most significant bit of theByte is '1', then digialWrite(). It looks like this code might be part of more code that attempts to set a data line high or low based upon the corresponding bits in a byte. I'm guessing the rest of it looks like this: digitalWrite(lcd_D7_ArdPin,LOW); // First set D7 line low. if (theByte &amp; 1&lt;&lt;7) digitalWrite(lcd_D7_ArdPin,HIGH); // if bit 7 of theByte is high, set the line high digitalWrite(lcd_D6_ArdPin,LOW); // First set D6 line low. if (theByte &amp; 1&lt;&lt;6) digitalWrite(lcd_D6_ArdPin,HIGH); // if bit 6 of theByte is high, set the line high digitalWrite(lcd_D5_ArdPin,LOW); // First set D5 line low. if (theByte &amp; 1&lt;&lt;5) digitalWrite(lcd_D5_ArdPin,HIGH); // if bit 5 of theByte is high, set the line high digitalWrite(lcd_D4_ArdPin,LOW); // First set D4 line low. if (theByte &amp; 1&lt;&lt;4) digitalWrite(lcd_D4_ArdPin,HIGH); // if bit 4 of theByte is high, set the line high digitalWrite(lcd_D3_ArdPin,LOW); // First set D3 line low. if (theByte &amp; 1&lt;&lt;3) digitalWrite(lcd_D3_ArdPin,HIGH); // if bit 3 of theByte is high, set the line high digitalWrite(lcd_D2_ArdPin,LOW); // First set D2 line low. if (theByte &amp; 1&lt;&lt;2) digitalWrite(lcd_D2_ArdPin,HIGH); // if bit 2 of theByte is high, set the line high digitalWrite(lcd_D1_ArdPin,LOW); // First set D1 line low. if (theByte &amp; 1&lt;&lt;1) digitalWrite(lcd_D1_ArdPin,HIGH); // if bit 1 of theByte is high, set the line high digitalWrite(lcd_D0_ArdPin,LOW); // First set D0 line low. if (theByte &amp; 1) digitalWrite(lcd_D0_ArdPin,HIGH); // if bit 0 of theByte is high, set the line high That might not be the most efficient way of achieving that, but I'm guessing that's what is going on here.
this is nonsense. computer science is meant to teach the concepts of programming. you are expecting the OP to learn a completely new operating system that is generally hostile to beginners, a complex editor that needs to be learned and configured before it can be useful (which is annoying even for many advanced users), complex tool chains that all need to be individually learned and environment setup. &amp;#x200B; he's not going to remain a beginner; he's not even going to start with your absurd suggestions. it is the worst thing you could throw at a beginner. &amp;#x200B; all the OP needs to get started is a light weight IDE. he might even benefit from using an online repl. learning programming concepts distraction-free. learning the tool chains and command line environments can come easily later.
you are correct. code can be found here: http://web.alfredstate.edu/faculty/weimandn/programming/lcd/ATmega328/LCD_code_ino_8d.html It does feel a little inefficient but right now I am just trying to get the basics working. I am coding for Arduino. Suggestions on making it more efficient in the future?
Something like this for the action, maybe? ex= ; \ thing1 || ex="${ex:-$?}" ; \ thing2 || ex="${ex:-$?}" ; \ etc; \ exit "${ex:-0}"
Did you mean int arr_dynamic[10]; Without the star. That would be a similar integer collection as arr\_pointer is.
When in doubt about order of operations, you can look up (operator precedence) [https://en.cppreference.com/w/c/language/operator_precedence]
Hm, you might be limited by the hardware configuration and the Arduino API, but a few thoughts: 1. If the LCD data lines happen to map to pins 0-7 on an 8-bit port, you could simply do a bit-wide write of `theByte` to the port's data register (assuming there's an Arduino API for that). That'd be most efficient, though that does make a big assumption about the data line configuration, which might be limiting if you're shooting for a general-purpose library that allows for the data lines to be on arbitrary port pins. 2. I'm not super familiar with Arduino, but if `digitalWrite()` sets a pin high whenever the `value` parameter is non-zero and low when it's zero, then you can simply do this (repeated for each bit): `digitalWrite(lcd_D7_ArdPin,theByte &amp; 1&lt;&lt;7);` This is less efficient than a full port write, but it's more flexible in that the LCD data lines can be mapped to arbitrary Arduino pins. It's also more efficient than the stock code because it performs only one write per pin instead of the stock code's two. 3. If `digitalWrite()` only works with the constants HIGH and LOW, then you can do this (repeated for each bit): `digitalWrite(lcd_D7_ArdPin, (theByte &amp; 1&lt;&lt;7)?HIGH:LOW);` This is less efficient than option #2 because each write contains a branch, but it ensures proper API usage and still only performs one write per bit, which is more efficient than the stock code.
`sizeof` also include the alignment of the variable; it's the actual number of bytes needed to store it. Even in a 4-byte variable, like `int`, if you run the code on a 64-bit machine, the compiler will automatically add padding bytes to get the variables to fit into a machine word, which on your machine is 8 bytes.
Maybe this would blast all bits at once? PORTD = theByte;
&gt; if you‚Äôre working with hardware directly, then portability isn‚Äôt a concern Portability is still a concern if you want your code to work on more than one type of hardware, or if you want it to work on hardware but also on a desktop.
Please elaborate on what that is and how to do it.
How do i get that to compile into an environment that gives me error messages and such?
I didn't realize it was open to the public! CS50's online course was really good for when i was first learning Python.
I don't care about this ancient flame war, I just want a simple, reliable development environment. How do i turn txt files into c programs (say, in notepad++)?
I haven't used Windows for a decade, but I imagine Visual Studio is about as good as it gets: Should have everything you need (editor, linter, compiler, debugger, etc). https://visualstudio.microsoft.com/vs/community/
Ternary expressions in assignments do not need to create a branch but instead a conditional move, which basically ends up in a No-op if the condition evaluates to false. I would say options two and three have equivalent cost, since the cost of a system call is way more expensive than the cost of an additional instruction.
just put on the lasts lines of main: char dummy; printf("Enter to leave\n"); scanf("%c", &amp;dummy); this will keep your program to end and to close the console
That's not what happens. `int* arr_dynamic[10]` is an array of pointers to int, each pointer is 8 byte.
True, I probably should have said, ‚Äúcould contain a branch.‚Äù And I definitely agree that the digitalWrite call dwarfs it regardless.
This is litterally the opposite of what I asked for. I want a simple, functional sandbox that fits in my back yard, and you're reccomending I buy a new house. Even if it was impossible to learn C on Windows, Linux barely supports my graphics card, do it would be 100% CPU fan noise all the time. I'd also have to spend most of a day backing up my data, dissambling my computer, installing Linux, and blindly copy-pasting terminal commands to fix whatever obscure issue accosts me. By this time, Ive wasted a day, become frustrated/demotivated, and most importantly FAILED TO WRITE A SINGLE LINE OF CODE. I'm looking for a simple, easy to install IDE with few enough features that i don't get overwhelmed. As capable as Linux is for the things it's good at, it fits none of those requirements.
You seem to have a lot of insight into C typing, so I was wondering what you thought of [this](https://matt.sh/howto-c?fbclid=IwAR2LtnZ8oYRlRTCUky3lrAmIPddUVcTU7iyxuG5ALYdb6624xy2wsysngRA#_types).
I havent written any code yet, since i can't get any IDEs to work. I double-clicked on the tcc executable and it opened a window for half a second and then stopped. How do i put tcc into a C toolchain so I can program with it?
Fair point, but nobody had mentioned alignment so I thought it was important to bring up.
That is... not true. `sizeof` a `struct` will include any padding that has been added between members, but the size of a single variable will not include any offset/padding bytes added by the compiler on the stack. But it's possible for a C compiler on a 64-bit platform to make `int` a 64-bit type, in which case `sizeof()` an `int` variable will be 8.
Did you read my post? I want a simple, easy to install IDE. Although Linux installation is pretty straightforward (unless you're Arch Linux), having to reconfigure my hardware setup and/or back up nearly a terabyte of data just to get a slightly better development experience is absurd. &amp;#x200B; The Linux kernal has many advantages over Windows' mess of an operating system, but being beginner-friendly has never been one of them.
Didn't realize I was walking into an operating system trade show here, but I'll give Dev C++ a shot.
Thanks for clarifying!
Right, but if it‚Äôs directly fiddling with more than one type of hardware, you‚Äôre still taking each ABI‚Äôs details into account and 99% of the time you‚Äôre `#ifdef`ing all over the place (or something equivalent) in order to do so.
Was about to say the same
I don't think the authors of the Standard intended the concept of portability to be an all-or-nothing proposition. Some compiler writers, however, seem to think that if the Standard wouldn't require that even obscure implementations process code usefully, it's "broken" and shouldn't be expected to work even on commonplace ones. Thus, for example, gcc will sometimes use a function like: unsigned mul_mod_65536(unsigned short x, unsigned short y) { return (x*y) &amp; 0xFFFF; } to infer that `x` will never exceed 0x7FFFFFFF/y because the Standard doesn't require that implementations handle cases where the product would be in the range 0x80000000 to 0xFFFFFFFF. Too bad the authors of the Standard didn't make clear that it deliberately allows implementations specialized for narrow purposes to behave in ways that benefit those purposes and but would make them unsuitable for many others, and it makes no attempt to mandate everything necessary to make an implementation suitable for any particular purpose.
That's what I'm referring to, yes.
An implementation cannot define `uint8_t` unless `char` is 8 bits, but that does not mean `uint8_t` is synonymous with `unsigned char`. A conforming implementation could define an 8-bit extended integer type and make `uint8_t` an alias for that. Given something like `uint8_t *p; int i;` at global scope, such an implementation could then process `*p++ = 1; *p++=2;` without having to reload `p` between the two operations [generally useful], but would be allowed to assume that code which converts an object's address to `uint8_t*` and then uses that pointer to access the bytes thereof would not affect the value of the object in question [decidedly less useful, but allowable under the Standard].
&gt; The Tiny C Compiler looks like exactly what I need, but the terminal windows its .exes generate dissapear too fast. Am I supposed to be using a Windows terminal window? If so, could someone give me an idiot's guide to doing that? I used the cd command to get into its folder, but the terminal still doesn't recognize tcc as a valid command. Small guide: 1. Copy the *tcc* folder to your C: drive (optional but recommended for simplicity) 2. Add C:\tcc to your system path. You can search for "add program to windows path" if you don't know how. 3. Open a cmd window from the Windows Start menu. 4. Use cd to go where your C source file is. Compile the program with something like: tcc myprog.c 5. Still in the cmd window run the generated executable from the above step. To edit a C program on Windows you can use any text editor. Simplest option is to use Notepad++, but VSCode, Atom, Sublime Text and others will work just fine too.
Yeah, you're right. I probably missed quite a few other details too.
Your advice is excellent for someone that wants to master C programming professionally. For a beginner that only knows Windows well this is a recipe for failure. First learn standard C, this can be achieved on literally any modern OS: Windows, Linux, macOS, BSD.
I don't mean you need to run Linux on bare metal and replace your daily OS. I would just run Linux in a VM, or even on a Raspberry Pi. It's _extremely_ easy these days to get a fully working Ubuntu running.
did you try with visual studio, the community edition?
If you just want to get started, check out [wandbox](www.wandbox.org). You will ultimately want to set up a new ‚Äúhouse‚Äù in the *nix world. Windows 10 has amazing support for this as part of the Windows Linux Subsystem. I use VMWare Player running Ubuntu, and I used to dual boot. The reason is that windows C programming comes with many strange caveats. C has enough confusing details as is. Stay away from Cygwin and Mingw. You will outgrow these solutions too quickly for them to be worth the trouble. Ubuntu in a VM is friendlier and a true *nix. And the new Windows 10 solution is probably ideal and works out of the box, but I have not tried it. The C Programming Language is very dated and I don‚Äôt know any good Windows books. 21st Century C is good.
Since you're never going to use `garage_s` and `house_s` to refer to the structures (that's what the typedef is for, after all), the first two typedefs can be simplified: typedef struct { int bays; } Garage; typedef struct { int windows; Garage *garage; } House;
If you insist to go forward with Windows C programming, the first few episodes of Handmade Hero on YouTube will guide you through setting up a build environment. Note that MSVC only has partial support for C99, but it does have all the important bits by now.
True, good point!
Some quick feedback: 1. Include descriptions of the problems and the solution in your own words. This is VITAL in the actual interview because the question is rarely presented as the ‚Äúcore‚Äù problem. So being able to distill a ‚Äúword‚Äù problem into a ‚Äúcore‚Äù problem is important. 2. In a few files you use a while loop when a simple for-loop is preferable fine. It‚Äôs a minor thing, but it takes a reader a few more seconds to read because we have to think ‚Äúok, what‚Äôs this...oh it‚Äôs just a loop‚Äù and at worst (given that you only get one or two problems) the interviewer might think ‚Äúdo they know what a for-loop is??‚Äù https://github.com/dariogithub1/cracking-the-code-interview-solutions/blob/8985efd88c3f84b58e95ea6b22e2808d1e4617b0/chap2/findthenthelement.c#L5 3. Edge case handling. In your linked lists examples, what happens when n is larger than the list length? Looks like segfault. It‚Äôs fine if that‚Äôs what‚Äôs documented. But can you do better? 4. Minor style. I don‚Äôt write as much C as I‚Äôd like to, but a few things I‚Äôd suggest: brackets around each block. It‚Äôs just too easy to forget to add them when you realize you need another line in your loop. Overall the solutions look solid. I‚Äôd be inclined to hire based on what I‚Äôve seen. Keep it up!
You can write your own operating system for PC. The osdev wiki is a great place to get started. I'd recommend interfacing to it primarily over serial, especially if you've got a motherboard with built in bios support for serial. I'd say more what you want is a raspberry pi zero configured to boot to single user mode, and the micro usb port set up to be an ethernet gadget so you can connect to it via ssh over usb. Build a low latency, feature free kernel. You get all the benefits of C in hosted mode, no competition for the single CPU, and the kernel takes care of the slog work of interfacing with the hardware. If you're on windows, make sure to find a tutorial about configuring the USB otg gadget to use rndis 7's driver. rndis 6.1 (acer) is a POS that will lock your computer.
I just pulled up the compression one and my immediate thought was that you need more comments. On a white board, no comments isn't a huge deal. But really there are two things you are going for here: 1. Being able to explain what the algorithm does 2. Being able to explain your process for getting to that point To that extent, comments here walking through what the code does and why are more important then the actual code. The comments don't have to be novels about what each line does, but something documenting the flow and your thinking.
Perhaps try switch (tolower(text[i])) { case 'a': ...; } if you want to count any character and not just `'a'` or `'A'`, try if (isalpha(text[i])) counter[i]++;
Hi, thank you! One fast question what does isalpha do exaclty? I've seen it a lot around
Yes. OP explicitly mentioned that and does not want this behaviour.
Just convert the character to upper or lower case, then do your switch on only upper or lower case characters.
Wouldn't that change the whole text to uppercase? Because unfortunately I need it again later üòì
Just set MAKEFLAGS, then: horizon:~/tmp/keep-going$ cat Makefile MAKEFLAGS = --keep-going both: first second first: echo this is the first task. exit 1 second: echo this is the second task. exit 2 horizon:~/tmp/keep-going$ make echo this is the first task. this is the first task. exit 1 Makefile:6: recipe for target 'first' failed make: *** [first] Error 1 echo this is the second task. this is the second task. exit 2 Makefile:10: recipe for target 'second' failed make: *** [second] Error 2 make: Target 'both' not remade because of errors.
Instead of answering your question, I ask you to refer to the documentation. On UNIX, simply type `man isalpha` to get the manual page for `isalpha`. You should always have the documentation ready and you should have read it before asking any questions about library functions. This makes your C experience much less frustrating.
Alignment has nothing to do with sizeof. You use alignof to get the alignment.
&gt; you'd end up with a lot of (x, y) tuples ... z = sqrt((x*x)+(y*y)); if (z&gt;=1.0) { // reject } else { }
Windows is the best OS to learn C on, and I recommend Pelles C IDE, it's free and very popular. http://www.smorgasbordet.com/pellesc/
The ascii codes for lower and upper case letters are separated by a constant number.
A trick I have seen is using the character normalized to 0 as an array index. counter\[tolower(text\[i\]) - 'a'\]++;
This is just a less optimized version (because you have a square root in there) of what I proposed to begin with?
I could have worded that better. Yes - unless you want only points on the surface, you'd need another random number. double z = ((x*x)+(y*y)); if (z&lt;0) reject(); else if (z &gt; 1) reject() ; else { // explicit formulation of constraint... z = 1 - sqrt(z); // at this point z is on the surface of the sphere... z -= rand_from_zero_to_1_inclusive(); // now it's anywhere in the sphere.... } I have not tested this but I believe it will work.
Oh - then many pardons. :) Sounds like you were right then. :)
WARNING: ignore above reply completely. Dude/Dudette has no flipping idea how arrays work in C.
Google is your friend if you are short of time. Reddit for discussions. https://stackoverflow.com/questions/13213422/count-the-number-of-occurrences-of-each-letter-in-string
&gt; // Set the array dynamically to store 10 ints What does that mean? That's gibberish. What you did is you declared an array that can hold 10 **pointers** to int. A pointer is usually 4 bytes or 8 bytes. It's an array of 10 elements, so 10*8 = 80. That's your second `sizeof`. In your first declaration, you're asking for the size of a pointer. It's 8 bytes. That's your first `sizeof`. You don't know how arrays work in C. Judging by most replies in this thread (holy fuck, guys) - most others don't know either.
You could use a loop to scan the alphabet. Remember that characters are just numbers that represent the ASCII code. So for example: ``` 'a'+1 == 'b' ```
I don‚Äôt think there‚Äôs time in a CS degree to not hit students with 80 things at once.
It would be best to use offsets ie. counter[(text[i] - 'A') % ('a' - 'A')]++ No switch statement and the modulo handles lower and upper case chars. This is assuming you only have characters. You would need to do some checking if the char is in the ascii character bounds.
This obviously seems like homework... but I‚Äôll give you pointers. Is the text ASCII? If so, you can convert cases using a single AND or a (NOT + OR) which removes half your cases. Then, to remove the switch all together, just increment the offset in an array. ``` for c in string: norm = toLower(c) counts[norm] += 1 ```
**nothing** to be ashamed of. I have 30 years of experience in C. I would not write ``theByte &amp; 1&lt;&lt;7`` without parentheses. In fact, I wrote a quick one-liner to check that my understanding was correct before answering your question.
Look at the [numeric values of the characters](http://www.asciitable.com/) and think about what you're checking. Upper and lower case vary by one bit - you can mask that bit and check for both cases at once.
I don‚Äôt think there‚Äôs *a* way, let alone a good one, to know a malloc‚Äôd array size without tracking it.
sizeof includes padding with compound types, so it has a lot to do with alignment
&gt;Sizeof is evaluated at compile time Not necessarily, e.g.: int x[rand() % 6 + 1]; printf("%zu\n", sizeof x);
It‚Äôs an opinion expressed strongly, certainly. IMO it‚Äôs sort of missing the point, and it‚Äôs outright wrong in a bunch of places. The problem it seems to be addressing is that *during the learning process*, the built-in types are never presented correctly to the student, and they‚Äôre often presented by the same sorts of people who declare C to be a ‚Äúhigh-level assembly language‚Äù because the late ‚Äô80s were the last time they had a hands-on experience with C. So the student ends up learning ‚Äú`int` = integer mod 2^(32) and always safe‚Äù instead of ‚Äú`int` is at least 16-bit-ish and that‚Äôs it,‚Äù and then they end up using `int` everywhere instead of more appropriate things like `size_t`. The correct thing to do is to look at the APIs for the functions you need, see what they use, and see how to make them interact properly without losing bits or causing UB. That‚Äôs all that‚Äôs required; 99% of the time that can and should be done without reference to specific numbers of bits. Furthermore, a type is a collection of assertions about the variable/field/whatever that holds its values and the operations that can be performed on them. The assertions underlying `int` are very different from the assertions underlying `int32_t`, and the assertions underlying `unsigned char` are very different from those underlying `uint8_t`. Idunno. There‚Äôs a bunch of stuff in this entire document that‚Äôs either iffy or downright wrong, more than a few cargo-culty things. To be considered, but not followed authoritatively.
His array size for 'count' has to be bigger now. int count['z'];
I was avoiding solving all the issues because I‚Äôm not going to do their homework for them. But no, it does not have to be bigger. Just clamp to the range you need. N unique possibilities would only require N integers.
From the C99 standard: &gt;If any argument is not the correct type for the corresponding conversion specification, the behavior is undefined. Undefined behavior is well... undefined. You cannot expect consistent/reliable results (especially across machines). As for why the output is the same between code::blocks and your terminal, i have to ask why you expect them to be different? Are they not the same executable?
There are two instances of undefined behavior here, both relating to the format arguments. The first is where you pass `n3` and `n4` as arguments to `%e`. `%e` takes a `double`, not a `long`, and there‚Äôs nothing to tell the C compiler (which may or may not understand what the format string to `printf` means) that it should pass the `long`s as `double`s. `n1` is fine because `float` autopromotes to `double` in that situation. (Which is specifically passing a vararg. More on that later.) The second is where you pass `n1` and `n2` for the arguments to `%ld` specifiers; again, undefined behavior, and the compiler will faithfully pass `double`s, not `long`s. The prototype (i.e., gozins and gozouts) for `printf` is int printf(const char *format, ...); This is (theoretically) all the compiler can see, a format string and maybe-some-other-things. That `...` represents a variadic parameter list to the compiler. When you call `printf`, the compiler will construct a variadic argument list from what you give it, which involves applying default argument promotions‚Äîdefault because they‚Äôre what the compiler does to shake things into the right places in absence of more specific information, promotions because they involve widening some things. These are used when setting up a `...` argument list or when calling a function without a full prototype. Per default promotions,`float` is promoted to `double`, and `_Bool`, `signed char`, and `short int` will promote to `int`, as will `char` if it‚Äôs signed. `unsigned char` and `unsigned short int` will promote to `unsigned int`. These promotions mean that by default, `printf` pulls `int`, `unsigned int`, or `double` arguments unless told otherwise (e.g., `%ld` vs. `%d`), and there‚Äôs no need for it to have special `short`/`char` size specifiers. Because of all this machinery, the callee function (usually) has no means of determining how many arguments it was passed or what types they had, so it has to trust whatever the format string specifies. When it reads its arguments, it pulls out `int`, `long`, `double`, etc. based on the format specifiers, and pulling out the wrong kind of, or a missing, argument is undefined behavior, so there‚Äôs Officially No Telling what happens. Turn on all your compiler warnings and you should see a complaint about `printf` format stuff BTW, because usually it *is* smart enough to notice screwups like that at compile time. (It can‚Äôt always, though.)
uh what does `ex= ;` do exactly? why not initialize ex to `0`?
This is less a comparison between C &amp; C++ and more a comparison between reading the entire file into memory with a single call vs reading the file line by line.
Maybe I'm missing something, but isn't your fgetsw() stopping at the first newline character in your test file? It makes sense that it would be faster if it's only reading 1 out of ~300 lines.
Thanks for the input i'm going have a look at reading the whole file in the C function too. I will update it, thanks
Hi going have a look at reading the whole file in the c function too. i will update it, thanks, I'm dad.
hey, thanks! it does honestly get hard to wrap around the concept of arrays and pointers the first time, i got enlightened after sone replies and now understand more!
Thanks for the idea. I was able to make the load func much smaller, but now I cannot get the values out of the hash table. This is my new load, note the use use of the `.` operator in near the end. Using your node function doesn't allow me to use the `-&gt;` here. void loadHashTable(void) { int count; puts("Enter count: "); scanf("%i", &amp;count); for (size_t i = 0; i &lt; count; i++) { puts("Enter name and number"); char nameTemp[NAME_LENGTH]; int numTemp; scanf("%s %d", nameTemp, &amp;numTemp); node newNode = *createNode(nameTemp, numTemp); int hash_index = hashValue(nameTemp); if (hash_table[hash_index] == NULL) { // insert node at head of linked list // same as head = mem hash_table[hash_index] = &amp;newNode; newNode.next = NULL; // count++; printf("%s\n", newNode.name); printf("%i\n", newNode.number); } else { newNode.next = hash_table[hash_index]; // reassign head to new node hash_table[hash_index] = &amp;newNode; printf("%s\n", newNode.name); printf("%i\n", newNode.number); } } } &amp;#x200B; But when I try to access the hashtable later I cannot get the values out. I've checked and the hash function is working but when I try to get something like this, I cannot get the value out. node *cursor = head; printf("%s\n", cursor-&gt;word);
One small nitpick is that when dynamically allocating memory inside a function, generally convention is to return a pointer to the memory rather than passing in a double pointer for output. For example, your linked list initialization might be refactored to the prototype `Node *create_list(int data[], size_t size);` The details of your implementation would require a similar refactor of the `push()` function.
It's been a while since I read it, calling UTF-16 "UCS-2" is blatantly incorrect and will really confuse people about Surrogate Pairs for one.
Theoretically nothing prevents you in C of writing all over the stack, but I thought your operating system should be complaining.
I'm no expert but I'd say your redefining the array with a size of 6, int array[6] = 6 should be array[6] = 6. Sorry for Mobile formating etc etc
This seems correct. When I try to recreate GCC throws an invalid initializer.
You can, but it's frowned upon at least? to do it that way. create two structs, and reference the second one in the first via pointer to create an array of that struct.
So basically you're creating a histogram, aka a frequency map? Smple create an array with the number of elements in the array eqal to the number of characters, use the index of the array as the character, and simple increment a count for each array element's value. example: uint8_t *Histogram = calloc(1, 128); for (uint64_t CharacterInStream = 0ULL; CharacterInStream &lt; StreamSize; ChracterInStream++) { Histogram[File2ReadFrom[CharacterInStream]] += 1; }
So basically you're creating a histogram, aka a frequency map? Simple create an array with the number of elements in the array eqal to the number of characters, use the index of the array as the character, and simple increment a count for each array element's value. example: uint8_t *Histogram = calloc(1, 128); for (uint64_t CharacterInStream = 0ULL; CharacterInStream &lt; StreamSize; ChracterInStream++) { Histogram[File2ReadFrom[CharacterInStream]] += 1; }
So basically you're creating a histogram, aka a frequency map? Simple create an array with the number of elements in the array equal to the number of characters, use the index of the array as the character, and simple increment a count for each array element's value. example: uint8_t *Histogram = calloc(1, 128); for (uint64_t CharacterInStream = 0ULL; CharacterInStream &lt; StreamSize; CharacterInStream++) { Histogram[File2ReadFrom[CharacterInStream]] += 1; }
Sorry my bad, i updated the code to reflect what i meant.
You can't use `sizeof` with dynamically (aka at runtime) allocated arrays. You have to store the array's size somewhere and submit that as function parameter, OR you can do like C strings, and have value that indicates the end of the array at the end and not use that value anywhere else. Those are your choices.
Too bad that standard hasn't been updates to support storing 64 bit values. I had to use a damn define to store PNG's magic number :(
C arrays are not bounds-checked unless you explicitly do so. If you get far enough out of bounds you'll eventually try to access memory you can't use, and get segfault , but for this example that's not going to happen.
I think the old saying is that if you are holding a length of rope and looking at a tree you have the choice to hang yourself if you want. The results are usually quite bad. So don't do that.
thats some genius saying. im just trying to wrap my head around C and how it works.
https://en.m.wikipedia.org/wiki/Bitwise_operations_in_C
Desktop link: https://en.wikipedia.org/wiki/Bitwise_operations_in_C *** ^^/r/HelperBot_ ^^Downvote ^^to ^^remove. ^^Counter: ^^262166. [^^Found ^^a ^^bug?](https://reddit.com/message/compose/?to=swim1929&amp;subject=Bug&amp;message=https://reddit.com/r/C_Programming/comments/c35y46/the_bits_and_the_bytes/eroxkzz/)
**Bitwise operations in C** In the C programming language, operations can be performed on a bit level using bitwise operators. Bitwise operations are contrasted by byte-level operations which characterize the bitwise operators' logical counterparts, the AND, OR and NOT operators. Instead of performing on individual bits, byte-level operators perform on strings of eight bits (known as bytes) at a time. The reason for this is that a byte is normally the smallest unit of addressable memory (i.e. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Cool stuff! Is that a mandelbrott render I see? ;)
Jetbrains CLion was pretty easy to set up and is a very solid IDE. Free for students, but you'd have to pay otherwise.
Yep! Fractal rendering is something I always do first once I start programming graphics on a new platform lol. The source for that is included in the repository as \`mandelbrot.c\` if you want to play around with it! I didn't document it but it shouldn't be too hard to figure out.
Well C will let you chamber the round and shoot yourself in the foot if you want. Total low level freedom and even inline assembly can happen. Wreck havok and poke of death or HCF or whatever.
That picks the first nonzero exit code, essentially.
Having a file system is a lot nicer than having to manage things as raw sectors.
All they do is make #defined constants that auto-increment in value with each item listed. They are not variable so they do not live in memory. Arrays live in memory and require explicit value assigning
An array in C is just any number of consecutive locations in memory. You refer to that memory with a pointer to its first element. That‚Äôs what an array variable is - a pointer to the first element in the array. A regular variable is a named memory location that holds a value. A pointer variable in itself is just a memory location whose value happens to be *another* memory location. That second location might be a plain integer. Could be an array. Could be a struct. Could be another pointer. And that pointer may point to a third pointer. And so on. Arrays ‚Äúdegrade‚Äù to plain pointers when passed into a function as a parameter. Try an experiment. Declare an array of say 50. What does sizeof() say? Now pass it into a function. What does sizeof() say about the array inside the function?
The createNode() function returns a pointer for a reason: it's all you ever need! Your hash table stores pointers, remember? What you are doing by dereferencing (using a '*' operator on the createNode() return value) is in fact **copying** the value from the pointer and saving it in a local variable. Then, when you try to save it to your hash table, you take the **address of the local variable**! This local variable (which you saved to the hash table) will be destroyed once you exit the scope, and the pointer is therefore invalid. What you need to do, is just save the **pointer** returned from createNode (), and write it to the hash table. I'm going to reiterate now, because I'd really like you to understand this: *local variables are deleted once you exit the scope they were declared in*, so if you are taking a pointer to a local variable - that better be for a goddamn good reason (e.g. copying a local data to heap with memcpy). Heap is persistent (unless manually free'd), stack of not! By the way, the last thing. In your OP you talked about performance problems. Even simple hashtable like yours is reeeealy fast, so that shouldn't be happening if all's done correctly. There is only that one thing... You know the complexity of a lookup in a hashtable is said to be amortized constant, but what happens if you have a table if width 1? It becomes a single linked list with complexity of lookup O(n). The less is the width of the table - the closer you get to that linear lookup and the further from the constant you depart. So, what do you do to get *closer* to the constant time?
Only if your application benefits from the file paradigm/abstraction and isn't crippled from the drawbacks of FAT filesystems. Offset based databases, large ring buffers, raw partitions for shell sort, etc. I worked for a large quick service restaurant around y2k, and the old DOS code base had to manage this stuff itself, as it was the only way the PC could finish processing data when the manager closed the day and the time the mainframe dialed in.
Or one wants to be able to use a single storage medium to hold information from multiple applications, as would typically (though admittedly not always) be the case. &amp;#x200B; BTW, I'd not heard of Shell sort (named after the inventor) being used with external media. I would have expected something like merge sort to be superior for that.
&gt; Or one wants to be able to use a single storage medium to hold information from multiple applications, as would typically (though admittedly not always) be the case. Maybe today that would be typical, or maybe for a home user in the 1980s. &gt; BTW, I'd not heard of Shell sort (named after the inventor) being used with external media. I would have expected something like merge sort to be superior for that. Then you've missed the obvious benefit of shell sort over merge sort.
Enlighten me. How would one arrange data to get good performance from Shell sort's access patterns? Classic merge sort would work nicely with four tape drives. Using a single disk drive wouldn't work as well, but the sequential access patterns facilitate buffering and minimize the need for random access. Shell sort involves comparisons and swaps among widely-displaced list elements without any effort to consolidate accesses to them with accesses to nearby elements.
They serve a purpose of having multiple integer values with some kind of common root-name and each value having a specialised-name on its own. For example You could have an enum type of "Colors" with values of "Red", "Yellow" and "Green". You know that any value of "Colors" is valid for a traffic light, but until you get a value of specific "Color", You don't know what light it is.
&gt;Oh boy. I assume you found this solution on the CLC Wiki? I went through that page and the only decent solution there is the fourth from the top, although I would have used character literals instead of magic numbers (which, in addition to clarity, would have the advantage of working with any character set with a contiguous alphabet, not just ASCII derivatives). Yeah, that is the site I used to check my answers against. Is that not a good place to go?
No one can easily read this, so no one would reply. Try reformat your code. Add atleast one empty line between each two lines.
They are not preprocessor constants. For a start, they have a type.
Thats because you don't access an array, you access memory address, where variable name is the ram location and the number inside of [] is just an offset, you could also write 6[arr] it ends up being arr (memory pointer) + 6 That's why it works
Most of that doesn't even matter under DOS, and it's the reason you wouldn't use FAT in the first place. That's not why you would pick shell sort over merge sort back then though.
You commited at least 20 hate crimes writing this code. **You gave me terminal cancer.** Anyway, I took it upon me to cleanse this world and cleaned up your code: #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; void sort (int *start, int size) { int min; int cmin; int head; int j; for (int i=0; i&lt;size; i++) { //min and cmin are the indicies for the leading minimum //and candidate minimum values cmin = i; for (j=i; j&lt;size; j++) { cmin = j; printf("Start value is: %d\na is: %d and b is: %d\n", testart[0]mp, start[cmin], start[min]); if (start[cmin] &lt; start[min]) min = cmin; } head = start[i]; start[i] = start[min] start[min] = head; } } int main(void) { int array[9] = {65, 234, 676, 3, 98, 35, 297, 34, 12}; sort(array, 9); for (int i=0;i&lt;9;i++) printf("array[%d]=%d\n", i, array[i]); return (EXIT_SUCCESS); }
They provide constants, that are type-checkable by the compiler. that way you can reduce people creating bugs by using the wrong constant when they call your function. let's say you have a function that handles UUIDs. UUIDs and GUIDs use the same format, the only difference is the byte order. if you have a parameter that's a bool true for UUIDs false for GUIDs people could get confused nd use the wrong bool. if you instead create a parameter called GUUID_Types Type , then the user would be given a list of options, in this case GUUIDType_UUID and GUUIDType_GUID when they called whatever function used that parameter, reducing confusion. and if the user used some batshit insane constant that wasn't defined in the enum, the compiler would error telling the user to fix their mistake.
No, you don't use gcc. you use cc. cc is the actually compiler agnostic alias for whatever compiler is installed.
My opinion is that they're gnu graybeards who are obsessed with the gpl and eating toejam tbh.
&gt; sing sed notation in a fucking reddit comment. top tier cringe tbh.
It is incrementing the value of data array indexed at Codelengths[index]. It is essentially the sama as ++i, here i being data[at some index] and "some index" being Codelengths[index]. Hope it makes sense.
I don't know why you got dislikes, it's true. I studied (and learned) a lot before actually programming in C. All things considered, you can easily expose a vulnerability in the code if you don't know what to do.
You might try asking this in /r/learnprogramming.
They have nothing to do with arrays. An enumerator is a name for a number that you use to make your code more readable and less error-prone in comparison to just using the number. Google "magic numbers" for more info
Please post projects as link posts instead of self posts!
The output on code:: blocks and the terminal are **not** the same. It is the **same** executable however. That's why I get tripped up
Good point, I will follow your suggestion and returning a pointer to the allocated memory.
Please post projects as link posts instead of self posts. I have removed your post so you can try again with a link post.
Thanks for your feedback.
Right, I will add the explanation of the problem and my solution at the head of every problem and better comments inside code, probably I too slavishly referred to job interviews when time is limited. Thanks for your feedback.
Yes, I will include descriptions of the problems and solutions at the head of every file, for understanding code I agree it is better to use a for loop instead of while loop. For the third point I coded only to pass the simple base tests and surely I have to add code to pass tests like the case you highlighted. For the last point about brackets i will add brackets to every block. Thanks for your feedback.
Here you go, it's a handy cheat sheet for situations like yours: https://en.cppreference.com/w/c/language/operator_precedence
Oh sorry. Thought they were the same that is strange. Are tyre results consistent? I'm not familiar enough with code::blocks. Is it possible that the executable is optimized, and when you run it within code::blocks is running a non-optimized version that would be easier to debug?
If that's to be believed, then ++ is the first thing that happens, or am I reading that incorrectly?
It's probably compiler dependent, but what does running some simple code in your compiler give you?
How can I add additional remarks like in this post to a link post?
I would also add that the typedef above has no relation to the code in the for loop. The 'Buffer' in the for loop is a variable of that name, whereas the typedef defines a type of that name - not the best practice and can be very confusing for someone starting out. To fully understand the code you would need to find out what type the variable 'Buffer' is declared as.
Make a comment under the post.
Thanks for the advice and sorry for the trouble.
Effectively they work the same as an immediate. I should have said "like a define" then?
 Hey fellow C geeks. I wanted to improve my knowledge on data structures and I love programming in C. So I'm currently working on a library of generic data structures for the C language. Maybe you can take a quick look and give me some advice on what could be improved. I'm sure there's lots of things. Thanks in advance!
Terminal cancer ahahahaha
Ah, VLAs, a very very bad thing that should be avoided for these reasons...
This is a big beyond my knwoledge, but I'll try to translate that by using references, thank you!
I did something using this method but the letters l and m didn't get counted üòì thank you anyway for the help, I'll try smething like this again
Why dynamically allocate an array of size only 256?
The results are consistent which is odd. I've learned over the past 12 hours that this is undefined behavior so basically the results can be the safe or they can vary with no expectations of always getting the same results
`Buffer.Data[CodeLengths[Index]` is being incremented.
Hi, thank you for the help, I actually already did it but for some unknown reasons it wouldn't count l and m and instead it would give l counts to n... Also I wanted to clarify that it's not a homework but an exercise I did from a book while learning C and I already did it but by using switch cases which I think could be somehow avoided so I though about your method but it wouldn't work for these letters üòî
Thank you very much this is something I didn't think about and neither knew... I'll try it later to see if it works for me, thanks!
I did one that was also pointed out by some users that is by going to the array index of the char number but for some reasons it didn't count some letters
What reasons? That you have trouble understanding them?
See the second comment. I just didn't want to "spoil" this answer. Don't forget to apply the `tolower` function to first convert the letter to lower case.
``++Buffer.Data[CodeLengths[Index]]`` is `++(Buffer.Data[CodeLengths[Index]])``. As the value is not used (and we are in C, not C+), this is ``(Buffer.Data[CodeLengths[Index]])++``, which is ``Buffer.Data[CodeLengths[Index]]++`` (Unless weird macros tricks, of course).
To be honest I wanted to discuss various methods, I already used a similiar method and it did not work for some letters, because I actually also use some letters that are not in the English alphabet
Oh I'm just replying to all comments one by one, I missed it. I'll try to figure out something but maily it was just curiosity because I have already done the exercise in a different way so everything is well accepted, I might try to do some test later, thanks
This is very similiar to a method I used but I like this writing, just a curiosity wouldn't tolower better be used in the if statement like if(tolower(text[i]) == 'c') counter[c]++
Undefine behavior doesn't just mean that the result of that particular operation is unspecified, it means that your *entire program* behaves in an unspecified manner. For example, it would be legal for a compiler to compile, #include &lt;stdio.h&gt; int main() { printf("Hello world!\n"); return 1 / 0; } into a program that prints nothing at all.
Yes, actually I did - 'a' to get the difference but for some reason it doesn't work for l and n letters... maybe I did something wrong
How could something like that be "compiler dependent"?
I already answered by chat because Reddit was down for a minute, anyways I did it after asking for it and wanted to edit my comment but I couldn't . I use tutorial point for some documentation because I like its descriptions. Thank you for answering anyway!
Enum are more like a list of #define that ensure that each elements in the enum represent a different number. They are not a structure, an array, in fact that code is not compiled, its juste a replacement of your code before compilation.
To give a slightly more concrete example, here's an example: CodeLengths = [3, ...]; Buffer.Data = [10, 20, 30, 40, 50, 60]; when `Index = 0`, it increments the 40 to 41. This is because `CodeLengths[Index] ` has value 3 so then you have `++Buffer.Data[3]` and `Buffer.Data[3]` has value 40 which you are incrementing.
VLAs are allocated on the stack, and are basically a standardized alloca() function (that was not a good idea). The problem is that you cannot know how much memory it will be allocated, and the stack is limited in most architecture. Also there are performance problems, because you cannot statically refer to variable allocated on the stack with the stack pointer. A lot of C coding conventions, especially in the embedded universe, but also in the Linux kernel, forbids the use VLAs.
On Windows, refer to the Microsoft Knowledge Base. Windows is a difficult environment for learning though, I recommend you to avoid it.
You're welcome. As other comments pointed out you could use isalpha to check if its a letter first and then increment the counter using offsets.
This subreddit is for C programming, not C-sharp. Try asking in /r/unity3D.
My example is less likely to cause a stack overflow than `char x[7];` Some coding guides forbid the use of pointer arithmetic ...
&gt;Thanks a bunch
They already told me that, I'm thinking about getting a live os so I can use it without installing or dual booting it since Windows is my first os for working purposes and my PC is a bit slow
Overflow of a static allocated array can be checked by the compiler, overflow from VLAs can only be checked at runtime. Thus for context like embedded systems where you really don't want to have runtime errors, VLAs are no good.
Wicked cool! Starred!
Disagree; e.g.. `for(int i = 0; i != sizeof x; ++i) x[i] = 0;` can be validated at compile-time regardless of whether x is VLA or not. (I'm assuming that when you say "static" you mean "non-VLA array"; the word static has a different meaning in C)
Ah, gotcha. Using string interpolation and relying on empty initial value here, as opposed to equivalent but longer code involving explicit conditional branching.
An RPC, PPM ray tracer, and 8080 VM would fit nicely there.
If you run Windows 10, you also have the option of installing WSL, which is a way to run Linux applications on Windows. This saves you the hassle of dual booting.
Note that this is not portable as the C standard does not mandate that letters have consecutive character codes. For example, this does not hold when writing code for IBM main frames as letters have disjoint character codes in EBCDIC.
No, the comparison is not helpful in understanding what they are, how they work, or why they are useful. See the replies by /u/OldWolf2 and /u/bumblebritches57 for a much better explanation.
Not really entirely sure if I'm correct with this because I hardly work with integer pointers but. &amp;#x200B; `int a = *(start + cmin);` `int b = *(start + min);`
Can you fucking not upload your source code as an archive on GitHub? By all that is holy do you know what version control even is?
As long as you stay within the memory allocated to your program, the OS will not complain. In this case, they are staying on their stack so they don't try to play in unallocated memory.
Sorry, I don't know.
I recommend putting the source code in GitHub, **NOT** on a zip file like what the fuck lmao.
I figured as much
Good Lord... Imagine the merge conflicts a single ZIP-file will spawn if working on a larger project...
Forgot what subreddit I was in, yeah it's not at all compiler dependent
No need to bully the guy around! Explain what‚Äôs wrong and why, and what can be improved!
That's what I'm trying to do, but as I explore the code it gets worse and worse, I'm instead editing the comment with tips instead of reviewing as I honnestly have no energy to go through another program BDSM session
Indentation is like that because of using tabs in vscode.
Then fix it. Or use something else. Because this just makes it unreadable. Also I can't compile your program. Add a makefile.
So on GitHub there is a single zip file. If you want to make the code viewable and properly versioned you should commit the individual files on their own to the repository rather than a zip archive. Also the README doesn't contain much info in it. It may be worth adding some sections about **what** the code accomplishes and **how** it accomplishes that so that other people reading the code don't have to dig through the source files to get an overview of the project.
/u/Garuda1_Talisman, OP is obviously new to this. You can be constructive without being an asshole.
nice! Might want to explain that when compiling as in your readme that the executable will be called a.out
Honestly, I'm just used to dynamically allocating arrays. you could totally statically allocate it tho.
Even though you are doing a great job explaining, adding comments like: &gt;Can you fucking not upload your source code as an archive on GitHub? By all that is holy do you know what version control even is? &gt;Kernighan would drink 13 litres of gasoline if he knew such code existed. &gt;drinks gasoline &gt;Then why on the holy K&amp;R are you labeling such obvious things but not labeling the most essential parts of the code? &gt;This isn't related to skill but common sense, what are you doing? Don't add anything constructive what-so-ever and are just plain insults. I don't care how smart you think you are, or how right you are, there's no reason to be an asshole to someone trying to learn about programming. You are no Linus Torvalds venting to his peers. You're just an average programmer talking down to someone who is just starting out. And even Linus' behavior is absolutely disgusting. With those remarks, YOU are a disgrace to this community. YOU are the reason why most beginners give up because of the toxicity of our programming culture. Even I may be a bit harsh in my response. I don't know you, you may be trying to be funny. But being an outsider just reading your comment, it doesn't sound like a joke and more of a "I'm having a bad day" response.
Compile using : gcc unmj_Demo.c unmajjan.c -lpng -o unmj_Demo -lX11 -lm
I never claimed I was any more than I am. I am neither good nor bad, I am simply myself and that's great enough. Saying I'm a disgrace though? I think you're being the exact thing you're criticising by doing so. OP should not feel insulted. If they are hurt by what a random idiot on the Internet is saying, they need some time outside. I am not attacking OP, I am not trying to acquire any self esteem by being a cunt, I am simply reviewing and commenting. The relevance of the comments is not on par with the rest though. Also, OP isn't asking questions or trying to learn, OP is sharing a project to help us make 2D games.
I do get what you're saying though: "don't be a cunt, it's free and better for everyone". But to be honest, I'm not perfect. I'm just like everyone behaving like a total piece of garbage at times. I think I am entitled to the right of behaving like this at times, even if I should strive for perfection, because just like OP, I make mistakes.
I also think people make mistakes and incorrectly behave at times. I'm human, I don't think I deserve to be called an ass hole especially after the time I spent pointing out problems so OP could improve.
"drinks gasoline" "Kernighan would drink 13 litres of gasoline if he knew such code existed." "This isn't related to skill but common sense, what are you doing?" The above is not very helpful when giving constructive criticism. Pointing out someones mistakes is great if it helps them improve, but bullying them and insulting them more often then not shuts people down and makes them not want to continue. I **do** think you deserve to be called an asshole because you are in fact acting like an asshole.
&gt;Saying I'm a disgrace though? I think you're being the exact thing you're criticising by doing so. I see what you're saying and trying to get at. But I don't think I fit that definition. The difference between you and I, is that you were giving shit to someone who wasn't giving shit to anyone else. I was giving shit to someone who was giving shit to someone else; defending, calling you out on your bad behavior. But that's up for debate whether or not I fit that definition; I'm okay with being a hypocrite if it means I can defend someone and change someone else's behavior for the better in the future. &gt;OP should not feel insulted. If they are hurt by what a random idiot on the Internet is saying, they need some time outside. OP has the right to feel insulted, because he **was** being insulted. &gt;The relevance of the comments is not on par with the rest though. You're right...so why add them? It's not something accidental that you *said* or you gave OP a funny look, it's something you purposely *typed*. The funny thing about communication via messaging/letter is you have time to think about what you are saying. Everything you say is on purpose and has some intent behind it. I'm sure you are a great programmer. And you are doing a wonderful job explaining to OP what to fix and the reasons why to fix it. I just hope that in the future, you're more professional about how you explain it (no extra insults). I wish you the best.
I used to use Virtual Box but it's too slow for my PC, is WSL better? I'll try this out before buying a new USB and getting a live os, thanks!
Thanks Buddy I really needed this
I see you have deleted your post. Please don't do this. The other users in here spent a lot of time helping you and by deleting your post, you deleted all that help you got. This is a huge disservice to all future participants with the same question. Be considerate and do not delete your posts after receiving answers.
I do not give answers to deleted posts. Do not delete your posts. Make a new post if you want to have answers. And then don't delete it.
Oh I thought it was unwanted looking at the downvotes so I decided to remove it since I also got a lot of ideas now. I'm sorry I know it's now irreversible... I have already thanked them all at least. I just didn't want to harrass people looking at the sub who are giving downvotes. Next time I'll keep it, sorry
np), my target is 999 challenges then get ready).
Yeah, I read your other comment, I'm sorry didn't mean to be selfish. Anyways I don't want to flood the subreddit for now, next time I'll make a post I'll keep it promised
I'm sorry for the downvotes. Beginner questions tend to get a lot of them because beginners are usually better served with following a C book to the end before asking questions that are answered in later chapters of the same book. Shouldn't keep you from asking though. Note that the users in this subreddit have no say about what is on topic and what is not. That's the job of the moderation team. And I can tell you that your question is perfectly on topic, though the way it was asked could be improved.
I don't mind if you post additional questions as long as they are on topic (questions about WSL might fit better into /r/windows or /r/linux). For your particular question, [this thread](https://www.reddit.com/r/linux/comments/8kkobo/ubuntu_1804_wsl_on_windows_10_is_it_any_good/) might be helpful to you.
That's very kind of you to be honest I felt a bit sad seeing my question with lots of downvotes so I thought it would have been better to remove it. I don't know how I could improve but I'll try to be more descriptive next time also I'll link to this post so anyone can look at it if it changes something, thank you for your compresion
Thank you for the link I think I'll find lots of info in the comments, thanks
I think the core problem is that you could do a much better job at describing what you want to do. You posted a question that indicated one thing, with code that didn't quite match what you described (with some ‚Äúand so on‚Äù lines where it was not entirely clear what you omitted). Then you posted comments where you explained how you actually wanted something different from what you asked in the question. When talking about programming, it is very important to be as precise as possible. Post a complete and exact description, including sample input and sample output. Show your code. Make sure the code you show can be copy-pasted and compiled as is without having to edit anything. You should remove anything from the code that is unrelated to the problem, but don't just write ‚Äúand so on‚Äù and omit code unless you are 100% sure that there is only a single way the code could be continued from there. The more time you spend working on your question, the easier it is to write an answer and the better the answers are going to be. I have no way to see your original question as it was deleted, but if you like, I can try to rewrite the question such that it is as easy as possible to answer. As a last note, it's always a good idea to read the documentation of every single function you use. The documentation is your friend and you should always have it open while programming. If you ask questions about functions that can be answered by reading the documentation, you are wasting everybody else's time and people start being less interested in helping you. If you read the documentation but didn't understood it, that's fine. Just mention this and cite the part you had trouble with. This way, other people can understand where you are stuck and can pick you up right there, giving you a quick and helpful answer.
I don't want to harrass you, you were very clear. Next time l'll be way more descriptive I just was half asleep after trying the code and a bit angry since I had not saved my old codes (the switch and the char) so I only wanted to see if there was something I was doing wrong since the char one didn't work as expected . I know it's a stupid apology but it's the truth I just wanted to understand what was going wrong. I started everything almost by myself by reading a book and doing some exercises so when something goes wrong I get a big angry. I think I will start everything from scratch and when I'll find a problem I'll come here only two days after so I'm more relaxed and thoughtful... for the documentation I'm reading a book for now so when I find a new function it gives me that but unless I encounter it I don't know it, mine was only a quick question that I later found out by looking it on the internet but was unable to edit. Anyways I learned the lesson, next time I'll keep the post up
No need to apologise and don't mind asking questions. I'm interested in helping all our participants in their journey of programming. I can totally understand your situation and I have been there many times before. My suggestion is: if you are tired, angry, and frustrated about some problem you can't solve, put your computer aside and fetch some sleep. The answer is usually going to be obvious the next morning and if it is not, you can now concentrate well enough to distill your problems into a well-asked question. I wish you all the best for your studies!
Well, summer is here
I think the instructions should have more detailed specs and include some sample input and output.
Ok I'll do it!
Yeah, that's a good point!
`s/sing/using/` FTFY
Eh, I don't mind getting downvotes. People are hugely entitled these days. They want something handed to them that "just works," but they aren't going to become great at anything with that attitude. The path to enlightenment is never an easy one!
I see you're new to Git. That's ok, I was too once upon a time. You don't need to compress the project into a zip archive. Github offers that feature automatically by allowing users to download your repo as a .git archive. Instead, within your project just run \`git add .\` and then \`git commit -m "A commit message"\` and push to github. No need for the .zip. Also, add a bit more to the README. Here's a couple of single file header libraries. Have a look how they do things: * [https://github.com/nothings/stb](https://github.com/nothings/stb) * [https://github.com/vurtun/nuklear](https://github.com/vurtun/nuklear) And here's a great place to learn more about Git: [https://try.github.io/](https://try.github.io/) Hope that helps.
Thanks! A lesson I learned early on (thankfully) is to get specs in sometimes excruciating detail and not leave much if anything up to interpretation. For calculator example, I would have written it to parse an input like `8+16`, which is different than your implementation. Both are valid per the instructions, but one is more advanced for a #2 challenge.
Binary search tree implementation. Just finished mine for a summer course. For sure a good way to practice pointers.
I highly recommend Pellas C. It's my favorite IDE for Windows development: [http://www.smorgasbordet.com/pellesc/](http://www.smorgasbordet.com/pellesc/) You can also use Vim, VSCode, Sublime and run CL and ML from the command line.
Maybe it's just me but I found Windows development with C to be much easier. I'm one of those strange people that enjoys working with the WinAPI's. But, I had been programming on nix machines long before I started on Windows. A great book for learning C on Windows is this one: [https://www.amazon.co.uk/Windows-softcover-Developer-Reference-Paperback/dp/0735663777](https://www.amazon.co.uk/Windows-softcover-Developer-Reference-Paperback/dp/0735663777) ... sadly it's no longer available but you can find used copies. Combine that with KNR, and maybe Headfirst C and you're good to go.
Here's mine: Write a function that accepts an n-D array and returns it's determinant. It looks simple but is quite complicated. Remember input array can be of any size 2x2, 5x7,9x11...... and values can contain negative,positive and zeros. Trying to write this since last year.
This is a great idea. If you polish it up the assignments a bit, you could publish it.
You cant take the determinant of a non square matrix though
The library is xlib based. XCB replaced about a decade ago. xlib isn't going anywhere do to legacy code, but you should avoid writing new code against it. Not sure what font you expect to be install, "free times"?, not something I've got install on either of the machines in front of me. Might want to stick with something pretty standard (if not one of the fonts X11 guarantees). You could crashes if it can't find the font it's looking for. I see memory leaks , unnecessary repeated operations, and use of uninitialized values. -Wall gives a LOT of warnings. Fix every warning, then test the code with valgrind to find where you're leaking memory and using uninitialized values that the compiler isn't catching. There is a lot of nitpicking that could be done with the code, but from the look of it you're just learning. Doing things like correcting warnings and testing for memory leaks (and understanding why the memory is leaking don't just fix the leak), are things you can do to improve your code and programming skills in general. Maybe wonder over to r/ProgrammingBuddies/ and find a mentor or at least someone with some experience to point out problems with your code one on one instead of publicly. Your code crashing if it can't find the font (which you leak and reload repeatedly). Not sure what font you expect, but it's not one I've got install on any of my systems. You're leaking memory. unmajjan.c:223 for example
Are you familiar with truth tables? Basically: and(0,0) = 0 and(0,1) = 0 and(1,0) = 0 and(1,1) = 1 or(0,0) = 0 or(0,1) = 1 or(1,0) = 1 or(1,1) = 1 nor(0,0) = 1 nor(0,1) = 0 nor(1,0) = 0 nor(1,1) = 0 xor(0,0) = 0 xor(0,1) = 1 xor(1,0) = 1 xor(1,1) = 0 not(0) = 1 not(1) = 0 Now imagine you have two numbers, A and B, represented as an array of bits: bit A[8] = ..... bit B[8] = ..... What `A&amp;B`, `A|B`, `A^B`, etc. mean is: bit *and(bit *res, bit *A, bit *B) { for (size_t i=0; i&lt;8; ++i) (A[i] == 1 &amp;&amp; B[i] == 1) ? res[i] = 1 : C[i] = 0; return (res); }
I've made changes, as suggested.
Enums are always int, then take care to use in structs for serialization, I got problems communicating with an Arduino, the sizeof of same struct was different on my laptop and the Arduino. For this I recommend you using stdint.h types to build the struct, then you can cast the enum value to the struct row.
[RPN](https://en.wikipedia.org/wiki/Reverse_Polish_notation) calculators are usually implemented with a [stack](https://en.wikipedia.org/wiki/Stack_\(abstract_data_type\)). Your program will loop over the user's input, breaking it up by whitespace. When a number token is identified (e.g. 55), you will *push* the number onto the stack. When an operator token is identified (e.g. +), you will *pop* the top two values from the stack, perform the operation, then push the result back on top.
Can you link to the example since that doesn't sound right.
I add the link. It says that the variables are mapped to the same cache line and this will cause many superfluous invalidations.
If I give this project to be done by my students and receive such source code as a result, I would be disappointed. You need to write this project without the use of the `system()` function. Would you writing this program for windows (I assume you're targeting windows by the use of the "move" command and not the UNIX "mv" one) or UNIX. You need to be able to add a new directory associated with new file extensions without modifying your algorithm code, but only adding new data in your program. Additionaly, I would add a new rule : add every file with an unknown extension in a "miscellaneous" directory. Print on the output the work done. Steps by steps, first part (I miss time) : 1) Write a program that list every files contained in a given directory (the directory path is given as the first command-line program argument). If the program is called without parameter, use the directory containing the program as working directory. Use the following functions (say me if you're not writing this program for windows, my bad) : https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-findfirstfilea https://docs.microsoft.com/en-us/windows/desktop/api/FileAPI/nf-fileapi-findnextfilea 2) Write a function that give you the extension of a file. Here is the function signature I expect you to write : int get_filename_extension(const char* filename, char* output, size_t output_size_max); // usage exemple : const char* filename = "c:\\x\\y\\z\\file.txt"; char extension[32]; if (get_filename_extension(filename, extension, sizeof(extension) - 1)) { printf("file extension is %s\n", extension); // Print "file extension is txt" } else { printf("oups...\n"); } This function should returns 0 if an error occured (extension size is greater that output_size_max). 3) Write a function that given a filename and an array of extensions says wereas the given filename match one of the given extension int match_extension(const char* filename, const char** extensions, size_t extensions_count); // Exemple const char* extensions[] = {"txt", "doc", "odt"}; assert(match_extension("my-file.txt", extensions, 3) == 1); assert(match_extension("my-file.png", extensions, 3) == 0); If you have a problem, just ask ! :-)
That might cause performance issues, yes. It's likely that the variables are placed right next to each other in memory, so if they are 16B each they're probably all in 1-2 cache lines on an x86-64 platform. The language spec does say a whole lot about where stuff is stored. Most compilers have a way of enforcing alignment on variables; you'd need to use that. e.g. for gcc: https://gcc.gnu.org/onlinedocs/gcc-3.3/gcc/Type-Attributes.html you could do: ``` static double s1 __attribute__ ((aligned (64))); static double s2 __attribute__ ((aligned (64))); static double s3 __attribute__ ((aligned (64))); static double s4 __attribute__ ((aligned (64))); ``` You could also do something like: ``` typedef struct { double val; uint8 _padding[56]; } t_cache_aligned_double __attribute__ ((aligned (64))); ... static t_cache_aligned_double s1, s2, s3, s4; ```
Thanks. It makes sense how to align them. But why does it cause performance issues?
Thanks.
Internally in the execution core, when it writes to a cache-line, it needs to lock the entire 64-byte line, so any other thread that also needs to write to the cache line, even in a different spot, is blocked. If all 4 threads write to the same cache line very frequently, you'll essentially be reduced to single-thread performance.
Would it be better if I don't declare the variables globally and declare them instead in the main function? Or will there be the same problem?
The problem becomes potentially worse since you have less control over var placement within the stack. Your only guarantee is to block off a large span of memory that you fully control, and manually separate your vars. /u/TheSkiGeek also has a method that uses compiler built-ins to help with alignment. In the end both strategies are the same, keep those vars separated so they can't possible be cached together!
Declaring stack variables has the same problem, essentially.
Thank you.
Sorry, there is another solution that maybe needs mentioning, but ideally you want your thread to update it's own stack, and then from time to time you perhaps update the globals. Like unless there is some specific reason why you need those variables updated constantly in global memory, then don't! The best solution for all threading is to, as best as possible, have each thread live inside it's own little bubble, not needing to ever read or write from outside of it.
Yes. This was only an example program for learning.
Thank you for giving me such a nice, concise explanation! If you don't mind me asking, how would you handle cleaning the stack after each operation? If there were more than 2 numbers pushed before an operator was found, you'd need to re-organize the stack, right? I might be thinking of the problem incorrectly, as I'm visualizing the stack as an array of numbers, of course starting at index 0. I imagine a linked list could handle that process a bit better, but I'm not sure if it would be considered bad practice to use one in this context.
Sorry about this, but I just wanted to add another reply to my previous one. I think I'm simply unaware of how to handle a stack in C. I'll look into how to implement that, as it seems very helpful to know. If you have any information though, that would be greatly appreciated too. Thank you so much for the help!
The cache line thing may be true, but I think this could be an example of the [XY problem](https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem). Nevertheless you could allocate the doubles on the heap to ensure they are far enough away from each other. In a real multi-threaded program though, the data that the threads work with most is on the stack anyway, so the problem won't arise (since the threads have separate stacks). Or if it's not on the stack, it's allocated on the heap (and the code takes care to use a mutex where there might be access from multiple threads). Anyway, here's one way to solve the problem you actually asked about: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; enum { MAX = 100000 }; enum { MAX_LIKELY_CACHE_LINE_BYTES = 64 }; pthread_t fail; /* must be set to thread ID of main thread. */ void *threadfunction(void *arg) { int i; double *var = (double *) arg; *var = rand(); for(i = 0; i &lt; MAX; i++) { *var = *var + i * (*var); } return NULL; } pthread_t create_thread(void) { pthread_t id; /* As our double is allocated on the heap, the address would * satisfies the system's maximal alignment constraint, but we don't * want to assume that that is greater than the system's cache line * size (for any of its cache levels). Hence we prefer * posix_memalign to malloc. Yes, it's likely overkill. */ void *p; if (0 != posix_memalign(&amp;p, MAX_LIKELY_CACHE_LINE_BYTES, sizeof(double))) { perror("posix_memalign"); return fail; } *(double*)p = 0.0; if (0 == pthread_create(&amp;id, NULL, &amp;threadfunction, p)) { return id; } else { perror("pthread_create"); /* return our own ID to signal an error. */ return fail; } } int maybe_join(pthread_t id) { if (id != fail) { if (0 == pthread_join(id, NULL)) { return 0; } perror("pthread_join"); } return 1; /* failed to join, or no thread had been started */ } int main(void) { pthread_t id1, id2, id3, id4; fail = pthread_self(); /* initialise this in main thread only. */ id1 = create_thread(); id2 = create_thread(); id3 = create_thread(); id4 = create_thread(); return maybe_join(id1) || maybe_join(id2) || maybe_join(id3) || maybe_join(id4); }
If you have C11 support, you can also use `alignas` for this.
You can ensure this by placing each one on a cache line on its own: #include &lt;stdalign.h&gt; alignas(64) double s1, s2, s3, s4;
Why do you use a enum for MAX?
I always forget they added some of the memory model stuff to C11 as well as C++11. That should be a more portable way of doing it.
Check out OpenCL.
Keep this alive please. I am on my second semester and we are doing C for all of the year and i gathered some tasks they gave us. They are for beginners (different calculators, binary operators, arrays,dynamic allocation,for/while loops, reading from and writing to files,recursion etc ).If you wont i can send them to you
In Standard C an enumerator is an `int`. Arduino is a non-standard variety of C++ however.
Thanks for the errata
Thanks for the errata
Something I think would benefit people learning to program are exercises that focus on program design and writing "full" programs rather than just writing algorithms. An example of this would be to write a checkbook program vs solving the n-queens problem. &amp;#x200B; These programs should have a UI (can be text/console) and perform some task that a end user would find useful and not just illustrate some aspect of writing algorithms. The exercises could have different levels of difficult/features. Taking the checkbook program as and example, it could start as a basic program that uses simple in memory data storage (array/structs) then have levels such as: &amp;#x200B; 1. add data validation 2. add formatted output 3. add the ability to data in a file 4. change from simple data storage to using datastructures 5. add the ability to sort data 6. add a better user UI 7. change external storage to SQLite 8. etc. &amp;#x200B; Not sure if this is a direction that would interest you, but I think that it would fill a void. There are tons of sites aimed at writing algorithms, but I haven't found any that aim at writing "full" programs and designing programs meant to be used by end users. To me, the prevalent approach to learning programming is like learning how to woodwork by building abstract objects that only illustrate how to use various tools, rather then learning by building useful objects like a bird house or a spice rack.
https://youtu.be/7ha78yWRDlE Watching this videk might help you.
Was about to say that. Use libraries. Interacting directly with gpu drivers will be more than horrendous
Or if you love NVidia, check out CUDA.
&gt; The library is xlib based. &gt; XCB replaced about a decade ago. xlib isn't going anywhere .. A very good reason to keep using it. It will work and keep working long term for a very very very very long time and thus not a valid reason to not use it. Otherwise we may shut down this whole subreddit and say "Python replaced C a long time ago and ..." sort of argument.
are you sure it isn't feasible to do it without this API, in case I just want to do some really basic things?
That API is implemented by a library. I'm not sure what you are looking for.
so the API is more like a protocol in this case?
Let me try it.
An API is a set of functions you can call with defined behaviour. The library is what drives these behind the scenes.
A struct using only fixed-width types still isn't guaranteed to have the same total size or layout because the compiler may align the fields differently on different platforms to optimize memory access unless you tell it to pack the struct.
check out CUDA ... best advice here.
Wrong place to ask. This is for C which works pretty much everywhere whereas the C# stuff is a Microsoft sad little lost animal that no one likes anymore. Sarcasm aside this is the wrong place to ask about C#.
It is technically possible to do that (make GPU do things) without that API (after all, Linux developers did this to some degree), but it is not feasible because the operation principle of these devices is so complicated you have to write millions of lines of code just to do the most basic things (like summing up an array).
r/csharp, where programmers go to die.
An API for something of this scope is necessary. It's not related whether you need to draw a vast universal landscape or compute the sum of two numbers, you'll need an API or library to give you functions to work with.
&gt; They provide constants, that are type-checkable by the compiler. that way you can reduce people creating bugs by using the wrong constant when they call your function. No. No no no no no. This is not what they do in C. typedef enum { ONE, TWO } First; typedef enum { THREE, FOUR } Second; void takes_first(First f) { } int main() { takes_first(THREE); // This is actually a Second takes_first(11); // Not even in any enum First f = FOUR; Second s = ONE; int i = TWO; } How is the compiler checking this? It isn't, because it doesn't. All enum does in C is make int constants from the identifier you give it. Any typedefs you do are typedefed to int, and since typedef in C just introduces a new name for an existing type then all enums are just ints. Not types that are like ints, not types that are compatible with ints, they're just ints. There is no typechecking because everything is an int.
The compiler Arduino uses, avr-gcc, is _nearly_ standards compliant as far as the language goes. All the basic language features are present and as they should be, this means ints and enums acts like on any other compiler. The compiler has nothing to do with your problem. The problem is that an int is different size on different platforms, and even possibly different endianness. Enums are just ints, after all. This is why network protocols are defined with a very specific size and endianness for each field. It's fine to serialize binary data from Arduino to PC, you just need to take care when serializing and deserializing to get the size and endianness correct. The suggestion to use fixed width types is not good enough, it doesn't fix the endian problem. This is also why Arduino's Serial library wants to do things in text, it avoids this entire issue which can be very confusing to a newbie who just wants to send some data over serial.
Depending on what "lot of simple tasks" exactly means and what performance you expect, I would recommend having a look at OpenACC. With OpenACC you just annotate your C code with compiler directives (like in OpenMP) and the compiler takes care of creating the GPU code. Would recommend PGI, although gcc's support for OpenACC is not bad either :)
I knew a guy who sent out 99 resumes instead and is now a very rich programmer.
r/lostredditors
And maybe unit tests to ensure correct input and output
CUDA is Nvidia-GPU specific.
At the end of the day, if you want to interact with the GPU in any fashion whatsoever you're not going to be able to do it with the C standard lib. You're going to have to delve into OS-specific calls, or use some kind of platform-abstraction library (i.e. SFML, SDL, OpenCL, etc..) Personally, I use OpenGL in production software that I'm developing and marketing on my own to do behind-the-scenes parallel computation. I hand-write vertex/fragment shaders that I hand off to GL along with the data in whatever form is convenient (i.e. textures, uniform buffers, etc..) and retrieve the results in a framebuffer object. Your best bet is OpenCL, if you want something that will run across just about any vendors' GPU. CUDA is specific to Nvidia and will render whatever your project is useless to anybody or on any machine that's not running an Nvidia GPU, which is more than half the PC laptops/desktops in the world.
In C++ the cast is required, but in C the cast can suppress errors. For example, if you forget to include stdlib.h, then your compiler will assume malloc is a function return int rather than void \*. Assigning int to a pointer will produce a warning, but casting int is perfectly valid and can hide that warning.
Is there any other way ?? :-\
I also recommend the OpenCL API. Its memory and task handling model helps to broaden one's view.
Perhaps add some Windows instructions? It's a little annoying since you have to download Visual Studio... alternatively there's the Cygwin+gcc route.
So basically c is a very low level language and that is being demonstrated here. Youre making a pointers and pointers need to have the memory allocated for it before it can place values into those memory addresses. So the way a linked list works is that you have a struct that has another struct as a reference (next) to the next struct in the list. Here we have a list of reviews and (for example) review 1 has a reference to review 2 due to the fact that its next pointer is referencing the address of review 2s struct and so on. Here basically what its doing in main is allocating the memory for the review. It first tells the compiler "hey, I'm gonna make a review" and sets it to null. The compiler sees that you then "makes a new review" by calling the function new_review_node(). In that function the memory is allocated for a new review. Then you place - with strcpy() - actual values into the memory address that you set aside. From the example they gave its not toally a linked list because they only created one struct. Theres no need to reference another because we have one. If we made another in main() them we would set one of their 'next' pointers to reference the other. If you dont understand some of this I would go review memory allocation: you NEED to know pointers in C. Look up pointers in general, malloc, calloc, free, and strcpy. Feel free to dm me if you have any other specific questions
If you have an NVIDIA card, I highly recommend looking into CUDA development. Much finer grain control of parallelism. Also, pick up the book Programming Massively Parallel Processors by Kirk and Hwu. It outlines lots of structures and design patterns for efficient use of GPU hardware.
So from what I can tell, after the first two lines of int main() `Review_Node *my_node=NULL` And `my_node=new_Review_Node();` Which allocate a new `Review_Node` on the heap with the pointer `my_node`, the next 3 lines, `strcpy(my_node-&gt;rev.restaurant_name,"Veggie Goodness");`, `strcpy(my_node-&gt;rev.restaurant_address,"The Toronto Zoo, Section C"); `, and `my_node-&gt;rev.score=3; ` dereference the `my_node` pointer and assigns its `rev` member variables. After this, `printf("The review node contains:\n"); printf("Name=%s\n",my_node-&gt;rev.restaurant_name); printf("Address=%s\n",my_node-&gt;rev.restaurant_address); printf("Score=%d\n",my_node-&gt;rev.score); printf("Link=%p\n",my_node-&gt;next);` dereference `my_node` to print out its `rev` member variables that were just assigned. Finally, `my_node` is `free`‚Äôd and the program exits. This is a linked list in that it the `Review_Node` struct has a `next` pointer that can be assigned to another `Review_Node`. It is, however, a linked list of length one since `my_node-&gt;next` is `NULL`. I hope this explains how this program works. Feel free to ask me any further questions you might have.
OpenCL
Give visual studio code a try with the C++ extension. Microsoft and the community are truly creating a beauty of a product. Also if you take the time and learn how to use VSC tasks you can set up some useful tools such as linters and memory leak checkers. (Once your comfortable with the language of course)
This displeases the Linus.
If you're using Windows 10, set up the Windows Subsystem for Linux. Google it if you're unsure what I'm talking about. Once you get it all set up, install gcc. If you decide to go with VSCode, the Terminal is built in. Make sure you use the WSL Terminal, not the Command Line Terminal. Run your program in the terminal with: gcc file.c After that you will see a file called: a.out in your directory. Run: ./a.out to execute your code. If there are any errors, you will see them either in the compile or execution phase.
I could not get GCC to complain about mismatched enums (Wall) unless they were pointers. As immediate its treated as an int is an int is an int note: expected ‚ÄòFirst *‚Äô {aka ‚Äòenum &lt;anonymous&gt; *‚Äô} but argument is of type ‚ÄòSecond *‚Äô {aka ‚Äòenum &lt;anonymous&gt; *‚Äô} 5 | void takes_firstp(First *f) { } So only half-useful for typing
Clang checks it.
I could not get GCC to complain about mismatched enums (Wall) unless they were pointers to enum-typed variables. As immediate its treated as an int is an int is an int. It'll still allow "illegal" values in the correct type note: expected ‚ÄòFirst *‚Äô {aka ‚Äòenum &lt;anonymous&gt; *‚Äô} but argument is of type ‚ÄòSecond *‚Äô {aka ‚Äòenum &lt;anonymous&gt; *‚Äô} 5 | void takes_firstp(First *f) { } So only partially useful for compile-time typing
OpenCL automatically utilizes CUDA if it's available on the current hardware, which is far superior than just hard-coding for CUDA and completely locking out Intel/AMD GPU hardware... and Intel HD gfx are nothing to laugh at, as someone who develops software that employs GPU for compute purposes. Intel HD is vastly superior for parallel compute applications than plain software/CPU, and should not be ignored as a valuable compute resource by just blindly adopting CUDA and only CUDA. OpenCL will make the best use of any available graphics hardware, period.
You could try [OpenMP](https://en.m.wikipedia.org/wiki/OpenMP). It‚Äôs primarily for CPU parallelism, but a call like #pragma target #pragma teams #pragma parallel { // Do Stuff} Will also enable GPU support. The library is often used in High Performance Computing.
Desktop link: https://en.wikipedia.org/wiki/OpenMP *** ^^/r/HelperBot_ ^^Downvote ^^to ^^remove. ^^Counter: ^^262430. [^^Found ^^a ^^bug?](https://reddit.com/message/compose/?to=swim1929&amp;subject=Bug&amp;message=https://reddit.com/r/C_Programming/comments/c3idq9/gpu_parallel_processing_in_c/errxmvr/)
**OpenMP** OpenMP (Open Multi-Processing) is an application programming interface (API) that supports multi-platform shared memory multiprocessing programming in C, C++, and Fortran, on most platforms, instruction set architectures and operating systems, including Solaris, AIX, HP-UX, Linux, macOS, and Windows. It consists of a set of compiler directives, library routines, and environment variables that influence run-time behavior.OpenMP is managed by the nonprofit technology consortium OpenMP Architecture Review Board (or OpenMP ARB), jointly defined by a group of major computer hardware and software vendors, including AMD, IBM, Intel, Cray, HP, Fujitsu, Nvidia, NEC, Red Hat, Texas Instruments, Oracle Corporation, and more.OpenMP uses a portable, scalable model that gives programmers a simple and flexible interface for developing parallel applications for platforms ranging from the standard desktop computer to the supercomputer. An application built with the hybrid model of parallel programming can run on a computer cluster using both OpenMP and Message Passing Interface (MPI), such that OpenMP is used for parallelism within a (multi-core) node while MPI is used for parallelism between nodes. There have also been efforts to run OpenMP on software distributed shared memory systems, to translate OpenMP into MPI and to extend OpenMP for non-shared memory systems. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Unless you are working on 3D graphics specifically the answer to your question is, "get this book and read it." https://www.manning.com/books/opencl-in-action Any other response is wrong.
Alternatively (next to OpenACC, OpenCL or Cuda), you could use OpenMP for offloading your code to a GPU. However, last time I tried it, it didn't work that well. And I'm not aware of any actual full implementations of openmp 5.0. Moreover, you'll probably have to recompile your compiler with openmp offloading support. https://bitbucket.org/icl/slate/wiki/Howto/Build_GCC_with_Support_for_OpenMP_offloading
don't worry too much about "such and such OS is better for programming c." it's all nonsense. any OS you're comfortable with will work just fine. you don't even need an OS, all you need is an internet connection to an online repl (like [https://repl.it/languages](https://repl.it/languages) ), a keyboard and your passion to learn.
thank you for the lengthy reply. i have a few questions, but i think i understand this a lot more. q1: Review\_Node \*new\_review=NULL;// so we have this line because the function new\_Review\_Node doesn't have any parameters right? and so the memory address is set to NULL so it can be set in next line? q2: new\_review=(Review\_Node \*)calloc(1, sizeof(Review\_Node)); is this whole line just finding a memory address that fits the criteria? q3: for the four line after new\_review, why are they there? do they have to be initialized in Review\_Mode in order to be changed in main()?
thank you too for the lengthy reply. sorry for taking so long to get back to you, i was actually still stuck on the same problem (sad i know). i have a few questions in case your answer is different from the other person who answered q1: Review\_Node \*new\_review=NULL;// so we have this line because the function new\_Review\_Node doesn't have any parameters right? and so the memory address is set to NULL so it can be set in next line? q2: new\_review=(Review\_Node \*)calloc(1, sizeof(Review\_Node)); is this whole line just finding a memory address that fits the criteria? q3: for the four line after new\_review, why are they there? do they have to be initialized in Review\_Mode in order to be changed in main()?
thank you i sent you a message but i think on reddit chat lol idk how to use this
[for loop] { if i%4 == 0 { printf(‚Äú%d‚Äù, i*i) else printf(‚Äú%d‚Äù, i) } Up to you to convert that to proper C
How is this better than directly spoonfeeding?
Why ya‚Äôll hating on me for actually answerig the question?
Generally, programming subs are overran with homework questions. Not that there's much wrong with that, but answering them with code doesn't actually help anyone. It inflates someones grade unfairly and they won't learn anything from it. Programming is about breaking up a problem, not about remembering a solution.
You didn't answer my question. You gave him the exact solution to his problem, how is this any better than you doing the entire test yourself for him? He won't have learnt anything and will only become more dependent on people because now he expects to just get ready programs here willy-nilly. That's not what this subreddit is for. As for OP, he also doesn't know how to actually ask a question properly, which he could've and should've done by reading the first and only sticky on the entire sub.
Tbh I‚Äôve learned more from stackoverflow than I have forgotten from books. Should stackoverflow be banned as well?
StackOverflow encourages answers *unlike* yours.
Unlike my what? But I guess I can agree that this shouldn‚Äôt be a homework site.
C# is off topic in this subreddit. Please post C# content to /r/csharp.
It's tricky, yes but I have tested the sizeof of the struct I am using in my AMD64 laptop and a Arduino Mega 2560, I was successfully serialized the struct, I have checked the sizeof but in the beginning I don't know this trick. Arduino have a function to fill a char vector with x bytes from serial, I have communicated and rebuild successfully the data on the other side. I think my struct is a bit huge (sizeof of it = 16). I will test with smaller sizes to achieve better results. I need to try it in a raspberry too.
Good to know. Thank you!
&gt;so we have this line because the function new\_Review\_Node doesn't have any parameters right? and so the memory address is set to NULL so it can be set in next line? That line isn't really necessary. You could write `Review_Node *new_review = (Review_Node *)calloc(1, sizeof(Review_Node));` and assign the result of `calloc` directly. &gt;is this whole line just finding a memory address that fits the criteria? Yes. `calloc` basically asks the operating system nicely to reserve a segment of memory that fits 1 element that takes up `sizeof(Review_Node)` bytes and then returns a void pointer to the start of that segment. The `(Review_Node *)` then turns ("casts") the void pointer into a pointer to a Review\_Node. Actually, the cast could also be removed because it is allowed to assign void pointers to any pointer variable without explicit casting. &gt;for the four line after new\_review, why are they there? do they have to be initialized in Review\_Mode in order to be changed in main()? You could leave the memory uninitialized and change it later. But if you did that, the Review\_Node would simply contain random data. In particular, the `next` pointer would point to some random memory location. If someone then appends a Review\_Node from this function to a list, forgets to set `next` to `NULL` (or some other useful value) and tries to iterate over the list, the program would crash with a segmentation fault. (Or, worse, the next pointer by chance points to some other variable in your program and weird stuff happens.) It's probably a good idea to set some sensible default values.
It's called a new language. Take a look at Crystal which is "C in Ruby syntax."
Nahh, check out Vulkan.
Guessing you're already familiar with `Cython`? Seems like a good place to start thinking about it.
Is there are reason you want to do this? I would start by clearly stating the reason why I want to do this and see if an implementation already exists that would fulfill my needs.
Or, you know, you could just use Clang which includes it by default.
How would you use Vulkan for computations?
Crystal looks like a full blown language. What I want to do is more like TypeScript. You write in one language, it gets converted to another language before the code gets used.
Isn't Cython a Python interpreter implementation with C? So it just does normal Python interpreter things but written in C.
Because I want to? It's a toy project, I'll be doing it just for the sake of it.
Good luck, then! I would start by reading on source-to-source compilers, since that is what you are basically going to do. Maybe look into some existing ones and see how they work? And if your approach is an academic one, maybe invest some time on reading publications about source-to-source compilers. It might give you an idea what has been done, has it worked, and what can be done.
This actually already exists, it's called [Genie](https://en.m.wikipedia.org/wiki/Genie_(programming_language)) I don't know why anyone would use it over Vala, but oh well...
Desktop link: https://en.wikipedia.org/wiki/Genie_(programming_language) *** ^^/r/HelperBot_ ^^Downvote ^^to ^^remove. ^^Counter: ^^262526. [^^Found ^^a ^^bug?](https://reddit.com/message/compose/?to=swim1929&amp;subject=Bug&amp;message=https://reddit.com/r/C_Programming/comments/c3ri6e/c_in_python_syntax_toy_project/ersr2ew/)
CUDA without a doubt if you have a nvidia GPU
You‚Äôre thinking of CPython, the reference implementation of the Python interpreter. Cython is a compiler superset of Python https://cython.org/
Typescript is a superset of JavaScript and transcompiles to Javascript, existing JavaScript programs are also valid TypeScript programs. C and Python could not be further apart. Python is interpreted language that is functional, imperative, OO, and reflective with dynamic typing. You could look at it's source code I guess as that's written in C?
Of course there's a difference.
&gt; Typescript is a superset of JavaScript and transcompiles to Javascript, existing JavaScript programs are also valid TypeScript programs. Yup. &gt; C and Python could not be further apart. But this point doesn't matter. I just want to borrow the **syntax**, to write a Python like code and then have to converted to actual C code before compilation. I gave the TypeScript example because how the TypeScript codes are compiled to JavaScript and then run in browsers. It's like saying cows are like dogs in the sense that they both are mammals. Saying it doesn't mean implying cows would make excellent guard animals or dog milk should be drank or made into cheese.
Damn, I thought they were the same for far too long. Maybe I can take notes from their Python-C compilation process. Thanks.
What is it you want to do?
I'm doing it for bragging rights, but it could make a great Bachelor's graduation thesis. Source-to-source compilation is not a phrase I've heard before, I'll surely check previous work.
You can write compute shaders using the Vulkan API. You would typically use their glslang tool to compile GLSL(OpenGL shader language) into a SPIR-V compute shader. There are effecting differences between the compute shaders you can write between OpenCL &amp; Vulkan. For example, I think(?) while in OpenCL you have access to these raw pointers, you can't use them in glsl. OpenCL is definitely more accessible than Vulkan. Much faster to get going with, especially if you are new. However, if you learn the Vulkan process, you'll cover a lot more about how the GPU works. Especially considering OpenCL abstracts this away into their own, general model. I'd recommend OpenCL to this person. But if anybody else reading really wants to get stuck in and has the time, consider looking into Vulkan:)
It's like saying dogs are like wolves and transposing one to the other is relatively easy and straight forward. That's Typescript and why MS created it, to add Type safety. You're saying dogs are like birds and the transposing is doable or straight forward. Good luck with that. Would like too see how that dog flies or is it a grounded bird, lol!
Would any of these work for you? https://github.com/kozross/awesome-c/blob/master/README.md#web-frameworks No personal experience with any of them, but the awesome lists are usually pretty high quality.
Assembler and virtual machine
For an 8080 CPU?
Yep yep.
Hey, if you dont mind that your program is not dynamic then you can actually actually precalculate the stack space and allocate an array in the fly
Vulkan has a Compute API, tho I'm not sure how far along it is. I used to think it was just OpenCL, but it's apperantly it's own thing that I'm excited for.
I don't quite understand what the intent of this post is. Do you just want to proclaim that this is a project you want to do?
Start by studying finite state machines and design a simple "processor" in a hardware description language like Verilog. Something that can move about things in memory, perform conditional jumps, and addition/subtraction. After that, you'll have a better idea of how to build a complete VM.
Those are two different names for the same thing, so there's no difference.
C18 is the informal name for the ISO C Standard (ISO/IEC 9899:2018) that was published in June 2018. It was tentatively called C17 and even sets `__STDC_VERSION__` to `201710L`, but wasn't officially published until 2018. So, no, there isn't any difference to the C programming language between C17 and C18. C18 itself is a bug-fix release, fixing defects in C11. With respect to compiler support, GCC accepts both `-std=c17` and `-std=c18`, and its documentation says: &gt; This standard is same as C11 except for corrections of defects (all of which are also applied with `-std=c11`) and a new value of `__STDC_VERSION__`, and so is supported to the same extent as C11. So, for GCC at least, there isn't even a difference (beyond `__STDC_VERSION__`) between C11 and C18.
If you're doing this to learn &amp; have some fun, then follow the other suggestions already provided. If you're looking to do actual long-term (1+ hour) computations, then the only real answer these days is to rent nVidia GPU's from Amazon or Google. For about $1/hr you can get access to NVIDIA Tesla V100 GPUs (up to 8 GPU's per computer), each pairing 5,120 CUDA Cores and 640 Tensor Cores. These machines have 8, 32, or 64 3GHz CPU cores, 64GB+++ RAM, 16GB++ GPU RAM, and there are Linux &amp; Windows images pre-installed ready to go with CUDA GPU programming. You are free to use whatever programming language and environment you want, but the pre-installed and set up images are great. A lot of people rag on CUDA because it's not "open &amp; free", but it's extremely cheap, extremely fast, and it is what most people use so it's extremely easy to find help. My over-all recommendation is to eventually learn it all though. Parallel computing, especially using GPU's, is tricky to learn compared to serialized programming we're all used to in C. It wont matter what API/library and hardware you end up going with, learning how to efficiently split algorithms up into chunks of work is your main goal.
API is google.com
I'm not sure, so take it with a grain of salt: Floats have around 5-6-7 decimals of precision in this scale. Maybe all the imperfections add up to this much of a difference?
We use CppUTest at my workplace (primarily embedded device code), and it isn't half bad. I find their macros to be better than Check or CUnit's.
I use CUnit because I like the intuitive interface.
If it's an entire struct you're serializing then there's something else you have to worry about: padding. In order to align struct members so they can be accessed quickly by the machine the compiler is targeting, the compiler may insert empty space between struct members. struct padding_test { char c; int i; } Between c and i, there is likely 3 bytes of empty space on a 32-bit machine. So even if you are serializing in binary, you should still do it field by field, or understand that that padding is there and account for it.
I wanted resources on where to start. I've never done anything like make an assembler so I wanted to ask for resources
Thanks for the tips!
Well, the thing is that C is very different from Python. For example, implementing Pythonic "for x in list" isn't possible without some intermediate type, because decayed arrays in C do not carry information about their length (it is basically just a pointer). Types also have to be inferred from somewhere as they are not present in Python syntax. There is more of that, like multivalue returns, namespaces, lambda,... It would be easier to do this the other way around - from C syntax to Python code. I am not discouraging you. Just pointing out significant problems.
I use check and cunit. I find both libs easy and simple enough to work with.
Do you just want to access the device directly? If so you'll be rewriting 80Mb of heavily optimized code (the driver). Having done some osdev, modern GPUs are some of the most complex and annoying devices to code for. It's not like what you're thinking (draw this triangle, put this pixel here, compute 2+2 and give me the sum) but closer to give me a region of memory, create a vertex (or set of vertices) of this shape to that region of memory, apply this texture, apply this post effect, do z-buffer calculations, memcpy this to the primary memory, render, flip buffer. All of this done through extremely specific bitwise commands and opcodes in a command ringbuffer with strict timing.
Psssst... if you know some Python, you can take a look at [my x86 CPU emulator](https://github.com/ForceBru/PyVM) written in pure Python.
For it at the moment my struct is an int64_t and a union of int64_t or two int32_t. Because of it I am worrying to reduce the size of the struct. I will try if I have time to polish because I can't go home with the physical part. It is for computer architecture class. Thanks for the advice.
I'm assuming you mean you use one on some projects and the other on different projects, not both in the same project, right?
I wrote an [assembler](https://github.com/PurePi/6502-Assembler) and [emulator](https://github.com/PurePi/Apple-II-Emulator) for the 6502 (specifically the Apple II), and here's what I did: First decide on the hardware you want to emulate, a CPU isn't any good without IO to interact with you. I found a manual of the CPU to learn about the instructions and how it functions. For the 8080, [This one] (https://www.google.com/url?sa=t&amp;source=web&amp;rct=j&amp;url=http://altairclone.com/downloads/manuals/8080%2520Programmers%2520Manual.pdf&amp;ved=2ahUKEwj_04rH-v3iAhUKCKwKHVv6BgUQFjAAegQIBBAB&amp;usg=AOvVaw2VlJmsiGm8CmFPmoi2flZK) looks promising. Using it I wrote a simple emulator for just the CPU, just hard coding an array of bytes for testing simple sequences of instructions. Once that was good I wrote the assembler to make it easier to write and test more complicated code. My assembler is probably pretty bad cause I didn't look for any help or guides, so you might want to do that if it gets difficult. Then I read the technical manual for the computer, which for the Apple II went into great detail about all of the interfaces and whatnot so it was pretty easy to implement. Check out [this file] (https://github.com/PurePi/Apple-II-Emulator/blob/master/src/memory.c) to see how I handled the connection between the CPU accessing memory and IO. Good luck!
Of course. I use check on my smaller personal projects.
How much experience do you have with C?
Intermediate. I mostly do opengl programming
I've had a pleasant experience with [Unity](https://github.com/ThrowTheSwitch/Unity) in the past
TeX sources: https://github.com/illinois-cs241/coursebook
Okay. So why I don't have a general resource on assembler development, the basic approach is very easy: write a parser that parses label, instruction, and operands. Then match the instructions and the operands against an instruction table to know what to emit. You need multiple passes to fix up all forward references.
PDF: [https://raw.githubusercontent.com/illinois-cs241/coursebook/pdf\_deploy/main.pdf](https://raw.githubusercontent.com/illinois-cs241/coursebook/pdf_deploy/main.pdf)
Thanks for awesome list, just started adding support for Meson in [facil.io](https://facil.io).
Needs a proper title.
I just wrote my own basic framework one afternoon.
Good stuff. Thanks.
Thanks for the response. The compiler basically forced me to do it that way because of warnings making me ad the dereference. I must have a typo somewhere causing it to do that. But not I've got the load function working, and the data persists. But I am back to where I started again re: performance. I am not passing the tests because it takes too long to run the 100,000 tests. While the new load function looks much nicer, similar to the one I pasted above but working, the real problem lies in the memory allocation for the check function. I still don't understand how to get the proper amount of memory without causing undefined behaviour. It takes between 5-7 seconds to run which is too long to pass. Just need it to be fast enough to pass. I'm not looking to break any speed records but totally stuck again back where I started in the first place.
I use this as well.
Was looking for a system programming resource. Thank you so much!
A recent project that kinda wraps C in a Rust like package is ZZ - drunk octopus. It deals with some aspects you'll encounter like header generation. Implementing a python to C transpiler/source-to-source will be alot harder though I'd imagine because you'll actually have to implement the classes etc. yourself and somehow infer the types (or compile not to primitives but rather PyObjects or smth).
If you have the time: read language implementation patterns by Terrence Parr. You don't need to do any cleanup. push: Set Array at Stack Pointer and dec stack pointer Pop: read Array at stack pointer and inc stack pointer If Stack Pointer reaches 0 either resize the stack or panic
Having UTF-8 support will not make everyone use fancy chars for math because it's a huge hassle and not efficient. You can use a plugin that renders != as ‚â† etc which goes a long way and could also make one that renders **2 as ¬≤ (in Python for example). I'm also using a plugin that can convert Latex code to corresponsing unicode to put into comments.
Nice material
Perfect resource, thanks
I'm not sure I understand what the compiler could be complaining about, you better take a look at the warning. There is nothing wrong in returning a pointer to some heap memory from the function. Considering the speed, I'd try making increasing the table width (like x10). If everything else fails, feel free to look at my solution (and please ask questions if you find anything at all unclear): https://dumpz.org/a7DswkNdW6ab
/r/csharp
sizeof is an operator damn it
this book will save my life for my final exam in operating systems next week.
Please, I need all of it, but I don't have 40k/yeah [https://cs.illinois.edu/academics/courses](https://cs.illinois.edu/academics/courses)
**memset** does not perform memory allocation, all it could do is overwrite memory locations incorrectly. The code though makes extensive use of a library NvFBC. I don't know this library, just basing this on what I read in the code. But it appears to be allocating memory for capture sessions end data encoding. Do you know how big the session is or how much memory it requires for the decoding operations?
The book looks good. Will it be possible to access the video lectures without an University login ?
GCC's (and clang's) -o option sets the output file name, so when you compile your main.c file with the line you mentioned, the executable created by GCC will be named main. a.out is simply the default output file name, so if you run gcc main.c you executable will be named a.out. The name a.out comes from historical reasons, which you should find easily by simply googling this name
An ‚Äúelse‚Äù function does not have a condition. Remove the condition behind ‚Äúelse‚Äù. You should study ‚Äúif‚Äù ‚Äúelse if‚Äù else usage.
Gotcha, but how come my code runs fine whether I have a.out or not? I‚Äôm still confused about that...
h &gt;= 1 || h &lt;= 8 is always true. Use &amp;&amp;
Because the name/extension of a file doesn't mean anything. They only exist to make it easier for humans to recognise. Computers don't give a shit. You can call in document.xlsx if you want and it will still be an executable you can run.
Understood, at least to a basic level. Thank you for answering all my questions!
C# is off topic in this subreddit. Please post C# questions to /r/learn_csharp instead.
Doesn't this depend on operating system? I was under the impression windows uses the file extension to determine whether a file is executable or not.
Clearly not. I'm sure there are good solutions there too, but it's not curated or reviewed.
Yes that is correct, this is operating system specific. &amp;#x200B; Windows works by checking the file extension of the file first, then Windows checks a table for the program loaded to work with that type of file extension. &amp;#x200B; Linux/Unix-like distributions treat files differently. All *regular* files or basically text files are opened through open() whereas for different types of files such as directories (on Windows called 'folders') the file is opened with opendir(). &amp;#x200B; To learn more about open() and opendir(), check out their respective man pages. You can either do man 2 open from terminal / command line or Google for the man page. Note that if you do it on your laptop, some man pages (e.g. opendir) may not be supported. In this case, Google it to read more up on them.
I don‚Äôt understand the question. a, b, and c aren‚Äôt guaranteed to be contiguous.
To add on a little bit to what /u/JerseyJeffCow said, `a.out` happened to be the default name for files generated in the `.out` format that existed on UNIX before the now dominant ELF format. The extension doesn't actually do anything since a file is a file regardless of it's extension on *NIX systems, but the particular name `a.out` generated by C compilers is basically just a historical remnant of the old behavior.
I hope you didn‚Äôt wait till the last minute because this one can be tricky as it uses recursion. What language and what are the program specifications?
This is both academically dishonest and in direct contradiction with the purposes of higher education. If you missed classes it is your responsibility to get up to speed with the missed content or make an arrangement with your professor. You are asking for help to cheat on an assignment. This is wrong. I strongly recommend you rethink your actions and do the work on your own.
Thank you for the additional info! I guess I‚Äôll just not worry about the file at all then
&gt; but the particular name `a.out` generated by C compilers is basically just a historical remnant of the old behavior. True, and for some trivia: `a.out` is short for "assembler output," and was from Ken Thompson's original PDP-7 assembler.
MacOS does not include gcc. you're using Clang. the correct command to use is cc.
You‚Äôre absolutely right. Thought a lot about it and I realised I have to work harder to make the assignment on my own. I just had a lot of trouble the last few months, but it‚Äôs never an apology to cheat. I‚Äôll delete this post and only write a new one, if I need help with my own source code. Thank you so much for putting me back on the right track.
thanks for offering your help. But I realised this post is not the right way to go. Cheating and wanting others to do my work is absolutely wrong.
Making an emulator is not difficult. * Make a struct that represents the entire machine state. This includes the value of every register as well as a big uint8_t to represent all the memory. This is pretty much laid out for you in the CPU docs, usually in the first few pages. All you have to do is rewrite it as a C struct. * Implement an opcode. Decode it by using bitwise operators and either a lookup table or a switch statement. Look at the docs very carefully and implement every function and addressing mode of that opcode. For example, for an ADD instruction you'd take the value in the argument, add it to the accumulator register and set flags according to the result. Be sure to read the docs very carefully, skipping one tiny aspect of an instruction means programs you run may mysteriously not work and it takes forever to figure out what's going wrong if an opcode appears to work, but forgets to set a flag, for example. * Repeat until all (or all needed) opcodes are implemented. That's pretty much it. I've done a few hobby CPU emulators before and it's a fun project. The one thing you'll need to find is good documentation, which for this chip I'm sure is not difficult to find. Another thing to look for are test suites. Other people who have written emulators have written programs that put every instruction through its paces, and checks the output of all of them. These are gold for people writing emulators.
I don't know this library either. And the API docs require more effort to get than I feel like putting in. The most likely answer to me, would appear to be you're not properly freeing resources. Presumably. Line 360: static unsigned char *frame = NULL; Line 409: grabParams.ppBitStreamBuffer = (void **) &amp;frame; //I assume this is allocating memory for the image? There doesn't seem to be any freeing of this resource. Each iteration of the loop allocates a new frame pointer, which never gets freed, and leads to your high ram usage. Maybe I'm incorrect in how the library you're using works but I'd look into this issue first.
 I'm not sure if this is correct, but you're trying to print a union which doesn't have a type. Try printing x.obj_1 instead as an unsigned integer.
Appreciate your efforts in answering my questions. The error is gone and the load function is now working. So that part is okay now. Looking at your solution though it looks like it takes in the name to search for and then prints either the name=number, or not found, immediately rather than taking in all the names and then returning all the name/number and not found-s at the end. Obviously I am still learning C, and reading other people's code is still a challenge, but does this pass the tests? I would think it should fail since this is not the correct output format, but I could be wrong :). Anyway, I think my issue is that I am allocating memory wrong and so the performance prob is caused by errors in the code re: realloc. So not that the paradigm is wrong, there are just bugs I don't know how to fix. I don't expect you to continually respond here so I'll try to analyze your answer and see if it helps. I've re-written this so many times that I don't want to abandon my version yet again so I might have to put it on ice for awhile until such time as I have the skills with realloc to figure it out. &amp;#x200B; Thanks again.
I'm still unsure how to fix this. I've re-written a bunch of it. In the `checkHashTable` I use `strlen` but it is on a str that comes from `scanf` so should have a null-terminator. I don't see where I am using `strlen` without a null-terminator. If you could tell me where the memory leak is happening it would help me alot since I am stuck at this stage and cannot move forward with help. Else I'll leave this until such time as I understand how to use realloc better. &amp;#x200B; Current demo: [Here](https://www.onlinegdb.com/SymXYPhyr)
The standard doesn't specify how the fields are laid out. Having said that if you specify the #pragma to pack them I believe all major compilers will pack the fields from the LSB first.
Love SDL, people don't realize how vastly cross-platform it is.
When you run stuff on an unix system the execution looks at the header of file that is marked executable. #! tells to use interpreted execution and a specific binary header xan tell that this one's going to be loaded into the memory and the respective location of initial data. So yes. Extension is irrelevant.
What operating system do you run on your computer?
GCC in MSDOS (DJGPP) used the default name A.EXE for this reason. Probably still do. Guess various GCC-ports to Windows for the same.
Windows: Visual Studio (Yes, get over it) Linux: Vim/Emacs/VSCode + Makefile Mac: Xcode Or Linux ones. If you want to do a somewhat portable project with GUI: Qt Creator
You could use GTK https://developer.gnome.org/gtk3/stable/gtk-getting-started.html
A lot of ABIs don‚Äôt even dictate how bitfields are laid out, so you‚Äôll get different results for different compilers on the same system. Some compilers will even let you switch between different layouts, so you can get different results for the same compiler on the same system.
I use vscode for actual coding and debugging these days. As far as toolchain goes, cmake is probably the most common cross-platform option. There are plenty of others though, so feel free to explore the space. The advantage of the cross-platform options like cmake and meson is you don't have to worry about maintaining make/xcode/vs build files individually.
I've had a lot of success recently with abandoning widget toolkits altogether. Instead I open a simple OpenGl context and just use one of the many primitive drawing libs like [nuklear](https://github.com/vurtun/nuklear) to draw what I need. If you want to use widgets, I would use the native kit for each platform. Abstractions tend to be slow and clunky. That means .Net and WinForms/WPF on Windows, Quartz 2D on Apple platforms, and GTK or Qt on Linux (here those frameworks aren't abstractions, they're the standard, though Gtk is more popular outside the KDE world)
I like to code in vim, would totally recommend it! Btw I use Archlinux
&gt; I understand that it is a lower level programming language and requires a complier unlike high level dynamic programming languages You seem a bit confused here. There is no connection between low/high level and compilation or interpretation. Swift, Haskell, F# are high level languages compared with C and all three are compiled languages, incidentally all three are also interpreted and can be used from a REPL. About your main question - you can use GCC or Clang with Visual Studio Code on all major operating systems.
&gt; If you want to do a somewhat portable project with GUI: Qt Creator With the *small* caveat that QT is a C++ library, technically you will have to use C++ or some bindings.
I have a 2015 macbook pro running macOS High Sierra 10.13.6
I think I‚Äôve used that to edit php.ini one time. I didn't realize you could write whole projects with it.
 else (h &lt; 1 || h &gt; 8); for (int i = 0; i &lt; h; i++) { get_int("Height:"); } This code does not do what you think it does. The compiler sees it as identical to else { h &lt; 1 || h &gt; 8; } for(‚Ä¶) {‚Ä¶} First thing, as noted already, `else` doesn‚Äôt take a condition. The `h &lt; 1 || h &gt; 8` expression is evaluated on its own, as a statement. Most compilers will warn about this because it obviously doesn‚Äôt do anything (and it‚Äôs vacuously true), and usually in imperative languages statements should at least pretend to do something, or explicitly &amp; descriptively do nothing like `(void)0`. You also have a semicolon at the end of that expression; if an `else` took a condition like an `if`, then that‚Äôd break things too. Throwing a `;` after the `if` condition‚Äîi.e., `if(x); {y}`‚Äîis treated as if(x) {} {y} because the single `;` is captured as an empty statement.
Low level programming lang like C, C++ etc are complied langs. Higher level dynamic lang like PHP, JavaScript etc are interpreted. How am I confused?
Android and iOS support?
You can compile Javascript and you can interpret C. The method of execution and the language are not interlocked
Yeah, https://discourse.libsdl.org/t/does-sdl-2-0-work-with-apple-ios-phones-and-tablets/20593/3 emscripten too
Nice.
Apple's xcode should do the trick. They should have a CLI C app template for you to start with.
Thanks you for your help - please refer to update above.
Thanks you for your help - please refer to update above.
I‚Äôm sure you can but my point was I‚Äôm familiar with higher level lang and I want to learn a lower level programming lang and I dont want to limit myself to programming for the web I want to fully u derstand all aspects of the computer.
I thought that was only for swift and objective-c? I can write C programs in there too?
What have tended to do for a long time is write the C parts as a console application and open that as a pipe using Tcl/Tk. Unfortunately, Tcl has a bit of learning curve. But never fear, the Brent Welch book is the best way to learn it. " Practical Programming in Tcl and Tk (4th Edition) 4th Edition by Brent Welch (Author), Ken Jones (Author) ISBN-13: 978-0130385604 " I expect you can do something similar in Python but I haven't used Python in this way. Python does not treat nonblocking asynchronous processing as a first class citizen; Tcl/Tk does. The downside is that the UI won't be very sexy. It may even have a 1990s aroma unless you spend some time on it. But it'll be cheap to make ( once you learn how ) . Note: If you choose to go this way, you will learn to fall "fflush()" frequently in the C program.
I can‚Äôt speak to the quality of C support (I personally use CLion for my C/C++ work, but it‚Äôs not free) but it‚Äôs there. It *might* take installing some extra packages, I don‚Äôt quite remember. For starting out, you would typically compile your program into an executable you run from the command line. In an IDE that should be as simple as clicking the ‚Äúbuild‚Äù/run‚Äù commands.
You can use some simple math: 175.99 / N = 1 175.99 - (100 * N) = 75.99 Solve for N.
Is this homework? char buf[10]; sprintf("%s", 175.99); printf("%c", buf[0]); printf("%s", &amp;buf[1]);
If you want to mess around with C easily, use an online compiler. Most IDEs are a pain to work with C depending on your OS. Eclipse sucks on Windows, Visual Studio is still a C++ compiler and you can't use the "dangerous" C functions without some tweaking, etc. https://www.onlinegdb.com/online_c_compiler
You are confusing high level with interpreted which is false. F# is a very high level language and it is compiled.
Please make it more readable. Do you have Discord? I would help you with it. sqbi#2735
Wrong sub
Notepad++ or just the basic text editor that comes with windows is sufficient.
What exactly is your problem printing them? Also maybe that should be: printf ("%#010x\\n", x.**obj_1**);
Why is the word "static" being used to describe memory that is allocated on the stack? "static" normally has a different meaning. Anyway, there are seven variables defined inside `main`: `count`, `age`, `initial`, `lastName`, `agePtr`, `initialPtr` and `tempPtr`. These variables are all allocated on the stack when `main` is called. Which variables were the three that you counted?
All 7 of the locally declared variables will be on the stack. But 4 of them are pointers. A pointer is distinct from what it points to. The memory(stack) used to hold the pointer is not the memory that the pointer points to.
I guess you aren't counting the pointers as variables. Pointers are just a special kind of variable, they 'point' to something else via an address, the value of the pointer variable is the address of that something else. But that value still needs to be stored somewhere, in this case on the stack. The pointer 'agePtr' is allocated some space on the stack and assigned a value of the address of the variable 'age'. The amount of space needed to store the address (ie, the size of the pointer variable) depends on the architecture you compile for, but will generally be either 4 or 8 bytes.
That is exactly what I was doing. In the textbook we were told that pointers are stored in heap, but I guess there must have been a specific circumstance for that scenario. Thanks.
I have no idea, I guess because Heap is dynamic, so the opposite is static. I counted \`count\`, \`age\` and \`initial\`. I didn't count the pointers because, like another comment stated, I didn't count them as variables for some reason. Or at least not as variables that were stored in stack.
You declared 7 variables. They're on the stack because you didn't put them elsewhere. The only thing here that won't be on the stack is the block you `malloc`'d. Its address will be stored in `tempPtr` on the stack, but its contents will be on the heap. `free` is for when the memory a pointer is pointing to was allocated on the heap, so you should use it before the assignment on the last line to avoid a memory leak. That assignment will cause `tempPtr` to point wherever `lastName` points, "losing" the address of the block allocated on the heap. `tempPtr++` will increment the address stored in that variable (essentially an integer with special meaning) by the size of its declared type (`int`). The assignment on the last line can cause confusing bugs or worse because you're pointing at data with type `char` as if it has type `int`.
Anything declared as a variable in a function (except static variables) ends up on the stack. To store something on the heap you would need to call malloc() to allocate some memory explicitly. It is of course possible to store pointers in memory allocated from the heap, but in this example everything is a local variable and therefore on the stack.
The pointers themselves are stored on the stack. However, the thing the pointer is pointing to could be stored anywhere in memory.
Pointers can point \*to\* memory stored on the heap, but the pointer itself doesn't have to be on the heap. When you use \`malloc\` it returns a pointer to memory in the heap, but in that code the pointer will be stored in a variable on the stack (\`tempPtr\`).
Pointers can store the addresses of things on the heap.
Appreciate the clarity. You mention static variables, but we were told that stack and static memory are the same. I'm guessing this is wrong because another user said so as well, but what is the difference? Most references I have come across say that stack and static memory are the same.
The stack is a form of statically allocated memory. By that I mean it is allocated at compile time rather than run time. Dynamic memory is the kind that you have to manage through calls to malloc, realloc, free, and is managed entirely at run time. Think of it at statically allocated memory is reserved by the compiler, it's size is fixed at compile time and can't be changed later. That doesn't mean that the address of items on the stack always stay the same, the stack itself is a dynamic structure that you, the programmer, don't get to control. The compiler reserves space on the stack for each variable but that doesn't mean that successive calls to a function will always allocate the same address for a variable. This is all different from a static variable however. A static variable is more similar to a global variable, they are stored in a different part of memory that is again decided by the compiler (not the heap) but isn't on the stack. Static variables are sometimes described as retaining their value across function calls, they do this by being stored somewhere other than the stack. A static variable is declared as static int age; The main difference between a static variable in a function and a global variable is that the first has a limited scope, that is it can only be accessed from inside the function where it is declared.
You're sprintf is wrong... unless that is intentional?
So, a static variable will "stick around" after the function is over, whereas a regular variable will be overwritten? If I called it in a function and made it increment from 0 to 1, every time I called a static one it would get larger, rather than the non-static which would remain as 1?
There is a function to do that, but in this moment I don't remember :( tomorrow I will give you the answer
Pretty much. A static variable would behave as you described. If a normal variable is initialised properly its value will be reset every time the function is called. For example int age = 1; would be reinitialised to 1 on every call to the function. If a variable is not initialised, eg int age; its initial value will be undefined. It is a violation of C to access an uninitialised variable, you will get a compiler warning at a minimum if you try. Since addresses on the stack are constantly being reused and you have no way of knowing exactly where a variable will reside on any call to a function, the value of an uninitialised variable will be whatever happened to be stored at that address previously. It could be absolutely anything, so you must always initialise (assign a value to) variables before using them.
Thanks for the help!
You're right thanks for catching it. It wasn't intentionally wrong but I didn't spend too much time thinking about it in order too just give OP some ideas to start from.
I've heard "static allocation" and "dynamic allocation" refer to putting things on the stack or the heap, too (although we were using C++ in those classes). afaik that terminology exists because: 1. The size of things on the stack generally has to be known at compile time, while the size of a block allocated on the heap can be determined dynamically at run time. 2. The relative positions of things allocated on the stack are also determined at compile time. These relative positions are "static" in that they can not (readily) be changed at run time. Where in the heap your `malloc`'d block will be allocated, on the other hand, is up to the OS to determine during the call to `malloc`.
A pointer is a variable that stores a memory address. Therefore, there needs to be memory allocated on the stack to store that memory address.
&gt; I have no idea, I guess because Heap is dynamic, so the opposite is static. Actually, there are three main storage types: - Dynamic: the heap - Automatic: the stack, what you (or your uni) seem to call static - Static: this is a separate zone of memory, and is where global variables, constants, and static variables go. Since those live for the whole duration of the program, they don't live on the stack or the heap, but in a separate section of memory (several actually, but that's details). &gt; Or at least not as variables that were stored in stack. The pointers themselves are on the stack, but what they are pointing to isn't necessarily. Pointers are just variables holding a memory address.
&gt; These variables are all allocated on the stack when main is called. They might be optimized out
The stack isn't allocated at compile-time .
My Mac had gcc out of the box...
Not on Windows
What do you mean by "optimized out"? Variables don't have any representation in the program unless they have a symbol (so, at the global scope, or as a function-local static variable), but values do. Those values can reside in registers or in stack memory at different points in time during program execution, depending on optimization levels and whether the compiler needs the value to be addressable through a pointer.
Good job on getting the loading sorted out! I do retract my advice on increasing the hashtable width, as yours (65k) seems big enough. I assumed it was like 100 or something. Considering the input/output format: my code will indeed process one word at a time, but you might want to think again about what do 'input' and 'output' mean. What does my program output? What is the expected output? What would happen if you were to pass the input from a file as opposed to stdin (console)? As a first step I'd suggest saving the example input sequence to a file and passing it to your executable using the '&lt;' operator (Google 'read input from file c' or something). As for does my code pass the tests - I've no idea - I am not registered on the site :-) Something like this sure passed the tests when I was implementing a hashtable for the first time a few years ago. Good luck and ask away!
I mean that there might not be any stack space set aside for the variable
https://idownvotedbecau.se/imageofcode
I think in newer standards of C, thread local storage is also another type of storage.
Psst hey, I found this laying around as reference material of course =) &amp;#x200B; &gt;!\* Towers of Hanoi!&lt; &gt;!Implement a program that will solve the towers of hanoi problem using stacks. The constrains are:!&lt; &gt;!\- (1): Only one disk can be moved at a time.!&lt; &gt;!\- (2): A disk is slid off the top of one rod onto the next rod.!&lt; &gt;!\- (3): A disk can only be place on top of a larger disk.!&lt; &amp;#x200B; &amp;#x200B; &gt;!Implementation:!&lt; &gt;!The =moveToH= function first argument \~disks\~ means how many disks to move from the \~from\~ stack to the \~to\~!&lt; &gt;!stack, since rule 3 does not allow us to place a bigger sized disk we need to use \~tmp\~ to temporarily place smaller!&lt; &gt;!disks when trying to move bigger disks.!&lt; &amp;#x200B; &gt;!The base case moves the value at the top of the \~from\~ stack to the \~to\~ stack. All other cases first move the entire!&lt; &gt;!stack of =n - 1= to the \~tmp\~ stack and then move the last remainder disk in the \~from\~ stack to the \~to\~ stack, and!&lt; &gt;!since the stack was originally ordered from biggest at the bottom and smallest at the top the last disk is the largest!&lt; &gt;!disk.!&lt; &amp;#x200B; &gt;!After this largest disk is placed we move the rest using the same function except that in the \~from\~ location we!&lt; &gt;!place the \~tmp\~ stack since that is where our disks currently are and our helper stack changes from being the \~tmp\~!&lt; &gt;!stack to now being what was originally the \~from\~ stack.!&lt; &amp;#x200B; &amp;#x200B; &gt;!typedef struct {!&lt; &gt;!s32 top;!&lt; &gt;!u32 id;!&lt; &gt;!u32 count;!&lt; &gt;!u32 size;!&lt; &gt;!s32 data\[30\];!&lt; &gt;!} Stack;!&lt; &amp;#x200B; &gt;!Stack CreateStack(u32 id)!&lt; &gt;!{!&lt; &gt;!Stack stack = {};!&lt; &gt;!stack.id = id;!&lt; &gt;!stack.size = 30;!&lt; &gt;!stack.top = -1;!&lt; &gt;!return stack;!&lt; &gt;!}!&lt; &amp;#x200B; &gt;!void push(Stack \*stack, s32 value)!&lt; &gt;!{!&lt; &gt;!if (stack-&gt;top &lt; 0) {!&lt; &gt;!stack-&gt;count = 1;!&lt; &gt;!stack-&gt;top = 0;!&lt; &gt;!stack-&gt;data\[stack-&gt;top\] = value;!&lt; &gt;!} else {!&lt; &gt;!stack-&gt;count += 1;!&lt; &gt;!stack-&gt;top += 1;!&lt; &gt;!stack-&gt;data\[stack-&gt;top\] = value;!&lt; &gt;!}!&lt; &gt;!}!&lt; &amp;#x200B; &gt;!s32 pop(Stack \*stack)!&lt; &gt;!{!&lt; &gt;!s32 result = 0;!&lt; &gt;!if (stack-&gt;top &gt;= 0) {!&lt; &gt;!result = stack-&gt;data\[stack-&gt;top\];!&lt; &gt;!stack-&gt;data\[stack-&gt;top\] = 0;!&lt; &gt;!stack-&gt;top -= 1;!&lt; &gt;!stack-&gt;count -= 1;!&lt; &gt;!} else {!&lt; &gt;!printf("Cannot pop from empty stack\\n");!&lt; &gt;!}!&lt; &amp;#x200B; &gt;!return result;!&lt; &gt;!}!&lt; &amp;#x200B; &gt;!void print\_stack(Stack \*stack)!&lt; &gt;!{!&lt; &gt;!if (stack-&gt;top == -1) {!&lt; &gt;!printf("Stack is empty\\n");!&lt; &gt;!return;!&lt; &gt;!}!&lt; &amp;#x200B; &gt;!for (s32 i = 0; i &lt;= stack-&gt;top; i++) {!&lt; &gt;!printf("%d : %d\\n", i, stack-&gt;data\[i\]);!&lt; &gt;!}!&lt; &gt;!printf("\\n");!&lt; &gt;!}!&lt; &amp;#x200B; &gt;!void moveToH(s32 disks,Stack \*from, Stack \*to, Stack \*tmp)!&lt; &gt;!{!&lt; &gt;!if (disks &gt; 0) {!&lt; &gt;!moveToH(disks - 1, from, tmp, to);!&lt; &gt;!s32 fromValue = pop(from);!&lt; &gt;!printf("Moving %d from Tower: %d to Tower: %d\\n", fromValue, from-&gt;id, to-&gt;id);!&lt; &gt;!push(to, fromValue);!&lt; &gt;!moveToH(discs - 1, tmp, to, from);!&lt; &gt;!}!&lt; &gt;!}!&lt; &amp;#x200B; &gt;!void TestToH()!&lt; &gt;!{!&lt; &gt;!Stack A = CreateStack(0);!&lt; &gt;!Stack B = CreateStack(1);!&lt; &gt;!Stack C = CreateStack(2);!&lt; &gt;!push(&amp;A, 5);!&lt; &gt;!push(&amp;A, 4);!&lt; &gt;!push(&amp;A, 3);!&lt; &gt;!push(&amp;A, 2);!&lt; &gt;!push(&amp;A, 1);!&lt; &amp;#x200B; &gt;!moveToH(A.count, &amp;A, &amp;C, &amp;B);!&lt; &gt;!printf("Printing A:\\n");!&lt; &gt;!print\_stack(&amp;A);!&lt; &gt;!printf("Printing B:\\n");!&lt; &gt;!print\_stack(&amp;B);!&lt; &gt;!printf("Printing C:\\n");!&lt; &gt;!print\_stack(&amp;C);!&lt; &gt;!}!&lt;
Fuck are your classmates on about? Not a single one of these is static. Static variables have a lifetime of the entire program and get allocated before main() is even called. Static and Stack are not the same thing.
In the same fashion as nuklear, there‚Äôs [raygui](https://github.com/raysan5/raygui). Those immediate mode GUI have the advantage of having simple API and few dependencies. It fits C rather well if you want to easily compile your project and share it.
I think there is an executable called gcc by default on mac for compatibility with other unix-like systems, but this executable is simply a symlink to clang
Variables are stored wherever they are stored. That's often on the stack, but it doesn't have to be. Pointers often (but not always) _point at_ an object which is on the heap. The bottom line is that where a pointer variable itself is stored, and what kind of memory it points to are completely separate issues. The pointer can be auto, static or heap allocated. The object it points to can be auto, static or heap allocated. Or the pointer might be NULL in which case it doesn't point to an object at all.
*number* in malloc argument is strange. Trick question ...?
idownvotedyourcommentbecau.se it's fucking stupid. You can clearly see what's going on in the code, it's trivial.
(1) there are users of this subreddit that are vision impaired/blind, have some consideration and empathy for them, (2) some users, like to copy/paste the code in their favourite setup and work based off tha Whether it is trivial or not is irrelevant.
It's definitely relevant. Why would you need to copy this code anywhere? The question had nothing to do with fixing errors. And second of all, do you really think a screenreader could easily read erroneous code, let alone code itself? I know you're probably trying to make the sub better, but linking to a site explaining why you downvoted someone just seems arrogant. Like, you don't even have time to actually answer the question, just downvote and say you can't be bothered because it's not text. And also, the website literally just mentions that it's bad for checking for errors. This guy isn't searching for errors, it's most likely from a textbook.
&gt; Why would you need to copy this code anywhere? Because I don't like to read text on backgrounds that blind me and are difficult to read. &gt; And second of all, do you really think a screenreader could easily read erroneous code, let alone code itself? Yes, vision impaired and blind programmers are versatile with such software and know how to use it with respect to any code. &gt; I know you're probably trying to make the sub better, but linking to a site explaining why you downvoted someone just seems arrogant. Actually it isn't, and it is commonly recommended to people pasting code. Again, the amount of code whether trivial or not is irrelevant. It's about courtesy to the users of the sub that you're requesting time to help. Again, I'll ask you to show some consideration and empathy to the actual users of this sub. &gt; This guy isn't searching for errors, it's most likely from a textbook. Frankly, don't care.
It still seems arrogant, though. Judging by how much you can type in a few minutes, it surely wouldn't have hurt to just type a sentence asking if the user could type out the code in the future. Linking a website, which doesn't really relate to the post makes you come across as an asshole. The website doesn't mention anything at all about visually impaired people, just that it's better for finding errors, which is not what this post was about. You could've actually explained, and not come across as an asshole, if you would've just written one sentence. Just mentioning the two points you said to me.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
What about eclipse on mac lol bc i already got it on my machine I use to use it for python
Im running macos i hate fucking windows
Huh. I just looked into it, you are correct! I tend to use `cc` on whichever platform for exactly that purpose (it being a symlink to wherever)
"Static allocation" and "dynamic allocation" are bad ways to describe both of these processes, since "static" has a very specific meaning in C that has little to do with allocating on the stack and the word "dynamic" AFAIK doesn't appear at all. Why not just call them "stack allocation" and "heap allocation"?
You should call this code out for being incorrect. Is `number` declared/initialized elsewhere? Why would you need to "free" a pointer that points to something allocated on the stack? Also, care to take a stab at what happens on `tempPtr++`?
7 variables, a pointer is a variable which stpres the memory location of the variable you want to access.
with the pointers, there are 1-8bytes in stack debending on address space and bytes(allocation) in non stack
I agree with you for clarity, but it's also true those terms are taught in some 100- and 200-level CS courses to describe the difference between compile-time and run-time allocation in a sense that's not *specific* to C. That's probably where OP is getting them.
change \`"r"\` to \`"rb"\`, that fixed the problem for me (running on Windows).
Can you post a complete working example? That code should behave as your described expectation, and adding the bits missing for a compilation, it also do that for me.
[This site](http://www.emulator101.com/) has a (almost)full tutorial for developing an emulator for Intel 8080.
That's compiler specific and outside the scope of the question.
Simple enough to hack. Functional enough to work with. I will be sure to use it for my projects!
Be the change you want to see instead of an insufferable jackass. You're not going to change the stray commenters who don't know your standards, so just shut up and do the transcription if you actually care about the visually impaired. Otherwise it is patently obvious you're just trying to complain for the sake of complaining.
this doesn't make sense
7.21.9.2: "For a text stream, either **offset** shall be zero, or **offset** shall be a value returned by an earlier successful call to the **ftell** function on a stream associated with the same file and **whence** shall be **SEEK_SET**."
Math should be used to extract the leading digit of any number. It's significantly faster than using a string function to render the number to a string, then extracting the first character out of the string array... 175.99 / 10 ^ floor(log10(175.99)) = 1 234.99 / 10 ^ floor(log10(234.99)) = 2 390.99 / 10 ^ floor(log10(390.99)) = 3 etc Thus the formula for extracting the first decimal of any decimal number is: double N = 175.99; char first_digit = N / pow(10, floor(log10(N))); Not only does it make perfect sense, it's a first year Computer Science problem!
This works just fine for me. [A working example](https://repl.it/repls/BurlyAwfulMonitors). Can you provide a complete program that give this result, please?
The most "IDE" use for C is Visual Studio Code on Mac and I find it to be powerful enough to have features that I like (such as heavy clicking a function call and having it open the appropriate header in a new tab, scrolled to the definition) but enough like a bare bones text editor to not require a 10+ second startup time or require a heap of byzantine configuration.
If you want to build good habits early, don't use the stock Windows text editor. You should be able to leverage features like auto bracket matching, auto indenting, variable suggestion, etc at any level of skill.
If you're doing Windows development there's the Win32 api.
I use Visual Studio Code on macOS over the stock clang and it works great.
That's perfectly fine! But you don't strictly need a compiler to do that. However, you *probably* want to have a local suite of tools available to let you do things like step debugging and viewing the assembler output of the compiler. On your platform of macOS, look into clang and LLVM as a debugger.
Either you got some of the terms wrong, or the book is full of shit.
Thanks, I'm interested to see what you do with it