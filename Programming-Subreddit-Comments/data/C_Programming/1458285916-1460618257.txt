I hope they add endian conversion that works nicely with stdint types, and lets you explicitly convert to little endian, the way the C++ stuff does. A type based thing would be neat to hwt typechecking protection, but portable canversions that wark on the explicitly sized typedefs wou'd be enough.
I don't understand your point. Why should that influence the type of an UTF-8 encoded string.
UTF-8 is supported already. What do you miss?
Why add this to the language when you can use a set of handy utilitiy functions [like these](https://github.com/fuzxxl/memf/blob/master/src/fiddle.h)? Overlaying buffers you got from a file over structures is a bad way to do things anyway.
The one thing I wish for is a standard way to deal with and detect overflow in integer types. Almost all CPUs have a carry flag, why not give the programmer a portable way to access it? Other platforms have to emulate that, but while subtle, it's not the most difficult thing in the world. And for the sake of all that is holy, remove annex K before it breeds.
Something like [Universal Function Call Syntax](http://ddili.org/ders/d.en/ufcs.html) would be comfy without changing the semantics of the programming language too far. EDIT: More literature http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4174.pdf http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4474.pdf http://www.drdobbs.com/cpp/uniform-function-call-syntax/232700394
So you're saying I have to write my own UTF-8 parser? I mean I'll do that if I have to, but I'd prefer not having to.
Well, yes, you have to. Why should the language supply functions that can be implemented in a portable fashion by the programmer?
Majority of embedded programming is done in C. C is my dominant language because of that. 
If you expect to stay in the practice of computing in the Linux environment, you will never regret learning about the C language and the system libraries and APIs. There's a reason that practically all of the other languages are themselves written in C (along with the Linux kernel itself...), it's the language which gives you access to all of the underlying facilities of the system. Consider learning it to be an effort at understanding the literal foundation of the system. 
The most disappointing thing for me when learning C was the fact that const int x = 1; x is not a constant. #define x 1 Is not typesafe. It would be awesome if we could use something like constexpr int x = 1; where x is a LiteralType. Anything following = must evaluate to a constant at compile time. Another thing, can somebody give me a good reason why to not add C++ like enum clases.
I concur - I don't want the compiler to magically allocate some arbitrary context for me whose lifetime I have to manage. Nor would I want the compiler to automatically manage that lifetime - there's other languages for this kind of stuff. 
Learning concepts is more important than learning a language. 
There are concepts such as memory allocation, buffer overruns, pointers etc. (lack of strings!) that are front-and-center in C. IMO Dealing with a computer so "close to the metal" gives one a deeper understanding of programming and computing that is not as easily attainable using a higher level language. I'd argue that spending years doing low-level C coding gave me a leg up on my peers who started their careers in higher level languages.
It isn't as hard as it sounds. Since you likely don't care about supporting every possible encoding, just utf8. Should type up a set of utf8 utils myself really (like ulen, ucmp, etc).
[source](http://en.cppreference.com/w/c/types/boolean).
is there a reason I can't use assignment operator with the string? also if i do this: scanf ("%s","abc"); how am I passing a pointer to the string? plz help:(
&gt;is there a reason I can't use assignment operator with the string? Because a string literal has type `char*`, but `abc[0]` has type `char[6]`. Assigning a string literal just assigns a pointer to the string in memory, but that's not what you're trying to do with `abc[0]`. It has its own location in memory, which you want to fill with the chars, which is what strcpy does. &gt;also if i do this: scanf ("%s","abc"); how am I passing a pointer to the string? Again, the string literal "abc" passes a pointer to that string's location in memory. I'm not sure why you would do this, though. In your original example, you passed `a[0]`, which, when passed into scanf, actually just passes a pointer to the beginning of the char array `a[0]`.
I have always only used C, for desktop apps and gamedev, and more recently have begun incorporating the use of some C++ conventions, like being able to directly = a struct variable without having to perform a memcpy about it. But that's as far from plain ANSI C as I stray from. EDIT: I also am self-employed, and good at what I do, because the whole 'getting a job' thing doesn't align with my goals in life (ie: spending more time with my kids, spending more time doing what I want and not what my employer wants, etc)..
You *could* do myStr[0] = 'o'; myStr[1] = 'n'; mystr[2] = 'e'; But I think it's pretty obvious why strcpy is better.
Yeah, the potential to subset the standard is a pretty exciting development. The tension between the very small machine market and the general purpose market has been a drag on C's development, IMHO. I certainly don't want to make the standard less useful for the small end; if that happens (as it arguably did in C99 in some ways) they'll either stay on an old standard -- effectively setting a lower bound for the language level of portable code -- or simply ignore the standard, which would be unfortunate. It'll be interesting to see how it plays out over the next couple years. If I had to guess, I'd say that C unfortunately (or not, depending upon your POV) is likely to ossify into a pretty static "very small environment" language. I hope not, but we'll see.
&gt; I can miss something, but could you please elaborate a bit on how I can make use of it or how should get advantage from that? It's mainly how to design Cross-Platform API-s in C. i.e. how to handle memory, how to design entry points, how to setup defines etc. Just general practices and examples for writing easy to use cross-platform libs. &gt; ... which does not seem to refer to interfaces in the "Java sense". AFAIR it was about linking against different implementations rather than using multiple implementations at runtime. It's more about code separation rather than "Java style interfaces". &gt; From what I see from your code and some snippets I have collected, to translate the same concept in C the way to go is to create a Device struct type with function pointers and then having some code populate the pointer references to some functions implementations? Yes, that is one way. I can remember some libs using global function pointers (bad if you want to communicate with multiple devices and with different "io"s) or linking at compile time to a specific implementation (bad because you are limited to one specific implementation, e.g. the book you linked). If you need dynamically change the calls then you need function pointers in some form or an other. Note for the actual calling and callbacks, I think SWIG should be capable of handling them. [1](http://stackoverflow.com/questions/4313004/registering-java-function-as-a-callback-in-c-function), [2](http://stackoverflow.com/questions/12210129/how-should-i-write-the-i-file-to-wrap-callbacks-in-java-or-c-sharp), [3](http://stackoverflow.com/questions/12210129/how-should-i-write-the-i-file-to-wrap-callbacks-in-java-or-c-sharp), it's a pain, but it's possible. Maybe using [JNI](https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaNativeInterface.html) will be easier, but I have no experience in that part, so you would have to experiment. Oh, I also realized that there is one more (obvious) approach, that doesn't require callbacks. typedef struct { uint8_t *input; int32_t input_length; uint8_t *output; int32_t output_length; } device_io; error device_write(device_io *device, uint8_t *buffer, size_t size){ } error device_tick(device *device) { process input ... } Basically, write the device logic such that the caller is responsible for writing data in and reading data out. It becomes just an "object" without access to IO. Then use SWIG to generate methods for inspecting the device state. *(Optionally have a callback to notify the caller that there is new data available.)* This avoids the complicated callback setup, but the binding has more responsibilities. &gt; ... "Interface" pattern ... It's an idiom. See [Software Patterns](https://csis.pace.edu/~bergin/dcs/SoftwarePatterns_Coplien.pdf) at 1.1 for Viljamaa citation, or if you have access to ACM see [The pattern business](http://dl.acm.org/citation.cfm?id=225917). If it's a "standard way of implementing something in a language" it's most likely an idiom.
I would do something like this: #define FLAG_FILTER_A (1) #define FLAG_FILTER_B (2) ...... if ( flags &amp; FLAG_FILTER_A ) { filter_a(); } if ( flags &amp; FLAG_FILTER_B ) ......... 
Ah, okay.
Please use the right reddit format for code, which is four spaces before the lines I believe you want to use a cast. This is done as follows: int i = 420; double di = (double)i; You have to watch out while using them though, because you can lose data while doing it, when you cast an integer to a char for example.
Can't you do something like this? #define x ((int)1) 
Completely true, that's why C supports libraries.
Just an assignment will do it int i = 42; double d = i; or double shrink(int i); double ret; ret = shrink(a);
My theory is learn as many languages as you can. I program in c every day, but learning other languages has only made me a better c programmer. C is good because it teaches you about memory and forces you learn techniques you may not have needed to solve the same problem in c++, Java etc 
I agree, but it isn't. So I guess this is our chance to recommend it to the ISO C WG.
Ah, so Window's command prompt was to blame after all. I'll have to play with it some more to find any other weird intricacies, or maybe just switch to Cygwin instead. Thanks for the helpful info and clarification.
That output makes no sense. Shouldn't the 97 come first? `^Z` has a special meaning in my shell (bash, it puts the application in the background), so that makes for a boring test. With `^D` I get "97 -1" ... with the caveat that I have to put in the `^D` twice (there's some special logic in the shell that I don't fully understand).
Enum classes are actually on [the list](http://www.open-std.org/jtc1/sc22/wg14/www/docs/PreLondon2016.htm). They do seem entirely in the spirit of C.
I'm assuming that you're looking for a means by which you can accomplish [this](https://www.reddit.com/r/C_Programming/comments/4avn9m/noobie_looking_for_some_help_with_a_school_project/). As such I would recommend following the suggestion from u/skeeto not only because it will give you experience with file I/O, but also because it is the most basic means by which you can access GPIO on the rPi, and as such doesn't require you to learn someone else's library (you could even make your own). If you're not comfortable with that, there appear to be a couple libraries made for this [here](http://www.airspayce.com/mikem/bcm2835/) and [here](http://wiringpi.com/), though I feel obligated to mention I've never used them. If I've misunderstood and you're looking for a means by which to capture keyboard input, you may want to consider [ncurses](http://www.gnu.org/software/ncurses/ncurses.html). Regardless of which way you intend to capture input, you may want to consider working on what I would consider the meat and potatoes of your piano simulator: output. I mentions this for a couple reasons: 1. There are a number of options available for outputting sound; just of the top of my head: do you want to generate simple sine waves with a key press, or do you want to play pregenerated sound files (like .wav or .mp3 files). The former may provide a wider degree of freedom, but may take longer to implement depending on how many options or effects you want. The latter on the other hand would require you to make files to play on user input, but if you generate a few different sets you can cut down on implementation time and still have a fair amount of options. 2. By implementing sound generation separately from input you can make a more modular project, possibly even allowing the user to decide on input (GPIO vs keyboard) and output (different effects). This is not only a good general practice in programming (complexity stemming from coupling simple parts) but I see it as particularly useful here because it allows you to progress meaningfully in the project with tangible results (you can make a test implementation of your output library to show that you can generate sounds in general, and then later add input events). I know that to some extent this is my opinion in regards to software design in general, and if you or others disagree I'll understand. As a final note, if you are completely clueless on how to proceed with a given programming problem I recommend trying first and then asking for help while showing code that isn't working and describing how it's misbehaving. This is not only a valuable experience for you as a student because it teaches you to think programmatically, it is also a valuable experience for us as teachers because it demonstrates the problems you're actually facing, and that we need to address, as opposed to giving you the answers. I hope that I haven't misunderstood anything, but more than that I hope I've helped!
I would approach this as follows: I don't know what order you would like to apply them (perhaps this time a,c,d and some other time, b,a,d,c) or the number of times (a,b,a,c,a,d) I would use a string where 'a' means run filter a(), 'b' means run filter b(), etc. Then my main loop would be: char *filter = "acdbab"; char *p; for (p = filter ; *p ; p++) { switch(*p) { case 'a': a(); break; case 'b': b(); break; case 'c': c(); break; case 'd': d(); break; default: assert(0); break; /* handle however */ } } That way, adding new filters is easy, and it's easy to run them as many times as needed in any order as needed. 
it's a data structure with a constant time of execution... but I didn't realize how can I apply it to my problem...
You need to use a hash table for values that give back keys. Get rid of your binary search, and go through the vector one index at a time and do a validity check. Hopefully you can now figure it out.
thank you so much... i'm trying, but i'm such a noobie em c, i don't know how to do it &gt;.&lt;
I think he's suggesting you figure out *which* data-structure is it.
You don't need any additional data structures besides your sorted array. Now, the desired run time must be O(n), so that means you can only scan through the data a constant number of times, and thus you can't use your current strategy of searching for the number that would give you the right sum, as no possible search strategy can guarantee constant time on the list directly. So as a result, you should probably just scan the list with 2 indices. Let `i` start at the begging of the list and 'j' start at the end. Now compare `a[i] + a[j]` to `x`. if the two are equal, then you've found the pair. Otherwise, if the sum is greater or less than the total, how should you adjust `i` and `j` ? How do you know if there is no solution?
Apparently there's a 2 article limit? Looks like I'm gonna read it from archive.org.
temp2 is a 'node1 *', but endk-&gt;next1 is a 'node *'. You have to change struct node1{ int data; int countn; struct node *next1; } to struct node1{ int data; int countn; struct node1 *next1; }
Picking that initial pair of `i=0` and `j=len-1` is key to the solution, any other and it would be hard to define the step-by-step adjustment.
&gt; But it's also possibly broken code that relies on a deprecated, obsolete feature. The standard even says that! It's not a silent change: any attempt to call void f() with arguments will result in a diagnostic. The solution is relatively simple in the vast majority of cases: add the appropriate parameters to the prototype, a practice that has been encouraged for all new C code for nearly 30 years, and it's likely to fix more than one bug along the way. A tool might even be able to automate this. The C language has always been developed to break as little code as possible. Removing the implicit `int` rule was a big mistake already. They should not go any further. &gt; For those rare cases where it's being used purposefully, I'll admit the fix is a bit harder. For that reason only, I might be able to support some sort of syntax that could be used instead to explicitly state intent. void f(...) is taken, but I can dream of some potential options (like [[ unspecified_parameters ]] if C brings in C++-style attributes). So you want to make it impossible to write code with K&amp;R-declarations that compiles both with a C99 and a C2X compiler? Do you recall the time when all projects used a `PROTO` macro to be compatible both with K&amp;R and ANSI compilers? Do you wish that time back? &gt; nullptr A reserved word named `nullptr` couldn't be introduced anyway due to the compatibility rules. &gt; You just omit it, it's the default anyway. Be honest: when was the last time you actually wrote auto in a line of C code? Last year in a safety critical project where the coding style mandates to explicitly write down the storage class in every declaration to make sure it is not actually forgotten. `auto` has a reason to be and it's a damn good reason. &gt; changing its meaning would be a lot easier to justify. It's meaning is never going to change. The C committee did a lot of questionable things but they never changed the meaning of things beyond clarification or rectifying obvious mistakes in the specification.
So you want that C implementations for platforms with 64 kB RAM are forced to supply an implementation of something that needs more than 64 kB of tables?
Nothing, but the APIs are sorta broken and hard to use.
It's also possible to use: char a[6][6] = { "one", "two" }; 
Would `i * 0.5` count as a fifth solution? ;) At least in the distinct past, multiplication was always significantly faster than division.
&gt; then why does this work There are three circumstances where a string literal is treated as an array (which it actually is!), not a pointer: &gt; Except when it is the operand of the `sizeof` operator or the unary `&amp;` operator, **or is a string literal used to initialize an array**, an expression that has type “array of type” is converted to an expression with type “pointer to type” that points to the initial element of the array object and is not an lvalue. Translated from Standardese into English: 1. `sizeof("Kernighan")` is 10, not `sizeof(char*)` 2. `&amp;"Kernighan"` is a `char(*)[10]`, not a `char**` or a `char*` 3. `char s[] = "Kernighan";` copies a `char[10]`, not a `char*`
While it would be very unlike C for a feature like this, anonymous functions could be made very convenient to use if there also was a minimum amount of type inference e.g. char *strings[N] = ... qsort(strings, N, sizeof (char *), (const char *const *lhs, const char *const *rhs) { return strcmp(*lhs, *rhs); }); where the return type is inferred from the `qsort` parameter type `compar`, and `lhs` and `rhs` are implicitly cast from `const void *` in this case, or could be automatically cast to a compatible pointer type. If you didn't need to cast the parameters, then their types could be omitted and inferred.
Returning a string from a function is not trivial in C. You have three choices: 1. Have the caller pass in a char array that is big enough (idiomatic C) 2. Return a pointer to a static char array (same buffer is shared across calls) 3. Return a pointer to a dynamically allocated char array (caller must remember to free it) Here is an implementation of choice 2: #include &lt;stdio.h&gt; unsigned int labelNumber; const char * getLabel() { // enough space for L@ and 20 digits and NUL static char buffer[23]; sprintf(buffer, "L@%u", labelNumber++); return buffer; } int main() { puts(getLabel()); puts(getLabel()); puts(getLabel()); } But you would probably be better off implementing choice 1, because that's what C programmers are accustomed to.
To answer your second question, you can exit the program straight from the switch statement: switch(flag) { case 1: a(); exit(EXIT_SUCCESS); case 2: b(); exit(EXIT_SUCCESS); .... Or maybe better is to pack your switch statement inside a static function and `return` from within the switch statement: static void switchme(int flag) { switch(flag) { case 1: a(); return; case 2: b(); return; case 3: a(); b(); return; } } switchme(flag); exit(EXIT_SUCCESS);
I *am* using C++, quite often just because it has standardised lambdas (I already mentioned that). Besides, it could be optional like the many things in C, e.g. VLAs, threads and atomicity, complex number support etc.
Why don't you use pthreads? That's the standard API. C11 threads are basically castrated pthreads with everything removed that isn't possibly on every obscure platform. Pthreads, not C11 threads is the industry standard API you should use.
I could get behind that idea too.
Interesting! So let me get this straight, you want us to solve these challenges then push them to the repo? That way there's a collection of solutions. That's my understanding, correct me if I'm wrong! 
This is really neato and a good way to learn Github and programming concepts by actually *doing* rather than just reading/watching, or especially procrastinating. Also a question for clarification, are you accepting multiple solutions of the same problem done in the same language? Do they have to be different implementations of the same solution, or is there a limit at all?
I'm accepting multiple solutions of the same problem done in the same language (PER person). So...if you see that a totally different person submitted a solution in C for a specific challenge, you can still submit your own (assuming the implementations were different). 
 // write data to file type by type // Why do I not need a **f and a **wString here? I am manipulating their values here // just as I am manipulating the ints. Since they are just ints they become int* // but the file *f stays *f and it works just fine. Same as wString. void write_data_to_file(FILE *f, int *wInt, double *wDouble, char *wString, int n) { f = fopen("test.bin", "wb"); void main() { FILE *f = NULL; write_data_to_file(f, &amp;wInt, &amp;wDouble, wString, n); After main's call to write_data_to_file, main's local variable `f` will still be NULL. write_data_to_file has a variable also called 'f'. It has the same value as main's since it is a parameter to the function, but when write_data_to_file alters `f` it is altering a local variable an not affecting main's f at all
If you're going to allocate the memory, you don't need an array, you need a pointer: char *testPtr = NULL; When you call your function that does the allocation, you pass the address of your pointer: doSomething( &amp;testPtr, ....... ); Or, better yet, have your function return the allocated pointer. char *doSomething( void ); ...... testPtr = doSomething(); if( testPtr != NULL ) { ........ } Later, you'll free it: free( testPtr ); testPtr = NULL; 
I created it as an array because my teacher told me to do it like that. I know that I can use it as a pointer but he said to use an explicit array definition so we don't get confused. I tried doing that thing you did in your example code returning a pointer from the function. It's actually much more flexible like that and I don't have to reduce levels of indirection with *s everywhere but I wanted to get the way of doing it with pointers to pointers. About the freeing - I remember I have to do it every time I allocate with malloc, calloc realloc etc. because the system only frees the data it allocates itself and doesn't touch the things that I allocated right? &amp;nbsp; Just to make things clear - what you did with sending the address to my pointer to a function. That results in a **testPtr in the function arguments right?
In C, arguments are passed by value (as opposed to passed by reference). What this means is C will make a copy of all of the arguments being passed into a function so that the new function will only modify the copies. To get around this (ie - to allow the function to modify the original variable and not just the copy), you need to send the *address* of the variable that you want to modify. Therefore, if you have an int, and you want to modify the original variable, you have to pass the address of the int (ie- &amp;intVariableName) into the function so that the function can *dereference* the pointer and have access to the value that's being pointed to (ie - the actual variable's value). In the case of a char\*, the value of a char\* is *already an address*. So if your aim is to modify the characters that a specific char\* is pointing to, you can simply pass in the char*. Also, lol, sorry about using 'ie' all of the time. It's hard to convey tone via text, but I'm just trying to be clear and am not trying to be patronizing! If you want, I can give you some examples of when you might use a char** over a char* if you think that will be helpful.
So arrays are pointers in their core but their memory is already allocated. If you put it like that I get it. I have read that I can't use malloc on something that's already allocated. But I can use realloc right? It just takes the initial memory and copies it to a new place with a specified size.
See the Sidebar -&gt;
Ok I just tested what you said and it's true - I can actually modify the value of the array without sending it as a pointer to a pointer. I tried allocating memory to it without it too - didn't work. So I guess I need it because I am *modifying* the pointer to the char pointer, since malloc returns a void*. Do I make sense? Did I get how it works? &amp;nbsp; Oh and what about FILE then? If I understand correctly it's a pointer just like a string(char array) is. It is already an address too but if I try to modify it by just sending the pointer itself it doesn't work. Instead I have to send &amp;theFile which results in **file in the argument place. &amp;nbsp; EDIT: some example might prove to be really helpful yeah.
Oh yeah that's right. Then the only option for dynamically allocating memory to an array is to first create it as just a pointer. Thanks for clearing this up for me!
**This is my code that is trying to initialize this data file http://imgur.com/goNdas3 which when i print it out, it appears to be done correctly. However when i try to print out the first line it works, but the second line is off, I'll show the terminal output here http://imgur.com/4C7ZMoe** char i,j; int flag; char array[102][80]; flag = 0; for (i = 0; i &lt; 102; i++) { for(j = 0; j &lt; 80; j++) { if(scanf("%c", &amp;array[i][j]) == EOF) { flag = 1; break; } printf("%c", array[i][j]); } if (flag == 1 ) break; } for (i = 0; i &lt; 80; i++) { if (array[0][i] != '\n') printf("%c",array[0][i]); else break; } printf("\n"); printf("key: "); for (j = 0; j &lt; 10; j++) printf("%c",array[1][j]); printf("\n");
I misread that the vector was sorted, no wonder people didn't like my solution.
Pick the first one!
First one is free too!
ah~! it worked, i really appreciate your help this has been eye opening. what did you mean about posting plain text and what did i do wrong? thanks
yeah silvian understands my question, so the only solution would be instead of creating new variables and having them stored afterwards I would have to store them in an array and then accessing that?
Fabulous idea!!! would love to participate. 
yeah thats what im trying now just having issues with other things now :( 
When you reallocate memory, you aren't adding extra memory to the end of the memory that you've already allocated. What you're doing is setting the pointer to point to an entirely new chunk of memory that is of the new, appropriate size. SO, if you have a function that reallocates memory, if you pass in just a pointer, the function will create a *copy* of that pointer (ie - a totally new variable that has, as it's value, the same address that the original pointer was pointing to), and then set your copied variable to point to the reallocated space but not modifying your original pointer at all. Does that make sense? SO, if you want a function to change the *value* of a pointer (which is just a number - ie the address), you have to pass in the address of the pointer. And I guess that's the moral of the story. If you want any function to change the value of any outside variable (a variable that you are passing in), then you have to pass in the variable's address, otherwise it will just modify a copy. So, knowing that the value of a pointer is just some address, if you want a function to make your same pointer point somewhere else (like to a new chunk of memory), then you'll need to pass in the pointer's address. Another way to do this, however, could be to have the function simply return a pointer, and then you can set your pointer equal to that. **Ok, example time!** **Ex 1)** Let's say you wanted to maintain a list of words. In C, a good way to do that would be to have an array full of char* (ie - think about the argv parameter in the main function). In this case, you are going to be passing a char** around in your functions, if you want to have access to the entire, original list. **Ex 2)** Let's consider a function that read's a line from an input file, and wants to store it somehow. There are a few strategies I can think of to do this. * Possibly the most straightforward way would be to create an array of length BUFFER_SIZE, and then pass in both the array *and* the BUFFER_SIZE into the function. This way, the function can just copy the line directly into your array without worrying about overflowing, and without allocating any memory on its own. * Another way would be to malloc the memory for the line inside the function, copy the line into the malloc'd space, and then return the pointer that is pointing to that space. That way you still have access to the modified memory. In this case, you are going to have to remember to free the pointer on your own, however. * Thirdly, you could pass in the address of a pointer (ie - a char**) into your function, malloc the memory and copy the line over like before, and then set the dereferenced value of your pointer equal to the malloc'd memory. You are still going to have to remember to free it like before, however.
Building off of an answer provided by u/slivian: You *could* use `malloc` and `realloc` to allocate memory for an array and then add more space for it in the loop as needed. This can be an easy way to store a previously unknown number of variables. Unfortunately, these operations are expensive, and using them for each iteration of the loop can drastically slow down your program. A good compromise is to count how much of your array is filled and using `realloc` to expand it once it's full. Remember to `free` your array once you're done. Hope this helps!
Possible AWS-related issues: 1. AWS firewall config 2. If you're sending broadcast datagrams the AWS gateway won't forward these because there's no direct link layer (L2) access in AWS (for this you would need to use an overlay like n2n or GRE tunneling). Try sending to a different host to rule out AWS issues. Without knowing what the traceroute implementation looks like it's not possible to say whether beej's listener will work. I would just avoid the listener completely and use tcpdump like this: Listen for any UDP traffic: tcpdump -nvvSX udp Listen for any traffic from host &lt;android-phone&gt; (e.g. a WAN IP or inside-VPN address): tcpdump -nvvSX host &lt;android-phone&gt; The -nvvSX flags basically just say "show me a lot." Check the man page for specifics. etc...
1. The firewall is configured correctly, I can provide a screenshot. I checked the inbound security settings and confirmed my instance is using that security group. 2. Hmm, I know nothing about this stuff. I assume my broadcast is getting there because my traceroute from my phone to my ec2 instance is successful. I can traceroute to multiple host successfully, the issue is listening. I need to intcercept and parse the UDP datagram that arrives at my server from the traceroute. The traceroute implementation is the one contained within BusyBox v1.22.1 &gt; Listen for any UDP traffic: tcpdump -nvvSX udp that actually doesn't work for me, i get the following reply: &gt; [ec2-user@ip-172-31-59-51 EvilTwinProject]$ tcpdump -nvvSX udp tcpdump: no suitable device found I ran: &gt; [ec2-user@ip-172-31-59-51 EvilTwinProject]$ sudo tcpdump -i eth0 not tcp port 22 -w output.cap &gt; tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes &gt; \^C &gt; 12 packets captured &gt; 12 packets received by filter &gt; 0 packets dropped by kernel [ &gt; ec2-user@ip-172-31-59-51 EvilTwinProject]$ tcpdump -r output.cap | less output: https://gist.github.com/aeb5005/0835a23696873aa23f10 Wouldn't these be traceroute? &gt; 22:29:07.858411 IP c-76-99-28-199.hsd1.pa.comcast.net.33938 &gt; ip-172-31-59-51.ec2.internal.33498: UDP, length 10 22:29:07.858452 IP ip-172-31-59-51.ec2.internal &gt; c-76-99-28-199.hsd1.pa.comcast.net: ICMP ip-172-31-59-51.ec2.internal udp port 33498 unreachable, length 46 22:29:08.046661 IP c-76-99-28-199.hsd1.pa.comcast.net.33938 &gt; ip-172-31-59-51.ec2.internal.33499: UDP, length 10 22:29:08.046711 IP ip-172-31-59-51.ec2.internal &gt; c-76-99-28-199.hsd1.pa.comcast.net: ICMP ip-172-31-59-51.ec2.internal udp port 33499 unreachable, length 46 22:29:08.098544 IP c-76-99-28-199.hsd1.pa.comcast.net.33938 &gt; ip-172-31-59-51.ec2.internal.33500: UDP, length 10 22:29:08.098580 IP ip-172-31-59-51.ec2.internal &gt; c-76-99-28-199.hsd1.pa.comcast.net: ICMP ip-172-31-59-51.ec2.internal udp port 33500 unreachable, length 46 3 attempts, which is the default # of attempts traceroute provides. 76.99.28.199 is my ip. Ah. each attempt the port value must increase! 33434 + 66 = 33500! 
The packet cap shows the traceroute program scanning the ports. Try starting the listener on the first port and see if you get "port unreachable" on that port.
PS when you're writing and debugging the program, just run tcpdump and let it spit out the stuff you're interested in to the console when you run. I usually just leave it running through the whole write, compile, run, debug cycles.
Sure thing
It's much easier and more educative to understand the code that you find and re-implement it yourself to fit your assignment. Follow the spirit of the rule, not just the letter :)
I know how to code everything, it's just much easier to copy an ~80 line function from another program that I wrote than rewriting and rethinking through the logic.
Are you able to open a c file created in another editor?
I can create a c file in both Xcode and Geany using the same method. 
But I mean, can you open an already created c file using sublime text?
This is not really related to C. Please ask this question in /r/SublimeText instead.
Alright I've done that. 
Nice way to get people solving problems and using GitHub. Nicely done.
&gt; is there a way create a variable in a for loop and each time it loops it creates another variable is created It would be helpful to understand why you think you need this capability. What is the end goal that you actually want to achieve with your program? I bet then we can suggest better alternatives to help you reach that goal.
Just a wild guess, but have you searched in your browsing history?
Sadly, yes. I looked through all devices, my bookmarks and pocket without success. Maybe I am just missing the right terms which to search for.
I should have said that the context needs to have a copy of the stack frame and the registers, which means each closure is similar in cost to an ISR.
Thank you for your cooperation.
 int get_input(double *reliability) { printf("Enter individual component reliability: "); scanf("%f", &amp;reliability); } Check your scanf. Notice how you are trying to get the input and put into `reliability`, which you declared as a `double`. `%f` does work for functions like `printf()` for both doubles and floats, as they will be both received as doubles. However, `scanf()` works differently, and will end up writing the value of `reliability` in the wrong number of bytes in the wrong format that you want it to be in when you later attempt to read the value of `reliability`, which is a double, from that same memory location; this would spout out a bunch of gibberish that you don't want which must be the error you're experiencing. You have to change the `%f` to another type of specifier to work with a `double`. What do you think that should be? Hint: It's `%lf` Edit: Also make sure to turn on warnings in your compiler, it should've told you about this.
Thanks, I tried that but I still get the same output, just zero. Is it correct to have void in the put_output function? I am just trying to pass series to main.
While you should be reading your compiler warnings, your real issue is in put_output. Your get_input is trying to modify a pointer to a pointer, so get rid of the &amp; on reliability. But, in put_output, you declare a double called series, and the value is discarded when put_output exits. This is a different series than the one you declare in main. If you want to use the one you declare in main, you will have to pass it as a pointer.
The value in series gets destroyed when that function finishes performing and does not get sent to main. You can either return series, and set the return type of the function to int, or make a pointer. Either one will work. Remember, the series you declared in main is simply a local variable, not a global one, and the program sees them as two different things.
This could be caused by several things. There might be stray whitespace on the line, e.g. the string buffer written by `fgets()` might contain `" \n"`. Or the file might be using line endings that aren't the native line endings of your platform. For example, if the text file was written with CRLF line endings and you run this on a Unix system, then the string buffer written by `fgets()` would contain `"\r\n"`. In either case, the test for `'\n'` in the first spot will fail. To debug this you should have your code print out the exact character value of each line. Or just examine your input file in some program that can show you these things (e.g. a programmer's text editor, or a hex dump utility.) 
ok, i see what you are saying. Im failry certain all empty lines will be indicated by '\n\n'. edit: so i tried running it on Koding.com it seems to properly detect new lines. Thanks!
Thankyou for your help. It makes much more sense now.
Yeh, just reading through this, I'm wondering why would someone do this and not just use C++?
You have some bugs, notably in get_input. But, when it comes to the simulation you need to look at the individual random numbers, not multiply them together. If you are simulating the serial case, generate 3 random numbers - if any of them are over the limit, then count a failure. If parallel, if all of them are over the limit then count a failure. And do this `trial` times
No. The simulated reliability is `successes/trials`.
Ok that makes sense, Thank you.
This is a similar problem to a subtype of the knapsack problem called the change making problem. For more information you can look to Wikipedia. https://en.m.wikipedia.org/wiki/Change-making_problem the general solution people use is a dynamic programming approach. 
It's impossible to say without any code. EDIT: Apparently there's a bug in my app.
You should clean up your code before you ask others to understand it. You can start by adding some vertical space. Continue refactoring the code by dividing it up into smaller functions and name everything descriptively.
I ran your program with n=4 and m=3. After entering the 4 sorted numbers, I tried to enter the first new number, but I got a "read from uninitialized variable" at the line: array[k+1]=array[k]; At this point, `k` was 4, so you tried to copy `array[4]` to `array[5]`. Smells like a fencepost error.
Did you have a question?
I *think* (but then again even though I only think, and haven't actually tested it, I am pretty sure I am right) that the problem will occur whenever you will enter a number that is higher than any number that is yet in the array. What happens is, the check goes over the whole array, since the unassigned values are set to 0. So, if you're entering 128, it's not going to stop after 68, because 0 is still smaller than 128. The easiest way to work around this, is to just add &amp;&amp; array[j]!=0 to your while loop check, but if you want the program to work even with zeros and negative numbers, you will have to be a little bit more cunning. EDIT: Also, it doesn't usually make much difference (usually in some objective languages dealing with objects in an array or something like that), but since you want the elements that you've added last to be later in an array than elements that you've entered earlier, you should be checking your array from behind. Since you have an array with 5000 values that could take some time, so you should just make an array only after the user inputs the amount of numbers he is about to enter.
Assign INT_MAX to a number of array slots equal to 1 + the number you're gonna work with (original size + additions). INT_MAX is the largest number that can be stored as an integer, and hence any number you try to insert will always be less than or equal to this number, which means the last index bug should be removed.
What if the number you want to insert is the biggest? while (tmp &gt; array[j]){ j++; } So you should write this: while (j &lt; 5000 &amp;&amp; j &lt; (n+i) &amp;&amp; tmp&gt;array[j]){ j++; } if (j &gt;= 5000) {/* array is full */} You didn't check the array bounds. The loop you wrote could run forever. (actually until it gets a SEGFAULT)
Yes, that will work, except it would look pretty ugly if you were to read the array before the work is done.
okay...
Which bits have you tested? Does your command parsing work? Does the connect work? Does the file open succeed? Is the data making it to the other side? Is your receiver even writing packets to a file?
What are you trying to tell us?
I've a general question. If I have to identical but equal structs could I, say, do this... struct A { int x; }; struct B { int y; }; Will the hash produce equal hashes for both if both x and y are the same? Then let's say we physically subtype two structures... struct A { int x; }; struct B { int y; double d; } If we hash up to sizeof(struct A) bytes can they produce equal hashes if their first member is the same? This sounds like an interesting way to store multiple types of objects safely. Only issue is that if they collide they won't be added. However let's say the first member indicated its type, and other base members are compared as well. I.E let's say we hash a struct used to identify an underlying object... struct id { uint32_t id; enum type type; } And a physical subtype... struct person_id { uint32_t id; enum type type; uint32_t ssd; } Could it then be used to yield whether the map contains a type of object? I.E if given the id of a student we can obtain a student hashed with the same id ( given type == student ) or a person or employee, etc? Pretty much I mean something like... struct person_id pid = { .type = person, .id = 1 }; struct person *p = map_get(map, &amp;pid); struct student_id sid = {.type = student, .id = 1 }; struct student *s = map_get(map, &amp;sid); Even though their ids are the same they result in different objects. I wrote it on mobile so sorry if it doesn't demonstrate my point, was just wondering if you can do some tricky stuff by physically subtyping to obtain different things. 
So let me get this straight, so when you add a new element to the hash table, if the key associated with it is full, you move on to the next bucket to see if it isn't, if not add it there, etc. Then, if it reaches a certain size, you rehash everything so that everything ideally has it's own bucket without need to probe linearly. How does this change the worst-case scenario of insertion? Is it O(N) instead of O(1)? Is it easier to do compared to before? Do you ever shrink your hash table if enough elements are removed?
Thanks for the input, but I have found what I was looking for. See my edited question.
Thanks for the input, but I have found what I was looking for. See my edited question.
Didnt you read? File handling is one of most renowned and needy topics.
I am getting old. I never even heard of traceroute with UDP until now, it has always been ICMP. 
Now that you have written this, think of a way to make this faster. If `stdin` is seekable, you surely can do better than reading the entire file. Also, rework this to not use fixed buffer lengths and admit lines of arbitrary length.
Glad you found what you were after. :-)
for comparison, OS X's version of "tail": http://www.opensource.apple.com/source/text_cmds/text_cmds-8.3/tail/ 
If you have control of the buffer size make it the needed size + 1 then add the byte yourself before printing it.
I don't really know if this would work, but can't you specify format lengths and what not, like: int n = 4; char str[] = "hello"; printf(" &gt;%.*s", n, str); &gt;hell It has been awhile since I wrote C code, I am unsure how secure this would be. edit: hey, if you're going to downvote here, explain why, I am always looking to learn, anonymous downvotes don't help.
Unfortunately the function calling this one is a "black box", so all I get is the buffer and it's size. I could make a copy of the buffer and add the trailing null byte, but wanted to look at ways to do it without allocating more memory.
Your approach is fine. The tone of your post suggests you think there is something wrong with your code - can you elaborate? You could replace the `printf("%c"` with `putchar` although modern compilers will optimize that anyway.
You could do something like this: char c = 0; for(int i = 0; i &lt; length; ++i) { c = ((char*)buffer)[i]; putc(isprint(c) ? c : ' '); //Substitute with whatever you want to print if its non-printable. Else: //if(isprint(c)) putc(c); } This will ensure you only print out things that can be printed (which is not every value of char) If you just want to attempt to print all the characters, regardless of whether or not they're printable, you can just use /u/chasesan's answer
Ah! I wasn't aware you could redirect `fwrite` to `stdout`, but that would make sense since everything is a file in Li/Unix. Thanks, I'll likely implement this, and re-read the syntax for `fwrite`.
Also what happens when it finds a zero mid string? I think he would be better off just checking it manually before handing it off to any string or print functions. I don't know enough about how the format strings are implemented behind the scenes to know if I could trust them.
No--the code works fine! Just checking if there was a better way to do it without using a for loop, as I'm still a bit fresh on C, and not terribly well versed in the available functions and idioms yet.
Thank you; I do know that the content coming into the function is printable for the entirety of the buffer, so I don't need to be safe in this case (though that's good practice regardless). I'll likely be implementing /u/chasesan's answer!
 void print_buffer(void* src, int length) { char buffer[length + 1]; memcpy(buffer, src, length); printf("%s", buffer); }
Yes, this is a possible implementation, but I'm trying to avoid making another copy of the buffer and appending a null byte to it.
I was going to say use realloc() but then I noticed the buffer is marked constant. I don't see any other solution aside from copying to a new buffer. One thing to watch for, you don't really know that the null byte is in the last element. The caller may have allocated more memory then was required. so, when you check if it's there you'll need to check each element in the buffer.
Your post got caught in our spam filter. I unblocked it this moment. I'm sorry for the inconvenience.
I've been playing with Macs for a recent job and noticed this as well, since I'm really used to closing my terminals with `exit`. I found [this](http://superuser.com/questions/158375/how-do-i-close-the-terminal-in-osx-from-the-command-line) to be helpful, however your problem may have a deeper seated issue as I'm not sure what "the buffer mode pager thingy" is. I hope I haven't misunderstood the nature of you question, but if I have please let me know. More than anything I hope I've been helpful.
There's an option in Terminal.app prefs to close the window instantly rather than printing that message and waiting for user input, fyi.
Yeah I clicked his link too before posting. I'm just saying that's not the default behaviour for the reasons I just mentioned. If you don't have any further use for the output in the the window so you want to end the session AND close the window you can already do that by pressing cmd w. It's faster and shorter to type than exit, plus it's consistent with the way you close every window you're done with on OS X so you're not having to switch back and forth between two different window closing behaviours depending on which window you happen to be typing in.
I think there might be a hidden code somewhere in here.
it doesnt work with the ascii values either
i dont think the problem is that. i've tried with m and p instead of + and - and it works. i think it is not working because it is a low level programming that doesnt recognize these characters and it doesnt recognize their ascii values either 
I added this line after the scanf(). printf("Op 0x%08X Arg %d\n", ch, it); And got this output: $ ./read input.dat i 2 + 2 r 3 + 5 r 5 s 0 Op 0x00000069 Arg 2 Op 0x00000020 Arg 2 Op 0x0000002B Arg 2 Op 0x00000020 Arg 2 Op 0x00000072 Arg 3 Op 0x00000020 Arg 3 Op 0x0000002B Arg 5 Op 0x00000020 Arg 5 Op 0x00000072 Arg 5 Op 0x00000020 Arg 5 Op 0x00000073 Arg 0 efgmnopq Clearly, some of the white space is being interpreted as the `ch`. While I'm not sure that this is causing your problem, you should definitely fix it.
i have this .bin file that contains the following:" ola one two three four"; then i have the input.dat file that contains i 2 + 2 r 3 + 5 r 5 s 0 and i am supposed to compile the program and then do "./a.out test.bin &lt; input1.dat " the dat file contains the instructions to find the string in the binary file and my output is "a one tw" when it should be "onethree". so i've reached the conclusion that only the'+' and '-' instructions arent working BTW: are you running your code in macOS??
your code is messy, but fixable (and you even got told how to do it), however don't ever fking use the built-in random number generator
A year is leap year when it's divisible by 4 but not by 100 or divisible by 400. #define is_leap_year(y) ((((y) % 4 == 0) &amp;&amp; ((y) % 100 != 0)) || ((y) % 400 == 0)) Tip: you can store the number of the days in a month in an array. int num_of_days[] = {0, 31, 28, 31, ....}; and if ((month == 2 &amp;&amp; day &gt;= (num_of_days[month] + is_leap_year(year))) || (day &gt;= num_of_days[month])) { day = 0; month++; } day++;
There are several mistakes. If I'm not mistaken leap year is every year divisible by 4, unless its divisible by 100, unless its divisible by 400. So, first of all, if((year % 4 == 0) ||(year % 400 == 0)) is wrong. It should be something like: if(year %4 == 0 &amp;&amp; (year%100 != 0 || year % 400 == 0)) Now, It's pretty late, so I might have mixed something up, but I think thats the right way to go. But still, what you wrote would only ever fail every 100 years. There is a whole another different problem. Here goes: You're checking if(day&gt;=29) and then executing the leap year stuff... You should be doing the leap year stuff on the 28th, not the 29th. right now, you will never get to 29th, because you will skip to next month at 28 every time. So basically you could have the first if be if(month == 2 &amp;&amp; day == 28). That's the only time you have to check for leap year. If it's leap year, take another day, otherwise, move to next month. If(day&lt;28) then just increment the day. if(day==29) just move on to next month. I hope I was clear enough. 
What makes CHL uniqe though is the support for executing functions inside HTML files, much like PHP using the &lt;?php ?&gt; syntax. Maybe it might be a good idea to point this feature out a bit more clearly on the Github page?
&gt; some sort of struct with a constructor and destructor function? Yep. struct LTexture { SDL_Texture* mTexture; int mWidth; int mHeight; }; struct LTexture* loadFromFile(char* path); void free(struct LTexture* texture); void render(struct LTexture* texture, int x, int y); 
OK you've got your answers (/u/dijumx did a *great* job) so here's just a few of my own remarks: 1) What is an IDE? An IDE is a text editor which has a few tricks up its sleeve, most importantly invoking the compiler from within the editor. That is very, very handy. 2) There's not only MinGW and GCC as free compilers for Windows, but also CLang. It depends (or used to depend) on MinGW, unfortunately, but it gives incredibly handy error messages if something is preventing your code from compiling.
If you are just getting started with C development on Windows, I highly, highly recommend installing [cygwin](https://cygwin.com/install.html). It is by far the most mature of any of the other projects. When you install it you get a gui which asks what packages to install, install the development packages. With cygwin you get a bash shell, and if you've installed the development packages you'll have gcc and friends. At the bash shell you can run 'gcc hello.c -o hello.exe' to compile hello world. Alternatively if there is a single file called 'hello.c' and you type 'make hello' the Make program will know what to do even without a Makefile. 
3) An IDE can read the compilers error message and jump you to that line. While that's a subset of your (1), it's worth pointing out on its own.
 int is_leapyear(int year) { int result = 0; if(year % 4 == 0) result = 1; if(year % 100 == 0) result = 0; if(year % 400 == 0) result = 1; return result; } const int month_length[] = { -1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; void next_day(int *year, int *month, int *day) { int leap = is_leap(*year); int last = month_length[*month]; if(*month == 2) last += leap; if(*day &lt; last) (*day)++; else { (*month)++; *day = 1; if(*month == 12) { (*year)++; *month = 1; } } return; } /* ... */ Many people use two different arrays for month lengths, one for leap years the other for regular. You could use a big `switch()` statement too, that would give you a `default` clause instead of having to bounds check the array properly (not shown here). People love using data tables because there a fewer steps to screw up computing (but beware screwing up the data in those tables). The leap year rule can be thought of as a basic rule `(year % 4 == 0)`, with an exception to that rule when `(year % 100 == 0)`, only that exception has its own counter-indication! Thus the final `(year % 400 == 0)`. You can fit those rules/counter-rules/counter-counter-rules together more tightly but think of the logic as a basic rule happy path with override logic in certain cases. Often with rule-exception logic you can use `if`-'s to check the uncommon cases first but since it flip-flops I could do it fprward in this example. Ruby has an `unless` keyword so you can write the happy path first with counter-rule guard afterwards. If the logic is too complicated make a comment, break down the steps, put documentation somewhere... In extreme cases tracing logic is included in the code, either runtime or preprocessor, or both!
“doesn't like” is not an error description. Have you provided the correct `-L` and `-I` flags to the compiler/linker so it knows where to look for the library and the header files?
Why are you using `lseek()` ? This is awkward with `scanf()` but try doing something closer to parsing the input yourself. You would probably need a function to skip whitespace, determine end-of-file/input (including early EOF), and in C `ungetc()` is helpful. If you didn't have `ungetc()` you would use at least two character variables. A `look` variable for "current" character and a `peek` variable for one character in the future (that was actually pre-read). With those tools, you can skip spaces (if any), grab the operator ('+', '-', '*', etc), skip more spaces (if any), bump into the following digit, push that digit back into input, THEN use `scanf()`, and so on and so on. The trace on what characters that were actually read was a great idea BTW. 0x20 is a space character 0x61+ tend to be lowercase letters 0x2b is a '+' I think Just skip all the whitespace and `ungetc()` the first non-blank.
I'm not sure how to use the flags but I did change the header search path to /usr/local/Cellar/gtk+3/3.18.6/include and the library search path to /usr/local/Cellar/gtk+3/3.18.6/lib. Then I added the dylib to the frameworks section. It has worked for me for other stuff. I'm still learning c so a lot of the compiler stuff doesn't make much sense to me. 
That should suffice, but what's the error you get? You haven't told me yet. I can't really help without knowing the error.
Have you made sure the file `/usr/local/Cellar/gtk+3/3.18.6/include/gtk/gtk.h` exists? Sounds like a weird path for OS X.
And GCC works on Solaris and Windows, and probably many other operating systems.
Definitely. There's also interactive debugging. I've only very rarely ever used it myself so I've skipped over that option. Especially since the OP says he hates IDEs. 
I wouldn't recommend it for day-to-day development though... clang's error messages are quite a bit less incomprehensible.
You're doing math and not storing the result in a variable and you're telling the compiler to treat warnings as fatal errors for some reason. You'll probably run into infinite loops too because of this.
Thanks for the help
The error you're seeing is from these lines: (n-25); (n-10); (n-5); (n-1); You should be able to see this from the error messages (lines 26, 32, 38, and 44) The issue is that those lines don't actually do anything. It looks like you're trying to change the value of `n`, but in order to do that you need some kind of assignment operator, like `n = n - 25;`. There's a short form for this in C: `n -= 25;` Also note that `q++;` is just a short form for `q = q + 1;`
Sublime Text and emacs can both do that, such a nice feature :D and I don't miss editing in slow and laggy Visual Studio 2015, although I do use it for interactive debugging being that nothing beats it for that
Ah yeah, sorry, just blind copy&amp;paste on my part. But you are quite right!
If you want to understand compilers, start from [From NAND to Tetris](http://www.nand2tetris.org/). It will ensure that you also understand how CPU-s (in principle) work and what the compiler does. *Of course this won't help with your GCC problem.* &gt; Why is it so difficult to download this GCC whatever it may be that's so special!? Seriously guys these things are really bugging me as I don't understand why it has to be this way. It doesn't... but this is what happens if you have a project that is first developed on Linux and then port it to Windows. You would have different problems trying to go the other way. Also people seem to prioritize compiler optimizations over usability. tl;dr; it's that way because there hasn't been a significant effort to fix it. (Obviously it's not a very easy thing to fix). gcc was built for Unix (which Linux is based on)[🔗](https://en.wikipedia.org/wiki/GNU_Compiler_Collection#History). However some people decided to make it work on Windows... now gcc depends heavily on Unix infrastructure -- this meant there must be something that implements the dependencies and compatibility layer for Windows. This is where Cygwin comes in[🔗](https://en.wikipedia.org/wiki/Cygwin#History). It contains the compatibility layer and some additional tools for making it work like Unix. It also can do a lot of other stuff. Mingw32 was forked from Cygwin to make it smaller[🔗](https://en.wikipedia.org/wiki/MinGW#Comparison_with_Cygwin). People working on gcc usually use Linux and use Windows as a last resort. Hence people working on the compiler don't care (that much) whether it is very usable or not on Windows. On Windows people usually use VisualC, which means there isn't motivation for people on Windows to port GCC -- it's easier to make code compile with gcc and VisualC. tl;dr; In open-source, people are concerned about their own problems, so they try to solve those, when it helps someone else, great, when it doesn't, if the fix is small, then they probably do it, if it's large then probably not. *Obviously a huge over-generalization. [🔗](http://ocw.mit.edu/courses/sloan-school-of-management/15-352-managing-innovation-emerging-trends-spring-2005/readings/lakhaniwolf.pdf)*
Thank you very much! This definitely helped a lot!
Thanks for your reply
Linux didn't exist when gcc was created: the initial release of Linux was in 1991, the initial release of gcc was in 1987.
You wrote: &gt; a project that is first developed on Linux which is what i was responding to. &gt; (which Linux is based on) or something like that. Yes, "based on" in the "overall design" sense, though not in the "genetic" sense, of course. (i.e. Linux isn't a "fork" of a codebase whose roots can be traced back to the original Unix.)
I'm not sure how to do this or how to use pig-config. 
Are you sure you need to put it in an array? That's a string so it's probably fine staying a string unless you're planning to edit it later or something. If you decide you do need an array you can put a string into an array using strcpy().
If you can use `&lt;stdlib.h&gt;` then you might use `memcpy` instead. Just a bit more annoying since you need to provide it the size of the string (don't forget about the null terminator!).
1. Yeah I kinda thought that would be a problem when I run in read only memory or when the memory isn't enough(highly unlikely). I actually don't check for this on any of my implementations. I guess I should add those thanks! 2. I'm not sure what you mean. My knowledge of size_t is limited but iirc it could hold any positive value and it's used to represent any object's size in bytes. This next thing is the first thing that popped in my head when I saw you say to use size_t but can I use size_t to make my implementation work not only with ints but with any other values like double and char? Since it's unsigned and the description I read online seemed to suggest that. Sorry if I'm mistaken. 3. Just googled that because it puzzled me and I saw a wide selection of discussions on this. When I think about it it makes perfect sense too. It's not wrong but it does look pretty bad compared to just using if and after it's body another return. Will fix that too. 4. Yeah it's because my destruction functions are not making the stack null. So I had to go ahead and change the way my destruction functions work. They used to take a pointer and try to destroy it. Here's where I slipped again on my pointer knowledge. They destroyed nothing because I didn't send them as reference. So my destruction functions got changed to accepting a pointer to a pointer(the stack). When I implemented that the destruction worked perfectly and therefore the is_empty worked too. 5. I just used 10 for an example value. In school we call it for as low as 1 of any type. Is this wrong? 6. When learning the data structures that's the way they were named in the tutorials. I guess a name like stack is more appropriate but it made sense to me while making the linked list versions since the thing stored is not the whole stack but only the pointer to the head one. It doesn't sound good for an array implementation I guess. &amp;nbsp; Thank you for your answer!
Thank you!
I decided to [review](https://gist.github.com/theif519/5aa3b65e723853aa89e7) your code by adding my comments, but only for your stack. You definitely have things to work on, but you'll get there. If anyone finds anything disagreeable or flat out wrong, let me know, and I'll fix it.
&gt; First, you cannot assign a string-type (char*) value to an array (char[]). I don't understand what you mean by this one. I've made plenty of character arrays before, e.g. `char name[]="John Doe";` That works. I thought I was doing the same thing here. &gt;Second, you're mixing up declaring the size of an array (`char var[MAX]`) with accessing an indexed array (`var[MAX] = val`). &gt; &gt;The code you have is trying to take a pointer to a static string, and assign it to the 20th entry in a `char` array. You're getting a warning about this. So, should it work if I just get rid of `[MAX]`? Because when I do that I get this error instead: http://pastebin.com/CPAAtfGk (Sorry for my incompetence, but I don't understand what this error means either.) &gt;Next, when you try to print the string, you're supplying an argument of type `char*[]`. This is because you're passing in the address of the `secret_code` variable (with the `&amp;` operator). You should just pass in the argument `secret_code` to `printf` Whoops. I actually knew about this one, just overlooked it. The real code I'm working on doesn't even use a `printf` here; I just put it here in this example code because I want `secret_code` to equal `ABC1234` for use in another function later on.
Yeah you can't assign something to the whole array like that unless you do it at the time as declaring it. Just go through the array cell by cell. Better yet, stop thinking in terms of arrays, just allocate yourself some memory and use pointer math.
1. - 2. - 3. It's mainly make sure it's easy to use on Linux... currently the project layout is very specific to VisualStudio. It's more of "learn-how-to-use-different-OS-and-how-to-make-sure-project-works-there". 4. e.g. allocate 64 items at a time and deallocate when you have popped 96 items. Depending on the usecase those numbers will vary. 5. Usually people are more impressed, if you've implemented a project or something interesting, not data-structures. Of course data-structures are better than nothing. And data-structures with manual memory management are better than data-structures with GC. 6. STB libraries are designed for ease-of-use first and maintainability second. This means, to get any of those libraries working in your project; you just include them, and you are done. For any other "non-single-include-file" you also need to configure your Makefile or whatever build-script setup some linking etc. For bigger projects with good maintainability take a look at Plan9 and SQLite sources. 7. I mean, use them in a project, it will guide you to a better design of the interface and internal implementation. For example a `Packets` structure is something concrete, this would lead you to an interface with packets_enqueue, packets_dequeue etc. I.e. by implementing a library for a specific purpose, will make the code clearer, more useful and easier to evaluate etc.
&gt;First, you cannot assign a string-type (char*) value to an array (char[]). A char* is a pointer to a place in memory that is going to be interpreted as a char. It's not a "string-type..." 
.2. You index the top element via `top` which is declared an `int`. It should be a `size_t` though. Otherwise you are limiting the maximum size of your stack. .3. Hm `is_empty` should simply check if `stack-&gt;top == 0` and then return true. .5. No operating system can manage memory on a per-byte level. It allocates pages in chunks of KB. So if you call `malloc(10*sizeof(int))` you are waisting a lot of memory. Instead you could just statically allocate a fixed buffer. 
Start by writing your own version of `strcpy()`. Then when you have that working it should be a simple matter to extend it so that it takes two source strings instead of one, and then copies these to the output string, taking one character from each input string in turn.
use sizeof() to get size of your arrays. Note that they will both have a /0 at the end. Allocate a new chunk of memory that is long enough for your new string. Use a for loop or something to copy the characters into your new array.
1. - 2. - 3. I'm not planning on taking on Linux. It seems like a huge overkill for me and I feel it will burn me out to be honest. I'll stick to windows for as long as I can even though Linux seems really interesting. Interesting but big. 4. Yeah makes sense. I did it 1 by 1 because I thought I was being efficient by doing so(only allocating when it's needed). I had no idea it was such a tasking action but I should have figured since it's working with the memory directly. 5. Yeah that's my next stop after learning all I can about data bases and algorithms. I am aiming for a project that can show my work with both of them and is fun for me at the same time so I don't burnout on boring stuff. 6. Yeah C libraries seemed kinda clunky to me coming from java's compressed jars. Having more than one file makes them harder to use. I will read up on STBs and those projects you sent me when I have the time, thanks! 7. Yeah if I use them in a project I would definitely go for a concrete implementation because I would be 100% sure what they will be containing. Since I wanted to make a generic library that could take many types I wanted to make it an abstract one, but halfway through I decided to drop the multiple types idea and stick with ints so it's easier to finish. &amp;nbsp; Thanks for the answers!
Thanks for taking the time to do such a detailed review! You even mention the thing I had in mind(for the stack to be able to handle multiple types) but dropped afterwards for simplicity's sake. I will try to read it when I can and get back to you as soon as possible. 
Here's generally what to do, but not exactly the answer: 1. Iterate through both strings with a single loop. 2. Print a character from string1 and another from string2 in the same position. Do this for each iteration of the loop. and some things to consider: * `string1` can be shorter than `string2`, so how can you make sure that your loop will read both strings in all different-length scenarios? * Try to keep track of when each loop ends. How can this information be of use? edit: also don't be afraid to break out a pencil and paper if you can't do it all in your head! Wrapping your head around the problem is always the hardest part, but once you do understand it, it'll be satisfying and you'll remember better for the future.
&gt; f = malloc(sizeof(struct fruit)); The return value of malloc is a pointer to the allocated data -- unless malloc fails. If f == NULL, the system didn't allocate. When you try to dereference NULL, that's illegal. I'm not saying that's what is causing your segfault, but you should test those pointers.
something like this maybe: char new_array[lengths of strings]; for (int i; i &lt; lengths of string1+string2; i++) { // also check if null new_array[i] = string1[i]; new_array[i + 1] = string2[i]; //also add '\0' }
Paste it into the box at Build Settings -&gt; Other C Flags. And hope you're not trying to share this code ;)
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct fruit { char *name; double unityPrize; double value; struct fruit *next; }; void insertEnd(struct fruit *f, char n[50], double p) { while(f-&gt;next != NULL) { f = f-&gt;next; } if(f-&gt;next == NULL) { f-&gt;next = malloc(sizeof(struct fruit)); (f-&gt;next)-&gt;name = n; (f-&gt;next)-&gt;unityPrize = p; (f-&gt;next)-&gt;next = NULL; } } void resetvalue(struct fruit *f) { while(f-&gt;next != NULL) { (f-&gt;next)-&gt;value = 0; f = f-&gt;next; } } void setvalue(struct fruit *f, char c[50], int q) { while(f-&gt;next != NULL &amp;&amp; (f-&gt;next)-&gt;name != c) { f = f-&gt;next; } if(f-&gt;next != NULL) { (f-&gt;next)-&gt;value = ((f-&gt;next)-&gt;unityPrize) * q; } } double getvalue(struct fruit *f) { double valueTotal = 0; while(f-&gt;next!=NULL) { valueTotal+= (f-&gt;next)-&gt;value; f = f-&gt;next; } return valueTotal; } int main(void) { int M, j; struct fruit *f; f = malloc(sizeof(struct fruit)); f-&gt;next = NULL; char c[50]; double p; int q; scanf("%d", &amp;M); for(j=0; j&lt;M; j++) { scanf("%s %lf", c, &amp;p); insertEnd(f, c, p); } int P; scanf("%d", &amp;P); resetvalue(f); //set all values to 0 for(j=0; j&lt; P; j++) { scanf("%s %d", c, &amp;q); setvalue(f, c, q); //set just the values that showed up } double valueTotal = getvalue(f); printf("%f\n", valueTotal); }
for the INPUT: 4 avocado 2.19 onion 3.10 tomato 2.80 grape 2.73 3 avocado 2 tomato 1 grape 3 My output should be 15.37, but I'm getting 6.570000
You'll have to decide on the boundary conditions of the grid you are looking at. If they are periodic, accessing the left neighbor of grid[0][0] would yield grid[0][6]. Otherwise you could just not count the neighbors. You could calculate the number of non-zero neighbors as such: int numNeighbors = 0; //somehow handle boundary conditions (wrap around or ignore) //left neighbor if (grid[0][i-1] != 0){ numNeighbors++; } // similar for other neighbors: i+1 = right, j+/- 1 = left. 
** j terms are below/above respectively. 
Your indexing into new_array should be [i * 2] and [(i * 2)+1]. In your existing loop, when new_array[i] will overwrite the value from the previous iteration's new_array[i+1].
Bubblesort, ( which shouldn't be used for anything other than showing how bad bubblesort is), and many other sorts work best with random access to the data. Linked lists are very poor at random access. Merge sort is good with linked lists.
Can you elaborate why bubble sort works best with random access? I can't see any advantage for bubblesort if efficient random access is possible.
There is a link to a help below the right corner of the edit text box. If you follow this link you can read "Lines starting with four spaces are treated like code". It would be fine if you format your code as code.
* You used the term *struct segment* in the definition, but then you refer to it as *struct segmento*. I'll assume it's *struct segment*. * Your for loops don't actually iterate through to the next elements. You probably want them to be *i = i-&gt;next* and *j = j-&gt;next* instead, rather than constantly being set to their original element. * Your function doesn't really modify the original array. Rather, it just keeps swapping the new variables *i* and *j* around, which doesn't do anything but obfuscate your program. What you need to do is modify the *next* and *prev* properties of *i* and *j* to modify the ordering of the list. * Since you're not using a header for your list, the first element of your list will either get shifted, or will have to be ignored. That means that your list probably won't point to the beginning by the end of the function. I'll take a stab at this later on, but try to fix up on these points. :)
See: http://stackoverflow.com/questions/3533348/how-does-this-code-generate-the-map-of-india and http://stackoverflow.com/questions/15221026/c-loop-printing-india-map and http://stackoverflow.com/questions/15172106/how-this-program-can-print-the-india-map 
Sure! I will work on it!
I'm eager to see the results!
Correct me if I'm wrong (I'm not), but I don't think you can just write a&lt;b&lt;c as a statement. It must be a&lt;b &amp;&amp; b&lt;c. Other than that, your program is fine, however you could make it into one line using || (or) between all of the possibilities. There are certainly nicer solutions though.
&gt;a&lt;b&lt;c as a statement. It must be a&lt;b &amp;&amp; b&lt;c. Thanks a lot! I changed that and it worked and was approved! Now before you answered, I tried some reverse thought process to what I had done before and wrote this code: #include &lt;stdio.h&gt; int main() { float x1, y1, x2, y2, xu, yu; scanf("%f %f %f %f %f %f", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;xu, &amp;yu); if(xu&gt;x2 &amp;&amp; xu&gt;x1 &amp;&amp; yu&gt;y2 &amp;&amp; yu&gt;y1 || xu&lt;x2 &amp;&amp; xu&lt;x1 &amp;&amp; yu&lt;y2 &amp;&amp;yu&lt;y1) printf("out"); else printf("in"); return 0; } I looks much better and more compact, right? It was not accepted however. I think it has something to do with special cases where the inputs do not create a rectangle, in which cases it will still print "in" regardless.
How could it not make a rectangle? The only option is for it to be a single point. EDIT: nevermind, lines exist. As for the code... You messed up a bit, but good thinking. It's not in the triangle if xu is either bigger or smaller than both given points, OR if yu is either bigger or smaller than both points. Yours says: xu and yu are both bigger than given points or xu and yu are both smaller than given points.
Oh, I get it. No need for both to be bigger!
Exactly.
 seeds = seeds ^ 2 The `^` operator is the Xor operator in C, not exponentiation.
i already tried seeds = seeds * 2 and it didn't work
Oh I'm sorry. I didn't know the bit-shift operator and therefore I didn't know where to do research. That should be enough, thank you.
http://puu.sh/nTFns/a54ef6b0ce.png Translation: Type the number of spaces: 64 space 64 contains 2 seeds will be payed 2 seeds. 
can you modify my code and send me the right one please? im new to C program, that would be very helpful
That is not what we're here for. "Give a man some code, you help him for a day. Teach a man to code, you help him for a lifetime." We understand you're new to C. That's fine. We're here to help you learn.
Find another book to start with. I love the K&amp;R book, but take it from someone with 15 years of experience; it's not a good beginners book. K&amp;R was written in a simple, straight forward manner and it's what makes that book great, but it's also not great for people that aren't already somewhat familiar with systems level programming. Finding a good book that is a bit longer and can delve into the details that aren't common in modern languages (pointers, memory management, etc...) will help you ramp up much faster. After you get those concepts down where you can read code and understand exactly what pointer arithmetic is doing and how memory management works, then go back to K&amp;R and you'll be surprised how it will even further your knowledge and you'll have a firm respect for the book then.
Thanks for your reply. Hah, it seems like you and /r/learnprogramming are saying the exact same thing. I took the advice of someone in their irc channel and am taking a HarvardX course that he says is an excellent introduction to CS concepts and the C language. I also plan on using their course C book for learning what the course doesn't teach.
To make the program wait for 3 seconds, you should use the `sleep` function from `unistd.h`
Section 2.9 will help you come up with ways to solve these. Experiment with bitwise operations. You can either figure out a way to print out the numbers in binary for feedback, or just calculate what the binary number returned would be manually and aim for that.
To repeat part of your program, use a loop. Perhaps something like this: int main() { while (1) { puts("Type Ctrl+C twice to quit."); /* Check for double Ctrl+C */ } return 0; }
Additionally, everything you're doing is on integer types, so you shouldn't be using the `float` data type
I'll try to figure out how to print unsigned ints as binary and go from there, that sounds like fun anyways. Thanks
&gt; The exercises I'm struggling with at the moment are 2.6 through 2.8. I don't even know where to start here. I think it might be the way things are worded, in addition to the fact that the book seems to presume I already know a lot about bitwise operations and such. Exercise 2-6 to 2-8 or the exercises in section 2.6 to 2.8? &gt; Section 2.6, Exercise 2-2 &gt; Write a loop equivalent to the for loop above without using &amp;&amp; or || &gt; Section 2.7 Exercise 2-3. Write a function htoi(s) , which converts a string of hexadecimal digits (including an optional 0x or 0X ) into its equivalent integer value. The allowable digits are 0 through 9 , a through f , and A through F &gt; Section 2.8 Exercise 2-4. Write an alternative version of squeeze(s1,s2) that deletes each character in s1 that matches any character in the string s2 . 45 &gt;Section 2.8 Exercise 2-5. Write the function any(s1,s2) , which returns the first location in a string s1 where any character from the string s2 occurs, or -1 if s1 contains no characters from s2 . (The standard library function strpbrk does the same job but returns a pointer to the location.) None of these require bitwise operators. Section 2.9 is Bitwise Operators and contains Exercise 2-6 to 2-8. &gt;Exercise 2-6. Write a function setbits(x,p,n,y) that returns x with the n bits that begin at position p set to the rightmost n bits of y , leaving the other bits unchanged. &gt;Exercise 2-7. Write a function invert(x,p,n) that returns x with the n bits that begin at position p inverted (i.e., 1 changed into 0 and vice versa), leaving the others unchanged. &gt;Exercise 2-8. Write a function rightrot(x,n) that returns the value of the integer x rotated to the right by n positions. I assume you're talking about Exercises 2-6 to 2-8. You don't need to be an expert in bitwise operators, but the chapter should give you enough to go on. edit: Actually it is a bit spartan. It seems to assume you're familiar with binary representation of numbers and the AND/OR/etc operators. Thankfully these days there's a lot of into online about them! Did you manage the previous exercises without issue?
Use %x for hex :)
Since programs and mathematical proofs [are equivalent](https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence) why not just do the math: A chessboard has 8*8 = 64 spaces. So the answer to your question is the sum from n = 0 to 63 of 2^n i.e. 1 + 2 + 4 + 8 + ... or written differently: 2^0 + 2^1 + 2^2 + 2^3 + ... + 2^63 = 36893488147419103232 or roughly 3.6 * 10 ^19 
&gt; Also, with the example in the book just above those exercises, getbits(), I have no idea whatsoever how this function does what the book says it does. /* getbits: get n bits from position p */ unsigned getbits(unsigned x, int p, int n) { return (x &gt;&gt; (p+1-n)) &amp; ~(~0 &lt;&lt; n); } Imagine the 16bit number 0b0000111100001010, hex 0x0F0A. position 0 is the rightmost bit, position 15 is the leftmost. int main() { unsigned x = getbits(0x1F2A, 15, 16); printf("%x", x); return 0; } prints out 1f2a. So here we can see it get all 16 bits. getbits(0x1F2A, 15, 8) -&gt; 0x1F getbits(0x1F2A, 7, 8) -&gt; 0x2A getbits(0x1F2A, 15, 4) -&gt; 0x1 getbits(0x1F2A, 7, 4) -&gt; 0x2 Does this make sense so far? As for how it works, let's take getbits(0x1F2A, 7, 8) -&gt; 0x2A, (x &gt;&gt; (p+1-n)) &amp; ~(~0 &lt;&lt; n); split this up into: unsigned z = (p+1-n); unsigned y = ~(~0 &lt;&lt; n); (x &gt;&gt; z) &amp; y; Remember x=0x1F2A, p=7, n=8. ~0 simply flips 0 into all 1's. So ~0 is the same as 0xFFFFFFFF. So why not write that? Because if we wrote 0xFFFF it would work fine on a 16 bit computer, as unsigned ints are 16bit there, but fail on a 32bit computer, as unsigned ints are 32bit there. Assume 32 bits: unsigned y = ~(0xFFFFFFFF &lt;&lt; 8); `0xFFFFFFFF &lt;&lt; 8` is `0xFFFFFF00`. ~0xFFFFFF00 is 0x000000FF. You can confirm this with two lines of C and a printf or a bit of paper. :) unsigned z = (p+1-n); z = 7+1-8 = 0 So now we have: unsigned z = 0; unsigned y = 0x000000FF; (x &gt;&gt; z) &amp; y; `0x1F2A &gt;&gt; 0` is 0x1F2A and `0x1F2A &amp; 0x000000FF` is 0x2A. Did you manage to follow that through? 
It was the exercises for section 2.9. I managed a good portion of the previous exercises, but there were some that I struggled with and skipped. I didn't want to get bogged down with exercises where I didn't know where to start. I think this book is a bit too difficult for me to use as a learning guide, unless I skip the exercises and read through just to understand the syntax and what it's doing.
Ooooohhhhhh i have to flush the input buffer or get rid of the whitespace input with a dummy char. Thanks a lot!!! I just tried it and its working now i can practice some of the harder stuff with pointers and edits 
Another issue no one has raised here, is that you are going to very quickly go out of bounds of an integer if you try to compute 2^64. Even an unsigned long in C is typically 4 bytes (or 32 bits) which means 2^32 - 1 is the max value it can hold. If you want to use a 64 bit unsigned integer, I would suggest using: #include &lt;stdint.h&gt; uint64_t seeds=0, sum_seeds = 0; You'll also need to use a special macro to print out a 64 bit integer (printf will not support this), so you'll need to include another library: #include &lt;inttypes.h&gt; Then use printf("Space %d has %" PRId64 " seeds\n",counter,seeds); This method will still not be able to hold the sum for you, and will similarly be limited at 2^64 - 1
Isn't he swapping the entire structure on line 144? Person[d] = Person[d + 1];
What error are you getting? As mentioned by /u/jedwardsol, you aren't calling the `fnSortDetails()` function anywhere. So if your error is that you aren't seeing any sorted array as output, try calling it in `main()` before `fnPause()` call. And you already have `fnPrintDetails()`. Why are you implementing the same thing again inside `fnSortDetails()`?
The lines above and below that only deal with the employee number
you are doing it wrong. If you don't give us any more info we can't give you a better answer.
Look up the documentation for the `srand` function.
&gt; z = (p + 1 - n)? I don't understand why it wouldn't be (p + 0 - n) or (p + 2 - n), for example. However, I think I'm way overthinking things for my current level. Imagine the binary number: 10101010 that's 8 bits, from position 0 to position 7. There's no position 8, right? (Just like other forms of indexing in computer science). The standard notation for talking about a subsequence of bits is e.g. [7:3] if we want to talk about bits 7 through to 3. How many bits are in the sequence [7:3]? Well there's bits `7,6,5,4,3`, which is 5. You and I can see it's 5, but to calculate it for the computer: 7-3 = 4 wrong 7+1-3 = 5 correct or in variable form: count = highest_bit + 1 - lowest_bit This calculations works out the size for any bit slice, [7:0], [32:1], [1:0], [0:0] etc The +1 is there to change from INDEX (or OFFSET) based numbers (bits 7:0) to ORDINAL based numbers (8th bit down to 1st bit). So +2 or +3 or +21 wouldn't make any sense here. You'll have seen this conversion from index to counts before with array, I think? (Or perhaps arrays haven't been introduced yet, I can't be bothered to check. :P) ----- Going back to the original code: `z` is used to shift the number down before masking it by `y`. `(x &gt;&gt; z) &amp; y;` Imagine: 10101010. If we want to move the top 5 bits down 3 places (and also mush the right 3 bits of of existence) we do a right-shift by 3. 10101010 &gt;&gt; 3 = 00010101 That is to say, if we want to shift bits [7:3] down to be bits [4:0], then we just need to shift by 3. Easy. For us. But for the C code we need to write? /* getbits: get n bits from position p */ So if we want to get 5 bits from position 7, we're taking about the slice [7:3]. But we've given the function p=7 n=5. So to work out that it's high=7 low=3 count=5, we do this nonsense: z = (p+1-n) Or, to rename that for you: lowest_bit = highest_bit + 1 - count Make more sense? It's an algebraic rearranging of the thing we had before that worked out how many bits we have in a slice: count = highest_bit + 1 - lowest_bit Note: One reason I'm no so keen on K&amp;R, or indeed any C code from before the 1995, is that the people who wrote it back then were in love with one letter variable names and completely nonsense function names. If I wrote getbits I wouldn't use p n z x, I would use actual names so we can all understand wtf is going on. 
You've only generated one random number. You have to generate it again before printing it again.
Oh!!!!! Okay! That helps. Thank you!
I tried to call in the fnSortDetails() after the fnPrintDetails() function but I kept getting errors, I don't think I was calling in the correct arguments for the function. The assignment asks us to created the following: *Create structure with a specific set of members *Store the information for those variables within an 1D array *Populate the array *Output the contents of the array as I did in fnPrintDetails() *Sort the array by EmployeeNumber (lowest to highest) *Sort the array by FamilyName alphabetically. I thought about implementing the EmployeeNumber sort by declaring another function fnSortDetails() and then sorting the contents of the array within that function and outputting the details the same way as I did in fnPrintDetails() 
yep I figured out why as well, silly mistakes I made. 
Ahhhh, your explanation makes a lot more sense! Thanks! I would have never been able to work this out just from reading the code. I didn't even stop to think about the difference between the numbers in an array and the numbers we count with, either. "C Programming: A Modern Approach" is doing a much better job making things clear to me. It's so much less confusing. 
What happened to the 'i' in your name?
What happened to the 'q' in yours?
The C standard library provides the [qsort](http://www.tutorialspoint.com/c_standard_library/c_function_qsort.htm) function. To use it, you just provide the array and a comparison function. I'd recommend giving that a try, it simpler and probably more efficient than implementing your own sort.
What would be a more efficient way of doing this? I'm only going by the algorithms I can find on the internet. if(Person[d]&gt;Person[d+1] How would I do this better? I'm still very new to programming.
Would this sort also work the same for comparing the letters of the alphabet to sort a family name out alphabetically?
Wow, thank you, really &lt;3
yep, thank you :)
 I wrote a calculator that handles 'bigints' doing all the usual operations, addition, subtraction, multiplying, etc.. The trick is finding a way to represent your large values and then manually performing the operation almost like you would by hand on paper. In many cases this can be parallelized as well for massive speed gains. EDIT: I stored my values in plain text files, and everything was handled that way, two files as inputs, one file as an output, and a specified operator, all as a commandline application.
Ravenshad's class?
No GMP? OpenSSL's libcrypto has a bigint package... Not as fast, but it gets the job done.
We use this as an interview question when we're looking for candidates. Basically, do exactly the same thing you would do manually on paper.
Shouldn't you be dynamically allocating the new struct and returning a pointer to it? Wouldn't this variable be destroyed after returning from the function? Edit: for future reference http://stackoverflow.com/questions/22957175/how-does-function-actually-return-struct-variable-in-c 
People more frequently want powers of two because memory is sized based on powers of two.
There are more uses than the maximum number of entries you can index or the size of total virtual memory (the disk portion of virtual memory will somewhat frequently not be a power of two, ruining the effect). There are things like: * processor cache lines are usually a power of two in size, and things not fitting into one can lead to a slowdown. * alignment issues, where having data that's ragged in shape so that it straddles two words (which are almost always a power of two in size) takes much longer to access than aligned data (though alignment is usually handled by the compiler). * a common strategy to grow appendable array-backed data structures is to simply double the array's size when the capacity is exceeded, which gives a good amortized cost of reallocating all that memory and copying all the data over to the new memory compared to the size of the data being copied. * The maximum size of network packets, disk drive hardware buffers, and other communications are usually a power of two, so the buffers used are the same size.
Yes, that's exactly what I meant.
Your welcome. Were you able to finish a program that calculates the answer as well?
First you have to decide how you're storing your 4096 bit numbers, and come up with a library for handling them. After you've done that, multiplying them is trivial.
I think as *unsigned long long int*s and 64 bit integers go out bounds, you may need to either (unless I have made an error in my implementation) : 1) look in to using a third party library to handle such big integers (e.g. the one at gmplib.org, which you may need to install and learn how to use), or 2) you will need to devise some other method of handling numbers that big; perhaps by messing around with large enough strings and calculating things manually by the digit.
Woah thank you for finding time to write such a long answer! I just read the whole thing and I'll try to refactor my code to something better. You even went to the trouble to write a basic implementation of a stack in readable code. Most of the examples on the internet use code that looks like Egyptian hieroglyphs to me. One example even typedefed an int which made me want to gouge my eyes out. &amp;nbsp; About the pointer typedef, yes it looks totally horrible. It even made me question how pointers worked again in the process of creating these. It's just how the tutorial did it and I thought I should try to stick with the code since it was a CS teacher speaking so I had a bit of faith it was fine. &amp;nbsp; I'll try and get an acceptable version of all my previous implementations using the tips you gave me and I'll even try to make it accept any value using a void*. Thank you again for the help! &amp;nbsp; EDIT: Looks like my internet failed and the paragraphs above this one didn't even get sent. I'll leave them nevertheless. I went and I refactored the stack versions of my code and they seem to be working fine. I put them both in one repo and I plan to do that with the queue implementations too. I can't tell you how happy I am with myself. Thanks to you I learned so much these past few days! Thank you so much! I think I got them correctly but you could look at them if you want. There are slight differences between the linked list and the array implementations. For an example the push and pop in linked list take **stack since they need to push the edit the head node(I insert in the beginning because if I didn't I'd have to traverse each time to push and O(n) is a worse option). &amp;nbsp; EDIT2: Lol forgot link to repo: [ADT_Structures](https://github.com/Zetxus/ADT_Structures) &amp;nbsp; EDIT3: Oh yeah I wanted to ask you about your implementation. I see your destruction function uses a callback(just learned what that is so I'm not really confident in it) and destroys all the items. I think you misunderstood what it's purpose was. Probably because I didn't present it properly. I want it to free the space allocated bu the create function. Since it's an ADT it needs to have create and destroy functions. I made a big mistake freeing an empty array implementation because you **can** have an empty stack with the array implementation but you can't really have one with the linked list(that's why in my new implementation I free the memory allocated for the head node when the last item gets popped). &amp;nbsp; And for the struct you have that contains the size_t size; I see why this is good in an array implementation - one stack, one node and the extra memory is 4 bytes. And I can have a size(stack*); function that runs in O(1). But this is pretty bad in a linked list version right? Since it takes extra memory for each node. So in the linked list I should have only *value* and *next* in the struct and if I want a *size* function there I should just traverse the list and get a result right?
Start by fixing line 17. You're missing the closing parens before the semicolon.
Okay. Now, two items: * Can you share your #include sections at the top; it's important to ensure everything you're using is defined. * What language standard are you targeting? You're using variable length arrays, which are only valid on some C standards versions. My guess is that you need to do some variant of flush() on the send() request socket, but it will help clarify issues to identify these points.
So basically, I have to recv no matter what? :( Alright, will check it out.
I'm going to assume, based on your code, that you're using `send` and `write` interchangeably, as well as `recv` and `read`. On my computer, it did send the requests when I commented the call to `read` on line 39 out. However, I could see far less requests than I expect were sent (about 20-25, when I expected 250), and the number of requests wasn't the same each time. Networking, at heart, is an asynchronous process. When you call `send`, you tell the OS what data you want it to pass to the hardware adapter and send down your cable (or through your Wi-Fi). The OS then waits for an opportunity to grab some CPU time and process this data. As long as your program is running, the OS can't send What's happening, if you don't call `read`, is that even though you called `send`, your program closes the sockets before the OS actually sends the data down the wire, so your requests are basically lost. When you call `read`, your program blocks until there is something to read. When a program blocks, it doesn't hog the CPU until it's unblocked, but yields it to other processes that need it. This creates a great opportunity for your OS to actually pass the data down to the hardware layer. So by calling `read`, you actually give the OS the time to send the request. There are other ways to block a process, for example by calling `sleep`. By calling `sleep`for 10 seconds before closing my sockets, I could send all 250 requests before the program closed sockets and quit. http://pastebin.com/TU8JWhZB The concepts you manipulate when doing raw networking code are quite complex, and it's a great way to begin understanding what happens behind the system calls (like `send`/`recv`/`read`/`write`). I' recommend these two papers. It's a dry read, but it's pretty thorough and covers a lot of notions that will come in handy. * [An Introductory 4.4BSD Interprocess Communication Tutorial](https://docs.freebsd.org/44doc/psd/20.ipctut/paper.pdf) * [An Advanced 4.4BSD Interprocess Communication Tutorial](https://docs.freebsd.org/44doc/psd/21.ipc/paper.pdf)
for the INPUT: 4 avocado 2.19 onion 3.10 tomato 2.80 grape 2.73 3 avocado 2 tomato 1 grape 3 My output should be 15.37, but I'm getting 6.570000
First off, if you aren't comfortable with programming (or with programming in C) then signals are not something you really want to mess with. Now, with that out of the way, the best way to deal with signals is to do a little as possible in the actual handler. Many reasons for this (one reason: you get all the headaches of a multithreaded program because the signal handler can run *at any time*) so for now, you are better off using something like: #include &lt;signal.h&gt; volatile sig_atomic_t g_flag; static void ctrl_c(int sig) { signal(SIGINT,ctrl_c); g_flag = sig; } Because you are using signal(), you need to reinstall the handler from within the signal handler, because of history (too long to go into here) and that signal() is one of the few functions you can safely call from within a signal handler. I store the signal number in a global variable of sig_atomic_t (defined by ANSI C) and it's marked as volatile to let the compiler know that "Here Be Dragons" around reading/writing that variable (it can change at any time). That said, g_flag is 0 until Ctrl-C is hit. Then it contains SIGINT. You can check for this condition. Two other functions you might want to look up, pause() and sleep(). Both are POSIX functions. pause() just waits until a signal is delivered, and sleep() will cause the current process to sleep for a given number of seconds. That should be enough to get you going. 
You set the socket to nonblocking, which means you're asking the OS not to wait around until your send() call finishes. If you want it to wait until the send() finishes before returning, don't set the O_NONBLOCK option on the socket, or come up with another way of waiting for the operation to finish. It's doing what you told it to! You should also be checking the return value of send(). It will return -1 and set errno if there's an error, and the way your code is written, that could cause an infinite loop.
Thanks for the lengthly explanation! Yeah, thats the problem I was having also.. I've decided to implement a timeout etc. This was an example on a site I was looking at, thanks for helping.
Thank you! I really didn't know that I can't compare strings with '='. You helped me so much, I'll keep trying! 
Try the following, as you're attempting to modify a string literal which is most likely stored in a read-only data section: int main() { char str[] = "word"; reversestring(str, 4); return 0; } Also a bit of nitpicking; in your "reversestring" function you declare str as type "const char *", but you are clearly modifying it within the function. Also not sure why you're returning 0 from that function which is entirely unnecessary, and then neglect to return 0 from the "main" function.
Assuming you're using standard printf, it is possible intervening \\t characters in the format string can help things line up, if fixed padding is inconsistent.
Honestly, I don't think so. C11 thankfully didn't change the language all that much. The clc FAQ (near as I can tell) never addresses things like threads or noreturn, so the new standard doesn't affect those. New things from C99 like [macros with variadic arguments are already dealt with in the FAQ](http://c-faq.com/cpp/varargs.html). I haven't gone through every single question, but from what I've seen, the suggestions in the FAQ are still valid. Some may not be as relevant any more (there are a few questions that talk about "if you're on a pre-ANSI compiler...", which is vanishingly unlikely these days), but they're not wrong.
That FAQ is one of the best sources on C questions. It may be old but definitely not out of date.
1. Post the link to the repository you want reviewed... 2. Work on your writing skills, it is impossible to make any sense of what you wrote here 
I think the repository is Githome - I only have one under my user Pentalive. 
A physical link to the repo is generally customary when looking for code reviews. Don't expect people to go trawling through github. 
I'm bored, so there is a small review: You have 2 different README files, which is not necessary. As you can see, Github takes the `README.md`-file to display it on the "front page", so you want the description there instead of a seperate file (`ctrek.README`). Usually on how to compile the project is also in the `README`, or sometimes in a file called `INSTALL`, or both. Also, give your repository a better name. I didn't expected that the "project" is about some game. And now for the code. The first thing, use enums. The first "block" of defines can be rewritten as: enum somename { EMTY, STAR, BASE, KLIG, ENTP, KLIB, PTRP }; It is still accessable like `EMTY`, but you don't care about giving them numbers, as it is made automatically. By default, the first element has the value 0 and increases with each element, so `STAR` has the value `1`, `BASE` has the value `2` and so on. Also, what are these constants? Some comment would be useful, or more descriptive names (self-documenting code). From the code above, i used `enum somename`, where `somename` can be something like `place`, which also give a hint that these are places. Also, you can use it as a type, eg. `enum place place = STAR;` would define a variable called `place`, initalizes it to `STAR` (1) and gives a "hint" (to the programmer) that this variable should hold the value in the enum. The actual type is a integer-compatible type, so you also can just put any number into it. For the functions `ShortNameDevice` and `LongNameDevice`, you can also use the enum directly instead of the number directly, eg. `case LRS: printf("LRS"); break`. By the way, i don't know if it is intended, you start counting from 1 in the case-statements instead of 0. This text gets lengthy, so i'll stop now. Short: `enum` may makes life easier, document your code/variables. I haven't checked the rest of the code.
Comments even if you didn't include a link to your repo: - You should include a `Makefile` or at least doc on how to compile your software - You can put your source into a directory named `src` - `githome` is fairly generic, you should use a better name like your project name `ctrek` or anything that makes sense
Is it too late to change githome (it's also the name of my subdirectory on my machine). Make already knows how to make ctrek... but if it gets more complex or needs some library like math.h 
@pzl - thanks for publishing the link for me - and your comments.
If I'm understanding you correctly you would need to print out each line of necessary characters at a time before moving to the next line... to do this instead of going digit-by-digit you would input all the necessary digits to be printed and print them row-by-row. I think a more organized or intuitive num_list implementation would help you with that. You would need to separate each line of each printed digit with a consistent spacing, probably a "\t". The more complicated option that still has a lot of power would be to utilize a library that gives you more control of the console such as ncurses. As far as efficiency is concerned the scope is so small that I don't think efficiency would really be a factor. Is this the best way of doing it? Probably not, but any way that works should be fine unless you're printing some extraordinary amount of digits.
Yes, assuming you are using gcc. Gcc has a C extension for [statement expressions](https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html) that allow you to return a value. 
I'm using Clang. I don't mean to create a statement expression, I mean a function itself that returns a PAIR. PAIR(char *, void *) * get_mapped_entry(void *entry); Where the above will return an anonymous function with a string and a void pointer. So I'd want to catch the value like so. PAIR(char *, void *) *p = get_mapped_entry(entry); Or think of something like this... PAIR(int, x, int, y) *point = get_coord();
Remember that all macros are, are a text substitution system performed by the C preprocessor that is invoked before compilation even begins. So think about it in terms of what the code looks like after macro substitution. If two structs have the same member types, in the same order. Then they are indeed compatible types. You can see what the preprocessor outputs with clang using the command line option -E Edit: I should probably qualify further. &gt; If two structs have the same member types, in the same order. Then they are indeed compatible types. A pointer to some 'struct A' then cast to a pointer to some 'struct B' is well defined if the two structs have the same member types in the same order or if 'struct B' is subset of 'struct A' sharing the same initial members. Barring, of course, the normal c++ aliasing constraints.
I'm looking through c99 standard. I can't find anything that disallows assignment from a cast from one pointer to a struct to another. 6.5.2.3 Doesn't like operator . or operator -&gt; applied to different types. But that doesn't seem to apply here. &gt; 6.5.2.3 Structure and union members &gt; Constraints &gt; 1 The first operand of the . operator shall have a qualified or unqualified structure or union &gt; type, and the second operand shall name a member of that type. &gt; 2 The first operand of the -&gt; operator shall have type ‘‘pointer to qualified or unqualified &gt; structure’’ or ‘‘pointer to qualified or unqualified union’’, and the second operand shall &gt; name a member of the type pointed to.
I'm not sure what format your input will be in but you could also consider accepting the entire input before printing anything to avoid outputting characters on different lines of the terminal. ex: print 15:30 Input 1 5 3 0, print the top line of each character, new line, etc. etc. til you move to the bottom row.
What is your goal of doing this? It seems that you're just making the code needlessly complex. I'll take a simple struct declaration over macro abuse anyday. 
My thought was to take the input from argv, convert it to a string, and then read the string in to a function that that prints the all the characters together line-by-line. Your idea to reimplement the array in a different way might be the key to getting this to work. Or, maybe adding another array or some data structure to help make it happen.
Just take care not to alias two different structs. ( make two pointers of different types, point to the same memory at the same time ) For example, this code produces undefined behavior if 'a' and 'b' point to the same object. struct s_struct_a { int foo; }; struct s_struct_b { int bar; }; int bad_function(struct s_struct_a *a, struct s_struct_b *b) { a-&gt;foo = 1; b-&gt;bar = 2; return a-&gt;foo; } 
For fun, really. Or "educational" purposes. And for some practicality. With anonymous structs you won't have to worry about collision much, and they can even work for other structs of the same make (or at least I'm trying to make it so anyway). As I said above, if I wanted to, say, have a simple point structure, I can define what type I want, change the names of the underlying paired attributes ({a, b} -&gt; {x, y}), cast to compatible structures of the same type (I.E, your point is compatible with my point, and I get to alias the attributes). Not just for points either, but key-value pairs, or anything that can be tupled together as well. Plus without the extra concern for collision. Of course right now it's throwing warnings of incompatible pointer assignments and whatnot, and I'm trying to figure out if there will be any extra problems down the line.
I think you're just adding needless complexity. Hiding the definitions of structs with macros makes code more complicated, not simpler. To keep things simple, use typedefs with structs, or go all out and use void pointers, with functions to get/set the values, which you then cast to internal struct pointers. Just because you can do something with the preprocessor doesn't mean you should! 
I've a question, is there a way to disable the compiler warnings for particular casts between structs of the same type without having to disable all warnings? I know that -Werror would stop this in it's tracks, and -Wall produces a ton of warnings (at least from what I can see from ideone), but I was wondering how I would go about allowing the implicit casts without warnings. Also in your example, what exactly is wrong with it? Why would foo and bar produce undefined behavior if the struct is of the same size (?).
I mean, I suppose you do make a valid point. The issue I had with void *'s, was that it requires you to cast and know what the type is before hand. Plus, for the example of a point, to return a point you would have to allocate an integer on the heap (or tell caller to cast from void * straight to an int; which won't work for double/float). I suppose the only reliable way would be to use a normal struct declaration instead. Unfortunate.
*messed up accounts* &amp;nbsp; Thanks for the explanation on callbacks. They look pretty damn useful. I think I got most things to work on my implementations except for one. &amp;nbsp; First of, I used int instead of bool for the is_empty and is_full functions because we have 3 cases - stack is empty/full(1), stack is not empty/full(0), stack is null(I want to use -1 here). Is int a good choice or should I have gone for size_t and made the errors 0,1,2...? I did the same thing on push so it can return error codes. &amp;nbsp; I think I could have avoided all these small errors you found as in not checking for null etc. if I had remembered about unit testing before beginning. I watched a few videos about those and I really liked the way the tutor put it - If there is something that can break it put it in the unit test functions. If it can be NULL make a is_stack_null unit test function and so on. I think that would have saved me a lot of trouble. What's your opinion on unit tests like these? Are they a waste of time that I can use to code instead? Or should I just create one for every possible thing that may break? &amp;nbsp; About the test where I casted like this *(void *) 2* I can't get it to work with the way you showed me. I tried doing int x = 2; starray_push(head, &amp;x); but all I get are addresses inside my stack and not the numbers. If I cast them however, it works. Am I doing something wrong? Should I cast the pop result to an int? &amp;nbsp; PS: oh got it to work. Looks like I had to do some fancy dereferencing. *((int*)stlist_pop(&amp;head)) So now I get how it worked last time I was casting. I wasn't actually sending 2 but rather the address 0x00000002. And that's why it appeared on the screen without any casting to int - I was using %d in printf on 0x00000002, which gets me 2. So looks like the downside of the void* being able to point at anything is that I have to cast them myself on the client side. It seems kinda ugly but I guess it's pretty impressive that it can hold every possible type. PS2: Oh I went ahead and looked over your post prety fast the first time because I was eager to checkout the commented code and I have missed the next to last piece of code which contains the dereferencing itself..well I guess the journey will make me remember it better. &amp;nbsp; I guess the dereferencing doesn't have to be on the client side after all. I could create some functions in the header and the implementation file to do it for me. For an example I could have something like: &amp;nbsp; int get_int(void *); but the problem with it would be that it can't know for sure you are passing it an int and if you pass another type like a char for an example it will return jumbles. &amp;nbsp; Anyways I'm too tired to brainstorm any further. I updated the ADP repo if you want to take a look. Thank you for all your help and if you have anything else to add please do so! 
I am familiar with the FFT but I was unaware of this, I must go read now!
This was mostly a for-fun thing I thought about once I found out recently that C++'s STL had a Pair utility class, and I figured "I can probably do something like that using the pre-processor". I just like implementing things like that, I.E back-porting, because I always end up learning something new.
Your smile at the end shows that you're being (slightly?) funny, and I'm glad. There's some truth to what you say. Languages like Python are very powerful and capable, but one downside is that by hiding the complexity of what they do, the programmer doesn't always appreciate it, nor understand the performance impacts.
you're being way too harsh man, unnecessarily. what's not useful to you may be useful to someone else. 
The smiley was to be friendly. 
The last question is the easiest to answer---you should always use "int main" as "void main" isn't legal C. If you see it being used, it's wrong. Now to answer your first question---main is the starting point for a program written in C. When a program is compiled and executed, it starts executing at main---the main function. The "int" portion of "int main" means that the main function will return an integer to the caller, and in this case, it's a value that is returned to the operating system, which now gets to your second question, the "return 0" bit. By convention, a "return 0" means the program ran without error and anything else means the program failed for some reason. It's up to the operating system (or possibly the program that asked the operating system to run this program like a command line program) to deal with the return code.
Okay, does that mean that if changed it to char main, the value returned will be a character? And if the value returned is an integer, how come I can use strings inside the code that when run give out out sentences? 
So I have a very topical understanding of malloc, realloc and free. Is the essential advantage to using malloc (to reserve a block of memory in the heap) that you can decide to extend the block size if the program (while looping for example) approaches the edge of the block size? Whereas with the option of simply creating a large reserved section in the stack by using a large buffer, you simply have to guess at a large size to try to avoid overflowing? Thus by using malloc and realloc you can start at a reasonable size and expand as necessary, instead of guessing to small and overflowing or guessing to large and wasting stack space?
&gt; does that mean that if changed it to char main, the value returned will be a character? No, the only acceptable return value for the `main` function is `int` &gt; how come I can use strings inside the code that when run give out out sentences? I don't understand what you mean by this. Can you show an example? Are you calling `return "some text";` in your code? Because that's wrong as well.
Thank you, I really appreciate the example. This is a topic I really don't have a great grasp on, but I'd rather start trying to figure it out early on in my C work. Do you have any suggestions of resources that break down heap memory allocation, malloc, realloc, etc in great detail?
The heap gives you a few nice properties: size (the amount of memory you can allocate on the heap is roughly all of your memory); duration (heap memory is available to you until you free it[careful not to lose your last reference], stack memory is freed when the frame returns); dynamic sizing (while you can do some things on the stack to extend the amount of memory you need at run time, you really should use the heap if you might need to extend your allocation).
I don't like to be the bearer of bad news, but you're risking breaking tons of rules if you don't forward-declare your `struct`. Being that I tried to create a data-type exactly like that, I realize that having to do that pretty much shoots the idea in the foot, too a degree. Your `PAIR_CPY`seems to be legal to me on just a preliminary examination (though you need to use `memcpy`, not `memset`, but I'm presuming that was just a typo). Whether it's a good idea is debatable - you're using `memcpy` to get around the fact that you can't assign them directly. That said, your `PAIR_CAST` will result in some rule breaking. The big issue is one of strict-aliasing. Since the compiler sees `p` and `q` as both pointing to anonymous `struct` objects, they are inherently treated as 'different' types. This means that if you assign `q` to `p`, and then access the members through `p`, you're breaking strict-aliasing because you're accessing the data from `q` through `p`, and they don't have the same type. You can think of it as essentially creating two separately named 'pair' types with identical members - even though they're identical, you can't access the members of one from a pointer to the other - the compiler *will* screw you over on this. The way I 'solved' this is by using a macro to do forward declarations, and another macro to generate the type name (You can decide for yourself if you want to leave the `struct` keyword off or not). So: #define PAIR(name) _pair_##name #define PAIR_DECLARE(type1, type2, name) \ struct PAIR(name) { type1 t1; type2 t2; } To use: PAIR_DECLARE(int, int, intint); PAIR_DECLARE(char *, int, str_hash); int main() { struct PAIR(intint) int_pair1, int_pair2; int_pair1.t1 = 2; int_pair2 = int_pair1; return 0; } How it works is fairly self-explanatory. It does 'pollute' the `struct` namespace, but since you hide the name behind a macro you can make it as complex as you'd like. Personally I would find this acceptable if it weren't for the extra 'name' you have to provide like "intint" or "str_hash". The reasoning here is that, while you'd like to just use the types themselves to generate the name, something like `#define PAIR(t1, t2) _pair__##t1##__##t2##`, types like "char \*" break this idea because they can't be translated into a legal `struct` name, because the `*` isn't a legal character. Types like function pointers and such cause problems as well. That said, it *would* work for generic non-pointer types, so in that way it could have some limited utility.
I can't imagine any person this post might be usegul to.
Use `fmemopen` if your platform has it.
Yes I think I'm getting the hang of it little by little, by my instructors don't really explain stuff quite well, so I'm having trouble understanding. I'm also at a basic level, so as a last question, does bool work on C? The boolean?
hmmm, okay :D thanks in advice
Yes. bool is a type in C. Like mentioned earlier, C doesn't know the difference between data types. So TRUE is represented as 1 and FALSE is 0 (in memory, not in code).
This tutorial might help: https://www.happybearsoftware.com/implementing-a-dynamic-array
then if it gets more complex I will actually need a makefile - I will have one soon anyway as I will need the math library to compute distances. I am not sure what you mean by 'remotes' in my local git repository... I will research that. Is there a good GUI for git / github that I can use to simplify this stuff - I am attacking two fronts C programming and Use of git. and learning in both areas. 
At the moment I am working on some modifications to PostgreSQL for this I needed to have a dynamically sized stack and list. [Here](https://bitbucket.org/muyajil/postgres-ssdacp/src/8368aa1ddf6eef0f060b7d67217cfc9788a271d5/src/backend/access_control/context.c?at=build_maps&amp;fileviewer=file-view-default) you can see their implementation. Basically it is what the others wrote, but it is a further example. If you ask yourself about the resizing, it is something we learned in the first year of CS, since realloc can be an expensive operation, doubling the space each time is considered to be the most effective.
Seems you're pretty new to C concepts, I'd recommend either following along some video tutorial or getting 'The C Programming Language' by K&amp;R and going through that, to save yourself some confusion or perhaps getting the wrong idea about what some things are
I recommend reading [git scm](https://git-scm.com/documentation). If you are using from the commandline, you can also use `git help &lt;command, eg. remote&gt;`. Depending on the environment, it either opens a man page or opens the webbrowser and displays the help there. There is a small [list of GUI Clients](https://git-scm.com/download/gui/linux) you can use, like "Git GUI" in [git-for-windows](https://git-for-windows.github.io/) or [TortoiseGit](https://tortoisegit.org/) (Windows, uses the context menu). make can be a bit complicated at times, so if you want it really easy, you can use cmake, in which you can create a executable with 3 lines (or 4 with library linking). I also recommend reading something like a book for C (eg. a free one, like i did), so you know the elements and the functions you can use by default in C.
Without looking at your code, I would guess that you're not NULL-terminating your strings properly.
Yeah, you're not nul-terminating your postfix string. And I think based on argument names your eval function expects a postfix expression, while you're giving it an infix one. You're also passing it the wrong value for size. Your example output isn't the same as what your program outputs either. The order is different. When your code and examples don't match up it makes it difficult to help.
Post the code. Are you using `%o` with scanf?
No, but you shouldn't be using `%i` either. `%i` with scanf means that it autodetects the base of the number (hexadecimal with a leading 0x, octal with a leading 0, decimal otherwise). If you only want it to parse numbers as decimal, use `%d` instead
There is the renaming thing: http://puu.sh/nX8tT/f6b657b6b8.png If you use google, you can also find a help on github on the next steps after the renaming: https://help.github.com/articles/renaming-a-repository/
No it isn't, because the first one `int x[5];` doesn't have a initalizer while the second one `int x[5] = {};` does have. So the first one just have garabage. This can be easily tested. Define `int y[5] = {};` and `int x[5];` and print the values from every of them. The values in y will always have 0 while the values in x are random. #include &lt;stdio.h&gt; int main() { int i, x[5], y[5] = {}; for (i = 0; i &lt; 5; i++) printf("x[%i] = %-15i; y[%i] = %-15i\n", i, x[i], i, y[i]); return 0; } Output: (compiled with mingw-gcc 4.8.1) x[0] = 2686824 ; y[0] = 0 x[1] = 4200654 ; y[1] = 0 x[2] = 4200560 ; y[2] = 0 x[3] = 4194432 ; y[3] = 0 x[4] = 2686756 ; y[4] = 0
Probably, assuming your `int`s and `char *`s are the same size. The point is that doing this is wrong, because a) that pointer is useless after your program exits and b) you shouldn't rely on `char *` and `int` being converted implicitly. This should produce a compiler warning.
Arbitrary values are arbitrary.
Right. Thanks!
The values are not random, but rather garbage data. Saying they are random might lead to misunderstandings. I saw this in someones code once. int fastRand() { int i; return i; }
The whole program is more than a thousand lines of code. Why do the arrays need to be at least 5 entries long? (sorry kinda new at this.) But yeah all of them are
I don't quite fully understand what you're attempting to do in your code, but I think that a structure would be a suitable data structure to contain the bank account information(credit,checking,savings). 
&gt; There's 4 players btw (thats' why i=0,1,2,3) the player[4] is the dealer you start counting from 0. if there are 4 players, there's player[0], player[1], player[2] and player[3]
`int x[5] = {};` is ill-formed. Maybe you are thinking of `int x[5] = { 0 };`, which initializes all of the elements to `0`. The `int x[5];` behaves differently depending on the storage duration. For automatic storage duration the ints are uninitialized; for static storage duration they are initialized to `0`. 
&gt; y[5] = {} This is illegal in C, your compiler should say something. (If not then it would be a good idea to invoke the compiler in conforming mode).
Ahahaha damn, i'm dealing with pros here xD that's exactly what i had. Thank you very much guys!
Happy to help, and I wish you luck on your future programming endeavors, however there is one more thing I'd like to say. Try not to split up everything into different GitHub repositories, especially if they really belong in one. Your ADT implementations repository should be your only one, and I advise you really add everything else to that. I see a ton of undergraduate profiles (I'm an undergraduate myself) who have like 10 - 20 repositories with almost nothing in them, which just makes people not want to shift through each, even if you did have one really good one. A repository with 100 commits will look better than 20 with 5 each, know what I'm saying? Hash maps aren't too difficult, at least not after you get the figure out how to hash. Plus the hashing algorithm is mostly just whatever the most convenient and implementable algorithm you can find, I.E [Bob Jenkin's Hash](https://en.wikipedia.org/wiki/Jenkins_hash_function). Then you get the hash from the hash function, and obtain the index by using modulus division based on the amount of buckets. So, if the hash returned is 1234567890, and if there are 64 buckets, the index is 1234567890 % 64 = 18. Hence the actual index is just 18. However, once again, that's a lesson for another day. Good luck, and if you need any other help, feel free to ask me or anyone else on this subreddit, we're generally a helpful bunch.
I'm pretty sure that local identifiers with a leading underscore are allowed as long as they're not followed by an uppercase character.
When I transitioned from Windows to Linux full time, I started with running Ubuntu in a virtual machine (virtualbox). If you get used to that, you can start dual booting Linux/Windows (although this has occasionally rendered my computer unbootable due to Windows overwriting the master boot record, so be careful). Eventually, you can just install Linux only on the hardware, and run Windows in a VM. Since you asked for a specific version, I'd suggest Ubuntu 14.04 since that is a long term support version.
Regarding a specific flavour, I can definitely recommend Xubuntu. Its got a nicer, more familiar style than standard Ubuntu and it runs faster (less 3D effects, etc). Good luck!
VirtualBox for Windows hosts is what you'd use - Windows will he hosting your VMs. Linux will be a "guest". If you need some specific software such as MS Office or etc, you'd need to run that under Windows. So, you'd run a Windows "guest" for this software, under a Linux host.
For what you want, you'll download Virtualbox for a Windows host. The virtual machine doesn't know anything special about the OS it runs (or at least that is the idea). You can run a Windows vm inside a Windows host. This is nice if you want to run a different version OS inside your main OS for testing. I do a lot of web dev, and for this I need to test in IE every once in a while. Having a Windows VM I can boot up and test IE with is essential. I'll never dual boot with Windows again. If I get rich, I might also just buy multiple computers.
Just for fun, sometimes variables will get allocated in the same location on the stack too: #include &lt;stdio.h&gt; void f1(void) { int i,x1[5]; for (i = 0; i &lt; 5; i++) printf("x1[%i] = %i;\n", i, x1[i]); } void f2(void) { int i,x2[5]; for (i = 0; i &lt; 5; i++) printf("x2[%i] = %i;\n", i, x2[i]); } int main() { f1(); f2(); return 0; } Output: x1[0] = 1; x1[1] = 0; x1[2] = 0; x1[3] = 0; x1[4] = 4195920; x2[0] = 1; x2[1] = 0; x2[2] = 0; x2[3] = 0; x2[4] = 4195920;
OK, so first it is important to note that when your program runs, it will only run the contents of the `main()` function. You will have to call your `AccountBalance` function within the `main()` function. Try starting there and see what happens.
You can compile a project using this command gcc -o out main.c Where `gcc` is the compiler, `-o something` shows what will be the name of the output (-o = output) and any argument without a `-` is a file (in this case `main.c` is a C file). The arguments `-Wall -Werror` are for warnings (-W = warning). They are optional, but can help a beginner understand why something they did is wrong, and to get better habits. I also like `-Wextra`, that (if i'm correct) shows warnings that are not "that" important, but are still warnings.
I had been programming for years in C before ever trying an object-oriented language. After trying out C++ and learning the power of encapsulation and abstraction I realized that I wasn't using these techniques in my C programs and overall I was a pretty terrible programmer. In my opinion, programming in and object-oriented language forces you to think about data and the responsibility of each component in your program in a different way. My two cents: Learning C is great and is a really easy language to get into, but dive into C++ just for a taste and then apply some of those techniques to structure your programs.
I learned C from the King book, it's a great book. You don't need linux to work with C, I was able to use gcc by installing code blocks and running gcc from the windows command line (There's a youtube video that shows how to do this). Other than that, I have since installed a separate Ubuntu partition on my hard drive and I do all my programming there now.
You should crank your compiler warnings up to the max. I see one obvious error involving trying to read a string with scanf and storing the result in a char that can cause memory corruption.
is that the answer char? do you think that is what is causing the error? how do i go about fixing it i tried making answer and array but i breaks the rest of the program 
Please do not use -Werror but do compile with -O2.
You made excellent choices with your books. King's book will give you everything you need to learn 'modern' C. K&amp;R expects you to have some basic theoretical knowledge (linked list, stacks, parsing, etc.). It starts gently but ends up using concepts you need to have to understand the book. A great way to follow after King's book. If you enjoy the K&amp;R, I would suggest you to have a look at the delightfully obsolete 'The Unix Programming Environment" by Brian Kernighan and Robert Pike. It will give you a great taste of the original Unix frame of mind. 
What's the issue with using -Werror?
Thanks, I had heard the term "function pointer" used, and have used them myself for calling a specific "updateprogress" function during a loading routine. But could never separate them from that single use scenario. I'll have a bit of a practise, then implement! I've bookmarked that page for reference until I get a good grasp.
Isn't -O2 about optimization? I'm curious.
Makes sense, never thought about it that way. However for the OP, maybe while learning a language it would be good to keep the option on with gcc (which I would expect to have sane warnings), so that good programming habits are enforced from the get-go. All depends on the situation I guess :-)
Yes, but many warnings only trigger with optimizations enabled.
Not all warnings are errors. Not all suggestions gcc makes are correct. Attempting to satisfy the compiler does not make programs more correct. You need to understand why the warnings occur to use them effectively and you can't do that if you never run a program where the compiler gives warnings. Failing is an important part of learning.
If you like an xfce distro based on Ubuntu, try Ubuntu Studio. My personal preference is Linux Mint.
Just install Ubuntu. It's the most Googlable distribution, it's user-friendly and will have pretty much anything you need included or easy to install.
You can use K&amp;R in Windows, just skip the chapter on Unix. Or write the programs and if you get an error that there is no such function it's probably because that was a unix function. 
as long as -Werror is not in final build it's fine.
Thanks! - Definitely did my research on the books. King is so far so good. I'll have to check out that Unix book some time in the future!
I'll have to look into codeblocks, haven't heard of it. I'll probably download anyway just to compare the different options. I just figured that, since I'll be learning learning C, that it'd be probably be a fruitful experience to get used to using Linux. They seem to go hand in hand. Edit: Looking at codeblocks right now. Is there a specific version that I should download?
It sounds like you're not specifying any source files for your executable, or only one but no executable name (which should come first) For more accurate help you should post your actual CMakeLists.txt, either directly on reddit with 4 spaces before each line to make it code-formatted, or through a service like pastebin. ~~/r/cmake might also be more helpful~~ (nevermind, it seems pretty empty)
Output: 28 1 [^source](http://ideone.com/9Oe3M5) ^| [^info](http://www.reddit.com/r/CompileBot/wiki) ^| [^git](https://github.com/renfredxh/compilebot) ^| [^report](http://www.reddit.com/message/compose?to=compilebot&amp;subject=Report%20Abuse&amp;message=--report%20https%3A//www.reddit.com/r/C_Programming/comments/4cevb5/passing_pointer_for_an_array_argument/d1hjz0t%20Include%20your%20reason%20for%20reporting%20here.) **EDIT:** Recompile request by Meanda
Do some pointer math. Let's visualize it: Pos: 0123456 Str: Hello! Ptr: ^- Pointer The length of this string is 6 characters. So if we add 6 to the pointer, then the pointer points to the terminating character (\0): Pos: 0123456 Str: Hello! Ptr: ^- Pointer Off by one! So we just fix it by subtracting it by one, so it points to the last character in the string: 0123456 Hello! ^- Pointer So the formular is `str + str_len - 1`, where `str` is the pointer to the string and `str_len` is the length of the string. Let's test it with some code: #include&lt;stdio.h&gt; #include&lt;string.h&gt; int main() { char str[] = "Hello!"; printf("Normal: %s\n", str); printf("Last: %s\n", str + strlen(str) - 1); return 0; } Output: Normal: Hello! Last: ! Yep, it works!
Honestly, you will already have to learn new things by picking up C. Learning Linux on top of it will dilute your memory and *will* send you down paths for recovering errors taking a whole day and leaving you frustrated and nerve wracked. In embedded environment, none of the Unix tools will be present. There is no need for you to be familiar with them. That'd be nice, sure, for a better, general understanding of trying C on different platform. But for a simple entry-level self-exercise, you don't need it. I'm saying it from the viewpoint of someone using linux exclusively for 5+ years (and a long time before that with dual booting), and working on it as my day job and my hobby.
Maybe OP is unclear, but I understood it as he wants to print a string from a beginning pointer to an ending pointer. Either way, you are correct, I need %.*s instead
You are correct in your interpretation of my ask. It was not well phrased on my part. Sorry about that. What's appearing problematic about this is that the embedded system I'm working with doesn't have a rich enough printf() port to support passing %.*s coherently. I think my next step is to try incrementing the pointer from the start of the token to the start of the next token, and putchar()'ing each character one at a time. 
This is correct, but not what I was interested in. I blame poor explanation on my part. :) I'm rewriting a simple strtok_r function for an embedded system, as it is not implemented there. I'd like to be able to pass a whitespace delimited string to the function Tokenize() and have it return a pointer to the first delimited substring. For the phrase *quick brown dog*, the function should return a pointer to the start of "quick", and should store a pointer to the first space (the one between "quick" and "brown") in char *save. That way, a second call to Tokenize can use char *save as the starting point of the next tokenization - the second call should end up returning a pointer to the start of "brown", and char *save should contain a pointer to the whitespace between "brown" and "dog". I've got enough printing capability to do putchar() and a simple printf() - what I don't know is the proper way to manipulate the returned pointer and char *save to print only the letters in the substring. Further complicating matters is that /u/_5__'s suggestion of using %.*s doesn't seem to be supported in this printf() port. Here's my code in case it helps. Thanks for your answer! char *Tokenize(const char *buffer, const char *delim, char *save) { char *token; if ( *save != NULL ) { token = save; buffer = save; } else { token = buffer; } while ( *buffer != NULL) { if ( *buffer == *delim ) { *save = buffer + 1; return token; } buffer++; } return NULL; }
In that case, your method could work. You could also use strncpy to copy the segment to a new string, and null terminate it manually. However this can use up unnecessary memory, which you might not have spare on an embedded system.
I appreciate the honesty. I'm interested in Linux because the books I mentioned seem to assume that you're working in a UNIX-environment. It doesn't seem like it'd be too much extra work, but I'll keep this in mind. You're right though, I'd prefer to focus on the C aspect for now.
If I understood you correctly, set *buffer to '\0' before saving *save and returning token. BTW, NULL is guaranteed to be the same as 0 only in a pointer context, you should use '\0' (or just 0) instead to represent the nul (one ell) character. 
&gt; Your main question is: Do I want to use an ide? Yes, yes you do. IDE's for small or 'just learning to code' projects might be overkill, but once you start debugging large projects you'll quickly find out that breakpoints, watches and all the other tools an IDE provides are time saving and worth the effort to learn the IDE. While learning to how write a make file is a good skill, it can be a major PITA once you get to a certain project size. Other than linux fanboys no one will care if you use an IDE or cmd line. Once you get a job, you will use whatever tools they have... and most likely that's a IDE.
Thank you!
The way strtok_r works is that it replaces the delimeter with a NULL byte, and stores the original end of the string in **saveptr. The man page tells you exactly this. It's up to you to implement it the same way - if the first argument is NULL and saveptr is not, then you know to continue where you left off.
&gt;Yes, yes you do. IDE's for small or 'just learning to code' projects might be overkill, but once you start debugging large projects you'll quickly find out that breakpoints, watches and all the other tools an IDE provides are time saving and worth the effort to learn the IDE. Until you get to really large code bases and your ide goes "lol no", eats all your ram and crashes. Between gdb and ctags there is no reason to ever touch an ide, unless you want to experience what a trying to write on a substandard editor feels like. If anything IDEs are only good for small and medium sized learning projects because they choke on real code bases.
At work you have little choice. Use their toolset or else. If your workstation can't handle a project then its either a hardware issue or a project management issue. And most of the time you are working on a dll or lib that does not require a full build. I work at a Fortune 50 corp with billions in sales annually. The largest application we run is a few dozen MB, that chews up a few Gb of data. Largest dev workstation has 64Gb RAM, most have less than 16Gb. 
I've edited my post with the CMakeLists.txt file. 
Text does not contain the null byte. Text must not contain the null byte. Standard library functions do not support strings that contains null bytes. Do not try to find anything that supports null bytes, you won't find it.
There is no simpler way of fixing that 
You have it just slightly off! project("MY_PROJECT_NAME" C) ... add_executable(Project_Name main.cxx) target_link_libraries(Project_Name ${GTK3_LIBRARIES}) `add_executable` requires you to create a target name. `target_link_libraries` requires you to specify a target name. You accidentally passed your project name to `target_link_libraries` and never specified a target. The project name is something completely different. Be sure to consult the cmake documentation directly when in doubt (i.e. Google "cmake add_executable").
...I find your comment confusing and a little needlessly aggressive. 
I tried your solution but I'm still getting the following error: -- Configuring done CMake Error at CMakeLists.txt:8 (add_executable): Cannot find source file: main.cxx Tried extensions .c .C .c++ .cc .cpp .cxx .m .M .mm .h .hh .h++ .hm .hpp .hxx .in .txx CMake Error: CMake can not determine linker language for target: Project_Name CMake Error: Cannot determine link language for target "Project_Name". -- Generating done -- Build files have been written to: Here's my code with the changes you suggested: project("Project_Name" C) cmake_minimum_required(VERSION 3.5.0) find_package(PkgConfig REQUIRED) pkg_check_modules(GTK3 REQUIRED gtk+-3.0) include_directories(${GTK3_INCLUDE_DIRS}) link_directories(${GTK3_LIBRARY_DIRS}) add_definitions(${GTK3_CFLAGS_OTHER}) add_executable(Project_Name main.cxx) target_link_libraries(Project_Name ${GTK3_LIBRARIES})
It's in the default location where it is put after creating a new Xcode project. So for me it's in a yellow folder called Project_Name. 
I have no clue how your project is structured, but relative to your `CMakeLists.txt`, you have to specify the path to your `main.cxx` file. 
Hmmm it would be simpler to read just one char with %c, cus i tried making answer an array so it can take a word but something didnt go right. Thank you all, youve giving me new things to try hopefully i can get it to work so i can keep learning more complicated things 
If you want to read a string, you need space for that string. An empty string will contain just a NULL terminator, so that's one byte. How big is 'answer'? A string that just contains 'y' will be two bytes ( 'y' + NULL = "y"). How much room did you save for that with your 'answer' variable? Also, you're going to find out next that you can't compare strings with '==', though you can compare characters. You can use google to find out how to compare strings in C or search them for the characters you are looking for. 
I'm surprised you got stuck, because that's pretty much all that `strtok` does: find one of the delimeter characters, and replace it with `'\0'`. It says so right in the man page: &gt; The end of each token is found by scanning forward until either the next delimiter byte is found or until the terminating null byte ('\0') is encountered. If a delimiter byte is found, it is overwritten with a null byte to terminate the current token, and `strtok()` saves a pointer to the following byte; that pointer will be used as the starting point when searching for the next token. If it *didn't* replace the delimiter with `'\0'`, it would be no different than `strpbrk()` or `strcspn()`: find the character but do not replace. BTW, you need to use `char** save` in `Tokenize()`. You ought to be getting a type mismatch at `*save = buffer + 1;` with the current version. And `buffer` needs to not be `const`, although you probably already figured that out.
Another suggestion, not that you need anymore if you're overwhelmed, but Lubuntu is another nice slimmed-down variation on Ubuntu. If you're wondering how different these *buntus are, well, not terribly. You could take any one and using the package manager, turn it into any of the others by installing and uninstalling stuff. So my point is, don't fret too much :) But I personally suggest something a little slimmer than Ubuntu.
I should have done that, but nevermind. It feels strange, because the types are different and in any other language I can think of, something like this would give a compile error.
In C, an array degrades in to a pointer. You will learn much more if you experiment. Your post would have been so much better if you had started with "I wonder why this works....." :) 
&gt; We use this as an interview question when we're looking for candidates. Goodness, for what kind of job? As a firmware engineer I would find this challenging, since I have no reason to know offhand how to multiply bigints.
deftware, if possible can i have a look at the source code? Thanks
Crypto and security. Working with extremely large numbers comes with the territory to a certain extent. We don't expect most people to know it off the top of their head--in fact we're mostly hoping that they don't so that we can see how a candidate will approach a problem. It's at the end of a series of questions like: - if you add two 32-bit numbers, how many bits of storage do you need for the result? - how much storage to multiply two 32-bit integers? - how would you represent those results? What would the functions look like assuming you're limited to using 32-bit integers? How about multiplying indefinitely large numbers? etc 
You could download a public domain implementation of `vsnprintf` , if your system's one is broken (although it seems unlikely that it would have `printf` but not support such a basic feature). 
`printf` also allows to operate on length-counted character data. 
Experiment, then read, then experiment some more.....then find the ANSI standards,.......
Nope. `printf` still stops printing at the first nul byte.
sure, I wrote it a few years back and there's probably a lot that I could have done differently (ie: better) but hopefully it will be enough to get you started. I'll pm you a link to my dropbox.
Is your main file named `main.cxx` or is it named `main.c`? Are your programming in C or are your programming in C++?
Try "Project_Name/main.cxx" But you should really show us the complete project. That would be much easier to help you.
Function prototyping serves a few purposes. if you're just starting, the most important thing it does is code cleanliness. You certainly don't need to prototype your functions in most cases, but it does provide a nice catalogue of the functions available to you or whoever may be using your code. It does have a purpose beyond readability, defining a function prototype will let your program "know" about that function, and what parameters it will take. Trying to call a function that is not yet defined (for example, say if you had two functions that would call eachother) your compiler will whine. without prototypes; void A () { B(); } // Who is B? void B () { A(); } would simply not work because A does not know about B. to fix this we would go: void A(); void B(); void A () { B(); } // oh, I know who B is! void B () { A(); } that being said, modern compilers may not work this way and may just autodetect your functions, but I don't know about that. As far as I know, variadic functions require a function prototype as well. 
From the printf man page, regarding the `%s` conversion specifier: &gt; The const char * argument is expected to be a pointer &gt; to an array of character type (pointer to a string). Characters from the array are &gt; written up to (but not including) a terminating null byte ('\0'); if a precision is &gt; specified, no more than the number specified are written. If a precision is given, &gt; no null byte need be present; if the precision is not specified, or is greater than &gt; the size of the array, the array must contain a terminating null byte. 
This is probably more pedantic than the OP needs right now, but main can have any return value you want (and any input parameters) if you're in a freestanding environment.
Yes, in a practice, you should never dereference an uninitialized pointer, this was just a short example for presentation.
Compilers aren't magic black boxes! In the old days, compilers were severely limited by resources, so people defined language rules to make sure the compiler would run as efficiently as possible. If calls to a function could appear before the declaration of the function, then the c compiler would have to read the whole document, find and store all function declarations before it could begin reading any function body. That would require making 2 passes over the source code. That is wasteful use of computer's resources, so instead the C language standard requires that within the body of a function, only calls made are to functions already declared before the function body. Thus the compiler only has to go over the source code once, doing all the processing on the spot. 
That's a possible reading, too. I think I misunderstood the question.
http://hentenaar.com/dont-learn-c-the-wrong-way
Read that. A lot of it, apart from the setup, is Hentenaar's own issues with syntax and stylistic convention. He also tends to falsely equate "Learning C" to "learning *everything* about C" - for the sake of his argument, I think. 
And if instead of a prototype, we have the full definition, above main(), all the better as far as the compiler is concerned? I get the "why" of it, sort of, but I feel like there's still some hidden truth about function definitions, prototypes and maybe overloading, since I noticed I can repeatedly prototype the same function with no problem. Maybe that feeling is wrong. Maybe I need to study how compilers work!
No, I'm new to C but not to programming, I'm fine with lots of pedantry.
I already understand why the convention is there, I'm just wondering about any sort of deeper insight on what a prototype is. I have a suspicion it's not actually special, something like it being just a specific kind of function definition that sets aside memory or something.
There's no hidden truth, the function prototype is literally just: "Hey compiler there's a function named 'x', it takes these argument types and returns this type". Your function x doesn't even have to be in the same .c file as where it's called, the compiler just knows to put a placeholder wherever x is called and to come back to it once it knows where x is. For example when you include stdio.h, it contains the function prototype for printf (amongst other things), and you won't (typically) compile a .c file which defines printf, rather it has already been compiled into the .lib containing the C runtime library and the linker puts it into the executable after compilation. Don't worry if you don't understand this stuff yet, it is something you probably won't need to know straight away, I just thought I'd go into detail. As for the compiler allowing multiple identical function prototypes, it is (as far as I know) just a convenience, so you could have (for whatever reason) 2 headers that contain declarations for the same function and be able to use them together. Oh and also, the only reason you would ever prototype main() in your code is if you were going to call it before it was defined, but I don't think you're meant to ever call main yourself, and I certainly can't think of any reason I would.
In C, *declarations* specify types, and *definitions* allocate storage (i.e., set aside memory). Function prototypes are *declarations* for functions. They're analogous to declarations of `extern` variables: /* These can be referred to, but don't allocate storage. * They must be defined in another object file. */ extern char **environ; void exit(int status); /* These allocate storage in the current object file. */ double square(double x) { return x*x; } const char sentence[] = "The quick brown fox jumps over the lazy dog."; int n; The only confusing part here is that a variable declaration without `extern`, like `int n;` above, is treated as a definition *as long as the variable hasn't already been defined,* and as a declaration if it has.
- There's no reason to use calloc() here. malloc() will be at least as efficient, if not moreso - There's no need to use snprintf if you know the size of your string and the size of the buffer you just created. Just use strcpy(). - There's no need to use printf to copy strings, at all. See above. 
It absolutely does. Thanks for the tips!
To jump on the unsolicited feedback train, OP should not be using `unsigned long`, either. The only thing you should be using to store the size of an object is `size_t`
Ah, neat-o. I didn't know about this function.
Thanks for the feedback. Yeah, this is definitely something I wondered about when I was originally deciding where to put them. The book I am learning from (Kochan's 'Programming in C') uses function declarations both inside and outside of other functions and doesn't really go in to detail about when it is or isn't appropriate to use either convention. My reasoning was to place them based on their scope. The function declarations I placed inside of main() are only used in main(), whereas the function declarations I placed outside of main() are used in multiple functions. The C compiler doesn't seem to be complaining either way.
`strdup` isn't standard, though.
It's valid, just unusual.
&gt; My reasoning was to place them based on their scope. The function declarations I placed inside of main() are only used in main() Makes sense to me. I haven't seen it very often, but from the standpoint of reducing clutter at the top of the file, I can't argue with your reasoning.
Well, suggesting I use a header file is exactly the kind of feedback I am looking for! Hehe. What would you suggest I put in the header file? Everything above main()? So, all #include and #define statements as well as all variable and function declarations? Edit: Oh, are you saying I create a header file along with *another* c file? Can you elaborate more on that?
This is how I was taught: When some function is used across many files, there should be a .h file that has its header (which I think is the same as a prototype), and there should be another *separate* .c file that has the code for this function. This way, if using a function in multiple spots, there is no copy-pasting involved, as you only need to include the library file. So for example, say I define a function &gt;int get_member(void); in a file called myfunc.h; then, I create another file called myfunc.c which has all the code needed for the function get_member(). Edit: Oh, and functions which are only used in one program once are defined (with no header needed, just the code itself) *above* the main function in your main program. 
Yup, That all makes sense. Since I don't really have multiple files containing code, there doesn't seem to be a reason to create a header and corresponding c file. I suppose that's the reason I never did that to begin with.
Hmm its interesting to see the things other people do in their code. In any case, good stuff! I hope you don't feel like I'm critiquing you haha I'm just curious
Have a look at the sidebar. I like *The C Book* by Banahan et al, because it's a solid intro for free, but most people on this sub are huge advocates of K&amp;R even though it costs money.
I was thinking I had to use a pointer, but I am not too positive how to use them. I am still currently learning them.
Please see the sidebar under Resources =&gt;
Have an array to keep track of the distinct numbers. I would recommend iterating through the number to get each digit and add it onto the array if it didn't exist already. 
Well -- there are two problems: You need to be able to take an integer and extract value at every order of magnitude. Can you do that? Be aware that integer division in C truncates or in other words rounds toward zero. So 11 / 2 is simply 5.
If you want to do math, converting to a character array isn't doing yourself any favors. What calculations do you need to do?
Not sure why people aren't mentioning modular arithmetic... Consider a d digit integer n expressed in base 10 as d1 d2, ... dn. Then di = n/(10^(n-i)) % 10. Eg, n = 1234567, d7 = 1234567 % 10 = 7 d6 = (1234567 / 10) % 10 = 6 And so on. From here you can easily determine the digit count as well as the unique set of digits. 
That's doable, but you'll have to do the XOR manually.
My humble attempt at doing this... void convert(int hex, char *binary) { if(hex &gt; '9') { hex -= 'a' - 10; } else { hex -= '0'; } //if hex &lt; 0 or &gt; 15 then error int index = 3; while(hex &gt; 0) { binary[index--] = (hex &amp; 1) + '0'; hex &gt;&gt;= 1; } }
Try compiling the two example lines i gave above with a recent gcc and -Wall. You *will* get warnings.
Are you seriously saying not using parentheses in this case is not standard-compliant? dude...what about 'a * b + c * d' ?
Til I'm blind. Sorry about that...
save to a file and read from that
I would just use a loop and scanf(). 
You compare the addresses of str and str2.
i ususally do a single scanf for the record count and then a looping scanf for the records storing in a length counted large array
So the ASCII is never compared?
If the strings are identical the compiler *might* store them at the same address. Remember that str and str2 are **pointers** to strings, not strings themselves.
Similar questions have been asked. [This one](https://www.reddit.com/r/C_Programming/comments/20eljb/what_do_you_do_with_c/?ref=share&amp;ref_source=link) has answers that include work and side projects.
a string in C is actually just an array of characters, an array in C is actually stored as a pointer to the first element of the array, and accessing an element through brackets (e.g. myArray[3]) is shorthand for taking the starting address of the array and adding to it the size of each element, multiplied by the index that the person is trying to access. so if you were to compare strings directly, that would actually be comparing the values of the pointers that point to the start of each string. Not the strings themselves nor their length. It's likely that on your edit, the compiler makes the "hi" as a constant to optimize a bit of space in the generated code and makes str and str2 point to the same thing. Regardless of what the compiler is trying to do, you shouldn't rely on that behavior and should use strcmp(), as you said.
Most of the heavy lifting stuff: protocol/socket engine, database processing, realtime applications. All of this with some C++ mixed in. 
&gt; If the strings are identical the compiler might store them at the same address. Alright. Didnt know this! Thank you. 
Are you sure it's an array of characters? I'm certain it's an array of bytes.
In C, sizeof(char) is always 1, so there is no distinction between bytes and characters, and, in fact, strings should be typed as 'char *'.
http://lmgtfy.com/?q=compare+strings+in+c
They are C strings. A C string is a NULL terminated array of characters. That's just how C works. Yes, other language do it other ways. If you want to make a 'string' type in C, go for it. No one will use it, and your code won't be compatible with anything else unless you also provide functions for converting to and from NULL terminated C strings, but you could do it.
That's what they're called, yes. In the same way a 'struct' is an object, it's similar but not the same as an object in a language like java. Saying it's a string these days, given C is pretty old, means people expect it to behave like the string concept they're used to, which it won't. C char arrays don't even *have* to be null terminated, just that they usually are. 
Yeah but you can still have one with no nulls and it'll work perfectly well so long as you know how long it is and don't use anything expecting a null. Also "foo\0but there's more! \0" is a valid C string/char array with three nulls in ig
Try building in debug. The compiler most likely does not optimize in that configuration
C strings and Pascal strings and other similar implementations predate string _objects_ or _managed_ strings in languages like C++, Java, Python, etc. In fact that use of the term "objects" comes after K&amp;R who used "object" to refer to typed data in memory, not "objects" in the "object-oriented programming" sense of things that have data and methods. It is more like the later languages used the same terminology for more complex objects that also hold text.
You're also incorrect. The standard states that: const char *astring = "foo"; Will produce a 4 character value 'f','o','o','\0'. That is a part of the language.
This is true only if you define "C string" as "a string you can use with standard C library functions." In practice it is very common to pass around text data in buffers with length values rather than bother with null termination -- for example, transmitting data over a serial link in fixed-sized packets. Of course when you write code like this, you should be careful to specify what it expects, in the API documentation, and in the implementation, I would recommend comments to clarify that you are working with unterminated string data.
A buffer containing binary data is not a string. I would call it a buffer. I think you're just being contrary for the sake of being contrary. Yes, you can have all kinds of arrays in C! Some of them are null terminated character arrays that are treated as strings, and some of them aren't! Wow, amazing. 
No, I'm not being contrary for the sake of being contrary, and I'm not talking about binary data. I'm talking about text data, in that the contents are the same as a zero-terminated string, but lengths are managed with external data counts. You could copy it into a zero-terminated string and printf() it (but not with strcpy() or its relatives). Or if you had space for it, you could write a terminating byte in the array and use it with standard C string functions. Let me ask you this -- if you were to _implement_ Pascal strings in C -- let's say you were implementing a Pascal runtime -- what would you call that data structure and the operations on it? Why, you'd call it a string, I think -- a Pascal string. Let's say you were to use C to implement a _Scheme_ runtime, or a _Haskell_ runtime -- what would you call those data structures together with the operations on them? How about if you wanted to pass text data to an industrial machine that had a UART and received data in a fixed packet and displayed it on an LCD display, but didn't handle zero-termination. I'd call that "unterminated string data" or something similar. Notice the common word? "String" is too general a concept to insist that if something is not a zero-terminated string in C, it is not any kind of string. Call it what you will -- a "standard C string" or "zero-terminated string," but there are other kinds. And -- this is an important point -- the other kinds are, in general, usually _better_ and _safer_. Standard C string handling is really a thing that in general needs to die. It is still a source of so many, many horrendous bugs and vulnerabilities -- Heartbleed, for example. Really worth studying. Insisting that a string in C must be the original zero-terminated kind holds back migration to safer techniques.
It's a C string...and we're back in circles. Okay, fine. It's a "null terminated character array potentially existing on the stack or the heap, and it may or may not be modifiable. Sometimes it's in RAM and sometimes it's in ROM and you can use it with the following functions......." Or, ya know, we could just rely on the fact that people using C who are wanting to know how strings work in C are asking about the standard, null terminated strings used across every platform on which C runs. Even arrays in which you know the length should be null terminated, in case someone ( such as the original developer, 6 months later ) passes them in to printf....... 
&gt;Relatively simple, actually, compared to what most people in this thread are doing. Yeah, it's not like Rocket science or anyth--wait.
The compiler warning you should be getting about mismatching types would be your first hint, the second should be that you're not using the variables `r` and `c` within your loop. Try fixing those first.
Should I change getpic() to int and in the loop, fscan(_____, &amp;*pic[r][c]);? Sorry if that is dumb, the pointers with arrays always confuses me a bit
If you want to do it yourself, you should probably look for "hashes". Basically, you need to create a hash for every single "key" and store them in order. If your hash generate a single number, you can use that number as index in a list (not linked lists, as you need to be as fast as possible to find elements.) If you don't want to implement it yourself, you can have a look at `hsearch`, which is a posix function, but it's a pain to use. If you want something nicer to use, there is [Glib Hash Tables](https://developer.gnome.org/glib/2.48/glib-Hash-Tables.html). And, finally, if your hash have a set of pairs and will never change, you can use [Gperf](https://www.gnu.org/software/gperf/manual/) to create perfect hashes.
Can anyone else help me with this? kindof lost
In my honest opinion, that is a different circumstance. It is perfectly acceptable to not put parenthesis there. I have yet to find a compiler that complains about that. I'm not trying to start a fight, but all I'm saying is that if multiple compilers warn about `if(a &amp;&amp; b || c &amp;&amp; b)`, then whether or not that is valid in C should be reconsidered. Please read [this for more information](https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B). Even if you do not believe that this is a part of the standard, using parenthesis makes the code more readable and easy to understand. For example, `if(a &amp;&amp; b || c &amp;&amp; b)` can be interpreted in many different ways by anyone who is not a C professional. It can be seen as `if((a &amp;&amp; b) || (c &amp;&amp; b))` or `if(a &amp;&amp; (b || c) &amp;&amp; b)`. So even if you do not consider it to be a part of the standard, it makes the code more clear and should be thought of as good practice.
Kernel developer, C all the way
1. you are opening the file for writing. You can't read any data with that. 2. you give your "displaypic" function an int with that call: &amp;nbsp; displaypic(pic[ROW][COLUMN]); 3. you declare "pic" in getpic to be a pointer to a 2D array, in your definition you declare it as an int pointer, this should also not be working. 4. as already mentioned, you are not using your r and c variables in your for-loops. you should try something like : &amp;nbsp; fscanf(infile, "%d", &amp;pic[r][c]); 
1) Okay, I changed the w to r to make it for reading. Thank you for pointing that out. I made changed, and I am still not getting the values. I am getting constant random numbers for 1s, and constant random numbers for 0s. I edited the original post of this with how my code currently looks
I edited my post a little after this and am lost. Was changing the functions to ints wrong? Man I hate arrays with pointers. Its so confusing :S
Embedded iot platform for ble and WiFi products running on arm cortex microcontrollers
Somehow this worked for a while by changing it to strcpy, but it looks like the advancement through the hex array doesn't always work because int i = pos*4 Will go from index 0 to 4 to 8. Any ideas?
You responded before I could edit my comment haha! Yes I saw that works, but i had to change some code around and now it doesn't work. I added some printfs to see if i was getting the right switches: switch(input){ case '0': strcpy(&amp;converted[i],"0000"); printf("hi"); break; case '1': strcpy(&amp;converted[i],"0001"); printf("hello"); break; case '2': strcpy(&amp;converted[i],"0010"); break; case '3': strcpy(&amp;converted[i],"0011"); break; .... But I get an infinite loop of hellohellohello.......
For compile-time tuning of program-wide behaviour, no. They bring unnecessy overhead and are better avoided. It's not just memory consumption but also indirection (function pointers etc.) that is actually quite costly on modern CPUs. Much more than a few kilobytes of memory. For having the same code do different things inside different parts of the same program, definitely. Well, given the previous, C++ templating would be even better but since C does not have it, a configuration structure is the closest way to do something similar in C. It's possible to do it with multiple includes and `#define`s but it will get really, really messy (you would need to mangle all functions' names, for example, or the result will behave very weirdly, a nightmare for debugging). Nice advantage of configuration structures is also that they can be easily modified for run-time configuration e.g. by reading a configuration file or `argv`.
K&amp;R have an example implementation in the book. Don't remember what chapter though. Probably near the end. 
I fixed it, haha I am a moron, I was printing the address of pic XDDDDD rookie mistake haha
Thank you. My book states "for any two-dimensional array, a, the expression a[i] is a pointer to the first element in row i". Is the book incorrect or ?
Thanks for giving me another sarcastic response to give to people. This is great. https://www.reddit.com/r/BestOfReports/comments/3ivfus/hmm_an_image_report_i_wonder_where_it_goes_oh/ is similar. I *shouldn't* find it funny, but it is.
Computational astrophysics. Generally, anything that's running for more than a few hundred CPU hours has to be written in C or something that's comparable in terms of speed, memory control, and access to parallel computing libraries (Fortran, Go, whatever) for sanity's sake. Additionally, C &lt;=99 and Fortran &lt;=90 are really the only things that you _know_ are going to run on everybody else's clusters, most researchers don't know any other languages, and all the useful libraries in the field are written in one or the other, so if you ever intend your code to be used by other people it pretty much has to be in C.
I definitely don't plan on using it for compile time things. When i think of such things, i think of portability concerns like checking compiler versions or what platform you're on. What way would you do with pre processor? I mean as an example. How would you mangle function names with preprocessor
Thank you, that is quite helpful.
Here'es the code snippet that calls the conversion function. The puts function im just using to check the output and "length" is the strlen(inTxt) . Thank you for your time for(i=0;i&lt;length;i++){ convert(inTxt[i], i, converted); } puts(converted);
You should check the return values of scanf and fgets and any other input function to see if they succeed or fail. You should also check to see what is being read into partner, either with a debugger or something like `printf("\"%s\"\n", partner);`
Something doesn't make sense here. Can you just post the whole code?
`hex &amp; 1` simply determines the value of what the first bit of the given value, a zero or a one. So say you have 5, 5 in binary is 101, the first (or in the zeroth place) bit of this is 1, the one at the end. So this means in this case, it would return 1, if you had 6, 110, this would return 0. `hex &gt;&gt;= 1` means to shift all bits right one value. So say again if you had 5, or binary 101, this would make it 10., for 6 or 110, it would make it 11. Since it shifts all values right and discards the right most value.
When referenced, an array will 'decay' into pointer to the first element of that array in most situations, but with a few exceptions. The ISO C99 standard says: "Except when it is the operand of the sizeof operator or the unary &amp; operator, or is a string literal used to initialize an array, an expression that has type ‘‘array of type’’ is converted to an expression with type ‘‘pointer to type’’ that points to the initial element of the array object and is not an lvalue." A more in depth explanation can be found here: http://c-faq.com/~scs/cgi-bin/faqcat.cgi?sec=aryptr
Ah, I got you. Yeah, definitely messy, no doubt about it, makes it also hard to read source code when you got a ton of them. So pre-processor won't work (well) for things like configuring objects at runtime, which configuration objects excel at. Also, configuring objects (which are constant and can be compile-time) won't work well for configuration objects, but work well with the preprocessor. Anyway, I gave a thought of what you said on a configuration file, that seems like an amazing idea... I honestly should have saw that inevitability, but yeah, passing a configuration file instead of a stack allocated configuration object, sounds like it would come in handy. Although right now I have wayyy too many changes to do to consider over-engineering to that extent. (Sorry for rambling, a bit drunk at the moment). Anyway, thanks for the feedback, I figured the size of the struct would be an issue, but apparently there are some other there that are in the megabytes in size.
Network traffic analysis
ARM Cortex
Same here.
Firmware development. Actual showtime code is in C, test code is between C, C++, and Python.
No. a[2] is the same as *(a+2) Note that is `2`, not `3`. And you don't multiply by the size of the element.
Writing small Python modules sometimes. Socket programming
Parsing, graph algorithms, numerical analysis, forecasting.
Jim?
Is Go picking up in the parallel computing space?
&gt;a string in C is actually just an array of characters, Technically a string is a sequence of characters, which is stored in part or all of an array. I'm distinguishing between the storage area -- i.e. the array -- and what is currently stored in that storage area. There may be arrays which don't happen to contain a string at some point in time. 
The term "string" is defined by the C Standard, I think it is reasonable to take the term "C string" to mean "string as defined by the C Standard". Otherwise we just argue about what words mean which is pointless. 
Can you explain what's going on in that pic for people who don't use the addon (RES?) 
Call them "null terminated sequences of character" if you want. Most of us would rather have less of a mouthful.
I thought arrays are effectively pointers?
Any reason as to why?
Sharon?
C++ grew to big, and ugly and slow. I could list all the problems I have with C++, but this would be to for this reply.
Hm.. Please correct me if I am wrong. But is this because the pointer is pointing to the first character in the array and then by doing `+ 2` we move the pointer 2 steps and therefor it is `"in"` ?
Sorry, but I think I don't get it. Does it mean that **fgets** reads 50 characters despite of its content? Even if nothing is typed in? I'm really inexperienced in programming and I think I still don't get the logic behind it. Thanks for your patience!
OMG!
Great idea. I noticed that a few other "real" libc implementations put each function in a separate source file but I didn't know why until now. I talked about strict aliasing at the very end of [my reply](https://www.reddit.com/r/C_Programming/comments/4cnek6/im_implementing_the_c90_library_and_started_with/d1lnix6) to /u/OldWolf2. Basically, I didn't know that was a thing so I've got some research to do.
&gt; `&amp;X[Y]` is the same as `&amp;(X[Y])` , regardless of context. By the way, both of those are also equivalent to `X + Y`. I suggest you to always prefer this notation because it looks cleaner. Incidentally, it's also more likely to work if `X` is a macro expression that expands to a pointer.
Oh, and as a sidenote, your macros should always parenthesize everything: #define absdiff(A, B) A &gt; B ? A - B : B - A Is probably a bad idea. You should prefer: #define absdiff(A, B) ((A) &gt; (B) ? (A) - (B) : (B) - (A)) If that looks too ugly for you, then you'd better stick with functions.
I have no idea what you want.
We prove the correctness of industrial C programs (think software for trains) using [Frama C](http://frama-c.com/).
%d is for printing an `int` sizeof evaluates to a `size_t` size_t may or may not be the same size as an `int`. Therefore it is incorrect to use %d with sizeof. The 2 solutions are to cast sizeof to an int. Or to use the `%zd` format specifier. I can never remember `%zd` without looking it up, so I use the cast. %p is for printing a pointer, which again may not be the same size as an int (so %x may not be correct)
`main`'s usual return type is int, so arguably it can generate any number you want!
Oh wow! Amazing, this answer really hit the spot, thanks. I've been torn for a really long time on whether playing with assembly would be worth it or not, but this is seriously pushing me towards diving in. That website is really really cool. Pretty amazing to really see how different x86/ARM/etc are, too bad I have very little clue what's going on haha.
Hey /u/raevnos, solved the line break!: if ((strlen(partner)&gt;0) &amp;&amp; (partner[strlen (partner) - 1] == '\n')){ partner[strlen (partner) - 1] = '\0'; } Unfortunately I've been unable until now to find a solution for the main problem, and if I type the **fgets** after the **scanf**, it keeps being ignored. Any hint about it? Thanks! *Edit (1):* Hey, I get it now! So there's a "/n" pending in the buffer I should get rid of. Found this nice solution: while ((liters = getchar()) != EOF &amp;&amp; liters != '\n'); But how can I apply it if my data type is float or integer instead of character? *Edit (2):* Solved!: int main() { char partner[50]; float liters; printf("Amount: "); scanf("%f", &amp;liters); while(getchar()!='\n'); /* 1st key piece */ printf("Partner: "); fgets(partner, 50, stdin); if((strlen(partner) &gt; 0) &amp;&amp; (partner[strlen(partner) - 1] == '\n')) { /* 2nd key piece */ partner[strlen(partner) - 1] = '\0'; } printf("\n%s ; %f ; ", partner, liters); return 0; } Thanks so much for your help. It sounded a bit cryptic in the beginning, but it helped me understand the reasons behind the problem and what should I do to avoid it.
declare another int variable (e.g. "int result;") and give that variable the result of the function ("result = multiple(x,y);") and then compare the new variable in the if statement ("if(result == 1){...}")
 int main() { return 0; } You can replace `0` with any number you want to generate.
Line 21 is a terrible idea!
I am trying to set all the values in the array equal 0 in that line.Is this not how to do it , sorry not familiar with c
Hmm let me try, so I memset every row?
Can i make a for loop to make every value start at 0?
Note that the function [FindWindow](https://msdn.microsoft.com/de-de/library/windows/desktop/ms633499\(v=vs.85\).aspx) either retuns a Handle on success or `NULL` on error. Why are you checking with `1`? By the way, this is an example code, that renames the title of the calculator: (compiled with `gcc %` (`%` = the current source file)) #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;windows.h&gt; int main(int argc, char **arv) { HWND hWnd = FindWindow("CalcFrame", NULL); /* Look for the calculator */ if (hWnd == NULL) { puts("Window is closed"); /* Prints the string and a additional \n */ printf("Last error: %i\n", GetLastError()); } else { puts("Window is open!"); SetWindowText(hWnd, "Your lovely calculator"); /* Change window title */ } return 0; } Proof that it works: http://puu.sh/o2inw/19d369fc83.png So, you may just read the documentation. Also, use Google (eg. i searched for the function `SetWindowText` and i got the documentation for such function). Also, most of the default WIN32-API can be accessed by the `windows.h` header. For external DLLs, you may have to use different functions and load them by yourself (or use your compiler features)
Whitespace differences don't matter in C; Whitespace and comments effectively get collapsed down to single spaces. So: int my_array /* ... */ [ 10] = {1,2,3 ,4, 5, 6/*...*/} ; Is processed exactly like: int my_array [ 10] = {1,2,3 ,4, 5, 6 } ; In many cases the presence of whitespace between tokens is also irrelevant. For the most part the exceptions are obvious, but there are some not-so-obvious cases as well.
String literals and macros can be split with \\ char *YourName = "Bob\ the\ builder"; #define blah(c) {\ puts(c);\ } Otherwise whitespace does not matter.
Outside of string literals and `//` comments, C doesn't care about newlines. These are removed pretty early in the lexing process. As a rule of thumb, you can put a newline anywhere you could put a space, too.
Thanks.
“NOTHING is working!” is not an error description. Calm down a little and give a complete error description.
If you want object oriented C, use C++. C++ is fantastic for embedded if you limit your use to classes, templates, and function/operator overloading. Just for some background. I've been writing embedded software for about 9 years now. In the last two years I've migrated all of my code from C to C++. My rough estimate is that the C++ I write is approximately 25% the size of the C code for the same functionality with almost no performance loss. My chief complaint with C++ on embedded, so far, is that occasionally it's difficult to understand resource usage (code size and RAM usage) but that's more my inexperience than anything else.
Add comments. Describe what you do, not how you do it. Use short but telling variable names. Pick one naming convention and one programming style and stick to it for the whole project. All these things make code much easier to read.
Neui, Okay... That was quite interesting. I put your code into code blocks, then I decided it may have been the compiler causing me the stress and issues.... So, fiddled with codeblocks and installed a new compiler. Got that configured and threw your code back in and guess what? It compiled! THANK YOU! You've answered my question. I'm sorry it took so long, I've been trying to get the compiler to work since 1PM. -amv
I'd have to check the standard to be sure, but it doesn't *really* surprise me a ton. `memset` operates at the byte level, the initializer list operates on the member level. Really, generally speaking the standard gives no guarantees for the contents of padding. I'm guessing that, since you put them on the stack, the compiled code simply assigns values to the relevant fields and leave the padding with whatever garbage is on the stack. IIRC, doing anything with the padding is generally UB, so this is probably not breaking the standard at all. If you want to hash the structure directly (Which is probably not recommended) then I would either using some form of `__attribute__((packed))` for your compiler, or (probably better) manually insert the padding. By manually inserting the padding as named members, that should guarantee that the compiler will zero them for you. For example: struct s { int x; char c; char padding[3]; double d; }; It's worth noting that `packed` is not guaranteed to work well on all platforms, since it misaligns your members. You're *probably* better off just inserting the alignment yourself rather then using `packed`. That said, the *best* option would be to just not hash the `struct` in the first place. For example, you could translate the `struct` into a separate array of bytes and then hash that instead. it is admittedly a lot of annoying work to go through though, which feels like a waste - but it would guarantee that everything would work and produce repeatable results.
Please don't use packed structures. They cause problems in all sorts of places, like when you want to port your application to a platform that doesn't support misaligned memory access.
I like Blockchiffres more.
You can use structs sort of like classes. It's not exactly the same but you kind of get a struct which contains all of the data and operations of an "object"
Often the compiler doesn't warn about strict aliasing. It's not really possible to implement your `memcpy` optimization while fully complying with the standard - so my advice would be to turn off strict aliasing when compiling your function (or use inline assembly). 
Just as a style thing, many people would consider both of these to be anti-paterns (though that is not to say that there aren't some times when they are easier to read): if (boolean_expression) { return true; } else { return false; } and if (constant_boolean_expression) { do_something(); } if (!constant_boolean_expression) { do_something_else(); } Consider that the first is equivalent to: return (boolean_expression); And that the second can be shortened to: if (constant_boolean_expression) { do_something(); } else { do_something_else(); }
Where are you stuck and what have you tried? Looks like you need to write a program that in the main() method reads in two strings (look into thinks like [scanf](http://pubs.opengroup.org/onlinepubs/009695399/functions/fscanf.html), [fgets](http://pubs.opengroup.org/onlinepubs/009695399/functions/fgets.html), and [getline](http://pubs.opengroup.org/onlinepubs/9699919799/functions/getdelim.html)), then you need to pass these two strings to a function you implement called str_index. This str_index function is going to have to call [strstr](http://pubs.opengroup.org/onlinepubs/9699919799/functions/strstr.html) to find the substring, and find out how far it is from the beginning of the string you're searching and pass it back to main. Main is going to have to take the return value and print a message back to the user (probably using [printf](http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html)) *Edit:* One thing you should ask your instructor about is what you should do when the substring first appears at the 0 index of the string, since they've reserved 0 as an error code. I would think that they should use -1 for the substring not found case as it's a value that can never be a valid return value. *Edit2*: Missed that it's the rightmost, you're going to have to call strstr in a loop, saving each find, and using that + 1 as the new haystack string until it no longer finds anything, then calculate the difference from that last find and the beginning of the original string.
Holy... I just remembered something. I normally hide the implementation detail from outside the source file and just forward declare the struct in the header, so my original method wouldn't work in the long run anyway. However, as others have pointed out, finding a way to hash each field (hell, even have other ~~classes~~ source files provide serialization could easily make it possible to pseudo-recursively serialize a structure by also having it serialize the structs it is composed of. That sounds AWESOME! struct student { struct person p; size_t num_grades; struct grade *grades; size_t num_classes; struct class *classes; }; unsigned char *student_serialize(struct student *student, size_t *len) { buffer_t *buf = buffer_create(); buffer_append(buf, person_serialize(s)); unsigned char bytes[sizeof(size_t)]; SERIALIZE(student-&gt;num_grades, bytes); buffer_append(buf, bytes); for(size_t i = 0; i &lt; student-&gt;num_grades; i++) buffer_append(buf, grade_serialize(student-&gt;grades[i]); SERIALIZE(student-&gt;num_classes, bytes); buffer_append(buf, bytes); for(size_t i = 0; i &lt; student-&gt;num_classes; i++) buffer_append(buf, class_serialize(student-&gt;classes[i]); *len = buffer_size(); unsigned char *data = buffer_take(); buffer_destroy(buf); return data; } Edit: Added serialization for the size_t attributes too.
Of course. I'm just saying `X + Y` is better than `&amp;X[Y]`.
int str_index(char *s, char *t); int main(int argc, char *argv[]) { char *t,*s; printf("Give a string: "); scanf("%c",&amp;s); printf("Give the string you want to search: "); scanf("%c", &amp;t); str_index(t,s); return 0; } int str_index(char *s, char *t){ }
The instructor gives an example: If s is given the string "piriminimikirhimi" and t the string "mi", then the function str_index must return the value 16, because the rightmost appearence of "mi" is in 16th and 17th place of the string s.
I do think using C++ would solve my problems. Is there a C++ toolchain for microchip microcontrollers? There only seemed to be a C or asm compiler, but I wouldn't know where to look
AFAIK, It's practically supported everywhere (hosted, at least), either through a slower hardware-fallback, a compiler fix-up or a software-fallback (provided by the OS.) You may just be paying with a lot of performance (in the case of a software-fallback it'd be extremely expensive as you switch into the OS to do the fixup; in the case of a compiler fixup it'll execute a bunch more instructions than necessary; in the case of a slow hardware fallback it'll just be somewhat slower (also the case for many older x86, AFAIK))
browse popular githubs and study the sources. the more projects you look at, the more style and substance you'll pick up. over time you'll develop your own style which will form a good base for any project needs.
What do you mean? Wouldn't each write to the struct only change the values at the member's offset up to it's size? I mean I can see how if I do some fancy casting or pointer arithmetic and end up going beyond the actual size of the member, but how would it come about naturally?
At this point if you want to do OS stuff it may be a good idea to recreate basic linux commands in C such as bare bones ls or mv etc. Also get the lpi book by Michael kerrisk to start learning the Linux C api which is not exactly kernel ( more userland specific ) but a good start to serious OS programming.
It depends a lot on the microcontroller (I'm not familiar with the one you mentioned). In the worst case scenario, you can always convert C++ to C as a preprocessing step (e.g., using llvm, though that will depend on a C++ runtime)
Line 105 is incorrect. = is assignment. Line 93 is incorrect. That is not how you check that a value is equal to one of 2 others. You need 2 complete expressions and the || (logical or) operator
Just looked through quickly, but at line 95 you set next_board[i][j]=next_board[i][j], is that what you meant to do?
he meant 105 e: Same mistake at 118 and a few other places. When you are checking two values, do: if ( a == b) {} Not, if (a=b) {} If you do the latter statement, it will literally set a equal to b, and always execute the if statement. I suggest compiling your program with -Wall and -pedantic to catch some errors like this
Also each time through the loop you are copying board to `next_board`. So you're only calculating 1 generation over and over And, when you're counting neighbours yoy need to count on `board`, not `next_board`. Next_board is partially updated so counts will be wrong
&gt; I guess it's either have a hash function declared, or assume that they their structure has been thoroughly zero'd with calloc/memset, they packed their struct, or they used empty unused values for padding. Is this for a library? If so I'd probably recommend staying away from any assumptions on padding then. The compiler can really do anything they want with it, and it's fairly impossible to detect if there's a problem. &gt; Speaking of such, isn't that padding technique used with BSD sockets to physical subtype between different structs? Not really. The socket descriptors like `struct sockaddr_in` all start with the same initial members, which are identical to the contents of `struct sockaddr`. Being that they're identical, the internal padding between the members *should* be the same - and AFAIK no compilers break this so that probably holds true. That said, this is definitely *not* standards compliant. At the very least casting back and forth between the two breaks strict-aliasing. And, in such a situation I think it's hard to say if the padding guarantee really stays true, or if it's just something happen to compilers do. &gt; Lastly, how would one translate the struct into a separate array of bytes? Just go member by member and hash that instead? Then I'm assuming all you do is convert each to an unsigned char *, read each byte up to the size of the member into an array. Could it be abstracted a bit though? Yes, that's exact what I'm thinking. Essentially you're just taking the 'regular' version and converting it into a version with no padding. It's possible to get that macro using a few different tricks - not the trick you pointed out though, since that number will only be resolved at compile time, not preprocessing time. It'll get pretty complicated but you can do it with a recursive macro, some fancy argument counting, and a few other things. I don't have time at the moment but I might give it a go a bit later. The easy way is to do it like you described though. Use this to count the arguments: #define define NARG(...) NARG_(__VA_ARGS__, NARG_NUMS()) #define NARG_(...) NARG_GET(__VA_ARGS__) #define NARG_GET( _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, N, ...) N #define NARG_NUMS() 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 I did that a bit of the top of my head, so you'll want to check that it works. Also, you'll have to modify it if you want it to work with any more then 10 arguments. With this and a `TP()` macro: #define TP(a, b) a ## b You can create the correct `SERIALIZE_ARG_` name to start with: #define GET_SERIALIZE(n) TP(SERIALIZE_ARG_, n) #define SERIALIZE(obj, bytes, len, ...) GET_SERIALIZE(NARG(__VA_ARGS__))(obj, bytes, len, __VA_ARGS__) Something like that. From there it's just a matter of defining `SERIALIZE_ARG_10` to `SERIALIZE_ARG_0`. There *is* a way to avoid the repetitiveness of the whole thing and only have one `SERIALIZE` macro, but it's much more complicated and not something I could do without a little research.
I think it's really hard to do something, if you don't know what to do. I mean it looks like you want to solve some problem (and contribute to linux kernel for example), but you essentially does not have any problem or ideas in this area. I had the same problem, ended up dig in to cpython source code, and am trying to make some improvements in the performance area(so far unsuccessfully). But the source code and design of CPython is relatively straightforward and it helped me a lot to improve reading source code bigger than hello world. So as soon as you have real problem or idea it becomes a start point for your actions (contributions). And don't learn "advanced stuff" before this stuff is really necessary to solve your problem. In this world there are so many to learn that it's absolutely impossible to learn even small part of them. IMHO. Good luck. 
Yes Because one of the rules is if the index has a count of 2 or 3 then it stays the same.I assume this is the correct way to do it.
I don't even have a file, why i must use fgets()? I think gets() is ok. 
I was copying board to next_board because I was trying to change the contents in New_board which would have the same elements as the original. Is this bad
gets() is **never** okay, because it has no upper limit on how much data it reads. It is impossible to safely use. It's so bad it's the only function to have been removed from the standard. (scanf("%s", ...) has the same issue, BTW).
Ok that's what i ment, but the actual problem is the code on the str_index() function that this guy want me to create.
The only part you've shown us so far is the code that reads input from the user, and it's badly broken. You need to fix it before doing anything else. Focus on one part of the program at a time, get it working, and then move on to the next.
At the end of the day, you are probably using C to be closer to the machine level anyway. So human readability is generally not an optimization.
Well imagine that you had a `char` that had 3 padding bytes placed before it. It's entirely possible that the CPU can do 4-byte operations faster then 1-byte operations - and the compiler would know this. So in the process of modifying your `char`, the other 3 padding bytes may be messed with at the same time. 
What others have said in this thread, namely browsing github, is good. I'd recommend you look at utilities you're interested in and read the sources to them. [I happen to think text editors are rad](https://github.com/neovim/neovim/blob/master/src/nvim/memfile.c) and [lua is a pleasant read too. They even hyperlinked the sources.](http://www.lua.org/source/5.3/) Linux as a whole might be a bit over your head at the moment, but maybe you could try writing a memory allocator or something similar? If you're looking for something written from a pedagogical approach, [xv6 and the book for it](https://pdos.csail.mit.edu/6.828/2012/xv6.html) and the Tanenbaum book are both nice. If you can find a copy of the Tanenbaum book, I think you'll find it's a really pleasant read.
Well it isn't wrong however but I don't think it is a good practice to have. I would just have an if statement for (count &gt; 3), (count &lt; 2) and then nothing for (count == 2 || count == 3) since you are leaving it the same.
&gt;What's incomprehensible about C? C isn't incomprehensible, it's just a lot of work to interpret. To me, it seems to be a language that considers computers first, and humans second. For Python, that order is reversed. Python is designed to be comprehensible first, and optimized second. I think the idea with Python is that taking hours of the developer's time to get a couple extra % performance is hard to justify, especially when code can be updated quickly and easily (like with web development). But for programming firmware in high volume projects, the programming investment for more performance is easily justified. &gt;What do you miss about Python? If embedded progamming in Python were a thing (I guess it *kind of* is with raspberry pi's), I might write code like this: from SPI import SPIDevice from microcontroller_pins import * shift_register = SPIDevice(clock_polarity = ACTIVE_HIGH, clock_edge = RISING, clock_freq=10*10^6, MISO = PIN2, MOSI = PIN3, CLK = PIN4, SS = PIN5) shift_register.write(0b11011011) I can read that and understand immediately what's happening. It also enables me to change things in the future easily, and to hunt down bugs efficiently. The high-level logic is captured. Verbose comments are less necessary, as the code itself is pretty honest and self-documenting. In C, as I've been doing, the same simple logic would have to be too verbose: TRISGbits.TRISB2 = 1; // MISO is an input TRIGSbits.TRISB3 = 0; // MOSI is an output TRIGSbits.TRISB4 = 0; // SS is an output TRIGSbits.TRISB5 = 0; // CLK is an output RPOR20bits.SSI1R = 0b1110111; // MISO functionality mapped onto pin 4, port B2 RPIR6bits.RP164 = 0b1110111; // pin 5 gets MOSI functionality or too concise, so that it's not reusable or easily modified: TRISG = 0xBF; // setup MOSI, MISO, SS, CLK pins on pins 2, 3, 4, 5 respectively I guess my issue is that the logic is simple, so I think the code should be. I have to spend so much of my time setting up the minutae of each program that it just feels like a waste of effort.
Yes, SPIDevice would be a struct. (I also just made a couple of edits because I haven't had enough coffee to write code that makes sense) make_SPIDevice would be a function that returns a SPIDevice. write_spi_device a procedure that takes a pointer to a SPIDevice and a value.
Excellent. I was trying to piece together something like this.
My target number is 1509. I want from the program to generate those number (1,5,0 and 9 ) randomly. For exemple, it can do that number: 9051, 1590..
The real problem isn't actually CPU support, it's support by other languages. While almost all C compiler support packed structures, the FFI of many programming languages don't, making it very challenging to use the library in such a situation.
Hash every member instead of the whole structure. Or serialize the structure beforehand. It's tedious but it works.
You could always bitshift any type you need out of a packed struct, but I agree it'd be annoying...
Which is [what I had to do](https://github.com/fuzxxl/nfc/blob/master/2.0/nfc/marshall.c) (library used packed structs for no good reason except “saving space” for a struct that was used maybe once in the whole application). It sucks a lot.
In-house software. If it breaks, its on me. In recent news: Patch #308 will be out in an hour. 6 if you keep asking when it will be out.
If you're already relying on GCC then you really don't need to care about the length because there is [no length limit](https://gcc.gnu.org/onlinedocs/gcc/Identifiers-implementation.html#Identifiers-implementation) for the GNU toolchain. (And the limit is several thousand on other common toolchains.) 31 is the bare minimum, and you'd really have to go out of you way to find something with a limit that small. 
[Cello](http://libcello.org) has what they call [Tables](http://libcello.org/learn/table), which is fairly close to a dictionary. e.g. mydict = new(Table, String, Int); set(mydict, $S("hi"), 21); println("mydict['hi'] is ... %$", get(mydict, $S("hi"))); Would print: mydict['hi'] is ... 21 The limitation is the dependency on Cello, which adds quite a few macros and ideas, and the type-safety. No mixed-type dictionaries.
Ancient toolchains checked six characters in symbols and every C symbol began with an implicit underscore, so only five characters could be used. This is reflected in many C library functions like `creat()` having abbreviated names or names that are unique in their first five characters. Nowadays, all toolchains I know support unlimited symbol lengths or at least very long symbol names (up to more than 1000 characters).
&gt;I'm a Linux fan and I read a lot of stuff about the kernel http://eudyptula-challenge.org/ http://kernelnewbies.org/
Forgive the derail, but I'm curious how unlimited-length symbols are stored in memory during the compiler's run. I recently made a symbol table for an interpreter, and I figured I pretty much had to set some kind of max limit on symbol lengths. So symbols are stored in an array similar to this: char (*symbols)[MAX_SYMBOL_LENGTH] and then memory for some number of symbols (resizeable later, obviously) is allocated when the table is initialized. To support unlimited lengths, would I instead just create an array of char pointers and allocate memory for each symbol individually at the time it's added to the table? This struck me as really cache-unfriendly when it comes time to iterate through the symbols, but is it the usual solution for symbol tables or am I missing a better one?
The number of significant characters is implementation-defined. Strictly speaking, I don't think that 31 is even guaranteed to be a _minimum_ for external identifiers. 5.2.4.1 in C99/C11 mentions this number in connection with the "one program" implementation test, but this "one program" doesn't necessarily reflect programs in general. Practical guideline: Don't worry about any of this on modern systems.
&gt; To support unlimited lengths, would I instead just create an array of char pointers and allocate memory for each symbol individually at the time it's added to the table? This struck me as really cache-unfriendly when it comes time to iterate through the symbols, but is it the usual solution for symbol tables or am I missing a better one? Yes, that's exactly how it's done in ELF. It's not cache-unfriendly either as a special `.strtab` section is used for the symbol names so they all end up next to each other. That also saves a lot of space.
Aside from the aliasing, you may want to operate with unsigned char pointers rather than char pointers. Whenever you have the chance to get C99/C11 portability at no cost, I think you ought to take it. Note this C99/C11 wording in the string.h subclause: For all functions in this subclause, each character shall be interpreted as if it had the type unsigned char (and therefore every possible object representation is valid and has a different value). I don't have a copy of the C90 standard. IIRC, integer-based trap representations were a C99 invention. C11 then prohibited padding bits for signed char (and char when using signed char representation), but this still allows value-based traps (either 0x80 or 0xFF, assuming 8-bit representations and depending on which of the three signed representations is used).
I second APUE. Get the latest edition. Except perhaps if you're a DS&amp;A geek, it's hard to progress beyond toy programs with ISO C alone. APUE will introduce you to POSIX interfaces, and then you can start writing some really cool stuff in the Unix/Unix-like userland. GNU userland code is often a complete mess, so for code reading, I recommend the BSD userland, where everything tends to be clean and crisp, particularly with the OpenBSD tree (high readability is, after all, a security measure).
`strtok()` doesn't allocate anything, it just adds nulls into the buffer that you pass it, and returns pointers into that same buffer. Your buffer is a local variable in `getCommand()`, and its life ends when the function returns. But you're populating an array of pointers that all point into that buffer. There's no way to use that return value with invoking undefined behavior. If you want to return an array of strings, you have to allocate both the array of pointers *and* space for each string value, and then copy the contents of each token out of the local buffer and into the allocated space. [Here is an example](https://gist.github.com/Rhomboid/c8a1f52225a5be656250a3b6903d434f) that I wrote up at some point in the past when answering a similar question. This uses geometric resizing, rather than resizing every time, which can be quite inefficient. 
Note that if you want to conform with ISO C then dollar signs are NOT allowed in identifiers.
Yep, that's exactly what it's doing. It's actually a pretty common macro, I thought the same that it was very clever when I saw it the first time. It really is pretty simple once you write it out and try it. The only real downsides is that it's fairly convoluted if you want to support a large number of arguments, and if you use too many arguments it fails pretty badly. I don't really like it on the principle that it only works for a limited number of arguments, but it really is the best/only way to do it with the preprocessor.
You wrote “minimum overhead” so I went for that. What amount of overhead is acceptable to you?
How hard are the challenges? How much should you already know before starting?
Loops, have you heard about them? :) Sounds like you have floating point issues, try changing float to double.
I have heard about them, but I am supposed to solve without them :) I had tried changing to double already, it continues giving the wrong answer for some inputs (missing 1 cent). Example: 576.73 was missing a cent with float, does not miss with double. However, keeps missing for other values such as the examples in OP. 
I did this substitution, it still does not work for 281.84, for example. Been stuck with this simple problem all day now.
Not the OP but if I may answer the question: It's neither a book to learn C, nor one to learn programming (in the sense of algorithms, data structures, program design..whatever). It is exactly what the title says, it introduces the Linux Programming Interface. It explains how Linux handles processes, file input/output, memory allocation, groups and users, permissions etc. I'd say it's a good reference or maybe introduction if you read it from A to Z, it's very straight forward and written at a simple level, but you should already know how to program and you should know C. So depends on what 'a beginner' is. An absolute beginner to programming or C? Then I'd say no. A beginner to system programing? yes. Just my opinion.
I have remade my code with a slightly different approach, still the same problem. #include &lt;stdio.h&gt; int main() { float dinheiro=0; scanf("%f", &amp;dinheiro); printf("NOTAS:\n"); int grana, y; grana=100*dinheiro; y=grana/10000; printf("%d nota(s) de R$ 100.00\n", y); grana=grana%10000; y=grana/5000; printf("%d nota(s) de R$ 50.00\n", y); grana=grana%5000; y=grana/2000; printf("%d nota(s) de R$ 20.00\n", y); grana=grana%2000; y=grana/1000; printf("%d nota(s) de R$ 10.00\n", y); grana=grana%1000; y=grana/500; printf("%d nota(s) de R$ 5.00\n", y); grana=grana%500; y=grana/200; printf("%d nota(s) de R$ 2.00\n", y); grana=grana%200; printf("MOEDAS:\n"); y=grana/100; printf("%d moedas(s) de R$ 1.00\n", y); grana=grana%100; y=grana/50; printf("%d moeda(s) de R$ 0.50\n", y); grana=grana%50; y=grana/25; printf("%d moeda(s) de R$ 0.25\n", y); grana=grana%25; y=grana/10; printf("%d moeda(s) de R$ 0.10\n", y); grana=grana%10; y=grana/5; printf("%d moeda(s) de R$ 0.05\n", y); grana=grana%5; y=grana/1; printf("%d moeda(s) de R$ 0.01\n", y); return 0; } I cannot believe it took me all day and I still couldn't make it work.
+/u/CompileBot C #include &lt;stdio.h&gt; int main(void) { int d, c; while (scanf("%d.%d", &amp;d, &amp;c) == 2) printf("%d d %d c\n", d, c); return 0; } Input: 326.27 281.84 
You may as well use "%d.%d" instead of "%f". It's more in line with your code anyway.
Yeah, I removed that broken substitution. Better off going with "%d.%d" instead. Your code doesn't really do anything with the float variable anyway, so may as well let scanf() do what you're currently doing by hand.
If you like eli5 explanations and a less dry/academic style of book, books from the *Head First* series might be the sort of thing you want. Maybe *Head First Programming* to start with to cover basic coding concepts, followed by *Head First C* for similar content more geared toward the C language.
I don't know what you mean, should I keep everything the same and put "%d.%d in place of "%f"?
 float dinheiro=0; /* money variable */ scanf("%f", &amp;dinheiro); /* money input */ printf("NOTAS:\n"); /* announcing bills */ int inteira=(int)dinheiro, y; /* def whole part of the money and new variable y */ int quebrado = 100*(dinheiro-inteira); /* def the cents part of the money, multiplied by 100 for later purposes */ Change all that to this: int inteira, quebrado, y; scanf("%d.%d", &amp;inteira, &amp;quebrado); printf("NOTAS:\n"); 
Why are you complicating things? Just do `tse++` or if you want to increment a copy do this `char *yo = tse; yo++;` or even `char *yo = tse + 1;`
I suppose so, I'm trying to right some simple parser and I have this function: void advance(char** input_string, bool skipWhiteSpace){ (*input_string)++; if(skipWhiteSpace == false) return; if(**input_string == (char*) 32){ advance(input_string, skipWhiteSpace); } } I haven't really gotten far enough to see if this is a bad approach or not. 
basically you need to read input somehow for the size of the square, then you need a nested loop where you print in the inner loop a "#O" or "#" (wheather the run variable is size of the square - 1 or not) and in the outer loop you have to append a new line or not, (wheater the run variable is size of square -1 or not)
this one worked for me. Thank you very much. however it's still puzzling that it would work during the next iterations of the while loop. and why it just works as is in computer 1. 
Its one of the extensions with gnu99 that I make heavy use of. That and closures.
You need to pass a specific option to gcc to include macros in its debugging information; see [here](https://www.sourceware.org/gdb/onlinedocs/gdb/Compilation.html#Compilation) and [here](https://www.sourceware.org/gdb/onlinedocs/gdb/Macros.html).
It's not that, I did that. All that does is include macro SYMBOLS into the debugging info. It doesn't actually let you step through a macro the same way you would an ordinary function. It still means that if you have a 500 line macro, you have to either asm("int3") your way through it, or use print debugging. It's a hateful mess. 
LuaJIT has a fantastic FFI that interfaces well with C.
In my experience, as far as the C code itself goes, it's easier to go from Linux to BSD if you're building against the standard, C99 in particular (-std=c99). The headers on Linux are very namespace clean, so it's difficult to accidentally use a non-standard function or type by accident. The biggest problem you'll run into is the ancient versions of gcc found on OpenBSD ~~the BSDs~~, which may lack some feature you're counting on. Otherwise my biggest problem is in the tooling. I often accidentally depend on GNU extensions in my builds, which can be really annoying to debug and workaround when using a plain userland. 
Simpatico. 
Stick to POSIX by reading [POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/). Don't use any non-standard APIs. Test the code on FreeBSD, if it works it's likely fine. The differences aren't that large, if it compiles it usually works except where it doesn't, e.g. with certain usages of `select()`. Lastly, don't assume that the shell is a bash. It most likely isn't. If a bash is installed, it's likely neither in `/bin/bash` nor `/usr/bin/bash` but rather `/usr/local/bin/bash`. Write portable shell scripts if possible. Stick to POSIX wrt. the options you use for userland utilities.
Your post got caught in our spam filter. I unblocked it just now. I'm sorry for the inconvenience.
Your post got caught in our spam filter. I unblocked it just now. I'm sorry for the inconvenience.
What exactly is the assignment? Find all of the unique words in a text file?
Unless you're using Linux specific syscalls like epoll, or assume GNU versions of various standard utilities, porting should be painless. If you stick with the C and POSIX standards, everything will likely just work.
It's only Open that uses a really old version of gcc. You can always get the latest version through their package systems. I use 5.3 on my NetBSD 7 system for example, though the default is 4.8.4 (old but hardly ancient).
No worries! Thanks for the heads up.
Though honestly, that advance function is still a bit iffy, using recursion for recursions sake. Now that I think about it, this might be the better solution. while(*(++str) == ' ' &amp;&amp; skip_white_space);
That whole if statement doesn't make a lot of sense. The first case prevents the last and the central two can be compressed into one.
I think gdb can expand macros if you compile with gcc -ggdb debug flag.
interesting, more idiomatic c code
Not OP, but I've read both. APUE is a classic, very good book and covers a lot of the same ground as LPI. I found LPI a bit more up to date when I was writing a reasonably sized C server for Linux, some topics like shared memory access were a little better explained in LPI. As the name suggests LPI is completely Linux focussed, and APUE is more cross platform if you want to do generic UNIX programming. As far as ease of reading is concerned you can probably pick up and power through either, but LPI has a slight edge (IMHO) in terms of being easy for beginners if you are familiar with Linux.
I've heard many good things about that book, which is why I am thinking of picking it up and working through it during the summer. And thanks for the response.
Thanks for the reply. Got the site saved, and will definitely check it out!
This should give you a basic run down of how permutations work. http://www.regentsprep.org/regents/math/algebra/apr2/lperm.htm I would probably first start with reading in a string, and then counting the length of the string. Then identify unique numbers. You *could* actually generate each permutation, store it in an array, and then return it based on the random number generator. It might be more efficient to just generate the random number, i.e., rand() % 24 in your example, and then only from there generate the unique permutation.
You're invoking undefined behavior, which means anything can happen, including the appearance of correct behavior. On one computer, the part of the stack that used to contain your buffer was reused by the time you tried to access it, whereas on another computer it wasn't; but that's just down to pure luck. The differences depend on countless variables (the architecture, calling convention, compiler options used, such as optimization, the toolchain version, etc.) But the fact that it seemed to work in one case doesn't mean it was actually working. It was always broken.
I don't have that one but I've heard it is good and I've read good reviews. It might be more useful directly, but won't pass on historic overview. I like the old stuff because of that. And in computers everything is old soon enough, but the good stuff continues, so the older it is and still in print, the better the book! ;-)
Thank you so much for telling me about this, I had no idea! I managed to successfully free the memory on the code for my OP, but I am now trying to fix a similar, albeit slightly more complex version of the same problem elsewhere in my program. Do you think you could give it a look and possibly tell me why my code isn't properly freeing? http://chopapp.com/#68hkvmi Of particular interest, and the place where I believe my "Aborted (Core dumped)" errors are originating from are between lines 89 and 93. I tried both copying over individual fields of a struct, as well as making a copy of the entire struct using memcpy and I wasn't able to eliminate the "Aborted (Core Dumped)" errors with either way. Could I accomplish my goal of freeing all of my allocs by using either of these ways? If so, what is causing my attempt to fail? 
1)at the beginning of the loop put answer =0; 2)it should be scanf ("%d",&amp;exiti);
See [this question and its duplicates on StackOverflow](http://stackoverflow.com/q/35021521/253056).
&gt; what happens in the memory when we use "char * *p" to store an array string ? please help me visualize :) [A picture](http://i.imgur.com/dwvcR49.png) is worth a thousand words, they say.
&gt; scanf("%d", exiti); It's that. As /u/rjmessibarca points out, you should use `&amp;exiti`. Reason being, `scanf`expects a format string followed by a number of *pointers* to memory locations. Before, you correctly take the address of variables using the `&amp;var` syntax, but here you didn't, so it treats whatever *value* is in `exiti`as a memory address and writes the result there. Because you don't initialise `exiti`, the program will try to write to either `0`/`NULL`, or more likely, any address it fancies. *Most* of the time, this will crash, as you've seen. Fun fact though: there's a chance you'll get a valid address in `exiti` because you don't explicitly set it to anything. This would mean your input would go somewhere in memory, and your program would likely exit because `exiti` wasn't exactly `1`. This would be one of those horrible subtle errors that are hard to pin down :D.
indeed... I got a clearer view of the concept now. thanks for your valuable answer!
You can't copy the whole struct like that, because what the struct actually contains is pointers to strings, not the strings themselves. You have to copy each string individually. That said, the commented code doing that looks right to me at a quick glance through. I could be wrong, but I don't see any problems that would result in your error there. I haven't had time to read through the rest of the code and look for errors yet. (and probably won't for the next few hours)
This feels like spoon feeding you an answer, but this pseudocode might help: define ints for input and two loop counter variables initialise input=0; //which is out of range do (while input out of range) { print prompt scanf input if input out of range print complaint } optional print input to check it was scanned properly for input number of rows { for input number of columns { print # if column less than last print O } if row less than last print new line }
Usually a mask is something that makes more sense when you see the value in binary. Where I see it used a lot in code is when someone wants to (in binary) copy over every value except for a few bits. edit: one way to think of the AND bitwise operator is that your result is the common bits between the two variables (bits that are set in both), as opposed to the OR operator which gives you the combined bits of both.
&gt; First, is the opendir/readdir/closedir method the fastest way to traverse a directory? There are several things to take into account here. Firstly, the actual syscall for getting directory entries from a dirfd is `getdents()` (and the LFS version `getdents64()`.) These syscalls take a buffer of a specified size and will fill in as many directory entries as will fit. (N.b. they use a slightly different structure and format than `struct dirent`.) For efficiency, you want this buffer to be as large as possible, so that you have to make as few syscalls as possible. However, you don't generally have any control over that buffer size, because it's implemented for you by your libc, which provides `readdir()` on top of this syscall. If you want the absolute best performance, you need to skip that and make the syscall directly so that you have control over the buffer size. But the syscall is Linux-specific. The second factor is the time it takes for the kernel to have to constantly parse path names. Since you're in a multi-threaded environment, you can't change the working directory, which means you have to pass filenames to `opendir()` with multiple path components. The kernel just has to undo all that work to parse each component, then look up each component in its own data structures to eventually reach the final component. To solve this issue there were a number of syscalls added that are fd-relative. They all have names that end in -at, like `fstatat()` and `openat()` and so on. Since you already have the fd of the directory you're iterating (or you can get it via `dirfd()` of the `DIR *` handle), you can pass that and a filename instead of composing a path. However, there's no `opendirat()`. You can however simulate it with `openat()` + `fdopendir()`. In general, you should use `strace` to see what syscalls `find` performs when traversing a tree. (And make sure to do something that doesn't require it to `stat()` each file, as that really slows things down.) `find` has been written to do things as efficiently as possible. &gt; why does readdir give the inodes of the directory entries? I don't understand this question. Why would it not? Every directory entry has a name and inode. Why would you want to filter out some information for certain types of directory entries and not other types? Who would benefit from that? There's no efficiency to be gained, because that information is returned as part of every directory entry, so you can't not ask for it. It would take extra work to filter out, in fact. 
Well, that's not very nice, but let's take some time to look into this program and why it won't do what you might think it does: &gt;Classic: &gt; &gt; #include &lt;stdlib.h&gt; &gt; int main(int argc, char **argv) &gt; { &gt; while (1) &gt; malloc(1); &gt; return EXIT_FAILURE; &gt; } What you have here is a `malloc(1)` in a hard loop. One might think that what is going to happen is that this program is going to repeatedly allocate memory, 1 byte at a time, until the system exhausts all of its memory and either locks up other programs, OoMs programs to free up memory, or crashes. Something bad... However, in most default configurations, Linux is very lazy about actually *giving* you memory. Consider the following program: [pastebin](http://pastebin.com/bZUaqfDG), [mozilla pastebin](https://pastebin.mozilla.org/8866149). What it does is that it prints its own current memory size and memory resident set. The first is the total amount of virtual memory that the application is allocated, the second is how much of the program's memory is resident in physical memory. It then allocates a Megabyte (SI vs Binary arguments not withstanding). It does this 10 times before doing the process in reverse, freeing the memory. Running this on my system, I get the following output: Allocating! 00 : 4276224 B 679936 B 01 : 5328896 B 679936 B 02 : 6381568 B 679936 B 03 : 7434240 B 679936 B 04 : 8486912 B 679936 B 05 : 9539584 B 679936 B 06 : 10592256 B 679936 B 07 : 11644928 B 679936 B 08 : 12697600 B 679936 B 09 : 13750272 B 679936 B Freeing! 09 : 14802944 B 679936 B 08 : 13750272 B 1449984 B 07 : 12697600 B 1445888 B 06 : 11644928 B 1441792 B 05 : 10592256 B 1437696 B 04 : 9539584 B 1433600 B 03 : 8486912 B 1429504 B 02 : 7434240 B 1425408 B 01 : 6381568 B 1421312 B 00 : 5328896 B 1417216 B Note that while the virtual memory allocated to the process grows as we expect it would, because we're not using that memory, we don't get any physical memory, and the RSS stays the same (I'm not 100% sure on why RSS jumps after the first `free()`, I have some speculations but I don't want to present wrong information. If someone knows, I'd be interested) So, if you were to just allocate memory in a hard loop (and I would hope if you were trying to be malicious you'd do more than a byte at a time), it's not going to take down the system... The following program: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { while (1) if (!malloc(256 * (1 &lt;&lt; 20))) break; fprintf(stderr, "Broke!\n"); return 0; } on my system runs pretty quickly, before running out of address space and exiting: $ time ./allocloop Broke! ./allocloop 0.04s user 4.47s system 99% cpu 4.506 total
You're `mmap()`ing a file just to get its size? That's going to be a heck of a lot slower than `stat()`. `stat()` is only slow compared the case where you don't need to do anything (i.e. you just want a list of filenames, and you're able to use `d_type` to detect directories.) inodes are useful when you need to cope with duplicates of things. For example, if you have a directory tree full of files, some of them might be hard links. If you're writing a program that measures the amount of disk space used (like `du`) then you have to keep track of the inodes of all files in the tree so that you can spot this case, otherwise you'll report the wrong amount. (The `st_nlink` field tells you how many links there are, which is related information, but it doesn't tell you which names are sharing the file's contents and whether they are in the tree you're traversing.) Most filesystems don't allow hard links of directories (although HFS+ under OS X is a notable exception) so that doesn't usually apply when dealing with directories. But again, every dirent has an inode, and it would take extra work and effort not to return that information for certain types of dirents.
&gt; By the way, is it possible to send a SIGSEGV signal to a random process? Just like this: &gt; &gt; while (1) send_signal(random_pid, SIGSEGV); An interesting question, which actually has many non-malicious uses. The POSIX function used to send a signal to a process is [`kill`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/kill.html). `kill` takes a `pid_t` and a `signal_t`, and if the user has permission to send a signal to a process or process group (see the man page for how to send to a group instead of a single process) it will send the appropriate signal. If you want to be able to send to processes that aren't owned by you, you're going to need to be root (or have a capability set). You're going to need to be able to know what the largest PID is, and fortunately on Linux you can read that from `/proc/sys/kernel/pid_max`, then all you need to do is generate a random value 1-PIDMAX (we exclude 0 and negative numbers because we don't want to send to all processes or process groups, though if we select 1 it would kill init taking out the system). Putting it all together, you get something that looks like this: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;signal.h&gt; static int get_max_pid() { int max_pid; FILE *fp = fopen("/proc/sys/kernel/pid_max", "r"); fscanf(fp, "%d", &amp;max_pid); fclose(fp); return max_pid; } static int gen_rand_pid() { unsigned int random_val; FILE *fp = fopen("/dev/urandom", "r"); fread(&amp;random_val, sizeof(unsigned int), 1, fp); fclose(fp); return (random_val % get_max_pid()) + 1; } int main() { while (1) { kill(gen_rand_pid(), SIGSEGV); sleep(2); } } Which will attempt to send a SIGSEGV to a random pid every 2 seconds. Though, if you're not root, it's only going to affect your own processes (and even then, only when you generate a pid corresponding to one). Why might you want something like this? Well, for instance, Netflix runs something called [Simian Army](http://techblog.netflix.com/2012/07/chaos-monkey-released-into-wild.html) (or Chaos Monkey) which randomly kills parts of their infrastructure during convenient times, to ensure that their system can sustain 'random' failures. Beyond that, signals can be used as a widely supported mechanism for IPC, which will work on virtually any POSIX OS (though there are generally better options available). Though for that to would need to implement signal handling. An interesting project would to take the random process killer above and add a signal handler for SIGSEGV so that it can't kill itself, but prints when it tries to.
I'm not using `mmap` to get the size. I'm using something like: f_fd = openat(d_fd, name, O_RDONLY | O_LARGEFILE | O_NOATIME | O_PATH); fstat(f_fd, &amp;stat_buf); text = mmap(NULL, stat_buf.st_size, PROT_READ, MAP_PRIVATE, f_fd, 0); close(f_fd); /*Process file*/ munmap(text, buf.st_size); to read and process files. I haven't yet rewritten the code to use `openat` but that's the idea. The point is I have to know the file size to do `mmap` so I use `fstat`. So the inode numbers are basically supplied so duplicate files, or rather files with different names that actually go to the same inode, can be identified?
That is amazing! Was that a tool you made yourself?
The `OFFSET()` macro could be expanding to anything, including something that causes the error. We need an actual testcase, i.e. something that one can use to reproduce the error. 
It's: #define OFFSET(r, c, rowlen) ((r)*(rowlen) + (c))
You can only get the file size by executing `stat()`. You could open the file and do an `lseek()` as well, but that restricts you to files that you can open. You cannot open a file by inode number because that way, permission checking would be impossible. (which you already know)
Do you still need help with this? If so how have you progressed?
What do you want to do? If you want to read through large directory hierarchies, I advise you that parallelizing these operations is not going to help much as disk IO is the limiting factor and there is typically only one disk.
It does provide an advantage, as I already explained. [The size of the buffer matters](http://be-n.com/spw/you-can-list-a-million-files-in-a-directory-but-not-with-ls.html). 
I actually just got it resolved. Somehow I had created two file names of the same file and I was using the wrong one.
That's not relevant, and it's addressed in the very second line of the article. The point is that there exists an inefficiency. A large directory is a testcase that brings it into sharp contrast, but it's always present, even at smaller sizes. The question was about how to efficiently iterate directories, so why wouldn't you want a testcase that demonstrates worst case behavior? Do you test a sort algorithm with ten items or ten million? 
I see what you mean. How else am I supposed to get the absolute path to include it as an arg in `fopen()`?
My point is that this pathological behaviour almost never occurs in practice. The extra effort using `getdents()` takes and the unportability you get from doing so does not even cause the program to be faster in 99.9% of the cases you use it in. If the question was “performance at any price,” then my answer would be “write a custom file system driver tuned to be as fast as possible when reading directories ignoring anything else,” but this is not the question. Surely, some unspoken constraints exist and using `getdents()` just to get extra performance in a rare corner case is just not worth the effort.
use strcpy to copy the cwd into the file path char arrays, then use strcat to append the file name 
 char cwd[50]; char fileapath[50]; if(getcwd(cwd,sizeof(cwd) != NULL){ strcpy(fileapath, cwd); strcat(fileapath, "file_a"); file* file_a_p = fopen(fileapath); ... } 
I appreciate the feedback you have given me a lot. I was wondering if it might be a better idea to instead of creating copies of the contents of pointers, assigning those contents to new pointers, and then freeing the new pointers at the end of the program, to just point to the original pointers, and instead not try to free the memory of the newly created pointers fields, as they only point to the memory of the original pointers, Does that make sense? 
Yeah, that is probably a good idea.
Thanks to everyone for your responses! The project i'm considering trying to port is not my own, so all your suggestions and advice are particularly appreciated. :-)
it will work fine in this question...but as a general good habit, it is better to initialize each of the variable that you are using.
Warning: Almost a wall of text (also potentially wonky formatting) TL;DR: Without formally debugging your program, I would guess that your segfault is probably coming from `fprintf(out, "%s\n",modify);`. &amp;nbsp; *** There are a number of problems here, and most of them in fact have nothing to do with files. In lieu of simply fixing your program and giving it back to you, I'm going to point out as many errors as I reasonably can and attempt to point you down the right path. Feel free to ask for clarifications. That being said, let's dive in. &amp;nbsp; *** ###Unused variables: &gt; char upper; &gt; int i=0; Your compiler should have warned you about unused variables. These won't cause segmentation faults, but they represent code clutter that can and will confuse you and anyone else who reads your code in the future. What were they originally used for, and why aren't they being used now? If your compiler does *not* warn you, then you need to figure out how to get those warnings. For `gcc`, `cc` and `clang`, you want the flags `-Wall` and `-Wextra`, which will give you most of the warnings you'll need. If you use an IDE, then I suggest you consult *its* manual / documentation or dust of your trusty google-fu. &amp;nbsp; *** ###Infinite Loop: Generally, things like infinite loops are difficult to find just by staring at code, but here it's quite obvious if you know what to look for. Consider your loop condition, `f != EOF`. The *only* other mention of `f` in the entirety of your program is its declaration / initialization: `int f = 0;`. `f` is not modified anywhere within the body of the loop it controls, which is a sign of a loop that either never runs or never terminates. Consider also this line from within the loop: &gt; int c=fgetc(in); This is interesting, because the data your loop deals with resides in the variable `c`, whose *scope* is limited to the loop body (and not the condition / test). This is fine, except in the case where something outside of the loop (Hint: Loop conditions are not part of the loop for scoping purposes) might somehow depend of the value of `c`. &amp;nbsp; *** ###Argument types: Your compiler should have warned you about this line &gt; fprintf(out, "%s\n",modify); The `%s` in the format string means that `fprintf` expects you to give it a *string* as its third argument, which you have not. In C, strings have the type `char *`, whereas in your program, `modify` has type `char`. You need to resolve the type conflict, and you need to do it *correctly*. Figure out exactly what kind of thing you wanted to print, and then consult the documentation for [format strings](http://www.cplusplus.com/reference/cstdio/printf/) (you're primarily interested in the first table). &amp;nbsp; *** ###Redundancy: &gt; fputc(modify,out); &gt; fprintf(out, "%s\n",modify); &gt; printf("\n"); `fputc` and `fprintf` look like they print the same character to the same file. Is this behavior intended? Your call to `printf` prints newlines to the terminal, even though your program produces no other output. Is this behavior intended? &amp;nbsp; *** ###Files: &gt; out = fopen("change.dat","w"); In isolation, this statement is *not* wrong. However, you've placed it strangely in your code. To see why, imagine the loop runs three times. How many times do you open the file? How many times do you close it? One way or another, you need to reconcile those numbers. Consider opening the file elsewhere in your code. &amp;nbsp; *** ###Flow control / Program Organization: This also touches on a somewhat subtle (to newer C programmers, anyway) issue regarding file handling. &gt; else{ &gt; printf("Failed to open file\n"); &gt; } Question: What happens if we enter this conditional branch? Answer: We print a message and continue with the rest of the program. In general, that would be a problem, but you got lucky because the rest of your program is only the following: &gt; fclose(in); &gt; fclose(out); &gt; return 0; Do either of these calls to `fclose` make sense given that we failed to open `readme.dat`? While the C standard guarantees that calling `fclose` on `NULL` is not perfectly fine, you'd be in trouble if the rest of your program tried to use `in` or `out` for anything else! [exit](http://www.cplusplus.com/reference/cstdlib/exit/) may be of interest, especially the example code. &amp;nbsp; *** That's about it. In the future though, try to be more consistent with your indentation and whitespace. I see 0, 4, and 8 space indentations in your code, as well as inconsistencies in whitespace around operators, parentheses, and braces. It's a minor gripe, but it does impact readability.
The answer to your question really depends on what type of processing you're doing. * If you are running a real-time system with hard deadlines, then you simply ensure that the work you need to do takes less than the time you have to do it: then starvation isn't an issue. * If you aren't trying to meet real time deadlines then the simplest way to implement priority scheduling is with multiple queues, each with a priority. * To avoid starvation, an easy way is to schedule based on a weighted aging algorithm where the longer a thread is un-serviced the older it gets: highest score wins, where score = f(age,priority). That's a very simple scheme, but it's effective. * I think that beyond a certain point you're going to get diminishing returns from having an semi-infinitely prioritizable queue.
I'm using pointers to pairs because it's the way I was able to figure out how to accomplish my task to be honest, it might very well be sub optimal. 
It very much is. Looks like you're translating Java to C.
I knew the solution was going to be something totally simple like this. Thank you so much for your help friend.
Best practice is always to let the compiler manage memory for you when you can. The main difference between Java and C is that if you malloc some memory, and then don't clean it up, it gets stuck that way forever. Consider the following code: int foo(void) { struct bar* my_bar = malloc(sizeof(struct bar)); // Do a bunch of complicated things that could possibly fail and return early int result = my_bar.x; free(my_bar); return result; } In the above example, you need to explicitly free my_bar at the end of the function. Not only that, but you must free it any time there is an error and the function returns early. You also must make a copy of the value you intend to return before freeing the struct. This is easy enough with one variable, but add three other variables that get introduced at different points in the function, and it starts getting complicated fast. The solution is to simply allocate the struct on the stack: int foo(void) { struct bar my_bar; // Do complicated things return my_bar.x; } Here, the compiler does all the heavy lifting for you: You don't need to allocate my_bar to begin with, and you never need to remember to free it, either! Edit: Fixed a silly bug.
Thank you. Ironically, I switched to writing my code the way it is because I was having issues freeing the memory, and so found it easier if instead of mallocing more memory and copying things over, I would just use pointers. That being said, I still appreciate you taking the time to explain this concept to me. 
It's for people who want to install a package in a non-standard place like their home directory.
Your paste service does not load. Please use a different one.
That's exactly what I thought. But then I really don't know how I can use preprocessor macro and conditional compilation directives to specify test. Do you have any ideas?
Something like this?: if some variable is defined use c standard behavior else use custom behavior
When I wrote &gt; use c standard behavior I meant &gt; implementation defined Thank you. Now I finally got it. But why then explicit -13 / 5 == -2 is better? Works the same for all and therefore reduced responsibility for the client?
I don't see why you would need `-13 / 5 == 2` anywhere. I would write the code like this: 1. take the absolute value of both numbers 2. do a division / modulo 3. depending on the sign of the original numbers, adjust the result the last step is different depending on what method the caller desires.
Please do not remove the question after getting an answer! This makes your question useless for future readers!
Looks good to me. The reason you would use this definition test is so you can use a simpler implementation in case the platform uses the behaviour you want.
Same here, but also drivers for windows 7 !!! Network drivers at the moment. Some of the C work going towards programming an ATMEL ARM M0 microcontroller.
The first step is to format it so we can read it more easily: #include &lt;stdio.h&gt; int main() { int width = 0; int count = 0; int sw = 0; int count2 = 0; printf("Enter width\n"); scanf("%d", &amp;width); while(count2 &lt; width); { if(sw == 0) { count ++; printf("#"); sw = 1; } else { printf("O"); sw = 0; } if(count == width) { printf("\n"); count = 0; count2 ++; } } return 0; } The next step for you would be to add more printfs to see what the variables are doing during execution. Add immediately after the scanf line: printf("Width= %i\n", width); We see it captures the number OK, but after that program flow does not get to printing out the first #. I suspect this is due to the **;** on the **while(count2 &lt; width)** line - that is the extent of the loop. Nothing after that ; is read as part of the loop.
I see. Thank you! I'm a total C-noob. Really appreciate this :)
Well, could you put it back in? For example, you edited out the link to the paste service.
I'll put it back in! :) Give me a few mins. 
Thank you! I appreciate that.
What is the value of `c` the first time the loop goes? Also, when `c` is `EOF`, you still write it to the output file, thus appending an extra byte to the output. Here is a correct loop: /* loop through the source file and copy each char to the new file */ int c; while ((c = fgetc(source)) != EOF) fputc(c, target); Lastly, don't forget to check for IO errors with `ferror()` after getting an `EOF` result.
Pasting the above loop directly gives me the same results, an empty output file. If I `printf` the contents of `c` to the console it's definitely reading something. The first value of `c` is 82 which makes sense as that's R in ASCII and .wav files start with RIFF.
What did you expect? Training wheels?
As often, the problem does not lie in the code you originally posted. Which is why it is important to always post a complete program when asking for help about programming problems. The problem occurs in this line: currentFile = sf_open(newFilename, SFM_WRITE, &amp;information); when you call `sf_open()` with mode `SFM_WRITE`, the following flags are passed to the `open()` system call ([source](https://github.com/erikd/libsndfile/blob/4b14e4519031abe6c842cdb017bfa3d206ed8a99/src/file_io.c#L559)): case SFM_WRITE : oflag = O_WRONLY | O_CREAT | O_TRUNC | O_BINARY ; mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH ; break ; The mode `O_TRUNC` causes the file to be truncated to zero bytes before being opened, which is what you observe. When you let the read loop run infinitely, this line is never reached, thus it appears that the actually somewhat correct code is faulty. To fix this, open the file as `SFM_RDWR` or even better, use `sf_open_fd()` together with `fileno()` to avoid having to open the file a second time. The clearest approach is probably: fd = fileno(target); fd = dup(fd); /* retain a copy as the original is closed in the next line */ fclose(target); sf_open_fd(fd, SFM_RDWR, &amp;information, 1); Error handling has been left out for brevity. Also change the `fopen()` call to: target = fopen(newFilename, "w+b"); so the file descriptor is also opened for reading.
That's one of the nasty things I haven't written a check for yet. FrenchAnthem.wav is just a file I yanked from Worms Armageddon of all places to test the function.
Always happy to help.
Thanks so much, but another question - why put %i instead of %d? I am new to programming so answer in english please :)
You aren't null terminating your new string. You are incrementing what y and t point to, instead of the pointers themselves. You are copying the address of what t points to to the value pointed to by y. Also, this is horrible formatting. Are you trying to make obfuscated code? You should look at example code for strcpy. You'll see how it's done and why yours does not work. 
What thing do you have trouble with?
1) Make a loop 2) Utilize fork 3) Make sure children processes don't fork
Moss is a program that can compare and check for plagarism and such. I just finished an ece class and we learned about it. its kind of related to c programming because it can check against c codes
The scanf in your while loop isn't looking for newlines. It's catching them and putting it into your operator and invoking the default of your switch statement. Edit: assuming you're entering operator operand combos one at a time
That's really far fetched, but I'll let it slide. You can find information on how the program works in [this paper](http://theory.stanford.edu/~aiken/publications/papers/sigmod03.pdf).
Change scanf ("%c %f", &amp;operator, &amp;value); to scanf (" %c %f", &amp;operator, &amp;value); Ie. put a space before %c. This will make scanf skip over all whitespace before reading a character.
scanf reads from a buffer, and scanf will pull exactly what you tell it to from the buffer (stdin). Your first scanf reads: scanf ("%c %f\n", &amp;operator, &amp;initvalue); So when you type in an operator and operand, then press enter your input buffer will have a character, then a space, a float, and a newline '\n' (from when you pressed enter.) The above scanf will empty the buffer because this is exactly what its looking for. Your second scanf scanf ("%c %f", &amp;operator, &amp;value); isn't looking for a newline, so when the scanf pulls from the buffer, it leaves the newline. The next time your scanf executes, the \n is still there, and picks it up first before waiting for more input. This is putting the \n in your operator variable, which is obviously not a valid operator, so your switch statement executes its default case, which terminates your while loop. Using scanf is usually a bad idea for beginners for this reason. 
Guess I'll copy paste my answer then. scanf reads from a buffer, and scanf will pull exactly what you tell it to from the buffer (stdin). Your first scanf reads: scanf ("%c %f\n", &amp;operator, &amp;initvalue); So when you type in an operator and operand, then press enter your input buffer will have a character, then a space, a float, and a newline '\n' (from when you pressed enter.) The above scanf will empty the buffer because this is exactly what its looking for. Your second scanf scanf ("%c %f", &amp;operator, &amp;value); isn't looking for a newline, so when the scanf pulls from the buffer, it leaves the newline. The next time your scanf executes, the \n is still there, and picks it up first before waiting for more input. This is putting the \n in your operator variable, which is obviously not a valid operator, so your switch statement executes its default case, which terminates your while loop. Using scanf is usually a bad idea for beginners for this reason. 
Can you help clarify what exactly violates the strict aliasing rule? I read this explanation, http://dbp-consulting.com/tutorials/StrictAliasing.html , and from what I understand, aliasing can happen since I'm using `char` and any other pointers to point at the same object. At one or two points, these pointers will point to the same location, but the data they point to is only ever modified by one type of pointer. Is strict aliasing violated simply because `pCharDst` and `pLongDst` hold the same address at any one moment? Also, do the "source" pointers, `s1` and `s2`, having `void *` type make any difference here? I suspect not, but wanted to make sure.
The rule is not about two pointers pointing at the same object. It is about an object being accessed by an expression with a different type to the object's type. You can see this in the `int` / `double` example early on in the page you linked. Situations with two pointers are a corollary. (The rule has a special case for objects that live in space allocated by `malloc` but we don't need to go into that here) Let's imagine some valid code: void f() { double d[20]; char ch[sizeof d] = { 0 }; memcpy(d, ch, sizeof d); } Using your accelerated memcpy you end up with `*pLongDst` being used to write the space of `d` which is an array of `double`. This is a strict aliasing violation because the object of type `double` is accessed by an expression of type `long`. There is a similar problem with the source being read. 
scanf has lots of little nuances... this is one of them. try scanf(" %c %f", &amp;operator, &amp;initialvalue); The space between the " and the % is important. It tells scanf to ignore whitespace when reading characters with %c 
K&amp;R, C Primer Plus, C in XXI Century.
&gt; The best way is to spend 10 years researching this topic and finding a data structure that is better than all we currently know. Are you satisfied with a way that is merely “good” or “good enough for your problem?” I know it can't be PERFECT, but I'd want it to be a good, general-use heap that is good enough for a task scheduler/work queue. By "good enough", I don't want to be lazy and choose something inefficient, but I also don't want to spend too much time obsessing over the details of squeezing out every bit of performance I can. &gt; Argueably the most used data structure for priority queues is the Fibonacci heap today, it's a bit tricky to get right though. What would be the easiest to implement for a beginner who has never implemented a tree before? Well, no that's not what I mean, but something which isn't too over-the-top to implement, but also has great performance. I was working on a binary-heap, but it looks like it's time complexity of O(log(n)) is slower compared to Fibonacci's O(1) of almost everything. When it comes to resizing, I can always just make it customizable and choose moderate defaults, like I did before. However, what I'm curious about is the implementation of a comparator... Lets say priority goes like this... enum { HIGHEST_PRIORITY = 3.75, HIGH_PRIORITY = 7.5, MEDIUM_PRIORITY = 15, LOW_PRIORITY = 30, LOWEST_PRIORITY = 60 }; Weird values I know, but bear with me. `creation_time` can be based on time since submitted. Like, lets say based on overall time in seconds. Milliseconds using a monotonic clock times 1000 should do the trick. So, we get a huge number for the UNIX Time, then convert to seconds, subtract by the priority's value * 1000, and boom. That way even LOW priority tasks can go because it's based on the time they were submitted. However of course, the time values vary, probably can even make it configurable as well. I really like that idea, dunno how the OS would handle aging though, but I doubt I'd need it. &gt; Generally, you want at most one thread for every capability the host has. Anything more is not efficient. If a thread tries to schedule and no task is available, destroy it. If a task is added, no thread is available and the thread limit has not been reached, create a new one. There is an inherent race condition in that, but it's not too bad if an additional thread is created every once in a while. How can you determine (portably) how many "capabilities" (assuming you mean one thread per processor)? Also can you also portably assign one thread per processor?
But i have now problem with the main() code. As it seems the scanf() function is not working properly and cannot read the strings from the keyboard, i can understand that because when i try to printf() what the scanf() has just read the program itself exits with value 3221225477, without executing the rest of the commands. And i have no idea how to fix this. On the other hand puting an fgets() instead of a scanf() can't do the work because i have to work with arrays and on the array there are two problems. One is that the string gets the character of \n, and the other is that the string has the symbol of termination \0 so the code doesn't work properly for some reason. All in all, this code is a mess, when i fix something, something other will be bugged. 
Your post got caught in our spam filter. I unblocked it for you. I'm sorry for the inconvenience.
Games. I've also written a [framework](https://github.com/ArcaneIngenuity/arc) (which used to have a functioning JS counterpart) for real time / loop based architecture used by games / simulations. The only other language that would be likely to suit my criteria would be D, and in truth I'm not so keen to learn yet another whole language right now. C with all its warts!
I am bit late in responding because I'm trying to fill my ignorance gap on the topic and related issues and I'm in the middle of a sort of C cross-platform development strategies/tools/problems/solutions tour. You have touched upon some of sensible issues which scare me the most (don't be shy to scare me, I usually prefer to start worrying before writing the first 1000 lines of code, after that it could be even more painful ;)): build system and deployment strategy. Regarding the former: even tough at first I thought I could go for CMake (which seems to be the most "user-friendly" of the options) I've noticed that both the comm. libraries (libserial and libusb) do use auto-tools to manage their make scripts. Having *absolutely* no experience with the autotools tool-chain, may I ask your opinion and elaborate a bit on its strengths against CMake? For what I see autotools is geared towards UNIX dev envs, but e.g. on Windows, one should only install something like cygwin or some "lighter" alternative like MinGW-w64 tool-chain and MSYS2 environment and it would be ready to build. Considering my lib would directly sit above them it makes some sense to consider adopting the same build tool-chain, but this has to be weighted against the somewhat cryptic syntax of the tool. Also I've no experience in using CMake, so I don't know how it plays well in a mixed build system scenario like this one. For the latter(the scariest to me): the main deploying scenario for the lib is together with desktop applications and I can't count in absolute no way the end user expertise to install and resolve deps by hand (whatever the platform is) as the average end consumer of the app is generally barely able to log-in and check its email on a modern OS: this suggests that I should try bundle as much as possible by building static version of the lib packed with lib-/serial/usb) and deploy on the various platforms. Am I forgiving something about static libs which could create major problems in a cross-platform scenario like this one (e.g. https://github.com/OpenKinect/libfreenect2/pull/283) ? Thanks again for your comments.
Let's clear up a couple of misconceptions: * Warnings do not necessarily indicate code that violates the C standard. Some do but many don't. For example, the following code yields a *value computed is not used* warning in gcc even though it is perfectly fine: printf("test\n") || printf("printing failed!\n"); * The code `a &amp;&amp; b || c &amp;&amp; b` is standards compliant in all revisions of the C standard. It is not implementation defined either, it is 100% correct standard C. * The precedence of operators is unambiguous and clear. There is no disagreement between compiler developers as to what the correct precedence is. No compiler I know gets this wrong. * While I agree that the precedence of operators in C is overly complex, the precedence of `&amp;&amp;` and `||` to each other is clear and unambiguous. Logical and always had higher precedence than logical or by analogy to multiplication and addition. That's the convention from logic and mathematics, dating back to the 17th century. If you are unable to understand this precedence rule and are unable to look it up when encountering it in the wild, you should not call yourself a C programmer. * The warnings provided by the GNU C compiler are hints. They are neither an authoritative guide about how to write programs (Python has this with PEP 8) nor do they necessarily indicate problems in your code. Often they are just plain wrong. * Writing your code under the assumption that someone who is not trained in reading C code reads it is a futile endeavor. First, people who don't know rudimentary C won't read your source code. Second, if there is any confusion about the meaning of your code, add a descriptive comment. Trying to write code that is understandable by untrained people only leads to you castrating your sharpest tool (the C language) to something mildly useless. Once, a programming language was designed for untrained people to program in. It's called COBOL. Programmers today still have to deal with that mistake. You don't want to program in COBOL. * The C standard is authoritative in that compiler writes should absolutely stick to it. A compiler that ignores the C standard is a broken compiler. The standard is by any means not merely a guideline.
I think what he was trying to get across is that: fgets(s,20,stdin); is only correct if s is defined as 20 characters in size, and that we can see it is that size. e.g. we are able to see the definition further up in the code says: char s[20];
`a` and `b` are already declared (as `bantugan *`) in the function parameters 
To initialize the hp and mp of each variable to 10. Here's the struct: typedef struct { char p[30]; int hp, mp, weapon, shield; }bantugan; 
Your solution fixed it for me, although I omitted the "bantugan a, b" part. Thank you!
Where did you hear that you need a full path? If you don't include the leading `/` the IO will be relative to the process's CWD (likely inherited from the user's shell) /tmp $ cat writer.c #include &lt;stdio.h&gt; int main() { FILE *fp = fopen("hello.txt", "w"); fprintf(fp, "Hello World!\n"); fclose(fp); return 0; } /tmp $ gcc -o writer writer.c /tmp $ ./writer /tmp $ cat hello.txt Hello World! /tmp $ mkdir test /tmp $ cd test /tmp/test $ ./../writer /tmp/test $ cat hello.txt Hello World! *Edit:* As far as getting the actual binary's location so that you can do IO relative to that instead of the CWD, there isn't AFAIK any portable way of doing it, but [this stack overflow post](https://stackoverflow.com/questions/933850/how-to-find-the-location-of-the-executable-in-c) has some OS specific ways that you can do it (ish...) *Edit 2:* Update to clarify that the CWD is a property of the executing process, not the user.
That's a lot of code, like 100 lines a day or so on average. 
You are always reinitalizing the seed for the random number generator. Because the program is so fast, the "time" doesn't change and so, it always gets the same seed, thus always getting the same value. Simple solution: Move the `srand` function out of the loop, so that it is executed once.
That worked just perfect! Thanks for your help, appreciated So far im getting correct results http://prntscr.com/aoghq5
That did the trick! Cheers , thanks for the help
Do you have any idea how can i align the numbers in a column? http://prntscr.com/aogn1y
That doesn't seem to work. I've tried removing it, putting a space in between it and it still wont compile
Line 17 is missing an semicolon (;), thus confusing the compiler. EDIT: It seems the original creator removed the original post. For completeness, there is the images s/he provided: https://imgur.com/a/AzzBK
Put a number before the character, eg. `%5d` would use at least 5 characters for the number, filling the rest with space. That way making columns are easier. You may want to read more about the format, eg. there: http://www.cplusplus.com/reference/cstdio/printf/
I can't open that image site, but you should look at the field width specifier for `printf`, as Neui mentioned. Since you know the highest number you're dealing with is 5 digits, you could use printf("%5d %d %5d",k,My_Digits(k),Number_Reverse(k)); 
I'm not the most experienced in this matter, but coming from a game development perspective I don't think I've heard of this being done or entirely possible yet, in an efficient way anyway. I don't love this method but I've seen it done where you have different queues for different priorities. A worker thread update loop will start trying to process the higher priority queue, if no tasks available it tries the next lower priority queue, and so on. The reason I don't like this is because a worker thread with no work will spin and waste cpu cycles. If a worker thread has no work you could possible decide to shut some workers off so you're not maxing a system out; this will take some iterative work on balancing it out, whatever you decide to do. I guess this is a problem with any priority system, you have to be careful how you read/feed those queues, otherwise your worker threads could get stuck on higher priority tasks and never accomplish the lower priority ones. You either don't feed it that many higher priority tasks to starve the lower priority ones, or your worker thread can process so many higher priority tasks before it decides to process the next tier. Come up with whatever works for you, you can process at most 4 high priority tasks, at most 3 medium priority tasks, at most 2 low priority tasks, rinse repeat, for example. Since starvation is a serious issue, I wouldn't want to worry about supporting more than a handful of different priorities; having user defined where you could have 100, 1000, or whatever, seems like it can get out of hand. Don't do that. For what I propose, from what I've seen, you need a "multi-producer and multi-consumer queue", not a priority queue. Google that, you should find something that fits your needs. [Edit] Filling in more details.
C is most definitely not dead, nor is it likely to die in any of our lifetimes. As for why so many people hate it, well, people hate all sorts of things, and most people just can't bear to keep their opinions to themselves. There are plenty of valid complaints that can be made against C, and every other programming language out there for that matter, but that doesn't mean you need to rant against them in print or online.
I actually have the Python one too, ordered them at the same time but haven't picked it up since I started the C books. I think you're right. I imagine the Ruby one will be more of the same. It's a shame as the way he sets the books out seems to be sound but as you say his attitude is just strange sometimes. 
Yes, Perl is similar in this regard. Perl lets you do a lot of weird stuff and some people don't like that. C is similar.
Doing weird stuff that people don't like. I'm home. 
Output: Enter size of square [range 1:7]: Input= 5 #O#O#O#O# #O#O#O#O# #O#O#O#O# #O#O#O#O# #O#O#O#O# [^source](http://ideone.com/1xMuXZ) ^| [^info](http://www.reddit.com/r/CompileBot/wiki) ^| [^git](https://github.com/renfredxh/compilebot) ^| [^report](http://www.reddit.com/message/compose?to=compilebot&amp;subject=Report%20Abuse&amp;message=--report%20https%3A//www.reddit.com/r/C_Programming/comments/4d3jkw/can_any_one_help_with_thisbasic_loops/d1rble7%20Include%20your%20reason%20for%20reporting%20here.) 
In a simplified sense, C came about at a time when you were pretty much writing important stuff in assembly. So everyone was excited to write in a high level language that was easier and managed the minor stuff for them. There were other languages out there, but for whatever reasons they weren't as good or as fast or whatever (note: for that specific role that C filled). These days, the machines are fast enough that bleeding performance isn't as needed and cycles can be burned on more management of the little things. So some of the stuff that C forces upon the developer (say.... keeping variable types straight, garbage collection, etc) can be handled by the language. So all of these other languages now manage that stuff and they are fast enough that the advantages of C don't appear to be there anymore. C basically went from a high level language (compared to Asm and Machine code) to a pseudo-low level language. Because of that, concepts that used to be things that you just had to know and everyone knew (in theory) like memory alignment and pointers and etc, are now things that don't need to be worried about. Who cares about memory alignment of a struct when you have meta data on the variable type and serialize it to send it between modules? I mean, I had to explain memory alignment to mid-career C developers a few months ago and that blew my mind. "C needs to die" in that people don't feel a need to learn the code/machine at that level anymore. A more abstract, "hand holding" machine (for lack of a better word) makes more sense to them. It's safer and easier to develop in so code (in theory) is released faster with fewer bugs. At the same time, it's also the outcome of the programming market being saturated with programmers. As one of my managers once said on a product I worked on, "C developers are expensive. Java developers are a dime a dozen." We wrote a framework and middleware for Java developers to do their magic on easily. But since Java is easy and C is hard and they were isolated to Java land (because that was the easiest field to get into that paid the most), they would have looked at C like an antiquated language that needed to die without realizing that what they were doing wouldn't have been possible without it. In other words, when the language you learned first and best and use every day hides the inner workings of the memory for you and makes it easy to not care, it's a weird feeling to be forced to worry about what a pointer is, where it's pointing, or what it actually means. If Java (or C#, or Python, or even C++) can figure out how to deal with that for the programmer, then why should the programmer be forced to care still. C++ is the odd case. There are many people who feel that C++ fixed the "problems" of C and should replace C for that reason. Objects and classes make code more resuable and protect the intent of the original developer and keep the module pure and blah blah blah. Most of it is nonsense that looks great on paper (mostly... I don't buy all of it) but never seems to fully play out in person (grated, usually because of poor implementation, not the languages fault so much), but, regardless, people see it as reason for C to die and be replaced by it's successor (which they will call for the death of in 10 years)
Thanks - have been looking for something like this as a supplement to my OS course.
The problem isn't really with using C, where C works(e.g. low level situations). The problem is when C is used for higher level applications, which then introduces unsafety and certain classes of bugs. And that's what Zed tries to caution against. He sometimes exaggerates what he says, and that's not bad, it's just a way of speaking/writing that he uses.
go to the /r/learnpython subreddit and they have a list of reasons why "learn python the hard way" is not a good book to learn python. There are better ones. Also, I recommend Modern C or the K&amp;R book which will be difficult at first if you are beginner. Note: I'm actually not quite sure which is the best C book but I'm sure someone here have better recommendations. I just mentioned those two because I see them talked about a lot for people wanting to try out C. edit: also Linux isn't a language. Maybe you mean bash? 
Hi sorry I might not have been clear. I've bought resources on the Linux/GNU operating system. I now use it on all my main machines. I was just saying I have an interest in that and as the kernel and some command line programs are written in C Shaw's attitude was confusing to me. I have the Sam's teach yourself C, Modern C and K&amp;R are on my Amazon list for the future! Thanks for the suggestions! 
&gt; Why would you use pointer arithmetic to acces an array element or use pointer subscripting? Because there is no other way. The notation `a[b]` is just shorthand for `*(a + b)`; if you used arrays before, you used pointer arithmetic before. &gt; What are void pointers and when to use them? Void pointers point to no type in particular. You use them when the type a pointer points to isn't known or if the type can be any type you want.
This is one of the reasons I don't like 'Learn C The Hard Way'.
It's sad that there is no /r/B_Programming, but posting it here would be great, too.
Let's not forget about [BCPL](https://en.wikipedia.org/wiki/BCPL) and the long-awaited "P" programming language.
I like how main( ) { auto c; c= getchar(); putchar(c); } almost looks like modern C++.
And we've gone full circle.
I'm thinking if there's an algorithm that is able to find and print prime factors, it can be modified. Instead of printing the prime factor directly, it should try to store it in a variable. I'm thinking define three signed int variables, unimaginatively named variable1, variable2 and variable3. Initialise them to something that will not be a prime factor; if -1 or 0 qualify use them as default values. Find a factor, try to store in variable1. If variable1 has default value it is safe to change it, so do so. If not, try variable2, if it has the default value it is safe to change it, so do so. If not, try variable3, if it has the default value it is safe to change, so you can if you want. If variable3 is not default, exit with error. If process completes without variable3 changing and it remains with default value - print the two factors found. 
&gt; In addition, you can implement a safe function of your own, if necessary; a lot of examples and guides can be found around the web. Both examples are wrong. It's simply [not possible to implement a secure memory wipe of a non-volatile buffer within a conforming C program](http://www.daemonology.net/blog/2014-09-05-erratum.html) because literally zeroing memory isn't a required side effect. Casting to volatile isn't enough, either. You either have to reach outside the language (inline asm, rely on implementation behavior) or use a supplied function with those specific semantics understood by the compiler.
It reduces the chances that the compiler can catch a type error. Best practice for modern C programmers would generally dictate not writing new code using this style. What to do with existing code that uses this style might be more controversial. I generally don't see modern projects that use this style but there are exceptions -- for example, the last time I looked at the source code for the C implementation of Ruby, I was startled to find that it still used K&amp;R style. This may have changed since I last looked at it. My own suggestion would be not to migrate well-tested libraries that are just used in your code as unchanging libraries, but that anything under active development get migrated.
In theory, correct use of *volatile* ought to prevent dead-store elimination, but it's not really something you want to trust the compiler to do. The interaction of the "abstract machine," the so-called "as if" rule, and the *volatile* qualifier has always been rather murky. Hence the need for memset_s() in the first place (you shouldn't roll your own and hope the compiler behaves).
Trace what happens to the variable `flag`
 char *wafer_number[10]; [...] num_inputs = 1; InputOkCancelDialog(num_inputs, "Enter the wafer number:", wafer_number, "", str_2, "", str_3,"", str_4); Try this instead: char wafer_number[256]; [...] num_inputs = 1; InputOkCancelDialog(num_inputs, "Enter the wafer number:", wafer_number, NULL, NULL, NULL, NULL, NULL, NULL); It's not clear how much you want to get caught up in C, but the original code passes wafer_number as a (char **), whereas the modified code passes it as a (char *), as the interface expects.
Ive done it but this is what i keep getting now for some reason http://prntscr.com/aowv1v 
First, you shouldn't use static variables in your Rec_Bin function. void print_bin(int n) { if (n &lt; 1) return; print_bin(n / 2); putchar(((n % 2 == 1) ? '1' : '0')); }
And i add \n on printf("%ld",result); My results are all scattered around, Take a look: http://prntscr.com/aowzd2
I figured it out ! Added a new line printf outside the function into the main Thank a lot for your help ! appreciated :D Here is my final result http://prntscr.com/aox25m
Just a quick question how do you format your code to be a "box" on reddit? Thanks! 
Doesn't work for me on my main post :/
A blank line, and then put 4 spaces at the beginning of each line.
Please fix your layout. Your code is unreadable. Put four blanks in front of every line of code to make the code readable.
If you don't pass the size, how do you know how big the array is? It may contain 10 elements, or maybe 10000 elements. Usually you pass a pointer to the first element and the size to know how big the array is. For example: int sum(int *a, size_t len) { int sum = 0; for (size_t i = 0; i &lt; len; i++) sum += a[i]; return sum; }
You either allocate one more item than necessary (so the index 0 is unused) or you subtract one from the index as necessary (so an index of 1 becomes 0 when you actually access the array).
That's technically fine. Your function would only work with arrays of one specific size, of course. There are other ways of doing this, too. For example, strings are arrays, but you don't usually need to pass in the size to functions because the end is marked by a special character. (Of course, this can introduce all sorts of other problems, like what happens if the terminator is missing....)
Let's say you (or someone else!) want to re-use the function you are writing for a later program. For that future program, the size may not be statically defined as it is in this one. So for this case, you can write your function as /u/uno20001 suggested: int sum(int *a, int len) { /* function here */ } And then call your function with your pre-defined size (presuming my_array defined): sum(*my_array, SIZE); This promotes code re-use and portability, and makes it so that you've made something that isn't locked to a specific pre-defined value.
Yes i do, its a function in which it calls itself in order to get the result. I know you arent here to do my homework but im having a really hard time on recursive functions ;/
If you want help, you need to at least show what you've tried and why it isn't working. If you're completely stuck, maybe try talking to your professor, TAs, or classmates?
Thing is i have to submit in 2 hours and my professor isnt replying back to my emails :/ I do know how to code and such but its just the idea of making a recursive function of reversing a range of numbers is what im unable do . Its more like a problem solving issue than coding.
The sizeof solution works only for real, constant-sized arrays which are on the stack. (sizeof is computed in compile time) int *a = (int*)malloc(sizeof(int)* n); int l = sizeof(a)/sizeof(a[0]); /* 4/4 = 1 */ 
In my experience, the best way to define a recursive function is to find some subset of the data that you can operate on. There's two common subsets to work with: everything-but-one and half-and-half. For example, let's look at half-and-half. Using some pseudocode, we could define reversing something as: reverse(start, finish) { reverse(middle, end) reverse(start, middle) } So let's say we started with the list: 1, 2, 3, 4, 5, 6, 7, 8. Let's first reverse the second half: 8, 7, 6, 5. And then we reverse the second half:4, 3, 2, 1. See how I broke down the problem into a smaller problem: do the same thing, but only on half the data? Of course, all recursive functions need a base case. Here, what do you do when there's only one thing? You just print it! if start == finish print start The everything-but-one method is similar. In this case it's something like: reverse(start, finish) { print finish reverse(start, finish-1) } So, using the same example, this prints the last one, and then prints the rest of them in reverse order. So it prints 8, then prints the rest reversed: 7, 6, 5, 4, 3, 2, 1. And of course, you need a similar base case to make sure you don't try to print an empty list.
Every recursive function must have at least one case when it stops calling itself. (otherwise it'd run forever) So what's the base case? When you should stop in this function? If you know it, then you already have the first line of the code. void print_range(int start, int end) { if (/* something */) return; /* here you must do something with the data, and you must call this function, but in each step you should get closer to the base case */ }
i&gt;start Is that correct?
You have only two variables, `start` and `end`. If `end` was your loop variable, when would you stop? How do you know that you are out of the range? What is the condition using `start` and `end` if you want to know whether you are still in or already out of the range?
This is fascinating. I've always been curious how close B was to C. It's clear the syntax was fixed when B was developed. C filled in a lot of holes (typing, structs, a distinction between pointers and arrays, for loops, a heap) but the syntax stayed the same. Packing 4 characters into a single "char" variable is interesting. I'm curious about the machine they were developing on. It appears to be a Honeywell 6070 running some sort of TSS, but I can't find any information on that machine or the operating system. The fact that you had to run commands to pre-allocate space before creating them sounds horrifying.
You don't need a loop. You actually replace the loop with recursive calls.
[Source](https://www.securecoding.cert.org/confluence/display/c/MSC06-C.+Beware+of+compiler+optimizations): This compliant solution uses the volatile type qualifier to inform the compiler that the memory should be overwritten and that the call to the memset_s() function should not be optimized out. Unfortunately, this compliant solution may not be as efficient as possible because of the nature of the volatile type qualifier preventing the compiler from optimizing the code at all. Typically, some compilers are smart enough to replace calls to memset() with equivalent assembly instructions that are much more efficient than the memset() implementation. Implementing a memset_s() function as shown in the example may prevent the compiler from using the optimal assembly instructions and can result in less efficient code. Check compiler documentation and the assembly output from the compiler. However, note that both calling functions and accessing volatile-qualified objects can still be optimized out (while maintaining strict conformance to the standard), so this compliant solution still might not work in some cases. The memset_s() function introduced in C11 is the preferred solution (see the following solution for more information). If memset_s() function is not yet available on your implementation, this compliant solution is the best alternative, and can be discarded once supported by your implementation. 
 Well this sounds correct but when i run the program it gives me main.exe has stopped working and skips the 2nd function printing the first one only. http://prntscr.com/aoz5yt void RecReversed(int start, int stop) { int i; if(stop&lt;start) { return ; } else { RecReversed(start,stop--); printf("%d\n", stop); } }
Oh, just moving the printf before the calling did the trick! Now its giving me correct results Thanks a lot for your effort and help, really appreciated. I have learned a lot from you today. Thanks again!
Write the `printf` before the recursive call. Now you do this: 1. print the rest of the numbers, 2. then print the last So it prints the first number first, and the last number last; call `printf` before you go into the recursion. You want to do this: 1. print the last, then 2. print the rest
Ye this has certainly helped me look at the "problem solving" regarding the recursive better Thanks a lot for your assistance! :D
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void reverse(int start, int finish) { if (start &gt; finish) { printf("invalid parameters\n"); } else if (start == finish) { printf("%d\n",finish); } else { int middle = (start + finish) / 2; reverse(middle+1, finish); reverse(start, middle); } } int main() { printf("even element count\n"); reverse(1, 4); printf("odd element count\n"); reverse(2, 4); printf("one element\n"); reverse(2, 2); printf("false parameters element\n"); reverse(2, -1); }
You should start to panic sooner.
No. You have a tool to tell you what syntax errors you've made: your compiler.
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void print(int value) { printf("%d\n", value); } int main() { int var = 4; print(var); //4 is printed print(--var); //3 is printed print(var); //3 is printed print(var--); //&lt;--- black magic //3 is printed print(var); //2 is printed } void black_magic_explained() { int var = 4; //BLOCK A print(var--); //BLOCK B int temp = var; var = var - 1; print(temp); //BLOCK A AND B ARE FUNCTIONALLY THE SAME }
Automated testing in manufacturing, Mostly sequentially executing io commands.
The formatting of your code is a mess. I made a quick attempt to reformat it in a text file to see if it looked like your braces and semicolons and parentheses lined up. That looks OK to me, and I did not see anything that looked blatantly wrong, but I did not attempt to compile it. If you want us to help diagnose this: - Please fix the formatting so what is posted looks like your source as your are looking at it. - Tell us what kind of compiler errors or runtime errors you are getting. - Some details about platform, etc. would be helpful... there are a lot of different C toolchains out there. I do see one problem -- the converts() function is referenced by main() but defined after main(). You can do that, but you need to provide a prototype for the converts() function so that when the compiler compiles main(), it knows that there is a function to be defined later called converts() with a given return type and parameter list. Another problem: in converts(), you are treating str as a character, not a pointer to characters, so you are trying to treat a single character as an array. C lets you pass an array to a function and it will be automatically converted to a pointer to the first element of the array. It also lets you use the array syntax on pointers. But it doesn't make sense to use the array syntax on a single character. Some of this may be broken in my copy because your paste was treated as HTML and * characters got lost in the processing.
Why haha :P
This code will take a string as input and remove extra spaces by counting the number of extra space and then it will print the result.
* You need a prototype for `converts` * The first argument when calling `converts` is wrong, you probably meant `str` instead of `*str`. * `''` is meaningless, did you mean `' '` instead? * You don't initialize `i` in `ideal_length` * Don't forget to `#include &lt;stdlib.h&gt;` for `malloc`
Lets use the number 14. We divide 14 by 2 as many times as possible. which would be once. 14 / 2 = 7. You are right in saying that if the number is divisible by 2 once, that the two prime factors are the 2, and the quotient, but only if the quotient is prime. In the event of 18, 18 / 2 = 9. 9 is not divisible by 2, and it is not prime. so this would yield an error. How can you find if a number is prime or not?
You've not been shot for using the *gets* function, but the compiler should be warning you it is deprecated and not to use it.
You can only do that for arrays. As mentioned in OP post, the function only receives a pointer to the first element of the array.
`sizeof` may be computed at runtime, e.g.: int x[rand() % 6 + 1]; printf("%d\n", sizeof x); 
Could you give like a high level overview of your engine components? how things interact and work? I'm a masters student and I had worked on creating a c engine for myself. This is how far I got till I last worked on it: [Engine Link](https://github.com/Meith/OpenGLAllShaders). It doesn't have much but it got overwhelming too quickly. It would be great if you could give your insight and how i could change or take it forward. 
Except, of course, that in B variables are typeless and `auto` here is a storage class specifier, as it still is in C; the creators of C added data types and made automatic storage implicit, thereby making `auto` redundant, and C++ repurposed the useless `auto` keyword for type deduction. So we ended up with two snippets of code in two languages that look the same and do the same thing, but have completely different semantics!
Assuming you put the .h in an 'include' directory, something like: #include "include/header.h" or add the directory to your include path: CFLAGS += -I./include #include "header.h"
Im trying to write a program to display Pascal's triangle in the nth dimension and I've got this as my code #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "../dank.h" int dim,length; int main(){ printf("Welcome to pascal's nth dimensional tetrahedron generator\n\nEnter dimension: "); scanf("%d",&amp;dim); if (dim == 2){ printf("Enter length: "); scanf("%d",&amp;length); for(int i = 0; i &lt;= length; i++){ for(int j = 0; j &lt;= i; j++){ printf("%d\t",nCr(i,j)); } printf("\n"); } } else if (dim == 3){ } } The header file is in the location specified and it returns an error when I try to compile saying "implicit declaration of function nCr
You can check if your header is getting included by forcing it to throw a compiler error: #error "testing my header" It sounds like the nCr macro isn't defined.
are you actually looking for "stdarg.h"? https://en.wikipedia.org/wiki/Stdarg.h
No, it's part of the standard library. I think you have a typo in your code somewhere of #include "stadarg.h" instead of #include "stdarg.h". I've never heard of stadarg.h
You don't link header files, but they need to be in your include path. Check your original topic, you misspelled the name of the header file. :P
You are just giving us snippet of code, and not the commands you are using, for instance the error you are showing us look suspiciously like bash errors, and the "change permission bit" is weird (did you added an execute ('x') permission somewhere? Are you trying to execute the result of cc -E ?). Give us *all* the source and headers, with their file names + the exact commands you use to build and their execution output.
Was I the only one hoping for a fun fps game instead of an article on process control?
No worries - Thanks for fixing me up.
heh heh. Nice idea for a little Linux game. Tux being the main character, his job is to kill all the zombies!
Someone joined the chat for etherpad and helped me out. Thank you though for trying out the code
`memset_s` won't be implemented any time soon by most UNIX-like systems because Annex K is fundamentally flawed. Better use `secure_bzero` from OpenBSD, which I hope is going to be standardized soon.
The `#error` is "executed" during compiling, so you can't use that in a normal program. Functions usually return a status value, which indicates success or a error. This value might be transmitted - as a return value (most common one) - as a parameter (eg. `int *errorcode`, and using it like `int err; result = func(&amp;err);`) - to a global variable (eg. `errno` in `errno.h`, used by the standard libary) But of course you can use other things to indicate a error, like `assert()`.
Ha. He's the author of the series of books. I agree, only have to spend 15 minutes on stack overflow to come to that conclusion aha! 
So, C is pass by value. So passing a `struct` to a function (or returning a `struct` from a function) will do a copy. Copying a large `struct` could be expensive. Whereas, if you pass a pointer to a `struct` to a function, then the only thing that needs to get copied is that pointer. There is some cost to do the indirection necessary to access a struct by the pointer, however. Certainly, if the `struct` itself can fit on a CPU register, then passing it by value would be faster than passing a pointer, and similarly if the `struct` is so large that it doesn't fit in the stack space, then passing it by value would be very bad. The middle is more gray. I think, generally, passing by `const` pointer is a good way to go unless you have a reason to pass by value. For instance, if you are making local modifications anyway and need to make a copy, then why not pass by value instead. Or if want to treat it the same way we treat value types (this should be more of a semantic distinction than one about it's actual size). This also brings up the question of returning a `struct`, which has the same problem (a copy needs to be done to move it from whatever variable it was in the stack space of in the function to where ever the calling function wants it). It is often idiomatic in C to have output parameters that take in a pointer, instead of returning the `struct`. This kind of optimization can be made by the compiler itself in some instances, but I don't know about how often it is done in C (it's very pervasive in C++; see [RVO wikipedia article](https://en.wikipedia.org/wiki/Return_value_optimization)). 
I don't ever pass anything but pointers to structs in my code and I guess there are a couple of reasons. First is when you don't use the pointer the whole struct needs to be copied onto the stack. Except for the most trivial of cases this could have a significant cost. The other reason is consistency. Few functions don't write the structure members so why use two function styles? What if that read only function evolves to need a write? I have a couple of issues with your vec3_add functionstarting with the fact I am pretty sure you can't return a struct that was created on the stack like that. It is certainly non standard. Even if it works it's dangerous to allocate memory in a random method like that. I pretty much stick to a design where you have Constructor and Destroyer functions and make sure they are matched like VEC3 * vec3_create() void vec3_destroy(VEC3 *vec).
&gt; or returning an int with a specific error code. A variant of this that I've seen (and done in some of my personal code) is to return `char *` (generally `const`). A `NULL` return means no error, a non-`NULL` is a string beginning with an integer error code. If the caller cares about the specific error code, a simple call to `atoi` is sufficient. In either case, the string contains some descriptive text for logging. 
&gt; For instance, if you are making local modifications anyway and need to make a copy, then why not pass by value instead. This is precisely what happened. I made a few functions expecting that all I'd need is pass pointers. Then I had to write a function that needed to make copies of the arguments anyway. Which got me thinking which way is more appropriate. because now there are two ways to pass data to functions that belong to the same header file, which seems awkward to me. 
Well, I think by better I mean more correct. but the performance still matters to me since I am planning to use this in a very basic game engine.
&gt; so why use two function styles? I agree, this what motivated me to make this post. I started out making the functions pass by reference then I made another function and it felt more intuitive to make it pass by value because if I passed them by reference I was eventually going to make a copy anyway. float vec3_distance(VEC3 v0, VEC3 v1) { VEC3 t; vec3_scale(&amp;v1, -1); t = vec3_add(&amp;v0, &amp;v1); return vec3_magnitude(&amp;t); } &gt; I pretty much stick to a design where you have &gt;Constructor and Destroyer I am planning to use this in a very basic game engine, wouldn't having creator and destroyer functions impact the performance negatively?
the concept of throwing an error does not exist in ansi-c. Consider switching languages if you like that. I would go for error return values. Here is an example: #include &lt;limits.h&gt; #define math_error 1 #define math_ok 0 int math_abs(int value, int * output) { int error = math_error; if (INT_MIN == value) { error = math_error; } else { if (value &gt;= 0) { *output = value; } else { *output = -value; } error = math_ok; } return error; }
I would not expect 3 floats to be a real performance bottleneck, but if this is going into high-performance code where it is called a lot, you really need to profile the difference on your target CPU. Try timing a billion either way and see what happens...
I added 'pretty sure' as it sort of seemed familiar. Never did it in code I have written. At least not for a decade or more. 
&gt; In that case, the compiler will not generate a copy, even if you pass by value The compiler cannot do this if they can't figure it out. It might be non-trivial (or impossible) to determine. For instance: #include &lt;stdio.h&gt; struct A { int field; }; int doSomething(struct A s, struct A* ptr) { ptr-&gt;field = 10; return s.field; } int main () { struct A s = {10}; struct A* ptr; ptr = &amp;s; printf("%d", doSomething(s, ptr)); } Clearly, the compiler has to keep track of the value passed in even though they function doesn't seem to modify it as, if this was naively inlined, it would result in the wrong value being returned. 
&gt; I want to throw an error Well, then you're in the wrong language. C doesn't have throwable errors as part of the language. It predates that concept, and relies on other means of indicating success or failure. There are 4 basic ways you could solve this: * Make the program terminate. You could use `assert()`, but that's really only for debugging; when you compile with debugging disabled, all of the asserts are completely removed from the code. You could use `abort()`, which is what `assert()` does internally. But terminating the whole program isn't a very nice way of handling errors. How would you like it if a small and probably inconsequential in your word processor or web browser led to the entire application closing suddenly without any warning? * Have the function return a value to indicate failure. Anyone who calls the function must check to make sure the function succeeded. You could do by just directly returning the value, or by setting the global `errno` variable. In this case, you could simply return `-1`, which is a classic value for "some error" (error return codes are often negative) and makes sense here since factorial can't return a negative number. * Return a fake answer, like 0. The hope is that by returning a bogus but valid number, the program might be able to just keep operating normally. 0 is a common and good choice, but in this case maybe 1 is a better option since that's the smallest value factorial can ever return. But the best solution here, I think, is: * Change the parameter to be an `unsigned` type! If factorial isn't defined for negative numbers, then why are you allowing people to call it with negative numbers in the first place?
In this particular case either way is fine. It is really a micro-optimization decision, but the compiler may select the best optimization behind the scenes anyway. Perhaps you could experiment with the compiler you intend to use, and compare assembly code between the two versions. 
&gt; How can you find if a number is prime or not? Try dividing it by every other number and see if it divides without remainder.
Calling `srand` here is probably a mistake; you should be calling that once per execution of your whole program.
argv is an array of strings, it isn't a single string that you split. Do this int i; for(i=0;i&lt;argc;i++) printf("argv[%d] is %s\n",i,argv[i]); 
Use [`getopt()`](http://pubs.opengroup.org/onlinepubs/9699919799/) if you can, or another argument parsing library. Otherwise, typically, you have to loop over the arguments yourself and then act accordingly, which can be cumbersome. For example: int levels = 0; char filePath[200] = { '\0' }; for (int i = 1; i &lt; argc; i++) { if (strcmp(argv[i], "-l") == 0) { // make sure there is one more argument if (i &lt; argc - 1) { i++; // add error checking (e.g. sscanf should return 1) sscanf(argv[i], "%d", &amp;level); } else { fprintf(stderr, "Error, missing argument to -l\n"); return 1; } } else if (strcmp(argv[i], "-f") == 0) { // etc etc } } Use of `getopt` greatly simplifies things, as demonstrated in the linked reference above.
Your code is missing a few things. First, put four spaces in front of each line of code. The backticks only work within a paragraph (like `this` here). Next, I don't see a closing brace for the ` if (num_commands &gt; 0) {` block. Also, I don't see a definition for `i` or `process_index`. Please post a [short, self-contained example](http://sscce.org/) that we can reproduce. As you've posted it here, I have no idea how your function is supposed to work. Putting a simple wrapper around your code didn't show any errors.
 typedef struct x_r{ int num; }x; typedef struct y_r{ int num; }y; int main(){ x *test1; y *test2; test1 = (x*) malloc(sizeof(x) + sizeof(y) + 100); //100 is just an arbitrary number in this example //I want to place test2 at the location test1 + sizeof(x) + 100 } This code is a really simplified form of what I'm trying to create. I have two separate structures. In the first one, I can simply use malloc to allocate the full block of space and then I set the first struct as the pointer that's returned from malloc. I'm just stuck on what I should do for the second one. 
&gt; How do I keep track of this so that when I call malloc() again, the program knows to start the memory at memory[50]? You maintain a data structure that records that information. You store that data structure on the heap, i.e. the heap stores both the allocations that you're returning to the user as well as the bookkeeping necessary to keep track of which portions are free and which are in use. The most common way of doing that is via a linked list of free blocks. But your example already implements that, so I don't really understand the question. Did you not write this code? 
My question is how do I keep track of that information with the given structure. I did write this code but it was written using brk() and sbrk(), it's just completely throwing me off how to do the exact same thing but instead of brk() and sbrk() I am just using an array instead. If you look inside extend_heap(), you will see b and sb are not assigned values because I don't understand how I would implement this exactly in order for it to behave like the brk() and sbrk() functions 
If I were you, I'd use pass by reference, and have the add function reuse one of its arguments: int vec3_add( VEC3 *v0, const VEC3 *v1 ) { v0.x += v1.x; ....... return 0; } That way, you can even add error checking. For example, if v0 or v1 are NULL, you can return an error code ( such as -1 ). 
There are a few ways to do it. Maybe make an array that contains one bit for each byte of your 'region', and whenever you allocate memory, set those bits to one. Then when that memory is freed up, set them to zero. Then for an allocation, you just search for a block of zeroes in your map that is the right size, then set them all to one and return it. Another way is to use a few bytes in front of each allocation, describing it. For example, you might have a 4 byte value that stores the length of each block as the very first thing. Then the pointer you return from malloc() is 4 bytes past where it really begins. There's lots of ways of solving this problem and there's TONS of information on google showing exactly how its done. What have you tried?
I talked specifically about his code sample. Anyway, the compiler should be able to do that much alias analysis. gcc -O3 compiles your code to this main function: sub $0x8,%rsp mov $0xa,%esi mov $0x4005a4,%edi xor %eax,%eax callq 4003c0 &lt;printf@plt&gt; xor %eax,%eax add $0x8,%rsp retq nopl 0x0(%rax) So not only is no copy generated at all, the only trace of the function is that 10 is moved to the register esi. Edit: Even -O1 does this. This is actually an argument for passing by value, since no alias analysis is required.
I don't like that because while the article actually says the right thing (“Developers can no longer afford to use third-party libraries without also keeping track of the libraries' updates and security profiles.”) most people are likely to hear “Don't use third party libraries and rewrite it all.". The thing is, developers in your company aren't likely to be smarter than those that produced those libraries. Maybe they are but experience shows that most people tend to write buggy software just because they don't understand all the edge-cases that were added year after year in a well-known library. Cryptography is a good example of that. Wheel reinvention should be downright exceptionnal. On the other hand what is said is interesting: we need to put more time checking and managing our third-party libraries. The good thing is, if it's open-source it benefits to everybody.
I sincerely expect you're correct.
That's taking a very arrogant view of your own coding abilities, to say that 3rd party libraries are the **most** insecure parts. Generally, using a widely-used 3rd party library that is mature and has been put through its paces is a great idea for security. Now, obviously some things can still happen (look at Heartbleed) but in general, if a library is used by a lot of developers, edge cases are usually sniffed out. It's just up to you to maintain and update when security updates come out for your 3rd party library.
In my opinion, the best policy is to depend on libraries only where necessary. Each library is something you need to pay attention to when maintaining your code; each library has the potential for breaking things. Finding a bug in your own code is much easier than sifting through a library you aren't familiar with. But on the other hand, a mature library has the potential for being a much cleaner implementation of complex functionality than you can ever produce and if the library authors don't fuck up too much you can safe a lot of effort just by using an appropriate library.
&gt; It's awkward because it's broken and a blindingly obvious memory leak... No it isn't... there's a dereference before `f` (`*f`) and `foo_init()` is assumed to return `struct foo` and not `struct foo *`.
There's no memory leak - the non-obvious part is that the assignment is actually a `struct` assignment, *not* a pointer assignment - `foo_init()` returns a `struct foo`, *not* a `struct foo *`. Thus, the assignment copies the returned `struct foo` object from `foo_init()` into the contents of the malloced object `*f`. Underneath at the compiler level, the copy will (should) be removed so first piece of code will be identical to the second piece of code functionality wise. But obviously, it's still much harder to understand at a first glance, which was my point. If you were pointing out that I didn't call `free()`, then you would be right. I didn't bother because it's just a small piece of code to show a concept, and memory management wasn't the point.
Check again, it's actually **dereferencing** the pointer, and so writing *into* the memory returned by malloc, and not leaking the pointer at all.
I'm not quite sure what you're being asked to do, but it seems like you need to make a function for each part of your shell command and call them in order. Are you supposed to parse the command or is it always the same? A cat() function would just be an open(), malloc(), and read() into a buffer. I would then make a cut() function, a sort() function, and a uniq() function. Lastly, print out the results ( less() equivalent). Do it in pieces and it's easier.
This assignment is to use Pipes, FIFOs and sockets to emulate that series of commands. But that's a good suggestion! Edit: the command line is always the same. 
Sorry, the main question was on tips to create the program. But my other question is with the creation of cat() function. Tips on how I could make it work because of the flags that cat has (I read the manpage and didn't understand how can I implement it in C. 
Are you sure you need to implement all the cat flags, and not just the functionality used in this example?
You are right. Right there in edition 2. Looked through the structure chapter of edition 1 which I read back in the day and I don't see it. There is a line about returning pointers being safest with most compilers. I don't recall seeing anyone use it. I guess you never stop learning.
I think you don't understand the assignment well enough. You need to talk to your professor and get clarification.
To make your code show up correctly on reddit, put four spaces in front of every line. Some issues I noticed: 1. `fscanf` requires you to pass the *address* of the variable you want to read your data into, but you're passing the variable itself. 2. You're using `char` variables as indices into your array, which is legal, but unusual, and probably not what you want. 3. You're only reading a single `double` from the input file with your `fscanf` call, whereas I imagine you want to read the entire array.
Most modern compilers will move that to the heap if necessary. It's still not a great idea.
There is no compiler on the face of the earth that will allocate an array declared as a local variable on the heap. That's an invalid transformation. 
Not a good concept. Too tricky to get right in a concurrent environment without allowing memory leaks.
The strings are compile time const strings, for example (off the top of my head, not a real example): const char ERR_BUFF_TOO_SMALL[]="-5:Destination buffer too small"; /* more stuff here */ char *err=NULL; /* no error code */ if (nChars &gt; buffsize) { err=ERR_BUFF_TOO_SMALL; } /* more stuff here */ return err; Of course, this isn't appropriate for all cases, but it can work in some. For one thing, it's not as appropriate for "warning level" return values. I got the idea from an article that described the Linux kernel doing something similar. 
Citation needed. I call BS on the idea that Linux does anything of the sort. *Maybe* there's some badly written driver that does it just within that driver, but in general Linux is pretty consistent about returning standard Unix-style error numbers and/or using `errno`.
&gt; A NULL return means no error, a non-NULL is a string beginning with an integer error code. If the caller cares about the specific error code, a simple call to atoi is sufficient. So it bloats executable size by adding in a whole lot of constant strings and pointers everywhere (I pay attention to this because I work on embedded systems, and strings like this are killer), it requires string parsing in some cases, and it sucks to localize. What was wrong with using integer error codes and `strerror()`?
That's probably correct, since none of the flags are used in the example. As for tips, have you started writing the program yet? Got it opening and reading /etc/passwd? 
Because I'm inexperienced. I removed the for loops the program works the same now, thanks for the help.
why are you comparing the return value of strmp with `&gt;` ? The while loop will keep going until num is 20, regardless of what string you enter. You want &amp;&amp; if you want to quit if either condition becomes false.
 printf("x[%d] = %g\n", i, x[n]); `n` is the length of the array where `i` is the *current* number you are processing. `n` doesn't change and thus, `x[n]` returns the same value. for(i=0; i&lt;x[n]; ++i){ Same there. The following also shows, that you are saving to the constant place: scanf("%f", &amp;x[n]); There, you are also checking by value. Because `x[n]` happens to be `2` and you got 2 elements, you didn't saw any errors. Then, at closer inspectation.. Why are there `while`-Loops in for loops? What are they supposed to do? What is used `j` for? If you can't explain it, then it doesn't make any sense. 
Nothing wrong with integer error codes. I was just saying that I've seen and written a variant of it. In some cases, this approach is nice. In size-constrained environments it's not appropriate, obviously based on your comment. It's just a tool, not necessarily the best, or the right, one for all cases. `strerror` is, unless I'm mistaken, limited to strings associated with predefined error codes. This variant allows application-specific error codes and strings. 
I changed it to != and || to &amp;&amp; and I'm getting Segmentation Fault: 11 now. How could I be getting an infinite loop after I enter END?
It's been years since I read it, and it may have been wrong. I recall reading it someplace that also talked about the kernel's interesting linked list implementation. I spent a few minutes Googling, and can't find it, but it's pretty hard to search as well. I'm not trying to defend anything, just offering what I found to be an interesting option. So, I'll just say that you may be right. Edit: I may have misunderstood a description of `printk` or just decided to apply an idea from there in logging. 
Presumably the crash is then occuring in code you haven't shown. Run the program in the debugger, or use strategically placed printfs to narrow down where the crash is occuring and display relevent array indices etc.
&gt; `n` is the length of the array where `i` is the current number you are processing. So use `i` instead of `n` when accessing the array, because this variable is changed every loop iteration (goes one higher after each block has been executed). For example, this code will print the numbers 0 and 1: int n = 2, i; for (i = 0; i &lt; n; i++) { printf("i is currently %i\n", i); } If `i` reaches `n`, the statement `i &lt; n` is not true anymore (they're equal) and so, the loop stops. So if you access a array with `x[i]` in the same loop above (assuming `x` is a array), then it would access it once with `x[0]` and then in the next iteration with `x[1]`.
This. If you really want to go nuts with the printfs I recommend: `printf("Line: %d\n", __LINE__);` which will print out the line of the printf, and putting them before and after every actual line of code will tell you where the failure is. And in loops, you can expand it to include any variables of interest e.g. `printf("Line: %d, num: %d\n", __LINE__, num);`
Please share your solution so people with the same problem might find some help [relevant XKCD](https://xkcd.com/979/)
It sounds like you need to use fork and exec in a C file to call into each of those commands. If this is what you need to do, a hint for piping would be for you to look into what happens when you close an existing file descriptor and then duplicate another one.
Thank you so much, It makes sense now.
You're dereferencing size despite it being a integer value not a pointer. Could you give a little more detail on what is wrong here. "Pointers are wrong" doesn't help. What output are you getting? What is the expected output?
 printf("How many numbers? "); scanf("%d", &amp;size); At this point, `size` is already a pointer to an `int` so you don't need to take the address of it.
Author here. Some of you may know me as the developer of [Criterion](https://github.com/Snaipe/Criterion). Multiple users of Criterion asked about mocking libraries in C, and I did some research about existing projects -- however, all of them relied on external code generation or compiler-specific options. I decided to work on a saner, simpler alternative to these mocking library, and after a month of planning and experimentation, Mimick is coming closer and closer to its first release. The road to 1.0 is still long though, and I am actively seeking opinions on the project and its API, as any design decisions that we keep for 1.0 will have to stay for the better or the worst. 
Your post got caught in our spam filter. I'm sorry for the inconvenience.
No problem, thanks for the heads up :)
Are you promoting your own code or something ? There's barely any code there. [Beej's guide](http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html) is my goto for these things.
Use proper formatting: E3.c:25:43: error: expression result unused [-Werror,-Wunused-value] for (long long i = 3; i &lt; upperBnd; i + 2) ~ ^ ~ E3.c:51:42: error: expression result unused [-Werror,-Wunused-value] for (long long j = (i - 2); j &gt; 1; j - 2) //don't check whether even numbers are prime ~ ^ ~ The compiler is underlining the exact location of the thing it's warning about; it couldn't be clearer. Writing `i + 2` as the third clause of a for-loop has no effect, because that does not modify `i`. Also, that's only a warning. It's been turned into an error because you used `-Werror`. 
Beej is a great tutorial and you'll see that it is in the references section of that github page. But something I personally find useful for learning code/technology is having a simple program with prodigious comments around almost every line of the code. That's what that github link is. It's not meant to be a replacement for Beej's Guide.
To update the value, assign: `i = i + 2`. You can use the `+=` and `-=` shorthands for this: `i += 2`, `i -= 2`.
The array x should be just shifted. It is passed from main
Thanks! The API is heavily inspired by Java's Mockito, which turned out to be the easiest implementation with only C99 and macros.
It worked. I edited the initial code with my new question facing the issue I am having now. This is the part I need tips. And many thanks for helping! 
Your title says you want to shift, but your comments say you want to rotate. I will assume you want to rotate and actually modify the arrays. I took out printing of the array, but you can just loop from 0 to size-1 and print each element if you want that (note that the last index is size-1 not size) I didn't test this code, so there may still be an error, but this is approximately what you need to do: void choice_6(int size, float *x) // Rotate the list of numbers to the right { int i; float last_val = x[size-1]; for(i = size-1; i &gt;0; i--){ x[i] = x[i-1]; } x[0] = last_val; } void choice_7(int size, float *x) // Rotate the list of numbers to the left { int i; float first_val = x[0]; for(i = 0; i &lt;size-1; i++){ x[i] = x[i+1]; } x[size-1] = first_val; }
It's the name of the channel
Do you have any code to show what you've tried? No one is going to do your homework for you. 
Any for loop can be trivially converted to a while loop: for(A; B; C) { ... } ...is equivalent to: A; while(B) { ... C; } Technically it's not equivalent if you declare a new variable in A, since the latter does not introduce a new scope, but if you need to replicate that you can just put the whole thing in a block. It's also not equivalent if you have a `continue` statement in the "...", but you can also replicate that if you really need it. 
God dam it XD I learn C and C++ from him XS Do you know a better youtube channel then him?
&gt;&gt; Your indentation is inconsistent &gt; I did say I'm still a newbie. Didn't I? Sure, but take the hint: even newbies can learn to be consistent in how they write their code, and when you're starting out that may be the best skill you can develop. You'd get the same advice in how you format your essay in English class, or write equations in math or physics. Consistent formatting will make debugging your own code easier, and it will make asking for help easier (because the helper will have an easier time reading your code). Learning to make your code beautiful will make your code a joy to maintain - both for you and for everyone else. To put it another way: it's easy for bad algorithms and bugs to hide in messy code. Clean code helps make many types of errors stand out.
Your post got stuck in our spam filter. I apologize for the inconvenience. Since this has happened multiple times to you now, I have added you to the list of approved submitters.
OK, Thanks.
If you look at his channel, he has done tutorials for Java, C#, C++, C, Python, Ruby, Javascript etc... The fact that he covers **so much content** surely isn't a good thing. No one could actually know well every one of the dozens of languages and frameworks that he's done videos for, especially not well enough to be in a good position to teach beginners. I've also seen some people pointing out that some of his content is almost identical to some text tutorials online, which suggests he has only learnt the language to the level of someone else's beginner tutorial, so by the end of his tutorials *you would know the language as well as he does.* To give a recommendation of something else, [The C Book](http://publications.gbdirect.co.uk/c_book/) is a good quality guide.
The thing is that I hate reading XS So thins is why I had watch his videos.
Yep, fair enough. Just some basic feedback. If you're not using braces (`{`) in all your `if`/loop blocks, you should generally keep clean formatting so that it's obvious to the reader what's happening in each level. For example, it currently looks like the `return 0`only happens in your final `else` condition, or that the `if(prime==0)` only happens if `N &gt; 1`. As for the efficiency I mentioned, it's more of a math issue. You're incrementing by one each loop, so you're checking each number, but even numbers (other than 2) can never be prime. Your program would run (roughly) twice as quickly by fixing that. Also, your `while(x&lt;N)` is correct (it will work), but you could also look at the numbers less than `N/2` because the higher numbers can never be a factor of `N`. Even better, you only have to look at numbers less than `sqrt(N)` because by the time you reach them you would have already found the [cofactor](http://mathworld.wolfram.com/Cofactor.html). For example, 12 is a factor of 36 but you would have already found 3 before reaching it. [Here's](https://en.wikipedia.org/wiki/Primality_test#Simple_methods) some more information on that.
Well do be honest I study at Coventry University and as far as I know it has the biggest library in UK. But is it really worth reading a book instead of watching a video? A book takes week to read but a YouTube series takes a few days.
&gt; Well do be honest I study at Coventry University and as far as I know it has the biggest library in UK. But is it really worth reading a book instead of watching a video? A book takes week to read but a YouTube series takes a few days. self-learn more pleasurable 
You're going to have to get over that if you want to get past a beginner level, honestly. I'd say something like 90% of documentation/tutorial is text-based.
On MacOS X, drivers are written as kernel extensions (.kext) files that use the IOKit API. They are C++ classes, not plain C. This isn't to say C++ doesn't have a lot of basis in C, but there are differences, and a kernel extension isn't really a beginner-level project, mostly due to the challenges if understanding the memory and threading model, and difficulties debugging this kind of code (a misbehaving .kext crashes the kernel, requiring a reboot). All that said, go for it -- the toolchain is very good, and free to download, and there is a lot of good sample code. Just don't expect it to be quick and easy to talk to the hardware.
https://www.reddit.com/r/ECE/comments/279p5h/embedded_driver_design_an_incomplete_course/ This might be a good place to start. I keep meaning to back and read it more. That said, this isn't a "oh, I'll knock it out in an afternoon" type project. Even assuming that you find the tech papers about how the peripheral wants to communicate with anything, figuring out the rest takes a bit.
Aw man, and here I got all excited that this would be a link to something new for me... My post that you linked isn't really related to the question at hand - it deals with specialized, bare metal embedded systems with no operating system. Something like http://eudyptula-challenge.org/ - which deals with writing linux kernel modules - would probably be more suited to this kind of question. Regardless, thanks for the link :p
That's not going to work as the production rule for `define` directives is: #define identifier replacement-list new-line `{` is a punctuator, not an identifier.
if you're using gcc and don't really care about portability you could use gcc's cleanup attribute extension. you can find more about it [here](https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html)
You don't. C doesn't have features like polymorphism or automatic memory management, and its users like it that way. If you want those things, you use C++; that's the whole reason it was created.
The system I'm writing this for doesn't have a C++ compiler.
In addition to the cleanup attributes that gcc provides, LLVM provides blocks which can be used to provide similar functionality. While neither are truly portable, using both can give you a lot of compiler coverage. As an example, the Asterisk project looks to see if clang or gcc is compiling it, and changes a macro - [RAII_VAR](https://github.com/asterisk/asterisk/blob/master/include/asterisk/utils.h#L1033) - to use either blocks or the cleanup attribute as appropriate. This lets us do things like: static void free_cb(void *ptr) { free(ptr); } static void do_stuff(void) { // When execution leaves the scope of do_stuff, free_cb will // be invoked with foo RAII_VAR(char *, foo, malloc(128), free_cb); } 
https://www.linuxvoice.com/be-a-kernel-hacker/?pk_campaign=rd&amp;pk_kwd=cod-lxk If you'd prefer then. 
If you're using C, you should learn to do without objects and STL containers. Pair every malloc() with a free() and your life will be easy. Don't abuse the preprocessor. That leads to ugly, difficult to maintain code that will have more bugs than properly written C. A few things that can be helpful: - Write your functions such that there is precisely one entry point and one exit point - Do your cleanup at the end - When you free() something, set the pointer to NULL so you can later check whether it was freed or not if you have some exception handling. One way of implementing my first suggestion is to use a do{....} while(0) loop. For example: void myFunc() { int *ptr = malloc( one hundred bajillion ); int *ptr2 = NULL; do { ptr2 = malloc( two hundred bajillion ); if ( something ) { /* Uhoh. A problem! We'd better exit the loop */ rc = -1; break; } /* success */ rc = 0; } while( 0 ); /* The function always exits from here. Time to cleanup! */ if ( ptr2 ) { free( ptr2 ); ptr2 = NULL; } if ( ptr ) { free( ptr ); } return rc; } 
thanks !
&gt;If you want those things, you use C++ Or ObjectiveC 
True, though it is less popular and less widely supported, and not without good reason...
Print it out to check. Don't be scared to experiment, it's a good way to learn.
Sorry, I realised that it was C-only subreddit right after posting. Currently searching for a C# sub. EDIT: Found /r/Csharp I'll try there.
I've used this. It works well.
If you've never written any code for a kernel before, the first step would be to write a module for some existing kernel. It doesn't matter too much what it is because once you've done it for one it's not so hard to adjust to another. There's usually a hello world kernel module out there if you look into the documentation of whichever kernel you want to hack on. You'll want to run it in a virtual machine because you will crash the kernel, and that makes life less unpleasant. As a first goal, don't think about writing drivers for actual hardware, just a kernel module that does some trivial tasks. The hardware can come next and often is its own level of irritation. To practice actual hardware stuff, getting an Arduino or some other embedded microcontroller and toying with that might be the way to go. Many of these things operate without a real operating system like you're used to, so the software side is simpler. Also, the hardware is well specified, simple, and there are a lot of tutorials. An operating system device driver that interacts with real hardware is really just the fusion of the two. 
The term you are looking for is SCOPE. SCOPE related to what 'can see', and what 'cannot see' a variable. Your book should have a few pages, with examples, that explain scope, and also a compiler should give warnings if you set it to.
For linux, [this is the book](https://lwn.net/Kernel/LDD3/). Available for free.
Variables declared in a function are local to that function. This is what's commonly referred to as it's "scope". If you declare them outside the function, their scope is broader. You can have two different functions though with the same variable name, which are actually completely different variables. To answer your question though, no it doesn't reset or anything outside the loop (unless you write the code that way).
Do you happen to know what its selling points are supposed to be? I know its used for iPhone development but that is more a "why one would need to use it" not a "why one would want to use it" ?
Yes, garbage collection. Not shoved down your throat like Java's, IIRC, but available, and used by a lot of the libraries. The runtime is simpler than say a full-on VM. In some ways it's more like an interpreter for a language like Python, in that it has to be there to run your code, but Objective C is still compiled. It's just a matter that the code can't run on that machine unless Objective C is "installed" on that machine.
aha, thank you. (Its nice to have some quick insight without spending a few months learning a language just in case.)
(Without checking the functions etc in detail) When you are done printing (first while-loop), the internal "cursor" in the file is at the end of the file, thus you can't read anything from it. (Or what should come after the last byte in the file?) So the 2nd is never executed because you are already at the end of the file. You can reset the "cursor" with either [`rewind(file)`](http://www.cplusplus.com/reference/cstdio/rewind/) or [`fseek(file, 0, SEEK_SET)`](http://www.cplusplus.com/reference/cstdio/fseek/)
I think criticizing RAII style management as being 'automatic' and therefore not suitable for embedded systems really misses the mark. In C, reliable resource management comes down to the C programmer specifying and following certain rules: pair allocation and deallocation routines in this way, this function's returned pointer has to be freed using this routine, this function's returned pointer is only valid until this other function is called, etc. Essentially the programmer imposes structure on the management of resources, in the same way that [structured programming][1] does with control flow. Resource management in C++ is done by encoding these rules into types, similar to how structured programming lead to the introduction of languages that encoded those rules. Properly done, C++'s 'automatic' resource management does nothing but exactly what the programmer would be required to do anyway, except without all the copy-pasted code and mistakes. There's no more overhead in having a C++ destructor free memory instead of doing it ad-hoc than there is in organizing a program into multiple functions rather than using unstructured programming. Of all the C++ features one could criticize as being unsuitable for embedded programming, C++'s structured resource management is probably the absolute least reasonable target. [1]: https://en.wikipedia.org/wiki/Structured_programming
You can write a module, the system calls are well documented. But without headers/documentation to know things like data format, commands, timings, etc etc etc I doubt you will get far unless its a very basic peripheral. If they use a well known chip that has documentation then it might be a little easier. But custom anything means you are starting in the dark.
What switches did you use to compile? Use /MD to use the DLL version of the C runtime. Without an /M*x* switch, it will default to static linking the runtime.
I would also recommend looking at /r/learnprogramming
Note that there is the `rewind()` function just for this purpose.
I dont need two loops do I ?
Do someone know how to get a list of dependencies of a binary file? 
As others said static vs dynamic linking. There could also be differences in how debug information and symbols are being generated. Which often take up more space than the necessary machine code from assembly. Gnu provides the strip tool to remove the symbols from you're executables and you can look their as well. A static binary might be 300M dynamic 30M and dynamic and stripped could be 1M. Just shows how much these things can very.
Yes, your threads can read and analyse the data simultaneously. Depending on what and how you're writing you may need to take care. 
&gt; If each thread has it's own place to write then there's no problem. Excellent, thank you again.
For windows, depends.exe ( you can find it if you google ) also known as dependency walker. For linux, ldd is the tool you seek. For other platforms, you're on your own :) 
What output are you getting, and what output do you expect?
Okay, it sounds like you don't understand what your for loop does. I think you just need to take a step back and think about your problem. You want to print some number of '*'s. How many? Maybe you need two loops. One loop for how ever many rows you want, and one loop for how ever many columns you want. After the last character on each row, print a newline. Done. Google 'C for loop example' and you will find TONS of great tutorials. There's no need for people here to retype them for you. If you find one and don't understand it, then please ask a specific question. 
The output I'm getting in the first code is absolute blank. What I'm looking for is printing 100 asterisks, every 10 in a line using loops. In the end I switched while to if and it worked but I wonder if my professors will think its okay? The second one is a long line of asterisks all above each other, so it seem my print space was not taken in consideration at all. 
Today's hardware doesn't complicate things unless you use it. Our CPU's still boot into the same 16bit mode that DOS used. For the OS class in college we had to write a 32 bit protected mode os that didn't have much to it. I'd be surprised if it toped 100k without debug information. Now if your os starts including drivers, everything changes. 
As long as you don't need to access the same data, there's no issue. If you need to access the same data, you should use a mutex.
 &gt; Did you write the program? Yes. &gt; The only thing to avoid is reading and writing from the same place in memory. There will be no shared data.
This is specific to the library, it seems like you are using it incorrectly. I have no idea what “swap file” is supposed to mean in this context either.
## Where pointers are allocated in memory? Pointers can be placed anywhere other kinds of data can be placed, i.e. in all storage classes. There is usually no memory region set aside for pointers. ## There is a difference if they are local or not? I have no idea what a “local pointer” is supposed to be. ## And the appointed place, where are in memory? Please improve your grammar. I have no idea what this question is trying to ask. ## What happens when we pass a pointer as parameter in functions? The same thing that happens with any other kind of argument: it is copied and the function receives the copy to do whatever it wants to do with it.
**1.a:** Pointers are allocated wherever any other variable is allocated. If you in a function write int* moo; the pointer will be on the stack. If you do something like int moo; //Just a variable living on the stack. int* poo = malloc(sizeof(int*)); //Make poo point to an int pointer in memory. poo* = &amp;moo; //Now we have a pointer in memory, pointing to int moo. the pointer poo is on the stack (just like before), but poo points to another pointer in memory, like this: --- ---- --- |poo| ---&gt; |int*| ---&gt; |foo| --- ---- --- poo is on stack. int* is in memory and foo is on stack. So as you can see, pointers can either be on the stack or in heap memory. **1.b:** Again, just like any other variable, it matters not whether or not a pointer is global or local, it will work either way. **1.c:** I assume the question is "Where in memory does a pointer point to?". In that case, the answer is anywhere you'd like! You can have a pointer pointing to the stack, and you can have a pointer pointing to the heap. On the illustration in answer 1.a poo points to heap, and that pointer points to stack. **2:** When passing a pointer, the same happens as if you passed something else. A local copy of all parameters are created on the stack (just like local variables really), and when the function returns, these copies cease to exist. So in a function void foo(int moo, int* poo) { poo* = 100 poo = 0; return; } both moo and poo are COPIES of whatever was passed to the foo. Setting poo* to 100 affects the outside world: poo still points to somewhere in memory. But setting poo itself to 0 does not affect the outside world, since poo is just a local copy of something from the outside. Hope this was the answers you were looking for. Feel free to ask for further details :)
surely maybe u post your code
I assume you are using scanf(). You have to do two things: First you have to check the return value of scanf(). scanf() returns the number of patterns matched so scanf("%d") should return 1 if an integer is entered. Second, if an integer is NOT entered you have to remove the characters from the input buffer. Since scanf() didn't consume the bad data, it will attempt to re-read it on the next call. I think the best way to do it is with fseek(). 
I think you're supposed to be doing your own homework.
Yup I could remove it for my system but this would not resolve it for others, I think I was mostly just being lazy here, I've decided to get into the guts of the server and attempt to resolve the problem there. Thanks for the help anyways :)
I work on some small embedded systems that run a real-time multitasking OS and a full application in under 64KiB. It doesn't do anything heavy like Ethernet, but it has a UART interface to the master device, Ymodem for firmware updates, and flash driver. Not sure what your point is, since "complete" OS depends on your definitions.
If mpc.h is a self created header file it should be in quotes, not &lt;&gt;.
If it is known for certain ahead of time that only gcc or clang will ever be supported, then portability becomes less of an issue. As an example, the Linux kernel uses some non-portable gcc attributes (I think attributes -- something gcc specific that I forget now). 
Most extra stuff the kernel uses can be turned off without harm. This kind of cleanup cannot easily be removed as that would require an entirely different control flow so I suggest not to use it.
&gt; so I'm assuming this is a form of garbage-collection? Objective-C still uses reference counting. That is a form of GC, but not what most people think of when they use the term. In earlier versions of the language the reference counts had to be maintained manually and there were strict rules for doing so. The compiler was updated to do that work automatically, for the most part, and annotations were added to deal with the exceptional cases. &gt; A runtime is that a form of VirtualMachine or dependency on a framework running side by side? A set of runtime functions, not a VM or interpreter. Obj-C 1.0 could essentially be implemented as a preprocessor that just rewrote Obj-C expressions into C function calls to the runtime. Later versions added some features that required deeper understanding by the compiler (such as the automatic reference counts) but the runtime is still just a bunch of functions. Here's the current documentation on the runtime: https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/
Have you looked at the sidebar already?
I am just learning C and really can't get into LCTHW because of his attitude. He seems to *hate* C so why is he writing a book on it?! I find it very hard to learn something when all of the bad things about it are constantly mentioned yet none of the good things. 
I really enjoy the book. The c bashing is just something I noticed. I have another book on c which has better in depth information bit it's delivery isn't as good. Between the two is going really well. It's sams teach Yourself c in 24 hours if you are interested. 
What makes you think your current code isn't working? What results do you expect and what do you see instead? Show us the declarations of `old` and `new` and where you calculate `size` I will tell you that you're either outside of the bounds of your array, or not copying the entire array though. `memcpy` takes a `size_t` count of bytes, so you're copying at most 1/4 of your array.
I guess I'll copy this here, in case you delete your other post What makes you think your current code isn't working? What results do you expect and what do you see instead? Show us the declarations of `old` and `new` and where you calculate `size` I will tell you that you're either outside of the bounds of your array, or not copying the entire array though. `memcpy` takes a `size_t` count of bytes, so you're copying at most 1/4 of your array.
Please post Jobs to /r/cjobs as well.
Or just remove the asterisk from sizeof(int*). So you would get sizeof(int) 
You should show your actual code including variable definitions.
I suppose a good place to start would be data structure projects. Research and implement a linked list, using that implement a stack and queue. For a first timer that will probably be pretty involved. 
lel
Here is the signature of `fgets()`: char *fgets(char *str, int size, FILE *stream); (I've removed the C99 `restrict` qualifiers for simplicity, even though they are technically part of the signature.) It takes three parameters: a pointer to a string buffer, an integer representing the size of that buffer, and a pointer to a FILE struct describing the stream you want to read from. You can't call this with one parameter, you must pass all three. char buffer[200]; fgets(buffer, sizeof(buffer), stdin); If the book does not explain the three parameters, then you should get a better book. 
That's why people hate pointers. Nerd sniping me is so easy, just give me 6 lines of C code with dereferencing and i'm stuck for 20 Min.
I think you wasted your money on that book.
One other thing that isn't mentioned here, and something that your compiler should have warned you about, is that you shouldn't use `%d` to print a `size_t` value (which is what `strlen()` returns), you should use `%zu` instead.
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; main() { int number, i, sum; printf("Please enter a value:"); scanf("%i", &amp;number); for(i = 1; i &lt;= 10; i++) { sum = number * i; printf("\n mutiples %i", sum); } system("pause"); } Edit: You forget the %. Thanks OlderThanGif for correcting me.
thanks! i just saw that -.- its the little things..
`argv[1]` is `"-finput.txt"` and `argv[2]` is `-l1`. If you're at the point where i = 1 and you've determined that `argv[i][0]` is `'-'` and `argv[i][1]` is `'f'`, then incrementing i and copying `argv[i]` gives you `argv[2]` which is `-l1`. You don't want to increment i in such a case. You'd only do that if the filename was specified as a separate argument, like `-f input.txt`. You have to handle those two cases separately. The word splitting that the shell performed doesn't know anything about arguments, only words. It's not going to split up `-finput.txt` into two words. That's one word. 
I (eventually) figured out that if you click on "Java" or "C gcc" under each heading it'll take you to the source code and command lines.
Look at this https://github.com/StevenJL/learn_c_networking
Trying writing a parser that will load and parse XML, YAML, or TOML files into native struct or object that you can then manipulate. 
I wish they'd test other C compilers as well, maybe even proprietary ones. It seems they effectively measure the performance of libgomp which (for my problems at least) is slower than libiomp (of Intel), especially when paired with Intel's MKL. 
Nitpicky is good. It helps you write better/safer code. The reason for explicitly setting members of a struct to `NULL` after allocating the memory for it is to prevent memory protection violations. These are faults that happen in the CPU when attempting to access memory that is either invalid or that doesn't belong to you. What do I mean by this? Well let's look at how `malloc` works. It simply returns the starting point of a chunk of memory of the size you requested. It doesn't zero out that memory meaning the previously stored data will still be there. This means that your `next` member will potentially have a non-zero value. If you attempt to deference the `next` pointer it will use the underlying value to look up where in memory it needs to go, but because you have a garbage value in there it will be almost certainly invalid/unsafe memory, and thus trigger a fault/exception and ultimately crash your program. Now setting the value of `next` to `NULL` doesn't magically fix the problem of a crash when dereferencing it, but it does put it in a state that you can easily guard against. This comes to the next point, before dereferencing `next` (or any pointer really) you should always test to ensure it isn't `NULL` (which you are doing) as dereferencing `NULL` will also cause a crash. Hope this info helps you understand the reasoning behind the nitpicking.
To add a flair, click “Flair” right below your post. I added the flair for you. Have a nice day!
I mean these are very early chapters in this particular book so is it a critical error on the books part or something they are purposely leaving out at this point do you think? They have only introduced the character and integer format characters at this point. Thanks for the explanation on the null terminator and the linefeed character. It's obvious when you show the example. I should have really deduced for myself that if it will be recording spaces then it will record and \n or \t etc too. Thanks again. 
This is actually a good thing. Visual Studio does a good job at detecting those things in debug mode. The program might run okay on your machine and your compiler, but it could crash on another with this bug. [The memory that malloc() allocates is uninitialized](http://man7.org/linux/man-pages/man3/malloc.3.html) so it could be anything or nothing. In Visual Studio C++ debug mode, "uninitialized" heap memory is actually initialized to 0xCDCDCDCD... so when reaching the end toAdd-&gt;next was actually 0xCDCDCDCD and not NULL.
If I had to guess, I'd bet that was a call to gets (a function so dangerous, it was removed from the language standard library). They probably just changed the name and said fuck it. 
Your code was broken the whole time , it's not any fault in a compiler. 
Technically `restrict` is not part of a function signature. Also it has no meaning in prototypes, when present it's solely for documentary purposes.
&gt; However, in order to use memcpy() the array being copied has to be constant and read only. I'm guessing you read that the type of the source array in the function signature is `const void*`, which does suggest a read-only array, but any non-`const` pointer can be automatically converted to the corresponding `const` pointer. 
&gt; "If you're interested in something not shown on the benchmarks game website then please take the program source code and the measurement scripts and [publish your own measurements](http://benchmarksgame.alioth.debian.org/play.html#languagex)." Like this guy did for [Python interpreters](https://pybenchmarks.org/).
If you store the time data in double variables, then why do you cast it to float? Why not double? %lf is the type specifier for double in printf/scanf/...
I could be wrong. Then uninitialized variables on stack are 0XCDCDCDCD ?
There is no C culture. People program C in a myriad of vastly different ways that bear almodt no resemblance. There is no common culture.
There is a general culture in any language, especially those that have been around for a while. For instance, the C culture is to avoid OOP constructs, so rewriting things like lists, etc. is pretty much required. The C culture generally emphasizes efficiency, sometomes at the expense of maintainability or ensured safety. I agree with you that there are almost as many coding styles as there are coders, and some of those are exceptions to the generalized culture.
Basically everything that can go wrong will go wrong when programming in C. Because of the vast freedom C offers you'll write crappy code in the start. But you'll learn a lot from it and will benefit to learning any language, not only in the field of security. Finally you'll better understand why certain languages were made in certain ways. But if you have to write some secure code, use another language because it will already eliminate certain bugs for you.
Implement tic-tac-toe that can either be player vs. computer, player vs. player, or computer vs. computer.
You can make a new array, and then make a loop that copies every value.
I mean in my mind you would learn a lot less going with a high level language first. That's the benefit I'm imagining. 