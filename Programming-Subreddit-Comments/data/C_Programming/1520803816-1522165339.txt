Don’t use gets!
There's lots of boilerplate initialization code inserted by the compiler and c runtime library. If you do it yourself with assembly you can get a very tiny executable that does nothing.
Relevant: http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html
This is a nifty C trick, but it's not a very good C++ trick. You'd want to use `constexpr` in this situation in C++: ~ $ cat test.cpp #include &lt;cstdio&gt; constexpr unsigned hash(const char *s) { unsigned h = 0; for(; *s; h = h*65599 + *s++); return h ^ (h&gt;&gt;16); } int main() { printf("%08x\n", hash("funny_bone")); printf("%08x\n", hash("incredibly_large_string_that_gcc_groks_easily")); return 0; } ~ $ g++ test.cpp -O1 -c -S -o test.S ~ $ cat test.S .file "test.cpp" .text .section .rodata.str1.1,"aMS",@progbits,1 .LC0: .string "%08x\n" .text .globl main .type main, @function main: .LFB31: .cfi_startproc subq $8, %rsp .cfi_def_cfa_offset 16 movl $-238617217, %edx leaq .LC0(%rip), %rsi movl $1, %edi movl $0, %eax call __printf_chk@PLT movl $-453669173, %edx leaq .LC0(%rip), %rsi movl $1, %edi movl $0, %eax call __printf_chk@PLT movl $0, %eax addq $8, %rsp .cfi_def_cfa_offset 8 ret .cfi_endproc .LFE31: .size main, .-main .ident "GCC: (Gentoo 7.3.0 p1.0) 7.3.0" .section .note.GNU-stack,"",@progbits 
At a guess, it sounds like you're being denied an SSL handshake. I noticed: ssl_ctx = SSL_CTX_new(SSLv23_client_method()); This creates an SSL context that supports SSL versions 2.0 and 3.0, as well as TLS 1.0. If memory serves, OpenSSL will try all three of those in order unless it's explicitly instructed not to. The `SSLv23_clientMethod()` function is also deprecated since OpenSSL 1.0. SSL 2.0 was deprecated more than a decade ago due to some fundamental flaws in the protocol. SSL 3.0 was similarly deprecated several years ago for flaws in the protocol and an outdated cipher suite. As a result, Google does not support them, and hasn't for a while now. TLS 1.0 is also deprecated for similar reasons, and the updated TLS 1.1 and 1.2 are the only versions with cipher suites Google supports on most of their servers. (I recently had a related issue owing to the fact that Google's cipher suites require SHA-1 or SHA-256 HMACs, and will reject anything less secure.) So when you connect with a request for SSL 2.0, the handshake is rejected. Then OpenSSL retries with SSL 3.0, which is rejected. Then with TLS 1.0, which is rejected. Then with TLS 1.1, which probably works. I recommend changing that line to: ssl_ctx = SSL_CTX_new(TLS_client_method()); ... Which will skip trying SSL 2.0. Or, better yet: ssl_ctx = SSL_CTX_new(TLSv1_2_client_method()); ... Which announces to the server that you support TLS 1.2, and should be nearly instantaneous. The reason your browser is so much faster than your code is the fact that your browser is actually caching the cipher suite Google's server is using, and that the server prefers SPDY requests over the usual HTTP.
Hell yeah. When you have to deal with big integers you have to think on the best way to implement it so you don't have difficulties on the rest of the problem. 
This is your second post where you post an image instead of text. Don't do this again please. I'm removing this post, you can retry with code as text.
Thanks for the detailed response. I tested TLS[v1_1]_client_method and TLSv1_2_client_method but neither changed the performance. I did switch to SSLv3_client_method and this reached closer performance ~295ms. re: the SPDY, I recall reading about this, but I think this may have been abandoned. Someone else on stackoverflow was mentioning it could be the experimental QUIC protocol that google uses (can be seen in chrome://flags).
The code looks about right. The breadth first search is really easy, too. I do see a lot of potential to improve your algorithms as to make them faster. Let me see if I can whip up an implementation tomorrow.
I've got the corners database working and I wrote another program that tests it by entering scramble algorithms and then returning the minimum number of moves from the pattern database. I'll upload it to my github and share the link with you when I get it done.
The * binds to the right, so you should put it there. char *s1, *s2.
Here is a link to the project on github: https://github.com/AdamHayse/optimal-solve-rubikscube The pattern database took about 12 minutes to create on a 2.2 GHz laptop. It appears to be working with the testheuristic program. My next step is to create the edge database, but this one is tricky. I need to find a different way to map patterns to locations in memory because I'm only concerned with solving 6 of the 12 edges. It reminds me of the star and bars combinatorics problem. I'm sure it's a very minor change that I need to make in order to get it to work.
I had a little bit of trouble figuring out how to remember depth for the breadth-first search. I found a solution online that involved attacking a value on to the end of the queue to signal a change in depth. Whenever the search comes across that value, it increments the depth and adds another signal value to the end of the queue.
If you think that's large try doing the same in Go or Rust. The result will be megabytes in size.
C is neat and simple to learn and understand. C++ has lots more bells and whistles which can be handy to know but ultimately it's so complex that no human can fully understand the language. Since C is pretty much a subset of C++ I'd suggest that learning C might be a good way to start in any case. You can learn a bit of C and then decide if you want to move on to C++ from there.
With the advent of IoT and embedded C is ever yet stronger than ever. There are just a few PL that can keep up with C in this sector. I would bet that in next 10 years C programmers will still be required and well paid! PS: C++ is too bloated to those markets!
Not a perfect subset, though. If you want a superset of C try Objective-C, a simpler OOP to learn that C++
Maaaan i cant read source code on this mobile app. 0 formatting
Try -s to strip symbols. Reduces executable size IME
Check out Go https://tour.golang.org/welcome/1 It's like a C's younger sibling IMO
If you want speed then choose C. Though C is lower level it can still solve high level problems
Does Objective-C find much use since Swift was released?
It really depends on what you want to do. If you are interested in PC or phone apps and want to write apps then learn java, if you are working in embedded software for microcontrollers then learn C. If you want to write larger programs then on the PC then Python, Java or C++.... chose based on what you want to accomplish. 
I just updated an app I wrote a couple years ago in Obj-C. I make some new classes and felt keeping it all Obj-C just makes it easier. It was a actually quite enjoyable going back to objective-C. Oh yeah and 3 year old code worked fine without changes (which would have been a shit-show if it were written in Swift 1 or whatever).
If you're learning for hobby purposes, then just learn C. Move to C++ if you get bored, or move to Python or build Android apps with Java, etc. I think that C is fun from a hobbyist perspective. If you deal with "business rules" at work all day, it's nice to get into something that is more barebones.
You are not the first to discover this oddity, [Rob Pike on `/bin/true`](https://twitter.com/rob_pike/status/966896123548872705?lang=en): &gt; /bin/true used to be an empty file. The shell would open it, do nothing, and exit with a true status code.
For those who care to look deeper: https://wiki.sei.cmu.edu/confluence/plugins/servlet/mobile?contentId=87151939#content/view/87151939 https://trust-in-soft.com/trap-representations-and-padding-bits/ https://stackoverflow.com/questions/4475540/c-question-padding-bits-in-unsigned-integers-and-bitwise-operations-c89 Page 34 of https://archive.org/details/TheCProgrammingLanguageFirstEdition
With C you usually have to implement a lot yourself, forcing you to learn about how things really work. This could be a good or a bad thing, depending on who you are. C++ is *the* most complex programming language out there, and it is always changing. Things I learned a few years ago are already deprecated. It is not something that I would recommend.
Teensy is in assembly, but it is possible to get much smaller than 9KB in C as well. Switching from glibc to musl would reduce the size to about 5KB, with dietlibc it would be something like 2KB. In a project I'm working on, this compiles down to 700B and the project is still in C, albeit with a non-standard base library. In that 700B executable, stuff like "compiled by GCC" and section names take about twice as much space as the code proper. It's not necessary to load the executable, but common `strip` does not remove it. There's a tool called `sstrip` that does, bringing the size down to about 300B. The minimal bootstrap code for C (fetch `argc`, `argv`, call `main()`, and exit) is actually really small. https://github.com/arsv/minibase/blob/master/lib/arch/x86_64/_start.s However, things like threads support (TLS), dynamic linking, C++ constructors and destructors require init code that's large and difficult to eliminate even if the executable being linked does not need it. So that stuff is generally left in. The program above, linked with musl, will go through TLS init before entering `main()` for instance even though there are no threads in sight.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [arsv/minibase/.../**_start.s** (master → 053ded7)](https://github.com/arsv/minibase/blob/053ded71b4d81c7c2e150099ed7a0eba41a5b361/lib/arch/x86_64/_start.s) ---- 
Looks good. Does anyone know an easy to use http client library? I tried libcurl and it's just so cumbersome to use and terribly documented. I don't want to read source code for even the most trivial tasks. Is there a library that just allows you to call: http_get("https://google.com", result_cb); and be done with it? 
My code works in rounds. In each round, I scan through the pattern database to look for entries whose distance matches the number of the previous round. If I find such an entry, I compute all adjacent configurations and check if any of these have already been filled in (I call this step *expansion*). You can set all bytes in the database to 0xff initially to mark them as not filled in. Any adjacent configuration that is not filled in yet is filled in with the number of the current round. If a round finishes with no entries found, you are done. This algorithm is easy to implement and doesn't need a queue as the queue is implemented through the pattern database. You can also make it parallel easily. Just do the expansion step in parallel, splitting the pattern database into chunks for threads to process. While this does look like a giant race condition, you can show that all the data races are harmless as all writes change unfilled entries to entries filled in with the current round number and all reads don't really need to distinguish these two cases.
&gt; My next step is to create the edge database, but this one is tricky. I need to find a different way to map patterns to locations in memory because I'm only concerned with solving 6 of the 12 edges. It reminds me of the star and bars combinatorics problem. I'm sure it's a very minor change that I need to make in order to get it to work. You can use the algorithm from [my Bachelor thesis](https://opus4.kobv.de/opus4-zib/frontdoor/index/index/docId/6558) for this. You can also use the inversion count algorithm you already use, just make sure to only count the inversion numbers of the six edges, disregarding the others.
What "good" things do you associate with C++ precisely? Also I would very much like to contest that "C is too old". C is a simple structured programming language and it's basically the backbone of most code. It will at least prevail as glue code for decades, ie. for other languages to interface each other. With C you learn memory and basics of low-level programming, which are helpful in any language. You will always need the principles in C. C++ OTOH, despite being multi-paradigm, it does nothing as good as it does OOP. And OOP is actually declining a bit, only some ideas about the syntax sugar are prevailing (and of course it has nested in the business and will stay there for long too). But simple structured programming doesn't die that easily, because it's not so idiomatic. I wouldn't consider C++ modern actually. It does implement some modern concepts, but the language itself feels like an old dinosaur, like a Frankenstein. Also, "starting" with C++ won't do good. It is the defacto most complex language and your code will be bad. Most C++ code is bad. There's also quite some bad C, but it's easier to spot, easier to fix and also easier to write correct code.
Store your string in a pointer *str. Pass this pointer to your function isPalindrome, do the necessary computation and return 1 or 0 as needed. Also, please don't use gets. Use scanf("%[^n]s",str) instead to get the whole line.
might be worth testing with this ?? http://www.libressl.org/ there might be some difference with behaviour that could give you a clue...
libcurl? You probably could just wrap this into a function CURL *curl = curl_easy_init(); if(curl) { CURLcode res; curl_easy_setopt(curl, CURLOPT_URL, "http://example.com"); res = curl_easy_perform(curl); curl_easy_cleanup(curl); } https://curl.haxx.se/libcurl/c/curl_easy_perform.html 
Thanks
Might be something at https://github.com/nothings/single_file_libs/blob/master/README.md#network to suit your needs. Been a while since I looked at any of it.
I am mostly a hobbyist too--like you I taught myself BASIC as a kid (for me it was a VIC-20). Then at about 20 I randomly spent a summer writing embedded assembly (also self-taught) for an engineering start-up owned by a family friend. These days programming is occasionally useful for my research, meaning I write 2-3 programs a year, about half for work, and half for fun. Colleagues tell me it would be easier for me to learn a modern language, but I find C incredibly fun, and the fact it is bare bones only makes it more appealing. Also the fact it is essentially unchanging is a point in its favour--you don't have to feel like you have to stay on top of an ever-evolving set of libraries etc., which would be difficult if it's not your main pursuit in life. And I just like that the language and its constructs aren't trying to figure out what you want and implementing it for you--you figure it out yourself and tell the computer how to do it, and that's the fun part. For one particular combinatorics-type application, a colleague told me he could reproduce my program of several hundred lines of C in a few dozen lines of python (using a library). He was right, but my program ran thousands of times faster than his on small input, and his didn't run at all on long input that my program handled just fine. Bottom line, if you like the feeling of completely understanding what you are doing, then go with C.
Flush should be \n Use pastebin next time
I didn't know that there was a name for that, but I should have guessed. I just wrote a small case with 4 elements and found an expression that represented the indices. I was originally thinking of using the Johnson-Trotter algorithm to generate a permutation, but I couldn't think of a way to map permutations to the natural numbers (though something like that probably exists somewhere). I switched to lexicographic permute almost instantly after turning the page in my algorithms book.
&gt; but I couldn't think of a way to map permutations to the natural numbers (though something like that probably exists somewhere). As I said before, I have an entire chapter in my bachelor thesis about this topic. I already linked the thesis before. &gt; I switched to lexicographic permute almost instantly after turning the page in my algorithms book. Not necessarily the fastest choice; see my [micro benchmark](https://github.com/fuzxxl/permcode) for some implementation ideas.
I did initialize my database array to all 1s. It's cool that I got that right. Although, a conditional in my code tests for 15 instead of 0xF. I should probably stay more consistant. Hexadecimal shows that I'm more concerned with the bit representation than the value of the bit representation. Expanding nodes from entries in the database is a great idea. I thought about finding a way to do it without a queue, but I didn't give it too much thought. I would need to work backwards, look at the offset in the array and find the combination from it. This seems like it would be hard though. The last corner in the combination is determined by the others. This means that a given location in memory would map to multiple combinations, but only one combination would be valid. The state space is a disconnected graph with 12 disjointed sections. I've never taken a class in parallel processing. I know some of the basic terminology. I vaguely know how to do it in Java, but I've never done it in C. It seems obvious to me that there wouldn't be a race condition, but I think this might be because I've looked at this problem for so long. Unless I'm misunderstanding something.
&gt; I would need to work backwards, look at the offset in the array and find the combination from it. This seems like it would be hard though. It's pretty easy to do that. Both my bachelor thesis and the github link I gave you contain a bunch of implementatios. &gt; The last corner in the combination is determined by the others. This means that a given location in memory would map to multiple combinations, but only one combination would be valid. The state space is a disconnected graph with 12 disjointed sections. You have to compute the orientation of the final corner from the orientation of the other corners. This might be a bit tricky to do, but doing it makes you understand the problem more, which is always a good thing. &gt; I've never taken a class in parallel processing. I know some of the basic terminology. I vaguely know how to do it in Java, but I've never done it in C. You could use OpenMP for that. It's pretty easy: Just stick `#pragma openmp parallel for` in front of loops that are supposed to run in parallel. Read the manual for details. &gt; It seems obvious to me that there wouldn't be a race condition, but I think this might be because I've looked at this problem for so long. Unless I'm misunderstanding something. The race condition is that you are reading entries from the array while another thread is writing to the same array, making it unpredictable whether you get the old or the new value of the array entry. Doesn't matter in this case though.
Actually, there would be a race condition with the way I implemented it. I put two path costs per byte. index = C_get_index(queue[(head+queuesize)%Q_BUF_SIZE]); add = index / 2; pos = index % 2; When pos = 0, path length is stored in the left 4 bits of the byte. When it is 1, path length is stored in the right 4 bits of the byte. 
You can use C11 atomic variables to solve this one: Just and with a bitmask to turn 0xf into the desired value.
[urllib](https://docs.python.org/3.1/howto/urllib2.html) is pretty straightforward.
C++ is off topic in this subreddit. Please post C++ questions elsewhere, e.g. in /r/cpp_questions.
&gt; What are the reasons behind this? It is not optimized because this is not a use case worth optimizing. https://blogs.msdn.microsoft.com/ericgu/2004/01/12/minus-100-points/
I'm with zsaleeba on this. While you *can* make use of all the C++ bells and whistles, and effectively turn it into a whole new language, you don't *have* to. I've been programming C++ professionally on and off for over a decade, and C for twice as long. From where I sit, C++ is just C with more features.
(Assuming your on Linux) You may want to look into ncurses for the semi graphics thing like when you use WiFi-menu of make menuconfig
&gt; storeArray[X_arbitrary][Y_arbitrary] = (int*)charStr[charPosition]; &gt; //converts current character in charStr to integer &amp; stores it into a position in storeArray[][] This part is wrong. It does not convert the character character to an integer. It converts the current character to a pointer (you know because there's a \* there). I don't understand why you're using pointers at all. `storeArray`, for instance, is *not* a 2D array of integers. It's a 2D array of pointers. Why are you making an array of pointers?
First off, thanks for the reply! From how I understand it, pointers are used to allow its values to be changed dynamically, while normal objects are static. Please do correct me if I'm wrong; I'm trying to get a grasp around such topics.
Might be fun to work on some embedded stuff. There's a wifi+cpu device you can program in C - esp8266. It's got several SDKs (mostly FreeRTOS based) for it and you can have concurrent tasks running on it. Lot's of fun - I built a garage opener - the little device runs a http &amp; websocket server and has a nice html webpage with a button to open and close the garage door and realtime indication of what the gate is doing - going up or down. The esp8266 costs like 3$ from aliexpress. Then there's esp32 - adds bluetooth, more power, IOs and other stuff. You can also run micropython, and there are a couple of javascript, Lua interpreter OSes for these things. Can also build some RSS feed/tweet display....lot's of applications. Can also IOTify old appliences, etc. 
+1. esp32 since it usually has usb programmer and very comprehensive sdk.
 #include &lt;stdlib.h&gt; system("/usr/bin/curl https://www.google.com -o output.txt"); xD
Try [this](http://beej.us/guide/bgnet/) guide to internet sockets. Really awesome and you can do a lot with it. 
math.h already defines a macro giving the value of pi.
Even the trusty old Arduino can be a tonne of fun if you don't need WiFi. You can buy some pretty well-stocked starters kits (LEDs, 7-segment displays, grid displays, microphones, speakers, all sorts of sensors, etc.) for like $20 or $30. It's surprisingly fun trying everything out.
I've always wanted to try embedded, but I never have a clue where to start. 
Sorry for lazy answer, but one example can be when working with alot of data (long arrays/str/whatevet), instead of passing the whole variable by value (you pass the whole array for indtance), making your programme use more RAM because the whole value is pushed in the stack-frame. If you instead pass the pointer, you are only pushing the size of a pointer to stack, thus saving ram. Also if you are going to use heap, you need to have a pointer to know where the memory is, since the exact adress may change during runtime due to different reasons. Someone please correct me if Im wrong.
All variables store values of a particular type. int variables store integers, char variables store characters, etc.. When you declare a variable the compiler finds a a place in memory (address) to store the value you assign to the variable (1 byte for char, 4 or 8 bytes for int, etc..) A pointer is just a variable that stores the address of a memory location as it value (further defined by what type of value will be stored at that memory address.) You can point your pointer at the memory address of an existing variable or you can use a memory allocator like malloc you ask the compiler to reserve a block of memory for you. Why use pointers is too long to go into here. Take a step back and understand C's memory model thoroughly. Here’s an excellent tutorial - http://home.netcom.com/~tjensen/ptr/cpoint.htm
[removed]
&gt;I lack the knowledge to do actual cool things. You only get knowledge through experience. Pick a problem you want solved and solve it through programming. &gt;I want to do something cool, as the simple pocket calculators start to get boring. Programming is rarely glamorous. There tends to be a lot of boring details that need to be worked out before the 'cool stuff' happens. You'll need solid 'boring' skills to get anywhere. Just keep coding.
&gt;Programming is rarely glamorous. There tends to be a lot of boring details that need to be worked out before the 'cool stuff' happens. You'll need solid 'boring' skills to get anywhere. Just keep coding. The problem with this statement of you is that I didn't have that feeling when I started Web Development. With HTML, CSS and JS everything gets shiny and colorful immediately and programming there feels more like playing a game. In C you have to do so much more!
If you want to do something cool, and don't mind falling down a *very deep rabbit-hole*, game development is a very rewarding choice. Using a library like SDL or GLFW, you can easily set up a rendering context for OpenGL. From there, you can use libraries like libpng (image loading), libvorbis (audio loading/streaming), and OpenAL (audio playback) to build your own games from scratch. If you're on Linux and you're feeling extra saucy, you can them learn Vala (GNOME-developed OO language that converts directly to GObject C) and GTK3 (GNOME's UI toolkit library), and utilize the GTKGLArea class to embed your game directly inside of a desktop UI. Using this, you can build your own editor/tools pipeline. It's good stuff! Anyway, All that I've described here is a pretty huge commitment (years, not months). It's a really fun and rewarding pastime though, so don't be put off if it sounds fun to you! I'd be happy to answer questions and point you to learning resources for starting out.
Try contributing to an open source project, go thru the bug list and see if you can first reproduce the bug and then see if you can fix it. Whether your contribution gets approved or rejected you've learned something.
You should check if the user supplied enough command line arguments before accessing `argv[2]`. You can check `argc` for this purpose.
Here's one example. Lets say I have two variables, X and Y, set to 10 and 11 respectively. And a function some_operation(). I want the function to change the value of x and y. How can I do this? I could define the function like so: void some_operation(int a, int b); ...and call it with... some_operation(x, y); BUT that would only pass the values - 10 and 11 - the function would have no way to change the variable. If there were only one variable to change I might just return the new value and let the caller assign it to the variable, like so... x = some_operation(x); HOWEVER, it's only possible to return one value at a time. So what to do? If you instead set the function up to take POINTERS, then it knows where in memory the values are stored and can change them there. For example: void some_operation(int *a, int *b) { *a++; /*add one to the value stored at address "a"*/ *b++; /*add one to the value stored at address "b"*/ } int main() { int a = 10; int b = 11; some_function(&amp;a, &amp;b); /*the "&amp;" tells c to pass the ADDRESS of the variable, instead of its value - WHERE it is, instead of WHAT it contains*/ /*a is now 11, b is now 12*/ } I find it helps to forget programing concepts when dealing with pointers and just think of the physical computer - RAM + CPU.
the same result occurs when adding an additional check like you suggested. if(argc == 2) { if(strcmp(argv[2], "detailed") == 0) foo(); else bar();
If argc == 2, you only have argv[0] and argv[1] available...
Remember that arrays in C, and most other languages, are 0 indexed. This means that the first element is at index 0. You are checking for “detailed” at index 2 i.e. the 3rd element in the array after you have checked that argc is equal to 2 i.e there are exactly 2 elements in the argv. Array; this is what is causing your program to segfault. Note that the name of the executed program will be contained in the argv array, e.g. ./myprog arg1 arg2 would result in argc == 3 and argv == [“./myprog”, “arg1”, “arg2”]. 
I'd get a mega2560 board from aliexpress (cheap). There's the avr-gcc (C11 compiler, linker, all that) and avrdude (flasher). Also some display that you could hook up to it ("spi display" on aliexpress). Then just think of some task, like implementing a menu, graphics library. Or just get the aforementioned ESP chip and make some wifi controlled light switch
What would you say you need to know?
Well if one wants to get into embedded development it helps to already know C and some electrical basics. I'm not a pro in either
This sub is for C, not C++. Remember to properly format the code when you post it in a more appropriate sub by putting 4 spaces in front of every line of code.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
I know some C, I thought it was also important to know OS/device driver programming. I don't know much electrical, really want to work on that. Thanks
thank you. i always get confused with the array assignments. like, i get they begin at zero, but when i go to index into array i still think that it starts at 0, meaning that argv[2] would include 0, 1, 2. 
`(c == ' ') &amp;&amp;` is unnecessary since `c` has to be a space there. While you could argue that the code is slightly easier to understand, I think comments would be better if (c != ' '){ /* not a space. end the run of spaces */ blanks = FALSE; putchar(c); } else if (blanks == FALSE){ /* first space in a run. print it but suppress the rest */ blanks = TRUE; putchar(c); } 
You may want to include a short description of the exercise for those who don't have the book. I'm guessing the exercise is to "convert" many spaces into just one space. The condition in the second if statement can be simplified. Can you figure it out? (Edit: Ninja'd)
Thanks!
Thank you for the comment. In future I will add a short description to any postings. And thank you for the tip about the second statement.
thank you for the tip
Unnecessary is not wrong! 
Howdy! I'm just going to throw some things out for your consideration. A lot of this is personal preference, but some of it is pretty standard. Your code is pretty clean, and properly spaced, but there are a few things I would change. `int main(void)` is how I tend to label main functions that take no arguments. I find it a little odd that you don't at least have `int` prefacing yours. Moreover, `main()` should always return an integer; the most common way to do this is to place `return 0;` at the end of the function. `0` is used to denote a successful exit and is synonymous with the `EXIT_SUCCESS` macro. There's nothing wrong with the `#define`s you use for `TRUE` and `FALSE`, but if you're using the C99 standard or above it may be worthwhile to `#include &lt;stdbool.h&gt;`. Personally, I tend to evaluate `1` and `0` without comparison, but your mileage may vary. Your `if` on line 19 starts with a redundant check for `c == ' '` since the `else` can only trigger if `c == ' '`. Moreover, you can consolidate lines 19 and 18 into a single `else if (blanks == FALSE){`. You may also want to consider how you can incorporate other whitespace characters into your check like `'\n'` or similar. Overall this is a solid start, and you've done a great job. Hope this helps! Feel free to come back for advice or answers anytime.
I highly recommend learning gdb along with C. It is a debugger that will attach itself to your program and allow you to see things like the lines you are executing and view/set the values of variables (this is just the tip of the iceberg too!!). Imo you dont truly know C if you dont know how to use gdb
&gt; Beginning Linux Programming [This one?](http://www.wrox.com/WileyCDA/WroxTitle/Beginning-Linux-Programming-4th-Edition.productCd-0470147628.html)
&gt; but to make the code tighter I would've gone with something like this instead #include &lt;stdio.h&gt; int main() { int c, prev = 'a'; while ((c = getchar()) != EOF) { if (prev != ' ' || c != ' ') { putchar(c); } prev = c; } return 0; } It makes it a bit more clear that the goal is to not repeat spaces, imo. Plus you don't have to "repeat" code (`putchar` and the `blanks` assignment)
You're probably right about the code being tighter, however I'm trying to use only information that the book has provided up to the where the question is. For example, I had used an IF/ELSE statement in my code. I just realized that the ELSE explanation comes AFTER this question. I have just amended my code to remove the ELSE expression and keep in line solely with what the book has taught up to the question.
argv[2] does include 0, 1, 2, however in this case argc would be 3 not 2, so you need to check that argc is 3, not 2.
The restrict keyword is for when you have two pointers of the same type, which are allowed to alias each other. void func(int *a, int *b) /* a and b can point at the same memory) void func(int * restrict a, int * restrict b) /* I promise a and b do not point at the same memory */ 
Your homework is over and maybe you already get it, but I will annotate the function in case that is helpful to you. There is literally a whole o'reily book on pointers http://shop.oreilly.com/product/0636920028000.do which is a decent read if you would like to go deeper. The main concept that this function shows is pointer arithmetic which takes advantage of the fact that for pointers to arrays you may use simple math to move pointers to the next or previous element. It is important to really understand what is happening here if you want to understand how C deals with memory. ```C // The Function takes two C strings represented by pointers to the first character of an array of characters with a \0 character at the end. int mystery( const char *s1, const char *s2 ) { // This loop terminates if either the pointer points to a the null char. It moves the pointer one char further with each iteration (this is pointer arithmetic). for( ; *s1 != '\0' &amp;&amp; *s2 != '\0'; s1++, s2++ ) { // if the two chars are not equal, the loop is short-circuited and the function returns 0; if( *s1 != *s2 ) { return 0; } } // In all other cases it returns 1. Since the for loop ends if either string ends in the comparison it means the function checks if one string is the prefix of another. return 1; } ```
Hi, This maybe isn't really in the scope of what you're doing but I'd suggest checking out [getopt and getopt_long](https://linux.die.net/man/3/getopt)
I figured as much. However, given this function, what benefit does strict aliasing give you over simply explicitly denoting pointers as being restricted? For instance, for the following function: void f(int * pi, float * pf) { /* code */ } By the strict aliasing rule, it appears to me as if we had declared the function as void f(int * restrict pi, float * restrict pf) { /* code */ } as we assume that pointers of different types can't alias each other (save for pointers to char). If the restrict designation makes the same optimizations possible, what then is the purpose of strict aliasing?
Yes, in that case the `restrict` keyword is unnecessary. The strict aliasing rule means that the compiler can assume operations on pi will not affect operations on pf. If both pointers were `int *` then the compiler is not allowed to assume that operations one will affect operations on the other. If both pointers are `int * restrict` then the compiler is again allowed to assume operations are independent.
If that is the case, and we can achieve the same end by using restrict, then what purpose does strict aliasing itself have? It seems like any desired behaviour that is a result of strict aliasing can be accomplished through appropriate usage of restrict. I apologize if I'm asking questions left and right, and that most of them are likely to only yield opinionated answers, or that they may necessarily tie into historical reasons for why the standard is the way it it now. My curiosity comes from the fact that I had actually learned about strict aliasing well beyond my first dabbling in C years ago. In fact, even in my college systems programming class, it was never mentioned, and often I wrote code for said class (and saw teachers write code) which violated strict aliasing, and, to my understanding, invoked undefined behaviour. That being said, I'm now trying to understand why the standard is the way it is (if there's any reason to be found), and, furthermore, how people are able to generally get away with invoking such undefined behaviour, apparently without consequence.
I don't know the history. My guess is that the compiler writers went to the committee and said "if you make strict aliasing the default then we can make a large number of programs faster and it'll unfortunately break a small number of programs and the owners can fix them". Which is [arguably] better than introducing just the `restrict` keyword and relying on it being added everywhere that performance gains are needed.
You could start with some of the free online resources. For example: [NCURSES-Programming-HOWTO](http://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/). The best *book*, otoh, is probably [Gookin's](http://www.c-for-dummies.com/ncurses/).
1. If violating the rule were not UB, then the compiler would not actually be able to perform any optimization, i.e. the rule might as well not exist. 2. Many people learn C by trying something in their compiler and then they assume that if something seems to work then they did it right. It's less common for people to refer to the C Standard and there are not many reference materials that cover strict aliasing properly. 2a. "work as expected" is a possible manifestation of UB. 3. `restrict` allows you to say that the objected pointed to by a particular pointer will not be aliased by anything else in the current block. This is particularly different from the strict aliasing rule because it applies to expressions of all types (usually, the same type) 4. Footnotes are non-normative. 5. Union aliasing is permitted in C, so long as you access the members by name. (It's still UB to do `foo(&amp;u.a_float, &amp;u.a_int);` where `foo` commits an aliasing violation). In C11 and they clarified that it was always intended to be permitted, just the language was sloppy in earlier standards. 
I can see the logic in that, and imagine that the scenario you suggested could be accurate. Still, though, I'm curious as to why code that I have written fairly recently, across a variety of compilers and computer architectures, had behaved as I expected it to, even though, as I recently discovered, I have been breaking the strict aliasing rule left and right, without requesting explicitly that the compiler disregard strict aliasing through an appropriate compiler flag. I'm further confused by the matter, as my research into safe methods for type punning have yielded mixed results, with some people claiming that it is safe to use unions for such matters, and others saying that using unions to in such a manner is still undefined behaviour.
`restrict` was added in C99 whereas strict aliasing has been there since C89. Also, most people don't use `restrict`. 99% of the time you do want the strict aliasing rule to be "on"; having it off by default would result in degraded code performance. 
Thank you very much for taking the time to address each point. Your feedback is very much appreciated. I take it that this sloppiness in the earlier standards is likely the reason for why I have up until now seen conflicting explanations of the matter posted to various forums. If you wouldn't mind if that I ask yet another question, I'm curious to know whether or not the mnemonic for reinterpreting the bits of a value is UB or not, as is done in the inverse square root algorithm. For instance, would the following constitute an illegal alias, given that TYPE is not compatible with VAR's declared type? I had listed it above in the original post as an example of breaking strict aliasing, but now I am having doubts as to whether or not this would necessarily apply (since the alias itself is never used as an lvalue). X_TYPE X; Y_TYPE Y; /* ... */ Y = * (Y_TYPE*) &amp;X;
Is there an all-in-one PDF or zipped html archive version of the first link?
Your code is a strict aliasing violation if `Y_TYPE` is not permitted to alias `X_TYPE` as set out in the rule. The expression `* (Y_TYPE*) &amp;X` is an lvalue which is read through, and so (assuming `Y_TYPE` is not a character type) it must designate an object of `Y_TYPE` or the close permitted variants. 
Tldp used to, but it was always a PITA to find. Google the title and ".pdf"
If there is one must be paid!
Yes. I had an earlier edition but a lot of it seems to hold up. 
For the next time: If you want to post a link to your project, please post a link instead of a self-post.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [tcowley/ncurses-programming-howto/.../**a4c5beb36b251db381f6fcebe7f28965994b2bdf** (gh-pages → a4c5beb)](https://github.com/tcowley/ncurses-programming-howto/tree/a4c5beb36b251db381f6fcebe7f28965994b2bdf) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dvnzxet.)
I just saw python which already has wrappers to do just that. 
If you can figure out how to calculate an average, getting the standard deviation and min/max values is certainly within your ability.
It helps to think about how it will be printed in the terminal...top down as it were. If I remember correctly I did this with nested loops. Use a variable to track the highest frequency of word length and use that for the top row which will be printed first. Use a loop to count down the rows, highest frequency to lowest, while using the nested loop to count across the columns, smallest word length to largest (or just 1 -20 sequentially and last column for 20+). Then all you have to do is test weather the current column (word length) of the current row (frequency) is &gt;= the row you are on (weather or not words of length x exist for that frequency) and print whatever symbol you want to use if the test is true. Of course, this won't give you graph labels or anything but you can play around with it to make it print as nicely as you want, just offset rows and columns for any extra things you add to make it look nice.
You’d need to either - create a new system call, - extend an existing system call (e.g., implement an `ioctl` or go through `read`/`write` via memory buffers), or - map one or more pages directly into userspace that gives somewhat direct access to the bools, and provide something that lets the userspace program map/unmap and relocate the mapping. Typically, unless there’s a very good reason to do otherwise, you want to make use of an existing system call. If we’re talking Linux, you can implement a char or block device, or you can tie into /sys or /proc.
any declarations that need to be used by .c files other than the one that matches that .h.
&gt; DON’T include any executable lines of code in a header file, including variable declarations. Can anyone shed some light on why this "rule" exists? I have a project where my header files contain the full function definitions and so far nothing broke.
That advice was before inline functions, but inline functions are pretty uncommon. Basically, you have 3 possibilities: 1. You're writing an inline function. Cool! Putting it in a .h file makes sense. 1. You're including this (non-inline) function definition in more than one .c file. Things will break. 1. You're not including this (non-inline) function definition in more than one .c file. There is no use case that could possibly make more sense than just putting the function definition in the .c file where it's used.
I think I'm safe then. I'm doing a "unity" build with two compilation units, each in a single C file.
Well this subreddit is for C.... But did you bother to check out Microsoft’s website? https://msdn.microsoft.com/en-us/library/windows/desktop/dd743789(v=vs.85).aspx
Sure here you go: 
C++ is off topic in this subreddit, please post C++ questions to /r/cpp_questions.
Eh, it's a bit too rigid in a couple cases. &gt; DON’T include any executable lines of code in a header file, including &gt; variable declarations. Disagree. Static (e.g. no external linkage) functions intended to be inlined belong in the header file. It's like poor man's LTO and works really well. This technique is used all over the place in the Linux kernel. &gt; DON’T expose any variable in a header file, as is too often done by &gt; way of the ‘extern’ keyword. Too rigid. Sure, this sort of thing is a sign that there may be something wrong with your code, and that's pretty much always the case for beginners, but it has its uses. For example, [`jiffies` in the Linux kernel](https://elixir.bootlin.com/linux/v4.2/source/include/linux/jiffies.h) is a global variable that holds the number of "ticks" since system startup. This is global in nature. If you're accessing this kind of variable, you don't want to go through a function just for the sake of a purist encapsulation goal. Another example is constant, static, composite data: extern const struct entry default_entries[]; (While this is technically not "variable," the author probably intended the rule to cover even this case.) 
I'm led to agree with you, a bit rigid at times. It seems like the author's trying to enforce some degree of object orientation in C as his encapsulation model, which can vary your mileage. Tha
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [AdamHayse/optimal-solve-rubikscube/.../**edgesDB.c** (master → 7c7aae1)](https://github.com/AdamHayse/optimal-solve-rubikscube/blob/7c7aae116c842c8ddcc1e15d95f0b5dbf8f7fb7f/edgesDB.c) ---- 
I'm sorry that you had trouble following my Bachelor thesis. If you have any questions, feel free to ask. It is a bit terse, mainly because I wanted to save my professor from having to read more than that. &gt; How do you verify that your pattern database is entirely valid? Trial and error? Section 4.3 of my thesis deals with this question. The basic idea is to verify the following properties: 1. The PDB entry corresponding to the solved configuration has value 0 2. For each PDB entry *v*, all entries *w* reachable from *v* within one move must have a value that is either one less, equal, or one higher than the value of *v* 3. For each PDB entry *v*, there must be at least one entry *w* reachable from *v* within one move such that the value of *w* is one less than the value of *v*. Lemma 4.3.1 shows that checking these three properties is sufficient to check if the entire pattern database was generated correctly. &gt; Also, I made use of some preprocessor directives to change between generating the 1st edge database and the 2nd edge database, but the code is probably bad technique. The preprocessor directive looks corrent. I would have just used function pointers instead, so you don't have to recompile the code for changing the generated pattern database. &gt; This is the 2nd somewhat large project I've done, so I don't have a good sense of proper programming conventions and practices. The first one I did was generating the AES S-box using finite field arithmetic and then performing a linear cryptanalysis on it compared to a random S-box. That was a fun project. Here's a picture from it: ... Looks fun!
I think that people who design linux kernel code do no need to read this article, they already know what he is talking about and when to follow or break these rules. For the rest of the more common/smaller c projects I really agree with these points. I think they should be followed unless one "REALLY KNOWS TM" what he is doing.
Have you tried to fix the errors the compiler reports? Also, what is your exact question? In the `create_QNode` function: Node* tmp = (Node*) malloc(sizeof(Node)); Why do you cast? There is no need to cast in C. QNode create_QNode(void* data) { // ... return tmp; } With `QNode` I'm assuming you actually mean `struct QNode` (which is different than `QNode`). `tmp` is a `Node*`, but the function returns a `QNode`. In the `que_create` function: struct queueStruct* tmp = (queueADT) malloc(sizeof(struct queueStruct)); tmp-&gt;nodes = (QNode) malloc(tmp-&gt;size * sizeof(QNode)); See above about the casting. (`QueueADT` is typedefed to a `struct queueStruct*`. OP got also the type wrong) In the second statement, you're allocating a array of `QNode`, with `malloc` returning a pointer to the allocated memory. However, you cast it to `QNode`, which isn't even defined anywhere. I'm assuming you mean `struct QNode`, but it is still *not* a pointer. Also, in the second statement, you currently just allocates a array of nodes and tries to put it into a `QueueADT` in the `nodes` member. However, that member is a `Node**`, not `Node*`, so it (probably) expects a array of pointers pointing to an node. Like: (→ = points to) tmp-&gt;nodes → ptr[0] → node0 ptr[1] → node1 ptr[2] → node2 ... ptr[n - 1] → node(n-1) tmp-&gt;nodes[2]-&gt;data // returns the data in node2 So you should allocate an array of pointers to nodes and initialize them.
From the documentation for os_sys_init: "The RTX kernel gives the task a default priority of 1." You need to use os_tsk_prio_self in tasks_setup to raise its priority above the other threads it's creating so it's not immediately interrupted for them. As it is, it creates task1 and since 50 &gt; 1 the OS immediately switches to task1. 
Thanks! It worked. I thought that it started right away with tasks_setup (because of the os_sys_init), completed it and then started with task1 and that the priorities mattered from that point on.
What's the point of this, exactly? Is this a school project? If so, it sounds like you need to get some clarification of what they expect you to do. In a class that deals with the Linux kernel directly, I would expect that you probably *do* have to recompile the kernel. Adding a new syscall is a fun and informative project, since it teaches you the internals of how syscalls actually work. If this is for something else (hobby or work), then what purpose does it serve? There are already quite a few ways to read the keyboard, such as raw TTYs, Curses, [evdev](https://en.wikipedia.org/wiki/Evdev) which you just mentioned, or any of a number of wrappers like [SDL](https://wiki.libsdl.org/SDL_KeyboardEvent). Why reinvent the wheel for the hundredth time? The interface you propose doesn't even seem very robust, since it's not obvious how it would deal with different keyboard layouts. Unless this is just for your own self-education as a hobby or experiment, there are probably better ways to do whatever it is you're trying to do.
**Evdev** evdev (short for 'event device') is a generic input event interface in the Linux kernel. It generalizes raw input events from device drivers and makes them available through character devices in the /dev/input/ directory. The user-space library for the Linux kernel component evdev is called libevdev. Libevdev abstracts the evdev ioctls through type-safe interfaces and provides functions to change the appearance of the device. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
It's not a school project or a thing for a job, just for me to challenge myself. The reason that i don't want it to be a new syscall is I want it to work on any system without too much work, and recompiling the kernel is a fair amount of work. &gt;why reinvent the wheel for the hundredth time? for fun and to learn. I'm very much aware of all of those libraries and their capabilities but I've been wanting to mess around with kernel modules for a while, yesterday I was looking for ways to grab the current key state of any key without too much hassle and I found that linux doesn't give a very straight forward way of doing this but instead other libraries provide that functionality for it so I saw it as an excuse to jump into kernel modules.
** Update March 14, 2018 ** Was able to turn the pyramid right-side up. Sometimes starring at code for an hour straight and taking a nights rest works wonders. http://codepad.org/OJmQaTiT
&gt; But if we were to just type test, what would we get? You'd get the struct. For example void func(temp param) { printf("param.x = %d\n",param.x); } int main() { temp test = {1,2,3,4,5,6}; func(test); // pass [copy of] test to the function } 
When you declare a structure, you are telling the compiler: yo, please store the variables a,b,c,x,y,z in continuous block of memory. If you have a variable t of type struct, then semantically, it refers to the whole group of variables at once. The compiler is going to get upset if you have a statement like t++; The value of &amp;t is equal to the value of &amp;t.a i.e the address of the structure is equal to the address of the first member.
Very simple example that illustrates the point, really nice answer! One thing I'd like to add for completeness, even though it is implied, is that in such a case, the struct is passed by VALUE. This means, that the struct seen inside the function is a copy of the original, and any changes made to it will not be visible in main. 
Always consider the edge cases. For example, what if the list is empty? What if the value you're looking for doesn't exist? What if there's two nodes with the same value?
More interesting stuff about [struct](http://www.catb.org/esr/structure-packing/).
I know but c has more subs More subs = more replies
Use an array to store word length frequency, then use a loop to iterate over the array. If the frequency is the equal to or greater than the current column print a '*'. When you get to the end of the array, print a '\n'. You can keep track of the largest word length frequency and the longest word to help with scaling the graph.
That sounds like a proof by induction like I did in discrete math. I did figure out what the problem was. My address 0 wasn't the solved state. I need to either initialize at the solved state's computed index or change the way I compute the index. The first is easier, but the second seems more appropriate. The second one also requires some additional processing for computing the index though. Are you in grad school for your Master's or a PhD? I want to go to grad school too eventually to get my PhD in computer science. I planned on working for a few years since I'm still somewhat new to computer science; I've only been doing it for 2.5 years. I was doing mechanical engineering before that, and I had no exposure to computer science as a kid unfortunately. I don't much regret getting into computer science late though because I think that I've sufficiently trained my mind in problem solving. Now all I need to do is get the knowledge into my head to do the problem solving with. It's also easier for white Americans to get into a PhD program in the US because they are a minority in academia. How are you liking grad school so far?
I think I understand now. So then if i write this: while ( indirect &amp;&amp; indirect != ptr) then I'm checking if `indirect` is a pointer to `NULL` and also whether `indirect` and `ptr` are pointing to the same thing (if these happen then the loop isn't executed). &gt; Which brings up another edge case: removing the only thing in the list. When you're done, the head should point to NULL, because now it's empty. I'm thinking this: int removeEntry(struct entry *ptr) { struct entry *indirect = listHead_ptr; int counter = 0; int value; while (indirect) indirect = indirect-&gt;next; counter++; while (indirect &amp;&amp; indirect != ptr){ indirect = indirect-&gt;next; } value = indirect-&gt;value; indirect = ptr-&gt;next; if (counter == 1) listHead_ptr = NULL; return value; } I added `counter`, a variable that counts the number of nodes in the linked list, an if statement that executes only if there is one list node (which instructs `listHead_ptr` to be a `NULL` pointer), and I modified the function itself (adding also the variable `value`) so that the entry that was removed is returned. I have some doubts regarding the two `while` loops, is there a way I can write only one loop and have it function as both of the ones I wrote?
So, just to get this straight, in a linked list of structs, I'd set the pointer (`struct*`) with `t.next = &amp;t2` instead of `t.next = t2` (where t and t2 are variables of type `struct`, each with an element of type `struct*` and some miscellaneous payload).
&gt; I have some doubts regarding the two while loops, is there a way I can write only one loop and have it function as both of the ones I wrote? Yes! You actually don't even want the `counter` variable at all. If we're removing the last item, then that item must be the head. So we can just do the check: if ( listHead_ptr == ptr ) Just for reference, here's one way you could have written that function: void removeEntry2(struct entry *ptr) { struct entry *p = listHead_ptr; // handle removing the head if ( listHead_ptr == ptr ) { listHead_ptr = listHead_ptr-&gt;next; return; } // Look for the node that points to the one we want to remove while ( p &amp;&amp; p-&gt;next != ptr ) p = p-&gt;next; // If we didn't find it if ( !p ) return; // Remove the node p-&gt;next = ptr-&gt;next; } But here's the key: did you see how we had to handle removing the head? That should tell you something: we didn't do what Torvalds suggested in his code! The way he wrote the code should have already accounted for that! Here's my version of his code: void removeEntry(struct entry *ptr) { struct entry **indirect = &amp;listHead_ptr; // Look for the node to remove while (*indirect &amp;&amp; *indirect != ptr) indirect = &amp;(*indirect)-&gt;next; // Remove it if we found it if ( *indirect ) *indirect = ptr-&gt;next; } This is the exact same as what he proposed, except I've added the extra checks to make sure it exists in the list. His version wasn't really pseudocode, he just left off the types, and that double pointer is the key to the whole thing. A bit of caution, though: is Torvald's method any faster, or does it just look cleaner? We can't be sure without actually running some benchmarks to see. But I think it's interesting to look at the [compiled output](https://godbolt.org/g/S4138m). In the case that we're removing the head, my method does three moves, a compare and two jumps. His version adds an extra move on top of that. For all other nodes, his method has an extra add instruction than mine. They have the same innermost loop. So my version wins by a hair, but not enough to matter in the end.
Right! Thanks for the answers! However, since I have not learned about double pointers, I must ask. What are they and what's the advantage of using them (in certain situations) over pointers? Would that double pointer in your code, for instance, be correctly defined as a pointer to a pointer to a `struct entry`? I'm starting to feel unsure as if the book I'm reading to learn C is good enough; after all, I am constantly having to post on the sub. What's your opinion of Kochan's "Programming in C"? How did you learn? How can I have as much knowledge as you? Also, what do you think would be a good project for a beginner like me? I was thinking of creating my own text editor after I finished the book (I'm reading it whilst doing CS50x, if you've heard of it), but I don't know how hard that might be for someone like me Btw, that website you linked at? Bookmarked. Wow. Thanks. 
&gt; Right! Thanks for the answers! However, since I have not learned about double pointers, I must ask. What are they and what's the advantage of using them (in certain situations) over pointers? Would that double pointer in your code, for instance, be correctly defined as a pointer to a pointer to a struct entry? It's not a matter of having advantages over pointers, it's just another tool. A double pointer is no more than a pointer that happens to point to another pointer. As you said, a pointer to a pointer to a `struct entry`. The point of Torvald's code is to manipulate the node pointers, whether that pointer comes from the head or from the previous node, and to do that you need a pointer to that pointer. &gt; I'm starting to feel unsure as if the book I'm reading to learn C is good enough; after all, I am constantly having to post on the sub. What's your opinion of Kochan's "Programming in C"? How did you learn? How can I have as much knowledge as you? I'm not familiar with it at all, sorry. But I don't think it's wrong to be posting here (I might also suggest /r/learnprogramming). That's a resource I didn't have when I learned. I started programming in C about ... maybe 25 years ago? So I learned from a few books, but mostly by practice. Lots and lots of practice. Beyond programming, I would also recommend studying computer architecture, or what's going on under the hood. C is just a thin veneer over assembly and machine code, so if you understand the computer then you'll understand C. Go for both breadth and depth in your learning, because they reinforce each other. &gt; Also, what do you think would be a good project for a beginner like me? I was thinking of creating my own text editor after I finished the book (I'm reading it whilst doing CS50x, if you've heard of it), but I don't know how hard that might be for someone like me Hmmm... I've always had a hard time coming up with project ideas. A text editor is pretty challenging, so I'd save that for later. I found embedded programming to be a great way to program while doing interesting things. Pick up an Arduino and go to town. &gt; Btw, that website you linked at? Bookmarked. Wow. Thanks. Oh, yeah. Godbolt is amazing. I'll also recommend [this reference site](http://en.cppreference.com/w/c). The site mainly focuses on C++ (and I use that a lot, too) but its C section is very nice as well.
Pretty decent project, all things considered. As long as nobody at Microsoft tries to shove it down people's throats before it's provide itself (à la [Annex K](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1967.htm)), I think it's a great project worth researching. I agree with the author that expressing bounds as invariants instead of dependent types is a good way to go. My only real criticism of it is that it's too verbose, which is a criticism you could lob against any project like this. I think it's just the nature of the beast that this stuff is going to require a lot of annotations, and sadly a lot of annotations that programmers are going to be too bothered to provide in most circumstances.
Try linking them manually: Settings&gt;compiler&gt;Global compiler settings&gt;Linker Settings.
my best pick from the comments.... &gt; and are missing about a thousand other features. And thank God for that! C++ is a monster. 
Exactly! I still keep hoping a "safer" C arrives. Because Rust is already too bloated! Rust == New C++
&gt; I have not learned about double pointers Think of it this way: a pointer is merely an address of the variable. Now, in C functions are pass-by-value. What it means is that the function receives a **copy** of the arguments that were sent to it. Consider: void inc(int num) { num++; } Whenever you call inc from any point in your program, inc receives just the value of num. Not the variable itself. So, if, say, you have int x = 5 in main and you call inc(x), the x **in main** is not going to be incremented. Because only the value of x was passed to inc. If you want to change the variable outside its scope, you have send not the value, but rather the address of the said variable. Say you have int main(void) { list *head = NULL; ... return 0; } where list is the head node of a linked list and ... stands for some operations involving head. Now, in order to perform operations on the list you have to populate it, right? But then, if you populate it, head must point to the actual head of the list, not to NULL. This is where double pointers come in - remember, a pointer is just the address of the variable. We send the **address** of the head to the adding function: void add(list **head, int num) { // malloc a new_node, etc // take a peak at the variable that head points to - in this case it's a pointer, so we can compare it to NULL if (*head == NULL) { *head = new_node; // change the variable itself that head was pointing to } // else - whatever } And so, calling add(&amp;head, 0) from main will change the value of the variable list *head **in main**. It will no longer point to NULL, it will point to the newly created node. And, of course, in case of our inc function, it should've received int *num and incremented *num++ that is, the variable that num was pointing to. The call from main to inc would've been inc(&amp;x), and then it all works out - the x **in main** will be changed.
Why is Rust bloated? Do you mean the stdlib or the language itself?
Do try to fit Rust in embedded projects. PS: Raspy ain't! 
I do all the time. It’s not bloated at all after building for release and stripping, I reckon on average an extra 10% over an equivalent C project.
The amount of salt in that thread is enough to melt both of the world's ice-caps.
Good advice. unsubscribed! 
Could you share some real project?
haha
A small terminal utility to help you select words from stdin in shell scripts: https://github.com/p-gen/smenu
Real talk why do so many packaged clang++ configurations fail to find the iostream header. Analyze that, yall
Arduino. Need I say more? 
LOL because hanging out in a dedicated C language subreddit and hugging each other because r/programming made fun of your language is not-at-all a circle jerk, right?
Now everything makes sense! Thanks so much for the long explanation, you answered many of the doubts I had. 
Username checks out. If anyone can recognize a circle jerk it's this guy. 
What's your ultimate goal here? What's your platform? 
I fully expect this to be downvoted to hell, but C not-having-features is a liability, not a selling point. It just means you have to re-invent everything yourself. C++ is not a great language - or even a good language - but C is so incredibly feature-poor that even choosing C++ and mostly-programming-in-a-C-style still gets you so many benefits: - Generic functions - Strong type safety - Namespaces - Strongly-typed Enums - Memory safety w/unique_ptr&lt;T&gt; - Strongly-typed struct extension - Type introspection - Access to some of the STL types that are still helpful even in C code, such as dynamic arrays and linked lists (std::vector and std::list) - References 
Sorry, but these are definitely the words of somebody who doesn't actually know much about Rust. The code that Rust produces is tight - very tight. Tighter sometimes than even C code, since the compiler is given more information to work with and can perform optimizations it would have to be conservative about in C code because of pointer aliasing, or calculations it could do at compile-time. Rust's standard library actually has a smaller initialization routine than GLibC does as well, due to its lack of global variables and old shit like string locales.
No you dont. lmaaaaaaaaaaaaoooooooooooooooooooooo
Do you think SQLite would benefit from being written in minimalist C++ (as per the methodology you describe above)? I'm not trying to start shit or be rude, I'm genuinely curious.
Sure, I'm working on an electric longboard remote. It has a 128x64 OLED display, nRF905 transceivers, Hall sensor and a few buttons. It needs to encrypt and decrypt traffic between it and the longboard and NEVER fail. I started in C but the firmware was a mess. It was hard to write abstractly about the various components and I ran into memory allocation issues frequently. In Rust, I can use standardised component crates (Rust for library/package) to build a "device" crate defined by how the components are connected physically. Then all I had to do is use the standard embedded traits to write my program. Existing AES libraries were easy to use and honestly development was a breeze. Now when I want to write a CLI for the remote, I can pretty much just copy and paste the STM32 firmware, and replace the device crate with the embedded-linux crate and boom, I'm controlling a longboard from a computer. However, I really don't want to be seen as hating on C. For example, I wanted to write some code at my job for a pretty old and obscure PLC, and after a few minutes of googling, someone had written a C compiler that worked amazingly. I also needed to write some very high precision timing code, delays in the order of 3 or 4 NOP instructions, and I could never get the inline assembly to work in Rust.
There are tons of real-world projects that are essentially written this way. Tons of video game engines (Unreal for sure, I think Unity but I don't have actual experience there) are written in this manner. Ditto with a lot of system-level software. The entire Java VM is written in this style. Whether you have an NVidia, Intel, or AMD GFX card in your machine, all of their closed-source drivers are written in C++ using a style where they don't allow some of the more error-prone features of the language, like exceptions or template meta-programming.
The arduino is a fun little board, if you're interested in microcontrollers, it's a good starting point. Answers to your questions: 1) Arduino .ino is actually based off of C++, not C. That said, most of what you're learning about C will be applicable. 2) The big thing you get with Arduino is that you get access to their libraries and tools, which make quickly getting things up and running a breeze. I'd recommend getting started that way. What you get with C is flexability - selection of tools, libraries, etc. 3) Yes, you can program an arduino with C. You'll just have to use an external compiler and figure out how to flash it. The processor in the board is an [ATmega328](https://www.microchip.com/wwwproducts/en/ATmega328), so that's what you'd be writing code for. I haven't looked around too much, but it's such a common platform that I'm sure there are C libraries out there to get started in C on an Arduino. 4) The world is your oyster. You could build a handheld game. You could make art with it and some LEDs. You could build an animatron. Search around for something you're interested in making, maybe follow some tutorial projects to get your feet wet, then go from there. 5) If you just want to know more about computers and programming, you might have a better time learning C on your PC. If you're interested in jumping into hardware, the arduino is an inexpensive, fun way to get started. You'll also need to learn some electronics beyond just programming logic. I find that usually I spend more time planning and preparing the hardware than I usually do when I write arduino code. That could just be about how I use arduinos though.
I have very limited experience with Arduino, so take some salt with these answers: 1. As far as I understand Arduino is a minimalist C++ variant that relies upon the C standard library. 2. It's like comparing C to C++, because you effectively are. 3. Yes, but bear in mind it gets compiled as C++ (this usually doesn't matter, but can depending on standards). 4. Too much for me to list here. Honestly, I recommend you look for a cool project and try to replicate it, because in my experience being passionate about the project is more important than your experience beforehand. 5. This is entirely up to you. Arduino is a great introduction to programming microcontrollers, especially since most modern microcontrollers rely upon a dialect very similar to the Arduino language. If you want to work with embedded systems, do it, it's the best way to learn starting out. If you want to work on larger systems then it's probably not for you. Hope that helps. If I'm wrong or misleading please correct me in the comments.
Yeah, I know it's super common in microcontrollers, drivers, and high performance software, but that's not what I asked. Again, I'm not trying to be rude, but your overt avoidance of my question is a little frustrating. I'm not asking if it would be possible or plausible, I'm asking if you personally think that SQLite should be written like this. Could you justify your rationale, regardless of your opinion, for me? Thanks.
I'd add lambdas and type inference to that list. I pretty much stopped using C for anything new in favor of C++ a few years ago because of the sheer usefulness of having many of those points. 
I do, and I already listed the benefits any project, including SQLite3, would gain. Conversely, why do you think writing it in this "limited-C++" would *not* be a good idea?
Could you say what is your "main" programming language, the one that you are paid to? thanks!
&gt; Comparing an 80's library with a library written in 10's facepalm. There are some Glibc alternatives libraries written in C but way smaller! 
LOL - A modern "embedded system" is more powerful than a mainframe computer was 20 years ago when C++ was invented. So yeah - Pretty sure whatever make-believe "embedded system" your imagine can run C++ code pretty quickly.
yep...that is why 99% of embedded projects are in C++...nope...in C!
...And your logical fallacy is.... [Argumentum Ad Populum](https://rationalwiki.org/wiki/Argumentum_ad_populum) &gt; something is considered to be true or good solely because it is popular
If you are programming for Windows, you have to change the application class, though I'm a bit fuzzy on the details.
&gt; Conversely, why do you think writing it in this "limited-C++" would not be a good idea? Honestly? I don't think there would be a significant difference either way. Sorry if I sounded hostile, you just didn't say explicitly that you supported the use of limited C++ for this particular project until just now.
lol, that's funny
You convinced me. Time to learn Rust. I don't want to learn Python anyway! haha
Rust is great, but you won't find lots of jobs in it probably for the next decade, if ever. I mean - learn it if you want to - but C++ is definitely a better career move.
I don't really think that the behaviors this guy pointing out are really anything unusual. He's basically saying: "LOL A GROUP OF PEOPLE WHO LIKE C TALKING ABOUT HOW THEY LIKE C HOW OBVIOUS" I'm not getting a lot out of it
I saw it earlier and browsed the comments expecting someone to suggest that it be re-written in Node.js or something silly.
I assume vec3_t is a pointer to an array, so those if blocks populate the relevant array's elements if the function is called when a non-NULL value for those arguments.
vec3_t contains three floats in an array. So you're saying that if `forward` etc. isn't NULL then the code will be run?
haha
As I said before for the same "advice".. I rather shift carrers to DevOps, Web than C++, Java or C#
But they would still have to offer a plain C api for portability and bindings with other languages...
I have to heavily disagree with you and I think that you have this perspective because you never had to really work low level, mix assembly code or port C and the std-lib to an entirely new platform. Most of your points are only possible with a far more complex ABI than what C is requiring: * **Generic functions:** Only possible with a name masking and other ABI hacks * **Strong type safety:** This makes access to hardware registers etc a much bigger nuisance, for Cs main application this would be a big minus * **Namespaces:** Again, only possible with ABI hacks * **Strongly-typed enums:** See type safety * **Memory safety w/unique_ptr&lt;T&gt;:** Pretty hard to implement in a way that it would be compliant with assembly * **Strongly-typed struct extension:** See type safety * **Type introspection:** Only possible with ABI complications/hacks * **Access to some of the STL types that are still helpful even in C code, such as dynamic arrays and linked lists (std::vector and std::list)** * **References:** See unique pointers * **Type inference:** Very often is is necessary/required for performance * **Lambda functions:** See generic functions * **Functors**: See generic functions * **Automatic scoped release (RAII)**: See unique pointers Most of your points seem to make a lot of sense when you approach C from a C++/Java/... perspective. They are horrible when you approach them from the perspective of an assembly programmer or developer that has to provide these capabilities since nearly all of them need pretty sophisticated ABI's or make mixing assembly and C on a binary level a total pain.
As for threads, C17/18 fixes their issues (I've read anyway, I have no idea where the shit to find a pdf) the main problem is standard libraries not supporting them, not even Apple does who generally offers decent support for other c features other libraries don't, like Atomics.
&gt; C2 Sadly, without a big corp backing them, I find it difficult for any of those get attention! 
It’s not apparent exactly what you’re talking about regarding what the functions do or what you’d do differently, given only the information you’ve provided, which is that there’s a function that takes a pointer to (presumably) 31+-bit unsigned integers or 32+-bit signed integers. Is there a specific library you’re looking at, or can you link to the code you were reading? Can you describe what the function does? Generally you only free an argument if (a.) you’re actually implementing `free`, `munmap`, etc. or some wrapper for such things, or (b.) you’re cleaning up something another function you provided created; ditto for `realloc`. Nomenclature varies, but `init` and `deinit` sorts of functions (or ctors and dtors in C++) often don’t allocate or free their arguments directly, though they may allocate/free component pointers. Generally you’ll see pairs like T *foo = T_create(); use(foo); T_destroy(foo); vs. T foo; foo_init(&amp;foo); use(&amp;foo); foo_deinit(&amp;foo); with the second sort preferable when possible. For a UCS decomposition I’d probably do something like size_t decompose(const T *restrict in, T *restrict out, size_t maxOutLen); for whatever code unit type `T`, assuming NUL-terminated `in`, without which there’d need to be an additional `size_t inLen`.
The general idea of what the function does it take in a 32 bit string, and then create a new string because you're changing it's size, I would take in the string, malloc the new one, and return a pointer to that new string, leaving the original untouched. they're doing the same, except at the end they're not returning a pointer to the new string, but setting the String2Decompose variable to the new string's address. I'll try finding it, but I've been reading a ton of libraries so I'm not sure if I'll be able to find it.
That's quite a bit different from the examples in your original post, because it uses C++ references (and an actual string type, not a pointer to an array). That allows the function to safely replace the value stored in its argument. The closest C equivalent would involve passing a pointer to a pointer.
Learn-c.org explains this
Yeah I read the return value and realized I remembered it wrong.
This is why you should *always* turn on compiler warnings: $ gcc -g -Og -Wall -Wextra reddit.c reddit.c: In function 'main': reddit.c:6:15: warning: format '%ld' expects argument of type 'long int', but argument 2 has type 'unsigned int' [-Wformat=] printf("%ld\n", UINT_MAX); ~~^ %d reddit.c:6:15: warning: format '%ld' expects argument of type 'long int', but argument 2 has type 'unsigned int' [-Wformat=] printf("%ld\n", UINT_MAX); ~~^ %d 
Thanks. I use Codeblocks and will figure out how to enable these settings.
&gt; because you never had to really work low level, mix assembly code Making some pretty big and incorrect assumptions there bud.
Thank you kloetzl for voting on twinkiac. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
What's wrong with (char **array, int numStrings)? That's exactly how main does it. example: int main(int argc, char **argv) Each individual string is null terminated and argc tells you the amount of strings, i.e. argv[argv - 1] is the last string in the array.
Its been a bit since I did some C but I believe it is something along the context of a double char array something of the sort char[][] to simulate an 2d array that imitates a string in something like java by indexing throughout each letter. If I’m wrong google my friend stack overflow usually has something! When it comes to passing to a function pretty sure that’s up to how you want to implement or how your workin with it. Hope this somewhat helped sorry if not !
In the Unix world, the problem with C11 threads is they [can't be implemented](https://gustedt.wordpress.com/2012/10/14/c11-defects-c-threads-are-not-realizable-with-posix-threads/) as a thin layer over pthreads. Given the ubiquity of pthreads, nobody wanted to spend the time coming up with something new and different.
This often happens if you haven't properly declared your variables. Show us enough code to reproduce the problem.
Sorry but this is poor advice, multi dimensional arrays are not possible in C. You are perhaps assuming C++ in your advice which indeed supports multi dim array (although arguably it will still flatten the array behind the scenes). /u/8bitslime answer is the canonical way of doing this in C.
warning: incompatible pointer types passing 'char [4][13]' to parameter of type 'char **' [-Wincompatible-pointer-types] display_string(array2, 4); i get that warning when I try to do it that way.
Please, copy+past your code.
I believe if you are trying to do this with a statically allocated array then the array will be, in memory, basically one long array, and so you should simply pass in a char* and iterate through the whole thing as one long array. Passing in char** like that would be if you allocated the memory dynamically with malloc (first call to malloc to create an array of pointers and then iterating through that array and calling malloc on each one to create a row of chars). 
You can calculate the size of an array at runtime so you do not have to hard code it: `sizeof (array) / sizeof (array_type)` Example: void greet(const char *people[], const int people_length) { for (int i = 0; i &lt; people_length; i++) { printf("Hello, %s!\n", people[i]); } } int main() { const char *people[] = { "Steve", "Bill", "Linus" }; const int people_length = sizeof (people) / sizeof (char *); greet(people, people_length); }
You can build customized versions of rust std lib using [xargo](https://github.com/japaric/xargo) (the functionality of which should eventually be merged into cargo at some point in the future). As well, the embedded space is one of the focuses of Rust development and tooling for this year[(Roadmap)](https://blog.rust-lang.org/2018/03/12/roadmap.html). [Embedded WG found here](https://github.com/rust-lang-nursery/embedded-wg)
`char[][10]` or `char (*)[10]` would be a different format than `char **`—the first two are passed as pointers to arrays of `10*n` chars, whereas the last is a pointer to an array of pointers to `char`. Assuming fixed-size strings, you’d have to create an additional array of `char *` and point that into the larger buffer array: static char stringData[10][10] = {...}; char *strings[10]; unsigned i; for(i=0; i &lt; 10; i++) strings[i] = stringData[i]; and then you could pass `string` as `char **` or `char *[]`. The `char **` method gives you the ability to pass individual `NULL` string pointers (which is what `argv` and `env` use for sentinels), whereas the `[][10]` or `(*)[10]` method only gives you the ability to pass one `NULL` to the outermost structure. `char **` also allows your strings to have any length, and for their lengths to be entirely independent of each other.
Please post your code as text instead of an image. I have removed your post so you can repost your question with code as text.
haha
What does the compiler say?
It says “expected expression before ‘=‘ token” for lines 32 and 34
Could you post those lines? Formatting is screwy.
It is fans = 2 * Pi * r fans2 = Pi * r^2
I need help soon cause this is due in 3 hours
You need to put four blanks in front of every line of code so the code is formatted as code by reddit. Also, posting your midterm exam as a question is really bad style.
I am more than happy to help you, but it is very difficult to spot the error when the code is either a picture (which I can't plug into a compiler) or too garbled to be entered into a compiler. You could alternatively upload your code to a paste service of choice and post the link as a comment.
How do i do such? Sorry im new at reddit for starters and two im stuck having to do all of it through VNC viewer
The phrase "wall of code" comes to mind.
Note that the `^` operator doesn't do what you expect. There is no exponentiation operator in C, as a quick fix, try writing `r * r` instead.
We are not allowed to ask for help
Is that not taken care of when you use the #include &lt;math&gt;
Header files cannot change what operators the language has. What does exist is a function named `pow()` in `math.h`. `pow(x, y)` computes x^y.
I don't have the time or inclination to help, but I've sorted out the code's formatting in vim for anyone who does: #include &lt;stdio.h&gt; #include &lt;math.h&gt; #define Pi = 3.14 /* AUTHOR: August Goodrich COURSE: Computer Programming I- Section 02 PROGRAM SUMMARY: This is the second part to the midterm. this program will display my name. then a menu option will appear. the menu will include an option to calculate the circumference and area of a circle, and the perimiter and area of a rectangle/square. There are only 3 menu options. If an option is selected that is not part of the menu, an error message will be displayed. The number Pi will be resricted to 3.14. and error messages will be displayed for invalid information put in by the user. */ int menu(void); int main(void){ int selection, r, l, w, ans1, ans2; float fans, fans2; printf("Hello August! Please make a selection.\n"); selection = menu(); while (selection !=3){ switch (selection){ case 1: printf("What is the radius of the circle?"); scanf("%d", &amp;r); while (r==0){ printf("The radius of the circle cannot be zero\n"); printf("What is the radius of the circle?"); scanf("%d", &amp;r); } while (r&lt;0){ printf("The radius of a circle cannot be a negative number\n"); printf("What is the radius of the circle?"); scanf("%d", &amp;r); } fans = (2 * Pi * r); printf("The circumference of your circle is %.2f", fans); fans2 = Pi * r2; printf("The area of your circle is %.2f", fans2); break; case 2: printf("What is the length of the rectangle?"); scanf("%d", &amp;l); while (l&lt;=0){ printf("You cannot have a negative/zero length\n"); printf("What is the length of the rectangle?"); scanf("%d", &amp;l); } printf("What is the width?"); scanf("%d", &amp;w); while(w&lt;=0){ printf("You cannot have a negative/zero width\n"); printf("What is the width of the rectangle?"); scanf("%d", &amp;w); } ans1= 2l + 2w; printf("The perimeter of your rectangle is %d", ans1); ans2= l * w; printf("The area of your rectangle is %d", ans2); break; default: printf("%d is not a valid selection\n", selection); } selection = menu(); } printf("Midterm Complete!!\n"); return 0; } int menu(void){ int choice; printf("1. Area and circumference of a circle\n"); printf("2. Perimeter and area of a square/rectangle\n"); printf("3. Quit\n"); scanf("%d", &amp;choice); return choice; } 
`Pi` is equal to `= 3.14` (note the equals sign!) so the final code will be `fans = 2 * = 3.14 * r`. See the problem? `#define` is really nothing more than a search-and-replace operation. Just `#define Pi 3.14` should work unless there are also other errors.
Put 4 spaces in front of each line of code to properly format code for Reddit.
Have you tried using printf with proper format specifiers instead of `cin` ? Here people usually discuss C, not C++.
Oops sorry done ^^"
Oops sorry done ^^"
I'm currently running into a bug with the second edge database which deals with the last 6 edge pieces. I made a nice graphic in the testheuristic.c program, and this appears to always be correct. However, sometimes [I'll type in a scramble, and then type in the same scramble again, but with a U turn](https://i.imgur.com/U9BFU24.png), and the lookup from the edge 2 database will return two different results even though the U turn does not affect any of these edges. This might be because I tried to complicate things a little bit by making address 0 refer to the solved state. It's strange that the database generation still completes even though there appears to be a bug.
The error message is telling you what to look for. Your search function calls for a char*, but you are passing an int*. Look at your templine variable, it is an array of ints, not a char*.
You *might* be thinking of Cyclone?
Why are you re-seeding (calling srand()) repeatedly? srand() should be invoked once, and then just make successive calls to rand().
if you use JDoodle.com or another online IDE it will tell you the specific compilation errors 1) you don't use an equals sign (=) when defining at the top, just put #define Pi 3.14 2) you typed r2 as though that means r squared. In order to find r squared, you need to actually multiply r * r 3) you typed 2l and 2w as though you can multiply variables by a coefficient on a computer the way you do on paper. when programming you actually need to type 2 * l and 2 * w or even w + w and l + l. The way you have it now, the compiler thinks you're trying to print out a long integer instead of a regular integer. Here's your fixed code. You need to clean up the logic of the menus and the formatting so that text appears on a new line https://onlinegdb.com/r1QwTwFtG
I don’t see where you are printing the value. Anyway here is a short summary of union. Union allocates the largest element size of its members. Unlike structure it is not a summation of size. Depending on what part of the union you are writing to you might be using the entire size or part of it. In your example float will dictate the size of the union. Char will just occupy a subset of space. So when you allocate memory you are allocating a uninitialized memory and then when you write a char you are only initializing a part of the memory so you still have unknown content in all but 1 bye. So when you print it it depends how many bytes you print. If you print exactly one byte I think you should see the value you wrote. If instead you print say 4 bytes then you will see garbages in 3 bytes and your value in 1 byte.
I think he just wants to tell your prof that you're getting answers off the internet
but that's the reason your code won't compile
One of many desperate attempts to not get the same output every single time. After that, I tried creating an uninitialized char array with 100 elements, then converting the memory address into an integer, taking the modulo and trying to use that as a random number. I think I actually got that to work but that's ridiculous.
&gt; I tried creating an uninitialized char array with 100 elements, then converting the memory addresses into an integer, taking the modulo and trying to use that as a random number. The memory addresses would be sequential. In your first example 'move' has 'seedCounter', which always starts as zero and is only ever incremented once. So it's always going to be the same thing anyway.
correction: i didn't mean the address itself, i meant whatever gibberish is in memory at that address when you don't initialize an array &gt; always starts as zero and is only ever incremented once. So it's always going to be the same thing anyway. yes i meant to fix that but i figured that wasn't the issue anyway so i left it like that try it again without that unnecessary code , just seeding it once using time(null) and it still doesn't work.
So i need to point the individual pointers of an array of pointers to chars to the string array and pass that through char**?
1. This is undefined behavior, and it won't be random most of the time. 2. Why do you "do some overflow checking"? What are you trying to accomplish with that line? Now the issues with your *srand* approach: *srand* is for seeding the random number generator, that is, specifying the seed it should use. If you give it a seed, then call rand, then you give it the same seed again, *rand* will return the same value. This is useful for some purposes, but it's not what you want here. You want to call *srand* exactly once. Not just once every call to move, once per program run, so remove all calls to *srand* from your *move* function, and call *srand* exactly once at the beginning of your *main* function.
Well, if you want to use C, you're going to have that. Learn Haskell, then you get a bunch of "a -&gt; a -&gt; Char"
 I have enabled -g -Og -Wall and - Wextra I still get: ||=== Build file: "no target" in "no project" (compiler: unknown) ===| ||=== Build finished: 0 error(s), 0 warning(s) (0 minute(s), 0 second(s)) ===| 
but all I need are "training wheels", can something do that?
I'm an emacs guy, you can set up a ton of assists, but the best training wheels you can get is experience. It doesn't take long to get used to typing brackets if you just try.
Thanks. 1) Darn. 2) The first time I ran the code I was getting a number so big - it would print if I put it directly to the std output stream- but if I stored it in an int it would just give 0. 3) But i only made it that way because it wasn't giving me random numbers to begin with, and I thought that trying to seed rand() with new numbers might help. Now that I'm taking out the new seedings, it's working but that means I must have been doing something else wrong before - i swear i tried it that way the first time!
What a *darn* shame.. *** ^^Darn ^^Counter: ^^485071 ^^| ^^DM ^^me ^^with: ^^'*blacklist-me*' ^^to ^^be ^^*ignored*
Training wheels aren't good when learning to ride a bike. The very thing you want to learn, how to balance over the bike and lean to turn, is prevented by the training wheels, so you don't get practice doing what you need to do. So even if programming training wheels existed, you wouldn't want to use it. If that's what you want, just stick to Python. I also think you're overstating the problem, too: #include &lt;stdio.h&gt; int main() { printf("Hello, world!\n"); } There's one `#include` and a function declarations. That's it. Yeah, that's a bit of boilerplate for an incredibly simple program ... but once you get to even moderately advanced programs then you'll be making functions all over the place and multiple includes. You'd have to do the same in almost every programming language, including Python.
They are there for a good reason and they have been there without change for a very long time. That's C, get used to it or find some other language that fits you better. A program can't add those because it can't make any assumptions as to where your code blocks start or end.
&gt;fans2 = Pi * r2 lmao
That's pretty much every language out there (or more verbose begin/end nonsense.) Python is the annoying exception.
You could skip C altogether and do what all the cool kids are doing these days: learn Swift instead. But honestly, if your goal is Objective-C, you really only need the most minor practical experience with pure, straight C. Nearly all of the C data structures and pointer nastiness disappear when you use Cocoa and Objective-C classes. Some people think `[self reference] doWith:x using:Y error:&amp;error]` is ugly, but I quite love it. While I love C as well for different reasons, you might skip the C book and just get an Objective-C book, as it will teach you enough C as you go along. 
"Is there a way to program in c without all this nonsense?" The short answer is no. I understand that the "why do you need all this stuff in the program" may be confusing, but I assure you it's there for good reason. C is a programming language that gives a LOT of power to use at your disposable. Because of this, that power is a little more difficult to wield when you're coming from a language like Python that doesn't give you as much power. Forgot about you're big book on C. Get a book called The Programming In C 2nd Edition by Kernighan and Ritchie instead. Its about 280 pages long as will explain EVERYTHING to you. Once you understand the basics of programming in C and what stdio.h (this book will tell you in the first few pages), you'll be on your way to Objective-C And last thing you may be interested to know is that when Python was made, it was made using guess what language? C :) Best of luck to you. 
If you’re frustrated at the brackets in c wait till you discover the [] in objective c!
Not really. In any case if that did exist it would get in the way of you really understanding the language.
&gt; char random[1000]; //takes 1000 random addresses in memory These are not "random" values, they are arbitrary values. Arbitrary values could just all be zero, for example (without being guaranteed to be anything, including anything resembling "random"). &gt; long int g = (long int)random[seed]; You are casting a char into a larger type, but it still wont have any more possible values than a char. So for example, if a char could hold any number from 0 to 255, your long int after the cast will also only have those numbers. So your "overflow" check accomplishes nothing. Further, if you cast directly to an "unsigned int", or even just use "unsigned char" for your array, you can do the modulo arithmetic directly and not have to use labs(). ie. even though this function won't provide any randomness, you could have written: int dir_seed(int seed) { assert(seed &gt;= 0); assert(seed &lt; 1000); unsigned char random[1000]; return (int) (random[seed] % 4) + 1; } As for your question of why repeated srand() calls seem to cause rand() to return the same values for a while, it's because time() returns a value in seconds; ie. you are re-seeding the pseudo-random generator multiple times a second with the same seed, so it's completely understandable you are getting the same rand() results after each srand(time()) reseed. Basically, you are making a *less* pseudo-random sequence every time you call srand(). Call it *once* in main() and only use rand() after that. Just as a learning exercise, delete the srand(time()) lines, and magically you'll see things behaving more randomly. Although each time you run the program, you'll likely get the exact same results. Alternatively, you could put a one second sleep after each srand(time()) and you'll also see you program behave more "randomly", but at a huge cost in running time. Hope this helps. We all started somewhere.
Calling rand() repeatedly even without a good seed should give you random-looking results. Whatever seed it has, it'll use to produce a pseudo-random sequence that eventually repeats. If it's not doing that, you're probably doing something else wrong. The problem is that without a varying seed, the sequence will always start in exactly the same place - you'll get the same numbers every time you run the program. Seeding it with the time value is traditional because it's available on almost all systems and it's considered a 'good enough' source of entropy for something like your homework assignment. time() only returns seconds, though, so if you use that repeatedly in the same program, every time you seed the generator within a one-second period you'll get the same results. I work in embedded systems where there's usually no real-time clock and the time since boot will often be identical every time so the seed has to come from somewhere else - I usually run the least significant bit of a temperature sensor reading through an extractor until I've got enough entropy to seed the generator. If you ever get into crypto or anything where randomness really matters you'll want to educate yourself about where the numbers come from, but it sounds like you ought to be fine using time().
Python has very different syntax then the C family of programming languages, most notably is it's use of white space. Short of writing your own compiler there's nothing you can do to get rid of the braces and brackets. Embrace them, many of the most popular languages like Java share C's syntactical conventions. 
The first thing I'd do is to actually try to understand why there are so many brackets. Python does most things under the hood, but what exactly does it do? Learn C, learn pointers, learn how to use arrays properly, learn about memory management and structures. Only then you can understand what makes C (and most of its derivates) the preferred language when it comes to performance and efficiency. But, if your main goal is to learn Objective-C to do ios apps, well, I'm not sure you actually need to learn C.
Isn't `sizeof` a compile time operator and operates on types? Which would make the people array type above unknown at compile time (since no array length is given)?
In this case sizeof is calculated at runtime.
Set 2/2 is the simple %s call to a string. But what's a string, actually? It's a pointer to a character, which one? The first character, as "%s" is supposed to go through the array of chars, starting from the first one. That's why you can also take the reference (&amp;) to the first ([0]) character! As for set 4, the message is the same. Printf expects a string, and a string is given.
I'm surprised you're getting a warning instead of an error since your struct definition is incorrect. The typedef isn't established until *after* the struct has been defined, so you can't use `Person` as a field type in the struct. It's not defined yet. So you need to give the struct a tag name and then use that name for the `friend` field (e.g. `struct person *friend;`).
Don't you get an "error: unknown type name 'Person'", too? The problem is that with Person* friend; you are trying to use the typedef'd name for the struct, which isn't defined yet. You can fix that by giving the struct a name and using that: typedef struct Person { char* name; int age; struct Person* friend; } Person; 
* A pointer is just a reference to a memory location. The type of the pointer is used for determining the size of the element pointed to, which allows you to just increment the pointer and point to the next thing after the element you pointed to before (and static type checking of course). So the only real difference between a pointer to an int and a pointer to an int array is that you know there are more ints after the one you are pointing at. * The int (*stor) [] would give you a pointer to a pointer to an int. As said above, arrays are pretty much just normal pointers. A pointer to a pointer can be used as an array of arrays. You might have seen something like it in the parameter for the argument vector that main can take. That one is an array of character arrays. * It is often said that arrays easily decay to pointers. They are not the same (even though you might have noticed, that I treated them the same for the first two answers), but you can always go from an array to a pointer. The other way around does not work. An array carries the information of size with it. So sizeof(ARRAY) will give you all the bytes of the array. This is true for arrays on the stack. When you receive an array as a function argument it is actually a pointer and the expression above will give you the size of the pointer. So the array has decayed to a pointer. It carries less information. I think the best way to deal with this is to always think of arrays as pointers to be more careful not to assume things like sizeof will give you the size of the array. Even if you want to be important about the distinction, a[i] and *(a + i) are the same thing; use which ever one you prefer. * In C you need to declare things before you use them. Declaring is just giving some detail on what the thing is. The definition is the actual description of the entire thing. You can declare the struct and do the typedef in the header, so you can use the type (though only a pointer to it, I think, since its size is not yet determined) and then implement the type in the c file. So you can do typedef struct arraylist ArrayList; struct arraylist; in the header and then later define the type: typedef struct arraylist { size_t capacity; size_t length; int *store; }; * One thing I noticed is, that your header guard does not actually work the way you have it now. You should move the #endif to the end of the header file. The point of the guard is to prevent the header file from being used more than once if included several times. That is why you check a variable for not being defined and then immediately define it, which means next time you check it, it will be defined. If you #endif right after that, the rest of the file is still read regardless of how many times it has been read before. * void pointers and then casting is pretty much the original way to handle generics. C has introduced some more convenient generics in C11, but I have never really looked into them, since I don't really do to much C coding. * I don't understand the question here. Looks like your search works fine You could look into realloc for growing your array or memcpy instead of looping and copying, if you like, but it is fine the way it is now as well. Nice job. The only way to learn coding is doing it.
Example 2 is more popular in Windows API and Carbon, chiefly because they prefer to return an error code but that doesn’t make example 1 any less valid.
`sum` will never equal one because you never reset `sum` on each pass of the loop.
If you intend to sum the array on each pass of the outer loop, then you need to reset it to zero at some point, or it will only keep adding numbers to it, and so it will never* be 1. *eventually it could if the variable overflows.
I think it depends on how you want to expose the struct. If you want to make the struct opaque, you need to provide a "constructor" that allocates and initialize the struct, usually returning a pointer to it. You also have to be careful when returning the struct by value (the first example) because the struct is copied to the caller, and this copy is shallow (search on Google for an explanation if needed). Usually if the struct is simple (only scalar values or statically sized arrays) I tend to leave available for the programmer, and only have functions receiving it as arguments. If the struct is complex or require complex initialization, I prefer to keep it opaque and provide "constructor" and "destructor" (i.e. for cleaning up, free stuff, etc) functions. This approach provides a bare bones object orientation paradigm in C.
Thanks, that does make sense. I put sum = 0; as the first statement of the do-while loop, but it still seems to be running infinitely...
Short answer, no. Long answer: there's no getting away from it. It's fundamental to the language, and is why the language is as powerful as it is. In a certain sense, learning a programming language is no different from learning a natural language. When you first start, you essentially need to just step back and say "Okay, I don't know why this is the way it is. But I'll just accept that this is the syntax, and move on." When you start learning German, you start with something simple, like "Hallo, ich heisse massivebrain. Ich komme aus Reddit. Wie geht es dir?" You would learn these phrases knowing nothing of the grammar. They're simply "magic phrases" that communicate various things. It's not until you're comfortable that you start to understand the verb conjugation, the prepositions, and the dative pronouns that make these phrases. But there is no getting around this one fact: understand it or not, they syntax is vital to the language. A programming language is no different. When you learn it, you must just accept that things are how they are. Once you've become more familiar with the language, you'll start to understand why things are the way they are, and what they are. But there is one simple fact: the syntax is the syntax and it can't be gone around. Understand it or not, like it or not, that's just the way it is. I'm sure that when you were learning python, you had some similar questions. "Why do I have to use all these parentheses?" "What's with all the quotes?" "Why can't it just understand what I'm trying to get it to do?" If you're really curious: think of includes as being like the import statements in Python. Think of curly braces (these things: {}) as being like the colon in Python. Finally, just understand that anything can only ever be one type. So if you remember how Print can only take a string, similarly, functions can only return certain kinds of values, and the type of value a function returns is indicated in its definition. Finally, imagine that there's an invisible program at the start that does one thing: calls main. All you're doing is defining what goes into these functions.
If you want to pass a `char **` or `char *[]`, yes. You can’t pass a `char[][10]` as a `char **` because each row of the `char **` is a `char *`, whereas each row of a `char[][10]` is a `char[10]`. (With any luck the compiler would complain about this.)
God the "hipster" culture around software development has nearly completely ruined the whole field for me. I go on /r/programming and see news about some new programming language or framework of the week being released that has reinvented the wheel for the millionth time. Thankfully there are still some "old school" companies out there who don't think that you have to throw out petfectly good code just because it's X years old now. 
Ah what you're seeing is that your operating system buffers the output. When you do a putchar(), the character is sent to the operating system to be displayed, but it is not displayed right away. Typically, your output is *line-buffered*, meaning the operating system will buffer the output until a newline character is encountered (or stdout is flushed/the process is finished), at which point the operating system will display an entire line at once. If you change your loop to be like so: while ((c = getchar()) != EOF) { putchar(c); fflush(stdout); } You will likely see different behaviour.
thanks. for some reason ill learn pointers and be comfortable with them than a few weeks later I start confusing myself.
Yes. He is saying that if forward is non-null then that block will run. Same goes for the up and right blocks.
No, I was thinking of Zig. I meant to update my post but forgot to, thanks for reminding me.
The type syntax really doesn’t help, and the inconsistencies around arrays and functions really don’t help. I had to take a detour into assembly language before I really got pointers.
So your question only took minutes to close it's that bad? I wish I was in on closing it but I did downvote it at least.
I typically write functions to do both, and I almost always use opaque struct pointers. I have a "constructor" function to allocate and another function to initialize. The constructor will return a struct, or NULL if it failed. The initializer will take the struct as an argument and can return a more detailed error code.
It will be easier to undrestand if you move the sum loop into a function. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int sum(int a[], int n) { int result = 0; for (int i = 0; i &lt; n; i++) result += a[i]; return result; } int main () { int circle[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}; int iter = 2, step = 3; while (sum(circle, 10) != 1) { circle[iter % 10] = 0; iter += step; } for (int i = 0; i &lt; 10; i++) printf("%d, ", circle[i]); return 0; }
You do realize that's the same blog post I linked to in the comment you replied to? 
No, I didn't realize that or else I wouldn't have done it.
Lol, this is such a significantly more elegant solution and it makes immediate intuitive sense. 
I almost always prefer option 2. My personal rules for struct are: - never pass structure directly to a function. Instead pass pointer to structure. - within the structure define variables in ascending order of size - don’t use a global structure in any function but instead pass the global as pointers to the function. This way no function is dependent on globals and always use values passed. This makes changing code easier if global name changes etc - naming convention: use my_struct_s for structure, _e for enum, _u for union, all caps for macros.
For total beginners in programming, Python is a better choice because it is way easy but still cool! r/python will help you! --- If you are determined to learn C: A good choice is King's book, as it teaches as in a class! Well, he is a well famous teacher! haha [C-Programming-Modern-Approach](https://www.amazon.com/C-Programming-Modern-Approach-2nd/dp/0393979504)
can you clarify which question this is helping me with?
can you clarify where in the post did i say i want to learn c?
My answers are for #2 and #3. &gt; Books and Class are way better than tutorials and sites! As for #1, just keep studying and you will do fine! 
oh...
http://ressources.unisciel.fr/algoprog/s00aaroot/aa00module1/res/%5BCormen-AL2011%5DIntroduction_To_Algorithms-A3.pdf
Just two cents: What yammajr is assuming is that you are talking about arduino uno/nano, which is built on the 8bit MCU from atmel called ATMega328. There are other arduinos as well, but IMO this is the best one to begin with since it doesnt clutter you with peripherals and hardware abstraction layers .. You can program this arduino just using plain c syntax in an .ino in the arduino IDE. The only difference from regular c is that your loop function is in C called main with a while(true) or for(;;) which both is known as "the big while" and the setup function is in C just whatever that is called before the main function - the compiler (GCC) is the same. If you want to step it up a bit, you can install atmel studio, which has arduino support and program it using regular C code much like you would if you programmed the atmega328p directly. Now you also need to start looking at the MCU datasheet. So what you are missing now is the proper debug capabilities, which leads us to the next step, With in-circuit-serial-programming (ICSP) you have an external debugger (atmel ice or AVR Dragon) that communicates with your micro and lets you pause execution, step through the code, and read out the registers directly from the micro amongst other things.. This how you properly debug microcontrollers. 8bit micros are awesome and simple to get started with and there is a ton of resources and libraries available. avrfreaks forum has a lot of reading material but some of the guys there can be somewhat condescending, so be warned 4) Some simple starting suggestions - How about a light that changes color during the day? Blueish early on the day, and redish later. You just need an RGB LED. - A temperature display, you can make this fast and easy with hd44780 display and a tmp102 temperature sensor, both are quite common in arduino starter kits - You can connect a few resistors in paralell and put them really close to your temperature sensor, and try to build a PID-Controller from scratch and use PWM to hold the temperature to a certain level [PID Guide](http://brettbeauregard.com/blog/2011/04/improving-the-beginners-pid-introduction/) 
This submission has been randomly featured in /r/serendipity, a bot-driven subreddit discovery engine. More here: /r/Serendipity/comments/853awj/assignment_from_incompatible_pointer_type_warning/
*Is there a way to program in c without all this nonsense? is there a program that can add all those symbols so I could have "training wheels"?* Yes, use Python. You are facing two tasks: learning to program and learning C. If you find the C language difficult to understand, learn to program in a language you find easier. Programming is a skill that can be applied to any language. The C language was developed in the 1970s, back when languages like FORTRAN and COBOL were the bleeding edge. A structured language like C was such a transformation in thinking that its eccentricities were overlooked. Since then, we learn that some of its syntax is not needed and constitutes noise. But it is kept for familiarity. In short, C is what it is and not likely to change significantly in the future.
l problems without code. I'll highlight some, to help you've forward, but I will not solve this problem for you. 1) matrix size: if you have a 700x11 matrix, then you need mat[700][11], whose indexes will be 0-699 and 0-10. What you pass when creating the matrix is its size, not its maximum indexes. 2) You file is not a CSV per say. The values are not separated by commas, spaces are used instead. That means that your strtok token should be a space, and not a comma. 3) what you get from strtok is an array of chars (a string, if you will). You are trying to fit that in a single char (you are using a matrix of chars). You are using the wrong data types. You have two options: use a 3 dimension char matrix or use a 2 dimension int matrix (and convert the string to int before assigning) 4) remember to be careful with the first line of the file. It's not the same as the remaining lines since it contains only the headers.
I dunno
I dunno nothing
When you do: ```circle[i % 10] = 0;``` You are changing the sum by ```-circle[i % 10]```, so you can just adjust the sum and not recompute it.
I don't return structs ever. and I'll only return struct pointers when I'm initing it. Otherwise, I ALWAYS take a struct pointer in as the first parameter.
What do you mean by Carbon? Apple's 20 year deprecated API?
Pit a second new line between your points for your formatting to work properly. I almost always prefer option 2. My personal rules for struct are: - never pass structure directly to a function. Instead pass pointer to structure. - within the structure define variables in ascending order of size - don’t use a global structure in any function but instead pass the global as pointers to the function. This way no function is dependent on globals and always use values passed. This makes changing code easier if global name changes etc - naming convention: use my_struct_s for structure, _e for enum, _u for union, all caps for macros.
I agree mostly, tho I never make my struct member variables public. I fiddle with shit way too much for that.
I'm not talking about the *prototype* for a static function but the function definition itself. For example: https://github.com/torvalds/linux/blob/8f5fd927c3a7576d57248a2d7a0861c3f2795973/include/linux/list.h#L56 Since it's static, each translation unit that includes the header can have its own definition without conflict.
If you want to process each char when a key is processed, you need to use [noncanonical mode](https://www.gnu.org/software/libc/manual/html_node/Noncanon-Example.html). It looks like this is Unix specific and you have to do something different on [Windows systems](https://stackoverflow.com/questions/46142246/getchar-with-non-canonical-mode-on-unix-and-windows)
1. Where are the "break" statements in your switch? 2. Why are you mixing C++ (cin&gt;&gt;) with C (malloc)? 
Why would you have a different definition with the same name? I don't get it.
Yes. It is still being used out there. At my current job I am tasked with migrating from it to CoreFoundation and Cocoa. Some companies don’t bother with updating unless they really have to, like when Apple drops 32bit support. CoreFoundation uses a variation of ‘example 1’, probably because Apple probably wanted it to be OOP-like even though it is a C API. The structs are though returned by pointer and the user is responsible for releasing them.
I't very likely that those are tabs. The separator in CSVs may be comma, tab, semicolon or whatever you decide - i'd still call it a CSV.
You want to start to code and have no previous experience? Want to start with C? Not a bad choice. This is a good way to get a foundation: https://learncodethehardway.org/c/ After that start on a project on something you find interesting and just do it. Knowing what the goal is will make it easier to find the information you need. 
1. Ah i forgot to add it 😅 2.i just following up an example code, and it use malloc and im in process to understand this example code(iirc the c++ using "new" keyword) Edit: i already revised the code so it using a "scanf" now
I just added the print function, the float and int are okay but for char it always gives me a a garbage value, and thank you very much for the explanation
My bad, i already revised the code and thank you very much for the explanation :)
I just took a look at the print function. I don't see any obvious error in printing or reading the structure. However, I don't understand your add_tail function. It is not linking nodes of a linked list. It is creating a single node and assigning value and next pointer to NULL. But it is neither returning address of the node nor linking the newly created node to tail (assuming this is the head). So my question is are you sure the error is in printing structure but not creating the linked list ? May I recommend GDB to step through or if you are not familiar with GDB then maybe just read a character, store it in structure and print it in main() without adding it to list. 
Adding on /u/raevnos explaination, output streams, with the exception of stderr, are, by default, buffered if they refer to files, or line-buffered if they refer to terminals. When an output stream is buffered, many characters are saved and written as a block. When an output stream is line buffered, each line of output is queued for writing on the destination terminal as soon as the line is completed (that is, as soon as a new-line character is written or terminal input is requested). If we close the stream with `fclose` all buffers are guaranteed to be flushed to where it is supposed to go. The function `fflush` is needed in places where we want to see an output immediately on the terminal. So in your case output is really displayed when you press enter (when it encounters `\n`).
scanf("%d", &amp;year)
It worked. Thanks a lot :)
Thanks, it's running.
Thanks, it's running now. 
I really appreciate all the advice, thanks.
That's really awesome, but I hate that you're giving me such helpful advice for free, do you have a regular blog where you write about your work already? I really appreciate everything I'm learning from you guys.
i dont understand how this is helpful to any of the questions asked can you calify on how this is helpful to any of the questions asked 
I strongly recommend you try to accomplish the tutorial before asking these questions. The problem is that I don't know how to answer if this is for you, because I don't know how quickly you learn, or how good you are at pattern recognition. Skimming the tutorial I think that anybody with *some* programming experience (not even C) would likely be able to do it. I think that most people with strong problem solving skills, and no background in programming, could also do it. I am biased, I taught myself to program when I was 14, using half-baked examples I found floating around on the net. I say try it. If you can't get past the first 3 chapters, put it on the back burner, and move on to something else. As for what something else is, it depends on where you feel like you're getting stuck. If you're struggling with stepping through the logic of the problems, then you should probably find a beginner tutorial, in any language, that teaches you the basics. I tend to recommend Python to beginners, as the syntax is pretty straightforward, and most students grasp it pretty quickly. That being said, there's no reason you can't keep going with C, there's just a lot more to learn and it can be daunting. If you're struggling with the nuances of C as a language, then pick up a C book. The sidebar lists several, some of which are actually free and pretty good. Work through some of the problems you find therein that relate to what you're struggling with, or study up on the particular syntax you're having trouble with. I hope I've helped, but more than anything I hope that I haven't detracted from my main point which is: you have to be willing to help yourself. We can't do this tutorial for you, and we can't learn to program for you. You're at a point where you have a project you're interested in and the means by which to accomplish it, all you have to do is try. And if you find it's too much, that's okay, we're still here to help, and there are plenty of resources floating out there still.
I prefer: int main() { struct my_structure a = {1, 2}; } :-)
This is good for tiny structures, but very hard to implement when using nesting with dynamical memory allocation.
This code would fail to compile. My crystal ball tells me you actually wrote `struct Person *` in the struct definition
Instead of making a variable global, you just define it in main and whenever you need to use that variable to do some calculation or simpley change its value, send it as a parameter in a function. Also i don't see you using goto anywhere and just a tip that i got, from pretty much everybody, is to never use goto. 
For future reference , copy and paste your actual program code into your question (and check the formatting )
**Prototype Functions:** Prototyping Functions means that you put the function signature before the main, and the body after it. An example would be: void foo(int a); int main(){ int a = 0; foo(a); } void foo(int a){ printf("%d", a); } Because C uses a single pass compiler, the return type and function signature must be known when the function is called. In your code, you put the actual function definition ahead of the main body, but that's not typical. **Global/Local Variables and Passing Values:** It's quite bad practice to use global variables like you did, for a large number of reasons. What is typically done, is that you will declare the variables within main, then pass them into a function call. You can see I did that in my example above. In this case, that variable is passed into the function by value; that is, a copy of the data is made in the function, that you can use. If you are only displaying the data, then you can use a void function, which does not return any value. If you are modifying the value, you can instead use a function of the type you need to return from it. An example would be: int foo(int a){ return a * a; } This function returns the square of an integer. It takes a value in, and then returns the result of the operation. That result can be assigned as part of the function call: int foo(int a); int main(){ int a = 0; int b; b = foo(a); } int foo(int a){ return a * a; } I don't see that you have used goto anywhere in your code, so I'm not sure why you would have gotten that comment back... but it's absolutely correct. While goto may have a place in some programs, it's almost always a better choice to avoid it.
Oh! Makes so much sense, I guess I was overthinking the cases way too much! So then would it be OK to say that when one of `printf`'s arguments is `%s`, then it will print everything until a `\0` is reached (and that it can be used with arrays and `char *` as well)? One last question: what is the difference between a character array and a `char *` (is this one a "pointer to a character"?)? I found a difference that had to do with read only memory, but I didn't understand most of it.
Right! Thanks a lot!
Did you solve all exercises through? Because: Read != Learn --------------- If you did all that. You still have to fast through [C: A Reference Manual by Harbison &amp; Steele](https://www.amazon.com/Reference-Manual-Samuel-P-Harbison/dp/013089592X) Because... K&amp;R covers barely 40% of C features and the ones it covers it doesn't go deep enough on its proprieties! CARM do! &gt;PS: You will not need to [re]solve historical C bugs if you read more! 
It should be n&gt;&gt;1, you need to shift right for one bit in each iteration of your while loop. 
&gt;problem is that I don't know how to answer if this is for you, i like that you are honest as well honsetly counts as a helpful non-answer/reply but it is helpful and that is what matterss &gt;because I don't know how quickly you learn. * most ppl pretty much on average learn at the same rate (it just primarily depends on if it's a good learning source not, that's the bottleneck) &gt;because I don't know how good you are at pattern recognition. * there's likely much more significant varience in learning when it comes to this part (due to knowledge/info in other contexts -- since this part if more transferrable maybe, not really sure) * no comment on this one/part
Yes, I have. And thanks for that!
(*ll)-&gt;t.textID
It would be best if you could provide us with a snippet of code that runs and shows your error. I've made some educated guesses and come up with the following. #include &lt;stdlib.h&gt; struct Texts { int textID; char* textContent; } Texts; struct list_node { struct list_node *next; struct Texts t; }; int func(struct list_node** l) { return (*l)-&gt;t.textID; } int main(void) { struct list_node* l = calloc(sizeof(struct list_node), 1); l-&gt;t.textID = 1; return func(&amp;l); } Func() gets a double pointer to a list_node. You need to dereference it twice in order to be able to access list_node.t. In this case I've used the derference operator (*) once and the access through pointer operator (-&gt;) once, but the latter takes a higher precedence in the [order of operators](http://en.cppreference.com/w/c/language/operator_precedence) so I have to wrap the former in parentheses to make sure it happens first. Otherwise you try to access the "t" member of a pointer and dereference that.
"request for member t in something not a structure or union" :/ (I google that as well, since I did try this before, but didn't make much sense out of it) Thanks tho!
Thank you for your explanation. I tried using the dereference operator alongside the pointer/arrow one and I got `dereferencing pointer to incomplete type ‘list_node {aka struct list_node}’` which isn't very helpful to be honest (plus I googled this one too and didn't understand how to solve it). But you did help me understand it a bit better, thank you
`list_node** ll = NULL; ` (the NULL value is altered later on in my code) So it is.
Ok, so you probably have messed up order of declarations/definitions. When you are dereferencing ll, compiler needs to have full struct defined somewhere before.
I have included all my header and .c files and didn't have any other errors occur before this part (who lets old errors occur and move on to new code though? Anyways). So, my structs are all included properly and visible everywhere. I am still struggling with dereferencing and the sort, but thanks for trying to help :)
I see in the other comment an error about incomplete type list_node, so it looks like it's not visible at some point.
`struct`s are used for grouping data together to form complex data. It would be natural for you to want to group those pieces of complex data sometimes. For a silly example, maybe you have a `Point` struct, with an `x` and `y` , and then you have a `Circle` struct, which contains a `Point` and something like `radius`.
Just wanted to note, as OP noted above, that goto *does* have reasonable use cases. Most notably would be resource acquisition. For instance, imagine you needed to acquire resources A, B, and C prior to some calculation. If you fail to acquire any, then you would like to free what you have acquired and abort. Without using goto: void without_goto(void) { if (FAIL TO ACQUIRE A) ABORT if (FAIL TO ACQUIRE B) { FREE A ABORT } if (FAIL TO ACQUIRE C) { FREE B FREE A ABORT } /* calculations */ } Using goto: void with_goto(void) { if (FAIL TO ACQUIRE A) goto C0; if (FAIL TO ACQUIRE B) goto C1; if (FAIL TO ACQUIRE C) goto C2; /* calculations */ C2: FREE B C1: FREE A C0: ABORT } In this case, using goto both helps to keep the code clean as well as avoid code duplication, which I would argue is more likely to cause issues down the road than the use of goto.
Cool! Thanks for the detailed description of arrays/pointers, that's something that was confusing me a bit before now just because of different things I've heard out there. Unlike most beginners I really grok and love pointers, haha, probably because I haven't gotten to more complicated pointer types. Was looking at the Linux kernel linked list implementation today and I'm still not good enough at C where I could understand it well. Thanks for the tip about the header guard, I was under the impression that when you #include "arraylist.h" and if I have you header guard it only includes the file if _ARRAYLIST_H_ is undefined (i.e. it skips the entire file). My sort worked fine I was growing the array incorrectly. I'm using realloc now so that problem is fixed. I've been running my code under Valgrind and it's found some errors in there so I'm trying to figure that out for now. Thanks for the detailed answer! 
so to start with bit_test - every bit has a "value" - the rightmost starts with 1, next 2, 4, ... and so on. So to test if a specific bit is set, take it's value and use the boolean operator "and" to throw it against the variable you want to check. As for "and" both sides have to be true you get a zero when the bit ist not set. bit_set: same principle - calculate the value of the bit you want to set and then use the boolean operator "or" like newvalue = oldvalue | bitvalue; 
&gt;I taught myself to program when I was 14, using half-baked examples I found floating around on the net. hmm that's a lot of googling and it's unclear if that's actually the more effective way to learn, and while it may get done it's also unclear significant understand is actually via that way/method
I don't recommend it. As a child I had no better idea of how to go about learning. I meant it merely as an example of why I am biased toward people being able to learn by doing, as opposed to learn from books.
&gt; at a point where you have a project you're interested in ah no im not at all interested in it, the goal is to learn programming/cs and basics of such 
 &gt;probably find a beginner tutorial, well at least on the reddit site, ppl dont really know much when it comes to good resources but ill be learning python basics and ill be finding the answer eventually that so many do not know
Thanks! I understand what I have to do now, but stuff doesn't seem to work... I implemented `bit_test()`: int bit_test(unsigned int value, int n) { int track = n; while (track &gt; 0) { value &gt;&gt; 1; --track; } if (value) { value &lt;&lt; n; return value; } else return 0; } Basically, I shift the number to the right until the bit that was specified becomes the LSB, and then I test if it is on or off; if it's on, the value is shifted to the left as much as needed and then it is returned, otherwise, 0 is returned. My program seems to output the value as it was passed, and not just the bit value (e. g. if the call is `bit_test(3, 1)` the returned value is 3 instead of 2). How can I go about solving this? I'm pretty new to programming, especially the bit manipulation part...
Alternatively you can just pass `str_array[0][0]` and iterate over the initial array until the null character and the second dimension a known or given value.
Thanks. I was getting confused as to it being an array of pointers or a pointer to an array. I got it down now. 
It's like reading a double spaced essay padded to fit the page requirement.
I think this is very dangerous information to show a beginner. `goto` is such a double edged sword that it can be very easy to abuse, _especially_ for someone who doesn't understand all the nuances yet. I absolutely agree it has a place (and resource clean-up is definitely one of them), but the timing is wrong. It's better to stick with the old adage of "`goto` is evil", and then later on re-introduce it in the right context.
Code a real thing. Whatever takes your fancy. A simple game, utility, etc.
This. Pick a small project and code it up. Keep it simple at first - you can move onto complicated things like build environments, networking, threads, etc later as your confidence increases. Some examples: - write a program to walk a directory tree and print out the sum of the file sizes in each directory. - try a couple of Project Euler problems - prime number finder. 
I agree that goto is certainly an easy aspect of the language to abuse. However, I certainly am not giving anyone carte blanche to use it in any circumstance. Rather, I simply gave one of the few legitimate uses of it, with the expectation that one should stick to specific, very common mnemonics when using goto. I'll amend my comment to better reflect that there should be no experimentation when it comes to using goto. 
It's just like how you would organise your refrigerator - different compartments for different items based on their categories, right? Imagine the mess if you were to pile your meats, cheeses, vegetables, drinks, candies, jellies et al into one huge pile. Of course, that can happen, but don't be upset if people then judge you for it! :D
Here are the fundamental bit twiddling primitives, set out with minimal work done per line so that they are suitable for single-stepping in a debugger. static inline unsigned mask(int n) { assert(0 &lt;= n &amp;&amp; n &lt; CHAR_BIT*sizeof(unsigned)); unsigned m = 1U &lt;&lt; n; return m; } static inline unsigned set(unsigned v, int n) { unsigned m = mask(n); v |= m; return v; } static inline unsigned clear(unsigned v, int n) { unsigned m = ~mask(n); v &amp;= m; return v; } static inline unsigned flip(unsigned v, int n) { unsigned m = mask(n); v ^= m; return v; } static inline bool test(unsigned v, int n) { unsigned m = mask(n); v &amp;= m; return v != 0U; } Most real-world code wouldn't use separate functions for all of these and would put more work onto a single line as an experienced programmer would be able to spot that e.g. w &amp;= ~(1U &lt;&lt; n) is clearing the nth bit of w.
Do not post code as pictures. Always post your code as text!
i'm not sure if you can use strings with switch statements in C. You can't in c++ anyway. 
OP doesn't appear to be doing that.
Put 4 spaces before every line to format code for Reddit.
The commenter you replied to seems to be talking about "Object-Oriented" programming; I've never heard of "objective" programming. IMO it is much more important to learn the fundamentals (data structures, algorithms, etc.) than it is to learn a specific programming paradigm (like Object-Oriented programming). There are tons of great free courses online. I would highly recommend checking out Harvard's CS50 on edX. It's absolutely free to take, and you get access to pretty much all the resources that a student taking the course at the university would. The first half of the course is taught in C, and the content is really comprehensive. Can't recommend it enough.
[*ahem*](http://gph.is/1sEY5n5)
Thanks!
Bit masks? Haven't even heard about them. Do you recommend a specific resource to study all of the bit twiddling? 
Line 111 is what I can't seem to fix: https://pastebin.com/4cfJmDK9
Does the type in your `switch` statement match the types in your `case` statements? 
Just Google lol
Hint: `'1'` is a character (and its numerical value is not 1, but the ASCII code of `'1'`, which is 49). 
Too easy pffff. My mind stopped working hehe
I believe it does.. as I have the switch listed for hundred. I have hundred declared in the same function. Maybe I'm misunderstanding "type"? I thought for the cases that I declare that if hundred is 1 then it outputs "C". when the computer reads 2 for hundred it outputs "CC".
So I should put 49 for 1? Are you saying that when I say case '1' it's reading like a true/false statement?
&gt;Oh! Makes so much sense, I guess I was overthinking the cases way too much! So then would it be OK to say that when one of `printf`'s arguments is `%s`, then it will print everything until a `\0` is reached (and that it can be used with arrays and `char *` as well)? You've got it. It works with arrays because of the decay-to-pointer feature I mentioned, really it sees both as a `char*`. &gt;One last question: what is the difference between a character array and a `char *` (is this one a "pointer to a character"?)? A character array is a block of memory, a list of characters of fixed length. A character pointer (or pointer to a character or a `char*`) is a reference to a single pointer, a variable that points to some other place in memory. However, C lets you treat a pointer like an array as well. You can use the `[]` operator like an array, in which case C uses the pointer as if what it points to is the start of an array. You can also use pointer arithmetic to move the pointer around inside the array. The line is further blurred by decay. An array can become a pointer to its first element quite easily. Also, array function parameters are pointers, despite the declaration syntax. &gt;I found a difference that had to do with read only memory, but I didn't understand most of it. This is related. Consider this line: char *str = "Hello, world."; The string literal "Hello world." is an array. String literals are explicitly meant to be read-only in C, so trying to change it (`str[5] = 'Z';) is not allowed. In fact, most compilers will give a warning that you should have used: const char *str = "Hello, world."; In both cases, `str` is a pointer to the first character of the literal. In this case: char str2[] = "Hello, world."; `str2` is an array, initialized with the given string literal. Even though the literal is a read-only array, `str2` can be modified since it's a copy. So the following is valid: char *p = str2; p[5] = 'Z';
You should use `1` (which is an `int`) instead of `'1'` (which is a `char`).
No, your `'1'` is interpreted by the C/C++ compiler as the decimal number 49. You should not place these numbers in between single quotes. This is a pitfall many starting C coders fall into, a character is just a number too with which you can calculate, and which represents an ASCII character. The ASCII number for the character `1` is 49. For example: char c = 49; printf("The character is %c\n", c); will print out The character is 1 The line `char c = 49;` would generate exactly the same code as `char c = '1';` would.
I used HackerRank problems to get more familiar. A good practical problem to solve is wrapping a c library in another language. It is challenging, but doable for one person in a reasonable amount of time.
Don't name your variables "ll".
That doesn't seem like it's going to solve much but thanks for the heads up.
I fixed the error, it had to do with the way my files were arranged. Thank you everyone for your time.
I wrote a [function](https://pastebin.com/DTmnwKKq) that tests to see if a given random combination is solvable, but I don't think I'll need this for the search. I came up with an idea for getting a combination from the database memory offset. I haven't implemented it yet, but I'm pretty confident that it will work. However, I'm not sure if this is a good idea. I'm at another time/space issue. If I were to store the entire combination in memory, it would require 20 bytes (1 byte for each edge and corner). This seems like it would save the most time. The database offset values require 4 bytes, and I need 3 of these offsets for each database, resulting in 12 bytes, but it requires additional processing. I could go back to the idea I had at the start of this post and store each cubie value in 5 bits (assuming that the values in memory wouldn't need to be word aligned). If this were possible, I would need 5 bytes for the 8 corner pieces, and I would use 8 bytes for the 12 edges. This would require a total of 13 bytes to store the entire combination in memory, and the only processing required would be from converting the bit fields to something usable. Let me know if you are bored of this topic and want to stop asking questions because I might be posting here every once in a while for the next 6 weeks.
Done! I understood bit masking and it ended up feeling quite easy. Thanks!
There's no way to do it without modifying the compilation unit that `file1.c` is in, sort of by the very definition of `static` linkage: these functions don't leak out of compilation units. You'll have to compile it twice. Once for everyone else, and once for the unit tests. How you actually expose the functions to the unit tests is up to you. If you are willing to edit the `file1.c`, you could conditionally remove the `static` declaration using the preprocessor. If not, you could expose the functions through a second header file used for the unit tests compiled in the for-unit-test compilation unit, or through the same header file with conditional stuff using preprocessing. What you'd be exposing is either function pointers, or wrappers, or something. 
You can include the .c file in the test driver.
Is that a common practice for unit testing? 
I cannot really tell. It's a working solution that does not pollute the sources with defines that switch between `export` and `static`.
It's doing what you tell it to - it's stepping through the file and printing all the values. You need to examine the value before you print it - if it is null, then don't print and skip to the next entry. You need another test inside the for loop.
"Hello, world"
How to tell how many bits are in an int: sizeof(int) * CHAR_BIT 
It should depend on how the data needs to be ordered, but in general you'll need to loop through the queue comparing the new node with each successive node in the queue until you've found the new node's spot. So like, if the queue is meant to be ordered from smallest to largest going from head to tail then you would want to insert the node into a spot where it would be greater than the previous node but smaller than the next. It may be worth considering passing a function pointer that determines order into your insertion function to allow you to order the queue in whichever order you wish, but this may add more complexity than you want.
The problem specification dictates that you should report the occurrence of the pattern from the most significant bit (in this case it's where `101` "starts", or the 11^th most significant bit), but you appear to be reporting the occurrence from the least significant bit (in this case it's where `101` "ends", or the 14^th most significant bit). Hope that helps.
IRC client
Jokes aside, my first real **non-trivial** project is [this hex editor](https://github.com/krpors/hx). Did plenty of other things before that, mostly to learn pointers, memory management, the syntax and whatever.
Working on a MUD.
Personally I think it's overkill to feel like you have to unit test static functions. The static function will be called in the body of other functions, it should be possible to get full coverage of it though the tests of those functions.
Wow! Excuse my super noob level of general knowledge... did you just made it to improove yourself as programmer or did you really need an hex editor? Also... why somebody would need an hex editor? (Please, ELI5)
What's that? I'm very new in this.
https://en.wikipedia.org/wiki/MUD
My first zserious project is the one I am working on now. I am trying to implement the solution to the exact cover problem using Knuth's Dancing Links algorithm. Eventually create a Sudoku Puzzle solver/creator game using the nurses library. The next project I am mulling around in my head is a distributed multi player Rock/Paper/Scissors game where each player can play x number of hands concurrently. Maybe make it all computer generated?
Have you found out now? Anyway, I won't let you struggle more :-) The `switch` compares the value in `thousand`, an integer which equals to `0`, `1`, `2`, or `3`, to the value presented in the `case` s. So the value presented in the case should be integers matching those values. Therefore, `case 1:` without the single quotes will match, that's the numeric constant `1`; but if you put quotes around it, it becomes a character constant, like `'a'`. A character constant is a number corresponding to the ASCII code of the character: `'a'` is 65, `'1'` is 49, and so on. `1` and `'1'` are different things, and `'1'`'s numerical value is not `1`.
Tip: Use pastebin for more than 5-10 lines of code!
https://en.wikipedia.org/wiki/Internet_Relay_Chat
Wow this looks really nice and clean. I'm pretty new to C and may I ask a question? The size of editor.inputbuffer is 80. So what if u type more than that? I see u have strcpy's to it.
[A snake game](https://github.com/wingerse/snake-sdl) :3 It's pretty messy, coming from OOP land spoiled me. 
That's so cool. Do u have the source code still? 
well im biased towards ppl able to learn by doing but based on and under the reason that there is significant evidence for such so i guess it's not a bias, it's thought/fact/idea based on evidence
yea i beleive i said somewhere here that you cant do a project well without knowing the basics so imma go leran the basics with py
after i learn basics with py somewhere along the way ill check on this source and see if it was actually good for basics i'd still be able to see and understand from a place of not knowing basics so ill be able to value it accuraetely
Thanks for the heads up! Will make an effort to use it from now on.
I use: #if DEBUG // place test function in here #endif It allows me to test static functions and (sometimes but very rarely) internal data structures as well as the actual "black box" API (which is the main point in testing).
A string is just an array of characters with `\0' denoting the end. You should read some tutorials or something like *The C Programming Language*, this is a very basic question with tons of answers on the Internet
I'm not sure what you are imagining `sizeof(&amp;emp[i])` to do ... This is the size of a pointer (likely to be `4` on a 32-bit target and `8` on a 64-bit target). Can you explain your thought process for writing that expression?
You're not wrong, but what I meant was that `'1' != 1`.
Can you wait just use sizeof(int)?
I mostly submitted pull in my favorites packages. My first real project was getting paid! haha
A linked lists lib, not to have the lib (though it will be useful), but just to learn how it works
What did you learn?
He says in the description that he can't use `sizeof()` in the first sentence after his code snippet. Moreover, knowing how many bits it could be using is less helpful than knowing how many it is using.
Yup, I fucking do that all the time and this time I don't have a compiler to save me the embarrassment
Yeah, i think i understand. I will give it a shot tomorrow and hope for the best! Thanks again for your help! 
This has become my go-to hex editor on Linux. The first thing I do on every install is make and install.
Just some basic memory management (malloc calloc realloc) and a bit more about pointers and logic.
Check out [PyCParser](https://github.com/eliben/pycparser)
I think they mean: #include &lt;stdio.h&gt; int main() { printf("Hello, world"); return 0; }
I tried to implement the ordered insertion part and this is what I came up with: node *new = create_node(data); if(new == NULL) { fprintf(stderr, "queueADT::que_create failed to allocate space"); assert(NULL); } node *temp = queue-&gt;head; while(queue-&gt;cmp(new-&gt;data, temp-&gt;data) &gt; 0) { temp = temp-&gt;next; } node *old = temp; temp-&gt;head = new; temp-&gt;head-&gt;next = old; 
&gt; Make certain that the function makes no assumptions about the size of an int I would _not_ take this to mean you can't use `sizeof`. In fact, quite the opposite. I'd interpret it to mean you _should_ use `sizeof` as opposed to hardcoding in any assumptions - e.g. an `int` is 4 bytes. For extra credit - use CHAR_BIT as well. I.e. sizeof(int)*CHAR_BIT is the number of bits in an int. 
I want to have assert() fail. Would that not be the correct way to do that?
Well, it works, but why do you want assert to fail? You already logged the error, why not just `exit(EXIT_FAILURE)`?
&gt; First, I calculate the size of an integer (can't use sizeof()). This is the first sentence after OP's code snippet.
I suppose I could do that lol. Thanks for the suggestion! :) But other than that, do you see an issue with the other stuff? Ever since I added that my program has started to seg fault so I think that I'm doing something wrong (my guess is the part after the while loop).
Pong, using mode 13h in MS-DOS 5.0 The paddles were individually blitted as straight pixel lines. The ball "bouncing" was dx = -dx and dy = -dy I had to write it on a school computer at lunch time because I didn't own a compiler at home. I used Borland Turbo C.
Are you serious? hex editors are very useful for learn about formats, and finding bugs in things that manipulate I/O.
Nice! Did you publish it anywhere or do you have the code available? I'd love to study what you wrote
Try this: node *temp = queue-&gt;head, *old; while(queue-&gt;cmp(new-&gt;data, temp-&gt;data) &gt; 0) { old = temp; temp = temp-&gt;next; } old-&gt;next = new; new-&gt;next = temp; It may also be worthwhile to program in a means to ensure the `while` exits once it's progressed over the entire queue.
Unfortunately no - it was over 20 years ago now lol. But there's plenty of examples for coding pong in C found on the web - and probably ones that don't require you to make your own putpixel function.
A program to interface a UNIX box with Ericsson MD-110 PABXs.
I started in Borland Turbo C++ on MS-DOS 6.2. My first real project was a side-scrolling (well, paging - it didn't scroll) helicopter game, based on something I'd started on the Commodore 128, and I used sprites I'd drawn on graph paper. My physics were about as advanced as your Pong. I was also proud of my fireworks demo. It ran in 640x480 with 16 colors, and did pretty nice fireworks bursts. It took just a little more arithmetic for the gravity and drag.
The author is trying to teach you bitwise operators. there are 2 classes of operators, logical, and bitwise. logical operators generally use 2 of the same symbol (for example `||` being the logical OR, `&amp;&amp;` being the logical AND, etc) while bitwise operators use just one copy of the symbol, for example a bitwise AND is `&amp;`, while a bitwise OR is `|` You can read more just by searching "bitwise operators in C" in duck duck go.
It depends on the source and destination. if you're trying to get input from a user check out `scanf` if you're trying to output a string to a user check out `printf` if you're trying to convert a variable to a string check out `ftoa`. if you're trying to convert a string to a variable check out `atof` If you're trying to convert a variable to a string at compile time, well, you're gonna have to write a macro for that. 
Two separate, but related, C programs for a battery tester. One was written for a PIC processor to apply a load to a battery and measure the resistance and transmit that information out via a serial interface. The other C program would take in the raw data and process it so it could be read by a human.
I suspect you're likely inserting into an empty queue, so the while loop never triggers and `old` is still uninitialized. I tried to hint at this being a serious design flaw at the end of my last post. Maybe try a `do ... while` instead of a `while`. I'm sorry I can't help more but I'm running on 2 hours of sleep, and I don't want to rob you of an educational experience.
Given that both TCP and UDP headers have variable length options I’d like to see a single self contained structure declaration that could deal with all the permutations and alignment constraints for field level access in actual C. I’m also curious how you define a cube as six squares in the same plane. Even in three dimensions a cube had 8 vertices, not 24 so you lose space and risk inconsistency with data being replicated three times. Even with 8 verticies there is still some work involved to insure they actually form a cube. As for OP’s question, the issues of partitioning and organizing both code and data is something people in the field (should) spend their lives refining. The “point” examples people have been using is a way of conveniently expressing a concept called “point.” Over time you’ll discover operations on a “point” such as rotation, translation and scaling. You may think for those operations you could pass the individual x and y values to each function each time, and write more code to take the resulting x and y values and store them in your “flat” struct. As the concepts become more complex and you have a struct with 10 values passing and returning each individual value becomes more cumbersome and more fragile - if the struct ever changes every function will need to be individually changed to take the new value and every caller must be rewritten to pass the new value. If you keep everything in a struct it becomes much easiler to manage. The harder question as you learn about “pointers” is “when do I put an entire struct inside another struct instead of using a pointer to a struct inside another struct?” As a US based example, you might have a “contact” struct with a “phone_number” struct with fields for area code, exchange code and line number. In 1970 you might have embedded a phone_number struct directly in a “contact” struct and that would work for most people. Then fax machines and cell phones became common and you have no way of associating more than one “phone_number” with a “contact.” Your concept of “phone_number” would also have to be extended to include the type of phone number which is why *under some circumstances* it can be better to describe a concept with a struct even if it only starts with a single char array for the whole phone number. I don’t know where the OP is yet but it would help to study the generic concept of “data structures” (lists, trees, etc... which are often implemented in C with structs and pointers) and how you organize data will become more clear over time. 
&gt; Given that both TCP and UDP headers have variable length options I’d like to see a single self contained structure declaration that could deal with all the permutations and alignment constraints for field level access in actual C. One doesn't need a general purpose solution all the time. I've written enough network code that didn't need any variation of the options for our needs. More importantly, it was an example off of the top of my head. Relax. &gt; I’m also curious how you define a cube as six squares in the same plane. Even in three dimensions a cube had 8 vertices, not 24 so you lose space and risk inconsistency with data being replicated three times. Even with 8 verticies there is still some work involved to insure they actually form a cube. Again, it's an example off the top of my head (based on someone else's example). Relax. Examples don't need to be ideally optimized or ideal in all cases. They just need to be examples.
void my\_putchar\(char c\), a function that print a char using write. It was my first ever exercise of C.
Not as great as most other posts here, but my first not "Hello World" programm was TIC TAC TOE for the commandline. It was nothing special and the code was messy but at that time i was so happy i made anythig useable. Since then we got into firmware programming on very low level microcontroller at school. Yesterday I wrote a programm on a 8-Bit chip that calculates the speed from a GO-Kart for my final highschool project: www.greenberrykart.at (website is german but you might be able to translate it with google translater etc. )
Very very basic: Print a 3x3 matrix where in every field is a number (1-9). Than under the matrix was a text like "Player X choose a number". After the imput it would check if Player X won and if not it would print the matrix again but with the choosen number replaced by an X. 
Yes ist was great. AI is kinda tricky, because there are algorithms so that the AI would never loose. This would than frustrate the user. On the other hand if you make the AI random it might be too easy. After all making a not too easy and not too hard AI souds like a fun challenge :)
Of course, maybe even having an option to select AI difficulty?
I create a similar solution. I made a software renderer in plain C and got a very hard to find bug in my mathematics. After a few looks i found a python framework called Cython. With this Framework a created a wrapper for my renderer. So i could easy interact with my existing lib and found some bugs. Maybe you should take a look if it could work for you too: http://docs.cython.org/en/latest/index.html http://docs.cython.org/en/latest/src/userguide/external_C_code.html http://docs.cython.org/en/latest/src/userguide/wrapping_CPlusPlus.html =&gt; Create Cython wrapper class The last link is useful because it decripes the class or struct wrapping around a python class.It works for plain c structs too. Good luck :)
XML-parser.
very basic software renderer
Try practicing a lot and see if it goes better. We have too little information to give you any other advice than practicing 
In your `queue_remove`, do you want to free a `node` inside this function or outside of this function? What is the return type `void *` for?
I did it for a couple of reasons: 1. I missed an interactive hex editor 2. I owed it to myself to finally learn C well (to improve myself, indeed) 3. When I need to read C code, I want to understand what is exactly going on. 4. Maybe I want to contribute to the kernel someday :) I don't even know where I got the idea from. I remember seeing antirez's Kilo editor, and got inspired somehow I suppose. Anyway, it all started with a tiny bit of prototyping code, and grew from that :)
If you write c every day there is no way you can not learn it.
I never use `strcpy` but `strncpy` to prevent overflows. You'll see that there's a safety guard [in editor.c on line 1033](https://github.com/krpors/hx/blob/develop/editor.c#L1033). Now that I take a closer look, I use `INPUT_BUF_SIZE` and `sizeof(e-&gt;inputbuffer)` interchangeably... That's a bit off, I suppose. Maybe I'll fix that later :)
I know the feeling. I'm coming from OOP myself, and I wanted to tackle every problem in C using the same paradigm... Which did not always work out too well. I really had to think the "C-way" instead.
- [Simple Programming Problems](https://adriann.github.io/programming_problems.html) - [Beginner Projects](https://github.com/jorgegonzalez/beginner-projects) - [Exercism - C track](http://exercism.io/languages/c/about)
Your friends are right. Practice. A lot. Like hours every day. 
it is relatively sane, pretty clever, a little unclear (takes a couple of readings) but i like it. 
This looks pretty readable to me, but what happens if the first and last characters aren't equal? I haven't tested this but it seems that it will skip over the first and last characters no mapper what.
Ouch! I moved the test above advancing the pointers, I have a feeling the test suite for this one wasn't very comprehensive because that definitely should have been caught. Yeah, I found a few more bugs too, but I was more concerned about the readability since no one else on this site seems to be submitting code like this.
Very embarrassing, I was trusting the test suite on the site which is usually hundreds of tests but in this case was... 3. 3 tests. I've fixed that now.
Not sane: one statement per line. You have cleverly hidden buffer overflows and underflows. while( *fwd != '\0' &amp;&amp; ! isalpha( *fwd ) ){ fwd ++; } while( rev &gt;= fwd &amp;&amp; ! isalpha( *rev ) ){ rev --; }
Still looks pretty readable to me :)
I would suggest you find a tutor. Being gifted at math, my teachers often assigned me to tutor other students who were having difficulties. From that experience, I can say people that have trouble learning a subject each has their own unique problem. Finding the best solution takes time and a hands-on approach. You need to find a good tutor and keep trying until something clicks. This may take a number of sessions, so don't be discourage if things don't go well at first.
&gt; Now this is perfectly clear to me, but is it? https://en.wikipedia.org/wiki/KISS_principle For a small code piece like this, it shouldn't really matter. But for bigger projects, I will not be in favor of code which cannot be read like a novel (slight exaggeration, but you get the point). 
**KISS principle** KISS is an acronym for "Keep it simple, stupid" as a design principle noted by the U.S. Navy in 1960. The KISS principle states that most systems work best if they are kept simple rather than made complicated; therefore simplicity should be a key goal in design and unnecessary complexity should be avoided. The phrase has been associated with aircraft engineer Kelly Johnson (1910–1990). The term "KISS principle" was in popular use by 1970. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Take a test to identify your learning style. This will tell you the best way to study the material. You might also ask your teacher to go over the exam with you one-on-one so you understand where you are deficient. 
Your updated code will still overrun a string of all spaces.
I would return a bool, not an int... and I wouldn't use pointer arthimetic, I'd just treat the string as an array, it clutters up the meaning.
I have not coded C in 10 years, and given the name and the code structure, it was immediately clear to me. (I didn't check for any bugs though...)
First serious one was CORDIC on a Texas DSP. See: https://en.wikipedia.org/wiki/CORDIC
&gt; Isn't it necessary to store combinations or have some strategy for remembering the combinations during the heuristic search? Yes indeed. But if you use IDA\*, you don't need to store more than a couple combinations at any point in time. &gt; Otherwise, how would I obtain the solution to the puzzle once the solved state is reached from the scrambled state? In my software, I store what moves I did to get to the solved state. Simply output the corresponding inverse moves.
I guess I need to look more into what IDA* is. I thought it was just A*, but with a component similar to the depth-limit in iterative deepening depth-first search. A* would require a large amount of memory, correct? 
I'm not sure which project was actually my _very_ first, but early on, I learned C using Lightspeed C for Macintosh, later renamed to THINK C. My earliest projects involved writing plug-ins for HyperCard, called XCMDs (external commands). I also wrote some small Macintosh applications. I turned in some assignments for an algorithms class as full-blown Macintosh applications with GUIs. This was a bit of a problem as sometimes they were really, really late as I spent a lot of more time wrestling with getting the GUI part working than the algorithm part :) There were other projects and eventually during an internship year after college I was writing all kinds of things including an application to edit version resources and various plug-ins and extensions used in the computer labs. Most of this stuff has survived, at least the source code, although some files I managed to preserve that relied on old MacOS resource forks got screwed up and lost the resource forks when I used the MacOS X cp command to copy them. (I assumed the versions of the regular command line utilities in MacOS X would have been tweaked to know how to manage Macintosh files given that the OS supported Macintosh file systems -- but no so much, you had to use some special Mac-specific commands).
The members of struct _ticket aren't known in main.c.
Your struct definition needs to go in the header file, not the .c file, if you want to access its contents in that manner. Also, you need a semicolon at the end of the struct definition.
Let me try to elaborate on this a bit... The layout of the structure is not known to main.c, because it is not in a header that main.c includes. Until the linker stage, the contents of main.c and the other .c file are effectively independent of one another. So it becomes impossible to distinguish the contents, names of fields, or even the total size of the structure in main.c without that information. If you put the struct in the header, then it is accessible to both .c files, as long as they both include that header.
Looks like you need to know binary representation for this. Has your teacher taught you things liks 0b10000000 = 0x80? Basically if you have a number like 0b10000010 (or 130 in decimal) and you want to get the lowest three bits, then you use the &amp; operator. So ```0b10000010 &amp; 0b111 = 0x010``` or ```130 &amp; 7 = 2```.
That's a part of the process.
Indexing old Walnut Creek Shareware CD-ROMs so our custom RIPScript BBS could integrate them into the menu system. Good old 10BaseT co-ax cables and Borland C in DOS. Suck it, Younglings!
&gt; Can someone please help me debug? What tests have you run? What bugs have you found? To get you started, what does `char noun3[] = ("noun");` do exactly? And then what does `scanf("%s", &amp;noun3);` do to it?
this is a madlib. First the value is set to "noun", then it is reset by the user to become a noun. scanf makes the user input a noun to replace the stock "noun" with any noun you want.
&gt; any noun you want. How much room is there in the array `noun3` if is initialised with `noun3[] = "noun"; Test what will happens if I enter "Lumberjack" for the 3rd noun?
cant test now, but noun is four letters. would the result be "lumb"?
No, the scanf call will continue writing "rJack" past the end of the array, and anything could happen. A likely symptom is that one of the other strings will be corrupted. But you've found 1 bug - your strings aren't long enough for input the user is likely to enter. Another test case - ignoring the size issue, what happens if I enter "Empire State Building" for the 1st noun?
well, it was a good guess. But simple intuition has it's limits.
Yes, it was a good guess, and what actually happens doesn't matter too much. Recognising that the array is too small is the important bit.
Where should I even start... First and foremost, what you are trying to do with your strings is false. Think of char* var = "..." as static memory allocated by the compiler depending on your string with a '\0' or null terminator at the end! It don't really know how this works behind the scenes, and I'd be thankful if anybody explained, but the compiler does it automatically for you! On the other hand, char ..[n] is just a buffer that is n characters long, it's not string by default, and really it doesn't represent anything other than a block of memory! As such: char* string = "Hello"; char string2[] = {"H", "e", "l", "l", "o", "\0"}; char string3[6] \\ Where (n = 6) is the number of characters + 1 for the null terminator strcpy(string3, "Hello"); // http://www.cplusplus.com/reference/cstring/strcpy/ All these do the same! What makes a string in C is the null terminator, and If you don't add it in a buffer, the printf will keep reading until it encounters one, and you might read garbage or data after what you want... As such, scanf() demands a buffer that is big enough for the function to copy the string you input in... If you just pass a: char adj1[] = {'a', 'd', 'j','e','c','t','i','v','e','\0'}; adj1, you are passing a pointer to the first character... so scanf starts writing at a[0], but if the word you are inputting is bigger than "adjective", you will start overwriting data outside your buffer, and you will corrupt your memory! Here &amp;adj1 is passing a char**, since adj1 is by default though of as a char* All arrays are pointers by reference, as such you could also do &amp;adj1[0] which would be the same as adj1 The good way to do it, and the way I would: char adj[64]; // Just give the buffer a size that is big enough for anything ... stcpy(adj, "&lt;adjective&gt;"); /* I don't initialise because strcpy does the same as {...} */ printf("adjective:\n"); scanf("%64s", adj); /* %64s here means that I don't want to read more than 64 characters */ This is the my way of doing it, feel free to check it out! #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { printf("Welcome to the MadLib!\n"); char str[8][32]; // 3 Buffers of 32 characters each! strncpy(str[0], "adjective", 10); strncpy(str[1], "adjective", 10); strncpy(str[2], "adjective", 10); // http://www.cplusplus.com/reference/cstring/strncpy/ // Passing the numbers of characters I want to copy including null... strncpy(str[3], "noun", 5); strncpy(str[4], "noun", 5); strncpy(str[5], "noun", 5); strncpy(str[6], "adverb", 7); strncpy(str[7], "bodypart", 9); int i; for(i = 0; i &lt; 8; ++i) { printf("%s\n", str[i]); scanf("%s", str[i]); } printf("I'll never forget my first time going into the bar.It was %s and %s. It smelled like %s. I saw a %s person who offered me a drink on the house. I got the drink menu and ordered a %s. I drank it %s. After I got thouroughly %s faced, I puked up my %s. That sucks.\n", str[0], str[1], str[3], str[2], str[4], str[6], str[5], str[7]); /* I also added one last adjective after the first one, since I noticed you didn't use your thrid! */ return 0; }
&gt; On the other hand, char ..[n] is just a buffer that is n characters long, it's not string by default, and really it doesn't represent anything other than a block of memory! so then how do I make a real string? the way you say 'int variable = 666' you could say 'str variable = "devil"'
To respond to your edit. You don't need to initialise the buffer with anything. char noun1[50]; has room for 49 characters and the nul terminator. And you don't need to count anything to know how big the buffer is - you just look at the number. Note that this doesn't stop scanf overwriting the end. You can do scanf("%50s", noun1) to enforce a limit. 
&gt; All these do the same! They don't to the same and the distinction is very important for this particular program. char *word1 = "word1"; char word2[] = "word2"; The first is better written const char *word1 = "word1"; and, as you said, makes word1 point to a statically allocated string that must not, and probably cannot, be changed. If this program used that form then the scanf may crash trying to write over readonly memory. The second form char word2[] = "word2"; creates a local variable of a big enough size and initialises it, at runtime, with the data. It is a writable array. 
I would determine the length of the string, either using `strlen()` or by looping over the string until you get to the '\0' terminator. I would then use the string length and either array addressing or pointer arithmetic in a loop compare characters at each end of the string. If I found two chars that did not match I would return 0. If, on the other hand, the loop goes all the way to completion, I would return 1. 
Your variable mark is of type int, but when you call scanf you use "%f" which is for floats, so either change it to %d or change mark to a float
&gt; school assignment was to write a mad-lib in javascript. I wrote one in C. Maybe you should just write it in JavaScript?
No problem, glad you got it working!
Put a newline in the print that's in the while
Next time, put 4 spaces in front of each code line when you post: int mark; printf("please input a mark between 0 and 80\n"); scanf("%f",&amp;mark); printf("%f",mark); while(mark &gt;= 0||mark &lt;= 80){ ///not sure if such || work in C/// printf("%f",mark/80*100); break; }
Pretty sure this belongs in r/wtf
Not the original problem, for he runs the loop only once because of the `break;`. In the `printf()` before the loop, however, yes. But maybe he also forgot to enter double newlines in the reddit message, so we cannot say if what we see here is what he saw and wanted to type. 
Here's everything: https://pastebin.com/ySKRKnam
Sorry 4chan and quora have better code comfort
queue or queue-&gt;head is a null pointer for some reason.
I think this has to do with you reinterpreting mark, an int, as a float. The underlying bit fields are not of equal size.
The “int” thing mentioned by /r/WeAreAsUsefulAsDirt is point 1. -1 passes the &lt;=80 test but fails the &gt;=0 test, and 81 passes the &gt;=0 test but fails the &lt;=80 test. If you use || (OR) then every actual number will pass one test OR the other and the code inside the loop will always execute. I’m guessing you want both conditions to be true which means you’ll neeed to use &amp;&amp; which means AND - both the &gt;=0 AND &lt;=80 test have to be true at the same time. Third, since the loop only executes 0 or 1 times, use an “if” statement, not a “while” and “break.” That’s what “if” is for, and you can even add an “else printf(“%f is not between 0 and 80\n”, mark);” to let the user know why they didn’t get the computed value they were expecting. Fourth, adding a newline (\\n) to your other printfs will keep everything from appearing as one long string of digits and decimal points.
`\r` might be useful if your "animation" is on a single line.
@jedwardsol The second form is false, as in the second form you are assigning to an array of characters -- as such, you should follow this form, type word2[] = {element1, element2, element3, ...} or char word2[] = {'w', 'o','r','d','2','\0'}; where '.' is a character... @massivebrain It's the null character, or the '\0', that is why I add it at the end of every one of my buffers, see word2[] above... when you do char* word2 = "word2", the compiler takes care of figuring out your string and translates it to the characters 'w', 'o','r','d','2','\0', if you read the descriptions of most of the str... functions, they all stop at the null terminator, since it is expected of a char* to have one as it announces the end of the string! strings don't exist in C, C offers you the weird static char* thing instead, I call it a string, but it's not even technically one in regards of other languages such as java or golang, it's just a buffer of memory with a '\0' character at the end... 
A [tetris clone](https://github.com/MarcoLucidi01/tetris_clone).
That was literally it lol. This is exactly why I come here, because I spend hours making many changes to my code and all that was wrong was a single line. Thank you so much! :) There's no leaks and it seems to pass the tests that I have access to. It seems to take awhile with the larger ones... did you notice any parts that could be made more efficient? Or do you have any suggestions for how I could determine any parts that could be made simpler? I feel like a majority of what I do is overly complex, but I'm trying to learn how to refactor my code so it's cleaner and more efficient.
This is no place for such filthy, promiscuous heathens. Have you tried asking around /r/cpp?
This is an offbeat question
I don't think you can with that approach. Even if you track more stuff like file owner and timestamps, those can change without deleting the file and creating a new one with the same name using the same inode. If using linux, maybe a daemon using inotify to watch all the directories in a tree for IN_DELETE and IN_CREATE events (And all files for IN_ATTRIB and IN_MODIFY) and updating the database in realtime as changes happen?
You could track the ctime which is unchangeable. However, you do need a file system with sufficiently high precision for this to work.
The post has been edited since my comment. 
Im having trouble with looping and making arrays. I feel like they are the backbone of c programming
Oh indeed, I confused this with BSD's birth time. Though, the ctime should be good enough.
Various other suggestions: Don’t post a screenshot of your code, post actual code. In general don’t use names starting with underscores like `_ticket`; they’re reserved for platform, compiler, and language use. Single underscores are reserved for language use when `_Like_this` (e.g., `_Bool` or `_Generic`), and they’re generally reserved for platform or compiler use `_like_this` (e.g., `_exit` or `_flushlbf`) or `_LIKE_THIS` (e.g., `_MSC_VER` or `_POSIX_C_SOURCE`). Also, I can’t tell if you have a `typedef _ticket *ticket` (don’t hide non-opaque pointers in typedefs) somewhere in `Carros.h` but if you don’t, you’ve got a few more problems along those lines—most of your `ticket` type references should be `struct _ticket *`, or you should `typedef struct ticket ticket` and use that instead. Don’t hide an important aspect of the type behind a typedef; you’ll want to be able to do pointer-y things with it, so use `struct ticket *` explicitly. (Only if you’re doing some sort of opaque handle should you hide pointers behind `typedef`.) It’s also common to mark typenames specially so you’re clearer on how they can be used and they don’t look like mistakes; e.g., `typedef struct Ticket_s Ticket;`. You can’t assign `m` to `t-&gt;mat` on line 16 because `mat` is an array. I’m guessing you’d want to `str[n]cpy` or `memcpy` from `m` into `t-&gt;mat`, though `const char *m` would be more appropriate for the parameter type to indicate how that data’ll be used. `exit_` is a really bad name for a function, both because of the trailing underscore and the fact that it looks just like the `exit`, `_exit`, `_Exit`, and `atexit` functions in POSIX and/or stdlib but doesn’t actually have anything to do with exiting the program. In situations like this where there’re a bunch of functions related to a single type or purpose, it’s common to give everything a single prefix and its own header+source files, so you’d end up with a `ticket.h` like #ifndef carros__ticket_h__INCLUDED__ #define carros__ticket_h__INCLUDED__ 1 typedef struct ticket {...} ticket; ticket *ticket_create(const char *m, int he, int me); void ticket_destroy(ticket *); void ticket_finish(ticket *, int hs, int ms); int ticket_calc(const ticket *); #endif /* ndef carros__ticket_h__INCLUDED__ */ and then (a.) it’s clear that everything’s related and how, and (b.) the `ticket *` parameter is in a consistent position. Oftentimes you’ll want to opt for void ticket_init(ticket *, const char *m, int he, int me); void ticket_deinit(ticket *); instead of `create` and `destroy`; this allows the caller to choose how they want `ticket` allocated. They can embed it in some other structure/union, or create an `auto`/`static`/global variable for it, or they can do their own `malloc` and `free`. And of course, somebody noted the need for `;` after a struct definition/declaration. `struct [name] {...}` and `struct name` are types just like `int`, and can even appear in more complex types like `struct a /{...} (*fn)(struct b {...}[])`, not that you’d want to go quite that far. The final semicolon stops the compiler from looking for a variable name afterwards.
If the point of the program is to determine if a _string_ is a palindrome, why are you skipping over non- alpha characters? I personally would consider the non-alpha characters as part of the string. So, to my mind 'a b c cba' is not a palindrome. On the other hand, 'a b c c b a' and 'abccba' both are. I find the code below, which is essential what you posted, to be more straight forward: int is_palindrome(char *s) { int fwd = 0; int rev = strlen(s) - 1; if(rev &lt; 0) { // empty string return 1; } while(fwd &gt; rev) { if(s[fwd] != s[rev]) { // or *(s + fwd) != *(s + rev) return 0; } fwd++; rev--; } return 1; } 
I don't know what you mean exactly, but I'll guess: Use `scanf` to read a value, then check the value itself after the fact, before you try to assign it somewhere else. somevar = -1; do { scanf( "%d", &amp;somevar ); } while( somevar &lt; 0 || somevar &gt; 100 );
That didn't go very well did it
It wasn't my code. I don't see the point of arguing over what counts as a palindrome. It has its definition and it makes sense and it's clear what it is. 
I like your naming convention, do you have some naming convention when writing functions for structures ?
Not really. I don't use any specific naming convention for functions that operate on structures. Typically for function names I use the following rules: Name should be indicative of what function does. I use underscore to separate words. Function will be marked static if it is not exposed to external files. Any utility/helper functions that are mainly written for helping other functions and might be called from many functions are usually in a separate file labeled "module name utility.c" and the function will have util in their names to Indicate they are helper. Call back functions will have cb in their name. All functions will have comments explaining input, output and functionality. 
Thank you for your reply :)
Open it in a text editor and check the header is correct
Shouldn't there be some newlines in there? I think you should add "\n" to the end of each of the printf calls.
what should the header be? When I open it in a text editor I get [this](https://pastebin.com/fnGi0uZZ)
http://netpbm.sourceforge.net/doc/ppm.html describes the format in detail
I still get an error that my file is corrupted after I try to open it, [new](https://pastebin.com/Nn4wgTnt)
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://pastebin.com/Nn4wgTnt) - Previous text "new" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Adding the whitespace to the header was correct. But there mustn't be whitespace between the pixels
I would jump ship from JS, too, if I had the option. I'm curious in what class JS and C are interchangeable, though.
Yes. `strlen` returns the number of characters it's reached before encountering the nul.
Excellent! thank you. Second quick question if you don't mind. I am trying to understand what is defined as an element in C. How many elements are in str? is it 1 element or 2 or 3?
`str` is an array of 4 `char`s, 'a', 'b', 'c', and '\0'.
Hmm okay. Would that mean that every array of chars has '/0' at the end? 
Could, but not necessarily: char str[3] = "abc"; This is a valid initialization, but it does not allocate space for, nor assign the nul character, because we've specified the size. Also: char str[5] = "abc"; Also valid, and `str[3]` is your nul, and `str[4]` is also going to be nul. 
No, you can create an array like this: char notstr[] = {'a', 'b', 'c'}; Which creates an array of 3 `char`s and does not contain the nul terminator. However, strings in C are represented with an array of `char`s ending in the nul terminator.
slight correction, the int value that pValue points to is returned, not the actual pointer. I believe the memory chunk pointed to by pValue is leaked and never freed.
Oh yeah, you're correct. Missed the *. OP was talking about returning a pointer so he probably intended to return the pointer instead of dereferencing it. As it stands that memory is definitely leaked.
Generally if a function is returning a pointer the calling function, in this case your main, is responsible for calling free(). For example a program might look somthing like this: char* return_pointer_func() { char *tmp = malloc(sizeof(char)); return tmp; } int main() { char *myPointer; myPointer = return_pointer_func() //do things with pointer free(myPointer); } 
Thanks for your replies. I see how my else block is completely useless. I think I was grasping at straws at that point. I was trying to think how I could reuse the function to clear the memory. I'll try and see if I can clean up main and rework the problem. Thanks again!
Not to split hairs, but I wasn't arguing over what a palindrome is - it is more what a string is.
A string is a sequence of characters. There's no argument to be had there. Your palindrome definition, on the other hand, would lead to famous strings like "A Man, A Plan, A Canal-Panama!" and "Madam In Eden, I’m Adam" being declared non-palindromes.
 while(mark &gt;= 0||mark &lt;= 80) Plot that out on a number line. The set **(-∞,80] U [0,∞)** is the set of all real numbers, so that will always be true. I think you mean to use &amp;&amp; instead, while it's greater than equal to zero _and_ less than or equal to 80.
Yes, however the array is actually 4 elements long since string literals also produce a nul byte.
MODIFIED is about right, since it’s pretty common to do updates via something like generate &gt;new_file &amp;&amp; mv -f new_file old_file which would delete old_file first, then relink or copy new_file over to it. Otherwise, most UNIX OSes have a means of watching directories for events (e.g., Linux’s inotify, which obsoletes dnotify) but that’s typically only possible if you have a continuously live dæmon holding every single subdirectory open. You’re also not going to find an especially portable solution along these lines. Even less portably, you might be able to inspect things like ext3 journals to figure out what’s changed, but that’s probably overkill for something like this. Or you could implement your own filesystem overlay with something like FUSE and log events.
I have no idea what you are trying to accomplish, but here's a video that might motivate you https://www.youtube.com/watch?v=qzIwn5jvQyU
Line 41 does not have a minus, you have "_" at the end of your line
&gt; there are 2 classes of operators, logical, and bitwise. and relational
/r/TotallyNotRobots
Bools are ints Arrays are pointers 
Why is the base 10, if the string is in base 2?
You are so right. However, now I get the decimal representation of the binary. A35 is now printed as 2147483647. Is there a way to represent keep this as binary? I'm sorry I'm not articulate enough to thoughtfully describe what I want when it comes to ints and decimal.
linkedlist for the buttons. clear it when you lose a round. it should only need 4 states per node, but I'm not the one to talk about efficiency for such things(in that I don't know how ) I don't know off-hand how to output C++ to LCD. lights, unless you already have a CPLD or something... kind of depends on your hardware environment your in game loop should look something like loop(){ if(testingPlayer){ comparePlayerChoiceToThatStoredInLinkedList(); //should allow some time for button release instead of rapid double marking } else if(displayingNextCombination){ node * nodePtr = list.head; while(nodePtr){ displayToLCD(nodePtr.color); nodePtr = nodePtr-&gt;next; } } } there's more than this but I'm tired. let me know if you're stuck somewhere
No, bools are chars, not ints.
Good point, tho I think they're technically a subset of logical operators.
Indeed, thanks for pointing out my mistake.
Wrong sub. You're looking for /r/CppForBeginners 
Files are unique in their paths, not their i-nodes. And if a file is deleted and recreated, it is modified.
C++ != C. moron
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
Please be civil.
I will... blocked!
Nice. Good luck with that. Probably making a lot more work for yourself, but I've always found C more satisfying.
To test if your solution works or not you can use valgrind on linux. Not sure about other platforms. P.S: Compiling in debug mode using -g flag will help. Then valgrind --leak-check=full ./program should show you if there are any leaks.
Maybe he could ask Ninja Brian?
well, I can't learn to be the next jailbreak dev without c
Okay. Thank you!
The printf statement is printing the address of variable 'a', which is unwanted according to the logic behind the code.
 printf("Here's a list of things that Brian like to suck:\n"); for(i = 0; i &lt; 24; i++) { printf("dick\n"); } printf("balls!\n"); 
Hmmm... So, what should I put so that it will output the value of 'a', instead?
Just write 'a' instead of '&amp;a'. And it will print the value of variable 'a'.
Oh, wow. I feel ashamed of posting this. It's very simple. Thank you!
Basically rather than storing the string length and the string itself in separate memory blocks, store them in the same block. Currently you have something like this: +----------------------+ | size | r_size | data | +-------------------|--+ v +---------------+ | Hello world\0 | +---------------+ But this would be more efficient: +-------------------------------+ | size | r_size | Hello world\0 | +-------------------------------+ 
If the input us a grid, you might end up building the tree (and perhaps pruning it) as you go. Otherwise your plan seems sound. Since you know the location of the exit, A* search would be a likely improvement over BFS.
Yeah, the input is a grid (either entered from the terminal or read from a file). It is in fact the shortest path. Would that change much?
Non-Mobile link: https://en.wikipedia.org/wiki/A *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^161931
Yep, [your are right](https://en.wikipedia.org/wiki/Palindrome) and I am wrong. I solved this problem sometime ago and it passed all of the test cases, so I didn't really do much research on what is and is not considered a palindrome.
&gt; If I want to make my program run fast and use the least amount of memory possible, would this work? It would. A better approach could perhaps be to implement IDA\* using the Manhatten distance as a heuristic. 
Okay cool. When you say that in this case it's necessary to use it or do you think there would be a better alternative that isn't necessarily more efficient, but simpler? I personally think that imagining the problem this way is easier to understand. In general there seems to be a tendency to go in the more complex direction, which I'm not sure is a good or bad thing.
Thanks for this. I was able to understand better what to do. I believe I just needed to declare the pointer as a global variable and then i could free it from main whilst allocating from the function. I think. This is what the whole program looks like now: void sum(int userValue, int *pTotal); int getValue (); int *pValue; int main() { int userNum, total = 0, count; int *pTotal = &amp;total, *pUserNum = &amp;userNum; for (count = 0; count &lt; 5; count++) { *pUserNum = getValue(); sum (*pUserNum, &amp;total); free (pValue); } printf("\nThe total is %d", total); _getch(); return 0; } void sum (int userValue, int *pTotal) { *pTotal += userValue; } int getValue () { pValue = (int *)malloc(sizeof(int)); printf ("Enter a number: "); scanf ("%d", pValue); return *pValue; }
You have nothing allocated for `test_ptr`.
quick glance tells me there is a missing semicolon after the first struct. is it intentional?
thank you.
BFS and DFS have, if I recall correctly, the same implementation except for how the intermediate states are handled. Use a queue, you get BFS. Use a stack, you get DFS. You can use the same linked list for the stack or queue - the only difference is which end you remove items from. Consider implementing A* only if you get. BFS/DFS working.
You do not need to use global variables you just need to return pointers from your functions and accept pointers as arguments. So to simplify things if you can return a pointer from getValue() making it look like this (I have made comments on the lines I changed): int* getValue() { int *pValue; //pValue is not a global variable so it needs to be declared pValue = (int *) malloc(sizeof(int)); printf ("Enter a number: "); scanf ("%d", pValue); return pValue; //we need to return the pointer not the value } Similarly sum() can be changed to take in two pointers not just one changing it to: void sum(int *pValue, int *pTotal) { *pTotal += *pValue //Both need to be dereferenced now } And main() just needs to be changed to use the new sum() and getValue(): int main() { int userNum, total = 0, count; int *pTotal = &amp;total, *pUserNum = &amp;userNum; for (count = 0; count &lt; 5; count++) { pUserNum = getValue(); //getValue() now returns a pointer sum (pUserNum, &amp;total); //sum() now accepts two pointers free (pUserNum); //pValue is not a variable in main you need to free pUserNum } printf("\nThe total is %d", total); _getch(); return 0; } I hope this helps.
I'd look at something like this: https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search Given modern hardware 100x100 sounds relatively small so I'd be inclined to just expand on every node with explored neighbors until something touches the end.
**Iterative deepening depth-first search** In computer science, iterative deepening search or more specifically iterative deepening depth-first search (IDS or IDDFS) is a state space/graph search strategy in which a depth-limited version of depth-first search is run repeatedly with increasing depth limits until the goal is found. IDDFS is equivalent to breadth-first search, but uses much less memory; on each iteration, it visits the nodes in the search tree in the same order as depth-first search, but the cumulative order in which nodes are first visited is effectively breadth-first. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Thank you for your response. The problem was with my rkhash_init. I've solved it now!
Yes, absolutely. I have a clearer understanding now, thank you!
exploring a maze is just a search. the difference between BFS and DFS is how you handle decision points. in theory you could make the code so it can do either. i would store the maze in a grid, if that is how it is designed. that way the internal logic will be clear and easy to check. each grid square will need something like exit directions (4 bits) and, probably, a flag indicating whether it has already been visited during the search (another bit). but that requires that adjacent squares by consistent (a square above another where you can go down must also go up). you can remove this redundancy by only storing two sides per square (eg N and E). however, if you're going to use A\* search then you need to pre-process the grid and convert it to a graph (where weights are path lengths). this is significantly more work - i wouldn't bother for a first attempt.
Assuming you're running this in a normal shell, Ctrl-C actually means the SIGINT signal. You need to capture SIGINT (see [signal](https://linux.die.net/man/2/signal)) and then, inside the signal handler, kill your children (see [kill](https://linux.die.net/man/2/kill))
 { OBJ_T node; //node = malloc(sizeof(OBJ_T)); That's not a pointer. It should be, and you should be mallocing there.
Thanks
The best way to start would be to go to /r/cpp_questions and ask your question there as this subreddit is about C, not C++. I've removed your post as it is off topic, but feel free to repost to /r/cpp_questions!
Hi. You may want to try /r/CPP if your looking for C++ info. This sub discusses C. Yes it can be confusing as people mix up C and C++ all the time. If Valve and game programming is what you want the other sub may be better suited for you. Good luck.
Assuming that you want to start with C++ and you are a beginner, check this book: https://www.amazon.com/Programming-Principles-Practice-Using-2nd/dp/0321992784/ All you need is a C++ compiler, a text editor and a lot of patience. BTW, C and C++ are *different* languages today and /r/c_programming is not the best place to ask advice about C++.
'node' should be of type 'OBJ_T *' though, right?
Yes, that's what I mean by it isn't a pointer and needing to malloc.
The name of a function is a pointer to it, similar to how array names work as pointers. If you want to call a function (make it happen), you need to call it and provide any arguments that are required: printf( "%f\n", add( 2.0, 1.5 ) ); Alternately you could have done something like this: float a = add( 2.0, 1.5 ); printf( "%f\n", a ); 
18 doesn't go evenly into 100, so you could run into problems if you put multiple in that memory location (and I can't remember if pointer addition when it comes to structs has alignment concerns or not). But you aren't doing that. Is this right? I think you want the paren's around the pp and not the addition. int* iptr = (intI)(pp+1); 
I need to learn how to read. 
You are violating strict aliasing, yes. From C11: Allocated objects have no declared type [...] If a value is stored into an object having no declared type through an lvalue having a type that is not a character type, then the type of the lvalue becomes the effective type of the object for that access and for subsequent accesses that do not modify the stored value. This means that your 100 allocated bytes turn into a storage of type `person_t` as soon as you store 99 to the *age* field. The subsequent cast to an *int* pointer breaks strict aliasing.
Oops sorry, I've edited this line, it's: int* iptr = (intI)(pp+1); I always thought the point of void* was to be casted to another type as needed though that's what confuses me with the strict aliasing rule. 
Hum interesting, that's not where I thought the strict aliasing violation violation was since p and iptr are not pointing to the same address. Can you confirm that you took that into consideration? If so, my understanding of strict aliasing was completely wrong.
It's pre-ANSI C (very old).
It's the K&amp;R syntax from back when Kernighan and Ritchie published the [first book](https://en.wikipedia.org/wiki/C_(programming_language)#K&amp;R_C) describing C
It's an old style syntax of pre-ANSI (K&amp;R) C. 
This code is still valid, the compiler must accept it in standard mode. Perhaps you also had some other mistakes (or perhaps you set it to treat warnings as errors)
I’m not much of a C language lawyer, so I could be wrong, but since a pointer to a struct is completely compatible with and convertible to and from a pointer to the first element of the struct (6.7.2.1) this doesn’t seem to violate strict aliasing (6.5/7). 
Hm. When thinking it through an extra five times I'm not so sure any more. The *(person_p\*)* cast is clearly not a violation, since you can change the type of allocated memory by storing new data in them (as long as you no longer access it through the old pointer). You're having two objects of different type in the same allocated memory however, which e.g. [this](https://stackoverflow.com/questions/23582544/strict-aliasing-and-memory-locations/23713047#23713047) person on SO argues is totally okay.
Try /r/CSharp. This subreddit is for the C programming language which has significant differences from C#.
&gt; Oops sorry, I've edited this line, it's: &gt; &gt; ```int* iptr = (int*)(pp+1);``` Actually, what I was thinking was incorrect anyhow, so ignore that comment. 
&gt; The rule is simple: You may not cast or pass a parameter of a different type unless you cast either to or from a char* or void*. A pointer to a structure object, suitably converted, points to its initial member (or if that member is a bit-field, then to the unit in which it resides), and vice versa. (6.7.2.1). 
Off topic, but `calloc` is a much better habit than `malloc` followed by either `bzero` or `memset`. Also using `strncpy` the way you used it is a questionable pattern, as the code relies on the buffer having been fully zeroed prior to this call; something that happened several lines earlier. 
&gt;The rule is simple: You may not cast or pass a parameter of a different type unless you cast either to or from a char* or void*. The rule is nothing like what you claim. OP's code is correct.
Only retards use that syntax (in the first code example)
Inplicit int was removed in C 2011, AIUI.
Well last time I checked out, there was already some discussions there and community wanted those book recommendations posts to be removed. I gather SE team should have wanted it to stay (to increase view count) but it seems like the community/mods was really sore on deleting that. Personally, I find these dogmatic behaviors of mods/high-rep community on SE very bothersome. 
The code starts with an iteration for rows If it only did that it should indeed be "1 2 3 4 5" But this is not what you do After setting the value of rows, you create a new loop to iterate for digits So inside each row, you do the process again basically this row = 1 row1.digit 1 row1.digit 2 row1.digit 2 row = 2 row2.digit 1 row2.digit 2 row2.digit 3 
Write out the flow on paper. Then it should be clear. Or change printf(“%d”,digit); to printf(“%d, “, digit);
I don't know what standard removed the implicit 'int' part, but I maintain some C99 code that still uses the implicit int type (such as defining variables as "unsigned Foo"). Was it removed after C99?
Reformat please
The funny thing is there is a C++ version of that list and *it even points to the C version*. My guess is some author/publisher got offended and managed to convince the mods to remove the list. That's really a shame on SE.
not sure I see the point of this sorry but if you're doing a game (likely application for needing the state of multiple keys) you'd be using something like GLFW to support OpenGL which will not only do this for you but also do it in a cross platform manner allowing you to take your Linux source code and compile it unmodified (if you know what you're doing!) on some other OS....
Thanks!
Thank you!
Thank you!
it's not for anything that's actually going to be used, rather just for fun and learning :p
By making the it a stack of pointers. Push and pop will work with only the pointers. What they point to is left to the programmer to decide.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
&gt; For example there was a case where we strongly suspected that the author of a C book had added his own book on top of the list. What if some author that was not included/had bad reviews in the list made this post?
 int a = 1; int b = 2; printf("%d\n", a + b);
Just in case someone wants to save the lost list somewhere. https://web.archive.org/web/20180103230717/http://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list
https://hastebin.com/esihacufag.cpp
They never stopped to ask if they should, only if they could.
Python 1:1 equivalent : a = 1 b = 2 print('{}'.format(a + b)) In the C code, "%d" means that you want to interpret the variable as an int. ([Printf format string wikipedia article](https://en.wikipedia.org/wiki/Printf_format_string) for more information) 
Just note it's not as straightforward with strings. You could do printf("%s%s", string1, string2); Or strcat(string1, string2); printf("%s", string1); //string1 will contain original contents PLUS a COPY of string2's contents Note that the 2nd method is unsafe, as if string1 does not point to a region of memory large enough for both string1 AND string2, you will get a bufferoverflow and probably cause a segfault or something silly and undesired. See `strncpy` and the `strn*`family of functions for ones that are safer in that they also accept a maximum number of byte to copy as an argument. 
Why did they use %d for on int? It always make me think double eve. If I know its an int. Itd be like using %b for a float. 
I said "integer", but I'm wrong. It actually stands for "decinal" [Thank ^you ^^stackoverflooooow](https://stackoverflow.com/questions/13409014/why-does-d-stand-for-integer)
Ah this makes more sense.
Cheers
What kinds of "stack" are you using? It will be difficult to give a good answer without knowing that. Are you talking about something like a linked list based? Or more like a large buffer of memory that you add and subtract from the pointer to get to, like what you would do in assembly language?
I have made part of physics engine in C. Unfortunately I haven't finished it or have any plans to work on it in the near future. I'll leave it here just in case someone might be able to learn something from it. I think it only had spheres and planes and some cube physics working. https://github.com/8bitslime/Viscosity
Sadly, C++ is off topic in this subreddit. If you rewrite your code to be in C (e.g. by changing the file extension from `.cpp` to `.c`), it's on topic once again.
In C the format specifier must match the type of the variable. It's undefined behaviour otherwise. It's a misconception that it means to interpret the argument another way.
I've "wrapped" part of bullet physic to give it a C api without dragging in loads of stuff you probably don't want.... https://github.com/chriscamacho/bulletCapi
If you want convenience stick with Python. It's not something C is known for.
Undefined behaviour, because it's not *supposed* to be used like that. But please correct me if I'm wrong : binary is binary, bits are bits, how can you interpret the same binary sequence as 2 different numbers ?
Since you're just reading the entire file into memory all at once you really could replace `process_buffer` with a call to `strtok_r`. Also, the contents of `process_line` could be replaced with a call to `printf` with a `%*s`, but you're going to be replacing this with new code so that probably doesn't matter. If there's more than one word per line I would suggest using `strtok_r` again to tokenize into words. After that, the only question is how to store them. One thing you might consider is to have a `char*` array, each of which points to the start of a word. If you're using `strtok_r`, the null characters will be inserted at the appropriate points to create C strings. Since you're doing everything dynamically, I'm sure you'll want your array of words to be dynamic as well. I recommend using `realloc` to implement this. Something like: char** words = NULL; int count = 0; // Each time a word is added: words = realloc(words, count+1); words[count++] = &amp;buffer[wherever_the_word_is]; // ... free(words);
&gt; words = realloc(words, Never do this. If `realloc` fails you will lose everything you have.
Good point, I was being lazy. Shame on me.
Variables of different types can have the same representation (e.g. `-1` and `255` in different `char` types). There are code tools to reinterpret memory, but `printf` is not one of them
Since there is also `x`, `X`, and `o` (all for unsigned), the use of `d` as decimal kind of make sense (although `d` is signed).
Yes, you can do this. But before I show how, I advice considering just writing a function instead. Functions are easier to write, easier to maintain, easier to debug, easier to understand, etc, etc, etc. Since you're most likely going to write more than one line of code, this is the pattern you want to use: #define DO_SOMETHING(MAX) \ do { \ for ( int j = 0; j &lt; MAX; j++ ) \ printf("Hello, world!\n"; \ } while(0) Macros can only be one line. The `\` at the end of each line concatenates them together, which is how we can stretch it across multiple lines. Don't put one on the last line. The `do ... while` part might seem strange, and it is. It's a hack because there's all sorts of corner cases when using multi-line macros inside loops and conditionals, and this gets around all of them. There isn't *really* a loop there, since the `while(0)` means it will only be executed once, and any over head of this method will be optimized by even the dumbest of compilers. There's also no semicolon at the end, so it looks more natural in use: for ( int i = 0; i &lt; 10; i++ ) DO_SOMETHING(20); But, like I said, you should avoid this pattern if a simple function would do.
Thanks for the response! What led to this idea of thought was writing a function that writes lines of code to file, then turn the receiving file into a header file that can be used as a header for another .c file
The variable type is actually how you interpret the same binary code as 2 different values. Using 41h as an example (01000001 in binary): When you read this as an unsigned int/short, you get the value 65, and if you are printing this as an integer, you would get 65 printed out. When you read it as a char though, you get the value 'A', since that binary sequence is interpreted as 'A' when you are interpreting it as a char Similarly, when you consider 8004h (10000000 00000100) in binary as an unsigned short, the value you read from it is 32772, but if you read it as a signed short, then you are interpreting the value as -32764 
If I understand the code correctly, you try to rewrite text section loaded by the linker? Text section is read-only mmapped so you cannot change its access to read-write and `mprotect` should fail. Do you check its return value?
Well, you can't make mappings of read-only opened files writable, that would circumvent file protection (see `EACCESS` in the man page) but, as I recalled now, that limits only shared mappings and the loader uses private mapping. So you indeed should be able to make it writable (unless some security module like SELinux blocks that).
Why not print("%d"%(a+b))?
One little trick you can use to read the current instruction pointer is to execute CALL with a relative address of zero, which pushes IP onto the stack, and then POP that address off the stack.
I’m currently looking over information about that module. Thanks for bringing that up.
You'll have to ship your app with a compiler.
Yeah... which for now in college I’m Not making anything anything super large or whatever
Oh wow, that's a descendant of ACK 3D. I remember that.
Would expect that to work, but can never remember how inline assembly in GCC works. Tend to find it easiest to disassemble (with objdump) the linked binary (before linking all the calls will be zero offset!) to double check what happened.
This subreddit is for the discussion of the C programming languages. You mention `cout` which leads me to believe that you need help with C++. Try r/cpp_questions.
Ohhhhh, I'm sorry about that, I am using c++ my bad. I'll go there
Is `%hhd` the correct specifier for reading a 16-bit int? Is `%d` the correct specifier for printing a 16-bit int?
Hi, It's impossible to say why you're getting -17203 because you didn't mention what you entered for input. That being said, compiler warnings are your friend! When I compile your code the compiler tells us something is wrong: warnings.c:7:12: warning: format ‘%hhd’ expects argument of type ‘signed char *’, but argument 2 has type ‘int16_t * {aka short int *}’ [-Wformat=] scanf("%hhd", &amp;a); ~~~^ ~~ %hd warnings.c:9:12: warning: format ‘%hhd’ expects argument of type ‘signed char *’, but argument 2 has type ‘int16_t * {aka short int *}’ [-Wformat=] scanf("%hhd", &amp;b); You're using the wrong format specifiers in your `scanf` call. The `stdint.h` types have specific macros for this kind of thing (which I had to look up myself). For `int16_t` you want to use the format specifier `SCNd16`. The syntax may look a bit funny if you're new to C, but it would look like this: scanf("%" SCNd16, &amp;a); Working code: https://pastebin.com/8G9VHqq1
Whatever value is stored in `score`, at position `val - 1`, add one to it.
Light Bulb...yes! Thank you
Score is the array, val -1 is the position in the array that is being changed and ++ is another way to say score[val-1]=score[val-1]+1
I'm gonna try to explain keeping the pedantic level low: When you write `score[val-1]++` , as it was pointed before, you are getting the score index `val - 1` and adding 1 to it. Remember that `val` was defined as a variable that's equal to any input from the user. Now, with that out of the way, I must say this code is horrible, not only the formatting it's disgusting, but there are several critical typos here and there, absolute lack of whitespace, (-1?, - 1?), and a totally fucked logic that makes no sense whatsoever (you keep adding numbers to the array and the `if` condition is a forever-true test) Besides that, everything seems fine. #include &lt;stdio.h&gt; int main(void) { int score[5] = {0, 0, 0, 0, 0}; int i, counter = 0, val = 0; while(val != -1) { printf("%d. Enter a score: ", counter + 1); scanf("%d", &amp;val); if(val &gt;= 1 || val &lt;= 5) { score[val - 1]++; counter++; } } printf("\n The total number of scores is: %d\n", counter); return 0; }
thank you for your input, I will work on formatting. 
Take a look at the [`strchr` function](https://linux.die.net/man/3/strchr).
You can write a for loop that iterates over all elements of your string and then compare each character to '@'.
score array takes nothing from input since there's no assignment on it. score[val - 1]++; does literally nothing, you can remove this line and the array declaration and the program will run just as fine. cheers :)
#include &lt;stdio.h&gt; #include &lt;string.h&gt; void exists(char *ptr) { while((*ptr) != '\0') { ptr++; if ((*ptr) == '@') { printf("exists \n"); return; } } printf("not exists \n"); } int main() { char arr[31] = "mail2tobechecked"; char *ptr = (char *) &amp;arr; exists(ptr); return 0; } you can set the return value as it fits for you
Your exists function will be expecting a single char, not a pointer. You missed the *. You're incrementing ptr before checking it on the first iteration of the while loop. While this would be okay given the input, it's bad form. You're casting arr to ptr in main and passing that to exists, this isn't necessary. Arrays decay to a pointer+offset. If anything, you could cast when calling the function. A check function should, in general, return a result, not print something. In this case, I'd return the offset of the @, or 0 if it's not found. There's no validation of the length of the string passed to exists. Input validation is a good habit to get in to.
C macros are super fun. You can create all kinds of horrible hard to maintain machines with them. Ditto with template metaprogamming in C++.
Do not spam.
That is correct if you use `printf`, however, it is wrong if you use `scanf`.
**Frequency distribution** In statistics, a frequency distribution is a table or graph that displays the frequency of various outcomes in a sample. Each entry in the table contains the frequency or count of the occurrences of values within a particular group or interval, and in this way, the table summarizes the distribution of values in the sample. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
If `mprotect` returned 0 then it worked and this is not the issue. SELinux may block the change but `mprotect` will then fail.
https://en.wikipedia.org/wiki/Everything_(software) It does similar stuff but uses filesystem's features: Everything first runs, it creates an index of the names of every file and folder on all NTFS and ReFS volumes[4] on the system from file metadata, in the case of NTFS from the NTFS Master File Table. Once created, the index is continually updated by the application; in the case of NTFS the updates are fetched from the **NTFS change journal**.[7]
**Everything (software)** Everything is a desktop search utility for Windows that can rapidly find files and folders by name. On October 30, 2009, Everything was ranked #857 among 1,757 computer programs used by the 70,000 users of Wakoopa, making it more widely used than WinZip. Since January 2013, Everything has been actively developed after a four-year break. This utility is released under a free software license that allows modification and commercial redistribution, requiring only attribution. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
OOP is dead. Functional FTW!
I would love it if they included a tutorial or any sort of documentation on how to use this. It'd also be great if they had a github, so people could test and contribute to their code. As far as I can tell this uses lex and yacc to turn C∀ into C (no clue which standard) prior to compiling that C into a binary. It's kinda cool, especially the incorporation of some features that are popular in Go and Rust, but I can't help shake the feeling that people have been doing this for decades and this iteration merely adds to the noise of "modern C dialects." If I'm wrong please correct me, because I wouldn't mind something like this, I'm just not sure this is anything new, noteworthy, or useful.
&gt; edit: i wrote * but it seems there is an error it just dont show the * A word or sentence between \* \* is displayed as italic (and \*\* \*\* for bold) on Reddit. Remember to add 4 spaces before every code line, so that the \* are not interpreted. Interpreted: blah *blah* blah Not interpreted: blah *blah* blah
thanks!
"Procedural is dead. OOP FTW!" - 1995 probably (when Java came out)
**Cyclone (programming language)** The Cyclone programming language is intended to be a safe dialect of the C language. Cyclone is designed to avoid buffer overflows and other vulnerabilities that are endemic in C programs, without losing the power and convenience of C as a tool for system programming. Cyclone development was started as a joint project of AT&amp;T Labs Research and Greg Morrisett's group at Cornell in 2001. Version 1.0 was released on May 8, 2006. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
ansi? 1989? am i fucking delusional? we already have this. 
EVP_DigestSignFinal() gives you the signature in an array of unsigned chars. So... Just print those array elements out in base 16 or whatever.
Somewhat it is!
Ah sorry, I misunderstood you. 
Not a native english speaker, it happens a lot sorry :p
It looks like it's designed by college CS student. A lot of things looks useless and unnecessary. I mean, they even choose a fucked up name...
Also, why permit reserved words (such as `int`) to be used as identifiers? 
Please insert 4 spaces before each line to properly format code on reddit. I'll edit shortly with suggested changes to the actual code. 
[removed]
&gt; Why duplicate functionality with choose? `switch` is C-compatible, with default fallthrough. `choose` has default break. &gt; Why ctors/dtors? You never wished to have all your structures of a kind initialised to the same default values? 
If you do a Fahrenheit negative as your first item on running the program , it works... You have bugs in the Celsius entry and in the process of going to ask for a second number so you are probably drawing the wrong conclusion based on not being thorough in your testing. When posting this sort of question you should show the exact input and output you got that you don't think is right
Is the default behaviour (falltrhough or not) really needs dublicating? It's not that hard to: case X: { // code goes here } break; Do we really need to confuse people with multiple ways of doing same thing just with different default behaviour? &gt; You never wished to have all your structures of a kind initialised to the same default values? my_type_t* my_type_new(void) { my_type_t* self = (my_type_t*)malloc(sizeof(my_type_t)); assert(self); self-&gt;my_val = 0; self-&gt;my_other_val = my_other_type_new(); // init to defaults all other members return self; } 
&gt; Is the default behaviour (falltrhough or not) really needs duplicating? It's not that hard to: &gt; &gt; case X: &gt; { &gt; // code goes here &gt; } &gt; break; &gt; Do we really need to confuse people with multiple ways of doing same thing just with different default behaviour? Well, C's default as fallthrough is a bit of an oddity. It is not rare to have problems caused by forgetting the `break;`. Those problems are not not especially hard to find, but not always super easy either. Also, `break` is the behaviour you want something like 99% of the time, not fallthrough. And most of the times you want fallthough, it is to simulate an 'or' on a list of cases. So, logically, most later languages chose implicit `break` as default behaviour (and often do not allow any fallthrough). Here, they allowed `case` to take a list of case values to solve the 'or' thing. As they want to remain backward compatible with C, they chose to provide a new keyword instead of some fancy and probably confusion-prone syntax addition, and `choose` does the job well, IMO. You can do C style, you can do the more practical C-for-all style, I find the separation clean. You'd better practice a bit a bit of Perl, if you think that's too many ways of doing the same thing ;-) &gt; You never wished to have all your structures of a kind initialised to the same default values? &gt; &gt; my_type_t* my_type_new(void) Theirs works for automatic (stack) variables, and the destructor is automatically called when you leave the scope. You don't need to call the constructor explicitly either, I think.
I can see why you like it, but I still keep my opnion ;) As for ctor on stack, well I'd just split the malloc part and init part. And just pass `my_type_init(&amp;my_type_on_stack);` But anyways, as I said, this is just how I like it. 
Yeah, good luck Googling for that.
This isn't an extension, this is a new language. By adding polymorphism and overloaded functions, the name garbling requirement is added, making the whole thing incompatible with existing C projects. Removing the `struct` / `enum` requirements means that the namespace for `struct` / `enum` is no longer separate from the global namespace, which will is incompatible with existing C code. Exception handling requires setting the `longjmp` and signal catching, which adds abstraction layers, which goes against the design philosophy behind C (minimal abstraction). The `if ( int i = fn() )` could be an extension, the rest of it breaks C compatibility. By all accounts, this is a new language, not an extension.
They're the first result when googling c for all.
&gt; But anyways, as I said, this is just how I like it. What's really annoying is when people don't define _new or _init functions for their structs in the API. Even worse is inconsistency. SDL is an example for this. Structs like `SDL_Renderer` are initialized using `SDL_CreateRenderer' whereas you initialize the struct `SDL_Rect` (rectangle) by directly assigning to the attributes. Very typical for C libraries. It's not a huge issue once you have found out the initialization/cleanup scheme of the library but enforced definitions would have made things more consistent. I actually had a bug once because of issues like that. The library was poorly documented, I wasn't sure how initialization was supposed to happen and due to that, some objects of course weren't properly initialized afterwards. But I guess that's just how things are with C. Little enforcement.
Amen
Your code is C++, not C. Ask in /r/cpp_questions.
Instead of do ... while, could you not just put the code in a block with curly brackets?
The world is littered with far better language designs that never received acceptance from the developer community. Do kids even know what “line noise” is and do they still really need to compile it? If someone out there is a genius language designer, give me something simpler, cleaner and safer that doesn’t take 700+ pages to describe a million corner cases that 99% of its lifelong developers will never understand.
"Do my homework"
&gt; Mailing List (internal only) &gt; &gt; Dashboard (internal only) &gt; &gt; Bug Tracker (internal only) C∀? More like C∃, am I right? (∃ is the closest logical symbol to "for some" that I could find. I refuse to apologize.)
I also turned to the web archive.
Hi, Im new to the C programming language and I have this assignment that wants me to print out how many times I entered 'g' or 'G'. I finished all the code but I have this single problem that I couldn't figure out. The "printf("\nInput character (E or e to end):");" gets printed out two times for some reason. Any help would be greatly appreciated. 
it is printing twice because it is inside of the `for` loop. i'm surprised it is only printing twice. 
This actually worked, thank you so much for your help !
Try putting the printf outside the for loop
It printed out the sentence "Input integer" two times ignoring the scanf statement.
Oh! I see -- `scanf` is reading a two characters: whatever you entered and a carriage return. 
I need the printf to be repeated constantly, but thanks for helping.
So it prints twice for each loop?
It is hard to see what the problem is. Could you show us the rest of your code, too? One thing that is probably wrong is your call to `free()`: the `free()` function releases the storage of an object. After these lines: *list = node; free(node); `*list` points to unallocated storage, which is most likely not what you desire. Perhaps if you could explain what you try to achieve it might be possible to give a better answer.
When you want to remove a node from list, you should call free()
I am creating a ray caster that makes a linked list of sphere objects and prints their colors out to a ppm file on a 2-D space. [full](https://pastebin.com/pFfA0Axg)
Didn’t even think of that, thanks for helping out!
Yup, don't call: free(node); Until you're completely done with it. By storing it in *list, you're indicating that the caller will use it. The function that calls read_objs() should be the one that free's 'list'. 
*list = node Here, node is a pointer, you assign i to list and then immediately delete whatever both node and list point to, hence the seg fault
Where is your for-loop increment updater for your 'counter' variable?
I want it to be infinite. 
Wouldn't it be better to use a while-loop, in that case? Then you could remove the counter variable entirely. while(a != 'E' &amp;&amp; a != 'e')
Yeah it would actually be better, but I didn’t think of it really. Thanks for your great suggestion! 
No problem. Have fun with C!
python 2 *and* 3 equivalent: a = 1 b = 2 print('%d' % (a + b))
C++ is off topic in this subreddit. Also, nobody wants to see this kind of content here. Please don't post it.
ok
&gt; I would love it if they included a tutorial or any sort of documentation on how to use this. There is some kind of a PDF manual hidden in the page. But I still haven't figured where to find the source... :-D Because the lexer/parser files (oddly, one of them is in... C++!) are not enough. If there is someone less dumb than me, please share your knowledge :-) 
&gt; But anyways, as I said, this is just how I like it. Yeah, no problem :-)
BTW, you don't need your `else if`. Just do a 'or' in the ìf`: if(a == 'g' || a == 'G') { 
 int myarray[2][3] = { { 0, 1, 2 }, { 3, 4, 5 } };
Wow. Having that link look like no other link on the page was a terrible decision. 
And one can replace a = a + 1; with a++; to make it easier to read.
This is a very bad way to ask for help. Try being more specific and say what you did / you do not understand
This sub is for C, not C++.
So do you have any specific programming question? Also this is C++.
I know this is c++. That is not actually my major concern here. If you can open the drive link, there is an algorithm for partitioning the graph to get subgraphs. I want the c implementation of that algorithm .. or if you can explain it to me.
That is a good point. I didn't think about the semicolon.
If for some reason you can't use the initializer syntax like /u/dumsubfilter showed (say the array has been passed into a function as a pointer, and you have to fill it), an easy and portable way to do this is to make a local array with the initializer, and then memcpy it. Ex: void identity_matrix_3x3(int *buf) { int ident[3][3] = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}; for (int i = 0; i &lt; 3; i++) memcpy(buf[i], ident[i], 3 * sizeof(int)); } 
That's C++, not C... And thus off topic for this sub.
What the code above is Prims graph algo. As I said above, the code Lang is insignificant. If you guys can help me with the algorithm, I can write the code myself.
[Report a bug](https://bugreports.qt.io/projects/QTCREATORBUG/issues/). Use something else in the mean time.
Which operating system are you using?
We have to use Qt at the class so I that's a problem :/
Can you do your work in a different folder (Like C:\Dev\project_1)?
I've already tried it. I followed a tutorial how to change a registry path. I created another administrator account but now I can't log in into the original one
If you’re dealing with lots of pre-composed array values of the same length, you can wrap the array in a `struct`: struct whatever_array { int value[HOWEVER_MANY]; }; and then come up with some nice global static const struct whatever_array \ FIRST_VALUE = {{ELEMENTS}}, SECOND_VALUE = {{ELEMENTS}}; or enum whatever_array_value { WAVAL_FIRST, WAVAL_SECOND }; enum {WAVAL__COUNT = 1 + WAVAL_SECOND} static const struct whatever_array WAVALS[WAVAL__COUNT] = { {{ELEMS}}, {{ELEMS}} }; (The latter can be macro- or header-tabled easily, if that’s your thing.) Whenever you want to copy in a new array you can just assign directly: // struct whatever_array output; output = FIRST_VALUE; // or output = WAVALS[WAVAL_FIRST]; If you’re sticking with single-dimensional arrays of a single type, you can write a varargs function and either use a sentinel or pass it an explicit count. Version 1, avec sentinel: #include &lt;stdarg.h&gt; #define set_int_array_END (-1) void set_int_array(int *array, ...) { va_list args; int k; va_start(args, array); while((k = va_arg(args, int)) != set_int_array_END) *(array++) = k; va_end(args); } That requires you to have some spare `int` value you can use as a sentinel, of course. Version 2, counted: void set_int_array(int *array, size_t count, ...) { va_list args; va_start(args, count); while(count--) *(array++) = va_arg(args, int); va_end(args); } But those won’t genericize very easily—`int` is embedded quasi-inextricably in the function body, so if you wanted to use that technique with arbitrary types, you’d have to come up with one new function per type (disregarding `const`-qualification). If you use C99 features, then you can combine the newer `(int[]){...}` syntax with a varargs macro. (It’s hard to do much with arrays without varargs due to the fact that braces `{}` are not as meaningful as parentheses `()` to the preprocessor, which means `{1, 2, 3}` would be seen as three arguments `{1`, `2`, and `3}`.) #include &lt;string.h&gt; #define set_array(dest, T, ...)\ memcpy((dest), ((T[]){__VA_ARGS__}), \ sizeof(((T[]){__VA_ARGS__}))) set_array(array, int, 1, 2, 3, 4, 5) set_array(array, int[5], {1,2,3,4,5}, {2,3,4,5,6}) But C doesn’t give you a clean way to bundle up `T` in case you need something like `int (*[])[]` or `int (*[])(void)` or `int (*(*[])(void))[]` (not that you should be handling that last one without thick gloves), so that won’t always work unless complex types have been `typedef`’d first. It’s also possible for `*(dest)` and `T` to be incompatible types, which could break things quietly. GNU C gives you `typeof` ^(*[sound of angel choir singing]*), so with that you can do #define set_array(dest, elem0, elems...)(__extension__({\ typedef __typeof__((dest)[0]) set_array__0; \ static __const__ set_array__0 set_array__1[] = {elem0, ## elems}; \ (set_array__0 *)__builtin_memcpy((dest), set_array__1, sizeof(set_array__1)); \ })) which looks appalling but will at least auto-guess the element type for you both for `T[]` and `T *` sorts of `dest` values. Simpler to use, too, and the compiler can be in any mode without breaking it: int dest[5]; set_array(dest, 1, 2, 3, 4, 5); int dest[4][2]; set_array(dest, {1,2,3,4}, {5,6,7,8}); If you’re sure of `dest` being a proper array name, you could even throw in an `assert` about the size of the source array being ≤ the destination buffer. (Or gate the assertion with a `__builtin_types_compatible_p` ^(*[sound of demon gaggle grumbling]*) check if you’re not sure, but ickpoo.) `__typeof__` will also wrap up complex type names for you, so if you parameterize the type you can do `__typeof__(T)[]` to make an array out of whatever type `T`. This can of course be applied to the above C99 macro to cinch it down a bit. Without C99 or GNU additions, for anything generic you’re stuck with trickery like begin/end macros: #define set_array_BEGIN(dest, T) \ do { \ register void *const set_array__0 = (dest); \ static T set_array__1[] = { #define set_array_END \ }; \ memcpy(set_array__0, set_array__1, sizeof(set_array__1)); \ } while(0) which would look like set_array_BEGIN(array_name, int) 1, 2, 3, 4, 5, set_array_END; Same problem with complex `T` as the C99 macro, of course, and it’s ugly as sin. (You could leave out the braces at the end of `BEGIN` and beginning of `END`, which makes invocation look infinitesimally cleaner but leaves you more open to accidents.) Many options, none terribly inspiring.
Don't run development tools from an administrator account. Seriously, just don't. Nothing in this process requires elevated privileges.
This sub is pretty picky about being C and not C++. I suggest posting to /r/cpp_questions instead.
r/cpp r/cpp_questions r/AskProgramming 
You know what? I only found it while browsing the HTML source of the page... :-D
 int val = atoi(argv[1]); char newStr = (char) val; [...] strcat(newStr, (char *)(", ")); *newStr* isn't a string here, it's a *char* with the value of *val*. Treating that as a destination pointer in *strcat* will write memory to some low address, most certainly will crashing your program. Compile your program with warnings, the compiler should have complained loudly about it. 
It is a horrible PL, but ofc it is worth learning. C++ won't die in a decade or more... There is no evidence that it will change! So keep it on... &gt; Code Academy is horrible.....HORRIBLE! 
There is no such a thing C/C++.. C and C++share a minimal resemblance...just about 10%... I think that Java and C++ are more similar than C and C++!
Ruby is easier and have a more clear syntax. Ruby &gt; Python...anyday...anytime!
As described by Scott Meyers in Efficient C++, a good way to see C++ is seeing it as a federation of languages: C is one of them.
Hey, I did look into ffmpeg since I have used it numerous times as a CLI tool but this they don't have a C API style way of using it and its pretty overkill for what I feel is a simple task in comparison
I've never taught anyone Ruby, which is why I'm less eager to recommend it in this context. Moreover, I feel like Python will be in higher demand in the future than Ruby. It's unfortunate, because I too much prefer the syntax of Ruby over that of Python, but these are things I need to consider when recommending languages to beginners.
dumbest shit I ever heard... C has no relationship with C++... You C++ boys are just too "high" to realize that! 
Indeed. Seems that Ruby is gaining some more attention as the years goes by! haha
My apologies! I tried searching c++ and cpp in the search bar, but nothing came up. Even took a little leg work to find this sub. My manager gave me the same answer about low level C++ being difficult to learn. He also said that Python would be more viable to learn as a beginner, but I was looking for second opinions on if C++ is worth it as a beginner. Do you recommend Code Academy for their Python course? 
This helped a lot, thank you.
You can just do a single memcpy
Not if it's a multidimensional array, the destination memory might not be contiguous.
I think learning python first is the way to go. It will feel less daunting which will keep you motivated. Afterwards, you can learn C++ by translating the codes you have written in python into C++.
Take a close look at what happens in `getInputLine` when then input is `MAXLINE` or more characters. I.e. "Houston, we have a problem."
Hello. Thank you for testing my code. What did you find as a result? I just ran this string of 1000 characters through it: `NgMjlQC0MAFhzzM2XDAzkmwCVEeaNemS9EvRLkzt46ra6SINLcappTmBlF5Jje7KhwQZy60MBVaSHCp98lH40aA41beYShv2ptKFZHXJdKcU8lnpw0ocJBu8s1S8BeNUVAfwZ2OIt4Vd1FmmRs3Bbziv89VXsq0zyXWraFo8bJ5o5nPKuD7ap01hzSzgnMPvjgNx1j3XncdJfirOwEn4shjYlZgSbvFSLCPPMcvmh4iICcFgtZ7W4uOXcuPoBHNMHYCwKgxGhWuxX1KSVkSoGLBUel30UWMIbpOmccomlli0YARz7iJfvBoDwn8aVlFMkQfXGs3L6cmdaOAzF4jMybxbJT2RvSqdYB5R0nuTBIaYJ11gkBkhJ2VFi46G7LGP3leRPrG2KglxWmP9zNFwIXFbHLR7ernVeaDysF3BJnoLBYIPzkhM0FoIPdQIbQMVd2C8nflbRAHONK3b1P1icW4YBPHdOzXbHxp3BtGWaaBfehMCET8eRYOlQd1s1JuwRVuMOIFroIVN8et5zIt1aRsbKKjQqqa5SSJSov51g0TFN5OQAgslg2XQfwKDNnnRp8hGipXR7pwPJQKqGr9l616qecVYp9h0NTS6DB7UWlp10k0phJ7s0qJPYHmduka7EA1UnJQ4PCyMYCKOJ1YNMh0cMCLagsVslVD4DxUQra1kWOVdDUre6e6Sutq4bQGy7T5EBSbmqYupfzkeb7nlTCQvEvkuYhXKwiJlDA8d6newOdC96lrHbJBecKFKLHjUzD2oko1vKoxhMaraoJlKbwh5UHXW0eHSZDD0i5tc9QyBkCUkni0fGMlx71R3njcrN1xXoOmxLEKY021ii4NPxBIXtxDd69htm1Wq1LmfDH2Fu0h3TcOalbCYgaMX2Mt0hxK07L8ydVfRM8BewrKg0bE1mHSZVXAZbk1R5YUDoJ2zDDp6Dp2dtx5BAmOC4HDphNyj72q4IJOjuAYsWXYk2q28YPyPT0Z2dkd53SBQ` Can you kindly elaborate what bug you found? 
Some minor comments: If you're willing to write code with embedded assignments like: while (counter &lt; MAXLINE &amp;&amp; (letter = getchar()) != EOF) Then I don't think it would be too outrageous to turn: inputLine[counter] = letter; ++counter; Into: inputLine[counter++] = letter; Adding an element to an array and incrementing the counter is conceptually, part of one indivisible operation. It can be argued that embedding the increment op makes it easy to overlook, but I think for certain idioms, like this one, it's a win. I'm sure other people will chime in with alternate views. Another thing I notice is that, in cases where either will do, you tend to favor pre-increments over post-increments, which is fine (more on this below), but at the end of `printInputline` you use `counter++`. Why the inconsistency? Personally, I favor pre-increments, but most people favor post-increments for reasons that escape me. I think putting the ++ up front makes it more obvious (yeah, it's a stretch). A historical note is that in olden days it was an efficiency consideration. Post-increments were more costly because the code had to keep track of an extra values - the value of the variable _before_ being incremented since that's the value of the post-increment expression.
Thank you for the code `inputLine[counter++] = letter;` I am still very new to C Programming. Right now I am reading through K&amp;R and I want to answer all questions using only the material covered up to the exercise I am working on. Also I was not aware I could increment the counter as you explained. Maybe K&amp;R will explain this later on. If not, thank you for advising me. To answer the pre-increment vs post-increment inconsistencies, again I want to answer all questions using only the material covered up to the exercise I am working on. As of this exercise, the book has only covered pre-increment and not post. The reason I wrote a post-increment at the end has to do with writing PHP code many years ago. Most times I would use a post-increment and it looks like an old habit snuck into the code I wrote tonight
I don't want to just spill the beans. Here are some q's you need to consider. - In `getInputLine` what are the possible values of `counter` _after_ the while loop exits? - What is the largest value of `counter` you can legitimately use when indexing into `inputLine` ?
&gt; My apologies! I tried searching c++ and cpp in the search bar, but nothing came up. Even took a little leg work to find this sub. LPT: many subs have a list of related subs in the side bar. /r/programming's side bar has a link to [their wiki](https://www.reddit.com/r/programming/wiki/faq#wiki_what_language_reddits_are_there.3F) listing the subs for most languages, for example. And don't stop there -- that wouldn't have gotten you to /r/cpp_questions directly. But both /r/c_programming and /r/cpp have links in their sidebars to more specific subs like /r/cpp_questions. In this day of Google it's easy to think that a simple search will get you where you need to go ... but that just doesn't work on Reddit for whatever reason. Also, I'm going to suggest /r/learnprogramming, which is an active sub for asking questions about most any language.
&gt; C has no relationship with C++... Uh, no. There's actually a symbiotic relationship between the languages. A common subset that will compile and be interpreted the same (or near enough), and new language features are shared between languages. The [charter](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2021.htm) for C is explicit about this: &gt; **Minimize incompatibilities with C++. ** The committee endorses the principle of maintaining the largest common subset clearly and from the outset. Such a principle should satisfy the requirement to maximize overlap of the languages while maintaining a distinction between them and allowing them to evolve separately. C++ has also been incorporating features of C (designated initializers come to mind). That's not to say that they want to turn C into C++. Far from it, it's supposed to be the smaller, simpler language, and will always be that way. But there is a common subset between the two languages, and there's a desire on both sides to maintain this.
I just wanted to say that this is such a wonderfully kind reply. 
Don't be overly hostile, there is no need for it.
Sorry, I was in the middle of watching *Annihilation* when you posted this. Thank you!
It took a little work to get the character string output message for the consumer setup the way I wanted to, but after a little tweaking, I got the producer consumer relationship to be successful. Thanks all for the advice. Much appreciated.
Actually, there are a number of libraries that ffmpeg uses which are written in C. The can be found [here](https://github.com/FFmpeg/FFmpeg).
A simple google search led me to [this](http://www.portaudio.com/), which may be better suited to your needs than ffmpeg (suggested by u/olfert) since it is meant to be used only for audio. Hope this helps.
I think it looks pretty good. The built in 'pipe' cmd works on inter process communication so each time you fork and exec a stage, the output data from the last stage will be there. 
Ah! Thank you!
Thanks!
Cross-compiling is when you build binary formats compatible with a different processor architecture. A common type would be compiling ARM code on an x86 processor. The main reason you'd do this (in my experience) is because the cpu on your x86 pc, presumably your development pc, is much faster, and can compile the binary much faster than the ARM device, which is presumably the embedded device you want to actually run the code on. I don't know why that guide would want you to rebuild a compiler. 
&gt; As far as I know compilers do have an option to specify things such as abi, OS, etc so why can't those be used instead? While some compilers certainly could or does have that (I don't really know of any..), gcc does not. It must be configured when the compiler itself is compiled, to be able to produce executables for a particular CPU family and OS.
Thanks, already looked at it and in the [FAQ](http://www.portaudio.com/faq.html) `PortAudio has no support for reading or writing formatted audio files. We recommend using libsndfile for audio file I/O.`
Aside of the novelty no sane person is going to develop code on a watch. The same goes for phones, cable boxes, GPS, video cameras, refrigerators, car door lock controllers, and a wide range of other types of devices. There have been many specialized processors over the ages for which there has never been a native tool chain so cross compiling is by definition the only option.
Then, I will ask for the next C++ guy to write a C program without looking at google or books... I doubt he can write a decent C program!
It's really confusing because bound variables are usually to the right of the predicate.
Hey! I write all my android apps using google keep &gt;:(
what if you have two tabs?
What part of this is supposedly illegal? Also, I think you don't need the `#` operator in `CAT` as you already pass quoted strings to it.
the CAT macro, without # no works... are legal `""""`?
The new code should account for multiple tabs - thanks
I had lowered the MAXLINE to 10 to test it out and have found that the trailing characters entered just get cut off and not processed. For the purposes of this exercise and where it is in the book, I think that it okay.
Dropping the excess characters is fine. That's not the problem.
Not sure if you're asking this, but `""""` is the same as `""` because in C when you put quoted strings side-by-side they get concatenated at compile time (eg. `"Hello, " "world!"` becomes `"Hello, world!"`). This is useful for when you want to split a quoted string through multiple lines. To get the literal string `""`, you do `"\"\""`.
ok, try the CAT macro with `""-""`
If it runs, it's valid. But talk to a lawyer about any legal questions.
Please do not antagonize the mods. This is a very well maintained community, and I assume they do their work for free. Moreover, your post that was removed was *exceptionally* hostile. Nobody used similar language when you suggested Python was slower and more difficult than Ruby, despite clearly disagreeing with you. 
That’s your main problem I think. Also the results you can see can be related to this. Your struct can hold 1+1+4+1 byte. Frist byte is the first name. When you now scanf the the first name „bob“ you save the „B“ in the first char, the „o“ in the second char and the last „b“ in the first byte of the int value. At next you scan „Geldof“ where the „G“ is saved in the second char value and thus overwrites the „o“ from bob. The „eldo“ are saved in the 32 bit int value and the „f“ in the pointer to the next struct. When you now print the first name you print everything till the next null byte, which seems to be after your struct (probably luck ? At least undefined ). That should result in bgeldof (assuming after you struct is a null byte in memory). Maybe that helps a little bit to understand what is happening. 
Also you should have a look in how pointer references and de-references bind. Use brackets if you are not sure. I spend way to many time into debugging pointer referencing where before i was *absolutly* sure I knew what i did ^^ 
Thank you for your answer. I created pointers to first and last, and now the memory isn't being overwritten. So those two variables are solved. However, this isn't the case for int ID. Again thank you.
Thank you for your answer. I understand what's happening thanks to your explanation. I've solved it by assigning pointers to each variable. From what I understand, the first bit contains an address elsewhere, where it doesnt collide with the second bit (which also contains an address). If I understood what you said correctly, I only need to assign a pointer to the first variable, as the second one doesnt have any adjacent variables I am assigning.
u/PowderDirtRock has the right of it, you should change `char first` and `char last` either to `char *first` and `char *last` or `char first[LENGTH]` and `char last[LENGTH]` where `LENGTH` is a value that you `#define` above. Also note, `LENGTH` is likely a bad name for this, and you should use something more descriptive. Should you go the pointer route instead, you will also need to allocate space for a character array pointed to by `char *first` and `char *last`. Some final things that are slightly more personal preference: * I don't recommend casting the return value of `malloc`; the compiler will do this for you during assignment, and casting may obfuscate non-obvious errors in your code. * You don't need to allocate space for `root` in `main()` or set it to `NULL`. Since you only need the address of `root` in passing it to `newstudent()` you can get away with `struct student *root;` and it will be assigned a value in `newstudent()`. * `main()` should always return an integer value, and if it is not receiving command line arguments is best declared as `int main(void)`. Don't forget to `return 0;`. Hope this helps. If you have any questions, or anything I've said is wrong, misleading, or poor practice please reply below.
Moderation team should not make such unfounded affirmation on C being related to C++.
The id do not have to be a pointer. You need to understand that a string is not more than an array of chars. Problem here is that you do not know how long your input is. That’s a problem you will have often when working with strings in C. So what are you solutions ? You have to decide somehow how long a name can be. And than you have to decide if efficiencie or mem usage is more important to you. 1. efficiency: use a fixed size array of chars for the first name and the last name. If you decide a name can have at max let’s say 16 byte than just use char fname[17]; (one more for terminating null byte) and char lname[17]. Now you have to make sure to scan not more than 16 bytes and set to last one to zero afterwards. 2. Memory: use a single buffer with a fixed size and scan the values into that buffer. After scanning you can check how long the name actually is and malloc the exact amount of bytes for your fname and lname pointers(+1!). Then copy the string to your malloced memory. I haven’t done something with strings in a while so I am Note sure if there are more elegant solutions. 
 &gt; 1! 1! = 1 
Good bot 1!
Thank you, crest42, for voting on WhoaItsAFactorial. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
Do it yourself, smart guy.
StackOverflow has a lot of upvoted BAD advice.
Thank you for your answer. I assigned pointers to first and last, and now it works (I also understand why it works now). The remaining problem I have is with the integer value, which when casted with a pointer still returns gibberish. For malloc, I saw many posts from both perspectives, and I'm still not sure which one is objectively better, but I think I will take you up on your recommendation (as it's already cast there is no need to do it). I will definitely sort out main. As for declaring root NULL, I just need it in my full code, where I have a condition to check if a linked list already exists Eg. if (root == NULL){ createroot (root); } else { insertnode (); }
What’s the problem for ID? 
 printf("ID: %d\n", &amp;(*new_node).id); Remove that `&amp;` and you should be fine. The garbage you're seeing is the address of the `id` field instead of the actual value therein. As for the `NULL` business, I then amend my original answer; you should just have `struct student *root = NULL;`. Hope that helps!
Awesome! The id works now! Thanks a lot. Also for the root, I will do that, and then malloc once the function is called (so I dont use memory until it's required).
I solved it by getting rid of one of the &amp;'s, and just derederencing with the -&gt; operator. The \n actually causes the program to freeze at that point, but I solved the issue as stated above. Thanks a lot for your help!
Thank you everyone for your help and comments. They are appreciated. The issues have now been solved.
I also like this solution but I think it's a little too complicated for this code (as the number of char pointers is two). Also for this solution and the previous buffer solutuon I think the more char pointer fields you need to fill out the more memory you save with the buffer.
Really glad you got it working!
It’s always good to provide your working solution in your original post too. Other beginners will a appreciate it :) 
Yup, I'll do that :)
Oh ok I understand now. 
Why do you consistently write `&amp;(*foo).bar` instead of `&amp;foo-&gt;bar`?
OSdev recommends that, because it's writing bare metal systems code with NO operating system to interface. The best way to set up a target for that with all the best options is to rebuild GCC. (tho I think they have binaries on the site somewhere?) OSdev ALSO has a second tutorial for building a cross-compiler to target your own hobby, custom built OS. That would require rebuilding too since no-one's going to have configured a target for your own operating system.
Name checks out
i use this code to get the values but I get an error saying segmentation fault(core dumped) when I try to enter values for the vector. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; /* Our 'vector' structure with an attached name */ typedef struct vector { char name[255]; size_t size; double *data; } vector; int main() { char name[255]; vector vectors[4]; int i, nvec = 0; unsigned int size; double *data; while (nvec &lt; 1) { printf("[%d] Enter vector information: ", nvec); /* Grab the name and size of our vector. You may want to try to handle * invalid input if that's part of the assignment. I'm just aboring. */ if (scanf("%s %u", name, &amp;size) != 2) { fprintf(stderr, "Error: Input must start with a string followed by number!\n"); return -1; } /* Here we can attach the name and size to our vector, and allocate for data */ strncpy(vectors[nvec].name, name, sizeof(vectors[nvec].name)); vectors[nvec].size = size; /* Here is the part where you would allocate the 'data' for the vectors as well as set the values ... */ for (i = 0; i &lt; size; i++){ scanf("%lf", &amp;data[i]); } /* Move to the next vector */ nvec++; } /* I didn't do the work to fill the vectors, but did set the names * so they can be printed here */ for (i = 0; i &lt; nvec; i++) { printf("[%d]: name = '%s', size = %zu\n", i, vectors[i].name, vectors[i].size); } return 0; } 
One thing that you'll find very useful is to let the compiler help you out by telling it to warn as much as possible. When I compile your program with the `-Wall` and `-pedantic` flags, we get a nice hint: cc -O0 -Wall -pedantic -ggdb -g3 vector2.c -o vector2-debug vector2.c:36:33: warning: variable 'data' is uninitialized when used here [-Wuninitialized] scanf("%lf", &amp;data[i]); ^~~~ vector2.c:17:17: note: initialize the variable 'data' to silence this warning double *data; The compiler is correctly warning us that our `double *data` pointer is not initialized to anything. When created it's just going to point to a random location (whatever happens to be on the stack). This is where we need dynamic allocation. You've got the size of the vector, so you know how much memory to allocate: /* Allocate enough memory for the number of elements entered */ data = malloc(sizeof(double) * size); That's telling C to figure out how big a `double` is (it could vary from system to system) times the number of doubles we want to store. Then once you set each of the `data[N]` elements, remember to attach that pointer back to the structure by doing: /* Attach these doubles to our vector */ vectors[nvec].data = data; Now you should have your named vectors with elements. I can't stress enough how useful it is to compile with all warnings enabled. Compiler warnings can be annoying but they're usually there for a very good reason. :)
Thanks for the useful tip, lastly I just want to know how I display the values I entered so they appear on the screen. thank you for the help
If it works it's legal... That said, that's some ugly ass code, you might wanna refactor it.
So at first I didnt realise my issue was with the pointers assignment, and I thought it was with my referencing, and that format worked and for some reason the other one didn't (so I thought). Yes they are both the same thing and the -&gt; operator does look better. Initually that was the one I was using but like I explained, I tricked myself into thinking that it was wrong :P
So would the output from the first stage be in 1? How would I pipe it to the second stage? Would I pipe 1 to 0?
&gt;Is there any difference between them on the compiler or machine code level? No. It's exactly the same. The difference, if I'm not mistaken, is due to old versions of C standard not requiring declaration of parameters, so using `foo(void)` was a way to tell the users of the function that you don't expect any parameters. In modern C (I really hope you are using at least C99) using `foo()` or `foo(void)` is a matter of taste. I'd go with the first.
Ok, that makes sense. Thank you!
Thanks!
Strictly speaking, the two are not equivalent: `showTime(void)` declares `showTime` to have a prototype whereas `showTime()` declares `showTime` without providing a protoype. It's hard to notice the difference though.
with how small it is... really? which part?
They are not equivalent. In short, in the C language your second example defines a function that takes an unspecified number of arguments of unspecified type. Also, make sure you realize that in C++ it does not mean the same thing. There is a good Stack Overflow article about this [here](https://stackoverflow.com/questions/51032/is-there-a-difference-between-foovoid-and-foo-in-c-or-c)
Ok, that's really good to know. Thank you!
Thank you for the explanation and example!
So from what I gather, invoking the pipe command somewhere in the root parent process will return you both ends of a pipe, 0 (the end which you can read from), and 1 (the end which you can write to). We can then set stdin: 0 and stdout: 1 to these file descriptors via the dup command. For each stage fork and then exec the cmd..input will be read from 0 and output will go to 1. Example here[here](https://stackoverflow.com/questions/2605130/redirecting-exec-output-to-a-buffer-or-file?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa)
AllIsDoomed is a hilarious name. The code path tracer probably isn't smart enough on it's own to realize that function can't return. I think there's a VC annotation that tells the compiler that that's the case... _Noreturn or something? Or just put a dummy return statement in the default case of the switch.
The compiler doesn't know that `AllIsDoomed()` will never return. If it did, the "default" switch case would reach the end of the function where nothing is returned (from `DoTheSwitch()`). You change the `switch` statement to: if(a != 1) AllIsDoomed(); // No return. return EXIT_SUCCESS; A little strange, but the compiler would stop complaining.
Why are people down voting you so much? You didn't know, were corrected, and made note of that. You should be commended for owning your erroneous belief and graciously admitting to having learned. 
so in C, a **string** (for example 'myname@gmail.com') is an array of **characters**. so basically I would store the email string in an array, so for example char email[] = "myname@gmail.com"; then, since logically C sees this as: char email[] = {'m','y','n','a','m','e','@','g','m','a','i','l'}; you can use a for loop to iterate through each character. and then use an if statement to find the @.
Because the reply is not useful. I have no hard feelings against a person stating something erroneous mistakingly, but having a statement that is stroke through in the comments, just lowers the signal to noise ratio in reddit. I would personally advise everyone to downvote factually, objectively incorrect information. There is ofcourse the exception, that there is something to be learned from making that mistake. In this case, I don't think there is. 
There's a third case actually even: void showTime(); // #1 void showTime(void); // #2 void showTime() {} // #3 /* void showTime(void) {} //#4 */ The first, as already mentioned does not give a prototype and neither specifies the number of parameters. The second does both, specify the number of parameters and give a prototype of how the function should look like, st. a compiler *must give diagnostics* about someone writing code to either implement the function with different parameters or call it in a wrong way. The third is tricky, an empty parameter list in a function declaration that is part of a code block specifiies no parameters. However it still doesn't provide a prototype. This means, the compiler *must allow compilation of this code*, even if there are wrong calls or implementations of this function, since they are not conflicting with any prototype. *However*, it *is* **undefined behavior** to do so (which is not necessarily the case for 1), so, if the compiler could detect that, no matter what, this UD triggering code would be executed, it can warn about that (I'm pretty sure this is not done though, for any compiler). Case 4 is rather boring again, it's just like case 2, but as part of a code block, nothing special.
Bro, this is next level laziness... You're honestly just going to make your code confusing as shit trying to save time this way.
That's a good point. I really don't need a default. This also worked for me.
C11 has the `_Noreturn` keyword I was thinking of (Dunno if MSVC supports it). In the C++ world, it's `[[noreturn]]` in C++11 or better. gcc and clang have `__attribute__((__noreturn__))` for use with older versions of C and C++. 
Oh yeah definitely lol 
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
`AllIsDoomed` returns `void`. He could do `return AllIsDoomed(),0` or something, but IMO it’s better not to let the compiler/reader think a return might happen.
Developers != Teachers...
I prefer to put `abort()` on the death path in order to immediately and loudly announce the presence of a bug.
You didn't say which operating system you want to focus on other than mentioning desktop programming. This makes it bit harder to tailor recommendations. A lot of the general concepts are the same, but the specifics vary significantly across platforms, especially so between unix-like systems and Windows. Dependency management is not standardized at all and so is unique to each platform, and depends on your specific needs. For make just toss the vendor's manual (especially for GNU Make) and just [read the POSIX specification itself](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/make.html). I've also [written my own tutorial](http://nullprogram.com/blog/2017/08/20/). The [gcc man page](http://man7.org/linux/man-pages/man1/gcc.1.html) is a good *reference* for interfacing with GCC and Clang, but it won't serve as a tutorial. I don't know a good tutorial for the very basics offhand — building object files and linking them, etc. — but the main part is actually really simple. If you're going to debug with GDB, just read through [the GDB manual](https://www.gnu.org/software/gdb/documentation/). That serves as both tutorial and reference. Throw in whatever text editor you prefer and that's basically about all you need for professional software development work in C. This is one set of industry standard tools. The additional complications added by dependency management depend on what you're specifically doing. On the "how stuff works" side: You'll want to learn the application binary interface (ABI) for your platform. For the desktop that's going to be either the [System V ABI](https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf) or the [Windows x64 ABI](https://msdn.microsoft.com/en-us/library/ms235286.aspx). Fully understand this will require some knowledge of x86-64 assembly programming. Unfortunately I don't know of any good resources for this, online or off. The best reference is the [Intel software developer manual](https://software.intel.com/en-us/articles/intel-sdm), but this won't serve as a tutorial. To understand linkers, you should read [Ian Lance Taylor's Linker Essay](https://lwn.net/Articles/276782/). You should find it to be fairly accessible. You'll also want to understand the binary format for your platform. This would be [ELF](http://www.skyfree.org/linux/references/ELF_Format.pdf) (any unix-like other than macOS), [PE32+](https://msdn.microsoft.com/library/windows/desktop/ms680547(v=vs.85).aspx) (Windows), or Mach-O (macOS). Learning all this sets you up to understand many of the more complicated features that *will* come up as you write more sophisticated applications: shared libraries, procedure linkage table, global offset table, imports/exports, address space layout randomization (ASLR), position independent executables (PIE), sanitation tools, other hardening features, etc. I think the linker essay covers most of this stuff. 
You don't think a wrong answer flagged as wrong is useful? Maybe in this case it's one way or another, but in some cases there may be multiple causes or reasons for something and I want as many answers as possible, as long as wrong ones are marked as such, it's valuable to me to see that one approach or reason is not correct. I get down voting to push it down to the bottom, but down voting to the point where stuff gets hidden, depending on the site, or the person becomes ashamed and removes it, is my concern here. I say if there are positive votes and you know it's wrong, down vote and reply saying why it's incorrect, but if it's zero or negative already, no use in piling on.
Here's a few more finds that look good especially the *Let's Make Dangerous Dave* series. - [Learn Socket Programming in C from Scratch](https://www.udemy.com/learn-socket-programming-in-c-from-scratch/) - [Let's Make: Dangerous Dave](https://www.youtube.com/playlist?list=PLSkJey49cOgTSj465v2KbLZ7LMn10bCF9) - [Write a C Interpreter](https://github.com/lotabout/write-a-C-interpreter) - [Sudoku Programming with C](https://www.amazon.com/dp/1484209966/) - [Coding A Sudoku Solver in C](https://www.youtube.com/playlist?list=PLkTXsX7igf8edTYU92nU-f5Ntzuf-RKvW) - [Coding a Rogue/Nethack RPG in C](https://www.youtube.com/playlist?list=PLkTXsX7igf8erbWGYT4iSAhpnJLJ0Nk5G)
These are all awesome! Thank you!
* [List of Top Ten College Mini Projects in c/c++ with full source code]http://www.codeincodeblock.com/2012/04/list-of-top-ten-college-mini-projects.html?m=1) 
Please use your vote buttons to judge the quality of submissions. Moderation only removes the absolute bottom of the quality scale (mostly, blog spam).
Thanks, I'll give these a gander.
This is totally just my feeling, but probably "modern C++ hur dur" freaks trying to push their anti-C agenda.
Try tracing the course of the program line by line, keeping track of what value each variable has.
What do you think it should be? Why?
Use substitution model: 1. nCount = 0, nAccumulator = 4+0; 2. nCount = 1, nAccumulator = 4+1; ... 3. nCount = 3, nAccumulator = 7+3;
The entire idea of writing loops in macros...
I'm pretty sure it does not specify the number of arguments, except when part of a definition, ie. void showTime(); // doesn't specify number of arguments void showTime() {} // does specific number of arguments
It is often very useful to express, in detail, what your code does. Check out rubber duck debugging, something like that would absolutely help you.
Yes, indeed.
[Don't use feof() in a loop](https://latedev.wordpress.com/2012/12/04/all-about-eof/)
thanks for the advice.
C++ is off topic in this subreddit. Please post C++ content to /r/cpp instead.
C++ is off topic in this subreddit. Please post C++ content to /r/cpp instead.
Why many build systems produces a makefile at the end and don’t just handle the compile process ?
Why not? Makefile is the best one to describe dependency graph and easy to debug. 
Hi OP, You're probably going to get little or poor response to this because the way you asked the question is simply poor. I'd first recommend the /r/C_Homework subreddit, which is more geared toward C homework questions. Next, you've really explained nothing, and it seems like you expect the community to solve the assignment for you. That's never going to go over well for anything. Here's a few things you can do to get a better response * Explain what this game is to us. Don't put the burden of research on the people you're asking the question. * Tell us where you're struggling with clear and clean code. A starting point helps people resolve questions * Show some initiative in solving this. As it stands, it looks like you're simply being lazy * Ask questions with clear direction. I'll try to offer some guidance at this point, but I have no clue how helpful it will be because the prompt is very vague. First, before you start trying to type any code, look at the problem or project as a whole. Break that down into as many smaller sub-problems as needed. For example, since this is a game, you will probably have some turn structure in it, which means you'll have a main game loop that everything executes within. Within a turn, you will have to do various tasks such as reading user input, processing it and changing state based off it, maybe doing some simple AI to have a computer opponent respond in that turn, check for a termination condition, evaluation of success or defeat, etc. Make each of the subtasks, then stitch it together, and test things, trying to hit corner cases. If needed, use tools like a debugger to artificially change program state so that you can get to unusual or difficult to reach states in the game. Really, the main take away here should be this: take time to ask well thought out questions. This will save you a lot of headache not only in school, but also in the workplace.
Hi, you reversed where your [] and () go in the link. May want to edit
This is a great resource, thanks!
NP
is not really a loop, each statement push different content, the trick with the macro, is to show without "strange scapes" the drawing ascii
thanks, the issue is that I did not know the scope of applying a concatenation via macro to a string, I should be more clear with the doubt, my mistake
How to win friends and influence people!
r/iamverysmart
&gt; I just do not understand why this is necessary? To drop your elevated privileges once you're done doing whatever it was you needed them for. &gt; This may sound silly but, if we set the saved user id to the effective, how do we revert back? You don't. That's the point. If there's a code injection bug in your code, you don't want an attacker to be able to reacquire privileges. These aren't C questions, by the way. They're Unix or POSIX questions.
Linus...? is that you?
Thanks, I should probably post in a subreddit dedicated to unix/posix then :) And I understand that you have to drop elevated privileges after using it - I guess that could be done by just setting the effective user id to the real user id. But if the setresuid just sets them all to the efrective uid (which is the owner of the file, because of the setuid bit), what is the difference? Aren’t you just doing the same twice? 
That was so much easier than what I had in mind. Basically, only print the characters that are within the specified range **and omit the rest**. Than omitting part was the one I hadn't even thought of. I complicated myself haha! This worked perfectly. Thanks a bunch!
Soooo...arrays start at 1, right?
&gt; But if the setresuid just sets them all to the efrective uid It doesn't. What makes you think it does? The man page says: &gt; Unprivileged user processes may change the real UID, effective UID, and saved set-user-ID, each to one of: the current real UID, the current effective UID or the current saved set-user-ID. &gt; Privileged processes (on Linux, those having the CAP_SETUID capability) may set the real UID, effective UID, and saved set-user-ID to arbitrary values.
&gt; a ‘\n’ does not work, this is because *it is two characters* No it isn't. Comparing to 0x0A is even less portable, because \n will work regardless of your character set, whereas 0x0A will be some other character.
I am not really sure what it means then (on the man page). I guess I am in a privileged process since the setuid bit is set? I have an example here (code is long, just look at lines 80 + 81) https://exploit-exercises.com/nebula/level18/ This program has the following "bit"-masks (I am level18): -rwsr-x--- owner: flag18 group:level18 and even though there is a "s", it still uses (lines 80 + 81 in link) setresgid(getegid(), getegid(), getegid()); setresuid(geteuid(), geteuid(), geteuid()); Not sure why it needs to be there. When I already have elevated privileges. 
This looks reasonable to me. You do have a mistake in that you want to be allocing the maze, then allocing the rows, then the columns. Right now you are assigning the rows to the maze itself, not "array".
You have a few options for this, and which you choose depends on how comfortable you are mucking about with types and memory. If you use a double pointer, you’re probably going to end up allocating an array of pointers to arrays, which is annoying to deal with but syntactically simple because you can just do `p-&gt;array[i][j]`. This approach should mostly be reserved for situations where each “row” of the outer array could have a different length or be missing entirely, which is not the case here. (The double-pointer approach is what Java does for multidimensional arrays, and performance-wise it sucks ass vs. a flat array.) You’d allocate the outer array as `rows * sizeof(char *)`, and then you’d allocate each inner array as `cols * sizeof(char)`. (Or you can allocate the entire thing at once: size_t outerSize, innerSize; char *q; size_t i; assert(SIZE_MAX / sizeof(char *) &lt;= rows); outerSize = rows * sizeof(char *); assert(SIZE_MAX / cols &lt;= rows); innerSize = cols * rows; assert(SIZE_MAX - innerSize &lt;= outerSize); p-&gt;array = (char **)malloc(outerSize + innerSize); q = (char *)p-&gt;array + outerSize; memset(q, 0, innerSize); for(i = 0; i &lt; rows; i++) { p-&gt;array[i] = q; q += cols; } But that allows you to free it in one go, as opposed to having to do—in addition to freeing the `Maze` itself—) for(i=0; i &lt; rows; i++) free(p-&gt;array[i]); free(p-&gt;array); Another, probably easier option is to allocate a flat `char *` and compose your own array accesses, as `p-&gt;array[i*p-&gt;cols + j]` (row-major, which is the way normal C arrays work) or `p-&gt;array[j*p-&gt;rows + i]` (column-major). This is what happens under the hood when you do a normal array, but the `char[][n]` type allows the compiler to do it for you. You’d allocate the array with `malloc(rows*cols)`, optional `* sizeof(char)` but that’s effectively multplying by one. You can avoid having to do the explicit multiplication by setting up a quick function: static char *maze_cell(const Maze *p, size_t i, size_t j) { assert(p &amp;&amp; i &lt; p-&gt;rows &amp;&amp; j &lt; p-&gt;cols); return p-&gt;array[i*p-&gt;rows + j]; } ... *maze_cell(p, i, j) = 'X'; c = *maze_cell(p, i, j); If you can do C99 stuff, you could also do a C99 flex array so you don’t have to allocate `array` separately (that would look like struct maze { size_t rows, cols; char cells[]; }; or `char *cells[]` if you’re going for the `char **` approach, but as noted above, the latter is moderately ickier. With or without the flex array, you can allocate the structure+array in one big `malloc`, but the flex array makes it slightly easier to get at the trailing array. The `malloc` would look something like size_t arraySize; assert(SIZE_MAX / cols &lt;= rows) arraySize = cols * rows; assert(SIZE_MAX - sizeof(Maze) &lt;= arraySize); p = malloc(sizeof(Maze) + arraySize); With a flex array, you’d be able to use the `p-&gt;array[i*rows+j]` approach; without a flex array, you can drop the `array` member entirely and do // Maze *p char *array; array = (char *)(1 + p); c = array[i*rows + j]; // etc. Then you can `free(p)` at any point and the entire thing will disappear at once. You could also store `array` as a `void *` that you cast to a C99 `char (*)[][p-&gt;cols]` VLA type, which would let you do // const Maze *p; char (*p_array)[][p-&gt;cols]; (*p_array)[i][j] = 'X'; c = (*p_array)[i][j]; which isn’t too bad either.
You need to remember how large the maze is so you can do bounds checking, i.e. not index outside the allocated memory. If you do a single block of memory instead of char**, you also need to know how much to multiply the first index (x in my previous example) by.
I was thinking of going with your first suggestion, but are these in place of what I already got or tacked on to what I already have? And what's p? Is it the Maze structure?
To your first question, the first two strategies (for `char **array` and `char *array`) are in place of whatever stuff you have for `array` now. The C99 flex array and (C89) `(char *)(p+1)` approaches integrate `array` into the memory block used for the `Maze` structure. The VLA `(char (*)[][cols])` one is a C99 type hack to get around having do to `array[i*rows+j]`. I was using `p` as a `Maze *`, so ~yes on that second point.
Is this what you mean: Maze* maze = calloc(1, sizeof(Maze)); maze-&gt;rows = size; maze-&gt;cols = size; for(size_t n = 0; n &lt;size; n++) { maze[n] = calloc(sizeof(char), size); } return maze; 
Okay, I asked because I didn't see where you initialized p. Would that pretty much be where I malloc the Maze struct?
= P?
Lol I was hoping someone would say that
Yeah, for the first two you would presumably `malloc` `p` separately. (Though if you just had a straight `Maze p`, those would still work as long as you changed `p-&gt;` to `p.`.) For the last two, you’re `malloc`ing everything at once.
Okay. One last thing, was what I already had nowhere near correct? I revised it to the following: Maze* maze = calloc(1, sizeof(Maze)); char **a = calloc(sizeof(char *), size); maze-&gt;array = a; maze-&gt;rows = size; maze-&gt;cols = size; for(size_t n = 0; n &lt; size; n++) { array[n] = calloc(sizeof(char), size); } return maze; Would that not work?
As long as you’re allowed to use C99/equiv (non-CTC initializers, `size_t n` in the head of the `for`—that would normally be `i`; `n` is usually used for cardinals, not ordinals), that’s mostly fine. `array[n]` should probably be `a[n]`, since AFAICT `array` is a field in `*maze` and not a local. The `Maze` and `a` allocations can just be `malloc` since they’re small and you’re filling them in anyway—you don’t need them zeroed first. All allocations should also be checked, because any one of those could return `NULL`, whether from insufficient memory (it does happen) or because a `size_t` would overflow. You’re doing rather more work than you need to in the final init loop—even if you’re going with the `char **` approach using separate allocs for `Maze`, `char **`, and content data, you can just allocate one big `char *` and point the `char **` into that at various offsets. Something like char *data = calloc(size * sizeof(*data), size); // check data for(i = 0; i &lt; size; i++) { a[i] = data; data += size; } If you do that, you’d free `maze-&gt;array[0]`, then `maze-&gt;array`, then `maze` when you’re tearing down.
&gt; I guess I am in a privileged process since the setuid bit is set? “privileged” means root. So if the program was setuid root but you switched to your real UID, you can switch back to root but not to a different user. &gt; Not sure why it needs to be there. When I already have elevated privileges. Because the real and saved UIDs are still those of the user that ran the program, and not those of the owner of the program. After the `setresuid()` and `setresgid()` calls, they are all set to the owner of the program. There may be cases where it matters; for accounting purposes, for instance.
I think I finally get what you're saying. Thank you so much for all the help! :)
What behavior are you experiencing?
Data structure would depend on the data in a file, performance and resource limits, etc. The only real difference between stdin and a file as far as stdio cares is that you probably can't seek in stdin. Unless it's a redirected file. And just because you opened it with fopen() doesn't mean you can seek in it, if it's a FIFO or other special file type.
1,000 x 1,000 isn't so big if you're running this on a normal machine. Assuming you are populating an array, we're talking about 4mb of data there assuming 4 byte integers. That's something you probably want to put on the heap instead of the stack, but it's not a concerning amount of data to put in memory. If you're just looping over the file and slurping the contents into a data structure, reading from stdin and a file will feel the same. stdin may be more limiting than a file in general. Also, your example of reading from stdin has an useless use of `cat`. You can just do `./myprogram &lt; file.txt`. 
&gt; printf("%d\n", list[i]); You're still going to have teh same issue here, because you are printing a newline.
Right, piping the output of cat into your program will work, it's just morally repugnant. Lots of people do useless uses of cat though. There's even an award: http://porkmail.org/era/unix/award.html 
Thank you very much :) didn’t know there were cases where it mattered if the real user id was the same as the owner of the file - to do some privileged stuff. I thought it was enough to have euid set as the owner of the file, to do stuff as if I was the owner.
As u/dumsubfilter pointed out, you are printing a new line after every number. Also remove the semicolon immediately after the for loop. Your if statement is just incrementing all the *array elements* in the list that are less than 10 then adding an extra new line for all the *array elements* greater than 10. If you are trying to print a certain number of *array elements* you should use your **array index** variable in the **if statement** rather than the values stored in the array. That way you still print out the correct amount of data whether the array is sorted or not. Try something like: if (i == 10) // array index printf("\n"); Rather than if (list[i] &lt; 10) // array element printf("\n");
Suggestions (these are bugs): * remove the ";" at the end of the for line. * remove the ++ on the "list[i]++;" line. **Think** about what you are trying to achieve ... print the array elements and insert a new line after every 10 elements. Split the problem in pieces: - first print all elements by inserting a space after each element. - see if you get the expected result Next, add an if statement that checks if the number of elements printed (hint you already have a counter in your loop) is divisible with 10. If it is divisible with 10 print a new line character. 
for(cur; cur != NULL; cur = cur -&gt; next) The first `cur;` doesn't do anything.
So I should just delete it? or replace it with something else? I guess it isn't causing any real problems then
I would just move the assignment on line 72 to the loop declaration: ` for (cur = list; cur != NULL; cur = cur -&gt; next)`
Thank you! That fixed the warning but not the broken ppm file
"Crafting Interpreters" looks awesome... However, to anyone else checking it out the book is incomplete. The book plans to implement an interpreted language in Java first and then C later on. The book has not even begun to implement the language in Java.
You need to change `char c` to `int c` because **EOF** doesn't fit in a `char`. while( (c=fgetc( file )) != EOF ) { if( c == ESCAPE_CHAR ) { break; } else { ... } } Something like that. You could have also just tested it in the `while` after you'd read it and checked for EOF.
Put OBJ_T *node inside the whole loop to start
 printf("P6\n 1000 1000 255\n"); This says you're describing a 1000x1000 pixel image, where each RGB component of a pixel is a value between 0 and 255. printf("%c%c%c", (unsigned char)(color_out.R * 255), (unsigned char)(color_out.G * 255), (unsigned char)(color_out.B * 255)); This writes out a single pixel. You multiple the all of the RGB components by 255. Remember what the maximum value of a color component is? What are the RGB components of the color black? 
This would break if g is read from the file. You still need to read from stdin. 
Good catch.
You say that you want to wait for "another two lines" after the first `g` , but your code contains no such logic; it attempts to wait another 20 lines. Have you tested this on a file larger than 60 lines? If you respond to the first input by pressing `g` then Enter, I suspect you will actually see 40 more lines and then a further wait for input. 
Can you post your code? How massive is massive, and what data type are you using to store the multiplicands and the product? If you're talking about two's complement I assume you're at least talking about integer multiplication.
Macros?
I actually managed to solve it on my own I made an if block that said if (sizeof(*void) == 8) //64bit Mult = (a * b) &lt;&lt; 32 //mult is intmax_t Else //32bit Mult = -uintmax_t((a * b)&lt;&lt;32)
Yeah, it's just gonna make the macros look sloppy but it'd definitely better for my main loop. Like in the code I replaced my typical for loop (i = 0 through 5) with a0=b[0]; a1=b[1]; a2=b[2]; a3=b[3]; a4=b[4]; a5=b[5]; so now that BS is sitting in my .c file with no decent way to collapse it. in face there's like... 60 things like that in the same function.
If it works with 64 bit ints, just always use them?
You haven't initialized the actualAge and birthYear variables. Either do int actualAge = 21; for example or use scanf to let the user input the two variables. 
So I understand that. I'm more asking why is it generating that number? Where is it coming from? Is it because %d knows there needs to be an integer so it just generates a random one. 
When a variable isn't initialized it allocates memory and in that memory there is information. That's where it comes from. 
`stdint.h` contains definitions for integers of specific widths. It sounds like you need to store your numbers in an `int_least64_t`. If your numbers are still larger than that, you will need a bignum library.
I tried them with both intmax_t's and int64_t's
Perhaps you're better off with a bignum library then. That way the results are more predictable, and can extend to larger values if required. 
Most signals default behavior is to terminate the process or terminate the process and dump core. There are some signals that are ignored by default but I can't remember any from the top of my head (probably SIGCHLD).
[List of signals](http://man7.org/linux/man-pages/man7/signal.7.html). Scroll down about 1/3 of the way and you can find a list of POSIX-defined signals. You're sending signal 1, which you can see has a default behaviour of terminating the process. 
THANKS that wasn't clear to me but now it's very clear
https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#index-funroll-all-loops " This usually makes programs run more slowly." small loops that fit inside the cpu's cache will possibly work faster... (your program knows what size the cpu cache is right?) larger loops will probably be slower because of cache misses and reloading... profile first, change one thing, profile again.... 
also to add to bizarre_monkey. There are programming coding tournaments that list their problems. https://medium.freecodecamp.org/the-10-most-popular-coding-challenge-websites-of-2016-fb8a5672d22f
how would you get started in this? I would think you need to be good a bitwise operations?
The difference between a white pixel in colour ASCII and binary; The ASCII is 12 chars: 2, 2, 5, , 2, 2, 5, , 2, 2, 5, ; where as the binary is 3: 0xFF, 0xFF, 0xff; If you can see the correlation and think of a way to convert between the two, you're golden.
Can you explain a bit more about what you mean by "ASCII" and "binary"? The second one is definitely not "binary".
Thanks! 
Sorry, that was a bit vague... It refers to the format of the file. The ASCII version is basically a text file while the binary one is data written straight to the file. Half of the fun is working out the problem. Save a few images using GIMP in the appropriate file formats and try opening them in a text editor or using hexdump on them and seeing what's in them. 
To add on to what _sogood said: In official terms, accessing an uninitialized variable induces undefined behavior. (Congrats, your first UB!) UB is an exciting feature of the C standards that basically means that the compiler can do whatever it want—emit an error, emit code to generate an error, emit no code that would lead to UB, emit a bitmap image of a chicken. If you’re on GCC or something similar, you should generally enable warnings with `-Wall -Wextra` so the compiler catches at least the easy stuff like uninitialized variables, and pay attention to anything the compiler tells you for now even if it generates a binary. Without optimization (=the compiler basically translates your code literally), you’re pulling whatever crap happens to have been in memory where those variables live. With optimization (=the compiler derives some higher meaning from your code and acts on that instead), no telling what could happen.
Have you checked for bugs in your build system? This might happen if you had two processes competing to create `foo.exe`. Are you using GNU make or some other build system?
I have my own little compile script that compiles some assets into an object file and then compiles that along with my source code into the final executable. The amount of assets (and thus the size of the resulting object file) seems to increase the chances of the problem occuring, so it could be a factor.
I found picking a problem from the project Euler to be pretty fun and fairly quick if you pick one of the easier ones. 
I don't understand what you are doing. //64bit Mult = (-4294967296 &amp; (a * b)) &lt;&lt; 32; //mult is intmax_t `-4294967296` is `0xFFFFFFFF00000000`, that is: higher 32 bits at 1, lower 32 bits at 0. If you AND it with something, the result always has the lower 32 bits at 0. If you shift that towards left 32 times, the result is always 0. Or did I miss something (like `uintmax_t` being 128-bit on your setup)?
Why did you manually unroll your loops? let the compiler do the nitty gritty like that... Really, the only things you should manually do to optimize code (unless you're gonna, like, write it in assembly) is make the code layout more vectorizable, and keep in mind cache lines and what not; and use a better algorithm.
&gt; What would you recommend I do? Something that's not on the list, maybe? Just start doing the projects on your list. Apart from the fact that it's primarily used in systems programming and embedded systems, C is a programming language like any other.
This one is just awesome - [Let's Build a Simple Database](https://cstack.github.io/db_tutorial/)
You're using calloc backwards, the first parameter is the number of items to allocate; in this case, that's Rows * Collums. the second parameter is the size of the type in bytes, generally you just use `sizeof(char)` Also, you should change your type in the Maze struct from `char **` to `uint8_t **`, because your array isn't characters, it's bytes. Oh, and don't loop to allocate, that's a terrible idea. Just multiply Rows by Collums, and you're good. 
All I can say is I’m not done and my cpu is a third of what it was. Most of it, I think, has to do with sitting if blocks outside the loops. 
The linker failing to open and write the executable is almost always caused by a virus scanner. The virus scanner might not even consider the file particularly harmful, but the action the linker is taking, opening an existing executable file and writing to it (even though it is replacing it), looks awfully suspect to some aggressive virus scanners. My guess is that you're running a virus scanner that isn't Microsoft's own. Microsoft's scanner doesn't tend to do this as it isn't as terrible as some others. I doubt that even turning off real-time protection will help. One thing that sometimes works is to explicitly delete the existing executable via your build system prior to linking. That can get around some virus scanners. 
I have Norton, yea. Any way to test conclusively that it is what is causing the problem? I've excluded my source code's path from its auto-protect for now, maybe that'll help. &gt; One thing that sometimes works is to explicitly delete the existing executable via your build system prior to linking. That can get around some virus scanners. I've tried that before (adding `del foo.exe` to my compile script before the `gcc` command) and it didn't change anything.
See the source code for `diff`‽
I have no clue??
I had no clue this existed. Will google! 
Couples of suggestions: - Use Process Hacker or Process Explorer to see what other process has got a handle to the file. - If there's nothing eith a handle to the file then run Procmon, add a filter for "path contains foo.exe" (whatever your outputted executable is) and then keep compiling till it fails. You should be able to see in the logs what else has opened a handle on the file at that point.
[Here's what they say.](https://www.fmod.com/licensing)
At first you should made a decision what kind of comparison you want to perform? Cuz you could compare it by size, by hash, line by line or compare every characters, etc.
I would suggest, when it fails, using [Process Explorer](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer) to determine what program has a handle on the executable, preventing modification. 
Thanks Hellenas for reply, but if I add advertisement in app. Will it call commercial app? Non-Commercial use means that you do not make money from the product in any form including up front purchase, subscription, in app purchase or any form of sponsorship/promotion. If you have questions, please get in touch.
I think it would be commercial in that case. If I were you, I would email them, explain the project, and see what they have to say. You're going to get the best answer from them in that case, not someone here (unless they're lurking)
Ya that's my last option. Thanks anyway
No Problem! Hope the project goes great!
The statement says this: A program that should be invoked by: micmp [-i n1:n2] [-l] file1 file2 file1 and file2 are the directories of the files [-i n1:n2]: skips n bytes from the begging of the files [-l]: it list every byte that differs So i think I have to compare the files byte by byte.
I know. I honestly don't know why do we even use arrays. 😥 we were just asked to make a sudoku puzzle, but I want to make a 6x6 one 
Neat tools. Will see if they'll find anything, if not it'll still be nice to have them around.
You should also provide the linked with the actual _path_ to the library files: `gcc &lt;stuff&gt; -L/path/to/lib your_code -lquantum`
generally in life, or regarding something specific ?
You need to tell `gcc` where to look for the binary during the linking stage. This requires the use of the `-L` flag followed by the directory where that binary can be found. I'm not sure where this would be installed, as I've never used it, nor is Windows my main environment, but you may be able to find out in the makefile, or similar.