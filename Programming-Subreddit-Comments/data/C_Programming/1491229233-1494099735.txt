how did u convert 0x400766 to 67139168 ?? 
First convert 0x400766 from hexadecimal to decimal, then observe how `val` is shifted right by four before being called. So, you have to multiply the address by four to undo that.
For robotics, you'll want a good Mechanics background too. Mechatronics is a great field and requires a wide variety of knowledge.
Side note: Almost no code base is 100% MISRA compliant. It's not about making everything fit the standard - it's about documenting exactly when and why you are violating it, thoroughly enough to justify it and verify that the exception you're making to the rules is safe.
If you want to show your code, try using pastebin or other text file sharing website. 
There's a function similar to sizeof() called offsetof() that will give you the offset to a specific field in a given structure - at which point you can then just add that to the offset to the beginning of each struct in the file and read whatever specific field you want.
Also if youve succesfully printed it backwards, can you not just print it in reverse order?
 #include &lt;stdio.h&gt; void recursive(int number) { int digit = number % 10; number = number / 10; if (number != 0) recursive(number); printf("%d ", digit); } int main(void) { int number = 123456; recursive(number); return 0; } 
 if (number != 0) { recursive(number); } printf("%d ", digit); This can be tricky for new people. It's very important to understand *exactly* what's going with these two lines. The crucial insight is: the program checks to see if it's run out of digits, and then actually goes and computes the next digit, *before* it ever prints out the current digit. That's why the `if()` and the function call happen *before* the `printf`. It is only *after* the `recursive()` function call *comes back* from doing its thing, that the `printf` actually happens. Like I said, this can be tricky for new people. It can be conceptually hard to wrap your head around the idea the first time. That's why I'm writing this comment, that contains with a longer and more elaborate explanation. I want people who aren't familiar with the concept to understand precisely what's going on here, how, why it works, and also to understand the concept in a more general way.
Hahahaha because I guess the homework wants me to use a function to solve the problem! Good thinking out of the box tho~
You cannot handle a string like this. A null terminator is the absolute end of the string, and using it for any other purpose is unexpected both by the compiler and by human readers. You will need to use some other terminus for the end of a string and handle finding that instead, but that leads to other problems if a string contains the terminus character. Do you have to use a string, or can you use an array of strings? 
You have to do something like: char **words = malloc(sizeof(char *) * numwords); And then assign each element the start of one of your words in your data block. Something like: words[0] = data; words[1] = words[0] + strlen(words[0]) + 1; etc.
No, because we compare number: (number != 0) In your case when digit equals 0, the number will be equals 1.
Well, you open a file with fopen()... If you don't already know things like that you seem to be a bit over your head here. You might want to go back and review earlier material from your class.
No I know about them but just learned about them and need help with that. Thx so much!
I found out changing the function to this works: char * getWordWithDog(){ char *p = (char*)malloc(50*sizeof(char)); scanf("%s", p); strcat(p, "dog"); return p; } 
You mean this? char * getWordWithDog(char *w); int main(){ char *word = (char*)malloc(50*sizeof(char)); printf("%s\n", getWordWithDog(word)); return 0; } char * getWordWithDog(char *w){ scanf("%s", w); strcat(w, "dog"); return w; } 
You don't need to use `malloc()` if you do the allocation in `main()`. Also, when you do the allocation in `main()` you really need to pass the length of the allocated block to the function, and the function needs to ensure that it won't read more than the allocated size. As written this is buffer overflow galore. Also, it's a memory leak. 
Okay I knew about the malloc() thing. Also: char * getWordWithDog(char *w, int size); int main(){ char *word = (char*)malloc(50*sizeof(char)); printf("%s\n", getWordWithDog(word, 50*sizeof(char))); free(word); return 0; } char * getWordWithDog(char *w, int size){ fgets(w, size, stdin); strtok(w, "\n"); strcat(w, "dog"); return w; } Is this one better? I think I addressed everything you said.
With you being so young, you have quite the opportunity to get a jump start on others. I suspect you don't know what real time is, let alone hard or soft real time. Real time is not about running fast. An RT algorithm often runs slower on average than a non-RT version. RT is all about meeting your deadlines meaning it can never take longer than some fixed amount of time. It can run faster, but it can never run slower than its promised deadline. In other words, it has O(1) execution time. You can learn about [Big O notation](https://en.wikipedia.org/wiki/Big_O_notation) from Wikipedia. The difference between soft and hard real time is simply the outcome if you blow a deadline. In hard real time, it is a critical, unrecoverable failure (rocket blows up, person dies, car crashes, reactor melts down). In soft real time, if you have a failure, it can be recovered from, say your phone loses sync with its cell base station and the call drops. The caller can just call back. If it happens too often, then your product gets a bad rap or maybe fails FCC certification. In RT, you also learn about things that seem contradictory. For example when prioritizing interrupts, which interrupt should have the highest priority? Hint: "importance" of the interrupt has nothing to do with it. Interrupt priority is simply assigned by the frequency of the interrupt. The more often it occurs, the higher priority you make it. It took me some time to wrap my head around that concept and prove to myself that is the right answer. 
Learning how to program is mostly about how to find answers to questions. If you want to pursue a carrier in this field you will encounter similar obstacles in the future. It will be expected of you to find answers to these problems on your own. So it is imperative to your success to train yourself in answering questions. Here are a few relevant questions: * What is a control flow? * What are the basic control flow elements? * What is an array in C? * How are C arrays created, populated and accessed? * How are characters represented in bytes in C? (Prerequisite: What is a byte and why is it used to represent data in computers?) * How can files be opened and read? * How to translate bytes to characters? Using a search engine (eg. google) and the right keywords the answers can be found. Relevant resources can be: http://en.cppreference.com/w/ http://www.tutorialspoint.com/ansi_c/c_introduction.htm Edit: Learning the first programming language can be hard. I will become easier with time and practice, but no matter what similar challenges await. 
Yup, doing the operations manually is the fallback. It's likely I'll have to end up rolling my own thing, but I was curious if someone else had already done it, especially with the OUI/EUI portions.
And now you have a memory leak.
Nice, you did his homework for him. Good work.
You have a typo in the sub-heading: "Is the stack realy growing downwards?" s/realy/really/ 
Very good read
Do you have any code? What is giving you trouble? What do you *think* you should do? All these questions should be answered by you when you ask a question on the internet.
It's less restrictive than MISRA C and has a few differences of opinion. I think it has more style-oriented rules, too. It's a little easier to jump into than MISRA C.
That was interesting! Thanks for sharing :)
Or, better yet, you can post your question in r/learnprogramming :)
This isn't how you ask questions, you know. If you read [ESR's essay on how to ask good questions](http://www.catb.org/esr/faqs/smart-questions.html) and follow it you should not only get the best answers available but you will also be a benefit to all users of the network. Never ask people for help via PM. It's rude to other users. It makes it seem like you're trying to hide your homework from searches, but it also deprives everyone else of the answers that anyone provides. (I thought this was going to be a post about HardWare, not HomeWork. Please try to use abbreviations only when they're well-known and unambiguous!) 
Yeah, if you don't free it in main, it gets leaked.
Most likely, you still need to be careful of buffer overflows among other things. Also, `malloc`ing when you don't really need to, like here, is not a good habit to get into. A better way of writing your function would be to have the caller pass in a pointer and length, and have it use that as the string buffer. This means that the caller can decide where the memory will be allocated (stack/heap) and what to do if the allocation encounters an error. 
You're welcome - no thanks necessary - my inner pedant is just happy finding tiny mistakes in other people's work. ;-)
&gt; is using a static global variable (seen only in the file, right?) bad practice? Using static on a variable declared outside of a block makes the variable scoped at the translation unit level. Effectively, file wide. This isn't as bad as a global variable but in this case it is pretty limiting since it means you can only ever have a single queue. Why not track your queue entirely from a struct so that you can have as many as you want? &gt; Related, is using extern bad practice? For the most part, yes. That is how you end up with global variables.
Haha I actually did all of that, so I'm feeling good about it.
If you want to have something that exists once for the entire program, than a global variable is the way to do that. However, quite often that's not at all what you really want. When you want something that might exist more than once in your program, don't use a global variable for that.
Yes. If you want you can use `typedef` to make it look like a native type. Some people don't like that but I prefer it. `typedef struct queue queue;` This lets you just type `queue` instead of `struct queue` elsewhere in the program.
I mean, yeah, sure. My point was to just guide you to seeing that having a single global instance means exactly that, you'll have one single global queue. If that's what your program requires then sure, why not. All programs have some global state, but the more you can minimize this the better, for several reasons. Testability, reusability, readability, etc. extern declarations have their uses but in general should be avoided. You're instruction the compiler that the variable does exist somewhere, and leaving that up to the linker. This can make testing things in isolation difficult
The way your structs are defined is OK. The following compiles and runs with out error using gcc on Linux #include &lt;stdio.h&gt; #define MAX_FOOD 100 #define MAX_BEER 101 #define MAX_TIRED 102 #define MAX_BORED 103 #define MAX_STORAGE 104 typedef struct { int food; int beer; } inventory, *inventory_ptr; typedef struct { int tired; int bored; } state; typedef struct { inventory preINV; state preSTA; } dwarf, *dwarf_ptr; //second structure typedef struct { int food; int beer; int ore; int coins; } storage, *storage_ptr; void print_structs(dwarf_ptr d, storage_ptr s); int main(int argc, char const *argv[]) { dwarf premTrp = { { MAX_FOOD, MAX_BEER }, { MAX_TIRED , MAX_BORED } }; storage premSkl = { MAX_STORAGE, MAX_STORAGE, MAX_STORAGE, MAX_STORAGE }; dwarf_ptr ptrTrp = &amp;premTrp; storage_ptr ptrSkl = &amp;premSkl; print_structs(ptrTrp, ptrSkl); return 0; } void print_structs(dwarf_ptr d, storage_ptr s) { printf("Inventory: food = %d, beer = %d\n", d-&gt;preINV.food, d-&gt;preINV.beer); printf("State: bored = %d, tired = %d\n", d-&gt;preSTA.bored, d-&gt;preSTA.tired); printf("Storage: food = %d, beer = %d, ore = %d, coins = %d\n", s-&gt;food, s-&gt;beer, s-&gt;ore, s-&gt;coins); } If you can post more information, I might be able to help you find the problem. Also, you can use a [code beautifier](http://codebeautify.org/c-formatter-beautifier) to clean up your code's formatting. 
 &gt;I was thinking a good way might be to convert everything to a char by something like this: &gt; &gt; char c = 2 + '0' &gt; Why do you think this is a good way to do it? Try write: http://pubs.opengroup.org/onlinepubs/009695399/functions/write.html 
I use typedef for all my structs/unions all the time, its become second nature to me, and it makes it easier to read. Additionally, I made it a habit of naming my structures, variables based on the file/module they are defined in to avoid having repeated names. Ex: queue.c =&gt; QUEUE_init(QUEUE_t *queue); Also super easy to find where its defined.
Get a small embedded development board to thinker around. Start with an Arduino or a STM32 Nucleo board. Just doing something simple requires familiarizing yourself with many basic ideas and processes involved in embedded development. If you manage to get input from the serial port to command a servo you are 90% there. 
Splint has an aneurysm with my SDCC codebase. I can't figure out how to make it handle anonymous structs but my device headers are literally all anonymous structs. Edit: And that's no matter what C I compile for, C89, C99, and C11 all choke the same. 
Depending on your use case you need to take care of the endianess. Google the word and you'll find more answers how to handle binary data. 
Is there a problem with doing it that way?
Why do that when you can just read the uint_32 directly to a file with `write` then read it back again trivially with `read`? uint32_t x = 42, i; int fd; fd = open("/tmp/foo", O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU); write(fd, &amp;x, sizeof(x)); close(fd); fd = open("/tmp/foo", O_RDONLY); read(fd, &amp;i, sizeof(i)); close(fd); /* i = 42 */
I have a similar scheme. I capitalize the first letter of the struct/typedef but leave the function prefix all lower case.
This is a most recommended read - http://www.catb.org/esr/structure-packing/. 
Divisible by 8 because it's a 64 bits os? 8*8 bits? 
How are you intending to set this value?
there are a few advantages: its human readable, modifiable by any text editor and no worrying about endianess.
wow, so the constant 0 does not equal 0x00000? So many lies. #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { void *pt1 = 0; void *pt2 = 0x0; void *pt3 = NULL; printf("pointer1: %p pointer2: %p pointer3: %p\n", pt1, pt2, pt3); printf("are equal: %d\n", pt1 == pt2 &amp;&amp; pt1 == pt3); return 0; } output: pointer1: (nil) pointer2: (nil) pointer3: (nil) are equal: 1 Then inspect in gdb and: (gdb) p pt1 $1 = (void *) 0x400430 &lt;_start&gt; (gdb) p pt2 $2 = (void *) 0x7fffffffdce0 (gdb) p pt3 $3 = (void *) 0x0 
If you mean setting a pointer like so: int *ptr = 0; //or ptr = 0; Then your pointer is a null pointer. However, if you're setting it like this: int i; int *ptr = &amp;i; *ptr = 0; Then `ptr` points to an integer (`i`) with a value of 0.
ok I give up trying to format that
prefix every line with four spaces.
Huh, looks like I need to brush up on my NULL pointer knowledge. Thanks!
Coolies, I'm doing it the first way so it looks like everything is all good. Cheers :)
&gt;6.2.2.3: "An integral constant expression with the value 0, or such an expression cast to type void *, is called a null pointer constant." &gt; &gt;My understanding has been that an implementation can define a null pointer constant as any integral constant expression cast to void * (i.e. it doesn't have to be 0)? This seems to be valid according to the standard. The NULL constant must be either 0 or ((void *)0) according to 6.2.2.3 that you quoted above. However, on some systems, null pointers are not addressed with 0x0000 bit some other bit pattern. On such systems, C compilers are required to translate between 0 and the system null representation in all pointer contexts. &gt;But, it makes sense that the compiler would know you're testing a pointer and automatically compare it against `NULL` for you, meaning that when `p` is a pointer, `if (p)` is equivalent to `if (p != NULL)` and that `if (p)` still works even if `NULL` is defined as `0xdeadbeef`. I hope that's right because that's awesome! NULL cannot be defined as something like 0xdeadbeef (it can only be 0), but even if the system null pointer representation is 0xdeadbeef, boolean comparisons involving null pointers will still work correctly because the compiler is bound to perform the required transformations as you describe.
That is valid if example is a pointer.
So just to make sure, the standard is saying the implementation can choose between `0` and `(void *) 0` for its null pointer constant? I originally thought it meant `0` cast to `void *` or any integral constant cast to `void *`, which is wrong (I think). Further, if a system doesn't represent null pointers with a bit pattern equivalent to 0, can they have a conforming C implementation? I get that the implementation can do the transformations, but it would still get back to `NULL` being defined as something other than an integral constant expression with the value 0. Actually, the C FAQ discusses this: [5.5](http://c-faq.com/null/machnon0.html), [5.9](http://c-faq.com/null/nullor0.html), [5.10](http://c-faq.com/null/macsochange.html), [5.16](http://c-faq.com/null/confusion4.html). Ultimately, there's no issue with what I was doing but I was doing it for an invalid reason. Maybe I'll switch to `if (p)` now, it's so much shorter. [Question 7.31](http://c-faq.com/malloc/calloc.html) was also interesting because `memset`ing to 0 or `calloc`ing a struct doesn't guarantee valid `NULL` pointers. I'm learning all kinds of stuff today!
You are measuing CPU time, not "walltime". Here I am using clock_gettime function from time.h. CLOCK_MONOTONIC ensures that we get the actual ellapsed time, and not actual clock time (as that would be affected by timezones, DST, leap years etc. #include&lt;time.h&gt; int main(){ struct timespec start_time, end_time; double elapsed; clock_gettime(CLOCK_MONOTONIC, &amp;start_time); printf("fun() starts \n"); printf("Press enter to stop fun \n"); while(1) { if (getchar()) break; } printf("fun() ends \n"); clock_gettime(CLOCK_MONOTONIC, &amp;end_time); elapsed = (end_time.tv_sec - start_time.tv_sec); elapsed += (end_time.tv_nsec - start_time.tv_nsec) / 1000000000.0; printf("elapsed time is %f", elapsed); return 0; }
You should probably use int *ptr = NULL; instead of int *ptr = 0;
That's the case for Linux: 64-bit programs keep doubles 8-byte aligned, but 32-bit programs keep doubles 4-byte aligned, even though doubles take up 8 bytes of memory in both cases. Other systems may have different rules. [Wikipedia says](https://en.wikipedia.org/wiki/Data_structure_alignment#Typical_alignment_of_C_structs_on_x86): &gt; A double (eight bytes) will be 8-byte aligned on Windows and 4-byte aligned on Linux (8-byte with -malign-double compile time option). But I don't have a Windows system handy right now to test if that's actually true (I have tested it on Linux, both 32- and 64-bit).
As a general principle, yes they are to be avoided. Usually when I see that in code, even code produced by experienced programmers, it was more about convenience than an actual need. In other words, unless you have a very good reason to use a global, then don't. Keep in mind that a const global is not really a global because its value (state) cannot change. They are actually good practice in many cases because they help you name things and avoid magic numbers. Obviously as a novice you are not going to have great judgement about when globals are needed, but always ask yourself if there's any other way you could accomplish the same thing. The bad thing about globals is that they make it harder to reason about your code and thus add complexity. They also make changing your code more difficult.
&gt; They are actually good practice in many cases because they help you name things and avoid magic numbers. Is a const global better practice than `#define` when trying to avoid magic numbers?
Or `gettimeofday()`.
&gt; ``` This syntax doesn't work on reddit.
it's osx, so I don't think that'll work
&gt; I originally thought it meant 0 cast to void * or any integral constant cast to void * You seem to have misread the text you quoted from the standard: &gt; An integral constant expression with the value 0, or such an expression cast to type void * "such an expression" means "an integral constant expression with the value 0" 
Each time you call fscanf() you're storing a float in an element of the array. Which one? Does it change the next time fscanf() is called? Deleting the commented out bits might help make it clearer.
If that's the only change you made to the posted code, it's still incorrect. What value does `i` have the first time you scan into `diff_arr`?
It appears that you are programming in C++. C++ is off topic in here, please post C++ questions to /r/cpp_questions. I have removed your post as it is off topic.
Another issue with globals is that they make threading pretty tricky. Note the random functions and their thread-safe variants. 
Thank you for all the input everyone but unfortunately none of these have worked. I've tried the below code with clock_gettime and with clock_get_time and neither have yielded the correct result. I haven't tried gettimeofday() yet but FUZxxi is saying this won't work either. Any other thoughts? 
So would an unsigned short also do the trick in addition to uint16_t? EDIT: Also I just tried that. It is definitely an improvement! But I still get 0000 0000 between each of the lines that I want to keep. I'm not sure where this is coming from and how to remove it....
Be familiar with the way the C programming language is turned into machine code and be familiar with the tooling your development environment provides. It is clear from the code that you need to guess the address of `win` (times four). Now, if you are programming on a UNIX-like system, you should definitely know about the tools provided by the platform such as `nm`, `size`, `ld`, `ar`, etc. Then it's just an exercise in using the right tool to find the information you need.
`'Add'` is not the same thing as `"Add"`. If you try compile your code with `-Wall -Werror` it will fail. When referring to strings you must use `"`.
This could be a problem with [endianness](https://en.wikipedia.org/wiki/Endianness). You have to know whether your binary format requires big endian or little endian and write your data accordingly. If your program is the one both writing and reading there'd be no issue. But if another program is reading the file, that program makes an assumption about the endianness of the data. This is one reason that for small amounts of data it's often best to just use ascii.
In addition to henry_kr's comment, be aware that C doesn't support comparison of string values using the equality operator. You'll have to use strcmp(string1,string2) or strcmpi to determine whether they match.
I don't want to do people's homework, at the same time it's nice to have an example. Data structures are your friend. Not only can they make your code more readable, they can make it easier to reason about and write a solution. It sounds like you want to create a binary file that just stores coordinates, say x and y of uint32_t. Then it is probably wise to create a data structure with that form. Then you can read and write that data structure in binary form. I've written an example based on what code you provided. It's probably not the best implementation (some c89 people will be unhappy with not declaring vars up front, etc.) but it should show the general idea. You can improve this implementation by writing your own functions that deal with arrays of coordinates, and even create your own dynamic arrays of coordinates and pass them around. #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; struct coord { uint32_t x; uint32_t y; }; void write_coord(FILE *fp, struct coord *c) { fwrite(c, sizeof(struct coord), 1, fp); } int read_coord(FILE *fp, struct coord *c) { return fread(c, sizeof(struct coord), 1, fp); } void print_coord(struct coord *c) { printf("{x:%d, y:%d}\n", c-&gt;x, c-&gt;y); } int main() { const int MAXLEN = 10; FILE *fp = fopen("foo.bin", "wb"); if (fp == NULL) return -1; struct coord c1 = {3, 5}; struct coord c2 = {1, 9}; write_coord(fp, &amp;c1); write_coord(fp, &amp;c2); fclose(fp); fp = fopen("foo.bin", "rb"); if (fp == NULL) return -1; struct coord *coords = malloc(sizeof(struct coord) * MAXLEN); int count = 0; while (count &lt; MAXLEN &amp;&amp; read_coord(fp, &amp;coords[count]) &gt; 0) count++; fclose(fp); for (int i = 0; i &lt; count; i++) { print_coord(&amp;coords[i]); } return 0; }
BTW, this solution will perform the "padding" you desire, and you won't have to worry about endianness. As long as the coordinates you construct fit within uint16_t then there will be 2 bytes of zeros that will pad the 32 bit numbers.
Also, == is used for comparison, not assignment. You will need to change all the lines that compute the result. For example change: numberone + numbertwo == result; to result = numberone + numbertwo; You are also passing the address of the result to printf, when you just want to pass the value. Remove the &amp; in front of 'result' in your printf calls. What compiler are you using? gcc gives me a ton of warnings when compiling your sample. You should **not** ignore warnings, or at least not until you know what you are doing.
Thanks for help! It works now. Here's the changed code. https://codepaste.net/y9r8me I don't know why but numberone+numbertwo=result didn't work. I had to change it to result=numberone+numbertwo, any idea why the first one didn't work?
 state == IN;
Hello! Another C n00b here but maybe I can give little help. num&gt;=20-60 &lt;---- I think it may mean num&gt;=-40. You may have to use the operator &amp;&amp; like num&gt;=20 &amp;&amp; num&lt;=60 . No idea if I'm right just wanted to give my 3 cents, so any more advanced people feel free to correct.
Thanks for you answer! It totally makes sense now. The example of x = y is great. EDIT Typo.
It looks like you already found your answer, however have a look at this if you will, [C/C++ operators](https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B), it could save you some time in the future.
Sure... #include &lt;stdio.h&gt; #include &lt;stddef.h&gt; typedef int (*fn_def)(void); int test1() { printf("Test\n"); } int main() { void* fnvptr = (void*)&amp;test1; fn_def fnptr = (fn_def)fnvptr; fnptr(); } 
[PGM](https://en.wikipedia.org/wiki/Netpbm_format) is an easy to use greyscale image format. 
 http://prog.re/blog/2017-02-08.html its python but porting to c should be trivial. You can use the std out trick as is
Any C PNG library would work, as well.
&gt; (DO NOT store the random numbers - just the counts) Looking at this line: &gt; `array[x] = ray;` you're doing exactly that. Also, what is `a[x]` referring to? What is the exact assignment description anyway? It looks like you are supposed to be generating a bunch of random numbers in a certain range (1 - 100?), then count how many times the number 1 has been generated, the number 2, etc. Is that correct?
[Farbfeld](http://tools.suckless.org/farbfeld/) is very nice too. Just a look to a glance at some program that use it should get you started.
I think you wanted to post that at r/learnprogramming, not here.
What operating system are you programming for? If Linux, what distribution? On some systems, you need to install a separate development package for each library for the headers to be present.
Glad you got the program working! I used to use Dev C++ on Windows 7 which is an IDE like Codeblocks, but now that I'm taking harder courses in college, I find it much easier and more efficient to use Linux and use Vim to code in the terminal. I wish I started using Vim earlier lol.
sorry for a [x] I meant array[x] not really sure if thats right anyway. In this program I created a file with two numbers, the first one is the seed and the second is the count. In a previous function I read the file and stored it as the seed and count. Then I used the withinRange function to make sure the numbers are in a specific range. Then I used a validateInput function to display error messages is the file numbers were out of range. Now I am supposed to create a random number generator that creates numbers between 0 and 99. The program should then count the number of occurences of every number and store the counts as an array. 
the array is going to be 100 numbers. 
not sure I understand.
Ah, assumed to post here as it was c related
A normal thing would be for the server to `bind` on `0.0.0.0` meaning "any interface". `127.0.0.1` means "this machine" so this is what a client could `connect` to, asumming its running on the same machine as the server.
Okay, so does address 0.0.0.0 put the server on all interfaces including the loopback interface then?
Not all interfaces, only those with an IPv4 address. "::" binds to any IPv6 address, and also any IPv4 address if supported and configured in the operating system.
Hey guys, I'm new to C and am writing sorting algorithms to teach myself the basics. Is it normal to return an array as part of a sorting function? Is it OK to declare the functions inside a header file? Is there anything else I'm doing strangely? I really appreciate any suggestions
Well, you are doing the sorting in place anyway, so returning `arr` is kinda pointless, no? Declaring functions in header files is not typical, typical would be having headers in header files, and actual implementation in c-files. However, if making a library, and if that library is simple/small enough so everything can fit in one file, then sometimes people put the implementation directly in the header file so that the user only has to download/copy a single file.
for example when reading from the file players would look like ["Jim\000\000\000\000\000\000", "Bob\000\000\000\000\000", "Mike\000\000\000\000"] i need to get rid of the "\000" so it looks like ["Jim", "Bob", Mike"]
The thing is, strings are terminated by the null byte in C, which means that you will want at least the first null byte to remain. Also, most functions that work on strings stop reading buffers at the first null byte encountered, rendering the rest of the buffer irrelevant. Finally, if you want exactly what the last array you wrote, you will need to dynamically allocate each element to be the exact size you want, the rest of the array won't disappear like magic.
It's more idiomatic to declare your function like `void bubble_sort(int *array, size_t size);`. * You don't need to return the pointer; the caller already has it. The caller gave it to you, remember. Returning the pointer might lead to some confusion: Is the function modifying the array I'm passing? Is the returned array going to be a sorted copy? Do I need to call `free()` on the returned array when I'm done with it? The declaration `void bubble_sort(int *array, size_t size);` only lends itself to a single interpretation, which is a good thing. * I don't know why `int *array` is more idiomatic than `int array[]`, but it is. Note that there is some debate between `int *array` and `int* array`. Both proponents are ... they can be vehement. * Use `size_t` to pass sizes. It's 32 bits on 32 bit machines, 64 bits on 64 bit machines, and does not wrap around to negative numbers. * *Declare* a function in the header, (the .h file) and *define* the function in a .c file. If multiple parts of your program include this header file, it will fail to compile. The terms "declaration" and "definition" are not interchangeable; make sure that you know the difference. The declaration is what the function looks like (has the semicolon after the closing parenthesis of the argument list) the definition is what the function does. (has all the lines of code in it between curly brackets) * It is acceptable to put definitions of *very* short functions (1-3 lines at most) as functions declared `static` or `static inline` in header files. Keep these to an absolute minimum. * Take some time to understand how to compile multiple C files into a single application. You need declarations in .h files, definitions in .c files, and [include guards](https://en.wikipedia.org/wiki/Include_guard#Use_of_.23include_guards) in your .h file.
Thanks :)
Why are you testing to see if fp is NULL before initializing it with an fopen() call? 
If the user will input the array size, then you have to 'dynamically' allocate the array after getting the input from the user. A static memory allocation like this: int n[ 100 ]; ...won't serve you. See? It's size is set at 100 at compile time (static). No good for this code requirement. Instead -- small hint: int *n, user_size = getUserInput(); n = malloc(user_size * sizeof(int)); 
Sorry, been busy traveling. Just got back and had to catch up before delving back into Reddit. That job wasn't all that exciting. Look up the company called [Rhino Robotics](https://www.rhinorobotics.com/). Back in the early 80s, I developed some of the software for their [early robots](http://www.theoldrobots.com/rhinoarm2.html) (XR-1 or maybe an XR-2 early prototype, don't remember clearly anymore). As a consultant, I was originally assigned to port some of their existing software, but quickly realized it was fundamentally flawed due to an erroneous geospatial engine. I threw out their old engine completely and I quickly redesigned a new program for them from scratch. The job only lasted about 5 months, but I learned a lot from that job. Not just about robotics and refreshing my geometry and numerical analysis knowledge, but when debugging problems, look beyond what you know and educate yourself constantly on what you don't know. I also learned about work environments. If you're promised anything as part of a job, *never* take someone's verbal word. *Always get it in writing*! Also, small companies are often run by people who are arrogant and self-aggrandizing and think they are better than others. Big companies are too, but those people in a small company have a stronger, more direct influence. Even though I showed them just how broken their software was and how good my software was instead, including my new test suite to prove it, they didn't want a good engine. They preferred their junk and were mad at me for fixing their software. Without any explanation, they wanted me to throw out all my good code and redo it to use their seriously buggy code. At that point, I quit. Three weeks later, one of the employees I had been working with closely called me and told me they decided to ship with my good code. That made him happy. My guess at what had happened was the original software was written by one of the big shots at the company and he didn't like being shown up with how flawed and broken it was.
When a pointer, 0 is called NULL. You literally just do `uint64_t *Pointer = NULL;`
To let the user input values you'll need to have `scanf("%d", &amp;n[i]);` inside the `i` loop, or something similar. If you want to restrict the user's array size to 100 then your current definition of `n` is fine.
 termInfo.c_lflag = 0; termInfo.c_lflag = 1; You need to change these 2 lines so they use the ECHO constant. It may not be 1. And then you need to tell the operating system to use the new values.
&gt; n = malloc(user_size * sizeof(int)); I prefer: n = malloc(user_size * sizeof(*n)); The reason for this is because it is immune to changes of type of n (e.g. if you decide to change n to a *long, you run the risk of forgetting to change the malloc line) 
Do you mean a null pointer? It wouldn't work since then you can't specify the port. (BTW "::" is the IPv6 address containing all zero.)
`c_lflag` is a bitmask. you shouldn't set it to zero or one. Instead, use `&amp;` and `|` to flip bits: termInfo.c_lflag |= ECHO; /* turn on ECHO */ termInfo.c_Lflag &amp;= ~ECHO; /* turn off ECHO */ Note that you need to use `tcsetattr()` at the end to give the terminal your updated configuration.
no sorting necessary just successively swap the first character with the last character, moving inwards at each swap
if you read input into an array via gets for example then the array will be a proper null-terminated string and the last element will be offset by strlen(array) post the relevant code to give a better idea of where you're going with this :P
Right there. ===&gt; Hard to miss It's right under **Resources** 
Never suggest using gets().
 /* C strings are terminated by a null character '\0'. The length of * a string can be determined using the `strlen` function. */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; char charbuf[256]; int main() { charbuf[0] = '1'; charbuf[1] = '2'; charbuf[2] = '3'; charbuf[3] = '4'; charbuf[4] = '5'; charbuf[5] = '\0'; printf("strlen = %lu\n", strlen(charbuf)); printf("charbuf = %s\n", charbuf); for (size_t i = 0; i &lt; strlen(charbuf) / 2; i++) { char temp = charbuf[i]; printf("Swap %lu and %lu\n", i, strlen(charbuf) - 1 - i); charbuf[i] = charbuf[strlen(charbuf) - 1 - i]; charbuf[strlen(charbuf) - 1 - i] = temp; printf("charbuf = %s\n", charbuf); } printf("strlen = %lu\n", strlen(charbuf)); printf("charbuf = %s\n", charbuf); } 
I have removed your post as it is a [repost](https://www.reddit.com/r/C_Programming/comments/61hnwi/c_project1_scientific_calculator_with_source_code/) of something you submitted just to weeks ago. Please don't repost your content in quick succession.
what does the a do?
The `a`is just to show the size of the random number array. You can throw it away. Actually, I coded it wrong, too, it was meant to sum all counts, so, `a += count[i];` not` a++;`. You already have your function there, just put the last `for` inside a function and pass the array pointer and size, the code will be the same. If you don't want to print zeroes, a `if` before printing solves it. If you generate 100 numbers, it's not a uniform distribution with zero standard deviation, you might get only one number 100 times. Chances are low, and you just wasted your chance to win on lottery, but... it happens.
because when I use count[number] i get errors saying expression must have a pointer to object type
Do you memset your array to 0?
Read C Programming by King, do the problems. When you're up to it, try doing all the problems in K&amp;R. Also, have you heard of the course CS50? Check out r/cs50
I'm not sure, do I need to?
Unless you know what you're doing, yes.
When you write array[], you are requesting as parameter a pointer to the start of the array. So, you can call your function with arguments `generateNumbers(array, seed, count)`, but remember to put no brackets on `array`, because your function doesn't want an element, it wants the entire array. Your code will work, just change `ARRAY_SIZE` to `count` and `i` to `x`, declare `number` and `count`is not an array, it's `array`, but that's the idea.
&gt;gets considered harmful lets just not use c at all then
my vote goes to "Modern c" by K N King
FUZxxl is correct. When a file is open as a text things behave differently.
I'm not sure this is a wise undertaking. What exactly does this provide over TCP? Sure, TCP is complex and not great if you are worried about latency, but every choice in TCP was made to address an issue and for a reason. Of course, there are problems with TCP and sometimes the left hand didn't know what the right was doing (e.g. Nagle's algorithm plus delayed ACKs, added independently around the same time). Still, TCP is a time tested protocol that considers a wide range of possible issues that could arise in a real-world networking environment and addresses them. It seems that you are attempting to create an interface similar to TCP but just ignore all of those issues. Right out of the gate, I see a big issue with this: what if I send a message much larger than the MTU? It seems that currently, you just send it with one call. That will behavior very poorly with the UDP protocol (basically, the probability of a message being lost increases exponentially with the length of the message). Another issue: what if two peers try to connect at the same time? In fact, what if a peer you aren't expecting tries to send data? it seems like the `udp_conn_recv` doesn't actually check that the data it receives is from the peer it is expecting (`udp_conn` defines a `dest_addr`member but never actually does anything with it). I'm sure that this works great for your use case, but I think if you are going to release it into the world, you should document that use case. This wouldn't be appropriate for a situation where only one of the ends of a connection can be trusted, for example. I think you should explain why you made this, what it does, why it does it, and who should use it and for what. Also, I would ask you to please not do [this](https://github.com/vietjtnguyen/udp_conn/blob/master/udp_conn.c#L189): bytes_recvd_out &amp;&amp; (*bytes_recvd_out = ret); It's exactly the same as if (bytes_recvd_out) *bytes_recvd_out = ret but a hell of a lot less readable.
Nothing wrong with having srand in the function since it's likely only called once
What does the function return? If it returns a single `char` and you want to set each entry of the array to that `char`, use `memset()`. If it returns a pointer to some array, use `memcpy()` to copy the data.
Thanks for the feedback. First, regarding the readable `NULL` check, you're totally right. Change made. As for the rest, I think this is a case of just poor name selection (is one of the hard problems right?). Maybe it should just be named `bidir_udp` or something like that (suggestions welcome). It really isn't meant to be a "connection" and all of the robustness that implies. It looks like a toy because it practically is because it's for the case of two known end points talking to each other using UDP and some developers who aren't that savvy with sockets. What do you think, `bidir_udp` sound right?
I'd call it udp_pair or something like that because it sounds like you're essentially pairing up two UDP streams as server/client.
You can `malloc` some memory inside the function and return a pointer to that. E.g char *my_fn() { return malloc(20); } int main() { char *array = my_fn(); /* Do stuff */ free(array); } 
If you are using a C99 compliant compiler, you can indeed define your own variable length arrays where you specify the size of the array at runtime. For example: #include &lt;stdio.h&gt; int main() { int n; printf("Enter the size of the array: "); scanf("%d", &amp;n); // define the array of size n int arr[n]; for (int i = 0; i &lt; n; i++) { printf("Enter element %d: ", i+1); scanf("%d", &amp;arr[i]); } for (int j = 0; j &lt; n; j++) { printf("%d ", arr[j]); } printf("\n"); printf("array length = %lu\n", sizeof(arr)/sizeof(int)); return 0; } Sample run: $ gcc -Wall -o variable_length_arrays variable_length_arrays.c $ ./variable_length_arrays Enter the size of the array: 3 Enter element 1: 1 Enter element 2: 2 Enter element 3: 3 1 2 3 array length = 3 $ ./variable_length_arrays Enter the size of the array: 6 Enter element 1: 1 Enter element 2: 2 Enter element 3: 3 Enter element 4: 4 Enter element 5: 5 Enter element 6: 6 1 2 3 4 5 6 array length = 6 
Thanks, i added the line breaks. I use this function to hide only the user inputs so it must be stdin.
Oh this sounds cool! Out of curiosity, why not go for utp? Or is that too different from your intended use case? Thanks!
Why not? It's possible to return a pointer an array.
No wonder everybody's downvoting this without even commenting! No, you're of course right. What I had meant with that comment is that my understanding is that OP originally intended to have something like so (especially since he mentioned initialising an array with the return value): int[] get_my_array() { // create some array // populate array with useful values // return the array } and then use that returned array to directly initialise some other array in his client like so: int main() { int[] brand_new_array = get_my_array(); // use array for fun and profit! } And of course, that works nicely in many languages (including languages considered to be systems languages), but unfortunately not in C. For instance, in D, import std.stdio: writeln; void main() { int[5] brandNewArray = getMyArray(); foreach(elem; brandNewArray) { writeln(elem); } } int[5] getMyArray() { int[5] arr = [1, 2, 3, 4, 5]; return arr; } $ dmd -run return_array.d 1 2 3 4 5 As also in Rust: fn main() { let arr = get_my_array(); for e in &amp;arr { println!("{}", *e); } } fn get_my_array() -&gt; [u32;5] { [1, 2, 3, 4, 5] } $ rustc return_array.rs $ ./return_array 1 2 3 4 5 and many other languages. It's no stretch of the imagination that OP might have imagined this scenario. 
Have you tried using gdb, valgrind, or simply [sanitizers](https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html)?
I'm no expert. But are you checking if hamming_string is not null? malloc will return null when it fails. You should always check that. Also, I think scanf should not be used to take inputs from user. I don't remember the alternative function name. I'll get back to you afterwards. Edit: ok, I remembered I used to use getline function. It's safe then scanf. Read man. 
Yes so i enter 1000110 as hamming_string. let me run though some test cases and get back to you
So the program crashes at scanf (line 27), as i entered a printf statement right afterwards and it didnt even get to it
In C, if you declare the array static, you can return the actual (not garbage) values: #include &lt;stdio.h&gt; int *getMyArray() { static int arr[5] = {1, 2, 3, 4, 5}; //declare as static return arr; } int main() { int *n = getMyArray(); printf("%d %d %d %d %d \n", n[0], n[1], n[2], n[3], n[4]); return 0; } Runtime out: 1 2 3 4 5 
Of course, but the problem with that is that the client needs to know the size of the array, isn't it? In other languages, because arrays are essentially "fat pointers", the client doesn't have to worry about that.
correct, i didn't mean to present that as an end to all troubles.... just showing it's do-able. To discover size, you have to get creative -- like for char strings, the last char should always be NUL so we can easily discern it's size (length) with a function like strlen(). For other scenarios, we can insert negative 1 (-1) (or some such) in the last place, and we can parse the array until we find that value, etc... 
Agreed. That's why it's almost always easier in C to allocate in main, and then mutate the array inside the function. That way the client always knows how much it has allocated. For char arrays, the approach works fine due to `NUL`, but using sentinels with numeric arrays has always been iffy since the sentinel itself might represent a valid input value, unless we know that the problem domain can't have that as a valid value.
&gt; using sentinels with numeric arrays has always been iffy since the sentinel itself might represent a valid input value, you said a mouthful there ;) -- a decades-old problem. 
And after all this discussion, it's almost comical that we really still don't have much clarity on the OP's request/issue. (Vague question -- has not come back to clarify) This horrible code will actually do what he asks -- but I doubt it's what he wants: #include &lt;stdio.h&gt; int foo() { return 0; } int main() { char arr[sizeof(int)]; int iii = 0; *(( int *)arr) = foo(); while(iii &lt; sizeof(int)) printf("%d ", iii++ ); return 0; } 
Valgrind and gdb are indeed what you should use here. One quick note though: using `scanf` to read in a string is very dangerous since it's very easy to invoke undefined behavior by accidentally reading a string that's too long. Of course for this pset you can assume the length that you read in is correct but in general you should really use `fgets` instead. In any case, it seems to me like you're not allocating enough space for the NUL byte.
Write a function, for example, precess Which takes user input as an argument and returns the sum.
This question is solved by Google in 30 seconds. How do you want to pass the course if you can't even do this? An 8 year old could do better. 
Not sure pointing a newbie at VLAs, when the simple solution is to use dynamic memory allocation, is a good idea.
Lol I'm still here. I just hate pointers and C in general. 
I'm on mobile now so I'll avoid a code sample, but back to the list example: you could make a header with all the functions you need to deal with a list. The function prototypes don't need to know if it is an array list or a linked list. You can just add data to the list, get the nth element from the list, etc. The distinction happens at link time when you choose to link against one implementation or the other.
To expand off of /u/necheffa, here is a basic implementation for a stack ADT implemented in C. This implementation ignores some basic boilerplate. // stack.h typedef struct stack_ stack; void stk_push(stack*, int); int stk_pop(stack*); // stack.c --&gt; Everything in this file is hidden from the end user struct stack_ { size_t size; int* data; // other stuff you may want } void stk_push(stack* s, int n) { // if the stack is full, expand it somehow, and dd // n at the top of stack. Otherwise, just add to top. } int stk_pop(stack* s) { // return the element at the top of stack, decrement size, // possibly rescale array. } Now, whenever you want to change the implementation of the stack (say, have it be a doubly linked list) all you have to do is recompile the object file. No software using the stack ADT needs to be changed (but potentially recompiled).
In ASCII, all letters are next to each other. So for example, `'A' + 1` yields `B`, etc. You can print out single characters with the `%c` directive. This should allow you to solve the questions you have.
So what's your question? Best approach: break it down into smaller problems. You are asked to show a menu. Was is a menu and how does it work? What do you need to do to show some options, let the user pick one and figure out what they picked? You can write that independently of the rest of it, and it makes for a smaller, more easily understandable problem. Sam with the rest of the requirements: show a time adding two times together? Write that separately, run it and make sure it works, then hook it up to your menu. Same with he other options: take an iterative approach.
For the future this is a better question for /r/learnprogramming but like /u/FUZxxl said you'll need to learn the char variable type and ASCII characters. You can declared a character variable like an int. &gt; char charA = 'A'; Printing a char is like %d but with %c and you can walk up and down the ASCII character table using simple integer math. 'A' + 1 etc. This is because characters are actually stored as ints representing their ASCII value. If you print a char using %d you'll print the corresponding int value for your char instead of the actual char.
The reason those are good practice is that not following them tends to create code that is difficult to understand and debug. Generally, I'd say following the global variables rule is more important than the too many arguments rule. But, still, if you find yourself frequently creating functions with more than, say, 5 parameters or so, you might want to rethink your design. Both of these are kind of geared towards thinking about data structures. Data structures are useful in a few ways: - They organize the data you're working with into aggregate chunks. Then you can pass around a pointer to one of those chunks, rather than passing all of the data as individual variables. - They create layers of abstraction. A good layer of abstraction allows you, the programmer, to think of the aggregate as a single thing that supports different operations as a whole (rather than a bag of individual things). - Some data structures give you emergent properties that are important for performance. The simplest data structure is just a struct that contains a list of individual fields. Perhaps your game needs a "game_state" struct. Inside it, you'd have all the variables that represent the current situation in the game. Then instead of passing around those variables individually, you'd just pass a pointer to your primary instance of the game_state struct. Maybe your game needs a list of enemies the player is currently engaged with. So you have an array that contains entries for each enemy. Each of those entries might be a struct w/ multiple variables on its own. And then the game_state has a pointer to the array as a whole. Any function that you pass the single game_state variable to will be able to access both the general state variables for the game and also variables associated with each of the enemies. Make sense? 
&gt; I'm not sure i would be too worried about having too many arguments though. It's certainly not something I think too much about. I agree that it isn't a death knell, but if you write unit tests for your code it is nice to not have 20 arguments to a function.
If you use `\t` in the printf statement, it will add a tab. It's more compact than using all those spaces. printf(" Time Treatment\n --------------\n\n"); becomes printf("\tTime Treatment\n\t--------------\n\n"); Add more `\t`s as needed.
It works for me.
The indentation is a mess ... those lines are in main.
Wow that NULL pointer dereference case is so blatant if (ha == NULL) { device_printf(ha-&gt;pci_dev, "%s: arg == NULL\n", __func__); return; } Is there any justification behind this? How could they have overlooked this? Are there any cases, or compilers where they might allow this to be legal?
I came to post this. How does this even happen? The originally coder is drunk or something? The author of the paper states they found in 3 other locations. Possible this is some kind of automated/boiler plate code or something?
that was the case in my computer as well, but I viewed this again here and it showed me outside. Compiler should'd raised an exception for being outside of main there with } as well 
Oh goodie I forgot I could do that! Thanks!!
I tend to use a semi-object-oriented approach. In the header, I'd have something like: struct GameScreen; struct Enemy; typedef struct GameScreen* HGameScreen; typedef struct Enemy* HEnemy; HGameScreen MyGame_GameScreen_Initialize(int width, int height); int MyGame_GameScreen_GetEnemyCount(HGameScreen screen); void MyGame_GameScreen_Dispose(HGameScreen screen); HEnemy MyGame_Enemy_Initialize(const char* name, int skill); void MyGame_Enemy_Move(HEnemy enemy, int x, int y); void MyGame_Enemy_Dispose(HEnemy enemy); Then I'd put the actual definitions of those `struct`s in the source file. This makes it so that within that source file, you can see all the members of the `struct`s, but other files that include your header can only use pointers to them since they don't know the definition. I prefer to `typedef` handle types like I did above to sort of hide that they are `struct`s and emphasize that all a user of the code needs to care is that they're an opaque type.
`numberone + numbertwo = result` won't work because it's not a mathematical operator. It assigns the value on the right to the variable on the left. If it didn't, you couldn't do something like `x = x + 1`.
It's impossible to come up with a good answer without knowing you or your goals. C is a beautifully simple language, which is what made it great for me to learn, but C++ offers much more in it's standard library for someone to pick up and use right away. These are just two of the many differences that make each one good for learning. The best one for you is whichever is easier for you to stick to. For me, that meant C. For many others, maybe that is C++.
If your end goal is to learn C++, then learn C++. If your end goal is to learn C, then learn C. There is zero reason to learn C if your end goal is C++. While there is a common base, modern idiomatic C++ looks nothing at all like C. Treating C++ as if it was "C with classes" leads to terrible habits that have to be unlearned. C++ has a completely different philosophy and approach to problem solving.
Oh man, you've put me on the spot lol
What are you trying to achieve by storing the string in a different section?
This declares `x`, `i`, `num`, and `j` as integers. At the same time, `x` is initialized to zero, the others remain uninitialized.
It's exactly as /u/FUZxxl says. But if you're not familiar with that idiom, you may be interested to learn that int x = 0, func(int); is also syntactically correct.
The inefficiency is in your time. If you spend an hour optimising something that doesn't need it then that's an hour wasted.
Personally, I would use int i, j, num, x = 0; Since i and j are likely iterators for for loops, num and x are some other variables with some special meanings, and the declaration comes last so it is more obvious. I would not use four lines for int variable declaration because it reduces the amount of total code on the screen at a time. As long as the long line of code is under 80 characters long, it's perfectly readable, imo.
Pretty sure he means that the languages are different - just as C and C++ :)
The quote doesn't have anything to do with compiler optimizations. It's talking about things that people do, in particular focusing attention on things that don't matter. For example someone might spend some amount of energy trying to make a certain function a few milliseconds faster. They might spend several hours doing this, and the result might be code that is harder to read and harder to maintain. But often that function is only called a few times and never in the hot path. Saving a few milliseconds when the overall program takes, say, twenty seconds to perform its task is completely meaningless. It's a drop in the ocean. The person spent all that time and ended up with worse code, all for being able to say "look, I made function foo() twenty percent faster!" which is utterly meaningless in the ultimate scheme of things. Twenty percent of nothing is nothing. It is very easy to get caught up in micro-benchmarks that are completely misleading. In order to optimize effectively you must profile, so that you can know what is actually taking the bulk of the time, in order to know where to focus your efforts. And in many cases the largest gains come from algorithmic changes, not minor tweaks. 
That's the joke.
Ya totally agree man, i usualy stay on top on things.. I just got super lost with school. BTW, i inboxed it to you. 
If they're so different that they should be learned completely separately, why are they so often packaged together as "C/C++"?
You can write and compile C using a C++ compiler.
&gt;But no-one writes it in 5 lines when they can condense it to a single line. Speak for yourself. 20 years ago I was proud of what I could cram into one dense line of C. Now everything gets formatted with safety and readability first. I only condense things when expanding them makes them *harder* to follow.
So is this: typedef int num, *num_pointer, (num_array)[8], (num_func)(void);
Wow, you learn something new every day!
You are totally clueless.
How does it happen? Obviously it's way over your head and you wouldn't understand the reasoning behind it.
Thank you for showing your idiocy for all the world to see. I know you are an idiot because you posted that.
Is there something wrong with checking for NULL in functions? I've been adding that to my functions lately to take care of the low hanging buggy fruit.
I personally enjoy writing C far more than C++. However if you have a need to write C++, then write C++. However, C can do everything C++ can, however it is simply structured differently. C isn't an OO language like Java or C++ so it might be a bit more effort to transition to it from Java.
Your question isn't at all clear. Are you asking for the size of the structure, or the size of a pointer to the structure? In either case: #include &lt;stdio.h&gt; struct xyz { int t; char name[20]; }; int main(void) { printf("the size of the struct is %zu\n", sizeof(struct xyz)); printf("the size of a pointer to the struct is %zu\n", sizeof(struct xyz *)); } Note that on all but the most obscure hardware platforms (i.e. nothing you're likely to ever encounter) all pointers are the same size, regardless of the type of object they point to, so `sizeof(void *) == sizeof(double *) == sizeof(struct xyz *)` and so on. 
You keep implying there is some deep reason for this, enlighten me I'm genuinely curious 
consider: int x; printf("The address is of size: %d", sizeof(&amp;x)); prints 8, and was thinking a similar strategy could work for structures. &amp;x is the address of x itself, I wanted to know if structure's own address could be of a variable size.
Have you looked into [XkbSetDetectableAutoRepeat](https://linux.die.net/man/3/xkbsetdetectableautorepeat)? I vaguely remember having to disable keyboard autorepeat on X11 when writing a game a long, long time ago. That function is probably what I used.
+1 To those starting out; please don't write garbled code. Readability should always be at the forefront. The assumption that you're writing code for someone else to maintain should be front and center, cuz... That's exactly what we're all doing.
Well, x is not a variable. It's a typedef. You can't get the address of a type. A pointer to an object does not vary in size. They are always the same size.
That's almost what I meant. The struct code block is also in memory right? so why can't we do this: https://pastebin.com/4T5V5Ejp
On Windows, you basically have three options: an actual mutex like you mentioned, a critical section, or, if your accesses are simple enough, you may be able to do interlocked exchanges. These choices involve tradeoffs between versatility and performance, with the mutex being on the high-versatility and low-performance side of the spectrum (relatively speaking anyway; it's still quite fast) and the interlocked exchange functions being the least versatile but fastest mechanisms available. There's a good discussion of the different mechanisms [here](https://software.intel.com/en-us/articles/choosing-appropriate-synchronization-primitives-to-minimize-overhead), and the Microsoft synchronization library documentation can be found [here](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686353\(v=vs.85\).aspx).
Thanks. Let me read through what you provided before I reply with additional questions.
The 'ol saying: Its easier to optimize a working program than it is to get an optimized program working.
&gt; KNowledge of FreeBSD Kernel internals isn't necessary And you are the poster boy for that.
Thank you for proving my point.
It reminds me of the time some street tramp tried to give me clothing advice.
You are offended that I'm calling out the clueless idiots who are trying to contribute to something they have no knowledge of?
Funny how you berate me for doing the same thing you are doing now. But this is reddit, where reality is nonsense.
You have still not posted a single argument in support of your point. Instead you defer to an unlinked discussion that is supposed to make some sort of point. Perhaps you could at least tell me where to find said discussion and what the argument is? I mean, if you can't even tell me what the argument is, it's probably not very convincing.
it didn't have the code lined up
I've been using Linux for like decades, always just used bash for my shell. Could someone explain to me why I would use this over bash? Just curious :)
Nice name OP! For others Khol is hindi for shell.
That function doesn't disable autorepeat, but it allows YOU to detect when a KeyPress event is due to autorepeat or not (so you can effectively "disable" it). That page explain it in more detail, but basically: - normally, when the user holds down a key, the X server sends repeating KeyPress/KeyRelease events to simulate autorepeat - if you enable "detectable autorepeat" (and the X server supports it), then the X server will only send repeating KeyPress events, with no KeyRelease until the user actually releases the key. To enable "detectable autorepeat" you must do something like: Bool autorepeat_supported; XkbSetDetectableAutoRepeat(display, 1, &amp;autorepeat_supported); Try adding that to your test program before the `while(1)` loop. If you hold down a key, it should print a lot of "KeyPressed" events, and when you stop holding the key down it should print one final "KeyRelease" event.
P threads can only be used on Unix systems right? 
Exactly, thank you for explaining! And yes, this was more a self-teaching thing and I am planning to extend it as much as possible.
Any POSIX compliant system, so any Linux, macOS, Unix-like would, but there is also packages for windows. The underlying concepts are the same regardless of which thread library you use. 
Damn.... That's a tiny bit harsh don't you think?
To clarify this further for beginners, while ((to[i] = from[i]) != '\0') actually checks whether `to[i]` is `NUL` or not. This means, obviously, that `to[i]` is indeed `\0`. In C, assignments have a value (unlike some newer programming languages). The code makes use of that in this example. 
Makes a handy starting point for someone who might have an experimental shell feature they'd like to try.
Note that function pointers can have a different size than data pointers.
I guess I am speaking for myself (original comment edited to reflect this), but I fail to see how int i, j; is "harder to follow" than int i; int j; They're both equally as clear, and the first one saves valuable screen real-estate.
Thanks so much! I guess this was the whole point of posting it here. I will take a look at your comments soon.
Yep, I don't have multiple pipes working. I got one pipe working (i.e. two comands) but I remember struggling with it for atleast five days. Multiple pipes working is definitely on the TODO
Yes. That's true, though situations like that are quite rare. I think in C++, there can be "fat" function pointers, which store more than just the address of the function so that pointers to lambda functions and virtual functions can be resolved correctly.
At first glance those all seem very simple. Hopefully I can knock them out without much trouble and get a little confidence boost :) Thank you for the recommendation. I'll especially spend some time on the C-isms you mention. I have no formal training and I know *my* answer to these types of questions but it may not be 100% correct.
This subreddit is for programming in C only. Please post C++ content elsewhere. I have removed your post as it is off topic.
C doesn't have any form of type metadata; so, when your program is running, there is absolutely nothing in memory that corresponds to `struct xyz`, `int`, `double`, or `const char*`. They're only ever in memory when you're compiling your code. If I have this code: #include &lt;stdio.h&gt; struct xyz { int a; int b; int c; }; int main(int argc, char* argv) { struct xyz abc = { 5, 6, 7 }; printf("%d\n", abc.b); return 0; } It compiles to: _main: push ebp mov ebp, esp and esp, -16 sub esp, 32 call ___main mov DWORD PTR [esp+20], 5 mov DWORD PTR [esp+24], 6 mov DWORD PTR [esp+28], 7 mov eax, DWORD PTR [esp+24] mov DWORD PTR [esp+4], eax mov DWORD PTR [esp], OFFSET FLAT:LC0 call _printf mov eax, 0 leave ret Notice that the numbers 5, 6, and 7, which correspond to `abc.a`, `abc.b`, and `abc.c` just get put into the addresses `esp+20`, `esp+24`, and `esp+28`. There's nothing that even says they're part of a struct. The CPU doesn't care that you made that struct in your code. It just needs to know there are 3 `int` values and where they should go in memory. (The syntax `mov DWORD PTR [whatever], number` means move value `number` to memory location `whatever`, which is 32 bits wide.) In fact, if I write: int main(int argc, char* argv) { int a = 5; int b = 6; int c = 7; printf("%d\n", b); return 0; } It compiles to the exact same code. The definition of `struct xyz` just tells the compiler that when you say you want a variable of type `struct xyz`, you actually want 3 `int`s arranged sequentially in memory. After it's done compiling, it doesn't need to know about `struct xyz` anymore because it just put 3 `int`s there instead. Using a struct can make it easier for you to think about the code, but it essentially gets replaced by the definition when you use it.
You can write a "C-like subset of C++" and compile it with a C++ compiler, but there are features that have been added to C that have not been added to C++ (like VLAs), there are things that have different behavior in C and C++ (`sizeof('a')` is the same as `sizeof(int)` in C but the same as `sizeof(char)` in C++), and things that are valid in C but not in C++ (`int class` and `struct xyz xyz`).
That's a very simplistic example, and something like that in existing code I wouldn't go out of my way to change. OP's code is a better example of why it's bad practice. Mixing initialized and uninitialized variables can be confusing. I spent about two days tracking down a bug in Freescale's bare metal USB stack that came down to someone screwing up initialization of a local variable. I generally follow the Barr Group's coding standards, and rule 8.1 says that the comma operator shall not be used within variable declarations. Their reasoning is that the cost of placing each one on its own line is low, and putting them together increases the risk of confusion. MISRA-C's rule 12.10 also forbids the comma operator. I used to permit comma-separated declarations with each one split out to a separate line, but I stopped doing that because having them each on their own line *with* the type specifier and a semicolon makes it easier to change one variable or to move it around. Also, in Eclipse, keeping each one to its own line makes the mouseover hint more useful - you get one line with (hopefully) the comment describing it, rather than a whole block of variables. I'm coming at this from the embedded world, which is generally more conservative and safety-focused. The coding standards are full of minor things like this that don't seem like a big deal, but they add up.
What does "editing from" mean? Do you mean reading and writing the struct contents? 
There are three more function pointer like types in C++: - Pointer to member function (resolves virtual function calls!) - Lambdas (type implementation defined) - std:function (Pretty heavy as it is designed to support all callable things)
More like Java in a few decades. I still see C being used as a basis for new systems and languages far into the future, after all this decades unfortunate fads have faded and we realise we need the stability and reliability of the C language and standard. And I say Java because while it's relatively stable, it is (like COBOL) in heavy use in finance and line-of-business applications.
I think it is being de-prioritized. C++ was my college language. Java and Python seem to be the first two languages of everyone. I definitely don't see C going anywhere, but I wouldn't be surprised if it had an aging problem ie more C devs are aging out than are picking it up. 
&gt; if it guesses wrong and tries to read in a few bytes too many, ideally it won't block until the sending end sends a second packet. If you use non-blocking I/O then recv will return when it has read as many bytes as requested or when it would block.
https://codility.com/ There's lots of practice material there.
I made fun of a friend of mine for taking COBOL classes in 1980. He died last year but was a COBOL programmer at the same financial institution till he got sick. I wonder if it was COBOL that did him in.
I've seen things like this, topcoder, dailyprogrammer, etc. They were a really good learning tool when I was starting out but I feel like a lot of the time the challenges are very impractical. I would assume since this is a proficiency test at a job they might expect more practical usage of the language. Still, I'll check it out once I've exhausted my other options. Thanks!
&gt; Will cause only the first 5 bytes to be read, not the combined 10 bytes. This assertion can't be guaranteed - it depends if Nagle's algorithm is enabled, and if it is, it's current state. You can try and use MSG_MORE and TCP_CORK, but there's a 200ms upper limit on these. The takeaway is to not rely on TCP to do the framing - use your own application layer framing mechanism with a header. Looking at one of your replies: &gt; I would like to do is have the receiving end read in some data without knowing exactly how much data it's going to be. `read()` never knows how much it's going to read. You set an upper limit, but it returns the number of bytes read, which may be less than the upper limit.
thanks so much to you both for replying, that has helped me understand this so much better! :)
As you wish :-) ------------------- if(line[0] == '!' &amp;&amp; !line[1]) { int index; sscanf(line, "!%d", &amp;index); args = split_line(history_get(index)-&gt;line); } Does this actually work? IMO, the `if` matches only when line is `"!"` and nothing more: `line[1]` must be `'\0'` (so that `!line[1]` is true) to match. So the `scanf(line, ...)` wouldn't find an integer after the `'!'` since it has to be the only character in the string. BTW, when you call `split_line()`, you act directly with `strtok()` on the string you pass as parameter. So that means you modify the line that is stored in the history (if I understand correctly, `history_get()` return a pointer to the actual structure, not to a copy of it), because `strtok()` places `'\0`' characters in the string at places where it splits. So that means that the next time you fetch the same history line, it will look shorter, because there will be a NUL termination after the first token. And when you call `split_line()` again on it, you will only get the first token and not the other ones. Did you test it? (Perhaps I'm wrong.)
Loop over stdin, parse input text. Row = input_char - 'A'. Col = input_char Update array[row][col] with the next input_char
I see. This is a bit of an odd situation since it's more of a test to see if I need to go through additional training. I'm not too worried either way. Thanks for the input
thanks for trying to help, but im still extremely confused 
The likelihood to get a job as a new Cobol programmer is zero because you have to know finances and the host systems too. 
So, your basic problems are - you need to know what type of data you're storing, and what you're using as the key. Usually the easiest key is `int`. - you need to make a `struct KeyVal { int key; &lt;whatever&gt; value; };` *type*. - you need somewhere to put a bunch of those, like `struct KeyVal storage[32]:` or however big you want your storage to be. This is the "table" in "hash table". Now, you need a function that, given a key, determines where the value gets stored. This is the "hash" in "hash table". Say, `int get_index(int key);` Once you have an index, you try to store your key and value both in that cell. It might be occupied! If so, deal with it - throw out the old data - throw out the new data - store the new data somewhere else using another function of your choice. - now you need a function that, given a key, retrieves the matching value. `&lt;whatever&gt; get_value(int key);` It has to know about the problem above: the right data might not be in `get_index(key)`! Some trivial functions that transform integers into a small number of indices are - `key` - `key % number_of_array_cells` - `(5 * key) % num + 1` - (for n as a power of 2) `key &amp; n` In short, you need - a type to hold your data as key/val pairs (struct) - a bunch of places to put data - a way to figure out where to put data - a way to get that data back out Hash tables are just arrays that aren't necessarily storing things in a straight line.
Banks are dumb. Cobol isn't some mystery that no one can learn...programming has almost nothing to do with what language is being coded.
&gt; Pearl It's [perl](https://68.media.tumblr.com/98898fc6c7a47d890bff0536a74337c1/tumblr_mqe3l0FUlY1saqds9o1_500.gif), you savage!
I agree. Anyone can buy a book on Cobol and learn it. Just nobody wants to. 
Structs shouldn't really be used this way, I think you're trying to abstract your code at the wrong point tbh. loops should be threaded, if you're trying to parse packets or whateve each thread should have it's own buffer to readfrom/write to.
True... but on mainframes, parts of COBOL are tied to the environment (storage, CICS, batch, JCL, etc.) and those things are learned more by experience than a pure generic COBOL book. I programmed in COBOL and C for the first 20 years of my career on Unix (later Windows) systems, and I know COBOL as well as anyone... but I couldn't step into a job programming COBOL on a IBM mainframe without learning a lot more about the things I mentioned. Not quite as dramatic, but almost like knowing how to program in C on Windows and thinking one can just step into programming C on OSX, because you already "know" C. 
TCP doesn't work like that, though. It's stream-oriented, not datagram-oriented. Safe, portable applications should always assume that the network stack will accept as little as 1 byte at a time. Sending those two 5-byte structures will fail if the network stack doesn't have enough buffer space for them, and you don't check the return value and try to send the remaining bytes. Similarly, on the receiving side, the network stack could always receive or give you as little as 1 byte at a time. It's mandatory that you have something in your data to tell you how much to read. Simple HTTP 0.9 or 1.0 can simply read until the connection is closed. Better HTTP will read until it sees the end of the headers, then will look for a Content-Length header to see how many bytes to read. Etc.
Be the change you want to see in the thread
I fully agree. Rust can put a dent in it but I don't see Linux or OSX going to Rust so at least from an OS perspective, C will always have a necessity.
Autocorrect is a bitch.
I can't imagine Java ever going the way COBOL did. 
Here's one, encrypt your message using a Caesar cipher (rotate the letters by a certain number looping around at the end of the alphabet). Give him the message and tell him he can decrypt the message if only he were a Roman soldier. Any cs major should be able to pick a small word and figure out the shift count by hand pretty quickly. You can also do a block cipher with it to make it a bit harder
Good to hear. I'm horrified when I come across CS grads who don't don't understand the way bits, bytes, addresses and memory work. Let alone know about ASM. It does seam some places only cover Java and some highlevel C++.
Well this is ballpark that time. Rediculous is not easy to think of haha. 
Computer engineering we have to learn DSP in C and build a MIPS processor on an FPGA. We definitely focus much more low level than computer science does which tends to be more high level and focuses on things like algorithms and data structures. Computer engineering is more about computer hardware than software, or more the intersection between electrical engineering and computer science.
Try giving him the message via an easy algorithm. An example is zlib. Or store the message in another format. 
The US military has their entire payroll infrastructure (for their 3+ million employees) written in COBOL.
When I was going through engineering, it was kind of a known thing that the CS majors didn't know much about memory management, bits, bytes, and such. They could run circles around us computer engineers with OO, web, and database development; but couldn't even begin to fathom what a pointer was. 
I bump into it and it horrifies me every time. I'm like "what the hell did you learn if it isn't how computers work?".
`scanf()` requires a pointer argument, you're passing an `int`. This should be giving you at least a warning. You need to call it with scanf("%d", &amp;arrayPosition); to pass the address of `arrayPosition`
P.S. We have rechecked a fresh version of the FreeBSD code using PVS-Studio. Git revision: 59fe28863e6a0903b50b37c616f21a2a865bbbf2 We have worked on the reports a bit, having filtered those messages that seemed unnecessary. There are some other false positives in the list of course, but its not possible to eliminate unnecessary warnings in large groups. The remaining warnings should be reviewed separately. The report is provided in two formats (tasks and csv). To those who will start working with the report: perform the automatic replacement of SOURCE_ROOT with the necessary path, so that the navigation works well. Tasks: http://cppfiles.com/freebsd.plog.tasks Csv: http://cppfiles.com/freebsd.plog.csv
 scanf("%d%*c", &amp;arrayPosition); scanf is a funny one and I don't konw why it needs it but there you go. Hope this helps/
**My program so far** https://gist.github.com/anonymous/f06ec0e55381bc447b199766a1c3efed So, why my program is printing the full chessboard without the pieces. Also, I'm putting only one input and he is printing the hole chessboard. i.e. I write in the compiler: 5 // A 2 q and when I press enter do type the other input he prints the hole board without a piece. What I'm missing, is it a 'for' statement? ps.: sorry for putting the hole exercise. I wanted to compare or have any ideias of where my problem was. New here, did not read the rules.
Sounds like a shitty CS program. Pretty much all the decent CS curriculums I'm aware of require classes in computer architecture (with assignments using ASM and C) and OS design principles (with assignments using C) to graduate. I really wouldn't trust any CS program that didn't require these things. I've been out of school for a number of years now but probably over half of the courses in my CS program required either C or C++ as the primary language for assignments. No idea what it's like now but I really don't see how you could teach something like an OS course in anything but C or C++. Honestly, I have a hard time trusting any programmer that doesn't have at least a passing familiarity and competency in C (or some other low level language). The concepts are so central to what the computer is doing under the hood that if they don't understand them then there's just too much of the system that is *black magic* to them.
If you are willing to write Cobol for the next 30 years I would bet they're willing to teach you the domain-specific knowledge necessary for the job. 
Can you show us the entire program please? It is possible that the code crashes elsewhere. Without seeing your code it is very hard to tell where it fails.
What does dedupable mean for you?
That shouldn't make a difference. However, you can try to write something else each time, e.g. by writing memset(buffer, mb, 1024*1024); instead.
Thank you so much, I will give this a shot. Not knowing C, can you help me understand what "mb" does in place of "0"?
Read the documentation of `memset()` and you will know.
Late to the party, but... You could also encode your message using base64 on this site: https://www.base64encode.org/ . Decoding base64 in C is a nice little (but non-trivial) exercise. Or he could cheat by using the same website to decode it, of course.
OK, so I did some reading, and my understanding is that I am filling the buffer with the character string "mb". (mbmbmbmbmbmbmbmbmb...) 
Note that `mb` is a variable, so the buffer is filled with whatever is in the variable `mb`. As you increment `mb` every iteration, it's a different value every time.
Thanks for your help so far! I tried my code and I output "r" for each run, and it always comes back "3".
Have you called `srand()` to seed the random number generator?
You rock, thank you!
CS here starts with Python. CE on the other hand starts with C.
&gt; Uh? Is that a remain from a previous version when the ternary operator had an actual condition? Um, I don't know what to say about this. This is mostly me writing a lot of python and thinking that the format of ternary operator format is same for all languages except for the syntax. I have fixed this, thank you. What I wanted to write: int khol_bg = (options &amp; KHOL_BG) ? 1 : 0; int khol_stdout = (options &amp; KHOL_STDOUT) ? 1 : 0; int khol_stderr = (options &amp; KHOL_STDERR) ? 1 : 0; int khol_stdin = (options &amp; KHOL_STDIN) ? 1 : 0; Wait, how did this work then? It did work perfectly. &gt; and what happens at next loop iteration? TOKEN_BUFSIZE is not updated (it is a #define anyway), so pos will be &gt;= TOKEN_BUFSIZE again, and it will realloc() gain for nothing. Also, when pos will reach TOKEN_BUFSIZE*2, you will start writing out of the allocated area. Oops, you are right! I'll fix this too. Thank you for the other suggestions, I'll fix them too.
I don't know why I didn't test this enough. Also I put the more dominant condition downwards, so backward history recollection was never working. Thanks again! &gt; So that means that the next time you fetch the same history line, it will look shorter, because there will be a NUL termination after the first token. And when you call split_line() again on it, you will only get the first token and not the other ones. I cannot replicate this. This is a concern, I'll definitely dive deeper, thanks!
&gt; 10 to 15 minutes ... &gt; LSB steganography Lol
I've only done a couple of the challenges due to lack of time but check out [cryptopals](https://cryptopals.com/) 
&gt; and build a MIPS processor on an FPGA The most complex thing we've done on an FPGA is PWM :(
At an abstract level, a "hash table" is a way to store objects using other objects as the key. Say, for instance, that you were using names as the keys. A hash table does this: table["joem8_98"] = {name="joem8_98", age=19, address="123 Main street", likes="long walks on the beach"} table["capilot"] = {name="capilot", age=44, address="Obsidian Fortress", likes="seeing my enemies flee before me"} ... then later you can recover items from the table by referencing `table["joem8_98"]` or `table["capilot"]` (Obviously, this isn't C, it's just to illustrate a point.) How you implement this table is your business, and there are countless solutions, but a **hash** table is a very popular implementation. The word "hash" describes the way the table is implemented. A [hash function](https://en.wikipedia.org/wiki/Hash_function) is a function that takes arbitrary data and converts it to an integer within a restricted range. See [Josh Bloch's algorithm](http://stackoverflow.com/a/113600/338479) for an excellent implementation. The implementation of a hash table is pretty much up to you. There are a few common ways to do it: * Allocate an array of N pointers where N is much much greater than the number of objects you plan to store in the table. To add to the table or search it, take the hash of the key, modulo N, to get the index into the array. Store a pointer to your object at that location. Hope you get lucky and no two keys ever hash the same. Obviously, this is a pretty bad algorithm. * Allocate an array of N pointers, where N is a reasonable number, maybe 2-3x the number of objects you intend to store. Generate an index as described above. If that entry in the array is empty, store your pointer there. Else, start looking through the array starting at that location until you find an empty spot, then put your pointer there. If you loop all the way back to where you started, then the table is full and that's a fatal error. To fetch from the table, compute the index as before, and check that location in the array. If it matches, then fine, return that object. Else, start searching the array starting at that location until you either find a match, you find an empty spot in the table (which means the object wasn't in there), or you loop all the way back to the start (which means the object wasn't in there). * Allocate an array of N pointers where N is whatever you feel like (between 1/4x to 4x the number of objects you anticipate storing is fine). But this time the pointers are pointers to `struct hashnode {void *key, *object; struct hashnode *next;}` structures. To add to the table, hash the key, allocate one of those `hashnode` structs, copy the key and a pointer to the object into the struct, and then add the struct to the linked list at that location. To search the table, hash the key, then linearly search the linked list at that location of the array. That final algorithm is slower than the other two, and consumes more memory, but has the advantage of never running out of space until you're actually out of memory. If you plan to do a lot of deletions from the table, you might want to use a doubly-linked list, but frankly there's almost nothing to be gained.
Great idea
Yeah, OP should know what to do. Let's hope we don't ruin her relationship ^^
Might be a good relationship test ;)
Because a function is an actual thing that resides in memory. Your example prints the address of the printf function. A type does not reside in memory. It wouldn't make any sense to do `printf("The address of int is: %p", &amp;int);`, right?
It's x86 assembly in Intel syntax. You don't really have to know much about it. The basic idea to take away from it is that it's just dealing with 32-bit values and doesn't care about the struct. 
[This GNU C library](https://www.gnu.org/software/libc/manual/html_node/Complex-Numbers.html) may be of use to you. If not, then you may have to define complex numbers yourself, using a structure/record with two components. Then you write your own functions for operations on the structures (modeling addition, multiplication, inversion, etc. of complex numbers).
Don't use that. Wouldn't work even if it was valid syntax. See my other comment.
Preprocessor recognizes tokens. Only the token `I` would get replaced; it won't hit the letter "I" in other tokens or inside string literals.
Can someone explain to me what the point of C having complex numbers is? Like, I'm not that big on math, but can someone ELI5?
Obviously, whatever you can do recursively you can do iteratively. Personnaly i'm tempted to say recursion is evil but that's arguable. I'd say it comes down to readability against efficiency/performance.
I'm seeing this same problem everywhere on different subreddits for days now! I don't know if this subreddit allows posting full solutions, but sometimes spending too much time on a problem isn't really helpful or productive. I'm not putting in any comments so that you rather use it as a reference to get some ideas off of. Good luck. #include &lt;stdio.h&gt; const int COL_MAX = 8; const int ROW_MAX = 7; int main() { int n; scanf("%d", &amp;n); int r = 0, c = 0; char prev = 'A'-1; char curr, piece; int col; while (n--) { scanf(" %c %d %c", &amp;curr, &amp;col, &amp;piece); col--; if (curr == prev) { while (c &lt; col) { printf("%c ", (r+c)%2 == 0 ? '.' : '*'); c++; } printf("%c ", piece); c++; } else { if (c != 0) { while (c &lt; COL_MAX) { printf("%c ", (r+c)%2 == 0 ? '.' : '*'); c++; } printf("\n"); c = 0; r++; } if (curr != (prev + 1)) { while ((prev+1) &lt; curr) { for (int i = 0; i &lt; COL_MAX; i++) printf("%c ", (r+i)%2 == 0 ? '.' : '*'); printf("\n"); r++; prev++; } } c = 0; while (c &lt; col) { printf("%c ", (r+c)%2 == 0 ? '.' : '*'); c++; } printf("%c ", piece); c++; prev = curr; } } while (c &lt; COL_MAX) { printf("%c ", (c+r)%2 == 0 ? '.' : '*'); c++; } while (r &lt; ROW_MAX) { r++; printf("\n"); for (int j = 0; j &lt; COL_MAX; j++) { printf("%c ", (r+j)%2 == 0 ? '.' : '*'); } } printf("\n"); return 0; } Sample runs: $ cat chess.in 10 C 1 Q C 2 k C 5 T E 2 K E 4 Q E 8 t F 5 q H 1 P H 4 q H 7 T $ gcc -Wall -o chess chess.c &amp;&amp; ./chess &lt; chess.in . * . * . * . * * . * . * . * . Q k . * T * . * * . * . * . * . . K . Q . * . t * . * . q . * . . * . * . * . * P . * q * . T . $ cat chess.in 5 A 2 q A 6 b B 1 p G 4 P H 8 T $ gcc -Wall -o chess chess.c &amp;&amp; ./chess &lt; chess.in . q . * . b . * p . * . * . * . . * . * . * . * * . * . * . * . . * . * . * . * * . * . * . * . . * . P . * . * * . * . * . * T $ cat chess.in 2 C 5 q F 7 K $ gcc -Wall -o chess chess.c &amp;&amp; ./chess &lt; chess.in . * . * . * . * * . * . * . * . . * . * q * . * * . * . * . * . . * . * . * . * * . * . * . K . . * . * . * . * * . * . * . * . $ cat chess.in 16 A 1 q A 4 K B 2 p B 5 P C 1 q C 7 K D 5 b D 8 k E 2 P E 4 t F 3 q F 6 T G 4 p G 5 Q H 1 K H 2 T $ gcc -Wall -o chess chess.c &amp;&amp; ./chess &lt; chess.in q * . K . * . * * p * . P . * . q * . * . * K * * . * . b . * k . P . t . * . * * . q . * T * . . * . p Q * . * K T * . * . * . 
Thanks, I have now added a "links" section in the README from where I have gained most of the inspiration.
So you've introduced a few new errors :-D char* history_copy = (char*) malloc(MAX_BUFSIZE * sizeof(char*)); * The `(char *)` cast is not needed in C. (And unnecessary casts may hide mistakes.) * You allocate 4 times or 8 times more room than necessary: you want to allocate memory for `char`s, not `char` pointers. --------------- You should `free()` `history_copy` after you're done with it (and done with `args` too). As it is now, you allocate new memory for it each time the loop runs, so it leaks. Otherwise, since you allocate the same size again and again, you could allocate it once and for all (or just declare a fixed buffer) outside of the loop. BTW, is it a good idea have its size fixed? The line stored in history is the line got through `readline()`, I imagine it can be arbitrarily long. So if the string is longer than `MAX_BUFSIZE`, `strcpy()` will write out of bounds. I think you should rather allocate just the right amount of space: put_the_right_type_here *history_entry=history_get(the_right_index); char* history_copy = malloc(strlen(history_entry-&gt;line)+1); strcpy(history_copy, history_entry-&gt;line); args = split_line(history_copy); /* .... */ free(history_copy); // placed at the right position in the loop --------------- In `get_prompt()`: else { return NULL; } You should `free()` `prompt` here (in the `else`) because you've just `malloc()`'ed it, and you won't be able to free it later. ----------------- 
That title is very much clickbait. :(
`sqrt` doesn't work with negative numbers, you would have to use `csqrt` from the `complex.h` header (but that one already provides the constant `I` for you anyway.)
I don't know why I always get the malloc wrong, maybe its just force of habit that will need to change. The history thing is a good recommendation, it makes sense. I have been so inspired by your comments that I will do a complete overhaul of the file to check for any extra mem allocation and leakage, and also make everything error checked. Thanks so much!
This is neither syntactically nor semantically correct. Please don't give misleading help.
Not an expert, but my interpretation: It depends what encoding iTerm2 expecting. `L''` is a `wchar_t` literal, which you are saving as an int. This is saving the unicode codepoint for the character `` character as an `int` (which happens to be 248). If iTerm2 is expecting UTF-8 then it expects this codepoint to be represented by the two bytes: {0xC3, 0xB8}, however instead it is likely getting: {0x00, 0x00, 0x00, 0xF8}, which is what the `int` representation of 248 might look like (depending on architecture/compiler/endianness/etc.) So it depends on what encoding iTerm2 is expecting (probably UTF-8). Then you will need to convert from a given code point to that encoding (again, probably UTF-8). Here's my work: https://repl.it/HKIu/0 Given this, you will also need to amend your how you call`ft_putchar` to give it each byte at a time... https://repl.it/HKJO/0 edit: added last line., edit: added second example. 
What is this code supposed to do?
&gt; the ranges for double in C are smaller than Java Are you *sure* about this? What platform are you working on that has a Java implementation but no IEEE doubles? It's a very unusual situation. Basically, you've got two possible situations: 1. Your platform is IEEE, in which case your C doubles have exactly the same range (or bigger) as your Java doubles 1. Your platform is not IEEE, in which case the behaviour of `double` is poorly defined around things like overflow and infinity, so there's no portable way to do what you're asking. You can try comparing it to `INFINITY`, but I don't believe that's guaranteed to have well-defined behaviour in the absence of IEEE 754 (I'm not 100% on this)
If you want to do message delineation in TCP you will need to provide a fixed-length context before each message is sent describing the size of the message. This could be as simple as affixing an integer (encoded as little/big-endian, unsigned, etc.) which represents the length of the message, for every message. Or it could be an 8-bit byte, or you could make it a variable-length integer.
&gt;Also how did you inline some of the text in your comment? `inline text`
Your function accepts a single narrow character... obviously passing some unicode to it isn't going to work
`wchar_t` is probably the natural choice (although if you're in Windows maybe `wint_t`)
Ok thanks I will have to read up on that data type
42 US or Paris? Anyway good luck on your ft_printf =) 
https://www.programiz.com/c-programming/bitwise-operators
All of these examples input the decimal representaion of binary numbes i need to input 8 bit binary numbers
Anyone?
Why are you downvoting me? I'm just asking for some direction??
oh my god i cant believe it was this simple, thanks man!! i really appreciate it!!
Post sample code and I am sure you will get more help. I think people just want to make sure you are at least trying. Write a code block trying to do the assignment and post it here for help. ;)
For the future: On Linux, you can use the `strace` tool to see what system calls your program performs. I actually used a variant of this tool (`truss` on FreeBSD) to debug your problem.
oph nice i didnt know that! that sure is helpful! And maybe you can help me with one more thing! Say that i want to run my program this way: ./redir -i input -o output ls -a my program crashes because it doesnt recognizes the '-a', i think getopt parses it but i just want for ti to parse de '-i' and '-o' is there any way to do it?
wow just how much do you know? amazing! thanks a lot!
If you want to know all the details, write a lot of code and read [the POSIX standard](http://pubs.opengroup.org/onlinepubs/9699919799/). Which contains everything you need to know and much more.
I would say you should amend `ft_putchar()` to take a unicode codepoint directly (using whatever datatype you choose that's large enough to take all unicode codepoints...`wchar_t`, `uint32_t`, or `char32_t` etc), then translate that value into UTF-8 bytes. Since unicode code points are often larger than one byte (`char`), you need to accept values larger than a `char`, and actually `int` ---since it is ambiguous--- might not be large enough for all codepoints. Also, to write in line code, you surround your code in backticks ````` edit: typos
After the last `printf`, because at that position, you have `" exiting all_connected"` in the buffer, so if you flush it, it goes to the terminal/file/whatever. I would just append `"\n"` to the string in the `printf`-statement instead of using `fflush` in this case.
Do you know of any resources for learning this kind of stuff?
Sadly it was just a case of diving into a work code base and taking lots of time trying to understand things. Make, CMake, Scons, and even the occasional python script. Sucks
&gt;It's expected that they can write slightly advanced programs such as a TCP client on their own. &gt;Since C is only a small part of the course, I have very very little time to talk about C itself. Is this the Humpty Dumpty School of Programming? What kind of "college" is this? Your whole post sounds like insanity defined!
Pointers (as you were planning to), and strings (I assume that's what their TCP clients are going to receive from the server). Undefined behaviour is really important but it's also very easily explained, e.g. "you have the right to access whatever memory address you want, even if you didn't put anything there, or use undefined variables, but if you do that then you have no warranty from the people who maintain C about the behaviour of the program". And when it comes to strings you should tell them about string literals vs arrays of `char`, stuff like that. IMO basics of C is really pointers and strings (which are related), if they really don't have any programming experience you might have to quickly tell them about top-down compilation
&gt;Use only %u for user input and data printing. I'd get some clarification on the above. It seems like an error in the assignment description. Using %u will _not_ work as expected with input like 00110011. Instead, you want to be reading the string and then looping over its characters (1's and 0's) and computing the number it represents. &gt; The result should be displayed to the user as a decimal number. This also seems suspicious. If the user input is in binary it seems natural they'd expect the output in binary as well.
sounds like a winner
Ok cool thanks
US thanks!
...huh?
^ Assuming we're not in a function parameter.
No it's probably not a memory issue. Show your code. Think about it, do you think there's some weird unseen error in C that causes for loops to misbehave, or do you think it could be a programmer error? Obviously the programmer error right? But we can't help you further unless you show us more code than that. We need (at least) the entirety of the for loop. 
In response to your q in 2nd Edit: suppose your tree had a root with no left or right child. In that case, the stack would be empty (you just popped off the only item and assigned it to root), root-&gt;right would be NULL, and peek(stack) would return NULL.
Thanks for the reply. If you would be so kind as to give your opinion, does it look like I'm plagiarizing?
ahahah I think it's just a coincidence, i didnt had my exam yet this was a practice exercice!
This is where you should use `gdb` or some other debugger
Use standard format specifiers, pick a different language which has safe printf-like methods (C++, D, Go, Java, Python, ) or write a checker that will test it as part of compilation or CI (typically based on LLVM).
For any array sizeof(my_list)/sizeof(my_list[0])
You're the best, thanks a lot!
This sub is for the C language, /r/cpp is for C++ and Q&amp;A's about C++ should go to /r/cpp_questions .
Unfortunately, variadic functions in C are inherently not typesafe. It's basically just a hack that allows you to directly access the stack. You'd have to write an analysis plug-in for your compiler or a standalone analysis tool to check the validity of your code. 
I actually made a not so good version without getopt if you want to check it out! #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; int main (int argc, char **args) { int fd, counter = 1; if (argc == 1) { printf("Usage: redir [-i file in] [-o file out] command args ...\n"); return 0; } else { if (!strcmp(args[counter], "-i")) { fd = open (args[++counter], O_CREAT | O_RDWR, 0600); dup2(fd, 0); close(fd); counter++; } if (!strcmp(args[counter], "-o")) { fd = open (args[++counter], O_CREAT | O_WRONLY | O_TRUNC, 0600); dup2(fd, 1); close(fd); counter++; } } execvp(args[counter], &amp;args[counter]); }
Im sorry, thank you
Well I did put a to-do for memory alignment. But for memory alignment, I would first want to check alignment according to pointer size, no? And if I have some data larger than bus size, how do I align that (specifically when vector register is used)? Also, I kinda figured the branching would reduce performance. But how is that case for predictive branch CPUs? I would do template programming, but I'm trying to make it stay in C.
1. I have some TO-DOs listed in the header files. Those are the immediate ways of improving it. I was just experimenting and playing around. 2. Well I think according to some memcpys out there they overwrite some important data with just a struct to struct copy. The glibc memcpy looks okay, which I'm taking a further look at to see if I can improve that one. I mentioned 'fine-tuned' because it switches variable width of a copy operation based on how much data needs to be copied, but I guess with excess branches in the code this isn't as efficient as one would want. 3. I'm respecting wishes of RMS and the FSF.
It's not necessarily possible to cast a pointer to a `size_t` and back. Only `uintptr_t` and `intptr_t` have this guarantee (and they're optional). Also, arithmetic on these integers [isn't necessarily meaningful](http://nullprogram.com/blog/2016/05/30/) even if you do it right. Cast to a `char *` instead. That always works and always operates on bytes. Using the `register` storage class specifier in the 21st century is pointless. Especially with the way you're using it. As was already pointed out, you might be violating alignment constraints of the implementation. More generally, *you're never going to beat the compiler doing this with C*. It already knows how to optimize memory copy operations, including with SIMD streaming. If anything, your functions may prohibit the compiler from doing its job had you used `memcpy()` in the first place. The only chance you have at beating the compiler is stepping outside of C: going behind its back and coding the memory copy directly in assembly. 
I have removed your question as it is off topic for the reason /u/Dexterous_ mentioned.
That's way better explanation, thanks. I also understand your fascination of RMS and FSF - it was also "my thing" some time ago - until I understand that Stallman's "Free as in freedom" should be rather "Free as Stallman wants it" in most of the cases. Better stick with Torvald's point of view - at least for your mental health.
I do have the codebase downloaded, but I have to run it on a virtual machine (ubuntu) and then submit a small file (or set of files) that will compile and run independently for grading (except I'm not submitting the project for grading anymore). I guess the thing to do is just what you suggested, and download the whole thing onto an easier to work with development environment and get to know the package like a good friend. Maybe that's the way to learn how to work with professional c development build projects. It seems like a very professional set of code. Edit: This looks like a more detailed version of what I had in class: [MIT OCW Makefile Lecture Notes/Documentation](https://ocw.mit.edu/courses/civil-and-environmental-engineering/1-124j-foundations-of-software-engineering-fall-2000/lecture-notes/gnu_makefile_documentation/)
I'm not sure what your needs are in great detail, and I've only used CMake professionally for about 3 months so I could be less-than-mediocre at it (in fact I took a week to fail at something that took a far more senior engineer like an hour, but he said it's ok so hopefully he's both honest and nice) but it has tons of neat goodies like find_package and setting paths for includes, so if you're working with something big like boost, qt, libevent, thrift, like I was and you need to compile for QNX on linux, CMake is simultaneously the best way to do it and very difficult for noobs to slog through. Now if you're able to compile a binary from the code you care about, Visual Studio has a way to link against a binary (I'm sure it's doable from any unix-like, I just only know about using VS to do this) such that you could just call a function. That could be better for you, again I'm not sure
OK. That's definitely something I can look into. I would like to work with boost libraries. Thank you for the tip about cmake!
Is the assignment to insert strings (which are arrays of char) into an array?
Basically any time you are working with multi-dimensional arrays, you will be using nested loops. Specifically, one loop per dimension IF you wish to iterate through all the indexes/elements in the array. To go about putting names into a 2d array, imagine that each row is a different name with the letters making up the columns. If you want to iterate through more than one name (and therefore a row), you must go through each letter (or column) until the name is finished, then update the counter for the rows, moving on in this fashion until there are no more rows to go through. This process would call for two nested loops in your case. TL;DR: Using nested for loops (specifically two) is probably what you should be doing.
Bottom right is [9][9] in your example.
Which is weird considering they are both pointer values, but that's C for ya!
It's not weird anymore when you realize that: 1. *sizeof* is operator, not a function, 2. In C, _everything_ passed to the function is passed as *value*. 
That doesn't really make sense, isn't it a pointer to begin with?
You should test shmget for an error, and int** =/= int[][]
My bad. I have tested I just didn't include it in the code above. There are no errors with `shmget` or `shmat`.
In alphabetical order, or just anywhere?
With C you're deep down the stack to a place where you actually have to specify what steps your computer has to take. So yeah, this is the way to do it, although this is a trivial example. Hidden within the python interpreter there's a place where code looks just like that, it's just abstracted away for the convenience of the programmer. C is not about convenience, it's about control.
Linux 64 only.
1. I know. 2. I'm aware that you can only pass by value. However, if you have an array you declared as x [10] and you call on the variable, x, it is referring to x [0]. Therefore x itself is just a pointer value before and after it is passed into a function. So even in the main it is a pointer which is why I find it weird l.
There is no difference in execution speed between `i++` and `++i` with a good compiler and multiplication is in fact very cheap on modern processors.
If you are an absolute beginner then head first series of programming books may be nice for you(see if you like the style). Doing tutorials online on hackerrank, code chef etc maybe helpful as well.
All your multiplications are in parallel, running the program on the GPU seems like a good idea in this case. Look into CUDA/OpenCL.
I highly recommend you to just fork and exec `ip` as doing this stuff manually is very cumbersome. The interfaces `ip` uses are not all stable and documented as far as I know, which is why `ip` is more or less tied to the kernel you're running. You can find out what `ip` does by running `strace ip` and observe what kind of system calls it performs. It seems to do something like this: * open a number of files in `/proc/net` to find out what inerfaces exist. * create a `netlink` socket (see **netlink**(7)) to talk to the kernel * sends a command to the kernel to create an interface There is also an older `ioctl` based interface using the `SIOCG...` set of `ioctl` calls declared in `sockios.h`.
You might instead parallelize, like /u/bxlaw explains, but that comes at the cost of overhead (syscalls, context switches, ...), while SIMD does not. In addition there are a lot of neat tricks you can do with multiplications if you know what numbers you will be dealing with (bit manipulation comes to mind). I think it comes down to considering the workload and picking the right tool for the job.
&gt;I think it comes down to considering the workload and picking the right tool for the job. This is the best advice anyone could give.
Your else if will never execute. You have an if statement: if( pid &lt; 1 ){}else if(pid==0) But if you notice if the pid is 0, 0 is in fact less than 1 so the first if executes, not the second. Please excuse my formatting. I'm on mobile. 
Though, I would assert, it is very fun. I'm going to be doing this for an n-body project soon!
&gt; if you have an array you declared as x [10] and you call on the variable, x, it is referring to x [0] It would be referring to &amp;x[0], which is different. x or &amp;x[0] is the address of the first element (which should be asigned to an int *), x[0] is just an int.
I knew about the optimization, that was the reason for the Makefile. Thanks a lot!
Basically I've chopped up [The Hacker Manifesto](http://phrack.org/issues/7/3.html) into 15 parts and stored it in the TXT records of my domain. That was the main idea. Everything else is obfuscation. I've removed my dependency on the standard library (for sockets, timing and output) by directly calling the OS with that asm line in the middle of the code. I've used recursion to hide the for loops. I've used the ternary operator to hide the conditionals. and memory references to hide the variables. The DNS request packet and all the other data I used is stored in one array and I reference the correct place in the array when I need it. Next, I represented every number as a sum of powers of two and transformed those into sums of bitshifted expressions. That's basically it. If it stops before it reaches then end, it might be because of your internet connection.
I just typed `cc -o 1 1.c` with a good internet connection.
I notice you have a set number of iterations. Try doing loop unrolling; that should increase performance. E.g. doing 2 iterations of the code over 500 loops instead of 1 iteration over 1000; doing it the former way means it's incrementing and checking condition less often, which can be much faster at the expense of more program size. EDIT; As an additional note you dont need "i" declared outside of the loop, you can just put "int" before it in the for statement. If you have multiple loops it is optimal to reuse the "i" outside of the loop, provided they are not nested (in which case you have a bit of a problem.)
I can tell you when I'm home.
`ip` uses `netlink` underneath, which is part of the Linux's stable ABI. [libnl](https://www.infradead.org/~tgr/libnl/) makes access easier, but the documentation isn't great. The examples and tests in its codebase are reasonably good places to start, though. In any case, the following C code, using `libnl-route-3.0`, will do something like `ip link add dev wg0 type wireguard`: #include &lt;netlink/netlink.h&gt; #include &lt;netlink/route/link.h&gt; int main() { struct rtnl_link *link; struct nl_sock *sk; int err = 0; link = rtnl_link_alloc(); if (!link) { nl_perror(err, "rtnl_link_alloc"); goto OUT; } rtnl_link_set_name(link, "wg0"); rtnl_link_set_type(link, "wireguard"); sk = nl_socket_alloc(); err = nl_connect(sk, NETLINK_ROUTE); if (err &lt; 0) { nl_perror(err, "nl_connect"); goto CLEANUP_LINK; } err = rtnl_link_add(sk, link, NLM_F_CREATE); if (err &lt; 0) { nl_perror(err, ""); goto CLEANUP_SOCKET; } CLEANUP_SOCKET: nl_close(sk); CLEANUP_LINK: rtnl_link_put(link); OUT: return err; }
C as a language doesn't have the same sort of built-in system for internet sockets like Python does. It is largely OS specific, though I suspect there's a fair amount of overlap. Be that as it may, there are still guides for socket programming in C; my personal favorite is [Beej's Guide](http://beej.us/guide/bgnet/) but I'm sure others will chime in with theirs shortly. **EDIT:** clarification.
so, how to understand C sockets from the beginning ?
Man(ual) pages define aspects of operating systems including system calls which you'll need for networking. I suspect u/thebatwayne expects you to be on a Unix-Like OS (like a linux distribution or BSD variant). But if you're not, you'll have a hard time finding a similar level of documentation for free.
I feel Beej's Guide is a phenomenal introduction to network programming for those already well versed in C. Man pages, as others have suggested, will provide you with more specific information, but Beej's Guide will show you real-world examples.
W. Richard Steven's UNIX Network Programming.
Also, printf("%d\n", stor); is wrong. stor is not an int like the %d format requires. If your compiler isn't warning you about this, turn up the warning level (-Wall -Wextra for GCC and clang). 
The authoritative book.
Hey thanks for your reply. This is certainly the reason why it does not work. I made something that's platform specific and, it seems, compiler specific. What a mess, I guess I was pushing it. :)
 current = head; You do all this work with current, then you clobber it with head. That seems odd.
My bad. Just wrote a quick mock up of the code for reddit. Assume the code reaches the child. 
You're not checking any of your functions for error returns. As other posters have pointed out, strdup() is your friend here. You were especially wrong to assume none of your fields would be over 60 characters -- that's just begging for someone to deliberately corrupt your program with bad input. Your style and indentation are inconsistent. Here's a handy pattern for extending a linked list: Node *list = NULL, **nextp = &amp;list; Node *node; while (there's more data) { node = malloc(sizeof(*node)); if (node == NULL) { deal with error } // fill node with data ... node-&gt;next = NULL; *nextp = node; nextp = &amp;node-&gt;next; } Note: I'm especially fond of the `node = malloc(sizeof(*node))` idiom. If you change the type of `node`, you won't get burned because 20 lines further down there was a `sizeof(Node)` that you forgot to change to `sizeof(BiggerNode)`
This is the correct way of handling linked lists in C. Instead of having a special case for the head node you keep a pointer to it (`nextp` in this case).
Thanks, this looks great!
Thanks - That one was actually just an error in copying/editing the code to reddit :)
Yeah, I don't get it either. I would hardly call myself a guru, but I would expect it to do integer multiplication. The issue may be that char is not necessarily signed, it depends on the compiler, but I don't get the right way to do it. I've tried a couple of ways very explicitly, now I feel like a complete idiot. (edit) Okay, I played around with the C# one, which multiplies and int * string. I initially tried to convert to an int Int.Parse(string), but it gave me some compiler errors, which led me to believe that the error is in the function definition. I just changed the argument "string" to "int" and it passed the test :-/. So I went back to the C question. And changed the "char *" to just just "int" (of course adding in the * for the multiplication), and it worked fine. I'm not sure how I feel about this site.
At least Windows and *nix sockets are pretty close. Few defines should be enough to cover both.
I feel a bit BIASd about that one.
My guess is, that your files are being compiled individually, but not being linked properly. That, or a library file isn't visible to the linker. 
Usually "undefined reference" means that the function is mentioned in a header file, but you haven't linked in an object file that contains the actual binary code of the function. 
It's not a pointed to char. It's a bogus pointer. They pass in "1". 
Because "b" is a bogus pointer. "1" is outside your address space. It's the stupidest thing I've seen in a while. 
I hate to be this guy right now and ignore your request, but compilation is a pretty important aspect of writing C in my opinion. Compiling your code isn't going to take more than a second if you're just playing around with basic syntax and you'll be thanking yourself later when you understand how to properly configure your compiler for the task at hand. Even if you're using Visual Studio, Code::Blocks, or some other IDE that encapsulates the compilation process at least you'll be familiarizing yourself with how to properly use your IDE. That being said, if you're still dead set on doing this in your browser [tutorials point](https://www.tutorialspoint.com/cprogramming/) has several examples that you can edit and recompile. They even show you the `gcc` command they use to compile the code.
Please properly format your code with 4 spaces prefacing each line. As for safety I think I would use `snprintf` over `sprintf` in order to avoid overflow (although it's impossible as it currently stands, it won't hurt and will help keep this safer as your function may change in the future). I'm not familiar with what appears to be MSP430 assembly (according to google) and as such I have no idea what the `BIS.B` instruction does, but I imagine it's probably fine.
So it "passes" if you change b from (char *) to int. Fucking idiots.
well thats kinda dumb
Like Newt_Hoenikker said, `snprintf` over `sprintf` would be preferred - just pass it `sizeof(command)`. That said, you're right in your impression that it is not the right way to go about this. The entire thing can be done straight in C and requires no extra assembly. And even if it did, you should either use inline assembly, or call a function written in assembly that is assembled at compile time. Creating the assembly in a string and passing it to a function that then takes the string and runs it like assembly at runtime is basically always going to be the wrong way to do it. You should be including some file with a name like [msp430g2231.h](https://github.com/danlash/msp430/blob/master/msp430g2231.h) in your code (Note: I wouldn't recommend just copying the linked header, I just found it via google and your controller is probably a different version or etc., but such a header definitely exists for your controller). You should also consult the documentation for your controller which will explain what the header provides to you. You should note that in the header there are constants defined for things like `P1DIR`, `P2DIR`, etc. This is the same header that the `ASM` function gets the constants from in the first place. So if you include this header in your C code then you'll have access to those constants directly in C and won't have to bother with the assembly. The header does some magic to declare the relevant port's direct as variables directly, so you should be able to do this: P1DIR |= 0xFF; Which will do the equivalent of your assembly (`BIS.B #0xFF, &amp;P1DIR`). To handle all of the ports (Since using those constants directly is a bit annoying), you could make an array: unsigned char volatile *port_dir[] = { &amp;P1DIR, &amp;P2DIR, &amp;P3DIR, ... }; Then you just do `*port_dir[port - 1] |= 0xFF` to access your port. Much better then having a bunch of `if (port == 1) P1DIR else if (port == 2) P2DIR` and on and on till `P9DIR`. But I'm not an export on `MSP430` by any means, so you should check your documentation to figure out if `unsigned char volatile *` is the correct type - It is probably fine, but microcontrollers can do funky stuff some times.
Make sure you use canonical links when linking to a file/directory on GitHub. On GitHub, you can press the "y" key to update the URL to a permalink to the exact version of the file/directory you see -- [source](https://help.github.com/articles/getting-permanent-links-to-files/). I've tried to fix your links: Relative | Canonical -|- https://github.com/danlash/msp430/blob/master/msp430g2231.h | https://github.com/danlash/msp430/blob/2e47e5d6830eec0d997f89bfc79a89a8d736e19c/msp430g2231.h Shoot me a PM if you think I'm doing something wrong.
This is exactly what I wanted. I will have to use an array of short ints (on MSP430) though because the addresses are actually sixteen bits wide. I did not want to hard code the port numbers because I needed flexibility with my I/O. I am writing a library for any variant of the MSP430 to interface the super common Hitachi HD44780 liquid crystal displays. I wrote the whole library in assembly and am now in the process of writing a mostly C version. Thanks!
Files are files. "Binary" only makes a difference on Windows and only affects line ending conversion. They're all just bytes. The important part is how different programs treat those bytes. Anyways... When you write that structure, the number of bytes you're telling fwrite() to read from the address you're giving it is not equal to the size of the variable, so anything can happen. You want something like fwrite(&amp;var, sizeof var, 1, pFile); 
Ultimately I know that I should generate 2 random numbers that represent nodes and swap them with the head /tail each time and do this many times but I am very unfamiliar with linked lists and have only used the random number generator once so I don't know what the code would look like
The port itself is only eight bits wide, but the MSP430 has a 16 bit wide memory space. The addresses are 16 bits wide. The problem with sending the address of the port is it may not be consistent between variations of the MSP430, thus the port number is passed and the appropriate header files will know where the port is located on a chip-by-chip basis.
Nope. `fwrite` writes it byte for byte and will keep that empty space as empty space. It is worth noting that on my system there is no empty space in the above example (`sizeof(int)` yields 4 bytes, `sizeof(struct x)` yields 8).
&gt; The port itself is only eight bits wide, but the MSP430 has a 16 bit wide memory space. The addresses are 16 bits wide. Gotcha, that's what I thought. You want a `char *` then - the `char *` pointer itself should be 16-bits wide already (Since it is an address). The `char` means that when you use this address, you're accessing an 8-bit value. If you use `short *` instead then you'll attempt to access your 8-bit port as a 16-bit port. Though if you're thinking of storing the addresses directly as numbers (and casting them to pointers when you use them) then `short int` makes sense. &gt; The problem with sending the address of the port is it may not be consistent between variations of the MSP430, thus the port number is passed and the appropriate header files will know where the port is located on a chip-by-chip basis. I guess my thinking is just that the person using the library can pass in `&amp;P1IN` or `&amp;P2IN` or etc. depending on what port they wired it to, and then you don't have to bother with those constants at all and wouldn't even depend on the headers defining those constants (Which, not all of the MSP430 variants may actually define those constants. The one I found only defines `P1IN` and `P2IN` and none past that). But I mean, at the end of the day it's probably not that big of a deal, it was just an idea. And I suppose the MSP430's might not have the same layout for each port so it might not be a portable solution regardless.
The distinction of text vs. binary only relates to how line endings are handled. On some systems, opening a file in text mode means that a translation is done between the system's preferred line ending and the newline character. But on other systems, where the line ending is just the newline character, opening a file in text mode has no effect at all and is equivalent to binary mode. (Note: files opened in text mode may not be seekable if on a platform where translation is being done.) 
this is a bit outside the question, but, I just started C 5-6 months, and all these stuff seem to be complicated that I wasn't introduced to. As a beginner, I'm getting a little worried that the above things(CPU, portable, etc...) will come later during the course of learning the language, or do I have to take them in as a beginner?
On Windows, I suggest Visual Studio. It's free, has a nice debugger and it's "usable" for C unless you bump into unimplemented C99 features. Then there's DevC++, a nice package with TDM-GCC. It's a smaller download too. EDIT: Pelles C, never tried it but it seems to be quite full featured.
It is not an IDE, but I use Atom. A lot of packages that together, are IDE-esque.
This is my first _real_ C program. Since I'm pretty new to C I'd like to know what I can do better.
qt creator
But if you want all the (external) tools integrated into one tool, [consider emacs](https://tuhdo.github.io/c-ide.html).
\+ GNU Make + GDB + Valgrind + Git
You probably meant KDevelop? Sure thing, here's a link, with some fancy screenshots: https://www.kdevelop.org/
Reason I'm trying to store it in another section is because the program is taking awhile to load the binary. This is due to the semi-hosting in the background. So, moving print, without the use of sprintf or printf, to print into memory would create faster load times. 
Eclipse CDT
`1 &lt;&lt; PCIE0` shifts `0000 0001` (`1`) to the left (`&lt;&lt;`) by the value of `PCIE0` (`0` in this case) bits. This is to get the 0th (from right to left) bit set. If `PCIE0` would be `1`, the result would be `0000 0010` (`2`, bit 1 is set). `PCICR |= 1` is the same as `PCICR = PCICR | (1)`. It just does an logical OR. This is often used to set certain bits while not affecting other bits. `PCICR` is now `0000 0001`.
+ tmux
and cscope will make it somewhat an IDE
DevC++ and Code::Blocks
I resisted switching to Eclipse for a long time, but I'm pretty comfortable with it now. Most of the time I'm using packages like CodeWarrior that have modified versions of Eclipse with embedded toolchains and some vendor add-ons. Can't say that I've ever used straight Eclipse CDT for anything but cross-compilation. I've never seen the appeal of Emacs. I've done development in vi in a pinch, but it's not my favorite.
`size_t` is not a 'standard' type, you need to include it via `#include &lt;stddef.h&gt;`, just usually this gets included automatically when you include other standard library headers.
What you're looking for is called the flexible array member. There is a special provision whereby you can define the last member of a struct as an array with unspecified bounds. struct foo { size_t size; size_t capacity; unsigned char data[]; }; size_t desired_capacity = 42; struct foo *example = malloc(sizeof(*example) + desired_capacity); example.size = 0; example.capacity = desired_capacity; /* now use example.data as a normal array that contains 42 elements, i.e. example.data[0] .. example.data[41] */ It saves having the pointer in your example, which isn't really doing anything of value because it always points to a fixed offset past the beginning of the struct. 
As you've mentioned you're a beginner, I strongly recommend that you spend time without an IDE, or if you do use an IDE, make sure you don't exclusively use it. The simple reason is that IDEs aren't always available, and I recommend you make certain that you are a capable developer without the IDE.
Note that all sections are loaded from the same file. And typically, segments are memory mapped and only loaded on first access. Putting some data or functions into a separate section would only slow down loading (due to the need to set up a mapping for an extra segment) if it made a difference at all.
Of course this is below two sarcastic Vim/Emacs suggestions.
Eclipse CDT, CLion or QtCreator. If you really want to go old school (or need to work remotely) Emacs with [tuhdo's guide](https://tuhdo.github.io/c-ide.html).
As the above poster said, but note that you'll still need to provide the `sizeof` the flexible array member type if it is not a `char`: struct foo * example = malloc( sizeof *example + desired_capacity * sizeof example-&gt;data[0] ); 
That's all I use, good ole code::blocks.
notepad. jk, that's too hardcore. I use CLion. Aside from standard IDE features like search &amp; replace, word completion, library include suggestions, it also has some really useful keyboard shortcuts (I love the auto format shortcut). It also has GDB integrated and have the option of starting up terminals. Of course, there's also the Git plugin for version control and collaboration.
I found the problem, and you were right, it wasn't in the initialization (I thought it would be because Xcode didn't show the array at all, it just looked like a flat structure in the debugger) In the parsing function, I was trying to auto add a help option, but yeah, it's a major PITA so I'm just gonna remove that part.
I use it when for almost everything. Including C works like a charm tbh
Clion
&gt;The student licence can be renewed until you **no longer have a .edu email address** 
Thanks for the advice. I'll definitely try it :)
You don't require an email terminated in ".edu" to have access to the license, as long as the domain belongs to a university it's accepted.
I think I'm in your shoes. Depending on your deadlines, Notepad++ and Cygwin can help while you're getting up to speed with the syntax. And then when you have breathing room, start dipping your toes into emacs and/or VIM. (I seem to have profs that prefer one or the other)
First off - this looks better than a lot of code I have seen (sadly). Here are my comments, mostly sylistic because I know nothing about the imlib library: 1. Don't mix C and C++ style comments. It looks ugly to me. I'd just use C-style comments, because fuck C++. 2. Divide main into a few functions. If a function is longer than a page, it's probably too long (with exceptions). for example, find_value_for_monitor() can be a function, draw_lock() or draw_text() can be functions and so on. check_args() maybe... 3. Eliminate duplicates: const char *prompt = NULL; if (argc != 4) { prompt = ""; D_PRINTF("Prompt: %s\n", prompt); } else { prompt = argv[3]; D_PRINTF("Prompt: %s\n", prompt); } Instead: const char *prompt = NULL; if (argc != 4) prompt = ""; else prompt = argv[3]; D_PRINTF("Prompt: %s\n", prompt); } or make some people angry and write: prompt = (argc == 4) ? argv[3] : ""; 4. Check out your returns from main(). The work you have to do keeps increasing with each return statement. Yes, yes, goto is bad but this is where we usually use goto and say it's OK. See [this link](http://stackoverflow.com/questions/788903/valid-use-of-goto-for-error-management-in-c) for an example. 5. Some of your magic numbers should probably be macros (150, 300, dw/5, 40, 80). For example #define LOCK_SCREEN_SCALING_FACTOR 5 #define LEFT_MARGIN 40 /* I think ? */ 6. dum2 can be limited to the for() loop's scope. 7. We use index variables like *i* when iterating in a loop, but it's a good idea to have a more descriptive name for variables that hold a meaningful value. In this case, *n* should really be something like num_monitors. That's it for now!
At my office, everyone uses text editors with syntax highlighting for C programming. I'm Working, it's Notepad++. On Linux, most editors will do.
Thank you, I'm implementing these changes right now!
\+ sed + awk + grep + find + ctags + bash/zsh/fish
It's a perfectly reasonable code editor, but I wouldn't call it an IDE.
You appear to be writing C++ code, but you've posted your question in a C programming subreddit. You would probably have more luck over at /r/cpp_questions. For your specific issue, your print statements are expecting to print a string from the arguments (`%s` format specifier), but you're passing in structures.
This is the wrong sub I think, as this is c++, but it looks like you need to actually access the elements of the struct (position or color, whichever you would like to print): printf("vertice %s \n",vertexBuffer[i].position[0])
Portability is only really going to become an issue once you start writing code meant for multiple target platforms. Over the course of learning C it's entirely possible that you won't need to do worry about this, but eventually it will probably come up. My advice is to worry about it as it comes; for now focus on learning the standard for your platform, get good at it, maybe contribute to some open source projects or start your own, and learn how to make your code portable once you need to.
yeah your missing the placeholder in the printf string...which I forgot to correct from an `%s` to a `%f` so try this: printf("%f\n",vertexBuffer[2].color[2]);
&gt; printf("%f\n",vertexBuffer[2].color[2]); Thanks! it worked, prints 0.000000 
It appears that you are programming in C++. However, this subreddit is for C only. Please ask C++ questions elsewhere, e.g. on /r/cpp_questions. I have removed your submission as it is off topic.
Actually the issue is more that if you have two statements in your `#define`, then only the first gets picked up by an if-statement (or similar) without braces. e.g #define MACRO(x ,y) do_thing(x); do_thing(y); if (something) MACRO(a, b); gets expanded to if (something) do_thing(a); do_thing(b); when it should be if (something) { do_thing(a); do_thing(b); } If you have it as a do-while loop, then it turns the whole macro into just one statement, so you don't get any issues: if (something) do { do_thing(a); do_thing(b); } while(0);
The variable `screen` just holds a pointer as a value. This value indeed gets overwritten each time. But it points to some block of memory, and that block it what gets freed when you call `XRRFreeCrtcInfo()` with the address of the block. `XRRGetCrtcInfo()` allocates a block of memory, fills it with relevant information, and returns a pointer to it. You store this pointer in the variable `screen`. So each of the `n` times you run through the loop, you allocate a new block of memory. You end up with `n` blocks of memory, that you should free. Since you didn't memorize each of the `n` references/addresses of those blocks, you need to free them one after another while you still have the address stored in the variable `screen`: inside the loop, before the value stored in the variable `screen` gets overwritten by the next iteration and call of `XRRGetCrtcInfo()` assigned to `screen`.
For debugging with curses you can have gdb/lldb latch onto the process from another terminal, makes it a lot easier.
it is probably a bad idea because it is smaller than a word and thus may require masking and shifting to access. it may take up a full word of memory as well if the compiler can't pack any other char next to it. i think at worse it will be as fast as an int but most likely much slower and require the same space.
if you tend to be on unix, I'd say VIM or EMACS paired with GDB/DDD; The editor for coding, GDB for debugging. CScope and CTags (exuberent tags? whatever the current hotness is) will be good for getting around the code. They integrate with VIM and I assume with EMACS.
`int_fast8_t` is a type designed to be the fastest way to store values in the range -128 through to 127. Your con "need to cast to an int" - actually there is no need to cast
Depends. Use a char counter on a 32-bit machine that doesn't do 8-bit instructions, and it'll have to check to see if an increment instruction created a rollover back to 0 (the expected behavior in C), so that could be slower. stdargs.h gives you some types that (if implemented) let you choose by alias the type that would be, for example, the *fastest* type guaranteed to hold at *least* 16 bits. Also, for a for loop, it's frequently faster to count down than to count up. Comparing with zero is often basically free, and comparing with anything else requires an extra instruction. The HCS08 has a decrement-and-branch-if-not-zero instruction, so that (for c = 10; c; c--) loop compiles to one load instruction and one DBNZ instruction.
I use Atom as my go to text Editor, it has a lot of plugins , while not an IDE (no profiler/debugger) it has a huge array of plugins and you can also reprogram it if you so desire.
For an iterator for a for loop you wont gain anything (and as ruertar points out you might actually lose some performance). If you're storing tens of thousands (or more) of integers in the range of -128 to 127 (or 0 to 255) then char *might* be beneficial as they would use less memory (and hence cause fewer cache misses). Depending on the use case, chars can also benefit more from vectorisation (SIMD).
Good if you're working in single chip embedded system, which usualy has very limitied data memory, and mostly likely, those single chip usually have special instruction for handling 8 bit data, no additional masking will needed... However it's pointless for PC which has virtually unlimited memory... 
Yep, I know. But I still don't understand why the dirent1 is not padded like dirent3.
Are you sure it didn't just move the 'unsigned reg's to after d_name? I believe C compilers are allowed to put bitfields in arbitrary order. ~~Also, the 'reg' keyword is pretty useless in structs. I'm fairly certain that GCC ignores it entirely.~~ Edit: I see your #define reg long. I'm not sure _why_ you're doing that, though.
BTW, reg is not a keyword; it's just a plain dumb #define reg long. I could have written `unsigned long` instead of `unsigned reg`. It's just a typedef-like emulation, like saying `typedef long reg;`; unlike the former, this one allows to use both `signed reg` and `unsigned reg` declarations (which plain typedef forbids).
Yes that's the normal use for do/while(0) loop. The question the OP has is not that. It's an empty do/while(0) loop which has zero, not two statements. That was the practice when the compilers gave warnings for empty statements after a conditional. Most compilers don't do that anymore.
One more trick: $(OBJ_DIR)/%.o: $(SRC_DIR)/%.c @echo Compiling $&lt; @mkdir -p $(OBJ_DIR) @$(CC) -c -o $@ $&lt; $(CFLAGS) $(LIBS) This will try to run mkdir -p every time the rule is invoked. Sure it's not harmful but looks a bit ugly, right? You can use an order-only prerequisite. See this: https://www.gnu.org/software/make/manual/html_node/Prerequisite-Types.html Another make trick is to use VPATH instead of SRC_DIR in your example. With that you can add multiple source directories if your program expands and not worry about setting the prerequisites for the objects properly. The rule would go from: $(OBJ_DIR)/%.o: $(SRC_DIR)/%.c to $(OBJ_DIR)/%.o: %.c even if you have multiple source directories.
You cannot take an address of a bit field. What should have it contained, if you could? However, it doesn't matter. I for sure CAN understand at which offset each bit field is placed; I've already pointed the way one can understand it using some memset tricks; the point is that it does not explain why all compilers employ such strategy.
Because I want a typedef to an integer type which is capable of storing a register. Again: it doesn't matter, I could've used a `long` here.
So why dirent1 differs from dirent3, although both have unnamed long bit fields?
The padding at the end is simple. The structure contains a type that requires 8-byte alignment, so the structure itself must be padded to a multiple of 8. This is done at the end of the structure. It's needed so that it will work correctly as an array. You'll see this without bit-fields. Good point about dirent1 still having a long bit-field. I forgot about that. I think it comes down to this part of the ABI: &gt; bit-fields must be contained in a storage unit appropriate for its declared type In dirent1, the 8-bit field shares space with the `uint8_t` before it. Then the 32-bit field is just a 32-bit integer with 4-byte alignment. In dirent3, it looks like all the bit-fields are essentially joined into a single underlying `long` field, and so it has 8-byte alignment. I can't see anything in the ABI to say that this is how it *has* to work, so it seems this is really up to the compiler's discretion.
The whole uintX_t stuff makes sense if and only if you have a C library and a compatible &lt;stdint.h&gt;. Well, I should have written it before. :-) Did you note that I've chosen struct dirent as an example? That's exactly due to the fact that I develop some piece of code **without** libc and with as minimal headers as possible (even &lt;stdarg.h&gt; is not present). Does it clarifies why I have a register-like type? :-)
I took the addresses of the other ones since they are not bit fields. :-)
stdint.h is not part of libc - it's part of C. If you're using a platform that doesn't have it, you can always create it. 
I understand the padding will be different, but they should be the same size though according to manually laying out the memory structure in my head: struct dirent1 { uint32_t d_ino; // [0x0000] size 4 bytes uint16_t d_namlen; // [0x0004] size 2 bytes uint8_t d_type; // [0x0005] size 1 byte // +1 byte padded for 8-byte alignment (for next variable) unsigned reg : 8; // { [0x0008] size 8 bytes, bits 7-0 used unsigned reg : 32; // bits 39-8 used, bits 63-40 padded } char d_name[255 + 1]; // [0x0016] size 256 bytes }; // size 272 bytes struct dirent3 { unsigned reg d_ino : (sizeof(uint32_t) * 8); // { [0x0000] size 8 bytes, bits 31-0 used unsigned reg d_namlen : 16; // bits 47-32 used, unsigned reg d_type : 8; // bits 55-48 used, unsigned reg : 8; // bits 63-56 used } unsigned reg : 32; // { [0x0008] size 8 bytes, bits 31-0 used, bits 63-32 padded } char d_name[255 + 1]; // [0x0016] size 256 bytes }; // size 272 bytes 
3.1: "Unnamed bit-fields' types do not affect the the alignment of a structure or union." `dirent3` has named bitfields with the `long` type, so it has to have alignment appropriate for `long`. `dirent1`'s has no `long` members except the unnamed bit-fields, so its alignment is determined by the `uint32_t` member.
that's a possibility. or you could [redirect i/o to another tty](http://www.dirac.org/linux/gdb/07-Debugging_Ncurses_Programs.php#separatingtheinput/output). 
&gt; What I expected here is that all structures would occupy 268 bytes on x86_64. &gt; Yep, I know. Which one is it? Those two sentences contradict each other. Forget the word padding. The word padding leads to misconceptions. The term to focus on when laying out struct members is "alignment". Padding is what's left over after all the alignment requirements have been fulfilled. On x86_64 the size of the struct must be a multiple of its alignment requirement. The alignment requirement of the struct is equal to the alignment requirement of its most strictly aligned member. First two cases the most strictly aligned members have the type "int", in the third case they have the type "long". The fact that they are bit-fields doesn't matter. The ABI document says: "bit-fields must be contained in a storage unit appropriate for its declared type" and "Bit-fields obey the same size and alignment rules as other structure and union members." And why d_name has the same offset is also stated in the ABI: "bit-fields may share a storage unit with other struct / union members". 
Guys, I think we've found an answer. In case anyone is interested, here's a link to the comment in the original post: https://www.reddit.com/r/gcc/comments/66glcd/gcc_anonymous_bit_fields_padding/dgilvyh Thank you for participating! It was a really interesting discussion and it has shown one more time that there are subtle corners in C language which may surprise every single day. As for me, it's yet another reason to love this language! :-)
my bad for not saying this at the very beginning of the post: we just started learning the c language at my university and our prof gave us a problem to solve: write a recursive function that checks if all the numbers in a linear array are even and, if this is the case, return true. The prof said that he does not care about the program itself but about the logic process that we will use to solve this problem so there is no need to include libraries, to specify a main function or to write additional functions. In this case he probably imagined that he had a given function he could use to sum vectors and he used it in this sample. I think this is a little bit confusing for newbies of c but this is the problem and I'm trying to understand what each line does. In particular I'm confused by pointers and by what it's written in the first bool function bool dummy(int v[],int len, int*s){ ... } ___ btw I tried doing the program on my own and this is the result, it seems to work since it returns 1 if I use the first vector, it returns 0 if I use the second (I don't like to use bool if I can return 0 or 1.. is this logic correct?) #include &lt;stdio.h&gt; int main(){ /* int vector[10]={1,2,3,4,5,6,7,8,9,10}; */ int vector[10]={2,4,6,8,10,12,14,16,18,20}; int i; for(i=0;i&lt;10;i++){ if(vector[i]%2==0) return 0; return 1; } } 
&gt; Which one is it? Those two sentences contradict each other. It seems that I've formulated it incorrectly. OK, here is what I wanted to say: * I know that alignment and padding exists, and wouldn't have been surprised if it was in all three structures. * Anyway, I expected all the structures to occupy the same amount of memory and obey the same alignment rules.
I tried running your sample but I get Process returned 1 (0x1) Also there is a really high chance that I made mistakes copying from the blackboard so that's probably one of the reason because my first function does not work at all 
Well that's exactly what it will do if the array is all evens (return true aka 1). I don't really understand what you are expecting.
ooooh. my bad, somehow I was told that 0=true and 1=false (not by my prof, just previous knowledge of my own)
And you might want to use file mapping.
Is there a pattern to your shorts? If so, consider constructing a lazy iterator instead of an eager array. Though that's still a huge data set to work with lol
In shell scripting that is actually the case, but virtually everywhere else, 0 is false and 1 is true.
Mmm not really... I need the whole array in one shot, I need to run sorting algos on it.
This is an interesting idea, will look into it!
not helpful, I know, but I would be very curious to know why you think you need such a large array...
Even assuming you can afford to map that much (page tables take memory too), the *actual* amount you can portably allocate via `malloc` or array decl is (1.) related to `SIZE_MAX`, not `ULONG_MAX`, and (2.) usually `1 + SIZE_MAX/2` for reasons. Also, if youre on x86-64, you cant use the top half of the address space from user mode so even if the language let you allocate more, you cant because of the ABI and architecture. You might theoretically be able to `mmap` almost up to `SIZE_MAX`, however, if you can find the room.
You may find this useful: https://www.cs.rit.edu/~ats/books/ooc.pdf
Look into glib's object system.
Object Oriented programming is about data hiding and coupling data to the functionality that changes/access that data. An opaque struct with associated functions receiving a pointer to said struct as object instance is usually enough, there is no need to have function pointers and such. That said, your approach is fine, the only issues I see are your use of static global variables (the foc pointer) and returning the struct by value in one of the functions. If you're interested, I'd suggest you take a look at GTK or GObject libraries, they implemented a complete OO system in pure C. Edit: since you are using the wonderful godbolt site, make a proper C++ implementation of your code (with classes and virtual functions) and compare the generated assembly with your C version. I'm sure you will be surprised.
If you want to avoid learning Assembly and still be able to understand Assembly code, you're wasting your time.
So can we see the ten little lines ? 
Did you have a question?
Yes. What is wrong with my reverse function as why it doesn't work.
I couldn't hold myself: https://godbolt.org/g/iFY0W6 ;-)
OOP is a nice way to think about programming. People who know it often miss it when they go back to procedural languages. 
As /u/maddoc74 said, it is a nice way to think about things. If I wanted to, say, normalize a vector named `x`, it'd be nicer to be able to do `x.norm();` instead of doing `norm(&amp;x);` imo.
What's it supposed to do? What is it actually doing?
Print the linked list backward by iteration not by recursion.
You'll more commonly see it called the [ternary operator](https://en.m.wikipedia.org/wiki/%3F:#C). It's essentially a shorter `if ... else ...` In this example, it's equivalent to the following: if (strcmp(str1, str2)) c4 = 'C'; else c4 = 'M';
Non-Mobile link: https://en.wikipedia.org/wiki/%3F:#C *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^58714
Object Orientation is just one of many programming paradigms. You can do it in C as you can do it in Lisp. As you can do functional programming in C or C++. It's just a way to think about the algorithms and organize the code. Some languages have syntax to ease the use of one paradigm or another, but you can usually get any paradigm in any language with some effort.
You're printing the values as you process them, not as they're ordered in the list. Your code does appear to be reversing the list properly, although you need to update the `head` value in your `main()` function. You could do this by returning the new head pointer.
Makes sense. Thanks!
I would look into `container_of`, which provides a very low cost (Syntactically and in general) approach to basic object orientation. That said, the general approach of function pointers inside a `struct` is very powerful. Take for example a basic struct with a `read` and `write` function: struct stream { int (*read) (struct stream *, char *buf, size_t len); int (*write) (struct stream *, const char *buf, size_t len); }; The first argument to the function pointers is the `this` pointer equivalent in C++. So you would call such a function like this: struct stream *s; s-&gt;read(s, buf, len); s-&gt;write(s, buf, len); The advantage of this approach is that you can 'extend' the `struct stream` as much as you want, and then `container_of` can be used to easily 'cast' between the various levels. Combined with making functions internal to files (via `static`) it can be very powerful. For example, a file-based stream might look something like this, with this in a header: struct stream_file { struct stream s; FILE *filp; }; void stream_file_init(struct stream_file *, FILE *); And then in a file called "stream_file.c": #include "stream_file.h" static int stream_file_read(struct stream *s, char *buf, size_t len) { struct stream_file *f = container_of(s, struct stream_file, s); return fread(buf, len, 1, f-&gt;filp); } static int stream_file_write(struct stream *s, const char *buf, size_t len) { struct stream_file *f = container_of(s, struct stream_file, s); return fwrite(buf, len, 1, f-&gt;filp); } void stream_file_init(struct stream_file *f, FILE *file) { f-&gt;s.read = stream_file_read; f-&gt;s.write = stream_file_write; f-&gt;filp = file; } This design hides the actual implementation functions in the "stream_file.c" source file, meaning that it becomes basically impossible to incorrectly assign that function pointer to a `struct` of the wrong type. A common further step (Though it isn't always that necessary or important) is to extract that relevant operations into a separate `struct` and only make one copy of it. So in the header: struct stream_ops { int (*read) (struct stream *, char *buf, size_t len); int (*write) (struct stream *, const char *buf, size_t len); }; struct stream { /* Other related fields would go in here, if there were any */ struct stream_ops *ops; }; Then in the C file, you would do this: /* ... Implementation code ... */ static struct stream_ops stream_file_ops = { .read = stream_file_read, .write = stream_file_write, }; void stream_file_init(struct stream_file *f, FILE *file) { f-&gt;s.ops = &amp;stream_file_ops; f-&gt;filp = file; } This technique is nice because for one it saves some space (All `stream_file` objects use the same copy of `stream_file_ops`), and two, you could expose `stream_file_ops` in the header and then make `stream_file_init` inline in the header, and you still won't have to expose the actual member functions (`stream_file_read`, `stream_file_write`, etc.) in the header, keeping them hidden and preventing people from being able to call them directly.
I know PETSc uses a heavily object oriented program structure and is purely C. It's quite opaque however and I'm not sure I would recommend it. 
just use c++ lol
I guess I'll have to try and see if it's OK 
Well yes, but then you dont gain much of an ergonomic advantage over type_function(x, args), which is simpler. The goal I had was avoiding passing a "self" thing. The ideal setup would be somehow getting a pointer to the parent struct from inside the function, but I doubt this is possible without hacky globals.
Yes, that's the method I'm currently using in my code. I'd prefer OO for the sake of it being shorter and more straightforward, though.
Have the programs return the x in main so that they are forced to actually do something. Right now g++ realizes that "welp, this does nothing, return 0 and we're done here".
Haha, I know right! Thanks for checking it out. Do you have a link to your implementation?
Sure but note that the C++ version is even more optimized because the compiler understands what you're doing and is able to realize it does nothing. The C version the compiler "don't understand" and so can't optimize further. 
~~I can't get this to work. I've copied your code verbatim and the following is my output:~~ 0 8 4 12 2 10 6 14 1 9 5 13 3 11 7 15 ~~Am I the only one?~~ **EDIT:** Just now realized this is meant to imitate bit *reversal* not bit negation... My bad.
&gt; Just now realized this is meant to imitate bit reversal not bit negation Right. When I print in binary this is what it looks like before and after: 0 0000 0 0000 1 0001 8 1000 2 0010 4 0100 3 0011 12 1100 4 0100 2 0010 5 0101 10 1010 6 0110 6 0110 7 0111 14 1110 8 1000 1 0001 9 1001 9 1001 10 1010 5 0101 11 1011 13 1101 12 1100 3 0011 13 1101 11 1011 14 1110 7 0111 15 1111 15 1111 [I extended the code](https://pastebin.com/zbkzH1Aq) to show every step that is performed. The reversed representation of all numbers in the array from 0 to 15 are already there. Only the right ones have to be swapped. For example 1 and 8, 2 and 4, etc. Numbers like 0 or 6 are already their counterpart. The algorithm basically finds the correct values to swap.
Yeah, that's true but not really respresentative of the overhead with a program that actually does something.
Codeblocks doesnt like the array style notation when used with pointers, it throws an error with compiling as opposed to crashing at the scanf. scanf("%lf",*point+i); should be dereferencing to the address and then incrementing to the address of the variable in question but many times it wont even let me type a number before it crashes the program.
What error do you get? What exactly did you write? Note that Code::Blocks isn't a compiler, so it doesn't give you compiler errors. Rather whatever compiler you configured to use gives you this error. I get an error is not an error description and won't help me resolve your problem. Your program crashes because you allocate the wrong amount of memory with `realloc()` as I said before.
The counterparts j for the incrementing i for the swap are based on the [Van der Corput sequence](https://en.wikipedia.org/wiki/Van_der_Corput_sequence) and this technique is described in [Bit-reversal permutation](https://en.wikipedia.org/wiki/Bit-reversal_permutation). You might find more to the subject in the material referenced in the article. What is the DSP book you are reading?
What do you seed it with? It needs a seed to generate numbers.
i did seed it with time and put it outside of main and called it multiple times but same value keeps on being generated 
will do this just now 
Show us the code then.
thank you man so much so very much you just saved my project thank you so much . I mean i couldn't succeced due to my lack of knowledge and you saved me thank you so much . and btw can you tell me the name of the book from which you studied c language . Thanks again man for helping me
Thankyou. That did it.
Thank you man ! Im doing the project with him and you saved us from what looked like a problem that would completely ruin the project !
No problem, and good luck with the project! :-)
What you wrote should be correct except that you should allocate memory for `deg + 1` coefficients. Let me run a quick test... What does `*point` point to initially?
Ok, that should work. With the correction from the previous comment applied (`deg + 1` coefficients, scan into `&amp;deg` instead of `deg` when scanning the polynomial degree), your code works on my machine.
Neat! Thanks for sharing.
You're doing it right, but your chosen value (ULONG_MAX - 1) is just too big for the machine. For now. 
For a fair few of these, the man pages on your system (Assuming you're on a *nix) are probably going to be a lot more detailed than what this says. Though this has code examples for some things that the man page doesn't.
Yikes.
Weird, in Xcode it's just `int main(int argc, const char * argv[])`
Indent code 4 spaces to make it readable: int port; //will be set in program at runtime char command[20] ... if (port &gt; 0 &amp;&amp; port &lt; 10) { sprintf(command, "BIS.B #0xFF, &amp;P%dDIR", port); ASM(command); //configures port to be output } I don't know what ASM() does. With most compilers I've used, ASM was a macro and you couldn't compute its argument at runtime. So if that's the case, then this code wouldn't work. If, on the other hand, ASM() actually assembles its input on the fly and then executes it, then this may be dangerous code, depending on a lot of factors. At least you were smart enough to check your inputs, because the first way someone would try to exploit this would be to provide a very large, carefully-crafted value to port, which would cause overflow to morph your BIS instruction into something else. But this is a micro controller, so your problem domain is different from most of us. If this works, and you have full control of the inputs to it, it's probably safe. Hell, I wrote self-modifying bitslice code once. (An aside, read the [Saga of Mel](http://www.catb.org/jargon/html/story-of-mel.html))
Yeah, that avoids situations where you're locked in to one compiler. The Linux kernel is currently GCC only, there are efforts to make it work with clang. 
No, there's no error. C supports [one's complement](https://en.wikipedia.org/wiki/Ones%27_complement) systems, which have both positive and negative zero. There really aren't many such systems left, but some protocols specify algorithms that uses it (e.g. the IPv4 checksum).
Thanks. I somewhat remember this from my assembly language class. So it is the compiler that determines which system to use, right?
It usually depends on the architecture of the system you are running, unless you are cross-compiling.
It's not considered bad style to do that. And yes, you can safely assume that relational operators return 0 or 1.
It is not bad practice per se, but it's good form to use flag.foo = !!(x == 'y'); This shows that the result is expected to be either 0 or 1, and that the field foo can be a bitfield of width 1 without problem.
At least in C11 the result of a comparison is assured to be either 0 or 1, never anything else. I'm not sure for other versions however. But yeah, the !! is purely cosmetic and a way to shout at the reader.
If A is greater than B, do foo, else do bar.
I know that `0 == 1` is 0, but am i correctly recalling that on some architectures, `1 == 1` might not be 1, possibly something like -1?
Nope. The result of a relational operator is always 0 or 1 as per ISO/IEC 9899:2011 6.5.8 6.
`graphics.h` is a DOS header and only works on DOS. What operating system are you programming for? Are you writing a terminal application or a GUI application?
Im programming for windows Its a terminal application
By definition, `a ? b : c` is equivalent to `if (a) b; else c;` except that `a ? b : c` is an expression and takes the value of what is executed. For example, `x = a ? b : c` behaves like `if (a) x = b; else x = c;`.
Okay. In this case you can use the Windows API (`windows.h`) which provides the function [`SetConsoleTextAttribute()`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686047\(v=vs.85\).aspx) to change the font color.
I see. I pronounce it as *a* question mark *b* colon *c*.
Its a project so I need to only use C :/
The Windows API is a C API. You can use this function from your C program, even though it says C++ in the description.
So, maybe I'm still not making myself clear. If you see the following: if (foo) bar(); else baz(); Do you literally just pronounce the symbols and say, "If open-parens, foo, close parens, bar..." Or do you turn it into a closer-to-plain-English sentence like, "If foo, *then* bar, else baz" (even though the keyword "then" was not in the statement)? I think that's more what I was looking for.
No. `if (foo) bar(); else baz();` is pronounced if foo then call bar else call baz. However I also pronounce a ? b : c as previously indicated.
'a' greater than 'b' question 'foo()' colon 'bar()'. But I'd say whatever works for you mentally.
Oh hey, I did this project too.
"if a is greater than b then foo else bar" is how I would read it.
Because the ternary operator makes your eyes bleed.
I came from Lua as a first language a decade ago, so I've carried over saying "a and b or c", and that works for me. 
`!!` is used when you want to convert an integer to 1 for any non-zero value. `==` already produces only 0 or 1 so it's useless and confusing to do that.
Because it's redundant. The result from `==` is already 0 or 1.
That doesn't seem particularly hard, I'd just say "call function foo if a is greater than b, else call function bar".
I would read that as: If c is not an end of file character, call foo, otherwise, call bar.
[PDCurses](https://pdcurses.sourceforge.io/doc/index.html) might interest you. Also, typically, IDEs are not responsible for installing libraries. [here](http://www.codewithc.com/how-to-include-graphics-h-in-codeblocks/) is a article about installing graphics.h so that you can use it with code blocks. I am not a Windows user, but apparently, graphics.h is native to Turbo C++.
Just keep in mind your to code examples are not the same. In the first case, flag.foo is always set, in the second case, it is only ever set to 1. If you want the second case to be equivalent, you need an else statement setting flag.foo to 0.
I've attempted to research this for my own knowledge, and as far as I can tell, there was only one sign-magnitude computer ever sold commercially. One's complement was popular during the 60s and early 70s (most DEC PDPs, some other ones too) but pretty much two's complement won during the late 70s. Very few one's complement machines are made anymore, and those that are, are really emulated by modern systems (mostly mainframe architectures from the 60s still in use by several large industries). 
What IBM models used sign-magnitude? And I'll have to dig out my Art of Computing to see what Knuth said. 
According to me what it does is that it sets the base value same every time srand is called so in order to avoid that srand is just called once
If you mean before 1989, maybe, but very unlikely. The same thing is standardized in ANSI C. In fact, the words in C11 are identical to ANSI C. This is not a thing that can change.
Does ANSI codes like that work on Windows?
Windows-10-TH2-(v1511) seems to support them. Haven't tried myself though http://www.nivot.org/blog/post/2016/02/04/Windows-10-TH2-(v1511)-Console-Host-Enhancements
Back in the day I used to use conio.h but that was very MSDOS. I think windows.h is the way to go these days.. edit: I see that yes, windows.h is it from reading other replies. 
You miscounted by one
-127 to +127 is 255 numbers, 0-255 is 256 numbers.
 /* I use this for temporary stuff. This works only on linux I think. example: */ printf(kY " ! " ky " Warning " rs "\n"); printf(kR " ! " kr " Error " rs "\n"); /* * 1st is foreground, 2nd is background; * lower case means dark color, uppercase means light colors. * k = black * r = red * g = green * y = yellow * b = blue * m = magenta * c = cyan * w = white * rs = reset */ #define kk "\x1b[30;40m" #define rk "\x1b[31;40m" #define gk "\x1b[32;40m" #define yk "\x1b[33;40m" #define bk "\x1b[34;40m" #define mk "\x1b[35;40m" #define ck "\x1b[36;40m" #define wk "\x1b[37;40m" #define kr "\x1b[30;41m" #define rr "\x1b[31;41m" #define gr "\x1b[32;41m" #define yr "\x1b[33;41m" #define br "\x1b[34;41m" #define mr "\x1b[35;41m" #define cr "\x1b[36;41m" #define wr "\x1b[37;41m" #define kg "\x1b[30;42m" #define rg "\x1b[31;42m" #define gg "\x1b[32;42m" #define yg "\x1b[33;42m" #define bg "\x1b[34;42m" #define mg "\x1b[35;42m" #define cg "\x1b[36;42m" #define wg "\x1b[37;42m" #define ky "\x1b[30;43m" #define ry "\x1b[31;43m" #define gy "\x1b[32;43m" #define yy "\x1b[33;43m" #define by "\x1b[34;43m" #define my "\x1b[35;43m" #define cy "\x1b[36;43m" #define wy "\x1b[37;43m" #define kb "\x1b[30;44m" #define rb "\x1b[31;44m" #define gb "\x1b[32;44m" #define yb "\x1b[33;44m" #define bb "\x1b[34;44m" #define mb "\x1b[35;44m" #define cb "\x1b[36;44m" #define wb "\x1b[37;44m" #define km "\x1b[30;45m" #define rm "\x1b[31;45m" #define gm "\x1b[32;45m" #define ym "\x1b[33;45m" #define bm "\x1b[34;45m" #define mm "\x1b[35;45m" #define cm "\x1b[36;45m" #define wm "\x1b[37;45m" #define kc "\x1b[30;46m" #define rc "\x1b[31;46m" #define gc "\x1b[32;46m" #define yc "\x1b[33;46m" #define bc "\x1b[34;46m" #define mc "\x1b[35;46m" #define cc "\x1b[36;46m" #define wc "\x1b[37;46m" #define kw "\x1b[30;47m" #define rw "\x1b[31;47m" #define gw "\x1b[32;47m" #define yw "\x1b[33;47m" #define bw "\x1b[34;47m" #define mw "\x1b[35;47m" #define cw "\x1b[36;47m" #define ww "\x1b[37;47m" #define Kk "\x1b[1;30;40m" #define Rk "\x1b[1;31;40m" #define Gk "\x1b[1;32;40m" #define Yk "\x1b[1;33;40m" #define Bk "\x1b[1;34;40m" #define Mk "\x1b[1;35;40m" #define Ck "\x1b[1;36;40m" #define Wk "\x1b[1;37;40m" #define Kr "\x1b[1;30;41m" #define Rr "\x1b[1;31;41m" #define Gr "\x1b[1;32;41m" #define Yr "\x1b[1;33;41m" #define Br "\x1b[1;34;41m" #define Mr "\x1b[1;35;41m" #define Cr "\x1b[1;36;41m" #define Wr "\x1b[1;37;41m" #define Kg "\x1b[1;30;42m" #define Rg "\x1b[1;31;42m" #define Gg "\x1b[1;32;42m" #define Yg "\x1b[1;33;42m" #define Bg "\x1b[1;34;42m" #define Mg "\x1b[1;35;42m" #define Cg "\x1b[1;36;42m" #define Wg "\x1b[1;37;42m" #define Ky "\x1b[1;30;43m" #define Ry "\x1b[1;31;43m" #define Gy "\x1b[1;32;43m" #define Yy "\x1b[1;33;43m" #define By "\x1b[1;34;43m" #define My "\x1b[1;35;43m" #define Cy "\x1b[1;36;43m" #define Wy "\x1b[1;37;43m" #define Kb "\x1b[1;30;44m" #define Rb "\x1b[1;31;44m" #define Gb "\x1b[1;32;44m" #define Yb "\x1b[1;33;44m" #define Bb "\x1b[1;34;44m" #define Mb "\x1b[1;35;44m" #define Cb "\x1b[1;36;44m" #define Wb "\x1b[1;37;44m" #define Km "\x1b[1;30;45m" #define Rm "\x1b[1;31;45m" #define Gm "\x1b[1;32;45m" #define Ym "\x1b[1;33;45m" #define Bm "\x1b[1;34;45m" #define Mm "\x1b[1;35;45m" #define Cm "\x1b[1;36;45m" #define Wm "\x1b[1;37;45m" #define Kc "\x1b[1;30;46m" #define Rc "\x1b[1;31;46m" #define Gc "\x1b[1;32;46m" #define Yc "\x1b[1;33;46m" #define Bc "\x1b[1;34;46m" #define Mc "\x1b[1;35;46m" #define Cc "\x1b[1;36;46m" #define Wc "\x1b[1;37;46m" #define Kw "\x1b[1;30;47m" #define Rw "\x1b[1;31;47m" #define Gw "\x1b[1;32;47m" #define Yw "\x1b[1;33;47m" #define Bw "\x1b[1;34;47m" #define Mw "\x1b[1;35;47m" #define Cw "\x1b[1;36;47m" #define Ww "\x1b[1;37;47m" #define kK "\x1b[5;30;40m" #define rK "\x1b[5;31;40m" #define gK "\x1b[5;32;40m" #define yK "\x1b[5;33;40m" #define bK "\x1b[5;34;40m" #define mK "\x1b[5;35;40m" #define cK "\x1b[5;36;40m" #define wK "\x1b[5;37;40m" #define kR "\x1b[5;30;41m" #define rR "\x1b[5;31;41m" #define gR "\x1b[5;32;41m" #define yR "\x1b[5;33;41m" #define bR "\x1b[5;34;41m" #define mR "\x1b[5;35;41m" #define cR "\x1b[5;36;41m" #define wR "\x1b[5;37;41m" #define kG "\x1b[5;30;42m" #define rG "\x1b[5;31;42m" #define gG "\x1b[5;32;42m" #define yG "\x1b[5;33;42m" #define bG "\x1b[5;34;42m" #define mG "\x1b[5;35;42m" #define cG "\x1b[5;36;42m" #define wG "\x1b[5;37;42m" #define kY "\x1b[5;30;43m" #define rY "\x1b[5;31;43m" #define gY "\x1b[5;32;43m" #define yY "\x1b[5;33;43m" #define bY "\x1b[5;34;43m" #define mY "\x1b[5;35;43m" #define cY "\x1b[5;36;43m" #define wY "\x1b[5;37;43m" #define kB "\x1b[5;30;44m" #define rB "\x1b[5;31;44m" #define gB "\x1b[5;32;44m" #define yB "\x1b[5;33;44m" #define bB "\x1b[5;34;44m" #define mB "\x1b[5;35;44m" #define cB "\x1b[5;36;44m" #define wB "\x1b[5;37;44m" #define kM "\x1b[5;30;45m" #define rM "\x1b[5;31;45m" #define gM "\x1b[5;32;45m" #define yM "\x1b[5;33;45m" #define bM "\x1b[5;34;45m" #define mM "\x1b[5;35;45m" #define cM "\x1b[5;36;45m" #define wM "\x1b[5;37;45m" #define kC "\x1b[5;30;46m" #define rC "\x1b[5;31;46m" #define gC "\x1b[5;32;46m" #define yC "\x1b[5;33;46m" #define bC "\x1b[5;34;46m" #define mC "\x1b[5;35;46m" #define cC "\x1b[5;36;46m" #define wC "\x1b[5;37;46m" #define kW "\x1b[5;30;47m" #define rW "\x1b[5;31;47m" #define gW "\x1b[5;32;47m" #define yW "\x1b[5;33;47m" #define bW "\x1b[5;34;47m" #define mW "\x1b[5;35;47m" #define cW "\x1b[5;36;47m" #define wW "\x1b[5;37;47m" #define rs "\x1b[0m" 
Yeah! My bad, I apologize. I adapted the examples from my real code, where I know for sure that the test will only run once and all fields in the beginning are 0. I edited the post for clarity =)
Thank you very much =)
My brother uses linux and he said the exact same thing
1. A comparison result is defined by the standard as an int. 2. What follows !! can be anything, not just int, which is one reason to use it some times. 3. I've already acknowledged that it was useless and only a matter of cosmetics previously, as well as verified in the standard that there was no risk not to use it. I only leave this discussion here because it can be informative. No need to downvote.
Tracy is a tool that gives you a slick interface for error propagation for code that doesn't use exceptions. It's a part of a bigger infrastructure we had at work, and decided to take it out for everyone to use. IMO, it's extremely comfortable. I'd like to hear opinions and ideas about it.
You're probably thinking of Javascript if you're screaming and trying to make yourself vomit.
 Thanks! I didn't know that
Nice OS, Emacs I mean.
&gt; Why is it bad to check compilation for both C and C++? I imagine that if someone uses that, he could either use the source code or a precompiled library. If anyone chooses to use the source code, why shouldn't he be able to compile it with the C++ compiler? C and C++ are different languages. While some programs might do the same thing and be well behaved in both languages, many more complicated programs aren't. C has many corner cases on its own; writing software which gets around the corner cases of both C and C++ is somewhat tricky as it requires close familarity with both language standards. You shouldn't do that. I have discussed this topic very often and by now I am a bit sick of it. &gt; It's a convention at my old workplace. Will change it. Is there a common convention for type definitions that are exported from a library? Choose any other name that is not [reserved](http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_02_02), such as `tracy_error`.
How do you mean 'can't use any library', and does that preclude you from looking at something like the cephes implementation? https://github.com/deepmind/torch-cephes/blob/master/cephes/cmath/exp.c
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [deepmind/torch-cephes/.../**exp.c** (master  f8a3a11)](https://github.com/deepmind/torch-cephes/blob/f8a3a110c369bd1f65253b35436f3037458b4264/cephes/cmath/exp.c) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dgougcd.)^.
Try to precompute the factorials so you don't have to call `fact` every time. By precomputing `1 / fact(x)`, you can also turn a costly division into a cheap multiplication. In a nutshell, that's what the usual implementations do. Another thing you could do is using the coprocessor's `f2xm1` instruction to do the heavy lifting. Here is pseudocode to do that: 1. Let *x* be the input. 2. Compute *x'* = *x*  log2(e) (push log2(e) on the stack using `fldl2e`) 3. split the result into an integer part *a* and a fractional part *b* 4. compute 2^(*b*) using `f2xm1` (don't forget to subtract one) 5. use `fscale` to multiply 2^(*b*) with 2^(*a) 6. return the result This should be reasonably fast and precise. I'm currently implementing this to find out how well it performs.
Do you mean the single character '0' or the '\0' character? 
(no library, including the standard one) I already have a compilation setting (`MATH_FASTFACT`) which uses a value table instead of an actual algorithm to compute x!. Unfortunately, starting from x=12, x! overflows on 32 bits integers so I can't have a lot of accuracy... Also, I have no idea how to implement a decent natural logarithm function at the moment, I just finished working on the 3 main trig functions (cos, sin, tan) and will look into log later though.
It would seem like \0 as cygwin's gcc seems to print a strange square-like blob
Read in your book about null terminated strings. 
I recommend you to store 1/x! as floating point constants, this solves your range problem. Here is an assembly implementation of `exp` that is fast, takes up some 27 bytes of storage and is precise to more decimal places than you care about: .text .globl myexp .type myexp,@function .align 16 myexp: fldt 4(%esp) # x fldl2e # log2(e) x fmulp # x' (= log2(e) * x) fld %st(0) # x' x' frndint # round(x') x' fsubr %st(0),%st(1) # round(x') x'-round(x') fxch # x'-round(x') round(x') f2xm1 # 2^(x'-round(x'))-1 round(x') fld1 # 1 2^(x'-round(x'))-1 round(x') faddp # 2^(x'-round(x')) round(x') fscale # 2^(x'-round(x'))*2^round(x') (= 2^x' = e^x) round(x') fstp %st(1) # e^x ret .size myexp,.-myexp Note that this code doesn't care about the current rounding mode as `frndint` is just used to split *x'* into an integer and a fractional part. Further note that this code of course doesn't treat out-of-range arguments, infinities, and NaNs correctly. You can build a logarithm function using the similar `FYL2X` instruction.
Your reverse function needs a bit of tuning: Why? Let's consider your snippet: for (index = 0; index &lt;= len; ++index) { if (input[len - index] != '\0') output[index] = input[len - index]; } Suppose your input string is `hello`. This is actually represented as `hello\0`, right? So its length is `5`, and `input[len-index]` in the first run would be `input[5-0]`, which is `\0`. So `output` already starts from index `1` instead of index `0` since it's skipped due to the `if` condition! So the progression is, for reasons of brevity, like so: output[0] = &lt;some junk value&gt; output[1] = input[5-1] = 'o' output[2] = input[5-2] = 'l' output[3] = input[5-3] = 'l' output[4] = input[5-4] = 'e' output[5] = input[5-5] = 'h' So `output` becomes `*olleh` where `*` represents some garbage value. Also, your `output` string is not `NUL` terminated, so it's just pure chance that it actually prints out some valid characters in the first place! **Always** terminate your strings with an explicit `\0`. Instead, something like this should work (minimal modification): void reverse (char output[], char input[], int len) { int index = 0; for (index = 0; index &lt; len; ++index) { output[index] = input[len -1 - index]; } output[index] = '\0'; } for instance. Note the change in the index values (the `-1` is since we are now looping upto one character before `\0`), and also explicitly marking the string termination with `\0`. The `if` condition is also not required since you already have the length of the string captured in `len`. Secondly, in your `getline` function, you should again terminate the input string with a `\0`. Relevant snippet: for (index = 0; index &lt; limit -1 &amp;&amp; (current = getchar()) != EOF &amp;&amp; current != '\n'; ++index) line[index] = current; Append `line[index] = '\0';` after the `for` loop! 
I think OP knows about null terminated strings as he's checking for it when assigning to `output`.
Should I change my rand algorithm? 
is this good? It looks easy to read on my screen =/
Still not right. Four spaces in front of every line of code, all of them. I am not sure what you are doing wrong.
Did a thesis on computing exp (well, for ugly operator arguments, not real numbers, but close enough), and excited that my randomly deep knowledge of the matter can be useful! Lookup Pade approximants (Taylor series are often garbage approximations, and Pade approximation can get much better accuracy with the same number of multiplies) and use a low order one, along with scaling and squaring. Basically, want exp(10)? 10 is a big number, and a low order approximation can compute exp(1), at best. Well, no problem! Divide ten by two until it's smaller than one, .6125 = (((10/2)/2)/2)/2 Now apply whatever function you're using to.approximate the exponential to that number, so get Y = exp(.6125) Then square that number however many times you divided by 2 earlier and you'll get an excellent approximation to exp(10)!
Here is my code so far (I think it is incorrect) #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define MAXSIZE 50 int i=0, zz=50; struct metal_info{ char metal[6]; char symbol[6]; double atomic_number[6], atomic_weight[6], density[6]; }; int one_metal(FILE *file_in) { struct metal_info mi; file_in=fopen("metal_info.prn","r"); //mi.metal[6]=malloc(sizeof(struct metal_info)); //mi.symbol[6]=malloc(sizeof(struct metal_info)); for(i;i&lt;6;i++) { //mi.metal[i]=malloc(sizeof(char)*MAXSIZE); fscanf(file_in,"%s", mi.metal[i]); //mi.symbol[i]=malloc(sizeof(char)*MAXSIZE); fscanf(file_in, "%s", mi.symbol[i]); fscanf(file_in, "%lf", &amp;mi.atomic_number[i]); fscanf(file_in,"%lf", &amp;mi.atomic_weight[i]); fscanf(file_in,"%lf", &amp;mi.density[i]); printf("The %s", mi.metal[i]); printf("The %lf", &amp;mi.density[i]); } fclose(file_in); } int main() { int one_metal(char metal,char symbol[],double atomic_number, double atomic_weight, double density); } void sum_wd(int size, struct metal_info structs[size], double * sum_wgt, double * sum_den) { } //void write_to_file(FILE * file_out, int size, struct metal_info structs[size]double sum_wgt, double sum_den) 
It indeed sounds like a good way to compute exponential values! I wanted to implement this but as stated before I only have 64KB of stack memory, and I fear an implementation of this algorithm would go into deep recursion once the argument grows in size. I'll look up Pade approximations, ny Taylor series yielded garbage results like exp(5)=128, thanks a lot! 
This algorithm isn't recursive. You can directly compute how many divisions you have to do ahead of time in like 2flops and just use a for loop. And yes, use Pade approximants. 100% do. You gain so much accuracy per flop by just doing one division...
Non-Mobile link: https://en.wikipedia.org/wiki/Pad%C3%A9_table#An_example_.E2.80.93_the_exponential_function *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^60320
One thing I find helpful is to break the program down into small steps and solve them one at a time. Also if you are have trouble understanding something like using structs or doing file IO, write a really small simple throw away program just to learn that one aspect of programming. Once you have all of the pieces, then put them together. I think you will find it much less frustrating if you are working on a small program and making progress then trying to write your program all in one go and getting lost in the details. You could start by writing simple code to define your struct, populate it with data then print it out. Once that is working, modify your code to create an array of structs. Next, put that code aside and create a program that uses fopen() to open a file, fwrite() to write data to, then fread() to read the data, and finally fclose() to close it. Then put the two together. I also find that it is better to write your code a little at a time and test it as you go. This way you know that the bug you are looking for is in the last 10-20 lines of code you wrote. All that being said. First you need a struct to store your data: struct metal { char name[25]; char symbol[4]; int atomic_number; double atomic_weight; double density; }; Start with that, and if you need more help let me know.
Variable-sized structures are longstanding C tradition supported by MSC/GCC/Clang extensions since forever ago and included as an official feature in C99. Theres nothing wrong with them as theyre done right. In this case its just fine because the x86 stack grows downwards from the (IIRC) 8KiB boundary above the start of the task_struct, and the end of the task_struct floats somewhere down near the bottom.
It's a function that takes an object as an argument. It's not a method that belongs to an object. 
I see. Thanks for the tip. 
One needs to run ansi.sys to have cmd respond to ANSI sequences 
The _t thing is reserved by POSIX IIRC, but absolutely nobody follows it so it's sort of pedantic. Single underscore is reserved for the specification and double underscore for the implementation.
This is not a question
&gt; native c library graphics.h `graphics.h` is not native. It's an interface to the DOS graphics API. You might also want to list the `libX11`, which is the basic way to get graphics on a UNIX-like system.
For the trig function, I implemented `cos(x)` with a degree 8 taylor polynomial, which has a reasonable (but still terrible) accuracy on [0, pi/2]. Here's my implementation (which abuses the periodicity of the function), I still haven't pushed it to my project: [Github link](https://github.com/Garuda1/unixlib/blob/master/source/math/my_cos.c) I first get the argument and mod it under `2*PI`. If the argument is greater than `PI/2`, I return `-cos(PI-x)`, and if the argument is inferior to zero, I return `cos(-x)`. That way, I have a constantly accurate value for any argument. For the sine function, I just return `cos(PI/2 - x)`. For the tangent one, I return `sin(x)/cos(x)`.
I'm limited to 32 bit values as the operating system currently doesn't compile for x86_64 targets, so I want a uniform set of variables, all limited to 32 bits. Also, is it guaranteed to at least have an emulated FPU?
Just noticed you also have a mistake in the swapping logic. What you want is: temp=arr[count]; arr[count]=arr[ncount]; arr[ncount]=temp; 
100% correct thanks so much, i added a count reset and changed the swapping logic
Will learning SDL give a more clear idea of what's happening at lower levels than GTK would? If you learn GTK, is SDL necessary?
IMO, [Nuklear](https://github.com/vurtun/nuklear) is very good if you want something simple and in C.
)
Yes. Depends on your goals, but if you're wanting to make games like OP, then SDL is a better choice than GTK if you have to choose one or the other.
Thanks. I'm more concerned about understanding what's going on than I am trying to accomplish something concrete. I would be in there messing around with memory myself if it were remotely feasible! 
Interesting. Thanks! I'm the kind of person that does things like trying to replace a roof by myself. Pain and Futility are my middle names. 
&gt; `int strlen(char *s)` &gt; &gt; `int strcpy(char *s1, char *s2)` &gt; &gt; `int sanitise(char *s1, char *s2)` Broken APIs. In general, you shouldn't pass an array to a function in C without also passing its length. &gt; ` char string1[50], string2[50];` What if we need to handle strings longer than 49 characters? &gt; /* first we check we have space available for both strings */ &gt; if(malloc(100) == 0) This is just complete nonsense. Even if we *did* `free` this, we'd still be allocating the same memory twice, which is an anti-pattern. &gt; string3 = (int *)malloc(50); &gt; string4 = (int *)malloc(50); Here, on the other hand, we call `malloc` twice without checking its return value. Even if you can get away with it, this is a bad practice. Also, the cast to `(int *)` is wrong, since `string3` and `string4` are `char *`s. &gt; printf("Please enter your name: "); &gt; gets(string3); &gt; printf("Please enter the format to print your name: "); &gt; gets(*string4); [Never use `gets`.](https://stackoverflow.com/questions/1694036/why-is-the-gets-function-so-dangerous-that-it-should-not-be-used) &gt; ` printf(string1, string3);` `printf` will treat `string1` as a format string, and (attempt to) substitute the value of `string3` (a `char *`) wherever it sees a conversion specifier (`%s`, `%d`, etc.). I'm not sure what this line is *intended* to do, but I'm guessing it's not that. &gt; `/* delay before returning so user can see output */` Better to just use `sleep`.
#include &lt;ourdatabaselayer.h&gt; should be #include "ourdatabaselayer.h" /* delay before returning so user can see output */ float dummy; for (float x=0; x&lt;20000000; x++) { /* just give it something trivial to do, so it doesn't get optimised away */ y=x; } y is not declared anywhere. dummy is not used, probably should be used in place of x. 
thank you.
In a bit of a rush, there are plenty more that I haven't mentioned. #include &lt;ourdatabaselayer.h&gt; Should be wrapped in `""` quotes, i.e. `#include "ourdatabaselayer.h"` int strlen(char *s) For `const` correctness, should be `int strlen( const char * s )` int x=0; Could be better named e.g. `int len = 0` while (*s != '\0') { x++; s++; } The post-increment of `s` could be moved up into the loop itself i.e. `while (*s++ != '\0')`. If being particularly pedantic one could also argue that it's safer to swap the literal to be on the left hand side a la `while ('\0' != *s++)` so as to avoid accidental assignment, though modern compilers will warn about this. Also you don't technically even need the comparison, this could just be `while ( *s++ )` return(x) While this works it's bad practice as it makes `return` look like a function call. Linus Torvalds had a marvellous rant about this in a mailing list post a while back. int sanitise(char *s1, char *s2) No string lengths are provided It's unclear which string is the source and which is the destination i.e. use better argument names For `const` correctness the source string should be qualified at least `const char * src` Arguably the destination string should be qualified at least `char * const dst` char string1[50], string2[50]; Will the strings always be 49 (+null) characters long? /* bit of code for sanity test */ strcpy(string1, "hello"); /* copy "hello" into s1 */ strcpy(string2, string1); /* copy s1 into s2 */ Comments use nomenclature `s1` and `s2` whereas actual variables are named `string1` and `string2` string3 = (int *)malloc(50); string4 = (int *)malloc(50); This allocates *another* 2x 50 `sizeof(char)`s so the original `if(malloc(100) == 100)` has leaked The return value of `malloc` is not being checked The pointers returned by malloc are being cast into `int *` but `string3` and `string4` are of type `char *` printf("Please enter your name: "); gets(string3); printf("Please enter the format to print your name: "); gets(*string4); `gets()` is unsafe If you know `string3` will be used to hold the name, and `string4` will be used to hold the format, those variables should be appropriately named Also `gets(*string4)` is passing the dereference of `string4` as the argument which looks like a typo printf(string1, string3); This is using `string1` as the format string but `string1` currently holds `hello` ? sqlinsert("name", string3); `string3` was never sanitised because the actual call was `sanitise(string1, string4)`, so the database could be corrupted for (float x=0; x&lt;20000000; x++) Comparing `float` to `int` Using `float` as loop increment float dummy Never used y=x `y` is undeclared /* just give it something trivial to do, so it doesn't get optimised away */ This won't prevent optimisation; you need to use `volatile`
Did you also test the assembly routine?
If you want native Windows and Linux applications, try [IUP](http://webserver2.tecgraf.puc-rio.br/iup/). Unlike GTK+, you don't need to install a runtime for it to work. It's just clicking an executable and the program runs. Also, it has a very simple interface where you pass strings into functions to change the attributes of GUI elements. But be warned, it lacks good Mac support and uses Windows XP dialogs. If you want to draw your own graphics instead of native dialogs, the best option is [allegro 5](https://www.allegro.cc). It is simpler to use than both SDL and OpenGL. Having tried all three to make a game, I found allegro to be the most straightforward and clean. It's a better fit for complex games that need animation and real-time input.
/r/osdev
All the good ones are already taken! So mine can be a bit of a stretch. Generally speaking, printf(string2); is not a good practice. You want to use puts(). if(malloc(100) == 0) { printf("ERROR: Out of memory\n"); return 1; } This is one that not many people know (or care.) printf() *might* call malloc(). So when malloc() fails, to call a function that might call malloc() is not really the best idea. write() is probably the safest to use in this context.
It doesn't come up often, it is mostly useful for interacting with a console or telnet client.
 printf("Download Progress: 1%"); printf("\b\b2%"); printf("\b\b3%"); and so on.
thats cool
ah
If you're providing this as an API to a programmer, they shouldn't have to worry about disabling interrupts before accessing it. Also, if you want to access it in multiple places, you would have to do disable, get, enable in every place. 
Yes, if you do something like int getValue() { int ret; disableIRQ(); ret = global_val; enableIRQ(); return ret; }
Ah, I see. The provided code snippet didn't include those irq manipulations though.
Global_var should be declared volatile in my opinion.
Why?
It look like when you're reading the file, and get to the entry before EOF, you're mallocing a new node, but it never gets a value, so it's no longer NULL, but garbage. Like this [...]-&gt;LastAnimal-&gt;garbagedata-&gt;NULL
You can also do the same thing with printf("\rDownload Progress: %d%%", percent);
Who knows what the interviewer is thinking but if global_var is something that has a low and a high half (say a 32-bit var in a machine with 16-bit registers), the interrupt in the middle might cause you to return something that is neither the old value nor the new value of global var. To simplify using two decimal digits, imagine this sequence of events: var = 19; high = top-half-of(var); /* 1 */ INTERRUPT var = 20; END OF INTERRUPT low = bottom-half-of(var); / 0 ! */ You'd end up returning 10, which is neither 19 nor 20.
You don't see from those snippets if gloval_var is also used outside of the irq. If this is the case, it forces the cpu to always read the variable from memory and not use some buffered value it might have in the cpu registers. This is important if the value changed in an irq and the buffered value might not be accurate anymore.
I didn't post it initially because it's 50 lines in a big ass program and the names are in portuguese, but give me 5 minutes please and I'll edit this comment. https://pastebin.com/CgDiEG7t nvm i think i ll just give up
&gt; I'm limited to 32 bit values as the operating system currently doesn't compile for x86_64 targets, so I want a uniform set of variables, all limited to 32 bits. Also, is it guaranteed to at least have an emulated FPU? The x87 FPU was introduced in the i486, so you can go back pretty far and expect some kind of floating point hardware support. x87 provides for single, double, and extended precision floating point arithmetic. The i486 certainly did not support the x86_64 instruction set; so I think hardware-wise you are fine. You can still provide a nice uniform interface to your users though: float pow(float f) { return (float)dpow(f); } static double dpow(double d) { // use double arithmetic here } Your users won't call `dpow()` directly, they'll use `pow()`; but all the arithmetic is done using double precision in `dpow()`, only at the very end the result down cast to a float. 
 I'd completely forgotten about `\b`. The few times I've cared, i used ANSI control codes. 
&gt; the 'sanitise' function - we shouldn't increment s1 in the else loop as nothing has been added to it Which means that you can get rid of the `else` part: the only remaining instruction is `s2++;` and it is common to the `if` branch and the `else` branch, so it can be taken out of the branches since it has to be executed in every cases.
&gt; printf(string1, string3); &gt; &gt; This is using string1 as the format string but string1 currently holds hello ? No, it does hold the format. The format string was read into `string4`, then copied into `string1` thanks to the `sanitize()` call.
Dont allocate anything before you actually know youll need it. Check that you *actually opened the file,* read line contents into freestanding variables and *check that you actually got valid data,* then allocate and fill the node, then link it in. Imagine your code as putting a little TSA checkpoint between things outside your programs control (e.g., command-line arguments, files) and things inside (e.g., the existing part of the linked list). You shouldnt need any extra passes (thats where linked lists excel!) or spare nodes (unless your design requires a sentinel node). Also, `main() {}` is the oldest-school possible way to set up a function definition, leftover from elderly folks who learned C before 1990 or so. You should eschew it in favor of `int main(void)` instead. Always specify the return value, and always specify the `(void)` for empty parameter lists. (`int()` is actually a totally different type than `int(void)` anywhere except a definition.)
No. The accessor does not atomically read, push onto stack and return. The use of volatile does not protect against context safety. Volatile will only cause the CPU to do an explicit read every use but does not mean don't operate using registers. So if global_var is volatile, the accessor function when called will read from memory into register X then BAM interrupt happens which reads the same value, increments and stores back in global_var. Context is restored to the accessor function on IRQ exit and it puts register X, which now contains the old value, onto the stack. You must put reads and subsequent operations of global_var in a critical section. Edit: cached values of global_var are also only possible when within the scope of a read and a subsequent operation occurs within the same scope. Functions are a scope so a single line like the accessor is not subject to volatile. The behavior will be the same with or without the keyword modifier i.e. It will always do a read. Using it in another function with volatile will always do reads but since they are not guaranteed atomic, still subject to context errors. 
Was the global marked `static`? Maybe in terms of linkage, the global is accessible only via these functions with external linkage?
strcpy() quits before it copies the terminating NUL ('\0'). No good, that. sanitize() suffers from the same issue. sanitize() should not increment *both* pointers if a slash is found -- just the source. There are still more, it is a target-rich example. 
It can! I modified the example provided by /u/rcoacci to pass the "this" variable as a parameter instead of a global "focus" variable. *Almost* as small as the C++ program. // Object-Oriented C #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #define CALL_MEMBER_FUNCTION(x,y,...) x.y(&amp;x,__VA_ARGS__) // Object Setup typedef struct obj obj; struct obj { void (*exec)(obj*,int); int var; }; // Object Functions static void objadd(obj* anObj, int in) { anObj -&gt; var += in; } static obj obj_init(void(*fun)(obj*,int)) { obj out; out.exec = fun; return out; } // Main Function int main() { obj x = obj_init(objadd); CALL_MEMBER_FUNCTION(x,exec,1); } **Now, the assembly is:** objadd(obj*, int): add DWORD PTR [rdi+8], esi ret main: xor eax, eax ret [Godbolt](https://godbolt.org/g/kQdiOf)
&gt; &gt; **Contact:** [How do you want to be contacted? Email, PM, career page, etc.] &gt; &gt; Just copy-paste and fill them. Feel free to include any additional information. Here is an example post from previous thread. This sounds a fun place to work at,sadly i dont think you guys can sponsor visa's :/ 
Are you sure you enter a number when it asks for the name? Since a number is expected by the program.
oh fuck.....
Thank you =)
https://en.wikipedia.org/wiki/Rubber_duck_debugging
How are you writing it? Hint: printf has options for signed or unsigned.
Sure, but see how complex your program is. My point is that people tend to think that C++ creates overheads, and that by sticking to C you get more optimized code, but simple C++ code is as optimizable as simple C code, whereas *complex* C++ code is *more optimizable* than *complex* C code, because the compiler knows more and understand more of your intent. There is an interesting talk by Stroustroup that shows that *because the C++ knows the types* is can generate faster (asm) code for quick sort than the generic non-typed C equivalent.
You probably want %d instead of %i. Enter 012 to see the difference.
Keep up the good work!
Yeah, I know. I'm saying I want the syntactic sugar, not that I want inheritance or other features-- just the ability to avoid redundance through that syntax.
Well, unfortunately in pure C you can't have that syntax. You could get something close with macros, but please don't go that way. If you care so much about that syntax, and are not constrained to C by company/teacher/whatever, just use C++. You'll thank me later. 
Nice job, and keep at it. C is love, C is life!
Books usually are the way to go. You might want to study the C++ STL's containers to get a better understanding of how they work. If you want to start by implementing data structures and potential use cases, start with linked lists and sorting algorithms.
There is no simple way. Get yourself a decent data structures book and read it carefully. I can recommend you [this book](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/).
I know I could just use C++, I was just curious if this syntax could be achieved cleanly.
Sometimes I wonder if it wouldn't be better to just add a Lisp-like macro system to C++. (Yeah, C++ Template Metaprogramming has already been proved to be turing complete in itself and probaly *is* the equivalent of a lisp macro system in C++, but it's just so hard to reason about) 
&gt; C is love, C is life! So true!! Even though most of my work is in Python these days, C was the first language I tackled and the one I go back to to play with whenever I can.
&gt; I always felt this subreddit is way ahead of my level and most of the discussions here, If you didn't spend time in a forum with content above your level of understanding you wouldn't learn much. Learning all of those things at once is challenging, though. Be careful to take breaks and not burn yourself out. Besides K&amp;R the book I would recommend is [*The C Book* (1991)](http://publications.gbdirect.co.uk/c_book/the_c_book.pdf) (freely downloadable from link). 
In my codes i use system("COLOR 0F"); But im a newbie so dont bank on it
What is the situation like in Seattle? I've become interested in this field because it allows you more control (No more generic Java web service) but I'm not seeing a ton of open positions. Any idea where I should look? I'm perfectly fine using C, C++, or even other languages fit for the job.
There's nothing wrong with it, but a better practice in general would be to use a pointer and calloc the memory needed. Kernel programming can be weird tho, who knows if that might break something?
Is there a way to do this in the standard library or posix?
If you're on ~~C99~~ C11 you can use [_Generic](http://en.cppreference.com/w/c/language/generic).
Oh shit that's perfect! Thank you for this!!!
It depends on your platform mostly. I primarily develop on Linux and within unix-like operating systems most people use [GCC](https://gcc.gnu.org/) but there's nothing wrong with [clang](https://clang.llvm.org/) either. OS X comes with clang by default, but you can install gcc. Windows I see a lot of people stick to [Visual Studio](https://www.visualstudio.com/), but there's nothing wrong with [mingw](http://www.mingw.org/). There are other options as well, obviously, and there's no reason to completely discount IDEs if you're already familiar with one. These are just the ones I hear the most about.
Hear, hear! I also do a lot of work in Python, and R. But if I need something very mathematically intensive, I will go back to C. There was a program I wrote in Python that took about 4 days to run (a genomics program that required a dizzying number of calculations). When I rewrote it in C, the runtime came down to ~5 minutes. My poor Python skills likely contributed to this, but I used the same logic in the C program.
&gt; If you didn't spend time in a forum with content above your level of understanding you wouldn't learn much I agree with this, and it also helps to answer questions within one's understanding. Teaching is a very good method of solidifying one's understanding of something.
gcc might be simlinked to really be clang
&gt; but you can install gcc But why would you?
You can download Clang as a plugin for VS.
I develop on a Mac, and use clang. gcc is good as well.
gcc is just symlinked to clang, unless it's like pre Snow Leopard I think.
There aren't only books for beginner level, you know?
Books aren't limited to "fake C programmers" as you strongly imply. The different application domains for C all have their tricky parts, and experienced developers often write books to pass on their specific sets of knowledge onto new generations of programmers. It all depends on what you're doing as a programmer. Embedded programming? Heavy computations? Server-client interactions? I, myself, won a K&amp;R in this sub last year. I got overwhelmed with exams and medical problems since then and only a week ago have I found the time to program again. And guess what I did? I opened the K&amp;R and as a refreshment decided to work a bit on the UNIX interface. Books aren't limited to beginner tutorials, they accompany a programmer throughout its whole career, until one day, it's time for that programmer to start writing. For book recommendations, sorry, we need more informations on what you're doing. 
You can barely write, let alone read. Also, clearly a troll based on your history.
Really not sure. Maybe try like this: static FILE *stdinout = FDEV_SETUP_STREAM(usb_serial_putchar, usb_serial_getchar, _FDEV_SETUP_RW);
I do not think OP is a troll. He seems to be looking for a language to learn, so he looks around in all directions.
yup got lost on formatting :/
(Generic selection was actually added in C11, not C99)
Are they not unformatted i/o functions though? The question is quite vague
On Linux at least they are the underlying system calls that all I/O functions end up calling at some point. That's what I'd class as basic, but you're right, the question is quite vague.
Keep in mind that looking at references is not "cheating". Ok, you won't search for the whole code ready, as this is kinda simple code, but I'd advise you to read the documentation of each and every command you use (or search for the command you can't remember). You have to get totally ninja on that, cause when you start learning more programming languages, things are going to be kinda messy in your head and you have to find a way to remember which language is which. Note to self: PHP string concatenation is done with DOT, not a PLUS (I had 4-5 experience with PHP and after 1-2 years into python &amp; C without touching PHP, I banged my head against the wall why `$str` was 5 when I did `$str = "hello" + "world";`) Happy hacking &amp; code on! :)
Make sure usb_serial_putchar and getchar have been declared before that line otherwise the compiler will guess the signature for those functions.
Thanks for mentioning it. I've created an Atom feed.
Perfect, thanks!
The C standard expresses every other IO function in terms of `getchar()` and `putchar()` but that's not how they are actually implemented. POSIX specifies [read](http://pubs.opengroup.org/onlinepubs/9699919799/functions/read.html) and [write](http://pubs.opengroup.org/onlinepubs/9699919799/functions/write.html) as the fundamental IO functions and that's how stdio is typically implemented.
Faster than `malloc`? How so?
When you allocate a memory region with `malloc`, some implementations decide to actually allocate a bit more memory than you asked for. If you use `realloc` and there is space available right here and now, `realloc` can avoid having to search for and allocate a new storage region and return the original region.
irq routines are usually declared in the files supplied by the manufacturer. I know that the snippet does not show any includes, but I'm certain that this is a case.
Because there's more than one compiler and you should ensure that your code works on the ones you most expect to compile it. Depending on the goals of your program it may also be worthwhile to see if one compiler produces a more efficient executable.
st2 is a pointer to st1 and id not the same size. You can assign the address of st1 to st2 by doing `st2 = &amp;st1`. 
Your sort function basically only goes over the list once, which won't always properly sort. Consider a, b, c such that a &lt; b &lt; c and the list starts as {c, b, a}; by only passing over it once the list will end up as {b, a, c}. Instead each iteration will need to compare more than just one pair of values. As for the crashing I suspect it has to do with the block starting at line 100 which accesses `links-&gt;next-&gt;next`. Since the loop at 97 only guarantees that `links` isn't `NULL` you're probably getting a segfault when `links-&gt;next` is `NULL`. Moreover, the block at 100 should be swapping `links` with `links-&gt;next` but it's actually swapping `links-&gt;next` with `links-&gt;next-&gt;next`.
Can confirm, the following compiles and executes as expected for me (Xubuntu, GCC): #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct st_name { int val; }; int main(void) { struct st_name st1, *st2; st2 = malloc(sizeof(struct st_name)); st2-&gt;val = 5; st1 = *st2; printf("%d\n", st1.val); return 0; }
It doesn't need a memory allocation because it points to another variable which has a fixed size. Thats the code, things may get clearer then if the code is not too messy. https://mega.nz/#!CJt3xZ4B!qnual0BunqpaCCQPX4Y_G1UWY4EoyYaFq61RLbssJRc file server/main.c l:85
gcc begs to differ: #include &lt;stdio.h&gt; int main(void) { struct test { char name[10]; int age; }; struct test s1, s2 = {"rick", 100}; s1 = s2; printf("s1: %s %d\n", s1.name, s1.age); printf("s2: %s %d\n", s2.name, s2.age); } This code compiles and runs as expected. The problem was that you were trying to assign a struct to a _pointer_ to a struct. 
Ohhh, I thought the argument was how much I wanted to increase! &gt;Don't be surprised if this significantly slows down your program, because there's a lot more bookkeeping going on now. Hmm, so it would be better if I just counted how much space I need and do only 1 realloc afterwards? About the cast, thanks I'll stop using it now, my teacher told me it should be used even though it's "useless".
*Note: I'll be assuming we're only talking about positive integers* First you need to change your way of thinking. Try to figure out the maximum number of divisors for any number N in [0, 2147483647]. Let's say that the maximum number of divisors that you will every find is equal to K. You don't need to allocate memory for 50000 items, only for K items. If K is greater than 50000, then your code is prone to potential buffer overflows. Something else you can try is allocating memory based on N. Based on its value, try to find a way to mathematically get the maximum number of divisors you could find. It's always less than or equal to N. While after reading this allocating memory for N items seems like a good solution, try to figure out what would happen with `N=2147483647`. You'd be allocating 2GB of memory to simply get the divisors. According to your post, this is what you're looking for, but I would never run such a code on my machine (3GB of memory, welp...). Something tells me you should find a compression system to save memory. As an example, instead of saying "1, 2, 4, 8, 16, 32, 64, 128, 256, ... are divisors of N", you could say "The first 10 powers of 2 are divisors of N". This might be tricky, but would fit better from an efficiency perspective. Another thing worth pointing out: `malloc` takes a hell of a lot of time to complete execution. Calling `realloc` repeatedly definitely ISN'T a good idea, especially when working with 2GB arrays. Zeroing that same array is also pretty intensive.
Compilers are completely transparent. There's no compiler suiting a begginer's needs better than another. The "default" compiler in 2017 is GCC. Everyone used it or one of its ports at least once. It's the default compiler for Code::Blocks, one of the most popular IDEs for C development. GCC is extremely handy thanks to the gigantic amount of features it offers, but again, you shouldn't care as a begginner. Another widely used compiler is Clang. It's supposed to be interchangeably used with GCC, but I've noticed some differences between the two leading me to stick with the latter. Overhaul, it's a great compiler, since you can't really tell the difference between it and GCC. If you're on Windows, Visual Studio is the official Microsoft IDE. It features its own compiler which while I never used it seems to be pretty decent, especially debugging-wise. (GCC and Clang not being IDEs, you have to learn how to use a standalone debugging tool like GDB). If you're targetting embedded platforms, which I assume is highly unlikely given your skill set, your device's manufacturer should provide a compiler for the target architecture. Note that those compilers are often a pain to use. There you go. I kinda went a bit ahead of your question, but I feel like getting to know some compilers is an important step.
A couple of thoughts: 1. You could start using malloc to create a block of memory the size of n (this assumes every value from 1 to n is a divisor of n). Then while going through your loop to find the divisors of n, keep a count of how many you find. After the loop completes use realloc to shrink the block of memory to the size required to store count divisors. 2. [This page](http://mathcentral.uregina.ca/qq/database/qq.02.06/joe1.html) shows a method to calculate the number of divisors of a number. You could use this method, then use the result of the calculation to malloc the required memory. Since the second method involves prime factorization, I would guess first method will be easier &amp; faster. 
Thanks! I did method 1, except I malloc'ed it as a random small value (maybe even 0 is okay to use?) and then expanded it.
&gt; Hmm, so it would be better if I just counted how much space I need and do only 1 realloc afterwards? That would be faster, but also harder to do if you don't have a known limit in advance. Every time you call `realloc` to increase your allocation, it will take some time. Some common solutions would be allocating in blocks, such as always adding space for 20 new numbers and then tracking how many of those you've filled. You could also try [doubling](http://stackoverflow.com/questions/2369467/why-are-hash-table-expansions-usually-done-by-doubling-the-size) the amount of space every time you increase the allocation. Note that these will be more complex to develop. An important part of developing software is deciding how to balance performance (run time), memory usage (allocations), and complexity (how long it takes to write and maintain).
`malloc(0)` does nothing. On POSIX systems, `malloc` is basically a fancy linked list abstracting `sbrk`, another standard POSIX function. `sbrk` in simple words changes the memory bounds of your program. So, calling `sbrk(0)` won't change your program's memory layout. Calling `sbrk(12)` for instance would however allow your programs to use 12 more bytes of memory.
Well, when I try to declare the array as just: "int *divisors;" in my main, and then malloc'ing to it inside the function, the program doesn't work, for some weird reason. So I guessed I couldn't do that, and my workaround was to declare the array in the main as: int *divisors = malloc(0); //not necessarily 0, just any small value And inside the function, use realloc. Then it works. Maybe I can't malloc inside the function if the array comes from the argument? idk.
Ah I changed it here, just added a * and that worked. :) Though I got this warning which I don't quite get but it's working so I don't care much hehe c:44:10: warning: assignment makes integer from pointer without a cast [-Wint-conversion] *div = malloc((c+1)*sizeof(int)); I didn't modify it to pass a pointer to divisor because I'd have to change a bunch of other stuff in the code, but there doesn't seem to be anything wrong. Perhaps I'll be unable to free that allocated memory.
Um, all the bit shifting in that does nothing. The function is equivalent to `return x;`
Yes, because you created a block of memory of the appropriate size. So this is OK. You can't however assign a struct to a struct pointer without first use malloc to create enough memory to store the struct in. 
What are you doing with this array after you finish? And a cuter way would be to find the prime factorization of the number, and then compute the combinations of the factors. In fact, the number of prime factors of a number is going to be less than log2(n) -- if every unique prime factor was treated as 2, there could be at most log2(n) of them. Since the prime factors are going to be on average greater than 2, this is a upper bound. The product of the first ten primes is more than 2^32, so you realistically only need 10 spots for the prime factors. Now you would need an array of 10 elements for the primes, and ten elements for the exponents. Then you can compute the combinations based on that, and directly compute the size of the array in one hit. 
https://www.amazon.com/Expert-Programming-Peter-van-Linden/dp/0131774298
I pass the array to another function which will look through it and determine which is the best number there.
Am I misunderstanding your comment? OP wants to copy using an assignment rather than a memcpy. This is an ok thing to but you seem to be saying it's not.
It'd help to answer your question if you make a small self-contained program with the same problem 
Casting a function pointer to avoid a warning just means you get silent undefined behaviour, instead of being notified about undefined behaviour ... It would be better to supply a function of the correct type. You can use a wrapper function to help with this, etc. 
&gt; but there's nothing wrong with mingw. It's more or less defunct. [mingw-w64](http://www.mingw-w64.com/) should be preferred now, which is under active development and fixed a lot of the bugs that had always plagued mingw.
even changing to this: http://pasteboard.co/9zr1oLLbb.png does not make it uncrash.
It definitely is, thank you so much
Either will work. My point is that in OP's original code, he was trying to assign a struct to a pointer but there was no memory allocated to the pointer. So you can do all of the following struct test { char name[25]; int age; }; struct test s1, s2 = {"Fred", 25}; struct test *s_ptr1, *s_ptr2; s1 = s2; // assign the vale of s2 to s1 memcpy(&amp;s1, &amp;s2, sizeof(s2)); // copy the value of s2 to s1 s_ptr1 = &amp;s2; // assign the address of s2 to s_ptr1 s_ptr2 = malloc(sizeof(s2)); *s_ptr2 = s1; // assign the value of s1 to the memory pointed to by s_ptr2 memcpy(s_ptr2, &amp;s1); // copy the value of s1 to the memory pointed to by s_ptr2 What you can't do is: struct test s1, *sptr; sptr = s1; // try to assign the value of s1 to the pointer sptr. sizeof(sptr) != sizeof(s1) 
A+B will overflow if B &gt; ( ResultType_max - A)
Dude, use fread and fwrite, fuck the other shit.
Use a compiler builtin. https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Builtins.html
Which program? I don't have my K&amp;R on me right now.
You might want to also have a jump if not flag. You might want to combine your `div` and `mod` instruction into one as on almost all architectures, `div` and `mod` are computed at the same time with a single instruction. To get C to run, you also need a `call` and `return` mechanism, an indirect `call` and instructions to do memory access. Why don't you just copy an existing instruction set to save yourself some time?
Let's say I'm computing `div`, the result will be stored in `a`, but where would the result of `mod` be? Some temporary buffer? The stack? I don't think I'll get any C to run on 256 bytes of memory, so it might never happen (it also requires a compiler) but yeah I'll see what I can do when it comes to `call` and `return`, it seems especially useful. For the flag part, I don't really get it. The system can just execute `neq` then `cjmp`.
You can either have your `divmod` instruction overwrite one of the source registers or take two destination registers. &gt; For the flag part, I don't really get it. The system can just execute neq then cjmp. How do you get the content of the flag into the a register?
in comment i explained i cant take another datatype long
Jump if not flag is very commonly used. See how many instructions you need to emulate it and then think about whether it's worth it.
Did you at least try to understand what I wrote? My solution requires no other variable than A and B. 
The preprocessor is your friend
Doesn't matter, you can't assign a struct pointer to a struct anymore than you can assign a struct to a struct pointer.
im not that experienced in OOP but if you want reusable algorithms you could write an ADT(Abstract data type) which contains generic functions (which would be your algorithms). IIRC ADT are the predecesors of OOP so you should check that out.
Take a look at Glib: https://developer.gnome.org/glib/2.52/ You can merely use the functions it exposes or take inspiration for your own library.
I tried writing a simple program in it (just to count the number of 1 bits in a register). The biggest problem I have with it is the combination of (1) only %a can ever be a destination register and %b a source register; and (2) the only mechanism available to shuffle values between registers is simple push and pop. Any time you're doing anything with 3 different variables (let alone 4 or 5...), half your code is Byzantine sequences of pushes and pops. It sort of feels like you're playing a game of Towers of Hanoi whenever you do anything. Considering you only have a maximum of 256 instructions in a program, most of which will be pushes and pops, that means you can't really do much of interest. At least in typical stack-based (registerless) instruction sets, you have instructions like dup, swap, etc., which simplify a lot of common use cases with shuffling variables around. In your case, even some register-to-register mov instructions would simplify code dramatically. The fact that you have no pointers (beyond the stack pointer, which is very limited in use, as it can't be accessed directly) is limiting, too. You have no arrays, then, which also means no strings. What programs have you written in this instruction set? What programs do you want to be able to write?
There are a few different styles to implement generic containers in C. Which to use is controversial. I will give a few examples and let you decide: * [tree.h in freebsd](https://github.com/freebsd/freebsd/blob/master/sys/sys/tree.h). It implements functions inside some long macros. Before calling these functions, you need to *instantiate* them with proper types. This style is closer to C++ template and incurs little overhead in the sense that it can achieve the same performance as a type-specific implementation. This is my preference. * [list.h in Linux kernel](https://github.com/torvalds/linux/blob/master/include/linux/list.h). It embeds a predefined struct to the struct holding the actual data. Here is [an example program](https://www.cs.uic.edu/~hnagaraj/articles/linked-list/). [uthash](https://github.com/troydhanson/uthash) follows a somewhat similar route, though it uses much more macros. * [avl.c from libavl](https://github.com/sam0x17/libavl_fork/blob/master/avl.c) and Glib. It uses `void*` pointers to represent generic data types. I don't like this approach personally because it often hurts performance. However, many others hold different opinions.
He deferenced the pointer first.
Basically, you are trying to allocate memory for a struct by declaring a char array. This could work, but it might not be portable across platforms or even compilers. If you are really determined to use a char array, you might be able to declare it `char msg_buf[sizeof(struct st)];`. I don't know if this works, since it is really not a common practice. Usually, if you want to allocate memory for a struct you use malloc (`struct st st2* = malloc(sizeof(struct st));`. You could also just declare a struct as follows: struct st st1, st2, *stptr; stptr = &amp;st2; Also, instead of adding up the sizes of the individual elements of the struct you should use `sizeof(struct st)`. It is possible that you are getting the wrong size because adding up the individual elements of the struct does not account for whatever extra bytes there are for bookkeeping, padding or alignment in memory. If you are trying to create a msg_buf to use with write to send your data over a socket, I think you would be better off using sprintf to create it. One last thing, typically you do not send variable through sockets due to portability issues. The common practice is to serialize the data either into a textual format (JSON, XML, YAML), or a binary format (protocol buffers, msgpack). Edit: Grammar 
You want to use `&amp;&amp;` and not `||`. With `||` the loop will continue so long as either is not `NULL`, which by definition `links` can't be while `links-&gt;next` is. You want to continue the loop so long as *both* are not `NULL`.
It will, but within that loop you're accessing `links-&gt;next` and as a result `links-&gt;next-&gt;next`. If the former is `NULL` the latter will trigger a segfault.
It won't work for signed values sorry
Oh, well, you're definitely right. It's true that 2/3rds of the program would be sequences of push/pops... I haven't written anything yet, as the instruction set is still a matter of debate, but given the current objectives the instructions should focus on signal processing and mathematical operations. Of course with time I'll add instructions to interface with the device's hardware, but as of now I'm mostly focused on the "cleanliness" of the programs one can write using this instruction set. So, would implementing instructions like `swp %x, %y` to swap the values of register X and Y be enough? Or should I dump the stack-machine system and go with `mov`? For the array system, I'm afraid 256 bytes of memory are nowhere near enough to hold large arrays, I might increase the memory size with time if it gets problematic. I'll look into adding pointer registers.
CLR is a great book, but like all text books, it's not cheap. If you're looking for used books, and find that you can get [Sedgewick](https://www.amazon.com/Algorithms-4th-Robert-Sedgewick/dp/032157351X/) for a better price, then that's an equally good book to learn from.
**I just provided you with the solution**. If you can't understand such a simple arithmetic operation, I'm sorry, but give up on programming.
Macro is evil. It looks ugly, feels weird and is notoriously hard to debug. However, if you want to implement generic containers matching the performance of type-specific implementation, being evil is often the only solution unfortunately. Many argue performance doesn't matter most of time. It is true, but what if performance is critical in the rare cases? I would rather invest more to develop something more universally applicable. At least for me, it pays off in the long run. &gt; if there are guides on how to use the preprocessor in a way that is not hazardous If you write macro code, clang could be of great help as it properly reports warnings and errors in long macros. To debug logical errors, I often use: gcc -E test.c | grep -v ^# | indent &gt; test-unroll.c &amp;&amp; gcc -g test-unroll.c This way you can step into unrolled macro and set break points etc. Note that writing macro code is hard, but using a macro library is much easier as long as you get used to the style.
In the embedded systems world you see some heavy use of the preprocessor for the sake of efficiency. On a 32-bit MCU with plenty of memory you might have a fairly heavy UART driver that can do things like calculate the proper register settings for a particular baud rate at runtime, for example, but on a smaller 8-bit MCU that's more likely to be implemented as a macro or series of macros. The end product might be a few load and store operations instead of hundreds of bytes of code. The downside is that like you say, it's easy to shoot yourself in the foot and it can really make things hard to follow.
Lately, I've been more inclined to use refactoring. Write a good implementation with a junk name void GENERIC_init (GENERIC_name *str_ptr); Etc... then when I want to use it for a particular type, I just replace the names. cpp and void\* are annoying to deal with. So the resizing arrays, trees etc all just compile and have correct typing when I refactor.
Oh really?? This Thing kid also knew..i need signed solutions.. If don't no shut mouth and shut down ur system 
Your computer is already a register machine. Don't implement `swp`, it's rather useless. Instead, implement `mov`.
For that I would use a for loop to cycle through until the first space, take that data into its own char array, and then use the rest of the string to the null byte. Unless youre dealing with a variable amount of spaces in between and then you'll need another loop to handle that. 
Hey thanks for your reply! By "use a for loop to cycle through until the first space", do you mean use a for loop to read character by character until i hit a space?
I actually just did a little bit of reading and found that there's a [stdlib function] (https://www.gnu.org/software/libc/manual/html_node/Finding-Tokens-in-a-String.html#Finding-Tokens-in-a-String) that would handle this. So you can use this once to get the first part and the pointer should be moved to the beginning of the rest of the string. (sorry I don't do a ton of C, just browsing new). Take a look at the strsep function in that document
The function to move is already predetermined by the library.h My issue is having this function: bool move(char field[20][20], char faction, int fromRow, int columnFrom, int rowTo, int columnTo) What would you suggest me to begin with? I'm stuck, I don't really know where to start from. 
In ANSI C there's probably no easy way but in C99, you can use [compound literals](http://www.drdobbs.com/the-new-c-compound-literals/184401404) which are as ugly as the name implies :) I think the syntax would be something like: list_append(&amp;list, &amp;(int){3}); Note: not tested.
The `if` at line 22 will only evaluate as true when `key` matches the first element of `array`. This is because as you describe `matches` it doesn't compare an entire array, just a single element thereof with a key value. Consider instead passing `array + (i * elementsize)` with proper casts, similar to your result. I also want to point out that `void *` is not an array, but a pointer presumably pointing to an area of memory that has been allocated to be used as an array. The `void *` type allows you to store addresses without explicitly typing the data therein; thus permitting the generic style of function you're trying to implement. As a final note, what you're doing here is pointer arithmetic and as such it is not best practice to use `int` when performing said arithmetic because you can run into overflow problems. The standard type for this is generally `uintptr_t`or if you absolutely must `unsigned long long`. There's probably nothing wrong with it here, since I suspect this is homework for an introductory class, but it's a good thing to know and a good practice to get into. Hope that helps!
So long as the function pointers are 1) static or 2) passed in once at initialization, it's not that great of a burden. I think the good thing about C is building layers that encapsulate both state and function, with modules ( compilation units ) publishing fairly generic interfaces to be used. And I think that this is somewhat *harder* with OOP, especially when it comes to heavily configurable systems. What function pointers make difficult is static analysis. This is one of those "trading one kind of correctness for another kind" things that is complicated to think about. 
I think the preprocessor is a great way to do this, and a great many other things. But I like to have code that can nearly be cut and pasted into static tables from a spreadsheet. You do have to avoid uses of the preprocessor that you have to debug, although it's always possible to run the preprocessor by itself to do that. 
Typically, network applications do not send raw variables across the network. Sending data like this is basically trying to do a memcpy across the network. While this should work Ok on the same machine using software compiled by the same compiler, it is not how network communication is typically done. Typically, the data is serialized by changing it into a textual format or a binary format, then de-serialized at the other end. If you wish to send the date in a binary format, I would recommend either [Protocol Buffers](https://developers.google.com/protocol-buffers/) or [msgpack](http://msgpack.org/index.html). If you are just learning network programming, I would recommend using a textual format since it human readable and you can use telnet as client for testing. There are a number of ready to use textual formats such as [JSON](http://www.json.org/), [XML](https://www.w3.org/XML/) or [YAML](http://yaml.org/). I think doing things the way you are trying to do is going to result in hard to find bugs due to low level compiler details like padding and memory alignment. Every network program that I am aware of uses a network protocol to serialize data. For that matter, pretty much any program (except beginner programming assignments) that save data to disk serial the data into some kind of structured format. If you are looking for a simple way to transmit you structs over the network, just use sprintf to build a char buffer with the fields, then use scanf to read them on the other end. Be aware that, due to security concerns, you don't want to use scanf in a production program. 
How is `list_append` implemented? Does it allocate memory with `malloc` and then copy the content under the pointer? If not, you will have a memory violation when you use the list outside the scope of `a`. If yes, you are wasting memory on an extra pointer. This is a major problem with `void*` based approach.
The most common reason is that the compiler may not be able to optimize the code if it does not know the underlying type at the compile time. In addition, we typically use function pointers with `void*` (e.g. `qsort`). Function calls may become a bottleneck. You can in theory use macro with `void*`, but you are really combining the weakness of the two approaches. Furthermore, when you implement generic containers with `void*`, you often need to call `malloc` and `memcpy` to duplicate contents. This hurts memory locality and adds heap allocation overhead as well. You can avoid the duplication, but that is often cumbersome and anyway you need to waste 4 or 8 bytes on an extra pointer, which can be significant.
yes. The assignment operator (=) is an binary operator that that assigns the rvalue to the lvalue. More generally, it is an expression. The expression evaluates to the value of the lvalue after the assignment. nc = nl = nw = 0; //is equivalent to nc = (nl = (nw = 0)); // and since ( A = B ) is also an expression that evaluates to B this becomes nc = (nl = 0); nc = 0; 
thanks
Thanks for your help, I appreciate the effort, I'm still very new to this stuff. Indeed, I am using AVR and the teensy-usb-serial which has the signatures you mention! I tried out what you suggest, and get the following types of error: 'type name' declared as function returning a function cast specifies function type and the warning: function declaration isn't a prototype I've done with and without the prototypes of the put and get functions declare in my .c file before the stream setup, but it shouldn't be needed there anyway, since the header file for usb_serial is included in my .c file.
&gt; Does it allocate memory with malloc and then copy the content under the pointer? It calls malloc for every new node (perhaps I could implement a scaling memory pool) and assigns the parameter of list_alloc to void *data in the node. So, it doesn't copy the content. &gt; If not, you will have a memory violation when you use the list outside the scope of a True. I guess I would have to malloc everything before appending it in that case. Alternatively, how would you do the copying?
Correct, but please don't use lvalue and rvalue for this kind of assignments. It's misleading. More info here: http://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c
If you want to recreate an architecture, I recommend to look at the PDP-11. Its instruction set is very well designed.
Yes, it is best to use an array for this. I would use a global array (you can use an array passed to a function, but why complicate things in a straight line program like this). For example, the simplest implementation I could think of is of the form: int letter_weight[26] = {0}; void assign_weights(some_sort_of_attribute att) { if (att == this_specific_attribute) { ++letter_weight[some_letter]; ++letter_weight[some_letter2]; ++letter_weight[some_letter3]; } if (another option) { ...} } Does this help?
1. To increase the weight for a specific letter, use `letter_weight[some_letter] += x`, where `x` is either a hardcoded number (1, 2, 3, ...) or a variable passed to the function. Note the function type must change to to `assign_weights(..., int x);` if you do this. 2. To find the maximum value in the array, you don't have to be that fancy. Our array is only on the order of 100 elements long (including all ASCII printable values), so a linear search is trivial to implement. /* returns the index of the maximal element of an integer array. */ int max_in_array(int* array, int n) { int i; int max_i = 0; for (i = 0; i &lt; n; ++i) { if (array[i] &gt; array[max_i]) { max_i = i; } } return max_i; } From here, you can find the letter with the highest weight via `best_match = max_in_array(letter_weights, 26);`. A switch statement over your enum values will tell you which letter this index corresponds to. I will leave this as an exercise to you. That being said, if you run into trouble, show your code and I will happily push you in the right direction. No problem, I am happy to help people who have a genuine interest in learning. I hope your problem is solved soon :).
I changed it to return (((x) &lt;&lt; (16-b)) &gt;&gt; (16-b));
He abused me, so I abused him
You might like to check out 'C Interfaces and Implementations' by David Hanson. Long time since I read it (think it's about 20 years old now) but I remember enjoying it at the time .. and he certainly provides a lot of code and explanation of building reusable data structures in C.
That's not a valid excuse tbh. Try to be civil, regardless of other people.
What is your problem with implementing flood fill?
I work in embedded systems and do consulting so I have lots of smaller projects that need to get done quickly. My main strategy however is to just not write any new code if I don't have to. If I only need 16bit integers, I'm not going to rewrite my 32bit integer library. My application will take up a bit more memory and it slows down any communication but most of the time it's negligible. I have a few libraries that I consider "highly reusable" where I link to them and don't make any project specific modifications. They are very low level and most use function pointers. I try to make code that can use them whenever possible since I have a lot of confidence in them, and I can always rule them out when debugging. Any improvements I make in the implementation are easily forwarded onto all of my projects. Check out the book "C Interfaces and Implementations". It has a lot of good ideas and practices.
Hi OP, I've been looking at the other things you got going on here and I just wanted to pop in really quick. I'm a bit involved with stuff related to [RISC V](https://riscv.org/specifications/), and I think it's a design you'll want to take a look at if you're interested in computer architecture at all. It's a very well designed ISA, very modular, very clear, designed to be easy to expand into intentionally non-standardized domains. I like it quite a bit. While it definitely isn't as widely used as x86, it's fun to use and quick to pick up. Having worked with a good handful of ISAs, it definitely is the one I find nicest to work with. And it does seem to be an up and comer too.
If you only have two months experience, this may be a bit difficult. Do you have to implement a flood-fill algorithm for this assignment? There are much, much simpler ways of solving the problem and you may be over-thinking it.
then we are all screwed :p
Nothing bad with that!
Yeah, I debated that when writing it up. Including the diagonals will give slightly different results. I just decided to go with the simpler implementation.
Hi. Try replacing this line: static char s[]= "Cold "; For: static char s[]= 'Cold '; 
No. You can't initialize a char array with a single multibyte char literal like that.
It is open source, and at least partially geared for education, but simply because it's a risc doesn't make it minimalistic. It does have room for vector extensions, can computes to sixteen but modes, and expand to 64. It can get pretty involved, but they're keeping the isa clean so it doesn't go down the road of becoming a mess like 86.
I get another error: character must be one or two character long.
http://imgur.com/a/t7apJ
why main returns int?
I highly doubt that the assignment is to "find an arbitrary 9/8/etc shaped object" because that would be way beyond an intro to C class. So you probably just have to detect the specific shape on a grid right? You can iterate through your given bitmap, and compare each pixel to all the different known shapes. Whichever one that it matches with is the answer.
Main returns an int (0) which tells the OS (I think) whether it ran successfully. 
You think correctly
it's working now, thnx
i see, thank you
Does order matter or do you have typos in your example? All the characters from "@3\n" are present within "A@c3\n" but they aren't consecutive. Either way, you can compare `char` values directly from each string. This should only take one `if` statement within a couple loops. The main difference will come depending on whether order matters, but it doesn't make it much more complicated. Post back some code and some specific questions and we can help you more.
I can't use arrays :\
You're not. They are.
It's been about 20-25 years since I've used BGI, but I think maybe there was a draw mode setting? You want to make sure that you're setting pixels and not ORing or XORing them or something. I don't recall ever having any trouble clearing text with a draw command. Edit: Can't find my old code but I looked up the docs. If you're using floodfill then no, that won't fill in the text and it'll be slow. I think you need to set the fill mode to empty or solid. Also, I think clearviewport() will clear the current viewport.
I am using setfillstyle(SOLID_FILL, BLACK); floodfill(6, 205, WHITE); edit : will check empty fill and clearviewport()
empty_fill is not does gets me the same result as solid_fill black. clearviewport() will crash the program when it reaches the line its writeen in, I set setviewport as a rectangle around the word to be deleted
That will start to become a problem when comparing symbols such as `@`, because it can match a space or a backtick. Similarly your upper case characters could end up matching decimal digits or non-alphanumeric symbols. For case insensitivity you'll need to process each range of alphabetic symbols differently to ensure your program doesn't match things that shouldn't match.
What is your question?
The problem is, how is the string provided if OP cannot use arrays? Why can't arrays be used? They are a fundamental part of C!
You can use the function tolower() (ctype.h) which converts a letter to lower case to bypass that. Just make a lower case copy of each word and check them together.
So how does your fifo version differ from what you posted?
Since you're dealing with numbers and punctuation, you can't assume that 2 characters that are 32 apart are lower and upper case versions of a letter. 'A' + 32 = 'a' 'A' - 32 = `!` 
There are only 10 possible ways (5C3) of pairing up letters, so you could do this: if ( (eq(a1, b1) &amp;&amp; eq(a2, b2) &amp;&amp; eq(a3, b3)) || (eq(a1, b1) &amp;&amp; eq(a2, b2) &amp;&amp; eq(a4, b3)) || (eq(a1, b1) &amp;&amp; eq(a2, b2) &amp;&amp; eq(a5, b3)) || (eq(a1, b1) &amp;&amp; eq(a3, b2) &amp;&amp; eq(a4, b3)) || (eq(a1, b1) &amp;&amp; eq(a3, b2) &amp;&amp; eq(a5, b3)) || (eq(a1, b1) &amp;&amp; eq(a4, b2) &amp;&amp; eq(a5, b3)) || (eq(a2, b1) &amp;&amp; eq(a3, b2) &amp;&amp; eq(a4, b3)) || (eq(a2, b1) &amp;&amp; eq(a3, b2) &amp;&amp; eq(a5, b3)) || (eq(a2, b1) &amp;&amp; eq(a4, b2) &amp;&amp; eq(a5, b3)) || (eq(a3, b1) &amp;&amp; eq(a4, b2) &amp;&amp; eq(a5, b3)) ) where `eq` is a function to do case-insensitive comparison of a single character. (Use toupper/tolower, not `-32` and rubbish) 
Yes. Until we didn't learn some sort of material, we can't use it to do our assignments.
You are correct, I should use a&lt;='z' &amp;&amp; a&gt;='a' etc'. thanks!
You are right, I will change it, thanks!
While I can understand that, the choice of task is very strange since, you know, strings are arrays.
First of all, the C language doesn't have *commands.* There are *functions* like `gettimeofday()` and *types* like `struct tm`. Please use the correct terms, otherwise people might get confused. Only `struct` is highlighted out of `struct tm` because `struct` is a keyword (as is `int` and `char` and the other basic types) and `tm` is just an ordinary structure defined in some header. On POSIX systems, you can use the `strptime` function to parse a date and time from the user. Otherwise I recommend you to use `scanf` (or `sscanf`) for this purpose: Scan all the bits and pieces of a date and then put them into a `struct tm`. Finally, you can use `mktime` to turn this `struct tm` into a `time_t` you can pass to `alarm` or such to set an alarm.
Hi! Sorry about my incorrect terminology! I'm still new to the language so I flub often. Thank you for your help!
It's my pleasure. Don't feel discouraged by my remarks, everybody gets things wrong in the beginning.
Format your code. It's illegible like that.
Except if you want to program for systems that old.
So you only mean to allocate one usuario to modUsuario? Also, I don't see you ever freeing that memory, which is a bug but not one that would crash your program. Have you run this in a debugger to figure out what line it's crashing on?
*The C Programming Language* (aka "The Old Testament", "K&amp;R") is still one of the better books on C. The later edition that was updated to describe ANSI C (aka "The New Testament", "K&amp;R2") should of course probably be preferred now. Another good book that you might want to consider is *The Practice of Programming* by Kernighan and Pike. It's not about C specifically, but most of the examples are in C, and it's a fantastic book. 
That it's not always possible to use LuaJIT :-)
When the processor you are using does not support it (I work on embedded systems)
Why is vUsuario a double pointer? Isn't it supposed to be an array (single pointer)? I may be misunderstanding the way you are storing the data though.
Thank you I do will :)
Yes!! This solved it! Thank you a lot. I will definetly check out the operator priority so this don't happen to me again. I thought my head was gonna explode. Again, thank you a lot! 
It was failing in the if statement; because brackets operator priority. In addition, thank you a lot about the freein memory part. You are totally right. I will fix that aswell. Thanks and happy coding! :)
Upvote for old testament / new testament. Haven't heard that in awhile.
Is there apocrypha? In other words, what's after k&amp;r? Preferably more best practices type stuff?
I'm depressingly old.
A global int will always be 0 according to the standard, but a local int is allocated on the stack, and the stack may or may not have some garbage left over from previous function calls. Also, in a philosophical sense, C is designed to let you make your code as efficient as possible, and automatically setting a local variable to zero goes against that idea. 
It is correct in the second edition of K&amp;R. On page 39, the corrected function is int strlen(char s[]) { int i; i = 0; while (s[i] != '\0') ++i; return i; }
*The C Programming Language* is probably the best C book ever, but you should learn C first to fully appreciate it. (I'm not joking.) 
int array[2][2] is the same as int array[4] There is no spoon.
What explicitly are you having trouble with?
I need to figure out how to create a function that can read words from a file "words.dat" into an array of strings with 200 words per arraywhich holds up to 30 chars. the function should read until end of file and return the number of strings read. I need to know should I use 2D arrays or is 2D arrays a bad idea?
I completely agree with the above statements. *Programming in C* by Stephen G. Kochan is a great book for getting started with C. Then once you are more confident, make the move to K&amp;R2-ANSI C as is above suggested.
Your instructor has clearly spelled out what steps you need to take and has even given you examples to look up. What more do you want? 
The type of `array1[0]` is `int[2]` it just gets converted to `int*` easily.
I like _The Standard C Library_ by P. J. Plauger. It covers the standard C89 library, quoting from the standard, going into the history of each function (any *why* each function is defined the way it is) and gives a sample implementation (including trade offs in approaches). 
Besides processor support, there's the fact that it does not support 64-bit integers (unlike Lua 5.3). 
Lua (the PUC version, *not* LuaJIT) is written in ANSI C (C89) which means you can compile it on any system that support ANSI C. Second, it's small (and you can even make it smaller by dropping portions of it) and *very* easy to embed. 
You declare `arraywords` but don't use it. Instead you call the functions using `charholder`. Try changing the function calls in main to: array(arraywords); printf("The string is %s\n", arraywords); stringLine(arraywords); Also, please consider using more descriptive names for your functions and variables. For example, `array` and `stringLine` are very vague.
2D arrays is pretty much the only way.
*The Practice of Programming* is lovely.
Didn't you post and delete this at least once already? 
http://fabiensanglard.net/c/
in your first program you calculate and return the value, but in main() you just don't fetch that returned value. this would be needed to pass it to the Value()-function for print out. e.g.: int main(){ int calculatedValue = Calculation(); Value(calculatedValue); return 0; } 
char words[300][31];
Please be civil.
Arrays are (pretty much) pointers to the first element.
Besides what has been mentioned, these two are also good: * [C Interfaces and Implementations: Techniques for Creating Reusable Software ](https://www.amazon.com/Interfaces-Implementations-Techniques-Creating-Reusable/dp/0201498413): teaches good design practices in C. * [Writing solid code](https://www.amazon.com/Writing-Solid-Code-Microsoft-Programming/dp/1556155514): focuses on debugging, also filled with interesting anecdotes.
Also, one of the differences between C and C++ is an empty parameter list means different things. Since your functions don't take any parameters, you should do `void myfunc(void)` which explicitly means that they don't parameters. `void myfunc()` means that your functions take any number of parameters (including 0). So while the latter will work, the former is far more explicit. 
Halfway "C a modern approach" an I can confirm your roadmap.
Yo creo que no deverias usar scanf("%3s", id); Almenos no lo veo de ayuda.
Agreed! While we're at it...let us add *C A Software Engineering Approach - Third Edition* by Peter A. Darnell and Philip E. Margolis. You know, just for good measure!
You will need to emit the LLVM il yourself. Make a few functions that write to a string buffer with the LLVM IL in it. There is no way around learning the LLVM IL to my knowledge if that is what you were trying to avoid.
Of course! What was I thinking? lol Ok, but when I ran it just now after fixing it, I'm getting deadlock between the philosophers after a while. I thought my code would avoid deadlock since they can only ever pick up both chopsticks or put down both.
How would I prevent the deadlock without using a monitor? I'm only allowed to use mutexes and conditions.
That's awesome! It's a great book on C.
Thanks a lot for your help.
You can use mutexes to check the state. Lock Check state of chopstick. If chopstick is not picked up then acquire chop stick and set state to picked up. Release lock. Then do the same for other chop stick. If the other chopstick is not available then release your original one. Only use mutexes to check or update the state of the chop stick. You don't need the mutex to be locked the whole time you are holding the chop stick
Didn't know that, thanks for pointing it out. You are amazing, thanks again. Do you have any recommendations as to where I can improve on understanding functions and getting values out of them?
Good suggestions. Along the lines of what you suggested, one of my favorite intro to C projects is a dumbed down version of `dc`, the father of posix bc. It only takes a little more work than building a parse tree (which isn't even required for a stack based language.
I did that. and altered my code to look like this. #include &lt;stdio.h&gt; float cross_product(float ax, float ay, float az, float bx, float by, float bz, float cx, float cy, float cz); int main() { float ax, ay, az, bx, by, bz, cx, cy, cz; printf("Please enter vector a= &lt;ax, ay, az&gt;:\n"); scanf("%f%f%f",&amp;ax,&amp;ay,&amp;az); printf("Please enter vector b= &lt;bx, by, bz&gt;:\n"); scanf("%f%f%f",&amp;bx,&amp;by,&amp;bz); cx=cross_product(ax,ay,az,bx,by,bz,cx,cy,cz); cy=cross_product(ax,ay,az,bx,by,bz,cx,cy,cz); cz=cross_product(ax,ay,az,bx,by,bz,cx,cy,cz); printf("The dot product of vector a= &lt;%.2f, %.2f, %.2f&gt; and vector b= &lt;%.2f, %.2f, %.2f&gt; is &lt;%.2f, %.2f, %.2f&gt;.\n",ax,ay,az,bx,by,bz,cx,cy,cz); return 0; } float cross_product(float ax, float ay, float az, float bx, float by, float bz, float cx, float cy, float cz) { cx=(ay*bz)-(az*by); cy=-((ax*bz)-(az*bx)); cz=(ax*by)-(ay*bx); return cx,cy,cz; } I essentially have the same issue. Except instead of just outputting zeroes for the cross product. It just outputs the value of cz instead. I still don't know what's wrong. 
No problemo
I understand how you would go between both of the styles of function definition. I just don't know what is meant by old-style. I think old-style is actually to referring to something different other than the K&amp;R C style function definition that was mentioned earlier in the book. The K&amp;R C style function definitions result in some unexpected behaviors. For example, when a function defined using this style in a program compiled with a K&amp;R C compiler, calls to the function will promote the actual parameters before sending them to the function. So if the function find_int() was defined to take chars or short ints as parameters, then even if you call the function giving the proper parameter types, those values will be promoted to int by default. The conversions are called default argument promotions. ANSI compilers also take into account the K&amp;R C formal parameter declaration style when they see this and turn on this default argument promotion for compatibility reasons. However, if you use a mix between the two styles, then it can result in problems. Also, K&amp;R C is a little different when it comes to recognizing a function's signature. With ANSI, you need to either use a function prototype to specify the return type of the function and the number and type of the function's parameters, or you need to make sure that the function is defined in the code before that function is called. With K&amp;R C, the compiler does not remember the number or types of the arguments that the function takes. The only thing that is remembered is the return type of the function.
Is efficiency a requirement for your program? Your time is precious and you have a pretty powerful computer at your disposal. You can write a program that tries all the possibilities for each box. Brute force baby. For example in the 4x4 you solved the top left empty box only has two possible answers 0 or 1. 
The assignment didn't mention that the program needs to be efficient. So are you saying that I should brute force 1 row first, then brute force the next row. Then, keep repeating till it equals the sum of the row and the column?
What `int *func()` means in old C is a function declaration with an unspecified number of parameters. Putting `void` inside the parenthesis solves that problem and explicitly tells the compiler (and the user) that the function has no arguments.
The trick in both these cases is to ask what is happening at the file descriptor level. 
Readers' FAQ on Articles about PVS-Studio. [Have you reported the bugs to the project developers? Have you sent them a patch?](https://www.viva64.com/en/a/0085/#ID0EIBAC)
Oh so what's going on at that level? I'm aware of what file descriptors are but I've never really thought of them beyond the point of their definition and how they used by the linux system to deal with files, devices etc.
To read words from a file I would use fscanf http://www.cplusplus.com/reference/cstdio/fscanf/ . In C there are no methods as far as I know. You are using functions in C. 
Think of it in a different way -- what is being copied on fork? The memory, for sure. But beyond that... what? Would a file be duplicated? What would that mean? If a file isn't being duplicated, how does the reference to the file work?
Thanks! I've only done C since February so I'm noober than you! haha
Hi, thank you for your response. I'll try using the dynamic memory allocation method. You're probably right about the changing the structure, but unfortunately we've been urged to use this method to deal with collisions in class. I guess they want us to get our hands dirty with the memory, or something.
I'm not sure if I conveyed the wrong idea when I said that mixing the two styles can result in problems or if the book is wrong, but what I said was meant to be a paraphrase of the last paragraph in this section: http://imgur.com/aOzjTvn
GTK works like really nicely i agree. why do you prefer to use gtk2 to gtk3?
I have done a some of the tutorials in both Qt and GTK+, and I think that the reason Qt is easier due to the natural fit between GUI programming a object oriented programming. Haven't looked into to it much, but I have heard [Vala](https://wiki.gnome.org/Projects/Vala) does much to ease the pain of programming GTK+.
Well, GTK+3 is not *horrible*, yet not so good. While technically bringing new features (like hidpi), it is slower and greedier for resources. There are several flaws created due to changes in development cycle, involving very important one - often broken backward compability with themes, wgat was a real pain in early development and support. Now GTK+3 got status of *rock ^s^t^a^b^l^e* (by gtk developers) since work on GTK+4 started already. Interesting that you can much better live without GTK+3 software at all instead on GTK+3-only GUI system. My advice is to use GTK+2 and wait for GTK+4 reception since there is no really good reason to use GTK+3.
In addition to what /u/Newt_Hoenikker has said: You may also want to consider a circularly linked list which guarantees that `next` and `prev` are never `NULL`. However, you would have to make sure you don't write infinite loops that cycle through the list because you forget to check if you've reached the head/tail. There are other benefits to circularly linked lists like being able choose to go backwards or forwards when accessing elements, depending on which distance is shorter.
So is the function declaration similar to a variable declaration? Can you assign something to func()?
&gt; I'll be the first to admit I was too lazy to look up a better hash algorithm and just named one I knew. :P Fair enough. :-D &gt; Sorry for my ignorance re:buckets; what's the best way to ensure proper retrieval of an entry? Well, by definition, a hashtable stores key-value pairs. If you then define your "put" function so that if a key exists in the table then the old value is overwritten with the new value and the old value is returned to the caller, you can guarantee keys in the table are unique. This means, doing a lookup goes something like: hash the passed in key to get address into array of buckets, if the value at that address is NULL then a value doesn't exist for the key, otherwise iterate over the bucket and compare keys until a match is found or the bucket is exhausted. It sounds slow; but it isn't that bad. When I wrote my homebrew hashtable I snagged the hash algorithm from my compiler textbook and fudging with the array length (the array of buckets) I was able to keep buckets to a fairly small number of elements. I put 8192 elements in the table and each bucket only had about 8 elements because I chose an array length of 1009 and the hash did a good job of evenly distributing the collisions over the buckets. As your expected number of elements increases the array length should increase to a proportional prime number too.
&gt; As a final note, you may want to look into the use of a hash function such as SHA-1. Cryptographic message digests are completely overkill for a hash table. They are much slower than non-cryptographic hash functions and produce output that needs to be reduced further (with a significant risk of introducing bias if you're not extremely careful) before you can use it as an index into a hash table. Use something simple like Pearson, Murmur or FNV, unless the keys can be influenced by untrusted input, in which case you should consider a keyed hash function like SipHash.
It's better to use GTK3 because it will ease migration to GTK4, in addition to having modern features such as HiDPI and support from developers
Who knows, maybe migration to GTK4 won't be even needed.
To be fair... which software do you know of that uses GTK+3 (aside from GNOME calculator and the alike)? I don't mean the bidings like PyGTK3 (myPaint is an example). I mean written in C and using GTK+3? 
Oh yes please and thank you
I recently moved from simple Makefile to CMake. I am unable to understand the practical difference between CMake and autotools. Any opinion on this?
You can't. Redesign your program such that `fflush(stdin)` is not needed.
It's not what I meant. Maybe GTK+4 would be worse.
"You could definitely design an easy-to-use GUI framework that's much more natural to use in C" Is there an open-source example of such a framework?
That problem is solved by having `scanf` consume the '\n' : `scanf("%d\n",&amp;i)`. There's no need for `fflush(stdin)` if you use the IO functions properly.
I would wager yes on a small scale, but I personally haven't really looked into it since I don't really do much GUI programming. I doubt there are any worth committing a project to though, unfortunately. The big problem is that writing a full-fledged GUI framework is really a job for more then one or two people, so most other GUI frameworks out there besides the big ones are lacking many key pieces of functionality or components, and it's not usually clear the project will be sticking around for very long unfortunately. That said, a high level description of one possibility would be that it would likely be similar to GTK but with a more natural interface by not using GObject and going for a simpler approach.
You use *fgets()* or the new *gets_s()*
Are you using a 64 bit version of mingw? And the return value from ftell is long and not int, but it wouldn't matter if you use 32 bit version of mingw anyway.
No, but I have literally just downloaded one to try and see if that works. How would I do it when I do have the 64bit version installed?
How exactly would I declare the __stat64 struct? edit: using `long` instead of `int` does not work
`__stat64` is a non-standard structure.
Make sure you've included the headers. If it still doesn't work then download [mingw-w64](https://mingw-w64.org/doku.php), it's an improved version of mingw that has better support for Win API among other things. The following works for me perfectly: [pastebin link](https://pastebin.com/raw/BQCau7Gd). The code was copied from the Win API reference online with a minor modification: `#define __USE_MINGW_ANSI_STDIO 1` was added to allow the `%lld` specifier in printf (because Windows still doesn't fully support C99 ).
 ||=== Build file: "no target" in "no project" (compiler: unknown) ===| C:\Users\User\Desktop\test.c||In function 'main':| C:\Users\User\Desktop\test.c|26|error: storage size of 'buf' isn't known| ||=== Build failed: 1 error(s), 0 warning(s) (0 minute(s), 0 second(s)) ===| 
Ah, I was still using the 32 bit version... I'll try the 64 bit
No. Windows is IL32LLP64.
[This](http://www.gidnetwork.com/b-57.html) has a solution for it. &gt;Your best bet, and I know this is beyond beginners so it's something to look forward to, you need to read a character buffer and parse the input yourself. There's only so much intelligence a canned C/C++ function can have. Until you can do this, you won't easily be able to create bulletproof input. Sorry.
Use a 64-bit build of mingw-w64. Code blocks, for some reason comes with an old 32 bit buggy compiler called mingw 
Exact opposite of my experience then. I've written assembly code many times because the compiler output was so godawful slow. I'm sure it depends on the compiler and the processor though.
Finally tested it, Thank you! This worked perfectly :)
You should absolutely second guess the compiler. That's what optimising is. But you should also measure to make sure you really were successful.
*Any* optimisation you do is you being smarter than the compiler.
Compiler and processor, yes, but code quality is also a very important factor. Turn warnings up to 11 and fix everything, add `static`, `const` and `restrict` everywhere you can, avoid idioms that rely on aliasing or type punning, avoid clever coding techniques that obscure the meaning of the code unless you know for a fact that the compiler recognizes that idiom.
That depends on your definition of optimization you do. If you mean a change that demonstrably made your code faster then yes, by definition. If you mean a change intended to make your code faster then no, many obvious optimizations serve only to obscure the meaning of your code, making it harder for both human readers and the compiler to understand what it does. Learn the three rules of optimization and take them to heart.
Good software design and choice of algorithm is not second-guessing the compiler. The compiler doesn't determine those things at all.
&gt; should never, ever, ever try to second-guess the compiler Absolutisms are usually wrong. You should always, *always* fully verify that any assembly you write is indeed enough improvement to justify carrying the complexity and nonportability in code. And you should have a fallback C implementation, and your test routines should compare them for both results and performance. 
The compiler does to a certain extent but the processor itself also does many things to avoid stalls. An out of order processor will reorder instructions as data dependencies allow to achieve higher ipc. Another technique used to help with longer stalls like memory fetches is simultaneous miltithreading or what Intel calls hyperthreading. The general term for what you are asking about is instruction level parallelism and there are many many techniques for taking advantage of it
An older but classic example (probably not as true anymore): A swap can be written as: a^=b b^=a a^=b Which looks clever. It doesn't use a temp variable. One less memory access! Gotta be faster... Except, since most architectures have a SWAP instruction, code that looks like you are doing a traditional swap is easier to recognize during the sliding window. (Like I said, this is an ancient technique, and decades of optimization techniques have squeezed this out as well, but it can still serve as an example)
Please make sure to compile your code with a C compiler, it seems that you try to compile your code with a C++ compiler. If you tell me how you compile and run your code, I can perhaps tell what the problem is.
Thank you for trying to fix the representation, but please don't post code as images. I cannot debug images. If you don't want to add blanks you can instead upload your code to a paste service of choice.
You also need to change the line #include &lt;cstring&gt; to #include &lt;string.h&gt; as the former is a C++ only header.
This is *almost* C code, but you are using a C++ compiler. While C and C++ share a common subset and look very similar, there are important semantic differences even in the shared subset, one of them being that C++ is very strict about casting pointers. You need to replace `&lt;cstring&gt;` with `&lt;string.h&gt;`, fix whatever is going on with that `timestart()` thing, and switch to a C compiler. You should also stop using `scanf()` and read a style guide.
You have a typo in the line that scans the number of trials. It should read scanf("%d", &amp;Trials); If I fix that, your code seems to work.
By the way, do you realize that the way you've designed your program, the correct answer can always be found in ten or fewer guesses?
Its indeed interesting I closed the Dev and re opened it later to find it surprisingly work this time. Then I did some outputs modifications about the messages shown when you fail an attempt, and saved, but they won't show the updated version when I run it again
gtk-- and gtkmm are the same thing. gtk-- is the old name.
Yea I realized when I posted it "Huh, mm stands for minus minus". Anyway always good to use the current project names =).
TL;DR: * Make sure both compilers use the same ABI. * Use C linkage (`extern "C"`) where the two languages interact. * Avoid mixing C++ and C streams on the same file descriptor, even though it's technically permitted. * Don't use exceptions or `long_jmp` across language boundaries. 
I feel like it takes years of experience to fully grasp when your code is or is not violating these rules. I've only dabbled, using C libraries like libcurl and libxml2 in C++ programs and in those cases it appeared pretty straight forward where boundaries were being crossed, but I always wondered whether I was missing something subtle. All I could rely on was that my tests passed, and hope I was covering everything important.
Note that you need to escape `&lt;` and `&gt;` when using them as arguments as otherwise the shell will interpret them as redirections, `./a.out 1 &gt; 2` meaning execute `./a.out 1` and redirect the output to a file named `2`.
yes, thank you, i did that when testing, forgot to put them on the example. the problem, (i'm gessing) is that the cut isn't getting the stdin for it to execute
They pretty much accomplish the same purpose, and it could probably be said that CMake is better than autotools.
That depends entirely on what `ptr` is (how it was declared, its lifetime, scope, visibility, etc.) We need much more information. And an invalid read is not the same as a leak. 
but cut can't use the buffer as a stdin method, or can it?
if ptr is a pointer- then no this line itself is not an invalid read. Null is a valid value for a pointer to have. Dereferencing it however is an invalid read because you are trying to go to address 0.
i've tried that first, using the read in the father, and then thru a pipe pass to do the cut, but the cut never executed. Maybe i've put something wrong. but i could try again if there are no other sugestions.
Depending on what `ptr` is (it could be a macro), yes.
An array is *not* a pointer.
Do you understand how pointer decay works? Do you understand what the declaration `char* history[3][4]` is declaring? What kind of declaration would decay to `char **`? (It's not `char *foo[3][4]`. That decays to `char * (*)[4]`, per the error.) 
Well I though I started to understand the basics of pointer, and then I got to this problem and I am lost.
Indeed! However, it is not a pointer. Very important difference!
It is a field in a struct that points to a string (`char*`) I know it's not a leak, but I needed a title
What are some alternatives to scanf
Start with the following: char foo[3]; What type of object is being declared here? An array of three char. What does such an array decay to? A pointer to the first char (i.e. `char *`) of the array of three char. In other words, an array of T decays to a pointer to T, for any type T. Now consider: char *bar[3]; This is declaring an array of three pointers to char. What does that decay to? The rules are the same as before, an array of T decays to a pointer to T. This is still an array of T, but T is `char *` because it's an array of three pointers to char. The decayed type is `T *`, so substitute T and you get `char **`, a pointer to the first T of the array, i.e. a pointer to the first of three pointers to char. I can't tell you what this function is expecting because you can't know that from just looking at its declaration (we'd need to have its complete documentation.) But it's probably expecting such an array that has decayed to a pointer. The array in your example is not correct, because it's an array of arrays of pointers to char, which decays to something completely different (but still following the exact same rules as before.) 
Ok, you are correct about that, a pointer is just pointing to an address in memory, while the array is a block in the memory. However they are both accessed by just a pointer (which is in the case of the array the address of the first element).
History is an array of an array of char pointers. So assigning a single element here means they assign to the single element the address of the string "1234". That's why it is possible. And that also should give you the hint how to call that function correctly.
For programs that are meant to be used interactively, it often makes more sense to read input a line at a time (using `fgets()`, or possibly `getline()` if you can use POSIX) and then parse its contents using `strtol()`. This allows you to diagnose error conditions, such as stray trailing junk after the number, as well as ensuring that you don't get out of sync with what the user types. (For example, if the user types "10 20" and presses return, then the first integer will be consumed by the first `scanf()` and the second integer will be immediately consumed by the second `scanf()` without waiting for user input, which catches many people off guard.) I don't quite agree that `scanf()` is always bad, but using it without checking its return value is always wrong in my opinion, because you have no way of telling if the conversion was successful and dealing with the case of invalid input. And mixing input methods that consume whitespace-delimited tokens with input methods that consume lines also leads to confusion, so if part of your program wants to take lines then you should probably avoid `scanf()` for that reason. Also `scanf()` is very easy to use in an unsafe manner, e.g. using `%s` without a maximum field width specifier is a buffer overflow vulnerability and is rarely handled properly by beginners. 