I think it's because your make rules do not actually generate the object files you promise to generate. If you look at them, you see that they make object files in `$(TEMP_DIR)` but `make` expects the target to be made. The whole `vpath` thing is for dependencies, not targets, so the path name of the target must be correct if I recall correctly.
Based on your original post it looks like you only need to do this for odd numbers, so you probably don't need `n`. You can determine the i^th odd number without the use of that second argument. Moreover you can simplify your recursion further. For instance for any `a` given this function will run one more time than is necessary. Consider: a = 1: return 1 * 1 a = 2: return 1 * 3 * 1 a = 3: return 1 * 3 * 5 * 1 etc... That doesn't make it wrong, but having unnecessary steps is generally frowned upon.
I am afraid the malloc isn't working. I have been trying to figure out cuda-gdb and I can't make much sense of it , just yet. However, I tried the manual way of doing things and it seems the malloc calls don't work. &amp;#x200B; &gt;// Allocate the host input vector A &gt; &gt;float \*h\_A = (float \*)malloc(size); &gt; &gt; &gt; &gt;// Allocate the host input vector B &gt; &gt;float \*h\_B = (float \*)malloc(size); &gt; &gt; &gt; &gt;// Allocate the host output vector C &gt; &gt;float \*h\_C = (float \*)malloc(size); &amp;#x200B; It just hangs.
There's more to it than this, but it's a concise way to parallelize loops: #pragma omp parallel for for (int i = 0; i &lt; N; i++) { /* iterations will be executed in parallel */ } It's a higher abstraction level than spawning and managing threads yourself, which makes it a little more portable. The program will also still work correctly (if more slowly) when compiled without OpenMP. You still need to be very careful about synchronization, though. Variables local to the loop body are safe, but variables outside the loop may require synchronization. There's a "critical section" OpenMP pragma to help with this: long counter = 0; #pragma omp parallel for for (int i = 0; i &lt; N; i++) { #pragma omp critical counter++; } 
I think your friend is telling you that you are going to need to consider parallel processing at some point with your raytracer. OpenMP is an implementation of multithreading, a method of parallelizing whereby a master thread (a series of instructions executed consecutively) forks a specified number of slavethreads and the system divides a task among them. The threads then run concurrently, with the runtime environment allocating threads to different processors. I think you are going to want to learn mutithreading to optimize the render time since raytracing is inherently slower than rasterization. Check out https://www.andrew.cmu.edu/user/lingzhaj/finalreport.html
As someone who made the mistake of trying to learn recursion through programming, I advise against it, as chances are that, like me, you'll be just wasting time because it's too inefficient and though you may learn to understand it, you won't be able to apply it. What you're looking for are topics described in discrete math. With that said, here's what you're looking for. https://wandbox.org/permlink/0NVgOBhYfZdruYFL It's basically the canonical factorial recursive formula altered to work with odd numbers only and be 1-based. You should try working it out, but I think it'll probably be a bit too complicated to understand, especially with the arithmetic mixed in the recursive step, so I suggest you look for the factorial recursive formula instead, as it's simpler. Ideally you should pick up that discrete math book as it'll teach you much more and help you work your way up to getting this topic right.
To format code as code, click the button in the editor that is hidden beneath the … menu. That said, be wary of things the IDE puts into your files automatically. My recommendation is to turn this behaviour of; do not ever put things into your source files you do not understand. The source of your confusion is that macros are just text substitution. They are evaluated prior to compilation and changing a macro in one translation unit (i.e. invocation of the compiler on a source file) doesn't affect any other translation units. The compiler has no way to know that you modified `STRING` in a file you didn't include.
OpenMP is an API for shared memory multiprocessing. What does that mean? It allows you to design software that is concurrent (meaning two processes in your program could be worked at the same time) and for a modern machine with multiple cores it would also be parallel (meaning those processes could be running at the same instant). For more information search "concurrency vs parallelism" because my description is likely somewhat lacking. How is it different from pthreads? I'm not as familiar with OpenMP but it stands to reason it may not need threads (though it likely does on most modern operating systems and architectures), but more importantly it is cross platform; so while pthreads is stuck to posix compliant systems, OpenMP could be more easily ported to any system that supports it, like Windows, Linux, OS X, etc... Should you concern yourself with it? That depends. AFAIK raytracing is a performance intensive operation that would benefit from parallel execution. The problem is that designing concurrent/parallel software requires some level of forethought, and while this particular problem seems at face value to be relatively easy to do concurrently (literally just have each ray handled by a different process/thread), even trivial examples can pose non-trivial problems when translating a mature codebase from being single-threaded to multi-threaded. Okay that sounds like I should be using it, what's your hang up? Well, raytracing can be something you want to do for any number of reasons, on any number of setups. For a modern desktop it makes more sense to leverage GPUs (via OpenGL or Vulkan if you want to display your results, or OpenCL if you're using your tracer to analyze something without display) to perform numerous small calculations like tracing multiple rays in tandem. Clusters designed as render farms may not have GPUs available and my rely on having an array of several cores perform tasks in tandem. Your use case will determine whether or not OpenMP is a good fit. Hope that helps. If I've said anything unclear or misleading please comment below.
You've practically given me the code,but I've written it down and did all the steps. I understand it much much better now,thanks to you int rek(int a) { if (a&lt;=0) return 1; return ((2*a)-1) * rek(a-1); } &amp;#x200B;
My goal is to have a default value that is easily overridden in one line of code (as opposed to in every call of the function). If not with macros, what do you recommend? Also, a whole ago I looked up what `#pragma once` is. IIRC, it prevents the file from being included multiple times, but whatever it was I decided it was useful to keep.
Much better! Although it is worth noting that you are still calculating one more iteration than is necessary, because `a &lt;= 0` and `a = 1` should both be returning `1`. Instead, once it is passed `a = 1` your function calculates `a = 0` despite not needing to. Again, it's technically correct, but could be more efficient.
Ah, I understand (roughly speaking), will need to investigate this further, thank you for the explanation!
example.cpp can’t see macro definitions that are in a file compiled separately; preprocessor symbols *only* exist in the preprocessor, and the compiler might not even be able to see them. Usually project-wide config values like this are either set up informally in some `CPPFLAGS` variable like CPPFLAGS='-DSTRING="wrong\n"' g++ $CPPFLAGS -c example.cpp g++ $CPPFLAGS -c Source.cpp or else in some header like `config.h`: #ifndef myproject_config_h__INCLUDED__ #define myproject_config_h__INCLUDED__ 1 #pragma once #define STRING "wrong\n" #endif and then config.h should be installed with the headers, and generally everything should `#include &lt;myproject/config.h&gt;` to set up those values. (Alternatively, you can require that preprocessor flag `-include myproject/config.h` be passed at the command line, but that’s harder to deal with.) Usually the config.h approach is used in larger projects that have a separate configuration stage before build; e.g., with autoconf you might have a template config.h.in like #all the other stuff #define STRING @@STRING_VALUE@@ #endif and then you can autogenerate a config.h from that, with the right value filled in. Now if the configuration variable is *solely* for some source-level transform—e.g., enable extra `#pragma message` debugging, or enable/disable assertions, or enable/disable certain APIs—then as long as you define macros like `STRING` before `#include`ing whatever file needs them (however consistently you need to), things should work out okay. Examples of stuff that works this way include glibc `_GNU_SOURCE` to suggest enablement of GNU APIs, GNU `_LARGEFILE64_SOURCE` to enable 64-bit-sized file APIs, or POSIX `_POSIX_C_SOURCE` to suggest enablement of POSIX APIs. But that stuff only affects what’s exposed to the compiler on some pass through the headers, not what’s actually in the libraries.
Thank you for your explanation! Much appreciated.
I understand, thank you for the concise and simple explanation! I'm getting a feeling I'm in way over my head here 
If it's a learning experience then forget the parallelization. Just figure out how to do the per pixel manipulation for each pixel do compute viewing ray find first object hit by ray and its surface normal n set pixel color to value computed from hit point, light, and n 
I had to read through that several times, because there’s quite a bit in there that I’ve never seen before. ...but did you put `#pragma once` _inside_ an \#include guard?
That would be somewhat weird though because K&amp;R C looks pretty similar to modern C, with ands/ifs/buts.
I'll revisit it after I'm done, I'm currently working on normals as I'm writing this! 
A macro can do the trick but you have to make sure that the override is seen whereever you need it. Overriding a macro in one translation unit does not affect its value in others.
[Have a look.](https://minnie.tuhs.org/cgi-bin/utree.pl?file=V7/usr/src/cmd/sh) For comparison [here's the v.5 Thompson sh source](https://minnie.tuhs.org/cgi-bin/utree.pl?file=V5/usr/source/s2/sh.c) shown in the emulator above.
You haven't allocated memory for your `v` array.
copyright 1973 bell telephone laboratories inc. huh? &amp;#x200B; Also, didn't realize Bourne Shell existed in 1973. Thompson shell was developed I believe in 1975, which is sh. I never saw that copyright in any Bell Labs Source Code. I never saw any copyright in any of the original source code.
Yeah, Microsoft didn't get the concurrent pipes Unix had in early 1973 until Powershell. The latest version Microsoft has released the source for is [COMMAND.ASM](https://github.com/Microsoft/MS-DOS/blob/master/v2.0/source/COMMAND.ASM) from MS-DOS 2.0.
My mistake, the 1973 is the Thompson shell, the first with pipes. [Full source.](https://minnie.tuhs.org/cgi-bin/utree.pl?file=V5/usr/source/s2/sh.c)
That's pretty typical for programs written in the 70/80s -- implementations were system dependent before ANSI C.
Wow that’s horrifying
Your function MatrixTranspose needs to be declared/defined before main. I.E. copy and paste it above main
label statement's a statement with a label expression statement's a statement with expressions jump statement's a statement using one of the 4 jump statements selection statement's a statement using one of the 2 selection statements formatted statements... C don't have those
 unsigned int x = 0; for (int i = 0; i &lt; sizeof(int); i++) x = x &lt;&lt; CHAR_BIT | memory[sizeof(int)-i-1]; Would be not very efficient, but correct way to get 1 on posix (CHAR_BIT). There are technical restrictions, like aliasing and aliment. And say, you've written an integer to the memory, you shouldn't deal with the memory as containing an integer.
r/dailyprogrammer
its says implicit declaration of MatrixTranspose is invalid in C99
I think the major error there was on the " Matrix transpose " function level, you tried to fill the source matrix "a" with the destination matrix "b" U can rectify it by : b [ i ][ j ]=a [ j ][ i ] Or you can simply call the function by: (b,a) Hope it helps.
Hmm, your nombre initialization is quite wrong. You need to copy the name from a pointer with \`strcpy\` or \`strncpy\`, and not set one character at 100th position.
Wow. This was actually a delightfully informative glance into the history of the topic. What a breath of fresh air compared to the boatloads of "do my homework for me" posts I've been seeing on this sub lately. That said, looking at the Bourne source nearly gave me a hernia. 
Your `int a = {{1,2}, {3,4}}` doesn’t do what you think it does. That declares a single integer `a` and then redundantly fills it with more data than it needs. Compile with warnings turned on and read them. When I compile with clang it tells me: warning: too many braces around scalar initializer [-Wmany-braces-around-scalar-init] int a = {{1,2}, {3,4}}; ^~~~~ warning: excess elements in scalar initializer int a = {{1,2}, {3,4}};
Oh my god, that's awful. I can only imagine how much it must've sucked to work on that monstrosity if you weren't familiar with it.
That's nothing! That C code is really straight forward to read and reason about. It's well organized into files that contain sensibly coupled data and functions. It's a breeze.
I have discrete math classes at my collage next year. Not really excited to be frank,it will be my 4th math class,but will study for sure
Checkout recommendations on suckless. The two shells there are dash and mksh. I cloc'ed and they're about 12k and 24k lines of C code respectively. dash looks pretty refactored.
PowerShell still only runs concurrently and not necessarily in parallel.
Using threads not processes, and yielding by object, not characters.
I love really pragmatic writings like this people who certainly know their shit. I really disagree with not using capital letters or underscores to make variable names easier to read, but his examples still look easy to understand.
https://minnie.tuhs.org/cgi-bin/utree.pl Start with Unix version 4 (first version of Unix written in C back in 1973)
I searched for "original Unix source" and found this: https://github.com/qrush/unix/tree/master/src/c Look at `cc.c` for example. Function headers: main(argc, argv) char argv[][]; { extern callsys, printf, unlink, link, nodup; ... } Lot of "interesting" `goto` labels.

Exactly...
What was abusive about how it used the preprocessor? 
Right. So to fix this, we declare functions before they’re used. I think it’s a bit of a pain but get used to rough edges if for programing in c. 
&gt; Outside of, imo bad, interviews, you'll never be in a situation where you have to make your own implementation of these data structures without being able to at least look it up online. You will probably never have to implement one but you will have to know the trade offs of using them and that's best gained by implementing them yourself. How do you know if a binary tree is going to be quicker than iterating through an array for instance? It depends on the data size, and several other factors. I already work with far to many people that think hashmap lookups are essentially free operations because they look like array access in higher level languages.
I just ported some 90s cgi C code to work with fcgi. My main impressions: making new functions is generally avoided except to prevent code duplication. The preference was to only call leaf functions from main as well (with the exception of C library and system calls, because these are implemented as assembly per platform anyways), so all functions are thousand line functions. The most annoying part was that there was an immense amount of effort expended towards maintaining an 80 character line length limit across the entire source code, which meant that there was really no consistent style whatsoever as far as code formatting. Also, static arrays of heuristic sizes were used everywhere instead of memory allocations. And gotos were used liberally for exiting from these long functions when error codes are returned. There were some wonky macro wrappers around standard library functions too. And some global variables for signal handling. However, the code was very well commented. I found myself simply reading the comments line by line to figure out what I needed to know, which was surprisingly pleasant. Unfortunately, maintaining comments is a nightmare, so today the preference is to write code that reads like comments. My advice to myself next time I work with some old C code is to start by reformatting it using a code formatting tool and taking note of all the global and static file scope variables before reading any code.
Create a header file, let's say `settings.h`: ``` #ifndef SETTINGS_H #define SETTINGS_H #ifndef STRING #define STRING "This is default" #endif /* !STRING */ #endif /* !SETTINGS_H */ ``` Include it in every source file where STRING macro is used. Change default string either by setting `-D` option during compilation or by defining STRING macro in a file included **before** `settings.h` (or in it).
Legacy C code is actually beautiful, save for the gotos. Not many languages can say that. 
 #include &lt;stdio.h&gt; int main() { int i=0, j=0, q=0, v[j], v1=0; FILE *arq; if ((arq=fopen("entry.txt", "r")) == NULL) { printf("Acess denied.\n"); } else { while (!feof(arq)) { fscanf(arq, "%d", &amp;q); j++; v[j-1]=q; printf("%d \n", v[j-1]); } fclose(arq); } return 0; } you have v\[j\] which is v\[0\], so there's 1 single space for an integer
Haha that's hilarious -- so... stubborn!
This is a C programming subreddit. C++ and C are not the same thing. if(month == 'March') { You didn't post what it's doing, not doing or any error messages you're getting. That would be the most important piece of information here. However, your compiler should have given you warnings or errors from that. In C and C++, string are always "double quoted," single quotes are for single character constants. 
Your wait() is in funny place. You wait a process that waits to output into the next process in the pipeline, that's not yet there. If valgrind complains about exec argv, there must be a problem in getAuxCommand(). You don't need the big fd\[\]\[\], just one pipe is enough. Think: int ifd = STDIN\_FILENO, ofd, fd\[2\], next\_ifd;
nodePointer unambiguous nodepointer, no depointer, no depo inter and as for a few caps being distracting... nah its actually easer to read!
I am not sure if this is the correct sub to ask this question. A better subreddit would be r/learnprogramming (they have a good resource list for general programming questions). &amp;#x200B; I buy most of my books used from [thriftbooks.com](https://thriftbooks.com) or [amazon.com](https://amazon.com). They are pretty cheap. Note: I am not associated with either of those places. I am just recommending them out of personal experience. 
If you live in the US, just look on Ebay. You can get older programming books for like $5 each with free shipping. The Art of Computer Programming, though, will always be expensive and I don't think people are willing to give it to random people on the internet.
As a bit of a noob, what is so bad about abusing the preprocessor like this?
I like it too, but I wonder if I'd be able to maintain or modify it with all those unfamiliar macros.
Or just don’t put pointer in the name because your IDE can easily tell you that your variable is of type Node *. So why not just node or activeNode?
The struct contains a single member `transfer` which is a function pointer. (if you don't know what a function pointer is, *now* is the time to learn. As an exercise, I suggest working through some arbitrary usage of `qsort` to sort some arbitrary structs to get some exposure to function pointers) Anyways, the struct contains a function pointer points to a function that has a return value of `int` and it takes 4 arguments (`bus`, `msgs`, `msg_count`, `dev`) of types `i2c_bus*`, `i2c_msg*`, `uint32_t` and `test_device*` respectively. Can't help out any further without more code context. The great thing about struct definitions is that they're *exactly* what they say they are!
Here's your problem (adding line numbers for clarity) ``` 1 if (cursor-&gt;data &gt; n) 2 if (cursor-&gt;left) 3 cursor = cursor-&gt;left; 4 else 5 { 6 cursor-&gt;left = create_node(n); 7 complete = 1; 8 } ``` The if statement on line 1 doesn't have curly-brackets to enclose anything. This means that the if statement is only going to apply to the next statement (ie. lines 2 &amp; 3). If line 1 evaluates to 0, then control flow is going to skip directly to the `else` statement on line 4, which will continue to line 6 then line 7, which will then end the while loop. Furthermore, you're only doing your checks for the left node... Remember that you also need to see if it's appropriate to add to the *right* node. Think about how to fix your code above (ie. how to get your if statements working correctly) then duplicate the logic for your right node.
I'm doing a bunch of kernel hacking right now -- ie. writing modules, and working on a homegrown scheduler. I swear -- one of my recent commit messages was `refactored error handling OR how I learned to stop worrying and love the goto`
Thank you for the reply. I edited everything accordingly, and had no idea I was being derpy enough to forget about the right node, but even after looking into what you mentioned, it doesn't appear to be working correctly. struct binary_tree { int data; int count; struct binary_tree *left; struct binary_tree *right; }; struct binary_tree *create_node(int data) { struct binary_tree *new_node; new_node = (struct binary_tree*) malloc (sizeof(struct binary_tree)); new_node-&gt;count = 1; new_node-&gt;data = data; new_node-&gt;left = NULL; new_node-&gt;right = NULL; return (new_node); }; void *add_node(struct binary_tree *root, int n) { struct binary_tree *cursor; int complete; cursor = root; complete = 0; while(complete == 0) { if (cursor-&gt;data = n) { cursor-&gt;count++; complete = 1; } if (cursor-&gt;data &gt; n) { if (cursor-&gt;left) { cursor = cursor-&gt;left; } else { cursor-&gt;left = create_node(n); complete = 1; } } if (cursor-&gt;data &lt; n) if (cursor-&gt;right) { cursor = cursor-&gt;right; } else { cursor-&gt;right = create_node(n); complete = 1; } } } This is the new code, just in case I missed something again. When I printf("%d\n", root-&gt;data); It still contains what ever node was most recently added, which is not at all what should be held in the root node. int main(void) { struct binary_tree *root; root = create_node(5); root-&gt;left = add_node(root, 3); root-&gt;right = add_node(root, 7); printf("%d\n", root-&gt;data); return (0); }
&gt;test\_device \*dev code from [https://github.com/RTEMS/rtems/blob/master/testsuites/libtests/i2c01/init.c](https://github.com/RTEMS/rtems/blob/master/testsuites/libtests/i2c01/init.c)
the main block, where you check cursor-&gt;data is equal to n, has the error. First it should be "==" and then, where are you forming a node and adding it?? I don't see you adding it anywhere. Please check that block
`test_simple_read_write_transfer` is an example of the type of function that it takes. Sorry, aside from that, I'm not doing your detective work for you. The code is there for you to read and work through. Without more specific questions (and displaying some effort/attempt at understanding it yourself) you really shouldn't expect others to do hold your hand.
Thank you for that. I derped pretty bad with the =, rather than ==. I think I'm misunderstanding my own code now. Since *create_node returns a new, malloc'd node, and *add_node has the statement: cursor-&gt;right = create_node(n); I assumed this would make the right value hold the newly malloc'd node. Am I misunderstanding something badly here?
I fixed the problem by removing the cursor entirely, and simply using root itself, but I would appreciate if you could explain to me what I'm missing out on in understanding. The working code is this: void *add_node(struct binary_tree *root, int n) { int complete; complete = 0; while(complete == 0) { if (root-&gt;data == n) { root-&gt;count++; complete = 1; } if (root-&gt;data &gt; n) { if (root-&gt;left) root = root-&gt;left; else { root-&gt;left = create_node(n); complete = 1; } } if (root-&gt;data &lt; n) { if (root-&gt;right) root = root-&gt;right; else { root-&gt;right = create_node(n); complete = 1; } } } } The thing I'm confused about is this: Firstly, why did it not work with cursor, because I thought cursor pointed to the location of where I wanted to work, which would make cursor-&gt;right be the exact same thing as root-&gt;right. My other point of confusion is that this isn't destructive. I thought passing something as a pointer, and modifying it would have permanent effects, but making *root = root-&gt;right in that function didn't effect the main functions copy at all.
Simple example: imagine you have to support such code. You work in c, you expect c and then you see this. Even worse, in time you'll see mixed statements. And everything is going to be bananas
Yeh mksh. I use it on my arch.
I believe its just -l&lt;name&gt; so if it was glfw3.dll it would be gcc -o main.exe main.c -lglfw3 . Reference [http://www.mingw.org/wiki/specify\_the\_libraries\_for\_the\_linker\_to\_use](http://www.mingw.org/wiki/specify_the_libraries_for_the_linker_to_use) 
I'll take straight forward text replacements for language primitives over long files littered with gotos and no comments any day.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
That's only partly true.
There's nothing wrong with goto in C. It's a good flow control construct, and preferable to other error handling flow control constructs in many cases. You can't jump out of function scope in C using goto. 
In C, you can not use `==` to test for equality between two strings. Instead, you need to use `strcmp()`.
I haven't read this in awhile, but I remember him alluding to a class. I wonder what other material he made for this class.
What do you mean? I might be a dumbo, but don't btrees usually look a lot like linked lists, just with two children (and maybe a parent) pointers. No guarantee they're stored close to each other?
Thanks for the tip, but im still not getting any output :(
Rob isn't exactly the kind of person to use an IDE. The trick is that each function should be so short that you can see the declaration of each variable without much scrolling if at all. This way, it doesn't really matter how verbose the names of local variables are as you can see their declarations on the screen.
Thanks for all replies. I have done this with C++ as it was somewhat easier than with pure C and code looks way cleaner.
You are thinking of binary trees, a different thing.
What a madlad
You were crashing, but now are hanging? What changed? Why can't you use a debugger?
 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char *morse[3] = { "A-morse", "B-morse", "C-morse" }; char *real = "ABC"; char test_string[] = "BCA"; int i, c; for (i = 0; i != strlen(test_string); i++) { for (c = 0; c != strlen(real); c++) { if (test_string[i] == real[c]) { printf("%s\n", morse[c]); break; } } } return 0; } Here's an example how you could do it, sorry there are too much mistakes in your code &amp;#x200B;
[And there's more](https://minnie.tuhs.org/cgi-bin/utree.pl?file=V7/usr/src/cmd/sh/mac.h), that's crazy, he even defined EOF as 0 instead of -1.
OK, I've managed to fix it myself.
&gt; if( test[i]==('.'||'-')){ Daaaang ... that is one hell of a construct :) To explain what you are doing here: '.'||'-' means to C "interpret the two characters '.' and '-' as booleans and do an OR on them. Because the ASCII values of those are some non-zero value, they are interpreted as "true", and thus the entire thing becomes true. However, then you are comparing it against test[i], which is a char again. That "true" value now gets cast back to a "1" (the default integer value for true), which means your entire if statement **actually** says "if test[i] == 1". That is never true, since ASCII 1 is some control character.
Sorry about that and thanks for your help &lt;3, im trying to do the opposite tho(morse to text), any idea how to do so? 
As a side comment, there is usually not much didactic value to presenting a newbie with a complete rewrite of their erroneous code. It like he's trying to build a house and the door won't fit, and you say "here, I built you a new house, take that instead".
Goddamit, sorry, my bad. I changed that to strcmp :)
No worries dude, we all learned that stuff the hard way. C is notorious for this type of implicit casting between things. That's why it is so fast, and also so dangerous.
&gt;As a side comment, there is usually not much didactic value to presenting a newbie with a complete rewrite of their erroneous code. It like he's trying to build a house and the door won't fit, and you say "here, I built you a new house, take that instead". He can't use my code, because it does the exact opposite
Agree 100% for locals. This is C though, so I was thinking activeNode could be used by multiple functions (though hopefully it’s at least static!).
Try \`malloc\`ing more than 0 bytes... you'll want to make sure size is set to the number of bytes you allocate, then in sb\_add\_str, when \`position &gt; size\` realloc \`sb-&gt;buffer\` to a larger size, and update \`sb-&gt;size\` as well
Thanks, I deleted that lines accidentally while deleting my spanish comments while editing the post, the code is complete now but the problem is the same.
Yar har! Yo ho! It be a pirates life for me! 
Thanks, I deleted that lines accidentally while deleting my spanish comments while editing the post, the code is complete now but the problem is the same.
As Rob Pike says, the length of an identifier should correlate with the size of its scope. Use long identifiers for external variables, brief identifiers for internal variables and short identifiers for local variables. For functions, similar concerns apply.
 #include &lt;stdio.h&gt; #define MAX_LETTER 2 int main() { char *letter[MAX_LETTER] = {"a.....", "bxxxxx"}; for (int i = 0; i != MAX_LETTER; i++) { if (letter[i][0] == 'b') { printf("%s\n", (char *) &amp;letter[i][1]); break; } } return 0; } `letter[i][0]` is always the char and the string is behind it, if you compare the first letter to your input and it's right, you output `printf("%s", (char *) &amp;letter[i][1]);`
I would start by writing the simplest program that solves some part of your problem. I would recommend first writing a progam that just prints out your input - test on this case. Once this working, I would add the logic to find the morse code. After that, I would keep adding features, testing at each step, until ths program is complete.
When you realloc, it doesn't look like you're accounting for the memory needed for the null character. After the while loop, I think you access outside the allocated memory when you assign the '\0'.
Assuming `a` is a pointer and `y` is a pointer... "Set the value located at at the address `a` equal to the value located at the address `y`"
Thanks for taking the time to comment. I think you’re totally right, though I have been surprised (and inspired) by the generosity of people in the past. I mainly mentioned that book in particular because it’s notorious for sitting on bookshelves without being opened. To anyone with the book, I’d recommend opening it now and then. From what I can tell, it is _dense_, but it’s pedagogically written, and therefore isn’t as _hard_ as it’s often claimed to be, if that makes sense I’ve followed a very large list of books on eBay, and check my email daily for updates. I’ve got more time than money, so I’ve gotten in the habit of checking eBay like this daily for years. The downside is that it can take over a year to find what you’re looking for, if you ever find it at all. I’m obviously very happy to do that, though And unfortunately, the well revered books tend to not be cheap, at least to the extent that they are still relevant. The US edition of The C Programming Language (2nd edition), isn’t easy to find for less than $20, for example. It’s understandable why it still costs so much, though. The information is wonderful!
The macro is a function that takes in two parameters `b` and `c`. It takes the value held at the address `b`, adds it to `c` and casts the result as an integer
Actually, there is no way to flush the input buffer; `fflush(stdin)` is undefined behaviour and should not be used as its effects are unpredictable and generally indicative of a defective program. The reason why this is some times done is that if you use `scanf` to read a number, `scanf` scans until the end of the number, leaving the newline character you entered in the input buffer. This effectively desynchronises the input your program sees with the input the user types, causing unexpected behaviour. There are multiple ways to get rid of this character and on some platforms in some specific situations, `fflush(stdin)` has this effect. However, here are some better options: * if you want to have line-oriented interactions with the user, use `fgets()` or `getline()` to read a line of input and then parse numbers from it using `sscanf()`. This avoids the whole desynchronisation issue. * as a quick'n'dirty fix, you can read until the end of the line after scanning a number: int c; while (c = getchar(), c != '\n' &amp;&amp; c != EOF) ; alternatively, some people like to do something like `scanf("%*[^\n]%*c")` to get rid of the newline.
Damn, another great reputation ruined by #metoo... 
Call by value means that if you pass a parameter to a function, the argument the function receives is a copy of the parameter; changing its value does not change the value of the parameter at the caller. This stands in contrast to *call by reference* (used in Fortran) where the function receives a reference to the parameter as an argument and modifying the argument modifies the parameter through the reference. C exclusively has call by value. If you want a behaviour similar to call by reference, you have to pass a pointer.
Call by value means that when you pass a value into a function, you are duplicating that value in memory, and giving that value to the function to use. Any changes you make to that value will not persist outside of the function. Ie. if you have a snippet like so: void foo(int num) { num = 10; return; } int bar = 5; foo(bar); assert(bar == 5); // this assertion passes because bar doesn't get modified by foo() 
Thank you—that is an excellent subreddit suggestion, I will definitely try that! I’ve actually been using Biblio.com rather than ThriftBooks.com, as their prices tend to be slightly cheaper. I’ve indeed found several for less than $5, but others seem much less promising. I’ve been checking periodically, though, and I haven’t ordered much yet as I’m hoping they will email me a coupon through their mailing list. Amazon’s prices are mostly prohibitively expensive for me, unfortunately
Okay so variables are stored in memory (RAM) in a specific address, which looks something like 0xFFF34684. If you were to read the value at this address in memory, you will read the value of the stored variable. So let's say you have: int a = 5; The computer will save variable "a" in memory at a location say 0xFFF34684. If you look at that location, you will read the value 5 saved as an integer. Why is all this important? If you use call by value, you send a COPY of a to the function. So 5 is sent to the function and any modifications to the passed parameter will not affect variable "a" once the function returns. Conversely, call by reference will send the address in memory or, in this case, 0xFFF34684. If you modify the passed parameter in the function, it was physically changed in memory and will maintain its new value when the function returns. Hope this helps! 
Please be civil.
is there a way to choose which backend is used for the playback?
When you declare a pointer you use * before the name correct? Ex: int *a; Then this pointer stores a memory address so if you print a, you recieve some hex value. However, with pointers you can also derreference them. If you want to access what value is stored in the memory address the pointer is pointing to, you use * before the pointer again like this: print(a) //prints a memory address print(*a) //prints value stored in the address So the first line is taking 2 pointers a and c, dereferrencing them, saying to make the value of the address stored in a equal to the value of the address stored in c. The second one is a macro that takes 2 parameters, an int, and an int pointer. Then it returns the sum of the first int and the int stored in the memory location the pointer is pointing at.
Dunno about streams, but if you know how to read Martin Fowler did a great book on this called 'Refactoring: Improving the Design of Existing Code'. Readily available on amz.
 char* cc = ""; sprintf(cc, "%d", n) Don't do that. Use an array and snprintf.
 char* cc = ""; sprintf(cc, "%d", n); this seems problematic
aabke? Try char test\[\] = ".- .- .- -... -.- ."; and strtok().
I couldn't figure it out. But I have been able to resolve the issue myself.
I fixed the error. I put the answer here on [superuser.com](https://superuser.com/questions/1422426/encountered-bus-error-while-trying-to-run-code-in-cuda/1422434?noredirect=1#comment2147175_1422434)
There's an easier way: void insert(struct node **p, struct node *new) { while (*p) { if ((*p)-&gt;data &gt;= new-&gt;data) p = &amp;(*p)-&gt;left; else p = &amp;(*p)-&gt;right; } *p = new; } You'll start simply with root = NULL; insert(&amp;root, ...)
something else: what happens if I run the following? stringbuilder sb = stringbuilder_init(); printf("%s\n", get_str(sb)); (if you fix this, you will simultaneously fix the problem identified by u/markgamedev)
Why are you doing a small malloc? If you know you will need a buffer to work in then just malloc 64kB and work within that. Unless you are working on an embedded device with very very small memory then there is no valid reason to realloc() over and over and over and over and just waste time and resources getting a few more bytes. Most systems have a pagesize that is preferred and you should ( a hint ) always malloc a multiple of that pagesize. Make life easy for the memory management hardware and the kernel.
something else: what happens if I run the following? stringbuilder *sb = sb_init(); printf("%s\n", sb_get_str(sb)); (if you fix this, you will simultaneously fix the problem identified by u/markgamedev)
It really hasn't changed that much. No standard lib and no prototypes impacted style to a degree. All the distributions I used had some sort of lib that was pretty close to what we currently have. You might see copy( d, s, n) rather than memcpy( d, s, n ). Actually you also might see copy( d, s ) because no prototypes. The n would be whatever happened to be in memory at the time. It was common to have code that worked based on magic numbers that just happened to be left on the stack. Add a print and boom. Development style in general was all over the place. The idea of structured code was still considered new to many so you would see a lot of code with only one large function with gotos skipping about and lots of pointer manipulation rather than using structures. Not all though. To say they coded in an assembly language style was not really accurate as the assembly guys wrote structured code as well. Like today, there was good code and there was bad.
Suppose you took English, but came up with trivial word replacements from Spanish. You might end up with something like this: &gt; QUATRO score Y SIETE years ago NUESTRO PADRES brought forth on ESTO continent, UN new nation, conceived in liberty, Y dedicated A EL proposition that all men SER created ==. There's a word we like to use to describe things like that: abomination. It's a misguided attempt to make one language *look* like another, completely glossing over all the multitude of ways that the two languages are syntactically and grammatically different. The result isn't valid English or valid Spanish; it violates the rules of both languages. The fact that you could, in this example of the shell, equally write IF x == 3 ) { and if (x == 3 THEN both of which are valid, is a big red flag that something has gone horribly awry with the basic idea.
Great! What was the issue?
What have you tried?
It means you cant modify your variable using that function.
I have tried finding most frequent occurring words in a given file using hashing. When I find a word that's already been stored in the hash table, increased it's counter by one but that's pretty much it, after that I'm lost.
Do your own homework. If you're trying to do this, post what you have. Or ask a specific question about how you might approach something, how what something means. Don't just post your homework question and expect people to do it for you.
You have (possible by accident) deleted your post.
I'm guessing you mean something with more interactivity from the user. Maybe look at GTK for gui development, or SDL2 for real time rendering apps
Old Unix source code was what I first though of, too. Let's take another example, `cp(1)` from https://github.com/qrush/unix/blob/master/src/cmd/cp.c: if(argc != 3) { write(1,"Usage: cp oldfile newfile\n",26); exit(); } It doesn't refer to `stdout` by name (and errors to `stdout` rather than `stderr`). The length of the string is calculated by hand and hard-coded directly in the source code. It uses `write()` to output a fixed string to avoid the overhead of `printf()`. Weirdly, it doesn't return a value to the shell to indicate success or failure. char buf[512]; fstat(fold,buf); mode = buf[2] &amp; 037; Ugh. I know they're trying to save a handful of bytes, but this is *gross*. They're reusing their data buffer to also hold a `struct stat`, *and* they're hardcoding the struct's layout to directly access the field they need from that char buffer. No modern programmer would or should *ever* do something like this. p1 = argv[1] - 1; p2 = argv[2] - 1; bp = buf - 1; while(*++bp = *++p2); *bp = '/'; p2 = bp; while(*++bp = *++p1) if(*bp == '/') bp = p2; This is very typical of old C code, and I hate it. There are a bunch of cryptically short variable names that are all too similar to each other: `p1`, `p2`, `bp`. Even if the names had to be short, `p` for "pointer" is too vague, when you could have had `n` for "name", since that's what it's manipulating. `nold` and `nnew` would have been better. In older C compilers, names of functions and variables were limited to just *seven freaking characters*, so naturally things are going to be terse, but even so, I think some slightly longer names here and there would have been nice. The pointer arithmetic is very efficient compared to a modern style of using array indices, but not easy to read. The fact that it has to be preincrement rather than postincrement in order to get both the efficiency and the free check for the null terminator makes it even harder to understand, and necessitates the awkward `start - 1` preface. I had to read this several times before I figured out what it's doing, since there are no comments, no documentation, and no helpful names like `S_ISDIR` to act as signposts for the reader. I would rather a modern programmer just do `snprintf(buf, sizeof(buf), "%s/%s", argv[1], argv[2])` or piece it together with `strncpy` and `strncat` if they have to rather than doing all the pointer arithmetic, but if they are going to do it with pointers, I'd rather they use array indices and additional variables; it would be easier to read, and *if* there's any minor loss of efficiency even with modern optimizing compilers, we can accept it in exchange for improved programmer and maintainer efficiency.
I’m not sure how familiar you’re with subsequences but have a read [here](https://en.m.wikipedia.org/wiki/Subsequence) to get a bit better understanding of what needs to be achieved. From there you can try and come up with a solution for creating a list of all the subsequences.
Desktop link: https://en.wikipedia.org/wiki/Subsequence *** ^^/r/HelperBot_ ^^Downvote ^^to ^^remove. ^^Counter: ^^249755
Here is a talk by Stephen Bourne himself describing the design and evolution of the Shell: &amp;#x200B; [https://youtu.be/FI\_bZhV7wpI](https://youtu.be/FI_bZhV7wpI) &amp;#x200B; I thought it was fascinating and I think you will, too!
Are the downvoters missing the subtle joke?
First question: You have a faulty assumption -- it does work if the variable is named `cursor` instead of `root`. What actually fixed the problem was what u/shyamcody mentioned -- your variable name change had nothing to do with it. (Try renaming everything back to `cursor` to prove this is true.) Second question: `*root = root-&gt;right` would indeed have affected all references to that node, but you aren't doing that. You have `root = root-&gt;right` -- no star. `root`, with no star, is just the function's [local copy](https://www.cs.auckland.ac.nz/references/unix/digital/AQTLTBTE/DOCU_056.HTM) of a number representing the address of that node. So whatever you do to `root` with no star will be just as self-contained as the `x++` in `void foo(int x) { x++; }` -- only by dereferencing it can you affect outside state. If, for some reason, you wanted to affect `main`'s copy of `root`, you would pass the address of root: void leak_memory(struct binary_search_tree **proot) { *proot = NULL; } struct binary_search_tree *root = malloc(sizeof(struct binary_search_tree)); leak_memory(&amp;root); assert(root == NULL); And a last terminology note: try to keep separate the notions of binary tree (in general) and binary *search* tree. It's possible to have other types of binary trees -- please don't erase them! (Also, if you aren't careful about this, you'll inevitably someday get an interview question where they tell you something is a binary tree, you assume it's a BST, and everything goes horribly wrong.)
The topics you've listed are not exactly C concepts, they are unix concepts. You can just read the man pages for these things. man pipe, fork, exec, signal, and socket will give you the information you need about the topics listed. Always check man pages first, they are almost always very good. For instance, the man page for bind() (part of the sockets api) has a full code example.
Start simple and build one step at a time. Personally, I would scrap what you have and start over. I would start by just figuring out how I wanted to represent my data (Morse code, alphabet, string to be converted). Then, I would write a program that sets up my data then prints it out. Now I would know that the input going into my program is correct. After that, I would figure out the logic for converting Morse to alpha. The main thing is to go one step at a time and test/verify each step is correct. The real advantage of this method is that you are only adding a small amount of code to a known working program. If you get a bug, you know it is going to be due to the lines you just added. The fewer lines of code you have to debug, the easier it is.
For sockets: https://beej.us/guide/bgnet/ For pipe etc read the man pages. You might need to install `manpages-dev` or similar first.
I would recommend making several small, simple utilities to get the hang of new libraries / interfaces. For instance GUI - Color selector Loader magic - "time machine"; something like valgrind that intercepts calls to standard time related functions and modifies the outputs Images - Make a tool that applies the dithering algorithm of your choice to an image Networking - Make an echo server Processes - Make a basic shell with piping and redirects Once you've done several of these, if you're interested, you can try to write your own libraries to get an understanding of what's done for you. Read other people's code to get a sense of what is done, and try making a library for a very simple function (for instance, try making a bignum library with efficient addition and multiplication, or one to process xpm images, or something simple like that). Once you've built up your skills in a variety of different areas, you should be ready to move on to bigger projects which incorporate several things you've learned, or you could go further with a single field. Ideally, you should have an interest in what you're making.
Self-study using Advanced Programming in the Unix Environment 3rd edition (and this handy-dandy walk-through) as your guide. Read Chapter 1 for an overview. Jump to Chapter 3 for understanding file I/O (understanding how file descriptors work is the important part here). Skip to chapter 8 for process control. Skim the chapter, but focus on forking, exec, waitpid, etc, as well as the section on race conditions. As an exercise, build a `mypipe` program that has similar functionality to a pipe `|` in the shell, such that `./mypipe program1 arg_a arg_b -pipe program2 arg_c arg_d` has the same functionality as `program1 arg_a arg_b | program2 arg_c arg_d`. (ie. pipe the output from program 1 into the input to program2, which writes to stdout) Skip to chapter 10 for signals. Skim the chapter, then focus on understanding how to use sigaction to install a signal handler. Skim chapter 11, then focus on the concepts in 11.6 (thread synchronization). Concepts to understand here (specifically) is deadlock avoidance, mutexes, condition variables, and spin locks. Focus on the differences between mutexes, semaphores, and spin locks and try to understand what each one does and what each is used for (and what each *can't* be used for). Skip to Ch 14.4 for I/O multiplexing, then jump into chapter 15, focusing on pipes and FIFOs, then jump to 15.8,15.9,5.10 for semaphores &amp; shared memory. Spend some time on chapter 16/17 for sockets. Important thing here is understanding the listening socket vs the connection socket. Ie. socket-&gt;bind-&gt;listen-&gt;accept on the server-side vs socket-&gt;connect on the client-side. A good quick-and-dirty project here is to try to recreate a simplified version of `wget`. A slightly more involved project would be to write a two-way chat application. (hint, forking is a good idea). A much more involved project would be to write a chat server that can accept multiple connections. (hint - I/O multiplexing is your friend here). Throughout the process, build, somewhat arbitrary purpose-driven programs that do *one* thing really. It doesn't need to be a useful thing -- just a thing that utilizes one or more concepts in an isolated way. Have fun.
That's great thank you!
Other comments are pretty good. One thing I would sort of recommend if you havent already done similar is a sound generator. It is a file output, but the exporter would be the same anyone else would use in their program and you can keep adding to the generater part for better sounds.
&gt;You are not allowed to use memset calloc or realloc for anything As somebody who struggles with this, excellent tip! Do you have any good ressources recommendation on API design without `malloc` ? I dont want to rely on internal global variables or asking user to always pass a structure into each functions.
Conflicting installs of CUDA with 9.0,9.1 and 10.0 all at the same time.
I didn't say don't use `malloc` -- `malloc` is great, in fact spend a lot of time learning how to properly `malloc` and `free`. Don't use `memset` or `calloc` because those just throw zeroes everywhere all willy-nilly, so they hide poor programming practices of actually understanding what you're doing to the memory every step of the way. Don't use `realloc` because it allows you to get away with under-allocating rather than forcing you to think critically about how things are stored, buffer sizes, scalable data structures, error/bound checking etc. Re: API design for data structures, use malloc for internal components of that data structure, but for any user-provided data, try to be agnostic re: it's type and memory lifeline -- ie store pointers to user data. (Whether that Data pointer is valid or on the heap/stack or whatever is the business of whoever is using your data structure.)
Oh, I see. I though you meant binary tree when you said "Btrees". I found [B-trees](https://en.wikipedia.org/wiki/B-tree) after some googling. Learned something new :)
Love it! It’s used in raylib, you should cross post this to /r/clibs
You can disable certain backends by adding defines, like disabling PulseAudio with `#define MA_NO_PULSEAUDIO`. You could also call `ma_context_init()` with a specific list of `const ma_backend backends[]` backends in priority order.
An excellent library made by an excellent developer. Always helpful and quick to help other developers with issues. I also recommend his other libs: [dr_libs](https://github.com/mackron/dr_libs).
Compilers vary, but it is fairly common for implementations to optimize out `if`/`else` constructs or or `?:` operators in cases where the condition is a literal constant. There is considerable variation, however, in when references to external symbols in omitted code get passed through object files and validated by the linker. On some implementations, something like: if (sizeof(FOO) &gt;= 256) { extern void bar(void); bar(); } will generate a reference to `bar` only if sizeof(FOO)` is 256 or greater, but will build perfectly happily if `sizeof(FOO)` is less than 256 even if `bar` doesn't exists anywhere. Others will squawk at link time if symbol `bar` is undefined regardless of the size of `FOO`. A similar situation would exist with something like: extern int bar; if (bar &amp;&amp; 0) {} which might result in `bar` being read but ignored, omitted from the file altogether, or included as a required reference without generating any code. On some platforms, it may be possible to do something like: if (sizeof(FOO) &gt;= 256) { extern int big_struct_support_needed; if (big_struct_support_needed &amp;&amp; 0) {} } and have the linker squawk if `sizeof(FOO)` is 256 or greater but `big_struct_support_needed` isn't defined, but not if `sizeof(FOO)` is 255 or less, all without generating any actual code in any case. Such behavior may be useful if a library includes both full-featured and lightweight versions, and one wants to ensure that the full-featured library will included when necessary.
Guys my main error was on this line: `for (int j = 0; j &lt; 1000; i++)` Now everything is working
For a typical mainstream multitasking virtual memory-based operating system, realistically the only thing you can do is abort.
There are a few times when it's possible to handle an out-of-memory condition. Maybe you can clear cached or prefetched data, for example. But honestly, these are rare. Most of the time the most you can do is log or report the error and abort.
[Microsoft switched to `cdecl` with 64-bit.](https://en.wikipedia.org/wiki/X86_calling_conventions#List_of_x86_calling_conventions)
return NULL then handle it further up the call chain
If this happens in a program, it's ok to abort. If it happens in a library, return an error to the caller. It's never a good thing for a library to abort on errors, even if you probably won't be able to do anything else. One other thing: be careful with the meaning of malloc returning null: it **doesn't mean** the computer ran out of memory, it means that malloc couldn't allocate *the requested size*. This is important because even if that particular call to malloc failed, you might still be able to do other things, and another call to malloc with smaller size request might succeed.
try this: &amp;#x200B; int\* pop ; if (!( pop = malloc(sizeof(int) \* totalGenes ))) return NULL;
Thank you!
Thank you!
Thank you!
To the idiots who downvoted this comment: `#metoo` looks an awful lot like a preprocessor command, doesn't it?! This was the joke and you downvoted it into oblivion.
1.- memory is allocated for an array of integers of size 3 2-
Thanks for the example!
1.- memory is allocated for an array of integers of size 3 2- a variable named "i" is created and is assigned the value 0 3- a comparison is made to see if I is less than 3 4- the only line of code is executed, in this case right to left. First get the value returned from get_int and then assign said value to scores[i], but before get_int is executed the calculation i +1 needs to be made. 5- i++ is executed 6- back to step 3 until that comparison fails to be true
Nice, clean walkthrough.
The for loop runs whatever is inside the loop as many times as the conditional inside the parenthesis is true. So in this case as long as i &lt; 3. Yes the i++ will apply inside the loop. This is because of the scope of the i variable which you will learn later. The i + 1 is not an assignment, it won’t change the value of i, but will make the program print score 1: score 2: score 3: ...... you want to add 1 so it doesn’t print score 0: score 1
It did help! Are most other programs done by Call by Reference? How about python? Thank you!
The tutorial book mentioned sth about FORTRAN as well. Thank you!
You may want to look into SDL. The wiki is fairly comprehensive a reference, and they link to various resources that give example code specifically for game development.
Yeah, Reddit doesn't make the C++ subs easy to find. :-/ Try asking in /r/cpp_questions.
Thanks!
Ok. Got everything except i + 1. I'll be grateful if you could go over that again. Thanks.
Ok. I'll have to google scope cause it's really confusing me.
It be like this. Loop increases i's value as long as (i &lt; 3) right? Now we use i's value as indice to set "scores[]" array. scores[0] = get_int(...) scores[1] = get_int(...) scores[2] = get_int(...)
I [posted this to r/technicallythetruth](https://www.reddit.com/r/technicallythetruth/duplicates/bb3zgz/the_1973_bourne_shell_in_unix_version_5_was_only/) so hard it was like the hammer of a Nordic God.
Your problem is language agnostic. Forget C for the moment. You need to learn how loops and array indices work.
pop\[0\] = ... kind of already checks if malloc succeeded, on many systems. Implicit (no checks) or explicit abort() will create a HUGE corefile, on many systems. Very inconvenient and bogs down disk, but allows you to debug, when it happens. In a library routine, an option could be to while (malloc fails) (*user_provided_oom_handler)(amount of memory now requested); Then the hook could try to release any possible unneeded stuff (if it knew how), or if it didn't just abort in an appropriate way after removing temp files etc.
have an array of strategy ID's and also an int to signify the max strategy index (MSI), when a strategy is used swap its ID with the ID at MSI and then reduce MSI by one, also choose a better variable name than MSI ! 0,1,2,3,4,5 MSI 5 (all 6 id's available) 0,5,2,3,4,1 MSI 4 (1 was chosen swapped with 5 and 1 is now out of reach) 4,5,2,3,0,1 MSI 3 (0 was chosen entries 0-3 - 4,5,2,3 are only available) hope I explained that okay ?
I'd go with SDL 1.2 It's quick &amp; easy.
Thank you, but I'm looking for something much more low level as more of an educational experience and a challenge.
shift != rotate, you need to test with MASK31 before shifting then if there is a 1 stick it on the right hand side.... for displaying you can start by setting a variable with MASK0 and logically OR-ing to see if there is a bit in that position, you then shift left your mask to check the next bit (a loop would be good for that - you can directly print from the loop or if you are feeling brave modify a string and print it at the end of the loop....
Perhaps reading the source code for SDL will give you an idea of how writing to an FB would work at a lower level, as well as how it's done on several other platforms. AFAIK, windows doesn't have the same concept of writing to an FB, and would instead need you to write to a window buffer, or make use of a system API, like DirectDraw or Direct3D.
If you want low level you can use the framebuffer device directly or use the DRM/KMS kernel module which is the modern approach. I found [this site](http://betteros.org/tut/graphics1.php) pretty helpful when doing graphics on Linux. For Windows support you need to do something seperately but that's the tradeoff for low level.
Ah, thank you. I'll try that.
low-level AND cross platform contradict eachother. You could write your own wrapper though, like GDI for windows and Xlib/XCB for Linux with a common interface. You would end up with something like SDL in the end but learned some of the behind the scene OS stuff. Another way would be programming for VGA directly and use dosbox for cross platform. It really depends what your goals are.
Suggestion: look at SDL 1.2, its not as complex as SDL 2.0
 #include &lt;stdio.h&gt; int main() { int i; for (i = 0; i != 3; i++, printf("for(): %i\n", i)) { printf("In loop: %i\n", i); } return 0; } Output: In loop: 0 for(): 1 In loop: 1 for(): 2 In loop: 2 for(): 3 I hope it explains itself?
I think the Dosbox suggestion is probably the best one here. Programming for VGA directly isn't really practical (because SDL, etc, is better), but if you're going to do it then you might as well target a platform like DOS (via Dosbox) that's never going to change.
Check out http://www.allitebooks.in - lots of free books about anything IT related like game and SDL
Just for fun and for a change, I tried this kind of "improved" strcpy some time ago in a somewhat memory limited black box. I liked the result very much. Returned address of the \0 in the return register was the same as an destination argument register for the next strcpy. Super compact, only the source argument had to be loaded between calls.
I guess that makes a lot of sense. What I was thinking of is internally creating the frame in the program then displaying it however possible. Thank you for the link.
Today, almost all programming languages employ call by value. In some programming languages like C++, you can choose between call by value and call be reference. However, in many object oriented languages (such as Python, Java, and C#), the calling convention still feels a lot like call by reference because objects are reference types in these languages. This means that while assigning to an argument (what the function receives) does not affect the value of the parameter (what was given to the function), both reference the same object and assigning to a member of this object affects the same object seen by both.
low level like SVGA lib, or just go back to MS-DOS so you can hit the hardware directly?
There are ways to do this with less abstraction but they either involve working in the virtual console (i.e. without X11) or dealing with X11 (which is rather painful).
[https://man.openbsd.org/atof.3](https://man.openbsd.org/atof.3)
I'm willing to deal with all the pain in the world in the name of learning.
Be aware that if you have a window manager like X11 running you'll most likely have to request a window there (using Xlib for example, which is pretty low level as is). Access to the framebuffer device will be denied while X11 is running.
What exactly do you want help with? Your question is a bit vague. Opening and reading a file can be done either with fopen() and fread() or open() and read(). If you want to process something like '1+3*5' properly (with multiplication taking precedence) you are writing something that is basically a parser and you need to know a little bit about the basic ideas of lexing and parsing (general programming concepts) and things get a lot harder. But I'm assuming you don't care about that. Then you can just go through the string from start to end, maintaining some state such as what the current intermediate result is, what the current operator is, and what the number is that you are currently parsing.
 return ((iVal&lt;&lt;1)|(((unsigned int)iVal)&gt;&gt;31)); But rather use `int32_t` and `uint32_t` which are defined at &lt;stdint.h&gt;.
Hi, I'm writing a framebuffer library. It only currently supports Linux, but I could add a windows support later (or allow someone to do so soon). Have a look : https://github.com/jesuschrist-official/jcfb It supports keyboard &amp; mouse, and mutiple color format.
Oh boy, this shows some promise. Thanks a whole lot! I'll definitely be using this I guess.
Got it, thank you for the detailed response!
If you have any troubles/remarks, don't hesitate to report them. I guess the version I pushed on github is almost outdated, I'll check tonight for that.
Alright, I'll be happy to report any issues.
C11 defines for loops as follows: ___ **6.8.5.3 The for statement** 1. The statement `for ( clause-1 ; expression-2 ; expression-3 ) statement` behaves as follows: The expression *expression-2* is the controlling expression that is evaluated before each execution of the loop body. The expression *expression-3* is evaluated as a void expression after each execution of the loop body. If *clause-1* is a declaration, the scope of any identifiers it declares is the remainder of the declaration and the entire loop, including the other two expressions; it is reached in the order of execution before the first evaluation of the controlling expression. If *clause-1* is an expression, it is evaluated as a void expression before the first evaluation of the controlling expression.¹⁵⁸⁾ 2. Both *clause-1* and *expression-3* can be omitted. An omitted *expression-2* is replaced by a nonzero constant. 158) Thus, *clause-1* specifies initialization for the loop, possibly declaring one or more variables for use in the loop; the controlling expression, *expression-2*, specifies an evaluation made before each iteration, such that execution of the loop continues until the expression compares equal to 0; and *expression-3* specifies an operation (such as incrementing) that is performed after each iteration. ___ We can expand your example to the following: { int i = 0; top: if (i &lt; 3) { scores[i] = get_int("Score %i: ", i + 1); i++; goto top; } } (the outer braces create a block which controls both the scope and lifetime of `i`). I hope this answers your question.
Yes, there are both send and receive queues/buffers. The packages are being queued, but if you are using a UDP socket and the queue is full, packages start to drop. You can configure the buffer sizes with `setsockopt` and the `SO_RCVBUF` option.
For a one-shot (or a class assignment), just assume that `malloc()` can't fail, because it won't unless there is a bug in your program, and if it does, your program will crash, which is easier to handle in a debugger than a clean exit. (Note that in the case of a class assignment, you should probably put in a comment explaining why you don't check the result.)
I think your missing a ; after your array
That is some of the worst advice I have ever seen. Do you by any chance make a living selling 0-days?
It's because your code doesn't compile.
You must be getting compile errors, at least two. And you should post the errors if you need help fixing them.
Ok thank you after that it gives me this error (I am new to C) &amp;#x200B; main.c: In function ‘main’: main.c:23:3: error: expected declaration or statement at end of input return 0; ^
Thanks!
You forgot the } at the end of the main function
missing close-curly brace at the end.
Here are the errors &amp;#x200B; $gcc -o main *.c main.c: In function ‘main’: main.c:16:3: error: expected declaration or statement at end of input return 0; ^~~~~~
Thanks i did not even think of that.
Also, you need to put 3.0 instead of 3 if you want that code to work properly.
That's terrible advice. What /u/ElMtDev did is inefficient but not far from the standard idiom, which is to grow the buffer exponentially, keeping track of both the size of the buffer and the length of the string it contains.
So that would give me The average of the 3 grades is: -1116191048 instead of The average of the 3 grades is: 85
&gt; Thanks i did not even think of that. Luckily you don't need to think, since the compiler tells you what's wrong and where it is wrong.
(We were all new once, I’m still a novice as well no worries)
There is no cast (and you can only cast types, not values). The `||` operator evaluates to either 1 or 0.
No love for AA trees? They are equivalent to red-black trees, but easier to implement.
Np! Good luck with programming
Did you change the conversion character ("%f" instead of "%d")?
You can't print a floating-point number with `%d`.
If the number is a float, the format should reflect that.
Why SDL 1.2 as opposed to SDL 2?
I prefer straight up implementing B trees.
SDL2 is more OpenGL/DirectX hardware GPU based, unlike 1.2 which tunks down to 2d/DirectDraw type stuff. And it's a heck of a lot more simpler to just open a simple buffer and blast bits to it.
This sub is for C programming. Try r/csharp.
thx
Use realpath. Type "man 3 realpath" to learn about it. Make sure you have the manual pages installed.
That's great! Do you think there's a way to also issue opengl drawing commands directly onto the frame buffer? Or is there a principal obstacle?
No, I guess there is absolutely no problem with that. I already thought about this question. In fact, OpenGL let you send &amp; receive images to/from the GPU, you can "upload" your image to a texture and "download" it to RAM, then blit it to framebuffer memory, and all the work is done. That would be a nice thing to implement in this library (or developping a new lib to do so). I would not be surprised this is the way libraries using OpenGL work, or perhaps the system could let us doing more direct things, like mapping framebuffer memory directly on the main GPU framebuffer ? The same things should be true for Vulkan (that should allow a largely better fine-grained control over the whole process ?) If someone has precise answers to this question, we'll take it :)
So good!
Javascript PDP-11/70 front panel emulator is in your r/C_Programming, delighting your retinal neuron projections.
`strtok` (see: [More info on how to use it](http://www.cplusplus.com/reference/cstring/strtok/?kw=strtok)) can split your string into tokens. You can then check the string for occurences of + - * / and then add those evaluations accordingly.
As a general tip, try upping the warning level: gcc -Wall -pedantic -Werror -o main *.c
Question: how relevant to C is SDL though? Like, If I’m looking to Improve my pure C skills, is SDL more a Library to quick start my gaming skills, or would I be better learning pure C in a gaming repertoire? (Not op but I’ve had a similar thought before, and not sure how much SDL would help with C learning compared to it being a C short cut to gaming programming)
We all learn something new everyday. ;D
I forgot to mention that I work in embedded where \`malloc\` is forbidden by most standard.
I respect both of your opinion, but I would like you to detailed your objection. :)
Yes yes. This super helped. Thank you so much.
Context: &gt; While you are mastering the ins and outs of memory management, you are not allowed to use `memset` `calloc` or `realloc` for *anything* nor are you allowed to broad-brush zero-out memory (unless a function explicitly requires it). 1. The point is not to rely on these, *while you are initially learning* because then you forget do things like intentionally null-terminate your strings, or intentionally set pointers to null or whatever initialization you need for specific variables. By restricting use of these functions, you force yourself to consider precisely what you're doing with memory, and why you're doing it. Use of these functions is great in the real world because they get rid of junk memory. Use of these functions *while you are still wrapping your head around memory* is a crutch. 2. Chill.
They're basically telling you carry a loaded, cocked gun with the safety off at all times because it will teach you to be careful with where you point it.
Oh no!! All I wanted to do was learn how to use printf and write linked lists, but now terrorists are using junk data exposed in my intro-to-CS assignment to gain access to credentials they need to the overload uranium centrifuges, hack an election, and show reruns of Firefly on every channel. If *only* I didn't take that advice from that guy on that subreddit! -No one ever
What happens is that i++ is executed after scores\[i\] is assigned. In the case of get_int("Score %i: ", i + 1); first i + 1 is calculated, and then it is only get_int("Score %i: ", 1);
SDL is basically a replacement for the windows api/X server, it will handle things like creating a window and setting it up to work with opengl/directx. It's not an engine though. You still would have to do a lot of the "dirty" work, it doesn't give you frame timing, or a physics engine(or even collisions). All it really does is give you a way to talk to the OS about things like keyboard/gamepad input, drawing(either with a graphics api or without one), and things like that. SDL isn't really a "quick start" style of library, if you want that most people would go with a game engine such as unity, godot, or unreal.
Thank you so much for this. This is exactly what I needed to hear, and is greatly appreciated. I'm still early on in my learning experience, so these bits of knowledge are incredibly important to me in building a solid foundation. Your explanation was terrific, thank you again.
Not the answer your looking for, but whatever format takes the overall least amount of time to understand and program is probably the best. Code is just a tool.
I think this sort of stuff (mostly) just comes down to personal preference and consistency. I would strongly prefer the second example because as someone who has never read your code before, but I just like to have structures declared first so that I know what to be looking for throughout a function up front. Doing delcare -&gt; define, declare -&gt; define makes me start to have to juggle the thought process of trying to determine what I'm looking for AND what is being assigned to them and why at the same time. It's a trivial difference in most cases though. The biggest factor is consistency though. If you do one, stick to it. Irks me more than seeing loads of different styles in the same project (or source file for that matter).
I did, for two reasons. 1. In most projects, you’ll want to have checked the compiler type before throwing down a `#pragma`, because you can get warnings/errors/UB from an unrecognized pragma. You’ll usually check the compiler type inside the include guard, often inside another included file. 2. The include guard is itself equivalent to a `#pragma once` for things like GCC, and putting a `#pragma` outside the include guard—anything other than comments or whitespace, even—may negate that. For other compilers, they’ll see the `#pragma once` the first time through the file, so there’s no difference between putting it outside or inside the guard.
I don't want to sound stupid, but I don't see how it would *not* work. I mean, you're sending the address of a local variable to the function, through `pthread_create`; in `sqrfunc`, you're just converting the pointer to a pointer-to-double, changing the value it points to to `sqrt(*ret)`, and returning that same address. So at least to me it makes complete sense that `ret` would be 4 there, as it is `sqrarg` (I'd be flabbergasted if the latter isn't true).
While I don't have a list making a HTTP server is always a interesting project to do. You only need to implement HEAD and GET for it to count I believe (check the standard just in case).
I'm pretty sure you are breaking strict aliasing which results in undefined behavior. If so your "working" example is not correct. Someone better at C than me can come verify or refute me.
SDL only provides a multimedia hardware abstraction layer (hence the name) and a few smaller handy functions and structures from the other parts of its standard library. You will still be largely writing pretty much the entire game in C, you just don't need to worry about using a specific system's API.
Aliasing? Is it because it's converting a pointer-to-double into a pointer-to-int? Wouldn't most systems produce a valid pointer-to-double after it converts it again to `double*`?
"Strict aliasing is an assumption, made by the C (or C++) compiler, that dereferencing pointers to objects of different types will never refer to the same memory location (i.e. alias each other.)"
Thanks!
you could take a trip down the OpenGL rabbit hole, you needn't do 3d at first, implement your own "sprite engine" and from there make some kind of galaga clone.... (am i showing my age!) and wadda ya mean a game isn't a real world application, they earn more money than Holywood ! This might seem a bit more like a intermediate project but if you break it down and just start with rendering a textured triangle, the rest will follow...
If your function is intended to operate on behalf of another function, you should return `NULL`. If your function is operating on behalf of whatever subsystem controls output and exiting, it can print a diagnostic and abort or `_Exit`. (Best not to `exit`, because that can call a bunch of handlers. You may also want to `write` to FD 2 directly to avoid `fputs`/`fprintf` trying to allocate anything.) Most of the time, in top-level stuff you’ll want to just bundle allocation up into its own function that does all that for you, along the lines of this: void *allocate_checked(size_t amt) { void *ret; ret = malloc(amt); if(__builtin_expect(!ret, 0)) { fputs("fatal error: insufficient memory"\n", stderr); fflush(stderr); for(;;) abort(); } return ret; }
Just realised there's been a misunderstanding in the whole thing, just a bit confused.
You didn't post code for the failing case, but even so, I didn't experience the same thing. I replaced the pthread stuff with a simple `ret = sqrfunc((void*)&amp;sqrarg);` and still got 4.000000 as the result. Just as I was about to write this up, I saw the answer. Keep reading. You *do* have several problems here, and they're all related to casting and how you treat your data and pointers. The fact that you have to cast `(void*)sqrfunc` and `(double*)number` and `*(double*)ret` are all code smells that maybe you're not doing something right. The function you pass to `pthread_create()` *must* have the prototype `void* sqrfunc(void* arg)`. It takes a single argument, which is a `void*`, and returns a value which is a `void*`. A lot of people abuse this, such as passing an int by just casting it: `pthread_create(..., func, (void*)intValue)`. That's not portable and shouldn't be done, unless you know for sure that `void*` on your platform is big enough to hold an `int`. Obviously if you were on a 32-bit system and tried to cast a `double` to a `void*`, it would truncate the value. So some care is needed in handling the argument. If you needed multiple values, you'd either have to pass an array (but how would it know the size of the array?) or a pointer to a struct that contains all the arguments. In this case, you pass a pointer to a value, which is fine. By using the correct types, we can get rid of the cast inside the function (`double* res = number;`) and when spawning the thread (`pthread_create(..., sqrfunc, &amp;sqrarg)`). That's an improvement. For the return value, if you know that the thread's function returns a pointer to a double, then IMO you should declare `double* ret` rather than `void* ret`. Unfortunately, this *does* require a cast somewhere, but I think it's more clear to do it this way than to have to do `*(double*)ret`. But remember, the return value is a *pointer* to something. It has to point to valid storage. Either `main()` has to allocate that storage and somehow pass it to the thread, or the thread has to allocate that storage, which it *must* do on the heap because obviously its stack will disappear as soon as the function returns its, uh, return value. So what value are you returning? ... you're returning `number`, which is the same pointer that was passed in: it's a pointer to main's `double sqrarg`. And in the function, you modified it when you did `*res = ...`. So you modified the value held by `sqrarg`, and then returned a pointer to it, which main dereferenced and printed. That's why it always returns the correct value, whether you call the function directly or run it as a thread. It's easy to see: add a `printf("%p\n%p\n", ret, &amp;sqrarg);` and you'll see that `ret` points to `sqrarg`. The fix is just as I said: either it's fine as is (the function mutates its argument, which is used as storage for the desired return value), or `main()` needs to allocate storage for the return value and pass it to the function (which will mean passing a struct so that you can pass both the in-parameter and the pointer the out-parameter), or the function needs to malloc storage for its return value and pass that pointer, which `main()` would then need to free.
Thanks
Love the name ;v
the basics, hello world and fizz buzz types of problems.
If they have no experience in programming make it as simple as possible. And if they well understand basics concept (variable, condition, array) then go on with pointer and all other low level stuff.
I think the title of the post is a little misleading. It seems like you're really asking "How do I tokenize a string without using standard library functions?" My answer to that comes in the form of a question: Why are you avoiding using string functions? It'll make your life so much easier to just use `strtok` or `strsep` rather than reinvent a string parsing function manually. the man pages have good examples of how to use either to accomplish the task. Unless, of course, the whole point of your exercise is to learn what an implementation of that kind of function will look like. In that case, well you won't learn a whole lot just by having someone give you a solution.
You'd have to use the native libraries for each operating system, which also means it will not be cross platform at all. Atleast on Linux you could go on to write your own window manager and the library yourself (not recommended). You'll need to look up each UI library for the operating systems you want.
&gt; as simple as a window I'm here to ask another question: are Windows _that_ simple? How do you write a _bare-bones_ program that prints "Hello world!"? A program that's _standalone_: that doesn't depend on the C standard library, C runtime or any other library, that relies purely on syscalls? How do you even make this program run, since it doesn't rely on C runtime?! _That's_ the simplest program you can write, yet it's not so simple to get it right.
if you want cross platform look at GTK+
Hi! Where can I get more info about this topic? Sounds interesting.
just the basics for sure. try to make it fun and frustration free for them. only a very small percent will think the back ground deep stuff is fun.
How much time do you have? I think the greatest thing you can do is to explain how C manages its memory. Stack; Heap. Draw pictures, let them crash their programs on purpose; read from random memory locations, read from stack, create your own pointers from addresses they know. Write to memory. Array memory. Struct memory. Memory-memory-memory :D And don't tell it's difficult. It's nontrivial. And fun! Since C is ridiculously simpler to debug once the students can imagine what their variables and function calls do in memory. But I assure you your third time teaching it is the time you grok what they struggle with.
So, it's basically like a 1 week crash course. I fear the topics you suggested would just go over their head since they have zero exp with programming and/or computers. I just have enough time to get them started with basic programming in C like really basic.
He wants an OS kernel, presumably.
I would not teach C to students with no programming experience. They'll walk away thinking programming is difficult and will be less likely to continue. Start with a modern language, with modern features, and then let them try C after they've learned something easier.
Teach them python, or java. What's the goal here? You can't go from zero to C developer in one week, with no prior experience.
Consider the behavior of uint32_t mul_mod_65536_and_promote(uint16_t x, uint16_t y) { return (x*y) &amp; 0xFFFF; } That would look like it should be portable, but on gcc implementations where `int` is 32 bits it may occasionally have weird side-effects if `x*y` is in the range 2147483650 to 4294836225, because the values of `x` and `y` will be promoted to a signed `int`. The authors of the Standard have stated that they did not expect the choice of signed vs unsigned promotion to affect the behavior of commonplace implementations given code like the above, since the Standard would allow implementations to process both identically and they saw no reason to expect that commonplace implementations would do otherwise. The authors of gcc, however, see no obligation to behave in the way the authors of the Standard expected and intended.
Well, if I go back to the past I would have liked a funny class, yep easy to say :P I remember when I was a young student (not university, younger) I wrote a "soccer game" using Turbo BASIC, just using chars for the "graphics". The teacher gave us a kind of template/skeleton to follow and guided us a bit, we was a small group. The program took some time but it was really funny, was the first time I saw code. I was looking forward to these classes, I think my love for programing came from there. Maybe that gives you an idea... &amp;#x200B; How old are your students? That's important I think.
If you want it to be cross platform then [SDL](https://www.libsdl.org/) is about as basic as it gets. Anything more low-level than that is going to have to be platform-specific.
I beg to differ. C++ was the first ever programming language I ever learned and loved it as well. I actually believe the opposite, C is the programming language everyone should start with, literally has every good programming practice a language could have.
Glad you enjoyed it. Thank you for posting the original piece here.
Then why does EVERY SINGLE UNIVERSITY teach another language first? If C is the best for beginners, it'd still be what's taught as a first language. I love C, but it's not a language to learn in one week with no programming experience.
They are undergrads
You need to talk more about what you want the program to do. At some level, unless you completely leave Operating System space, you will rely on an API to draw or print characters. Or write your own Window Manager, which though, again, would use the System API to execute the draw calls. And if you want to leave operating system space you'd need a boot loader and then communicate directly with the display adapter over some ports or somesuch. I mean, you can get reasonably close to the metal by using a more hobbyist OS like TempleOS. But those are deep depths and I believe the author&amp;maintainer of TempleOS unfortunately has passed away.
Nobody said, I'm getting them to become C developers in 1 week. The idea is like a 101 basic to programming with C. Even if they are able to write basic logical problems like palindrome or stuff with C and have a good understanding of basics, we would be more than happy.
Depending upon intended usage, it will often be better for a library to guarantee that it won't return unless it successfully creates an object, than to have it possibly return without doing so. Call a function pointer whose *default* value will result in the program being aborted, but which can if desired be changed to e.g. use a `longjmp` to a pre-configured `jmp_buff` if desired, will often be better than have the library kill the application directly, but in many cases the only way to make applications survive out-of-memory conditions is to use a more sophisticated memory-management library that can pre-allocate pools which can be guaranteed to honor a certain volume of allocation requests--something the Standard library can't do.
I had C++ as my first ever language being taught in high school.
Why C though? It's definitely not a language that lends itself to beginners. In one week of C, they might be able to sort of understand "Hello World". In one week of Python, they'll be able to write a simple text based game, and walk away with a more useful skill.
High schools aren't the best examples of good education. What language do the top 10 CS undergrad schools teach their students first?
I'm not sure if C is the best language for your students to learn. C is great, of course, if you want to learn how computers work. But if you just want something with which you can be productive quickly and make fun little MyFirstPrograms in a week, perhaps Python would be more suitable.
[https://www.radford.edu/ibarland/Manifestoes/whyC++isBad.shtml](https://www.radford.edu/ibarland/Manifestoes/whyC++isBad.shtml)
I don't understand your perspective, if someone takes one week to understand a hello world in C how would he/she even make games in a week in some other programming language. Sounds bs to me. Don't you feel you are exaggerating too much. Understanding the programming principles is same for any language I believe, and that's what we intend to do.
Which is easier, reading a file in C or reading one in python?
My school starts with Java
That's going to make things more difficult. I think the key is try to create interest, make something that they can be a bit proud meanwhile learning. I am not a teacher btw, maybe I am speaking gibberish
I just learned C from my Uni as the first programming language. Rough, but really good to learn about pointers and memory management from a computer scientist perspective.
On Windows the definitive book to do such things is "Programming Windows" by Charles Petzold.
Interesting reading
The language invented by Dennis Ritchie, described in the second edition of *The C Programming Language*, and processed by most compilers *when optimizations are disabled* is useful for teaching and illustrating many aspects of how small microcomputers and microcontrollers work, since it can be used as a form of "high-level assembler". Some of the reasons it became popular are alluded to in the Spirit of C [all quotes from the published "Rationale for International Standard—Programming Languages—C Revision 5.10"]: &gt; Some of the facets of the spirit of C can be summarized in phrases like: • Trust the programmer. • Don’t prevent the programmer from doing what needs to be done. • Keep the language small and simple. • Provide only one way to do an operation. • Make it fast, even if it is not guaranteed to be portable. The language that is actually defined by the Standard, however, is not suitable for such purpose. Although the authors of the Standard have expressly stated: &gt; C code can be non-portable. Although it strove to give programmers the opportunity to write truly portable programs, the C89 Committee did not want to force programmers into writing portably, to preclude the use of C as a “high-level assembler”: the ability to write machine-specific code is one of the strengths of C. It is this principle which largely motivates drawing the distinction between strictly conforming program and conforming program. the Standard leaves the question of whether to support such usage up to implementers' judgment, and some compilers like gcc and clang interpret that as an opportunity to regard any code requiring such semantics as "broken" and arbitrarily change its behavior. It is thus important to distinguish between the language the Standard was written to describe, and the one it actually defines.
Then this class is pointless.
I have finished teaching my annual class on C programming last Friday. We have a concept where there are (a) lectures explaining the theoretical concepts and then (b) exercises to practice programming. The focus lies on the exercises. The students are supervised while solving them and can ask questions if they are stuck. The exercises are all written such that there is no exact solution. In each exercise, the students must think about what they want to achieve and what kind of solution they are satisfied with. I believe this teaches valuable skills for professional programming work. The exercises are not graded but students are welcome to review their code with the teachers. Feel free to ask further questions.
&gt;TempleOS Thanks! I had never heard of that so I had to look it up. I'm tempted to try it out, I always love weird operating systems.
Teaching them Python or Java in a week won't be much better, if at all.
This may not be your goal but I would recommend a more straightforward language like python or modern javascript. C can be frustratingly low level as a first language.
In one week in python, you should be able to at least input and output text and numbers, and do simple calculations. You can probably also write simple loops and do something useful. In C? Forget about it.
Now you have two problems and things to teach. 1) They need to know how computers work and they don't. 2) You want to teach them C which is intimitly connected to how computers work.
I wish I could try :) Wish you luck: if you had any choice you'd do so much more with Python
I'd make simple examples, show how for loops work, how if statements work. Show the differences between float and int types. What is unsigned? What is an integer overflow? Show what happens when the wrong variable type is used (infinite loop). Initialising variables (structs) properly so you are not starting to use the garbage that is stored in them if they are not initialised. Some simple logic/binary arithmetic will certainly not be harmful. I would not go into libraries/header files/ and compiler flags more than necessary. Compiling with gcc -Wall -Wextra should also be sufficient to work on the compiler warnings to help get things right.
For windows you can follow [this walkthough.](https://docs.microsoft.com/en-us/cpp/windows/walkthrough-creating-windows-desktop-applications-cpp?view=vs-2019) It's a complete guide how to make the "Hello world" in a desktop application, even before you have your ide setup (they are using visual studio). If you don't want to use vs you can use other ide with another compiler but you need to target the windows SDK. Ignore the C++ in the guide cause it's actually everything in C. Create your file code as .c instead of .cpp and you are good to go.
Wikipedia should tell you just about all you need to know to implement http
The standards have the most accurate information just google "HTTP rfc" there are a few I think. You can use **netcat** to play with it a bit by pretending to be a browser sending a request to a site, and also pretending to be a server serving a page to your browser. Example: At a shell use netcat to listen on a random port (1234 in this case, you can use 80 but it is usually reserved) `$ nc -l 1234` goto your web browser and load [http://localhost:1234](http://localhost:1234) you will be able to see the request from the browser in your terminal, you can then reply with something like HTTP/1.1 200 OK Content-Type: text/plain Connection: close Content-Length: 6 hello The first part is the header used to tell the browser about the content the server is about to send it, for instance you can see the status code 200 and the length of the content, then two line breaks are used to signal that the next bit the "hello" is the content. You should now be able to see "hello" in your browser. There is also another example at [https://en.wikipedia.org/wiki/Hypertext\_Transfer\_Protocol#Example\_session](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Example_session)
Try checking out historical CS50 lectures available online through Harvard. It's a zero-experience-required course that starts with C. Contrary to other commenters, I found this to be an amazing first language, personally.
Why would Bourne code be so different in design from the **older** Thompson code that looks like more modern C code? O_o
I would aim the goal at creating a madlibs game or other similar type word games in order to keep people motivated. It would cover basic flow, logic, and IO. That should be enough to get people to do serious stuffs for later on. Try to use basic functionality as much as possible and avoid GUI. Another possibility is text adventure or hang-man, if your students are elementary grade. Build the pieces you need for a functional game over time to teach them how to reuse and organize their codes.
&gt; literally has every good programming practice a language could have. Allow people to confuse ints with enums and a large foundational set of undefined semantics?
I'm taking an intro to C course currently and can tell you things I like and don't like about it, if that would help. First off, the book. We're using *Programming in C* 4th ed by Kochan. I'm not a huge fan, personally; I really don't like the way the author explains things. Conversely, I've acquired a copy of *C Programming: A Modern Approach* and much prefer it. It has a conversational tone and the author is very easy to understand. I don't know if you have control over assigning textbooks, or if you even plan on using one, but I would not recommend the first book. Secondly, my teacher introduced function much earlier than the textbook did, right after decision trees and loops as opposed to after arrays and pointers. This was both good and bad, it was good because we got more comfortable with them as time went on, but bad because the book didn't always have examples (or at least very many of them) utilizing functions in the array and pointer chapters. Which somewhat coincides with my third point: Third, lack of example problems. We would typically create one program in class and make a few iterations to it. It'd start with the barebones and add functions and other stuff over the course of the class period. I feel like using multiple examples for each different iteration would have been better. Though I do have to say my professor might have chosen to teach this way due to class contraints, it's a 6p-9p 16 week class that meets on Monday. Fourth, class pacing. We spent the same amount of class time covering decision trees as we did on arrays. If possible, I definitely feel like cramming the easy stuff like general overview of variables, printf()/scanf(), decision trees and control loops in the first class or couple classes so that you can focus more time on arrays, pointers, strings. Anyways, that's it off the top of my head. I saw your teaching undergrad and that's where I'm at, it's just a 2000 level class, so hopefully my criticisms of my class can help inform you on what may or may not appeal to your future students.
As an embedded C programmer I would definitely teach another higher level language since they're there just to learn programming in one week. I'm currently teaching C to someone with almost zero experience programming and it's truly a burden to explain both high level and low level stuff, if it were for me I would teach that person Python first and then C.
API. Cocoa and WinAPI respectivley
You're so close to being right, and yet so far. &gt; Understanding the programming principles is same for any language I believe, and that's what we intend to do. Say that again, but slower. Look, I have two Computer Science degrees from a top-10 university. And what I liked about studying there was that while people who graduate from bootcamps and lesser schools might put on their resumes "I know Java and Python", we would put on our resumes "I know Computer Science". The concepts and the underlying math and logic are what matters, not the language, because every programming language obeys the same laws of discrete mathematics. Once you learn basic structures like if-statements, for-loops, and fundamental data structures like arrays, lists, and objects, you can pick up any programming language, recognize how it implements those familiar structures, and learn to read and write code using that language. That's not to say that every language is equal. Some make things very easy, and some make them hard. C gives you no memory protection, no automatic memory management, hardly any data structures, and requires a lot of work to accomplish tasks. Other languages where you can just `import graphics.lib` can accomplish very complex goals while requiring the programmer to write much less code. And you say this yourself. "Understanding the programming principles is same for any language." So why are you going to pick one of the hardest languages for a crash-course where students will barely have enough time to pick up the basics? &gt; if someone takes one week to understand a hello world in C how would he/she even make games in a week in some other programming language That you would even say something like that makes me question your abilities in this matter. If you're so unfamiliar with other languages as to not realize how easy it is in languages like Python and Java for beginners to implement something like tic-tac-toe in a matter days, I don't think you're qualified to be deciding what language should be used to teach beginning students. Get off your high horse and listen to what everyone in this thread is saying. Is this about teaching students and leaving them with a short but sturdy foundation on which to begin building their understanding, or is it about you having a favorite language that you refuse to acknowledge has limited applications?
Possibly controversial opinion: You mentioned that you would be teaching undergrad students, so I assume that they have a solid understanding of algebra. That being said, I would recommend that you start them with high level, functional code, where they don't need to worry about looping, complex control flow, variables, global state, etc, and slowly introduce them to lower level code. As a disclaimer, I'm not a teacher (though I'd consider going into teaching if I wasn't terrified of other people). However, I think it may be best to ease them into programming by giving them code to work with at a high level, like foreach, map, etc, concepts that should be fairly easy for them to grasp from their background in mathematics, and then over time introduce them to what's under the hood.
I found this when I was trying to do it on mac. https://github.com/rgl/minimal-cocoa-app
&gt; why does EVERY SINGLE UNIVERSITY teach another language first? My uni teaches Python in the introductory CS courses, and while it is very useful for teaching OOP, I think it can cause some problems that teaching C could avoid. Specifically, while *most* memory management is abstracted away in Python, there are some weird quirks that arise because of the fact that *everything is a pointer*, and that's kind of a hard concept to explain to people who have never programmed before. You would also have to explain this in C, yes, but it's at least explicit in C. An example of this: a_list = [None] * 3 a_list[2] = 10 The list will be [None, None, 10] as expected. However, if you decide you need a list of lists, you get into trouble with this method, and it's not exactly clear why if you don't understand pointers and how Python actually implements variables a_list = [ [None] ] * 3 a_list[2][0] = 10 The list will now be [ [10], [10], [10] ] because when you create the list in this manner, it uses the same reference for every element, meaning you have 3 copies of the same list. So if you want a list of lists, you have to initialize it differently than if you wanted a list of, say, integers. And there are plenty more examples of how these sorts of things in Python can confuse beginners. At least with C, you don't have to worry about pointers if you don't want to. Don't get me wrong, I enjoy using Python and I think it's a good language to learn first, but I think you could learn just about any language to start, depending on the person. Some people—myself included—would prefer to learn a language like C or C++ to start.
I'm going to infer from this comment that you are a) unfamiliar with Python, and b) have never taught a class to program before. I'm both a C and Python coder, and I've taught both professionally (JavaScript and SQL also, for the record). In productivity terms, I'd say without exaggeration you can cover roughly a whole week of C in less than an afternoon in Python and have students doing useful practical stuff literally *immediately*, starting with using Python as a calculator and working up from there. You can get absolutely get complete beginners coding (very) simple games with 2D graphics and sound after a week of Python with a simple game library, or crunching through CSV files and processing/visualising data. This would take weeks or months in C, and be much more difficult to teach. Yes, it really is that much more productive. But you haven't really said what are the goals of the course? What do you want students to be able to walk away with? To get them started as systems programmers? To teach them a useful practical skill? To pique their interest in programming as a subject to pursue later? ... what? C is not necessarily a bad first language, but it depends on the goals of the course. I've been coding C for nearly 30 years now, and I believe that every programmer should learn C at some stage. I love C. But scant few beginners will get anything useful from a one-week C course, unless the plan is to prime them for a longer subsequent C course.
Even university has introduction class for literature students. And I happened to attend that class, and they didn't even get to the class part(OOP part) with Python. They just explained how to program, how to execute and what is variables. I think the main purpose of class like those is **keep students interested in programming**.
I just don't care for these arguments. That's like saying culinary schools shouldn't let students use knives and stoves because you can cut or burn yourself. Learning environments are supposed to be rife with failure. Failure is undoubtedly the best way to learn. Let me get my segmentation faults, teach me why they happened, and teach me to not write faulty programs. I understand why a company wouldn't want their engineers writing C code in 2019. But given that many popular modern languages are descended from C (Java, Rust, Swift, Go, etc), it's really useful as a first language.
I've been helping teach highschool kids programming for a few years. You need to be thinking small and simple, then go simpler again, loops should be stretch goals, functions, loops, and complex types like arrays are out of scope for one week. I assume your goal is to give them a taste. Anything else will probably be unrealistic. The very basics are going to be alien to them. Using a fixed subset of the language to instruct the computer, breaking a problem down to the simplest logic elements, using variables. Even interacting with a computer program in a text prompt environment will be a new experience for some. Think very carefully about the process of getting the hello world program compiled and executed. Make sure it is well documented and as simple as possible. Having to physically help every student get their compilation environment up could burn most of your week.
It's like saying if you want to be a mechanic, you should learn how to change oil before you try to design an engine.
My degree program started with a class in Java and for everything else you had to learn C on your own.
You probably should though, and it would be weird not to.
OOP in Python is no fun. I much prefer to use a language more meant for that. When I took my first intro programming course, we glanced over how Python could do it, but never actually used it.
I would consider giving out an ungraded assessment to see where most of the class stands on programming concepts. C will be extremely frustrating for people who have no idea about programming. I would do light coverage of the under the hood working and maybe an exercise utilizing pointers, but I wouldn't go too far beyond arrays, control flow, variables and assignment, etc. I would touch on structs to give them a taste of pseudo-OOP, and maybe unions if you're digging a little deeper into memory and such. C is not a good language to teach someone programming who has never written a hello world in any language, just because you will not get a good taste of what C offers and the functionalities under the hood in just one semester if you're also teaching the basics of programming alongside it. But, if that is no concern to you, C is just as good a language as any- in fact it will give your students a taste of more realistic syntax.
Something bugs me about threads where these "X language is better than C for beginners..." Why? How is an OOP language like python or java where everything is a class easier? People say things like this, but from my own experience I struggled for years with python and Java. U started c++ and things began to finally unwind in my head, but I still couldn't understand the supposed benifits of OOP. Then I decided to try C, and it's been heavenly. It's small, it's logical, it's easy to debug, it's easy to see where issued are, it's easier to read than all of those other languages. I think the 'C is so hard OMG' shit is 99% not understanding memory and 1% missing some built in container or array or something. I have found C to be orders of magnitude easier to understand and use.
Could we get these questions
It's not that I'm unfamiliar or incapable to teach other languages. But, as I already mentioned picking one was not in my hands either. I've been given this humongous tak of teaching C, I understand it's hard but it's not impossible. That's why I thought I would ask the redditors for tips and suggestions. But, idk why everyone thinks this is r/changemyview post, maybe this goes for a meme in r/lostredditors. Jokes apart, sorry if was adamant in defending the real purpose of this thread. Please, if you can't help it, at least don't worsen it.
&gt; standard idiom Makes sense to a programmer. Not to the hardware.
Low level and cross platform are usually mutually exclusive. If you want low level, use the system APIs. If you want cross platform, use SDL. There isn't really anything that satisfies both.
It may be useful to write or find some libraries that implement some basic functionality that you can teach your students to use. Abstract everything but the fundamentals away from them and give them something to work with.
Your `subjects` variable is an array of 1000 pointers to `char`, it can't store chars. You need to allocate memory to store the actual chars for each string and save the pointer like this `subjects[i] = buffer;`. Your last printf needs to be inside a loop and it should be like this `printf("%s\n", subjects[i]);`
I learned C as my first language in a class. Best tip from me would be to write a string class and a printing class for them that hides the nastiness of pointers, and let them use it for the first part of the class. Because strings are necessary for a lot of basic programming lessons (which all tend to end in printf's), but pointers are really hard to grasp early on, this lets students focus on the basics. Then, unravel the mystery of pointers and show how the char* in the string class work. They'll be thankful you hid char* from them at first, and be more ready to take on the task of understanding memory management after they have the other basics of C down first.
The getLine function collects input from the user and then checks if it is the end of file character (EOF) or the new line character (‘\n’). If the character it receives isn’t either of these and it hasn’t exceeded the limit it’s been given it adds it to a string. If it reaches a ‘\n’ or EOF it will terminate the for loop before adding the character to the string. However after the for loop terminates the variables used will stay as they were when the loop ended. So they then check if it was the ‘\n’ character that ended the loop and if it was they add it onto the end of the string along with the null character ‘\0’ that signifies the end of a string.
 int getLine(char s[], int lim) { // Create two uninitialized integers // Since i is created outside the for loop, we can continue using it outside / after the for loop int c, i; // Loop from i = 0; to i = lim-1 (not including lim-1) // Only continue the loop if this condition is met: // (i&lt;lim-1 and (c=getchar()) != EOF and c != '\n') // - i must be less than lim-1 // - call getchar() and that char must not be equal to EOF (end of file character) // - that char must not be equal to '\n' (new line character) // Store each valid character read into the array s at the index i for (i=0; i&lt;lim-1 &amp;&amp; (c=getchar())!= EOF &amp;&amp; c!='\n'; ++i) { s[i] = c; } // If the last character read is newline if (c=='\n') { // Store it into s[i] s[i]=c; // Increment the index ++i; } // Store a null character into s[i] s[i] = '\0'; // Return the last index we used return i; }
If you understand french, there is a website that has a nice format for beginner lessons (in all IT fields) It's called openclassrooms
C is a very simple language. Keep it that way. The only "scary" thing for beginners are pointers and those can be tricky to explain clearly. Take extra time on this topic and make sure students understand pointers before going forward. Do not teach them to use *scanf() for reading user input or ato*() for number conversion. Check array boundary in every example, even the simplest possible. Good luck!
Ok so i is used three times. In the first one in the for loop, I get that i is from 0 to lim-1. However, what is i in the if loop? Does i continue from where it left off in the for loop? Or does it start again from 0?
It is a great project that you have! How I learned it in my school was to start with small exercises to learn the basics (variables, conditions, loops) like said in other comments. Then go on with pointers, arrays, recursion, dynamic memory allocation... Always based on practical exercices. We had to code some functions from string.h and were not allowed to use any function other than system ones (write, read, ...) and malloc. Coding your own library of string manipulation is a nice way to learn I think. &amp;#x200B; Good luck!
The part where you explained about i especially made sense to me. Thank you!
The comments helped me a lot! Thanks for the detailed response!
Not in public as I want to avoid solutions for them floating around the internet. It took me a while to come up with exercises for which no solutions could be found on the internet.
One approach is to have separate platform files for each platform that get you to a point where you can write the rest of your code in a platform agnostic way on top of those platform files. In terms of building the program its a case of compiling the windows platform file for windows, the mac one for mac, etc. If you search around you can find tutorials on how to do this.
The hardware prefers this idiom as well. Yours is extremely wasteful of physical memory and increases cache aliasing.
Here is a fun task: calculate the minimum levenshtein distance between a string and a regular expression. This will introduce you to finite state automata.
both codes have a typedef. i haven't checked with a compiler, but you could likely change line 5 to `struct ListNode* next` (you need the `struct`). the `ListNode*` is in line 1 because that's what you're defining a typedef for. that's what `List` "means". second list: yes. they are equivalent.
Thank you! Very helpful. The only thing that is still unclear is why, in snippet 1 line, you'd have to use ListNode\* instead of simply ListNode?
The typedef states that you are creating an alias name for a type. The type, in this case is "struct ListNode\*", and the alias for it is "List". The typedef in the second case functions basically the same. It's just that the full definition of the struct type is expressed inline. You could use "struct ListNode\* next;" in either example (with the '\*') and not use the typedef. But that gets tiresome to type, so people like to use the typedef to create the alias. The '\*' states that you're talking about a pointer type, and the pointer is a pointer to the type that comes before it. Something of type "List" is a pointer to something of type "struct ListNode". You definitely want a pointer here. If you didn't have a pointer, then you'd be telling the compiler to allocate an instance of the struct inside itself, which is not possible, and the compiler will give you an error. And, yes, the '\*' serves the same purpose in both examples. The difference between the two examples is mostly style. They function almost equivalently. The one difference is that the first style does give you the ability to place the struct definition in a different location than the typedef. That can be useful in some contexts. For example, you might have a context where you only need to talk about the pointer to a list (ie. a variable of type List), but you never need to dereference the pointer. You can design your .c and .h files such that some .c files can see the struct body and others can't. This can enable implementation hiding to create better abstractions. Finally, I'll correct you: the first example is not using mutual recursion. There's only one type referring to itself. Mutual recursion would be if you had two (or more) structs with fields that are pointers to each other.
Hi, I don't know about a book for C game programming, but game development is more about algorithm stuff rather than lanuage specific features. I'd suggest taking a look at Pico 8 to see how basic pixelated games are done and you can also take a look at this barebones C based game I made based on what I found from Pico 8 https://gecko05.github.io/2019/02/09/nucleo-squashy-part1.html
because the alias you're defining is a pointer. you don't *have* to do this. you could define it without, but then you would need to add a "*" when you use it (for the meaning of the code to remain the same).
All the other comments a correct so I'll just add my 2¢. The typedef defines `List` as a pointer to a ListNode, which i personally find somewhat confusing. What I would do would be more along the lines of one of the questions you were asking, where you define a node type (not a pointer), then your second struct item would be `node* next`. ie overall typedef struct Node { int item; node* next; } ListNode; This way matches in my head more with what a linked list is a bit better, and also gives you a type for individual nodes themselves which can be used later in a program.
Ideally give a crash course on computers, and how memory works and how programs are run (stack, heap, scheduling etc), keep it short and simple. Then go onto C. Problem with going right into C is somethings won't make sense, and pointers will throw them for a trip.
Thanks!
Explain cache aliasing when using the natural page size?
To add a side note on this topic: typedef struct ListNode* List; is the exact same as writing: typedef struct ListNode *List; (C Interfaces and Implementations (Hanson) page 103) In both cases, 'List' will be evaluated as 'struct ListNode*'. This threw me for a loop until a coworker pointed out that the pointer is part of the type definition whether or not you include the space. So, yeah, that is a thing.
So, basically, the \* is preventing the struct from containing itself. Instead, it contains the adress of another struct of it's own type (in this case, the next item in the list) . Thank you, this was extremely helpful! If I may ask another question, I have also seen the first line (for binary trees) in yet another way. 1. typedef struct TreeNode *Tree; 2. 3. struct TreeNode { 4. int item; 5. Tree leftChild; 6. Tree rightChild; 7. }; As far as I understand, this is exactly the same principle, a pointer to the next nodes (now plural) in the data structure. The difference I see is that instead of `TreeNode* Tree` (which would be analogous to `ListNode* List`) , we have `TreeNode *Tree` (Which would be analogous to `ListNode *List`). As far as I know, The functioning of both manners of writing is the same. Is this true? Can I use them interchangeably?
Okay, sorry for jumping on you like that, but you could have headed off the inquisition earlier rather than furthering the debate. Just tell us, "The choice of C was made by someone else and I can't change it. Given that, how should I approach this?" Even so, some more detail would help. You said this is a 1-week crash course, but how is it structured? How many hours of lecture time and lab/homework time will there be? How much prep can you do such as preparing a working compilation environment or writing labs (working Makefiles, skeleton code, etc.)? In order to make much progress, I hope the answers are "lots" and "lots", respectively.
Thank you! Funny, I just replied on u/nemotux 's comment with the question to this answer!
Glad I could be of help. It was totally baffling not knowing if the typedef I was creating was a pointer or would only be aliased when you used \*Type or I was just going crazy.
Yep, as /u/JBenzo stated, they're the same. And, you can also write it these ways: `ListNode * List` `ListNode * List` `ListNode*List` They are all equivalent. The '\*' is a separate token that is not attached to the tokens on either side of it, regardless of whether or not you put whitespace on either side of it or not. The semantics of the '\*' token in a type declaration is that it makes the type be a pointer to whatever type is to its left. That's irrespective of whitespace.
You can get pretty much there if you forward declare your structure. typedef struct _Node node_t; struct _Node { int data; node_t* next; };
Read K&amp;R C and work through the examples. C Programming Language, 2nd Edition https://www.amazon.com/dp/0131103628/ref=cm_sw_r_cp_apa_i_KsHRCbMHMDBX8
Just so you know you can put code into code blocks by inserting four spaces at the beginning of each line. Your first example is trying to use a type within its definition. The compiler hasn't yet defined that `typedef` so it doesn't recognize `Node` and you get an error at compile time. The second one uses a `struct Node` which isn't declared, but the compiler makes an educated guess that you want to use that `struct`. It doesn't require you to define it before using it like this, but it is somewhat less clear, so I recommend being more explicit. Consider one of the following styles: typedef struct node Node; struct node { int data; Node *next; }; typedef struct node { int data; struct node *next; } Node;
https://stackoverflow.com/questions/588623/self-referential-struct-definition
Do not suffix your types with `_t`. This is a suffixed reserved for POSIX types.
Sorry about that, I am used to using some stdint.h types regularly so I forgot that I shouldn't do that.
I would step back and ask why? If it's to try and save effort then you will waste a lot of effort comparing buffers (especially if whitespace dies not matter) so easier to just overwrite the file. You could check if files exists and leave it alone if it does. You could look at timestamps to guage if you want to overwrite. You can use tools such as diff? Hashing? These all take a little of effort to try and save effort, ykwim?
To answer your second question: you can close the file anywhere you make the file handle available (or file pointer or file descriptor - whatever the API you're using provides). Using the standard C file API this just means passing a FILE\* around and making it available to any part of your program that needs it.
No worries. I wouldn't even know if I hadn't made that mistake and had a good samaritan tell me the same. Sorry if my original reply sounded stern, I just mostly trying to be succinct.
Your current code doesn't have a way of `free`ing the stack at the moment. You may want to implement this. Right now you're leaking memory.
I am of the opinion that you [shouldn't cast](https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc) the pointers returned from the `*alloc` family of functions. I also don't think you need to be calling `realloc()` on every `push()` and `pop()`. It is generally more efficient to allocate an amount of memory and only reallocate when your stack is almost full, or when it's taking up significantly more space than it's using. You can use an additional member variable in `struct stack` to count how much memory has been allocated (since the `size()` function can show you how much is in use). I also couldn't help but notice that your `main()` and `pop()` don't have `return` statements. Moreover, it is generally best practice to declare `int main(void)` if it will not be passed arguments; though that is more personal preference. Hope that helps.
21st Century C and Deep C Secrets. Look and books/courses on algorithms and data structures. Explore concurrency. Check out The Linux Programming Interface.
It's not worth being able to specify an initial size if you're going to resize on every push &amp; pop. pop is declared as returning `int` but doesn't return anything.
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct stack; typedef struct stack* Position; typedef struct stack { int element; Position Next; }Stack; int Push(Position, int); int Pop(Position, int*); int main() { Stack head; //Allocation of head element; int* PopElement; // Element which is taken from stack PopElement=(int*)malloc(sizeof(int)); head-&gt;Next = NULL; //When stack is empty at start head-&gt;Next must be NULL Push(&amp;head, 5); Push(&amp;head, 4); Pop(&amp;head, PopElement); printf("%d\n", *PopElement); Pop(&amp;head, PopElement); printf("%d\n", *PopElement); return 0; } int Push(Position head, int el) { Position q=NULL; q=(Position)malloc(sizeof(Stack)); q-&gt;element=el; q-&gt;Next=head-&gt;Next; head-&gt;Next=q; return 0; } int Pop(Position head, int* el) { Position q=head-&gt;Next; head-&gt;Next=q-&gt;Next; *el=q-&gt;element; free(q); return 0; }
one week isn't enough
this is a very interesting read!
The declaration `int *p,q;` creates objects `p` of type `int*`, and `q` of type `int`. The declaration `int* p,q;` will do likewise. Even though it would appear visually as though the type is `int*`, only the first declared object would have that type.
Nice — but did you actually try that in your compiler? (Note that `node` is never defined.) However, you *could* simply do this: typedef struct Node { int item; struct Node *next; } ListNode; In fact, you can also do this: typedef struct ListNode { int item; struct ListNode *next; } ListNode; because `struct ListNode` and `ListNode` don't collide in the symbol table.
Yep, and stylistically, it's a choice you can make. Old-timers will remind you, however, that it's safer to always put the `*` next to the variable name rather than the type name...otherwise you'll be bitten by things like: int* a, b; which declares `a` to be of type `int *` and `b` to be of type `int`. If instead you write: int *a, b; then it's clear what you want.
You're fragmenting memory and lining everything up on page boundaries instead of spreading it out. You're allocating a minimum of one page of physical memory for every single string or whatever instead of fitting as many as possible in each page. You are wasting physical memory and reducing cache efficiency for no reason whatsoever. Lining data up on page boundaries is not required for efficient access. Lining it up on word boundaries, or at most cache line boundaries, is enough. And the compiler and allocator take care of that for you.
You want /r/cpp_questions or /r/learnprogramming. This sub is for C, not C++. Please post the code you have so far, and make sure to format it properly for reddit or use a 3rd-party host. And maybe it's just me ... but I'm not sure what you mean by massifs/number groups, so a more complete description of what you're trying to do is appreciated.
Thank you for the explanation 😃
Looks like a fun optimization task. I don't have time to look at potential optimizations now, but I did run into a crash when sending a lot of data into the program. Here's [a patch that should fix it.](https://gist.github.com/michael-grunder/70b88a078be08116fa874051863c47b4)
Usually when you need to track file changes, you either keep some separate hash of the content you expect it to have or just go with mtime (which is not great, but will usually suffice). Mtime is the easiest; you can check the output from `stat`/`fstat`/`lstat` to get it. But writing to a file isn’t atomic, so if anything else happens to be rewriting the file while you are, you can get data corruption. (Avoid doing this; any design that relies on multiple simultaneous writers to a single file is liable to break badly. If you need parallel communication, use pipes, FIFOs, or sockets.) Other things can crop up if (e.g.) somebody writes new data to a new file, then replaces the file you have open with it; you’re left in a file with no name, so without closing and reopening you can’t see any of the new data. If you want to read things for comparison/hashing, `fread` is a better bet than `fgets`, because you don’t care about line endings and you want to be able to catch NULs having been inserted into the stream. Also make sure your file is opened in binary mode, or some platforms (e.g., Windows) will convert CRLF pairs to LF and vice versa, which could ruin a binary compare. If you want to close a file, you need its specific `FILE *` as returned from `fopen`. If you aren’t opening and closing within a single function, you’ll need some way for the `FILE *` to escape so that something else can close it. Usually that’s either in some struct, in a global (boo), as a return value, or via out parameter. `fclose('all')` would be really, really, really wrong, and I’m not sure why you’d come up with that. `fclose` takes a `FILE *`, which `'all'` isn’t; `'all'` is a rather implementation-defined integer constant which you’re asking the compiler to coerce to a `FILE *` for some reason. The compiler should howl about this; if it doesn’t, enable more warnings. You can’t just throw random stuff like that into a file and expect it to compile and work. Nobody’s defined an `fclose`-like function that’d accept something like `'all'`, and you shouldn’t use constants like `'all'` in anything remotely portable. All open files will be closed when your process terminates, so that’s about as close to what you want as it gets.
Howdy, I'm a mathematician and computer scientist who works with distributed systems for the purposes of modeling systems that have ranged from physical to mathematical. I can't help but be intrigued by your problem, but I'm not sure what to recommend. Clusters that I work on tend to be owned by universities and research groups, so I can't help but feel like a VPS may not be the right fit for your use case. What are you trying to do? What leads you to believe that you need a distributed system? In what way is your processor falling short? I see you have experience with GMP and presumably some GPU acceleration (nVidia), but do you have experience with MPI or similar interfaces that help facilitate distributed computing?
Yeah! It's a small enough problem that it's perfect for nerding out. Thanks for the fix, I've added it above
Well I do many things, but one thing to give you an example would be to scan for every prime number that is 70-bits in length. My current computing can do this up to about 40-bits but now it'll take weeks to get the next bit-length. I do lots and lots of simple calculations that just require lots of bit manipulation, low memory requirements (size and bandwidth), etc.
Crap, should've definitely usedbthe `ListNode*` type for next. A great example why you shouldn't write stuff late at night whenbyou should be asleep!
Thanks!
Thanks! I'll look into all of these.
use pwritev with a reasonable ( MAXBUFSIZE) buffer size instead. putchar must adhere to stream sequencing. There is a reason \_unlocked is nonportable.
Don’t bother with K&amp;R, it is too old to be a good first book on C and will teach you bad habits. Read 21st Century C.
As you are using fputc_unlocked() etc, you probably realized that locking and buffering in stdio is in fact the bottleneck. If you want even better performance, you can reduce the calls to stdio by creating your own buffered I/O. See the program at the end of this post. Timing on Linux: yours=0.061+0.003 (user+sys sec); mine=0.034+0.003. On Mac: yours=0.078+0.015; mine=0.037+0.004. #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { int i, j, k, n = 0, max = 0, max_len = 0, bufsize, off; size_t max_line = 0; ssize_t len_line; char **list = 0, *buf, *line = 0; // read words while ((len_line = getline(&amp;line, &amp;max_line, stdin)) &gt;= 0) { if (n == max) { max = max? max + (max&gt;&gt;1) : 16; list = (char**)realloc(list, max * sizeof(char*)); } max_len = max_len &gt; len_line? max_len : len_line; line[len_line - 1] = 0; list[n++] = strdup(line); } // print bufsize = max_len * 2 + 2; bufsize = bufsize &gt; 0x10000? bufsize : 0x1000; buf = (char*)malloc(bufsize); for (i = 0, off = 0; i &lt; n; ++i) { int li = strlen(list[i]); for (j = 0; j &lt; n; ++j) { int lj = strlen(list[j]); if ((li + lj) * 2 + 3 + off &gt; bufsize) { fwrite(buf, 1, off, stdout); off = 0; } memcpy(&amp;buf[off], list[i], li); off += li; memcpy(&amp;buf[off], list[j], lj); off += lj; buf[off++] = '\n'; memcpy(&amp;buf[off], list[i], li); off += li; buf[off++] = ' '; memcpy(&amp;buf[off], list[j], lj); off += lj; buf[off++] = '\n'; } } fwrite(buf, 1, off, stdout); free(buf); // free for (i = 0; i &lt; n; ++i) free(list[i]); free(list); return 0; }
Nice post. A couple of production problems in the past I already wish I'd fixed then with what I learned later; and now I specifically add these two plus /u/attractivechaos' technique to that list.
for starters you never assign a value to N. also instead of posting a screenshot, it is preferred that you post the code directly (I believe with 4 spaces at the start of every line it gets formatted as code), that way people can copy and paste it. Now you say your function isn't working, why? Does it not compile, does it not give you the output you expected, does it throw an error at runtime?
b[0],[0] =1983021082 b[1],[0] =4199136 b[0],[1] =-426461471 b[1],[1] =4199136 Process finished with exit code 0
N isn’t assigned any value so who knows what you’re iterating to. Also your transpose function doesn’t return anything.
Did you try assigning a value to N (probably 2 in your case).
I think he's just printing the matrix to see if it worked, but yeah not assigning N is probably the issue.
isnt he also assigning to the input (a) from a uninitialized array (b) ? Seems reversed.
oh good call, didn't catch that
also as /u/refermen73 mentioned, you are assigning values from b to a, rather than from a to b, and b is uninitialized. Seems you have several issues with using uninitialized variables. when you compile try using the flags `-Wall -pedantic`, they may catch that (not sure, haven't written C in well over a year).
It's possible that while the compiler is evaluating the strict, the compiler classifies it as an "incomplete" type. Compilers may vary on how they deal with this (I think), but the compiler would need to know how much memory the interior struct would occupy, before the compiler has finished processing its definition. The compiler can, however, allocate the space for a pointer at any time.
This is great, and beats Go on my MBP. It's becoming rather absurd, but I was able to trim a couple more ms off the runtime by [keeping track of the line lengths](https://gist.github.com/michael-grunder/22a2569e28dbb0cd90021891f928761d) Benchmark #1: ./double2-release &lt; list.txt &gt;/dev/null Time (mean ± σ): 34.9 ms ± 1.7 ms [User: 29.2 ms, System: 4.3 ms] Range (min … max): 32.1 ms … 43.3 ms 100 runs Benchmark #1: ./double3-release &lt; list.txt &gt;/dev/null Time (mean ± σ): 32.7 ms ± 1.3 ms [User: 26.9 ms, System: 4.5 ms] Range (min … max): 30.1 ms … 37.5 ms 100 runs
I love small problems like this to gather puzzle pieces on for later use!
This is awesome! Thanks for taking the time to out it together. I learned a lot reading it. I haven't read that much C code yet, bit this is the first clear example of rolling your own buffer that I've seen. Very helpful. What steps does this buffer skip that an stdio function would use? ... Or in other words, why is it faster when in theory they both buffer then write.
Wow. That site looks like your typical blog spam site, but the content is actually decent.
For the next time: please do not post pictures of code. Always post code as text instead.
r/C_Programming and C++ in title? r/cpp is the place to go
N has no value If assigning a value won't make everything better, post the code as text and I'll try to help
Parse input and verify it before conversion or try to convert it with `strto*()` and check for errors.
MAX\_IOV is 1024 on my system, FreeBSD 10. With normal words, one writev(2) doesn't quite put out enough data to be fast with file output. Cheap in user time though :)
int head; (index, not a pointer) would simplify things a bit.
Enable compiler warnings, read them, and heed them. You should get at least three from this code.
Just a nit, but why are you using `sizeof(uintptr_t)`? What you're allocating is an array of pointers, so why not just use the size of that pointer type? Not least because `uintptr_t` is not guaranteed to be the same size as a pointer. I highly recommend getting in the habit of using foo *p = malloc(n * sizeof(*p)); rather than foo *p = malloc(n * sizeof(foo)); as it would have prevented the mistake /u/codeallthethings pointed out, as well as any ambiguity regarding the size of `uintptr_t`.
It's inline and mostly branchless, whereas `fputc()` and `fputs()` are almost certainly library functions.
Both examples are incorrect. The first tries to use a type called `Node` before the end of its definition. The second references a `struct Node` which is never defined. The definition works because the compiler doesn't need to know what `struct Node` looks like to know what a *pointer* to `struct Node` looks like, but you will not be able to dereference that pointer without a cast. You can use one of the following constructs: 1. typedef struct Node Node; struct Node { int data; Node *next; } 2. struct Node { int data; struct Node *next; } typedef struct Node Node; 3. typedef struct Node { int data; struct Node *next; } Node; Note that `typedef` and `struct` names are in separate namespaces, so `Node` and `struct Node` can both exist in the same program and even refer to completely different types.
Show us the code.
The second example is incorrect since `List` is not yet defined at the point where you use it to define the `next` member of `struct ListNode`. Also, when defining a pointer or a pointer type, you should stick the `*` operator to the name, not the pointed-to type, to reflect how the compiler interprets it. It makes no difference to the compiler, but it misleads the reader. For instance, this: int* a, b; will most likely be interpreted by the novice (or even unwary intermediate) as “define `a` and `b` as pointers to `int`” whereas in fact it means “define `a` as a pointer to `int`, and `b` as an `int`”. The following makes it clear that the `*` applies only to `a`: int *a, b; The rule of thumb is that declaration reflects use; `int*a` should not be read as “define `a` so that `a` is an `int*`” but as “define `a` so that `*a` is an `int`”.
i'd go as far as (with gcc) -Wfatal-errors -pedantic -Wall -Wextra -Werror as ya know what I know this has saved me no end of wasted time in the long run....
Why `-Wfatal-errors`? I'd much rather get a complete list. And `-pedantic` is more trouble than it's worth, especially for beginners.
&gt; but the content is actually decent. Thanks.
GCC is not finding the file containing \_get\_string. You will need to find the directory with the header files for cs50 library and use the -L flag to include this directory in the build. The GitHub web page states that the cs50 lib is install in /usr/local, so I would look there and find out what the full path to cs50 is.
Thanks MR2Rick, is she resolved, it was an issue in OSX of the symlink not being created correctly, all working now!
Ever heard of Curses?
Overkill for what the author is trying to achieve. The original post does exactly what it says on the tin and no more.
think of it as a base 26 number and start counting....
each to their own, I prefer not to be flooded with a bunch of console spam to wade through, generally I tend to fix one problem at a time.... in the long pedantic actually saves time, writing sloppy none standard code could be the worst habit for a new coder...
I haven't read the source code of fputs_unlocked() etc, but I guess they do extra work such as error checking. In general, libc functions are robust but sometimes at the cost of efficiency. When libc functions are the bottleneck, rolling your own implementations can be faster.
This is completely useless as a reply. I was not asking for a way to iterate through the 26 characters, that wasn't even part of the question. I asked what a succinct way to succinctly iterate through a string of VARIABLE LENGTH. A short and sweet way of handling variable length, rather than simply having an if statement for every single possible length, each containing a for loop... if (length &gt;= 1) loop a-z at the first index if (length &gt;= 2) loop a-z at the second index if (length &gt;= 3) loop a-z at the third index if (length &gt;= 4) loop a-z at the fourth index if (length &gt;= 5) loop a-z at the fifth index if (length &gt;= 6) loop a-z at the sixth index Is not pretty code. It's not succinct, and I am asking for an alternative, not a reply from someone who clearly didn't read the question in the title, let alone the actual post.
Looking at your code, I'm not even sure you understand the problem you're trying to solve. The comment above was more to the point than your solution if it's about permutations. Pro tip: if you want people to be nice to you, be nice to them. It's pretty simple.
But it **is** an increment of a base 26 number. When you look for the digit to increment, you have to carry over anything below it. while (p &gt;= buffer &amp;&amp; *p == 'z') *p-- = 'a';
could you reword your requirements I'm not clear what you actually wanted I thought you wanted to iterate from a to zzzzz ??
Useful and minimalist. I like it.
If you've got a foundational knowledge of C, the next step is to work on some personal project in C. A toy project, something you might not necessarily release but something that gets your programming chops going. Writing a simple shell or text editor would be good ones. I really liked this tutorial on building the kilo editor. https://viewsourcecode.org/snaptoken/kilo/ After that, look for an open source project that interests you and start contributing. (this is the step that I have not taken yet, but I am still looking. So you're not alone, friend). Good luck!
If this is homework, we're not just going to give you the answer. That doesn't make you a better programmer. That said, a little context other than "here's the code, help me" would be nice.
Are you not understanding how a for loop works or are you confused on the syntax of c?
its not homework dude, need help for other reason. please ?
im not familiar with c. just took the c course in my uni and need help with this one.
Okay so what part are you not understanding about the code, since you know what a for loop is and how it works, so that I can try to explain it to you.
I second this! If you want to be a good programmer, write code as often as possible! Automate things. Reimplement things that already exists. Find an open source app/library that you are using and look at the top issues on github.
&gt;s = s + a; &gt; &gt;printf("%d",s); what does these mean ?
Output will be 15 &amp;#x200B; On my compiler this code works, however you didn't specified main function return type. For example: int main() &amp;#x200B; First you make declarations: int a; int s = 0; (notice that only s is equal to 0) &amp;#x200B; Next you make a loop. It will work 5 times. Each iteration will make "a" increase by one and add it to the s value; s + a = (this is how it works, but in every iteration "a" is increased by 1 and "s" have a new value); 0 + 1 = 1 1 + 2 = 3 3 + 3 = 6 6 + 4 = 10 10 + 5 = 15 \------------------------ for(a=1; a&lt;=5; a++) s = s + a; &lt;-- note that this loop don't have any braces so it only execute s = s + a; \------------------------ &amp;#x200B; This is how I would type this code to make you understand it: &amp;#x200B; \#include &lt;stdio.h&gt; **int** main () { **int** a; **int** s = 0; **for**(a=1; a&lt;=5; a++) { s += a; // this is equal to s = s + a; printf("%d iteration is equal = %d\\n", a, s); // } printf("End result of sum = %d\\n", s); //prints end value **return** 0; //tells the program if everything compilled fine } &amp;#x200B; ps. Sorry for my bad english.
Ok, well first: main should return int. And get in the habit of putting curly braces around blocks of code used with control flow structures like for loops. Makes your code clearer and less prone to hidden bugs. Like this: #include &lt;stdio.h&gt; int main() { int a, s = 0; for (a = 1; a &lt;= 5; a++) { s = s + a; } printf("%d", s); return 0; } Compile with: gcc -o main \[source\_file\_name\].c Run with: ./main Result: 15 (with no newline after, so the terminal prompt prints right after your programs output. &amp;#x200B; What are you having trouble understanding?
I see. Cool idea!
Thanks Mate.
https://github.com/rby90/Project-Based-Tutorials-in-C make games compilers a minikernel anything even another language
Add the value of a to the previous value of s and store the result in s. Then print the result. (s)
I work as an embedded developer within industrial robotics. If you ever applied to a job at the company I'm working for, it would be expected that you have a decent understanding of electronics and are capable of doing electronics QA alongside embedded development. If I were you, I would buy myself a development board such as ST Nucleo or Microchip Xplained, a handful of sensors, and get yourself hacking. Inspiration: https://hackaday.io/lists
Make an Led blink and then try controlling the Led through a PCIe interface. Bonus if you implement your own PCIe on an FPGA / SoC.
I already bought stm32 and udemy course about it :))
I will check that for sure. Thanks!
Since you are interested in embedded computing have a look at RIOT. It’s a really cool open source project with the aim to implement a real time os for embedded computer. They are „big“ enough for you to learn a lot about embedded programming and „small“ enough to have a lot of basic stuff missing which you could implement :) invest a few bucks in some embedded boards and start to write small applications until you are used to riot. Afterwards you can have a look into their open issues on GitHub and try to contribute.
21st Century C and Deep C Secrets. Look at books/courses on algorithms and data structures. Explore concurrency. Check out The Linux Programming Interface.
Header files don't have any code in, that's essentially what makes them header files. The code is what gets compiled as whatever library the headers are associated with. When you build binaries that use functions from a library, you will include the header(s) provided by it so that when you compile your code the compile knows the signatures of the functions you're trying to use.
To put it very simply, header files contain your function prototypes. In the header file, another C file is included that contains the implementation of those functions. The key here being understanding what a prototype is and what an implementation is.
The C and C++ "macro language" doesn't work like C itself. That accounts for at least half of the criticism of C macros. It's not wrong criticism, but the macro language is what it is, and it can do anything that needs to be done. You can send your own code through the C Pre-Processor `cpp` to see how it expands the macros. Start by doing this with a piece of code that doesn't `#include` any system header files, because those will expand to thousands of lines in many cases. cpp practice.c | more The extra parenthesis you often see are because C programmers love the Lisp programming language. Just kidding! They're there because they guard against certain kinds of unintended effects by the pre-processor. Best practice today is to use macros infrequently, and judiciously, but to use them when you need them. Due to newer and more-uniform POSIX support today, we use fewer feature-option and feature-substitution macros than we tended to use in the past. You can use `const` variables for things that might otherwise be `#define` constants; the `const` variables are typed and more flexible in certain ways (less flexible in others). People are often advised to use [`inline` functions](https://en.wikipedia.org/wiki/Inline_function#C99) instead of using macros to insert functions. Most of the macros I've been writing recently are for Windows support and platform portability: #ifdef _WIN32 # include &lt;winsock2.h&gt; #else # define _XOPEN_SOURCE 500 /* For snprintf(). */ # include &lt;string.h&gt; # include &lt;sys/socket.h&gt; # include &lt;arpa/inet.h&gt; # include &lt;unistd.h&gt; #endif /* _WIN32 */
So that means the implementations are already compiled, and what header files do is to tell how you can use them.
&gt; a bunch of console spam to wade through That's what IDEs are for...
Also, read the printf reference and it may make things like printf("%d",s) a little clearer [http://www.cplusplus.com/reference/cstdio/printf/](http://www.cplusplus.com/reference/cstdio/printf/) https://alvinalexander.com/programming/printf-format-cheat-sheet
The prototype is a map of the city, and the implementation is the city itself.. did i get it right.
When you are writing code, do you sometimes use #include &lt;something&gt; or #include "something.h" ? those are header files being included into the current code you are writing. Header files can technically contain any c/c++ code but are most often used to specify macros, constants, statics, prototypes, classes, structs.. Most people, when they are first starting out, aren't doing anything complex enough to warrant writing in multiple files.. so let me post an example: &amp;#x200B; header.h #define MAX 512 bool getTrue(); &amp;#x200B; header.cpp #include "header.h" bool getTrue(){ return true; } &amp;#x200B; ProjectA.cpp #include &lt;iostream&gt; #include "header.h" using namespace std; int main(){ if(getTrue()){ for(int i = 0; i &lt; MAX; i++){ cout &lt;&lt; "This example is pointless" &lt;&lt; endl; } } return 0; } &amp;#x200B; If we look here, we have a header file that defines MAX and the prototype getTrue. 'getTrue' is then defined in header.cpp - then we have a main function in another file that uses both MAX and getTrue by simply including the header.h file. &amp;#x200B; So what do people use this construct for? Well in software development, sometimes we only want to expose as little as possible - show the client developer only how to use the function (eg. the prototype in the .h file), not how the function is implemented (the function definition in header.cpp).. Headers are not compiled - they are included into other files at compile time. &amp;#x200B; Hopefully this helps a little.. Happy to clarify anything if I didn't make sense.
But files like header.cpp are already compiled, aren't they?
Yes header.cpp is compiled and the resulting file can be paired with header.h in the compilation of other files
Got it bro/sis , thanks for the quick response.
Real world application. If you need to youtube/stackoverflow/reddit until it works, do it. Make something useful.
Exactly. If the project you're looking at is open source, you'll also be able to see the implementation code, e.g. the various functions provided in `string.h` have their sources here: https://sourceware.org/git/?p=glibc.git;a=tree;f=string;h=9be80755f065866e30fce37acdaaee88bb6fa63e;hb=HEAD
Thanks.. now i've got a plan for this weekend.
you have not uninitialized the variable d before using it.
Liking the re-poster's user name. Also: neat content. I did the Harvard CS50 online course and there's the final project. I was thinking of doing a somewhat eclectic minimal shell. This may prove to be rather handy.
Now learn git, and start hacking on a practical project. If you're interested in robotics, then https://index.ros.org/doc/ros2/ could be a good starter.
They do have code in them (otherwise they’d just be comments, presumably), and they may even have code that generates output artifacts (e.g., inline functions).
'code' wasn't the best choice of words I admit, but in the context the OP was using it it makes sense. There shouldn't be anything that gets executed at runtime in headers though.
Inline functions, contents of macros
I tried assigning a value of 0, if that’s what you mean, but it didn’t change the outcome.
Macros aren't executed at runtime. What do you mean by inline functions?
 foo *p = malloc(n * sizeof(*p)); This is a great trick. I'm surprised it's not more common.
It is *extremely* common.
Macros are expanded at compile-time, but their *contents* may execute at run time, which is why I said “contents of macros” specifically. (In the same sense, global declarations and definitions “run” at compile-time, but the bodies of function definitions may run at run-time.) You can use keyword `inline` in ≥C99 and ≥C++98 code to include function bodies in the header without them colliding at link time. Theoretically, if you don’t mind occasional warnings about things unused, you can define `static` things in a header as well. And of course, if you’re not intending the header to be available for general use, you can do any number of terrible things, since it’s just clumsily pasting text together. You can include a header inside a function body, inside a parameter list, inside a compound initializer, inside a subexpression… The only limits are set by our Dark Lord Cthulu, may His unsightly tentacles rip away all beauty that makes us give a fuck about living.
It's certainly less common than this: double *ptr = sizeof(double); Also pretty clearly the minority [on GitHub](https://github.com/search?p=12&amp;q=%22%3D+malloc%28sizeof%22&amp;type=Code)
Hey bro, come over to r/Electricalengineering and r/embedded. Buy a STM 32 and okay with it . Arm microcontrollers are the best way to get good at embedded. Source : Hardcore Electrical engineering student with a love of C programming
Read the Object Oriented Programming in C book by Axel Schreiner.
Linux kernel has plenty of places where code is directly in a header file. Maybe that's just "advanced" usage tho.
horrid things, get in the way, code much faster without unneeded complications like that....
I absolutely love you for posting this resource. It looks incredibly good for learning! I'm a few months into programming and honestly, this looks to be perfect for me as well. There's a lot to learn from something of this scale.
Once you know one language good I would say that the next logical steps are algorithms and larger project handling. Algorithms are rather straightforward. Find articles about algorithms, and practice implementing them. I would recommend CodinGame, codewars, advent of code etc and use the exercises there for practice. &amp;#x200B; Handling larger projects includes learning build systems, version control, testing tools, static code analysis etc. In my experience this is somewhat more valuable than algorithms for embedded software development, even though both areas are good to master. It might be harder to practice this, as there are not the same plethora of exercises to here. As a good start I would recommend learning Makefiles, as that is something that pop up a lot in embedded development. &amp;#x200B; If you got an stm32 based board you might want to take a look at Zephyr OS, as that can give you an indication on what a larger project might look like, and at the same time it seem to be relatively well described. This can also be used to bridge the gap between software and electronics. In combination with Zephyr I would look into CMSIS, a thin layer of defines that allows you to access registers etc on most, if not all, arm based processors
You can get rid of nested loops if you use recursion. Try rewriting the case for exactly 5 characters with recursion and after that, you'll see that your ifs will disappear as well and can be replaced with a for loop.
This is where I found the kilo project, btw. Some other stuff in here that might be good to chew on, too. https://github.com/tuvtran/project-based-learning/blob/master/README.md#cc
Pretty much. The prototype lets you know that it is there, what arguments it takes. It is more like a map to the city. The implementation is the map of the city.
Here's a version that does what you want: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #define MAX_LENGTH 5 void recurse(char* prefix, int level) { size_t offset = strlen(prefix); char new_prefix[MAX_LENGTH + 1]; strcpy(new_prefix, prefix); for (char c = 'a'; c &lt;= 'z'; c++) { new_prefix[offset] = c; new_prefix[offset + 1] = 0; if (level &gt; 0) { recurse(new_prefix, level - 1); if (level == 1) printf("%s\n", new_prefix); } } } int main(int argc, const char** argv) { char prefix[MAX_LENGTH + 1] = ""; for (int i = 1; i &lt;= MAX_LENGTH; i++) recurse(prefix, i); } This program prints 12356630 lines. If the strings may be ordered a bit differently, the program becomes a bit simpler: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #define MAX_LENGTH 5 void recurse(char* prefix, int level) { size_t offset = strlen(prefix); char new_prefix[MAX_LENGTH + 1]; strcpy(new_prefix, prefix); for (char c = 'a'; c &lt;= 'z'; c++) { new_prefix[offset] = c; new_prefix[offset + 1] = 0; if (level &gt; 0) { recurse(new_prefix, level - 1); printf("%s\n", new_prefix); } } } int main(int argc, const char** argv) { char prefix[MAX_LENGTH + 1] = ""; recurse(prefix, MAX_LENGTH); }
okay so you've basically asked exactly the same question again, without being clear on what you actually are looking for.... #define MaxChars 12 void display(char* s) { int i=0; while (s[i]==' ') { i++; } printf("%s ",&amp;s[i]); } void doCount(int n) { if (n&gt;MaxChars) return; char str[]=" \0"; str[MaxChars-1]='a'; int done=n; while(done!=0) { display(str); str[MaxChars-1]++; done=n; for (int i=MaxChars-1;str[i]!=' ';i--) { if (str[i]&gt;'z') { str[i]='a'; if (str[i-1]==' ') { str[i-1]='a'; } else { str[i-1]++; } } if (str[i]=='z') done--; } } display(str); printf("\n"); } void main() { int n; n=2; doCount(n); printf("\n------------\n"); n=4; doCount(n); } so this probably isn't what you're looking for....
The recursive approach is the natural approach for these kind of problems, but sometime you don't have the luxury of big stack etc. So it's well worth knowing how to describe how to solve this without recursion. It's worth pointing out that the compiler generally does a better job than the developer in optimizing the code, so it's in general a good idea to focus on readability. Among others the compiler is sometimes able to unroll recursive calls for you. Anyway, you can also write this without recursion: ```c int main(void) { char str[MLEN]; memset(str, 0, MLEN); for (int c = 0; c &lt; 100; c++) { int i = 0; bool cont = false; do { str[i] = MAX(str[i] + 1, 'a'); cont = str[i] &gt; 'z'; if (cont) { str[i] = 'a'; i += 1; } } while (cont); printf("%s\n", str); } return EXIT_SUCCESS; } ```
hi first problem that i see is that you create a variable d without assigning a value and than add d to sum. this is undefined behaviour.
`strftime()` prints date in whatever format you want. `strptime()` parses date from whatever format you have. You tell it what format is by supplying the format description. You can find details in documentation.
First of all, it's important to identify which kind of C dialect you're using, since the language has diverged into two families of dialects: 1. Those based on the language Dennis Ritchie invented and described in the second edition of The C Programming Language, which process many actions in machine-dependent fashion and are suitable for low-level programming, or... 2. Those based purely on C89, C99, C11, or C17, none of which make any attempt to mandate support for everything necessary for low-level programming (or any other particular purpose, for that matter). If you're wanting to do low-level programming, you need to make sure that you're using an implementation that's set up to process the first kind of dialect. Trying to run low-level code on implementations of the second family will sometimes work, but will be prone to failures without rhyme nor reason. As for why you'd be getting 800000000, that seems weird unless you are either using the wrong level of indirection somewhere (e.g. one too many or two few asterisks) or an "optimizer" is assuming that you won't be attempting to do any of the forms of low-level programming for which the Standard doesn't unambiguously mandate support. I think a problem with the level of indirection is more likely, but unless your implementation supports low-level programming anything would be possible.
For some reason I thought inline was a GNU extension, didn't realise it was in the standard. I'd still feel more comfortable with that sort of thing in a .c file rather than a header but that's just personal preference.
I find the advice in this article rather boring. I have learned nothing from it.
I agree. But I believe these basic tips useful to some of the readership of this subreddit. It's not only the most challenging subjects that are worth talking about.
Considere where you calculate `d` and where you use it.
Sorry for the delay on this. Finding every prime at that size is going to be exceptionally time prohibitive. Even with a [good algorithm](https://github.com/kimwalisch/primesieve) and numerous cores it can [take years](https://www.quora.com/Is-it-possible-to-generate-primes-upto-2-64-using-algorithms-like-sieve-of-Eratosthenes). That's not meant to discourage you. You should pursue this project however you can, and I hope you do, but I would feel remiss if I didn't warn you first: if you're just trying to generate prime numbers for the sake of it, this is going to be tough and time consuming. If you are trying to work with prime numbers at that scale, it may be better to use a [Fermat](https://en.wikipedia.org/wiki/Fermat_primality_test) or [Miller-Rabin](https://en.wikipedia.org/wiki/Miller–Rabin_primality_test) primality test to discover probable primes, and then use verify their primality with a list of smaller primes. That smaller list would be on the scale of ~36 bits, which is still pretty big, but it's far more doable. I hope that helps. Number theory is not my specialty, and while I like to program prime number generators as a kata, my expertise in this particular field is relatively limited, so there are likely better methods than those I've described here.
**Fermat primality test** The Fermat primality test is a probabilistic test to determine whether a number is a probable prime. *** **Miller–Rabin primality test** The Miller–Rabin primality test or Rabin–Miller primality test is a primality test: an algorithm which determines whether a given number is prime, similar to the Fermat primality test and the Solovay–Strassen primality test. It was first discovered by Russian mathematician M. M. Artjuhov. Gary L. Miller rediscovered it; Miller's version of the test is deterministic, but its correctness relies on the unproven extended Riemann hypothesis. Michael O. Rabin modified it to obtain an unconditional probabilistic algorithm. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Learn rust 😜😜. I’m just kidding in bad taste. I’d try to figure out what you still don’t know and make projects around that. For instance, if you’re not very comfortable at doing things with files, make a program around files. If your data structures are really lacking, work on that. Personally I think this all becomes more fun if you can see something on the screen. Look into SDL2 or something like that. Good luck!
A critically important piece of advice which the article ignores is to recognize that enabling optimizations will cause many compilers to process a dialect of C which is never designed to be suitable for low-level programming and consequently isn't. Given something like: uint32_t volatile tx_count; uint32_t volatile *volatile tx_pointer; void start_sending_data(uint32_t count, uint32_t *dat) { tx_pointer = dat; tx_count = count; } there would be some execution environments where the act of writing `tx_pointer` and `tx_count` might make information stored at `*dat` to become at least temporarily observable by the outside world, and some where it would have no such effect. It would have been wasteful to mandate that implementations treat actions on `tx_pointer` as sequenced after actions on `*dat` when targeting environments where the effects of doing so wouldn't be observable, and the authors of the Standard thought that the marketplace would be better able than the Committee to recognize how implementations targeting various execution environments should most usefully handle `volatile` qualifiers. Unfortunately, some compiler writers interpret the Committee's lack of a mandate to treat all accesses as sequenced relative to `volatile` accesses as a judgment that no implementations should be expected to do so even when intended for low-level programming in execution environments where such actions could expose buffers to interrupt handlers, DMA controllers, etc. using release/acquire semantics. In a typical pattern like the above, the main application will only access `tx_count`, `tx_pointer`, and anything that would be accessible via `tx_pointer` at times when `tx_count` is zero, and the interrupt will only access those things when it's non-zero. Effectively, the main application releases those things to the interrupt by storing a non-zero value to `tx_count`, the interrupt acquires those things by observing a non-zero value, the interrupt releases those things by storing a zero value, and the main application re-acquires them by observing that zero value. On an implementation like MSVC which supports acquire/release semantics for `volatile` objects, the use of such objects will be sufficient to avoid race conditions. On an implementation like gcc or clang, however, the only ways to avoid race conditions are to use compiler-specific intrinsics or disable most optimizations.
Awesome, this was all helpful. It looks like everyone had the same thoughts regarding variable d, I had to get it out of the loop, but also assign a value. Previously, I had either moved the variable out of the loop, or assigned it a value of 0, but not both. Also, I moved the sum = sum + d line to the bottom of the loop, now it calculates correctly. &amp;#x200B; Thanks so much, everyone!
* [Microsoft provides a minimal `Generic.c` here](https://msdn.microsoft.com/en-us/library/aa383690.aspx). I have a slightly older version with a separate `Generic.rc` file split out. I was only able to find this one because I had a copy of the link; I suspect Microsoft may be trying to replace this C code with the C++ example given by /u/Gblize. * [Here's a simple template one for Win32 with MinGW.](https://www.transmissionzero.co.uk/computing/win32-apps-with-mingw/) * [Here's one with the old X11 Xlib](https://archives.plil.fr/henyxia/tweekd_gui/raw/155f7ac19f7521b5febb0b43ab15b67f80804296/main.c), but I think most people would advise someone to use XCB today, or a higher-level toolkit. * [Here's a minimal C example for Win32.](http://www.winprog.org/tutorial/start.html)
It actually doesn't take too long: Fast Primality Testing for Integers That Fit into a Machine Word But that was also just an example. I meant that I am not doing Machine learning, or Database stuff, or things that require lots of memory or data storage. I am just iterating through number fields looking for interesting properties that other people have not found or thought of yet. I have found quite a few interesting things so far, but it would be better to mine the larger number fields to make sure these patterns hold true for more numbers. I already use GMP and related stuff for very large prime numbers (10kbits and larger) as well.
There is a GNU inline extension, as well as the standard `inline`s. Pre-C99, GCC added support for `inline` (non-mode-dependent keyword `__inline__`) using a slightly different scheme than the later (proper) C99 inlines would use, both using a different scheme than C++ uses because of course. So in pre-C99 modes or if you’re using old GCCs, `__inline__` makes “GNU inlines,” and in C99 modes (`__`)`inline`(`__`) makes C99-style inlines. In practice it means you have to do some light trickery if you want things to work in all three modes. For non-C++ inlines you do still need a .c file with a copy of the functions, in case the compiler opts not to inline some of them. IIRC for the GNU inlines, you do the non-.c varant with `extern __inline__` and the .c variant with just `__inline__`, and that’ll home the latter to whatever object’s generated from that; for C99, you throw a copy of the declaration (body optional) with `extern inline` in front of it in the .c file. Which seems like a lot of work, but once you have the infrastructure in place it’s no big deal, and it gives you a nicer scheme than macros or statement expressions for inlinable code.
Too late to tell you what to study, it seems. Get a good night's sleep, leave time for a good cup of coffee in the morning, and stick to what you know as much as possible. I'd also tell you to be honest about what you know and what you don't, though others may disagree. In the past I've hired plenty of people with gaps in their knowledge who were aware of those gaps, and honest about them; I've also sent plenty of people packing who tried to blow smoke up my ass about what they knew.
I do still have some days to a week before the interview, but it does seem like a lot to learn in such a short time. The position is asking for a bit more than I felt I could give but they reached out to me so I want to give it my best shot since it's basically my dream job. Great bit about being candid though. I'll be upfront.
Also eat a good breakfast with some protein.
Thanks. I was thinking oatmeal.
Very cool! I'll be sure to read the full paper. Sorry to misunderstand your needs and for not being able to say whether or not a VPS would be a good fit. I imagine that people do use AWS or GCP for high performance computing like you need, but I've never tried it and tend to prefer having physical access to my machines. Keep me updated on your research though; it sounds interesting.
I saw your post in /r/golang and thought about writing a C version as well. I compiled yours on FreeBSD and as you identified, you used some glib specific functions so I changed those so I could compile it. To my surprise my go version was faster than the C version. I plan/planed to use raw write calls instead of fputs and increase the buffer size to see if I can get the C version to be faster.
And orange juice. Need that vitamin C! I'll C myself out.
I also can't use array
If you want to accept all of the input before printing any output, you have to use an array (or similar).
How many C developers use gotos exclusively and don't know about for and while...?
http://www.drdobbs.com/parallel/volatile-vs-volatile/212701484
If I post something, I try to make my question clear without forcing everyone to google it: \- Post a link to the caesar cypher logic \- Post your code Your goal is extremely easy to achieve (without knowing how the cypher works), if you don't have any code yourself, go for some basic tutorials.
Use a printf statement to see what 'A' + 4 is.
For reading lines, it depends how robust you need to make the code. Because this is for an assignment, it sounds fine to me to figure out the longest the line can be and just have a local array. For safety, read the line using `fgets` and make sure the line ends with a `\n` and exit if it doesn't (this was your program won't misbehave). Structs themselves don't really impact performance although how you access memory can (read [What Every Programmer Should Know About Memory](https://people.freebsd.org/~lstewart/articles/cpumemory.pdf). If you know the input is always from a file, reading it twice is fine. But if possible, doing everything in one pass is more flexible as it allows you to handle not only files but streaming data (which can only be read once). The standard way would be to `realloc` your buffer as you need more data. A common trick is to double the size of the buffer each time you need to realloc so you don't have to realloc for every record you read. It sounds like you haven't even started your assignment yet. Get that done first and then decide if you want to do extra credit.
Specialize in something. Generalists make the best engineers, imo, but people don't hire someone with good I/O, systems, and algorithms skills, they hire someone with React Native experience. Pick something and take a junior position somewhere. Someone suggested git. Would be great and easy to put on your resume.
As far as storage goes of the Chars in the loop, do me a favor and look at an ASCII table with binary representation. Then go look up the the binary representation of a 64 bit number. Now as far as the actual Cipher goes, we'll need a little more information. The Caesar Cipher has a defined start and end, and defined characters contained within. While ASCII does have this, there are plenty that aren't great at being printed. Has your instructor given you any parameters on which characters to include? Are all ASCII values used? Are both Cap and non Cap?
Right. I got the point, thanks :)
Well first of all C and C# are very different languages. You want r/csharp my friend! I wish you the best in your journey.
I’m currently learning how to program in C# by making video games in Unity. Having a goal and a purpose makes the whole process much more enjoyable.
Oh right well ok thanks anyways
Go make something you want or need.
The POSIX [getline()](http://man7.org/linux/man-pages/man3/getline.3.html) function is handy for robustly reading lines of arbitrary unknown-in-advance length from a file. You can certainly directly fetch files over https through a program written in C (With libcurl, among other options), and decompress them, but often it's orders of magnitude faster and easier to implement, and more flexible to use existing utilities and include your program as the final step of a pipeline in a shell script. Something like curl https:/your.url/file.gz | gzip -dc | yourprogram (Where your program would read from standard input instead of a file in this case)
Looks like they did much interesting work besides this tbox which are worth looking at (eg a build system)
Its the way you have written your accept function. The return type is struct actor, but you are not collecting it in main. Instead you are passing variable a to the function, which is an error because that function does not have any parameters. Solution: In main, change the function call to a=accept();
/\* SET A 1.Create a structure actor with ano,actor name,age and movie name.Write seperate fucntions to accept the details and display actor details.\*/ &amp;#x200B; &amp;#x200B; \#include&lt;stdio.h&gt; \#include&lt;string.h&gt; //create a structure struct actor { int actorNumber; char actorName\[20\]; int actorAge; char movieName\[20\]; }a; //structure varibale is a &amp;#x200B; &amp;#x200B; int accept(struct actor\*); //accpet prototype.......here \[struct structurename functioname();\] void display(struct actor\*); //display prototype &amp;#x200B; int main() { struct actor a; printf("Now you are in main.\\n"); accept(&amp;a); //call accept to accept the structure display(&amp;a); //cal display to display the structure printf("You are back in main.\\n"); &amp;#x200B; return 0; } &amp;#x200B; int accept(struct actor\* b) //accept defination............here the same as prototype no need to pass a varibale { printf("Now you are in accept.\\n"); printf("Enter the following details.\\n"); &amp;#x200B; /\*printf("Enter Actor Number.\\n"); //you can accept the details in one line.I have used this for more readability scanf("%d",&amp;b.actorNumber); &amp;#x200B; printf("Enter the Actor Name.\\n"); //howerver there is some problem here scanf("%s",b.actorName); &amp;#x200B; printf("Enter the Actor Actor Age.\\n"); scanf("%d",&amp;b.actorAge); &amp;#x200B; printf("Enter the Movie Name.\\n"); scanf("%s",b.movieName);\*/ &amp;#x200B; printf("Enter the actor Name:\\n"); scanf(" %\[\^\\n\]", b-&gt;actorName); printf("Enter the actor Number, Age,Movie Name\\n"); scanf("%d %d %\[\^\\n\]", &amp;b-&gt;actorNumber, &amp;b-&gt;actorAge, b-&gt;movieName); getchar(); return 0; //structure varibale being returned is b you can use any other ariable name.Try a. } void display(struct actor \*c) { printf("You are in display\\n"); printf("Actor Number=%d\\tActor Name=%s\\tActorAge=%d\\tMovie Name=%s\\n", c-&gt;actorNumber, c-&gt;actorName, c-&gt;actorAge, c-&gt;movieName); //display the contents }
C# is off topic in this subreddit. Please post C# questions to /r/learncsharp instead.
Familiarize yourself with r/programminghumor, it's more real life than you might imagine.
Thanks for the help! I am currently using `getline`which I believe automatically resizes the buffer if necessary. The reason I'm reading the file twice is because I am using the struct definitions above; so I'd like to read a text file of integers `m, n` into my `graph` struct, and resize the `graph.nodes` array to the number of nodes in the text file. I could do this in one pass, but in order to create the adjacency list, I first need to set the `node.number_of_neighbors` (graph.nodes[i]) to 0 and malloc the neighbors array the first time a node is seen. The way I am currently doing this is essentially: // read the text file to set graph.number_of_nodes graph.nodes = malloc(graph.number_of_nodes * sizeof(*graph.nodes)); rewind(file); // initialize nodes for (i = 0; i &lt; graph.number_of_nodes; i++) { graph.nodes[i].id = i; graph.nodes[i].number_of_neighbors = 0; graph.nodes[i].neighbors = malloc(0); } if (file) { while (memory_read = getline(&amp;str, &amp;size, file) != -1) { int u_id, v_id; readline(str, &amp;u_id, &amp;v_id); // read current line into u_id and v_id node *u = &amp;graph.nodes[u_id]; node *v = &amp;graph.nodes[v_id]; u-&gt;number_of_neighbors++; u-&gt;neighbors = realloc(u-&gt;neighbors, u-&gt;number_of_neighbors * sizeof(*u-&gt;neighbors)); u-&gt;neighbors[u-&gt;number_of_neighbors - 1] = v_id; v-&gt;number_of_neighbors++; v-&gt;neighbors = realloc(v-&gt;neighbors, v-&gt;number_of_neighbors * sizeof(v-&gt;neighbors)); v-&gt;neighbors[v-&gt;number_of_neighbors - 1] = u_id; Sorry if it's not totally clear what I mean here. I can clarify if necessary. And I agree, it would be nice if I could get this done in one pass, because I could also read from stdin to create the graphs. Because I don't believe it's possible to have a default struct value (and my graph is just an array of user structs), I think I must do two passes, because I need to set each node.number_of_neighbors to 0 initially and malloc the node.neighbors array.
Thanks! I didn't think about piping with curl in a bash script. That will be much easier, and I'm going to need to write a bash script to run some tests anyway.
As I think back to when I first started learning C after starting with higher level languages, I realize that C only came into focus for me when I truly understood how the computer works. I would start a class like this with a simple demonstration of how the computer works so they can visualize it. You are the CPU. Assign tasks to each student in the class. Some are RAM locations, one is the bus, others are functions, one is the monitor, etc. Then put a simple C program on the board (do they still use chalk boards in school?) Something like this: int main(int argc, char * argv[]) { int i; char j[] = "odd"; char k[] = "even"; for(i = 1 ; i &lt; 10 ; ++ i){ if(i % 2 != 0){ printf(j); } else{ printf(k); } } return(0); } Assign these tasks to various students. One is the variable i. One is the variable j. One is the variable k. One is the function printf. You are the CPU. You start by giving i the value 1. Then you do the remainder operation on the contents of i by asking for the value in i, dividing it by 2 and checking if it equals 0. (Yes, I know there is a way to do this with less code. This is to simplify the explanation) If the remainder is 0, you tell the student who is j to give its contents to printf and printf then writes the contents of j on the board (the monitor). Then you add 1 to i, and check if it is less than 10. Continue through the loop 9 times and the students should have a pretty good understanding of what is going on under the hood. You can do similar demonstrations with more elaborate code. This is a good way to introduce pointers. One student is the pointer, another student is the region of memory pointed to. The student who is the pointer literally points at the correct student to access the memory there.
What makes it better
Wrong subreddit... This sub is only for C (not C++). Secondly, when talking about a "camera" you really, really gotta specify what libraries you're using, otherwise no one knows what you're talking about.
What you are trying to do would just jump to 0x90909090. You need to add something more to the buffer where it will overwrite the return address.
That can totally be done in a single pass. I'll give you some of the code but you'll need to figure out how to add it to your existing code: int new_num_of_nodes = ...; if (new_num_of_nodes &gt; graph.number_of_nodes) { graph.nodes = realloc(graph.nodes, new_num_of_nodes * sizeof(node); for (i = graph.number_of_nodes; i &lt; new_num_of_nodes; i++) { // Initialize just the newly added nodes } graph.number_of_nodes = new_num_of_nodes; }
Kind of a bummer that it is "cross-platform" but the only way to build it on windows is by installing yet another build system (xmake)
If all you do is change the definition and not the code, it won't work as the pointer will have some random value so the call to `strncpy` will either overwrite random memory or if it's a null, immediately set fault. Easiest thing to do would be to replace `strncpy` with [strdup](http://man7.org/linux/man-pages/man3/strdup.3.html)
There's two problems. The most important is you're not allocating memory for the string: n-&gt;bfr = malloc(256); Even better would be to size to the length of the input string: size_t len = strlen(str); n-&gt;bfr = malloc(len + 1); // Don't forget the terminator Also, `sizeof(n-&gt;bfr)` is the size of the pointer, which doesn't help you any. Instead, you would use the length you just calculated. But since we sized the buffer to be exactly the size we need, only `strcpy` is needed: strcpy(n-&gt;bfr, str); If you can use POSIX, this can be done in one function call: n-&gt;bfr = strdup(str); Regardless, make sure you `free` the memory for both the string and the node when you're done with them (you need precisely one call to `free` for every call to `malloc`, and `strdup` counts as a call to `malloc`).
Ahh okay, thank you. When you mentioned strdup I realized we used that in the project as well. Thank you!
Thank you, you reminded me that we used strdup in the program, so that makes sense :)
I had a feeling that you always have to collect the structure in some variable when you are calling it and then pass the same variable to display.
thank you for fixing. Can you please elaborate a few lines about char movieName\\\[20\\\] and scanf(" %\\\[\\\^\\\\n\\\]", b-&gt;actorName); what is happening here. I got this: You have used a pointer to a structure where accept and display point to the same adress location and use the arrow operator to accept. Thats pretty nice.
You have to treat the struct as any other single variable. Imagine if the struct is type defined in a header file where you can't see it. Then all you have to do is declare a variable of type actor and treat it as any other variable such as int or char. Hope you get it.
Reddit screwed up my code a bit, please send me dm for explaining
I don't know why it didn't occur to me to try this. I appreciate the help!
Thank you it works perfectly fine now.
 [https://pastebin.com/1PFCqQg3](https://pastebin.com/1PFCqQg3) Now, I saw that you made struct variable when you define structure, you don't need that. Try this: [https://pastebin.com/xwzpa8Ss](https://pastebin.com/xwzpa8Ss)
You are probably expected to use [ternary operator.](https://en.wikipedia.org/wiki/%3F:#C)
without that too 😂 , its what the teacher asked
Then you should use some math trickery: if x is your first input and y second, then you could do "(x + y) == 0" which will return 1 if it is equal, and 0 otherwise.
Check out [strtok](http://man7.org/linux/man-pages/man3/strtok.3.html)
how to use boolean with that
how to use boolean with that
If you don't consider == boolean operation (even though it is), you can also do "!((x + y) || 0)", which will again evaluate to 1 if x is opposite of y and to 0 otherwise.
Check out https://www.reddit.com/r/C_Programming/comments/bbqaon/large_speed_difference_between_ubuntu_and_osx/ekldzz4/, which does that, and is faster than Go
Yeah I think strtok would be the go-to for something like this
So I think that would work for parsing the output of the bash script and splitting everything. But I think I'm struggling to get that kind of design and implementation of the JSON Array I envisioned in the OP. Anyone have any suggestions how to tackle that?
I would start by moving this post to r/cpp_questions. This community exists to discuss the C programming language, please redirect C++ related content to the appropriate subreddit.
FILE \*fp; fp=fopen("Sample\_Bash\_Script\_Test.sh", "r"); if (fp == NULL){ printf("Failed To Run Script \\n"); exit(1); } &amp;#x200B; fscanf(fp, " %s %s %s", hostname, ip, macadress); &amp;#x200B; fclose(fp);
There is no one best way to learn a language. Some people prefer reading books, others prefer watching a video while yet others prefer having a mentor.
&gt; I'm curious why I can't use a char* in this (when run, I immediately get a segmentation fault). The declaration char* str; is a pointer to a char, not a pointer to an array. So trying to write more than one letter (a string) into that memory location will give you a seg fault, as you saw. The reason why like &gt;char* str = "This is a string"; works is because you are defining a string literal (by using double quotes), which exists somewhere in memory, and then you are pointing the pointer str to that place, wherever it is. It is more intuitive to view pointer declarations as two separate lines: &gt;char* str; &gt;str = "This is a string"; This is equivalent to the one line above. -------------- In general, there are a few ways you can store a string in memory: 1) Declare a pointer to a character, and then malloc (== *memory allocate*) a spot to hold your string. This is the most general method, but is computationally expensive. Like with the string literal, you are pointing the pointer to a char at the beginning of a block that is promised to be empty somewhere in memory; here it is uninitialized. 2) Declare a pointer to a character, and then point it to a string literal. This is what we did above. I hope you can see the parallel between this and the previous option, the difference being that string literals are *immutable* -- you cannot edit the string itself via the dereference operator (which is implicitly how [] notation works). But the two are the same as far as your system is concerned, in that it only knows that str is a pointer to one character. It happens to be that there is "meaningful" information beyond that one character, but you compiler doesn't "know" how far it should be allowed access, so attempting to read or write beyond the bounds of these two options will not return an error (but must be permitted). 3) Declaring a pointer to a character array (as in your code) tells the compiler the precise number of characters to set aside in memory, so accessing anything beyond the bounds of that array will return an error. This is obviously the safest approach but requires information about the string at compile time, and is inefficient since the full array is used in memory regardless of whether you actually need it at run time.
This the C sub. I would recommend asking this in /r/learncpp.
Or /r/learncpp
Just a lil boolean magic really, return a == -b;
what return do
How did you get into this class...
I probably shouldn't have said that without knowing your skill level in hindsight. Ignoring return (because your professor should be teaching you that soon), do you understand how the actual boolean logic works?
My suggestion is : Sign in to Cousera and register for ‘Algorithm’ by Professor Sedgewick of Princeton university. The lecture provides very clear explanations on the topic as well as working codes. But the codes are written in Java. I suggest you to run the Java codes, understand them, abd translate them into C++. If you have never coded, I guess you haven’t learnt algorithms either. This might be rather hard but challenging way to learn and will return.
It's so you can use `struct HEADNAME` later on if needed, yes. There can be several different uses for that, but if you leave it empty it will be an anonymous struct and can't be referred to by type name. There's advantages to that as well I suppose, which is why it's optional.
Quick question, does it support static linking? One reason I stopped considering GLib for certain projects was because static linking [wasn't an official goal of GLib](https://bugzilla.gnome.org/show_bug.cgi?id=768215#c16) -- at least it wasn't in 2016. Anyhow, it looks good and thanks for the share!
C++, like C, has a lot of “hard edges”—little pitfalls that can prove frustrating if you don’t know they’re there. The most important ones to remember vary from person to person, so my general advice is this: Keep at it and practice, even if it’s frustrating. If it feels like everyone else is better than you, don’t get discouraged—imposter’s syndrome is very common, and it’s probably not accurate. Don’t be scared to use Google and consult resources like stackoverflow. If you’re stuck, talk to your professor or classmates if you have any questions. It can be pretty difficult when you’re first starting out, but if you stay committed you’ll realize just how valuable a skill programming is and chances are you’ll be glad you learned it.
Ok, thank you!
Hey, dumb question: what do I need to free for this example? Should I only call free on the graph.nodes array or do I need to call it on every node as well? I know as a rule of thumb each malloc should have a free.
Thanks for your reply! I’m not quite sure how I would do that, can you provide some direction?
This code is C#, not C. Try asking in /r/learncsharp. Also, try reading the error message: "The variable `average' is assigned but its value is never used". What this means is that you set the value of 'average' at least once, but you don't ever use the value.
Oh ok I thought they were the same. Thanks
It's a common enough mistake, believe it or not.
Delete everything and redownload/set it up
try removing the space in your path /desktop/c programming/ change it to /c_programming/
I would use `sprintf()` or `snprintf()` to create your JSON string.
This. Never use spaces in filenames or folder names on a computer.
Holy shit thank you. i finally got it to work on cmd. damn i didn't think that the spacing would be that big of a problem
lol too many haters. Thanks for asking the question. It's a tiny bit of trivia I can know now.
Your using the wrong exec call. Use execvp(command, args)
My assignment sheet says execve. Is there any difference?
Consider using visual studio community edition, it's free and integrated with Microsoft's compiler. It doesn't optimize as aggressively as their commercial compiler, but it's a smoother experience. Also, if you use CMake to manage your project configuration, VSCode has plugins for that, and it'll play nice with VS Studio, regardless of edition. But since you got this working, I'm hesitant to suggest you change your environment.
Just be patient (a lot) reread your code, read the error messages and try making sense of them. *Patience is very important*
In your print statement, you hard-coded the value `34.25`
A nice way to better understand these macros is to use them in a small example code and examine the preprocessed output. Back at NetApp, I implemented a C++ interface to could of data structures. We could not use C++ STL in kernel space and had to find alternatives.
Also, just in general, avoid spaces in path names. There’s all sorts of situations like this where they can cause annoying problems
As far as I Know scanf is not usable in some microcontroller envoirments. Also it would be good if you could give more details, like which microcontroller are you using (ATMEGA328P perhaps?) Or if the keyboard is the computer keyboard or a matrix keyboard hooked to the microprocessor (in which case scanf really is the wrong tool, for example).
Atmega1284
There's nothing here that illustrates the "call by value" nature of c. It's simple -- `this` is a global variable. A global variable can be modified from anywhere in the program.
Function can’t change the value of *parameters*
i'll try that out actually.
Hey, thanks for the example! I just ran this and you are right. So the call by value only works for local variables, and not global variables? Is that how I should understand this? Thanks
I'm sorry, but what do you mean exactly?
it also doesn't support c99 and is a slow chugging mess.
That's not it. There's no such magic. Given a function like `void foo(int a)`, when you call `foo(some_variable)`, a copy of `some_variable` is passed to it. Just like what happens when you assign one variable to another. A copy is made and assigned. Global variables don't need to be passed to functions because they can be accessed anywhere as they have a constant memory address. Functions have stack frames. This is where local variables live. They do not have constant addresses. Read up on computer stack and you will understand.
What do you mean a function can't modify parameters? The following function is valid and changes both the 'p' and 'count' parameters void memset(char * p; char val; int count) { while (count--) *p++ = val; }
&gt; Ideally I'd like a somewhat functional shell that could do something like traversing folders, making a file, starting a process, etc like with the terminal. I dunno how doable that is so I wanted some tips on doing that. I'm currently trying to do a command history where one can hit up or down on the arrow keys and look through previous commands, but I'm not quite sure how to print out the command while being able to backspace over it and such. Making a toy shell is very doable, though it's a really big jump from what you have done so far. Many, many tutorials exist -- I get the impression that the first thing everyone on the internet does after they write their shell is write a tutorial for the next guy. :) I liked reading the code of [the s shell](https://github.com/rain-1/s), especially interpreter.c. I found that very helpful. If you're going to do this, I would stop worrying about the prompt for now. Taking user input isn't the fun, difficult or educational part of writing a shell. Figuring out how pipes and redirections and company work is the fun part. (Parsing, depending on how lenient you are with yourself/your users, is potentially the difficult part, but no one would argue that it's fun.) Good luck! This really is a fairly huge jump from what I'm seeing in that file, but it's a really fun project.
Call by value (or reference) doesn't come in to play if you're not passing any arguments. &amp;#x200B; Given a function \`f(x)\`, "call by value" implies that \`f\` gets a copy of \`x\`, so if \`f\` tries to make any changes to \`x\`, it only ever changes the copy; not the original. Thus the function that called \`f\` will not observe changes to whatever variable it passed to \`f\` after the call to \`f\`. &amp;#x200B; In your example, \`meme\` doesn't take any parameters, so there's nothing to copy. Instead of having a function \`f(x)\` ("f of x"), you have a function \`f()\` ("f"). \`f\` would be call by value had you provided arguments to it. &amp;#x200B; Eventually when you learn what pointers are, you'll see that you can modify original values through them, but C is still strictly "call by value" as the value of the pointer is still copied. In other programming languages, sometimes the parameters are call by reference, so modifications to parameters in a child function are observable later in the call of the parent function.
Consider using fdopen instead of the dup to stdin in the parent. That's the typical way to do this, such that the parent stdio is left connected to the terminal or the parent's parent. Doesn't matter much here but worth considering for a more complex program.
Hello there. So I should understand that call by value exists when there is a function with a parameter being called?
I'll check out what computer stack is, thanks. Goddamn people weren't kidding when they said C will be harder than Python.
 #include &lt;stdio.h&gt; void meme( int this ) { this = this + 1; printf("The new this is this: %d\n", this); } int main() { int this = 23; printf("This is the initial this: %d\n", this); meme( this ); this = this - 23; printf("Final this: %d\n", this); } gives: This is the initial this: 23 The new this is this: 24 Final this: 0 *this* is passed as a parameter to the function, and any change to the parameter within the function have no impact on the callers of the function.
Hi, thanks for the example. So I should understand that call by value exists when there is a function with a parameter being called?
You received three different implementations to your last question, without any reaction whatsoever. No thanks, no upvote, nothing. All I see is harsh replies from you. How do you think this subreddit works? Hint: people are people, not robots. Maybe you're better off searching for answers on stackoverflow, or trying things out for yourself until you've gained profound understanding of the matter. That way, you can make progress with C without having to deal with people.
Yes, "call" means calling a function. Call-by-value means the values are passed to the function, not the *variables* themselves (call-by-reference). C does only support call-by-value. If we use a language that supports call by value, and call by reference (C++), you would get: (I renamed this to that, as this is a reserved C++ keyword). #include &lt;stdio.h&gt; void meme( int that ) { that = that + 1; printf("The new this is this: %d\n", that); } int main() { int that = 23; printf("This is the initial this: %d\n", that); meme( that ); that = that - 23; printf("Final this: %d\n", that); return 0; } This is the initial this: 23 The new this is this: 24 Final this: 0 Using call by reference (adding the '&amp;' in the declaration), we get: #include &lt;stdio.h&gt; void meme( int &amp;that ) { that = that + 1; printf("The new this is this: %d\n", that); } int main() { int that = 23; printf("This is the initial this: %d\n", that); meme( that ); that = that - 23; printf("Final this: %d\n", that); return 0; } This is the initial this: 23 The new this is this: 24 Final this: 1 Hope that helps.
It depends if you have a lot of time but what you can do is to follow the Shell Command Language. You don't have to implement evrything (PS2, here document and other thubgd can be a little bit difficult especially if you are alone) but just follow the lexing and parsing into an AST. And then implement redirections and basic linux builtin like exit, cd, echo. Than gonna takes a lot of time but you will learn a lot of things, especially if you try to do it without memory leaks... 😉 For testing you can make a test suit that check the difference between the behavior of your binary and the bash bibary
You have an array of two pointers to allocated memory of chars, each 5 bytes long. These memory blocks are then terminated by a null byte, that makes them "compatible" with c-string. But, at this point it is just junk.
It does indeed. Thank you very much!!
The compiler sees a possibility for optimization of a statement that has no effect. Merely "mentioning" a variable, like `a;` has no effect (as opposed to a function call), so the compiler can safely eliminate it.
 bof(char *s) { char buf[24]; strcpy(buf, s); } ouch() { puts("ouch"); } main() { char bad[] = "xxxxxxxxxxxxxxxxabcdefghijklmnop\x30\x86\x04\x08"; bof(bad); puts("back"); } That's the basic idea.
The same thing is true in Python, what output would you expect when you run this? def myfunc(b): b = b+1 print("myfunc b: " + str(b)) a = 1 print(a) myfunc(a) print(a) Python also has global variables.
ForceBru directly answered your question: this typically compiles to nothing. Though your compiler may warn about not using the result of that expression. Casting with `(void)` is the conventional way to explicitly tell the compiler you don't care about an evaluation result. (Though GCC has long had an annoying "feature" where [it will warn you regardless](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=25509) in certain circumstances.) What you've literally written is potentially undefined behavior though, and that "do nothing" line could actually have an effect on a program. Since you didn't initialize it, the value of `a` is indeterminate. However, if its type has *trap representations* on the host platform, then the do-nothing line *does* have a side effect. If `a` happens to hold a trap representation, simply reading that value is undefined behavior. The optimizer can use that do-nothing line to make weird assumptions about your program's control flow — for example, assuming that this line will never be executed since it may invoke undefined behavior. Now, `int` has never had a trap representation on any platform, so your specific example will never practically cause an issue. However, practically every C99 host does have one type with trap representations: `_Bool`. This means reading an uninitialized `_Bool` is undefined behavior, and this information is exploited by GCC's optimizer. I couldn't get GCC to do it specifically for the do-nothing line, but the following demonstrates how the optimizer will reason about it: int global; void foo(void) { _Bool b; if (global) { global = 10; } else { global = b + 20; } } GCC 8.3.0 under `-O1` or higher will compile this to: int global void foo(void) { global = 10; } But only if `b` is `_Bool`. Reading `b` is undefined behavior since it's uninitialized. GCC assumes undefined behavior never happens, so it infers that `global` must always be non-zero. It's not a stretch to for a compiler to do the same with this: int global; void foo(void) { _Bool b; if (global) { global = 10; } else { b; global = 20; } }
I guess I just suck in general since I didn’t notice this haha. Thank you for the examples, I understand the concept better now.
I figured actual functionality would be a pretty big jump. The teacher wanted to be easy going towards the end of the semester but this is laughable. I actually don't know much about pipes or redirecting so that'll be cool to look into. Thank you :)
Cool, this also sounds like a good place to start thank you!
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Do not spam.
Please don't spam.
For your history feature, unless you are dedicated to doing it from scratch, check out [GNU Readline](https://tiswww.case.edu/php/chet/readline/rltop.html)
Call by value is about how *function parameters* (i.e. what you pass to a function) becomes *function arguments* (i.e. what the function receives). Your variable `this` is neither used as a parameter nor declared as an argument, so call by value is irrelevant for how it behaves.
My advice: do not write a shell. A shell is a very complicated program to write. While doing so teaches you a lot about how UNIX works, it is ultimately a very frustrating exercise.
Note that there is no `scanf` statement. `scanf` is a function which you call. The kind of statement you use is called an *expression statement* because its purpose is to evaluate an expression.
I wonder who are using this library given that most documentations are in Chinese. The implementations of strings, sorting and containers are unoptimized and the design choice is arguably questionable. C++ STL may be over-engineered IMHO, but much part of it is highly optimized and can be relied on.
Got it, thanks!
To be fair, it's a one line install and it looks pretty good.
So, this is definitely the wrong subreddit. This is a subreddit specifically for the C programming language, not C++. That being said, /r/vscode or /r/visualstudio will probably be more helpful for your question since it's not a programming language question, but about issues with your programming enviornment.
yea seen rules after I had posted, srry. &amp;#x200B; Thanks for the info
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Sorry, I have solved this. &amp;#x200B; I did &amp;#x200B; char salt[3] salt[0] = hash[0] salt[1] = hash[1] This makes the string salt = both chars.
A string is just an array of characters terminated with a `NUL` byte. So to make a string of two characters, define an array of three characters and set its contents: char mystring[3]; mystring[0] = foo; mystring[1] = bar; mystring[2] = '\0'; /* NUL terminator */
There are probably better ways to do this, but if you want to store only `hash[0]`, and `hash[1]` in a separate string, you could use `salt = strndup(argv[1], 2)` (you will need `#include &lt;string.h&gt;`). Since `strndup` allocates memory on the heap, you will have to free this once you’re done using it (`free(salt)`). If you are on a Linux system, run `man string` to get descriptions of functions in `string.h`.
This helped massively, I was creating an array, but missing the NULL byte. So I was getting a weird output! Thanks so much or this, by creating a array of my desired length + 1 for the NULL I was able to get this working.
Note that a `NUL` byte (i.e. `'\0'`) is the same thing as a `NULL` pointer! Do not confuse these two.
Some libraries define (void) as macro UNUSED and it is almost exclusively used to suppress compiler warnings about unused function parameters. However in case if a variable is volatile(not a function parameter) then compiler has to load value from memory. So in that case (void)x; will have a "side effect" of reading x value from memory to CPU register.
C# is off topic in this subreddit. Please post C# questions to /r/learncsharp instead.
&gt; is the same thing *not*
toupper()
 if ((string[i] &gt;= 'a') &amp;&amp; (string[i] &lt;= 'z')) { string[i] += 'A'-'a'; } this check if the current element is a-z and if so it will add the needed difference from the lower to uppercase. You can look it up here http://www.asciitable.com/
You don't show how you're defining the arrays. Since arrays are typically handled as pointers to the first element, your memcpy may not be working how you think.
Thanks for the reply! If i copy your code it would be http://prntscr.com/nbhf7t . And the error would be http://prntscr.com/nbhfim
I can print the elements uppercase with this. Not replace the elements with uppercase. Correct?
You need to put my code inside of a for loop so the **i** is getting increased.
https://pastebin.com/S4Einu9Y . Take a look at the code.
Yea man, i made a silly mistake. I am new to C.Expect more of those
Should the for loop be up to what? for eg. for(i=0;,what??;i++)
toupper() takes in a character and, if an upper case version of it exists, returns that. What you then do with the returned value is up to you. Assignment using it might look like: arr[i] = toupper(arr[i]);
error: assignment to expression with array type
error: assignment to expression with array type
 printf(" %s",wordsu[i]); `%s` is for printing a string. wordsu[i] is a single character
Ok
Typo. Thank you for the correction.
No, you'll have to detect the encoding and convert it to whatever transformation format you need.
If you're just communicating between the SQLite database and the server you can ignore the existence of UTF-16 – assuming you won't need to use the win32 API with non-ascii arguments anywhere, in which case you can just use *MultiByteToWideChar* or something like it. As for handling UTF-8 in general, it depends on what you mean by "parse". For several tasks (concatenation, substring search, word replacement...) you can program the software as if UTF-8 didn't exist at all; for the majority of the functions in *string.h* the presence of an emoji in the string or the like doesn't matter. For other tasks (e.g. string truncation) you pretty much need a library (e.g. ICU) to do it properly if you want to handle all the obscure edge cases.
You create a new string large enough to contain the original string plus the size of the "characters" you want to append to it, then loop over whatever in the order you need to manually interleave them.
Your code is all over the place, it will never compile as it is right now. You should start out with a very simple hello world program and then add other function to it one by one and read up how functions like memcpy work. You can read up the documentation on cplusplus.com for those functions (it also has C and not only cpp) int main (int argc, char **argv) { char string[13] = "Hello World!"; printf("%s\n", string); //uppercase for(unsigned char i = 0; i &lt; strlen(string); i++) { if ((string[i] &gt;= 'a') &amp;&amp; (string[i] &lt;= 'z')) { string[i] += 'A' - 'a'; } } printf("%s\n", string); return EXIT_SUCCESS; }
In C an idiomatic way to iterate over a string is: &amp;#x200B; char str\[\] = "This is a string"; int i = 0; while(str\[i\] != '\\0) { printf("str\[%d\] = '%c'\\n", i, str\[i\]); i++; }
Thanks for all the help, was able to finish it and submit it. &amp;#x200B; [https://raw.githubusercontent.com/EDB4YLI55/CS50/master/Week2/crack.c](https://raw.githubusercontent.com/EDB4YLI55/CS50/master/Week2/crack.c)
I am so confused over this. I come from Python and I have a hard time in C
this, except it's optimistic on search - you really need to normalize utf-8 before searching.
Cool!
a++
Pretty much every language on the planet, including C (this subreddit) and C++ (see r/cpp)
The native encoding is only important if you want to interact with the OS API, eg. files can be stored in whatever encoding. You might be aware of this, but it's not totally clear from your post where your "input" is coming from.
&gt; normalize utf-8 before searching This depends entirely on the task, and is frequently a very bad idea – especially since it introduces security risks as the same token can be interpreted differently depending on where it's processed.
Thanks! :)
If this meme is referencing `C++` I'd just like to point out that we have no worldly idea what either of these lines will do.
In C, strings are stored as an array of chars that are terminated by the null character. Usually, a char can hold an integer between 0 and 255. Each character is represented by an [ASCII value](http://www.asciitable.com/) and the null terminator is represented by '\0' (usually zero). So, if you have: char str[9] = "a string"; This will create an array of chars of length 9: 0 1 2 3 4 5 6 7 8 a s t r i n g \0 str[0 ] = 'a' ASCII 97 str[1] = ' ' ASCII 32 str[2] = 's' ASCII 115 str[3] = 't' ASCII 116 str[4] = 'r' ASCII 114 str[5] = 'i' ASCII 105 str[6] = 'n' ASCII 110 str[7] = 'g' ASCII 103 str[8] = '\0' ASCII 0 I would recommend writing some small programs to play around with how strings work in C.
 a=a+1; a+=1; there fixed that for you....
Don't forget to set the character at index 2 to NUL!
Input and output can come from / go to the server, the SQLite database and text files on the user's PC. The application, will, among other things, parse sentences into words (which is not as easy as splitting on space characters in some languages).
Input and output can come from / go to the server, the SQLite database and text files on the user's PC. The application, will, among other things, parse sentences into words (which is not as easy as splitting on space characters in some languages). I have no control over input files, so they could be in any encoding, but output files will always be UTF-8.
arr = toupper(arr) is not possible. Neither is arr = toupper(arr[i]) or whatever you just tried. toupper takes a `char` and returns a `char`. So if arr is a `char[]` then you can not assign a `char` to arr. You can assign a `char` to an element of arr like this: `arr[i] = toupper(arr[i]);`. If this is in fact, what you tried, please provide an updated code snippit.
Thank you very much for the details.So if i have char str[5][10]. It would mean,a char of max 5 "inputs" and max 10 bytes?
[https://idownvotedbecau.se/unreadablecode/](https://idownvotedbecau.se/unreadablecode/)
str[5][10] is a 2-dimensional array. It can be used to hold 50 chars or 5 strings with 9 chars + 1 null terminator each. So if your input is a string with 9 or fewer characters each, you can use it to store 5 strings/inputs.
You don’t suck, you’re just learning. And people don’t use global variables very often (for good reason), so it makes sense you’d be confused.
thanks
Your `char` string literals are never going to be UTF-16. They will be some sort of single-byte encoding. The encoding depends on the compiler (character set, etc.). GCC and Clang will generally use UTF-8. I don't know what MSVC does. char pi[] = "π"; char pi8[] = {0xcf, 0x80, 0x00}; /* explicit UTF-8 version */ In practice this only matters if you have string literals *in your program* that contain code points outside ASCII. Any real compiler today will just produce ASCII strings otherwise and you don't need to worry about it. SQL expressions are typically just ASCII unless you're embedding specific string literals in the query (Are you sure you shouldn't be using bind parameters for this?) or using unusual identifiers for your table, column, or index names. C does have a "wide character" type and wide character string literals (`L"..."`). This depends on the platform ABI. It's typically UTF-16 on Windows and UTF-32 on POSIX. #include &lt;wchar.h&gt; wchar_t pi[] = L"π"; uint16_t pi16[] = {0x03c0, 0x0000}; /* explicit UTF-16 version */ uint32_t pi32[] = {0x03c0, 0x0000}; /* explicit UTF-32 version */ Just pick an internal encoding to use everywhere within your program and only encode on the external boundaries. I strongly suggest you use UTF-8 internally everywhere, and don't bother with wide characters. Avoid using Unicode directly in your sources unless you're sure you really need it. SQLite speaks UTF-8 as you noticed, so you won't need to encode across that boundary. The full Win32 API uses UTF-16, so you'd need to encode between UTF-16 and UTF-8. This is like a dozen lines of code and it's pretty simple.
You would likely need to detect whatever format you are reading and then convert it to some internal format (UTF-8 would probably be a good choice). As for segmentation, there are standard Unicode word segmentation algorithms: http://www.unicode.org/reports/tr29/. There is an implementation in the ICU library which might be useful: http://icu-project.org/apiref/icu4c/ubrk_8h.html#details
Thanks for the explanation! It seems I won't need to do as much conversions as I thought. Quick question, would you recommend sometimes converting char* to uint32_t* ? (Making each uint32_t a unicode character.) I feel like this would allow for easier parsing of sentences, but I'm not sure if there are better ways to do this.
Thanks! ICU's API seems to be a bit complicated, but I guess it will still be a lot easier then implementing everything myself. Thanks for the links!
This is why images should be banned by default.
UTF-8 and UTF-16 are both variable length encodings while UTF-32 is fixed length. So, in theory, an advantage of UTF-32 is that you can index individual code points in O(1) while the others are O(n). However, in practice this hardly ever matters, so it's not worth using UTF-32 and blowing up the side of all your strings. Generally the reason you're ever indexing individual code points is that you're iterating over the string. In this case UTF-8 and UTF-16 have O(1) access anyway. Where you'd want something *like* UTF-32 is when you're handling individual characters. You'll want to use a 32-bit integer to hold that character. For example: /** * Decodes the code point, advancing the pointer over it. * Sets codepoint to -1 for invalid input. */ char *utf8_decode(char *utf8, long *codepoint); /* ... */ char *p = some_utf8_string; for (;;) { long codepoint; p = utf8_decode(p, &amp;codepoint); if (!codepoint) break; if (codepoint &lt; 0) abort(); /* ... do something with codepoint ... */ }
There may well be other ways but if your system uses apt-get then use apt-get for everything you can, the databases will update, system libraries, paths etc... you use apt-get because managing it yourself is a pain in the arse. &amp;#x200B; Also in most systems you are going to need sudo to call apt-get.
I just post what I read and what I know nobody else posted on Reddit before me.
Thanks again. - learning a lot more about this
You don't technically need to do any of this. The salt is treated by crypt() as an array of 2 characters and not as a c string, so it does not need to be null terminated and will only ever have the first 2 characters used.
[popen()](https://linux.die.net/man/3/popen is an alternative to system(). I gives you control of the input/output file streams. It's not any more efficient though.
Thanks, Let me take a look at it :)
[popen()](https://linux.die.net/man/3/popen) is an alternative to system(). It gives you control of the input/output file streams of the command you run with it. It's not any more efficient though, and is Posix only.
Interesting.
Thanks for the info! Your version of looping through the utf8 string seems a lot more optimized then what I had in mind. Thanks!
Write functions to do simple and common pointer operations. Implement `memcpy`, `memset`, `strncat`, etc.
This means you could get away with just: `crypt(argv[1] + 2, argv[1])`
Follow this [Tutorial on Pointers and Arrays in C](https://sourceforge.net/projects/pointer-tutorial/files/latest/download)
Implement type safe(ish) generic data structures like Linked Lists (Stack, Queue), Trees, etc...
Thanks man! You’ve been so helpful :)
Do you *have* to do this in C? I think you’d have a much easier time in a language like C# or Python where there are native string types and standard libraries that can properly handle things that aren’t ASCII. (Also things like native networking/database support, etc.) Not saying you can’t do it, but doing string manipulation in C is... clunky at best IMO.
theres a library that provides the functionality of apt, install libapt-pkg-doc
Unicode normalisation solves this, you just need to pick the correct normalisation for your problem. NFKD will map the Greek question mark into ASCII semicolon.
Charset detection is very clumsy at least, it's better not to rely on it. Windows will tell you which character set they use on the specific computer. If using ICU, the best is to internally use ICU strings which are UTF-16.
You should really move all those function declarations out of `main`. Place them either before the definition of `main` or in a separate file. When you do this, you'll have to add arguments to those functions.
`please` `format` `your` `code`
Sort of. C doesn't check array bounds for you, and that causes a lot of pain. `char str[5][10]` could hold a maximum of 5 9-character strings, and their null terminators. But, if *you* don't restrict the length of the input, it could just as easily hold 1 999-character string that happens to also overwrite some other stuff in memory. This wonderful "feature" of C can be abused to do *bad things**^(TM)*, so be sure to check array bounds and use functions like `strncpy` instead of `strcpy`. Dealing with this issue is going to be challenging, painful, and intimidating at first, but it will either make you a better C programmer, make you love Python 1000x more, or both.
a = -~a;
Thanks, I will take a look at libapt-pkg-doc.
Thanks Pal, I will try it :)
Thanks, that's a fascinating report, I particularly appreciated the summary of the proposal evolution for those of us who don't follow the standardisation meetings. It will be interesting to see it come in. The example at the top of aliasing and optimisation was eye opening. There is a small part of my that cries out against the proposal, it does seem a bit backwards to be designing the language for the optimisers rather than the other way around. But I mainly work on low level embedded devices where I play far more fast and lose with pointers than I probably should. It doesn't look like the usage of volatile pointers will change, so business as usual for me.
remove the const
 while (fscanf(read_f, Your while loop is reading all the data from the file. `while` isn't needed - call fscanf just once in the inner loop
Show the whole program please.
RTFM. Also wrong subreddit.
Does this work with the `munmap(2)` system call?
`qsort` sorts an array, not a linked list.
Dear god. Yeah, I'm a pretty big dumbass. Welp, time to go back to googling XD Thanks a bunch!
Do your own assignments ffs. Either ask a genuine question or piss off.
Or use an array. If you don't have random access you can't sort efficiently. Maybe a linked list sounded like the easier solution at first because it's easier to make them grow, but it's going to make lots of other things harder, look into using some sort of dynamically growing array, [it's easier than you might think](https://old.reddit.com/r/C_Programming/comments/93c5kw/a_minimalistic_vector_implementation_in_50_lines/).
 char *buffer; buffer = (char *)malloc(sizeof(char) * 21); The cast is unnecessary, and `sizeof(char)` is 1 by definition. What's more, these two lines repeat the same information (the type that `buffer` points to) three times. Use this instead: char *buffer; buffer = malloc(21 * sizeof(*buffer)); although as mentioned above, the `sizeof` is redundant, as long as you're sure that the type of `buffer` will never change.
`read` is permitted to return before all requested bytes have been read if, say, it is interrupted by a signal. Normal filesystem IO is typically "uninterruptible", so a signal cannot interrupt it... however that is frequently not the case with network filesystems. Are you using something like this?
Sorry but the absolutely most likely cause is that your file actually contains only 17 bytes. Did you forget to save it? What size does ls report?
&gt; the sizeof is redundant Doubly so. `sizeof(char)` is always 1.
The input is a .txt file in the same folder as my program.
It is not the files fault, if I, for what ever reason, change 21 to 40, it reads more of the file than 17 bytes. The file is saved, unopened, and reports being 82 bytes in size. (On Windows, not sure how much of that is irrelevant data.)
Unfortunately, I realize the sideof, and cast redundancy, but I have to follow a few silly rules for the project this is being written for. Though, when editing the code to be like such: buffer = malloc(21); count = read(fd, buffer, 20); printf("%d\n", count); For what ever reason, it reads 18, rather than 17. Still not what was requested, but it's something. I'm really confused by this.
To add to my earlier reply, when changing the code to this: int read_file(int fd) { char *buffer; int count; buffer = malloc(41); count = read(fd, buffer, 40); printf("%d\n", count); return (0); } count become 36, instead of 18. For what ever reason, for each 10 bytes I request it to read, it reads 9.
&gt;Charset detection is very clumsy at best, it's better not to rely on it. Windows will tell you which character set it uses on the specific computer. I could imagine so, but there are no real guarantee that the files are saved in the windows charset. It depends on what kind of files OP is dealing with and what programs might produce them.
Hrm, Microsoft recommends to not call read on Windows. They've even removed the documentation for it, just saying you should use _read instead. So maybe that has something to do with it? 82 bytes to me indicates the file might be saved in UTF-16 format and thus using two bytes per character, but I'm not sure why that would affect things.
Maybe it has to do with how Windows handles their files. I'll be using this on a Unix-based system eventually, but unfortunately, I don't have one with me to test on immediately. Thank you so much for the information, I think you've nailed what the problem was.
dat resolution
If you don't want to continue until you've gotten the specified number of bytes (or an error occurs) you can do: char *buffer, *bufftmp; size_t bufflen = 21; int count; int total = 0; buffer = malloc(bufflen); bufftmp = &amp;buffer[0]; do { count = read(fd, bufftmp, bufflen-1); bufftmp += count; bufflen -= count; total += count; } while (count &gt; 0 &amp;&amp; total &lt; bufflen); printf("%d\n", total); This will run the read over and over again until it either stops reading data or errors.
Not helpful, I know, but your code works properly for me. Returns 20 for the original code and 40 after the 41/40 edits.
Maybe I don't get it, but it seems like this will limit C, making it less powerful. For example: &gt; At any access via a pointer value, its numeric address must be consistent with its provenance, with undefined behaviour otherwise. In particular: &gt; &gt; — access via a pointer value which has provenance a single storage instance ID @I must be within the memory footprint of the corresponding original storage instance, which must still be live. &gt; &gt; —all other accesses, including those via a pointer value with empty provenance, are undefined behaviour. Wouldn't this prevent me from storing `void *` pointers in `intptr_t` variables, tagging these pointers with extra data, and later removing the tagging and restoring the original pointer value in a new pointer variable (this is common practice in Ruby and Objective-C)...?
Would adding O\_BINARY make any difference ? Are you sure you are not linking with some custom read() from odd inhouse library, instead of the POSIX version ?
Use your GNL.
I'm using the read from #include &lt;fcntl.h&gt; Not sure where to add O_BINARY, in all honesty.
I was thinking newline conversion, too, for some reasong
Which OS are you on out of curiosity? Someone mentioned that I apparently shouldn't use read() on Windows. I appreciate the reply, it's actually helpful.
open(... | O\_BINARY). It's not yet guarantee that the read() that's linked in, is the same as the one shown in fcntl.h. Unlikely, obviously. Your lines are 4 characters per line. If the read fills the given buffer and then squeezes out each \\r\\n into just \\n, in place, would that cause the behavior you see?
I ran it on OS X and Linux (Debian). Worked on both.
I guess it works as intended on unix-based systems, but not on Windows. Thank you very much for testing this.
I know this isn't particularly helpful, but at first glance your code looks fine (as in it should work) so I'll just recommend that if you're on Windows you should consider doing: CreateFile() ReadFile() CloseHandle() unless you have a pretty compelling reason not to
Wrong sub reddit and too lazy to even attempt the solution or even type out the problem. You’ll go far kid /s.
Look up seeding a random number
A few thoughts: 1. try use a faster changing seed. i.e., try XOR-ing `time(NULL)` with other data: srand((unsigned)clock() ^ (unsigned)time(NULL)); 2. `rand()` isn't vary random anyway... If you need "safe" randomness, **don't use `rand()`** - it isn't cryptographically safe.
C++ is off topic in this subreddit. Please post C++ memes to /r/cplusplus instead.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
you understand how the seen affects rand. time() should change every second. Can you print the value of time() when you run?
This isn't specific to your problem, but that `RAND_MAX + 1` is a mistake, and the lesson shouldn't be doing that. On many common systems, that's signed overflow — undefined behavior. For example, on a typical Linux system that code will not necessarily have any particular behavior. Here's what it should be instead: randValue = rand() / ((double)RAND_MAX + 1);
Your issue here is that `rand()` is synchronized — e.g. there's a mutex lock around it — and your threads are spending all their time contending for the PRNG state. This is what `rand_r()` is for, where each thread has its own uncontended PRNG state. However, the libc algorithms behind `rand()` and `rand_r()` are usually awful, and their biases will affect your results. Further, since they're typically dynamic function calls that do very little, [they're expensive to call](https://nullprogram.com/blog/2018/05/27/). Don't use `rand()` or even `rand_r()` for this! For the best results, embed a much better PRNG in your program. Use [xoshiro256\*\*](http://xoshiro.di.unimi.it/) ([source](http://xoshiro.di.unimi.it/xoshiro256starstar.c)), which is my personal favorite, or [PCG](http://www.pcg-random.org/download.html). Third, `rand()` returns, at best, 31 bits of entropy, and you convert it to a double, which has 53-bit mantissa. You're missing out on a lot of potential. You should [use more bits](https://mumble.net/~campbell/2014/04/28/uniform-random-float) when you generate your random doubles.
Do not use \`rand\` in different threads. \`rand\_r\` is the safe alternative.
How should I go about using rand\_r in these examples? Do I just change rand to rand\_r? Also, do I need a unique seed for each thread, how do I go about implementing that?
I think using rand\_r is the answer because as this is a school project, I think that's what my professor mentioned. But, how do I go about implementing it in these two parallelizations. I know each thread needs its own seed, so how do I set that up?
Solution [http://prntscr.com/nbumt6](http://prntscr.com/nbumt6)
Easy solution for pthreads: When threads start, have each use `rand()` to create the `rand_r()` seed for itself. In general it's better to use a different algorithm — such as a hash function — to seed your PRNG, but you said you're not too worried about having the best possible solution. The situation is a lot trickier for OpenMP since the threads aren't explicit. One way is to use `omp_get_num_threads()` to get the number of threads, `N`, then prepare an array of `N` states before entering the loop. Inside each loop, use `omp_get_thread_num()` to get that thread's PRNG state from that array. (This isn't the best way to do it since these states are close together and so there will be false sharing between threads. It also might not work correctly on some weirder architectures, but it's fine for a simple assignment.) Another method is [to use use an integer hash function](https://nullprogram.com/blog/2018/07/31/) on the loop counter, `i`, to generate the seed for that particular iteration. This will always work and there will be no false sharing.
There must be thread-specific storage of unsigned numbers that represents random state. It's easier done with an array, similar to `counterThread`. You can combine a pseudo-random seed you obtained by a rand call from the main with the thread number by some operation to get a better seed.
Oh, I also just noticed you're using OpenMP incorrectly. `x` and `y` need to be local to the loop, and you need to synchronize ` count`, which will kill all your performance. OpenMP just isn't a good fit for this problem.
The standard doesn't require presence of any synchronization for `rand()`, so just don't call it from different threads. Using rand family to get several seeds might not be a good idea too, because you can get several sequences each being the tail of the next one.
I didn't know there was a mutex in `rand()`. Do you have documentation for that?
[Neither the C nor POSIX standards require it](https://pubs.opengroup.org/onlinepubs/9699919799/functions/rand.html), but it's still common for `rand()` to be synchronized. Here's glibc's lock: * https://sourceware.org/git/?p=glibc.git;a=blob;f=stdlib/rand.c;h=ff122046ec017e041e63332bb716854fd8ccc4a5;hb=56c86f5dd516284558e106d04b92875d5b623b7a#l24 * https://sourceware.org/git/?p=glibc.git;a=blob;f=stdlib/random.c;h=06e2548898e21459b2ba7762e0899d4cbb0a3abc;hb=56c86f5dd516284558e106d04b92875d5b623b7a#l286
This is a frustrating thing about Windows. If you’re not particularly interested in developing for a Windows environment, you could install Cygwin. Cygwin is a Windows app that gives you a Unix-like terminal. It is capable of running gcc/clang, and many other terminal tools. Every command line tool I have written that runs correctly in Mac OS, Linux, and FreeBSD has also run correctly in Cygwin.
&gt; I understand why a company wouldn't want their engineers writing C code in 2019. Which reason did you have in mind? Regardless of my opinions on Go, Swift, Rust, or Java, for each of those languages I can think of several reasons why I wouldn't want my engineers using them in 2019.
It seems like different implementations do different things.
The function is defined in the source code of your vendor's implementation of the libc. Which operating system or libc do you use? Perhaps I can help you find the source code for it.
Sure, but OP was asking about a specific implementation and why it was behaving that way it was.
Thanks! I'm using Ubuntu 18.10
Type/memory safety. I could see myself discouraging C in a corporate environment, especially if I wasn’t the one writing the code. For personal projects, I wish more people were using C. I think it’d be interesting if C had the same market share as Javascript does on Github.
Then you can find the source code [here](https://sourceware.org/git/?p=glibc.git;a=blob;f=libio/getchar.c;h=90dea38ddb3026c0890156bc56dfb6c1336f243a;hb=HEAD). Note that the GNU libc (glibc) is a bit hard to understand because its implementation is sprawled out over so many files.
Thank you. What should I use instead ?
When I ran the code and noticed I had the same values each time, I tried to debug by displaying various values, and one thing I found was that the values increased regularly. Since I don't understand how time(NULL) works and what it represents I was stuck there. Thank you for the information.
Thank you !
The example code is terribly poor quality. Call `srand()` ONCE ONLY, at the start of the program.
Regular variables are locations that hold a value. Pointer variables are variables that hold a location that hold a variable. Double pointer variables are variables that hold a location that hold a location that hold a variable. Ipso facto recursion. That's a very high level definition.
For cryptographic level randomness, you should use a crypto library, such as OpenSSL (horrible, but prevalent), LibreSSL or BearSSL (super promising and thought-out). On most unix-like systems (i.e., Linux / BSD) these often read data from a file descriptor linked to [`/dev/random`](https://en.wikipedia.org/wiki//dev/random). The IO operation might be slower, but the randomness should be cryptographically safe. If you're looking for strong randomness but aren't worried about cryptographic qualities, there's a number of quality random algorithms out there that offer good randomness, such as the [xoroshiro128+ algorithm](http://prng.di.unimi.it). If you're feeling adventurous, you're welcome to use the random generator I authored for facil.io when I was took some time to look for solutions... it's better (and faster) than the my system's `rand()` implementation, but I doubt it's cryptographically safe (it's loosely based on xoroshiro128). All in all, it somewhat depends on your use-case. For example, if you need to randomly add variations into game-data, speed is of the essence, so don't use a crypto level library for that (better use a third party algorithm).
**/dev/random** In Unix-like operating systems, /dev/random, /dev/urandom and /dev/arandom are special files that serve as pseudorandom number generators. They allow access to environmental noise collected from device drivers and other sources. /dev/random typically blocks if there is less entropy available than requested; /dev/urandom typically never blocks, even if the pseudorandom number generator seed was not fully initialized with entropy since boot. /dev/arandom blocks after boot until the seed has been securely initialized with enough entropy, and then never blocks again. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Can the terms you are speaking they actually both have 4 properties: 1. An address 2. A size 3. A type 4. A value It just so happens that a pointer's value is the address of something else.
Pointers just have their own address and the memory address they point to (the value of the pointer). You can use the address they store to access a value, but it's not like they also store that value separately. Here's maybe a way to think about it: int values[4] = {8, 3, 7, 1}; int index = 2; printf("%i", values[index]); // prints 7 You can use the variable index to access the value '7' in the array, but the variable index itself doesn't store the 7. It's not a great analogy because pointers are tied much more closely to what they are pointing at, but maybe it's helpful.
&gt;and the value of the variable they are pointing That's not true. To get that value you need to apply an operator on the pointer.
The way I think of it. Pointers are exactly like other variables. They have a memory address (the place the variable is stored) and a value (the thing they store). The only difference is the way you interpret the value the variable holds. In regular variables you interpret the value by the type it has (int, float, etc.) In pointers you interpret the bits it holds as a number that identifies a place in memory that you can then look at and interpret the value of the bits there by the type the pointer holds (the memory at the value held by an int* is interpretted as an int, etc.)
u/ialreadyreddit123: **Do not delete your posts once you get an answer.** It robs other people of learning, and it's rude to those that answered. I didn't write my responses just to help you. I wrote them so that everyone could learn. By deleting your post you've effectively deleted my comments.
Thank you ! What I need here, is a way to show how randomness works to my daughter (12) who is trying this code as a way to learn how to create games. The current code is not satisfactory in that respect because it generates the same value at each call. Also, we're working with a 10.13 macos system and I'd like to use standard headers and not have to install specific libraries.
&gt; Note that the GNU libc (glibc) is a bit hard to understand because its &gt; implementation is sprawled out over so many files. No kidding. Just earlier today I was trying to link to the full implementation of `rand()` — a function whose implementation is effectively just a few lines of code — and it's spread across three different files from the top level down to the actual implementation: * https://sourceware.org/git/?p=glibc.git;a=blob;f=stdlib/rand.c;h=ff122046ec017e041e63332bb716854fd8ccc4a5;hb=56c86f5dd516284558e106d04b92875d5b623b7a#l24 * https://sourceware.org/git/?p=glibc.git;a=blob;f=stdlib/random.c;h=06e2548898e21459b2ba7762e0899d4cbb0a3abc;hb=56c86f5dd516284558e106d04b92875d5b623b7a#l286 * https://sourceware.org/git/?p=glibc.git;a=blob;f=stdlib/random_r.c;h=3292713641b6b19ffaa9785b52764c62678ee0c7;hb=56c86f5dd516284558e106d04b92875d5b623b7a#l352 Compare that to musl: * https://git.musl-libc.org/cgit/musl/tree/src/prng/rand.c?h=v1.1.22 Or FreeBSD: * https://github.com/freebsd/freebsd/blob/master/lib/libc/stdlib/rand.c Both of which have it all in one place.
What do you think about arc4random ? It is available by default on macOS and BSDs, (on Linux you'll need to link libbsd). Biggest advantage is that you don't need a seed to initialize it and that it is thread and process safe.
Thank you. Do you mean before main ?
Idk why this isn't the top comment, or why I was the first to upvote it.
He prob means at the first line of main()
It's excellent for seeding, but it still has the same thread contention issue that will kill performance. Since it uses ChaCha20, a CSPRNG, it's also *much* slower than necessary for Monte Carlo, which doesn't require all those additional cryptographic properties. Plus it's still a dynamically linked function, which has a relatively large amount of overhead in this case. For parallel Monte Carlo, you really want each thread to have its own PRNG, and, since a PRNG does so little each time its called, it's best to even avoid the overhead of thread local storage and dynamic function calls.
Does the position affect the number of times srand is called ? It is not in a loop or anything here, is it?
Cool :-) On macOS, you have access to volatile CPU data. You can use this data to automatically re-seed the random generator with volatile information. This should prevent the issue you're experiencing: #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;sys/resource.h&gt; #include &lt;sys/time.h&gt; int my_random(void) { /* automatic re-seeding every 65536 numbers */ static uint16_t seed_counter = 0; if(!seed_counter++){ /* collect system state */ struct rusage rusage; getrusage(RUSAGE_SELF, &amp;rusage); unsigned int seed = 1; /* treat system state as an integer array and add all integers */ for (size_t i = 0; i &lt; (sizeof(rusage) / sizeof(seed)); ++i) { /* multiply each data sction by a prime number, improve bit distribution */ seed += ((int *)&amp;rusage)[i] * 3839950729; } srand(seed); } return rand(); } I hope this helps.
looks fine to me. no idea what the original comment was complaining about.
SDL runs great on Linux. Doesn't need to be targeted for X Windows ..
SDL is great. But the appeal of handmade hero is that it goes to a lower level than is generally practical. I'm looking for the linux equivalent if there is one.
if i run this code on my computer, it will not compile without the fix above. with that fix, it works as expected. if you are seeing something else then i suspect you have a typo in the code.
Not sure if it's nuts and bolts, but a few examples using C and OpenGL can be found [here](https://gtk.dashgl.com/). Another one I found recently uses SDL and can be found [here](https://www.parallelrealities.co.uk/tutorials/#shooter).
I tried once do do it from scratch using xlib, and I managed to get it running, but decided to switch to SDL after, because it's not worth it. For educational purposes, just real xlib man ;) https://tronche.com/gui/x/xlib/
By size you mean the size of one pointer which does not depend on the data type it is pointing to correct?
Correct, the pointer itself has a size, which is typically either 32 or 64 bits wide, enough to store an address on you system.
I dunno, there's not much more "low-level" than SDL_RenderPresent and the buffers it manipulates. Maybe what you're looking for is the SDL source code, itself, which will teach you a lot about hardware/platform graphics interfaces...
I think he's just saying he wants to learn the X servers intricacies for its own merits. I don't have anything to point op to though.
SDL already has an X backend. Build the game with SDL configured to use the X backend, and then study the code.
`getchar()` first appeared as [assembly code in Unix V2](https://minnie.tuhs.org/cgi-bin/utree.pl?file=V2/lib/getchr.s) (June 1972) and was somewhat more sophisticated by [V5 Unix](https://minnie.tuhs.org/cgi-bin/utree.pl?file=V5/usr/source/s4/getchr.s) two years latter. By June 1975, it was re-written [in C for V6 Unix](https://minnie.tuhs.org/cgi-bin/utree.pl?file=V6/usr/source/iolib/getch.c) calling [the `cgetc()` helper function.](https://minnie.tuhs.org/cgi-bin/utree.pl?file=V6/usr/source/iolib/cgetc.c) By 1976, [V7 Unix has it defined simply in terms of `getc(stdio)`](https://minnie.tuhs.org/cgi-bin/utree.pl?file=V7/usr/src/libc/stdio/getchar.c) with [`getc()` being defined as a macro.](https://minnie.tuhs.org/cgi-bin/utree.pl?file=V7/usr/include/stdio.h)
&gt; [...] some sort of single-byte encoding [...] generally use UTF-8 UTF-8 is a multi-byte encoding.
If it says 18, then it read 18 characters. Have you tried printing them out? for (int i = 0; i &lt; count; i++) printf("%02x %c\n", (unsigned char)buffer[i], (buffer[i] &gt;= ' ' &amp;&amp; buffer[i] &lt;= '~') ? buffer[i] : ' ');
In that sentence meant an encoding composed of individual bytes, as opposed to UTF-16 which is a sequence of 16-bit quantities.
Better to install [WSL](https://docs.microsoft.com/en-us/windows/wsl/install-win10) and Ubuntu than Cygwin.
Install [WSL](https://docs.microsoft.com/en-us/windows/wsl/install-win10).
UTF-8 text is not composed of individual bytes; it is composed of variable-length sequences of bytes.
But I want to do it manually as an exercise. SDL is an extra step. If I were doing literally anything else then ya I'd just use SDL.
on windows, it's converting the "\r\n" pair to just "\n" after reading it into the buffer: &gt;_read returns the number of bytes read, which might be less than buffer_size if there are fewer than buffer_size bytes left in the file, or if the file was opened in text mode. In text mode, each carriage return-line feed pair \r\n is replaced with a single linefeed character \n. Only the single linefeed character is counted in the return value. The replacement does not affect the file pointer. from https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/read?view=vs-2019
You misunderstand. Allocate memory in pages. Then use the block of memory allocated.
This is more to offer a broader perspective: Other posts in this thread show you where to get the source for your particular implementation but you should also know the standard does not require &lt;stdio.h&gt; to be a file nor for the implementation of getchar() to be a function in a library. Even within a single compiler multiple behaviors may be available based on command line flags and other configuration. Currently GCC has chosen to support some functions as builtins which it may inline as shown [here](https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html). At least from the lists on that page puchar() may be inlined but they don’t seem to do the same for getchar(). It’s been a decade since I had to look into some of the internals but at that time it could also rewrite calls to one function with calls to other functions when it was faster to do so. The whole point of defining an abstract interface is that the implementation can change underneath the covers and your code should still work.
What page number/section of the book was it, just so we can get a better look?
Thanks a lot! It seems I have to dive into some files.
Really I wasn't expecting all that information. Did you study CS and/or you did the research? You surely know a lot. Thanks!
Unbelievably- but it is page 69
Okay this gives me more information to consider in the future. Thank you!
If the tagging you're talking about is done by accessing memory that actually belongs to the variable in question, I don't think you're doing anything they want to forbid. I actually read this as being pretty conservative. Looking back at their example: 1 # include &lt; stdio .h &gt; 2 # include &lt; string .h &gt; 3 int y=2 , x=1; 4 int main () { 5 int *p = &amp;x + 1; 6 int *q = &amp;y; 7 printf (" Addresses : p=%p q=%p\n" ,( void *)p ,( void *)q) ; 8 if ( memcmp (&amp;p, &amp;q, sizeof (p) ) == 0) { 9 *p = 11; // does this have undefined behaviour ? 10 printf ("x=%d y=%d *p=%d *q=%d\n",x,y ,*p ,*q) ; 11 } 12 } The idea here is that accessing `y` through a totally unrelated variable `x` should be explicitly undefined behavior, and it's (apparently) not. That seems uncontroversial to me. The type of the variable doesn't even seem to come into play. The bit that's more relevant to you is the part about "exposed" pointers. But that's not about making something undefined behavior, it's about what optimisations are or aren't available for a given pointer, and it sounds to me like it's largely a codification of what compilers already do.
You are correct. Perhaps they meant `return !found;`. That would return failure (non-zero) if no lines matched and success (zero) otherwise.
On the next page: "The pattern-searching program returns a status from main, the number of matches found. This value is available for use by the environment that called the program." A C function, including main, returning 0 for success and anything else as failure is just a convention, and one doesn't have to follow it. One should properly document the meaning of what they return though, especially when they break from convention.
As far as K&amp;R is concerned, main() can return any integer. By convention, that’s the exit value for the program. In general, 0 is considered success, but programs are free to have other successful exit values.
The return value from `main` is just an integer value, so it's perfectly valid to use it pass some information - and I've used this in a few situations. It's very similar to C functions that return an integer error code - 0 for success is common, but it's not required, and as long as people are aware of what you're returning then they can handle it just fine. *That said*, there are clear limitations to this approach. The biggest is just convention - it an unexpected usage and creates an easy spot for failures to pop-up (The same thing happens in regular C code when you mix zero and non-zero success values). There's another issue though, which is probably more relevant, which is that lots of OSs truncate the return code to 8 bits, meaning there's a max of 255 matches this can report and then it will wrap back around to 0 - that will get annoying pretty fast and there's no good way to get around that besides just not using the return code in that way.
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { if (sizeof(unsigned long) &lt; sizeof(void *)) printf("Undefined behavior\n"); unsigned long a, b, *c; b = rand(); c = &amp;b; a = (unsigned long) c; printf("*a: %lu\n", *((unsigned long *) a)); printf(" b: %lu\n", b); printf("*c: %lu\n", *c); return 0; } You are able to do the same with variables, output: *a: 1196089164 b: 1196089164 *c: 1196089164 Will just work on systems where unsigned long is the same length as pointers
Is this a GNU thing? `musl` is an invaluable project to me. Helped me a lot when I was trying to figure out how the C standard library worked. Couldn't figure out `glibc` at all. I've been exploring GNU Privacy Guard source code recently but I still don't know how to add the features that I want.
Yes - I dove into the C99 ISO standard. &lt;stdlib.h&gt; does define EXIT_SUCCESS and EXIT_FAILURE macros, but leaves it up to the environment to define the integer constant for these. In my environment EXIT_SUCCESS is 0. So in my case, this program breaks convention, but would not also be ANSI/ISO compliant for my environment and not portable to other environments that share this definition in &lt;stdlib.h&gt;. By doing what K&amp;R states seems to contradicted what the standard is trying to convey - that is - there is one value for a successful exit of main() - or am I interpreting this wrong?
 Here's the correct code: #include &lt;stdio.h&gt; void meme( int *that ) { *that = *that + 1; printf("The new this is this: %d\n", *that); } int main() { int that = 23; printf("This is the initial this: %d\n", that); meme( &amp;that ); that = that - 23; printf("Final this: %d\n", that); return 0; } Your second code example is completely wrong: main.c:3:16: error: expected ‘;’, ‘,’ or ‘)’ before ‘&amp;’ token void meme( int &amp;that ) ^ main.c: In function ‘main’: main.c:13:5: warning: implicit declaration of function ‘meme’ [-Wimplicit-function-declaration] meme( that ); ^
stdlib.h defines EXIT_FAILURE as 1 and EXIT_SUCCESS as 0, but this causes issues with boolean arithmetic of shell $status and test values, because of the true=1/false=0 convention in C language boolean expressions.
I studied CS in the 1980s when this was new. I should have also pointed you to [filbuf.c](https://minnie.tuhs.org/cgi-bin/utree.pl?file=V7M/src/libc/stdio/filbuf.c) which the `getc` macro uses to call `read()` in Unix V7.
I vaguely recall a claim at one point that gcc was deliberately hard to comprehend so that pieces of it were less likely to be pilfered for non free software.
In addition to the mentioned unix exit code range of 0 ... 255, values 126 ... can also cause problems. Shells present signal termination with 128 + signal and use 126, 127 for cannot-execute or not-found.
&gt; that is - there is one value for a successful exit of main() - or am I interpreting this wrong? The standard does not require there be a single way of indicating successful termination of a program. Returning `0`, `EXIT_STATUS` or any number of other implementation-defined values could do so.
SDL is a high level abstracted interface. Saying you can't get much more "low level" than SDL is a bit of a contradiction.
SDL is an abstract interface over low-level access to hardware using whatever means the host OS provides. In the case of the Framebuffer backend, its pretty low-level, yo. Just read the code.
The OS already allocates memory to your program in pages. Trust `malloc()` to do the right thing with them. Allocate just what you need, except when you don't really know in advance, in which case you use `realloc()` with a linear or exponential growth function, or a combination of the two.
I'm pretty sure K&amp;R2 assumes Unix, which at the time allowed any value from 0 to 255. POSIX allows the entire range of `int`, but you need either `sigaction(2)` with `siginfo_t` or `waitid(2)` to retrieve it, and I believe K&amp;R2 predates both. I don't think `EXIT_SUCCESS` and `EXIT_FAILURE` originated in an implementation; it is more likely that they were introduced in the standard to reflect the common subset of the capabilities of existing implementations.
The shell assumes the opposite: 0 is true, non-zero is false.
In VMS odd exit codes are success and even ones failure
I wonder if this breaks type punning through unions. I hope they don't allow relational comparisons for pointers of different provenance. There are machine models where this has a performance impact. Two examples come to my mind: * machines with memory colours (SPARC, Itanium, ARM64, maybe future x86) may have to strip colours before comparing pointers for ordering * 8086 programs with far data models have to compare both segment and offset for order and possibly normalise segment selectors The first one would be a real bummer, the latter one is of historical note; Intel apparently caused a great kerfuffle back in the day by writing a C compiler that would only compare the offsets (as opposed to segments) for order when comparing pointers for ordering. This broke some tricky programs. Intel apparently pointed out that comparisons for ordering are only valid within an object and as a single object cannot span multiple segments (except in huge mode), the segment part cannot possibly be different.
Exactly, which is why any form of boolean arithmetic looks insane in shell scripts.
`srand()` seeds the random number generator. In almost all programs, you should do this just once. If you're using `srand()` at all you should call it before the first call to `rand()`. Normally the most convenient way to do this is to call it early in `main()`. If reproducibility of results is a goal, you should also record the seed so that the results can be reproduced; this can be important for some kinds of scientific research, for example. Such programs might allow the seed to be specified on the command line (meaning that you'd only call `srand()` after you're finished processing command-line options with (for example `getopt()`). Most programs won't need to do this kind of thing.
I was reading Reddit on a mobile phone and misread the code as including the `srand()` call site in a loop. Partly I think because I'd assumed this was the cause of the lack of variation observed by OP. This is, of course, incorrect. Sorry.
&gt; Ideally I'd like a somewhat functional shell that could do something like traversing folders, making a file, starting a process, etc like with the terminal. I dunno how doable that is so I wanted some tips on doing that. I'm currently trying to do a command history where one can hit up or down on the arrow keys and look through previous commands, but I'm not quite sure how to print out the command while being able to backspace over it and such. The simple way to do this is to use a library for this purpose. For example [GNU Readline](https://tiswww.cwru.edu/php/chet/readline/rltop.html) (also: [Wikipedia page](https://en.wikipedia.org/wiki/GNU_Readline)). There are alternatives too, including for example [libedit](https://www.cs.utah.edu/~bigler/code/libedit.html) but (at least according to the article at that link) libedit isn't very well documented.
**GNU Readline** GNU Readline is a software library that provides line-editing and history capabilities for interactive programs with a command-line interface, such as Bash. It is currently maintained by Chet Ramey as part of the GNU Project. It allows users to move the text cursor, search the command history, control a kill ring (a more flexible version of a copy/paste clipboard) and use tab completion on a text terminal. As a cross-platform library, readline allows applications on various systems to exhibit identical line-editing behavior. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Good point. Making a shell work well requires the programmer to master Unix process groups and sessions, topics which are complex and which are useful for almost no other purpose.
While Unix may be normative to the examples of K&amp;R2, K&amp;R2 is not a book on programming using C in a Unix environment. The statement given above "The pattern-searching program returns a status from main, the number of matches found. This value is available for use by the environment that called the program." is true, but it might be a mistake to use those return values in a Unix environment.
Yeah, a lot of GNU source has this issue, but I don't know why. I'm with you on GnuPG. It's whole architecture is a complicated mess of multiple processes with buggy interactions. Even stuff in GNU Coreutils that should be really simple is made overly complex: * The `true` command, whose minimal implementation in C is a single function with one line of code is [80 lines](https://git.savannah.gnu.org/cgit/coreutils.git/tree/src/true.c?h=v8.31) not counting the code it calls in multiple other source files. * The `yes` command is [126 lines](https://git.savannah.gnu.org/cgit/coreutils.git/tree/src/yes.c?h=v8.31) not counting the code it calls in multiple other source files. Ultimately these programs work, and work correcly, but their sources are a mess.
&gt; Currently GCC has chosen to support some functions as builtins which it may inline as shown here. At least from the lists on that page puchar() may be inlined but they don’t seem to do the same for getchar(). No, it says that GCC *recognizes* `putchar()` as a builtin, which means that `__builtin_putchar()` exists as an alias for `putchar()`, and that GCC knows its type and arguments and will emit a warning if it encounters an incorrect prototype, or if you call it without a correct prototype in scope and the implicit prototype is incorrect (which is the case for `printf()`, but not for `putchar()`). In some cases (e.g. `memchr()`, but not `putchar()`), it will also perform a few static checks on the arguments. Check the source; the builtins are listed in `gcc/builtins.def` and implemented in `gcc/builtins.c`, the prototype logic is implemented in `gcc/c/c-decl.c`, and the substitution logic (which, for instance, replaces `printf("x")` or `printf("%c", x)` with `putchar('x')` or `putchar(x)`, respectively) is in `gcc/gimple-fold.c`.
Define “insane”, because this looks perfectly sane to me: for op in '&amp;&amp;' '||' ; do for a in true false ; do for b in true false ; do echo -n "$a $op $b = " ; eval "$a $op $b" &amp;&amp; echo true || echo false ; done ; done ; done true &amp;&amp; true = true true &amp;&amp; false = false false &amp;&amp; true = false false &amp;&amp; false = false true || true = true true || false = true false || true = true false || false = false
Don't use spaces in file names.
OMG that was magical, it solved it. Actually what I did was so dumb. Thank you dude!!
Also, please do not ever post pictures of code. Always post code as text!
**int c**; Characters like ü etc can look like EOF, depending on charset. count = 1 is also funny.
I'm new here I just replicated another post where I saw a picture of code . I'll implement your advice from now on.
Thank you for your understanding.
I thought the last line wouldn't be counted cuz it will reach EOF but idk really, I'm still a rookie anyway.
Files that have no \\n at end of last line, make humans and programs confused :)
I formattted your code for you: #include &lt;stdio.h&gt; // Variable declaration: extern int a, b; extern int c; extern float f; int main () { /* variable definition: */ int a, b; int c; float f; /*actual initialization */ a = 10; b = 20; c = a + b; printf("value of c : %d \n", c); f = 70.0/3.0; printf("value of f : %f \\n", f); return 0; } I don't know what your question is, but I can tell you that you don't need to do // Variable declaration: extern int a, b; extern int c; extern float f; These variables are not external; you declare AND define them in your `main()` function also: /* variable definition: */ int a, b; int c; float f; This is declaration, not definition. This is why you don't need to say `extern` for each variable at the top.
it is important to note though, that you *really* shouldn't use a non-zero return code. It makes your program much harder to use from shells because they assume that you follow the convention and non-zero = failure.
Fun fact: pintos means dicks in portuguese.
&gt; Maybe I don't get it, but it seems like this will limit C, making it less powerful. Because many implementations are used for purposes other than low-level programming, the Standard has *never* attempted to mandate that implementations support everything necessary for such purpose. Instead, the expectation was that implementations intended for such purposes would support "popular extensions" (Committee's term used in the Rationale) that define behaviors even in circumstances where the Standard itself wouldn't require them to do so. Many parts of the language defined by the Standard would be almost completely useless in the absence of the such "popular extensions". For example, given a definition like `struct foo {int a[5]; } s1,s2;`, the rules in 6.5p7 of C11 draft N1570 don't require that an compiler allow for the possibility that an lvalue of type `int` might be used to access an object of type `struct foo`. While this avoids blocking potentially-useful optimizations like: struct s test(int *p) { s1 = s2; *p = 1; s2 = s1; // May be omitted, since s1 and s2 are already equal } it also means that constructs like `s1.a[0]=2;` do not have Standard-defined behavior but are instead a "popular extensions". The authors of the Standard rely upon implementations to recognize when their customers would find optimizations like the above useful, and when their customers need to use "popular extensions", rather than trying to impose such judgments themselves. I doubt the authors of the Standard would have intended that compilers willfully ignore cases where an address of one type is visibly formed from an lvalue or address of another, as opposed to treating support for such cases as a "quality of implementation" issue, but that is clearly what happened. Although the Standard *defines* the meaning of `someUnion.array1[i]` as `*(someUnion.array1+i)`, neither gcc nor clang can recognize that an access to the latter lvalue might affect other objects within the union whose lvalues are formed likewise. The only way such failure would be allowable would be if support for `someUnion.array[i]` is not required, but is merely a "popular extension". Given that much of the language would be almost useless without "popular extensions", I don't see that provenance-based rules would make anything any worse.
I love VMS for arguments over conventions. - "Everything I've ever seen abides by X." - "Well, in VMS..."
Thanks it worked!
So, basically, this is an ad?
So how should portable source code support both VMS and a more traditional POSIX-like system? `return 0`? `return EXIT_SUCCESS`? `exit(EXIT_SUCCESS)`? Is there a compiler flag on VMS that will change what it does with the return value from a C `main()` function?
Ok thanks
This is absolutely an ad.
I read the whole post. I thought it was an interesting. I go to conferences to see material exactly like this. Do we really want to turn a blind eye to those contributions because they are on a commercial website's blog? Seems a little short-sighted.
Why only once? Seems that the very poor random generator usually associated with `rand()` could benefit from re-seeding with some indeterminate entropy (if possible).
Yeah I know, I didn't name the project.
If your implementation's `rand()` is of poor quality, better to replace it entirely. Unless you know the actual quality (cycle length, spectral properties, ...) of the PRNG backing `rand()`, calling `srand()` with a coarse-grained current-time value could easily do as much harm to the randomness of the output as benefit. Consider this random-number generator: int myrand() { int x = (int)time(NULL); int y = (int)getpid(); static int z = 0; return x ^ y ^ z++; } How random are the numbers returned by this function? Well, they're not easily predictable exactly, but if you get a lot of them they will display a certain pattern. It might be OK to do this once at the start of the program: srand(myrand()) but, if we do this a lot, we will be re-starting the system PRNG from a somewhat-predictable seed preiodically. If I use the same seed twice, I will see the same sequence of numbers from the PRNG twice. IOW, we'd only be seeing a reduced fraction of the actual output of which the PRNG is capable. We've actually reduced the randomness of the PRNG output by repeatedly re-seeding it. The reputation that `rand()` has for low quality is partly caused by the fact that the C89 standard said this (section 7./20.2.2): ### 5 EXAMPLE The following functions define a portable implementation of rand and srand. static unsigned long int next = 1; int rand(void) // RAND_MAX assumed to be 32767 { next = next * 1103515245 + 12345; return (unsigned int)(next/65536) % 32768; } void srand(unsigned int seed) { next = seed; } This isn't a great-quality PRNG. It was just meant as an illustrative example. But, because the standard included it, some implementations (including I believe Watcom, Digital Mars, CodeWarrior, IBM VisualAge C/C++) actually used that particular code. People often point out that `rand()` implementations are no good for security purposes. True. They're often [not great even for Monte Carlo simulations either](https://en.wikipedia.org/wiki/Linear_congruential_generator#Advantages_and_disadvantages). Of course, `rand()` doesn't have to be low-quality. [xoshiro](http://xoshiro.di.unimi.it/) seems to be a reasonably popular choice, these days.
&gt; the price of contribution is advertisement are you a capitalist or something?
Please post articles as links, not self posts. I have removed your post so you can try again with a link post.
A major problem with the Standard is the apparent lack of consensus or clarity as to whether it is intended to describe everything necessary to make an implementation suitable for any particular purposes, and if so, what those purposes are. If the Standard were to recognize a form of C which is intended to be suitable for tasks low-level programming (in which the above would have defined behavior), and another form that isn't (and where the above wouldn't have defined behavior), that would benefit both purposes far more simply and effectively than a compromise set of rules which ends up with absurdly complicated and ambiguous corner cases.
Different implementations are intended for different platforms and purposes. Rather than mandating that all implementations support a global transitive non-overlapping ordering for all objects' addresses, the Standard should define predefined macros or other means programs can use to indicate their semantic requirements and/or refuse to run on implementations that won't support them. Some algorithms would work just fine if attempts to compare the address of one object for equality with the address "just past" an unrelated object would individually yield 0 or 1 in unspecified fashion, while others could malfunction if two addresses that have compared equal, not do so consistently. Rather than mandating that implementations always implement equality comparisons consistently, or saying that they should never be expected to do so, it would be more useful to have a means by which programmers can indicate what semantics they actually need to accomplish whatever it is they need to do.
The C Standard invites compilers to define essentially whatever semantics they see fit for accesses to `volatile`-qualified objects. While it does specify some minimum requirements, that does not imply any judgment as to whether suitability for any particular platform and purpose might require going beyond those.
this is an interesting talk but the mic pics up every mouth noise the speaker makes which is incredibly distracting to me.
Have you looked at the source code to malloc in places like FreeBSD and Solaris and Linux?
externals? you mean files? if so you can easily embed them in your app glib has a nice gresources api for that [https://developer.gnome.org/gio/stable/GResource.html](https://developer.gnome.org/gio/stable/GResource.html) you run a program which can create a .c file to compile into your app, I'm using it in a few projects even going as far as adding it to my makefile so if any of the resources my app uses like for example images change the resource .c is automagically updated...
I think OP means the extern keyword for variables.
&gt; I want to pass values Then you can. void doTheThing(int, int, int); // in another file int main() { int stuff[10] = {...}; doTheThing(stuff[3],stuff[1], stuff[4]); }
I'm really interested in this topic, but the video format just utterly kills it for me. Is there a transcript I can read or a way I can download the slides and notes?
By arithmetic I meant numeric uses of status outputs, e.g. `grep -q`
Using output parameters is fairly common practice in my experience. Heck, a lot of the standard library routines (e.g. strcpy()). That said, I'm not sure why you're shying away from return-by-value. You're only talking about two doubles here. That's 16 bytes on typical modern systems. Which is hardly nothing. And if you place the function where it could be inlined, an optimizing compiler would likely eliminate any overhead. If you're really, really concerned about performance, do it both ways and see what kind of code gets generated both for the body (if it doesn't get inlined) and at call sites.
It's for a Mandelbrot set explorer, so potentially, I could have 50,000x33,000 pixels to test, and each test could call `square_complex` up to 200 times (although likely less). If you think that the overhead for a copy is negligible though, I could try it out and see how it performs. Thanks.
I think you can turn on CC and watch the video without sound.
The copy approach is **certainly** going to be faster than the malloc/free approach you started with. If you put your function definition in a place where it can be inlined by the callers and turn on optimization in the compiler, then I don't think you'll have a problem. Compiler optimization does crazy amazing things these days. In fact, you might find that the pass-by-value approach and the output-parameter/pass-by-reference approach end up generating the same exact machine code after the optimizer has its turn. On average, you really should not worry about performance at this level until you have solid evidence that you have a performance problem. You should be writing code in a way that makes it readable, easy to edit, and easy to work with. Let the compiler worry about optimizations. And then if you're unhappy with the result, dig into what comes out the other side with a profiler to identify where bottlenecks are.
You should consider using C11 complex number types. That said, it is likely that the function is inlined anyway (if the compiler can see its definition, that is), so the difference should not really matter.
&gt; a place where it can be inlined by the callers Does that mean put the definition in the header and mark it with `inline`?
I saw those. I'm doing this mostly for practice, although if I can't write performant code I might try them. Thanks.
You're right. I think everyone, including myself, completely misinterpreted your comment.
For most functions, he C library returns 0 on success, (or equal), and, actually, any other number for as many exit conditions the program needs to report. At the moment, however, I don't have the K&amp;R with me, but these match the return values of the command line utility grep. In the shell, the variable $! contains the integer exit value of the last command.
main() returns an integer. By convention returning zero means success, anything else means failure. That is just a convention. The return value is made available to the environment of shell process. So technically you can define your own contract / convention of what your main()'s return value means. I don't know what K&amp;R is, but I would not be worried about their choice of returning count of matching lines as long as it is understood and clear that this is what their main() means with the return value.
What is your take on the following function: extern int x[1],y; int test(int *p) { y=1; if (p==x+1) { *p=2; } return y; } Both gcc 8.2 and clang 8.0.0 will generate code that conditionally stores 2 to `*p` and then unconditionally returns 1, on the presumption that it would be impossible for `p` to compare equal to `x+1` if it were equal to `&amp;y`. Such behavior might be appropriate in a compiler that would never cause space to be allocated for an object of simple type immediately following an object of array type, but I'm unaware of gcc or clang making any effort to avoid such placements or requiring that modules written in other languages do so. Does the behavior seem appropriate to you?
Why not use C99's _Complex type?
It is nice to see that you are performance conscious. Yes, it is a very common practice to accept allocated memory via arguments. This moves the burden of allocation and deallocation to the caller i.e. one entity. Design wise this is a better approach than allocating within the method. If you chose to write an API that internally allocates memory, then you should also write another API that would help deallocating whatever was allocated in the first API. That would balance the APIs out. So now the caller will have to call your 2nd API to get things de-allocated instead of assuming any allocation behavior from our 1st API. I should also mention that C++ has RAII that helps, but this is not a C++ forum. Still something I would recommend you to look at.
Assuming you have two C files. And each of them has methods defined. One of them has the array you want to pass to the other's method. Now you can make a call from one file to the other's method and pass the variables/array or whatever. You will need to include header of 2nd in the 1st. Also, you will have to compile one file (say first.c to first.o), and second file (say second.c to second.o) and then link both object files (first.o and second.o) into your binary. This has to do with make/build. By the way we call the file "module". If you included more details of exactly what you were trying to do, we could provide a better suggestion.
This is mostly as an exercise. I need complex numbers for a project and decided that I might be able to learn from a small detour.
`return 0;` and `return EXIT_SUCCESS;` are designed for that purpose (the compiler will transform 0 to a success code)
Thanks. And I've used C++ previously, so I'm familiar with RAII. I wish C had a similar mechanism. I need to use C for a course, so I'm unfortunately not able to make use of C++ niceties.
I have to agree with eteran.
Yep, that's one way (assuming you're using C99 or newer). Another possibility is just putting the function in the same translation unit as the call sites (same .c file).
read() on a descriptor is interrupt-able by operating system. What this means for you is that it can return pre-maturely such that the descriptor may still have some data left to be read. You logic should loop to make sure it any remaining data is also read, that or a failure has occurred. If you don't do that you'll have nasty bugs show up. This also goes with read() done on socket descriptors. I've seen many programmers / contractors in the field doing this mistake.
Awesome, thanks.
The compiler will? Or the runtime environment? (In other words, if you disassemble it, would you see the `_main` function returning the values the OS expects, or would it return 0 when it exits the C runtime, and the runtime checks the result and translates it?)
Yeah, but e.g. `strstr()` returns NULL for not found, so you can use it as a truth value in boolean contexts, unlike say, `strcmp()` -- these sorts of things are why I predict C will not last more than 70-80 years as the kernel programmer's language of choice. Already Rust and the like are making major inroads on pointer safety, and transpiling ultra-easy languages like Python is already a thing wherever GC is still allowed. I can't imagine that we can go another couple decades with C pointer messes, and Ritchie's terrible nul-terminated strings.
Inside main(), strlen(shellcode) is not a good idea, use sizeof() instead. Also, most importantly you need to place a return address somewhere between nops. So there are two things you need to figure out: 1) what would the address be, so that it would execute some nops and lead to shellcode execution, 2) and where exactly the address should be placed in between the nops so that the return pointer under the context of bos would be overwritten by it.
I would like to recommend a book to you, "Datastructures and Program Design in C" by Kruse, Leung, and Tondo.
It seems just like the first example to me. I'm less surprised that the compiler optimizes out the `*p=2` and more surprised that it currently compiles without so much as a warning.
OP, this is certainly a major flaw in the book. You should be aware of the [errata](http://s3-us-west-2.amazonaws.com/belllabs-microsite-dritchie/cbook/2ediffs.html) and the [Critique starting on p. 13 here](https://www.math.uh.edu/~sanders/Math6378/Sp17/Documents/C_Lang/c-history.pdf) is as important as the errata, to be honest. Many people say you should always have a copy of [the C standard](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf) handy when you are relying on K&amp;R, or doing any kind of C where portability and undefined behavior issues might crop up (which is not usually, but more often than most experts admit.)
You should be aware of the [errata](http://s3-us-west-2.amazonaws.com/belllabs-microsite-dritchie/cbook/2ediffs.html) and the [Critique starting on p. 13 here](https://www.math.uh.edu/~sanders/Math6378/Sp17/Documents/C_Lang/c-history.pdf) is as important as the errata, to be honest. Many people say you should always have a copy of [the C standard](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf) handy when you are relying on K&amp;R, or doing any kind of C where portability and undefined behavior issues might crop up (which is not usually, but more often than most experts admit.)
[I mean I've said it before but](https://www.reddit.com/r/C_Programming/comments/86bed0/c_cforall_is_an_opensource_project_with_the_goal/dw3rq0o?utm_source=share&amp;utm_medium=web2x): &gt; It's kinda cool, especially the incorporation of some features that are popular in Go and Rust, but I can't help shake the feeling that people have been doing this for decades and this iteration merely adds to the noise of "modern C dialects." If I'm wrong please correct me, because I wouldn't mind something like this, I'm just not sure this is anything new, noteworthy, or useful. Although it's cool to see that there are other means by which you can modify the language this extensively.
C doesn't have the semantics to handle more than system programs that work directly with memory locations. Some of the revisions since K&amp;R sort of address that, like the stdbool.h and stdint.h headers, and types like uintptr_t and these allow programs to specify more exactly what they mean so the compiler can provide better warnings. I'd plug languages like Ctalk and other languages based on Smalltalk notions of object handling, which allow pointers when there's need to work with memory locations, and still allow for higher level constructs for programs that use anything more than a command line interface. WRT to nul -terminated strings, I think there were several reasons for using them; first, they're directly compatible with strings in assembly language, which early C compilers needed to use directly, and the fact that Pascal already used strings with a built-in length member, and there was some legal issue, but that's only a rumor....
BCPL and B had 16 bit string length fields, but in retrospect, those would have been worse. 32 bit is probably right.
I'm not sure if I would ever use it in production but it's pretty cool!
&gt; Both of these are arguments in favor of the proposal, not against it, right...? The proposal perpetuates the misguided notion that there needs to be a compromise between optimization and semantics, rather than recognizing that the set of features and guarantees needed to uphold the Spirit of C principle "don't prevent the programmer from doing what needs to be done" described in the Charter and Rationale will vary depending upon "what needs to be done", in ways the Committee cannot reasonably expect to fully understand. Fundamentally, an optimization that assumes a programmer won't do X is apt to be useful in cases where "what needs to be done" doesn't include X, but worse than useless in cases where it does. If the Standard wants to avoid reliance upon "popular extensions" to make the language usable without needlessly blocking optimizations, it will need to be fundamentally redesigned. Instead of trying to facilitate rules by allowing compilers to behave arbitrarily instead of behaving as described elsewhere in the Standard or an implementation's documentation, it would be much more useful--to programmers and compiler designers alike--to recognize certain forms of optimization that may be performed in the absence of certain forms of evidence that they would cause program behavior to adversely deviate from the basic execution model. The main purpose of the Effective Type rule, for example, is to allow accesses to some objects to be reordered in such a way as to allow consolidation and/or improve efficiency. A rule which simply specified that compilers may reorder accesses in the absence of evidence showing that it would have unacceptable effects, could allow more useful optimizations without having to limit the kinds of things programmers can do. Under the Effective Type rule, a compiler given: void test(int *p1, float *p2, int mode) { *p1 = 1; *p2 = 1.0f; if (mode) *p1 = 1; } would need to allow for the possibility that `p1` and `p2` might alias if they might occupy allocated storage or be part of a union, but not if they don't do either. Under an evidence-based rule, however, such allowance would not be necessary. Since nothing that could happens during the execution of `test` would suggest that `p1` and `p2` might alias, a compiler should be allowed to assume that they don't. On the other hand, the act of converting a pointer from `T1*` to a `T2*` should be recognized as evidence that reordering earlier operations involving the `T1` or any other `T1` that might alias it across operations involving the resulting `T2*` would be likely to break things.
Folks, It is a wrong assumption that read() would return incomplete data only on Windows. read() is defined in POSIX standards and that contract is not specific to Windows. The right way to call read() is to call in a loop until all expected data is read, or a real error is encountered. An alternate and simpler way to perform a higher level read is by using fopen() and fread(), so that you do not have to worry about interrupts happening between the read and some other tricky situations. You can find more details in read() manual page (search for Linux(3) read()).
Low level read() done on a file descriptor can be interrupted like any other read() on any other type of descriptor (for example, socket descriptor).
That is correct. _In practice_, however, the function is uninterruptible on Linux, at least, when reading from "ordinary" filesystems.
I recommend a project. Maybe a command line tool or system such as a shell, parser of some sort, simple database (like single table simple). From there work your way up. some lists of other projects you can do can be found (here)[https://github.com/danistefanovic/build-your-own-x] or (here)[https://github.com/tuvtran/project-based-learning#cc], both of which I keep starred on github in case I get bored or am learning a new language. If you want to get serious with C I recommend reading further and also in a more specialized way. Video game design (maybe more C++ but still), embedded systems, and operating systems development are three fields in which C is a major player. For learning OS development I would recommend reading "The Linux Programming Interface" to start. For other fields google or ask in this sub. I would also recommend taking a look at the books listed in the "Resources" section on this sub's sidebar (on old reddit, not sure where on new reddit but try old.reddit.com/r/C_Programming if you cannot find it)
Anyone seeking to understand the language described by the K&amp;R book should also read the published Rationale for the C Standard at http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf but recognize that the language some compilers process differs significantly from what the authors of the Standard intended. When the Standard was written, there were many actions which most implementations would process consistently, but for which a few implementations would be unable to offer any behavioral guarantees. Although the Committee recognized that such actions were often useful, they characterized them as "Undefined Behavior" with the expectation that implementations that could usefully support such "popular extensions" would do so without regard for whether or not the Standard required them.
Honestly, yes, they're fairly common. That said, I REALLY don't like that usage pattern, I avoid it like the plague.
It's clear this is something you know a lot about. Thanks for taking the time to write such a long reply. I'm still not quite with you on the idea that this proposal would actually forbid anything programmers could legitimately want to do. I read the line `if (p==x+1)` in your example as being equivalent to `if the compiler happened to have placed y immediately following x in memory`. That question strikes me as fundamentally "not my domain" while I'm writing my program -- the compiler should be free to put `x` and `y` in whatever order it chooses, and if I want them next to each other I can declare `int xy[2]`. So if trying to alter `y` via `x` breaks something, I'm not outraged, and if someone tells me that in the future that attempt will be explicitly UB, I'm not shocked. But judging from a quick peek at your comment history, I also don't have anything like your level of experience with low-level programming in C. Is there something about low-level C programming that makes this kind of "access a variable through an unrelated variable" thing useful? Or am maybe I missing your intent with that example, somehow?
While strtok is a nice way to split string into tokens, it’s not thread-safe — basically it has static buffer inside. While currently it is not an issue, but someday in a multi-threaded application you’ll be wondering what the hell is going on. So I suggest using a threa-safe version of that function — [strtok_r](https://linux.die.net/man/3/strtok_r). I’m not sure if it’s linux-specific or not though.
Or if you want to use a library to form JSONs you can try [jansson](http://www.digip.org/jansson/) or [json-c](https://github.com/json-c/json-c) but that seems like an overkill for this task
It is fairly common practice and I agree that it is rather ugly. The only suggestion I would give is to make the output pointer to be the first argument. Then the function kind of looks like a constructor. This can be helpful for users to understand that they may have to free the object when they are done with it. If you just have plain-old-data, i.e. data that a binary-copy works as expected, then it is not a crazy idea to simply return the object from the function. The compiler can then see everything and it is my understanding that optimization makes it essentially the same as the output paramater case and more efficient than returning mallocd memory. What I mean is something like: `const Complex sqrd = square_complex(current_complex);` I personally think this is the best method and it is a clear message to the user that the result is just POD and does not need to be freed.
watched this a while ago, I'd recommend the computerphile channel content overall...
Make simple programms and use malloc/calloc for everything: store int-values in malloc(sizeof(int)) for example &amp;#x200B; And why not storing all the adresses of pointers in unsigned longs (as long as sizeof(unsigned long) == sizeof(void \*)) ? &amp;#x200B; If you are able to achieve that, you should be fine with pointers
 $ sh -c 'exit 5' ; echo $(($?*2)) 10
Yes.
_21st Century C_ is a really good book, although I do not agree with some of the author's statements in it. Large portion is dedicated to talk about tools for C programmers (in latest edition), which is a great read and help for beginners.
GNU still does that to some extent, doesn’t it?
In regards to this particular problem, I think you’ll find that going more than about 80 levels deep won’t show significant results unless running at extremely high resolution or calculating closer views in advance (in which case you’ll want to save those values somewhere).
IIRC there was a bug with the imaginary _I in GCC about two years back, so I personally avoid it in code being compiled by it (although it’s since been fixed, I think.)
You can make use of Objective-C’s ARC framework, but that isn’t exactly “pure” either.
gay boi
I know that you can parse JSON with jansson or json-c, but I didn't think that you could use either library to serialize data into JSON.
Yeah I love this channel. It’s definitely one of the few where the content outweighs the fluff.
html doesn't "execute"... Are you asking to extract data from html-formatted reposes in email? It would be far easier to configure your online form to send plaintext delimited responses to make parsing easier. Or maybe you can use an XML-parsing library to extract the data from html Or you want to write a program to take user input directly and save it to disk? Easiest is to wire a series of printf() prompts with scanf() response captures from a CLI screen. Alternatively, just send the HTML form directly and have the submit button POST to a waiting service or even launch their email client with the `mailto:` tag, pre populating the email.
I think you missed the point of the example **The code doesn't try to use anythng based on `x` to alter `y`.** Parameter `p` is passed the address of `y`. The value in `p` has nothing to do with `x` beyond the fact that it might coincidentally equal `x+1`. Further, if an implementation claims to be suitable for low-level programming with a toolset that allows control over how symbols are placed, it should allow for the possibility that `extern` symbols might have been laid out deliberately. For example, on many embedded platforms it is useful to create linker symbols for the start and end of otherwise-unused storage. All a compiler would have to do to allow a program to use a heap whose size is determined at link time would be to refrain from trying to be "clever" if code does things like: extern uint32_t heap_start[], heap_end[]; ... for (uint32_t *p = heap_start; p &lt; heap_end; p++) *p++ = 0; Obviously such code could malfunction disastrously if the symbols aren't placed as the programmer expects them to be, but if the programmer is control of the link script the correct placement can be assured. The Standard, however, lacks any way to specify that a compiler should look at the addresses of the symbols because the authors expected that implementations would fall into two categories: those where such behavior would be useless (and thus the Standard shouldn't mandate support) or those where compilers would naturally support it (and thus the Standard still didn't need to mandate support). I don't think they anticipated compilers that would be capable of usefully supporting such behavior, but simply opting not to.
The authors of gcc seem to view cases where gcc does so as "missed optimizations". For example, given something like: unsigned mul(unsigned short x, unsigned short y) { return x*y; } the authors of the Standard have stated that they would expect commonplace implementations to process the multiply in a fashion equivalent to unsigned multiplication, even for product values in the range INT_MAX+1u to UINT_MAX. Unless `-fwrapv` or `-fno-strict-overflow` is specified, however, gcc will not reliably behave in such fashion. If the function is invoked as e.g. `mul(i, 65535);` gcc will sometimes use that to infer that `i` will be 32768 or less.
In that case I am an asshat and will go look at the sources better.
&gt; Is there something about low-level C programming that makes this kind of "access a variable through an unrelated variable" thing useful? Or am maybe I missing your intent with that example, somehow? Comparisons with unrelated pointers are often useful in memory-management code, or in code that needs to check the validity of pointers. If a function is only supposed to be passed pointers within a certain range, and is supposed to signal an error if it isn't, achieving such semantics would be difficult without the ability to compare potentially-unrelated pointers. Although some architectures might lack instructions that could cheaply test whether one pointer precedes another in a global transitive non-overlapping ranking, and compilers for such platforms might thus not provide any practical way for a programmer to achieve the required semantics, there's nor reason programmers shouldn't be able to do what's needed on platforms which have address comparison instructions that are suitable for that purpose. More generally, I would suggest--and I wish this notion would somehow gain traction--that C has diverged into two kinds of dialects, which differ in how they handle situations where some parts of the Standard and an implementation's documentations together describe the behavior of some action, but another part of the Standard classifies an overlapping class of actions as UB. Dialects which honor the Spirit of C principle, "Don't prevent the programmer from doing what needs to be done", and claim to be suitable for some kinds of tasks will give priority to the described behavior when doing so could help programmers accomplish such tasks, while dialects which honor the "spirit of gcc/clang" will give priority to the fact that the actions invoke UB, without regard for whether or not the described behavior would have been more useful. For some reason, the people responsible for supporting gcc and clang seem totally bewildered at the notion that programmers would ever have any expectations about how code would behave in cases where the Standard imposes no requirements, *even if the Standard and the implementation's documentation would together describe the behavior*. Further, they seem to be unable to grasp that programmers who would have a use for a construct might know more than the compiler writers about whether the construct is useful. Also, although my examples of compiler mischief tend to be brief and contrived, that's typically because realistic examples would be rather large and hard to analyze. Finding places where a compiler incorrectly processes large programs may be harder than finding places where it incorrectly processes short ones, but if a compiler can't reliably process short programs, it's unlikely to process large programs any better. Instead, it's more likely to produce undiscovered bugs.
The first edition of K&amp;R was considered the "standard" for the c language before ANSI and ISO - it was co-authored by the creator of C. [More info about K&amp;R here](https://en.wikipedia.org/wiki/The_C_Programming_Language)
Sure, but sh -c 'exit 256' ; echo $(($?*2)) 0 This why I think the example is a terrible one as a match program could easily get more matches than that.
&gt; At the moment, however, I don't have the K&amp;R with me, but these match the return values of the command line utility grep. I have have misunderstood this sentence, but the simple grep example in K&amp;R does NOT match the return values of the command line grep. The K&amp;R example returns the numbers of lines matched. grep on the other hand has the following exit statuses: EXIT STATUS The grep utility exits with one of the following values: 0 One or more lines were selected. 1 No lines were selected. &gt;1 An error occurred.
Am I missing the point somewhere or could you not do: printf("loop %*"PRIu64" ", width, foo);
maybe he meant microsoft's HTA? unlikely, but still...
yea ,actually i am working on appointment system of doctor through c programming for college project and after client selecting time , i want doctor to get that notification in email .so i just wonder i could do it or not . thank you
/u/FUZxxl says that there might be Closed Captions, so you could likely capture a transcript that way.
There are various things you can do, look for an SMTP library to send emails. If windows+outlook you can use MAPI API,. Linux can use sendmail. If you need a pretty UI you are getting into more difficulties with OS-specific API. Otherwise a .htm attachment should open directly in a browser and you can use javascript and/or html forms to blast data, assuming the browser doesn't block cross-site-traffic/xss (localhost to external domain)
You *definitely* don't want to be using malloc/free for a small function like this that gets called many thousands of times. That's completely wasteful. Using an out-parameter is a perfectly sensible way of implementing this, and is common in the standard library when it's required. Returning the value directly is may also not be terrible for a reasonably small structure like this one. Depending on optimizations, the compiler may turn either of those methods into the other. If it inlines the function, it might erase the out-parameter and access the struct in place, no differently than if it were a local variable. Conversely, to return a large struct, the compiler might end up invisibly using an out-parameter or returning a pointer in order to get the value into the right place on the stack. You would have to disassemble and profile the code on whatever platform you're optimizing for in order to decide which method is better. On x86 where registers are few, returning a large struct from a function is usually awkward. On x86-64 it's a little better, and since this struct uses doubles, it appears that the calling convention instead returns them in floating-point registers, of which there are many more available. ARM looks like it can return fairly large structures in registers. If in doubt, and you wanted to write portable code that could be optimized to work either way, I think the best option would be to prototype your functions to use out-parameters. That forces callers to have a variable they can take the address of. If it ends up that on a particular platform and compiler and optimization level that passing and returning by value is more efficient, then you can simply use a macro to do `#define square_complex(out, in) (*(out) = square_complex_by_value(*(in)))`. (If you try to design an API the reverse way, you might end up trying to take the address of a literal (if it were something other than structs being passed around), which doesn't work.) The compiler should have no problems optimizing that down to a simple pass and return by value.
Note: width should have type `int` (not size_t etc.)
256 is not a valid shell exit value.
&gt; `printf("%2$*1$d", width, value);` but... why? printf("%*d", (int)width, value);
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
No single way of handling strings is going to be optimal for every approach, but a useful concept for both strings and floating-point (which has unfortunately been lost with the latter) is to recognize a distinction between working formats and storage formats. When actively manipulating strings, it's most useful to keep the length, buffer size, and buffer address as separate values, but when storing strings it's helpful to be able to pack such information. The approach I'd favor for most purposes for strings would be to have the first byte identify the format and for most formats supply the buffer size or a few bits thereof, and then have a widely-used function which, given a pointer to a string and a blank string descriptor, fill in the string descriptor with information about the string (unpack the length, etc.) If the string descriptor started with a special byte value that was used for any other kind of string, then functions that need a string source operand could be passed pointers to string buffers or string descriptors interchangeably, and functions that want to pass part of a string to another function could create a string descriptor structure with the length, buffer size, and a pointer to the content, and pass that. Using this approach wouldn't be quite as fast as simply keeping pointers to string content and length separately, but would make it possible for many functions to handle many formats of string interchangeably if they start by taking a passed-in string and calling the "make string descriptor" function.
Merge sort is NlgN, works quite elegantly with linked lists, and also happens to be inherently stable unlike quicksort (meaning items with equal keys will remain in their original order). To start, create two blank lists, a pair of items from the original list, write them in order to the first list, take another pair of items and write them in order to the second, and keep on doing until all items have been transferred. At this point there will be two lists each with N/4 sorted groups of two items. For each subsequent pass which starts with items sorted into groups of K, create two new lists (or recycle now-empty ones), then merge the first group of K items in the first list produced in the last pass with the first group of K items in the second list and write the result to the first new list (producing a group of 2K items). Then merge the next groups and write the result to the second new list, the first, second, etc. Each merging phase can be done in linear time, and the lengths of the groups into which data is sorted will double each pass.
No kidding - neither is anything greater. So using the exit value to pass on a matching line count - which could easily be 256 or higher - is poor coding.
I haven't used xmake, but from what I can tell it looks refreshingly simple and intuitive. It is almost like what cmake intended to be from the start, but without all of the complexity and baggage that it has acquired over the last 2 decades.
That has absolutely nothing to do with your statement that boolean arithmetic in the Unix shell is insane. Or your follow-up statement that you actually meant *regular* arithmetic.
Um, try C++
Try libcello
This is a wordpress blog containing pictures of hand written code copied from a stack overflow post.
Any reason why you want OOP support strictly in C? Is this a practice project as a chance for you to intricately understand the language? If not, that is why C++ was invented.
That would be easier, yes, but I view this challenge as an opportunity to really get to know what C is capable of (or otherwise).
It's my handwritten notes with a link to the source.
Sentence 2 is correct. This is merely an exercise to improve my understanding of C.
\- Unable to find Mach task port for process-id 790: (os/kern) failure (0x5). (please check gdb is codesigned - see taskgated(8))
Yes! I just browsed libcello.org, and it looks like it could be helpful, thanks.
In addition to the recommendation to look at Cello (http://libcello.org/) from /u/TheMonax, I would additionally recommend looking at: * the GLib object system (https://developer.gnome.org/gobject/stable/); and * Object Oriented C - ooc (http://ooc-coding.sourceforge.net/) From looking at each of these it should be clear that while object-orientated development can be done, but ultimately, it is not something that C is intrinsically designed to support.
Have you looked into using lldb instead?
I thought macs came with a different debugger. Something like lldb I think
Yeah. I was trying to use gdb because Eclipse supported it. May just have to use lldb though.