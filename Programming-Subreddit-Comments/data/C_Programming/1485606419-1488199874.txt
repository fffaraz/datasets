There is very little reason to declare external functions within function bodies like this because typically you declare functions in header files and static functions in the beginning of a source file. Limiting the scope of the declaration has no benefits and forces you to repeat the declaration in every function you use it. If you change the function signature it's one more thing you need to change in several places. Declaring functions this way was common in early versions of B and is still legal in C, but not very useful. Declarations affect the way code for function calls is generated, but it doesn't matter in which scope a function is declared. If we're being really technical, a declaration like that automatically gets the `extern` specifier added to it so that within a function int a, foo(void), *p, buf[N]; everything but *foo* have automatic storage duration but the function naturally doesn't. But that is specific to that case, for instance typedef int fn(void); extern int foo(void); // OK int foo(void); // OK extern fn foo; // OK fn foo; // ERROR
Yeah sorry, I'm a bit too familiar with C++. First time trying to code in C. Thanks for answering anyway. 
See my updated comment.
You would love [C Programming: A Modern Approach](https://www.amazon.com/C-Programming-Modern-Approach-2nd/dp/0393979504). The book gets into some pretty advanced stuff. From MAKE files, to programming idioms, to how to organize your code. It's a really dense book, but super well organized, super clear for almost all topics (only two or three topics I needed to google), and most importantly very thorough. I was reading the book to refreshen my C. Out of curiosity, I looked up common or important interview questions on embedded C, and pretty much the book nailed it down.
Thanks a lot! Very much appreciated! My knowledge in algorithms is very little, and in data structures is 0. The story is that I am in my first year of a Computer Science degree, and in the next semester we are gonna have a C course (alongside physics calculus biology..nonsense courses), and as they said, this C course is to teach student the fundamentals and concepts of programming and to get them used to this stuff, by using the C language. And in the next year (the second year), I am gonna have the "advanced programming" (Java) course, Algorithms course, Data structure Course, Operating systems course, Compilers course, databases course, networking course, computer security course, and many others... So I don't know if it's a good idea to learn algorithms, data structure, and assembly by myself from now! Also because I got about 5 days only, just 5 days to learn C and come prepared to the course to stand out and be the best! And btw, I am comfortable with linux, and tbh what I am most interested in is Information Security, penetration testing, exploit development and malware engineering (in the future), and I've been in this field since a while, but I entered this CS degree to harden my networking/programming/system administration/etc fundamentals to be able to be a professional penetration tester in the future! As what I want to work as after graduation is a (junior) penetration tester, and I am working hard for that, I am learning pentesting everyday alongside everything in the university, alongside 1 computer basics course, physics calculus biology and all those things I don't need, and next year I am planning to get the OSCP, and hopefully start working in a security or programming-related job from my second year! I am not waiting for my university to teach me or hire me! I sculpt my own future. Again, thanks very much Sir :)
Thanks! Is it good for a programming beginner ? And does it care about writing a kinda-secure code like "learn C the hard way" book ?
Oh thanks, just did! Well, yes many many resources, but how am I supposed to choose! I have no idea what is right for me, as I have 5 days only to learn C by myself, then I am gonna follow my lecturer! That's why I am asking you, the experienced guys! 
Oh thanks a lot Sir! Very useful.
It's not. But the video he makes are great. Ashamed a great mind has to meet an end like that. 
According to this: https://news.ycombinator.com/item?id=9333520 , it says that Learn C the hard way teaches how to write secure C code, it touches that area (which books are written on "secure coding in C")...while the K&amp;R book doesn't actually, and that doesn't meet the nowadays standards and needs! As security is a thing now, not like when k&amp;R was written. And I am interested in that...so I am asking if then "C Programming: A Modern Approach." book teaches with security in mind or not.
Oh, that's what you mean by secure. IMO, it is wrong to expect one source to be everything to everybody. If you want to learn about security engineering, it's better to pick up a book (or series of books) on security engineering that will be better suited for the topic. [I've never gone through all of Learn C The Hard Way besides the first few lessons to see what it was all about, and it was interesting how he used (I think it was) Valgrind to check for memory leaks.] C Programming: A Modern Approach is an involved book that will go through *a lot* on C programming, and programming in general. Lots of concepts that are wide ranging. Its topics are thorough, and you'll finish chapters finding yourself reflecting upon how you are part of a team and how you can be a better programmer. With that said, it's a book that teaches you the building blocks of C. If you want something more than that, then I'm not really sure there is another book out there that can give you more than C.
iostream.h is not a C++ header either. The closest-named C++ header is `iostream`.
Ok thanks Sir :) Very much appreciated!
In C higher dimension arrays are just regular arrays which are nested. [Does this help?](https://www.tutorialspoint.com/cprogramming/c_multi_dimensional_arrays.htm) 
There's a book called "Hacking: The Art of Exploitation" by Jon Erickson. The first few chapters aren't related to hacking, but are designed to help someone get up to speed with C - read pages 6 to 114 for an **excellent** introduction.
The code you posted is wronger than that. We're not trying to discourage you but it looks like the project is too ambitious to tackle at your stage in your journey to learning C. The most glaring issue is your use of scanf(). I think if you could correct that on your own you might be able to submit code that we can critique. 
Sorry I meant to update, I ended up figuring it out. Got it to encrypt the word TRACED into OL&lt;=@&gt; and it displayed the ASCII values associated with the new encryption on a separate line which is all I was trying to do. I didnt use any part of the code I had posted since it was way off.
Valgrind doesn't seem to like the tests very much. Is this expected?
assuming you already have the string of digits in an array called `str`, of length `n`. char c; for (int i = 0; i &lt; n; ++i) { c = str[i]; if (c == '0' || c == '1') { // do stuff } else { // process error } } This can be cleaned up with just using pointers to be more "C-like", but I went with the verbose implementation for clarity. Is this what you were looking for? 
Ah well if you have it scanned as an int, you can easily modify this to a single iteration and comparison against numbers. I leave this as an exercise to you ;). That being said, if you get stuck, reply here and we can walk through the solution. 
Why don't you learn C.. In your course in five days? 
Non-Mobile link: https://en.wikipedia.org/wiki/GNU_Scientific_Library *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^24410
You could try something like a `while (scarf"%d",&amp;i)) { ... }` You can loop through and receive an new into each iteration from stdin. Does that make sense?
Thank you very much for pointing this out. Valgrind was cribbing out about some uninitialized memory, I have fixed it. It now runs clean with Valgrind.
With m-2 the do while loop stops executing after one character because it matches the first quote again. With m-1 it will have already advanced past the first quote by the time the test is run so it won't stop until another quote is encountered. Try running this program with `valgrind` or similar memory access checking tools. You have cases where you are accessing memory outside of the memory you've allocated and doing tests based on uninitialized variables. http://pastebin.com/NMdiTg5w here's a valgrind run with two lines of "Hello World" in the input file.
m-1 is causing a segfault. I've been using valgrind and took out a bunch of errors, and there aren't any popping up in that block of code. Anyway to see more information on what's going wrong?
A debugger will let you step through your code, inspect variables and see where execution differs from what you think should be happening. Can you post a sample input that segfaults?
http://pastebin.com/7n2CbsGe It takes a C++ file and converts it to C. Should I just use gdb?
Because I want to enter it prepared...knowing the syntax and some basic ideas at least!
The core tools I would recommend for dealing with linear algebra problems in C are BLAS and LAPACK - both available at netlib: http://www.netlib.org/ Many libraries that have linear algebra functionality in them have LAPACK underlying them, including for example the GNU Scientific Library. I have found in the past when using the GSL that understanding what's going on in LAPACK was necessary. Not sure if it handles tensors, it's been a while since I used it in anger.
Hacking - The Art of Exploitation by Jon Erickson has a nice C programming section in it.
Please search the archives of this subreddit—this question has been asked many times before.
Hahahah but which one should i start with?
You need to dynamically allocate the string memory if you don't know how big it will be at compile time. I've put together a little example below with comments http://pastebin.com/EGHMWNLb You will also need to include stdlib.h, and `free` your string memory after use. You will want to look this up online.
Ok, sorry
A nice little project. One question: why not leave the standard operators as '+', '-'. '*', '/'? Also, need the calculator output it's current state all the time? Why not leave the printing of the current state up to an operator 'p'? What would you consider a static (as oppose to dynamic) calculator? As for the code itself, try to have more descriptive names than `n` and `po`, it makes the code difficult to reason through.
An update, this is the book used by the lecturer: Problem Solving and Program Design in C (6th Edition). And they don't go in depth as the book goes in each topic, around 50% of the book's in-depth.
RPN is basically what is done after a SYA changes infix to postfix (RPN) notation. The RPN part of things is the easy part really.
&gt; How do I put in a free license? What is the common way? Goto https://choosealicense.com/ and put a file named `License` into your repo. Also state the license in the readme and in a comment at the top of your code.
Off by one error when reading input: char i[100]; scanf("%100s", i); From the scanf(3) man page: &gt; String input conversions store a terminating null byte ('\0') to &gt; mark the end of the input; the maximum field width does not include &gt; this terminator. Meaning it should be `%99s`. Yes, it's awkward. Next: printf("%Lf", list-&gt;head-&gt;value); You should use `%Lg` instead `%Lf` since the latter is truncating a lot of precision and won't handle huge or tiny numbers well. I don't know about long double (which, IMHO, isn't worth the trouble), but for IEEE 64-bit doubles the precision-conserving specifier is `%.17g`. Next: struct list *list = malloc(sizeof(struct list)); No need for this to be on the heap. Then you don't need to worry about freeing it. struct list list[1]; // (array so that usage remains the same) Also, **you're also not initializing this variable**, so you're just lucky it happens to initialize to something useful. 
Seriously that is how it feels haha. Glad some people agreed 
Thanks for commenting! I fixed the errors you mentioned, but I have two questions: 1. Why make the list an array? It's a linked list, not an array implementation. 2. What do you mean by initializing the variable?
Looks like list is being used uninitialized.
Hash map to a pointer to structs. I'd personally make the struct something like an opaque pointer to data, and then a pointer to a function that takes that data. This is effectively how signals are done in a Unix-based system. 
Thanks for the reply and especially the example. What is your opinion on using a simple flat array (so that only one call to malloc is made) to define matrices? I know the indexing is a bit awkward, but it seems more straight forward to a newbie like me.
The closest one.
You're getting some good advice on how to use an OS API call to send text or keystrokes from your program to another window. Another approach (also requiring an OS-specific API) would be to have your program cut/copy the desired text into the shared OS clipboard. This can also be handy and more flexible The user just has to paste into the destination program/window of their choosing. Something to consider. Good luck!
Cool, thanks for taking advice from a moderately heavily downvoted post (which I guess is technically justified for being off-topic). Some things in Python are frustrating, especially coming from C, like enforcing whitespace and formatting, but it's very easy to prototype ideas in Python.
If you plan to use only as matrix, there is no problem. However for stencil computation (image processing, finite difference) the approach that I have outlined I believe more useful/handy.
Looks interesting. Too bad the "download as pdf" is only for that page, and not for the problems themselves.
No blog spam please.
The book by Kim N. King C Programming: a modern approach is all you need. It covers all the features of the language and some CS topics. It comes with a complete reference of the language and emphasizes the key features that have been added/removed/supplanted throughout the life of the language. The C Programming Language by Ritchie and Kernighan is, from my perspective, too hard for a beginner, as it does require you know at least one language and have a consistent knowledge of algorithms/data structures. You can check it out after you're done with the former. For any doubt, feel free to post here. 
Yea, all the common ones are actually implemented in C.
You can run C programs in the back-end as CGI. Start your search learning about CGI. Security can be an issue, so be sure you know what you are doing.
Keep in mind that format strings are a thing if you do this, so make sure your inputs are sanitized. And you're gonna see an eye-melting number of \ characters. There was a day when more deviously-minded people would upload nc (netcat) into the /cgi-bin directory. 
Keep a set of variables storing the largest green value encountered so far and its value. Initialize it with the values of the first pixel. Then compare each pixel with the best pixel so far, if the pixel just encountered is greener, update the variables to that pixel.
Thanks a lot; very informative and straight forward. If you don't mind another question, what's your opinion in the "Problem solving and program design in C - 6th edition" book ? As that's the book that will be used in my course this semester. 
Actually I dislike how he explains structs and pointers. When you don't know what it's about it will not help you at all.
thanks for the heads up. and i was out of SRAM. look at my post to r/arduino if youre curious about the working code. i split it over two machines to make it fit 
Yes. It's not fun. I'm only doing it because my back end is a microcontroller with no operating system. C just isn't great at string manipulation and the sort of stuff you typically want to do in back end code.
If you're willing to suffer a little bit, you can make linked lists for string manipulation that make it slightly less horrid in the long run.
Exactly what it says. Is a bit at a particular position 1 or 0?
A word is 2 bytes, or 16 bits. So if all 16 bits are set to 1 (as opposed to some set to 0) then return 1.
Number your bits from right to left, from zero. `01010101010101010101010101010101` ← has all even-numbered bits set to 1 `11111111111111110101010111111111` ← also has all even-numbered bits set to 1 `01111111111111111111111111111101` ← yup `10011010001011100101001001010101` ← nope 
No. Word size must be defined by the problem. In OP's example it looks like 32 bits. 64 bits is also common. So is 16 bits on small architectures (by today's standards). But the world has seen 9, 12, 18, 36, and 60 bit words also. Also, OP's problem domain is even-numbered bits if you read the post. So some (up to half) may be set to 0 if they are odd-numbered bits.
Please post code as text instead of a screenshot. Post a comment with the source code. Remember to put four spaces in front of every line of code so the code appears readable.
Ah woops
Honestly this right here is C's biggest problem, there's just no good UTF-8 library out there, and it's REALLY impeding C's future. :/
IOStream is a C++ thing, not C. In C++ headers are included without the extension so just `#include &lt;iostream&gt;` In C, you pretty much just use `stdio.h`, but `stdbool.h`, `stdint.h`, and `stdlib.h`, and sometimes `string.h` are pretty much default includes, for me at least.
For the standard headers, it's allowed to be a compiler trick, there doesn't actually have to be a matching file. But usually library implementations don't rely on any trick.
Let people do their own homework
Since C is the second most used language in the world, I don't think it's having any problems with usage.
Your client reads a response from the server before sending the message that gets responded to... Similarly, your server writes (uninitialized) bytes to the client before reading a message from it. I imagine the segfault is coming from trying to display the uninitialized string and eventually accessing memory you don't have permission to read. You ignore the return values of read() and write(), which is bad. Only reason that doesn't bite you is the packets you're reading and writing are the same size on both ends. 
How many rows and columns do you have? You probably have 30 different signals that you're able to send/receive (depending on your OS, but typically you might have signals number 1 through 32, with 2 of them being uncatchable). If you don't have a lot of rows or columns, you could try to encode the coordinates in the signal number, I suppose.
Why is it your only option? It's not a very good one for the task.
Use a socket or (named) pipe to comlunicate.
Thanks, I figured it out and besides the errors you pointed out, I forgot to initialize the `pthread_attr_t` variable
checked it before and did not jump on, still early stage, plus it's more for RESTful services instead of CGI
Read the manual pages for `open`, `close`, `read`, and `write`. These will allow you to communicate between two processes using a FIFO.
The array is modified as soon as you modify it. So after the first inner loop iteration, the array is { 9, 10, 8, 7 ... }. Just below Reddit's new post text input box, there's a small button labelled "formatting help" in small text. It shows how to insert code snippets in your posts, among other things.
If they're both running on the same system, then you can have a master process assign them PTYs (`man openpty`) before forking them. Or, you can have the master process allocate a shared memory object (`man shmget`). Or, you can have them both open local domain sockets or create sockets for them before forking (`man 7 unix`). Those are all common IPC methods. X11 uses the last one. Shells like Bash use the first one.
I did something like this once. You can look here to see how it was done (It is C89-esk). https://github.com/Chase-san/Songbird/blob/master/deque.h
Easiest solution is either installing Visual Studio or enabling the Windows Subsystem for Linux and installing gcc
I recommand you to listen to the advices of your good friend Victor , he knows a lot of things ! 
I used codeblocks in windows and linux/os i use terminal, gcc script.c -o -lm script ./script 
Since the largest open source OS uses C, I'm not worried about it's future
+1 for codeblocks. It isn't pretty but it works
Also printf expects an char* but your c is just char. You can solve this by getting the address of c with &amp;c.
Thank you! :)
Thank you!
i am still getting an error though even though i think i fixed my code a bit, i editted the original question to show what i did recently but I keep getting these two errors: warning: initialization from incompatible pointer type [enabled by default] warning: (near initialization for 'test') [enabled by default] 
(I’m assuming from your list of functions that you have use of POSIX or something POSIX-esque.) Use `signal` only to reset a signal handler to `SIG_DFL` or `SIG_IGN` after you’re done with the handler. Use `sigaction` to set a specific handler. It’s possible on *some* POSIX implementations *some of the time* to send an `int` worth of data via the `siginfo_t` structure, but that requires use of `sigqueue`. With plain old `kill` on Linux you have just under 6 bits of information you can transmit qua signal number (IIRC 1–63 excluding `SIGKILL` and `SIGSTOP`), and that’s incredibly unreliable. You’d have to trap all possible signals, and you aren’t guaranteed to be unable to distinguish (e.g.) an honest-to-goodness ya-done-fucked-up `SIGSEGV` from an IPC `SIGSEGV`, although you can use the `siginfo_t` data to pick up the sender PID most of the time. Sticking to realtime signals, you have slightly under 5 bits on Linux, but the glibc can reserve an arbitrary number of those for its own use and they aren’t portable anyway. Of course, you can theoretically bit-bang over signals (e.g., `SIGUSR1` to append a zero bit, `SIGUSR2` to append a 1 bit, and call `kill` 8 times per byte transmitted) but that would be miserable for any number of reasons. You must use deferred signals in order to reduce your chances of dropping one, and it’s very easy to come un-synced with the slightest delay or stacking-up. Normal signals are not neatly queued bits or counters, and shouldn’t be treated as such. Which is why your best bet IMO, and as mentioned elsewhere here, is to use `open`/`write` to create a file (flag `O_CREAT|O_EXCL|O_RDWR` with mode `0644` to attempt creation, and if that fails with `errno == EEXIST`, retry the open with just `O_RDWR`) and write each side’s moves to it progressively. (AFAICT `open` won’t make FIFOs.) If you just read/write successive moves from/to it, you don’t need to involve signals at all, but if you want you can use them to prod the other process after you’ve written something. E.g., for alternating moves P1:B5 P2:A4 P1:C3, you’d start by reading and applying all moves from the file, then once you hit EOF: 1. Process A: Write 3 bytes `"1B5"` to the file (→file pointer @+2). Poke Process B (optional). 2. Process B: (Awoken from stupor.) Read 3 bytes `"1B5"` (FP@+0→+2) from file. (Wait for user input.) Write 3 bytes `"2A4"` to file (FP@+2→+4). Signal Process A. 3. Process A: (Awoken.) Read `"2A4"` (FP@+2→+4). (User input.) Write `"1C3"` (FP@+4→+6). Signal Process B. You’d need some means of signaling non-move events from process to process; e.g., `"1\x1BL"` (`\x1B` = ASCII ESC) for “player 1 just lost,” or `"2\x1BQ"` for “player 2 wants to quit.” You may want a process to pick up and resume a dropped game when reusing an existing file, in which case “quit” and “forfeit” should be different things, and you might want to deliver “quit” via (e.g.) `SIGUSR2` or `SIGQUIT` to avoid encountering it in the file when resuming. `read` will return EOF as soon as you’re out of data, so you’ll need a wait/retry loop; a signal is one way to manually break that but it’s kind of unnecessary. Note that pretty much any POSIX function call is a point of failure. `open`, `write`, `read`, `sigaction`, and `kill` can all fail, and if that happens your process should die gracefully and (if possible/applicable) notify the other process before doing so (e.g., `"-Emessage"`). You can `kill` with signal #0 to check if the other process is still alive; if the `kill` fails, no such PID exists. Receiving a signal should break you out of a system call with `errno == EINTR`; don’t use `SA_RESTART`. Always do `errno = 0;` before starting something whose `errno` output you want to check. You have no way of knowing whether the process behind the PID is still the one you’re supposed to be communicating with, so be polite. A common parent process would have a much better opportunity of guaranteeing interrelationship—e.g. by creating a shared pipe or memory region, in which case everything gets much easier. You have no way of preventing some nefarious third party from coming along and fucking with the file contents or triggering your signal handler at any point. You also have no way to prevent possibly being killed during a crucial operation (e.g., writing to the file). Check all inputs carefully. Usually catching `SIGINT`, `SIGQUIT`, `SIGPIPE`, and `SIGTERM` will cover your bases in terms of portable polite requests to die, but `SIGKILL` can’t be caught. You might want to look up whether the file has to be synced after a write in order for results to show up in other processes. I don’t think so, but it shouldn’t matter for a modern OS anyway—only an issue for portability or unusual FS drivers. If you make a “data ready” signal handler, you’ll want a shared (`static` or exported global) `volatile sig_atomic_t` variable by which to communicate with the non-handler portion of the process. `volatile sig_atomic_t` is the only kind of shared state you can safely access from a signal handler, and it’s basically only useful to communicate a byte or less, though AFAICT you’re not guaranteed more than a single bit by POSIX (“an integer”). You just need something to break a `read` or wait loop (e.g., interleaved readiness and `kill(pid, 0)` checks with `nanosleep`s), so one bit suffices. For `sigaction` with `SA_SIGINFO`: /* extern pid_t otherPID = 0; */ /* #define DATA_SIG SIGUSR1 */ static volatile sig_atomic_t sigDataReady = 0; static void signal_handler(int sig, siginfo_t *info, void *env) { assert(sig == DATA_SIG); /* or whichever you’re using */ sigDataReady |= !!(info-&gt;si_pid &lt;= 0 || info-&gt;si_pid == otherPID); } For `sigaction` without `SA_SIGINFO` or (heaven forfend) plain old `signal`: static volatile sig_atomic_t sigDataReady = 0; static void signal_handler(int sig) { assert(sig == DATA_SIG); sigDataReady = 1; } 
If you're doing reference counting, then you're maintaining a count of how many places can still reference the variable. If done correctly, then when the count decrements from 1 to 0 you know that the last reference has gone out of scope (or otherwise become unreachable) and the memory can be freed without a chance of a use-after-free, since by definition you just proved that it's impossible to reference. However, in languages like C where there is no inherent built-in reference counting, this has to be implemented manually, as opposed to other languages where it's done automatically or implicitly by the implementation. If you're increasing and decreasing the count manually, then there's always the opportunity to make a mistake and forget to do the correct operation at the correct time. Among possible bad outcomes, that could lead to the count being decremented to zero (and the resource being freed) when there are still live references, which if accessed would lead to a use-after-free violation. 
So you are saying if you keep track of the reference with a reference count, then free it, it eliminates a use after free? But how? If you keep track of the variable, free, can't you still use it again and still get a use after free? Any example code would help as well. 
I don't speak German, but the [**qsort** docs in German](http://manpages.ubuntu.com/manpages/xenial/de/man3/qsort.3.html) seem pretty easy to find.
Yeah it is totally possible for you to try and use a freed element no matter what you do on the backend of things. The idea is that if implemented in the right way, the memory is properly freed once all references to the structure have given up their reference to it. How could reference counting ever help stop something stupid like int* foo = malloc(1024); // do things free(foo); int x = foo[0]; // error.
Personally I like buffer=NULL, size=0 returns an allocated and filled buffer, and non null, non 0 on n returns size of n filled pre-allocated buffer. Similar to gnus readline I believe. That way you still get the choice.
Also, sum() returns `float` (why float?), but `z` is `int`. Not good. And it's more efficient to use `print` instead of `printf` if the string doesn't contain format specs (`%s`, `%d`, etc).
 if (img-&gt;values[i][j] &gt; img-&gt;maxval) { img-&gt;values [i][j] is a short. But you only read 1 byte from the file. The other byte is uninitialized memory because there's no initialisation after the malloc on line 90 The code presented does not appear to write the header at all. Line 41 is a comment
I would agree completely, I'm also a fan of how the Linux Kernel handles errors. Of course, it's important to also keep things consistent, but that's easier to do when you already have a good system in place. I would add that avoiding `errno` is virtually always the right way to go in my opinion, even if you don't decide to go for the Linux Kernel approach.
Thanks a lot. I will learn from Kim N. King book, LCTHW (for some secure coding notes), and my lecturer notes. 
The problem with the Linux error handling style is that you always need to explicitly catch the return value in a variable to remember it. This is slightly cumbersome; the libc approach of having a variable implicitly storing the error is much easier. Compare: int error; error = some_function(); if (error &lt; 0) { error_handling(error, "some reason"); abort(); } to if (some_function() &lt; 0) { perror("some reason"); abort(); } the latter is just so much easier. Another problem obtains when negative values could possibly be legal return values, then detecting error conditions becomes much more tedious. Easier to let the callee do this and return a binary pass/fail result.
This subreddit is about programmin in C. I have removed your post as both C++ and C# are off topic in this subreddit.
&gt; z=sum Thanks, buddy! I didn't realise that. If I declared z=sum, then z must be float two, or sum should be int.
thanks! I actually don't know how to format it...
thanks, buddy!!! =D sorry for the horrible format of the code. It works now!
You're opening the file twice so you're reading the header twice. The reads on `fp` don't update the filepointer on `fd`. So the first reads on `fd`, which you think are reading the pixels, are reading the header.
The code runs fine; I'll definitely do it on paper. Thanks for the advice! 
This is what we used in my computer architecture class: https://computing.llnl.gov/tutorials/pthreads/
Don't. Use a modern solution for parallel computing like Rust, Go, or Erlang. Seriously, you'll save yourself a lot of headache.
*Programming with POSIX Threads* by David R. Butenhof is solid.
The Linux Programming Guide (which can be found, with other good guides, here http://tldp.org/guides.html) is probably what you're looking for. Pthreads are very efficient and reliable but it's very easy to mess with them, so it would always be a good practice to consult the guide even after finishing the book. 
Everyoje mentioned qsort(), which is what you need. The comparison function should return the difference between the two characters so as to return the correct value for swapping. 
My Computer Systems course used a free online book called [Operating Systems: Three Easy Pieces](http://pages.cs.wisc.edu/~remzi/OSTEP/). The chapters on Concurrency were useful (the book as a whole is pretty good too). 
I did that, I went ahead and started with some python and I was pretty blown away so I understand where people were coming from, but I felt like a couple of them were talking down to me in a way and I just didn't understand it, because I was simply curious about implementing GUI in C, and then I got a bunch of comments telling me how horrible my mentality is and all this... like I never said that C is the only language I want to use, ever. In fact i already had experience with java, c++, pascal, JavaScript, basic, HTML and other things, it just so happened that C is what I wanted to learn about at that time. And people assumed I meant that I started with C and was only willing to continue using C. But anyway, I did start with python and I a amazed. I used tkinter, and I had a UI window up in about 8 lines of code. Overall with python it's basically like a simplified C, I can do anything with about a quarter of the code and in a quarter of the time. It's awesome. Im guessing the trade-off is that python is less capable of low-level memory maneuvering? I like to dabble in a little exploitation, so I enjoy breaking compiled C programs down into assembly code and things like that. I know I can easily find this out but I just like discussing with other coders, does python come with any native disassembly tools for that? 
My best guess is you asked for advice about GUI programming and the first thing I did was express a cavalier attitude about GUI programming. That or they don't take kindly to Python around here. Not sure, I don't hang out here much.
My work focuses in parallel programming. Most parallel applications nowadays use a library that abstracts all the complexity from things like pthreads. So, unless you are writing a library to drive parallel execution or you want to learn the basics, I totally recommend using Open MP. TBB is very good too.
You might be better off asking this question in /r/arduino than here.
&gt; How could reference counting ever help stop something stupid like By never directly invoking malloc or free in your code. Instead, you go through intermediate procedures that keep track of the number of references and only free memory when it is safe to do so.
If I don't invoke malloc or free, there is always still the chance of use after free whenever there is neglegent programmers. Ref counts are only useful for memory management and ensuring that everyone who has ref'd the structure have unref'd it before freeing it.
i know i should be figuring this out on my own but i'd like to ask what other problems are there,i do know that after taking the input for any of the two modes the program simply does nothing and exists.Can you point out why ? 
Does your compiler warn you about anything in your code? You should always have warnings turned on (-Wall -Wextra with GCC).
Nope no warnings
What compiler are you using, and what flags are set? There *should* be warnings in your code. 
I'm assuming you mean "mingw". You should be able to set the compiler flags like /u/raevnos suggested. I forget where in code::blocks to set them. 
Thank you!
Changed it to your way and I get Enter the high value for day 1: 5 Enter the low value for day 1: 1 Enter the high value for day 2: 5 Enter the low value for day 2: 1 Enter the high value for day 3: 5 Enter the low value for day 3: 1 total high 134514200total high 134514200
Pay attention to your data types. The format specifiers in scanf() tell it what data type to expect. Also watch your variable names. Which variables are you using where, and for what? Using more descriptive names instead of single characters will help you determine if the program is doing what you intended it to do. Using single character variable names is generally bad form, and I'll only do that for simple loop counters and such that are used only within a few lines of code.
The variables that store each subject, in your struct definition, are of type `char` and not an array of `char`s. After you fix that, you could do this: printf("\n%s Grade : ", student.sub1); ... printf("\n%s Grade : ", student.sub2); ... etc You replace the `Subject 1`, `Subject 2` etc in each of your `printf` string literals, with %s. %s is the modifier for printing a string, that's being passed on to `printf` as an extra argument. Example uses: printf("%s", "Hello"); //will print "Hello" char msg[50] = "Hello world"; printf("%s test %s", msg, "tost"); //will print "Hello world test tost" 
There's always a chance that you'll do something you don't mean to. You do the best you can to mitigate the easily preventable problems. That's just the nature of the thing.
A test should be done on data set close to real data. A solution would be to use generic algorithms with step argument (i.e. which store data in a contiguous array and use size of the single element to step through it). Things like `lsearch`, `bsearch`, `qsort` etc.
There is cachegrind builtin to valgrind if you want to look at the caching profile of the void data structure. valgrind --tool=cachegrind ./application but you'd want a visualizing software to view the output.
Why, exactly? Are you trying to see enter the "if block"? `if(x&gt;0 &amp;&amp; y&gt;0)` works perfectly well for that.
It does nothing because none of your cases apply to the input it's getting. Add a default case to your switch and have it output some debug data to figure out why neither of your cases are being triggered by your input. 
Thank you so much! It slipped my mind that I was to use an array of characters.
&gt; Finally, although not the source of your bug int x,y,a=0; isn't doing what I suspect you think it is. How can i fix it, thx
Thanks! I didn't notice this lack of consistence and it was very pertinent.
The choice of variadic functions was because in the most common use case I know the number of elements, but not their contents (think string "formatting" in environments without strnprintf/asprintf, C89 only). Were I to use an array representation I'd have to always initialize a variable first before calling the function. It's not the end of the world, but I figured using varargs for that would make the usage simpler. Anyways, I ended up using another strategy for this use-case, so the code ended up being more of an opportunity to explore alternatives and get some nice peer review. Thanks!
It's cute, but I have an aversion to writing code that I hope will catch future bugs of mine. I'd rather just avoid the future bugs in the first place, by compiling with `-Wswitch`
Interesting read that of the single-use functions. Thanks for linking. In this case, however, the compute_joined_length is purely functional and static to this compilation unit so pretty much all of Carmack's reasons to avoid it go out of the window. It could be faster, but I hope the compiler does a good job inlining a single-use, purely functional, static function :D Thanks for your time reviewing and benchmarking. It was really appreciated.
Yeah, I need to give it another read. My first pass didn't turn on any lightbulbs for me. I'm averse to "surprising" code practices unless they really deliver on some other *measurable* front (e.g. bugs, performance, ... *something*). 
If you want to declare and initalise 3 variables, then you need 3 `=`; int a=0,b=0,c=0; Or, more clearly; int a=0; int b=0; int c=0;
You have posted a duplicate post. I will be removing this one so that conversation on your problem can stick to one place.
Nope. strncpy() is actually harder to use and more error prone due to oddities in when it does or doesn't 0 terminate the copied string.
Not sure where to start with this one. Maybe poor syntax. if ((num &gt;= CMD1) &amp;&amp; (num &lt; END_CMD)) return true; return false; Gross. Also the solution is broken, if the enum is updated from enum { CMD1, CMD2, CMD3, CMD4, END_CMD}; to: enum { CMD1, CMD2=10, CMD3=20, CMD4, END_CMD}; Then calling the function where x=15 returns true as a valid command even though it's not enumerated. If you want to keep enums in sync for something just use an xmacro.
It's probably not printing anything because after the user inputs a single '.', arrays is filled by some number of length 0 strings. Lots of issues with what to copy when and how many times... Do you really want to populate the array with the last line read minus one character, reallocate the array to the same size, and then recopy that same line into every element, leaking all of the first copies? And then leak the array the next time through the loop when you allocate an array one element larger?
Fantastic option, had no idea it even existed, and had to look it up: &gt; -Wswitch: Warn whenever a switch statement has an index of enumerated type and lacks a case for one or more of the named codes of that enumeration. (The presence of a default label prevents this warning.) case labels outside the enumeration range also provoke warnings when this option is used (even if there is a default label).
In your printf statements, you don't need the &amp; symbol. The &amp; gives the address of the variable,so instead of printing the variables you are actually printing their addresses!
oh ok. I knew it had to be something stupid with the addresses. thanks man.
&gt; So it'd be expected to be running with the "default" allocator/free. The problem is that your module (if in a .so file) might not be using the same malloc/free as main. This is okay -- malloc/free support multiple heaps, but you can't allocate on one and free on the other. This causes weird errors and segfaults that surprise people when this happens. Better to, when having an API malloc, also have a sibling call that frees so that you never have an issue.
Yeah, there were some other things that don't sit right with me either. For example, he just does `STATUS1 = 10`, so what happens if you have more than 10 commands? Since adding new commands is the whole point he's making here, he probably should've done something like `STATUS1 = END_CMD + 1`. Edit: I don't mean to be overly critical. Just something I wanted to point out.
Hi pbohun, one last question. Is there a way to make this look better? #include &lt;stdio.h&gt; #define NUMS 4 int main(void){ int i; int high, low; int dayHigh[NUMS]; int dayLow[NUMS]; int lowestDay = 0; int highestDay = 0; double totalHigh = 0; double totalLow = 0; double average = 0; double lowestTemp = 0; double highestTemp = 0; printf("___===IPC Temperature Analyzer===___\n"); printf("\n"); for(i=1; i &lt;= NUMS; i++){ printf("Enter the high value for day %d: ", i); scanf("%d", &amp;high); printf("\n"); printf("Enter the low value for day %d: ", i); scanf("%d", &amp;low); printf("\n"); while( high &lt; -40 || high &gt; 40 || low &lt; -40 || low &gt; 40 || high &lt; low){ printf("Incorrect values, temperatures must be in the range -40 to 40, high must be greater than low.\n"); printf("\n"); printf("Enter the high value for day %d: ", i); scanf("%d", &amp;high); printf("\n"); printf("Enter the low value for day %d: ", i); scanf("%d", &amp;low); printf("\n"); } totalHigh += high; totalLow += low; dayHigh[i] = high; dayLow[i] = low; } lowestTemp = dayLow[0]; for (i=1; i &lt; NUMS; i++){ if(dayLow[i] &lt; lowestTemp){ lowestTemp = dayLow[i]; lowestDay = i; } } highestTemp = dayHigh[0]; for (i=1; i &lt; NUMS; i++){ if(dayHigh[i] &gt; highestTemp){ highestTemp = dayHigh[i]; highestDay = i; } } average = ((totalHigh / NUMS) + (totalLow / NUMS)) / 2; printf("The average (mean) %.2lf\n", average); printf("The highest temperature was %.2lf on day %d. \n", highestTemp, highestDay); printf("The lowest temperature was %.2lf on day %d. \n", lowestTemp, lowestDay); return 0; } 
The entire body of your while loop is wrong. Just throw away your current code and restart from scratch, paying close attention to when you call malloc() and when you call realloc() and being careful to not assign a new address returned by malloc() to a pointer that already holds an address.
Put me down for the paper bag and MISRA complaints, thanks
In the lines: int i = 1; int fact = n; where do you declare `n`?
I could be wrong, but with function pointers don't you lose the benefits of branch prediction? You'd also lose the penalty of a misprediction, but it's something to be aware of.
Just use `\n`. If you've opened the file in text-mode (default setting, or explicitly using `t` in the mode-parameter), it'll do the `\n`-to-`\n\r`-conversation automatically. Also, there shouldn't be a space between `\n` and `\r`.
Check if `(x1 - x2)(y2 - y3) == (x2 - x3)(y1 - y2)`, that should be sufficient.
You'd usually use a global variable to do this kind of thing. However, since you excluded what is likely the only sensible solution, here are some other ideas: * if you are afraid of global variables, you could also write the data to a file. Files are just as global, but they are not called “global variable” so everything is fine. * You could write a byte into a pipe and read it from within your main program. Just as global, but not called a global variable either. You might want to store the file descriptor number for the pipe in a global variable though. Note that in all cases, your code has a race condition: a `SIGUSR2` could appear before your `SIGUSR1` handler is done. This issue is difficult to address, I recommend you to send back a signal indicating that you processed the previous signal.
I took a look at this with clang at -O3 optimization level, after changing the id member of message to uint8_t id: 3, versus the int above. Trades off alignment for packing efficiency. No other change to the above, and got this: 1 .text 2 .file "switch_abuse.c" 3 .globl process_message 4 .align 16, 0x90 5 .type process_message,@function 6 process_message: # @process_message 7 .cfi_startproc 8 # BB#0: 9 pushq %rbp 10 .Ltmp0: 11 .cfi_def_cfa_offset 16 12 .Ltmp1: 13 .cfi_offset %rbp, -16 14 movq %rsp, %rbp 15 .Ltmp2: 16 .cfi_def_cfa_register %rbp 17 movl %edi, %eax 18 andl $7, %eax 19 popq %rbp 20 jmpq *f(,%rax,8) # TAILCALL 21 .Lfunc_end0: 22 .size process_message, .Lfunc_end0-process_message 23 .cfi_endproc 24 25 .type f,@object # @f 26 .section .rodata,"a",@progbits 27 .align 16 28 f: 29 .quad process_cmd_message 30 .quad process_cmd_message 31 .quad process_cmd_message 32 .quad process_cmd_message 33 .quad process_status_message 34 .quad process_status_message 35 .quad process_status_message 36 .size f, 56 37 38 39 .ident "FreeBSD clang version 3.8.0 (tags/RELEASE_380/final 262564) (based on LLVM 3.8.0)" 40 .section ".note.GNU-stack","",@progbits As you can see, line 20 is the branch; it's now an indirect jump, as expected, rather than a conditional branch. In terms of branch prediction, this varies significantly by microarchitecture. (See [here](http://www.agner.org/optimize/microarchitecture.pdf) for a great rundown for various x86[-64] microarchitectures.) Page 35 talks about it for older architectures, and then it changes as we move forward. There is no longer a conditional branch to speculatively start executing both halves of in the same way, but the branch prediction engine does still come into play. On the old architectures, the first time an indirect jump is encountered, it is predicted to proceed at the following instruction (as though it were a 'nop'), and on following branches, it is predicted to branch to the target that it branched to last time. Note that while we have 7 possible messages in this example, we only have two possible branch targets. Therefore, the branch prediction will work much like it would with a single conditional branch. (Predicting correctly any time both the last, and current, messages were CMD or STATUS messages, otherwise, wrongly.) As we move forward through the generations of microarchitectures, we get more evolved multi-tiered Branch Target Buffer tables. But what do we know about the behavior absent branch prediction? So, naively we might expect to reach our indirect jump and have to pipeline stall while we wait for the pointer to be fetched from main memory (hurry up and wait). It's in an .rodata section, rather than a .text section, so it probably wouldn't have been fetched along with the code page. However, at least with our trivial example, we also see that our entire function pointer table is just 56 bytes in size (as we would expect on 64-bit architecture). Also, the reference to f is quite predictable (the offset within f is not known in advance, but f will clearly be needed). Since the entire array is so small, when f gets (almost certainly pre-)fetched, the entire array comes along and fits in one cache line. So even the first time it is encountered, while we probably branch mispredict with no branch history, the indirect branch lookup can likely be satisfied from the L1 cache (on the order of 200x faster than if a main memory lookup were required). Subsequent encounters will depend on the microarchitecture-specific BTB prediction capabilities, but likely work well if there is a reasonably stable pattern to lock onto.
Other things wrong: - Your `printf` prompt should probably end in `"\n"` or `": "` so the user doesn’t end up tacking characters onto it, and you should probably make a nice prompt so the user has some idea of what to enter. E.g., printf("Select mode:\n" "a - Angles\n" "b - Side lengths\n" "&gt; "); Prompt consistently and politely. - `fflush(stdout)` between a prompt and a `scanf`, since you’re not guaranteed that `stdout` will flush before `stdin` is read. When you `printf`, characters may be saved up so they can be dumped in large blocks rather than one at a time. `stdout` may or may not go to a terminal—it might go to a file or nothing at all—and `stdin` may be completely independent. Some C libraries will auto-flush for you sometimes, but don’t rely on it. - You’re using the wrong `scanf` format string; you’re asking for a floating-point number, so `scanf` will write a 4-byte `float` value to your 1-byte `char` variable `a`, which constitutes a buffer overflow vulnerability. Use `scanf("%c ", &amp;a);` instead; the `%c` means “a character” and the trailing space means “discard any newline/space after it”. - *Always* check your input assiduously. You cannot trust the user, even if it’s you. `scanf` might not read anything successfully, and it might read a bogus character. It returns the number of things it read, so you want something like if(scanf("%c", &amp;a) &lt; 1) { fputs("error: invalid input\n", stderr); return 1; } to handle the case where you don’t successfully read. - When you `scanf("%f %f %f", &amp;x, &amp;b, &amp;c)`, you’re reading a `float` into `x`, which is a `float` variable so that’s fine, then you’re reading one into `b`, which is a `char` variable so buffer overflow, then you’re reading one into `c` which is a `float` again, and then since you don’t have a trailing space in your format string you’re potentially leaving a newline or space for a future `scanf` statement to pick up. Name, scope, and type your variables properly, and check your `scanf` output. E.g., kill all declarations and replace `char a` with `char mode`, which you should `scanf` into instead of `a`: switch(mode) { float val1, val2, val3; case 'a': if(scanf("%f %f %f ", &amp;val1, &amp;val2, &amp;val3) &lt; 3) { fputs("error: invalid/insufficient input (expected three angles)\n", stderr); return 1; } ... case 'b': if(scanf("%f %f %f ", &amp;val1, &amp;val2, &amp;val3) &lt; 3) { fputs("error: invalid/insufficient input (expected three lengths)\n", stderr); return 1; } ... } Inputting three numbers, absolutifying them, and checking their nonzeroness is probably a good thing to factor into its own function `static int read3float(float *v1, float *v2, float *v3, const char *what)` which you could use as `if(!read3float(&amp;val1, &amp;val2, &amp;val3, "angle")) return 1;`. - Any one of the input numbers could be negative or zero-ish and screw things up. You should probably do val1 = fabs(val1); val2 = fabs(val2); val3 = fabs(val3); first, then make sure they aren’t `&lt;` some epsilon value: if(val1 &lt; EPSILON || val2 &lt; EPSILON || val3 &lt; EPSILON) { fputs("error: one or more angles is zero or too small to handle\n", stderr); return 1; } if(val1 &gt;= 180.0F - EPSILON || val2 &gt;= 180.0F - EPSILON || val3 &gt;= 180.0F - EPSILON) { fputs("error: one or more angles is too large\n", stderr); return 1; } You’ll probably want to `#define EPSILON 0.000001F` or something like that up near the top. Don’t make it too small; `1e-7F` is down around the smallest value a `float` can represent under normal (har har) circumstances. - Floating-point values are not integers, and should not be treated as such. They’re basically tiny ranges of the real number set. `1F` is not 1, it’s 1ish. Comparing two f.p. numbers requires you to fudge a bit, because there are values the user could enter that actually sum to 180, but the sum of whose f.p. representations, or the f.p. representation of that sum, won’t equal `180F` exactly. To compare something as sufficiently-equal to something else: if(fabs(val1 + val2 + val3 - 180.0F) &lt; EPSILON) {/* equal-ish */} else {/* not equal-ish */} - Your `if(a+b+c = 180)` isn’t a valid statement in the first place, and if you didn’t fix it I cannot believe you actually compiled the code without warnings or errors. First off, `=` *assigns* the right-hand expression to the left-hand side, whereas `==` compares the two sides for equality. You’re assigning the value 180 to the sum of `a`, `b`, and `c` (where `a` is a completely unrelated `char`, mind you!). - `switch` statements should usually have `default` labels, and this is no exception. If the user enters anything other than `a` or `b`, you need to tick them off properly. default: fputs("error: invalid mode\n", stderr); return 1; If you want it to repeat, you need to (a.) put it in a loop, and (b.) change your prompt so the user can exit without EOFing: char exit_loop = 0; do { char mode; printf("Select...\n" "...\n" "x - Exit\n" "&gt; "); if(scanf(...) &lt; 1) break; switch(mode) { ... case 'x': exit_loop = 1; break; ... } } while(!exit_loop); return 0; Most `return 1;`s in the above code should have `if(!feof(stdin)) continue;`s inserted beforehand so an invalid input drops the user back at the prompt. (Though `fgets` would be more appropriate in general; you can `sscanf` from whatever it gives you.)
That was really great comment,you dived into detail thank you for explaining where i went wrong and yes i did realize i used = instead of == late into the night.
This is a very silly way to do IPC. If you're set on doing it for the humor value, then consider making the protocol bidirectional -- have the receiver ACK for each bit by sending another signal back. The sender should not send the next bit until it sees the ACK. Otherwise you have no way to guarantee the signals are received in the same order or the same number of times as they are sent. Also, it's not clear from your snippet -- you do realize `sigaction` is used to set up a signal handler, not to receive a signal, right? You do need to install a handler. The best way for the handler to record what happened is through a global variable. Be sure to declare it `volatile`. Better IPC mechanisms: pipe (if the processes have a common ancestor), named pipe (if they do not), Unix domain datagram socket, probably others. Edit: even with a bidirectional protocol, you'll need some way to determine where each word of data starts.
`sigaction` doesn’t receive a signal, it *sets the action that should be taken when a signal is received.* A signal handler is usually just a `static` function (you don’t want just anybody calling it casually): static void signal_handler(int, siginfo_t *,void *); /* if SA_SIGINFO included in flags */ static void signal_handler(int); /* if not */ ... struct sigaction action; memset(&amp;action, 0, sizeof(action)); action.sa_sigaction = signal_handler; /* if SA_SIGINFO */ action.sa_handler = signal_handler; /* if not */ sigemptyset(&amp;action.sa_mask); sigaddset(&amp;action.sa_mask, SIGUSR1); /* maybe */ action.sa_flags = SA_RESTART | SA_SIGINFO/*maybe*/ | SA_NODEFER /*maybe*/; if(sigaction(SIGUSR1, &amp;action, NULL)) { fputs("error: unable to set SIGUSR1 handler\n", stderr); return 1; } (Note that only one of each pair of lines involving `signal_handler` should be used. `struct sigaction` contains potentially-overlapping fields, so always `memset` it first and then set only the fields you need.) The kernel maintains a table of signal action entries often referred to as “vectors,” usually 1 table per process and 1 entry per signal (`man 7 signal` for a list). `sigaction` and `signal` access this table, and optionally return the former handler to you so you can save/restore them (e.g., LIFO). When a signal is sent to a process via `kill`, it usually raises a “signal present” flag associated with the vector, and if there isn’t already a signal handler active for that signal (depending on flags), it sets a “handler active” flag, suspends execution in the process, preps the stack and arguments, and jumps into the handler function, making it look as if the formerly executing function had suddenly called it. `SA_NODEFER` causes the “present” flag to be cleared before calling, and when the handler returns the “active” flag is cleared. Sending a signal with `sigqueue` will stack up signals so they’re received one-by-one, instead of just flagging that one or more of that signal has been sent. Flags you pass to `sigaction` can affect how signals are delivered, and there’s a whole history of different UNIX and POSIX OS behaviors here so it’s very tricky to do signal handling portably and correctly at the same time. In general, do not assume signals have come from any specific process, do not assume that only one signal has been sent, and do not assume that there’s any correspondence between signals sent and handler calls beyond ≥1 signal → ≥1 call. `pause` will wait until one or more signals has occurred, and will return after the handler(s) in question has(/ve) been called. Again, it’s possible that more than one signal has been folded into a single call, and it’s possible that more than one signal was received before the call ends, so it’s not a “receive 1 signal” function either. Your signal handler will have to delicately poke the main loop via twiddling of static/global `volatile sig_atomic_t` variables, after checking whatever arguments it’s given as thoroughly as possible—again, you could just `kill` the thing from anywhere and easily screw thngs up. So `pause` until one of them is set, add the appropriate bit, signal the sender that it can pass the next bit, and loop back around to the `pause` sub-loop. You can twiddle with the signal mask to try to limit when things are delivered, but it’s not going to be precise unless you start with `USR1`/`USR2` masked and use something like `sigsuspend` to only expose those two when you’e waiting, and even then it’s not going to behave perfectly. The `sa_mask` and `SA_NODEFER` stuff up in the above code tells the kernel what to do if it gets a `SIGUSR1` while in the `SIGUSR1` handler. Options: - `SA_NODEFER` without `sigaddset`: Any signal(s) can trigger the handler at any time, even while the handler is running. Multiple signals can still be folded into a single handler call unless queued, but it’s less likely. You’ll need to account for handlers being nested at arbitrary points, which is not easy to do right. - neither `SA_NODEFER` nor `sigaddset`: Handler calls for `SIGUSR1` will be blocked while inside the handler. - `sigaddset` with `SA_NODEFER`: Just before starting a signal handler, the signal mask will be set to exclude `SIGUSR1` from happening, though you can explicitly allow it by changing the mask. - `sigaddset` without `SA_NODEFER`: Has no real effect; `SIGUSR1` will be blocked until the handler returns and AFAIK twiddling the mask within the handler has no effect on that.
Or even a hidden global like this. volatile int *explicitly_nonglobal_variable_address(void) { static int just_a_local_nothing_to_see; return &amp;just_a_local_nothing_to_see; } Use it like this. volatile int *address = explicitly_nonglobal_variable_address(); *address = 42; (Still silly.)
Hell, redis is probably a better tool, and the only cases where it would be too heavy-weight would be extreme embedded or realtime environments. But in realtime environments, you can't use something with as few guarantees as signal delivery anyway. 
You could take a look at [Unity](http://www.throwtheswitch.org/unity/) it's a really small library that is easy to use.
Usually you find that your IPC quickly develops additional tumors. TCP sockets would definitely solve many issues, but if you find yourself needing much more, you'll eventually end up re-implementing a good deal of what's already there in redis until you finally give up and just use it :) 
Ctrl+C is interpreted by the terminal driver and thus only works within terminals. To close windows, press the close button or the appropriate hotkey of your window manager.
I see. After reading your comment I researched a bit and understood the problem better. Today I learned! Thank you!
Raspbian is not a window manager, it's a distribution and it supports multiple window managers.
In a file called default-display-manager I have `/usr/sbin/lightdm`.
ALT-F4 is working now, so I am questioning whether or not I pressed it hard enough before! Thanks for your help!
`~0 &lt;&lt; 4` shits the value `~0` (equal to `-1` on two's complent machines) left by four places, leading `-16`. At the same time, `1 &lt;&lt; 4` shifts `1` left by four places, yielding `16`.
`~0 &lt;&lt; 4` is undefined behaviour (left-shifting a negative number). `1 &lt;&lt; 4` means `16`.
If you mean bit pattern 0....01111, then use `15`, or `(1 &lt;&lt; 4) - 1`
If you have a number N you can do N | 15 This will sett the low order 4 bits to 1. 
Thanks for this info! I am going to be programming OpenGL games using Rasp Pi 3 as the hardware (input will be various GPIO, don't worry about that stuff, I know what to do there). At first I looked into using Windows &amp; DirectX, which is what I am most familiar with, but the cost of software is excessive for how many deployments we will need, so cheap Pi's and free software is the realistic road we need to travel. Luckily Nix/GL is not that different than Win/DX, so most of my hangups will come from being a novice at Nix programming. I should be able to pick up the hang of it from examples and demo's. My main concern will be OS related things, such as: * How do I get the game to be the process that boots up first? * What is a Display Manager? What is a Window Manager? Do I need both or either of them to do fullscreen OGL? * Can I just have Raspbian boot directly into a fullscreen process (after it boots up and init's all of the hardware+drivers of course)?
 ~ means negation. So when you attache it to 0, you're essentially saying 1.
i actually found qdecoder is more complete and probably "better", license is good too.
It's negative (assuming 2's compliment), which is what makes it undefined.
Without any size modifiers, 0 is an int.
No. \~ is only negation in the bitwise sense - 1's become 0's and vis versa. 
No. Not free-ing is really just the same thing as saying, "I'm using this memory forever". It won't cause a segfault, but it will cause a memory leak - things that aren't being used anymore must be let go of, so that the space can be reused. By removing the free's, you're just applying a bandaid to the problem. You need to figure out why your program is trying to use memory that doesn't exist anymore, and address that problem. If you think this is annoying, stupid, painful, or dumb, then perhaps you're not ready for C++. 
Try writing the declaration for a function that returns a pointer to a function, both with and without using a typedef for the function pointer. Which one is easier to read and write? 
In 2's complement it's -1. In sign-magnitude it's `INT_MIN`. In 1's complement it's "negative zero" , the behaviour of which is a combination implementation-defined and unspecified.
Thanks. I'm not removing the free's to bandaid the problem, but in an (admittedly inefficient) attempt to check my hypothesis that I've accidentally freed memory when I shouldn't have.
I have no idea what the first sentence even means. Is this a riddle?
Actually declarations use infix notation . Only certain basic types match the pattern "type name". `int x[5];` is a simple counterexample. 
can u try to translate it? u want to delete a node?
Take this with a grain of salt as I'm a C programmer, not a C++ one, but it's typically good hygiene to set pointers to NULL after you free them - this makes it obvious if you accidentally reference something that has been freed. 
vs. a #define ?
okay thank you a lot :D
aight im back soo if u are only trying to delete the second node what u need to do is this void deletesecond(struct t_node *head){ //make a temp node struct t_node * temp_node; //makes the temp node equal to the second node temp_node = head-&gt;next-&gt;next; head-&gt;next = temp_node-&gt;next; free(temp_node) } i think its like that so what u do is make a temp node set that node equal to the second node (u are deleting this one) then u set the first nodes next field equal to the 2nd nodes next field, then u delete the temp node, i hope i didnt confuse u, and my code might not be correct format i just dont remember C that well atm but that should be the jist of it 
I doubt that it is... `-1 &lt;&lt; 4` would be undefined, because you cannot be sure of the bit representation of -1. But `~0` is all bits set. `&lt;&lt;` ignores overflow, so you simply end up with all higher bits set, and the bottom 4 bits cleared. That is -16 in 2's complement , but you can't be sure of that in general. 
If you can't be sure it's not undefined, then it is not defined! `-1 &lt;&lt; 4` is undefined behaviour in all representations, left-shift is only defined for non-negative values.
`#define` has a whole lot more problems.
There's a (large) school of thought that it can do just the opposite, on both counts. 
That school should be shut down. However, pointer typedefs should be avoided, generally speaking. 
You can talk to Linus Torvalds, if you like. 
&gt; `-1 &lt;&lt; 4` is undefined behaviour But it is `~0`, not `-1`. Maybe the numerical value of `~0&lt;&lt;4` as an integer is "undefined", but its binary representation is not. n.b. an alternative is `~15`.
Don't use the preprocessor to lazily fix bad code. 
I'm studying programming at uni, my professor is using typedef for everything even just remaining int as something else for fun, I actually don't know when and where use it anymore
There is no need for guessing, if you are using a modern version of the g++/clang you can use -fsanitize=address,leak to find the cause of this problem. If your compiler does not support this option use the valgrind program. is better to compiler with the -g (debug) flag for both options.
Ohh Ok, I just wanted help. I'm a beginner in C programming, that's why I need some help. I came across this problem and don't know how can I write it's expression for checking the collinearity of three points.. Here is the expression that I've impelmented in the C program. x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)==0 Will this work ?
`[5]` is not part of the type name. Perhaps I should have written type expression; which is closer to what the standard says. The way to remember the C declaration syntax is this: To the left, there is a type name and to the right an expression involving the variable you want to declare that would yield something of that type.
Yes. That's what I said.
/u/VincentDankGogh asked if it was “defined behaviour” to which I answered ”No, it's not.” Not sure where your confusion lies.
That's not standard C, I strongly advise against using that notation.
Linus is all for typedefs in certain situations -- e.g: when you want to abstract what the underlying type is.
Textual substitution (`#define`) does not work well for types. e.g: #define my_func_ptr void (*)(int) This would work: void some_func(my_func_ptr); But this would not: my_func_ptr x; Whereas a `typedef` makes a new valid name usable as a base-type in a declaration expression, and other grammar contexts.
Of course very few people argue that portability typedefs are bad. However, personally I do not typedef structures: typedef struct mystruct foobar because that hides that `foobar` is a structure type, pollutes another name space and is just plain useless.
Note that C doesn't have the `delete` operator; you seem to be programming in C++. Please ask C++ questions in /r/cpp_questions. I have removed your post as it is off topic.
Um, no it doesn't?
I have never used an IDE for C programming. I consider an IDE to be distracting and useless; one more component to fight with in the struggle to write good code.
What is UNIX command ? will it work for windows ?
I don't know, I never use it. but you can install a free gnu/linux distribution using virtual box first, and then install it properly by partitioning your storage disk if it's large enough. these all give you access to a unix command line.
I use Dev C++. And there was nothing to do with any preferences neede to compile the program.
calloc exists, dawg
Visual Studio have it's own keywords of C language, which are different, or somewhat different from original C keywords.
CodeBlocks with gcc compiler.Yes i know its used often by newbies and students but its the only ide that doesn't require one to start a project.Its great for quick practice and snippets.
&gt; What is UNIX command If you are on Windows, you can try `bash on windows`. It's only available on Windows 10, though. Even you don't have Win10, you can still install cygwin. 
Slightly complicated C programs often require custom make files as you might need different compiler settings for different source files (e.g. if you have a 3rd party source file that requires GNU89 mode, you need to change settings just for that). Often you also need some sort of configuration (easiest case: Whether to pass `-DNDEBUG` or not), machinery to generate source code or to package different source files into different libraries. Tedious to do with an IDE.
He asked for the best IDE for C, not C++.
EDIT: Sorry i have no idea how to format code here, brb EDIT2: There we go Sure! For example, to define a structure, you could write struct tBook { char * name; int prize; } And to create a tBook structure you would have to write struct tBook example1 or, best case scenario, you write example1 after the '}'. OR, you could use typedef typedef struct //(1) { char* name; int prize; }tBook Then, if you want to create a structure you just write tBook example1, so its clear that example1 is a tBook structure. (1) If you need to write a recursive structure then you should write something here, like bookType or something like that. A bad situation would be to use it just to replace the name int with something that caracterizes what you are declaring, like: typedef int price; price priceBook; price priceDoor; It's bad style because if you have a big project and you do this, sometimes seeing price priceBook doesn't tell you nothing about the type of data, (is it int?, double?,float?) so you would have to go to the typedef everytime, same happens in a big project with a lot of people: no one will understand your code because every time they see something like that they will have to go up to the typedef, which can be a very dull and boring task. 
Heyy I just answered CMDRStephano where I use typedef and where I think is wrong to use it, I think it might help you too!
I misread and thought the question asked if it is undefined. I've corrected my comment. I'm sorry
You're right. Note my correction 
To create abstract data types (ADT). In summary, an ADT is a definition of a domain, a co-domain, and a set of valid operations. It's a mathematical thing brought to computer science. The types (int) and (float) are ADT. The language provides means for you to create objects of those types and operators to manipulate them. You don't need to know how they work internally, only the pre-conditions and post-conditions of their operations. For instance, you don't need to know what the architecture does when you add `INT_MAX+1`, only that it's not "allowed". ^*note* For your own and for more "complex" ADTs, there are typedefs. (FILE) is an ADT. The languages give you a name for this type and a set of standard operations for you to use. Even though you can manipulate those objects directly, you should always use the functions provided by the standard. You can, of course, use typedefs for anything you want. You can typedef (height) or (color). But you will realize very soon that they are not useful when you need to know the inner workings of stuff. Otherwise you'll start running into situations where you have to ask yourself whether you should dereferrence or `free()` an object of type (stack). Speaking of that, pointers are also ADT. So there's a general rule that you should never use a typedef to "hide" a pointer. Even if you are the author of the library, it just makes things more confusing. That's why you have to declare a *pointer to* (FILE), not a (FILE) object itself that's internally a pointer. ---- Note: `INT_MAX+1` is undefined behavior, but it's not the inner workings of this that you, as a developer must know. What you must know is that `(int)` and `+` do not form a closed set, that is, `INT_MAX+1` does not belong to the set of `(int)`. On the other hand, for `(unsigned)` it does and is equal to `0` in the co-domain.
No idea what you're talking about. You can do ANSI C just fine in Visual Studio
some functions are different, like _getch(), an underscore in it. 
Thanks, I'll try it.
Vim + command-line tools. But it's an aquired taste (and "old-school"), and if you're used to actual integrated IDEs you might have a bit of a time adapting.
Visual Studio Code, clang, lldb. This is your answer.
So which one will you prefer ? IDE or editor, command line ?? which one ? 
I suspect you mean concurrent programming rather than parallel
An IDE is an integrated development environment. The difference is in definition seems to be the cohesiveness of the softwares in the environment. The command line + vim has every feature any ide has.
I never said they are "just text editors". I said "just disrespectful". Please don't twist my words.
Most compilers have their own extensions, including gcc (used to be what dev c++ used) and clang. 
I thought microsofts c compiler only handled a really old standard, c89 maybe?
It only supports CMake for right now. That's not a problem, however. You can just ignore it and use makefiles via the terminal. And I think you can create your own build configuration to use makefiles too. I don't know about C11 support, but I think they added it a while ago.
Vim.
Realistically VIM or Emacs should be considered to be IDE's just as complete as any other once you get it set up how it can be. 
I'm not trying to twist your words, I'm trying to point out recommending unix + vim is not disrespectful, it is disrespectful to try an preempt that alternative, because it doesn't meet a stricter definition of an ide.
Mmmmh, dont get your hopes up. Bash on windows is only a way to have the Linux userland API working on Windows. It will allow you to use the kind of tools used by UNIX programmers, a lot of whom are on Linux. But in and of itself, it won't help you. Moreover, if you are asking what is the command line, I will probably take some time for you to get used to it, nevermind get productive with C programming. So, yeah, some people use those tools (I do for example, and my job is to write drivers for Linux in C), but it may not be the best ones in your context and your projects.
I'll second this. Combine with cmake for best results. 
Prob great but it should be free. 
I use neither of them.
nano without partylights.
cool. I've used nano quite a bit for quick notes during classes, but not really for any projects.
My comment "-1 &lt;&lt; 4 is undefined behaviour" was in response to your comment asking about the behaviour of specifically "-1 &lt;&lt; 4". You can't respond to that with "But it is ~0". &gt;Maybe the numerical value of ~0&lt;&lt;4 as an integer is "undefined", but its binary representation is not. No, if the expression `~0 &lt;&lt; 4` is executed then the entire program has undefined behaviour. Which means anything could happen. There's no such thing as "undefined value". 
It's not. He specifically asked for IDEs. So try and answer an IDE. Simple as that. I say this because from both sides it just confuses beginners too much. I've already seen lots of people saying "What's a good text editor for C?" and people answering that IDEs are better suited, and then the beginner started thinking that IDEs were text editors and... Well, it was just bad. If he had asked for a good text editor, I'd gladly recommend VisualStudio Code. But he asked for IDE, so I recommended CLion. In programmer words, I'm strongly typed.
Mods pls
So is there a way around it? Any ideas on what other methods to use but achieve the same functionality that i wanted.
Check out `asprintf`: int main(int argc, char** argv){ char *new_str; asprintf(&amp;new_str, "%sinput", argv[1]); printf("%s\n", new_str); free(new_str); return 0; }
Definitely C is not the best tool for what are you trying to do. Actually a simple shell script can be used and probably this solution will be more practical since all the tools likely to be used are already included on the distribution that you use.
In the way that it's not integrated. It's a great development environment that I use myself :D It's not integrated, however, since you can use that environment for waaaaay more than just developing and the tools are all stand-alone. It's just a matter of dictionary definition. We all know that both ways lead to the same thing (finished software) :P 
I think it generally comes all preinstalled in any linux distrobution. So perhaps linux is an ide. I'm sure the different tools in an ide are different packages. Eclipse for instance has lots of plugins. I understand there can be a distinction, but not enough imo to be excluded from an alternative ide.
Thanks very much!
I doubt that will ever happen -- i mean webstorm has been around for years and isnt free. QtCreator/KDevelop are much better options if they are supported on your platform. They are just as good and are free. Actually I would us VS on windows and Xcode on mac, QtCreator on linux.
unix+vim (or in my case, unix+emacs) is a "development environment" but by no means an "integrated development environment." 
vim is life boysss
Thanks man. C memory management is still really iffy to me.
Well my thinking was this: Bash syntax is very foreign to me and I'm not quite in the mood to learn any as of right now. Yes, I agree with you though that C is not as good as Bash for this. For the most part though, I knew what I needed to do to get this C program running. Also I'm currently reading through the K&amp;R book so thought this would be an ok supplement to it. And I figured that most distros would have the tools I needed by default. Just a little personal thing I'm doing for fun :). It's given me a little insight into argv and how I can use it so now I know what all those command-line arguments are for. I find C very interesting and as first little project, this fit my size and scope of knowledge fairly well.
When it lacks an integrated visual debugger, I think.
If you want to stick with MinGW, and like the simplicity and light-weight aspect of DevC++ then I'd recommend checking out MinGWStudio. It is no longer being actively developed (but neither is DevC++) and is much more stable. It's almost exactly identical to DevC++ and there is a site out there where someone is actively repackaging it with newer versions of GCC all the time. I used DevC++ for a few years about a decade ago until I found MinGWStudio and have been using it since.
I mean, stdio.h isn't the problem, so.....
why would you do that
laziness to type whatever i need :p 
Can you name a compiler that doesn't support it? (With out looking it up!)
[removed]
scanf reads only the input you specify in the format string, so for example the enter key you press is still in the input buffer. You can work around that by using a space in the format string which reads away any whitespace including \n; `scanf(" %d", &amp;num)` For this however it might be easier to check the return value of scanf in a while loop instead of a do loop. It returns the values read so in this case must be 1. How about while (scanf(" %d", &amp;num) == 1) { ? Edit: num/num is quite dangerous. num can be 0 for instance.
`find /usr/include -name \*.h -printf '#include &lt;%P&gt;\n' &gt;all.h` Now you can `#include "all.h"` to your heart's content. Note that this is an incredibly stupid thing to do.
Your setup sounds similar to mind. FreeBSD with vim and that's all I need. [Unix is my IDE.](https://sanctum.geek.nz/arabesque/unix-as-ide-introduction/)
Vim or die 
It means than one thread can access any memory, whatever kind it might be, of another thread that runs in the same process. This is in contrast to processes, where one process can not access any memory of another process.
I'd use 0xF personally, but to each their own
Right, and to specifically answer your second question: that includes the heap, stack, text, and data segments (i.e. the entire addressable process space). 
The stack space is split up to accommodate each thread, and to allow separate threads of execution to function, but it's all part of the same process space. So while each thread have their own stack, each of those are all together in the same shared process space. **Edit:** if you want to experiment and see what I mean, write a recursive function that contains a local (stack) variable (ideally an array), and print its address on each call. Then run it in parallel across a few threads. You'll see where in the stack each is operating, and you'll notice you get fewer recursive calls before blowing the stack in a multi-threaded environment. 
Maybe it would help to back up a bit. All memory has an address. The CPU can't access a variable, a function, a stack frame or anything without having its address in a register.\* C makes addresses explicit through pointers and the address-of operator, `&amp;`. In a multi-process operating system, each process has an address space. The address space is a mapping from addresses to memory. The CPU's virtual memory hardware makes the mapping happen. So if you run two simultaneous copies of the same program, and they both think the variable `foo` is at address 0x1000, then the OS sets up two different address spaces, where address 0x1000 references different memory for each process. Other programs can use address 0x1000 for other purposes, and each will get its own copy. The difference between processes and threads is that each process has an address space, and each process has one or more threads that all share the same address space. \* There are several oversimplifications here. Trying to explain the concept, not the exceptions. 
If it hides information that you want exposed, it's harmful. If it hides information that you want hidden, it's useful.
great project
scanf_s isn't a standard function. There are different implementations of the standard c library. There is a minimum to be compliant with the specification, but you can have non standard functions too. So scanf_s would likely only be used on windows only applications. Tangentially, yes there are a lot of similar versions to functions. Many of the (n) family. strcat vs strncat, strcpy vs strncpy... Many as you'll note are in the string family, and almost exclusively due to buffer overflows. You manage your own memory in c, so you request a segment of memory, and use it. But if use more than you request (aka buffer overflow), you are invoking undefined behavior. It's bad. So many of the (n) functions are just an explicit size parameter. In some cases it's considered safer, though there are exceptions and differing opinions. Plus, sometimes things get deprecated, but it is still in the library for backwards compatibility, so the new function replacing it generally has a similar name.
you should add in switch: default: printf("Not valid"); break; 
Print that number as hex and you'll see it is 0xc000005 which is an access violation. Which means you've written or read from memory you're not meant to. Your bug is on this line scanf ("%i, &amp;x");
&gt; scanf_s isn't a standard function It's part of the C11 standard.
Terrible default. Good on you for finding it. Cleaner coding for you!! :-)
That's what I "wanted" to use. Even started rewriting the post to use 0x, but in the end, 0b## seemed to be even more obvious I'm acting on specific bits.
Any support for lists or hashes? XD
For a long time the Libc have functions to create a hash table (http://www.gnu.org/software/libc/manual/html_node/Hash-Search-Function.html) and other data structures. However the interface and usability of these functions are not that great.
Interesting... will my ARM compiler be able to link in this code if I include the header?
the buffer is the space allocated on the stack for your variables and other stuff but I'm going to make a super simple explanation. just know that things like arrays (c strings too) have large space on the stack. say you have a string of length 10 and use scanf but the user inputs 100 characters, most implementations of c will happily start writing those 100 characters to memory blowing through the memory you allocated and into reserved memory and start causing havoc. that is too much data entering the buffer (overflowing) and is the reason behind a LOT of annoying errors. these errors are avoided by giving size specifier and using "safe" functions. for instance "%9s" specifier in scanf will make sure that you only read 9 characters (remember to just use buffer size minus one to have space for the null terminator)
You can use a ternary operator, e.g. printf("You have claimed for %d dependent%s\n", depndts, depndts &gt; 1 ? "s" : ""); --- Edit: I've not got time to look at your whole program but it seems you're using the wrong types in `scanf` for the data you are storing them in. `%f` is for a float, but at least one of the targets is an `int`.
Depends on the Libc that is used on your system, glibc, musl have these functions.
Microsoft introduced a bunch of `_s` functions that are supposed to facilitate safer programming (turns out the [don't really](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1967.htm)). Most other vendors decided against implementing them. There is no real risk of buffer overflow in `scanf` unless you use an unqualified `%s` formatting specifier, so don't do that.
In 'How to dynamically allocate a 2D array' you're not actually working with a 2D array, but an array of pointers to the rows. This is different from a 2D array which is a contiguous zone in memory where all the rows are stored. The correct declaration for a pointer to a NxM array of elements of type T is : T (*v)[M]; i.e.: v is a pointer to a row of M elements. With allocation too it is: T (*v)[M]=malloc(sizeof(T)*N*M); Now v behaves like a regular `T v[N][M]`, so it's a 'true' 2D array.
One difference I can think of is that valgrind offers other dynamic analysis tools, like cache profiling, heap profiling, and thread debugging in multithreaded programs. That last one seems to try to detect possible race conditions that aren't protected by a mutex. Clang seems to offer a similar tool aptly named [Thread Sanitizer](https://clang.llvm.org/docs/ThreadSanitizer.html). I haven't tried it yet, but it seems promising, although it could turn out to yield many false positives.
[AddressSanitizer vs Valgrind/Memcheck](https://github.com/google/sanitizers/wiki/AddressSanitizerComparisonOfMemoryTools).
Also I think something should be said for being able to profile a binary without the source.
Address Sanitizer is a security tool. It is for production runtime security. Valgrind can give you lots of information postmortem that address sanitizer won't give you, especially when it comes to heap allocation and leaks. However valgrind is primarily a debugging tool, and should not be used in production. Address santizer can make vulnerable source code safe from many types of attacks. They're really meant for different parts of the development cycle. A paper I wrote a few years ago talks about some things that address sanitizer covers, and what it doesn't. https://dl.packetstormsecurity.net/papers/general/BreakingAddressSanitizer.pdf
Address sanitizer performs checks at runtime and restructures memory to create redzones between structures. The binary is instrumented at compile time with additional code to perform the checks at runtime. See my other comment about how they are meant to be used at different parts of the development cycle. Valgrind and asan have some overlap, but each one has a large set of target memory bugs that the other tool doesn't cover. https://www.reddit.com/r/C_Programming/comments/5sew4n/writing_safer_c_with_clang_address_sanitizer/ddexkpw/
It's slightly different. Address sanitizer is supposed to stop after the first error because otherwise a memory corruption attack could be underway. It's weird that people compare them at all, honestly. They have entirely different purposes.
I think my answer is wrong.
For uninitialized memory there's [another sanitizer][1]. [1]: https://clang.llvm.org/docs/MemorySanitizer.html
I recommend the following approach: * read in the entire Sudoku using `fgets()` or another IO function * use `strtok` (or `strsep`) to split the Sudoku at spaces or newlines * for each token, check if it's an underscore (e.g. using `strcmp`) and try to parse it into a number.
While good points, you forgot to mention that address sanitizer is for debugging, you don't need to enable it for release builds, so the performance penalty doesn't matter at all.
No, because that would be pointless at that scale... Feel free to make your own library that includes some default functionality if you want tho.
...To make types... For example, why type struct in front of your struct every time you use it, when if you just slap a typedef in front, you can just type the type's name and be done?
I just do `typedef struct MyType {} MyType;` Why would you rename it?
I see. Yes, you're right. I would want to do static analysis (at least) before turning off runtime protection ... but the article does mention that. (i.e. clang-analyzer LLVM) Unfortunately, if you find yourself using this to *debug* it suggests your compiler or static analysis already missed doing the pointer/memory safety job. Debugging is expensive. But this does look like a good tool if it comes to that. Thx.
Interesting, I hadn't seen that before. The main problems that I was aware of were related to intra-object overflows. I spent a good year trying various ways to break it. I was running it with ASLR just fine under linux. I also am skeptical that it would cause any problems with UDEREF, considering that it exists entire in userland for userland programs. The thread you reference reports a specific bug related to environment variables (in the case of suid binaries) which can be patched, but I think that thread applies mostly to whether or not ASAN is suitable for kernel hardening. In the case of kernel development I can see ASLR and UDEREF being a problem. See the previous message in the mailing list: http://www.openwall.com/lists/oss-security/2016/02/17/9 Some of the points are definitely valid for non-suid binaries as well. It may be possible to attack the unwinding code, though I spent a lot of time trying and didn't find anything obvious. This is mostly because the very first write at an invalid address never goes through. There might be some way to corrupt the data the unwinding code uses, but one byte outside of bounds and ASAN takes over. NX bit and mmap permissions are not going to let you just write over the unwinding code even if you knew where it was. As far as the point about "nice diagnositc messages at undefined behaviour" goes, that is normally a worry due to debugging information being leaked to an attacker. Many other compiler level security tools that provide these kinds of errors don't print to stdin/out/err specifically for this reason. Instead, tools like ProPolice and ASAN print to an entirely different tty. It probably isn't wise to print out all of the addresses that ASAN does, but that alone isn't going to help an attacker unless they can find a way into that other tty. It looks like the ASLR problems mostly apply to MacOS due to some problems with the way they implemented memory mapping and ASLR. Since their kernel isn't open source, there's not much we can do. https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/37752.pdf Based on this discussion of people who are working on ASANing kernels it seems like there is some interest in a minimal, hardened version that is separate from a debugging version. http://seclists.org/oss-sec/2016/q1/374
That's just tutorials
Look at `scanf()`. Consider `%s` instead of `%d` since you might have a `'_'` or a digit. Then compare (`strncmp()`) the resulting string (`char *` in C) to `"_"`, otherwise consider using `atoi()` for the conversion to digits. Good luck!
Yeah, it sucks that you can't use the exact same name, but I usually go with more specific type name, more generic variable name.
[removed]
I did something similar for a Sudoku program I wrote. I basically realized that the only valid input are the characters '1' through '9' and UNDERSCORE (in my case, it was '.' for a blank space, but it's easy to use UNDERSCORE); everything else can be ignored. Every four characters define a row, and there are four rows to fill. All you really need is fgetc() (or getchar()) in single loop. The loop will looks something like (WARNING: pseudocode ahead!): x = 0 y = 0 while y &lt; 4 do c = getchar() if c in '1' .. '9' then set_sudoku_board(x,y,c) x = x + 1 if x &gt; 4 then x = 0 y = y + 1 end else if c == '_' then x = x + 1 if x &gt; 4 then x = 0 y = y + 1 end else if c == EOF then break end end That should be enough to get you going. 
Hmm. What happens when current size is 5 and you call the function with index 5?
`static`, when applied to variables outside a function does not enforce atomic access. Instead, it makes the variable only visible to the file (translation unit) it is in. So in foo.c and bar.c, I could have defined `static int baz;` and the variables would be at two separate addresses. If you want atomic access, you need to use the functions inside `&lt;atomic.h&gt;`or another atomic library.
No. It's stored in memory somewhere in the data segment (which may not be in the cache) whereas local variables can be on the stack (almost certainly cached) or in registers (fast). Example: https://godbolt.org/g/2apFC1
&gt; So, i ask you (because I didn't receive any precise answer from him): is there a possibility to make a GUI in C using no libraries? In theory it is possible. After all, GUI libraries are just C code someone else wrote. However, in practice nobody ever does that because the complexity is just so high and you're going to do very little else than reinventing the complicated GUI libraries. On Windows, the GUI is part of the operating system. The Windows kernel provides a number of functions and interfaces to create windows and widgets. The kernel also sends messages to you when the user clicks on a button, etc. You typically call into the Windows API comctl32.dll to get this functionality. This is the only documented and stable way. On UNIX-like systems, things are a bit more complicated. The graphical user interface is implemented as a network protocol called X11. Your application (an X client) connects to the X server and tells it to make a window. The functionality X11 provides is rather elementary (e.g. drawing points and lines, recognizing events). X11 won't draw widgets for you and won't make anything resembling a modern user interface for you without a lot of work. I wrote [something](http://stackoverflow.com/a/33845528/417501) about the futility of talking to the X server without any libraries. If you just want to understand how to paint with a program, I recommend you to use something like SDL. It's a graphics library (yikes!) designed for 2D video games. It provides a simple API to open a window and get access to a frame buffer for the contents of that window, hiding all the messy details. You can then play around with your bits and bytes and see what happens. TL;DR: Your colleague might be full of shit.
Aside from what everyone else has mentioned, you can interact with the Linux framebuffer without any libraries except libc, just opening /dev/fb0 and writing values to the right addresses (usually every 3 bytes are the values for red, green and blue, from left to right and then top to bottom) This won't be fast though, usable from within any other graphical environment nor portable (might work on systems with similar framebuffers, maybe BSDs? but never windows) So framebuffer can be fun to play with, but usually not a real option. If you do look into the Linux framebuffer you'll likely also want to look into mmap and the framebuffer ioctls.
Ha! RTFM is alive and well
Perhaps, but when I was starting out I was very grateful to find Mint where RTFM is anathema. If I'm honest, I think RTFM has actually held up adoption and done the cause of Free Software a lot of harm.
Really? Because I see that attitude everywhere in the industry, not just open source.
Sweet! Basically this post is a bookmark
As others have mentioned, you would have to write your own GUI. You could create a window manager from zero, it would be a great learning experience, however it's not probably what you want. If you're interested, I recommend following [this blog series](http://www.trackze.ro/wsbe-complicated-rectangles/), tldr: get a pixel buffer and try to draw rectangles on it, then rectangles with borders (windows), then draw only the visible parts of the windows, and finally add mouse input and maybe some buttons, and congratulations you have a substitute for Xorg. 
How low level do you want to get? On linux you can write directly to the frame buffer to get stuff printed to the screen. But it's very tedious. On windows, I don't know if you can write directly to the screen without talking to an API. You can draw anything to a window, but it all goes through a library at some point. Start with getting a drawing context (HDC) to the window. EDIT: Shaders are low level. They work on the pixels themselves. But, in order to upload a shader to your graphics card, you generally go through a library like OpenGL.
How do you expect to be a good coder if you don't want to read... 
It's not about not wanting to read, it's about efficient ways to impart knowledge, and the attitude that discourages questions. If you know the answer, a link to the specific manual entry even is a million times better than RTFM. Mans and other technical documents are great, but it's often better to just get moving rather than trawling. Until you're proficient at understanding what the manual is talking about. Just to clarify, I have nothing against the reading of manuals, I just think the RTFM attitude is lazy and unhelpful, and I think for a movement like Open Source, it's been a major hindrance.
You could go very old school the way i did my first GUIs - DOS. I don't know how well dosbox or freedos support it, but i did some VGA and eVGA talking directly to hardware. There are likely some old tutorials available. A timid start might be a TUI using something like ncurses on Linux. This develops the idea of separating the UI from the "business logic" (for your background, this could be scientific processing). You won't have pictures, but you'll have menus, radio buttons, check boxes, text input, etc. 
Thanks, I'll definitely check that out, but... My Computer Science teacher is requiring is to is Win VGI, mainly so we can't do what I'm doing right now... But I would just like to get a head start on our final project, not trying to cheat I promise lol
Sounds like a class you should be running very far away from.
I'm using gEdit and Sublime + gcc. If you know how to use Vim/Emacs, they're fine. However, I can't use them, so I settle with the standard text editors. 
Just a meta-comment: whenever you encounter a large number like this, especially a negative number, you should try converting to hex. In this case, -1073741819 is 0xC0000005. If you google *that*, you'll find out that it's an access violation in Microsoft C.
Actually, they can do and good manuals include sections with examples and some words about how to get started. For a good example, see the [FreeBSD handbook](https://www.freebsd.org/doc/handbook/).
Of course there are good manuals, Django docs are one of the best. Git default documentation is useless, as is 95% of manuals.
Embedded devices are basically anything programmable that's not a computer. Anything from coffee makers to industrial controls. [This](https://imgur.com/EAnIleU) is one gadget I did for a hobby project. It's a GPS navigator watch for Burning Man - it gives me my street address in Black Rock City, distance and bearing to my camp, to the man, and (after I upgraded it) to the nearest toilets. This project used some of the graphics library I wrote. [This one](http://imgur.com/oK7Ceiu) is a monitoring panel I built for my travel trailer. It shows holding tank levels, battery charge, solar power, and load current. As for whether you should do it, it depends on what you want to learn. If you're only going to be working on real computers, I don't know that there's much value in learning it down at that level. First semester Algebra teaches you how to draw a line - you just calculate your slope and step through each point. Going from pixels on a Cartesian plane to bits in a frame buffer is pretty simple, and you just need to know how the pixels and planes are laid out. In the case of the display on the watch, each byte is a set of 8 pixels that are on or off. On a grayscale display, it might be one byte for one pixel. For full color, 24 bits for one pixel. The bytes might be contiguous in memory, or each color plane might be a separate region of memory. Once you get beyond the naive implementation (like the algebraic slope calculation) and need real performance, things get more complicated fast. [Wu's line algorithm](https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm) is an example of a line drawing algorithm that supports anti-aliasing. It's not super complicated, but the point is that a lot of really smart people have spent a lot of time figuring out good ways to do this stuff. Most programmers will never have a need to know things at that level. It's good to know what anti-aliasing is, why you'd want it, and what the tradeoffs are, but you probably don't want to write that yourself unless you're specifically going into computer graphics and/or you're some kind of masochistic math nut. So... embedded stuff is a good way to learn about all sorts of computer technology at a low level. It's not necessarily good for teaching you how to efficiently design modern applications. If you just want to build GUI apps, use a GUI library.
No, unless you used a structure that had a bit set whenever it was sorted. Clearly you can't check if an ordinary list is sorted in constant time, because you can only read a constant number of list elements in constant time, and if you input a sorted list with any two elements you didn't read flipped, your constant-time algorithm would give the wrong answer.
This looks like a good tutorial. https://www.codeproject.com/articles/586000/networking-and-socket-programming-tutorial-in-c
CS theory proves that you cannot. If you do it in less than linear time, you can't have looked at all of the items on the list. You could make it a constraint that the list must always be sorted, but then ~~insertion~~ creation must be O(n log n) or O(n^2). Or, you can make a space vs time trade-off and have a flag to indicate whether the list is already sorted, but you'll have to have already determined that once before.
I got some hints from this tuts: https://www.udemy.com/learn-socket-programming-in-c-from-scratch/
People have written GUI libraries for as long as we had computers, and in some fields (like games) it's still not an option to use OS widgets like winapi or gtk. You do need to start somewhere, though - some graphics library that gives you primitives like rectangles and bitmaps, and a way to manipulate the screen. So at least for that, you'll want to use a library.A good place to start is [SDL](https://www.libsdl.org), you could take that and build your own windows, buttons, text input and checkboxes.
morsebin I assume is a char[]. So this ith iteration, we take a look at each bit. sizeof char is 1... so 1x8... or 8. Then - j - 1 which is just 7 - j, so really... (((int) morseBin[i]&gt;&gt;(sizeof(char)*8-j-1)&amp;1)?".":" ")); is (((int) morseBin[i] &gt;&gt; (7 - j) &amp; 1) ? "." : " ")); The (int) is a cast, &gt;&gt; is a right bit shift, &amp; a bitwise and, ?: is a ternary operation, and j goes from 0 to 7 for each ith iteration. 
True.
There's a typo in the second for loop: error: expected expression before ‘;’ token for(j=0;j&lt;sizeof(char)*8 &amp;&amp; (i*((sizeof(char)*8))+j)&lt;-;j++) ^ `sizeof(char)` is always 1 btw so you can leave that out to make the code more readable. There are some other problems with the posted code but let's get to the actual question. What you have to do is take each character, check if it's a dash or a dot and insert zero's or ones into a string. Here's a little pseudocode to help get you started: fill output string with zeros for each character skip character if it is a space or slash if character is a dash insert one and go to next bit else go to next bit (the string is already full of zeros) you need three counters: one to iterate through input characters one to iterate through output bits one to iterate through output characters (every 8 bits unless you want to make things complicated) 
I don't think you can overwrite files in place with the libsndfile. You are going to need to create a new file and write the entire track including modifications to that.
 if (chunkCount % chunksPerWatermark == 0) { printf("Watermark count: %d\n", chunkCount); insertWatermark(buffer, readCount, info.channels); sf_write_double(outfile, buffer, readCount); } sf_write_double(outfile, buffer, readCount); the second sf_write_double outside of the if block will be done no matter if the inner sf_write_double is executed or not. You likely want to put that in an else block or just use the same write whether the if block is executed or not: if (chunkCount % chunksPerWatermark == 0) { printf("Watermark count: %d\n", chunkCount); insertWatermark(buffer, readCount, info.channels); } sf_write_double(outfile, buffer, readCount); 
&gt; `skip character if it is a space or slash` &gt; `if character is a dash insert one and go to next bit` &gt;`else go to next bit` This will result in unintelligible output with all of the characters and words run together. The common standard for morse element lengths is this: &gt;Each dit is one element, each dah is three elements, intra-character spacing is one element, inter-character spacing is three elements and inter-word spacing is seven elements. You could cut that down to the dah and inter-char space to 2 and ther inter-word space to 3 if you wanted, but you need the different lengths to distinguish strings like these: TESTED - . ... - . -.. BAL -... .- .-.. 6 CE -.... / -.-. . 
&gt;This will result in unintelligible output with all of the characters and words run together. ~~Yes, but as far as I can tell that satisfies the sample output he posted. The line that's supposed to reverse it works that way too. (although it doesn't really, since it never inserts three dots)~~ edit: there is more spacing between elements in the sample output, reddit removes that and I didn't check the comment source 
Yes, this **definitely** has errors. 
Well, using clang i got the expected result, but it warns about unsequenced code points, but gcc does not, as it is not clear what will execute first, you've created an ambiguous program, here's the compilation output: test.c:6:14: warning: multiple unsequenced modifications to 'b' [-Wunsequenced] a = cube(++b); ^~ test.c:1:18: note: expanded from macro 'cube' #define cube(x) (x*x*x) and the output of gcc -E: # 1 "test.c" # 1 "&lt;built-in&gt;" # 1 "&lt;command-line&gt;" # 31 "&lt;command-line&gt;" # 1 "/usr/include/stdc-predef.h" 1 3 4 # 32 "&lt;command-line&gt;" 2 # 1 "test.c" int main() { int a, b=3; a = (++b*++b*++b); printf("%d, %d\n", a, b); } Even though the sulfix increment has the priority of execution it is only a single expression, so the order of evaluation is not obvious, for example, it could be interpreted as: (4*5*6), the current value of b is used (6*6*6), the last value of b is used So, yeah, i suggest [reading the wikipedia page on sequence points](https://en.wikipedia.org/wiki/Sequence_point).
If you put the code into [Compiler Explorer](https://godbolt.org), you'll see what happens when compiled with GCC. https://godbolt.org/g/NV0mso It's storing 3 in the variable at stack location `[rbp-4]`, and then adds 1 twice giving 5. It then multiplies with itself giving 25 (stored in `eax`), and adds 1 more to the variable, then multiplies it one final time with `eax`, giving 6*25=150. Because of the UB others have mentioned, the optimizer decides it can do the following: `++b*++b` is the product of `++b` twice. So it performs both `++b`s first, then multiplies them together. Note it's not storing the result of each increment separately. Then it performs the final `++b` and then the second multiplication.
Not to be a wet blanket but I've never seen a GSoC project last longer than 6 months. Many students work on the project for 3 months and leave the husk for the volunteers that've been working on the technologies all along. Much of it is sloppy, unusable work. They're in it mainly for funding. Nothing wrong with that, I guess, but it's really not contributing much to libre software.
That's a good observation. Do you think there's more value in getting students involved in a project and getting them some money to boot is more valuable than ensuring the feature/issue they're working is usable? I'm trying to get a fell for how it all balances out.
I guess we've been extremely lucky then. We've been in GSoC since 2014, and all 3 students that were accepted that year continue to contribute a lot - even now that they are no longer eligible to participate at all and in fact have jobs as engineers. Yes, many students (maybe even most) participate in GSoC for the money. I don't think there's nothing wrong with that, they can code for free at any other time and in fact many do already (we see it from the GitHub page). GSoC exist to motivate talented students to work full-time in open source instead of doing something else during the summer. 
You can't swap their contents because you don't know how many bytes they're pointing to (because they're void). Pass pointers to the pointers and swap their values.
Well you can't swap contents, as there's no way to guarantee the size of a void*, but you can XOR swap the addresses in the pointers like this: void* A = {some address} void* B = {some address} A \^= B; B \^= A; A \^= B; 
To be clear, you want to move around the contents of the memory the pointers point to, without changing the pointers? If so you will need to know the sizes of what is bring pointed to, and if they differ, how much memory has been allocated.
[removed]
Maybe. void swap(void *a, void *b, size_t s) { char *p = a, *q = b; while (s--) { char t = *p; *p++ = *q; *q++ = t; } } And then: struct x a, b; swap(&amp;a, &amp;b, sizeof(struct x));
`&amp;&amp;` is AND, i.e. int x = 3, i = 5; if(x == 3 &amp;&amp; i == 4) { // condition is not met } `||`is OR, i.e. int x = 3, i = 5; if(x == 3 || i == 4) { // condition is met } `&amp;` is bitwise AND i.e. `0110 &amp; 1100 = 0100` `|` is bitwise OR, i.e. `0110 | 1100 = 1110` 
Hi, the theory behind is that I will take an audio file, watermark it and save it as a new file. As of now, I'm only comparing the watermark values inserted into the new file with the values in my watermark[] array. I plan on comparing frame by frame for each file and see if the watermark can be recognised. As for the watermark values, yeah I get an audible click where the watermarks have been inserted. I have tried to compensate for the rounding errors by using a baseline with a small range difference. Looking at the RAW read/write functions of libsndfile, they state on the documentation &gt;Note: Unless you are writing an external decoder/encode that uses libsndfile to handle the file headers, you should not be using these functions. I'm not quite sure what this means apart from me having to use an external decoder/encode to handle the modified RAW data? Thanks for the inputs.
Why do you even want a generic swap function? That sounds a lot like a design smell to me.
Trust me, a swap macro doesn't make things cleaner a lot.
else if
Yes, that sounds pretty good, though I can use any of them. 
Can you explain how ?
Yeah, that's the right answer, thanks...!
What is there to be confused about? You need return 0; for the program to terminate once the condition has been met. Else it will print all messages.
It is customary to shorten this: else { if (condition1) { /* do stuff */ } else { if (condition2) { /* do other stuff */ } } } to just this: else if (condition1) { /* do stuff */ } else if (condition2) { /* do other stuff */ }
You can avoid it fairly straightforwadly in `if` statements, as I did in that example, but it's probably better to just get used to it---other programmers will use `!` in their code, and you'll have a harder time reading it if you're not used to it. Plus, it makes your own code harder to read for other programmers, because you often end up with tests that look like if (!is_valid_object(obj)) { free(obj); fprintf(stderr, "Got an invalid object!\n"); } where the name of the function in the test reads quite nicely. You can read that test as "if it *isn't* a valid object, then...", but it's a bit more awkward if it's `if (is_valid_object(obj) == 0)`. As for in bitmasks, it's much harder to read the intent of unsigned int inside = test &amp; mask; unsigned int outside = test &amp; (UINT_MAX ^ mask); compared to unsigned int inside = test &amp; mask; unsigned int outside = test &amp; ~mask; where `~` is the bitwise version of `!`.
In C, but not in all C-family languages, `x == 0` is equivalent to `!x`, so, yes, in C, it can be avoided entirely. If you find it confusing, it may help to learn the basics of Boolean algebra.
Macros are not functions, they're basically text-pasting, so`cube(++b)` expands to `(++b*++b*++b)`.
You're posting a lot of these type of questions---it looks like they're homework problems for a class in C or something like that. We're ok to answer questions here, but you have to show some effort in trying to come to an answer yourself. You can't learn if you're just told the answers each time. What are you struggling with here? What do each of the symbols mean, and what kind of answer are you expecting to get out?
Also `&amp;&amp;` and `||` are short-circuit.
Your `x` variable is integer (`int`). When you do integer minus 0.5, the 0.5 is truncated to an integer 0. Hence it never really decreases. Ways to fix: Decrease by at least 1.0, or better (and probably the right solution is to) make your loop variable to be `double x = 5.0;` and remove the subsequent `x=5`. Also when x is double, you should be printing with `%g` not `%f`, because `%f` is for `float`s.
I forgot all about typing float before x ! That was the solution thank you. Normally the book displays the coding but he put exercises in the book that you do without his help (Keep you fresh on all the other things and teaches you to problem solve and figure it out on your own with things hes already taught you). But yea, heres the output! Thanks. https://gyazo.com/51a4da20a7a307527008c7396156fcab EDIT: The reason I put %f is because I knew it would be a float. I just forgot to put float before the x .
That's ambiguous, there are two possible ways to achieve that: 1. Swap over the contents of memory being pointed to. 2. Swap over where each pointer is pointing to. 
There a few common approaches I know of, each with their own trade-offs: 1. Switch statement -- one large switch statement with each case being a state 2. Jump table -- an array of function pointers and an index for the current state 3. Goto -- the flow through the FSM is hard coded and implicit from the current instruction pointer 4. [Computed goto](http://eli.thegreenplace.net/2012/07/12/computed-goto-for-efficient-dispatch-tables) -- friendly to branch predictor without hard-coding transitions 5. Function calls -- each state is its own function and the callstack is used to transition states
That too.
These questions are not a part of my homework, if they were, why would I posted them here on reddit, instead I could have googled them or executed them by my own. I'm posting them here to gain knowledge about C programming from you guys, how we can create them in other forms and so on like that.
Why it will print all messages when one of the condition evaluates to true. It will execute the expression of the same If. 
What insight are you exactly hoping to gain? There is a correct answer to this question and once you found it, there is nothing else to gain.
&gt; how we can create them in other forms and so on like that. What's that supposed to mean? The questions you post are questions for absolute beginners and serve the purpose of testing if one has understood the operators of C. Once you understood these concepts (as most readers in this subreddit have), there is very little to gain from this kind of question.
Yep
A bitwise operator is a mathematical operator of sorts, acting on the actual binary representation of a value. It looks at each bit that's set for the two (binary) values, and performs some operation. The AND (&amp;) operator produces a 1 only if both bits are set, otherwise producing a 0. The OR (|) operator produces a 1 if either of the bits are set, otherwise producing a 0. There's also the NOT (~) operator, which is used on a single value to just flip the bits. The XOR (\^) operator produces 1 only if one of the bits (and only one) is a 1, otherwise producing 0. Here's some examples: 1 &amp; 1 = 1 1 &amp; 0 = 0 0 &amp; 1 = 0 0 &amp; 0 = 0 1 | 1 = 1 1 | 0 = 1 0 | 1 = 1 0 | 0 = 0 1 ^ 1 = 0 1 ^ 0 = 1 0 ^ 1 = 1 0 ^ 0 = 0 ~1 = 0 ~0 = 1 
I think that very little is not little, knowledge is knowledge.
the output is not sorted
What I am trying to tell you is that the kind of question you post is not very interesting to the average reader as the concepts are very elementary and nothing new is gained from thinking about them. Really, the kind of code in your questions appears in everyday code and isn't anything interesting or special. The only people who can gain something from your questions are absolute beginners. So unless you want to have these questions answered for you, please don't post them.
By the way, try increasing warning level for your compiler (e.g. `-Wall -Wextra` for GCC and Clang). It will warn you that you try to add float constant to an integer, print integer as a float and probably even that this loop will be infinite.
Logical vs bitwise. &amp;&amp;, || are logical (they coerce their operands first into true or false values, then short circuit evaluate). &amp;, | are bitwise, typically operating on integers or bytes, performing a parallel AND or OR of all the bits in the operands. ! is also logical, whereas ~ is bitwise, for negation AKA bit inversion. ^ (Exclusive OR) is a further bitwise operation, with no single equivalent logical operator, though a similar logical expression can be constructed
Most of the time you will only finish projects that you want to do. Project ideas from other sounds cool, but most of the time you need to be the one with the idea to complete the project. To come up with a cool idea write down all the sensors/functions that your arduino-device has. Than write down how you could combine those functions to create something useful or fun. It doesn't have to be the next big thing (because it won't be the next big thing). You could also just start trying to work with one of the sensors. While programming you get a bunch of ideas how you can improve upon your initial sensor experiment.
&amp;&amp; and || are logical operators. &amp;&amp; is "true" if both arguments are "true" ^1. Likewise || is "true" if either of its arguments are. &amp; and | are numeric operators. &amp; is the boolean "and" function, performed bit-by-bit on its two operands. | is the boolean "or" function. So for example, 6 &amp; 5 = 4 while 6 &amp;&amp; 5 = true. ---- ^1 Where C defines "true" as anything that's not zero. But a better coding style would be to let booleans be booleans. if (i &amp;&amp; j) // compact, but slightly obfuscated if (ptr) vs if (i != 0 &amp;&amp; j != 0) // say what you mean if (ptr != NULL)
You can, but you shouldn't. If x is a numeric value, then you should use `x == 0`. If it's a boolean value, then use `!x`. Makes your intent much clearer.
I work on a team of senior devs, and they don't comment a God damn thing in C, but they're becoming better with variable naming in our Java code.
You *can* avoid it. That doesn't mean you *should* avoid it. If you're into that sort of thing, there's always the [Obfuscated C Code Contest](http://www.ioccc.org/)
&gt;I'm not quite sure what this means apart from me having to use an external decoder/encode to handle the modified RAW data? Do you understand how the files are encoded? And what formats are you planning to work with? I just wrote a WAV decoder recently so I'm at least familiar with the major variants of that format. Most files will have samples stored as 8-bit integers, 16-bit integers, or 32-bit floating point. libsndfile is making things convenient for you by converting them all and normalizing them to -1.0 to +1.0 in double-precision floating point, but the samples still get converted back to their native format when written. The smallest difference between your watermark values is (0.1 / 100) * 2 = 0.002 on a scale of -1 to +1. For a file with 8-bit samples, that's well under one LSB. In other words, some of those watermark samples could encode to the same value. If you're working with any format with lossy compression, like MP3, then your watermark is going to be obliterated as soon as it's re-encoded. For uncompressed integer PCM files (like most WAV files), if you access the raw values you can at least encode a watermark that won't be audible and won't get destroyed during the encoding process. You just have to write your watermark bits one bit at a time to the least-significant bit of a string of samples. This is a common steganographic technique for uncompressed audio and image data. Again, *any* change in bit depth, sample rate, any filtering or re-encoding, any analog dubbing, and pretty much anything that touches the sample data at all will probably wipe that out, so it's not a durable watermark.
Practice. If you're just starting out, project euler is pretty good, otherwise make problems up. Pick something that you think is just outside your current ability and figure out how to do it.
GCC has some default paths were it searches for libraries, like (under Linux) `/usr/lib` and `/usr/local/lib`. You can add paths with `-L./lib` or using the environment variable `LIBRARY_PATH` (like `PATH`, but only for finding libraries). You probably installed the library in one of those predefined folders (former when using the package manager, latter when you compiled SDL2 by yourself). The `-lSDL2` option tells GCC to search for `libSDL2.a` (or `.so`) in those library folders.
Is the command line an expansion macro? So -lSDL2 expands into libSDL2.* and -lABC123 would expand into libABC123.*?
I enjoy the coding challenges of [Codewars](https://www.codewars.com).
Are you sure this is what you want to do? Any C compiler generally comes with some built-in "system" include paths, which have header files for the C library, kernel/OS, and other libraries available on the system. (On Linux, these live in `/usr/include`.) Any other include directories are specific to the thing you're compiling, and it's expected that you specify them every time you invoke the compiler. Hence why Makefiles and Autoconf scripts build up long command lines with lots of `-I` options. This is the normal way of doing things, and unless you have a good reason not to follow it — and you haven't given one — then you should do the same. If you're targeting an embedded system, you may need to use a different set of system headers. In that case, GCC has a `-nostdinc` to skip searching the normal locations, and you'll have to specify *all* necessary include paths with `-I` and its related family of options. Beyond that, there shouldn't be a need to change the path for system headers.
You'd use standard bit manipulation operations. A logical AND with 0xfe for an 8-bit integer or 0xfffe for a 16-bit integer will clear the low bit. A logical OR with 1 will set the low bit. For examples, I'd suggest doing some reading on [steganography](https://en.wikipedia.org/wiki/Steganography) in general.
&gt; Are you sure this is what you want to do? Yup! So how do I do it?
I don't understand your question. Are you saying you don't understand *why* `SEM_P()` and `SEM_V()` do what they do? Or you don't understand *how* they do it? Personally, I ***hate*** that we're still using `p()` and `v()` as the names of semaphore operations. Everyone gets confused by it, and it's just not helpful. You need to learn to mentally rename those: `p` is `acquire` or `get` or `decrement` or `down`, and `v` is `release` or `increment` or `up`. &gt; is there an efficient way to slim down the program? I only skimmed it briefly, but it doesn't look like there is. C code requires careful, tedious, repetitive handling of every possible error, which you've done. Good job! I didn't spend too much time reading it, though, because all the comments are in Italian. :-( Unfortunately, English is the standard language of computer programming, and if you want to get help from strangers on the Internet, you need to get used to writing your code (including all function names, variable names, most strings [i.e. help messages, logging, error reporting], and comments) in English.
Yes, that's a habit that needs to be broken as soon as possible. My intro CS classes insisted that all variable names had to be at least 6 characters long. It's annoying when you're doing trivial intro CS homework problems, but anything to discourage opaque 1 and 2 letter variable names is a good thing. Not that 1 letter variable names are bad... everyone knows that `i`, `j`, and sometimes `k` are for iterating over something, so *as long as that's what you're actually using those variables for*, and you only have 2 or maybe 3 of them, those are fine. (If you have more or if it's not a simple 2- or 3-dimensional array, you probably need to be more explicit.) If you're working with one set of coordinates, `x`, `y`, and `z` are of course okay. Other short variable names may be okay *depending on context*, but there's very little other context that's common to *all* programs. In OP's code, besides the variable names, `show_arr` is the other thing that really bugs me. You couldn't bother typing 2 extra letters to call it `show_array`?! That's the kind of stupid reasoning that gave us the Unix system call `creat(2)`, which Ken Thompson has said is the one thing he'd change if he could go back and redesign Unix.
Uh-uh. No way. I want you to say *why* you want to do this, because I'm still not convinced you actually need to. I can only think of one scenario where it makes sense, and I'd expect anyone who's in that scenario to already know how to do this or be able to figure it out themselves. So what's your scenario?
You should really step back and explain the actual problem you're trying to solve, because this sounds like an XY problem. If the issue is that you're trying to use a library that is installed in a non-system location, then this isn't going to work. Finding headers is just one part of using a library. You also have to specify the correct linker options, usually some combination of `-lsome_lib` and `-L/some/path`, in order to link against the library. So you still will not be able to compile and link without options even if you set `C_INCLUDE_PATH`. (There's also `LIBRARY_PATH` which does the same thing for `-L` that `C_INCLUDE_PATH` does for `-I`, but that still doesn't cover `-lsome_lib`.) Besides, compiling without options should not be a goal; you're missing out on lots of important things if you do that, like optimization, debug information, improved diagnostics, better standards conformance. The usual way of doing this is with a makefile, or some other build system, often in conjunction with helper tools like `pkg-config`. But you could also just write a simple shell script. All of these are much better options than trying to globally change something, which can lead to very annoying bugs. Compiler options should not be global, they are inherently local to the project being compiled. And if the problem isn't that you're trying to use a library installed in a non-default location, then whatever the problem is, setting `C_INCLUDE_PATH` globally is not the right solution. Don't do that. 
I cannot find the file that sets the Environment Variable C_INCLUDE_PATH. Please do not try to guess or assume what I am trying to do. Just answer my question, or politely leave my topic and stop posting in it. I want help, not lectures.
Make lots of mistakes? Also, years ago I learned a lot by answering questions on experts-exchange. Consider every question as a challenge and a free exercise.
&gt; I cannot find the file that sets the Environment Variable C_INCLUDE_PATH. It probably isn't set by default. (It's not set on two Linux machines and one Mac that I just checked.) I wasn't even aware of its existence, because I've never seen it used. I'm a bit surprised it even exists, because it seems like a very poor solution. It would get in the way of compiling multiple different projects with the same environment, which explains why I've never heard of anyone using it. The `-I` option is a better solution for basically everybody. But to answer your question, &gt; I cannot find the file that sets the Environment Variable C_INCLUDE_PATH. If that's all you want, then http://lmgtfy.com/?q=how+to+set+linux+environment+variables
To do that properly you need to step outside of ISO C and use platform specific APIs. On a Unix-like system, you would use [`stat(2)`](http://man7.org/linux/man-pages/man2/stat.2.html) and then check the `st_mode` field of the result using the `S_ISREG()` macro to determine if it's a regular file and not a directory, device, fifo, etc. 
`printf()` with `%d` expects an int, but you're passing a pointer to an int. You're probably confusing it with `scanf()`, which expects a pointer to int for `%d`. That's because `scanf()` has to modify the variable, but `printf()` only has to read it. 
I see you already solved your problem, yay! You should turn on warnings (`-Wall` with gcc), then the compiler should tell you about problems like these.
UDP port numbers are unsigned 16 bit integers so the full range is `0 - 65535` not `0 - 65435`: https://github.com/codepr/memento/blob/dev/src/memento.c#L122 
Directories are just a special type of file, btw. access() or stat(), yeah. Note that there's a race condition with this: if a different process creates a file between your checking for it and doing something based on it not being present, potentially bad things can happen.
I'm answering the question that the poster asked, which was specifically about checking if a file exists and is not a directory. 
Then what the poster wants is not a good idea in most cases.
That sounds like it'd work but a better solution that took me much less time was to just place all of my includes in the same directory, in my case /usr/include and /usr/lib. Now it'll find them with no additional command lines, and it also saves me having to learn how to use Makefiles and Make and everything else that is a huge waste of time.
`&amp;&amp;` yields `1` specifically if both arguments are non-zero. Your footnote suggests it could be any non-zero value.
`fopen` takes a character string for the openmode. You might be thinking of POSIX `open`.
Just ignore the file type. Try to read the file and check if it contains the data you are interested in. If someone places a directory somewhere where you expect a configuration file, that's the problem of whoever placed that directory there, not yours. Ignoring the file type has the important advantage that your program can transparently read from terminals, pipes, sockets, or whatever other special file the user wants to use. Programs that refuse to read from anything but regular files are really annoying.
The difference between `%f` and `%g` is the output format. Roughly speaking, `%e` means scientific notation, `%f` non-scientific, and `%g` auto-selects either `%e` or `%f` based on the magnitude of the value.
Father forgive him; he knows not what he does
proper error handling is usually a good idea! especially if you deal with users...
It is not an error to have a file that is not a regular file!
I would actually disagree. For some applications (mostly embedded stuff) using ANSI C is is nessicary.
How about we also add a "do my homework for me" category so we can filter those out? I don't mind answering questions when someone's stuck, but it gets a little old having posts every week that look like the first homework assignment from someone's first programming class and they didn't pay any attention to the lecture and don't want to read the text.
As /u/raevnos already pointed out, the answer you get back is already out of date. That's why a function like this is rarely useful. If you want to write bombproof code, it's simpler to just perform the operation and deal any errors after the fact. While I applaud the sentiment of wanting to avoid errors, your code should handle failures anyway. Preflighting adds extra code. Consider carefully whether or not it actually improves anything. 
I see where youre coming from but i still think its needed for proper user error checking even if It might be annoying to some users. In my case, i need to check if a file exists so i can make a sym link to it. Ln -s doesnt give an error if the file doesnt exist
Interesting, but in my case im not creating a file simply checking if it exists. Its also in a directory that should never be modified
you can easily make a symlink to a directory. Symlink can point to nowhere, that's a feature. Note that checking for the file existing doesn't guarantee that the symlink points somewhere; someone could remove the file after you check and before you create the symlink.
Let me clarify, I need to create a symlink, /etc/localtime, that has to point to a file in /usr/share/timezone. It cant point to a directory :/ only a file or else the timezone isnt set properly. I take a string from the user and check if it exists before making the symlink, Im operating under the assumption that the user wont touch /usr/share/timezone
i will change it. could you help check why the result array is fault
What does -pedantic do?
Python
Turns on a bunch of smaller, less important warnings that can sometimes annoy programmers that know what they are doing. I.e, comparing an `int` to `size_t` would throw a warning `-W-sign-comparison`, or something very close to that.
Those cases are getting rarer. I do embedded C programming for a job and my experience is that these days the hardware developers make an effort to use common compilers like IAR or GCC. I'd only expect to be forced to use C89 if patching something on abandoned hardware. In any case, we are discussing the default operation mode would be for questions on this subreddit, the majority would be situations where C11 is available. 
While we're at it, syntax highlighting and code posting could be definitely improved upon... I mean: ```c /* Why isn't this syntax highlighted code?! */ void main(void) { return 0; } ``` Seriously, why doesn't the common markdown we use in documentation work on Reddit? Where have all my new lines and spacing? WTF?
That's another subreddit, though. Doesn't filter anything and I don't see any rules about no homework here. I'm not saying there should be a no homework rule... but I'll reserve the right to berate posters for typing in their homework assignment verbatim without even trying to figure it out themselves.
OK thanks. I have a little C program that I wrote the other day. I will add the -Wall -Wextra and -pedantic flags to GCC and see what happens
Fresher programmer can participate in GSoC?
Sorry, I didn't understand the question. You can read everything about GSoC here: https://summerofcode.withgoogle.com/
[TCC](http://bellard.org/tcc/) the Tiny C Compiler.
Basically, you've gotten yourself all wound up losing track of what's a void and what's a pointer to void. An overview of the term "dereferencing": If Foo is a type, then `Foo *x` means that x is a reference to a Foo. *x is a Foo. Using the value *x is known as dereferencing. void is formless, and has no size. So it's legal to have a pointer (reference) to void, but you can't dereference it. So... s1 is a pointer (reference) to void. *s1 is a void. s2 is a pointer to void. *s2 is a void. temp is a pointer to void. *temp is a void. `void *temp = *s1;` takes \*s1, which is a void (and you can't do that so there's one error message), and assigns that value to temp, which is a *pointer* to void. You can't assign a void value to a pointer to void, so there's your second error message. `*s1 = *s2;` takes the void value pointed to by s2 and writes it to the location pointed to by s1. With any other type, that would have been legit, but you can't do that with void. So there's your third error message. `*s2 = temp;` takes the pointer in temp, and writes it to the void pointed to by s2. You can't write a pointer to Foo to a Foo, and you double can't do that with a void, so there's two more error messages. What you probably wanted to do was this: In order to swap two pointers, you pass *pointers* to those pointers to your function. It then dereferences the pointers-to-pointers in order to perform its actions: /** * This function swaps two void pointers. * @param v1 pointer to first pointer * @param v2 pointer to second pointer */ void swap(void **v1, void **v2) { void *temp = *v1; *v1 = *v2; *v2 = temp; }
Those false positives could form interesting questions to ask here.
-lABCD expands to libABCD.a
Yes, also in general it makes sure you're closer to the standard. It will throw warnings for things like function pointers with the wrong signature. I do agree that there are some cases where pedantic is annoying, but it can be useful to spot bugs in details a programmer may have overlooked. I'd rather have it there at it be annoying (sometimes) than not have it there and not consider some edge case. Plus if it's a warning that you don't care about it shouldn't really matter.
Is it possible to make -f $file recursive?
If you don't want lex or YACC, and want a small compiler, have you considered instead looking at something like the bf language compiler? 5000 lines for an understandable C compiler is a pretty tall order. 
My go to for answering "how" in simple loops like this is to manually step through. Write down the output for every iteration, making sure to do the if conditions. This discipline helps to learn to think like a compiler. After doing it manually, use a debugger to step through the code and see how that matches your results. 
Thank you.
You might want to have a look at the compilers for Plan 9, written by Ken Thompson. The code quality in the entire project is rather high.
To be honest, I think this is one area where the toolset for C is lacking. Some editors or IDEs will do a little refactoring, but I can't recommend anything there. You might look at [refactorial](https://github.com/lukhnos/refactorial/). It hasn't been updated in some time, but might still do what you need.
Use the search and replace function of an editor of choice. I typically script `ed` for this kind of task.
so how would you approach it? compile, and get a symbol table, and work against that?
One possibility. How large are these programs?
4,764 lines, about 82kb for the smaller one.
Homework is allowed in here. Yes, you may berate posters for posting their homework verbatim without trying to figure it out themselves.
The wikipedia [article](https://en.wikipedia.org/wiki/Library_(computing)) A [C programming](http://www.cprogramming.com/tutorial/shared-libraries-linux-gcc.html) tutorial A [stackoverflow](http://stackoverflow.com/questions/14884126/build-so-file-from-c-file-using-gcc-command-line) question. What you originally asked about seemed like a terrible idea. Factoring out the common components of both programs into a shared lib will allow you to have one instance loaded of the "library", shared by both programs. This is a much more sane solution to what you suggested.
Read [this article](https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_25.html) and [this answer](http://stackoverflow.com/a/452955/417501).
A popular scripted refactoring tool is *spatch*/*Cocinelle*. It's used by the Linux kernel and it parses the AST so it does what you need without the liabilities of basic regexp search and replace. If you need something interactive, you might download IntelliJ's Clion IDE. It looks at a glance to be pitched at the C++ set, but I'm very interested in a thorough review of it as a pure C IDE. Absent a review, I'm sure that eventually I'll get around to checking it out for myself. 
It's very frustrating to add indentation to a pasted piece of code, going line by line to the beginning of the line and pasting 5 spaces (which I assume is the correct amount). If Reddit is a serious platform, I would imagine that it would support some (if not all) of the later improvements that were added to make markdown even easier and more powerful. I wish there was something we could do.
does a shell script with [ -f $file ] search the directory recursively? i.e. including sub directores
`[-f $file ]` returns 0 (success) if `$file` exists and is a regular file, 1 otherwise. It doesn't search anything.
Learned this concept the hard way trying to inplement an earlest deadline first multithreaded timer program in OS class a few years ago!
That looks like a good way to safely end your worker thread, provided that you can guarantee that any `Executor` function will always eventually finish. If the executor gets stuck somehow, then the main thread calling `worker_kill` will also get stuck in `pthread_join` so you'll end up deadlocked. As for other comments: - You probably have done this, but just in case: make sure your `queue_*` functions are thread-safe if you plan to have other threads add tasks to a running Worker's queue. - (minor performance nitpick) In `execute()` you could probably move the `nanosleep()` call into an else block, since there's no point sleeping in between each task if you've got lots of tasks in the queue. - `pthread_join()` returns one of several error values if it fails; you should check for those and handle them appropriately (even `abort()`ing is better than letting it silently fail). Same goes for `pthread_create()`
Thank you for your comments! Each queue function, calls `pthread_mutex_lock` at the beginning then `pthread_cond_broadcast` and `pthread_mutex_unlock` at the end. That should be sufficient, right?
Sounds good to me!
++++[++++&gt;---&lt;]&gt;-.---[-----&gt;+&lt;]&gt;-.+++[-&gt;+++&lt;]&gt;++.++++++++.+++++.--------.-[---&gt;+&lt;]&gt;--.+[-&gt;+++&lt;]&gt;+.++++++++.[-&gt;+++&lt;]&gt;--.
&gt; The locking/unlocking is done inside the queue functions. That's insufficient because of the problem I described: Another thread could act between the `queue_count()` and `queue_remove()`. Either a single lock/unlock needs to encompass both operations or you shouldn't bother with `queue_count()` at all. For the latter, just call `queue_remove()` on each loop iteration and check if you got anything before executing (assuming the queue tolerates this). As you've written it, the information from `queue_count()` is stale before you can act on it, making it a pointless operation. &gt; Could you please explain a bit how worker-&gt;alive could cause a problem? This is a controversial issue that comes down to the interpretation of the spec. Since it's an unsynchronized access and it's not `volatile`, there's the potential that the compiler may remove the check. It sees that the value is not modified in the loop, and may "optimize" it into an infinite loop. In practice, no compiler I know of will perform such an optimization in this situation, but it's something to think about. The other problem is visibility. It can take an arbitrary amount of time for the change to `alive` in another thread to become visible to the worker thread. In your case it probably doesn't matter, and, in practice, because of the sleep it's at most one extra time around the loop. In general you need to be careful about unsynchronized access to shared memory. 
&gt; `pthread_join()` returns one of several error values if it fails In a well-designed program `pthread_join()` cannot fail. If it fails, then it's a bug in the program. It's only worth checking the return value if you're concerned that you've made a programming mistake. This is different than checking the return value of, say, `fwrite()` which may fail even in a bug-free, perfect program due to normal issues external to the program. 
Of course it would be a bug if `pthread_join()` were to fail in this program. But if you fail to check it, then the bug would (maybe) manifest as a segfault in another thread caused by a use-after-free after `worker_free()` frees the running thread. This would be rather difficult to debug. In the worst case, it could stomp memory without segfaulting and you'll have a silent data corruption. It is better to catch bugs closer to their source.
pls share your comments
F
T
Maybe a weird question, but do you really need put the lincense in every source file? I see a lot of bigger projects do this, is it just a common thing to do?
Musl comes with a wrapper for GCC and clang called musl-gcc/musl-clang (or gcc-musl/gcc-clang, I don't remember which). Those are included in the Archlinux package. Use them instead of GCC/clang.
It's fairly common to do this. If you put copyright information into every source file it is very hard for an (illegitimate) user to say that he didn't know the license.
I know, because I need some headers from there (wayland\*.h, asm{-generic}/\*.h, ...) but I need gcc to *prefer* musl headers, where there are both in `/usr/include` *and* `/usr/lib/musl/include`
Good question. Try to pass the musl include directory last; I think latter include directories override those passed farther before.
I've tried both without luck. Here [manual](https://gcc.gnu.org/onlinedocs/gcc/Directory-Options.html#Directory-Options) says they're read from left to rigt.
Fair point.
What do you mean by access? Access from where? Inside `printf()`? Unless you're writing your own standard library you don't generally have access to add code to such functions. And not all platforms pass arguments on the stack. On x86_64 linux for example: $ cat foo.c #include &lt;stdio.h&gt; int main(void) { int extra_arg = 0; printf("\n", extra_arg); } $ gcc-6.1 -S -O2 foo.c -o - -fno-asynchronous-unwind-tables -masm=intel | sed -n '/^main/,/ret/p' main: sub rsp, 8 xor esi, esi mov edi, OFFSET FLAT:.LC0 xor eax, eax call printf xor eax, eax add rsp, 8 ret The first parameter is passed in rdi and the second in rsi. The stack isn't involved at all except for the return address. Stack vs. registers is all an implementation detail that doesn't affect anything at the language level. The way you access args of a variadic function is the same (i.e. `va_start`, `va_arg`, `va_end`, etc.) regardless. And in the case of `printf()`, the only way you know how many times to call `va_arg()` is by inspecting the format string, so you would have no way of knowing if the caller passed excess arguments. 
&gt; Thanks for your detailed answer! My question was not very well thought-out, so I apologise. &gt; &gt; extra_arg is actually a string which is passed into a function, which does some string manipulation of extra_arg (toupper()), and then ends with the printf I posted. &gt; &gt; It is my hope that I can somehow instruct printf to "skip" the newline via some sort of esoteric format string. &gt; &gt; That's probably not possible as an "end user" who is trying to, quite frankly, make the code misbehave from the command line. &gt; &gt; Thanks again 
It's actually a so-called "Capture the Flag" system, where intentionally-vulnerable binaries are provided (sometimes with src, as in this example). It is used as a learning platform. Thank you the info!
In the interests of completeness, here is the "vulnerable" code: int capitalize(const char *str) { printf("Capitalized string: "); putchar(toupper(str[0])); int i = 1; for (i; str[i]; i++) putchar(tolower(str[i])); printf("\n", str); return 0; }
Pass a string where `str[0] == '\0'` and see what you can do.
That ought to at least give you the ability to dump the contents of the stack up to the next 0. That indented printf() is a perfect example of why I never use single-line conditionals anymore - I *always* use braces. Too easy to assume the indented part is part of the loop when it's not.
What you have looks correct. Maybe what you're looking for is that indexing is the same as pointer arithmetic. data[index] is the same as *(data + index) which is *((int*)((char*)data + index * sizeof(int))) where "int" is the data type of the pointer.
That is actually wrong. correct would be that `data[index]` is the same thing as `*(data + index)`. See also ISO 9899:2011 §6.5.2.1 ¶2.
I got it, thanks for the help
Change `data[nLeftItem]` to `*(data + nLeftItem)` and so on.
ITYM `int *` is the data type of the pointer.
I don't know what magic incantations you're using, but those don't print to stdout. 
Those functions do not have anything to do with stdout. You need to clarify what you're asking. 
Maybe he means its generating warnings as strcpy/strcat are generally considered "insecure" nowadays.
Yes, turn off the teletype console.
I'd have helped you had you not said you are literally dying. Unless this is the embedded code for your pacemaker. Which it is not. 
I wonder if I'm doing your homework for you here... Hope not. The program \*will\* access str[1], even if str has length 0. That might be your vulnerability. If you're passing str as a command-line argument like this, $ my_command argument Then pass an empty string for argument, and then pass a second argument in. The execve syscall stores arguments contiguously in the new process's stack. So the second argument goes right after the first. E.g., if you did this, $ my_command one two three then they would be in memory like this. ... m m a n d \0 o n e \0 t w o \0 t h r e e \0 ... So if you call this, $ my_command '' more_stuff (where `''` is a zero-length argument) it will print more_stuff in lowercase. This is all very architecture and OS dependent, of course. My description applies to Linux on x86 and some other architectures. The other thing is that toupper and tolower use the current process's locale. You might get something interesting if you change the locale, though I can't think of anything offhand. 
Thanks! I'll look into `epoll` and see what I can come up with. For an IRC server I guess the "basic unit" would be a `recv` and a `send`, so let me get this straight. If i have 4 threads waiting for sockets to have packets recieved, how would I know there is a packet pending? Right now the idea I ahve in my head is: Daemonize socket bind listen Create threads (?) accept() configure epoll (I have yet to read it in depth so I still don't know how to set it up) Now when a socket is made and data is recieved the file descriptor would raise some kind of flag (in select you'd see it with FD_ISSET i believe) and a thread would be sent to do: recv() Do the msg parsing and the things IRC servers do send() whatever info they may need to send detach from the socket and go back to being electable to attend another socket. Is this a fairly close representation of what I need to do? P.S.: I'm sorry if I'm oversaturating you with questions, its just that I've ahd trouble finding a source of information that I don't have trouble understanding. When i saw the select man page I left the page with the same knowledge I had before seeing it.
The convention I use is to base it on what the pointer in the program logically represents. If the pointer is passed to the function to do array operations, I declare the argument using []. Whereas if I'm using the pointer to access a single item (either to avoid needless duplication of a large data structure, or to support pass-by-reference behavior), I use pointer notation to declaring arguments. Also, if I'm not mistaken there is one difference: you can use any number of pointer operators when declaring arguments, however you may have only one array operator without a stated size. So int foo(int ***n); is a valid function declaration, but int bar(int n[][][]); is not.
What you just said is correct. The pointer type and the pointed-to type are different types. `int *` is the pointer type, `int` is the pointed-to type. The post I responded to said that `int` was the pointer type. ("Data type" means "type") 
You would be right, like a normal array declarations you can only have one empty `[]`. Of course, once you start adding in size's is where things start getting weird (Which is why I avoid the syntax). I'd agree that if you're not putting in a size and just using `[]` vs `*` that can arguably be a nice little bit of documentation.
getfield is nasty Why not populate an array of airPdata's using strcpy and then output them? Doing it the way you're doing it makes the struct pointless (because you could just put getfield in the printf statement)
It should be noted that the prototypes `void foo(int a[])` and `void foo(int *a)` are identical because arrays in C implicitly decay to pointers to their first element in many contexts including being passed as arguments to a function.
See how nginx does it also
Given this new info, I'm guessing that you're not intended to use malloc for each field of the struct. Note that strtok returns a pointer into the the line you just read. I'm guessing you're intended to assign the ptrs that strtok returns to the pointers which are the fields in your struct. This approach is a bit fragile in that the structs you populate this way only remain valid as long as the line remains valid. I.e. as soon as you call free(tmp) that struct goes bad. Note: you still don't need to use malloc to allocate the struct. You can allocate it on the stack as I suggested previously.
Could you use realloc to grow the array for each entry? Or probe the files to see how many records are in them before using malloc? The way you have it set up, the struct is just a pointless abstraction, especially since the data isn't saved (tmp is changed several times per iteration).
&gt; &gt; This way you don't have to malloc storage for each field. Imo, using malloc for character arrays is a better programming practice than declaring a fixed character array size. Imagine loading millions of records - you'd only want to use the memory necessary (and using the heap for large amounts of data is probably better than the stack). So even though it would not be necessary for this basic program, it is a good chance for you to learn. I write bioinformatics software and for sake of speed and ability to run my software on weaker hardware, that's the kind of thing I tend to do. And also in case an input gives a length longer than predicted. Just always have a corresponding free!
Don't call strtok multiple times on the same data as it modifies it. What you should be doing is a single pass over the data, something like: char *tokens[MAX_TOKS]; for (tok = strtok(line, ","), idx = 0; tok &amp;&amp; idx &lt; MAX_TOKS; tok = strtok(NULL, ",\n")) { tokens[idx] = tok }
I guess he is literally dying, hopefully at a very slow pace like the rest of us.
Yes, this is what was killing your initial implementation. You'd read a line, use strtok on it which wrote some '\0's. Then when you'd try to use strtok again the '\0's written by the previous call to strtok would defeat you.
Ah, yes, that's much different. For TCP, there is a big difference between the sockets accepting the connection and the sockets initiating the connection. In my example, those sockets were *initiating* the connection (normally, they are considered the "clients"). So my example was for 4 clients connecting to 4 servers. You could also model a server though. In that case, you would have one socket that accepts the connection and for each call to `accept`, you would get a new socket that would actually do the communication. You are probably better served if you read some guides to network programming. I think [Beej's Guide to Network Programming](http://beej.us/guide/bgnet/) is pretty good (and pretty well-known). Try reading that and see if it illuminates the idea of sockets a little more clearly. (I'd suggest reading it from start to finish, not trying to find the "relevant" parts. It's all relevant!)
94% of the about 108 billion people who were ever born have died, but that doesn't mean that the rest of us is dying too. I for one intend to live forever.
It is always useful to look at the man pages. If you get an EINVAL, that usually means that you used a function incorrectly. You might also want to consult [POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/) which explains most concepts very clearly.
Yep, you should learn to read documentations. 
Thank you! :)
I wouldn't trust Peggy Fisher's courses. I really don't think she has had any real programming experience in the industry. Bill Weinman's courses on Lynda are far more reliable.
1) I'm asking about the DIFFERENCES between the languages, if any. I'm more interested in the answer in C because that's what I use. 2). Then this is a dangerous bit of miss-information that shouldn't be taught.
You've just shown me a gold mine! Thank you so much!
I agree. Peggy Fisher seems to teach every single language under the sun. A few years ago, I checked out her C++ course and it didn't even cover pointers... I like Bill Weinman more but I don't always like his teaching style. "Here's a page of code I already wrote. Look at it and now I'm going to run it." I have to constantly rewind videos because I don't know where he's going. I really like Dmitri Nesteruk on Pluralsight who is more C++, but he almost always starts from a blank page with a new lesson and walks you through his logic. I think the best teacher on Lynda.com was Simon Allardice before he left.
How about also just a simple lookup table? Am enum of states provides one index, an enum of events provides the other, and at each location is the next state as a result of the event. 
I had to do this for cs1 last semester. such a pain. 
That's actually what I'm doing it for as well.
Ucf? 
Thanks for the help, I changed that and managed to figure it out from there.
Absolutely. There's nothing worse. That's why I reckon instead of saying RTFM, you simply point the questioner at the particular manual page, tutorial, stack, or whatever, with a little explanation message to get in touch if they have trouble understanding it. An alternative would be to have manual tutorials and help people confidently find their own info. I really like reading manuals and technical documents. Now. In the beginning it was a real struggle. Something like that would have moved me a lot faster.
Also, C supports implicit casting from void*, whereas C++ throws a fit.
Also, Peggy Fisher's teaching voice is the worst. I feel like I'm having some Mom trying to get me to recite my ABCs when she's teaching something.
That's why the putchar should be on the same line as the for loop.
int *p = XXXXX is declaring a pointer pointing to machine address XXXXX. It is not specifying a value.
You've got an integer overflow with `i * j`, causing `i * j &lt; N` to evaluate to true due to a negative result, then use a negative index. The math result is larger than 31 bits and an `int` is probably 32 bits on your system. It's undefined behavior, so literally anything could happen here, but this would be the most likely. Rather than use a `long long`, you should figure out how to achieve this without the large intermediate. 
Any time you have a segfault, run the code in a debugger. It will tell you where the fault is. In your example, it's here a[i * j] = 0; If you inspect the value of `i * j`, it's negative, which means that it overflowed. You're computing the wrong thing here; you're effectively squaring i, which is not what you want at all. The problem has nothing to do with how you allocated memory. 
Thanks so much. You're right. When I change my 'int' declarations to 'long int' it fixes the problem. Interestingly enough, I do not need to allocate the array to the heap. The stack seems sufficient to run the program with this change. So I guess it was never a stack overflow issue. &gt; Rather than use a long long, you should figure out how to achieve this without the large intermediate. The current algorithm is designed so that the resulting array indexes are set to a true value if the index itself is a prime. Thus allowing me to produce the list of prime numbers instead of just counting them. But yeah, if I wanted just a count I wouldn't use this design. 
I think what you're after is this: int x = 15; int *p = &amp;x; The first line creates an integer variable (on the stack) and initializes it with the value 15. The second line creates a pointer and initializes it with the address of x. I.e. the first line allocates memory for the integer holding the 15 and the second line creates a pointer that points at that memory. The key issue here is memory for the integer _must_ be allocated in order for the pointer to point it. This one is the most misguided: int *p = 15; You're trying to initialize a pointer to point at the 15th byte in memory (as opposed to a location in memory that contain an integer with the value 15). You have no idea what's at that memory location and if you decide to try and write something there who knows what would happen. This one is a bit closer: int *p = &amp;15 Using the &amp; operator means you're trying to the initialize the pointer with an address of something (as opposed to the address 15) - that's good. The problem is there's no something to take the address of. I.e. you haven't allocated any memory to hold the integer so there no address of memory to be had. &gt;Is there a way that a pointer may point at a constant value? I'm not sure if this example is going to help you or confuse you more. But, I'll try... Without going down the rathole of what you mean by constant value, there is this: char *p = "hello"; In this case, the pointer is initialized to point at a string constant. The compiler allocates an array of characters and the value of the string literal ("hello") is actually the address of this array - i.e. a pointer to the first character in the array. It may seem confusing that this works, but your attempts with integers fail. The reason is that string literals, like "hello", are very different beasts than integer literals, like 15. The q's you're asking are good. Keep pounding your head against the wall and eventually it will all sink in.
Please note that the default language for Arduino (and the language where `Serial.println`) is available is C++. C++ is off topic in this subreddit, please ask your question in /r/arduino or /r/cpp_questions. I have removed your question for this reason.
C is better at things C is better at. C++ is better at things C++ is better at. Ask a more specific question. Is this a homework assignment? If so, what are YOUR thoughts?
My favorite example is the if if else problem. :) if(a) if(b) ... else //a ... Whoopsy that else actually applies to if(b), but it is white spaced to a.
If my friend would say "C++ is just C with more stuff", what example should I give him so he understands that these are completely different languages?
they gave me really good advice. Thanks for everything ^^ 
One minor clarification: You can not have a stack overflow when using a malloc-ed array: by definition it is on the heap and not on the stack.
I think C++ is more *expressive*. It continues to implement new ideas. Consider, particularly, C++11/14. C is much more conservative. C++ is object oriented with traits of many other paradigms. C is largely strictly procedural, and while other paradigms can be emulated, it can be pretty hacky. In my opinion, yes, C++ is a better language. This particularly shows itself when there's a lot of inherent state, such as GUI programming. Game programming also benefits a lot from C++. The higher level abstractions also actually allow for greater performance benefits than C (albeit, AFAIK almost always marginal and inconsequential). But OOP doesn't sit well with all people. C code is often much more straight forward. Sometimes OOP doesn't provide much benefit and complicated matters needlessly. If you're staying extremely low level, C++ might offer no benefit or even be a hindrance. C++ also has a lot of other disadvantages. It's huge. It's complicated. Steep learning curve. It takes a lot of experience until you are fluent. Tons of other problems coming from this, compared to small, concise C. C offers other benefits, too. Embedding, self hosting, more compatible (c++ works almost everywhere, but sometimes only through C compatibility, and when C++ doesn't work, C will except in the most extreme cases). Lots of others I'm missing. At the end of the day, for most intents and purposes, it pretty much just comes down to preference. Edits: just elaborating.
With C you can write more performant and optimized code (because you don't have the overhead of objects, exceptions, STL, and the language is more simple and the programmer can write a more optimized code), and also you can write low level code, it's like a more high level assembly if you want, so it's used in all the situation where you need performance and low level access to the system (embedded systems, kernel OS, system utilities like command line tools, system daemons, web servers, etc, etc), in fact practically every OS is written in C, at least the kernel. Also some people prefers C because C++ is complex to use, programs tends to become difficult to understand and to maintain, objects in low level and high performance applications are pure overhead, and doesn't make the code simpler, so... most famous programmers (like Torvalds, Stallman, and other people of the free software movement) have also said that C++ is a bad language (for many reasons). Also another difference to consider, C is weakly typed, C++ is strangely typed, that it's better for some applications but you have to pay more attention... I think that at the end it depends on what you have to do, in particular it depends if you need objects, OOP is not always the better paradigm, sometimes the good old procedural programming is better., sometimes it's not, for desktop applications, GUI, games, sure OOP is good and simplifies the program, for command line tools, kernel stuff, micro controllers, the good old C is maybe better
Is this a Linux program? This is bit of a wild guess, but FS points to the thread local storage, and rax is where return values from system calls are placed. It's probably setting errno if the system call has returned an error.
This has nothing at all to do with C and doesn't really belong here. It's loading the qword located at offset 0x28 relative to the fs segment register into RAX. The meaning of the fs segment register is platform dependent, and you failed to state what platform you're using. But it's a safe bet that it probably points to an area used to implement thread-local storage (TLS) and is probably managed by your libc. That doesn't necessarily mean that this has anything to do with an actual TLS variable, though. Lots of things are thread-local, like errno. 
Your question got caught in our spam filter. I apologize for the inconvenience.
Is this part of an expression or a declaration? Give an actual example with full context; the `*` means different things in different contexts, and it could either be part of the type or the dereference operator. The `main()` entry point is allowed to take one of two possible signatures: int main(void) or int main(int argc, char **argv) (Technically other signatures are allowed in a freestanding environment, but you can ignore that.) So if you're referring to the declaration for `main()`, then `char *argv` is simply invalid. But in other contexts it can be valid, for example if the parameter was declared as `char **argv` then `*argv` is equivalent to `argv[0]` which is a pointer to the zeroth argument, usually the executable name. If your question is really about how arguments to `main()` work, then ask that instead. 
-fno-stack-protector vs -fstack-protector-all
Thank you for this remark.
This is a snippet gcc commonly generates for its stack protector (the offset 0x28 contains the stack-protector canary). Still, OP should have provided more context.
I'll probably get a lot of hate/downvotes for this but C++ is definitely the better language. The reasons why I think that way: * OOP. Nearly every single piece of C code I've ever seen "fakes" OOP by using structs that are passed to every function as argument. C++ supports real OOP which is cleaner, easier to read and less error prone. Less error prone because you can limit access to class members, this way you can prevent many accidental misuses of APIs. * RAII. This makes the lifte time management of memory and every other resource much easier and safer. * Casting. C++ style casting (static_cast, const_cast, ...) is much safer than C style casting. * Better implementation of `const` * Polymorphism (Function overloading, templates, ...). Again, I've seen a lot of C code accomplishing this in dirty ways like casting to/from void. * With modern compilers C++ is on par with C when it comes to performance and resource usage. IMO the only reason to use C is if there is no (good) C++ compiler available for the target platform. Contrary to common believe C++ is suited for low level programming (e.g. (small) microcontrollers, drivers, embedded, ...) just as well as C.
Weak types, and a simpler and far more portable 'libc' means you end up a lot of times things working, and quickly portable. Of course this means things may be working by accident, as type clashes, and memory over/underruns won't be automatically caught. 
You don't have a choice in the matter. `char **argv` is the only valid option. The signature is fixed, because the code that calls `main()` is fixed and outside of your control. The command line arguments are passed to `main()` as an array of pointers to char, i.e. an array of strings. And the way that you pass an array to a function is by passing a pointer to the first element, therefore the type is a pointer to a pointer to char. 
You didn't mention the brackets. Those kinds of details are very important. In the context of function parameters, `char **argv` and `char *argv[]` are identical and both mean the same thing, a pointer to a pointer to a char. The language allows it as a nod to the fact that you're dealing with an array that's decayed to a pointer. This is not in any way the same thing as `char *argv`. 
Word of encouragement: trust me, you WILL get it, and when the lightbulb turns on, watch out because it might blind you. ;) *So many* things in programming involve banging your head against a brick wall until it gives way. You just gotta build up the calluses.
Because `argv[] ` is a pointer, so, `*argv[] ` is a pointer to a pointer. * I'm still learning, but that is how I understand it... 
It's a good point, I would agree (Though obviously you should verify the file is indeed small before allocating that buffer). Ideally you wouldn't be reading the entirety of a file into a single buffer anyway if you can help it (And in lots of cases you can). I just figured it was a pretty simple example for why `malloc` might be useful. I think this conversation definitely feeds into OP's last question though - in a lot of cases, the use of `malloc` can just be one of a few options for allocating your memory. As OP starts coding C more, he'll start to pick-up when it makes sense to go for `malloc` vs. other alternatives. In general I'd say the biggest defining factor tends to be scope. Like you pointed out declaring on the stack is basically always superior if you can do it, but if the things you're handling are going to have somewhat indeterminate lifetimes (Like if you're going to be accessing the `file_data` from different parts of your program after the function allocating it returned) then using `malloc` and friends is generally the best option, since the lifetime of the object is from `malloc` to `free`, which can be done from anywhere.
Of course you can, you can also use an Objective-C compiler to compile C code, but does it make sense ? Also it's not true that C++ compilers can compile C code, take for example the fact that C is weakly typed and C++ is strongly typed, in C++ you must for example use a cast to convert from a (void *) to another pointer type, in C not (for example in C when you use malloc()). Or in C character litterals are 4 bytes (int) and in C++ are one byte (a char), so in C function like getchar(), putchar(), etc returns and accepts int arguments. In fact to manage these differences, in C++ you have to use the keyword extern "C" {} to insert c code 
[removed]
Well the code didnt format right at all. Can someone tell me how to do that? Sry reddit newb haha
Check formatting help. Also an empty line between the code and the text.
Usually when I make a calculator I use the [shunting yard algorithm](https://en.wikipedia.org/wiki/Shunting-yard_algorithm) and [RPN evaluation](https://en.wikipedia.org/wiki/Reverse_Polish_notation). The benefit of RPN being that you can just throw everything on a stack and evaluate it properly.
So basically argv is an array of arrays, right? so the first level is a string, and the second is an individual character in the string? I semi realized this the other day while struggling with multi dimensional arrays. :/
Write your own if at all possible. it's not nearly as much work as it sounds.
By programming... Unless you have a genie that grants wishes, if that's the case could you help finish me off too?
Single is bitwise, double is logical.
You've also got `^` (XOR), `~` (NOT), and of course bitshifts `&lt;&lt;` and `&gt;&gt;`
In libLIVC.c I think you need to change extern struct LIVCDecoder { struct blahblah *Blah; } LIVCDecoder; to struct LIVCDecoder { struct blahblah *Blah; }; 
I'm not going to spend too much time on this until the formatting is fixed so it's more readable, but at a glance... what are you trying to do with "if (a + b)"? You're reading a and b with scanf() but you're not looking for an operator - you're testing to see if a + b is non-zero. If you want to look for an operator between the two numbers (assuming you're using infix notation) you're going to need to add a format specifier for it so that scanf() can put it into a variable, and then you can check what operator was entered. (a + b) will simply evaluate to the sum of a and b. If the user enters -1+1, it'll be false. Anything aside from a 0 result will be true.
as in: 1 to "one" or 1 to '1' 
1 to "one"
Yeah, I should definitely looked a bit deeper into this stuff, I originally skipped over it because I had written public structs before so thought I knew all I needed lol. Thanks again dude.
[Very good one](https://github.com/rui314/8cc)
I found a method that work but seems pretty unsafe. void uint8_t_UTF_16(uint8_t *input, uint8_t *output, size_t length) { for (size_t i = 0; i &lt; length; i += 2) { output[i] = 0; output[i + 1] = input[i / 2]; } } 
Can you show an example of what you are trying to achieve? A small bit of code to look at would be good; you could put the thing on pastebin and link it if you want.
I'm not really sure that c is easier than C++ for writing an OS, but it is more popular. Mixing the two leads to bad code on both sides though, so unless some new kernels are written it will probably be hard to do any comparison.
Look into iconv() for converting between different character encodings.
Off course! I forgot about paste bin :) http://pastebin.com/fNgjhPsZ The idea behind this assignment is the user to type any value, for example "11" and it prints "eleven".
~~That won't work correctly.~~ `input[i / 2]` is ~~not~~ what you want.
[removed]
Thank you so much for the quick reply!! How would I go about making it point to different variables? Should i implement a loop like this pointer = malloc(sizeof (struct library[i])); 
The easy way is to change your structure to struct library { char book[MAX]; char publisher[MAX]; char date[MAX]; struct library *link; }; and either `fgets` right into those buffers, or do a `strcpy`. To malloc, you need to allocate the length of the string (+1 for the nul, of course) and then copy. 
The obvious way with the code the way it is is to just say 'Enter 0 when done', which will break the loop. The other way is to add a counter variable that's stepped with every loop iteration. Also, my compiler says this: cc knob.c -o knob knob.c: In function ‘main’: knob.c:10:5: warning: implicit declaration of function ‘exit’ [-Wimplicit-function-declaration] exit(0); ^~~~ knob.c:10:5: warning: incompatible implicit declaration of built-in function ‘exit’ knob.c:10:5: note: include ‘&lt;stdlib.h&gt;’ or provide a declaration of ‘exit’ Maybe you want to fix that, either by including stdlib.h or just returning (since you're in main).
You can declare and int runs =0 at the top. Then in your loop you do while (gallons!=0 &amp;&amp;runs++ &lt; 3) that will Inc runs by one each time through the loop and only run it 3 times. Since runs will be 0,1,2 and then break out of the loop.
Quick comment about the style here: float gallons = -1 while(gallons != 0) You obviously initialize gallons to be -1 so that it doesn't skip the loop. One alternative way to do this would be to use the do/while format: do { /* stuff in the loop */ } while (gallons != 0); This form will always guarantee that the loop gets executed at least once. It will stop repeating the loop when the condition is met.
&gt; but I cant figure out how to make it end the loop after 3 runs and give me the Average MPG in 3 tanks If you want to run a loop three times, then you could use a for loop int i; for (i = 0; i &lt; 3; i++) { /* loop stuff here */ } If you must do this with a while loop, you can do the same thing manually: int i = 0; while (i &lt; 3) { /* loop stuff here */ i++; } That is functionally identical to the for loop I demonstrated above.
I did have multiple attempt to use iconv but there is something that I don't understand because I am not getting the output that I want. I understand how ascii is encoded into unicode ( "t" is ascii 116, hex 0x74 and is equivalent to unicode 0x00,0x74). But I am obviously confused when my input is not ascii. I updated to original post with some code... 
It means exactly what is says: putc() does what fputc() does but putc() might be implemented as a macro, thus evaluating its argument more than once.
It could be: `#define putc(ch, f) (__foo(f), fputc(ch, f))` where __foo is some compiler defined function. The difference would be apparent if you invoked it as `putc('a', func());` where func returns a `FILE*`. func might be called twice by `putc`. 
Your submission got stuck in our spam filter; I apologize for the inconvenience.
Can you elaborate?
The presentation sounds great! pd: thanks for the emacs mini manual
As has already been said, the right-hand sides are not checking that `n == 'E'`. The reason that this breaks is because `'E'` is replaced by the compiler with a constant integer that is not 0, so you wind up with something logically (but not literally) equivalent to: if (n == 'e' || !0) // evaluates to true every time And, as has already been said, you need to have `n ==` on each of the checks: if (n == 'e' || n == 'E') // true if n is 'e' or 'E' Or, if you wanted to be fancy, you could add some logic to convert `n` to lowercase and then only do the first part of the check: if (n_lower == 'e')
No problem. What I am saying is to use compiler flags when compiling your program. There doesn't need to be errors to still get warnings from the compiler. If you are on windows, google around for the compiler you are using (probably visual studio), if you are on mac or linux, use `cc -o program_name source.c -Wall -Wextra -Wpedantic`. This will give you lots of hints as to where your code may go wrong.
Do you know what for or while loops are? If not, read your textbook / look online for these concepts. You'll want to use a while loop that looks like `while (something_that_terminates_my_program == flase) { // Run caclulator }`
Sure. The syntax is actually as simple as I just showed. Say I want to have the user be able to do calculations until they insert an "exit character". Since we are already using integers to represent addition, subtraction, ..., why not add the option of 5, which will result in quitting the program. I would code this up like so: int selector, arg1, arg2, exit_flag; exit_flag = 0; while (!exit_flag) { // Put in your code you had before // except this time, add in another case for 5 where you will set the exit_flag = 1. // This way, !exit_flag (think of it as "not exit_flag") would equal 0 (since !1 = 0, !0 = 1). } // This bracket closes out our while structure Sidenote: As a point of proper form, you should define your main function as `int main(void)`, and `return 0;` at the end of your program (before last `}`. Give it a shot, and if you run into problems come back and ask here.
Us old-school programmers (I know some of you are going to shake your fist and tell me to get off your lawn. Looking at you, COBOL and Fortran weirdos...) had that rebel spirit, and an *interesting*, subversive sense of humor. Don't mean to rant, but I do feel that that *spirit* is sadly absent in many young engineers these days. I think it is because people get into STEM simply because "It's a good career choice." Speaking for myself here -- but have a suspicion that a bunch of you will probably relate -- I was driven by an obsessive passion, not by a paycheck. I had no idea that my weird hobby of writing BASIC and Pascal programs in a spiral notebook as a little kid would turn into a lucrative career in one the most defining professions of the future. Ok, that went off on a weird tangent. Sorry! :)
I wrote FORTRAN programs as a kid. I wasn't any good at all. Over the holidays I finally found the old computer arithmetic self-tutor book from my collection. Paging through it, looking for the hex conversion examples I remember. *This is odd* I thought. *Where is the hex?* Check the index. No hexadecimal. Check the table of contents. No hexadecimal. Just octal. Check the copyright date. Think about the state of computer science as of the copyright date. Sigh, and get up to get some more tea. True story. 
Don't post images of code. `x *= i` is shorthand for `x = x * i` which doesn't require repeating the variable name, which can help avoid bugs if you change a variable name and forget to change both instances. 
What's the resonant frequency for human skulls?
I also asked over on Stack overflow. I kinda have it working, but I cant figure out where to put for (int i = 0 ; i &lt; 3 ; ++i) to get the loop to only run 3 times. #include &lt;stdio.h&gt; int main(void) { int i=3; int miles; float gallons = -1, mg, overall = 0, avg = 0; printf ("This program will calculate the miles per gallon for you for three tanks of gas after you have entered the gallons used and miles driven. \n"); while(i&gt;0) { printf("Enter the gallons used: "); scanf("%f", &amp;gallons); if (gallons == 0) { printf("\n\n The overall miles/gallon was: %f\n", overall/avg); exit(0); } printf("Enter miles driven: "); scanf("%d", &amp;miles); mg = miles/gallons; printf("The miles/gallon for this tank was : %f\n", mg); overall += miles; avg += gallons; } return 0; } /* end program */
*This guy gets it!* More, please. :) EDIT: I have worked alongside the uninspired and disengaged "engineers" throughout the years (with noticeably higher frequency within the last 10). And I really feel bad for them as I couldn't imagine doing something I wasn't passionate about, day-in, day-out. Their skill-set and system architecture stagnates. The books on their shelves march steadfastly towards irrelevance. Higher frequency of code-rot compared to more competent engineers. More time spent debugging. **while(1) \{\}**... until eventually they kernel panic, and settle for a JavaScript position. That STEM job you want simply because it is a *"good" career with "good" pay...* -- I actually believe if you followed your passions instead, you'll eventually find your way into a *"great" career with "great" pay*... and *much* higher satisfaction.
Oh, i know exactly what you mean, which is what i tried to say with my comment .. I did start my programming path with turbo pascal, so i'm really fond of borland's help files. To this day i think their stuff had much better impact on the industry than any other product. Looking at you DELPHI :) let's not focus on the negative, and remember that there are still some young people out there who are in the industry because they like it, and they find it fascinating. And i hope that passion stays with you in the future .. i know that's something that's hard to preserve :) .. peace.
Let's ask Linus. http://harmful.cat-v.org/software/c++/linus
That's definitely a great point you make about following your passions instead of being peer pressured into STEM. If you genuinely love something, it makes it *that* much easier to turn it into a career. Next time someone asks me for advice, I'll definitely make that point you made :). 
&gt; I think it is because people get into STEM simply because "It's a good career choice." I think that's a good thing because we need people in those jobs, but yeah, there's a bit of a culture shift. If you were into computers in the 1980s you were a nerd. You had to be interested enough in it to get into something that wasn't as pervasive and approachable as it is today and to not care what people thought of your hobby. And yeah, I've got spiral bound notebooks from junior high full of BASIC, 6502 assembly language, and schematic diagrams.
You made me look it up but couldnt find much lol
yeah, the x in the loop and the x in the loop head need to be different. int factorial(int x){ int final = 1; for (int i = 1; i &lt; x; i++) { final *= i; } return final*x; }
That would return (x-1)! (because final will never be multiplied by x). You could change the last line to return x*final; Or the final declaration to int final = x;
[removed]
We demand answers! EDIT: [This article on acoustic weapons](http://www.popsci.com/technology/article/2012-11/acoustic-weapons-book-excerpt) examines this issue. It was inconclusive, but they speculate you would need 200Hz at 240 dB to achieve the resonance needed to effectively make a head explode. What I learned today in *r/C_Programming*.
Yes i think, i dont know for sure because i dont use autocompletion on emacs (i use it as customizable text editor)
Yeah I should tried that. I found what I searched thanks man.
What book is that from? 
My best advise is to follow the famous words of Knuth: &gt; Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%. It is important to understand the meaning of the quote: The intent is not that you should write code without thinking about performance. In fact, it is very important to think about performance when you design your program. Choose good data structures and fast algorithms and your programs are going to perform well. Do ignore micro-optimizations like the one you describe in your question unless you are sure that the spot you want to apply them in is a performance-bottleneck. Most micro-optimizations are performed by the compiler automatically and the compiler is usually better at them than you are going to be. That said, there are a couple of things you can pay attention to: * try to avoid unnecessary work; every algorithm can be beaten by the algorithm that is never executed because you don't need its result. * if you have a function that has a small range of valid inputs, it is often faster to use a lookup table than computing the result manually. Lookup tables (especially small ones) are hard to beat from a performance POV. * if you write floating point code, it is often a good idea to manually rewrite formulæ to be less expensive as the compiler is not allowed do many of these optimizations unless you specify something like the dreaded `-ffast-math`. I also recommend you to carefully read and understand the IEEE 754 floating point standard. * also for floating point code: try to avoid conditional code. If your code is free of conditional branches, the compiler might be able to vectorize it. Also be careful with comparisons as NaNs cause unintuitive behaviour the compiler has to account for. This can cause it to miss optimization opportunities. Some times, negating the comparison (e.g. `!(a &lt; b)` instead of `a &gt;= b`) can cause the compiler to generate better code. * do inspect the generated assembly. If you are interested in micro-optimizations, do learn assembly programming. This allows you to spot situations where the compiler made a poor choice and gives you the right ideas to nudge it into the right direction with unintrusive code changes.
When working with small embedded systems like I do, even small optimizations will be useful (if applied everywhere). My goal is not to get a few good tricks but to write overall better optimized code without making the code unreadable. By the way: the arm compile I use right now did not optimize that specific example so not all compiles are doing the hard work for you (yes I have optimization set for speed when testing this). 
A very good book for micro-optimizations is *Hacker's delight.*
Writing good programs is not easy. People usually study computer science to learn how to do that.
I had a course in C last semester, and most people seemed to struggle with pointers. A pointer is basically a variable that holds an address to something. This something can be defined as a type (int, char, void), or a function. The character '*' is used in three separate ways in this language, so beware of that. 
&gt; you'll eventually find your way into a "great" career with "great" pay... and much higher satisfaction. Most people won't. You were lucky, so was I. We just happened to be passionate about something that blew up into a great career. Most people are passionate about stuff that won't pay the bills. If they are passionate about anything at all. But I wouldn't generalize from my own luck.
It's pretty good, and if you're a student, you can get a license for free for a bunch of their IDE's
Not understanding pointers is something I just don't get. I don't know if it's cause I started life as an electronic engineer and used to design computers from scratch or if people just aren't taught in a simple way for this simple thing. They're called pointers cause they point at something. A pointer is the memory address of what they're pointing at. How difficult is it to understand that? Yes, I know. Pointers to pointers and all that but, from what I gather people struggle from that first concept.
I think the reason why people "struggle with pointers" is that they are actually trying to learn "C/C++" instead of just C, and get confused by the different meanings of the '&amp;' character in C++ and the duplicate functionality of pointers and C++ references. The most important advice for someone who wants to learn C is to stay away from C++.
Hacking: The art of Exploitation by Jon Erickson
`i &lt; x` is fine, unless x is 0. Consider x = 5: First loop: i = 1 x = 5, i is less than x Second loop: i = 2 x = 5, i is less than x Third loop: i = 3 x = 5, i is less than x Fourth loop: i = 4 x = 5, i is less than x Fith loop: i = 5 x = 5, i is not less than x, loop terminates If `x` is 1 then the loop doesn't even run, and `x` is returned, which is the correct answer for `!1`. --- Edit: I seem to have based this off /u/postgresquirrel's corrected version above, not the original function.
I think most people just dont understand how memory works. That is why they are confused about pointers. Its like trying to learn integrals without knowing derivatives
You want to see `The overall miles/gallon was:` three times for different inputs before it exits? 
There's a few courses on Coursera by Tim Roughgarden on Algorithms and Data Structures that I found really informative. He also comes off quite personable as a teacher, which helps. 
Thanks for the advice :) . 
Cute. Here it is for easier copy/paste/compile/run: #include &lt;stdio.h&gt; double m[]= {7709179928849219.0, 771}; int main() { m[1]-- ? m[0]*=2,main() : printf((char*)m); } (worked on 64-bit clang, macOS)
Also, if you're interested, there's also a John Lions-style commentary on the kernel out there, called *Notes on the Plan 9 Third Edition Kernel Source*. [Here's one link](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.75.5409&amp;rep=rep1&amp;type=pdf). I haven't gotten past the boot process yet, but overall, it seems to be a pretty good accompaniment to reading the source. The only issue is that I haven't yet found a way of getting a snapshot of the kernel from when the book was written (all the supposed links to snapshots out there are dead), so you have to do some `grep`ing and searching to match up the books lines numbers with the most up-to-date source.
edit: [Here](http://coliru.stacked-crooked.com/a/f82bd371011225ab) is a less obfuscated version of the code, for clarity. On the machine you're using, doubles are represented by the [IEEE 754 double-precision format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format). This is a format where numbers are represented by a formula that looks (very roughly) like `fraction * 2^exponent * (-1)^sign`, and the three variables there are packed into the 64 bits of double [like this](https://upload.wikimedia.org/wikipedia/commons/thumb/a/a9/IEEE_754_Double_Floating_Point_Format.svg/618px-IEEE_754_Double_Floating_Point_Format.svg.png). So, the exponent are stored in the high (most significant) bits of the number, and the fraction is stored in the low bits. Additionally, your machine is probably little-endian, which means that the least significant bytes are actually stored first -- so, if you look at a double as a sequence of bits in the order they're stored, you'll see the fraction first (52 bits), then the exponent (11 bits), and then the sign bit (1 bit). Since the formula looks like `fraction * 2^exponent` (ignoring the sign for now), the simplest way of doubling a number (which is what `m[0]*=2` is doing) is to increase the exponent by one, since `2 * (x * 2^y) == x * 2^(y + 1)`, and that's what the computer does. You can see a progression of the way the array evolves as a sequence of bytes [here](http://coliru.stacked-crooked.com/a/c5286aa8f05fdf39), where each byte is represented by two hexadecimal digits (since each digit represents 4 bits). As you can see, each time it recurses, the first 12 bits of the number (the exponent and sign) increases, which, since we're using little endian, ends up being the first digit of the 7th byte and the 8th byte. The sequence `43 2B 2B 53 75 63 3B 43` in iteration 1 is really `43 3B 63 75 53 2B 2B 43` in "correct" order, from most significant to last, and here, in big endian, the exponent (and sign) are the 3 first digits. In iteration 2, the 7th byte changes from `3B` to `4B` -- the exponent is increased by one. Once we reach iteration 772, the last iteration, which is when `m[1]` is zero, and it finally prints, the sequence of bytes in `m[0]` is `43 2B 2B 53 75 63 6B 73`, and `m[1]` is just all zeroes. If you put that into an ASCII converter, like [this](https://www.branah.com/ascii-converter), you can see that this is just the ASCII string for "C++Sucks". Since `m[1]` is all zeroes, the first byte acts as a terminating null. (So that we don't continue reading garbage.) So, let's try printing "HiReddit" this way. We can do this by: * Converting it to a hex representation of each bytes ASCII value, which [gives us](http://coliru.stacked-crooked.com/a/259c57f33ecfad35) `48 69 52 65 64 64 69 74` * Subtracting the initial value of `m[1]` from the exponent. Since the exponent in the above value is 0x746, and the value of `m[1]` is 771, that gives us 0x746 - 771 == 0x443. inserting that back into the sequence gives us `48 69 52 65 64 64 39 44` * [Inserting these bytes into a double](http://coliru.stacked-crooked.com/a/cd889b1c270cd3ec) then gives us the value of `468402620148830699520.000000` [Substituting this value into the program](http://coliru.stacked-crooked.com/a/6d816e9f21566132), we can see that we do in fact get our desired output.
I disagree. Memory is easy to understand. The arcane seeming rules surrounding * syntax seem like the biggest stumbling block for people.
No, these days all of your programs run in their own, virtual memory space. So your rogue program will, in most reasonable circumstances not be able to muck about with anything else running.
No problem! Everybody starts somewhere. Slow and steady, you'll get there :D
Simply reading outside array bounds shouldn't do more than make your program crash. Acting on the data you get back if it *doesn't* crash could cause problems, and writing outside of array bounds can get you into all sorts of trouble. Hopefully it'll crash before anything really bad happens, but buffer overruns are one of the most common sources of security vulnerabilities in C because they can frequently overwrite the stack. The system's MMU is going to cause a segmentation fault if you try to access memory outside of a valid segment. Even on small devices without an MMU, writing to an invalid address will usually throw an exception. If you're writing to valid memory, though, you could be overwriting other variables, possibly code, and overwriting things on the stack like the return address of a function call.
Would these issues be resolved by a simple reboot?
ಠ_ಠ Read what they said again..
Wow, you are panicking for no reason at all. Leave it be, your PC/laptop is perfectly fine. 
Unless you know the exact number of bytes beforehand, it is not possible to malloc precisely.
glibc has a "getline" function that allocates a string to the precise size: http://man7.org/linux/man-pages/man3/getdelim.3.html This function is also standardized in POSIX.1-2008. 
I disagree with you. In certain high-reliability and embedded applications you might want to avoid dynamic memory allocation but for normal applications it's perfectly fine to use.
If I overwrite code that should be resolved by just restarting the program, so I'm guessing yes?!
Yeah, malloc is OK to use if you need it. Since u/BizarreRabbit has a string of only 50 characters, he doesn't need it (as far as I can tell from his post).
Unless you're in an *extremely* low-RAM environment, why not just allocate your 50+1 bytes and be done with it? Even in typical embedded applications, a 50-byte buffer for string input shouldn't break the bank. If you tell us more about your application and your platform, maybe we can help more. Also something to think about: The more clever you get with memory saving schemes, the more code you'll write (or rely on if it's a library) which will increase your code footprint (RAM or ROM) and increase the number of test cases you'll have to write to be confident in your clever solution.
The difference matters. Someone using gcc on Windows might get the impression that they can use `getline()`. 
I bet you're a pleasure to work with. 
My brain @_@
[The absolute best place to learn linked lists in C :)](http://lmgtfy.com/?q=linked+list+in+c)
Same idea, except you're going to be dealing with pointers instead of objects, and you'll have to deallocate the memory you create for each Node when you want to remove a Node. So you've got your Node structs and they'll have a pointer to another Node struct, often called "next", by default that should be set to NULL, so that NULL is the end of the list, and when you want to create a new Node you'll havesomething like: x-&gt;next = (struct Node*) malloc(sizeof(struct Node)); where is x is a pointer to a Node struct, the arrow operator dots and dereferences the pointer (you're okay with idea of dereferencing I'm assuming), its return is cast to a Node pointer because next is a Node pointer and malloc returns a void pointer and sizeof() gives you the size in bytes of a Node as that will be how much space you'll need to allocate. Now, instead of making a new Node at the Node x points to, maybe it already has one and it's *that* one that you want to make a new Node at, i.e. you're not making a new Node at the tail of the list but you want to make a new Node when you're at the Node right before the tail, in which case it would be: (x-&gt;next)-&gt;next = (struct Node*) malloc(sizeof(struct Node)); the take away here being that you can chain these, x-&gt;next gets the next Node and -&gt;next that gets the place where you want to create a new Node. This is more useful when deallocating memory, like when you're removing Nodes, you might be at Node x, want to remove y, but keep z and everything after it, so you'd point a temp pointer at y, then move x's next to z: x-&gt;next = &amp;z; free(y); where &amp; is the address of operator, because those are pointers you need to their addresses. But you might not actually have y and z as Node pointers, so it's something like: tempPtr = x-&gt;next; x-&gt;next = (x-&gt;next)-&gt;next; free(tempPtr); As for double pointers, I don't think I'd use them for this, chaining is good enough for most of what you need to do, and moving around the list can be done with: nodePtr = nodePtr-&gt;next; which would move nodePtr to the next Node. So, double pointers aren't needed typically, unless of course your Node struct has something that's a double pointer as a field, but that's different, which we can go into if you want. Does that help at all? Is there any part of that you don't get? 
If you have a standardized naming convention, carrying functions with the data is a lot less important. Imho, data objects coupled with functions are mostly useful for code discovery. List\_append (&amp;list, var) List\_concat (... essentially you type "List_" double tap tab, and you'll have the code discovery. The other great usefulness imo only, is the this or self reference that gets auto passed... which unfortunately I don't know of way that it is possible. The foreach and map filter reduce type functionality can be achieved with a function that accepts function pointers. struct Range { size_t begin, size_t end}; void custom_fun(T*); int match (T*); void callback (T*); void on_else (T*); List_foreach (&amp;list, custom_fun); List_select_foreach (&amp;list, range, custom_fun); List_on_match (&amp;list, match, callback); List_sel_on_match (&amp;list, match, callback); List_on_match_else (&amp;list, match, callback, on_else); // etc And then you can have multiple callback type calls in the same scope. 
I've come to that conclusion as well. A lot of time I get horrible analysis paralysis when planning complicated systems in C++. There are so many "good" ways to do things, each with its own trade offs. In C it's generally "well I'll implement what I need to get this to work".
Dunno why you're getting downvotes, you're right.
**Please** do not post code as images. We can't copy and paste an image to test it. Beyond that, you've not explained either of 1. What the code is supposed to do 2. What the code is actually doing. We can't read your mind. See http://www.catb.org/~esr/faqs/smart-questions.html and try again.
Please post your code as text, not an image. I have removed your post, please try again with code as text. Put four blanks in front of every line of code so the code is formatted correctly.
Thank you very much, nothing in particular I didn't get but I guess I'll have to play around with it for some time untill I get the hang of it.
Well, you could realloc down to the string size afterwards, but it's unlikely to be worth the trouble to save a few bytes.
I was told to replace all deprecated and obsolescent functions for a project, as shown here: https://www.securecoding.cert.org/confluence/display/c/MSC24-C.+Do+not+use+deprecated+or+obsolescent+functions 
The downvoters will learn the hard way I guess :)
If you're in the middle of writing a file or something you might corrupt the file you're writing, but generally speaking, yeah, you're fine if you just restart.
Oh my. I don't know where to start. It's hard to read with the formatting but there are missing semicolons and functions declaring instead functions. 
Yup, I missed this part.
Do you have any specific questions? If you can zero in on what you don't understand then someone can maybe help.
If this is how you react to someone informing you of facts, I'd rather take him than you.
`fgetc` returns an int and `buffer` should be an int. `EOF` will never compare == with a char value.
Thank you! Forgot to account for the size of the file, that fixed it.
Welcome :) 
I used Clion free on a student license to do an undergrad projects for my operating systems course. It was my first serious c systems program with parallelism and networking and I enjoyed the auto-complete and quick links to the C libraries in the Ide. However as a novice C programmer I will say that I can't speak about the allegations of inferior or broken auto-complete. 
One major benefit of the object carrying its function pointers is it can allow "derived classes/objects" to overload those functions for custom handling. It essentially declares List as an interface (think c# interface) without any concrete implementation, and List_new() as the constructor of the object. For example, let's say I'm on an embedded system with limited memory and I want to avoid any dynamic memory allocation possible, but still want to use a list type and allow consumers to use as such. I could reuse this interface with a new constructor function (e.g. List* static_list_new(List* new); ), but reimplement all methods in the object. Now consumers won't know or care the difference, because other than the constructor no other function calls need to be changed or updated. (Nevermind that this isn't a perfect example because the add method may fail due to static sizing, but hope you get the gist). On another note OP, I love your define to create lambda functions, can't say I've seen or tried that!
There's 21st century C: http://shop.oreilly.com/product/mobile/0636920025108.do
[This](https://matt.sh/howto-c) is a short article to get you started. [Linux Kernel coding style](https://slurm.schedmd.com/coding_style.pdf) is a widely used style guide I would recommend using. Absolute best book on (modern) C **In my opinion** is the freely available [Modern C](http://icube-icps.unistra.fr/index.php/File:ModernC.pdf) by Jens Gustedt. The book linked by u/benwaffle is more specific to your question, though (the author talks a lot about useful tools). [Here](http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf) is the C11 standard (including stdlibrary). You are right though, finding these kind of material on your own is unnecessarily difficult. Still, there is a lot of good info about using C out there, its one of the most used languages after all. Edit: updated link
I would look at the code [in ccan](https://github.com/rustyrussell/ccan). A lot of cool modern development going down.
&gt;How do I go about installing libraries? You don't install libraries. Either you compile them in as source code or you call them using your operating system or include them with your build command. &gt;Is there a package manager? For what? This has nothing to do with the language. There are no "packages". The rest of your questions are based on lack of fundamental knowledge and things learned from sources that have nothing to do with C. You need to find a very simple intro to get you going. Even though it's old and not modern, the very best book as an intro to C is ["the white book"](https://www.amazon.com/Programming-Language-Brian-W-Kernighan/dp/0131103628/ref=sr_1_1?ie=UTF8&amp;qid=1487505033&amp;sr=8-1&amp;keywords=c+programming+language). Easy to read by the author of C himself. Over 30 years later, I still have it sitting on my shelf as a homage if nothing else. EDIT: As always, I'm not surprised about redditors inability to read what I wrote and insert words I never said.
This code is pretty bad though, each instance of an object holds the pointers to the functions. Even if they belong to the same class. That's a lot of memory wasted. The good way to do it would be to have each object hold a pointer to its class. The class is defined in a separate struct that's filled with the function pointers at compile time. 
[removed]
Recently I had to optimize some code in a very tight loop that was reading from a device -- the API had no backoff for data transmission, so if you missed a byte due to taking too long, the whole system would error out. In this case, I had to do some hoops. First was thinking back to my CS compiler days -- what could the compiler guarantee at any given point? So, for example, I prepared the loop by putting a class variable into a local variable, and then letting all the work get done there -- this let me not have a memory access on each iteration. Then I noticed I had a modulo operation in the loop to bin -- turning that into a comparison with a counter looks uglier, but is much faster since the operation is cheaper. And then I looked at the assembly code produced by the compiler -- I didn't have any more things I could hand modify, so I considered it good there. So, in my case, I had to go back and remember some of the fundamentals in compiler design and language use to optimize correctly. 
That book should be used for syntax learning and nothing else.
I disagree, K&amp;R can definitely still be used to learn most aspects of the C language (never heard it being referred to as the white book). It simply shouldn't be the only book/resource you use.
I don't think you realize the context from which the OP appears to be coming. * in Linux, i can install all kinds of libraries with a simple command - libzip, postgresql libraries, and many others. No building needed. * in some language environments, libraries can be gotten through a language-specific package system. The build system knows to get the required package. There was a big deal in the node ecosystem when a low level library that was widely used was suddenly removed. 
We were told it was called the white book in 1985 when I was told to go buy it to learn C.
&gt; I don't know where should I look to find information regarding getting started with a c project using the latest standards. How do I go about installing libraries? Is there a package manager? That's not how C works. Thankfully! C programmers who don't need portability to MSVC on Windows mostly use C99. Programmers who need to support MSVC on Windows, particularly any versions of MSVC older than the latest, use "ANSI C" (also called C89 or sometimes C90). This is because Microsoft support of C has been historically weak. Use your OS to install runtime libraries and dev packages (libraries and headers). On many Linux distributions this would be "libfoo" and "libfoo-dev". People are opinionated about build systems but the original, and the one that hasn't yet caused me to prefer another, is *make*. For style, there is no canonical style. (Disagreement over style led the authors of Go to create a canonical style.) I prefer KNF or K&amp;R, and not Allman braces. Allman braces are most commonly seen in Microsoft documentation or programmers who came from Microsoft culture, in my experience. 
[Hungarian notation forever!!!](https://en.wikipedia.org/wiki/Hungarian_notation), well that and NT/OS2.
Thank you so much for such a detailed answer. You have basically answered everything I had and more. This should honestly be a blog post somewhere making easier to discover for people who are new to the language and want to learn about how to go about it. I still have a question though. You mention that I should look to C++ if I want advanced data structures, threads etc, why would you recommend that? I mean everywhere I look, almost everyone agrees that C and C++ are different languages used to solve different purposes. Plus C++ has so much going on, it is harder to get started with as compared to C too. 
The problem with types like `int` is that the standard only mandates a minimum size for them, so you actually don't know how big it is. You can find out for a given architecture and OS/compiler, but the typedefs in stdint.h provide a stronger guarantee about what you're getting. For example, `uint32_t` is a ~~long~~ `unsigned int` on my linux x86-64 system. edit: `size_t` is the type that is guaranteed to hold all results of `sizeof`
Your point about not knowing the size of an `int` on a given system raises another question. How do you profile your c program? What about memory profiling? Also, that makes sense. So using standard types is what someone writing new c code is supposed to do right?
In my opinion C++ is better for application development simply because a lot of wheels have already been invented for you. With C you don't get to use Boost or the STL and probably end up creating your own (buggy and inefficient) data structures and algorithms. With C++ you can concentrate more on the application at hand. 
You can use int and unsigned int types if you want. There is no rule against it and it is not considered bad practice. However if you use int, you have to assume that it is encoded with only 16 bits even though on most machines it is 32 bits. That is confusing. On the other hand, fixed sized types like uint8_t are not guaranteed to exist by the standard! (but uint_least8_t and uint_fast8_t are). Of course on most systems fixed types do exist. So what now? On systems with 16 bit ints, code using int can contain errors if the programmer assumed that int is encoded with 32 bits (which is a common mistake), but it might compile without error. On the other hand, if the program uses int32_t, the code might not be portable, but in that case the compiler will give an error! So it is personal preference which types to use. I personally often use fixed size types, many experienced C programmers do not. If your values fit in 16 bits, you can safely use int. size_t could be used whenever an integer is supposed to represent a size of some kind (Cardinality of a set etc.) and for indices. For example: for(size_t i = 0; i &lt; 10; ++i) {x += a[i]} can be used as a for statement. But if you use int instead of size_t or even int32_t it is not considered bad practice. It is only bad if the usage of types is not consistent. One more thing: If you use a library function which has return type int, one should assign it to a variable of type int to avoid implicit conversions. The same goes for every other return type and for function parameters. Edit: If someone who is new to programming in general reads this: Just use int and long, but be aware that int can be 16 bits and long 32 bits on some systems. The above discussion is targeted towards programmers of intermediate experience level. 
It's worth reading the reviews on Amazon before buying that book.
You sure you don't want to learn post-modern C?
The point of these types (i.e. uint8_t, int16_t and uint32_t) is very simple. These types guarantee how much space the take up - one byte (8 bits) two bytes and four bytes respectively. These types are particularly useful when you might compile the same code for different machines or even cross-compile for different architecture all together, since the memory footprint and minimal/maximal values will remain the same on all the supporting machines. Moreover, in networking, lets suppose you right a struct consisting of integers and size_t variables to a socket an a 64bit machine and send it to a 32bit machine. The 32bit recipient having the same structure defined won't probably receive it properly. Also, an off topic remark, the endianness of the sender and the receiver should be addressed as well, meaning both have to communicate using the same endianness.
Here's a follow-up question: how much value is there in reading K&amp;R nowadays if there are books to learn more "modern" C? I'm asking because I need to pick up C for a course I am taking in the fall and would like to get a head start.
I highly recommend as will, but I urge you do the exercises in the book as you go, don't just read through!!!! There is no better way to learn programming in general and C programming in particular!!!
There are plenty C libraries out there which are just as good as C++ libraries. Its only the C++ standard library that is better (or more precisely: larger) than the C standard library. This myth that C++ libraries are better than C libraries probably originates from students that are forced to only use the standard libraries of a language.
&gt; You mention that I should look to C++ if I want advanced data structures, threads etc, why would you recommend that? Well here's my rationale: if you want to use threads for C, then you will typically end up writing two implementations: one using posix threads for unix and one using windows threads for windows. MinGW, which is a port of GCC for windows, comes with a posix thread library and there's also [pthreads4w](https://sourceforge.net/projects/pthreads4w/), but in general making portable multi-threaded code in C is a challenge. On the other hand, C++11 has built in threads - so writing portable multi-threaded code is easier. If you want to use hash maps in vanilla C, you could use the GNU C Library's [hashtable](https://www.gnu.org/software/libc/manual/html_node/Hash-Search-Function.html); but if you decide to do this then porting to windows will be more difficult. Again, it's easier to write C++ that uses `std::map`. Now, of course if you want to program for the linux kernel or for a foreign function interface, it's often easier to stay with vanilla C since C++ support isn't always there. And frankly if you are just starting out, C is much easier to learn than C++ since it's a smaller language. But C++ absolutely has place for writing portable code when you need convenient abstractions, so it's something to consider when you are reaching for those.
Nah, malloc has nothing to do with the basic types (int, double etc.), it is only for pointers (the return type of malloc is a void pointer). This is how you access an int value of a struct object: struct point { int x; int y; }; struct point p = {.x = 2, .y = 1}; int z = p.x; // assign the value 2 to z 
Well, the `int8_t *` type is like the `byte[]` type in Java and [`Int8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array) objects in ES6. All of these are signed byte arrays. On the other hand, the `uint8_t *` type is like the [`bytearray`](https://docs.python.org/3.1/library/functions.html#bytearray) type in Python 3.1 and [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array) objects in ES6. These are unsigned byte arrays. In C99 Uint8 did not enforce that the underlying object had 8 bits, which is why the IEEE came up with `stdint.h` spec ~15 years ago with all of the `_t` types. You will generally see these types used in cryptography and wire communication. In ES6, the WebCrypto API uses Uint8Arrays for digital signatures and cryptographic hashes. Similarly `MessageDigest` hashes in Java use `byte[]` types as their interfaces. In C ZeroMQ uses `uint8_t` and `uint32_t` types for wire communication; similarly the Raspberry Pi uses `uint8_t *` types for interfacing with the GPIO pins on the device.
The summary of the classic advice for taking over "legacy" code from someone else is: *write tests*. All labs tend to use relatively poor quality, relatively undocumented grad student code. This is normal. If you think you might need to use Windows or Win32-specific code, a useful book is [Petzold's Fifth Edition from 1998](http://www.charlespetzold.com/pw5/). This is the previous-to-latest edition of the book, the last one on Win32 and C. (He was convinced to use Microsoft's preferred newer language for the Sixth Edition.)
For one trying to learn the language as a beginner, it explains more than he needs to know from the creator of the language and one of the best technical writers around.
Just driving by to congratulate this comment. It pushes OP in the right direction without being a dick *and* you're offering to help. Thanks for making this sub a pleasure to read.
TIL you can specify member values out of order if you want. Is that only available in a newer version of the C spec, or does it go all the way back to C89? I don't remember seeing it in the K&amp;R2.
This is really great advice! Thank you!! I'll try to ask about getting a copy of the source code, and I definitely might take you up on that offer if I end up needing help. When you say that many people use an ide, what do you mean exactly? Sorry if that's a stupid question, I guess I'm much more familiar with using IDEs to code. So they just use a text editor and run it on the command line then? If he did/didn't use an IDE to make it, does it matter if I use one when I go to try edit the source code? 
I really like that idea of writing tests. Every so often it just of crashes for no apparent reason, and nobody has ever really been able to figure out why or how to fix it. Turning it off and then on again usually solves it, but it would be really nice to have ways of identifying and fixing problems, especially if I'm starting to edit the source code as well 
Aww... well now's a good time to learn, before you go to grad school (if you have plans to do that) or get into a career. It would look pretty good on a CV or resume applying to grad school or science research jobs, although knowing R or Python are usually impressive enough. I'm a biology researcher. We had a perl script in our lab that was written a long time ago that completely baffled me, so I hired a CS undergrad to help with it. He worked on it for about a month, and I paid him around $10/hour. It ended up being under $500, which was a bargain imo.
yeah, I misremembered. thanks!
I'll give that a try, thank you for the info! 
Use a 2D array like: int mat[4][4]; Then access it like: mat[0][0] = 123; mat[0][1] = 456; etc.
It looks OK, the letters are spaced evenly. How would you like it to look instead? (If you precede your comments with four spaces per line, it will become monospaced.)
https://gyazo.com/343592918e8f95b221523ee0820f2a3e i want it to look like this
Yup, that makes sense. Thanks for clearing that up :)
ye i know where the spaces are coming from between the 13th value i just dont know how to get rid of them like if sz = 13 printf(""); so nothing comes up at a sz value of 13?
You could use an if statement when sz==13, to print a different thing in that situation. 
I figured it out i just needed to separate the if statement with an else if statement and switch the spacing up and it worked well thanks anyway.
thank you for your answer antiquark, i know it can be done like that. used this matrices example to show the "need" to be adding +1 on the name vars, like ...name1, name2.. but in a loop, not calling them by hand. but this was a too complicated example i think, will repost tomorrow with something less stupid xD
Do you mean you want to use an arbitrary number of variables named `name1, name2, name3, name4, ..., nameN`? You can do this with preprocessor macros, but you if you ever come to a point where you think you need to do this, you should probably reconsider how you're doing it.
oh i messed up the parenthesis
End and begin are right next to esach other. Instead, try: printf("Begins at %p ends at %p\n", buffer + 0, buffer + 99999); 
&gt;As someone who's really interested in learning low-level paradigms and working closer to the metal, c is something which I feel has to be learned. If you're going to be working in embedded environments, I'd keep in mind that embedded is very conservative. I feel like C99 is really just starting to get traction.
Good idea, thanks!
Functions could maybe return the class. So something like `list-&gt;class-&gt;map()-&gt;foreach() ...` 
Due to high interest, I have decided to pin this thread for a week or so.
Ah, I see. C# is entirely unrelated to C, so you're in the wrong subreddit, perhaps try /r/csharp. But that's also good news: some C# programs also work on Linux and OS X through the use of *Mono.* &gt; If I could interface with matlab somehow more directly and just extract data from the program to matlab, it would be most ideal since I'm more comfortable with matlab and so is everyone else in the lab. If this is the case, it seems like the program is already interacting with Matlab in the most direct way possible, i.e. through using Matlab's programming interface.
malloc always returns a pointer. You can allocate a single int, but malloc will return a pointer to it, and you'll have to access it through its pointer.
Probably noone cares but I found the problem to my crashes in addition to what was mentioned, I didn't cast the malloc to the correct type in ` p1-&gt;children` and ` p1-&gt;children[i]`
What's the advantage of these modules being single files? Does it not start to get inefficient?
I believe it's only slower during compilation. Advantages I can think of is simple to find what you want and it's all encapsulated within the single module so easier to wrap your head around the way it works. Moreover, you don't import giant groups of modules for a single mini feature. For example, the reason why including bool.h rather than an all powerful 'other' data types that would potentially have thousands of lines. 
I'd suggest understanding the difference between [arrays and pointers](http://www.panix.com/~elflord/cpp/gotchas/index.shtml). What you actually did in the code bellow is print the address of begin and end - two local integers declared one below the other, of course they'd be placed on the stack one beside the other. What you probably meant to write is: int *begin=&amp;buffer[0]; int *end=&amp;buffer[99999]; printf("begins at: %p\n", begin); printf("ends at: %p\n", end); I'd use this syntax in case that buffer is an array. There is an alternative syntax, and I'd use this syntax when dealing with pointers: int *begin=buffer; int *end=buffer + 99999; printf("begins at: %p\n", begin); printf("ends at: %p\n", end); **However, two of these examples are identical in their meaning.**
[removed]
You don't have to (and probably shouldn't) cast the return value of malloc. 
Do you have any specific question? Also, please put four blanks in front of every line of code so the code comes out readably.
It actually doesn't affect compilation if the header is constructed correctly. For example in these headers there's a define to place the implementation (like in a .C file of your project). Otherwise only a tiny portion of the file (the header portion) is seen by the compiler upon inclusion. The point is for very easy integration, literally 2 lines of C code, and no build script modifications necessary.
Would you mean unsigned integer? This is when the data is stored in normal binary, meaning your bit range is from 000... to 111... all positive, whereas a regular integer uses 2's compliment to store data, meaning your ranged is halved, but your value can be negative. Unsigned is better for a loop range, or list indexes, and regular ints are for processes like arithmetic.
Casting the return of malloc is considered proper in C++ and [improper in C](http://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc). This is one of the relatively rare cases where C-style code is different between C and C++. Normally C++ accepts proper C code, but in this case C++ would require the cast to void. 
-&gt; /r/TrueGameDev
That's the new fad. Probably kids coming from Javascript and other current scripting languages.
Hi /u/DemiGodYasha, You need to be more specific about what you want to achieve with this program, Also, please specify if you want to focus more on file i/o or is it just a means to an end i.e storing data in a persistent way and load/parse the data later to search what you need effectively. Regarding the file I/O part, there several I/O specific function families: fopen, fclose, fread, fwrite, fseek, fprintf - These functions deal with FILE streams. open, close, read, write, lseek, dprintf, mmap, munmap, fstat - These functions deal file descriptors. You should read about lstat and stat as well. I personally feel more comfortable with fd (file descriptor) family functions, but you should know about both "families". Some additional thoughts: As far as I understand your program have one of the two designs. 1. Storing file in a file. 2. Retrieving all records to RAM. 3. Searching in RAM. Or: 1. Storing file in a file. 2. Searching in file char by char. Your design decision should effect how to implement each part. GOOD LUCK WITH THE EXERCISE
(excuse my google-translator english) it is difficult to say that there are 3000 lines, using so many libraries... I have two doubts, for which you use `regex.h` and has a battery of tests to confirm the function of your library? 
Why did you typecast your (char*)data to (int*)? Why does the data need to be typecast? What I'm asking is, why is the data array (char *)? Isn't it int *data since it's an int array?
If you really want to do something like that, use `alloca` to grab a run of stack memory and build a binary tree in place on it. You can hack the array-as-bintree algorithm (for any node at index n, its left and right children are 2n+1 and 2n+2) to be recursive on pointers within that array. But no, stack frames are *very* strictly bound in lifetime to the function call/return sequence. Lifetime on the stack is a one-way street, from caller to callee. The callee cannot have any stack allocations persist after exit, because one of the fundamental assumptions of the stack is that everything above the current frame is alive, and everything below the current frame is free.
If you're afraid that the other company will steal your code make them sign a legal document. Don't apply technical solutions to social problems. Obfuscated libraries just make it hard for someone to solve problems that you have caused and are unwilling or unable to solve. There's almost no serious reason to obfuscate code this that isn't stupid.
That was my largely uninformed feeling.
You're welcome.
Document the stuff that should be used, don't document that which shouldn't be used. Arbitrarily change undocumented things once every few updates and if they complain just say "you touched things you were supposed to touch". I would count obfuscation as a very strong signal that a certain vendor shouldn't be trusted. The deafening silence of people suggesting tools here and in the same stackoverflow question you posted should be a pretty strong signal that this might not be a good idea. There has been 45 years to develop tools that do this for C, yet nothing exists that is well supported and widely used despite this not being a very hard problem. The almost total lack of those tools on the market should tell you something. And that something isn't that you're the first one to have this idea in 45 years. It is just a bad idea.
if the "threads.h" you are talking about is the one from C11, then yes, that is a very modern method (added to the standard since 2011) -- too modern for many projects, probably. pthreads is a more traditional approach, for instance (but needs some "emulation" work on windows, I think.) OTOH I don't know for sure what "threads.h" your book is talking about, it could in principle be anything. If the book predates 2011, it may be some proprietary threads.h implementation or anything else, who knows. You can check if the threads.h the book talks about looks like this: http://en.cppreference.com/w/c/thread If yes, then what the book is describing is the modern standard approach.
Note that C11 threads are just castrated pthreads. There is no reason to use them.
If they are available on platforms where pthreads are not, then why not. Using the more standard thing is always worth it, IMO, if it satisfies your needs. I don't know how widely threads.h is implemented in reality, since I think it's not mandatory even for hosted implementations (MSVC?) All codebases I work on use pthreads or other.
the book is compiled in 2017 by Jens
Your question got caught in our spam filter. I apologize for the inconvenience.
Your question got caught in our spam filter. I apologize for the inconvenience.
then it is most certainly talking about the modern C11 approach.
&gt; printf(length); `printf()` doesn't work like this. Confer the manual for details. For your specific instance, try `printf("%d\n", length);`.
What problems do you have? I'? On mobile so can't test it.
Thanks a ton! You really saved me. I was wondering if I could have another quick question? I decided to present the negative binary number using two's suplement. And for that I need to add '1' in front of the whole binary number (meaning it will have a '1' as the first digit from the right). Could you give me any advice on how to do that please?
You're welcome.
Thanks a lot. Do you know why it would return 5 if I only input 4 characters? Plus, what would the manual be exactly?
Ah okay, so should I always be decrementing the result by 1?
&gt; Plus, what would the manual be exactly? Typically, the vendor of your C implementation provides a manual for its C standard library. On UNIX-like systems, you can type `man -s 3 function` where `function` is the function you are interested in to get information about that function. For example, typing `man -s 3 printf` gives information about the `printf` function. For an introduction to the manual, type `man -s 3 intro`.
Thanks for the insight. 0-based indexing seems like the way to go.
I was just about to say that.
If I recall correctly, OP can just program agains the BLAS interface, letting the user decide which implementation to use.
No this is bare metal. No os. Those should be the addresses for the registers for the uart device. 
Yep, OP should just be able to do just that. I guess I was thinking a bit more of when the matrix library is actually being used.
I tried one and it worked. I till can't figure what's wrong with mine. Looks like everything is equivalent. 
Glibc doesn't and iirc refuses to implement C11 threading for the reasons FUZxxl mentions. As far as I'm aware none of the BSD libcs implement threads.h either. In practice you can sort of regard C11 threading as a windows-only extension of the C language (anyone know if OSX implements threads.h?)
Function declarations are the same as prototypes. The headers in the OP actually only contain prototypes of only a few functions, and the majority of them are static/hidden in the C/implementation part, and never show up unless the user does (which needs to be done in *one* C file somewhere): #define LIB_IMPLEMENTATION #include "lib.h" Otherwise including the header only lets the compiler see a tiny portion of the header thanks to the preprocessor (include the header as normal everywhere else): #include "lib.h" Unfortunately /u/TheCloudt has no clue what he's talking about.
I don't have a theoretical issue with it, bit MS suddenly grabbing the standards committee to implement its own extensions as part of the standard (see bounds checked functions, which are literally just taken from windows) after they refused to implement even C99 is....questionable
Saying it is some "random number" isn't really the best approach, since it is very likely not random, but rather chaotic, which is a great deal less useful than a random number.
Thanks for the info; I was not aware of the BLAS interface. Definitely going to program against the interface and let the user decide which implementation to use. Don't see the point in not using it!
&gt; nobody stops you from implementing pthreads Well, first of all, you might not be able to implement $POSIX_FEATURE because it makes too many assumptions about the rest of the system that you cannot satisfy, whereas a cut-down version included in the standard may be easier or possible to implement; and secondly, sure, you can, but you could say that about anything -- then what's the point of even having a standard at all? &gt; The only thing C threads do that is different from pthreads is that they removed half the features and guarantees and changed some minor things to make it just incompatible. There are no valuable new features C11 threads provide. Removing features is kinda the point. You would not expect a version adopted by the standard to have new features, but rather, fewer (except in relatively rare cases). This is how it works all the time with e.g. OpenGL, OpenCL et al; vendors create their own, vendor-specific extensions, then other vendors may or may not implement those extensions (if they can implement the extension whole-sale, they may) or alternatively roll out their own vendor-specific extension; then the comittee eventually looks into whether everybody could in principle implement the extension (or a subset thereof) and creates an officially sanctioned extension (which is usually somewhat of a subset of the vendor-specific ones) that everyone is supposed to implement; once everyone has implemented (or at least confirmed that it is possible for them to implement), it becomes part of the core standard that everybody HAS to implement. &gt; A standard should be written such that the provided functionality is useful without depending on platform-dependent features. Agreed, but sometimes its necessary. E.g. with EGL you may create an opengl context to render into, but then you might want to do something (somewhat exotic, as you say) platform-specific in addition, like disable aero on windows to improve performance or work around issues, sticky the window to all workspaces, prevent the mouse from escaping or somesuch, and since such concepts (aero, window stickyness, existence of a mouse cursor) are platform-specific concepts that EGL and GL can make no assumption about, that work just has to be deferred. &gt; It is possible (the interface is almost exactly a subset) but somewhat annoying as some interfaces are slightly different and logic has to be added to account for these differences. Eh, I don't see that as a big deal then. Just wrap it up, you can probably make a header-only implementation, and then you're all good. &gt; Why did the C committee make a new incompatible threading API instead of standardizing a subset of pthreads? What is this threading API if not an attempt to pull away the power to define multi-threading from POSIX? I really don't know anything about the internal power games withhin the comittee, and whether this was an intentional jab towards POSIX, but I certainly see many legit reasons for doing this. First of all, naturally if you include some functionality into the standard, you want full control over it. Secondly, it's (somewhat) easy to add, but impossibly hard to take away, so I see starting with a minimal subset of functionality to "test out the waters" on who will implement that extension as justified. Especially if you want to avoid creating an interface that will only be implemented by the "big three" or "big five" (win, linux, osx, + android &amp; iOS) but could also be implemented in embedded hardware of all kinds, game consoles, you name it. Maybe some functionality like barriers are hard to implement efficiently on some platforms (absence of atomic instructions for integer manipulations, maybe?), then it'd be good to get feedback from vendors on the matter first. Lastly, there may be some advantages to having this kind of thing specified directly in the language standard -- like specifying assumptions about memory and concurrency model. This may result in better compiler optimization et al? I'm not sure. Either way, I don't see it as a big deal as long as it's possible to implement the interface on top of the existing interfaces (like pthreads), which seems to be relatively easily possible in this case. And as a user, thread.h seems to cover most of my use-cases (although I admit the absence of barriers is a bit annoying.) Or it may be as you said and just be nothing but an attempt to make POSIX less popular, but it seems to me like that opinion is a bit on the harsh side. 
&gt; *((int*)((char*)data + index * sizeof(int))) I understand the sizeof(int) acting as an address multiplier in order to move a correct number of bytes, but still don't understand why you typecast data as a char pointer as a result Doesnt no part of the original code involve a character of any sort? And why cast that resulting as an int pointer right after? Isn't the result of data+index*sizeof(int) already an int pointer? Since data is an int pointer already? Why not: *(data + index * sizeof(int))? Would that be incorrect? I'm new to this!
That was a bit of code a friend wrote. He liked it better. I don't care one way or another. Baud rate is calculated from the documentation. I don't remember the formula off hand. Should be a real baud rate 115200. Wrong comment from debugging. Should just turn on transmitter. A 3 there doesn't fix it either. 
Even armadillo (a c++ linalg library that explicitly seeks to imitate matlab-style programming for ease of porting etc) uses 0-based indexing, even though matlab uses 1-based indexing. So I suspect the answer is (at least in the context of a 0-indexed language like C or C++) "no". In a 1-indexed language like matlab or lua it isn't that crazy, I mean, matlab does work fine for what it's used for.
Pretty bad idea to do that on a volatile hardware register, it's not an atomic operation so the register value could be modified by hardware between reading it, doing the XOR and writing back to it. I doubt that's the issue though. You don't seem to be enabling the clock for the usart peripheral, which I would expect to be necessary based on my experience with other MCUs. 
I'll look into that. Thanks. 
There is if you need compatibility with Windows. Of course at low level they probably are a wrapper around pthread or the Windows API, but it's good to have a cross platform method to use threading.
Matlab can be great and do some magnificent things. But I agree the 1 based index is off putting for everyone who started with some other 0-based language.
*almost every other language 
Note that there are pthreads implementations for Windows. You can simply use one of these.
It is only compiled once. Inline rotations are... Very tiny and never modified. A good use case for inlined header implementation.
Everyone here who says you can't do that is correct. You can't do that. However, there is a thing called [Cheney on the MTA](http://home.pipeline.com/~hbaker1/CheneyMTA.html) that does exactly that. The trick is to never return from any function. 
I am saying that is done invisibly for you. The char\* cast and arithmetic is to simply and equivalent to demonstrate that. Your code sample would not yield 0xFFF8. You do not need to and should not use sizeof(). That is done _already_ and you don't need to duplicate the effort. That 2\*4 is then multiplied by sizeof(type) by the compiler. So what you actually get is 0xFFF0 + 2 \* sizeof(int)^2. Try compiling some examples and printing the results to see what I mean.
Agreed there are some other languages that have 1-indexing. ^^
I had in mind a lot of pre-fabricated test... it turns out that i also have a regexp library https://github.com/nasciiboy/RecursiveRegexpRaptor/
Oh ok I should probably restate my comment: My code is asking if this is what the computer is actually doing itself, not what someone would code. Why is it that the computer does the char * casting under the hood? I get it doing the sizeof(type) multiplication in order to move accordingly through memory, but why this? *((int*)((char*)data + index * sizeof(int))) Why does the computer does this char pointer business under the hood when accessing an array? Why not just increment the address by index*sizeof(int)? Sorry to ask a billion times, I'm just very confused by why char is being used at all when this involves pointing to integers, and why casting is used at all when addresses can simply be incremented.
Not in a mathematical or intuitive sense. 0 stands for nothing in math. So having a 0th element doesn't make much sense. When you count how many apples you have you also start with the 1st apple and not the 0th apple. The 0 indexing is just a remnant of the hardware limited old times. Just like the QUERTY keyboard layout is a remnant of strike frequency limited typewriters. In both cases it made sense once, but does not anymore. At least in most cases.
The most popular recursion example, the factorial, is trivially implemented as a for loop. However some algorithms are naturally amenable to a recursive algorithm. For example, take a look at the [flood fill algorithm](https://en.wikipedia.org/wiki/Flood_fill#The_algorithm)
Nice I'll look into your library. What kind of pre-made test would be great to implement? 
All recursive algorithms can be written iteratively, and vice versa. But not "just as easily". Some things are much better expressed iteratively; and some recursively. E.g. walking through a tree structure is very simple recursively but messier done iteratively.
You can preserve the asterisks by escaping them using backslash. I should reiterate again that the char\* cast doesn't necessarily represent what goes on "under the hood", it is just another synonymous expression. You see that, because of the type of the data pointer, there is a multiplier on the offset. The reason I used a char pointer has to do with this. An int type is wider than 1, so the implicit multiplier on the offset is greater than 1. A char type is 1 byte, so the implicit multiplier is 1, meaning I can pretend it isn't there (multiplying by 1 has no effect) and add in the multiplier myself. I could have explained the multiplier on the offset with a diagram or something, but casting char which is 1 byte wide allows me to demonstrate it in C code itself. "Casting" in C doesn't transform the data it points to, so when I cast back to int\*, the data is exactly as it was before, as if I had just done *(data + offset)
This is incorrect. We are not keeping the 0-based indexing around due to legacy code. It simply makes more sense in programming. The zero is an *offset*. Accessing `data[0]` means accessing the memory at location `data + 0`. Factor in things like modulus arithmetic (accessing 2D arrays, etc.) and the zero starts to make even more sense. Do you realize how much corrective math you'd have to do if you treated the first element as 1? (And again, I'm not referring to interfacing with legacy code.)
Ok I now see what's going on. This is an array. So because it's an array, it automatically increases memory address accordingly. Therefore, in order to even use sizeof(int), you would need to treat the array pointer like any regular address rather than the pointer to an int. In oder to do that, you cast it to a char so that it can be incremented by 1 byte like any normal memory address. Whereas if it wasn't an array declared on the stack using array notation, but simply a bunch of ints allocated in the heap using malloc (effectively an int array but not specified as such to the compiler), you wouldn't have to do this casting to a char because the address (or pointer) would be treated just as any other address, and increment by default by 1. I think I kept missing the fact that when you declare an int array, creating it on the stack, you tell the compiler that you have an array with elements of a specific type, therefore multiplying by sizeof(int) would be like telling the computer to do its job twice in accounting for type size, since it by default will increment by type size. Whereas when you allocate memory on the heap using malloc, you may be creating an int array, but the compiler isn't clued in on that, and treats any pointer incrementing like any other memory address incrementation, and defaults to 1 byte increments regardless. Is that correct? Thank you for your time by the way
I agree with your reasoning to use 0 based indexing in memory related access. However in most high level cases the actual memory location is not relevant for the algorithm. (e.g. to sort a set of elements it's irrelevant where and how they are stored) The more you go from writing "how" to "what" , the less interesting the indices are. 
thanks for the help. Finally got it working! Turns out I also got the fflush and the scanf in the wrong order too
You are not wrong. A loop and a recursion have exactly the same ability to express logic. They will however look very different, even if the end result is the same. They will thus not be read or understood similarly by the humans writing them or reading them. While recursion will sometime look much prettier, it can also hide very nasty effects. A simple example is the fibonacci sequence, where the recursive solution is among the worst one. An optimized solution will use dynamic programming and memoization, which is far easier to express in a local context than through several scoped calls. Recursion is more natural to do a depth first search on a tree. Writing it as a loop however will make explicit the stack-based nature of the DFS, which when swapped by a heap becomes a BFS. Seeing this is among those small things that makes you have a greater insight in algorithmic.
Suppose you have a tree and wish to sum all the nodes, The natural way to do this is with a recursive function In pseudo code sum_nodes(tree) = sum_nodes(left_branch) + sum_nodes(right_branch)
https://youtu.be/8X_Ot0k4XJc
Recursion is great when the algorithm requires a stack.
 int* arr = (int*)malloc(10*sizeof(int)); Why are you typecasting a malloc? Doesn't malloc just return a pointer? Check this out: http://imgur.com/a/0w7EU These are from Harvard's course on malloc and pointers, look at the malloc statement Why no pointer typecast there? 
malloc() returns a pointer of type void\*. That screenshot is valid C but not all compilers will accept the implicit type cast from void\* to int\*, or they may spit a warning. I was explicit for clarity and in case you attempted to compile it.
In principle, yes, as long as you haven't used any platform-specific features or Linux-only libraries. There's also [mingw](https://en.wikipedia.org/wiki/MinGW), which implements large parts of the Linux stuff on Windows, as long as the functionality makes sense on both OSes and there's no major performance issues. With mingw, you could even cross-compile Windows executables from Linux. 
Oh ok, so it's like the difference between i = 5 and int i =5 when you can write it either way but one way is more specific than the other I'm guessing? So long story short, you're saying that the only way to increment the address of a pointer the way you would increment any other number, is by first casting the pointer to be a pointer of a type that is a byte long, or else it will automatically increment by the size of the pointer type. So sizeof() is only every useful when you allocate memory, not when you access it? It seems in theory that sizeof() should never be used to access memory since the computer will always adjust for pointer type length In other words, you almost never have to worry about accounting for type length when accessing memory at a pointer location since the computer always reads the memory like boxes of size sizeof(type)
Yeah, agreed it can be pretty confusing in the recursive case. My point is that you need a "basis step" or some way to escape the looping in lots of patterns; it's just a lot easier to wrap your head around when it's iterative.
Well, in C you can't omit the type name, but everything else in your post looks correct.
Here's the said project : https://github.com/ilomax/matchstick-alum1 I'd like to make it work on Windows so I could make my girlfriend play it, just to show her what I do you know. I won't see her in a while, so here I am. And I know that emacs/gcc works so well for such things and is just so much easier overall, but I wanted to see if it was possible.
Here's the project : https://github.com/ilomax/matchstick-alum1 To be honest, I don't know much about platform-specific features or Linux-only libs so I'll let you judge. 
The easiest way to do this is with Mingw-w64. Typically your package manager will install the compiler as x86_64-w64-mingw32-gcc, along with the x86_64-w64-mingw32- prefix for the rest of the toolchain. If you're not using any POSIX features, building is as simple as replacing gcc with x86_64-w64-mingw32-gcc ("make COMP=w64-mingw32-gcc" in your case). You've got a few problems. First, `unistd.h` is not part of ISO standard C. Fortunately it looks like you're mostly using it to define NULL. Just remove it or replace it with stddef.h. Second, `get_next_line()` uses `read()` and a file descriptor. This is POSIX, not C, so you can't use it on Windows. It's easy to replace with the stdio.h versions: `FILE *` and `fread()`, so this shouldn't be an issue. Third, you've got Linux binaries checked into your repository. This is generally bad practice. Worse, it definitely prevents you from building for Windows. You'll need to either get Windows builds for these or compile them with Mingw-w64 just like your program. Since these binaries require `read()`, `write()`, and `open()` it looks like it would take a small effort to port this code, too. The Linux man pages are very informative about where functions come from. Just check the "CONFORMING TO" section. For example, "man 2 write" says this: CONFORMING TO SVr4, 4.3BSD, POSIX.1-2001. This basically means you can only use it on any unix-like system. In contrast, "man 3 fwrite" says this: CONFORMING TO C89, POSIX.1-2001. Since it says C89 you can use it anywhere. Finally, have a look at "man 3 memmem": CONFORMING TO This function is a GNU extension. This essentially means it's Linux only. 
This interests me. Where did you get an existing code-base?
Have you tried any of the following? - mingw - cygwin - bash on Windows Mingw is like a Windows port of GCC while cygwin is more of a complete Linux environment you can run in Windows . I have had good experiences with cygwin and mingw, haven't used bash on Windows that much yet 
while(1) is an [infinite loop](https://en.wikipedia.org/wiki/Infinite_Loop_(street)), not an infinite regress. ;) 
That doesn't really matter if the algorithm still requires a stack, like DFS. In that case recursion just takes advantage of the processor's stack instead of having to use a software implementation.
No it actually matters. I had to implement 4x4 matrix functions in Lua to test my c99 implementation. On C I can do "for(i=0;i&lt;16;i++)" and i%4 gives me row number and i/4 gives column number. In Lua, it's (i-1%4) +1 for row number and ((i-1)/4) +1) for column number. Any operation like this will cause fuckery if you uae to a one based offset for anything multi dimensional or semi-complicated.
With Visual Studio, you can't use the Makefile, so you need to recreate that as a Visual Studio project. Create a new empty project to build a .exe, and add all the *.c sources to it. The problem will be library dependencies: The code you linked to includes unistd.h a lot, which is a non-standard header. There are also two binary libraries in lib/my, of which only libmypf.a seems to be used - you won't be able to link to this, and need to find the source code, if you can find it. The include/mypf.h header looks like it just implements a couple of string functions? You may need to take an educated guess at what each one is doing and reimplement it. Or ask the original author?
For production code, there are very good reasons not to use recursion - the cost of a function call, limited stack size, etc. But you can always start out with the recursive function, write unit tests around it, and then replace the recursion with your fast production code with test coverage already in place. Also, in cases like the one above, where the recursion happens at the very end of the functions, many languages (e.g. Scheme, Lua) have optimizations in place for [tail recursion](https://en.wikipedia.org/wiki/Tail_call).
&gt; The title has up to 60 characters fread(&amp;book[i].title, max_title, 1, fp); this reads exactly 60 characters. No more. No less. And your output Title: book1 John TJK 89.00 especially the 89.00 bit suggests that this is a text file, not a binary file.
kyofo says the output is similar to Title: book1 John TJK 89.00 Author: John TJK 89.00 Publisher: TJK 89.00 Price: 89.00 I don't know how similar to this it is. But the presence of the "89.00" in the text fields strongly suggests that this text is in the file. You're right that that doesn't jive with with output from the last printf With the real input and real output we'd know for sure.
&gt;&gt; The title has up to 60 characters &gt; &gt; fread(&amp;book[i].title, max_title, 1, fp); &gt; &gt; &gt; this reads exactly 60 characters. No more. No less. It's file with fixed width fields. Note that in the dumped data the strings are padded with null bytes. You need a smarter file reading system to read variable length strings. 
http://stackoverflow.com/questions/478898/how-to-execute-a-command-and-get-output-of-command-within-c-using-posix Like others have said, the easier way is to use a bash script or another scripting language.
Why do you make [another post](https://www.reddit.com/r/C_Programming/comments/5viyh0/running_c_on_rpi/) about basically the same question? That said, you can execute commands with the `system()` function. Read the manual of your vendor for details (on Linux, type `man system`). Something like this should work: char cmdbuf[4096]; sprintf(cmdbuf, "cc -O2 -o %s %s", binaryname, sourcename); system(cmdbuf); sprintf(cmdbuf, "./%s", binaryname); system(cmdbuf); Now add some error checking and code to find `binaryname` from the name of your source file and you're good to go.
No problem! Welcome to the ~~terrifying~~ wonderful world of C!
That's not comforting. I wasn't stressing over compilation complexity. I'd much rather have this: index = y * width + x I don't wanna have to do this: index = (y - 1) * width + x Also, what about recurring events? data[n % 3] // cycle over three elements Now I have adjust it? data[n % 3 + 1] Yeah, you have fun with your base-index-1 languages. I don't really care what the reasons _used_ to be for 0-base. I've worked with both and found 0-base to be infinitely superior. Using a 1-base for "mathematicians" or comforting humans as they transition to programming are super weak arguments.
Make and CMake. Most IDEs have a one click compile and run function.
And this is why "high level" is silly: it rapidly decomposes. You spend so much energy learning "abstractions" that you may as well learn how the computer likes to think and work that way.
Use an interpreter such as cint or picoc.
Learn GNU make, it's a great tool that will save you many keystrokes in the future. $ cat Makefile CFLAGS = -Wall -Wextra run: main ./main main: main.c $(CC) $(CFLAGS) -o $@ $^ $ make run gcc -Wall -Wextra main.c -o main ./main Hello, World! You can mount and access files on your Raspberry Pi as if it was a local drive using Samba (if you're on Windows) or SSHFS (if you use Linux).
C is a poor choice for this, but not because it's a compiled language. Maybe there's a program that is only intended to ever be run once, and is distributed in source form. Then, a simple way to compile and run it in one step might be useful. The real issue is that there is no portable C way to "run C compiler on file", because the name and location of the C compile vary between operating systems, and even between computers with the same OS. You'd resort to using OS-specific commands with the system() call anyway, so you might as well just do a shell script. All the C program would really be is essentially something that generates and executes a shell script at runtime anyway.
For really trivial programs like they seem to be talking about, Make is probably overkill. They could just as easily write a shell script containing something like #/bin/sh gcc -Wall -Wextra -o program $1 ./program That's 3 lines rather than 5, and doesn't require them to use a separate language, as it's basically the same syntax they use already for running the program from the command line.
Good write up
Fabrice Bellard's [Tiny C Compiler](http://www.bellard.org/tcc/) can do this out of the box. You just do `tcc -run myprogram.c`. No makefiles or extra shell scripts required. It's fast enough that they even have a related project that can [compile and then boot](http://bellard.org/tcc/tccboot.html) the Linux kernel from source.
Aka selling the same key that has unlimited use after purchasing your own. This should be removed.
Please don't spam.
[Really?](http://sc.tamu.edu/help/other/CshProgrammingConsideredHarmful.html)
make clean; make; ./program_name
Be careful with this kind of binary IO. A file written on one platform may not be readable on another and vice versa. Even using a different compilers or just compiler flags can screw things up. Compilers will usually do some padding to allow more efficient memory access. google a bit for ‘structure padding’ or ‘structure packing’. 
alias openC nano in .bashrc file
I worked with a man who wrote his CGI in C. I wonder how many well used C libraries there are to do this.
CGIs in C were common in the early days of the web. 
You need to have mDNS support to resolve `.local` domain names. On Linux, try to install avahi. On OS X, .local domain names should work just fine. Please always use the POSIX functions (`gethostbyname`, etc.) for resolving domain names as only these functions are guaranteed to interface correctly with all other subsystems.
I tried to install this once, a couple of months ago (it's posted on different subreddits every 4 months or so), it just didn't work. And frankly I don't see the point of writing my whole web application in C. If I really need something fast I'll use Go which has most of these things build into the standard lib. Maybe I'll take a look at it again and try to get it working under Nginx.
He said he wants us to "echo program output into a text file"
he wants us to echo program output into a text file, it cant be as simple as copy and paste can it? 
That's different than saving your code... Which should already be in a text file anyways. Output redirection in your shell is what you need. % ./a.out &gt; output.txt or the like. 
Once you're comfortable with memory management in C, you quickly start realizing that most frameworks are just giant nested layers of garbage.
If I get it to work I'll add a pull request to the wiki with a nginx setup description.
You can actually also use the stream operator "&gt;&gt;" which separates on white spaces. Then you don't have to do the looping over the string yourself.
You sure you are programming in C, not C++? Because `iostream`, `fstream`, and `cstring` are C++ types as far as I know. Note that C++ is off topic in this subreddit, ask in /r/cpp_questions instead.
Use `fgets()` or `getline()` to read one line of input, than scan three numbers from it using `sscanf()`. Check the return value of `sscanf()` to see how many numbers you parsed.
why defining **int a[0]** is valid?
Why not use `fscanf()`? Seems ideal for this.
That's possible, but since %d skips whitespace including newlines, checking that all numbers are on a line isn't possible.
Ahh, TIL.
I'm a little confused by what you mean... But if you're looking for code examples try rosettacode.org. Other than that there is a YouTuber named Derek Banas that has a halfway decent C language video tutorial.
C is no better or worse than other languages in terms of developing your skills at problem solving. It's a language agnostic issue. Some of the best advice I received early in my career was this: Write the problem and the solution on paper before you type a single line of code. Be detailed! It takes practice but it forces you to spend more brain power on solving the problem and not on translating a solution into code. Regarding your second question: I don't have any personal experience with sites that providing programming challenges. Life alone has provided me with so many programming challenges, I can't keep up. :)
I tried to get it to work on Nginx, but I couldn't figure out how you fastcgi implementation works. Nginx requires a unix socket (file) or a tcp socket for cgi/fastcgi communication with the back-end. Your documentation or code never mention a unix socket or tcp port for the fastcgi server. Any idea how I could get this to work on Nginx?
Zero length arrays are a GCC extension, yes. https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html Edit: From Section 6.7.6.2, paragraph 1 of the C11 draft: &gt; In addition to optional type qualifiers and the keyword static, the [ and ] may delimit an expression or *. If they delimit an expression (which specifies the size of an array), the expression shall have an integer type. If the expression is a constant expression, it shall have a value greater than zero. 
gcc works
Since op wrote, iostream is ok, cpp is usable, including streams
There's a lot of GCC extensions that -std=cXX doesn't disable.
See my other comment with links to documentation and citing from the standard.
C dialects infuriate me to no end. I do get to use C99 though so I guess I can just yank the 0 and make it `uint8_t msg[];` The [GCC page on ZLAs](https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html) is interesting; apparently `sizeof` on flexible members is inapplicable per standard, but GCC sets it to 0 as a "quirk of the original implementation" so that total sizeof can still be used. Which is good, because we use sizeof(Type) instead of magic numbers to handle transmutation between raw bytes and back. I don't know how to write out me bellowing "CEEEEE" like Kirk yelling "Khaaaaaan", but, pretend I'm doing that.
For a quick and dirty solution, simply reduce the result of `rand()` modulo `100`: number = rand() % 100; Note that this leads to a slightly skewed probability distribution, but usually that doesn't matter.
Yep, it's pretty easy. How far have you made it yourself?
You pick an appropriately sized range that is a multiple of your module. If the result of `rand()` is outside this range, you discard it: do number = rand(); while (number &gt; LIMIT); number %= MODULE; You can compute `LIMIT` like this: #define LIMIT ((RAND_MAX - MODULE + 1) / MODULE * MODULE - 1 + MODULE) This weird dance with subtracting `MODULE - 1` is to make sure that no integer overflow occurs during the computating of this limit.
Would you mind talking about how that's the case and why you do it?
Hmm good call. I'll give that a look. --- `warning: ISO C fobids zero-size array 'msg'` Okay. `warning: type of bit-field 'addr' is a GCC extension'` NOT GOOD `warning: ISO C forbids passing argument 3 of 'register_funcs' between function pointer and 'void*'` \*turns off `-pedantic`\* I could probably rewrite `register_funcs` to not warn, but we kind of need bitfields. That `addr` bitfield is 20 bits wide and *must* be in a 24-bit value. I don't think it's possible to get `-pedantic` to shut up by using a 32-bit int while also maintaining compliance with the bit representation the protocol requires there. ---- That was very educational, though. I completely forgot about pedantism, thanks!
Why C array syntax is the way it is? An array isn't a value in C, it's a pointer to some run of memory. To access the nth value stored in an array, you take the address of the 0th element and add n to it. C pointer math implicitly multiplies by the width of the stored type, which I hate but whatever. So for any type `T`, a C array `T array[n]` is `sizeof(T) * n` bytes wide, and the symbol `array` is the address of the beginning of some run of static memory. So to get the ith element in `array`, where i ranges from 0 up to but not including n, you take the address of the array base and add i, then dereference. As pointers, `array + i` really means `array + (i * sizeof(T))` in bytes, which as I mentioned, I think is bullshit, but whatever. Since the `*(base + offset)` method of reaching an element in a series is so common but also easy to muck up, C supports `base[offset]` as syntax sugar for calculating the true address of the item you want, then dereferencing it. Because addition is transitive, though, `offset[base]` will *also* work. Make a static array `int a[8] = { 0, 1, 2, 3, 4, 5, 6, 7, };` and then access `4[a]`. It's valid, and will be 4. Why do I use a structure type that has a zero-sized tail member? Because I didn't know C supported flexible members as early as C99, or I'd have used `msg[]` instead of `msg[0]`, and because the memory to which all instances of `struct Pkt` with which I work are known to have a size somewhere in 2 up *through* 1024. So `struct Pkt` actually is: 6 bits identifier, 10 bits length, and `length` bytes payload. We know in our environment that `length` will always have a value from 0 up *through* 1022. It will never be 1023, and 1024 is 0 when you only have ten bits. We do this because `struct Pkt` is representing a message of variable size coming out of a network interface, and since we're operating on a tight memory budget, we're not going to allocate a full kibibyte for messages that don't need it. We receive from the network interface into a static kibibyte buffer, figure out how long the message is, and then since the first two bytes of the network message are garbage, we can overwrite them with the sixteen bit `struct Pkt` header and voila, a custom-sized struct that supports "intuitive" access to its payload. `for (uint16_t idx = 0; idx &lt; pkt.len; ++idx) { do_something(pkt.msg[idx]); }` will actually come out to be: for (uint16_t idx = 0; idx &lt; pkt.len; ++idx { do_something(*(pkt.msg + idx)); } where `pkt.msg` is, because arrays are weird, the address of the zero-sized array at the end of a `struct Pkt`, so it's actually `&amp;pkt + 2`. TL;DR it allows for us to pretend byte arrays are actually values of specific types, when those values aren't of compile-time-constant size. It makes working with them a bit fucky -- they can only live in large, custom-built buffers or on the heap (which is just a very large, very custom buffer, really) -- or in 1024-byte stack buffers we're pretending aren't necessarily that wide, but it's worthwhile.
www.hackerrank.com
Not true. Restarting the computer doesn't affect this, however you can use `srand()` to reseed the random number generator. The typical idiom to get “truly” random numbers is this: srand(time(NULL));
Yeah, forgot to add that the restarting thing was just a guess... Anyway, yes srand() is the [standart] way to go
Cool thanks for this
Include files only needed by the implementation in the implementation. As a rules of thumb, header files should not include header files except when they absolutely have to.
Yes. 
+1 Maybe worth to mention, that it also helps not to end up with nasty circular referencing headers. 
This isn't necessarily related, but I'm not sure where else to ask this. About a year ago, I came across a website that showed flawed of bad C code, what the underlying bug/improvement was, and what the correct implementation was. I think it was either a site of some certification authority, or a static analyzer, or just some general code guidelines, but I can't find it anymore. I've literally spent hours looking for it in the past few days, but coming up empty. If it helps, the wrong examples were in red and the correct ones were in green, and there was quite a lot of them. --- **edit:** And after 4 minutes of posting, I found it https://www.securecoding.cert.org/confluence/display/c/SEI+CERT+C+Coding+Standard
The [sizeof](https://msdn.microsoft.com/en-us/library/0w557fh7.aspx) operator is probably what you want. It gives you the number of bytes needed to store a given thing, so you'd need to multiply the result by 8 to get the number of bits.
A `char` typically has 8 bit on all bit the weirdest systems. The macro `CHAR_BIT` from `limits.h` expands to the number of bits in a `char`. An `int` has at least 16 bit, you can find out how many bits it has by checking `INT_MAX` (expands to the highest `int`) and by multiplying `sizeof (int)` (number of bytes in an `int`) with `CHAR_BIT` (number of bits in a `char` resp. byte). Here is an example program: #include &lt;stdio.h&gt; #include &lt;limits.h&gt; int main() { printf("%d bits in a byte\n", CHAR_BIT); printf("range of int: %d--%d\n", INT_MIN, INT_MAX); printf("%zu bits in an int\n", sizeof (int) * CHAR_BIT); return (0); }
When I left it as 'zu' it simply output: "zu bits in an integer" but when I replaced 'zu' with 'd' it output: "32 bits in an int" (Code::Blocks on Windows 10, 64 bit)
A [Cray-1](https://en.wikipedia.org/wiki/Cray-1) had 64 bits in a char. Cray-1 was manufactured from 1972 through the late 1980s. The Cray C compiler didn't come along until the mid 1980s. I don't remember whether the Cray-2 had the same char size. A [Prime](https://en.wikipedia.org/wiki/Prime_Computer) minicomputer had four (I think) ABIs. In some ABIs, a char had 8 bits. In others, it had 16. Primes were manufactured in the 1970s and 1980s. [PDP-10s](https://en.wikipedia.org/wiki/PDP-10) and [DECSYSTEM-20s](https://en.wikipedia.org/wiki/DECSYSTEM-20) had 36 bit words, and bytes could be 5, 6 or 9 bits. I don't know whether anyone ever wrote a C compiler for them. The DEC mainframes were also 1970s and 1980s machines. You can design your own CPU architecture and implement it on an FPGA. You can give it any byte size you want. But yeah, 8 is nearly universal.
Do you just write a function that reverses a string?
Could you please elaborate? As I understand it, sizeof(type) delivers the amount of bytes 'type' uses. And a byte is universally 8 bit large. Edit: I looked it up - a byte isn't necessarily 8 bit large.
Agreed. In a lot of ways you can think of the .c and .h files in the same way - `#include` things which actually get used directly in the file, and conversely if it's not getting used directly in there no need to include it. So if `foo.c` uses `time.h` `#include` it in `foo.c` - and if `foo.h` doesn't use anything from `time.h`, don't include it in there. I'd go a little farther though - if both `foo.c` and `foo.h` directly use functions from `time.h`, then just `#include` it in both files. If the headers are correctly using include-guards then multiple include's won't be an issue, and that way if things get changed in the future you're still including the right files in the right locations. There are times when that rule can be broken, but like you said I'd say it's definitely a good rule of thumb to go by.
&gt; But if you use int instead of size_t or even int32_t it is not considered bad practice. It is only bad if the usage of types is not consistent. That depends who you ask. ;) Using int32_t instead of size_t is not acceptable, as there's no rationale to do it *and* it may introduce sign-conversion errors. Same goes for int. Remember that size_t is guaranteed to be large enough to hold the size of the largest possible object an implementation supports. That guarantee does not apply to neither int32_t nor int. 
&gt; On the other hand, C++11 has built in threads So does C11. 
The size of char is always 8 bits or 1 byte. You can determine the size of any data type using sizeof() function. But there is a variation in Integer data type.
There are lots of uses of C language. Here are some of them: 1. C is used to code Operating Systems. 2. C is also used in database engines development. 3. Device driver development. 4. In embedded systems. 5. In game development. 
"In a segmented architecture computer, a far pointer is a pointer which includes a segment selector, making it possible to point to addresses outside of the default segment." So you should learn what segments are. Windows at least has a flat architecture, so the segment selectors arent really used, except for special cases.
Far pointers are a Microsoft thing, not a C language thing.
Modern architectures typically have a flat address space, meaning there are no segments and special bank selectors and whatnot. The pdp11, and pdp8 before it were designed in a time when core memory was all there was, and they evolved quickly as semiconductor memories became feasible. This generally ran up against architectural limits, like the size of address used in machine instructions. When they reached the hard limit, they had to invent a way to switch out the whole address space to another set of memory, which was typically referred to as bank selection. On the pdp11, the bank selectors were another 6 bits, which gave you 22 total bits of addresses (4MB). On the 8086 there was 4 extra bits, getting you 20 bits (1MB) of address space. The 286 introduced the MMU (protected mode), but not flat address space. IIRC, it did increase the addressing to 24 bits as well, giving you 16MB total address space. By the time the 386 came out the x86 finally got flat 32 bit addresses and protected mode (4GB addressable). 
I started composing my reply before this was posted. I would have skipped the whole thing if I had seen your post before hand. One thing though, I'm pretty sure the 286 couldn't address 512MB of RAM. I was struggling to remember if it had 22 bit or 24 bit extended addresses, but I'm pretty sure it was 22 bits. Edit: according to Wikipedia protected mode on 286 was 24 bits.
The 80286 indeed can adress up to 16 MB in physical RAM, but it's programming model allows for a 512 MB virtual address space (8192 segment selectors @ 64 kB).
Just some trivia. I once worked with an old K&amp;R C compiler that allowed `-}` in addition to `-&gt;` for referencing structure members off the extra segment. You could allocate additional chunks of memory outside your program's data segment, make a set_es() call and use `struct-}member` to access it. Was able to make some very large (at the time) in memory data stores (avl trees) in fairly vanilla C using this technique. 
Do you recall the name of this compiler? I'm asking for a personal project.
It was the compiler that came bundled with the original release of QNX in the early 80s. My guess is Quantum may have made the mod themselves but not sure. Bell and Dodge were OS wonks and I could see them doing this. 
There is a /r/cjobs subreddit but nobody uses it.
just make sure the increment spotInBuffer in your while loop, or it'll just loop endlessly (since it's always &lt; holder)
QNX! Interesting!
&gt; Where did you get 512MB from? You have 8191 possible segment selectors as two bits of the segment selector (the value in cs, ds, ss, es, fs, gs) are used to indicate the privilege level and another bit is used for something I forgot. Each segment selector points to a segment of up to 65536 bytes, for a total of 512 MB virtual address space. Yes, you can't have that entire space mapped at once but that doesn't really matter as the operating system can remap GDT entries on-the-fly.
Yes you have 8191 possible segment selectors. But to get to 512MB they must overlap as there is only a limited physical address space. There is no virtual addressing on a 286. The 286 doesn't support paging. &gt;Yes, you can't have that entire space mapped at once but that doesn't really matter as the operating system can remap GDT entries on-the-fly. The 286 didn't support pre-emptive multitasking.
&gt; The 286 didn't support pre-emptive multitasking. On its own it doesn't, but you typically have additional hardware for that: interrupt handlers can be executed in ring 0 (kernel mode) and *preempt* the currently running process. By programming the PIT with an appropriate frequency, you can easily implement pre-emptive multitasking (as e.g. XENIX did) as the PIT generates interrupts in programmable frequency. &gt; There is no virtual addressing on a 286. The 286 doesn't support paging. You don't need paging to have a virtual address space. The virtual address space is what the process can access and spans 8192 segments @ 65536 bytes, so 512 MiB. That's how much data you can put into the virtual address space of a process on the 80286. Of course, not the entire virtual address space can be mapped into physical RAM at the same time (unless you have overlaps) but you can easily fake this by trapping the exception you get when a non-existing segment descriptor is loaded (just like how a page-fault handler works).
Okay. I concede that an operating system that trapped all 8191 segment selectors and provided the necessary memory swapping operations. It is feasible as a concept on the 286, That an O/S could manage 512MB. But I'm really not happy about it. :) and it would require external hardware outside the scope of a normal 286 based system.
&gt; But I'm really not happy about it. :) and it would require external hardware outside the scope of a normal 286 based system. No, not really. What extra hardware is needed that an 80286-based PC-compatible doesn't have? Note that “trapping” is something the CPU does for you. If a segment selector is marked “not present” in the GDT or LDT and a process tries to load it, an exception occurs to which the OS can provide an exception handler. This mechanism can be used to transparently swap segments.
I would need to see that, I don't buy it. There's no way an IBM PC AT could address a distinct 512MB of memory. OK, maybe, but show me the code. 
What code? Do you want me to show you an implementation of a memory manager with swap?
Well yes. But the 80286 doesn't directly support it. How much address space can a Turing complete processor handle? Well, as much as it want's I suppose. I don't think it's fair to say that a 286 addresses 512MB. With external hardware it can page as much as it likes using any mechanism it likes. The 286 is a 16 bit processor with a 24 bit address bus. It addresses a 16MB address range. the 386 is different though. It has an internal paging / mapping system so that a virtual 4GB address range is mapped internally inside the CPU to the physical address asserted on the external bus. That's a feature that the CPU directly supports.
When you pass a pointer to a function that might have to reallocate memory, it needs to be a pointer to a pointer.
When you have a function where the return value is already occupied for error status, now you would like to retrieve certain parameters or arguments from function, in C++ you can do either pass by address or pass by reference. Now if you are expecting your function to return an interface, where you can't create object on stack, so you would definitely need a pointer to interface in such case function would accept a pointer to pointer { ErrorCode ec = e_fail; ICat* pCat = NULL; ec=GetCATObject(&amp;pCat); if(e_ok) pCat-&gt;purr(); } //Function Definition ErrorCode GetCATObject(ICat** pCat){ return e_ok; } 
Great idea. Would love to see this happen
How does this look? http://pastebin.com/WsZmZyJA Output: A B C D E F G H I J K L M N O
Well, I mean i want to the output look like question F and G. It shape like stair
Are you in a hurry? Cause I need 15 minutes to get to my laptop and will solve the whole thing as I had a few similar problems to solve during my studies so the solution will probably be there in less than an hour
here I did it. http://pastebin.com/9v7BFcFt you have to input the letters on your own (sorry couldn't fix it) but it works perfect the the output I got is int the end in a comment. //and did it in an hour
Actually, even gcc is able to optimize tail recursion in a case like this. It'll even extract the implicit accumulator for you (what the semantics of scheme doesn't require). But since it's not guaranteed to work in every implementation, it's sadly not a good idea in C in general.
[removed]
It is a very typical practice for indices
That's why I started the discussion. I'm personally skeptical whether anyone will post on a "Who's hiring" thread.
a few general things I noticed which may help: make sure to declare your prototypes (they don't actually need names, just types) void displayBuffer(char [], int ); void readInput(); main: the "?" switch statement is probably unnecessary, the compiler usually handles these cases. You may eventually want to write a simple printUsage function (if you have the time), to display the various options and what they do, and call that from the 'default' switch. I'm pretty sure gValue/sValue/lValue/wValue should be ints, not char*. The program will read the characters of 1, 2, 4, etc, not the integer value. This is a point of confusion for people at first. A string of numbers is not the same as the integer value of those numbers. You will need to convert the optarg to int using strtol, something like "gValue = strtol(optarg, NULL, 0);" (notice how the instructions mentioned strtol? it's probably because of this) readInput: while loop depends on c, yet it's not used or defined there (only in main). Your approach here is very good though, but in "while(spotInBuffer &lt; holder)" you could try "c=getchar()", and then add in an extra conditional "if (c==EOF) break;" before you fill the buffer "buffer[spotInBuffer] = c;"
Done. 
Oh man, thank you very much! You help me a lot!
 - any text editor? - yes, a lot
Alright, so I'm going to assume you know how to make an application on the command line. Once you're ready to start making GUI applications, you first have to pick a graphics library. These are things like cocoa on macOS, GTK or QT on Linux, and whatever windows uses I'm not sure. These are libraries with huge amounts of functionality, they take a lot of what you want to do and make it so you don't have to invent a combustion engine every time you want to drive a car. You're also probably going to want a build system, learning makefiles will be helpful here. As well, some common tools such as qtcreator or xcode or another IDE designed for the purpose of creating gui applications. And just in case I misunderstood you, there is no drag and drop graphical interface to creating software. Everything you want to do is going to be a typed line of code. 
Ideally there would be a nice write-up about 286 and these details along with the architectural examples, or even better a case study on a real implementation of such a thing. But I'm not holding my breath. 
I think at this point we are arguing about semantics and I have no way to convince you. Note that even on an 80386, unless you have that much RAM you can't have the whole 4GB address space mapped at the same time, which is exactly the same restriction that also applies to the 80286. 
No blog spam please.
No, i just assumed the title was the question. There are numerous responses at stackoverflow... are they all wrong?
Before you try programming GUI applications in C, you'll first have to know how to program command-line applications in C. Judging from the way you stated your question, I suppose you haven't achieved the latter yet. I recommend reading the classic "The C Programming Language" book by Kernighan &amp; Ritchie to learn C. Once you finished reading that (and did exercises), you can progress from there by practicing, googling and reading more books. Note though that there are easier languages for complete beginners though. You have to do a lot of stuff in C yourself that other languages do for you and except for writing low-level software or extremely portable software this is often a bad trade-off and some C++ folks doubt C is still a good choice for even low-level software since it's so easy to have bugs like buffer overflow vulnerabilities in your code. Python, Java, C#, JavaScript or something like that might be better for now (pick the one you find the most interesting).
Oh, I apologize. I guess I coded up the wrong exercise. I thought you wanted the 3x5 matrix of letters. 
That depends on what operating system and hardware you want to program for.
To develop native Windows applications, use Microsoft Visual Studio. Keep in mind that their standard library is a bit outdated. You can also use something like Pelles C. Note that I have tried neither of these.
#include "stdlib.h" #include "time.h" //library for your seed void main(){ srand(time(NULL)); //create seed int x = rand()%100 + 1; //random number from 1 to 100 }
&gt; minimal resources Definitely not Visual Studio, then.
In the Microsoft programming culture it's typical to use Microsoft's tools, specifically Visual C/C++. The latest versions support most of C99, but until a couple of years ago were confined to C89. There's nothing wrong with that, as very few C programmers target other versions, but it's worth mentioning. Apparently the command-line compiler is available for free, but the license terms for the popular Visual Studio IDE are different. Other toolchains would be GCC or Clang/LLVM for Windows. I believe a popular distribution of the former is [MSYS2, with mingw-w64 compiler](http://www.msys2.org/). macOS Xcode uses Clang/LLVM and that compiler works on Windows, too. Straight C on Windows would probably use the least resources of any language with Win32 bindings. For straight C on Win32, [Petzold's Fifth Edition from 1998 is still in print](http://www.charlespetzold.com/pw5/) and likely to be the best reference on the subject. I've been hoping to stumble on a dusty old copy somewhere, to have on hand if I might need to work on Win32. 
prototypes, which are declarations (and not definitions) are just there to tell the compiler there is a function somewhere with a certain name that takes a few variables. You could have a program without them, but you would have to define a function before it's used. With prototypes, you can put your function definitions in any order. I had the same ffffff problem you mentioned, but only in some cases. I'm not sure why exactly. Using a field width didn't seem to help either, %2x still showed a bunch of f's. I remedied it like this: printf("%x ", charArray[tally] &amp; 0xff); It uses a bitwise AND with a mask (0xff), basically copying only those last bits you want (if they're both set, 1 &amp; 1 = 1, 1 &amp; 0 = 0). In a usage case like this it's a little weird. I feel uneasy doing it if I don't know why it's necessary, but at least it works. Also, you could format printf use things like %02x (00-ff), %03o (000-777), %03d (000-255). What I had trouble with when writing this had to do with the s/l/w options. I made a few counts, like sCount/lCount,wCount, and used them to keep track of things. The total and skipped byte's count increment before the while's printf, tests the count for a condition, and then takes the appropriate action, the line's byte's count increments after the printf and then prints new line and resets the line count. It got to the point where it was easier to change it to a "for" loop and just have a few conditionals for the printf, since that was the only part that was different. Both ways work though. Often when I'm writing code I'll start out primitive, and then once it works you can tweak it later and make it better.
Learn C first. Anyone who plans on doing any serious programming would never regret learning C. C++ is basically C with a lot more features, except this changed bit by bit over the years so that C++ is *also* a separate language. The bottom line is that 99% of the time you can program C syntax within C++ and it will work perfectly, but some C++ users will insist that you do everything the new ways and not like C. It's all quite complicated. Regardless, you basically need to know C in order to know C++ so there's no downside of knowing C. C++ has more abstraction features than C and will inevitably compile to more Assembly instructions, and usually consumes more RAM but doesn't necessarily run any slower than C. Also, I'm not a fan of C++. [As ESR says, "*There is more vocal criticism of OO in the Unix world than orthodoxy permits elsewhere.*"](http://www.catb.org/esr/writings/taoup/html/unix_and_oo.html) C# is Microsoft's competitor to Java. Both C# and Java descended from C and C++, but besides being object-oriented they are designed to fix "flaws" in C++, most specifically those related to safety and memory handling. Therefore you can't allocate your own memory or manipulate pointers. This allows the languages to do their own Garbage Collection, which has some pretty profound real-time performance implications. Both C# and Java run in language virtual machines, the CLR and JVM respectively. C# is theoretically a portable language with a Unix implementation called Mono, but in practice C# is Microsoft's creature and only popular among Microsoft-centric development cultures. 
If you're just testing out your code, I'd use strcmp (uses string.h header)
Windows has its own windows graphics library, complete with full documentation on their website. MinGW comes with it by default. However, it radically changes the way you would program C. There are alternatives such as SDL2 for windows, though.
the compiler is giving me an error that skippingChars isn't declared. IMO, you want to basically read the input the same way for all cases, and worry about certain options when it's actually being displayed. What I did for skipping characters is use a count that keeps track of how many bytes have been read so far, and don't display it until that many bytes have been read. As far as the logic, here's what I came up with on my own, maybe it can give you some ideas for your own code: [link](http://pastebin.com/khb26sBA) edit: the comments for lCount and wCount should be reversed
If you need to modify that pointer. The following example of opaque structure allocation is super contrived, but conveys the general idea: int allocate_something(struct something **something) { // pre-checks *something = malloc(sizeof(*something)); // post-checks, initialization } int ret; structure something *s; if ((ret = allocate_something(&amp;s)) != 0) { fprintf(stderr, "failed to alloc something, ret=%d", ret); }
 printf("%lu\n", sizeof(char) * 8);
 $ cat tmp.c #include &lt;stdio.h&gt; int main(void) { printf("program output\n"); return 0; } $ gcc tmp.c -o tmp $ ./tmp &gt; output.txt $ cat output.txt program output 
that's very good! that's how we all learn. Just try and work through the logic, break it down, search for the flaws. Work through it methodically. You're doing a good job.
Well this is depressing...
Garmin is always hiring C devs if anyone is looking for embedded work. 
Also If I had the same name variable in an outer scope this would not interfere with the value of that variable - right? i = 5; for (int i=0; i&lt;5; i++) {printf("%d ",i);} /* i still == 5 here */ 
Yes. But why would anyone code like that?
&gt;redditor since 02/27/2017 (an hour) Nothing yells edgy like making a throwaway just for your edgy 'jokes'.
[Tutorialspoint](https://www.tutorialspoint.com/cprogramming/) has some great examples for the standard library.
As in why would one print the numbers 1 to 5 while keeping a variable equal to 5? - it's just an example to clarify my question.. Why use i as an index and worry about i outside the loop? could happen probably would use a more descriptive variable name outside the loop though.
Look through the archives of this subreddit. This question has been asked a gazillion times.
Just discovered this one: http://zinjai.sourceforge.net/index_en.php?page=portada_en.php 
Hardware influences what IDE/compiler one uses?
Yes. Some compilers are only available for certain architectures and software recommendations vary depending on how beefy your system is.