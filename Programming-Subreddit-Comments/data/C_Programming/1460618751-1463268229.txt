&gt; There is no C culture. There is a type of programmer that C appeals to more though. I imagine if you ran a survey of various subreddits, you'd have more people here using gentoo/slackware/whatever other "hardcore" distro there is, and being elitist about their language being better than any other.
I don't know what you mean with c++ addresses. C has pointers which are addresses in memory. But in C you have to do everything on your own. For example in Java an array has a property length. So with the array the length of it is stored. In C you don't have the length of the array stored with an array. You either have to store it somewhere else, or put some termination element. This may result in things like that you forget to specify the array boundary and you end up printing the entire memory to the network. You can do everything in C. The only limitation C has is the machine. But it is not the only way. And yes there are people who think C is the only way.
Sorry I wasn't clear. Does C++ address the issues C has with being so free that there is a large field for mistakes. I've never looked at c++ as I'm still working through C so my only understanding is that it is a superset of C. 
Your post got caught in our spam filter. I apologize for the inconvenience.
&gt; the C culture is to avoid OOP constructs Have you told that to the Linux people? Because it appears they haven't got the message. OOP-style virtual function tables are used everywhere. It's just often not a convenient solution to the problem you have at hand. &gt; The C culture generally emphasizes efficiency, sometomes at the expense of maintainability or ensured safety. I would rather say “C programmers often do not completely foresake performance for safety.” C programming is programming with no training wheels attached.
I dunno, I've seen lots of people program in C under Windows, and more under OS X. While the latter is Unix-like enough to make it easier (in my opinion) neither is poorly suited to the task, and neither is "hardcore." Moreover, I wouldn't think of my distro as being "hardcore," and I definitely didn't choose it because of its reputation. Arch provides me with all the basic tools and documentation I need to easily build my systems from the ground up. Being so heavily involved in system construction allows me to more easily troubleshoot and solve problems as they arise. Similarly, I love C because it is about as low level as I'd want to get to solve almost any problem and it's old enough that I can easily find solutions to most. The formality of C appeals to me because it forces me to understand the whole of my programs, just like the formality of Arch forces me to understand the whole of my systems, and most importantly I recognize that my methods are not for everybody. Having such basic building blocks allows for a vastly different form of design and development from case to case, and I think this is what u/FUZxxl is trying to point out. There is no C culture, just loads of subcultures, and while I may fit into the "elitist" branch, I also recognize that other branches exist and for good reason. My way of doing things is not universal, and insisting that it is would be absurdly limiting to the only language I've seen that is meant to handle all manner of problems. C is a nuclear powered, Swiss Army Chainsaw light enough to tackle delicate embedded jobs where size comes at a premium, but capable of growing heavy enough to power vast, complex systems as needed. Trying to pigeon-hole it, in its entirety, to one group or another is grossly inappropriate in my opinion, as it has far too much utility.
 for (int i = 0; i &lt; d * d; i++) { space = 0; column++; if (column == d) { column = 0; row++; } if (board[row][column] == tile) ... Consider what happens on the very first iteration here (`i=0`). What values of `row` and `column` are you looking at? What value of `i` do you think corresponds with checking the tile at `array[0][0]`? If you're not sure, try printing out `i`, `row`, and `column` immediately before you check the `tile`
Happy to help. I didn't notice either until you reformatted your post.
IF you have a mac everything pre installed but if you are stuck with a windows download cygwin and make sure to select gcc when installing and then use sublime for text editing
Make the file extension .c?
Well since it's c/c++ project, one would assume that you can use code from one or the other. If I use a code that's made for c++ then that's how I would guess.
Might give it a try, thanks
Yes. And even if it in some magical way compiles it into c++ it would still be backwards compatable.
Actually I'm fairly certain that if you make any assumption about pointer reprentation you're into undefined behaviour even if you cast to uintptr_t first, the only thing the spec says you are allowed to do with a uintptr you got by casting a pointer is to cast it back to a pointer of the same type.
Wouldn't this be need to be: struct node* nptr = (struct* node) malloc(sizeof(struct node)); The above looks like you are trying to dereference nptr and get the size of a struct node, but the pointer is not in a valid state to dereference.
&gt; since it's a c++ compiler. [No it's not](https://www.reddit.com/r/learnprogramming/comments/2f81mq/starting_c_programming_in_school_i_am_very_new/ck73j83?context=3). 
seek to (the end of the file - the size of your integer) read your int seek to the beginning of the file.
Note that the loop only alters `b` Work out what this line does : c = c &amp;&amp; !c; Then this line return a || (b &amp;&amp; c); Then see if the loop terminates
I misread your question as saying the int was at the very end of the file. If it is somewhere on the last line, then see Rhomboid's answer
That's okay - thanks for letting me know. :-)
If a is false then `a || false ` is false. If a is true then `a || false` is true So it returns `a`. `or` doesn't mean 'pick at random', it means perform the logical OR operation on the 2 operands
Yes you're correct. I am accurately recording the file size, but for some reason my width value is 0 and my height value is 115200 (the size of the file minus the headers.) I checked the bmp file format wiki again and I'm fairly certain that my offset is correct though! The width and height are offset by 18 bytes. The file is 240 x 160 which is 38,400 bytes. Multiplied by 3 that is exactly 115,200. So it is detecting the correct size of the image but the width and height aren't correct? Is the problem you see an incorrect offset of bytes?
C++ addresses some things but by no means all. In fact, some of the problems it inherits from C can be easier to exploit in certain situations because of the juicy targets C++ provides -- e.g., vptrs+vtables. You can see this in real-world vulnerabilities involving heap corruption. It's relatively uncommon for there to be a useful function pointer on the heap in a C program, so attackers instead have to try working with other pointers, including those internal to the allocator (the Windows allocator and glibc's dlmalloc used to have some straightforward targets). For a C++ program, however, it's almost guaranteed that there'll be some vptr+vtable available, which is why so many real-world exploits use vptr+vtable corruption to kick off a ROP chain. Note too that a whole lot of reference implementations for other languages are written in C and have therefore on many occasions allowed attackers to step outside the seeming safety of those languages. 
This sounds like homework. But. You know what fscanf() does. To save things in an array, you have to set the array at that index equal to the string you read in. (Really, the pointer to the string, the char*). Also, EOF. Or are you asking how to allocate space in an array for holding strings from a file of unknown-at-compile-time length? 
Unfortunately, there is no such thing as a string in C; the closest you get is an array of characters. So in order to have an array of strings, what you really need is an "array of arrays." You can accomplish this in one of two ways: 1. Allocate each of the character arrays individually, store each string in a separate character array, and store the arrays' addresses in an array of pointers. 2. Create a two-dimensional array (i.e., a matrix) of characters, and use each row to store one of your strings.
Do not post code as an image. Always post text so we can compile and run the code to find out where the problem is.
Oh, I agree. It's just that I googled "how to daemonize a process" a while back and ran into this function, which I had never heard of before. I thought I'd add a little footnote for people who didn't know about it either.
Thanks for the tip
This is a project I've been working on since December, and it's the first nontrivial program I wrote in C. I'm hoping to get some feedback/criticism so I can improve my C skills. The project is an implementation of the [sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes) and [trial division](https://en.wikipedia.org/wiki/Trial_division) algorithms optimized by using [wheel factorization](https://en.wikipedia.org/wiki/Wheel_factorization) to reduce the number of composite numbers being checked while sieving and factoring.
Your submission got caught in our spam filter. I'm sorry for the inconvenience. If you want code review, flair this as “review” instead of project.
A while loop.
Whilst it's true that on most architectures, malloc returns pointers that are aligned to the largest word size. There is no guarantee other architectures will behave the same. You cannot make any guarantees as to the alignment of pointers beyond the specific implementation. I remember there were plenty of DOS games that used this idea that were difficult to port to Windows because it made assumptions of pointers. I would gladly trade a little bit of added storage for the potential headaches of undefined behavior and portability problems unless I was developing for an embedded system and memory was a massive concern. Even then, it would be a last option.
Of course. Give more detail on your desired pattern
The resulting .mp4 container is not correct, the format doesn't like files to be cut up like that. With formats like .m2ts that are designed for transport streams this would be less of a problem.
Well, no, it's not *correct*. But VLC is known for being pretty robust and tolerant of bad files.
I think it won't play because the mov atom is at the end of the file and without that it misses information about a lot of things. You can try moving that to the front to maybe get it to play. (ffmpeg has 'qt-faststart' for this). [here](https://www.adobe.com/devnet/video/articles/mp4_movie_atom.html) is a bit more information about it.
Ah, I thought you were talking about C stuff. Our codebase has C starting other processes; the code is doing the double-fork to safely have the child process not owned by the parent. I was hoping I'd managed to not hear about som cool system calls to make that code better.
If you find an interesting article, please post it here! We are always interested in good content.
Thank you so much for this! I kinda got it, but your super clear formatting and explanation really helped. :)
dunno why the downvotes - you gave a solid help that goes directly to 1000s and 1000s of code examples
&gt; double array[20]; This declares a variable whose name is `array` and whose type is `double [20]`. &gt; void arrayRead(double array[], int* num) This declares a function that takes a pointer to double (*not* an array of double, that's not possible; when you write `double array[]` as a parameter, it's the same as writing `double *array`) and a pointer to int. &gt; arrayRead(array[20], &amp;num); This tries to access the 21st element of the array named `array` (which is out of bounds and invokes undefined behavior, because there were only 20 elements in that array), which results in a value of type double. It's trying to pass that value as the first parameter of the function, but the function expects a pointer to double, not double. This is therefore wrong for several reasons. What you probably intended to do was write arrayRead(array, &amp;num); When you write the name of an array, with a couple of exceptions (which you should know about), it decays to a pointer to the first element of the array, which is what the function is expecting. Again, the name of the variable is `array`, not `array[20]`. Sticking braces on the end is indexing into that array. Those are not the only problems with your code, just the first ones that need solving. 
Assuming any startup code that may exist uses the value of main(), there's a small C99 exception for main(): &gt;5.1.2.2.3 Program termination &gt;If the return type of the main function is a type compatible with int, a return from the initial call to the main function is equivalent to calling the exit function with the value returned by the main function as its argument; **reaching the } that terminates the main function returns a value of 0**. To implement the return == exit semantics, the startup code on one of my machines does this (tidied up a little): call main mov %eax,(%esp) call exit That is, the return value of main() is handed off to exit(). Everything works out fine because neither exit() nor the eventual system call does anything untoward. Maybe the worst that can happen is a shell script bombs. But the C standard doesn't prohibit an implementation from taking the return value of main() and using it to index a vector or something, which is why it was useful to add well-defined semantics. As a bit of trivia, note that ISO standards are "concisely precise" documents -- pretty much every word counts. Look at this again: &gt; a return from the **initial** call to the main function Hmm: #include &lt;stdio.h&gt; int main(void) { static int i; int r; printf("Hello, world\n"); if (!i++) { r = main(); printf("%d\n", r); } } Does that program invoke undefined behavior? I would imagine so. 
What I find really interesting is... how short and minimal it is. I figured something like this would be a lot larger. It looks to be under, like, 2000 lines of code in total, which I find really impressive. That's not all though... I see a lot of C code that are minimal but I find are hard to read or lack self-documenting code, yet this... is actually some of the most readable code I've ever seen. Its apparent you've been writing C for years, and GOOD C at that, so I have to ask: What kind of coding style do you use? The code is both self documented and appropriately coded, it's easy to tell what's going on without even knowing what the rest of the code does; things are named appropriately and everything does only one thing. Anyway, enough over the way the code looks, I do have one complaint though. Could you include an example of it in use rather than the "Hello World" snippet? 
+/u/CompileBot C #include &lt;stdio.h&gt; int main(void) { int i; for (i = 0; i &lt; 10; i++) putchar('*'); putchar('\n'); return 0; }
yes i wondered about that also, certainly since it's adopted as the main internet video format somewhat and most tools default (i think, i only use ffmpeg) to the end instead of the beginning. Which kind of makes streaming impossible without moving it or fiddling with settings. And, i wonder what a corrupt mov atom will do to the file. It would be a bad thing if if a small error there rendered the whole file unplayable which i think it does.
some compilers may need return for main function as return 0; but latest compilers automaticallly returns value zero if we ignores return statement !!!!
temperatures[1] is undefined; int temperatures[7][24] = {{1, 2, 3, 4, 5, 6, 7....}}; is only assigning to temperatures[0]
Ah. Well, I'd suggest using an application like GDB to debug your code.
Thanks for your help.
I've been amazed by the number of people I know that need help googling, just can't do it well. lmgtfy gives the help with a chuckle. I'll guess that the down-voters think it was mean or something. 
I thank you for your critical opinions and your fine words @theif519. The lack of examples is a very good point, I will do my best to add several new examples later today. I have been writing C code for a pretty good while, yes. My main goal when writing code is to write code that I will be able to understand at a later point in life. So if I look back three years from now, I will still know what everything does. This keeps me from having to rewrite code everytime I want to add a new feature or something likewise. I also have a very strong desire to write as compact code as possible, that is to do as much as possible in as few lines of code as possible, which of course keeps the codelength down.
Definitely gonna play with this! Thanks!
I'm just going to be blunt. This website is *awful*. It took upwards of 5 seconds to load the useless splash image, and then the scrolling was choppy and slow. There is barely any information at all on the entire page, and what *is* on the page isn't very informative. What does *hand crafted* even mean in the context of a webserver plugin? I don't think I've ever seen a plugin that wasn't hand crafted. The library could be great, but I couldn't get past this terrible website to really find much out about it. Sorry for being so harsh, but this sort of thing is extremely annoying. It's exactly what's wrong with the "modern web". Completely unnecessary use of massive assets and javascript with very little actual information. I think simply a link to the GitHub repository with a well-written `README` would be better received.
I have to edit a fifo file in a socket, ence the use of dup2. I will give it a go! 
You do not make any sense. You know that a fifo is the same think as a pipe? How can you edit a pipe? You can't put a pipe into a socket. I have no idea what you want.
However, you might look into `memcpy`, which might help.
Sorry, I am not being clear. In short, it's a program that my OS teacher sent that consists on going through a pipe, a fifo and a socket using various fork(), one after the other. In each one, I have to execute a command with execlp (cat in the pipe, cut in the fifo and sort in the socket) and I have been using dup2() to "go around". This is all the teacher's indications. I got through the pipe and fifo without much of a problem but now I am stuck in the socket. That brings me to my initial question. I hope I was clear this time :) 
I think I understand what you mean. What you want is to call socketpair, which will give you two fds that are like the ends of a bidirectional pipe. Then you can use dup2 like with a regular socket. 
You're checking i before it's declared in create_bsp, not sure if that has anything to do with it. 
I accidentally cut the declaration out when pasting my code into gist. I'll fix that
I don't see where you fully initialize the automatic `theRoot` variable and its field `tree`, before it's going to test its value.
I see. I will try it when I get home. Thank you. It seems I may have gotten lazy and assumed left ptr and right ptr would be assigned in the insert function. I wonder why that wouldn't cause any issues when calling it on multiple lines rather than a for loop.
No problem! Bear in mind that if it were an array of something other than `char`, you should be doing something like `8 * 10 * sizeof (some_type)` for the final argument.
socketpair() creates an anonymous UNIX socket without having to do all that. It's like pipe() compared to a FIFO living in the file system.
That's just what I could notice, it may not be the cause. It should cause segfault at the first call of the insert function, but it depends on an unpredictable value of theRoot.tree, which in turn may end up being NULL, if you use one compiled version instead of another. If you use gcc, you might find `-fsanitize=address` very helpful. 
There are no loops in the code you posted.
The second part of your code must be posted, because I'm not spotting any infinite loop problems that'd arise from this part by itself.
Didn't know about that gcc argument. I'll try it out. Thanks!
&gt; //Creation of a FIFO + file desciptor int work_fifo; if(mkfifo(FIFO_PATH,0666) &gt; 0){ perror("mkfifo"); exit(0); } Others have commented on other problems, but `mkfifo(3)` returns an error code that is `&lt; 0` like most std functions, just an FYI.
So thanks to that command, I realized there was a problem with allocating memory and pointers. Even without the while loop, I get segfaults with that gcc argument. Still not sure why a loop would bring that to the light of day, but thanks to it I can go back to the drawing board on these functions. Ok, I realized I wasn't setting the root node's pointer to NULL. Silly mistake. Thanks again, I really appreciate having more tools to use with GCC!
&gt; ```current = &amp;head;``` head is already of type ```NodePtr```, because ```void printList(NodePtr head)```
Well, you're never assigning a value to your head node, You change ptr to a new node before changing num in it. Edit: If you intended the head just to be a pointer node, then consider moving &gt; current = current-&gt;next; to before the printf statement.
So you make your head node, right? You never set the num attribute of the head node, but you access it in the print function. (See my edit above if you intended to have the head be a pointer node)
I just realized what I was doing wrong.. Instead of having, printf("Node #%d contains %d\n", i, current-&gt;next-&gt;num); I had: printf("Node #%d contains %d\n", i, current-&gt;num);
Yes, that accomplishes the same thing as my edit noted. I'm glad you got your problem solved!
I suppose that's more difficult. First, choose a file name. Then fork. One side calls socket, bind, listen, then accept (which blocks until the other side is ready). The other process calls socket, then connect (with the file name you selected earlier). Then each side has a fd corresponding to the individual connection, and you can dup2 it into place if you desire. 
Thanks for the reply. I'm a bit nervous as I've never done something like this before. I know virtually nothing about cloud computing and don't even know what "SSH into it" means. What services have you used before? How complicated is it? Is this something I could learn how to do in a day or two? What are the typical prices?
Sign up for Amazons AWS, set up one of the free EC2 instances and play around a little. It's good to have some experience with Linux. If you don't, set up a local VM to learn a few Linux basics (SSH, working with the command line, compiling and running a program). After you feel confident, move to the EC2 instance. After all, it's not really difficult, after all it's just a computer like yours. 
Alright, there is a *lot* wrong here, so I'm just going to go through what I can see. There might be errors that I haven't caught. The expression `sizeof(head)` does not do what you think it does. The `sizeof` operator returns the size, in multiples of `char`, of whatever you give it. The size of a type is a compile-time constant; in this case, probably 8, since what you're working with is a pointer (`char*`). What it looks like you want is to test how many characters you wrote; the return value of `sprintf` already gives you that. Don't rush to change those lines, however, because there's more that's broken here. There are two big problems with `sprintf(head, "%s%s", head, '\0')`. First is that you're overwriting a string with itself. I get what you're going for here, trying to write incremental 0s, but that is a hilariously inefficient way of doing it that also won't work; `sprintf` only copies up to the end of the string, i.e. not past the NUL terminator, and automatically inserts a NUL terminator of its own. So it won't copy a whole bunch of NULs like you're trying to. The second problem is what I believe is actually causing your error: You've got a `%s` format specifier, calling for a string, but what you've passed in is '\0', a `char`. Now, as you may or may not be aware, `sprintf` expects a string in the form of a `char*`. What you've given it is one byte of 0, plus seven other bytes of whatever happened to be hanging around at the time of the call. That is almost certainly not a valid pointer to memory that your program owns. The correct format specifier for a `char` is `%c`. Don't change anything here either, though, because there's yet more. You assign `sIP` and `dIP` to static strings, and then later on you `free` them. You cannot free static memory. Do you understand stack vs. heap vs. static memory and how `malloc` and `free` work together? Finally, I want to point out that all of this contrivance is completely unnecessary. You have two fixed-length strings that you're trying to embed into a third fixed-length string; `sprintf` shouldn't come anywhere near this problem. What you need to do is, after you `malloc` space for `head`, initialize it to NUL all the way through. That's easy to do with `memset` or a `for` loop. Then, simply copy `sIP` byte-by-byte into `head`, starting at index 0, using either `memcpy` or a `for` loop. Then, simply copy `dIP` byte-by-byte into `head`, starting at index 16. Done. One buffer, two IP addresses, the rest NUL bytes. Also, by the way, you can declare *and* initialize a loop counter in a `for` loop, and braces are not needed around single-line loop/conditional predicates: if(sizeof(head) != 16) for(int gap = 16 - strlen(head); gap &gt; 0; gap--) sprintf(head, "%s%s", head, '\0'); It's still wrong, but it's a whole lot cleaner than it was before.
umm nope, its working if I dont scanf some integers before. Like its very strange. I dont know whats going on... EDIT: why do you say c is for char? It is s not c :S... EDIT: there isnt string type in c programming :S
hmmm, but it just skips the part where i have to input a char. Maybe its because i press enter before, when I input integers. How can I fix it?
yeah, i will use %c from now on, but now the program doesnt even let me to input. it just skips that part for some reason and unfolds
its working if i scanf like this scanf("%d/%d %c %d/%d", &amp;a,&amp;b,&amp;character,&amp;c,&amp;d); but its not working like this scanf("%d/%d", &amp;a,&amp;b); scanf("%d/%d", &amp;c,&amp;d); scanf("%c", &amp;character); Is this imposible to fix in simple way? Without using too many shenanigans&gt; Would something like this work? With a couple of fixes? scanf("%d/%d", &amp;a,&amp;b); scanf("%d/%d", &amp;c,&amp;d); character = getchar();
it doesnt matter how, we can do it however we want. We just need to scanf two fractions and make an action with them using switch statement. For switch statement we have to use + - / * thats why I use char for it.
I don't know what library you're using to write to the file, but if it's [this one](http://elm-chan.org/fsw/ff/en/printf.html), it doesn't seem to support the `%f` format specifier
**#include "fatfs.h"**
Ah but if i do that i get an error at f_printf(&amp;MyFile,"%f\n\r",TEMP); more specifically "&amp;" saying : "incompatible integer to pointer conversion passing 'int' to parameter of type 'const char *'"
I did, but I get the error Lab3_original.c:11:1: error: stray ‘\302’ in program 
My Saviour x 
signed integers on nearly all architectures use twos complement. So of the 16 bits of the 'short' type, 15 are used for the data and 1 is used for the sign. When you call printf, the short is implicitly converted to an int, which in your case is a 32 int. It changes from 8000 to ffff8000. This is called sign extension. The sign bit is copied from the most significant bit, in this case 1 into the rest of the bits. In binary the 'short' 1000000000000000 (0x8000) (-32768) becomes 'int' 11111111111111111000000000000000 (0xffff8000)(-32768) This is the actual behavior, but not the defined behavior. the c standard states that the &lt;&lt; operator is undefined when the argument or the result would be is negative. Edit: perhaps I should add that if you used an 'unsigned short' instead of 'short' you'd get the positive value of 32768 and it would be sign extended to 00000000000000001000000000000000 (0x00008000) (32768)
Reposting the same shitty article without any improvements is not a good contribution to this subreddit. I'm removing this.
 else if(ints[0&gt;=300]) { printf("Enter a number less than 300!"); } Pull the comparison out of the square brackets Should be else if(ints[0]&gt;=300) 
Thank you. Yeah, I have sent a message to the admins but they are kind of slow when it comes to answering.
You have some logical problem there as well. You have two loops, one inside of the other. Both iterate over "i" and modify it. I guess that was more a result of your debugging - the funny thing: this looks like it would still kind of work, but please correct it, you will one day run into problems because of this. The other thing is like already suggested: in your else if, you put the whole comparison into the "[..]", instead of "[0] &amp;gt;=..."
I think the problem is I don't really understand how the loops work. I've tried moving the if statements around in the code, but then I get strange results. Do I have to make three separate loop conditions of for (i =0; i&lt;9; ++i) with if statements inside each? 
Computer Science is the study of data structures and algorithms, Computer Programming (or coding) is writing instructions for the computer to solve a problem
Solutions that work that way read in input character-by-character (rather than reading in the string as a whole in one go). As the user enters in more input, the size of the array is increased (by use of realloc). Unless you're interested in using realloc and reading in character-by-character, you will have to give a maximum size to your array.
That's what [`realloc`](http://linux.die.net/man/3/realloc) does. Also, don't forget to `free` the memory afterwards
thank you very much this really helped
&gt; It can't know that. What you're trying to do is impossible. #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; char *gs( char *s ) { static size_t len; char *p = realloc( s, len + 1 ); p[ len ] = getchar(); if( p[ len ] == '\n' ) { p[ len-- ] = '\0'; return p; } else { len++; return gs( p ); } } int main( void ) { char *s = NULL; puts( "Type: " ); s = gs( NULL ); puts( s ); free( s ); return 0; } ( ͡° ͜ʖ ͡°)
I'm sorry, this question is off topic in this subreddit. Please ask general programming questions is /r/learnprogramming. I removed this post for you.
But how does creating an array with 100 entries waste less space than just doing `malloc(100)`?
Yes, that would fall under "several possible workarounds".
X-Post referenced from /r/computergraphics by /u/Goradan [Yocto/GL: C99 Single File Libraries for Physically-Based Graphics](https://www.reddit.com/r/computergraphics/comments/4ercgg/yoctogl_c99_single_file_libraries_for/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^P.S. ^^my ^^negative ^^comments ^^get ^^deleted. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Try what I wrote here: http://pastebin.com/GJjRmThX
Thank you for the help and a great reply! It works now! I think the problem I was having besides the 300] was that I wasn't using return. 
PICs are C only, except the PIC32. I believe Microchip offer XC32++ for that platform. 
Hm, so think about a loop really like just stuff you need to repeat over and over again. Like in your code, loops are used for example to do something with every element in an array. In your loop you have at the moment the if ints[0] &lt; 0 and also the &gt;= 300. That's something you can check outside of the loop, because you don't want to do anything there. In the loop written with words you want to: Every entry in the ints field is double as high as the previous entry. So you need just one loop that looks at the indices i of the elements in your ints array, and write ints[i]*2 into the next field ints[i +1] In programming you need to be very exact, so you need to be sure, that you do this only "for" the elements that really exist, if your array has n elements, the last index you can write to is n-1 (because the first is 0). That's why you do this doubling: for (i = 0; i &lt; 9; i ++) ints[i+1]=ints[i] * 2 
The `free()` function releases the memory allocated for the object you pass to it. Yes, it erases that memory (it doesn't have to, but it often does). If you could describe what your problem is, I could try to give more specific help.
We have a deck of cards and after dealing the first ten we have to remove the cards from the original deck
We can't help you without seeing a lot more of your code than this. Also, the error message, please.
I would remove the cards from the list and add them to a separate “removed cards” list so you can re-add them later if needed.
It's not clear to us how you're trying to use the `free` function. You should post enough of the code to reproduce your issue. This would probably include the function where you create the deck and the function where you are removing the cards.
That's a segfault. Look at /u/dragon_wrangler's comment for the likely cause and a solution.
Sorry, I don't answer questions in private messages, at least not for free. If you can't show your code, consider asking your TA for help or post code that is similar but shows the same problem.
First things first, every call to malloc should have a complimentary call to free on that allocated memory. When you don't need it any more, clean it up. 
In the past, debugging memory problems used to be a really tedious process. Luckily, there is good tooling today. Use *valgrind* to find out what memory regions you forgot to release.
That's exactly what I've been doing. I'm looking through some popular/recommended projects on Github. I like designing things myself, but at the same time I'm learning how other people do things, so my code can communicate with other people better and I can open my mind to more techniques. Anyways, thanks for the advice, much appreciated.
Yeah...wait how do you remove the cards from the deck?we were told to use mallow and pointers with linked lists.,,
Yeah I realize I just thought maybe I'm using the wrong function or something but it's basically I have a function that is dealing cards to two hands using Pointers but now need to remove these cards from the original deck
Formatting tip: put four spaces in front of each line of code. So if you put in: This will come out as code: #include &lt;stdio.h&gt; int main() { printf("Hello, world!\n"); } You'll get: This will come out as code: #include &lt;stdio.h&gt; int main() { printf("Hello, world!\n"); }
tried to figure out a way around that but ended up with just spaces everywhere, thx anyway
You still have mismatched braces. The line &gt;while (sls-&gt;next != NULL) { Is outside of any function. Copy and paste all your code into the text box, select all code and click on the 'code formatting' button. Or use paste bin
Yup, that's the way it is. For lots of code, use a site like ideone or gist.
alright give me a few min to do that sorry again eddit: my problem is right now I'm using emacs, and if paste my code from emacs its not multiple line its considered as 1 line who's long as hell. So I have to manually change that aswell, and thats not really fun im kinda blocked right now, and I feel so retarded not to be able to do a thing that simple tbh 
This is an excellent explanation of some of the key differences between C and higher-level languages. Apparently it was posted around a few programming subreddits a while ago, but I never saw it, so have an upvote.
You're gonna hate me, but you've still got code outside of braces. Take your time, it's only reddit.
you mean on pastebin? 
ok fixed sorry again
Yeah, iirc valgrind doesn't run on Windows, even under CYGWIN. You could set up a VM, but that might not be worth it.
I have some VMs set up for other things, so might try setting it up in one of those. 
Thank you for asking such a well-described question! If all users did that, people would be much happier to answer questions. No, this is not correct. units[0] = malloc(7); This creates a region of seven bytes and assigns a pointer to it to `units[0]`. units[0] = "pounds"; This overwrites the pointer to the previously allocated region with a pointer to the string `"pounds"`. The allocated memory region is now inaccessible. There are two options: * Fix your program so it actually copies the string. Replace `units[0] = "pounds"` with `strcpy(units[0], "pounds")` to copy the string instead of assigning a pointer. On UNIX, you can use the `strdup()` function to save some typing. It allocates space and then copies a string in one function call. * As it seems that you never write into the allocated memory region after assigning the initial string, you don't really have to allocate memory. Just assign the string constant and work with that. Lastly, when you do `free(units)`, only the `units` array is released. The memory regions pointer to by `units[0]` and `units[1]` are not implicitly freed. You have to explicitly free these yourself.
Thanks! And thanks for the "The Descent to C" post I was just reading it when you responded! I took out the extra calls to `malloc` and Valgrind is no longer complaining about any memory leaks! If I may ask a follow-up questions to make sure I understand what's going on under the hood: char **units = malloc(2 * sizeof(char*)); The point of this is to allocate a chunk of memory big enough to hold two string pointers, but there are no actual pointers that reside there until I create the string constants and assign them, correct?
ENJOY
In the C language, the compiler only knows things from the point they are declared. Thus, when the compiler encounters the line int searchList(NodePtr, int); it doesn't know what `NodePtr` is yet and gets confused. To resolve this problem, move the declaration of `searchList` after the declaration of `NodePtr`.
This is a (mostly) C++ program, but you're in a C programming sub. These are not the same thing.
Data works "best" when it is properly aligned. E.g. your int is happiest when its address is a multiple of 4. What happens when data is poorly aligned is up to the CPU; in some cases it may make no difference, in others it may make accesses slower, and in others it may crash your program. If your 1st structure was just a single char, with a size of 1, and you put the 2nd struct right after it then all the members of the 2nd struct would be at an odd address. This would be fatal if you had an atomic_int in there, for example
This is great. I poked around the author's [homepage](http://www.chiark.greenend.org.uk/~sgtatham/). Turns out he is the author of PuTTY among other interesting pieces of software.
You can achieve the proper alignment, avoid pointer arithmetic, and not call memmove explicitly: struct extended_data {struct meta_data mData; struct A data;} ed; ed.data = a; // copies the original data into your extended version // initialize mData // make sure everyone is using &amp;ed.data now, not &amp;a Also note that as written, your meta data is allocated on the stack. Given that you're doing reference counting, I'm going to guess you need it to persist beyond the current stack frame. If so, you'll need to use malloc to allocate it.
Few questions: 1) Wouldn't this require a wrapper exist for each individual struct? Hence you'd have N wrapper structs for N structs. I.E `struct B` needs its own too right? 2) Would this need to be passed to each individual thread in place of the actual struct itself? ~~If so how would this wrapper be properly reference counted itself?~~ For normal meta data it most likely would work fine, but I'm not sure for my particular example. I agree that for normal meta data wrapping definitely is the way to go though. Edit: For the example I kept it simple. Otherwise I'd have to go from a single line of `code` to multi-line. Yes the meta data is meant for that heap, although the data could be transferred from stack to heap if desired. Edit2: Took back question on reference counting itself. I suppose the entire struct would end up getting destroyed when meta data ref hit 0.
When would padding be absent to cause incorrect alignment? Is there a way to enforce it for the meta data?
If your `md` only contained elements that required less strict alignment than the elements in `a`. This isn't the case in the example you had in your post. But, for example, if you had struct md { char name[64]; char SSN[10]; } ; has a size of 74 (not a multiple of 4 or 8) because no padding is needed to align SSN or name. If you used memcpy to stick an `a` right after this, elements in `a` which needed 4 or 8 byte alignment would be misaligned. Some ways around it 1. Round up `sizeof(md)` results to the alignment that `a` needs. 2. Put `a` first. If any elements in `md` need stricter alignment that what `a` offers (e.g something in `md` needs to be 8 byte aligned, but the alignment of `a` means that `md` could start on a 4-byte boundary then you could put a large dummy element in `a`, with a union1 3. Use your compiler's 'alignment' syntax, if it has such extensions` to force the structs' alignments. e.g. __declspec(align(8)) struct md { char blah; } would give `md` a size of 8 (with the MS compiler) 
X-Post referenced from /r/programming by /u/iamkeyur [Nuklear: A small ANSI C GUI toolkit](https://www.reddit.com/r/programming/comments/4fhinz/nuklear_a_small_ansi_c_gui_toolkit/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^P.S. ^^my ^^negative ^^comments ^^get ^^deleted. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Bumb 
Get a better compiler, or use the warning options? Also, what do you expect the result of these two lines to be? FirstAndLast[length] = strlen(FirstAndLast); FirstAndLast[length] = 0;
`name` can just be: void name(char *FirstAndLast) { fgets(FirstAndLast, 20, stdin); } call it like this: name(FirstAndLast);
Can I ask why not pastebin.com?
firstly, \n isn't the null character. the null character is \0; they are two very different things. whenever you write "somestring" it actually evaluates to "somestring\0", so by removing the last (null) character from the string will just cause errors (null characters are VERY important). secondly, arrays are zero indexed so array[length] is always undefined, use this to get the last element of an array: array[length - 1] 
I talk about some of the reasons here: https://www.reddit.com/r/learnpython/comments/4f6k2m/meta_remove_pastebincom_from_sidebar_replace_with/ TLDR: It's bloated, has banner ads, capchas and is blocked for some people.
To store the closure?
The closure is stored in a structure in automatic memory (see the top of page 6).
Awesome! Thanks again, pointers and heap/stack memory are starting to make a lot more sense to me now because of little exercises like this. :-)
Why do you put all of this into a header file? Why not split it into a source file and a header file like every normal project? Or even better, subdivide the project into multiple source files so only the needed parts are linked in. What library is this linking against for rendering?
Pretty good, but I take issue with &gt; you can't write Java's garbage collector in Java, because you need to have the garbage collector already before you can even run Java code I don't know about Java, but there is self-hosting code. That's like saying you can't write C compilers in C.
What self-hosting Java code do you know? Java lacks pointers which makes writing the kind of low level code you need to write a JVM tricky at least.
It appears that it doesn't use any actual GUI toolkit, but instead outputs points, vertices and colors for you to render using your own rendering engine. It's based on the immediate GUI style which differs from event-driven GUIs. This C++ library https://github.com/ocornut/imgui uses a similar technique. As far as the single header file goes I agree with you. This code is a mess to study and it's unnecessary weight to include to your application even functions that aren't used. They probably followed a similar style to the stb single header libraries https://github.com/nothings/stb which are also equally hard to read. But since it's public domain you could just take the functions and copy them in your own source files without any licensing issues. That probably is the reasoning behind this style.
Like Gikoskos said the single header library format did not originate from me. It is not even my first single header library. There are reason for and against using this format (even harder to defend for bigger libraries like this) and I can assure you the decision to use a single header instead of .h/.c duo was not easy. In fact it took me 1 1/3 years. One week ago it was still split. But in the end it comes down to my personal preferences, way of thinking and ease of use. Side note if you take into account the platform depended code which uses a .h/.c and embeds the library you actually have a single duo (is a little bit of a cheat argument). As for the render backend. By default it uses simple buffered shapes as output which can be converted into vertex buffer output. So the library can be used on any platform providing basic user input and a way to draw simple shapes or vetexes.
&gt; the author of PuTTY Wow. Respect.
&gt; So the library can be used on any platform providing basic user input and a way to draw simple shapes or vetexes. Which means that it's going to be as slow as GTK with X11 over network, except if you use X primitives to draw these shapes (might be a good idea to add this). Then it would be great.
C++ lambdas don't dynamically allocate anything; I don't see why this should have to.
Did you seriously just type your question in notepad, take a screenshot, and post *that*? Your code isn't even C ... it's C++. And it's absolutely filthy with errors. Clean up your code. Fix the simple syntax errors. Take the time to make a meaningful post with a specific question. And then post it at /r/cpp_questions.
Try using the toolkit over a flaky or slow network connection to get an idea of what the problem is.
I can see no reason to use anything other than Visual Studio 2015 community edition if you are on Windows. While it is "sold" mainly as a C++ environment, it's a very very good C programming environment for anyone who is not investigating the outer limits of undefined behaviour in C standards. The GNU compilers are excellent, as is LLVM, but debugging is painful on Windows. VS is just plain better with an outstanding debugger and really nice code completion etc. My team develops for mainly embedded targets. Nearly everyone writes and debugs as much code as possible on Visual Studio before moving it to the embedded target because the environment is just so productive.
When you enter 'e', `scanf` tries to parse that with the `%d` format specifier ... which fails because it's not an integer. What does failure mean? The contents of `digit` is unchanged (I think), `scanf` returns 0 (technically it returns the number of successful matches, but none succeeded in this case), and **the 'e' sticks around in case you want to parse it some other way**. Since your code doesn't check for failure, it tries to do another `scanf` and fails in the exact same way, again and again. So, you need to do two things: check for failure, then do something about that bad input.
Well if you have a flaky connection is any GUI a good option?
i have most of my code written with some partial error and some parts in pseudo code... NOT a plea for someone to do my hw for me
Oh yes! I didn't realize that. Thanks!
This question is definitely based on an overall inexperience, but I would like to have it answered despite any potential criticism I may receive... Would it possible to... SIMULATE closures in C by having it replace those closure blocks at compile time with a localized (static) function with the same function parameters? The "captured" values, could be passed implicitly to the generated functions as well. Lets say you have something like... void async_callback(void (*callback)(void *), void *args); int x = 0; async_callback(^(void *args) { perform_some_work(args); perform_more_work(args); reference_external_val(x); finalize(args); }, some_args); Be turned into a mangled function like... static void _manged_name(void *args, int x) { perform_some_work(args); perform_more_work(args); reference_external_val(x); finalize(args); } And then passed in place of the closure? Would there be a disadvantage for this approach? Granted, I didn't read all of it yet, so I'll get to that tomorrow (don't have the time now). Edit: Noticed the issue immediately! The implicit parameters kind of ruin it (aren't compatible with function pointer), and it's impossible for the caller of the callback to know the parameter values (hence can't pass to callback). Which would make sense as to why it's wrapped in a struct or something. However, lets say it DOESN'T capture the external values implicitly, and it just converts the closure into a normal function declaration, would this work? I think it'd still be helpful when it came down to making code flow more easily. I.E, just inlining the code without needing to define an inline function.
There is the additional issue that the return value of `searchList` is incorrect. `current` is of type `NodePtr`, but `searchList` expects to be returning an integer. &amp;nbsp; I also suspect that the current implementation of `searchList` isn't going to do what you want it to. Consider the following: * The number the user is looking for happens to be in `head`. (It turns out that your list has a leading node with a dead squirrel in its `num` field, so this isn't an issue here, but generally, linked lists will have data in their leading node) * The number the user is looking for is not the second item in the list * The list is empty or has 0 elements * The list is only one node long * The list is two nodes long * This list is longer than two nodes * The number the user is looking for is the last thing in the list * The number the user is looking for is not in the list. While you can safely ignore a couple of these cases due to the implementation details of your program, your linked list and the relevant functions shouldn't depend on those details. &amp;nbsp; In general, searching through a linked list involves three considerations [that lend themselves very handily to recursion]: 1. Did the list end (is this the end of the list)? How can I tell and what do I do about it? [Trivial base case] 2. Is this the node I'm looking for? If so, I shouldn't look any further down the list. [Base case] 3. If this isn't the node I'm looking for, then I need to look in "the rest" of the list. [Recursive case]
Feel free to send me a pm. I just implemented a linked list in C a little while ago (I'm new at this). I won't do your homework for you but I'd be more than happy to help you work through it!
the issue comes with it being a class final project and so if anyone (i know quite a few kids in my class who use reddit and often browse the interwebs in hopes of finding answers) copies even part of my code without my knowledge both of us can get in serious trouble...i just dont want to put myself in a situation that could potentially go bad. and its a super specific assignment as well
thanks!and i would never ask for someone to do my hw for me! 
No don't
In case you are looking for a eTutor, you can check www.myonlineedu.com and you can select the hourly class instead of enrolling into the complete course. In the hourly class you can just go for a topic like Linked List for learning. The course details link: http://www.myonlineedu.com/course/full-course-details.php?crid=7
This is spam. Please don't spam.
I am trying to implement the function without recursion. 
If you want to play with reverse engineering then learning C is second best thing after learning assembly language for architecture you are interested in.
Put 4 spaces in front of each line of code. Also, post your actual code. I doubt it includes `#inlcude`. Also, what's your working directory when you run the code? What are the permissions on it? EDIT: Show us the console interaction (running the command and any output), and a directory listing before/after (`ls -la`)
Apart from the few typos and whatnot, the code should work on debian. The issue might be the file name/permission; Linux/Unix filesystems are generally case sensitive, so the filename "Sample.csv" is different from "sample.csv" Knowing what kind of error occurs would be useful for debugging though.
Yeah I have looked at x86 Assembler before, looks quite difficult haha. I suppose low-level languages are sort of required for anything remotely related to security and so forth so I should get started so I will have some experience when I get to uni at least. I have had a patch of about a year and a half where coding has been a chour; I lost interest after my life got pretty busy. I kept reading material to try and keep up but wasn't enjoying it at all. Only recently did I start to get some interest back, which is why I want to make the right desicison in terms of where to go next. It's all well and good me understanding advanced OOP concepts but I don't have anything to put into practice; hence me wanting to learn C which will actually serve me well for uni. I got into programming when I moved to a foreign country and didn't know anyone. I loved computers and always have; I'll spare the life story haha. I loved to code and to learn about security. Fast forward a few years and here I am; still trying to get into the security side of things haha. Sorry for vague answer, at college and using a phone is horrible to type decent replies on :P
But I can't do a thing that the others can. I can't code problems on spoj or codechef, I can't do my assignments, I cant tell you the complexity of data structures the second I know the algo. The only people that are worse than me are the drunkards and the forever high people. I dont think I can do this
That's not how this works.
Other than fixing the `#&lt;inlcude` typo and the `FILE *file2 = fopen("output.csv","w"):`line which should instead end in a semi-colon; I'd suggest you check if the files open correctly, make the program let you know if they didn't, and only process the file if it did: file1 = fopen ("sample.csv", "r"); if (file1 == NULL) { fputs ("Failed to open file1.\n", stderr); return 0; } edit: Also noticed in the `while(fscanf( file1,"%79[^\n]\n, line ) ==1 )` line you appear to be missing the end quote before the second comma. In addition, should that middle section start `"%79s[...`?
Fear not, try K&amp;R exercises or something.
Check out r/dailyprogrammer and try out some of the [EASY] problems to get started with some small programs. If you have questions, ask r/learnprogramming or shoot me a message.
[removed]
This looks malformed. Have you tried compiling it? To change the value of an array you just assign a new value: some_array[0] = 200; You haven't included enough code to see what you have wrong. Keep in mind that you need to declare and and define your variables. This can be done in two steps: int my_array[1]; my_array[0] = 28; Or it can be combined into a single statement: int my_array2[1] = {26};
There's a lot of point in making the syntax match. C and C++ have a symbiotic relationship. They pass features back and forth constantly, to the point that it's more appropriate to call them sibling languages, rather than have C as the parent of C++. Making the syntax different makes it that much harder to share features in the future. Currently, just about any syntax that C++ chooses will work for C as well. The more you break that, the harder things will be going forward, creating headaches for everybody. At least make the syntax the same, and preferably the semantics as well, even if the C-version of the feature doesn't have all the features and complexity of C++. It's also best for the programmer. I deal with both languages on a daily basis. Keeping the differences straight is hard enough as-is, but creating a separate syntax for a very similar feature doesn't help me at all. And then there's shared headers. It's very common to use a C library in a C++ program. You just have to make sure that the header file sticks to a common subset of the two languages. That's really not all that hard right now -- just make it C code, and you're 99% done. There's a few C features that haven't made it over to C++ (notably `restrict`, since that's common in header files), but finding a common subset is pretty easy. Add incompatible features and you're in trouble. With this current proposal, the declaration of `qsort_b` wouldn't compile and would need to be excluded when compiling under C++. If I get the time I'm going to propose some of the improvements C++ made to integer literals (digit separation and binary literals). C++ had to go around and around to find a syntax that worked for the digit separators to find something that worked. That work is done: a single quote works. It will also work for C as well, simply because of the tight compatibility between C and C++. On the other hand, C could choose to do an underscore, because that's what Java has. In some ways that would be more natural for C than a single quote (and actually is what C++ tried to do for a while, but couldn't because of possible ambiguity with user-defined literals). So which should C choose? `'` or `_`? The answer is clear: `'`, simply because compatibility with C++ is a desired feature (explicitly stated by the C standards body, actually). Then you don't have to worry about syntax differences between languages. A constant in a header file can use a digit separator without thinking about compatibility.
 #include &lt;stdio.h&gt; #include &lt;time.h&gt; int main(void) { int i,c,j,h, highest=0, lowest=0,grade,false, temp; float array[10]; srand(time(NULL)); for (i = 0; i &lt; 10; i++) { array[i]=rand()%(100-35)+35; printf("%d ", i); printf("%.2f\n",array[i]); } for(c=0;c&lt;10;c++) { if(array[c]&gt;array[highest]) { highest=c; } } for(j=0;j&lt;10;j++) { if(array[j]&lt;array[lowest]) { lowest=j; } } printf("The Highest Grade is ""%.2f"" and the lowest grade is ""%.2f"" \n", array[highest],array[lowest]); printf("Please enter a grade\n"); scanf("%d",&amp;grade); for (h=0; h &lt; 10; h++) { if (array[h] == grade) { printf("The position in which it is stored is %d\n",h); } else { false=1; } } if (false==1) printf("Not found\n"); array[0]= {35}; printf("Array 0 after change is %d",array[0]); } 
Heres my code as follows, i have already declared an array with 10 elements which are randomized numbers, so far i wanna change array[0] and its value and reprint it
The executable code isn't on the stack, it's located in the same place as all your other code. What's on the stack is effectively a function pointer. This is no more dangerous than any other use of function pointers.
You should start by fixing your errors: gcc -W -Wall -ggdb -o tmp tmp.c tmp.c:9:1: warning: implicit declaration of function ‘srand’ [-Wimplicit-function-declaration] srand(time(NULL)); ^ tmp.c:17:6: warning: implicit declaration of function ‘rand’ [-Wimplicit-function-declaration] array[i]=rand()%(100-35)+35; ^ tmp.c:59:11: error: expected expression before ‘{’ token array[0]= {35}; ^ tmp.c:60:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘double’ [-Wformat=] printf("Array 0 after change is %d",array[0]); ^ tmp.c:7:49: warning: unused variable ‘temp’ [-Wunused-variable] int i,c,j,h, highest=0, lowest=0,grade,false, temp; ^ tmp.c:65:2: warning: control reaches end of non-void function [-Wreturn-type] } 
The compiler is your friend especially when you are starting a new language.
use: gcc -W -Wall -Werror -std=c99 You can use some other std but you probably want c99 or c11.
There are issues, that's why you are getting warnings and errors. There is 0 reason to have any warnings in a program this short.
In order for `s` to be a string you can run `strlen` on, it needs declaring as an array e.g. `char s[20];`, not a single character like `char s;`(if you want up to 20 character names). Your `scanf("%c", s);` line is scanning a single character `%c` instead of a string `%s`.
strcmp compares strings. Using the address of a single char is not going to work because that's not a string. Use stuff like `if (c == '\n')`
Is using strcmp a requirement? It would be typical to compare characters like this: `if(c=='\n')` I suppose you could define a small char array, assign the first array slot as your character, and the next slot as '\0', and strcmp that array.
Where do i type that command? im new to the world of programming and compilers, bare with me :P
 i completely forgot c treats ' ' and " " differently. sorry haha, not my main language
Thanks for reply, I made the changes but still it is writing the data in output.csv file only when I am executing the second command. (1 command) gcc gps.c -o gps (2 command) ./gps
You're not alone. University is hard, and there are certainly other people in similar positions. Have you tried addressing this with your professors or with counselors at your institution? They're the people in the best position to help. If you're overwhelmed or uncomfortable with talking to them, consider asking your parents, a friend or a faculty member whom you trust to help advocate for you. Remember that your university wants to see you succeed and almost certainly has resources available to help you. In the end, even if exams don't go well, you've almost reached summer break. You'll have time to relax, clear your head and examine the situation you're in. You'll have time to look at how you got here and how you want to proceed. You will get through this.
A program (the executable - the equivalent of what a certain other operating system calls an .exe file) you have just created by compiling it (command 1), will only run if you execute it (command 2).
Your loop is subtracting 32 from all 25 elements in your array. This includes the nul character at the end of your string test\0..... becomes TEST -32 ... because your nul has gone, you no longer have a valid string. Additionally, you then print out all 25 values, what did you expect to be after "test" ?
Ahaa figured it out, i tried to make an array with an initial size but for some reason it did not work ;/ I tried doing this: char upper[] and then later on fill it, but it never worked, got any idea why is that? 
The second printf loop will print all 25 array slots. I suggest you ensure the upper array slot indexed on `j+1` is set to `'\0'`, and only print while `h&lt;strlen(upper)`.
Have you considered the possibility that you'd be better at something else you enjoy more? Life is discovery all the way. To rephrase: why is this your major? I can't tell you what's the right thing to do, but I don't get the impression you're where you are by true, conscious choice. 
yes, sure 
How do you know that? Have you run your program through a debugger?
Don't know. Do easy exercises in your spare time, at home. Start programs from scrap. Find a subject, which interests you, and implement it as a program. E.g. when I was younger, I did a simple dungeon graphics engine, because I was interested in this stuff. Basically, start easy, try to understand the basic syntax rules. Also general advice: don't do stupid stuff to yourself because of things like that. If programming is really putting you down that much, maybe think about a different career. But I know that feeling. Working in software for ten years now and also think I have seen the lowest depths of hell ;-)
Funnily enough, this compiles and runs ok: #include &lt;stdio.h&gt; int main(void) { char buff[1024]; int buffLen; while(1) { buffLen=sizeof(buff); fgets(buff,buffLen,stdin); printf("%s", buff); //send(sockFd,&amp;buff,buffLen,0); } return 0; } which indeed indicates the problem is the send line. 
Which upper array slot indexed? where do i assign the '\0' to?
Also, you should show a more complete, properly formatted, example.
I've adjusted my code and this is what i have come to so far, a lot better than before, but i get an extra space and one character extra Take a look: http://prntscr.com/aupl5n
One way would be in your second loop: for(j=0;j&lt;strlen(lower)-1;j++) { upper[j]=lower[j]-32; upper[j+1]='/0'; }
Security sounds pretty low level to me. With c you'll probably get some more direct insight to things like pointers, buffers etc. How stuff works internally. Also Linux is completely in c.
not working for me... I'll just lay down and cry 
Assuming a more or less standard listnode implementation struct listnode *removed = head; head = head-&gt;next; // do something with the removed node. 
That's what it's supposed to do. The first command takes the file "gps.c" and compiles it into an executable named "gps". It doesn't run it. It just converts your code into something that can be run. (On Windows it would be an .exe file, but Linux doesn't use any extension for executables.) The second command actually runs the executable that the first command created. There are two major types of programming languages, compiled and interpreted. C is a compiled language. That means you run your source code through a compiler, and it creates an executable that you can run. The executable has machine code in it that is specific to your operating system and processor architecture. You can take that executable and put it on any computer with the same OS and processor architecture, and it will run without needing the source code. It will also generally run faster than something written in an interpreted language. With interpreted languages, like Python or Perl, you run your code through an interpreter, which actually runs your code. This has a couple big disadvantages. First, it's generally slower because it has to translate your code into instructions for the processor while it's running your program instead of translating it once beforehand. Also, anyone who wants to run your program would have to have the source code. It does have the advantage that you don't have to compile your code for each operating system and processor you want it to run on, though. If you want to compile and run your code all in one line, you can use this command: gcc gps.c -o gps &amp;&amp; ./gps
The send line is most definitely the problem. Think about why you have `buff` in the fgets but `&amp;buff` in the send.
Can you show us where you're calling `vectCreate`? It sounds like you might be passing in the number of vector entries as the `dim` parameter, but when you `malloc` the vecotor you treat it as a byte count. If you're passing in a count of entries as `dim`, you should be allocating more memory, like: (*u).vector = (int*) malloc(dim*sizeof(int));
You're not allocating enough storage for the `vector` array. Change: (*u).vector = (int*) malloc(dim); to: (*u).vector = malloc(dim * sizeof(int)); 
Are you configuring sockFd? Can you post the whole code, formatted correctly? Far easier to see what the culprit is that way.
You are probably right with (*u).vector = (int*) malloc(dim*sizeof(int)); and I changed it, but it didn't fix the problem. I'm calling vectCreate in a c++ function const int d = 6; int array [d] = {1, 1, 1, 1, 1, 1}; Vmath::vect *u = Vmath::vectCreate(d, array); Vmath::vectFree(u); like this. Anything that's wrong here?
&gt;*r = vector + dim +1 is wrong. Yes you are right, that was the reason for the core dump, thank you very much. I would love to know why it worked with 5 or less numbers. &gt;Also why not embrace -&gt;? Not sure, I guess I brainfarted, just as I did with the *r. Fixed that. &gt;Also, sizes should be size_t not int. Which sizes do you mean?
&gt; I would love to know why it worked with 5 or less numbers. Pure luck. Accessing out of bound is undefined behaviour. Your program *may* crash, but it doesn't have to. Instead it could format your harddrive. &gt; Which sizes do you mean? The first parameter to `vectCreate`. Also, why not use a proper constructor?
I would've done strcpy(upper,lower); // copies lower to upper, and properly nul terminates upper for(i=0;i&lt;strlen(upper);i++) upper[i]-=32; 
I've taken my break in all honesty and now I want to get back into it and get my feet wet. One of the big problems I have is I want to get everything right first time, if I fuck up I generally lose my temper and quit; which stops me from really learning much. Still working on fizing that mentality haha. I've got some ideas as to what I want to write, some of it could technically be done in C# but where's the fun in using a load of code that's already written for me? At least by doing it in C I'll have some fun! As an example, my tutor is teaching us VB.net in college (it is horrible) and he was amazed I managed to allow saving and loading of files (we're making a 'html editor' aka a few winforms controls and a little code) in two seconds, I showed him that it was literally all done for me. I just had to open a SaveFileDialog, prompt the user and read from the stream. Thanks for your help, I don't really use reddit but if the community are this HQ I will be here a bit more from now on! The answers here (especially yours if I am honest!) have helped me realize I should get off my ass and start.
&gt; Also, sizes should be size_t not int. &gt; &gt; Which sizes do you mean? here: (*u).dim = dim; (*u).vector = (int*) malloc(dim); read malloc documentation.
Do you like programming? Is it an inability to learn or is your passion elsewhere? What have you tried, what have you failed and why. Is this only for C? Try a higher level language? I could ask a million questions, and without more information there's no way to give a clear cut solution to your problem. When your exams are finished you can message me if you want for advice, however I refuse to do any "solve my homework" problems.
You don't assign the variable to anything; Basically, what you're doing is "47+3;" Try an assignment, like "exam[i] = exam[i] + 3;"
use grade[i] += 3; or grade[i] = grade[i]+3; 
&gt;Pure luck. But I mean seriously, I looped that shit 500 million times, no leak or anything, worked perfectly. Undefined behaviour is scary. &gt;Also, why not use a proper constructor? In C? What do you mean exactly?
Thanks that really helped. While you're here and if you dont mind could you help me with this issue on my other program. I am supposed to print the letter next to if its lowercase or uppercase. For some reason all the letter it prints it prints Upper next to it Heres a picture: http://prntscr.com/ausqck
Your problem lies within your if statement. Look at the logical operators ("||" and "&amp;&amp;" and "!")
C programmer for 25 years -- It's kind of cool... IMHO name clashes tend to be infrequent and not worth the "noise" these constructs create. My advice would be to just use a prefix that's unlikely to be used by somebody else. Also, it would probably be a good idea to run something like cscope -R on your project to see if cscope can figure it all out. I doubt it. Or gdb, even. 
We use his QP-C framework at work and so far I've found it to be very solid and well built. 
Pretty cool! It seems like a bit of a "one trick pony" to me (in that it seems like it would have limited use), but if it useful to you, then I say go for it. I would argue that if code compiles, then it's not considered abuse. The only abuse I think one should watch out for is for the abuse of any future programmers having to sift through some pieces of code to figure out wtf is going on haha
[Here](http://opensource.apple.com//source/tcl/tcl-10/tcl/compat/strtod.c) is one implementation. Is that what you're looking for?
Are you asking how to use it or how it's implemented? 
Superb!.... Thanks a lot for this valuable information.
Project Euler might suit your needs.
[How about these?](http://adriann.github.io/programming_problems.html)
I just posted the whole code with comments 
I'm using Ubutnu 64 bit, with gcc 
Thank you, I just made the first four exercises.
Yeah can recommend, the first challenges are pretty fun when learning a language. I did them when I was learning JavaScript and learned alot from them
Try cyberdojo :)
Indeed. Thanks for clarifying. There appears to be weirdness afoot that's getting beyond my ken. I think valgrind and gdb are about to become your new best friends in finding out what's happening while your program is running. After looking at the main body of your code the only thing I can suggest concerns the way you remove the newline from the name buffer. I'd suggest you not decrement provLen directly and only compare against `provLen-1`, and only change `name[provLen-1]` if both provLen is greater than zero and `name[provLen-1]` is in fact a newline. if ( provLen&gt;0 &amp;&amp; name[provLen-1]=='\n' ) name[provLen-1]='\0';
UVA online judged problems. I am on mobile so I can't link, but it has well over 1000 problems touching on a pretty good range of topics
I just started doing the task linked by /u/boarhog If you want we can compare them https://github.com/iwtlc/c_spp
I suggest Martyr 2's list of projects if you want something bigger to work and or don't want simple tasks. There's something there for everyone and it even categorised. http://www.dreamincode.net/forums/topic/78802-martyr2s-mega-project-ideas-list/
So in some cases the prefix is ""... That is a good motivation. Is there any reason to have both a mylib_strlen and a strlen (given a std c lib is linked in too?) IOW maybe just #if out the ones that are equivalent to std c routines if they're already present. 
IMHO, Project Euler is more a collection of math problems than a collection of programming problems. The actual programs needed to solve the problems are usually very short — too short to reflect real programming practices. 
&gt; char*d=upper,*s=lower;while(*d++=(~32)&amp;*s++); Because OP barely understands strings and arrays and presenting this isn't going to help him.
The key is here: pi = 3,141592653589793; C uses the American convention for decimals, so it should read "3.14...". The comma turns it into two assignments, one of which is thrown away. 
Fun fact: When SUN developed localization support for UNIX, they had a lot of trouble with their C compiler. The compiler used `strtod` to parse floating point numbers, but when the locale was set to something like `de_DE`, the `strtod` function would recognize `,` as a decimal separator and `.` as a thousand-separator, causing really interesting behaviour.
Never personally read it but it's listed as part of the definitive c book list, http://www.amazon.com/dp/0201604612/?tag=stackoverfl08-20
&gt; The comma turns it into two assignments, one of which is thrown away. Very close, but not quite. There's only one assignment here. To be more explicit, the code is the same as: (pi = 3), 141592653589793; The assignment on the left is performed, and the result (3) is discarded. The remainder is a NOP. It's very easy to put the parentheses in the wrong place and think it's supposed to be: pi = (3, 141592653589793); But the comma operator has the absolute lowest precedence of any operator, even assignment. And it would have to throw away the right operand instead of the left for that to work.
Some tools I use, like the excellent [LXR](http://lxr.sourceforge.net/en/index.php) source code indexer, would choke on this. It doesn't preprocess source code, and since `extern int __MYLIB_NAME(foo) (void *p);` doesn't look like a normal function definition, it wouldn't be recognized as such. Nor does `__MYLIB_NAME(foo)(NULL)` look like a normal function call. So LXR would probably be completely unable to index this code. LXR uses [ectags](http://ctags.sourceforge.net/) to parse the source code, which I'm pretty sure is used in other tools such as Emacs TAGS files, so it's not just one single thing that's going to choke on this. Broadly speaking, I don't see why it's necessary. Just come up with a prefix that's likely to be unique. Even if you're writing something like a JPEG library, what's wrong with calling it "jpeglib" or "libjpeg"? I can't really envision a scenario where a project would be using *two* things both called "libjpeg"... you'd expect to only need one or the other, right? Worst case, if someone does have a conflict, it's open-source so they can just find-and-replace. As long as you're consistent with your naming, that shouldn't be a problem for anyone who knows how to use a basic regex.
From http://man7.org/linux/man-pages/man3/errno.3.html: &gt; Its value is significant only when the return value of the call indicated an error (i.e., -1 from most system calls; -1 or NULL from most library functions); a function that succeeds *is* allowed to change `errno`. &gt; `errno` is never set to zero by any system call or library function. &gt; For some system calls and library functions (e.g., getpriority(2)), -1 is a valid return on success. In such cases, a successful return can be distinguished from an error return by setting `errno` to zero before the call, and then, if the call returns a status that indicates that an error may have occurred, checking to see if `errno` has a nonzero value. That answers most of your questions, I think. Compare and contrast Windows' [`GetLastError`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms679360.aspx), which serves a similar purpose to `errno`. Now, my company has a network stack that's designed to be embedded into small systems, including ones that don't even have a multitasking OS or any OS at all. So it doesn't use `errno` like this, because `errno` has to be thread-local and not all of these systems can do that. So instead, every API takes in `int* pErrno` in addition to the regular parameters you'd expect in a sockets API, and it's up to the caller to have their own variable for returning error codes through. Inside the library, some functions will declare a second error variable and use that to call other internal functions, but most places it just reuses the pointer that was passed in (since if one of the internal functions fails, the original call should fail, too).
A CSV file does not have to be created in Excel. Let's say you create a CSV file in a pain text editor, call it movies.CSV Title,Runtime,Rating terminator 2: judgement day,137,8.5 driving miss Daisy,100,7.4 In your program, you will have to open this file and parse it. For each line in file Get each field value Store each field value in a struct member You can parse a line of a file using fgets and strtok, or maybe scanf. 
Wow, I just realized I used size_t inside the struct, but had the function take an int instead. Thanks for pointing it out.
This is likely a problem with the libraries you are including in your project, not the C files or paths to header files. Are you including arm_cortex(Something)_math.lib? When you bring up options for the target, is your "Software Pack" set correctly? This is probably not a good question for C_Programming per se and maybe a better question for Keil tech support or Google.
The arm_cortex(Something)_math.lib wasn't included. Thanks a lot! 
Ok, so what's a csv? Comma Separated Values. Meaning, the values aka columns, are separated by commas! So take this for instance: Title, Runtime, Rating // field(column) names Movie1, 120, 7.6 Movie2, 155, 6.1 Movie3, 111, 8.8 if you saved that into a file with a csv extension, guess what? You now have a csv. Ok so you have a file and now you want to read that info into memory. What steps do you need to do to accomplish this? Well, you have to open the file first right? fopen? And then you have to read the contents somehow. Line by line is probably the easiest. fgets? And now hmm...we need to parse each line somehow into it's fields. So, we'll need a structure to hold that info and some way to to do that. Ok so we know the fields we have, we know (or have an idea) of roughly the max size each field should be, and we're ready to go! hmm struct movieData { int runtime ; float rating ; char name[56] ; } ; You can make the name field as large as you want really, or dynamically allocate memory and make it a pointer, but lets keep things simple. Ok, so we have our struct to parse the data into, lets declare and initialize it! struct movieData movie {0,0,{0}} ; We know how to open and read from the file. All we need to do now is figure out how to parse each line into our struct. Progress! I'll just mention fscanf, but we're not going to use that as it's more complicated. Also, if your csv file has the field names, you'll need to skip the first line before you start parsing the info. So, strtok is the function we'll use to parse this line. So fgets reads a line into a buffer that we supply it with. And then we pass that to strtok which will scan through it and parse it based on whatever tokens we want it to parse that line with. Which in this case will be the comma. char* token = strtok(lineToParse, ",") ; The first call to strtok, you need to pass in the line buffer, but any subsequent calls you just pass in NULL. Ok, so we know how to parse the line, but we still have to get it into our structure. Well for the movie title, we can just strcpy it into our structure. strcpy(movie.name, token) ; To read the 2nd value: token = strtok(NULL, ",") ; Now since our 2nd value is the runtime, we need to convert it to an int. Ahoy there atoi()! movie.runtime = atoi(token) ; Call strtok a final time: token = strtok(NULL, ",") ; And as rating is a float, we convert to a float: movie.rating = strtof(token, NULL) ; There are various caveats to these functions that you should read about as I can't be bothered explaining all that. That should give you a decent idea of what you need to do to get up and running. Have fun!
This kind of comment is inappropriate. Please don't be condescending. 
Just watch out for titles like "Matrix, The".
CSV files are "Comma Separated Value" text files, with each record separated by a newline. They are plain text. 
Well yes, boundary cases like this are important. But I say to keep things uncomplicated for OP at the moment.
[Yes it's actually not that hard](https://media.ccc.de/v/32c3-7331-the_exhaust_emissions_scandal_dieselgate#video&amp;t=1)
&gt; needing to instantiate multiple versions of the library If that's the case, the better solution is to rewrite the library to support multiple instances, each with its own context. Duplicating the code and variables with different names is not elegant or efficient, and wouldn't work if you need to support an unlimited number of instances. &gt; multiple versions Oh, *versions*. I just realized I misinterpreted what you meant. I was thinking just multiple instances of the same library. Yeah, I guess if you need multiple versions, it would make sense. That's a very rare usecase, though.
Embedded is hard, yo. Something smells fishy in your description. You're running on a big and fast enough platform to have a sockets network stack (as in TCP/IP or at least UDP), but you're having trouble allocating and freeing on the order of 9KB/sec? That doesn't make sense. The network stack alone can probably do one or even two orders of magnitude more work and not break a sweat. I have a hard time imagining a system that's big enough to have a network stack, but so slow that receiving 30 packets/second and doing some parsing on them is too much load. My money is on a bug in your code. With embedded systems, there's very little protection against errors like using freed memory or overrunning buffers. Often it can be invisible for a long time just due to the way things line up in memory or due to the size of requests, but then after working for several hours everything lines up right and you get a packet that's just the right size and *boom*. Whenever I see something like that in my work, and it's not immediately obvious why it broke, first thing I do is get a network packet capture, so I can see exactly what the device is receiving. If it's triggered by a packet that's larger or otherwise different than the other ones, hopefully you'll spot the different, and then you can trace through the code to see what happens differently. Buffer overflows are particularly insidious, because they may cause corruption that isn't noticed until much much later when a long-forgotten structure is accessed again. In our memory allocator, we have an option that we leave permanently enabled to add fenceposts around each malloced block of memory. A lot of buffer over/underflows are only by 4 bytes or less (size of an int), so even adding just 4 bytes can catch a lot of mistakes without sacrificing much memory. Larger fenceposts help if you have long structures, strings, binary data, etc. Just having the fencepost memory reserved will help prevent crashes, but if you write known values to the fenceposts (like 0xAAAAAAAA) and check that when it's freed, you can catch the error around the same time that it happened, or at least have a better idea of what caused it. I'm lucky that my hardware also has hardware breakpoints. If I can figure out what memory address is getting corrupted (assuming it's reproducible/predictable), I can set a breakpoint to halt in the debugger whenever that address is about to be written to. It doesn't always help, but I've definitely tracked down a bunch of memory corruption errors that way. *If* the problem really is that your memory allocator isn't up to this challenge — and I *really* doubt that's the case — then you'll have to figure out how to replace its algorithm. We had our allocator using a best-fit algorithm, but in certain workloads, it would cause a flurry of allocations that took a significant amount of time to process. In our case, that caused a problem because the peer system, having not heard a response to its request yet, would re-send the request, so now we have to process the original request *and* the retransmitted one. The system would fall further and further behind until it crashed or the peer system gave up talking to us. Currently we use the TLSF algorithm, which has a couple good open-source implementations to choose from, is not difficult to understand, and gives pretty good bounded performance.
I once spent a week tracking down a 40 byte memory leak in a wifi driver and in the process came to distrust any non-trivial dynamic memory allocation. I eventually made wrappers for malloc/free that tracked allocation and once I did the leak became obvious. Something like this: //dmalloc.h #define DEBUG_MALLOC extern uint32_t g_mem_malloc; #define dmalloc(size) _dmalloc(size,__FILE__,__FUNCTION__,__LINE__) #define dfree(ptr,size) _dfree(ptr,size,__FILE__,__FUNCTION__,__LINE__) void *_dmalloc(size_t size, char* file, char* fn, int line); void _dfree(void* ptr, size_t size, char* file, char* fn, int line); //dmalloc.c uint32_t g_mem_malloc; void *_dmalloc(size_t size, char* file, char* fn, int line) { #ifdef DEBUG_MALLOC g_mem_malloc += size; printf("malloc(total:%d) %d bytes @ %s:%s:%d\n", g_mem_malloc, size, file, fn, line); #endif return malloc(size); } void _dfree(void* ptr, size_t size, char* file, char* fn, int line) { #ifdef DEBUG_MALLOC g_mem_malloc -= size; printf("free(total:%d) %d bytes @ %s:%s:%d\n", g_mem_malloc, size, file, fn, line); #endif free(ptr); } The only downside is you need to track the size you allocate so you can pass it to free but it isn't that difficult to do and, in my opinion, makes the code easier to understand. That said, if you're sure there are no leaks it's probably just an overrun or null pointer dereference. There's probably a HardFault interrupt on your processor that you should set a breakpoint on, wait for the crash, and see where the crash originated.
Thank you so much for your extremely detailed response. First off, your first line made me laugh. &gt;My money is on a bug in your code. I would place my money here too and maybe the code that I rewrote today fixed (or quelled) my bad code, its impossible to tell. But I'm inbetween my program and the malloc/free funciton processing &gt; first thing I do is get a network packet capture I have have done this and it doesn't make my program crash, sadly. I've sat with wireshark for a couple hours constantly refreshing it to get the capture I needed. I ended up with about 2 minutes of network traffic which represented the state of the network before, during, and after the crash but I was not able to reproduce this based on that. &gt; Buffer overflows are particularly insidious AGREED &gt; we have an option that we leave permanently enabled to add fenceposts around each malloced block of memory Actually, funny you mention this, my co worker (a director here) has written his own program which hooks into other C/C++ programs to track down issues like this and he uses your fencing technique. This methodology has slightly helped as we have seen evidences of buffer overflows (missing fence posts) but have not been able to track their sources down. &gt; I can set a breakpoint to halt in the debugger whenever that address is about to be written to The best, in terms of debugging, I have been able to do has been getting gdbserver to work on the embedded environment and getting a client to attach to it across the network. However, I can seem to only be able to set a watch point to the values of a pointer, not if the pointer itself changes. *Do you maybe know differently?* &gt; If the problem really is that your memory allocator isn't up to this challenge I really dont think it is this, even if it is though, this is beyond the scope of what I could fix. But we have this allocator running on other environments without much issue, so I doubt its that. 
That's what I spent 5 hours today doing. I rewrote my management of these packets to allocate a pool of data on startup and now I only clear/copy memory to these locations. Currently in testing now...5 hours of run time :)
&gt;&gt; I can set a breakpoint to halt in the debugger whenever that address is about to be written to &gt; The best, in terms of debugging, I have been able to do has been getting gdbserver to work on the embedded environment and getting a client to attach to it across the network. However, I can seem to only be able to set a watch point to the values of a pointer, not if the pointer itself changes. Do you maybe know differently? Not really. This is a capability of the CPU I use; there are some hardware registers that control the breakpoints, and you just set them with appropriate values and let the processor run. They could be set by code if I wanted to, since they're just hardware registers, but the debugger (using JTAG) has a GUI window for setting them, which is what I use. Still, a watch value ought to do what you need. If you set a watch on a variable, it's checking whether the N bytes of storage for that variable ever change. That's all these hardware breakpoints do: "break if the data stored at address P is ever written to". I don't see why you couldn't construct a watch on an arbitrary address by just casting a pointer or something, but I don't know GDB nearly well enough to know how to do that.
1. It adds 2 to `arr` and dereferences the result to get an `int*` 2. It adds 3 to that `int*` and dereferences it to get an `int`.
Makes sense. Thanks.
&gt; http://lars-lab.jpl.nasa.gov/JPL_Coding_Standard_C.pdf This is actually REALLY interesting, thanks for this. All the better its from JPL. Especially if you read the explanation on page 5, it makes sense and I was in direct violation of this rule. I will likely maintain this in my career going forward.
`sprintf()` doesn't parse anything. Do you mean `scanf()`?
I don't have anything useful to contribute - but I had to say this thread taught me a lot of cool stuff quickly, so thanks. Thanks for having a tough problem and thanks for people with really insightful answers. Upvotes for all!
Also [Beej's Guide to Unix IPC](http://beej.us/guide/bgipc/) might help out a bit. Personally I don't think it's as good as the network guide, but you get what you pay for. ;)
Are you allowed to use shared memory as IPC? (ex mmap) I am trying to keep the pain to a minimum. EDIT: less awkward sentence structure
Easy enough to give your function a straightforward, descriptive name. void somelib_function(void); Now if you want to use it in another library, without exposing somelib_ as an external symbol, compile both libraries with `-Dsomelib_function=anotherlib_function`. C sources for somelib don't need to be rewritten, and all exported symbols begin with anotherlib_. The replacement list can be written in a makefile. 
I agree. Since the app is multi-threaded the crash could be happening in that function. And if that strlen() doesn't do him in, passing the uninitialized pointer to recv probably will.
Just to add, `sprintf` could be used to **create** this string. For example, you could have: char name[20] = "Mildred"; char gender = 'F'; int id = 18059; char curr[40] = ""; sprintf(curr, "%s,%c,%d", name, gender, id); And `scanf` is used to receive input from the user, so you could have printf("Enter the name, gender, and id separated by commas:\n&gt;"); scanf("%20[^,],%c,%d", name, &amp;gender, &amp;id);
Probably because you aren't copying the '\0' (NULL) character into upper so your strlen(upper) isn't calculating the length of the string correctly. strlen will keep traversing the string until it hits a 0. I think using strlen(lower) on every for loop would work (upper and lower will always have the same length). Or after the second for loop you should assign upper[j] = NULL or upper[j]='\0'. Also changing the second for loop to say &lt;= instead of &lt; should work. Also using the function toupper() instead of "- 32" on every character is probably the clearer way to solve the problem.
Note that the behaviour is different if `arr` would be of type `int[2][3]` or something like that.
There is also sscanf, which is for extracting things from strings. #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char buff[]="Mildred,F,18059"; char firstname[64], gender; int somevalue; printf("%s\n", buff); if (sscanf(buff,"%63[^,],%c,%i", firstname, &amp;gender, &amp;somevalue)==3) { printf("%s\n", firstname); printf("%c\n", gender); printf("%i\n", somevalue); } return 0; }
What I'm interested in would be how large the difference between branch and branchless for different microcontrollers is. I guess some of them don't even have branch prediction? 
ARMv7-A and ARMv8-A (the only ARM architectures I have any experience with) both have pretty good branch predictors
Check out documentation of feof function 
Thank you so much, I will take you up on your offer. And I don't want anyone to "solve my homework", I came to college to learn!!
&gt;And I don't want anyone to "solve my homework", I came to college to learn!! The true reason for seeking education... besides for getting a decent job of course. Anyway, once again if you had any questions, shoot me a PM, rather than by comment.
Your post got caught in our spam filter. I apologize for the inconvenience.
Sounds like someone has only used CSV as an Excel file format (like a lot of people I work with). 
1) What have you tried? 2) What was the result? 
Also, remember to null-terminate your strings. As a result, if you want an n-character array, it's customary to declare `char s[n+1]` to leave room for the null character. In your example, you'd want to declare `char s[21]` and set the character after the end of your string to `0` as appropriate. And, as this commenter points out, handling strings in C is not the same as handling string in other, higher-level languages, where you declare a string and fill it with an arbitrary amount of content. Those other languages have to do all this, but they hide it behind abstractions, where C makes/lets you do it yourself. Which is better depends on what you're trying to do. 
So in this case arr is passed in as int (*arr)[col_size], or a pointer to an array which have col_size ints. So the pointer arithmetic in this case is *(arr + 2*col_size + 3) and then dereferences. Is this correct? I guess I was getting confused and thought that \*(arr + 2 * col_size) would be dereferenced first, similar to how an int** would be treated.
Even if the original logic of the source code remained (and it will not be there in any useful form), variables, methods, functions with useful names are stripped down to possibly meaningless symbols. Machines don't get confused by terse code without indentation, but humans do. So if you are looking for a challenge / hobby, sure thing, try a [disassembler](http://www.heaventools.com/PE_Explorer_disassembler.htm) and [have at it](http://boomerang.sourceforge.net/). Don't expect it to make sense right off.
It's generally impossible to recover the original C program exactly, given that plenty of source-code information is lost during a typical compilation. The best you can do is create a C program that's functionally equivalent to the original C program -- i.e., it behaves the exact same way when compiled. From what I can tell, your professor wants you to create a functionally equivalent C program that matches the behavior of the .exe when compiled. Depending on how advanced the class is, this could mean... ... you're expected to play with the .exe, learn its behavior, and write a C program from that (hoping that your explorations have been thorough). ... you're expected to disassemble the .exe, study the assembly code, and write a C program from that.
Almost. Let's walk through the process of evaluating `arr[2][3]`. First, let's use the definition of `[]` to rewrite it to `*(*(arr + 2) + 3)`. Then evaluate: `arr` has type `int[2][3]` (array of 2 arrays of 3 integers). Since it's an operand to the `+` operator, it is (as usual) implicitly converted to a pointer to the first element of `arr` which has type `(*int)[3]` (pointer to array of 3 integers). Note that dereferencing a pointer to an array does not actually cause a pointer be dereferenced as the pointee (what the pointer points to) has type `int[3]` (array of 3 integer) which is yet again implicitly converted to a pointer to the first element, i.e. an `int*` (pointer to integer), which points to the same place as the original pointer of type `(*int)[3]`. See [this post](https://www.reddit.com/r/Cprog/comments/30szuc/arrays_in_c_are_weird/) for more details. Anyway, we increment the pointer to the first element of `arr` (remember, each element is an array of 3 integers) by 2 and then dereference this. The resulting pointer (after implicit conversion) is `2*sizeof(int[3])==6*sizeof(int)` bytes larger than a pointer to the first element of `arr` as each element of `arr` has type `int[3]` and thus size `sizeof(int[3])=3*sizeof(int)`. At this point, we have evaluated `*(arr + 2)`. Even though this explanation is slightly complex, so far, we have only added 12 (assuming `sizeof(int)==4`) to the pointer to the first element of `arr`. Next we add `3` to the pointer received in the previous step. As each array element has type `int`, each element has size `sizeof(int)`, which is usally 4. Thus, a total of 12 + 4 = 16 bytes have been added to the initial pointer so far. This pointer is then dereferenced to get the integer at that position.
The executable (the `.exe`) is just a file of binary machine code that your computer's processor can read, which is basically how it runs. The human-readable code (stuff like `printf("hello world\n");`) is from a separate file, which you feed into a compiler to end up with an executable. This is mostly known as **source code**, opposed to the **machine code** in an executable. You can open an executable in a text/hex editor and it'll just be a big garbled mess because most of the data is in a format that only a processor can understand. The hex editor would show everything accurately, but no human would be able to decode what any of it meant without spending *a lot* of time and effort reverse engineering it. So you can't get the human-readable source code from an executable unless the creator provides the source *along with* the executable.
Can we not down vote OP when they ask questions? It makes us look puerile and it puts other potential posters from posting.
I feel like your professor wants you to look at a program, and make your own to do exactly what the one he gave you does. I've done that.
&gt; and it puts other potential posters from posting. How is fewer questions like this a bad thing? It drowns out any potential for meaningful content on this sub.
Reading through this, I get the impression that the author is quite opinionated. I feel that most of this could just be replaced with a single sentence: "Think about what you're doing." Also, I'm not familiar with the debugging tool being used, but it seems to me that a lot of these 'errors' are merely warnings.
Who chooses what's meaningful? And if you're the one posting questions, how could you possibly know? I have a feeling we're arguing from similar positions. But, I don't like the idea we can't ask silly questions without being reprimanded.
I think you get what I mean.
So I've got the file, here's the link https://www.dropbox.com/s/ptvyhz46fbyh010/The%20exe%20file.exe?dl=0
I don't see what this proves.
What have you tried?
C strings always have an additional character at the end - the null terminator `'\0'` which signals the end of the string when you read through it. If your year has 4 digits, then you need 5 characters to store the string, even though `strlen()` will still report 4. This is because C strings don't have metadata attached, so they use their magic number to end rather than having a known length. You'll also find that `strcat()` and `strcpy()` don't reallocate memory for you (nor could they here), so while you could have enough memory initially, too much concatenation will overrun your memory bounds. If you needed to have strings which grow, you either have to allocate as much space as you could possibly need from the start, or look into using `malloc` and `realloc` in `stdlib.h`.
Do you mean an array of char pointers? A char** can only hold the address of a pointer to char. In other terms, it tells you where in memory the address of a char is. If you have a string, you have an array of chars. Each char has an address. You can create an array that stores the addresses of chars you want. The type of the array variable without the subscript is char**. I typically only use double pointers when I don't know what the address of something is going to be (Like when it could be on the stack or heap).
A [rough draft](https://gist.github.com/sam97/fdebfe821e512160dae3c1a772065f92) of a `splitter(str, tokens)` function that stores the splitted strings of `str` in `tokens`. Modify it to your needs.
Alright that makes sense. So how would I solve this? Don't I need to write to i+1 to create the extra pixels?
Allocate the memory before you write to it.
When you allocate the memory for row `i` allocate for `i+1` as well. Your loop is going 2 at a time, so you should allocate 2 at a time. Your other problem is accessing myPic-&gt;pixels[i][j]. But myPic has half as many rows and columns as myPicG. So you need some `/2`in there.
You'll have to brush up on pointers in order to do this. Something like this should work. double **matrix_function(double **matrix, long column_number, long row_number) { /* Do stuff. */ }
Since you only need to work on square matrices I'd make a `struct` containing a `size_t` and a `**double` (assuming you need your matrices to hold decimal values, otherwise use whatever you want). The `size_t` would be the dimension of your matrix while the `**double` could have memory allocated to it to contain your actual matrix data. This way you only have to pass pointers to your matrix `struct` which could save you some typing and headache. I recommend posting some code and the aforementioned errors, and we might be able to give you some more direct help, but with how general your question is I think you'll mostly only get general answers like mine. I hope this helps!
Incidentally, if a professor handed me some Windows executable to run at home, I'd tell him/her to go pound sand. Please tell me you have access to lab computers for this. Reasonable universities no longer have a home Windows install as a course requirement, recognizing that there are plenty of Mac, Linux, etc., users who may not want to mess around with VM images, emulators, etc. These universities also try to develop good security habits in their students. 
It's not that bad, except for all the code duplication happening.
Allocate a flat (one dimensional array) and do the index calculations manually: int *matrix = malloc(n * n * sizeof *matrix); printf(Element at %d/%d: %d\n", x, y, matrix[n * x + y]; To pass the array to a function, simply pass the pointer you allocated: int *matrix_function(int *matrix, size_t n); Remember to use `size_t` for array lengths and (if you like) indices. You can use the double pointer approach but it's more complicated to set up and slower. You do get easier syntax though.
Why is a double pointer suboptimal? Can you explain? With respect to accessing/modifying elements, what is the speed difference between a double pointer and a single pointer? 
If you allocated them like this would they be scattered over memory? matrix = malloc(number_of_rows * sizeof(double *)); for(i = 0; i &lt; number_of_rows; i++) { matrix[i] = malloc(number_of_columns * sizeof(double)); }
Here's an example of a function; this one for adding two square matrices: int **matadd(int n,int **A,int **B) { int i,j; static int C[n][n]; for (i = 0;i&lt;=n;i++) for (j = 0; j &lt; n; j++) C[i][j] = A[i][j] + B[i][j]; return C; } which returns errors: error: storage size of ‘C’ isn’t constant and when I tried to use it in main(), with C = matadd(n,A,B); more compile errors: incompatible types when assigning to type ‘int[(sizetype)(size)][(sizetype)(size)]’ from type ‘int **’ Now I don't care for the moment for optimality of code - I'll only be dealing with small matrices (up to about 10x10) - I just want something which works. I've never really mastered pointers (as is perhaps obvious); in fact the difficulty of dealing with them was what drove me away from C into easier (for me, anyway) languages.
Yes. There is no guarantee whatsoever how `malloc()` lays out the memory. It's likely that the memory area for each row ends up in a completely different place in memory. If you want to have the areas next to each other, try something like this: matrix = malloc(rows * sizeof *matrix); double *colbuf = malloc(rows * columns * sizeof *colbuf); for (i = 0; i &lt; rows; i++) matrix[i] = colbuf + i * rows; To free the matrix, do: free(matrix[0]); free(matrix); However, I recommend to use a flat array instead.
Thanks for the information. Do you know how great the speed difference is between the two methods?
Here's how I would do this: int *matadd(size_t n, int *A, int *B) { size_t i,j; int *C = malloc(n * n * sizeof *C); for (i = 0; i &lt; n; i++) for (j = 0; j &lt; n; j++) C[i * n + j] = A[i * n + j] + B[i * n + j]; return C; }
Thanks.
In fact - I've just realized that this is a simple and workable way of moving arrays in and out of a function in C. All tricky, though.
Thanks, and yes there are the 3 different types scattered throughout the array in a difficult to predict fashion.
Hm, that sucks. One possibility would be to have two arrays. One contains a `char` for every entry, describing what type the entry has. The other contains the data union. This saves memory, possibly at the expense of speed (but I don't think it's going to be slower).
Well, C11 has anyonymous substructures as far as I'm concerned. Go has them, too, and uses them everywhere in the standard library.
I have written 2 share-your-knowledge questions about this on StackOverflow: http://stackoverflow.com/questions/30023867/how-can-i-work-with-dynamically-allocated-arbitrary-dimensional-arrays http://stackoverflow.com/questions/30409991/use-a-dope-vector-to-access-arbitrary-axial-slices-of-a-multidimensional-array And the code has been reviewed here: http://codereview.stackexchange.com/questions/122038/ndarrays-in-c-slicing-transposing-polynomials
Most of it found its way into the book [21st Century C](http://www.amazon.com//dp/1491903899/). I really recommend it.
[Here is the mobile version of your link](https://amazon.com/gp/aw/d/1491903899?ie=UTF8&amp;qid=1415866438&amp;tag=as_mi_tl-20&amp;sr=1-1)
 **21st Century C: C Tips from the New School** |||| --:|:--|:-- Current|$40.43|Amazon (New) High|$45.97|Amazon (New) Low|$36.00|Amazon (New) |Average|$40.26|30 Day [Price History Chart and Sales Rank](http://i.imgur.com/5m7m9Vg.png) | [FAQ](http://www.reddit.com/r/PriceZombie/wiki/index) 
I can suspend disbelief long enough to hear a rationale for no dynamic libraries, the scripting bullet. I agree that everything can be a file, and that `malloc` should be avoided when possible. But shared mutable state and global variables are just bad practice. It's been tried, a lot. It is terrible.
What are anonymous substructures and where can I read about them in relation to Go
Look at the [specification](https://golang.org/ref/spec). Keywords: embedding interfaces, embedded field. Also read the chapter [Embedding](https://golang.org/doc/effective_go.html#embedding) in “Effective Go.”
Plan 9 doesn't use multi-threading (although they have threads for POSIX compliance). They prefer a model where every thread is a separate process that communicates over file descriptors. In such a model, it doesn't hurt having global state as every process does a single isolated thing. Global state reduces register traffic and makes some algorithms easier to understand.
So Plan9 conventionally uses less re-entrance (only for signals). It still uses re-entrance. In my experience, if a programming technique makes things you don't anticipate needing easier -- it is a good heuristic that the programming technique is a good one. &gt; and now you are scrambling to change every single call) This is a feature, not a bug. Functions should not lie about their interface to the world. A function whose interface changed ought to change. This is a good thing. &gt; and cumbersome as you need to add extra boilerplate to every function call It's not boilerplate -- it's actual, useful information about the function. &gt; Are you ever going to do that? Likely not. Not if you made it impossible in the first place. I don't anticipate needing to do that -- but a programming technique that allows me to, easily, is likely a better one.
People like you are the reason why UNIX has a shitload of features “somebody might need” but nobody uses. What you want is the antithesis of Plan 9's model.
how would global variables make an algorithm easier to understand? It's much easier to understand an algorithm if you know all of it's parameters,and what those parameters will result in.
That's nonsense. If it's an algorithm, you don't need any boilerplate code, and most certainly, if you need the locale, but the algorithm doesn't use it, there is some serious design issue there. If the result would need the locale to be complete, but not the algorithm, than your algorithm should return a function , with an arguments that's the locale. Boilerplate code comes because the used language is too simplistic or because the language is just shit. Higher-order function solve the majority of this. If you don't have global variables, you can prove that every function, one by one, performs it's duty correctly, and that they are deterministic. If you have global variables, if effectively have goto statements, not functions, your functions can return different results for the same arguments, how do you reason about that. I've been programming for quite a few years, and i have never seen any situation where global variables would make anything simpler to understand. A few years ago i did firmware programming, and yes, when all you have is 512 bytes of memory and your program has a simple, single task it's okay to use global variables, and frankly, you can even kindof keep track all of them , because of the limited memory,
what model router/firewall is router_s?
I think realloc is your best bet here; realloc just increases the size of the memory a pointer points to. I bezlieve for double pointers, you can first increase \*l and then \*\*l. You might also want to consider using strcat in the string.h library, for appending a string to your letter.
It's no recursion because it isn't calling itself inside its body. To be honest, I don't think there's any practicality on creating a recursive square function, because it's a O(1) operation. Are you sure you're not supposed to calculate the factorial instead? 
I think what it wants you to do is to recursively add one until the square is reached. But really, this assignment makes no sense. It really should have been the factorial of a number or something like that. 
this is incorrect, see below edit: or above maybe
k just delete it so no one else can see
You're assigning 2 characters to a, but there's no nul terminator. To be a proper C style string (usable with %s and strlen) there must be a nul character (value 0) at the end of it. Malloc makes no guarantees about the contents of the memory it returns (ie. the memory doesn't have to contain zeroes), therefore you must put the nul terminator there yourself You need a[2]='\0' Secondly, although not the cause of any immediate problem a = (char*)malloc(2*sizeof(char*)); the `sizeof(char*)` need only be `sizeof(char)`. And now you need 3 of them, not 2, to account for the nul you need to append
No, if you ask for 0 bytes it will give you 0 bytes (or fail, it's up to the library) The compiler doesn't know you're going to try and stuff 3 bytes in there. If you do write past the end of the buffer you've been given then the results are undefined. You got unlucky and saw somewhat sensible behaviour. 
ooooh thank you very much for your answers and time man, it really cleared the clouds on my mind
You are also allocating more than 2 char worth of memory. You want a=malloc(2*sizeof(char));
Also, you do not need to cast the result of malloc. 
You can use a debugger and look at the call trace. For gcc/gdb, the command you're looking for is 'bt' ( short for backtrace).
Use a tabbed text editor to flip through files without getting lost 
You may want to look at reading a file line by line using fgets. You can use fscanf but fgets offers more flexibility and I think it's much much more common in real code. Each line (except the first which has the header) will be stored in a character buffer that you point to using fgets. You then would want to check the first character of your buffer for '-' (indicating -1) to see if you are done. If not you'll extract each element out of the buffer (from fgets) into a struct that you'd allocate with each iteration of the loop. You would then store the pointer to the allocated structure in an array. By doing that you're constructing a dynamic array (a vector in C++). You can use tools like strtol to extract numerical values out a string buffer and strncpy/snprintf to extract string values out of the fgets buffer.
Wrong. If you do it right. The header file basically serves as header and implementation and contains both. By default it only includes the declaration, and if you define some special macro it includes the definition (which you do in only one file of your project). I have a 25k lines header file I carry around with me, with a lot of commonly used code. Using this exact technique. 
Your post got caught in our spam filter. I'm sorry for your inconvenience. Could you tell me what the picture is supposed to mean with respect to your question?
&gt; par[] = {'b', 'b', 'b', 'b', 'b', '\0'}; What type is `par` supposed to have? You need to put the type in front, like this: char par[] = {'b', 'b', 'b', 'b', 'b', '\0'}; Note that you can use a shorthand for this: char par[] = "bbbbb";
With your suggestion I get: "error: ‘par’ redeclared as different kind of symbol". I pass it as a parameter so I cannot redeclare it in the function.
Ah, I see. Sorry, I misunderstood your code. Sadly, in C you cannot assign to arrays. You can only assign to their elements. If you want to set an entire array, you either have to set each element individually: par[0] = 'b'; par[1] = 'b'; ... par[5] = 'b'; par[6] = '\0'; or use one of the copy functions `memcpy()`: memcpy(par, "bbbbb", 6); and `strcpy()`: strcpy(par, "bbbbb"); or write your own variant of `memcpy` or `strcpy`. In your particular case, you could also use `memset()`: memset(par, 'b', 5); par[6] = '\0';
I found [this page](https://en.wikibooks.org/wiki/Data_Structures/Tradeoffs) somewhat arbitrarily, but the first table is all that I've verified. Notably, a linked list has a faster insertion and deletion than many other data structures, but is very easy to implement.
Yes. It works on GCC 4.92
&gt; C99 or not. I'm going to assume it does not, because my professor is really old-school. 1999 was 17 years ago. That *is* really old school! If the data is too big for memory, then read it in from a file.
That's a good suggestion, but perhaps I should have mentioned that the reason why Initialize() needs to be called at all is because many of the array elements are dependent upon a variable, *H*, that can be changed during execution by the user, via the UI. :/
It's effectively a `char*`, just like `par` effectively is when used as an argument to a function...
isdigit can tell you if an ascii character is within 0-9, so an if statement with that works. Checking non-negativity is simple by checking if a number is greater than zero. 
&gt; Essentially, I would have to declare and initialize a new array, and then copy it over to the array I actually want to initialize. Couldn't you just copy from a const static array? Depending on your compiler [compund literals](https://gcc.gnu.org/onlinedocs/gcc/Compound-Literals.html#Compound-Literals) might do the trick.
I suggest you "The C Programming Language 2nd Edition"! It is not very large reading material, BUT it is very dense and you must read and understand every single line. There you will be introduced to most of basic functions, how and why are they written and when should you use them. Even though, today, real C coding is a little bit different than in this book, you must understand concepts and basics that led to writing specific functions. You will see how simple C is, it just bunch of functions that are glued together in header files and libs, which you include in program and use them. As I said, after reading the book everything will unwrap and make much more sense.
Thank you. I'll be reading this and hope to get a clear understanding. I already have a pdf on Absolute Beginners Guide to C Programming. Is this the same book you're referring to? :)
And why would you want to do that? Also, I have provided a way that neither uses standard library functions (no builtin functions in C!) nor “reinvents them” (whatever that means).
scanf() has a return value. If it fails to convert, it will let you know that. If that happens, you need to find some way to consume the bad input - scanf will leave it sitting there until you clear it out somehow. Your job now is to figure out how to do that, and what scanf() returns. The man page for scanf may be helpful.
Nope. Don't know if links are allowed here, but I gave you exact naming of the book under the quotes. It is written by Dennis Ritchie and Brian Kernighan, so google it and you can't go wrong. You can find online some pdfs, although I think every programmer should own this book at least to have it sitting on the shelf. :)
&gt; The value of a pointer becomes indeterminate when the object it points to (or just past) reaches the end of its lifetime. Does freeing an object "poison" all pointers to it? Dereferencing is out of the question, but comparison should still work, right? e: LLVMs scan-build doesn't report a problem for the given example.
No, comparison is not allowed. If a pointer is dangling, you cannot access it in any way. You can't compare it, cast its value as an integer, dereference it, test it as a boolean, etc. Any access is invalid. The same rules apply for uninitialized pointers. 
Thanks a lot.
You might be looking for [`fseek()`](http://linux.die.net/man/3/fseek)
I think if you really wanted to you could save a copy of the old pointer in the form of a `uintptr_t` and then cast the new return value after `realloc()` to `uintptr_t` and compare the two. This gets around the dangling pointer issue, and an optimizing compiler would probably see what you were trying to do and avoid storing the copy. Of course it's not a 100% solution since the ability to cast a pointer to an int and get a meaningful value is not guaranteed, only implementation-dependent. But that conveniently acts as an escape valve for all the weirdo segmented architectures and whatnot that the original issue was designed to avoid, and on all modern systems that matter, converting a pointer to an appropriately sized integer type ought to have solid semantics. 
C11 7.22.3: &gt; If the size of the space requested is zero, the behavior is implementation defined: either a null pointer is returned, or the behavior is as if the size were some nonzero value, except that the returned pointer shall not be used to access an object. 
`fgets` gets the whole line from the stream/file, including the \\n (if it can), and stores the characters in the buffer array described in the first `fgets` argument. The buffer array needs to be large enough for the whole line too. The second `fgets` argument is for the maximum size of the buffer array (sizeof is handy here). To extract separate fields from the buffer array look in to the `sscanf` or the `strtok` functions. e.g. char line[256]; fgets(line, 256, fp); or fgets(line, sizeof(line), fp);
What part are you stuck with? Perhaps we can help you.
The problem is that many elements of the array are dependent upon a variable, *H*, which can be changed by the user in the UI, during execution. So the array literally needs to be recalculated every time *Initialize()* is called.
Wait, if you can calculate the array at runtime, why don't you just overwrite it with the newly calculated values?
I don't understand your question anymore. In the beginning you claim that there is no formula to compute the array entries but now you claim that you have to recompute the array for every `Initialize()` call. How are you supposed to compute the entries it if there is no way to do that?
Let your program remember how many names it already saw, let's call this variable `name_count`. Then your code becomes: int name_found = 0; for (i = 0; i &lt; name_count; i++) { if (name[i] is the name you want to add) { name_found = 1; break; } } if (!name_found) { add the new name to the file; } Is this helpful? 
Declare `ramdisk` as `volatile` and use `mmap()`. Basically, your program is going to look like this: /* somewhere on the top level */ volatile int *ramdisk; /* in some function */ int fd = open("ramdisk_file", O_RDWR); int pid = fork(); if (pid == 0) { /* this code runs if we are the child */ /* pass fd to dvs in some way */ execl("dvs", "dvs", "-shmfd", int_to_string(fd), NULL); } char *shm = mmap(NULL, 256, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); ramdisk = shm; Now in `dvs-programmer`, you do this: /* on top level */ volatile const int *ramdisk; int fd = get_fd_from_arguments(); char *shm = mmap(NULL, 256, PROT_READ, MAP_SHARED, fd, 0); ramdisk = shm; In this code, I left out all the error handling. It's your job to add it.
__TL;DR__: `l` is in local scope and is popped from the stack once `append(Listint, int)` exits. This is to do with the scope of `l` compared to the scope of what you are passing in. You are wanting to pass-by-reference, but instead you are passing by value. You should think about what is actually being operated on; if you were wanting to modify what `*l` then this would be fine. Here you are attempting to modify `l` itself but the results are lost^1 when the function exits because `l` is simply a copy of whatever you passed in. To modify `l` itself you must tell the function _where_ `l` resides; thus a pointer-to-a-pointer. * * * ^(1)This is actually leading to a memory leak but I assume you realise this because you're asking this question. 
Remember: in C, function arguments are local variables and everything is passed by value in C. The original code appends to the list's tail by modifying its `.next` member (which is a listint*). So it takes, as an argument, a pointer to it (`listint**`) to work on. It follows the list till the end then modifies the last element. Passing the next item by value wouldn't work. If you call `append()` with a pointer to an empty list (i.e. `Listint∗ l= NULL`) it creates the new element and dereferences `l` to change the original list pointer to point to that new element. Pointers are just variables, only they're dedicated to contain memory addresses. So if you want a function to change the memory address stored in a pointer called `p` you need to pass `*p` to that function. pay attention to this statement: return append(&amp;((∗l)−&gt;next), elem ); it takes the address of the elements `.next` member recursively processes it. if it was to take its value, the next recursion wouldn't be able to modify the passed element. It would only modify its local copy of this element and leaves the original element untouched (it doesn't even know about it). So, no.. your proposed change wouldn't work. For example, see this: if (l==NULL) { l = (Listint) malloc(sizeof(struct listint )); ... It changes the local variable `l` which has no effect on the passed pointer. All it does is allocate memory to a variable that's about to be lost after the function returns, making it impossible to free. The original code is, i think, a neat example of double pointer indirection. It saves you the trouble of making more tests in your function and makes it simpler and more concise.
I can do that, but it would require hundreds of lines to go through and change every single element. What I want is to be able to write the new array in bracket notation, which would allow me to condense my code down to a few lines, and make it vastly more readable.
What I'm saying is that I don't want to have to go through and write a line recomputing every single element in the array, line-by-line. That would take hundreds of lines, and make the code completely unreadable. I want to be able to reinitialize the array in *bracket* notation, which would reduce the number of required lines to a much smaller number, and make the code vastly more readable.
&gt; When the router is performing NATing operations, the incoming packet from the WAN is opened and only the "destination IP address" field is changed, This is probably what you *want* to happen, but for some reason, Router_S is performing source NAT on inbound packets (assuming SERVER isn't doing something weird). There are quite a few scenarios in which such rewrites can be useful. In any event, it's not a problem with your C program.
It'd be great if the next version of the Standard explicitly stated the behaviour for the 85 cases in their survey (and others); instead of providing some general text and expecting the behaviour to be deduced from the wording, which practice has shown leads to a lot of unclarity and debate. 
The official zlib implementation [does a wide string match that sometimes reads uninitialized bytes](http://www.zlib.net/zlib_faq.html#faq36) as part of a comparison. The result of the comparison doesn't effect the output. It's an annoyance when Valgrind isn't configured to ignore it.
&gt; The official zlib implementation does a wide string match that sometimes reads uninitialized bytes as part of a comparison. **The result of the comparison doesn't effect the output.** In ISO C reading uninitialized bytes leads to undefined behaviour; e.g. an optimization pass might remove the comparison entirely (or some larger chunk of code containing the comparison). This is one of the cases that the N2012 paper is surveying. (What do current compilers do, what do people expect, etc.). Their current recommendation appears to be to change it to unspecified behaviour, if the type is known to not have trap representations. I presume the algorithm in use is something like "if the comparison is equal, infer that the valid bytes were equal; otherwise fall back to comparing just the valid bytes". But even in that case, undefined behaviour means that the comparison could appear to be equal even when the valid bytes differed. 
Not really related; there the `const` applies to the pointed-to memory, but this thread is talking about the pointer itself. 
&gt;I think if you really wanted to you could save a copy of the old pointer in the form of a uintptr_t and then cast the new return value after realloc() to uintptr_t and compare the two. The recommended semantics under "Pointer provenance via integer types" in [N2012](http://www.open-std.org/JTC1/SC22/WG14/www/docs/n2012.htm#pointer-provenance-via-integer-types) suggests that behaviour of `uintptr_t` obtained by casting a pointer should retain the same provenance of the original pointer. Their survey also explicitly mentions the case of `realloc`ing a block containing pointers to itself, and trying to adjust the pointers if the allocation moved; although the main paper doesn't appear to explicitly address that topic. 
The point of the discussion is that free() invalidates the pointer, not the memory it points to, making all other copies of the pointer dangling and invalid (hence why it's related). Since it doesn't affect the pointed-to memory, it's not subverting the const.
You can, but that's not how this subreddit generally works. Plus linkedlists + pointers is very boilerplate code, I don't think plagiarizing that is something you would have to worry about.
Don't think you need to go that far. Post/PM your code.
It immediately decays into a char\* when passed to the function. arr and &amp;arr are for all practical purposes the same thing when used as a value type.
&gt;The problem is that many elements of the array are dependent upon a variable, H In C89 this means you cannot used braced initialization at all. Initializers inside braces must be computed at compile-time. C99 relaxed this requirement. In C99 you can write: void Initialize(Arr *p) { Arr const new = { {H, H + 1, H + 2, // ...... memcpy(p, &amp;new, sizeof *p); } In theory, the compiler can optimize `new` out and assign the values directly into the argument array. Perhaps you could test to see whether the compiler you're using actually does this. (Use whatever optimization flag you plan to use in the real code). ---- I tested with recent versions of gcc and clang. gcc actually did perform this optimization when I used compound literal assignment, but not with named variable. clang didn't do it in either case. To use compound literal assignment you'd need to wrap your array in a struct.
If only there was a function to **remove** a file...
&gt;In C89 this means you cannot used braced initialization at all. Initializers inside braces must be computed at compile-time. Why is this a problem? Here is an example of what I want to do. x = { {1., 1., 1.}, {0., sqrt(1/H), -sqrt(1/H)}, {-1/sqrt(1/H/D-1), sqrt(1/H/D-1), sqrt(1/H/D-1)} }; &gt;In C99 you can write The code you just posted looks completely compatible with C89. Isn't it?
`char(*)[6]` is a pointer type. Pointer types don't decay. Only array types decay. `arr` and `&amp;arr` have different types and are not interchangeable; OP's code contains a constraint violation. 
 #include &lt;stdio.h&gt; int main(void) { int foo[3] = {1, 2, 3}; printf("%p\n", foo); printf("%p\n", &amp;foo); return 0; } These don't print out the same value for you? The address of an array and the array by itself become the same thing in contexts like being passed to a function. They're interchangeable for all practical purposes in such situations. 
Sigh. Yes, they're different types. But it makes no difference because they can be used the same way and turn into the same thing. That's why I use qualifying terms like effectively.
Two problems here: 1. `number` might not be set to `0` when reading fails. 2. If reading fails due to the input not being a number; then the second read will also fail for the same reason. To solve these problems: 1. Check the return value of `scanf` to see whether it succeeded or not 2. Flush the input before trying the next read Sample code: if ( 1 != scanf("%d", &amp;number) ) { flush_input(); printf("Enter a valid number&gt; "); scanf("%d", &amp;column); } where you also have a function: void flush_input() { int ch; while ( (ch = getchar()) != '\n' &amp;&amp; ch != EOF ) {} } This code probably doesn't solve all your problems though: you'll want to check whether inputting `column` succeeded, and you want to make sure your code doesn't go onto use the value of `number` in the failure case. 
This subreddit is not about C++. Please don't post C++-Jobs here.
In C89, you can't do that.
&gt;C doesn't support that. Really? I have it on good authority that one of my fellow classmates successfully compiled the following code, with *T0* being a double variable. double m[5][5] = { {1., 1., 1., 1., 1.}, {0., sqrt(1/T0), -sqrt(1/T0), 0., 0.}, {0., 0., 0., sqrt(1/T0), -sqrt(1/T0)}, {0., sqrt(1/(2*T0)), sqrt(1/(2*T0)), -sqrt(1/(2*T0)), -sqrt(1/(2*T0))}, {-sqrt((2*T0)/(1-2*T0)), sqrt((1-2*T0)/(2*T0)), sqrt((1-2*T0)/(2*T0)), sqrt((1-2*T0)/(2*T0)), sqrt((1-2*T0)/(2*T0))} };
The `#define` lines are called "#define directives". These directives define a *macro*. The first token after the word `define` is the macro, and the stuff after that is the replacement text.
You're only partially right. You cannot say that reading uninitialized memory of automatic variables is undefined behavior, the different C standards have different opinions on that. The values have indeterminate values, that's defined by every standard. While ISO C90 defines accessing these as undefined behavior, ISO C99 and newer say that an indeterminate value is &gt; either an unspecified value or a trap representation and defines an unspecified value as a &gt; valid value of the relevant type where this International Standard imposes no requirements on which value is chosen in any instance It might not be the behavior you expect, or want, but it's well defined. What compilers think about using an indeterminate value is also something completely different. With the ISO C99 rules in place, you can always access an indeterminate `unsigned char` variable value, since `unsigned char` is defined to never have trap representations. **tl;dr:** While it's technically not undefined behavior in all standards, avoid accessing uninitialized variables. [*See my answer below for a more in depth explanation with examples*](https://www.reddit.com/r/C_Programming/comments/4ggrda/using_uninitialized_memory_for_fun_and_profit/d2i09if)
Thanks for clearing this up. I'm unsure about this because the standard seems to contradict itself. For example, Annex J claims that using the content of the buffer returned by `malloc()` is undefined behaviour, but as you say it clearly isn't.
Yes, that's possible but how you do it depends on the operating system. What system are you programming for?
There should be no contradiction. What I said only applies to variables with automatic storage duration, the buffer contents returned by `malloc()` clearly do not have automatic storage duration.
You should have said that! But where is the language that says that accessing the content of the buffer returned by `malloc()` is undefined behaviour? Remember, Annex J is informative, not nominative, thus the apparent contradiction. Actually, accessing the content of uninitialized automatic variables is undefined behaviour as per ISO 9899:2011 §6.3.2.1 #3: &gt; (...) If the lvalue designates an object of automatic storage duration that could have been declared with the `register` storage class (never had its address taken), and that object is uninitialized (not declared with an initializer and no assignment to it has been performed prior to use), the behavior is undefined. But as you said, allocated storage is not automatic storage.
Nethack has animations. eg. flying projectiles and explosions. Dunno how they do that, though.
Nope. It's still not undefined behavior. Accessing the contents of an uninitialized variable with automatic storage duration does not invoke undefined behavior. While, yes, accessing it directly does invoke undefined behavior (your quoted paragraph of the standard is absolutely correct). int x, y; y = x; /* undefined behavior */ Accessing it inderectly through a pointer, does not invoke undefined behavior: unsigned char x, y; memcpy(&amp;y, &amp;x, 1); /* perfectly legal */ printf("%d\n", y); /* perfectly legal */ Since `unsigned char` can, according to the standard, never have trap representation, this example above is legal in all cases. Regarding `malloc()`, I never said it's undefined behavior. You said that, and I haven't checked if it's true what you said. ANSI C89 §7.22.3.4 / ISO C99 §7.20.3.3 &gt; The malloc function allocates space for an object whose size is specified by size and whose value is indeterminate. Which means the same rules apply as they apply for automatic variables, accessing them in C89/C90 is undefined behavior, accessing them in C99 or is well defined (but might have trap representation).
Yes, I do.
Keep in mind that your school programs may not be tested on windows. If you want to include any fancy stuff in your assignments either ask what platform will be used for testing (including asking the TA if applicable) or make use of \#ifdef so that your code is cross platform. 
No, it doesn't. Reading uninitialized values is only undefined under very narrow circumstances. In general, it is not undefined!
If you want to see really fun stuff take look at [Text Mode Demo Competition](http://tmdc.scene.org), by following the links you should be able to find some of the sources. [Hedelmae - Carbon Tetroxide](http://youtu.be/w6_C5IIeh28) is pretty cool. Any advanced techniques will require moving the cursor [SetConsoleCursorPosition](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686025.aspx) and changing the color of cursor [SetConsoleTextAttribute](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686047.aspx). Note, that on Linux you need to use ANSI escape codes. Either way the basic idea is that you create a colored character bitmap (a two dimensional array of structs, where each struct contains the character, foreground and background color). Then you draw onto that bitmap and later write that content to the console; depending what features you have available. For animations, redraw with something changed every 30ms.
I have used some interesting preprocessor hacks in production code. Let's say I want to be able to determine between two different types of peripherals, UARTs or USARTs. They have similar APIs. And I want to be able to choose specific UART or UART numbers at build time. This is going to be compiled into code that includes interrupt handlers, so I don't want to do any run-time branching to select for peripheral type or peripheral number at run-time at all. First, some constants: #define SERIAL_PERIPHERAL_TYPE_UART ( 101 ) #define SERIAL_PERIPHERAL_TYPE_USART ( 201 ) #define SERIAL_PERIPHERAL_UART0 ( 1001 ) #define SERIAL_PERIPHERAL_UART1 ( 1002 ) #define SERIAL_PERIPHERAL_USART0 ( 2001 ) #define SERIAL_PERIPHERAL_USART1 ( 2002 ) Then code that determines what to do according to the value of SERIAL_PERIPHERAL, which is set differently for different code modules in the same program. (For example, communicate with one device on UART0, another device on USART1, etc., which can vary depending on what hardware board I'm building for). #ifndef SERIAL_PERIPHERAL #error "SERIAL_PERIPHERAL must be defined before including this file" #elif ( SERIAL_PERIPHERAL == SERIAL_PERIPHERAL_UART0 ) #define SERIAL_PERIPHERAL_TYPE SERIAL_PERIPHERAL_TYPE_UART #define UARTN 0 Then, code that does something with that build configuration: #if ( SERIAL_PERIPHERAL_TYPE == SERIAL_PERIPHERAL_TYPE_UART ) /* We want to generate a token UART0 or UART1 from a parameter. If we just do something like #define MAKE_PERIPH_TOKEN(UARTN) UART##UARTN the token generated by #define UARTN 0 MAKE_PERIPH_TOKEN(UARTN) is literally "UARTUARTN" (UARTN has not been evaluated). To force the evaluation we need to trigger another preprocessing pass using another macro function. To make it so we can add a parameter we use a _third_ pass. */ #define MAKE_PERIPH_TOKEN() MAKE_PERIPH_TOKEN_1(UARTN) #define MAKE_PERIPH_TOKEN_1(UARTN) MAKE_PERIPH_TOKEN_2(UARTN) #define MAKE_PERIPH_TOKEN_2(UARTN_EVALUATED) UART##UARTN_EVALUATED (...) Then further down: #define SERIAL_RECEIVED_CHAR ( ( ( MAKE_PERIPH_TOKEN()-&gt;UART_RHR ) &amp; UART_RHR_RXCHR_Msk ) &gt;&gt; UART_RHR_RXCHR_Pos ) #define SERIAL_TRANSMIT_CHAR(char_out) do { MAKE_PERIPH_TOKEN()-&gt;UART_THR = UART_THR_TXCHR( char_out ); } while ( 0 ) The token-pasting trick is helpful here. The key is to make sure you document what you are doing for the maintainer (which might be you). Also, if you are going to debug stuff like this it is imperative that you have a way of generating preprocessor output to examine before it gets to the compiler. Most toolchains have a way to do this. There's a second trick in there I use a lot, which is a do { ... } while ( 0 ). This is _the only_ clean way to create a macro that can be used in any code context where a statement can be used. This trick and the reason for it is explained here: https://gcc.gnu.org/onlinedocs/cpp/Swallowing-the-Semicolon.html I have been programming in C and C++ for decades and sometimes still come across new preprocessor tricks. If they really help I will steal them. Just use them with taste, caution, and plenty of "bread crumbs" in the comments. The only big problem I've come across is trying to work with other consultants who are much younger and come from a Java or C# background and haven't read or written a lot of production C code. They tend to lose their minds when reading what to me is a pretty common sort of C hack.
Yes. Binary search only works with sorted arrays.
Okay thanks :) I keep mixing up linear and binary. XD
`bb(6)` is a good example for the libaa.
The beep comes from printing the bell character to standard output. You can do it with `printf("\a")` (either in a C program or even probably in cmd.exe).
[See here for full discussion](http://stackoverflow.com/questions/25074180/is-aa-or-a-a-undefined-behaviour-if-a-is-not-initialized) There are narrow circumstances under which is *is defined* to do the read. But even in that case, passing the results of the read to library functions causes undefined behaviour ([DR451](http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_451.htm) - note that it introduces the problem in the context of automatic variables, but the same results would apply to all indeterminate values)
If true, your fellow student is not using a compiler in strict C89 mode 
You made a mistake somewhere
Interesting. I wonder if maybe our compiler is really C99.
Maybe find out what its name and version are. Many C89 compilers had a range of non-standard extensions.
Two things about this line: strncpy(pkg,argv[1],sizeof(argv[1])); 1. `sizeof(argv[1])` doesn't do what you think it does. 2. WIth strncpy you want the size to be the known size of the buffer, not the unknown size of the (untrusted) user input.
I think you want `-O` for curl, not `-0`
e.g. sizeof(pkg) or just 64? eh?
And after strncpy you must do pkg[63]='\0' because strncpy will not nul terminate the destination if source is longer than len. strncpy is a terrible function.
Do compilers optimize structs now days? When I learned C just a few years ago they still went over padding and alignment. I was under the impression that C you still did it manually. But is there no compiler flag to have it automatically optimized
What's a better alternative/method to strncpy() ? / whatever I code, I make an attempt at secure coding ops.
[`strlcpy`](http://man.openbsd.org/?query=strlcpy&amp;apropos=0&amp;sec=0&amp;arch=default&amp;manpath=OpenBSD-current) is, IMO, a *much, much* more sensible alternative. Unfortunately it's not standard, and not part of glibc, because, reasons.
I work in embedded programming. This is my every day!
In the C99 standard and onward "an unnamed bit-field structure member is useful for padding to conform to externally imposed layouts" avoiding the pad1, pad2, pad3 convention and making members and padding clear. 
There are only compiler specifics builtins. They are not meant to be interoperable with other compilers and should be used with caution. So yes, it can be automatized, however you have to know what your are doing and where your code will be used.
Try to answer questions here and on Stack Overflow and you are going to find that no beginner ever reads the manual. However, the manual is the single place where you can get answers to all your beginner questions. It is annoying to always answer the same questions when there is an extremely detailed answer to these questions in the manual. Thus the response is “RTFM.” If the beginner doesn't know about the manual, that's the right time to find out that there is a manual. If the beginner does, why is he asking this question? Also, we live in an age where you can plug all but the strangest beginner questions into Google and get an instant answer. Don't waste my time just because you are unable to use Google. Don't be lazy! Do your own research! Asking a question should be one of the last steps you take when you really can't find an answer either on your own or in the manual or on the internet. Another huge problem is the inability of people to write coherent questions. I understand that it is difficult to ask a good question (which is why Stack Overflow has a [how to ask](http://stackoverflow.com/help/how-to-ask) page) but from my experience many beginners ask on Stack Overflow like this: 1. If you have any, post an unindented chunk of code, don't put four blanks in front so it looks all fucked up. Make sure the code is only tangentially related to the problem you. Make sure to leave out the part that actually causes the issue you have. Be careful not take a single glance at the formatting help lest your code could actually be readable. Ignore the life-preview and throw in some BB-tags (e.g. `[code]int main();[/code]`) for good measure. 2. If you don't have any code, no problem. Pretend you have some and repeatedly claim that you can't show it to us. Act all flustered when we tell you that we need to see your code to diagnose problems with it. 3. If step 1 still doesn't cause adequate results, make a screenshot of your code and post that instead so there is no way anybody could test your code without typing it in all again. 2. Add some vague text, preferably “it doesn't work.” Don't tell us what you tried to do or what the actual problem is, just throw in some buzzword sentences that give absolutely no further context, like “I tried this for hours now and it and binary search still doesn't work. Is this because I used the pointer method?” Try to make sure that the text doesn't make any sense: “string can't print with pointer.” 3. Add a completely useless title, make sure to mention the word advanced despite an answer to your question appearing before chapter 4 in any decent programming book: “Advanced pointer problem.” 4. Even though your question is about C, tag as [c], [c++], [java], and [python]. It's about a program and all these are programming languages, so it can't hurt to add these tags. 5. Be careful not to specify at all what operating system you are programming for. Don't show any sample input/output either. It must be as hard as possible to actually reproduce your problem. 6. Make sure your post doesn't actually contain a single question. If you can't help it, leave the question implied (and for us to guess what you want) but under no circumstances there should be a single sentence ending in a question mark. 4. Hit “submit” and then immediately go on a three hour walk. Don't bother responding to any follow-up questions. 5. Three hours later, come back to a question closed as “unclear what you are asking.” Ignore all the follow-up questions and act confused and angry. 6. Make a new account (because the old one is obviously burned now). 7. Goto step 1 with the same question. 8. Optionally feel confused and angry when someone recognizes the question and links back to the original, asking “could you try to answer the follow-up questions?” 9. Make a post on reddit sharing your experience with Stack Overflow. Make sure to repeatedly exclaim how hostile and unhelpful they are. And that all the users are fascists who just love to close every single beginner question. Make sure not to link your Stack Overflow profile lest people could actually tell you why you had that experience. 10. ... 11. Profit?
You forgot to mention the people that do not speak very good english, which even if you try your hardest to help them, you cannot understand neither what they are asking or what they problem is.
I don't think you made a virus. If you could show us your entire problem, I could try to find out what the issue is. Note that anti-virus software frequently complains when you compile programs. To the anti-virus the compiler is suspicious as it creates new programs out of thin air, which is something viruses do, too.
Yeah, I though it's basic knowledge for C programmers tho.
Thanks to you!
I see a lot of the same behaviors here as I did when teaching system software in a University class. All semester, I'd tell the students that it was important that they understand a few simple concepts. I'd make ungraded quizzes on those concepts. I'd hand out study guides outlining exactly what was going to be on the exams. I'd read them those outlines and go over them in lecture. I'd set up office hours after class and special study sessions on weekends. I'd refer students having trouble to other resources, like the math center. I set up a class web site and posted everything there. I had a forum. I sent out e-mails outlining yet again what was on the tests. I offered extra-credit assignments. I threw out some tests where the overall class scores were very low. But yet, some students would miss a third of the classes, do very badly on all the tests, fail to come to any office hours, study sessions, or other resources, and then realize after I had submitted the final grades that they were going to fail, and take to Twitter to literally beg and grovel for a better grade -- they needed that credit to graduate on time, etc. -- after the point at which I could not change grades because they were already submitted, and of course because those students really did earn that grade. Some students would not even try the homework and stand there claiming they couldn't understand what was going on, while holding in their hands the handouts that literally explained in detail everything they were asking about. Personally, I have just about infinite sympathy for individuals. This stuff is hard to learn. It requires diligence and maybe a knack for it. I also recognize that students in 2016 are often in much more dire economic straits than I was when I was in college. They have taken out huge loans that they may never be able to pay back. They are facing a really difficult set of barriers to getting into the job market, which I didn't face 25 years earlier. They are also remarkably unprepared and they've been coddled and pampered and given passes to an unbelievable degree by a University system that does not enforce standards and that now makes enormous use of adjuncts like I was to teach some of the most critical classes. I had juniors and seniors in a Computing and Information Systems major studying Oracle and web development and with two semesters of C++ programming and Java programming allegedly under their belts who were unable to learn how to convert small numbers between bases. The biggest reason was that they could not do addition and subtraction of two or three digit numbers on paper. The ability to work with and understand how number bases work was one of the single most fundamental things one had to learn in order to understand just about anything else in the class. Students literally couldn't understand the examples in the textbook teaching assembly language, loaders, and linkers if they couldn't understand how computers treat numbers and how numbers are represented in different ways inside memory and registers and on paper. So we went over, and over, and over number bases... with handouts, and links to video tutorials, and references to articles, plus all of the above... but some of them just could not get it. I recognized that look of befuddlement and panic on the faces of the students who were trying. What I couldn't get across to them was that this was a _good_ thing -- that befuddlement and difficulty means the brain is working and will often be followed by enlightenment as something actually "clicks." What I didn't like was the blank faces staring at the phones and spending the entire class zoned out or texting. Or the empty seats. For students who spoke to me even once after class or before class, or came to a single study session, or sent me an e-mail, I really worked to try to help them. For a lot of the students coming here to ask C programming questions, I would like to help, and I like to answer good questions. But a lot of this looks like the last-minute folks turning to Twitter. They don't seem to want to help you help them. If they have tried getting assistance from a TA or tutor or their instructor, and failed, sure, I have a lot of sympathy for them. Maybe they are being taught by an exhausted, under-paid adjunct, or someone who is just not a good teacher. But maybe they aren't, and they have not been exactly diligent and they are turning to Reddit at the last minute out of desperation. In which case there is only so much we can do, because they often want a quick fix which they won't actually understand to help them complete a program which they didn't really write in order to get a decent grade in a class on material they didn't actually learn.
Eeek! I'll check in to it. I've tested on a couple different systems and have not seen that before. Are you using gcc on linux? Also, thanks for the compliment! Edit: So according to my doco, realloc() should work exactly like alloc() when the pointer is NULL. I think the problem was that I didn't initialize the char pointer to NULL, so I just fixed that. Since I can't reproduce this issue on my system, would you be able to tell me if the error is fixed now? (git pull origin master; make clean; make) 
Typically not a system call.
We had a similar discussion in this subreddit a few days ago. u/FUZxxl gave a nice solution [here](https://www.reddit.com/r/C_Programming/comments/4g22so/programming_with_matrices/d2e4jmw).
Even if a compiler could do sophisticated link-time optimization that might allow this, there would still be times when the programmer needs to optimize manually based on knowledge the compiler doesn't or can't have. Two examples from the Linux kernel's `struct task_struct`: * [Some fields near the beginning of the struct must be in that exact location](http://lxr.free-electrons.com/source/include/linux/sched.h?v=2.4.37#L284), presumably because some assembly code is hard-coded to expect that location. (That comment isn't in newer versions of the kernel, but I imagine the reason is still true.) * In some versions, placement of some fields was [deliberately optimized based on how it fits in cache lines](http://lxr.free-electrons.com/source/include/linux/sched.h?v=2.4.37#L300).
This is my every day... also why not just __attribute__(packed) if it's just about space
sorry about that, i didnt notice the top was a mess. it should compile fine. it works on my visual studio 2015 I hope my edit helps it be more readable. I edit it on my phone 
yeah it works great now.
Thanks!
did you miss the "if it's just about space"... nevermind sigh.
Even then you shouldn't. Pragma pack is an abomination that deserves to be shot and then burned.
This is totally valid. I, however, would suggest you to make them `static` if they're only used in this one C file, and not outside. Variables defined in global scope have external linkage by default, `static` will define them with internal linkage and do not expose them outside of this C file. If you want to access them outside, declare them as `extern` in your header and define them without `static` in your C file. They're not located on the stack, they're in a different section of your program (either .data or .bss segment, if initialized or not respectively).
If you enter something that's not a number, the loop means scanf will repeatedly look at it and fail every time.
Does the compiler make the .data or .bss segment? Or the os or something? I don't have to manage those myself right?
Ok. Could simplify a bit more? Do you mean that the variable x still has a char not a float stored in it and that's why it keeps going? And what exactly do you mean by "bad characters" and "input stream"? Links to explanations would help if you don't have the time. Thanks!
They're using the [CP437 character set](http://int10h.org/oldschool-pc-fonts/fontlist/#ibmvgamcga). The VT100 alternate graphics sequences do work on some terminals (i.e. `\x1b[(0` to enable and `\x1b[(A` to disable) but I wouldn't bother: Almost everything supports unicode these days, [and the mapping might be simpler](http://unicode.org/Public/MAPPINGS/VENDORS/MICSFT/PC/CP437.TXT).
It's doing exactly what you're telling it to do. Every time scanf is called, it tries to interpret whatever you entered as a number and fails. The bad input is still waiting on the standard input stream to be looked at again next time through the loop, and fail again.
There's a way to allocate `v` contiguously and still use normal subscripts, but it involves a pretty ugly pointer cast: int *v_flat = malloc(rows*columns*(sizeof *v)); int (*v)[rows][columns] = (void *) v_flat; //Refer to elements with the syntax (*v)[i][j] This *may* require C99 VLA support for the "pointer-to-runtime-sized array" type; I haven't tested it with a C89 compiler. **Edit:** this breaks strict aliasing as-written, so I wouldn't recommend it.
Thanks -- I'll relay this to the developer as an issue in Github and link them back here.
Tbh as a newbie I am terrified of asking questions. Mostly from responses like you mention. Its has lead to a fair bit headbanging against a problem before I find a solution, usually on stack overflow asked by another newbie. I often wonder what's the better approach. Its good to figure stuff on your own but after a point why reinvent the wheel, its better to just ask and build on it. 
Not entirely sure I understand what exactly your asking but my best guess is that you are just looking for [fread](http://pubs.opengroup.org/onlinepubs/009695399/functions/fread.html) 
`fread` will do that. You'll need to set `message_type` yourself.
Maybe there is more on the stream, and it would be better to get the entire line and discard it. 
http://pastebin.com/szxeHbe1 So everything worked fine until I linked void one_digit() with FILE check
http://pastebin.com/szxeHbe1 So everything worked fine until I linked void one_digit() with FILE *check
&gt; I just see no point in being horrible to others as it serves no purpose. Neither am I, but I am tired of people ignoring the rules. Stack Overflow is really obnoxious about putting the rules and guidelines in the face of people who ask their first question and still 50% of all questions on [c] are absolutely unanswerable. If there aren't consequences for asking shitty questions, beginners won't bother asking good questions on their second attempt. This way, at least half of the questions are answerable.
Don't be afraid to ask, but make sure you ask a question that already contains all relevant information. A good question contains code to reproduce the problem you have or a detailed description. Always provide sample input and output to illustrate your issue. Always say what platform you are working on. Hang around after asking so you can answer follow-up questions quickly. That should suffice to get decent answers.
Basically, sometimes the variables will be 0 by chance. And sometimes they won't. The technical term for this is "undefined behavior" and it's actually worse than having a random value for a variable. If you read from a variable that hasn't been initialized, the compiler is free to do *anything it wants*. Maybe your program crashes. Maybe it computes something unexpected. Or maybe it hacks a Navy submarine and launches a nuclear missile. Ok, so that last one isn't very likely ... but you can get interesting things like entire sections of your code being removed by the optimizer. I should also clarify that global variables are guaranteed to be zero, you don't need to initialize them. But local variables and anything from the heap are not.
under the function 'void one_digit(int x){}' I'm trying to add a fprintf of what I'm printing on the screen, similar to what I did for 'void two_digits(int x){}'. However, when I added: FILE *check; check = fopen(FILENAME, "w"); That's when the anti-virus kicks in
Why do you open the same file multiple times in the same program? That's weird.
First off you should turn on all error messages and warnings from your compiler. Also this line: a = scanf("%f",x); should be a = scanf("%f",&amp;x); It needs the address operator, &amp;, to make a pointer.
I guess I don't understand the context of this post, since POSIX has no notion of system calls, and even considering implementations, POSIX readdir is typically not a system call either. I expect it may make more sense if you know what "Gluster" and all that is.
I'd rather have the OpenGroup standards on top.. Most important reference for C developers in my opinion. Or better yet, a short extract showing the prototype, return values, and errors, along with a link to the full reference.
You need to understand how POSIX is typically implemented. Many programs rely on these implementation details, changing them causes software to break in mysterious ways. `readdir()` is a thin wrapper around `getdents()` whereas `scandir()` operates on what `readdir()` returns. However, I don't know how you want to make `scandir()` faster anyway as the comparison function is C code and cannot be evaluated on a different machine.
Well, you have to pass the `FILE` pointer as an argument to each function so all of them can write to the same `FILE`.
`check` is just a variable. There is nothing special about it. If you declare `check` in four functions, that's four different variables that aren't related to one-another in any way.
Thank you very much! It now works like a charm!
Thanks for the template, that will be a useful approach to remember. For this particular project it won't matter though because i only need one instance of every "object". Any of the ones that need to have dynamic data structures are just using a linked list of structs internally.
Quite. Strictly speaking, nothing there requires that it be evaluated locally. But I'll admit I'm being a little pedantic there.
&gt; when you say that nothing changed with stdin, why is that so? I clearly wrote to scan another input within the loop, so why does not scan an input, but go back to stdin and scan the value I've already inputted? I guess I missed this part in my explanation. `scanf` will only pause and wait for more input when the input buffer (`stdin`) is completely empty. Since this isn't the case for your program (`stdin` still contains that 'e'), it won't pause and will instead keep trying to work with what's already in the buffer. &gt; Another question is the function the temp part, how does this discard what's inside the stdin? Again, I wasn't clear about this. `scanf` will only remove a character from `stdin` if that character matches the format string. In your code, you're trying to read a numerical value which does **not** match so the character gets left in the buffer. By using the %c specifier instead, you're saying "give me any character", which **does** match, so the 'e' would be removed. On the next loop, `scanf` will automatically remove any leading whitespace (including the '\n') when looking for another numerical value. Since `stdin` is now empty, the program will pause and wait for more input.
Post your whole program.
What do you mean by "truly multi-dimensional"? A one dimensional array where you calculate the index of various members is a multi-dimensional array. Are you looking to have the syntax of a multi-dimensional array? e.g. `matrix[row][column]`. 
I don't understand. Your program does what you want. &gt; have the program state whether any digits repeat. Ah, just yes or no? Have a bool variable slot which signifies whether anything repeated. &gt;What I am confused about is taking a digit and assigning it to an array, while making sure a repeated digit isn't assigned to another array as well. You probably mean "array element". By using the digit as index, only this array element will be modified. So the same digit's repetition flag will always be stored at the same place. &gt;I've researched a bit, horribly, but if I understand I can use booleans to test true or false if a number repeats. Yeah. Note that all `if`s already automatically test for `==true` (actually for `!=false`). So if you have a boolean variable `x` and write `if (x == true)` what it does is `if ((x == true)==true)` which is redundant (but works). Enough would be: `if (x)` Likewise `if (x == false)` is better replaced by `if (!x)`. I'd name `digit_tally` as `digit_repeats` because then it's easier to understand. Your second cin &gt;&gt; number; is a very bad idea. I know why you do it (the original `number` was modified) but that's not the right way. It will read a NEW number and then discard it. What you should do is replace the bottom condition to just read (`do`...) `while (true);` and remove the second cin &gt;&gt; number; What I'd do is extract the digit counting (everything done after reading a number) to a new function `process_number` or whatever, but that's not necessary. Also, if you check if (digit_tally[digit] == true) { cout &lt;&lt; digit &lt;&lt; " "; inside the loop then the same repeated digit can be printed multiple times - but you didn't print it the first time. So put it outside the loop in order to print repeated digits only once per digit.
Good suggestion. I've filed an issue for this: https://github.com/duckduckgo/zeroclickinfo-goodies/issues/2938
This subreddit is about programming in C. C++ questions are usually off topic here. I removed your post. See the sidebar for places where you can ask C++ questions.
I think this sort of attitude is one of the many reasons I've never been able to commit to any coding projects, I am so worried about someone else seeing my code and thinking it low quality or messy that I spend most of my time refactoring code so it is tidy, neat, clean, etc, etc. I can never seem to get over the next hump in the project and end up abandoning it. Off to the /old_projects folder they go, to never be touched again. I've been teaching myself C since 2001 and feel like I have a good grasp on the language, before that I wrote some Basic and now I am flopping my way through C++, but every now and then I'll peek at someone's git repository when they post them and I am either super lost (ugh, templates) or get that old feeling of, "wow this code is beautiful, I can never show anyone mine! it will bring me great shame!". siiiigh. I do enjoy learning and helping others though, and I can appreciate the knowledge all these years of coding has brought me, I feel like it has given me the ability to fix any computer software related issues.
Yep, this was last updated in 1998, and even then, it states that these changes may slow down your code. With the lightning fast improvements in the tech industry, even information just a few years old can be outdated. This kind of article can easily lead you to believe you're getting something done, when you're not doing anything, or maybe even hurting yourself.
What would you recommend in order to learn the optimizations performed by the compiler? A compiler book? Compiler documentation? CS freshman here. Ty in advance.
Take a look at some smaller compilers like pcc or tcc. After that maybe jump into the deep end and study GCC or clang.
Thank you a lot. The second cin &gt;&gt; number is because the program keeps shutting down on me. I used that as a stop gap. You've been very helpful. I appreciate it.
I'll just point you to [my comment](https://www.reddit.com/r/C_Programming/comments/4gp72i/why_does_this_line_of_code_create_an_infinite_loop/d2jm5yu) in a different thread, you have the same issue.
If you ask `scanf()` to extract a formatted value from the standard input stream, but the contents of the stream cannot be parsed as the specified type, then `scanf()` does nothing. It does not touch the variable you asked it to write to, and it does not extract anything from the stream. Its return value is the only way to detect this case. So it's not "failing to ask for the second." Both calls to `scanf()` are succeeding. You're misunderstanding how IO works. The first call did not extract anything from the stream. The second call does not need to wait for input because there is already something waiting in the stream — the exact same thing that was in the stream for the first call, which was unable to be parsed as an integer. The second call therefore returns zero instantly, without waiting. If you want input that's immune to things that can't be parsed as the requested types, then *you* must handle extraction from the stream. The best way to do this is to read *lines* of input from the stream with `fgets()` and then parse those lines with `sscanf()`. This means that you always experience forward progress, i.e. `fgets()` always extracts a line from the stream, regardless of what it contains. If `sscanf()` fails to parse a value from that line, then the line was still extracted from the stream. Summary: - Always check the return value of IO functions. - Consider always reading input a line at a time and then parsing it from there. 
&gt; &lt;user_1&gt; How do I print hex using printf? &gt; &lt;user_2&gt; man printf &gt; &lt;user_1&gt; What is man I use Windows? &gt; &lt;user_2&gt; give up learning c better still give up learning to code If you're "user_2" in this scenario, and you know that "user_1" can not even figure out to go type "man print" into Google, as a first step, it shows an inability to do things (whether through laziness or not) that are *necessary* to become a proficient programmer. The response is brutal, yes, but it's brutally honest. You have to have some intrinsic ability to be able to ferret out certain things on your own, and to ask "what is man?" demonstrates an inability. [Actually, what's worse here is that "How do I print hex using printf?" would be asked in the first place.](http://bfy.tw/5VVr) Whenever I stumble across something that is presenting me with difficulties, I do a *whole lot* of spelunking before I resort to posting questions to a forum. 
Thanks alot for your help!
Actually, it works if you only pass it numbers (ints). You have to make s a character array or something if you want to scanf some text (or just a char to scanf a single letter).
That's just plain wrong. There are optimizations a compiler simply cannot do, that a human can do. E.g. - a human might know that certain pointer don't alias, while a compiler almost always has to take aliasing into account. - if you link against a binary, the compiler almost always has to treat functions as black boxes with side effect, whereas a human might know that a function doesn't have certain relevant side effects. - Compilers are still not that good at vectorizing code, whereas humans can be very good at it. - A compiler often can't make any assumption on the microarchitecture or other cpu features, whereas a human might know a lot more about the cpu where the software will run (yea, there are the -march flags, but a human can restructure code on a higher level to suit the cpu better). - A compiler simply cannot restructure code on a higher level (say bubble sort -&gt; merge sort, convolution -&gt; fft etc) - and much more Performance critical code is to date still optimized by humans and consistently outperforms compiler optimizations often by an order of magnitude. Whether you should carry out optimizations yourself is another question, if you write an application that's IO bound or mostly idle, it's indeed counter-productive due to the maintenance/readibility over head (see premature optimization). Btw, this guide is from 1998 and is very basic, many performance relevant aspects aren't even touched such as caches, vectorization and a lot more.
Use [`fgets`](http://en.cppreference.com/w/c/io/fgets) instead.
Your post got caught in our spam filter. I apologize for the inconvenience.
My undergrad advisor once compared optimizing by hand to John Henry's struggle against the steam hammer. Yes, if you are very good and work very hard, you might beat the machine, but is it worth killing yourself over?
Knowing virtually nothing about processors, I would guess nanoseconds, but yeah.
That won't work at all.
Are codeNumber and moneyAmount initialized? I think your loop should look like this (but I don't know what your file looks like): - go from zero to ss-1 (x) - read from file - go from zero to ss-1 (y) - check if code is ok, if so, then add +: I can't imagine why you don't use [ and ] operators.
A few extra things: 1. You don't need to declare strerror(), because string.h does that for you. 2. You're aware that printf(...) is a shorter fprintf(stdout, ...), right? 3. Under POSIX/SUS, a &lt; 0 return from system() is pretty limited in what it catches, i.e., it may not be covering everything you think.
This begs for http://www.iso-9899.info/wiki/Candide#C-Aphorisms : The questioner's first description of the problem/question will be misleading. All examples given by the questioner will be incomplete, misleading, broken, wrong, and/or not representative of the actual question. The questioner will not read and apply the answers they are given but will instead continue to practice c1 and c2. The ignorant will continually mis-educate the questioner. When given a choice of solutions, the questioner will always choose the wrong one. The questioner will always find a reason to say, "It doesn't work." The questioner will paste code and say "I have a problem" or "It doesn't work" without any further information or description of the problem. The more beginner they are, the more likely they are to be overcomplicating it. The questioner will always have some excuse for doing it wrong. The newbie will not accept the answer you give, no matter how right it is. &lt;skipped due to existing c11 factoid&gt; The newbie will think they are smarter than they really are. The newbie will fail to recognize undefined behavior, and will wrongly think that their program is correct because it appears to work. The more the questioner attempts to describe their problem, the less coherent their description becomes. When multiple people respond to the questioner's problem, the questioner will focus on the person giving incorrect advice and ignore everybody else. 
So run system("cc -o bar bar.c"); with one the quines above should suffice right? 
Well, that line should be part of your program of course. And exchange the source and binary name as appropriate for what you want to do. Consider reading `man cc` for details.
Okay Thanks a lot. This helped a lot.
Use `%llu` and a cast, `unsigned long long` is guaranteed to be at least 64 bit wide. A more general approach is to use (u)intmax_t and the `j` length modifier: printf("%ju", (uintmax_t)t);
Classic C developer literature. 
C cannot be replaced now in many ways, it's too much popular, universal and widespread.
As long as there is no better option for realtime, and people continue to use C for performance-critical subsystems, no, C will never die. 
The actual problem is that my insertion algorithm always consider the root = NULL, so the 'while' inside of it is never executed
Low level programming languages like C have their purpose and certain uses. Networks, security systems... Etc this is why C will never die
&gt; millions of lines of C code continue to be written every day. Even on sundays?
Especially on sundays.
I fixed the issue... it was caused by a separate function (forgot they shared variables). Thanks for the help.
Used it this semester. Most networking professors give this link day one. 
I see three main reasons that C is not in danger of dying anytime soon. First, the enormous body of C code. That includes things like the Linux kernel. Second, the C _model_, which was the UNIX-ish model. This includes how most modern linkers and loaders work, calling conventions, ABIs, etc. The C model is not the only game in town, but it is the most common one second to "managed code" models. Last, the C library, which is the basis of an awful lot of UNIX and POSIX APIs across many platforms. C has its flaws and complexities and weaknesses, and so over the years I have tried often to find other languages that would be suitable for low-level programming. When blinding speed isn't needed I've migrated projects to have front ends in languages such as Python or Ruby or embedded Scheme or Java. This can work really well; for example, build a GUI in Python or C++ with a heavyweight framework like Qt, while the back end code and drivers are straight-up C. I'd really like to see more research into languages that can compile to efficient binaries without requiring garbage collection or even necessarily supporting dynamic allocation, suitable for safer library code and embedded code. Because i don't believe C really is the "last language" or the "be-all, end-all" of efficient languages, and we have actually made advances in being able to write compilers for improved type safety and memory safety. But for the most part, even in 2016, when it comes to "here's a new chip that goes in a box and you need to write code for it," or "write a portable utility or library where most of the code is portable between Windows, Linux, and MacOS X," at least the low-level part of that code is going to be C, maybe with support for some version of C++.
That particular problem occurs because you're calling insertion() repeatedly from main() as insertion(NULL, n); The 'root' pointer in main() never changes. Effectively all the program does is allocate (and leak) discrete chunks of memory. You've probably received so few responses because there are signs you've jumped too far ahead of yourself with C, and giving a helpful answer would require covering a lot of ground. This is why I'm skeptical of the value of some popular courses. Nothing beats the traditional approach of working through *The C Programming Language* from cover to cover, doing all the exercises -- or *C Programming: A Modern Approach* for something more recent. 
It depends on how portable you want to be. If you know what platforms this will run on, and don't expect that to change (or don't mind a lot of work updating the code when it does), then sure, be non-portable. But if you want this to be portable, you don't have many alternatives. Even Linux and Windows have different choices for the 64-bit integer on x86-64: Linux uses `long`, and Windows uses `long long`. You could throw `%llu` at it, at the cost of using a 128-bit integer on Linux and [I think] needing to cast for the argument to be passed correctly. There might be other ways to print it with a large type, but either way I think you'll have to cast up, which makes it pretty easy for a bug to lurk, and the performance will be worse. Otherwise, you have to suck it up and use the format macros. (Unless you really think having your own API for this would be better. It might be, but you'll have to be the judge of that. I've been using the format macros for some of my code at work, and it's not that bad; you just kind of get used to it.)
You need to either use a double pointer for root or initialize `root` before passing it to the function. It's simply not possible for `insertion()` to modify `main()`'s `root`.
It's a lot easier to use and most times is all you need.
Can't help without seeing your code.
Could instances where it is required not just use the async version wrapped up outside the library? I suppose my point is: _is it time to shift the default from sync to async?_
No. Don't fix what isn't broke.
You say it's is passed a single 1d array, then how did you get a 2d array in your example? Is the function called repeatedly with the same x/y coordinates but with different arrays? 
Yes, the issue was getting the correct index for the sums. Basically I had a for loop which worked for "square" sized arrays where the point of interest was in the top or bottom "row". The issue is getting the correct index for when it would be outside of the array. So when x y is element 3, sum = array[3] + array[6] (array[9] is outside so skip) + array[0]. Thanks for the help. What you've shown seems like an easier way to approach this. 
I'm sorry, but this is not about C and thus off topic. Please demonstrate the relationship to the C programming language and I'll approve it again. I removed the post for now.
This is difficult to read. Please paste your code in a [gist](https://gist.github.com/).
That's not how this semaphore API works, like not at all.
To get the coordinate (x, y) of a 2D array represented as a 1D array, you can use the formula: [x][y] = [y * width + x] 
This is a master piece simply put.
defines with no () around argument expansions! My eyes, they buuurn!
How so ? There's no inherent problem in calling sem_wait() on a semaphore that lives in shared memory, accessed by 2 different programs.
I really like this. I've been using a similar pattern for a long time now, but I wasn't aware one could declare a struct opaquely like that. Very cool.
This isn't a question you can really expect a straight answer to; optimizers are wizardry to most programmers, and even if you ask those who work on them, there's not some easy set of heuristics you can run through to tell you what the optimizer is going to do to your code. Profiling is the only way to get a real answer to "which code is faster?", and examining the code is the only way to know why. That said, there are plenty of reasons why C++ could produce better code than C, even when using high-level features -- zero-cost abstraction is its raison d'être, after all. C++ has a stronger type system than C, first of all, and typing is a static optimizer's bread and butter; it's not as fancy as Haskell or Rust, but it gets the job done. C++ containers and algorithms are usually specialized in terms of their operand types, to produce optimal or near-optimal code for many common cases. C++ offers language-level support for (N)RVO and move semantics, which allow some very gnarly optimizations to be lifted out of the muck of manual memory management into the high-level world of regular types and abstract containers. C++ offers a big performance-saving feature that C does not in Turing-complete compile-time computation and code generation, though that doesn't seem like it's happening here. Of course, we can't seriously attempt to answer your question here, because you haven't provided us with the C++ source code, the compiler, version, flags, and settings you were using for each, any of the assembly output, the specs of the machine you were testing on, or even the timings of each version. I assume you were running the exact same compiler settings for each one? Did you try running your C through the C++ compiler to see if the codegen differed based solely on language? Did you try writing and testing your C more naïvely, to see if your hand-tunings were confusing the optimizer? Did you try making some of the same "tricks" on the C++ version to see if they made any difference in performance there?
https://gist.github.com/anonymous/311f5b118e5da6c786a6d30b71ad6146 ok ill read how to indent the code properly in reddit. meanwhile i pasted my code on the gist. hopefully that helps a bit.
I added a link to it.
gcc / g++ on x86_64 and using the same compiler flags for each.
Thanks for writing such a comprehensive reply. I have tried profiling the function, but am struggling with getting any meaningful results. So far I've really only confirmed that 99.9% of the execution time is spent in the function, which is not a surprise. I don't really know what I'm doing when it comes to profiling, however. As for the speed of C++, I've almost always heard it said that C is going to be faster because you can work at a level much closer to the machine. Maybe this comes from C zealots and isn't really true? I don't know. I've added the C++ version to the OP. Yes I've been testing with the same optimization flags for each. I'm currently changing around my C code to be compatible with `g++` (I need to remove all implicit `void*` casts). Would comparing assembly output actually be useful? Presumably the C++ one is going to have a load of convoluted stuff for the standard library functions and containers. About trying to write the C more naïvely, I started out with a naïve implementation and then started optimizing. The C was around twice as slow when I started out. 
`scanf()` returns the number of successful conversions, or EOF if the end-of-file condition occurred before the first conversion or there was an IO error. In this case, since you're asking it to perform only one conversion, that means the return value can only ever be zero (if it failed) or one (if it succeeded) or EOF. The value returned has nothing to do with the value parsed and extracted from the stream and written into the `num` variable. 
Oh! I knew it was a simple problem, thank you very much!!! Code works now :) Thanks a lot EDIT: just one more thing for me to be sure about, when I type a "k" for example, the while will stop because it will not be able to read the number and then the condition will not be met, is that correct? The program is working fine now, I just wonder if my reasoning is correct.
As /u/acwaters points out, a definitive answer is unlikely to come, but I'll take a guess: g++ is better at optimizing than gcc, and my specific guess is that g++ optimized your if == statements into jump tables (switch statements). Doing so guarantees that you never pay the penalty for false branch prediction on these, which is quite costly on modern processors. You can test my guess by turning them all to switch statements and see if the C program becomes faster. EDIT: if you really want to know the answer, I'd recommend generating the assembly code for each and comparing it.
&gt; zero-cost abstraction is its raison d'être, after all Can you explain what you mean by this? Many of the abstractions provided by C++ pay heavy performance penalties.
It doesn't seem to have had an effect one way or another, I imagine the compiler can see that the first statement is useless and optimizes it away.
A couple of things that might help understand the cause: * compile both programs with no optimization. If their times are closer, then it's the optimizers. * run a profiler on the two programs to see where the time is spent in each
It's definitely the optimizer quality between the two. I ran it with ICC 2016 for both using the exact same settings, O3, etc.... with 10,000,000 for 100 loops and both version come out consistently at 79 milliseconds per iteration. Edit - Ran it on a couple of others out of curiosity: c c++ ICC 2016 79 79 Clang 3.7 with ms code gen 74 116 MSVS 2015_140 77 89
You could just use a gist (gist.github.com) or pastebin to share the code instead. Without the code there's not much to say about what you did wrong.
As a rule of thumb, `free()` everything you `malloc()`. That's all.
Not related to your question, but an optimization tip for you: Move the 4x^2 and 3x^2 calculation outside of the y-loop, you're doing it way more often than you need to.
All memory is deallocated on program termination. However, if you allocate memory in a long running program and never free any, the memory tends to pile up so you should free stuff you don't need anymore. 
Under all modern operating systems, when a process terminates all of its resources are relinquished. There's no way for a process to consume memory after it has terminated, so memory leaks are about dealing with resources while your program runs, not after it finishes. For simple trivial programs, it might not really matter. There's a school of thought that says you shouldn't worry about explicitly freeing memory if you're writing a short-lived program that's about to exit anyway. But there are counterpoints to that philosophy. For one thing, many programs don't have that luxury. In particular, libraries can't assume they will be used in a short-lived program, so they must always take care to do accurate memory accounting. And it's not uncommon to start out writing a program and then turn around and later decide that it's so useful it needs to be turned into a library so that the functionality can be reused in other contexts. But if you never bothered to manage memory, under the assumption that you were writing a short-lived program and not a library, then you have a ton of work on your hands; you may have to completely rethink the entire foundation of your code. Certain classes of programs are not short-lived, like servers. When writing code that's going to run for a long time, it's absolutely essential to not leak memory, because even small leaks will add up to significant amounts of wasted memory as your program runs for weeks or months. And then there's the issue with tools like valgrind which can be used to diagnose all kinds of errors, including leaks. Again, if you write code that intentionally leaks, that's a defensible standpoint under certain circumstances, but it also means you make it a lot harder to use these tools, because they will light up with thousands of alerts to memory leaks, drowning out the actual problems that you were trying to find. Especially as a beginner you need to learn the proper discipline of how to manage memory. You can always choose to intentionally leak if you've made a careful analysis, but you can't do the reverse — if you've developed shit habits of never properly dealing with memory then you won't be able to write libraries or servers or all kinds of other programs. 
Hm... I have no idea what the problem is. Let me investigate. On a hunch, the problem is the different treatment of `primes`.
Thanks for the detailed response! Really helpful example, cheers. So in summary, the whole idea of freeing memory is purely for the sake of memory efficiency. While my program is a very short lived program, the idea behind memory freeing is a large component in industry is it not?
While that might be cleaner, the compiler is way ahead of you.
&gt; the whole idea of freeing memory is purely for the sake of memory efficiency Purely, yes. But since efficiency is what C is all about, this is a rule you'll take it to your heart. :D
No. When the allocation fails, `malloc` will return `NULL`, and when you call `free( NULL )`, the function does nothing. The thing is that `malloc` [will pretty much never fail you](https://www.quora.com/What-are-the-possible-ways-malloc-might-fail) on deskotps and similars. But if it does, trying to allocate it again could work if other processes freed enough memory, but if that's not the case, and your OS doesn't handle it, which again, is another event with very low probability of happening, you're pretty much better off restarting your PC.
Oh yeah, I think you're right! I remember now that C++ vector&lt;bool&gt; is special and is actually a bit array. So that's why I wasn't seeing `sete` (x86) in the C++ version. Edit: Yup, **switching to a bit array brings the run times to parity.** Mystery solved! Edit 2: Actually, after some repeated testing, the C version is a little faster! Here's what it looks like after my hack job: [primes.c / primes.cpp](http://pastebin.com/WQUh5QiD) (intended to compile as either C or C++).
As I understand it, zero-cost abstraction is supposed to mean that if you don't *use* the abstraction, you don't pay any cost just for having it in the language.
Thank you so much. Ill start reading on that and try to make it work. But now i finally have something else to try. Thank! 
As the error says, you can't use initialization with VLAs (&amp;sect;6.7.8/2 in C99.) It makes sense if you think about it. VLAs are for when you don't know the size at compile time. But if you don't know the size at compile time, how would you be able to specify an initializer? It could end up being too big or too small depending on the dimensions, which are only known at runtime. If you know how big it's going to be at compile time, then you don't need a VLA. Your example is misguided, since if the size is always going to be 3 then just use a `#define` and get rid of the VLA. (This is, sadly, one of the few times where you must use a `#define` and there's no good way to get around it. Using `const int` does not work. That only works in C++.) 
I'm confused. Are your columns swapped? It looks like the C code is consistently faster/as fast, which contradicts the other evidence.
Gotcha! Thanks :)
This code is very unsafe. If `A` has less than nine elements, the code is going to write past the end of `A`. If `A` has more than nine elements, the code is going to read past the end of the compound literal. It pretty much only works when `rows` is 3.
No, it's not. You can leave out the inner braces.
Both of these are regular userspace utilities. They are not part of the linux kernel. In fact, they are not even linux-specific. Since I couldn't quickly find the source I guess they're just allocating a small struct, containing meta-info (address to call, parameter pointers) and a small amount of x86 machine code. The latter will read the parameters from the struct (e.g. using PC-relative addressing) and plug them into registers for a following function call. The function pointer just points at that opcode string. It's a funny little hack, but suffers from a few problems. First, it obviously conflicts with ```W^X```, the security practise of not having memory both writable and executable at once. Second, it's highly dependent on system and architecture. Third, it is pretty slow as it introduces a jump to some dynamically allocated memory region (likely clobbering caches) and requires the use of a va_arg-like mechanism to get even some basic portability. The usual way to do this kind of thing in C (as it's done e.g. in the linux kernel) is to have two variables for each callback: A function pointer and a user data pointer: struct { void (*foo) (void *); void *userdata; } my_callback; To register the callback you would then set ```foo``` to the function to be called and ```userdata``` to a pointer to the argument you would like to be passed. The caller would then do: my_callback.foo(my_callback.userdata); ...and the callee would do: void cb_impl(void *userdata) { struct my_arg_struct *args = (struct my_arg_struct *)userdata; printf("I haz been called: %s %d\n", args-&gt;some_string, args-&gt;some_int); } [edit] To actually answer one of your questions, "first-class function" refers to a concept where in some languages functions and other data are similar in their handling. I.e. you can create functions on the fly, use them as parameters, return values and everywhere else. Most of the time this feature is used just to make code more readable by interleaving setup code and callback handlers, automating much of the argument passing mechanics. C does not provide this level of abstraction, not even with the two obscure headers you found. At the same time, an experienced programmer would very rarely even need this in pure C code. Most instances where you would want something like this can *in C* be solve using a pattern such as the one I described above. [/edit]
The example you give is an oblique way of transforming a recursive algorithm into a loop. The question in the latter part of your post I don't fully understand, but maybe the following will be of some use to you: In C, at runtime every function resides at a certain, fixed memory address. Now, if you had some piece of shitty code that could call a callback for you, but would only accept a ```void (*fp)(void)``` signature, you could use something similar to ```callback.h``` to use *the same* function at multiple places, with a different ```data``` argument in each place. This works by ```callback.h``` simply on-the-fly generating a wrapper for each place the callback is used in that just sticks the relevant arguments in the single, shared callback function. Normally, you'd just use the ```void *data``` argument pattern instead. It's both faster and less complex.
Am quickly wondering what the actual point is to the two libraries then. With GNU C there already is support for nested and statement expressions ( and consequently pseudo lambdas ), and even that seems to be more portable than this, and convenient. You need to define an actual function anyway, you need to pass in the data and function pointer wrapped in a struct meaning the called function must go through the extra work to obtain the function pointer and data. The trampoline/callback must be cleaned up because it gets allocated. It also isn't very portable. I swear I'm missing something, things aren't added to that kernel without an actual valid reason.
Those are from libffcall which has been made to implement dynamic programming languages. https://www.gnu.org/software/libffcall/ alloc_trampoline probably allocates some executable memory then writes some bytecode where the passed arguments are immediate values. An implementation of trampolines for x86 32 bits http://codepad.org/OZASXmSo #include &lt;stdio.h&gt; #include &lt;sys/mman.h&gt; void* trampoline(void *proc, void *variable, void *data) { typedef unsigned char uchar; struct __attribute__((packed)) { uchar moveax; void* variable; uchar movat[2]; void* data; uchar moveax2; void* proc; uchar jmp[2]; } *tramp = mmap(NULL, sizeof(*tramp), PROT_EXEC | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0); tramp-&gt;moveax = 0xB8; // MOV EAX, VARIABLE tramp-&gt;variable = variable; tramp-&gt;movat[0] = 0xC7; // MOV [EAX], DATA tramp-&gt;movat[1] = 0x00; tramp-&gt;data = data; tramp-&gt;moveax2 = 0xB8; // MOV EAX, PROC tramp-&gt;proc = proc; tramp-&gt;jmp[0] = 0xFF; // JMP EAX; tramp-&gt;jmp[1] = 0xE0; return tramp; } char const *var; void test(void) { puts(var); } int main () { void (*ta)(void) = trampoline(test, &amp;var, "ta"); void (*tb)(void) = trampoline(test, &amp;var, "tb"); ta(); tb(); ta(); tb(); return 0; }
Yes this code is unsafe. Using the size of either array will cause an access past the end of the other one if it is smaller. This could be avoided by using the minimum size like `sizeof (A)&lt;9*sizeof (double)?sizeof (A):9*sizeof (double)` and also specifying the length of the compound array literal so you can't accidentally give it more elements than you meant to. I should have been more specific about the potential problems in my comment, but I was just trying to show that compound literals and memcpy can be used to essentially initialize variable length arrays.
&gt; First, it obviously conflicts with W\^X, the security practise of not having memory both writable and executable at once. Not necessarily. Just like in a W\^X-friendly JIT compiler, the code can be generated in a W buffer, then flipped to X before use. Closed over variables that might be mutated can remain in a separate writable buffer.
That's correct. The only remaining problem with that is that that permission-flipping can only happen on at least whole pages, which depending on implementation would probably waste space in this application (vs. a JIT).
A sequence point is a term used by the standard to describe where and when side effects of evaluating expressions can be counted on to have occurred. It has nothing to do specifically with pointers. In particular, you may only modify a given variable once between any two sequence points. A classic example is: i = i++; There is a sequence point at the end of the full-statement (i.e. at the semicolon), but that's it. There's no sequence point at the assignment operator. `i` is modified twice, once by the assignment operator and once by the postincrement operator without an intervening sequence point, so this invokes undefined behavior. The reason for this concept is that it allows the compiler to generate better code by rearranging the order that various side effects take place to better suit the capabilities of the hardware.
You're passing the variable `intsum` into `Average()`, but you never give `intsum` a value. Maybe you meant to pass in `sum` instead? EDIT: Also, your loop condition is backwards while (count &lt; 0)
And change sum = count + value; to sum = sum + value;
The scariest thing for me about this UB with regard to compiler optimizations is not that security vulnerabilities can result (which has been established many times) but that, particularly for large programs, it becomes virtually impossible to assess the full security impact of a UB construct without either a thorough reverse engineering or an intimate knowledge of the compiler in question. Before 2008 or 2009 (when this issue started gaining more attention), if someone alerted a vendor about a problem, it was generally immediately obvious whether there was a security impact. If, however, you present a vendor with a UB construct without any obvious immediate impact, how do they decide whether to write a security advisory or not? Short of a thorough reverse-engineering effort, they're pretty much required to be intimately familiar with what the compiler does program-wide when presented with a UB construct. Fortunately, no compiler I know avails itself of the full freedom afforded by the C standard -- undefined effects are quite local -- but with increasing optimization intelligence, it's only a matter of time before undefined spaghetti becomes the norm.
This looks a little better but you are still decrementing `length` and using it between sequence points (I think). I'm not sure if there is a sequence point after the control expression of `?:`.
Hi, I am the maintainer for that cheatsheet. There is the order of precedence given seperately. Are you talking about precedence in each sub section?
K&amp;R is great because it introduces the complete language correctly and in an easy-to-understand way. As opposed to many modern books, K&amp;R is sufficiently terse that reading it isn't boring and there are exercises to make sure you understood everything.
Been hit by that once, and my policy is to be bitten by a category of defects only once (only as much as I can, unfortunately). You defines where not in a header, so it wasn't that bad :-) I do like the way you get the AABB and area, though (I love code that can be asserted as correct by just looking at it, and this one is). I am not completely sold to the idea of getting both intersection and surface in a single call, thought, as you can get the intersection rectangle as an output and computing surface is trivial from such rectangle (and probably already exists in the codebase). So many ways to write code :-)
getchar is basically a different way to take input, as I understand it. It's not strictly used just for conditional syntax (eg, int number = getchar(), then test number). If you wanted to just get something with scanf it'd look more like this: char str[16]; printf("Enter a string: "); scanf("%16s", str); printf("string: %s\n", str); If you wanted to just use getchar, the best way would probably be to assign getchar to a var inside the while loop, and have the loop condition test that var.
I think everyone can agree that the material in K&amp;R is good. It gives you good advice and is fairly complete from a language standpoint (if not very complete from an applications standpoint). Stylistically, some people find it to be dense or dry. Some people consider it a little intimidating for an absolute beginner. Some people use it as more of a reference book, or a way to brush up on things you've forgotten, or iron out bad habits, rather than a learning book.
hmm. Than replace it with `fflush( stdin );`. That should clean the input buffer.
Thanks. Yea the code snippet is actually 3 snippets from 3 different places in the code of my project Holocraft. There are more possible applications for use of a call that also returns the rectangle of overlap as well. For example: if you wanted elastic bouncy jello physics you could allow for overlap but be using the overlap rectangle to impose a force on an object (or objects) that pushes them away by the amount of the overlap rectangle itself. Etc... You won't *always* actually need to know the overlap rectangle in most cases, but in Holocraft it serves useful, and I'm sure other people will find uses for it as well.
Apologies for that, as you may be able to tell I'm new here, but i understand what you mean regarding the title. Also, thanks for the swift response. You are correct, however if i may, how would i go about directing this to the last line as you said?
That's a little more complicated, try this: if (fp != NULL){ int got_line = 0; char max_line[LINE_MAX]; while(fgets(max_line,sizeof(max_line),fp) != NULL) got_line = 1; if (got_line) { if (strstr(max_line,finder)||strstr(max_line,finßder2)){ fgetpos(fp,&amp;get_pos); capture(max_line); } } else fprintf(stderr, "File was empty!\n"); fclose(fp); }
Perfect, thank you so much!
Cool! Might I ask why you created/use this? Is there something about the currently existing git repo hosting services that you don't like and want to fix?
All modern OSes do memory overcommitment. 
Nope. Server operating systems usually don't by default. They do however use allocated but unused memory for the file system cache until it's used.
Oh, that's completely fine. You just happen to work on a modern computer with a device known as virtual memory. Programs can live in big address spaces and that address spaces are mapped by your CPU's memory management unit into the physical memory of your computer. If you merely requested a memory page and didn't access it, it doesn't have to be mapped into the physical RAM, and so resident memory size (rss in ps) isn't increased. For big chunks, modern malloc will call mmap on Linux that allocates whole pages. For small chunks, it will call sbrk, but I don't think it has good correspondence with memory pages.
Welcome to virtual memory. Until you're actually using the the memory you asked for, the OS isn't going to be assigning actual RAM to it.
&gt; I've been recommend this, how exactly does one format this argument? Just add another argument to your function: void two_digits(int x, FILE* check) { /* code here */ } Then, you don't need to call `fopen` because the file was already opened in `main`. &gt; Are there any bad side effects if one doesn't use fclose? For one, `fopen` returns a pointer; so, if you don't call `fclose` you have a memory leak. I/O may be buffered, in which case, things you write to the file may not actually be saved until you call `fflush` or `fclose`. Additionally, there is a limit of how many files can be open at the same time; so, you should get in the practice of closing a file as soon as you don't need it anymore.
It is how "software breakpoints" are implemented. See this article for more details: http://www.nynaeve.net/?p=80 :)
Interesting. What about *free()*? Will *free()* still instantly clear up the space that I need? My program creates two different successive arrays that are both larger than 50 percent of my RAM, so I absolutely *need* the first one to be fully and completely scrubbed from memory before I can start building the second one.
It's quite common to pad entry and sometimes exit with nop for various reasons. Microsoft does it a lot in various DLLs or binaries with user APIs so you can runtime patch a function by redirecting the function entry. This is often called inline hooking or dynamic hooking. 
Here's how to do it [with stock GCC without stopping the program](http://nullprogram.com/blog/2016/03/31/).
&gt; You could throw %llu at it, at the cost of using a 128-bit integer on Linux ...Very no; `long` and `long long` are *both* 64 bits on 64-bit Linux.
This is not my project but I thought it looked clean and minimal for a self hosted solution. On another note I'd actually like to see this subreddit have more links to articles and c based projects rather than be a poor mirror of stack overflow and links containing homework questions.
Not quite. Those software breakpoints have their own opcode that is not the nop instruction. The nop slides are common in malware. In fact, a program that has this X-ray system looks to conveniently set one up for every function as an on/off switch, which could be quite bad if attackers figure out your offsets. Lots of extra space to put shellcode. 
You might consider mapping it with a call like this mmap(addr, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON | MAP_LOCKED, 0, 0); or just malloc/free and mlock/munlock, but I've read [elsewhere](http://www.linuxforums.org/forum/programming-scripting/108060-malloc-mmap-virtual-memory.html) that "On some systems using private anonymous mmaps is more efficient than using malloc for large blocks. This is not an issue with the GNU C library, as the included malloc automatically uses mmap where appropriate" (from [section 13.7](https://www.gnu.org/software/libc/manual/pdf/libc.pdf) under MAP_ANON). As per the mmap/mlock manpages, anonymous memory is initialized to zero and having it locked means it's guaranteed to stay in RAM until it's unlocked.
YES. if only Clang would adopt this mindset so we could still get decent performance, AND predictability!
&gt; nr[j] = (1 + rand() % 9); What is this line supposed to do? Did you possibly mean &gt; nr[j] = ('1' + rand() % 9); Also, it is incredible unlikely that a standard library function is broken. Most likely your program is.
If it's more practical, I would also accept a compiler that clearly tells me every time it sees something that's "undefined", "unspecified" or "implementation-defined".
Like http://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html ?
You should print the contents of `mac_address` and `drop` to the console before running the iptables command. Confirm that it looks like you expect it to.
I've tried the command "/sbin/iptables -A INPUT -m mac --mac-source &lt;mac address&gt; -j DROP" on the console and it's returning the same error. 
He doesn't want a compiler that throws errors upon discovering undefined behaviour, but instead he wants one that defines these formerly undefined behaviours and sticks to these definitions, ie. the behavior remains the same with different compiler versions
Well, that command works for me. Are you sure that &lt;mac address&gt; is in the format expected by the mac extension?
I don't: Signed integer addition relies on undefined, unspecified, and implementation-defined semantics. That is to say I don't want a warning every time I see: a = b + c; 
Looks like an IPv6 address to me. Try ip6tables. 
I know. But still, software breakpoints are an "examples of modifying the code section of the executable like this". I don't get the bit about shellcodes. SC typically end up in data sections, not in .text. The nop sleds that X-ray adds would not help an attacker in any way.
At the end of the day correctness is more important, but I don't see why it has to be one or the other.
Because the Standard can't guarantee and require absolutely identical function across all platforms and compilers without removing the advantages of supporting different compilers and platforms. Those undefined pieces of the standard allow different compilers to generate different code for different processors, operating systems, etc. Without that, all standard-compliant compilers would be restricted to the capabilities of the weakest supported platform.
In one case, the compiler can simply treat the variable as an address. In the second case, it has to also write `0` to that address before the program accesses it. That's a already a difference of one instruction.
Here's a better example, one which involves aliasing. According to the specification this function always returns 1. int foo(int *x, long *y) { *y = 1; *x = 0; return *y; } However, imagine I called it like this. What does it return now? assert(sizeof(int) == sizeof(long)); int x; foo(&amp;x, (long *)&amp;x); Because x and y point to different types, they're not allowed to alias in `foo`. Violating this is undefined behavior. The compiler can take advantage of this fact to generate more efficient code. Otherwise a write to *any* pointer invalidates all memory and may require additional loads. Here's another example. int x = INT_MAX; x++; What's the final value of `x`? It depends on if your architecture is two's compliment, or something else. So C makes it undefined behavior. If C specifies two's compliment, then all other architectures have to emulate it (slowly) on every add. 
There is nothing undefined about declaring an uninitialized variable. That allows the compiler to reserve the space in memory for that variable without having a value to assign it to. Accessing an uninitialized variable without first writing to it is undefined behavior, however, which allows for various behaviors; if other pieces of code access that variable (as may be in the case, for example, in a multithreaded program or one that utilizes shared memory across different processes), then requiring that the compiler define that value to 0 regardless of whether it has already been written to by other parts of the code would be an unwarranted restriction of otherwise logical code behavior.
Why not just decide on a version of `clang` that is considered the "long-term" version? I don't see a reason to create a whole new compiler.
Can someone write a compiler where that clearly defined, permanently committed to behavior is always "rm -rf /"? 
&gt; Not trying to be annoying but I'm just not getting how undefined behavior allows a compiler to optimize code? `x * 2 / 2` can be optimized to `x` , only if we have undefined behaviour on signed int overflow. Otherwise it might have to consider that `x * 2` overflows to produce a negative number, and then dividing that by 2 would produce a smaller negative number, not `x`. Another case: with out-of-bound memory accessing being undefined behaviour,`p[n] = 4;` could be implemented as a single assembly instruction. But if you want this to be fully specified behaviour, then the compiler would have to, at runtime: * Implement all pointers as "fat pointers", so that for `p` it knows where the memory block of `p` begins and ends * Test `p + n` to see if it would be inside that block * If the test fails, then take whatever fully specified action you want to occur (perhaps this is "do nothing", or "raise a signal"). Somehow I think 99% - 100% of coders would baulk at seeing this simple assignment statement translate into 6 times the code size, and their program suddenly have each pointer take 32 bytes instead of 4 or 8. 
9899 is a code assigned by [ISO](https://en.wikipedia.org/wiki/ISO). They give a number like this to each of their projects. ISO 9899 is C Programming; ISO 9001 is a QA system, ISO 43 is aircraft jack pads, and so on. 1999 is the year the standard document was published. The latest one is 2011. Answering your question: 1. This has nothing to do with Microsoft. 2. Many organizations are stuck in the past. Such as Microsoft. They didn't even begin to implement the 1999 standard until about 2014. My advice would be to use the latest version. 3. `int` is a *standard integer type* and also, informally, a *primitive type*. 
Anything that covers basic data structures such as growing arrays, linked lists, trees, and hash tables is worth reading, I like "The Practice of Programming" by Kernighan and Pike. In my opinion a hash table or a trie would lend itself well to this particular process.
&gt; For example, let's talk about an uninitialized variable. &gt; &gt; how does uint64_t X; help a compiler with anything at all. Do you mean attempting to read it? An uninitialized uintN_t, like an uninitialized unsigned char, is somewhat "safer" than other uninitialized types because it's not possible for these types to have trap representations. But trying to read from them is still undefined behavior (except if the variable's address gets taken, which rules out declaring the variable with register storage class, which in turn avoids the undefined behavior mentioned in C11 6.3.2.1p2). One of the practical reasons given for leaving the behavior undefined is to accommodate something like IA64, which has NaN values for integer registers (referred to as NaT, Not-a-Thing, values, implemented with a dedicated bit). 
One thing you'll see a lot in the programming world is the separation between specification and implementation. C99 and so on are specifications, GCC and Clang are implementations. No one can enforce the standards or regulate the compiler vendors which is why we occasionally get discrepancies in behavior between compilers. However if a C compiler expects to be used by anyone it should at least mostly correctly implement the standard.
Programming languages are there for us so we can express our instructions to the computer in a more abstract way. A standard compiler can't realistically be made because that compiler would have to make x86 instructions, PowerPC instructions, MIPS instructions, it would also have to compile a binary that hooks into Windows APIs, Mac APIs, PlayStation APIs, Wii APIs, Linux APIs. Our standard language covers so many use cases that a standard compiler would just be impractical. But because we have a standard language at least the majority of our code will work on all of these platforms, and that's pretty amazing. In my opinion that's why even with all of these high level languages on the rise C and C++ are still the languages to know. 30 years of being the industry standard for fast and abstract code is pretty hard to beat.
You're right, sorry 
&gt;1.These represent the new versions made by Microsoft? Gah! What are these needles stabbing into my eyes? I think I'm getting a migraine. /u/olderthangif mentioned three standards, but you will also see an "informal standard" based on the first book by Kernighan and Ritchie, called "K&amp;amp;R C." Before standardization efforts, K&amp;amp;R was the only universal authority on the language for some fifteen years. I believe much of the initial standard was taken from industry best practices that developed during that period or widely-accepted library functions that industry lobbied for the committee to put into the standard. Also, C90 is basically a ratification by the ISO of the American National Standards Institute's C standardization effort promulgated in 1989, which is why C90 is sometimes referred to as "C89" or "ANSI C."
&gt;&gt;1.These represent the new versions made by Microsoft? &gt;Gah! What are these needles stabbing into my eyes? I think I'm getting a migraine. All those _s functions in C11 feel that way. 
There is also C95 but it's kinda unimportant. Note that C11 has atomic datatypes with `_Atomic`.
The problem is you don't have most of the data structures you have in C++ at hand, so why don't you just write some of them? Make a generic vector and a hashmap to get started, then build something like a multithreaded rss feed reader? 
Cool, you can make it CLI for starters (I never touched any GUI stuff on C). This is probably going to take some time but you can learn a lot as you go. 
Write an L2 packet sniffer without using libpcap, just raw sockets. Once you're happy with that, expand to L3, then L4.
project Euler
[This article](https://en.wikipedia.org/wiki/ANSI_C) gives some context to the various standard revisions.
Sorry, blog spam like this is not welcome in /r/C_Programming. Please put a little more effort into your posts.
Write something like a CHIP-8 emulator. Pretty easy and fun!
I've never used it, but I did find [cflow](http://www.gnu.org/software/cflow/manual/cflow.html) which might help.
Write a shell, including built-ins like env, cd, etc, using only section 2 of manpages, plus malloc and free. Bonus if you also recode malloc and free.
A simple project could be a simple CLI file copier 
Hey /u/sheriffRAGE I have just started learning C as well so if you want someone to collaborate with send me a message :)
First, you're forgetting to delete the data of every non-root node before deleting the node itself. Second, your way of deleting the list doesn't work when on only 2 nodes. Try this: void super_free( void ) { Node *temp; while ( super_malloc_list-&gt;root-&gt;next != NULL ) { temp = super_malloc_list-&gt;root; super_malloc_list-&gt;root = super_malloc_list-&gt;root-&gt;next; free( temp-&gt;data ); free( temp ); } }
 Variable* newVariable(char* name) { Variable* new_variable = (Variable*)malloc(sizeof (Variable)); new_variable-&gt; name = (char*)malloc((strlen(name))); new_variable-&gt; next = NULL; new_variable-&gt; value = -1; return new_variable; } You're not allocating enough memory for name (should be `strlen() + 1`), and you're not setting the name to anything (only allocating memory for it), so that's why "the variable stays NULL".
Just glancing through your code... this is wrong: Token* popFromStack() { Token* result; if(tokenStack == NULL){ return NULL; } result = tokenStack; if(result-&gt;next == NULL) { tokenStack = NULL; } tokenStack = tokenStack-&gt;next; return result; } Since this is homework, I won't tell you why this is wrong... but it is.
&gt; So when the organization standardizes the language, they are adding new syntaxes and importable libraries? In some cases, new versions add new stuff. In rarer cases, a new version of a specification will deprecate a feature that turned out to be a bad idea. In some cases, a new version of the spec will not actually change a feature, but it will clarify how a feature is defined using less ambiguous language. That way compiler writers don't risk interpreting something differently. It's also important to note that "C11" comes from 2011, bu that's when the standard was published. Not necessarily when compilers implemented support for all the new features. It can take years before a compiler supports 100% of the new changes when an updates specification is released. Then a few years after that before most programmers have the new version of the compiler installed. That's why c11 is still a "new" thing, even though it is a few years old. &gt; Do they also regulate compilers like GCC and Clang so there is less gaps between versions of C? The specification exists independently of the compilers. It's just an idealized description of the language as the compilers are supposed to accept it. Anybody can write a compiler that follows the specification, and in general compilers will self report "We now support all the features in the C11 standard!" or whatever.
Let's say you want to remove something from the middle of your dataset. If you have an array, you'd have to move everything over one by one. With a linked list, you can just update one pointer (or two for a doubly-linked list). Now, let's say you want to add things to the end. If the array isn't big enough, you have to reallocate it, which involves copying the whole thing to a new memory location. With a linked list, you just have to allocate the new node and change a pointer in the old last node. Everything that already existed stays where it is. There are a lot of things a linked list would be inefficient for, though. Random access through a linked list could force you to read a lot of pointers. Memory for a linked list is not necessarily contiguous; so, you might lose the benefit of memory locality, causing access to be slower. If you know how many elements you're going to have (or a reasonable upper bound) and don't plan on rearranging elements, an array will most likely be faster. Linked lists have advantages in several situations, though. 
Short answer is that a good instruction set with a good compiler will optimize things to be the same. Read the first part of this comment for a brief example of a naive compiler. http://www.reddit.com/r/programming/comments/4daew9/why_i_wont_do_your_coding_test/d1shb5c
Green Hills Software had a tool called gstack that would calculate the same thing. I haven't seen the same in the free software arena. Max stack usage is mostly an embedded concern since Linux and Windows have automatic stack expansion. You could write your own tool with cflow and the output of -fstack-usage...
https://docs.google.com/document/d/1DYOVYFyWoR8tgIvW0_ZMn5eY8gZrrlirtFZMYkOGYyI/edit?usp=sharing infixToPostfix.h is here. I was compiling as I went through but I never ran the procedures due to it not being done. Not sure if there is a way to check them like that. 
&gt;Pointers are necessary for dynamic memory location, many data structures, and efficient handling of large amounts of data. Without pointers, you'd have to allocate all the program data globally or in functions or the equivalent, and you'd have no recourse if the amount of data grew beyond what you had originally allowed for. I hesitate to use absolutes here, but as far as I know all modern computer languages have pointers in some form or other. &gt;In most languages that use pointers, there are certain sorts of references that are pointers, and perhaps certain sorts of references that aren't, and there is no further notational difference. A Lisp cons cell is a pair of pointers, although a fixnum is not a pointer. In Java, the variable used for the instance of a class is a pointer, but an int isn't. The language syntax doesn't reflect that. &gt;C is unusual in that pointers are optional, explicit, and allow explicit pointer arithmetic. It is perfectly possible to write struct foo bar; struct foo * baz;, and once you've allocated memory for baz you can use both bar and baz to represent struct foos. Since pointers are optional, it is useful to have notational differences. (It's essential in C++ for smart pointers, as given boost::shared_ptr&lt;foo&gt; bar;, bar.reset() has one meaning and bar-&gt;reset() is likely to have a much different one.) &gt;(Actually, explicit pointers were often used in other languages when C was originally being developed, such as ^ in Pascal. C is an older language than most in common use today, and it shows.) &gt;One of C's design goals was to write Unix in, and therefore it needed to handle memory locations in a detailed manner. (C is actually one of a family of system implementation languages common when it was being designed, another example being Cybol for Control Data computers. C is the one that became a big hit.) Therefore, it is possible to manipulate C pointers directly, assigning memory addresses and calculating new ones. This also led to some design decisions in C. C arrays are based heavily on pointer arithmetic, and indeed an array decays into a pointer in very many situations. Passing variables to C functions by reference is done by pointer. There was no strong need for arrays and passing variables by reference in the form that other contemporary languages had, so C didn't get those. &gt;So, the answer is that, in most languages nowadays, you use pointers constantly without being reminded of the fact. In C, and to a lesser extent C++, you use pointers either to do low-level things, or as accomplish higher-level things that there's no special notation for. http://programmers.stackexchange.com/questions/16211/what-are-use-cases-and-advantages-of-pointers
My first real project was a line based text editor like ed. 
Yes, I know the intention. You've done it wrong.
Ascii Pong
I believe that the origin of that optimization is from older processors and naive compilers. For example, if 'arr' was an array of 32-bit (4-byte) integers, then an expression like this arr[43] would require a multiplication and an addition. That is, take the base address of 'arr' and add 43*4 to get the byte address of arr[43]. When put into a loop like this, those extra operations add up: for (int i = 0; i &lt; 1000; ++i) { sum += arr[i]; } In that loop, i is incremented 1000 times, sum is incremented 1000 times, and the address calculations for arr[i] involve 1000 additions and 1000 multiplications. If the loop is structured like this instead: int *end = arr + 1000; for (int *p = arr; p &lt; end; ++p) { sum += *p; } p is incremented 1000 times, sum is incremented 1000 times, and that's it. (Well, except for the extra cost of calculating 'end', but that's a one-time cost) edit: Nowadays, modern processors have instructions that can calculate the address of something like arr[i] very quickly (practically instantaneously). Plus, modern compilers would realize what you're doing in the loop and optimize accordingly.
A function will need to process a bulky data structure whether the arguments are through pointers are not. The large pieces of data will still likely be in memory throughout most of the program, and then the addition of pointers take up a little bit more memory, if I'm correct about both of these things... So I'm wondering if the part of memory where pointers live is in a completely different part of it, where there's less space available or something. If that's the case, that would help it to make more sense. I can look this up but I briefly remember stack, heap, and something else. 
Interesting, as much as I've tried to search around for good explanations on why pointers can help, I don't ever remember seeing it explained like this. Maybe I should try and just think of it as a comparison between two different math problems, when comparing a loop that involves pointers vs one that doesn't, when the goal of the loop is the same. Modern literature on C doesn't seem to dismiss pointers at all though. Could it be that the compiler just isn't as sure what to do with larger data sets. 
This could probably be done with a `while` loop. while( /* model is bad*/ ) { /* regenerate model */ } return model;
pay more attention to how much memory needs to be allocated and under what conditions you should free memory. 
Not really. The guy is clearly doing embedded, do there's no ulimit that you can run.
Recursion should only be used if the problem is well-defined. This problem is not well-defined so I would encourage you to look into an iterative solution instead. There's lots of great content that covers this better than I could so I'll just drop a few links here: http://www.programcreek.com/2012/10/iteration-vs-recursion-in-java/ http://www.cs.cornell.edu/info/courses/spring-98/cs211/lecturenotes/07-recursion.pdf
Your comment got caught in our spam filter. I'm sorry for the inconvenience.
Don't wrote code that way. The stack is only that large. You can make the stack larger, but that's only a momentary band-aid. Instead, re-write the code so it doesn't use recursion anymore.
Pointers live in the same memory other data lives in. The argument `gliese946` is trying to make is that without pointers, you had to make a copy of the bulky dataset every time you pass it to a function, whereas with a pointer, you can just tell the function where the dataset is without actually copying it.
The stack usage isn't the only problem here. You're malloc()'ing lots of memory and never freeing it. Also, you're ignoring the return value for generate_model(), so the 'model' variable each recursion is using is lost and will not be passed back to the caller. Each recursive call has its own stack frame and it's own copy of 'model'.
This is a good topic for compiler design/language design. The problem is that pointers has many unknown factors whereas an array index has none. A pointer can point to before, after and to any random address. An array index always points to an address of the array + ( index * element size ). The unknowns makes it much more difficult, to the point of being near-impossible, for the compiler to make good assumptions without side effects. 
Possibly. Also, a sizable segment of modern C programmers are people who work on embedded systems, and embedded systems are somewhat notorious for having neither sophisticated processors nor sophisticated compilers.
It's not dangerous, it's just that when comparing a signed and unsigned value, the signed value gets promoted to unsigned - i.e. a negative signed int becomes a large unsigned int. This is easy to overlook and can be a source for very frustrating bugs. Sometimes people decide the solution is just to swear off using unsigned values entirely. I don't think this is a workable approach since in C you can't avoid using unsigned values - e.g. strlen or sizeof. It's just one of those things in C you're going to have to learn to deal with. After you've been burned by it a couple times you'll get the hang of it.
&gt; There, I've just written an infinite loop. Even worse, it's undefined behavior because `a` will overflow when it's a signed 32-bit integer. In common practice today this code *usually* results in an infinite loop. The constant 4000000000 would exceed the size of a 16-bit `unsigned int`, permitted by the standard. In that case your loop would stop after 10,240 iterations rather than loop infinitely. 
So, are you duplicating the data set every time you pass it to a function without pointers? Even if the effect of that duplication only lasts until the end of the function, that would make more sense. Still, it sounds like maybe compilers should know better than that. 
Interesting script. Does it just report the stack usage per function? I ran it on my binary with `arm-none-eabi-objdump -d &lt;target_name&gt;.elf | ./checkstack.pl arm 0` and the output was something like this: 100 [&lt;target_name&gt;.elf]: 124 [&lt;target_name&gt;.elf]: 116 [&lt;target_name&gt;.elf]: 116 [&lt;target_name&gt;.elf]: 116 [&lt;target_name&gt;.elf]: 116 [&lt;target_name&gt;.elf]: 116 [&lt;target_name&gt;.elf]: 100 [&lt;target_name&gt;.elf]: 100 I'm already doing stack painting to find out the dynamic usage but the callgraph is just a nice feature to have because it shows the calling tree (like cflow) along with stack usage at each step.
&gt; So, are you duplicating the data set every time you pass it to a function without pointers? Yes. C is a call by value language. For every function argument, a copy is made and that copy is passed to the function. &gt; Still, it sounds like maybe compilers should know better than that. They can't because by passing a value, you instruct the compiler to make a copy. That's what you say the compiler should do.
&gt; I guess it would help more than anything to see a visualization of exactly what is going on when the pointer and pointee is declared, stored, and accessed That StackOverflow question is asking about unoptimized code, so what would probably help one understand why two 'equivalent' statements compile to different instruction under those circumstances is to implement the instruction selection part of a compiler. This step takes an abstract representation of code and figures out some concrete assembly instructions that implement it 'naively'. Once one does this, one will understand exactly why things that seem like they shouldn't matter actually do result in different instructions being selected. (Even when the code actually is equivalent, unlike the example from the StackOverflow question.)
You're guaranteed that all the values of an enumeration can be represented by an `int`. I would put an `int` in your union (even though it's likely the same as `int32_t`, that's not guaranteed) and use that to hold the value.
I was thinking explicit use of the stderr fd was a more secure method, no? Or I'm just repeating something. I have seen so many code insertion exploits caused by printf I've grown a phobia towards it. I suppose doing things like printf("%32s",somestr); would limit this. Kinda sucks, secure devops = longer production time (for me anyway). Anybody know of a free linter that checks for insecure practices? It would be cool if it would yell at you for the mistake and reference an example when it cost company X, y amount of dollars, or something to that effect. A (e.g. sublime plugin) like this would be massive I suppose. 
Would you not also need some sort of tag to tell you which enum type you're using, and some function to tell if the int is valid for that enum?
Not in the way it's used here. You can assign any `int` value to any `enum` type, it doesn't have to be within the defined range for that `enum`. More to the point though, you have to know what type of variable you're expecting on the other side anyway - currently `anyVal` is *not* a tagged union. If you don't know what type of value to expect to be passed to you, then `anyVal` as defined won't help you there. It's only useful for generic interfaces that involve something like callbacks - where you're passing something that will ultimately only get touched by the callback, but the in-between function still has to pass it off (And thus define the type of variable being passed). That said, you are right if you're trying to use `anyVal` to let a function handle a bunch of different variable types. But you have to add some type of tag information for that even without considering `enum`s. After doing that though, since your function can only handle a finite number of types anyway, you can just code all of the `enum` options into your tag options.
An integer is a 4-byte signed number. It simply can't hold a large enough number to represent the 4 millionth fibonacci number. Look at how to store 8 byte numbers, and then look at unsigned numbers (can't store negative values).
Thanks for the reply, my mistake just came to me and I've passed the euler task. in the For loop, the condition should have been: sum &lt; 4000000 - c. 
Thanks elvindude, learnt something new this evening! Good to know what caused the error. 
What do you get out of using this 'anyval' type? You've basically recreated a void, except that anyval is not guaranteed to fit in the space allocated for a void. It's now less useful. The proper way to do this is to use a void pointer ( void * ), and cast and dereference that pointer to the type you need, once you know what that type is. You're adding needless complexity to fix something that isn't broken.
&gt; You're guaranteed that all the values of an enumeration can be represented by an int. The reason I wasn't sure about that is that the compiler we use has the following option: &gt; The `-enum-is-int` switch ensures that the type of an `enum` is `int`. By default, the compiler defines enumeration types with integral types larger than `int`, if `int` is insufficient to represent all the values in the enumeration. This switch prevents the compiler from selecting a type wider than `int`. It's probably irrelevant, since I don't think anywhere in our code we use an enum that wouldn't fit in an `int`, but if the guarantee you mention is true, then I wonder why this is an option to begin with.
Exactly. Said it all.
&gt; You've basically recreated a void I'm going to assume you meant `void*`, since you can't declare a variable of type `void` in C. &gt; `anyVal` is not guaranteed to fit in the space allocated for a void [I assume `void*` was meant]. What, you mean `anyVal` could be *larger* than `void*`? I suppose on a system with maximum 16-bit data pointers, you'd be right, but we don't support such systems. And if we did support them, then that's exactly what I would want; a value large enough to hold a `void*` or a `int32_t`. &gt; The proper way to do this is to use a void pointer ( `void *` ), and cast and dereference that pointer to the type you need &gt; What do you get out of using this `anyval` type? What we get is *avoiding all those horrible casts*. (Although I'm not sure why you mentioned dereferencing... you can't dereference an integer.) We had to get our code running on 64-bit systems, to support iOS (which now mandates 64-bit support). With about a million lines of code, the only way we could feasibly do that is turn on a lot of compiler warnings as errors, and use that to identify unsafe operations. And all the casts that are required to use `void*` for passing integers are exactly the kinds of things it complains about, and rightly so. With this solution, there's no need to cast. If the data you're passing around is a pointer, use `anyVal.p`. If it's a function pointer, use `anyVal.f`. If it's an integer, use `anyVal.u32` or whichever size is appropriate.
Let's look at the standard (7.6.2.2): &gt; The identifiers in an enumerator list are declared as constants that have type `int` and may appear wherever such are permitted.^109) An enumerator with `=` defines its enumeration constant as the value of the constant expression. If the first enumerator has no `=`, the value of its enumeration constant is 0. Each subsequent enumerator with no `=` defines its enumeration constant as the value of the constant expression obtained by adding 1 to the value of the previous enumeration constant. (The use of enumerators with `=` may produce enumeration constants with values that duplicate other values in the same enumeration.) The enumerators of an enumeration are also known as its members. &gt; Each enumerated type shall be compatible with char, a signed integer type, or an unsigned integer type. The choice of type is implementation-defined,^110) but shall be capable of representing the values of all the members of the enumeration. The enumerated type is incomplete until after the `}` that terminates the list of enumerator declarations. The important part is to distinguish between the enumerated type and the type of the identifiers. The former is implementation-defined -- and your implementation allows forcing the value to be an `int`. It's legal for the enumerated type to be any integral type, signed or unsigned, as long as it can represent all the values of the members. On the other hand, the members are of type `int`, regardless of what the enumerated type is. So, it's fair to assume that an `int` could hold any valid enumeration member. Now, where this gets tricky is when we consider enumerations that don't hold a valid member. For example: enum E { A, B } e = (enum E) 2; *Is this undefined behavior?* I'm looking for a definitive answer on this, but my searches are giving me conflicting ideas. It doesn't help to add C++ in the mix, especially C++'s new `enum class`, for which this looks to definitely be undefined behavior. It might only be OK if the value is between the minimum and maximum members of that `enum`. Regardless, it's something worth considering briefly: what would happen if something larger than an `int` (isn't a valid enumeration value anyway) gets put into this `int` inside your `union`?
I don't see how that is correct. The last fibonacci number you calculated is c, so what you are calculating here is checking that the new number plus the sum is less than 4million? How is that the fix? 
Why not write a quick test program to time both signed and unsigned in a lengthy loop and let us know which is faster on your setup?
I agree with the other comments saying this would be better written as a loop. Is there any reason it was implemented using recursion and not a loop that we may not be aware of?
The enumerators have type `int`. The type of a variable declared as enum may be different but that doesn't matter since we are storing the value of the enumerator in the union. There is no such thing as "enum that wouldn't fit in an int" in Standard C. (If you did have such a thing, it'd be a compiler extension).
Interesting, maybe unsigned values are being promoted to signed in whatever operation is happening in the test and that is adding some time?
It will make you feel good to know that fully half the bugs in the earliest Windows web browsers were from wrapping 16-bit ints because all the other engineers writing the underlying cross-platform code were used to 32-bit Unix macihnes. 
Yes, but given that integer overflow wasn't known, I was aiming for simplicity than 100% accuracy.
Sorry, I should have included that I did this, so I don't believe this is the problem. 
&gt; The issue is occurring with open() - every call fails (returning -1). Print out the error number upon failure. You can't know what's going on if you don't know *why* the call is failing.
I included a perror statement. What is output when you run the code I posted?
And if you manually cd to that directory and try to cat the file? # cd /proc/1/ # cat stat
cd /proc says no such file/directory...
You don't have a /proc directory on your system? What OS are you on?
Will take a look at your code when I get home. Btw not an experienced C programmer. Currently studying computer networks and security and one of the encryption algorithms we learn is AES ofc. So I'm curious how you implemented the algorithm : )
Use the `perror()` function to print the reason of failure and an error number.
This is what I'm asking, how do you know you're interpretation of the values maps to the same enum type?
Ah, I see your point, you can probably disregard my comment then. The advantage of `container_of` would be that in some cases you could embed that event-specific data into your event object and avoid all the allocating and freeing. But it depends on the situation. If you're already using such a thing it's probably not worth changing it - and in some cases `malloc`ing the data can be useful.
Yes.
If you want something that's at least 16 bit but don't otherwise care, try int_fast16_t. 
Rotate it 2 more times.
It tells everybody who reads your code that this variable should be at least 16 bits in size and use the fastest data representation available. All these datatypes are about making the intention when you write clearer to anybody who reads the code. All these datatypes are typedefs of the basic types anyway. 
This would work, but (I didn't look at the code) wouldn't it be better to make degrees negative?
I know that /proc isn't a system call. I meant with open(), close(), read(), write(). We were limited from using strlen() and fgets() and stuff like that essentially...
You don't initialize `neighbors` to 0 in `countNeighbors`. The extra calls to `refresh` just happen to clear this memory on the stack so that your program works almost correctly. Valgrind detects this problem and will warn you about it. It's a good tool to use when you're having weird problems like this. 
In many cases it doesn't actually matter what size it is. Unless I have a *lot* of them, I don't use an `int16_t` over a plain `int` as plain `ints` are easy, fast and usually sit on word boundaries. The main thing is to recognise what the libraries you are using are themselves using and predict those problems. For example, if a library uses [`size_t`](http://en.cppreference.com/w/c/types/size_t) and you cast it to an `int` then it might work in 32-bit modes but not in 64-bit.
[valgrind.](http://valgrind.org/)
I dont want to sound condescending. I hope i dont come across like that. My suggestion is always using Google first. Google gives you answers for pretty much everything. Best of luck and happy programming!
You have a number of mistakes. Try: gcc -W -Wall -Wextra -std-c11 -O0 file.c Then is it doesn't do what you think it should: gdb a.out
`--track-origins=yes` can also help. If you compile with debugging symbols (`-g`), `valgrind` can then tell you exactly where the leaked memory came from.
X=1 should evaluate to true(It also sets x to 1 in every iteration of the for loop). It should enter the for loop. Then the if (x%i ==0) should always fail (it should pass for i=1) and so it doesnt go into the while loop ever 
Thank you for that information. I indeed know that but still wanted to implemented the ECB mode first and will later go on to CBC, etc. I also added a remark in the README to please actually use professional implementations in real code as this is mainly a understandability implementation - so thank you for that remark too!
FUZxxl, thank you very much! That is some very helpful feedback! I also basically implemented every remark of yours and will go on to write a better Makefile next. Two rationalizations by me though: - I implemented the keySize as a parameter to check if it actually has the right size. As I have learnt it one can never be too wary when it comes to API calls. - I did not shorten state[i] = state[i] ^ expandedKey[(16 * round) + i]; as I like to write it out when it fits in 80 characters. I haven't seen any decisive Coding Guideline against it yet. So again, thank you very much for your feedback. Good day!
no worries, thnx though 
What do you mean with [your args]? 
Ah, you changed `perror()` to `printf()`. Don't do that. Error messages go to `stderr`. Use `fprintf(stderr, ...)`. And think again if you *really* want to abort the program on API misuse. &gt; I did not shorten state[i] = state[i] ^ expandedKey[(16 * round) + i]; as I like to write it out when it fits in 80 characters. Do as you like, but repeating yourself gets tiresome after a while. &gt; - I implemented the keySize as a parameter to check if it actually has the right size. It's not going to help. A typical user is going to call into your API like this: aes256_ecb_encrypt(input, size, key, 32, state, state_size); They tried to add similar redundant “just for checking” parameters to standard C functions (cf. ISO 9899:2011 Annex K) and they turned out to be [utterly useless](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1967.htm).
Oh and please remember to make the tables not just `static` but also `const`! Otherwise they can't be shared between multiple instances of the same program as the program could modify them. It also helps the compiler if it knows that the tables are not going to change. You also made a couple of variables `static` that should not be `static`. `static`, unlike `register`, is not a magic word that makes your code faster. It changes the meaning of your code (namely, the content of the variable is shared between all instances of the function including those concurrently running in another thread). You should only use `static` where you either need the semantic of `static` or for performance where the semantic doesn't make a difference.
I can't because the answer depends on how the hardware and software you haven't shown to us works. If this is a question on your test and you have no clue what any of this means, perhaps you should re-take the class.
Doing homework for you is really not an effective way to have you pass your class in the long run. If you could tell me where you are stuck and what you didn't understand, perhaps then I might be able to give you the ability to do the homework yourself. Also, the datasheet is not enough. I also need to see how your serial driver works (the one that supplies `getch()`).
Perhaps you can find someone else to do your homework.
This paper gives perspective to golang's roots. There are aspects to unix that make Pike and his community uncomfortable. A highlight in the paper is the unwieldy nature of the BSD sockets API, pages 7-8. Previously that community tried to expose a better way of the world by creating an OS platform that suited them - plan9. On the second attempt they tried to create a virtualisation layer that sat on multiple OSs and offered basically the same ideas - Inferno. Each had some effect on mindshare but failed to get mainstream traction. Pike noticed that perl dominated because it was a general-purpose, garbage collected, high-level language. So their third attempt has been to create a language infrastructure that captures the ideas. To whit, go networking module offers 'dial' - along the lines of the plan9 networking example in the paper. This third wave seems to be getting traction. 
You can pass command line arguments to your program. You may have seen the main function in a C program declared as follows: int main (int argc, char* argv[]) Argc contains the amount of arguments passed to your program, and the array argv contains what you passed to the program. So for example you could run your program as ./myprogram hello world. Argc would contain 3 and the array would contain {"myprogram", "hello", "world"}
[“Considered Harmful” Essays Considered Harmful](http://meyerweb.com/eric/comment/chech.html) Though it is a good article, it just needs a better name!
I agree about TTY being disgusting. It's emulators emulating emulators emulating the idiosyncrasies of teletype hardware that can only be found in museums. However, I *do* generally like ANSI escape codes, though its specifics aren't great. Having metadata in-band with data incredibly simplifies the sorts of problems escape codes solve. I can pipe color output into a pager and have it displayed in color. If they're included when dumping output to a file (which, admittedly, is usually *unwanted*), the escapes are trivially "played back" when dumping the file out to a terminal. Escapes go over a network connection (SSH, Telnet, etc.) without any special support. There hasn't been an alternative that works nearly as well. Windows has console functions, allowing programs to do many of the same things out-of-band. But it loses all of the above benefits. 
Wow I just started reading that book! Haven't finished it yet though. I was also reading the code of the [OpenJDK JVM](https://github.com/openjdk-mirror/jdk7u-hotspot) a week ago and it follows a similar style. The hardest part probably, is actually coming up with an API so abstract that actually works on every platform regardless of implementation and doesn't break for every tiny change you make on your low-level calls. Other than that, if you have knowledge of system calls/instruction sets on each target OS/CPU you can kinda make it work somehow.
Why wouldn't this change to the program work then? int i,j,x; printf("Input: "); scanf("%d", &amp;x); printf("\n"); for (i = 2; x == 1; i++) { if (x % i == 0) { j = i; while (x % j == 0) { printf(" %d ", j); x = x / j; } } }
Not really a fan of abstracting structs. That style is used by WinAPI a lot. Everything is an opaque HANDLE type. It's not really that bad if you know how to use it but it takes a toll on big codebases. The worst thing about using opaque types, is the fact that you can pass handles on many different functions, and the compiler won't give you an error if you pass the wrong handle on the wrong function because it's the same type everywhere! Every HANDLE is the same basically from the compiler's point of view, from thread handles to mutex handles to timer queue handles to whatever else. That makes debugging big applications kinda hard, because you need to keep track of what kind of object each handle variable of yours symbolizes. So you start using Java-y hungarian notation-like names on your variables, for example ObjectOneMtx, ObjectTwoThrd, ObjectThreeEvt etc you get the point. I guess you can get away with it if you don't follow that style and abstract different type of structs with different names like mtx_handle, event_handle and stuff
with valgrind, just valgrind ./a.out
Sorry, did you have a question? Or are we admiring your picture of a bunch of lines on paper?
I ll just repost my whole text
Oh, your image is rotated, which confused me for a while. The first thing to note is that there's no reason to iterate over all the entries in your array. Try this instead. It specifically looks at only the rows and columns you're interested in. for(i=0; i&lt;=l; i++){ for(j=0; j&lt;=c; j++){ tab[i][j] = ' ' ; } }
If I understood this correctly, this is what the Quake engine does, there are OS specific interface files, so like a Sys_Readfile or Sys_FloatTime that all return the same values but use their OS specific functions, but the interface is all the same.
it worked!!! thanks!!
What part do you need help with? scanf or printing the integer? Remember that 123 is just 1 * 100 + 2 * 10 + 3 which means you can print the integer parts pretty easily by dividing by a multiple of ten and bitmasking. You can use the modulo operator instead of bitmasking too. Parsing numbers is in a nutshell just the reverse process. It becomes trickier with floating points if you want very good accuracy and so forth, but integers are very straightforward.
 char* str1 = "string 1"; char str2[] = "string 2"; char* args[] = { str1, str2, "string 3" }; works fine
&gt; the second argument is a pointer to a char Whoops, `int args[]` should've been `int *args[]` in the first place. My bad. But since it's an array of pointers to characters, it should be `char *args[]`. Although the difference between ints and chars is subtle in this use case and you should look into it. &gt; you can't really have array strings can you? I'm not sure what you mean by array strings. Do you mean just strings in general, or arrays of strings? "Strings" in C are simply arrays of characters. So in order to have an array of "strings", you can have an array of pointers to chars, with each pointer to char being the beginning of a different "string". edit: "pointer to char" in the last bit instead of just "char"
Thanks, and your right, my original question was poorly worded. What I meant is an array of strings. I appreciate the help
Yeah I guess they would have to be allowed. The first thing they taught my class when learning parsing was strtok to I've always used it when parsing.
Why does the program crash when you try to change all of the variables to floats? #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ float a, b, c, d, e; scanf("%f", &amp;a); b=a*33.7; printf("%f\n", b); scanf("%f", &amp;c); d=c*a; e=d/b; printf("%f\n", e); } Also, when I used your edited program only certain inputs worked. Why is this?
Can you give an example of it crashing? Or certain inputs that don't work?
You appear to be shadow banned. Please talk to the admins to resolve this problem.
Just check if either of them applies.
&gt; What you are asking is for printf to interpret the underlying 4 bytes of e as an IEEE 754 floating point number Not even that sometimes. E.g. on x86-64, different registers would be used for passing int to float, so the output is completely unrelated to the int value. 
No prob. There are times when it's useful to cast the argument to toupper() with (unsigned char) -- because it expects an int argument that's either EOF or a value that can be represented as an unsigned char -- but I'm assuming you're just writing a toy/exercise program.
Please don't ever write actual code like this. Also, it won't work as written. Honestly, /u/SQLinjectionsection , if what you have works, it's what I'd use. There's no need to overcomplicate things. The code OP posted was clear and concise. Unless he's got thousands of these to do, it's probably best to just do the calls directly.
 case 'A': case 'a': if(in == 'A' || in == 'a') if(tolower(in) == 'a') if(toupper(in) == 'A') if(in &gt; 0x60) in -= 0x40; //equivalent to in = toupper(in) for ascii EDIT: See Hali_Com's comment below.
You can check some of these challenges out. https://imgur.com/qrsVBpA
 for(int i = 0; i &lt; ARRAY_LEN(args); i++) { args[i] } You don't see any problems with that? 
Having had to work on code that was written by someone who thought macros simplified things, I can tell you that stuff like this makes life hell for future developers. If you're incapable of writing for loops correctly, you need to either find another language or find an IDE that autocompletes things like that. Anyone who writes C should know how to determine the size of an array using the sizeof() operator. There's no excuse for hardcoding it or hiding it in a macro. It's just one more hoop for a future developer to have to jump through to debug. Code it as you meant it. The way you determine the size of an array will never change, so there's absolutely no value in hiding it in a macro. This is of course, just my opinion, as someone who's worked on code developed by people that just love abusing macros to make loops. So much time wasted. The customer of the code you write is a future version of you, who doesn't remember all the cute macros you wrote or which of the 300 include files you put them in. The compiler is not the customer - the developer is. Simplicity, clarity, brevity, and ease of maintenance are all crucially important, and macro abuse does not aid any of them. That said, I've certainly done my share of abuse. I would never recommend a 'FOREACH' macro like you've developed above - I'd recommend that they perhaps consider a better language like befunge or Ook! C is, clearly, not the language for them. 
&gt; It's just one more hoop for a future developer to have to jump through to debug. How so? gdb steps through this macro *exactly* as it does step through the macro expansion. It is a very straight-forward translation. &gt; The way you determine the size of an array will never change, so there's absolutely no value in hiding it in a macro I don't want to read a division between two sizeof expressions -- which is exposed potential precedence bugs and is just unreadable. `ARRAY_LEN` is just far more readable, less error-prone and thus more maintainable. &gt; abusing macros to make loops When you're hiding the loop body inside a macro, I absolutely agree. When you only hide the "for()" statement (without the block), it's not an issue. &gt; who doesn't remember all the cute macros you wrote And doesn't understand ARRAY_LEN?? &gt; or which of the 300 include files you put them in Who cares what header file they come from? Also, we've got TAGS navigation at the very least (or eclim for the more fancy users). &gt; Simplicity, clarity, brevity, and ease of maintenance are all crucially important, and macro abuse does not aid any of them `ARRAY_LEN` is *simpler*, *clearer*, and more *concise*, thus also easier to maintain. So it helps all 4 of these, and is thus irresponsible NOT to use. 
Whoops, you are absolutely correct. I wasn't thinking much by the end of it. Nice catch. Bad Chase, Bad! No code haiku's for you tonight.
it goes to a label. so you have a couple lines int n=0; potato: n++; if(n&lt;20){ goto potato; } that will increment n until it is 20 its really nice for simulating state machines or doing things that are awkward with the available constructs in c 
You don't need to, the ability is more or less just taken out of newer languages.
A label isn't a variable. It's a name for a place in your code. When the `goto` statement is reached, execution continues from the given label.
If your code for instance has many exit points. Under various conditions and all those exit points need to be handled either similarly or in some uniform way, I would use a goto in that case. Example would be if you have to free some memory before returning and you can return from many places in a program under error conditions, then well yeah use a goto. 
In theory, I agree. It looks like a cool tool to use. I don't honestly know what the historical reasons were to take it out of modern languages, perhaps some sort of performance issues? Anyways, so far, I've not yet gotten to a point where I were to say "Man, I wish I could use goto here.". Also, at my university we were taught to avoid it at all costs, and that supposedly only the best of programmers really know when the use of goto is justified. 
"Butt buuut, for readability via excess redundant code and/or convoluted loops, wrap that in curlies and copy-pasta your free-ing code. My professors says it's the devil so it must be tru!"
As far as I know, `goto` is the cleanest way to break out of nested loops. There are two retorts people usually give: "You should make your nested loops into a function and then return from that!" -- Function calls can be expensive, and as such changing performance-critical code into functions is not possible.
Handling errors is a very sensible use for gotos. Higher-level imperative languages have fancy constructs like exceptions and using blocks, but C doesn't (and shouldn't) have those, so gotos are a great way to structure robust code that handles a lot of resources.
&gt; Anyways, so far, I've not yet gotten to a point where I were to say "Man, I wish I could use goto here.". Getting out of a nested loop is much simpler with a goto.
I wish C had named loops like perl where you can specify a label with break or continue. In the meantime, goto it is.
&gt; In theory, I agree. It looks like a cool tool to use. I don't honestly know what the historical reasons were to take it out of modern languages, perhaps some sort of performance issues? In the past, when compilers where dumb and computers where slow, people would write spaghetti code composed of extremely long functions with liberal jumps all over the place instead of slightly more expensive function calls. Out of this situation, the [goto considered harmful](http://ce.sharif.edu/courses/90-91/1/ce364-1/resources/root/GoTo/Dijkstra.pdf) sentiment was born. Structured programming was seen as the solution to the problem of unmaintainable code and one of the core ideas of strict ivory-tower structured programming was to forbid the use of all unstructured constructs. The goto statement was the single most powerful “unstructured” construct and to encourage people to not use it, it was left out of a number of languages designed after 1980 or so. However, other authors [argue](http://fuz.su/~fuz/structured-programming-with-the-go-to-statement.pdf) that the goto statement is neither the cause, nor a contributing factor to unstructured code. Rather, the way people structure their code is deeply connected to how they learned to program and careful use of goto can enhance the structure of programs. I believe that most programmers who learned how to program in the last 20 years would not ever write the kind of spaghetti code that led people to see goto as an abomination. The use of subroutines and loops for control flow has been hammered into the heads of young programmers (and they never learned anything else) and they tend to write code that is acceptable. However, professors who know the horrors of spaghetti code from the 70's (and a lot of people who follow their words without reflecting) still keep pushing the “goto is evil” meme despite having little to know hard reasons why goto is a problem. It's the same way in which some people believe that pointers are evil because they've seen so many bugs coming from sloppy pointer bookkeeping, whereas modern languages like Go allow you to use pointers in a perfectly safe yet useful way. To me, goto is a sharp tool that can give an advantage when used correctly but hurts you when used without thought. I use it where appropriate. Often, I begin to write a function with goto in the control flow because that's what I came up with when finding a solution. Later I can usually turn these goto statements into loops or other “structured” ways of control flow. However, without goto, coming up with the initial control flow would be much harder because I cannot write down the control flow as it comes in my mind. This makes programming in languages that do not provide goto (like Java) tedious to me. There are also certain [programming idioms pertaining to resource allocation](https://www.reddit.com/r/ProgrammerHumor/comments/3p7j1b/hes_the_most_hated_man_in_software_development/cw46say) that demonstrate how useful goto is. You should keep these in mind.
It still does, when you're working at the machine level (whether producing bitcode, machine code, or assembly).
It can get ugly, though. See, for example, the error-handling code in libJPEG. `setjmp`s. `setjmp`s everywhere.
Yes, but there's a reason we have high level languages :) And unlike some other constructs, it shouldn't have ANY performance impact because a compiler will produce the same assembly output.
There's a reason we have low-level languages too.
It's done all over the place in Linux kernel drivers. Grep for it in the kernel source code and look at some examples.
Yes, but of course only if it simplifies flow of control. If you have to break at every error condition and execute some piece of code to free memory ( or any cleanup, or some form of exception handling for that matter), and if you have to do this many times- might as well use a goto. See, goto is an unconditional jump. Compiler uses a lot of unconditional jumps in your code to optimise. They are not inherently bad, in fact are almost always used under the hood. The issue is a lot of bad programmers end up using goto as an excuse for bad practises, or what rather could much easily be done using simple loops. But if you have irregular corner cases, ( typically error conditions/exceptional control flow) then goto statements can provide a streamlined way of exiting instead writing the same code again and again. 
I'd also argue that breaking a nested loop into functions is not always good for more reasons than just performance. I could list them here but [this article by john carmack](http://number-none.com/blow/john_carmack_on_inlined_code.html) covers what I'm talking about.
I was on a phone before, now I'm at a computer and can properly type. I'm not saying this is necessarily a great example of a kernel driver, because I picked it at random, but it's the driver for a GPIO mouse. This particular function is the "probe" function, which is called by the kernel when the driver needs to be initialized. Note the use of gotos to "unwind" or "undo" the initialization in error conditions. If one of the set-up steps fails, you can't just leave leave the driver as it is because it could cause memory leaks or other badness... you generally need to clean up after yourself in the reverse order you initialized. So if an intermediate step fails, the author used gotos to jump to the correct spot in the "clean up" section of the function. https://github.com/torvalds/linux/blob/master/drivers/input/mouse/gpio_mouse.c#L48
:D
A label is more like a line number than a variable. It's a meta kind of thing. If you're using GCC for compiling things, try out the -S option. It outputs the assembly generated for your code, so you can go in and see how labels work at a lower level. When you use a label in C, you're inserting your own into the assembly, and when you `goto` that label, you're telling GCC to put a `jmp` to that label in the assembly. Assuming they don't do optimizations on `goto`s.
Grep = text search Linux kernel = The code found [here](https://www.kernel.org/) *Linux is an extremely popular open source operating system, similar to Windows or Mac OS in goals. The kernel is the most critical part of the whole thing that boots the computer and talks to the hardware (among other things).
"Extremely popular" Citation needed
&gt; Function calls can be expensive, and as such changing performance-critical code into functions is not possible. `inline` all the things!
I'm pretty sure you can break (or continue) out of several loops in java, very much like goto. Don't know about other languages though.
This is not true. Most tips are universal and suitable for both C and C ++.
In 2013, 1.5 million new android phones were activated each day, 48 billion apps have been installed from the play store, and one billion android devices have been activated in total. It is difficult to know how many supercomputers there are, but of the one registered on sites like top500 et al, almost 99% run linux When it comes to servers, nobody really has any very clear answers as to the popularity of different operating systems, but I've never seen any estimates where linux wasn't the most popular OS (although the numbers given vary anywhere from like 30% to 90%) For embedded it's also pretty popular and rapidly on the rise (esp. in automotive), although there are some niches where it can't go (due to technical or legal restrictions) and other systems reign supreme. That's just from spending two minutes on google, I'm sure there are more applications of it that I've never heard of. So ye, it's pretty damn popular.
Well, quake is a competitive game where frames can matter.
There are some missing details here if you don't want the crude approach. It seems each move eliminates any food within a rectangle whose bottom-right corner is the move square. Is that correct? What's the game configuration at the start? Is the venom square always in that corner? Are there any constraints on the moves?
The moment someone made a Linux distribution that didn't have X11, root access and a nice 3d accelerated environment, of course it sold. The same could be said for XNU. Linux and NeXTSTEP failed on the desktop, but have done pretty damned good on mobile space, unlike Windows NT.
Labels are like variables as in that they're named entities. But that's as far as the similarity goes.
That is correct, but only resources specifically about C are on topic in /r/C_Programming.
Christ, could you be any edgier?
Then you add more and more processors. We have 32 CPU machines with 24 cores each, with terabytes of RAM. A few bytes doesn't mean anything anymore, you just get more hardware. Oh of course you are an embedded guy, as I said unless you are trying to live on a small machine/footprint it doesn't mean anything. Just get a bigger machine. Source: I've been running horribly written piles of shit applications for decades, and even help write ones that leaked, but just got bigger machines, every cycle that run longer, and faster. Life moves on and fighting over that 2kb doesn't mean anything. Even spaceships run JAVA.
I'm not writing a Wikipedia article, I'm casually informing a single person who had a simple question - using informal language. I won't get dragged into a pedantic debate about whether my use of a qualifier is technically justified.
&gt; The moment someone made a Linux distribution that didn't have X11, root access and a nice 3d accelerated environment, of course it sold. Unlike those lame x11 GNU/Linux distros RHEL and SUSE which of course sell nothing right? /s
Compared to android? yeah they don't sell anything. Go back to the millions of activations PER DAY.
In Java, there is a special form of `break` that allows you to break out of multiple loops at once.
Yeah, Linux's domination of the server market as well as embedded devices shows what a niche kernel it is. Android is a failed platform since Google gives away the OS for free and doesn't sell it to OEMs. /Sarcasm
Sorry, I wasn't paying attention and thought you were the same person who posted [this comment.](https://www.reddit.com/r/C_Programming/comments/4im6vs/goto_is_always_bad_except_when_it_isnt/d2zo323)
Anyone who labels some aspect of code as "always bad" tends to be merely regurgitating rules rather than demonstrating an understanding of principles.
yea fuck assembly for giving us the ability to jmp 
&gt; sometimes you have semaphores or mutexes to release &gt; Then you add more and more processors. I just... what? 
xor sum sum sum label1: add sum sum i add i i 1 jlt i 10 label1 &lt;unnecessary string arithmetic&gt; &lt;decrement stack pointer, jump to callback pointer&gt; 
How is that a nasty state? That's exactly equivalent to a do-while loop.
I have almost every achievement. I really liked the challenge to complete signal comparator without any conditional branches.
I'd just like to interject for a moment. What you’re referring to as Linux, is in fact, GNU/Linux, or as I’ve recently taken to calling it, GNU plus Linux. Linux is not an operating system unto itself, but rather another free component of a fully functioning GNU system made useful by the GNU corelibs, shell utilities and vital system components comprising a full OS as defined by POSIX. Many computer users run a modified version of the GNU system every day, without realizing it. Through a peculiar turn of events, the version of GNU which is widely used today is often called “Linux”, and many of its users are not aware that it is basically the GNU system, developed by the GNU Project. There really is a Linux, and these people are using it, but it is just a part of the system they use. Linux is the kernel: the program in the system that allocates the machine’s resources to the other programs that you run. The kernel is an essential part of an operating system, but useless by itself; it can only function in the context of a complete operating system. Linux is normally used in combination with the GNU operating system: the whole system is basically GNU with Linux added, or GNU/Linux. All the so-called “Linux” distributions are really distributions of GNU/Linux. 
I cried when I saw that one. It took me a couple hours just to get the signal comparator to *work.* I felt dumb. :(
... I thought the divider was easy.
okay, the divider wasn't that hard. it's just a loop. okay, I liked the prolonged sequence sorter, because it's bucket sort. :D I haven't finished the prime factor one, the spatial path viewer, the sequence mode calculator, the dynamic pattern detector, the sequence gap interpolator, or the signal exponentiator.
It sounds like you're saying the term, "high-level language," is meaningless because someone can always come up with a language that is yet higher. Then let me reword that. If a language supports structured programming, e.g., if-then-else, one should never use goto.
We actually never looked into data structures in my module. That's definitely something I should look into. I'll take a look at that subreddit thanks very much :)
Do you know C? Have you read the GCC manual? 
the printf statement ( textLenght * 100.0 ) / textLenght) is supposed to return 100% but any subsequent iterations need to return the frequency of each character as a percent. corrected %c, the array is supposed to take in the letters of a phrase, wasn't sure if I should count each character individually or if there was a better way to do it in an algorithm using the array, and I'm horrible at math so calculating text percent is even holding me up.
Oh then you should definitely start with data structures. Very important I would say. Linked list being the most common one.
I would just store it as an int with units of hundredths and only deal with the decimal when printing.
What do you want to learn? Just invoke gcc like any other C compiler that follows [the standard interface](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/c99.html).
You literally have no idea what you're talking about.
FACEPALM. That is SO EASY it hurts. Holy mother of God. I've been programming since 6am and came across this "problem" about 3 hours ago. My head just exploded. Thank you.
The comment I replied to described Linux as "similar to Windows or Mac OS in goals". I usually consider Windows or Mac OS as operating systems targeted towards desktops, so that is the context I was evaluating it under. 
You will go further with it if you make a project that interests you. But only you know what that could be.
That particular print statement (`printf(" ALL %5d %9.2f%%\n", textLenght,( textLenght * 100.0 ) / textLenght );`) comes before your loop. It depends only on the total length of input and will only run once. Notice that in the math, `textLenght` cancels with `textLenght` and the resulting expression is just `100`. Try plugging in some actual numbers if you're unsure of the math - for small things like this it's very manageable. Using an array to track occurrences of characters is completely fine in this program. In fact, you will find that it is difficult to do anything with characters if you work exclusively at the string level. Just keep in mind that if you want to use that information later (for output, processing, etc), you have to actually access the array. Since you modified the array contents with `asciiArray[textChar]++`, why not use a similar indexing strategy to access the contents? For example, `printf("[%d]: [%d]", i, array[i])` is a simple way to dump the contents of an array using `i` from some loop. Don't give up on the math so fast; calculating percentages doesn't involve any fancy math. Besides, you already have a percentage calculation in your program: `( textLenght * 100.0 ) / textLenght` is the percentage of `textLenght` that `textLenght` is. More generally, `(number * 100.0) / total` is the percentage of `total` that `number` is. Again, run some small numbers if you don't trust the math. Not printing redundant statistics for characters that did not appear is a simple matter of checking before printing. You're using a loop so I assume you know about conditionals (`if` and `else`). Given `asciiArray`, it's easy to check whether or not a character appeared.
it's a copypasta https://www.reddit.com/r/copypasta/comments/3d7iqd/spawn_of_richard_stallman/
never mind, got it, thanks!
Nice writeup. I do kind of think it would be hard to cram all of that into even a junior or senior level undergrad class. And you'd also have to deal with realities of some students are going to 'get it' much much sooner than others, and they will be the minority. I think theres a lot of value if you apply these ideas in a unified manner across a couple of different classes, such as a baseline C/lowlevel programming class followed by Operating Systems taught in C.
Your comment got caught in our spam filter. I'm sorry for the inconvenience.
Don't use `atoi`, it doesn't do error checking. Use `strtol` and if you want to receive a floating point number, use `strtod`.
Thanks you very much sir. 
google project euler 
Well, depends on use case. There are plenty of times you're doing this in a tight loop and you already know you have clean data (say because it came from a DB column that can only store constrained clean data). 
You're reading out of bounds of the regs array. Writing out of bounds on it too.
Thanks, I'll implement some checks
It looks like you're using PC plus an offset for indexes into your regs array. Assuming PC is program counter, that doesn't sound right unless it's an array longer than the number of instructions in the bytecode you're evaluating. Edit: or is PC the current opcode? Still odd, but means regs only needs to be bigger than the number of opcodes in the instruction set.
dope. This looks awesome. I'm going to dig around the src and write some examples when I get some time. Also, minor doc point, c-cl-file needs quotes around the filenames. Got confused for a second.
PC is indeed the program counter, but I am in the process of turning the VM into a corewar like VM, which means the addresses are relative to the PC. The memory is also circular
I added the -std=c99 command into the parameters of the compiler but it's still gives the same error.
Ahh, I put the parameters in an incorrect option. Trying again now. EDIT: It looks like your solution actually works out well. I think it outputs all that's required too.
Here typedef cell cell; you missed a struct typedef struct cell cell;
You have to clear and test errno, and you have to examine the returned values to understand what error occured when errno gets set. So, it obviously is more complex, and it's also going to be slower. By how much would depend on what error conditions you're checking for. If you don't care about errors, there's no difference between atoi and something like "strtol(ptr, NULL, &lt;digits&gt;)", except that the latter is slightly harder to comprehend. 
As I've already stated, there is a completely valid use case for atoi, and you just pointed it out: when using strtol and endptr can never point to anything but a null byte. If you care about errors, because you're dealing with input that might not be clean, yes, use strtol. But, then you need also do more than just check endptr. 
I used Google. I already knew about atoi and all the other functions. I wasn't looking at the problem the right way. I was trying to convert a string to a double, but I needed to convert a string of cents to dollars as a double. Even though I knew it represented money, I wasn't thinking in terms of cents and all I needed was a $'s worth. Btw, I had to divide by 100.0. char sNumbers[5] = "54302"; int iNumber = atoi(sNumbers); double dNumber = iNumber / 100.0; dNumber is now 543.02
I do not know lisp (or scheme) very well but I think Chicken Scheme may do this as well. Can you explain how lispc is different from chicken?
To fix the first error in the Valgrind report, change MAX_PROG_SIZE in stor.h from 128 to 256. While you're at it, change MEM_SIZE in mem.h from 1024 to 256. And note that REG15 (regs[15]) in regs.h is out of bounds for a 15-element array. The other Valgrind errors occur because of this in processccu() in ccu.c: inst = PC; a = PC + 1; b = PC + 2; c = PC + 3; You'll want to change that to the following (note that readmem() in mem.c uses PC-relative addressing): inst = readmem(0); a = readmem(1); b = readmem(2); c = readmem(3); As a matter of good practice, loadprog() in ccu.c should be changed to use writemem() in mem.c instead of accessing mem[] directly -- otherwise, you're breaking the interface contract. In all these cases (including the four lines in the suggested fix), you'll have to decide how you want to adjust for the load address. The final thing isn't a source of any current errors, but it's asking for trouble. From regs.c: uint8_t i; i ^= i; regs = malloc(0xF); while (i != 0xF) { regs[i] ^= regs[i]; Initialize i and regs[i] to 0 explicitly (as you do everywhere else) instead of what you're doing, which invokes undefined behavior. If you do want 16 registers, fix the size allocation. &gt; If they were really invalid wouldn't dvs segfault? Not necessarily. Accesses to memory can be valid from the hardware/OS perspective (so no segfault) but invalid from the userspace perspective. For instance, if your malloc() implementation were to mmap() a whole bunch of pages and place regs[] in the middle, invalid accesses (such as reading a not-too-large number of bytes outside of regs[]) may be perfectly OK from the hardware/OS perspective but invalid from the userspace perspective.
Thanks for sharing the information.
Can you track how many food items have been eaten vs. the area of your array minus the venom? Then when your number eaten == number of available food, break out of the loop.
Could you give me a link in which it is described how to set flags for my environment without the need to state them in the Makefile? That's new to me. Thanks for that
Thank you again for your feedback FUZxxl, I changed the error output to fprintf and removed the static from the expandedKey. In my function declarations I already declared all constant arrays as const, so this should be sufficient as I understand it. I did not remove the keySize parameter from the function as I think it is clear now that this is not the professional implementation but rather one for good understanding (IMHO). I changed the whole abort() situation by declaring the aes functions as int, so I check their value when they return and exit (kind of) in the main - I would love to know what you think about that style! So thanks again for all the help!
&gt; In my function declarations I already declared all constant arrays as const, so this should be sufficient as I understand it. I was hinting at the arrays `sbox` (why is this one defined twice in your program?), `mixMultMatrix`, `invSbox`, and `invMixMultMatrix`. They are never modified, therefore they should be `const`. Making an array in static storage `const` has a performance advantage: The page the array is on can be shared between all instances of the program. This saves memory when more than one instance of the same program is running.
None. It's the same for the compiler. I prefer char* p because it's part of the type of p. Also when you add const to the mix, it's better too: const char* const p This means "p is a const pointer to a const char". Remember to always read the types from right to the left.
Here is the [standard](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/make.html) for make. See section *Macros* for where the definitions of macros are sourced from.
Outside of string and character constants, the compiler generally does not really care about white space.
There's no difference, it's just a matter of preference. Typically C developers tend to put the asterisk with the variable name, whereas C++ developers put the asterisk with the type. There is *one* case where it makes a difference, which is when declaring multiple pointers at once, where putting the asterisk on the left can easily confuse and deceive the reader. `char* a, b, c, d;` = `char *a; char b,c,d;` `char *a, *b, *c, *d;` = `char *a; char *b; char *c; char *d;`
&gt; The line p = new_p is never reached if realloc() fails. Undefined behaviour only occurs when the code that causes it is actually reached. The problem is when realloc() succeeds, where `p` may or may not be live (provenance) anymore: https://www.reddit.com/r/C_Programming/comments/4ge2ci/dangling_pointers_and_undefined_behavior/d2hehd2 From the linked article in the linked thread, and the comment I linked, it seems like any access to `p` (or any other variable that has been assigned to from `p`) is undefined behavior. Am I reading too much into this? Or am I misunderstanding something? Or does "undefined behavior" here only apply to "reading" `p` but not "writing" to it? &gt; PS: Please do not append [tags] to your post titles. We have flairs for that. Sorry about that, I thought using [tag] would actually turn it into a flair. How can I directly use flairs?
I agree that you should not use 'p' in a comparison after free. If you're going to compare two pointers, you should certainly do it before free'ing one of them. 
That refers to assigning the indeterminate value to something else, not assigning to a pointer that currently holds an indeterminate value; int *a, *b; a = b; This is undefined behavior because of b, not because of a. Again, this must be the case because even the simplest program in the world that uses pointers would invoke undefined behavior were it not so. 
Alright. Thanks!
I, and I think most C and C++ devs I know, prefer char \*p, because the asterisk doesn't modify the type of all variables declared after it, only the one immediately following the asterisk. So best to put it right next to that variable for clarity's sake. For example: char\* p, q, r, s; declares one char pointer and three chars despite the appearance suggesting all four should be char pointers. edit: escape asterisks so they show up in markdown edit: fixed some imprecise language
Your asterisks are missing.
If you write to a variable, it's value is not used. Therefore, no undefined behaviour occurs when you overwrite a variable containing an indeterminste value, such as a pointer to released memory.
I prefer `char *p` because it makes sense if you mentally substitute in your head, "The thing referenced by `p` is of type `char`." &amp;nbsp; That'll be handy for more complicated declarations like `char a, *b, **c, ***d`. It says, "When you evaluate the expression `(***d)`, the result is of type `char`."
Everyone else has answered correctly, so I'll add a slight spin on the answer: The difference is only in the ease of reading by people. To the compiler, they are the same (in your example; see the counterexample by /u/eXeC64). 
Btw is edyptula still active? 
Ive been doing that for quite a long time for exactly the same reason. The \* modifies the p not the char, which is clear when you have multiple declarations on a single line. 
&gt; because the asterisk doesn't actually modify the type, only the variable closest to it Note that this is only syntactically speaking. Semantically speaking, the asterisk modifies the type. typeof(char*) != typeof(char).
It is. 
Yeah, no difference. It's just a matter of preference. In my early coding I always prefer to use char *c; but on functions who return a char pointer per example, this didn't feel appellative char *function(); so I always put the * together with the type in all cases for the sake of consistency char* c; char* function();
Which is why it should be with the variable
As you learn C please keep in mind that, unless you are actually entering the International Obfuscated C Code Contest: http://www.ioccc.org/ this is not a style to _emulate_... making the source code as small as possible does not actually improve the efficiency of the compled program. Reading the IOCCC contest winners can be highly amusing, though...
Visual C++ formats this way when you add function bodies through its UI and it is annoying.
The problem is that this doesn't generalize to more complex types. For example: int (*a)[10]; Where do you place the space? 
I format this way, and I would do it like so: int (* a)[10];
how would that work with the people who put the * next to the type?
cool, I kinda like the format, honestly.
&gt;I'm pretty new to programming in C, and pointers are a fun new toy to me right now. I feel like I'm sold on using pointers and pointer arithmetic in place of conventional arrays and array indexing, but I thought I'd ask for an elaboration on the conventions. So to lay out what I think I know: &gt;Say I want a two dimensional array of ints. I can do this two ways: &gt; int a[10][20] Allocates 200 contiguous ints on the stack. Memory management is unnecessary. &gt; or &gt; int ** b = (int **)malloc(10 * sizeof(int *)) for (i = 0; i &lt; 10; i ++) { b[i] = (int *)malloc(20 * sizeof(int)) Allocates on the heap 10 contiguous pointers to int, then allocates 10 regions of memory the size of 20 ints. Each region is not guaranteed to be next to the previous allocation. You need to free each region individually. &gt;so indexing works via pointer arithmetic right? In the heap example, you can try to access an element of the 2d array. If you are lucky, it will segfault. If you are not, it may or may not work - some of the time, and you could end up chasing a bug that is created in one part of the code and manifests in another. &gt;So, what motivated the need for a difference between the notations? Is one "more right" than the other? When would you use one over the other? Write what is easier to read in the current context. //pointer arithmetic int strcpy(char *out, char *in) { int len = 0; while (*out++ = *in++ != '/0') len++; return len; } //arrays int strcpy(char *out, char *in) { int len = 0; while (out[len] = in[len] != '/0') len++; return len; } &gt;Now that I'm done with b I need to free it. When I want to free b, should I also free every pointer pointed to by b? You have to free every valid pointer that malloc returned. Edit: Whenever you malloc, you should always test it. If malloc fails, if will return a null pointer. It could fail for internal or external reasons. 
Simple example consider 2 programs, one uses `a`, the other `b`. Size 2x3 Each get allocated to memory address 0 when the program loads, and the size of a pointer is 1. You layouts could look something like this: http://i.imgur.com/YsuSxTd.png How your memory get allocated is entirely up to your OS. I have no idea what modern OSes do (ASLR, memory virtualization, and related techniques). If malloc fails you CANNOT use the variable as is (you don't have any memory), you can either end your program or try again, what you choose is up to you.
You're a saint, thanks for the learnin
I like this, the idea is conveyed more clearly.
http://www.cs.uml.edu/~canning/101/RLWM.pdf For more complex declarations like [u/peaker asks](https://www.reddit.com/r/C_Programming/comments/4izwrh/what_is_the_difference_between_char_p_and_char_p/d338srm)
I don't know much about programming but guessing it compiles and runs your code.
Would [this](http://www.tutorialspoint.com/compile_c_online.php) meet your requirements?
Thanks a lot, such a basic mistake lol. I know that I needed to initialise 'mean' and that the other two uninitialised ones didn't matter, I simply forgot, but I never realised I could initialise a number of variables in that way, thanks for that. I really appreciate the swift answer. 
Thanks for the tip friend, I'll be sure to keep my code pretty in the future :\^)
Yeah, I didn't know that there were online ones. Thanks!
Any strncmp() with a comparison failure is going to set `b` to 2, and there's always going to be a comparison failure for the simple reason that the function contains mutually exclusive comparisons (e.g., "y" vs. "n").
Also you need to know when you need a little break from coding :)
See if you some task on your PC you need to redo often. Then try to automate by using C. No matter what you program, just doing it stays the best way to learn C.
Thanks for constructive feedback. Also i had idea of multiple storages. About makefile, do you have any good resource how it should be done, how it should look?
First result for "make tutorial" gives me this link: http://mrbook.org/blog/tutorials/make/ This looks like a reasonable introduction. Once you've got the gist of how it should work, just read through the manual for your version of make. Every version comes with many of its own extensions. * [GNU Make](https://www.gnu.org/software/make/manual/) * [FreeBSD make](http://www.freebsd.org/cgi/man.cgi?make(1\)) 
/u/FeelTheEmailMistake nailed it. However, I would add that you should probably use 'unsigned short' instead of 'short'. Shifting a signed value right may sign extend the MSB, which could shift in '1' instead of '0'. 
I would just look around github. Tons of great projects on there. 
It makes the p a pointer to char. Which is clear because: char *p, r; r is a regular char here, not a pointer to a char. If it modified the char, both would be pointers to char. 
Please note that "simulator" is not the correct term here. All that site does is compile your code (using a compiler) and execute it (likely in a virtual machine). You can do the same thing on your computer by using a decent [IDE](https://en.wikipedia.org/wiki/Integrated_development_environment)
Input isn't a pointer or array. It is a char So input[i] can't be done
Hi, in the program, 'input' is an array of chars inputted by the user. the function is designed to take each char in the array and convert them in to an int. How do i access each char if not cycling through them? Thanks for the reply!
The first example I looked at looks like the library uses global state for everything so... 
 void convert (int k, char input) `input` is a char. Perhaps you meant to write void convert (int k, char *input) ? 
Another thing that is good to know if you are starting using C. Is that there is no such thing as passing something as an array in C, its all pointers. If you take a look at how function declaration works in the [C standard](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf) in section 6.7.5.3 / 7. You will see that a function that takes an array as a parameter will actually be interpreted as a pointer. void foobar(char data[]) { } Will actually be interpreted as below. void foobar(char *data) { }
I don't see how that conveys the information that's meant to be conveyed by the type-space-name convention.
In addition to what others have pointed out, you need braces around the contents of your for loop. Otherwise, only the first line ( converter = ..... ) will be executed inside the loop. The others will only execute after the loop has completed.
(edit) In guessing you want a table similar to this: Medium Speed Carbon Dioxide: 258.00 Air: 331.50 Helium: 972.00 Hydrogen: 1270.00 I'd suggest you define a const array of four strings with your media, and a const array of floats for your speeds. Print them together on one line for each medium in a loop, using tabs to separate the fields and look in to defining a field width for both medium and speed, to help line columns up.
Most globals I've seen in the code were static, i.e. local to the module they're in. If you need, say, current font available to your text drawing module (which is a single .c unit), why wouldn't you keep it as a global static variable exactly?
*saved for later* :)
Array with comments to remind you of what things mean or a structure if you really wanna get fancy
I'm a bit of a cheat who often looks for easy ways out, rt? That said, here's what I would do: - Create a project in your Workbench/GUI that has C and assembly files/modules. - Use the 'Export Project to Makefile' function (available on most/many) Now that makefile's a perfect template for *your* compiler/tools, going forward. Other folks gave the better answers, of course. And if you don't have a Workbench/Project GUI, then pls disregard. 
What you're looking for is called a Multi-Dimensional Array. For the header row, move the printf statement outside and just before the loop. Edit: that's if you want output like Carbon Dioxide; Air; Helium; Hydrogen 258.0; 331.5; 972.0; 1270.0 376578.0; 6764.6; 46.8; 256 567.4; 4675.0; 6766.0; 66.667 ...; ...; ...; ... ....... (not necessarily fixed-width aligned, but still semicolon delimited) 
And just to extend your answer, there *is* a way to pass an array of fixed length to a function- but only through a pointer, and only ever a pointer to arrays of that length. It looks like this: void foobar(char (*data)[N]) { } Where N is the only array length you'll accept. Note that even with this method you still can't pass arrays by value.
Not sure if it's what you asked, you didn't make it clear #include&lt;stdio.h&gt; int main() { char* Medium[] = { "Carbon Dioxide", "Air", "Helium", "Hydrogen" }; float Speed[] = { 258.0, 331.5, 972.0, 1270.0 }; int n_items; int i; n_items = 4; printf("%*s \t%s\n\n", 15, "Medium", "Speed"); for (i = 0; i &lt; n_items; i++) printf("%*s:\t%*.*f\n", 15, Medium[i], 6, 1, Speed[i]); return 0; } Output: Medium Speed Carbon Dioxide: 258.0 Air: 331.5 Helium: 972.0 Hydrogen: 1270.0 
Have you tried checking for memory leaks / errors using `valgrind`? That's where I'd start. I'll try to take a closer look at your code if I have time later.
thanks, ill check. If this can help now, im using a mutual recursion for creating siblings and child.
Simplicity, and familiarity. The OP is more likely to have experience with arrays of simple types at their stage of learning. That and the first struct/typedef I ever defined is in my example below.
If you want to do GUIs in C - have a look at GTK+ If you are ok with stretching the definition of GUI to include text based interfaces then also checkout ncurses. How comfortable are you with data structures? I suggest implementing some of the more complicated ones in a generic way to build confidence. i.e. a good hashtable or self-balancing binary search tree. The trick is to do it in a way that you can put any data type in these structures and not just tailor make them for each new data type you need to handle. Doing this requires mastery of void pointers as well as function pointers. I wouldn't bother with C and HTML - yes if you are dedicated enough you can make it happen but it is mostly insane unless you are doing some kind of weird super embedded thing. Doing network programming might be interesting, but you'll be focusing less on C and more on what kinds of interfaces your operating system supports. (The Linux Programming Interface by Michael Kerrisk is great for all kinds of systems programming, including networking) You also mention working with files in more depth: For the data processing; you might be interested in writing some kind of lexical analyzer. Pick some kind of text language (or a subset) and write something that can tokenize the file. Also, building on-disk data structures is a great way to build confidence in the direct I/O functions including fseek(). EDIT: (book recommendations) The Linux Programming Interface by Michael Kerrisk (mentioned above) and The C Programming Language second edition by Brian Kernighan and Dennis Ritchie Yes, TCPL is a little dated and only covers C 89; however there are _lots_ of little nuggets of computer science in this book that are served to you on a silver plater. For example, when they build text processing functions they don't use clumsy but easy to follow methods they actually build finite state machines. Both books contain exercises through out. Some are fairly simple, others (like implementing your own malloc() and free()) are a little more advanced. 
You are absolutely right about doing someone else's homework could be bad for that person. But I too believe it could be a positive experience because reading code from others is a good tool to improve your own concepts and understanding. And well.. I like to help :)
If you are on Mac OS X, you can build GUI applications and iOS applications with Objective-C. Build the backend/logic portion of the application in C. The Mac specific Objective-C can interact fairly seamless with the plain C.
You could've done something similar without doing the exact thing OP is trying to do, so that OP can learn without having someone just do all the work for them.
OP, maybe you should look in to strcasecmp. Or, convert all your inputs to lowercase before doing the comparisons. It'll be much simpler.
On mobile so I can't really write up much but on Linux google for execl, execlp, execle, execv, execvp, execvpe.
It should be noted that, IIRC, the exec family of functions replaces the currently running process with a new one. To execute more than one program from inside your program you will need to use a combination of fork() and exec().
I noticed that. Everytime during while, I tried creating an args array, then execvp(line,args);. This I think only executed the last line and the others are printed as "./hello" instead of executing it.
Use the `system()` function to execute commands. You can also call one of the `exec()` functions, but that's more complicated.
[`snprintf`](http://www.cplusplus.com/reference/cstdio/snprintf/) returns the number of characters (excluding the `\0` byte) it *would* write. So you can do something like this: size_t length = snprintf(NULL, 0, "&lt;img src=\"../images/%s\" /&gt;", name) + 1; char *image = malloc(length); snprintf(image, length, "&lt;img src=\"../images/%s\" /&gt;", name); Smart compilers would point the constant string in both cases to the same location (and not 2 seperate strings like in yours). It is still verbose, but you may wrap it into a function, which does the allocating for you. For this, you need variable arguments (see [`stdarg.h`](http://www.cplusplus.com/reference/cstdarg/)) and use [`vsnprintf`](http://www.cplusplus.com/reference/cstdio/vsnprintf/), as it uses the `va_list` things, making things simple.
Good approach. My only nit would be that duplicating the string literals is fertile ground for future bugs - when you need to tweak the output and forget that some other line needs to be kept identical. Your recommendation to make a helper function that uses variable arguments would be cleaner in that regard. 
If you don't want to deal with allocating either, `asprintf` is a wonderful method supported by most Linuxes and Mac OS X. You pass it the address of a pointer and it will allocate the correct size and print for you. Just don't forget to `free` after
Cool solution. A helper function to `vsnprintf` is exactly what I was looking for since then I can avoid writing out the strings twice.
`asprintf()` is standard POSIX already.
`system()` is OK for hacking things together, but for any "real" programs you should avoid using it.
[function-pointer.org](http://www.newty.de/fpt/index.html) has a new URL, but it should have all you need.
Please do not post code as an image. Always post the code as text! If you don't want to post it here, put it on a paste service of choice and link that.
Be careful to take into account that `snprintf` returns a **signed** value. It will return a negative value if an error occurs, so you should use a `ssize_t` variable for the return value and not a `size_t`. If you use `size_t` which is unsigned and an error occurs the variable will wrap. Check for errors before you do the addition.
I think an easy/fast fix could be a simple getchar(); before the glfwSetCursorPos call. You would need to press any key at start, but it will work for sure.
I want it posted so others who won't visit this thread can see it, too. I can post it as well but because you came up with the resource, I want to give you the chance to have some karma.
It's okay, just remember for the next time.
I've only ever heard it's use being criticized, but whatever.
True. Luckily, `asprintf()` is easy to implement on your own.
You could define a variadic function like this to simplify your code: char **str_array(const char *member1, ...) { va_args args; size_t i, n; char **arr; if (member1 == NULL) return (NULL); args = va_start(args, member1); for (n = 0; va_arg(args, char*) != NULL; n++) ; va_end(args); arr = malloc(n * sizeof *arr); if (arr == NULL) return (NULL); arr[0] = member1; args = va_start(args, member1); for (i = 1; i &lt; n; i++) arr[i] = va_arg(args, char*); va_end(args); return (arr); } You can use this function like this: struct my_struct st = {str_array("word_1", "word_2", ... , "word_n", NULL)}; I hope this is good enough for your purpose. There is another way, but it's slightly more complicated and doesn't check for allocation failure: #define STR_ARRAY(...) memcpy(malloc(sizeof (char*[]){__VA_ARGS__}), (char*[]){__VA_ARGS}, sizeof (char*[]){__VA_ARGS__}) This one has the advantage that it doesn't require you to stick a `NULL` at the end: struct my_struct st = {STR_ARRAY("word_1", "word_2", ... , "word_n")}; You can combine both approaches to get this: #define STR_ARRAY(...) str_array(__VA_ARGS__, NULL) struct my_struct st = {STR_ARRAY("word_1", "word_2", ... , "word_n", NULL)}; but this doesn't work if one of the strings is `NULL`, so keep that restriction in mind. It is possible to work around the restriction by rewriting `str_array` to receive the number of arguments it receives so you can get rid of the `NULL` sentinel and then generating that count from `sizeof (char*[]){__VA_ARGS__}/sizeof (char*)`. This is left as an exercise to the reader.
This is definitely interesting, however I don't like that it uses `malloc`, which means I have to take care of the freeing stuff at some point. I like the logic behind it though, I didn't think of combining `#define` into this, which brings a lot of new posibilities. I was hoping for a simpler solution that perhaps I was missing something syntax-wise, but I guess what I was asking is not really do-able with built-in rules. Thanks for the help!
On second thoughts, a more correct response would be that I simply haven't yet learnt how to implement a version as you suggest. I have changed the typedef/struct definition/initialisation, as follows: typedef struct medium_speed_stct { char stct_medium[16]; float stct_speed; } medium_speed; medium_speed medium_speeds[] = { {.stct_medium = "Carbon Dioxide", .stct_speed = 258.0}, {.stct_medium = "Air", .stct_speed = 331.5}, {.stct_medium = "Helium", .stct_speed = 972.0}, {.stct_medium = "Hydrogen", .stct_speed = 1270.0}, }; I have a broken for loop definition: for (loop_count = 0; medium_speeds[loop_count].stct_medium != NULL; loop_count++) { printf("|%14s\t| %7.2f |\n", medium_speeds[loop_count].stct_medium, medium_speeds[loop_count].stct_speed); puts(tablerow); } How would I go about initialising the last member as null, and correctly defining the for loop exit condition as you recommend? Thanks,
Speed wise there shouldn't be a difference, but I'm not sure if you can actually use compound literals like this.
&gt; but I'm not sure if you can actually use compound literals like this. What do you mean? I tried with the `(char*[])` on my project and it works great! I made plenty of tests and everything works as expected.