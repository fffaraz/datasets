Sorry, I noticed afterwards you used the word "tonic" and figured you already knew theory. The intervals are defined in the `enum` for ease of use. I use them to make up chords, and scales. In my application a chord is played from a progression when a button is pressed. I guess it's quite hard to describe the application without a good bit of detail.
Well, then a bitmap should do it. Think of the bitmap as describing a *set of notes.*
Yeah I think you're right. I like your solution. Thanks.
Actually, it wouldn't work because it when it comes to sending MIDI on/off messages I need to send each interval as a separate message. That's why in my example psudocode I had each chord as an array of intervals.
I'm C noob, but I've been trying to follow the Nasa style which is pretty dope looking. http://homepages.inf.ed.ac.uk/dts/pm/Papers/nasa-c-style.pdf
I think you use too many in-function comments. If you need to comment so much to explain a simple loop or number, there might be a better way to express that (variables names/constants, function abstraction). With your get 'get_next_node' function, you explain what is going on at the start of the function, this is enough. You have effectively turned a ten line function, which generally shouldn't need a lot of explanation into a 30 line piece of code; this makes it very hard to read.
If you used a single call to `fwrite`, writing the entire struct at once, then you can't read back the individual fields without knowing exactly how they're laid out - e.g. taking into account any padding. You can use `offsetof` to get the offsets of the fields and `sizeof` to get the size of the entire struct. From this you can figure out the actual size used by each field. When it comes time to read a field, e.g. link, you should make a call `fread` using `sizeof(myStruct.link)` _and_ then if the actual size of the field is larger than what sizeof gives, you need to skip over the difference (i.e. the padding) before reading the next field (use `fseek`). Alternately, if you can control the code that writes out the structs in the first place, you can just write the fields out individually, end-to-end, with no padding. That way you don't have to worry about padding when reading the fields back in individually. Mixing the two approaches is what complicates things. Should I ask "why" you need to do this? 
C11 has optional support for threads in the standard library, before that there was no way to do it in strictly conforming C (though the most common operating systems did provide ways of doing it through the system API). But global variables are bad even in single-threaded programs. The issue of shared state between threads is of course one problem (and one of the reasons why OOP is popular for complex programs), but there are others. When a global variable is read and written from multiple functions, it's very difficult for a programmer to predict what value that variable will have at any given time, and it's overall harder to understand a program. In general it's desirable that a function be fairly small, and not depend on anything but its arguments, so that you can hold the whole function in your mind at once and understand it as a complete unit. There are some cases when global variables are necessary, but they should be used cautiously.
I would go with C99 because it's a reasonably common denominator in that the code can be easily written to be pretty platform independent. Many libraries are written in C99 for this reason. And if use use the `-pedantic-errors -std=c99` flags for gcc, it'll help you stick to the standard.
Well, then you need to convert the bitmap into a set of values. That's not too difficult.
I would think it maybe possible in Python using a library for the keylogger, and you could use ImageGrab from PIL to keep grabbing the screen, then use OpenCv to process. It seems like it would be of better use just doing it in a different language even if you have to learn it, rather than forcing it in one that perhaps isn't best fit. 
I've already made prototypes in Python. Basically, I used ImageGrab to fetch a region on my screen, then used OpenCV to just remove all the garbage I didn't need. The program (KSP) being a rocketry simulator, I calculated the inclination of the rocket based on the detected rocket's longitudinal axis and the screen's vertical. Based on this the program would then send input using `pyautogui` to correct the rocket's trajectory. The problem is, it was extremely slow. I was getting probably 15 frames per second at best. I have seen someone on the Internet doing a similar thing with GTA V, but he had the same problem as me, it just didn't bothered him much (there is a difference between driving a car and driving a rocket). I was thinking about doing it in C instead, as I'm way more familiar with it, and could probably optimize bits here and there.
That comment almost gave me cancer. Saying "X is good" means nothing without explaining **why**. It's your opinion, don't take it as I'm attacking you, just take it as "explain why". Otherwise you could talk about how you cook your turkeys and your comment would still be as interesting.
Have you worked out the area of the code that is making it slow? Have frequently are you capturing the screen? Really interesting program btw, I haven't played KSP enough due to studies but interesting idea. I would only suggest if you could write your own library to simulate the libraries used on python. But that maybe longer than learning python to a higher degree. 
Using the latest version of something is a good "null hypothesis" to have in computer software. Usually later versions are produced with the intent of fixing bugs and making improvements on the earlier version. Of course there can be specific instances where a later version is widely regarded as worse than an earlier version , but C isn't one of those. NB. My comments reflect my opinion, in case that was unclear. For anything there will always be some subset of people who prefer an old version. I prefer the new version as it fixed mistakes and made improvements.
&gt;Have you worked out the area of the code that is making it slow? Yes. The screen capture is really slow. I had been using OpenCV without CUDA, so it was pretty slow, but the real bottleneck is getting the screen data. I had ImageGrab get me a 1024x768 area, which would be the KSP window. That alone takes between 0.05 and 0.07 seconds. The time doubles with basic processing (converting to grayscale -&gt; masking the unwanted screen areas (mainly, the UI, but we can press F2 in game so I removed that piece of code) -&gt; detect the edges to outline the rocket -&gt; Gaussian blur the image to smooth the detected edges -&gt; filter out the small lines) so I'm worried about the performances. My objective is to use the CUDA acceleration with OpenCV. I believe C will definitely outperform Python in the first place, using CUDA will make the program way faster too. I'll first make a Linux version with X11. I'll see about Windows later. The issue now is simulating keypresses &gt;How frequently are you capturing the screen? As much as possible. Roughly 15 frames per second with Python.
There are client server add-ons for ksp you can use to extract all the data you want and the plugin API is well documented as well - that'd be an easier way to retrieve your data instead of fiddling around with screen grabbing and ocr.
All the versions since C90 are basically similar, K&amp;R C is wayyy diff tho.
C11 supports localization? how?
Why not just use a struct?
Can you name one of those addons? I'm definitely interested 
`enum`s can't be `struct`s or anything else than integers. So the 'trick' is to put *indexes of objects* in an enum, and not the objects themselves. Example 1, with structures : #include &lt;stdio.h&gt; typedef enum { UNISON = 0, ROOT = 0, // Same as UNISON, useful in different contexts MINOR_SECOND = 1, DIMINISHED_THIRD = 1, // Same here too MINOR_THIRD = 31, MAJOR_THIRD = 33, MAJOR_FIFTH = 55, } INTERVALS; struct chord { INTERVALS a; // since I don't know what they represent, I couldn't come up with better names :-) INTERVALS b; INTERVALS c; }; const struct chord chords[]={ { ROOT, MAJOR_THIRD, MAJOR_FIFTH }, { ROOT, MINOR_THIRD, MAJOR_FIFTH }, }; typedef enum { MAJOR, MINOR, } CHORDS; int main(void) { printf("MAJOR: %d %d %d\n", chords[MAJOR].a, chords[MAJOR].b, chords[MAJOR].c); printf("MINOR: %d %d %d\n", chords[MINOR].a, chords[MINOR].b, chords[MINOR].c); return 0; } The same, with simple arrays (may be more suitable if you want to loop on chord indexes 0, 1, 2) : #include &lt;stdio.h&gt; typedef enum { UNISON = 0, ROOT = 0, // Same as UNISON, useful in different contexts MINOR_SECOND = 1, DIMINISHED_THIRD = 1, // Same here too MINOR_THIRD = 31, MAJOR_THIRD = 33, MAJOR_FIFTH = 55, } INTERVALS; const INTERVALS chords[][3]={ { ROOT, MAJOR_THIRD, MAJOR_FIFTH }, { ROOT, MINOR_THIRD, MAJOR_FIFTH }, }; typedef enum { MAJOR, MINOR, } CHORDS; int main(void) { printf("MAJOR: %d %d %d\n", chords[MAJOR][0], chords[MAJOR][1], chords[MAJOR][2]); printf("MINOR: %d %d %d\n", chords[MINOR][0], chords[MINOR][1], chords[MINOR][2]); return 0; } 
Another way. `enum` are not much more than glorified `#define`s. So, an example with defines: #include &lt;stdio.h&gt; typedef enum { UNISON = 0, ROOT = 0, // Same as UNISON, useful in different contexts MINOR_SECOND = 1, DIMINISHED_THIRD = 1, // Same here too MINOR_THIRD = 31, MAJOR_THIRD = 33, MAJOR_FIFTH = 55, } INTERVALS; #define MAJOR { ROOT, MAJOR_THIRD, MAJOR_FIFTH } #define MINOR { ROOT, MINOR_THIRD, MAJOR_FIFTH } #define CHORD(x) ((INTERVALS[]) x) int main(void) { printf("MAJOR: %d %d %d\n", CHORD(MAJOR)[0], CHORD(MAJOR)[1], CHORD(MAJOR)[2]); printf("MINOR: %d %d %d\n", CHORD(MINOR)[0], CHORD(MINOR)[1], CHORD(MINOR)[2]); return 0; } Or: #include &lt;stdio.h&gt; typedef enum { UNISON = 0, ROOT = 0, // Same as UNISON, useful in different contexts MINOR_SECOND = 1, DIMINISHED_THIRD = 1, // Same here too MINOR_THIRD = 31, MAJOR_THIRD = 33, MAJOR_FIFTH = 55, } INTERVALS; typedef INTERVALS chord[3]; #define MAJOR ((chord) { ROOT, MAJOR_THIRD, MAJOR_FIFTH }) #define MINOR ((chord) { ROOT, MINOR_THIRD, MAJOR_FIFTH }) int main(void) { printf("MAJOR: %d %d %d\n", MAJOR[0], MAJOR[1], MAJOR[2]); printf("MINOR: %d %d %d\n", MINOR[0], MINOR[1], MINOR[2]); return 0; } In the end, that is not much different that declaring a bunch of `const chord MAJOR={ ROOT, MAJOR_THIRD, MAJOR_FIFTH };`.
One was named kOS, though they wrote a whole new language, iirc. kRPC is what you'll want to use. There are client libraries at least for Python and cxx, I fiddled around with those. 
Not entirely sure if this fits, but you can build a macro table (a special kind of xmacro) that keep the information in one easily-modified place, but which can then be applied to all sorts of cases in order to build out your data into separate structures. Assuming GNU99 because it helps, and this is ad-hoc so forgive glitchybugs: #define Interval__TABLE(T,q...)\ T(UNISON, 0, ##q)\ T(ROOT, 0, ##q)\ etc. #define Chord__TABLE(T,q)\ T(MAJOR, 3(ROOT, MAJOR_THIRD, MAJOR_FIFTH), ##q)\ T(MINOR, 3(ROOT, MINOR_THIRD, MAJOR_FIFTH), ##q)\ etc. (Note the strange tuple representation `n(a1, a2, a3, ..., an)`; this makes life slightly easier later on.) These tables are called with a subordinate row macro and spare arguments, so basically `*__TABLE(T, q...)` calls `T(DATA..., q...)` once for each row. As a simple example of something you can do with this: #define COUNT_TABLE(T)(T##__TABLE(COUNT_TABLE__0)0U) #define COUNT_TABLE__0(...)1U+ This generates a handy count of rows in the table. (An empty table will just leave the `0U`, a single-element table will leave `(1U+0U)`, a two-element `(1U+1U+0U)`, etc.) You can do similarly kludgey things to find the minimum and maximum values of an `enum`’s range. You can generate an `enum` from the first table (elements have explicit, possibly shared values) with something like this: #define MAKE_VAL_ENUM(type)\ enum __attribute__((__packed__)) type {\ type##__TABLE(MAKE_VAL_ENUM__0, type##_)\ }; #define MAKE_VAL_ENUM__0(name, value, prefix)\ prefix##name = value, // Called as: MAKE_VAL_ENUM(Interval) Note that this will give you prefixed `enum`s, which is as close as you get to the `Interval::` prefixing you were doing—`Interval_UNISON`, for example, though you can just remove the `prefix##` if you don’t want that. For the `Chord` table, with auto-valued names: #define MAKE_AUTO_ENUM(type)\ enum type {\ type##__TABLE(MAKE_AUTO_ENUM__0, type##_)\ }; #define MAKE_AUTO_ENUM__0(name, _0, prefix) \ prefix##name, // Called as: MAKE_AUTO_ENUM(Chord) Same prefixing applies there, `Chord_MAJOR`. Now for the money shot: Using the `Chord` table you can do // The row structure: struct Chord_Info { const char *name; const enum Interval *intervals; }; // Build out a (static; change that if you want it externally visible) table of chord // rows: #define Chord__MAKE_DATA(IType)\ static const struct Chord_Info Chord_INFO[COUNT_TABLE(Chord)] = { Chord__TABLE(Chord__MAKE_DATA__0, IType) }; // For each row, assign name and use a compound literal for interval list. If // you don’t have C99, you have to set up the interval data in a separate pass // from before the `Chord_INFO` definition and then reference it instead. #define Chord__MAKE_DATA__0(name, tuple, IType)\ {\ #name, \ Chord__MAKE_DATA__2((IType, Chord__MAKE_DATA__1__##tuple))\ }, // Now the complicated bit. Tuples start with their length so’s we can call ’em // like macros if we paste on a prefix. The below should be autogenerated // if possible, but you shouldn’t need more than what, n=6 or so, depends on how // many notes you’ll need in your chords. This next macros turn a tuple into // an unwrapped comma-separated length and element list. This will be bundled // up by the above into group `(Itype, len, intervals...)`, which will be passed // down as a single argument to allow reshuffling—i.e., the call to -__1__- may // otherwise be seen as a single argument to -__2. #define Chord__MAKE_DATA__1__1(v1)1,v1 #define Chord__MAKE_DATA__1__2(v1,v2)2,v1,v2 #define Chord__MAKE_DATA__1__3(v1,v2,v3)3,v1,v2,v3 // etc. ad autogen // Fully reduce the contents of the group in preparation for its use as an argument list. // Non-GNU compilers may require an extra step of pumping. #define Chord__MAKE_DATA__2(x)Chord__MAKE_DATA__3(Chord__MAKE_DATA__4)x #define Chord__MAKE_DATA__3(x)x // Finally, we actually have the interval type, count, and elements, so we can call // into our final phase to emit the properly pasted-together interval names. #define Chord__MAKE_DATA__4(IType, n, x...)\ (const enum IType[n]){Chord__MAKE_DATA__5__##n(IType, ##x)} // As above, only with the extra first argument. This is most compactly done with recursion, // but there’s no harm in inlining if it’s easier to autogen. #define Chord__MAKE_DATA__5__1(IType, x)IType##x #define Chord__MAKE_DATA__5__2(IType, x, y...)IType##x, Chord__MAKE_DATA__5__1(Itype,##y) #define Chord__MAKE_DATA__5__3(IType, x, y...)IType##x, Chord__MAKE_DATA__5__2(Itype,##y) // etc. ad autogen And with a final macro invocation: Chord__MAKE_DATA(Interval) you now have an array of structures with precisely the information you need, autogenerated so you can edit all your data in the tables up top. If you have some `enum Chord c`, you can do `Chord_INFO[c]` and get the name and intervals for that chord. Adding more info to the tables gives you more potential fields for the table. If you need to do a lookup by name, you can either scan the table (O(*n*)) or build a hash table into it (amortized O(1)). You can probably do a compile-time hash table with macros too, but it’s a little more adventurous than I recommend getting. A technique similar to xmacros can be done with `#include`, where you treat certain macros as parameters to the include and then inside you do the same sort of T(p, DATA...) thing. That allows you to cleanly rope in arbitarily many files (you can do the same with xmacros by including external TABLE calls inside the outer TABLE macro), but it severely limits where and how you can use that data.
I second Vim. I've been using it as my editor for everything, and it's much more resource friendly than anything else I've used. It's also extremely powerful, but with great power comes a steep learning curve.
You need a variable of of type debts: struct Debts d;
Sorry, I have added that in but I still get the same errors saying I have undeclared (first use of this function) which didn't happen when i didn't have a struct but the chars and int inside int main
Add the 'struct Debts d;' and the refer to the structure as 'd' not 'Debts'.
I get error expected identifier for Debt d and debtor,creditor,amount undeclared still
1. Is it `Debt` or `Debts`? 2. There is no `amount` in `struct Debts`. 3. To use a struct, you must define an instance of it. 
Sorry it is indeed Debts, I corrected by adding in amount into struct, apologies but in this instance how would I define the instance? I have struct Debts d; with char debtor, char creditor and int amount and just want to scan the first persons name, second persons name and amount into that struct and print it.
C has barely changed at all in the last 30 years. A few minor features get added from time to time. My advice: use the oldest version that runs on your computer. You almost never need the new features, and saying you want the latest version is just another way of saying you want to write code that's compatible with as few systems as possible.
I think it has Unicode string constants.
Using the latest version is a good way to make sure your code runs on as few systems as possible.
Hoo, boy. Please make your indentation consistent for readability. Find a C style guide (any guide) and follow it. 20 characters for a name length is far, far too short. The first long name found in the data file will overflow a buffer and lead to chaos. This is how most security breaches occur — someone deliberately overflowing a buffer with long input. As other posters have pointed out, you need a variable of type "struct Debts". What you have in your code is a struct definition, not a variable declaration. You wanted something like this: struct Debts { yadda yadda; }; struct Debts debts; Then refer to `debts` in your code, not `Debts`. This is the reason your code didn't compile. Learn how the %s scanf format works. It scans until a blank is encountered. As written, your code will read "John" into debts.debtor. I do give you an A+ for using a scanset correctly. However, checking the output of fscanf() for EOF was a mistake; fscanf() returns the number of items assigned. You could have done all the reading with a single call to fscanf(): while (fscanf(in, "%[^,], %[^,], %d\n", debt.debtor, debt.creditor, &amp;debt.amount) == 3) { ... } But while we're at it, let's revisit that overflow issue. Assuming you're comfortable with the 20-character limit, your format string should actually be `"%19[^,], %19[^,], %d\n"`, but to be honest, in a production environment, that wouldn't fly either.
Wow, this answer is impressive. I'm going to have to dig into this one a bit more because some of that looks confusing. I've never used X Macros, but I have found a great explanation of them [here](http://www.drdobbs.com/the-new-c-x-macros/184401387). Many thanks.
Thank you so much, it finally managed to compile, just need to figure out why it only prints the last line without the amount
What the shit is "RAII" and why are you assuming the audience you're targeting (beginners) knows what it means?
If a client is current receiving data or not is not a property of the socket, but the application logic. How to handle this depends on how server is written; there could for example be a state variable that tells you what the server is currently doing w.r.t. the client. We're not going to be able to help you much without actually seeing the code. BTW, if you have problems with stale connections lingering forever, try enabling SO_KEEPALIVE. This makes the OS periodically send probes that indicate whether the stream is dead or not. 
Honestly, it can be confusing while you’re putting it together, but once you have the MAKE_ENUM etc. macros in a header, it becomes trivially easy to just blast out data structures. The only limit is the C preprocessor’s inability to do much of anything (e.g., requiring the awkward re-/pasting for case-matching). It’s functional programming at its sub-Turing-compete worst. OTOH, you can do pretty much anything at compile-time if you autogen big enough structures. String handling, arithmetic, all sorta fun stuff.
From inside C, all of your options are system-specific. Longer-term, you can either log properly (→see what’s open but not yet closed) or pick up SIGUSR1 to request status reports, stuff like that. For current versions, you’ll need to be root or whatever user the service is running under and use dirty, totally-nonportable tricks. If you’re not on Linux I can’t really help beyond that. If you are on Linux, quickest-and-easiest is to use /proc/PID/fd and see what all’s open—each file in there is a softlink that you can `readlink`, and you’ll see `socket:[NNNNN]` for open sockets. Probably the lowest-numbered one’ll be the listening one, and the rest are connections. However, this will pick up UNIX domain sockets too and I’m not sure how to take the NNNN in the brackets and turn it into actual socket information, so YMMV. There may be other files in /proc subdirs to help you sift through which socket is which, but I’m not familiar enough to go any farther there and those have changed quite a bit over recent-ish kernel versions. Alternatively, there’s /proc/net/tcp, which shows all network connections open (/proc/PID/net/tcp may show you only for PID or not, and it may or may not exists). You can search pretty easily through this for your service by looking at the passive-side port. However, this whole thing runs into a race condition. If somebody connects after you’ve checked for no connections but before you kill the old client, then you could still kill a connection. There’s no way around this short of first signalling the client that it should stop accepting connections (e.g., SIGUSR2) and *then* poll-waiting until no connections are left, or else suspending the client’s ability to accept, checking connections, and then resuming. Maybe SIGSTOP/SIGCONT could be used for this purpose, as long as you keep it under 15s of downtime.
My issue isn't with stale connections so to speak... It's trying to determine if I can restart the app upon the device connect exceeding the max allowed connections... This is very important because I can't have the app recycle itself if there are devices currently getting updated, this would be bad. Anyhow, if you had an app that is a sever listening on a specific port for TCP connections, that accepts multiple devices connecting and you restrict the number of allowed connected devices... and upon a connection being made that exceeded the allowed # you need to reboot the app... How would you first see if it was safe to reboot... meaning that no connected devices are currently getting sent a file or that no devices are currently connected then reboot the server application? Hope this helps explain what I want better and shouldn't have the need for me to provide code... as all I wanted / looking for is a sample of how to check for such a criteria... some actual code sample. Thanks. 
Why not just stop accepting connections until some existing ones have closed? Or rewrite it to be able to handle more simultaneous ones? Unless there's something you're not telling us, this server should easily be able to deal with thousands of connections at once. If you must restart it, then, yes, just wait until all current connections are in a file transfer completed state and don't accept more connections while you're waiting on that. 
&gt; all I wanted / looking for is a sample of how to check for such a criteria... some actual code sample. As I said, tracking client connection state is done by the software itself. How could we possibly write sample code for you when we have no idea how the program works internally?
So you have an instance named `d`. You need to refer to that, not to the struct itself, which is an abstract concept (a description of the layout of `d`).
I don't allow any more connections... But I don't know how to know that any active connections are done for sure.... cleanly. Right now I have a integer value that I increment when the device starts getting it's file, and decrement when it is done... But my issue is that if the device looses connection for whatever reason during that process this integer never gets decremented and therefore I don't know that I need to restart.... So I was figuring there has to be a way to check for active connections on a socket... so that I could just do that instead of looking at this integer ...
Er, you don't have some sort of struct used to represent a connection's information and a list or array or something of active ones? And do you not do any error handling when it comes to failed read()s and write()s or sendfile() calls or whatever?
reverse polish notation calculator or use infix with the [Shunting yard algorithm](https://en.wikipedia.org/wiki/Shunting-yard_algorithm)
**Shunting-yard algorithm** In computer science, the shunting-yard algorithm is a method for parsing mathematical expressions specified in infix notation. It can produce either a postfix notation string, also known as Reverse Polish notation (RPN), or an abstract syntax tree (AST). The algorithm was invented by Edsger Dijkstra and named the "shunting yard" algorithm because its operation resembles that of a railroad shunting yard. Dijkstra first described the Shunting Yard Algorithm in the Mathematisch Centrum report MR 34/61. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Well there is logic to handle failed reads and such. But what seems to happen is that once the device looses connection it just seems to stop dead there. At least in my last batch of testing that is what seemed to happen. It drops dead right in the spot where it is in the middle of sending the bytes out to the device. Code that is in place to determine the return code of the write never is reached... Really bizarre behavior... Again I didn't write this code I just took over this crap... I really hate it. 
for c/c++ code browsing use vim+ctags+cscope. Its a complete package.for further searching of texts use grep command.
Thank you veryyyy much !
I suppose it could be W\^X, but I think valgrind's error message says the issue could be with imposed memory limits. I recall running `ulimit -a` on Linux, and virtual memory being unlimited, and, on OpenBSD, it's some particular number.
How about http://git.savannah.gnu.org/cgit/nano.git/log/?
Write a `tsort` replacement. `tsort` is a small UNIX program that does topological sorting. You give `tsort` a bunch of lines indicating a “must be done before” relationship, such as these: briefs pants pants shoes shirt tie socks shoes briefs shoes pants belt undershirt shirt Then `tsort` computes an order in which you could do these things such that each constraint is met, e.g.: briefs socks undershirt pants shirt belt shoes tie If there is a loop in your requirements, e.g.: experience interview interview work work experience then `tsort` outputs an error message stating how this can't be done: tsort: -: input contains a loop: tsort: experience tsort: interview tsort: work However, this part is optional. 
&gt; Once you move past the basic syntax, learning C will not help you learn C++, nor vice versa It will.
Thank you veryyyy much !
Thank you veryyyy much !
I have 25 years of experience with both. If you want to write good, idiomatic, modern C++, as opposed to just “C with classes”, then knowing C will not help you, and some of the habits you will acquire while learning C (especially wrt pointer manipulation) will hurt you when learning C++.
 tsort: -: input contains a loop: tsort: experience tsort: interview tsort: work Hey, I never got this error while trying to apply for a job. Would've been nice to get a heads up.
Oh, please don't take my suggestion as a serious one. :p Nano is the name of a basic command line text editor - I took your question literally for some slight humorous effect. After all, the best Nano-sized project out there would be Nano itself.
:P
Well, you could work on that Nano-sized project just a little git. I'll see myself out.
Thanks for the tip :)
Wow thanks for the tip, that's quiet intelligent ! :) I wasn't able to find a way to avoid storing additional data besides the HTML tree ! I know that a recursive algorithm is far more easier to write, but I was bored at work so I had time to think about other implementation :P 
This is well-known since pretty much the beginning of programming. I doubt you are going to find any papers about that.
I see what you did there.
Note that behind the scene, your libc or your OS may commonly fetch a large chunk of data even though you just request one byte (and then it just `memcpy`s from it each time you call `fread()`). The libc/OS might even start filling its buffer as soon as you `fopen()` the file in reading mode.
I think he's talking about low level syscalls.
I thought he would have been talking about C functions on a C sub :-), believing that each C function call automatically induces the corresponding syscall.
No... You even mentioned stdio's buffering. Each fgetc() or whatever doesn't necessarily involve a read().
I don't know what you are talking about. I don't know what point you are trying to make. I don't know what your "No..." refers to. I don't know what difference there is between your statements and mine. What did you understand in what I said? What does it conflict with?
I'll admit this one because it contains a decent explanation of the code, making it actually interesting to our readers.
To be honest, your comment uses grammar in a way that makes it a bit hard to understand. I had to read it three times to get the intent.
ANSI C and K&amp;R C are quite similar . The standard codified existing practice and introduced some new things that you can use but don't have to. It could be argued that the difference between C99 and C89 is greater than between C89 and K&amp;R. E.g. do a diff between K&amp;R1 and K&amp;R2 (ANSI C edition), there aren't really that many changes.
He means Unicode character types and encoding.
Oh, i thought K&amp;R is when function definitions were required to not have variable definitions, but just the types. And the same for for loops
TBF a read from/write to the disk would read/write in page- (or cluster- or whatever)sized chunks IIRC, and small reads from a socket or pipe generally come from a larger buffer. Reads/writes across the system bus are usually buffered. Hard to find a place in a computer where buffering doesn’t happen during a data transfer.
Reading byte-by-byte is at best negligibly worse than reading in larger chunks, because it tends to impose a higher overhead onto access to input. However, how much worse it is depends on what you’re doing specifically. If you’re calling `fgetc`/sim. repeatedly instead of `fread`ing, you’ll take a small hit for the function call overhead; less if you use LTO. A good CPU can get rid of most of the call overhead, though there is a small mandatory hit for shuffling registers and stack before/after call/return to meet ABI requirements. If you’re calling `read` (as in, the syscall in reference to a FD), you’re taking a much bigger hit that’s harder for the CPU, linker, or compiler to optimize away because you’re forcing the CPU into a different privilege level (user→supervisor mode or ring 3→ring 0) and there’s going to be a save-everything and restore-everything phase and several layers of indirection between you and the actual `read` implementation for the FD in question. If you’re doing a lot of work per character—sufficiently more than the baseline overhead of the sys-/call(s) behind whatever function you’re calling—neither of the above matters as much. If you’re repeating this in a loop, whichever overhead is larger will tend to dominate. If you’re blocking more than occasionally, that will dominate by far for a number of reasons (e.g., cold cache, millisecond+ delays). Some simple things like filling a buffer in search of a newline can benefit from reading in large chunks—it’s easy to encode the search as a pointer scanning through the buffer as you go. If, OTOH, you have some generic function-pointered interface that you’re calling to get characters in a matching routine, then you’re going to have to interpose a function call (or macro invocation if you’re cloning) between the main drag and the actual pointer usage, in which case the character-by-character approach might not matter as much. Furthermore, if the code you’re writing isn’t performance-critical (e.g., it’s only called occasionally), then it’s often much easier and more maintainable to go with char-by-char. This especially applies in exit/error/exception/abort/fault situations—e.g., your program encountered an error and has to exit, or has successfully set the graphics card ablaze. Those things shouldn’t happen, or happen right next to super-expensive things anyway. Overhead doesn’t always matter.
nice!
Can't take credit; I got it from someone else's code. But it may come in handy from time to time.
Note that if you want really fast image grabbing in X11, you should use `XShmGetImage` instead of `XGetImage`, as the latter will allocate memory (that you have to free) every time you grab a frame. `XShmGetImage` writes the image to an area of shared memory you allocated previously, so you just pay the cost of copying the image data.
It's very simple: when you read n bytes at once we can assume that it takes `C + f(n)` seconds where `C` is the overhead of purely doing the read, independent of n. `f(n)` is the part of it that depends on how many bytes you read. Now if you do `n` reads of 1 byte each you get: `n*C + n*f(1)` Now `C` is much bigger than `f(n)` (n small enough) for HDDs and many other devices. So obviously: `n*C + n*f(1) &gt; C + f(n)` 
I will try to do some micro-benchmarks to compare the CPU usage and the memory footprint of these 4 algorithms (recursive, iterative, and the two lazy algorithms). When I have some figures I will post it here :)
/r/csharp This subreddit is for straight-up C, not C++/C# et al. 
This subreddit is about C only. Please ask C# questions elsewhere. I have removed your submission as it is off topic.
nice! can anyone link some benchmarks on the new gcc release? I'm interested.
From the little playing around I have done on toy programs I made for benchmarking have improved performance anywhere from 0%-10% across 3 little 50-100 line programs. I'm predicting the code hoisting, memory merger, and value range propagation will be more useful in much larger programs, but that is conjecture. The biggest improvement in GCC5/6-&gt;7 are the warning, suggestions and sanitizers, they are amazing now.
&gt;access modifiers Out of all the things you could have borrowed from OO, why this?
 There are. Look better. C89, C99, C11, it's all the same for a beginner. If you want a link or book recommendation now, the subreddit is full of that. Look better.
Because C11 doesn't add enough to justify a book. [Look at the changes here](https://en.wikipedia.org/wiki/C11_(C_standard_revision)#Changes_from_C99) We have: alignment specification, which isn't horribly important to...anyone as long as you pack your structs. A noreturn keyword, which is just a hint to the optimizer. ***One*** new macro form which has been included more or less so that the C standard library can be written in standard C. It previously *required* extensions. 2 unicode types and unicode literals. Removal of a function that's been deprecated for 12 years. Bounds checking function versions, which even the committee admitted will not actually help with bounds checking. As far as I know, no mainstream compiler intends to implement this (MSVC maybe?) Analyzability features (is any compiler implementing this? Macros for checking whether a floating point number is, among other things, denormalized. Anonymous structs/unions, a feature which every compiler has included as an extension for approximately forever. An exclusive mode for fopen, making it possible to create lockfiles within standard C. quick_exit, so that if you mess up badly enough that even exit(), doesn't work, you can do more than dereference NULL. Macros for making complex numbers. Finally: a threading interface which everyone I've seen recommends *against* using because it's just a bad subset of pthreads.
Show the complete output. It sounds like you don't have the linker installed, but who knows. 
without the `-v` flag it doesn't output anything besides that error message but here's the out put with &gt;Using built-in specs. COLLECT_GCC=gcc Target: x86_64-w64-mingw32 Configured with: ../../../src/gcc-7.1.0/configure --host=x86_64-w64-mingw32 --build=x86_64-w64-mingw32 --target=x86_64-w64-mingw32 --prefix=/mingw64 --with-sysroot=/c/mingw710/x86_64-710-posix-seh-rt_v5-rev2/mingw64 --enable-shared --enable-static --disable-multilib --enable-languages=c,c++,fortran,lto --enable-libstdcxx-time=yes --enable-threads=posix --enable-libgomp --enable-libatomic --enable-lto --enable-graphite --enable-checking=release --enable-fully-dynamic-string --enable-version-specific-runtime-libs --enable-libstdcxx-filesystem-ts=yes --disable-libstdcxx-pch --disable-libstdcxx-debug --enable-bootstrap --disable-rpath --disable-win32-registry --disable-nls --disable-werror --disable-symvers --with-gnu-as --with-gnu-ld --with-arch=nocona --with-tune=core2 --with-libiconv --with-system-zlib --with-gmp=/c/mingw710/prerequisites/x86_64-w64-mingw32-static --with-mpfr=/c/mingw710/prerequisites/x86_64-w64-mingw32-static --with-mpc=/c/mingw710/prerequisites/x86_64-w64-mingw32-static --with-isl=/c/mingw710/prerequisites/x86_64-w64-mingw32-static --with-pkgversion='x86_64-posix-seh-rev2, Built by MinGW-W64 project' --with-bugurl=https://sourceforge.net/projects/mingw-w64 CFLAGS='-O2 -pipe -fno-ident -I/c/mingw710/x86_64-710-posix-seh-rt_v5-rev2/mingw64/opt/include -I/c/mingw710/prerequisites/x86_64-zlib-static/include -I/c/mingw710/prerequisites/x86_64-w64-mingw32-static/include' CXXFLAGS='-O2 -pipe -fno-ident -I/c/mingw710/x86_64-710-posix-seh-rt_v5-rev2/mingw64/opt/include -I/c/mingw710/prerequisites/x86_64-zlib-static/include -I/c/mingw710/prerequisites/x86_64-w64-mingw32-static/include' CPPFLAGS=' -I/c/mingw710/x86_64-710-posix-seh-rt_v5-rev2/mingw64/opt/include -I/c/mingw710/prerequisites/x86_64-zlib-static/include -I/c/mingw710/prerequisites/x86_64-w64-mingw32-static/include' LDFLAGS='-pipe -fno-ident -L/c/mingw710/x86_64-710-posix-seh-rt_v5-rev2/mingw64/opt/lib -L/c/mingw710/prerequisites/x86_64-zlib-static/lib -L/c/mingw710/prerequisites/x86_64-w64-mingw32-static/lib ' Thread model: posix gcc version 7.1.0 (x86_64-posix-seh-rev2, Built by MinGW-W64 project) COLLECT_GCC_OPTIONS='-o' 'test.exe' '-v' '-mtune=core2' '-march=nocona' cc1 -quiet -v -iprefix C:/Users/musta/Desktop/projects/c/c-testing/../lib/gcc/x86_64-w64-mingw32/7.1.0/ -D_REENTRANT test.c -quiet -dumpbase test.c -mtune=core2 -march=nocona -auxbase test -version -o C:\Users\musta\AppData\Local\Temp\ccOeAztn.s gcc: error: CreateProcess: No such file or directory
It's failing when invoking the actual compiler, `cc1`. That sounds like an installation problem. Where is cc1 in relation to the front-end driver, gcc? Normally you'd have something like `$prefix/bin/gcc` and `$prefix/libexec/$target/$version/cc1`. What do you have? 
I found this book [1] written by Jens Gustedt, didn't read all yet but it refer mainly to C11, as the other reply says C11 isn't implemented completely on many compilers. [1] http://icube-icps.unistra.fr/img_auth.php/d/db/ModernC.pdf
Why would public void Box*.print() { printf("%i %i %i\n", this-&gt;height, this-&gt;width, this-&gt;depth); } be better than public void print(Box * this) { printf("%i %i %i\n", this-&gt;height, this-&gt;width, this-&gt;depth); } ?
Personal preference.
inside the mingw64 folder there's the bin folder which has the gcc command and then cc1 is under `libexec\gcc\x86_64-w64-mingw32\7.1.0` Edit: also im not sure if im supposed to use mingw-w64.bat to use gcc but what i did was just make a path variable that links directly to the bin file, using mingw-w64.bat for gcc actually works and im not sure why
I would like to see a module system and namespaces in C.
thank you ! 
namespace would be cool. I'm going to add that to the todo list.
That was very unhelpful
Sounds like you didn't actually set up your path correctly -- that's all that mingw-w64.bat does. Not sure what you mean by "a path variable that links directly to the bin file", it'd be clearer to copy-paste exactly what you did do. 
&gt;We have: alignment specification, which isn't horribly important to...anyone as long as you pack your structs. Packed structs are non-standard and can cause problems with the ABI, my advice would be to not use them. Also, alignment specification can be used with things other than structs. For example if you're writing an allocator. &gt;A noreturn keyword, which is just a hint to the optimizer. It also avoids bogus warnings if you have enabled the warning that a non-void function reaches the end without returning a value (which you generally should). &gt;One new macro form which has been included more or less so that the C standard library can be written in standard C. It previously required extensions. I guess you are referring to `_Generic`, which is a primary expression, not a macro. But its main use case is to be expanded to from a macro. &gt;Anonymous structs/unions, a feature which every compiler has included as an extension for approximately forever. gcc 4.1 in ISO C99 mode didn't allow anonymous unions. A bunch of the other things you mention are pretty nice quality-of-life improvements. One in particular that you omitted is `_Static_assert`. I use static assertions a lot in header files, and this makes shit much easier. 
There are courses and books to learn C. If you want to learn a specific specification, it's that you already know C, so you can just read about the changes.
sorry that was a confusing way to say it but basically I just added the bin file to the windows path. But you are right, I just added the file that contains cc1.exe to my path and it works now
Paths should contain directories, not files. I'm not sure what you mean by "the bin file" etc. 
sorry I have a bad habit of referring to directories/folders as files
At that point you could just use [D](http://dlang.org) compiled with `-betterC`
Nested recursive templates
I always like how C++ compilers will not let you do things that are "undefined" but provable and working on your platform. Specifically, when you run in to the rare situation where you need to perform arithmetic on a function pointer (yes, there are use cases, mostly in reversing or modding closed software), C++ compilers just won't fucking have it. So you wind up with a huge chain of casts and shit just to make the compiler shut up.
Visual studio for windows C/C++ dev, autotools, gmake, gcc. Generally a vim guy but I'm using VS code a bit more often these days. 
VS Code is a good alternative. 
Read "21st Century C"
This is pretty cool! Are you planning on implementing default struct member values? It would be nice if you made a list of planned features to the README file.
&gt; default struct member values Just added it to goals on the readme.
This is an interesting idea. You may want to look at the older cfront compiler. It also reminds me of [ooc](https://ooc-lang.org) or even nim. Both of these languages compile to C. One advantage you have right now,I think, is that the generated C files are still readable. Nim's C code is a bit difficult to read. 
no problem, if you find more books/tutorials let us know.
I hardly think there are any binary packages avail yet? Maybe in a few months. 
Do you know what the format specifier `%p` does?
If you "know pointers etc" but you want to "learn everything" else ... the only thing else I see here would be understanding [`printf` format strings](https://en.wikipedia.org/wiki/Printf_format_string). `"%p"` will display something appropriate (for your platform) to represent the corresponding pointer arg you give it. What else do you need to know? Give it a pointer (any pointer) and it will format it for display.
You can always compile it yourself if you want.
wlib.h is a header, not a library, and to specify its location to the compiler, you should use -I/path/to/wlib.h 
well yeah .. hardly a trivial matter 
I've done it a few times, didn't have many issues. You should try it.
Scanning reddit subs, redditors always come up with the best thread titles.
He also knows computers and stuff.
What do you mean solve it? If you read the code and the output it makes enough sense. The %p just gives the address the pointer is pointing to. in this case 1634 or 0x662.
Harvard's cs50
It's blogspam. The explanation is decent because it's ripped directly from [this](https://stackoverflow.com/questions/3533348/how-does-this-code-generate-the-map-of-india) stackoverflow question.
A nice, easy-to-understand, explanation of hash tables. Upvoted.
The actually interesting part is construction of the hash function.
If the table is full and you search for a value that isn't in the table, won't you get an infinite loop?
Either or both? It's common practice to read from standard input if no files are given on the command line, for example.
You need to look over the functions in stdio.h, specifically fopen(). This will give you a pointer to your file stream. If you are developing on a *nix environment, %&gt;man 3 fopen. Most of the C standard library documentation is available in man pages. Just man the function or the name of the header file ("stdio.h") and you'll get the official documentation. Depending on what the data in the file is, you will probably want fgets() to extract char data and read it or manipulate it or whatever you're doing. https://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm Finally, it's your choice whether you want to identify the file to open on the command-line or not. Depending on the requirements of your program, you can hardcode the path in your source code (first argument to fopen() I think), or you can parse argv to get it from command-line and pass it to fopen(). Also, if there's no printf() in your source code, there will be no output. You're just counting stuff and then blowing it away when your application ends. Hope this helps, but your question is a little vague. 
[removed]
[removed]
It would happen with this code example, but linear probing requires knowing the hashtable size in advance to work properly and perhaps doing array reallocation in insert function ( to keep at least 50% space unoccupied as author stated ). I believe he did not implement that because this serves as teaching example and not for actual use ( at least without few modifications).
Indeed! What a ripoff!
Yep, good catch.
The author said that you only need 50% for performance reasons, though.
Why is it necessary that M is a prime in this implementation?
Well I understand a bit more of what the heck this piece of crap app does. So it's using the epoll events to do stuff... now here is what I am seeing and am hoping someone could clarify this for me some.... There are these events EPOLLRDHUP and EPOLLHUP both of which are setup in this app to be monitored .. now from what I read in the docs for EPOLL_CTL the EPOLLRDHUP states this - Stream socket peer closed connection, or shut down writing half of connection. (This flag is especially useful for writing simple code to detect peer shutdown when using Edge Triggered monitoring.) Now if I understand this right this means that that will be 1 if the connection is dropped abruptly... ?? No ?? Am I not interpreting this correctly? The other EPOLLHUP is normally 1 if the device closed the connection properly ... right? Now if I understood that other one correctly this doesn't seem to be detected consistently .. I seen it not detected at all or several minutes later if at all... Let me know... thanks 
Thank you very much! Sorry if my question was vague, I wasn't quite sure if there was an issue at all or if I just hadn't learned enough to know how to open and read files in C. Your answer helped and I just managed to read my first file!
You are correct that a full hash table will loop infinitely. I didn't think it was worth mentioning because I state that this implementation should use a table size roughly twice the number of expected records, which makes it a moot point.
Good question! An ideal hashing function should not produce biased results. When used in a modulo operation, only prime numbers have an unbiased quality. I'm having trouble explaining this in detail which is probably why I didn't include it in the article. But suffice it to say that the more numbers that evenly divide into your table size, the more possibilities you have for an unbalanced table. I'll see if I can explain more when I have time to research it.
It might be that the program expects the input file to be piped into your program rather than read via 'fopen'. If your program reads from stdin (say, via 'getchar') then you can have it operate on the file 'foo.txt' from the command line thusly: myProgram &lt; foo.txt
That worked too. I tried that method before, but I must have used '&gt;' instead of '&lt;'. Thanks for clarifying!
Thanks. However, I found that I could compile thusly: gcc -o &lt;executable-to-be-created&gt; &lt;source.c file&gt; -liw
For deletion you can do better without making your code much more complicated. Look into Algorithm R (Deletion with linear probing), "The Art Of Computer Programming" Vol 3, 2nd ed, 6.4, pp 533-534.
Using a prime M is a weak technique to reduce collisions. A good hashing function first needs to generate as unique a value as possible for the data. Sometimes this is actually easy to do. E.g. using the addresses of objects gives you unique values. However, the unique values may not be well distributed. E.g. in the case of address of objects the low order bits are likely to all be zero and most of the high order bits are likely to be identical. This a where a mixing function comes in. You take the _unique_ values and pass them through the mixing function to get values that are well distributed across 2^32. Here's an example of a mixing function I've tested exhaustively (2^32 isn't beyond brute force anymore whereas a 64 bit mixing fn can only be tested by sampling). Changing a single bit in value has a 50% chance of flipping all the other bits. I.e. if you compare Mix32(value) and Mix32(value with one bit flipped) you'll find that, on average, half the bits will differ. uint32_t Mix32(uint32_t value) { uint32_t result = value; result += result &lt;&lt; 16; result ^= result &gt;&gt; 13; result += result &lt;&lt; 4; result ^= result &gt;&gt; 7; result += result &lt;&lt; 10; result ^= result &gt;&gt; 5; result += result &lt;&lt; 8; result ^= result &gt;&gt; 16; return result; } A good mixing function should _not_ introduce any collisions. Since you're mapping 2^32 into 2^32 - there's no reason collisions should occur. The above mixing fn achieves this by using only _reversible_ operations. If you do this, there's no need for M to be prime. Commonly M will be a power of 2 and you can use masking (`value &amp; (M - 1)`) instead of mod to compute the bucket index. Edit: I meant this to be a reply to /u/olfert's q about M being prime.
Are we (a pretty safe assumption) assuming the hash function you're using is unbiased? In that for any random input, each individual bit of output has a 50 50 chance of being true or false? This is a valid assumption for cryptographic hashes, and should be true for any hash you're using in a hash table. In that case, if you use a power of 2 size table, the bucket selection by simply masking out the last or first n bits, where the table size is 2^n is also going to be unbiased, by definition. Not to mention both mod operators are more expensive than a straight bitmask, and you will run into modolus bias if the bucket count isn't divisible by the maximum number of the data type of your hash. Which, since you're saying it's prime, is always true. The only time I can see a prime number having any benefit is when you have a poor hash function, in which case powers of 2 might be a worse choice than a prime number. Fix your hash function in that case. 
How is this related to C programming? I have removed your post as it is off topic.
like literally all I want is namespaces, returning multiple variables at once, and better generics.
If you don't want to post here, why do you do it? Note that I do not plan to remove this post any time soon as its quality is just high enough to not be considered “blog spam.” How about you try to write your own obfuscated programs instead of reposting the same one for the umpteenth time?
"Contiguous"? VLAs obey the same alignment rules as regular arrays. The compiler will typically calculate the space required at runtime, and reserve that on the stack.
I believe the usual practice is to just allocate them on the stack just like any other array. The diff being that since you don't know their size ahead of time you grow the stack dynamically once you know the size. See [alloca](http://man7.org/linux/man-pages/man3/alloca.3.html). The way you've phrased the question makes me think that _you_ think a VLA's size can change _after_ it has been allocated (a la arrays in many other languages) - it doesn't. 
Whoops, you're right about my misunderstanding.
Don't forget generics, and i believe the atomic stuff is new too, but that's pretty much it
Too bad there isn't an epub version
&gt; &amp;myBox.create(); This breaks the usual precedence rules for postfix operators -- `.` should bind more tightly than `&amp;`. Otherwise, it gets very confusing when trying to take the address of variables. `f(&amp;foo.member)` would not evaluate to the address of member, for example. But, to be honest, if I wanted one thing out of a new C, it would be type parameters for functions. Generics, but without the insanity. If I wanted two things out of a new C, it would be the generics, and the removal of textual includes. I've actually got my own language that does both of these, but it's rather far off from C in many other ways.
Maybe if you request it to the author he can upload a epub version of it. or some conversion tool.
Why would you ever do that to yourself?
I'm running out of time, tomorrow interview is there 
Have you tried it?
Generics are the macro syntax I was referring to. Because they're not extensible outside of the fixed variants I say, nor are they properly generic, I'm not a fan of them.
I moderate this subreddit for quite a while now and I clearly remember removing this post from techiedelight at least twice and a bunch of times from other sites that just copy-pasted the program (typically without any explanation). &gt; I can't write obfuscated code Then learn how to do that! If you are good enough at programming to write tutorials that are actually useful, then surely you can write obfuscated programs. &gt; Why don't u show us how good is moderator coding skills are by writing same code for ur country! Challenge accepted. Give me some time to write such a program please.
All arrays are contiguous. The compiler typically allocates variable length arrays by decrementing the stack pointer by the size of the array and using the new stack pointer value as the starting point of the new array. For example, this simple example: extern int bar(int*); int foo(size_t n) { int array[n]; return bar(array); } Is compiled into something like this on i386: foo: # establish stack frame pushl %ebp movl %esp, %ebp # load (n * 4) into eax movl 8(%ebp), %eax shll $2, %eax # compute address of array in ecx by computing (esp - n * 4) movl %esp, %ecx subl %eax, %ecx # adjust stack pointer to account for new array movl %ecx, %esp # call bar(array) pushl %ecx calll bar movl %ebp, %esp # destroy stack frame and return popl %ebp retl 
Yes, it is possible. The local variable *shadows* the global variable, meaning that inside the function, the variable name refers to the local variable whereas outside the function it refers to the global variable. This is generally considered bad style.
It's not necessary. But using a prime number increases the distribution of all bits in the original value to the hashed value. For example, if you used 16 for M, the hash function would only take the 4 lower bits into account. Using 17 instead lets all bits in the original value to have an influence on the hashed value. 
Could you share other articles like this? 
What happens if you compile with warnings enabled (using the -Wall compiler option)?
Nothing - no warnings come out and the compiled .so file behaves the same.
It is possible that some other function with the name `step` exists in some library. In this case, it can happen that the other `step` is used instead of the one you declared. You can fix this by making `step` a `static` function (making it invisible from other files) or by choosing a different name. Normally, the linker should complain if you have such a conflict and refuse to link. This might not be the case because you create a shared object. It could also be that Python checks if your shared object contains a function named `step` and tries to call it expecting it to have a certain signature (which your `step` doesn't have), crashing the program. You can guard against this sort of problem by hiding `step` from users of your shared library using `__attribute__((visibility("hidden")))` or by making it again a `static` function. The “correct” solution for this problem is to use a *map file* (also called *versioning script*) which indicates what functions should be exported from your shared object, but that's just overkill for your example.
Making it `static` worked perfectly (as did renaming it, of course). Thanks very much for the advice!
Yes, I think I'm also used to Python's scoping rules in that if Python couldn't find step within write_arg, it would search just outside before looking anywhere else. I'll be sure to bear this in mind when I come to write more C code in the future.
I emailed him about it but doubt i'll get a response
You might have already realized this but, in C, it's good practice to declare internal, module-level functions ("internal" meaning "only used within the same module" as opposed to functions you intend to expose through a header as part of your module's API) and variables as `static`. This prevents them from polluting the namespace and colliding. Unfortunately, you will find a *lot* of C code that doesn't follow this practice.
&gt; What the shit is "RAII" [Resource Acquisition is Initialization](https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization) Quite nice feature for avoiding memory leaks if you don't need explicit memory management but also don't want garbage collection. C doesn't have it out of the box. &gt; why are you assuming the audience you're targeting (beginners) knows what it means? They could find out from googling and they could also understand it from my post. Also, note that I'm targeting **C** beginners, not **programming** beginners [*]. I'm assuming programmers with multiple years of experience would have learned about it eventually. RAII is a very basic C++ feature and one would come across it quickly after even a superficial glance at the C++ language. [*] Ok, you could be both, but really.. learning programming with C is possible but quite rough. I don't recommend it. Handling pointers, memory and related stuff is hard enough even if you don't struggle with the actual core programming anymore. Even experts don't get it right all the time. Just take a look at all the CVEs of popular software related to buffer overflows, use-after-free etc for reference. I don't know about you specifically, but if C is all you know, you should check out other languages (and paradigms!) eventually. C isn't well suited for everything.
not directly relevant to the post, but have you considered using cython for this purpose? just found it to be a lot easier in my experience, than using the python C api directly
Have a look at [g_file_monitor](https://developer.gnome.org/gio/stable/GFile.html#g-file-monitor) and [GFileMonitor](https://developer.gnome.org/gio/stable/GFileMonitor.html). I've put together a quick example: https://gist.github.com/simu/0ed1e9b12871e20cec48efe73eeeb8e1 
I'm not sure but I think string literals go on code section and CS usually is given priority by the OS's memory manager to be in memory than be paged out. CS in kernel will always come from non paged pool unless you explicitly specify for it to be pageable. So having insanely large number of string literals _may_ give problems. Note that there are compilers settings where you can specify that it keep literals in data section.
No, not really. You really need awfully many of them (many hundred megabytes) to have any problems.
&gt; taught linked lists, stacks and queues &gt; asked us to implement these in form of a small project in C a completely retarded way of teaching imo
it's pretty trivial if the build is stable and you know basic autotools
&gt; basically just wrappers around pthreads so C++ is basically just a wrapper around C
OOP != C++ C++ developers mess up the performance. C++ developers increase compile time and bin sizes Compilers find it difficult to spit out optimized assembly if you use C++ C++ developers cannot fix segfaults easily because it's impossible to post-mortem a segv when the last 5 frames is STL code because nobody can read that compiler generated C++ code without vomiting all over the keyboard Also https://www.youtube.com/watch?v=1i4-e1okZtw 
&gt; string literals go on code section no &gt; CS usually is given priority by the OS's memory manager no &gt; large number of string literals may give problems no /u/Noobflair, your question doesn't really make sense. Those strings are going into your program anyway, how you refer to them doesn't make any difference.
benefit of doing OOP with C is that it keeps C++ programmers out
wat? edit: &gt; no no &gt; no no &gt; no no &gt; question doesn't really make sense The question makes perfect sense and I had asked it myself (to myself) earlier.
I usually develop on embedded processors with 8k to 32k of flash. Your answer makes me cringe.
For the sake of my self education, can you briefly explain why?
what is chunk ? If it means something more than a byte then simple answer is you'll reduce syscalls (as reading form socket, file, chardev, pipe requires a context switch to kernel) and thus reduce CPU utilization.
&gt; virtual addressing never needs to copy data assumes virtual address space isn't fragmented and a contiguous big enough virtual extent is readily available 
does it beat jemalloc's perf?
I'd be glad to. However, I'm not sure what you are asking about so I guess I'll answer both the questions I can think of. If you are actually asking something else, feel free to clarify. Q) Why only 8K to 32 K of flash? A) Economics. When you are making a lot of something every penny counts. Processors with fewer resources cost less, so we use the most stripped down processors that we can get away with. Actually 8K is an exaggeration. I've worked on processors that had less than 1K of flash although it was probably not flash. It was an OTP or ultimately a ROMed part and it was several years ago. Q) Why does the offhand remark that anything short of "many hundred megabytes" of strings isn't a problem make you cringe? A) I've been writing embedded code on small processors for nearly 40 years. Resources are always tight and I'm always looking for ways to save them. I never use an `unsigned short` when an `unsigned char` will do. Someone recklessly squandering resources is sort of like fingernails on a chalkboard to me. It's not just /u/FUZxxl though. The whole mentality of PC developers that "if it's not fast enough you need to get a faster computer, if it's too big you need more memory" has given us incredibly fast, huge computers for cheap, but it's also given us enormous, slow software. Incidentally, I mean PC in the original sense of "personal computer" so I'm including Macs and Linux. When I started programming, the processors I worked on were 8-bit and ran at 1 MHz. They had an entire address space of 64K, although most of that space wasn't populated with anything. And this was the computer you were developing on. The processor you were developing for, the embedded target, was about the same, but usually had far fewer resources. Today the computers are thousands of times faster, have millions of times more memory and have other improvements over those original computers that would have been unimaginable when I started, but the responsiveness of the user interface in many cases is worse than those original tiny, slow computers. Why? because of the mindset that inefficient poorly written code is OK because it can be offset with better hardware. To be fair, PCs are doing enormously more than those dinosaurs were. Something as simple as displaying a text string in a GUI requires many times more code than it did when displays were character mapped. On the other hand, many things that are slow and take a lot of memory don't need to. I had a long rant here, but I took it out because it isn't important. Suffice it to say that as an old programmer I've got my own set of "get off my lawn kid!" type pet peeves. I'm sure many of them are unimportant, but in general: if we had a different attitude in the software development community, where performance and size were considered at least as important as time to market, without even changing the existing hardware, we could have remarkably better performance.
The question is *at best* incomplete and your answer is completely wrong. You are confusing sections with segments, assuming that the platform has segments and uses them the way DOS did 30 years ago, assuming that the executable format has sections, assuming that the section that contains the actual code is called “code” (it is usually called “text”), assuming that string literals go into that section (they usually go in the “data” section), and finally claiming (incorrectly) that large amounts of string literals “may give problems” with no evidence or even argument in support.
He just told you. In case you find arithmetic difficult: “many hundred megabytes” is at least 100,000 times more than the total amount of storage available on the platforms he works with.
I am completely with you in not wasting resources. I'm also with you with “every byte counts.” Even though I don't do embedded development, this is very important for me because I write code where indeed every single byte counts because I deal with a dataset of many billion entries and reducing the amount of storage needed to process each entry by as much as one byte can be the difference between having to use a cluster or just a beefy server. However, OPs question was “how many string constants can I have until there are problems?” and the answer on a modern machine is clearly “couple hundred megabytes at least.” Not that you should waste that much memory if you can help it, but the computer can deal with that many string constants.
Hey, you'll love Electron! Haven't you always wanted your simple desktop apps to have a 5-second splashscreen and each depend on the same statically linked 60 MB executable?
I'm not 100% sure what you're trying to do from your description, but scanf can handle multiple strings, or any other type. The code as you're written it won't work however - or at least it shouldn't, if it does work then that's purely by accident. `char *s1` is a pointer to a character, but it's not pointing anywhere, so there's nowhere to store these characters. You probably want something more like this: char s1[32]; char s2[32]; scanf("%32s %32s", s1, s2); printf("s1=%s\ns2=%s\n", s1, s2); 
Thanks for the answer. Lets just say that the program is to take input for two strings. Coming back to the answer what if the size of the input string is unknown? Could realloc be an option?
String literals usually go in `.rodata` I think.
&gt; modern machine And what is a "modern machine"? An STM32L011 is quite modern, has 8K of flash and 2K of RAM. The original question doesn't specify the platform the program will be executing on. Without that information it's an open ended question. I think the appropriate answer to, “how many string constants can I have until there are problems?”, would be, "as many as you want until there are problems".
if you don't know how large the input is, yeah you'll have to dynamically allocate an array to hold it. You can just use malloc. A good strategy is to double the size (+1 byte for null character) of the previous array, copy over the contents of the old array, free the old array, resume reading the input. 
`scanf` isn't well suited to arbitrary length strings. You'd be better off reading to a temporary buffer with `getc` or `read` and re-allocating that as necessary. You can't use `realloc` or `malloc` etc without knowing how much to allocate.
It's very hard to find a project that has both never been done before and is easy enough for someone with your level of knowledge to implement in a reasonable amount of time.
&gt; data being addresses in both case Nope, *data* in *main* is an array, and *data* in the function is a pointer. Arrays behave like pointers in several cases (since they usually decay to them when operated on) but not always. &gt; wouldn't the sizeof() operator require the address only Nope. *sizeof* works on types and objects, not addresses.
Good luck finding an unique idea in the 21st century. Stick to recreating something you use every day, or would like to learn more about. Keep the scope small enough that you can finish a basic skeleton in a day or two and a rough alpha concept in a week or two.
In `check`, `data` is a pointer to an integer. In `main`, `data` is an array of 8 integers. On your system, a pointer to an integer is 8 bytes long, so `sizeof(data)` is co-incidentally 8. You get the same result by running `sizeof(int *)` `data` in main is 8 integers, each take up 4 byes, giving the total size of 32 bytes. If you want instead the number of elements, then you need to divide that total by the size of an element, e.g.: printf("There are %d elements in data\n", sizeof(data)/sizeof(data[0])); You may also want to add another element to data, so that it's not co-incidentally the same size as a pointer to int, e.g. int data[] = {1, 2, 3, 4, 5, 6, 7, 8, 9}; In this case `check` will still print out 8. --- Edit: I forgot to mention earlier, `sizeof` is a keyword, not a function. It is generally handled at compile time, not runtime. It doesn't take an address to anything, it's working at a different level.
Just to add to other responses, there is no way to pass an array to a function - whatever syntax you use, the passed object will always end up being a pointer in the called function.
&gt; assumes virtual address space isn't fragmented and a contiguous big enough virtual extent is readily available Although this is a true and important comment, I believe it might be read inaccurately. If there isn't a large enough memory address range to be used by the memory map, `realloc` will fail (as will the process, eventually, since it indicates a fragmented memory map). The data isn't copied, ever. There's no need and no reason to do so. The need to copy data exists only when small chunks (less than a page) grow and need to be moved within a page (or to a different page). otherwise, it's more efficient to rearrange the memory map managed by the kernel. 
I think if OP asks this kind of question, he probably doesn't program a microcontroler.
Traditionally, they go into the text section but that has changed over the years.
You may be right, or he may be writing code for an Arduino. Hard to know.
I mean, aren't those basically the same? Except the rodata section may be marked as no-execute.
Yes, they are about as similar as the data and text section.
Removed. Please submit programs you wrote as text, not as videos. Nobody wants to watch a 5:38 minutes video just to see how your program has been written.
It looks like you need to read up on pointer decay. `data` is an array. When you mention `data` as a parameter to pass it to a function, it temporarily acts like a pointer, sometimes called pointer decay. It's important to know when and where this occurs, because `sizeof` is one of the specific contexts where it does *not* occur. Have a look at C99 &amp;sect;6.3.2.1/3: &gt; Except when it is the operand of the sizeof operator or the unary &amp; operator, or is a string literal used to initialize an array, an expression that has type ‘‘array of type’’ is converted to an expression with type ‘‘pointer to type’’ that points to the initial element of the array object and is not an lvalue. If the array object has register storage class, the behavior is undefined. `sizeof(data)` is not a function call because `sizeof` is not a function; it's an operator and it has special rules. You are asking for the size of the array, not the size of the pointer that would result if the array temporarily decayed to a pointer. 
A list of captured pokimon, strength and weaknesses agaist others based on rarety. Ie, how likely is it to win / loose a randomly found Pokimon. FYI, I've never played, so I have no idea how the rules work exactly, but it sounds like a fun project.
Block chain based digital wallet?
maybe adventofcode.com in pure C? 
You've forgotten about destructor/cleanup functionality. Whatever you malloc(), you shall free() later :D Having method pointers inside each instance is kind of a waste (both memory and CPU), but I can't think of other ways that would allow them to be called conveniently from plain C. You could build a "call method" macro that calls functions directly without going through a function pointer, but it would look uglier than what you have now. Also, depending on what definition you use, this is not "true OOP". Most people would say that true OOP requires inheritance and polymorphism, too. Don't let it discourage you from doing this as a learning exercise, though.
Thanks a lot, I will definitely take a look at memory cleanup. Regarding polymorphism and inheritance, it might be possible using a pointer to a superclass instance and some method-pointer-relinking.
Is there a problem in your life that you are facing or do you know of a problem that someone else is facing? Could it be solved by coding a program? What could you do to make the greatest positive impact in the world with the knowledge that you now have? It's true that many solutions to existing problems have been coded already, however new problems arise everyday when new systems or ideas are implemented which means that there are always new opportunities to solve new problems. Listen really closely to people complaining around you and focus on the most worthwhile complaint to address. That should give you inspiration for your new, unique code. Good luck! Also, acedemic institutions like public schools, high schools, and especially colleges and universities are always looking for help solving problems, especially dealing with big data. C is great for processing big data because C is simplier than modern day languages so it is easier and therefore faster for computers to process the code required for processing large data sets.
Write your own window manager. You can make it on top on Xserver or wayland, or make it standalone, writing into a pixel buffer. I recommend the later, because it's way more fun, you have to implement everything yourself.
Don't do `fflush(stdin)`. That does not do what you think it does. I know you want to use `scanf` and do use it, if your situation fits the use case. But I recommend you read the following first: * [fflush vs gets](http://c-faq.com/stdio/gets_flush2.html) * [Why not use scanf](http://c-faq.com/stdio/scanfprobs.html) * [How to flush stdin](http://c-faq.com/stdio/stdinflush2.html) Also follow the links in those three questions to find out more.
It's valuable to know how to build these OOP mechanisms in C, but it's also important to recognize that it shouldn't be used casually, saving it for special circumstances.
This is a good suggestion 
The traditional way to implement polymorphism is via a [vtable](https://en.wikipedia.org/wiki/Virtual_method_table). It only takes one pointer per instance (or one pointer per supertype if you allow multiple inheritance). The traditional way to implement inheritance is to have the super instance(s) be special fields of the derived instances. C has a special rule that allows you to safely cast a pointer-to-struct to a pointer to the type of its first member, so single inheritance can be implemented like this with upcasts/downcasts working properly (but not checked by the compiler, of course): struct Base { int whatever; } struct Derived { struct Base super; int some_extension_field; } Derived *d = malloc(sizeof(Derived)); Base *b = (Base*)d; /* guaranteed to point to d-&gt;super */ b-&gt;whatever = 42; free(d); Of course, if you keep implementing things like this, you are just slowly reimplementing a limited and awkward version of C++. It can be an interesting learning experience, but not something you want to do in production code.
&gt; that way I can set a macro to enable byte order specific code in my source. Ehem... You sure you want to have byte-order specific code? This usually indicates a code smell. Anyway, if you are using the autotools, there is probably a configure test that finds out the byte order. Otherwise, check what macros your compiler defines. Typically there is something indicating endianess.
I'm writing an IO library, I have a 2 promged approach, first the user says which endian this field is written in, and I have a generic function to read the various endians properly, but it also depends on the target machines endian so the numbers are correct no matter what platform it's compiled for. For the second part I need to extract the targets byte order from which machine it's being compiled for (not nessicarily the host platform either in case it's being cross compiled, which will happen like 100% of the time) And obviously i don't want the overhead of detecting it at runtime, it adds a lot of executable bloat. I'm trying to avoid autotools, but I can check the compiler's macros again.
How about using an endian-agnostic read/write idiom? E.g. functions like [these](https://github.com/fuzxxl/memf/blob/master/src/fiddle.h). The compiler should optimize these into simple moves with byte swaps, but it [some times does not](https://stackoverflow.com/questions/25219621/preferred-idiom-for-endianess-agnostic-reads) sadly.
That's more or less what i'm writing actually.
Then why do you need to know about the endianess? Just use an endian-agnostic function and let the optimizer do its job.
Because if it extract a field from big endian on a lil endian machine, it'll need to be flipped if it's running on a lil endian machine. the generic function decides only which endian the data is being read from, but within that function is a set of `#ifdef`s that decides which code to enable depending on the architecture of the target. and the problem with macros is they only reflect the host platform, not the target. so if I'm compiling for ARM64BE on an AMD64 machine, the byte order will be wrong.
Do not flush input streams. That's undefined behaviour. `scanf` is not the right function for your task. Try `fgets()`.
Using it in productive code wasn't my intention anyway. I simply find it interesting to experiment and to build stuff like this, because it teaches a lot about the implementation of these features in higher-level-languages. If I just needed C with abstractions, I could've just gone with C++ as well. :)
The idea behind endian agnostic functions is to always write data to files (or the network) in a well-defined byte order (e.g. always little endian). Programs can then use the endian-agnostic function to read the data and it always comes out in the native byte order. It is not necessary to know about the byte order of any of the involved platforms to program like this. &gt; Because if it extract a field from big endian on a lil endian machine, it'll need to be flipped if it's running on a lil endian machine. You can use the function `rm32()` from my header to read a 32 bit quantity from a file in big endian. It does the right thing both on little and big endian machines without having to know what endianess the machine has due to the way it is programmed.
Good for it but some formats write data to files in a different order, shit BMP 1 bit files are written in most significant BIT order. You HAVE to convert those dude.
Of course. And since you know the endianess of BMP files, you can just use the appropriate endianess-agnostic function like `ri32()` (read 32-bit little endian [**I**ntel byte order] datum). This reads one 32 bit value in little endian and converts it to whatever the hosts byte order is. That's exactly what you need and the implementation does not need to know what the host byte order is.
No blog spam please.
I found [this](https://commandcenter.blogspot.com.br/2012/04/byte-order-fallacy.html) very helpful, maybe it fits your case.
I'm reading binary formats, i may be wrong it's sort of confusing as hell, but i'm pretty sure the endian matters. Obviously byte order and for that matter bit order only matter when it's being transferred from one computer to another, but that's kinda the whole point
That would be an option if I didn't have a BitBuffer abstraction above fread, and that abstraction is kinda important.
Then redesign your abstraction so it accounts for that. Poorly chosen abstractions are code smell, get rid of them!
OOP in C isn't really possible but here is the closest I have ever come. It has inheritance and constructors and destructors. #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #define New(T) \ (T*)T##_new(sizeof(T), &amp;_##T##_VTable); #define Release(T) \ free(T-&gt;vtable-&gt;dtor(T)); T = NULL #define Class(T) \ typedef struct T T; \ typedef struct T##_VTable T##_VTable; \ struct T #define REGISTER_CLASS_END(T) \ T* T##_new(size_t s,T##_VTable *vt){ \ T* o = (T*)calloc(1,s); o-&gt;vtable=vt;\ o-&gt;vtable-&gt;ctor(o); \ return o; } #define REGISTER_CLASS_CHILD_END(T, P) \ T* T##_new(size_t s,T##_VTable *vt){ \ T* o = (T*)calloc(1,s); o-&gt;vtable=vt;\ o-&gt;vtable-&gt;ctor(o); o-&gt;parent=New(P);\ return o; } #define VTable(T) \ struct T##_VTable #define CREATE_VTABLE(T) \ T##_VTable _##T##_VTable #define CLASS_REQUIRED_MEMBERS(T) \ T##_VTable *vtable #define CLASS_PARENT_MEMBER(P) \ P *parent #define CLASS_FUNCTION_HEADER(R, T, M) \ R T##_##M(T* this) #define VTABLE_REQUIRED_FUNCTIONS(T) \ VTABLE_FUNCTION_POINTER(T *, T, ctor); \ VTABLE_FUNCTION_POINTER(T *, T, dtor) #define VTABLE_FUNCTION_POINTER(R, T, M) \ R (*M)(T*) #define VTABLE_FUNCTION_VALUE(T, M) \ &amp;T##_##M #define _(T, M) \ vtable-&gt;M(T) #define DBF() \ printf("Call: %s\n", __FUNCTION__) #define _parent this-&gt;parent /* */ Class(Abstract) { CLASS_REQUIRED_MEMBERS(Abstract); CLASS_PARENT_MEMBER(void); }; VTable(Abstract) { VTABLE_REQUIRED_FUNCTIONS(Abstract); VTABLE_FUNCTION_POINTER(void, Abstract, hello); }; REGISTER_CLASS_END(Abstract); CLASS_FUNCTION_HEADER(Abstract*, Abstract, ctor ); CLASS_FUNCTION_HEADER(Abstract*, Abstract, dtor ); CLASS_FUNCTION_HEADER(void, Abstract, hello); CREATE_VTABLE(Abstract) = { VTABLE_FUNCTION_VALUE(Abstract, ctor), VTABLE_FUNCTION_VALUE(Abstract, dtor), VTABLE_FUNCTION_VALUE(Abstract, hello) }; /* */ CLASS_FUNCTION_HEADER(Abstract*, Abstract, ctor) { DBF(); return this; } CLASS_FUNCTION_HEADER(Abstract*, Abstract, dtor) { DBF(); return this; } CLASS_FUNCTION_HEADER(void, Abstract, hello) { DBF(); return; } /* */ Class(Base) { CLASS_REQUIRED_MEMBERS(Base); CLASS_PARENT_MEMBER(Abstract); }; VTable(Base) { VTABLE_REQUIRED_FUNCTIONS(Base); VTABLE_FUNCTION_POINTER(void, Base, hello); }; CLASS_FUNCTION_HEADER(Base*, Base, ctor ); CLASS_FUNCTION_HEADER(Base*, Base, dtor ); CLASS_FUNCTION_HEADER(void, Base, hello); REGISTER_CLASS_CHILD_END(Base, Abstract); CREATE_VTABLE(Base) = { VTABLE_FUNCTION_VALUE(Base, ctor), VTABLE_FUNCTION_VALUE(Base, dtor), VTABLE_FUNCTION_VALUE(Base, hello) }; /* */ CLASS_FUNCTION_HEADER(Base*, Base, ctor) { DBF(); return this; } CLASS_FUNCTION_HEADER(Base*, Base, dtor) { DBF(); if (this-&gt;parent) { this-&gt;parent-&gt;_(this-&gt;parent, dtor); } return this; } CLASS_FUNCTION_HEADER(void, Base, hello) { DBF(); _parent-&gt;_(_parent, hello); return; } /* */ int main() { Base *o = New(Base); o-&gt;_(o, hello); Release(o); return 1; } 
You should put four spaces in front of each line so reddit formats it properly.
You're right, sorry. It's my first time posting code and I copied out of a C app I have on my iPhone that lets you compile code. I wrote the whole thing on my iPhone while on holiday last year. The main function is the important bit as it shows how to instantiate the objects. I'm on my phone now but I will try and clean it up tomorrow when I have my laptop.
No problem, no need to apologise.
I'm still thinking about your bit buffer abstraction. How does this abstraction introduce the need to know anything about the endianess of the host platform? This would only matter if your bit buffer read data without accounting for the file's endianess. If you programmed the code that way, that would be very weird.
Whenever I think about this kind of inheritance, iimagine a third generation function accessing a first generation member. foo.super.super.whatever This feels awkward. 
I forget, will three backticks work? ``` How does this look? Does indent work? ``` Edit: it works! A line of three backticks before and after. Good for mobile Edit 2: never mind. It only works in simple cases
Try putting 3 backticks (\`) on a line before and another after, instead of indenting all lines. May be easier.
How does it fare in [JSONTestSuite](https://github.com/nst/JSONTestSuite)? So far the only C library to pass all the tests is [pdjson](http://seriot.ch/json/parsing.html#9) (disclosure: that's my own library), but Jsong looks promising. 
What tools/apps/etc are you using to write C code directly on an iPhone? I tried to do this with an Android phone and found it to be a pretty miserable experience.
Build from scratch a Kruskal maze generator and an A\* solver to go with it. The maze generator will require a disjoint set data structure as well as something to efficiently draw randomly from a set. You'll also need to choose a representation for the maze. For the solver you'll need to write a priority queue (heap) and a couple of map-like data structures. 
That may work with some other Markdown flavour(s), but unless I derped completely when I just tried it, it doesn't work on Reddit. (I got an inline code block with line breaks and indentation removed.)
With code of this length you should make it practice to link a gist anyway. If I had a nickel for everyone I've seen kicked from freenode after 3 lines into their 40 line paste I'd be a millionaire. 
I've never wrote endian specific code, and I don't know if I understand the concept entirely, but I think the following holds. If we write uint16_t x = (0xAB&lt;&lt;8)|(0xCD&lt;&lt;0); We're assigning the value 0xABCD to x, it's like we're concatenating the byte AB with the byte CD, and that code must produce the same result regardless of the endianess of the machine running it. So, if we were to examine the memory in x's address in a big-endian machine, we would see: ABCD But in a little-endian machine, we would see: CDAB (And that's correct, that data pattern represents the 0xABCD value on that machine) The same code produced different (but correct) internal representation of the value. So, I guess that's why we only need to know the endianess of the source we're reading, and the rest stays the same. 
Yes, the standard defines that shifting works regardless of endian, but your perspective is wrong. Lets say a program on a little endian machine writes the number 4095 with fwrite. 4095 is 0x0FFF in big endian (the most significant byte is first) or 0xFF0F in little endian. So, 4095 is written as 0xFF0F is written to the file. That file is opened on a little endian one, and the first field is 16 bits so my bit reader needs to read 16 bits, it reads those bytes one at a time blah blah blah. The thing is, it may or may not need to be byte swapped depending on the architecture that way the 0xFF0F is interpreted as 4095, rather than as 65295. (The numbers may be wrong, i wrote this on my phone, but this is the general idea) Ok so that may've been a little unclear i was busy. The point is, the actual value of a group of bytes/bits can be interpreted differently, when a number has been pulled into memory for you these details don't matter, but when you're doing it yourself, you have to be sure the bytes are assembled together in the right order. In order to assembly them correctly, I need to know both the format the original data is in (the fields I'm reading from a file), AND the byte order (AFAIK there's no MS bit first machines out there, but if there is, this too) of the machine that is running (preferably during compile time)
 Vector2D test = newVector(); test-&gt;x = 2; test-&gt;y = 3; What?! No private variables and setters? That'll teach you for straying from the procedural church, you heretic!
Most of what you said is correct, however, the advantages of easier to maintain code greatly outweighs all of your complaints. This is the reason 90% of development has moved off of c and onto languages such as c++/java/c#. Also the fellow in the link doesn't give any evidence on why c++ is poor, he attacks the author of c++ and people who program in c++, calling them inexperienced. I don't believe anyone who holds opinions this emotional should be referenced in any context.
Because it reads in data with fread as individual bytes. The swapping happens above BitBuffer as the data is read from or written to it, i have to do all that myself. What do you mean by host platform? I feel like the terminology is getting in the way, at least for me. I'll walk you through the process, hopefully this'll help. So, i have a function called OpenInputFile, it opens a file with fopen for reading, the file pointer and associated data is store in a struct called BitInput. Ok, so once the file is opened, the user creates a BitBuffer struct and data is read in byte by byte. The data in this BitBuffer is absolutely platform agnostic, it's literally just an array of bytes. Lets say you're reading a BMP file, the file magic is "BM" so you'd call ReadBits, and tell it to extract 16 bits, and that this data is in big endian (because it's a string) Now is where it gets tricky, since we read this chunk as a single 16 bit field instead of as 2 bytes, byte order comes into play. So, this field is in big endian you've told this function, and lets say the platform you're reading on is little endian, therefore those 2 bytes need to be swapped. So the result is "MB". If it's being read to a big endian platform it would not need to be swapped because the data format matches the target architecture. Now let's say the next field was a 32 bit int in little endian byte order that said the size of the file. (It's not a string and is therefore little endian) Now we just need to extract the next 4 bytes from BitBuffer with no swapping since it's in the target's byte order already. (This flip flop happens ALL THE TIME) Now obviously this example choice was dumb and potentially confusing, but hopefully you got what i'm trying to say? Now there is one more thing I should add, i probably could do what libpng or whateve does it, and simply call fread all the time, and simply mask shit out right then and there, but there's a LOT less flexibility in doing so, and you have to keep more in mind as you write the code. Why not pay for all of the work to read and write bits once, instead of having to do this everytime, plus with a buffer it reduces IO latency.
do you know how to archive it with only glib library? ty
That's not possible. Doing so would assume every field was a certain size, and byte order, and it would all still need to be converted.
Well, trying to do OOP in a language that's not designed for it will be awkward no matter what. If you have a "super pointer" as proposed by the OP, you get `foo.super-&gt;super-&gt;whatever`, which is no better. Do you have an idea that would look nicer?
It's called Mobile C. Yes it was a miserable experience but I was on a 3 week holiday and would do it on the plane or on the bus it any moment that was worse. I have a tiny iPhone too and that didn't help things.
&gt;The distinguishing feature of CompCert is that it has been formally verified using the Coq proof assistant: the generated assembly code is formally guaranteed to behave as prescribed by the semantics of the source C code. Does it mean the compiler is guaranteed to have no bug?
Multiple header files. E.g. foo.c // source, #includes foo_internal.h foo.h // public header foo_internal.h // only for use by other files implementing the fooXXX module, can include OpenGL stuff Sometimes it's even necessary to have two (or more) layers of headers. E.g. `foo_internal.h ` and `foo_private.h ` Where private is only for _select_ clients.
Nothing is preventing you from using getters and setters to encapsulate your fields.
Nothing wrong with having two header files. What constitutes a module depends on where you want to draw the boundaries. A function can be a module and so can an entire library, and anything else where you can modify or replace the implementation without affecting the users of the interface. If you relax the view of a 1-to-1 relationship between headers and source files then you can have multiple headers and source files and still say that it is just one module. There are technical reasons to split source files (separate compiler options, smaller linked executables) and header files (more focused headers can result is shorter compile times), but also non-technical reasons such as being easier to understand. Even if we still define module boundaries to be files then the "graphics.h" header could be the module interface and it happens to be implemented in terms of several smaller modules. Parts of its interface is defined in this source file, others in that one, and these sources depend on a third module with a header of its own that is independent of "graphics.h".
What about relinking your non-overriden method-pointers to the super-instance?
You'd still need to have access to inherited fields from overridden methods, and that's the place you could end up saying `this-&gt;super.foo` or `this-&gt;super.super.foo` in case of deeper inheritance.
While this is true, fields generally shouldn't be inherited anyway and only accessed via the method interface to encapsulate them.
&gt; Nothing wrong with having two header files. That soothes my concerns a little bit. If that's the generally accepted practice I'll be using it, certainly gives a lot of flexibility (e.g. with different headers for different levels of access as someone else suggested). &gt; more focused headers can result is shorter compile times Yea, I like to keep my headers clean. Needlessly including a dozen other headers just seems wrong.
True, but in C, you have no way to enforce this, it doesn't have visibility modifiers. So basically, if you don't want to access supertype fields, you shouldn't worry about how many fields you would have needed to go through to access them, and /u/pfp-disciple's point is moot. If you do want to access those fields (C doesn't have a way to prevent you from doing it, in any case), I don't think you have an easier way than to manually walk through those "supers".
Assuming coq is flawless 
It's a funny question considering there's a "bug fixing" section in the link provided. The compiler is guaranteed to produce correct output according to the specifications, but the specifications need to be, well, specified. There can be a bug in the specifying what correct behaviour is.
If you want to read fields larger than a bit, why do you have a bit buffer abstraction in the first place?
&gt; What do you mean by host platform? I feel like the terminology is getting in the way, at least for me. The *host platform* is the platform your program runs on. The *host byte order* is the byte order of that platform. &gt; So, this field is in big endian you've told this function, and lets say the platform you're reading on is little endian, therefore those 2 bytes need to be swapped. That's the mistake you make. The correct way of thinking is: I receive two bytes that represent a short in big endian byte order. You can do the conversion without knowing about the host byte order like this: unsigned short field; unsigned char first_byte, second_byte; first_byte = extract_byte(); second_byte = extract_byte(); field = first_byte &lt;&lt; 8 | second_byte; Now `field` contains the 16 bit datum in the host byte order. This works correctly on both little and big endian platforms. You did not need to know what the host byte order is. Note that in case the field is a string, it's not really in "big endian byte order" but rather it's a bunch of byte sized fields after each other. So the correct approach for conversion is: unsigned char field[3]; field[0] = extract_byte(); field[1] = extract_byte(); field[2] = '\0'; /* optional, for convenience */ &gt; Now let's say the next field was a 32 bit int in little endian byte order that said the size of the file. (It's not a string and is therefore little endian) And you convert this one like this: unsigned char byte1, byte2, byte3, byte4; unsigned field; byte1 = extract_byte(); byte2 = extract_byte(); byte3 = extract_byte(); byte4 = extract_byte(); field = byte1 &lt;&lt; 0 | byte2 &lt;&lt; 8 | byte3 &lt;&lt; 16 | byte4 &lt;&lt; 24; No need to know about the host byte order either. &gt; Now obviously this example choice was dumb and potentially confusing, but hopefully you got what i'm trying to say? Yes, and that's exactly what I assumed from the beginning. I hope my point is a bit clearer now. Please actually look at the header I sent you, it contains implementations of exactly that. &gt; Why not pay for all of the work to read and write bits once, instead of having to do this everytime, plus with a buffer it reduces IO latency. Note that you really don't want to read individual bits if you can help it. The overhead is tremendous as you typically have one function call or loop iteration per bit. Try to at least write your code to read one byte at a time.
This is really pushing the boundaries as it's really a Doxygen question that is only tangentially related to C. Consider asking on [tex.SE](http://tex.stackexchange.com) or in /r/tex or /r/latex.
Thanks for the reply, I couldn't find any subredit related to Doxygen so I assumed this was a good place to ask. I will try at those you suggested.
Because i want to read a variable number of bits from bytes? The number of bits to read is context dependent, but it's very rarely a multiple of 8...
That is crazy, but doesn't really alter what I wrote before. However, if your fields are not aligned on byte boundaries, how did you expect to just copy a word from the input?
Glib (see https://developer.gnome.org/glib/stable/ for the full official glib documentation) does cater more towards the non IO needs of a C application programmer. The only file-related API I found in glib is a platform independent layer on around POSIX/WinAPI file IO (see https://developer.gnome.org/glib/stable/glib-File-Utilities.html). The more advanced IO functionality is all in GIO as far as I'm aware. Looking at the official git repository for glib there seems to be (at least some) support for GIO on Win32 platforms (see https://github.com/GNOME/glib)
I don't have it handy, and I'm on my phone, but I've used macros and typecasting to get inheritance. It might not be nicer overall. Basically it's something like this. (again, off the top of my head and I'm not fully awake) #define BASE \ int foo; struct base { BASE } ; #define CHILD \ BASE; \ char bar; struct child {CHILD} ; struct child thing = {1, 'x'} ; struct base* p = &amp;thing; Of course I had function pointers, constructors, and destructors. There was no single vtable, just a struct member per function. The derived type was responsible for keeping track of the parents function. Function pointers were assigned in the constructor.
How are you determining that the max # of connections is exceeded? Couldn't you just use the same technique to track how many of those are downloading firmware? Is the app serving up the firmware bits to the device? Wouldn't it know if it were still connected? Another option that comes to mind is using a semaphore.
To do OOP in C, you eventually have to rely on convention and discipline. The art is in knowing how much effort is appropriate to enforce that convention without adding too much overhead. 
Poor C preprocessor gets really abused.
I guess I understood what you said, but let's examine a "endianess agnostic" solution to see if it pass, at least, in the case you described. (Please, let me know if I misunderstood it) The file will have the byte FF followed by 0F, and this data is encoded in little-endian First we put those bytes in an array called data in the order they appear, so in the first position of the array we will have FF and in the second position 0F, the same order those bytes appear in the file. The supposed "endianess agnostic" code to read a little-endian encoded stream is the following x = (data[0]&lt;&lt;0)|(data[1]&lt;&lt;8); Which in this specific case is equal to x = (0xFF&lt;&lt;0)|(0x0F&lt;&lt;8); Which will assign the value 0x0FFF to x This piece of code doesn't make any assumptions on the endianess of the machine running it, only about the endianess of the stream been read. And the correct value of 0x0FFF will be assigned in any machine. If the value was written in the file by a big-endian machine we would expect to be 0F followed by FF And the code to read from a big-endian source is x = (data[0]&lt;&lt;8)|(data[1]&lt;&lt;0); And should be easy to test if this code read the right value in a little-endian machine, I mean, test if this code can read a big-endian data stream on a little-endian machine. I guess the thing is, if we read the data as a whole with fread for example, we must see if it's represented correctly in our machine, testing the correlation between the endianess of our machine and the stream, and then performing a byte swap if it's the case. But with the code above, the assignment can be made right only knowing the endianess of the stream, and no byte swaps are needed.
why not jsmn?
Extremely large structs will occasionally blow the stack. If you have large data known at compile time, declare it static and use pointers to parts of it as the access. If you don't know the data at compile time, just use malloc. Unless you're operating in constrained environments, there's no reason to not use dynamic memory and many reasons to use it. Also, your data seems ... weirdly organized. Why wouldn't you do struct Robot { Optic optic; Leg leg; Arm arm; /* etc */ } static Robot robots[100]; If you only want 100 Robots ever, a static array is fine. Otherwise, I would strongly suggest using a Vector of them at runtime.
Coq would need to have a flaw where it accepts invalid proofs, and then the compiler needs to have a bug - with exactly that kind of an invalid proof about its correctness. It's possible, but it's orders of magnitude less likely than an ordinary bug.
Right, and it's not "assuming Coq is flawless," it's "assuming Coq's (comparatively smaller) proof checker is flawless."
I'm doing something like a [ECS](http://entity-systems-wiki.t-machine.org/). It is more common to handle components isolated than robots as whole, so doing it that way makes more sense. 
Pretty clever! That's less code than I expected. This variant of the hacker logo with the diagonal inversion is my design (and that's my blog). The [original version was hacked together in Inkscape](https://pastebin.com/Qq3yw71d) without much precision. Using SVG and having a fancy program rasterize it means anti-aliasing is automatic. To actually use the output of your program, I'd first render it at, say, 4x the size I want, then I'd scale it down with a binlinear or Lanczos filter to smooth the harsh edges, simulating a higher resolution display. For example, here's your second image with this treatment: http://i.imgur.com/zYz95wB.png You can produce similar naive, simple anti-aliased edges directly in your program by making multiple nearby subsamples for each output pixel and blending the results together for the output. Pixels on the on a threshold will get some samples in one color and some of the other, blending proportionally to something in between.
It also helps understand what is happening in OO languages like C++
Once I mastered the basics, I had to implement several algorithms in college. I think it was a good path into both writing data structures from scratch, and learning to debug properly in C (with GDB, valgrind). I thought I was pretty good at it and wrote a few respectable projects where I was usually the lead. However, once I was out of college and started working on a large codebase, I found that I was far, far from being good. Beside *really* learning git, reviewing code, maintenance and so on, the C you write from scratch in university project and that you will only improve once or twice, and the C you maintain for years, is different. I think what you are trying to do is a good idea, but keep in mind that you will probably not understand a few subtle stuff without experiencing it first-hand. And if you are asking yourself what kind of C jobs you can find, myself I started working on networking stacks for kernel bypass solutions. I write userland drivers for network interfaces with a few L2 / L3 / L4 standards on top of it.
Alright, let me provide you with a couple alternatives to accomplish what you're trying to do: #Singleton robot object `Robots.h`: #include "Arm.h" #include "Leg.h" #include "Optic.h" #define MAX_ROBOTS 100 typedef struct Robots { Arm arms[MAX_ROBOTS]; Leg legs[MAX_ROBOTS]; Optic optics[MAX_ROBOTS]; } Robots; extern Robots robots; `Robots.c`: #include "Robots.h" Robots robots; Advantages: - No need to call an `_init()` function just to use the fields of your struct - Avoids the problem of `Robots_init()` being called multiple times with multiple different top-level handles Disadvantages - Global, mutable variable. If you find yourself doing this, it's always worth a step back to see if there's a cleaner way to accomplish what you're trying to do # Robots "constructor" for singleton object `Robots.h`: #include "Arm.h" #include "Leg.h" #include "Optic.h" #define MAX_ROBOTS 100 typedef struct Robots { Arm arms[MAX_ROBOTS]; Leg legs[MAX_ROBOTS]; Optic optics[MAX_ROBOTS]; } Robots; Robots * Robots_handle(void); `Robots.c`: #include "Robots.h" static Robots robots; Robots * Robots_handle(void) { /* Maybe do some init stuff, or maybe delegate that to another function */ return &amp;robots; } Advantages: - Controls access to the robots handle, disallowing access to it before it's properly initialized (unlike the `_init()` function above) Disadvantages - Still just a global mutable variable, only it's a little hidden - Introduces the mistake where someone assumes the `Robots_handle()` function gives out different objects (a constructor) rather than a singleton object # Dynamic memory allocation You say you want to avoid dynamic memory allocation "by any means possible." I'll echo /u/myrrlyn and challenge that stance. There are strong reasons to avoid dynamic allocation. In my experience, these are twofold: - Avoidance of memory fragmentation - Predictability and long-term stability These are primarily problems with extremely resource-constrained systems (I'm talking embedded systems with less than 1 MB of RAM) which have to operate, stably, for years at a time, or have to have extremely provable and deterministic behavior. In this case, it's important to have a well-understood memory footprint, and avoid fragmentation effects which can cause the system to "run out" of memory even though its total allocation is lower than what's available. However, in a modern system with many GB of RAM, fragmentation is unlikely to present a problem. This is further helped by the fact that large allocations don't necessarily have to be contiguous in physical memory in a system which uses virtual addressing and paging. And a modern OS will reclaim a processes memory on its termination, and manage your systems memory overall, which makes it hard to see a complete system failure due to over-allocation. Instead, you tend to see a degradation in performance as pages need to be swapped to disk more frequently. I can't speak to your specific situation, but what I *can* say in general is that you should default to using dynamic memory allocation unless there are strong reasons to avoid it. In this particular case, for instance, your tradeoff for not using dynamic allocation is being forced to use some sort of global, mutable variable. I'd be hard-pressed to justify that kind of compromise for a userspace program on a modern OS. # Data layout This is less critical than the above, but I'll again echo /u/myrrlyn's point about your data organization. A struct with "parallel" arrays is going to be more difficult to use correctly, to reuse, and to reason about than an array of individual structs. ## Readability Code is read more than it's written. The corollary to that is that you should spend effort to make your code understandable -- even if only for the sake of your future self. If I come across a line of code which says Arm_wave(robots-&gt;arms[3]) my first impression will be that this means "wave the robot's third arm". The plurality of the variable name notwithstanding, I'd have to consult the `Robots` type, and read its documentation carefully, to understand what's going on. Conversely, when reading Arm_wave(robots[3]-&gt;arm) it's immediately apparent that what's being indexed is the *robot*, not the robot's *arms*. ## Composability Your link to the Entity Systems Wiki talks about the advantages of composition over inheritance. I wholeheartedly agree with this reasoning. But by declaring a `Robots` type which is always an array of 100 robots, you're actually *hurting* composability. Let's approach this from the other side, and say that we want to declare a `Platoon` of robots, which has a captain and some peons. With your definition above, this is actually quite hard to do -- there's no singleton `Robot` type to build from. But if you instead declare a your set of robots as typedef struct Robot { Arm arm; Leg leg; Optic optic; } Robot; Robot robots[MAX_ROBOTS]; /* or some other static declaration, perhaps */ you've built your array of robots, but also created a usable type which can be used to declare typedef struct Platoon { Robot captain; unsigned int peon_count; Robot peons[MAX_PEONS]; } Platoon; You'll also have presumably built some functions on top of the `Robot` type (`Robot_run()`, `Robot_do_damage()`, `Robot_kill_all_humans()`, etc) which can be re-used on the members of this new composite type, whereas functions which must take a `Robots` struct which describes exactly `MAX_ROBOTS` robots won't be as usable. On the other hand, you might be performing some operations which make the most logical sense to perform on an array of all the `Robots`' `arms` at once -- I understand that your current situation probably doesn't line up perfectly with the example you presented above. In this situation, I would re-factor my function on an array of `Arm`s to be a function on an array of `Robot`s, using each robot's `arm` field. # And so... I hope I'm not coming across as too preachy -- I think the main thing to keep in mind is that there's *always* a tradeoff. 
Would you mind showing your own language? I am quite interested
https://myrlang.org
Not at all. This is greatly appreciated. Thank you very much. I think the bottom line of it all seems to be "use dynamic memory allocation to avoid exploding the stack". Now that I see, my Robot example was terrible. What I mean by that arrangement is that some robots might have some of those components, but not all of that. In any case, if anyone got more curious about what I was trying to exemplify, the first 15 minutes of the videos below might be helpful: https://www.youtube.com/watch?v=NTWSeQtHZ9M https://www.youtube.com/watch?v=3N1pLtTV2Uc
https://commandcenter.blogspot.se/2012/04/byte-order-fallacy.html
&gt;Nothing is preventing you from using getters and setters to encapsulate your fields. The whole point of a setter is that it allows you to have instance variables that are private, package-private, protected, or some such. C has no notion of such guarded access (though some folks have approximated it with internal linkage with varying levels of complexity), so the most straightforward solution here would be only encapsulation by agreement, given that the `test-&gt;x` and `test-&gt;y` accesses would still be possible. Of course, C has no notion of implicit this/self either, which is why your 'method' calls end up looking like a weird cross between instance methods and static methods: test-&gt;printThis(test); And there's a subtle academic problem here (which I don't think the C committee has ever bothered to clarify): implMethod(double, length) { return sqrt(pow(this-&gt;x, 2) + pow(this-&gt;y, 2)); } pow() can have a macro implementation (7.1.4#1). Such a macro implementation might not contain the sequence points that a corresponding function would contain (7.1.4, fn 186). pow() has associated range, domain, and pole errors (7.12.7.4#2). These errors may entail modification of errno (7.12.1). Thus, the expression pow(...) + pow(...) may entail modification of errno twice between sequence points, which is undefined behavior (6.5#2 -- though the C99 text is probably easier to understand than the C11 text).
That is C++ not C. Also, take a look at that post. The formatting is horrible... you want to put 4 spaces before every line to format it properly I think.... #include &lt;stdio.h&gt; // hello world int main(int argc, char *argv[]) { printf("formatting example\n"); return 0; }
my bad ill switch to a different thread.
I suggest trying your newly acquired skills in some application. There are many ways: 1. Try contributing to an open source project. It's a bit hard to get started because you will have to understand their version control system, how they merge new code and so on. But it's a really good practice for the kind of programming that's done in industry. In real world, you rarely write programs from scratch, you modify and extend someone else's code. Furthermore, when you submit your code for review, you will learn a lot from project reviewers who will critique your code. 2. Try approaching a subject or topic that involves heavy use of C programming. I suggest operating systems, compilers or maybe computer graphics. Try reading best books in these topics and you will surely run into concepts that involve C programming. Also, try to implement the concepts you read. By the end of it, not only would you improve your C programming skills, you would learn a new area as well.
For C in particular, I find it very hard to find open source projects that are in active development. There's not a lot of projects that are being started in C and of the established C projects out there, most are quite mature and any work tends to be maintenance not terribly suited for new contributors. Are there any projects you'd recommend? I suppose the Linux kernel is one but it probably has the highest barrier to entry possible!
Hello! Well I have a very good Idea :) Why don't we open a project on github so that we can spend some time on creating a respectful big project (as the saying goes : 1+1 != 2 but 1+1 = 3 :) synergy yay :P ) Abt me: I am a 2nd year undergraduate student in information tech. And we have a subj : data structures and algorithm. Apparently everyone in my college doesn't care about serious coding (those who care are involved in other uber activities.) so i am quite alone on my journey to becoming a good programer and also improve my skills for collaboration! Maybe somehow you would be able. To join me :) Oh even i know only C language and a bit of matlab. 
Great idea! Well-documented application is a great way to learn. Maybe start a discord?
What's Electron?
Definitely.. What kind of project are we looking at?
I guess you can try FreeBSD, PostgreSQL or MySQL projects. You can also try Redis. They are very active. Do note that when you get started, you will probably start with a small enhancement or bug fix. As you get more and more experienced with the project, you can start tackling projects of increasing complexity.
&gt;Once I mastered the basics, I had to implement several algorithms in college. &gt; &gt;&gt;&gt;Can you give us a few examples of algorithms. I am familiar with basic search and sort like bubble, selection,binary etc. Is there more to it than searching and sorting?? 
If you can go through K&amp;R and do 90-100% of the exercises by yourself, then you know the basics.
You've mentioned yourself that access modifiers only can be done through some hacky workarounds. My project is still far from finished, thus I might come up with something in the future. The method calls are similar to Python, where passing a self-instance as an argument is required too. Might be able to use macros instead, but that would look even less elegant. While the pow-implemention might differ, the included vector class was never intended for serious usage (as was the whole project).
I was under the impression that k&amp;r is outdated in terms of actual style of programming or is it still relevant?
&gt; The method calls are similar to Python, where passing a self-instance as an argument is required too. Python methods are defined with a first-param self-instance (contra, say, Java, which has no such first-param this-instance), but that self-instance is passed implicitly -- you don't pass it as an argument: &gt;&gt;&gt; class SchlongClass: ... def schlong(self, v): ... print(v) ... &gt;&gt;&gt; i = SchlongClass() &gt;&gt;&gt; i.schlong(42) 42
It doesn't teach you "a style of programming." It gives you a good understanding of C. Calling K&amp;R outdated would be the same as calling C outdated. C hasn't changed for years now (C89 and C99 are still the most popular standards).
As you've stated, most "flaws" in my current design are simply because of limitations of C.
That depends on our level, doesn't it? So um what about making a simple product database using curses.h? Forgive me for sounding so basic but this is a basic program.. Which will make us learn the curses header file.. :) Any other ideas are welcome. 
I'm not a serious gamer so i don't have discord installed.. I was thinking of kik, discord would Do too :) correct me if I'm wrong, don't we need to start a server dedicated to it to use discord? 
Hi /u/roecrew ! Nymph looks like a cool project :) Would it be possible to have documentation on how Nymph compiler works, what are the features available and how to use them ?
Debian's (DEB) is brilliant. I use apt-file to find which packages have the header I'm after. Where the header is the lib is too. A *-dev package normally. Plus it will install all dependencies it needs to. Plus being popular in itself, and the root of other popular distros, it has most things. I use if it's in Debian or not as a mark of quality even when not targetting Debian.
I've made some progress to the point where CLion now recognises the includes and types but I'm getting compilation errors when I try to build a simple program. Here's my CMAKE, do I need to also include some lib folders? cmake_minimum_required(VERSION 3.6) project(Learning) set(CMAKE_CXX_FLAGS "${CMAKE_C_FLAGS}") set(GRAPHVIZ_INCLUDE_DIR "C:\\Program Files (x86)\\Graphviz2.38\\include\\graphviz") set(SOURCE_FILES main.c) include_directories("${GRAPHVIZ_INCLUDE_DIR}") add_executable(Learning ${SOURCE_FILES}) Program #include &lt;gvc.h&gt; #include &lt;cgraph.h&gt; int main() { Agraph_t *graph; Agnode_t *nodeA, *nodeB; Agedge_t *edge1; Agsym_t *symbol1; GVC_t *gvc; gvc = gvContext(); graph = agopen( "graph", Agdirected, NULL); nodeA = agnode(graph, "nodeA", 1); nodeB = agnode(graph, "nodeB", 1); edge1 = agedge(graph, nodeA, nodeB, 0, 1); agsafeset(nodeA, "color", "red", ""); gvLayoutJobs(gvc, graph); gvRenderJobs(gvc, graph); gvFreeLayout(gvc, graph); } Compilation errors - "C:\Program Files\JetBrains\CLion 2017.2.1\bin\cmake\bin\cmake.exe" --build E:\Development\C\Learning\cmake-build-debug --target Learning -- -j 2 [ 50%] Linking C executable Learning.exe CMakeFiles\Learning.dir/objects.a(main.c.obj): In function `main': E:/Development/C/Learning/main.c:38: undefined reference to `gvContext' E:/Development/C/Learning/main.c:39: undefined reference to `_imp__Agdirected' E:/Development/C/Learning/main.c:39: undefined reference to `agopen' E:/Development/C/Learning/main.c:40: undefined reference to `agnode' E:/Development/C/Learning/main.c:41: undefined reference to `agnode' E:/Development/C/Learning/main.c:42: undefined reference to `agedge' E:/Development/C/Learning/main.c:44: undefined reference to `agsafeset' E:/Development/C/Learning/main.c:45: undefined reference to `gvLayoutJobs' E:/Development/C/Learning/main.c:46: undefined reference to `gvRenderJobs' E:/Development/C/Learning/main.c:47: undefined reference to `gvFreeLayout' collect2.exe: error: ld returned 1 exit status CMakeFiles\Learning.dir\build.make:96: recipe for target 'Learning.exe' failed mingw32-make.exe[3]: *** [Learning.exe] Error 1 CMakeFiles\Makefile2:66: recipe for target 'CMakeFiles/Learning.dir/all' failed mingw32-make.exe[2]: *** [CMakeFiles/Learning.dir/all] Error 2 mingw32-make.exe[1]: *** [CMakeFiles/Learning.dir/rule] Error 2 CMakeFiles\Makefile2:78: recipe for target 'CMakeFiles/Learning.dir/rule' failed Makefile:117: recipe for target 'Learning' failed mingw32-make.exe: *** [Learning] Error 2 
&gt; The question is at best incomplete and your answer is completely wrong. Nope &gt; You are confusing sections with segments and you're behaving the way C++ ***** usually behave code section or code segment or text section or test segment are same in this context unless your want to quibble (like C++ ***** like) simple googling gives you the result: https://stackoverflow.com/questions/2589949/string-literals-where-do-they-go &gt; Where do they go? &gt; the same segment where the .text section of the object file gets dumped, which has Read and Exec permissions, but not Write now code section or code segment or text section or test segment is always loaded into NPP for kernel so if u have a giant ass code section or code segment or text section or test segment it's completely valid to question that maybe you'll can issues. But go ahead c++ pleb continue ******** your ******* like your kind always does. edit: https://stackoverflow.com/questions/2589949/string-literals-where-do-they-go Even in this link people call it text/code segment/section freely and nobody is there coming and fingering the commentators in the *** while saying they're wrong and they are confusing things and they should use c++ freaking C++ ppl should just ***
I've only heard of biicode but never tried ir.
nope CS memory is always pinned in memory for kernel and for usermode I think it's more likely that cs will not be paged out as I remember reading a code which makes this distinction 
&gt; the advantages of easier to maintain code greatly outweighs all of your complaints it's more difficult to read thus not maintainable and thus your statement is wrong &gt; the reason 90% of development has moved off of c and onto languages such as c++/java/c# the only reason it moved off is because of social engineering &gt; fellow in the link doesn't give any evidence on why c++ is poor google him, watch his videos and you'll find out he gives lots of evidence &gt; don't believe anyone who holds opinions this emotional should be referenced in any context. yeah right. C++ ppl who **** - *** to the syntactic sugar are pragmatic and the guy in link isn't
What compilation errors do you get? Note that on reddit, you need to put four blanks in front of every line of code for the code to be formatted correctly. The three-backticks syntax from github is not available.
Typically your distribution provides package management for libraries and programs, including those implemented in C. I recommend you to not use any other package management, that's just a lot of trouble when other people try to compile your program and the library versions in the package management you use and the system's package management differ.
Thanks I've edited the original comment
You need to tell CMake that you want to link against the `libcgraph` so the compiler considers it when searching for symbols. Try something like link_directories(directory/with/libcgraph/in/it) and then target_link_libraries(Learning -lcgraph) Note that the `link_directories` directive receives the path to the directory with `libcgraph` in it, not the path to the file `libcgraph.dll` or whatever it is called.
Thanks for your answer :) I do agree that I really like Debian package manager. I don't want to start a flow war on whether X package manager is better than Y but I have some question about how you handle things with DPM: - How do you manage dependencies that are project specific, or when you don't want a library to be available system-wide ? - How do you access the latest version of a library since pushing/updating a package on Debian does not seems to be a trivial thing and most library maintainers dot not provide a .deb file ?
Thanks for your answer ! Biicode website seems down but I added to the main post list :)
Hi /u/FUZxxl ! Thanks for your answer too ! I asked some question about using a distribution package manager [just here](https://www.reddit.com/r/C_Programming/comments/6uv091/any_good_c_package_manager/dlvl6s5/), where we can continue the discussion.
As of writing the first comment I've checked the website and it seemed up -- otherwise just head over to their GitHub!
&gt; How do you manage dependencies that are project specific, or when you don't want a library to be available system-wide ? Then you put the library into your project and compile and link it as a part of your projects build cycle. &gt; How do you access the latest version of a library since pushing/updating a package on Debian does not seems to be a trivial thing and most library maintainers dot not provide a .deb file ? You don't. Debian has a carefully tuned update schedule to ensure that all libraries are reasonably stable and well-tested. If you really need a new version, you can always take the corresponding package from Debian unstable or Debian testing. Lastly, you can of course always compile your own copy of the library and install it into your home directory in case Debian does not have a sufficiently new version.
I'm getting the following even if I change to cgraph.lib and gvc.lib e:/mingw/bin/../lib/gcc/mingw32/5.3.0/../../../../mingw32/bin/ld.exe: cannot find -lcgraph e:/mingw/bin/../lib/gcc/mingw32/5.3.0/../../../../mingw32/bin/ld.exe: cannot find -lgvc I managed to get it to compile by altering my cmakelists.txt as follows but I get "Process finished with exit code -1073741515 (0xC0000135)" when I try to run or debug the program, even after adding graphviz/release/lib/dll to my windows path cmake_minimum_required(VERSION 3.6) project(Learning) set(CMAKE_CXX_FLAGS "${CMAKE_C_FLAGS}") set(GRAPHVIZ_INCLUDE_DIR "C:/Program Files (x86)/Graphviz2.38/include/graphviz") set(GRAPHVIZ_LIB_DIR "C:/Program Files (x86)/Graphviz2.38/lib/release/lib") set(SOURCE_FILES main.c) include_directories("${GRAPHVIZ_INCLUDE_DIR}") add_executable(Learning ${SOURCE_FILES}) target_link_libraries( Learning "${GRAPHVIZ_LIB_DIR}/cgraph.lib" "${GRAPHVIZ_LIB_DIR}/gvc.lib" ) 
I don't see any `link_directories` directive. Why did you leave it out? Also, it's supposed to be target_link_libraries(Learning cgraph gvc) as CMake automatically takes care of the file extension in a portable mannerif any.
I'll be adding documentation over the next couple days. And thanks! :)
Here's the output I get when I follow your suggested approach. Maybe I should be going to the dll instead of lib directory? I really appreciate your help here I realize this is probably frustrating for you. cmake_minimum_required(VERSION 3.6) project(Learning) set(CMAKE_CXX_FLAGS "${CMAKE_C_FLAGS}") set(GRAPHVIZ_INCLUDE_DIR "C:/Program Files x86)/Graphviz2.38/include/graphviz") set(GRAPHVIZ_LIB_DIR "C:/Program Files x86)/Graphviz2.38/lib/release/lib") set(SOURCE_FILES main.c) include_directories("${GRAPHVIZ_INCLUDE_DIR}") add_executable(Learning ${SOURCE_FILES}) link_directories("C:/Program Files (x86)/Graphviz2.38/lib/release/lib") target_link_libraries( Learning cgraph gvc ) When I try to run I get these linking errors - "C:\Program Files\JetBrains\CLion 2017.2.1\bin\cmake\bin\cmake.exe" --build E:\Development\C\Learning\cmake-build-debug --target Learning -- -j 2 [ 50%] Linking C executable Learning.exe e:/mingw/bin/../lib/gcc/mingw32/5.3.0/../../../../mingw32/bin/ld.exe: cannot find -lcgraph e:/mingw/bin/../lib/gcc/mingw32/5.3.0/../../../../mingw32/bin/ld.exe: cannot find -lgvc collect2.exe: error: ld returned 1 exit status mingw32-make.exe[3]: *** [Learning.exe] Error 1 CMakeFiles\Learning.dir\build.make:96: recipe for target 'Learning.exe' failed CMakeFiles\Makefile2:66: recipe for target 'CMakeFiles/Learning.dir/all' failed mingw32-make.exe[2]: *** [CMakeFiles/Learning.dir/all] Error 2 mingw32-make.exe[1]: *** [CMakeFiles/Learning.dir/rule] Error 2 CMakeFiles\Makefile2:78: recipe for target 'CMakeFiles/Learning.dir/rule' failed mingw32-make.exe: *** [Learning] Error 2 Makefile:117: recipe for target 'Learning' failed mingw is set as my toolchain in CLion, do I need to do anything special to show mingw where these libraries are or should that be covered by the cmakelists?
I'm searching one my self. I work with a proprietary system that doesn't have a pkg mgr for their projects and can't be public available (must be self hosted). And must be available for Windows (but we do cross-compiling). The only answer I have is to build my own with CMake :/
Very strange. What files are in the `C:/Program Files (x86)/Graphviz2.38/lib/release/lib` directory? Please try building with `cmake VERBOSE=1 --build` so I can see what comments cmake tries to execute.
 "C:\Program Files\JetBrains\CLion 2017.2.1\bin\cmake\bin\cmake.exe" --build E:\Development\C\Learning\cmake-build-debug --target Learning -- -j 2 "C:\Program Files\JetBrains\CLion 2017.2.1\bin\cmake\bin\cmake.exe" -HE:\Development\C\Learning -BE:\Development\C\Learning\cmake-build-debug --check-build-system CMakeFiles\Makefile.cmake 0 E:/MinGW/bin/mingw32-make.exe -f CMakeFiles\Makefile2 Learning mingw32-make.exe[1]: Entering directory 'E:/Development/C/Learning/cmake-build-debug' "C:\Program Files\JetBrains\CLion 2017.2.1\bin\cmake\bin\cmake.exe" -HE:\Development\C\Learning -BE:\Development\C\Learning\cmake-build-debug --check-build-system CMakeFiles\Makefile.cmake 0 "C:\Program Files\JetBrains\CLion 2017.2.1\bin\cmake\bin\cmake.exe" -E cmake_progress_start E:\Development\C\Learning\cmake-build-debug\CMakeFiles 2 E:/MinGW/bin/mingw32-make.exe -f CMakeFiles\Makefile2 CMakeFiles/Learning.dir/all mingw32-make.exe[2]: Entering directory 'E:/Development/C/Learning/cmake-build-debug' E:/MinGW/bin/mingw32-make.exe -f CMakeFiles\Learning.dir\build.make CMakeFiles/Learning.dir/depend mingw32-make.exe[3]: Entering directory 'E:/Development/C/Learning/cmake-build-debug' "C:\Program Files\JetBrains\CLion 2017.2.1\bin\cmake\bin\cmake.exe" -E cmake_depends "MinGW Makefiles" E:\Development\C\Learning E:\Development\C\Learning E:\Development\C\Learning\cmake-build-debug E:\Development\C\Learning\cmake-build-debug E:\Development\C\Learning\cmake-build- debug\CMakeFiles\Learning.dir\DependInfo.cmake --color= mingw32-make.exe[3]: Leaving directory 'E:/Development/C/Learning/cmake-build-debug' E:/MinGW/bin/mingw32-make.exe -f CMakeFiles\Learning.dir\build.make CMakeFiles/Learning.dir/build mingw32-make.exe[3]: Entering directory 'E:/Development/C/Learning/cmake-build-debug' [ 50%] Linking C executable Learning.exe "C:\Program Files\JetBrains\CLion 2017.2.1\bin\cmake\bin\cmake.exe" -E cmake_link_script CMakeFiles\Learning.dir\link.txt --verbose=1 "C:\Program Files\JetBrains\CLion 2017.2.1\bin\cmake\bin\cmake.exe" -E remove -f CMakeFiles\Learning.dir/objects.a E:\MinGW\bin\ar.exe cr CMakeFiles\Learning.dir/objects.a @CMakeFiles\Learning.dir\objects1.rsp E:\MinGW\bin\gcc.exe -g -Wl,--whole-archive CMakeFiles\Learning.dir/objects.a -Wl,--no-whole-archive -o Learning.exe -Wl,--out-implib,libLearning.dll.a -Wl,--major-image- version,0,--minor-image-version,0 @CMakeFiles\Learning.dir\linklibs.rsp e:/mingw/bin/../lib/gcc/mingw32/5.3.0/../../../../mingw32/bin/ld.exe: cannot find -lcgraph e:/mingw/bin/../lib/gcc/mingw32/5.3.0/../../../../mingw32/bin/ld.exe: cannot find -lgvc collect2.exe: error: ld returned 1 exit status CMakeFiles\Learning.dir\build.make:99: recipe for target 'Learning.exe' failed mingw32-make.exe[3]: Leaving directory 'E:/Development/C/Learning/cmake-build-debug' mingw32-make.exe[3]: *** [Learning.exe] Error 1 CMakeFiles\Makefile2:69: recipe for target 'CMakeFiles/Learning.dir/all' failed mingw32-make.exe[2]: Leaving directory 'E:/Development/C/Learning/cmake-build-debug' CMakeFiles\Makefile2:81: recipe for target 'CMakeFiles/Learning.dir/rule' failed mingw32-make.exe[1]: Leaving directory 'E:/Development/C/Learning/cmake-build-debug' mingw32-make.exe[2]: *** [CMakeFiles/Learning.dir/all] Error 2 mingw32-make.exe[1]: *** [CMakeFiles/Learning.dir/rule] Error 2 Makefile:120: recipe for target 'Learning' failed mingw32-make.exe: *** [Learning] Error 2 Contents of lib folder - Pathplan.lib gvc.lib osage.lib ast.lib gvortho.lib patchwork.lib cdt.lib gvpack.lib rbtree.lib cgraph.lib gvplugin_core.lib sfdp.lib circogen.lib gvplugin_dot_layout.lib sfio.lib dot.lib gvplugin_gd.lib sparse.lib dotgen.lib gvplugin_gdiplus.lib topfish.lib dummyfile.txt gvplugin_neato_layout.lib twopigen.lib expr.lib gvplugin_pango.lib vmalloc.lib fdpgen.lib gvprlib.lib vpsc.lib gd.lib ingraphs.lib xdot.lib graph.lib minglelib.lib gts.lib neatogen.lib Contents of dll folder Pathplan.dll gvc.dll gvplugin_neato_layout.dll ann.dll gvplugin_core.dll gvplugin_pango.dll cdt.dll gvplugin_dot_layout.dll vmalloc.dll cgraph.dll gvplugin_gd.dll dummyfile.txt gvplugin_gdiplus.dll 
Very strange and seems that I don't understand CMake correctly (never used it in my own projects). Confer [this answer](https://stackoverflow.com/questions/31438916/cmake-cannot-find-library-using-link-directories). Perhaps someone else can resolve this issue because I'm all out of ideas.
Ok thanks a million for your help so far I do really appreciate you taking the time 
It's my pleasure.
I like it.
Yes. FWIW, the O’reilly book “21st Century C” covers this, plus a lot of other things. Highly recommended.
Line 67. You *print* successfully connected, but you never actually test that it did. After that, RS232_OpenComport doesn't return a handle; RS232_PollComport expects the port number.
The library actually tells me if there was an error, so...
There are a few popular OS's without (that kind of) package management
You can reopen the file for writing (mode `w` or `w+` or `wb` or something like that). This truncated the file: freopen(filename, "w", fp); Alternatively, you can use the function `ftruncate` from `unistd.h`: fflush(fp); rewind(fp); ftruncate(fileno(fp), 0); The `rewind()` and `fflush()` calls are important here.
so ... if you had checked then you would have found the bug
I checked a while ago. It can't open the serial port. I'm still looking for a solution.
Fixed in the latest commit. The library was poorly documented and didn't work as expected. Thanks!
Try moving the add_executable line to the end?
&gt; How do you manage dependencies that are project specific, or when you don't want a library to be available system-wide ? It's often not an issue, and I'm happy to have the whole system use the latest. I run Debian Testing with Apt-Pinning from Unstable and Experimental, so I'm normally pretty up to date. But I have had it when the build/run environment is older. I don't want to downgrade my home, just be compatible. So what I do is a I have a build/run chroot. There is a formal system for this, Buildroot, but I've always done it manually, taking their "build distro" (all too often ye-old-old-stable Debain) and trimming it and making it into a chroot so I don't have to live in the ancient place. I'm waiting for a project that requires me to use Buildroot, most of the time that is what they should have been using..... ;-) &gt; How do you access the latest version of a library since pushing/updating a package on Debian does not seems to be a trivial thing and most library maintainers dot not provide a .deb file ? With Testing/Unstable/Experimental, I'm normally close enough to the edge this is a non-issue. Also, as I said, Debian normally has anything good packaged for it. Even projects not in Debian, often have Debian package building in the source. Failing that, if it's cmake, it's easy to add. Failing that, there is [CheckInstall](https://wiki.debian.org/CheckInstall).
Well, people did that and [bad things happened.](https://en.wikipedia.org/wiki/Software_crisis). That's why many people moved on from imperative and procedural languages to OOP. While low-level access is indoubtely useful in kernel- and embedded programming, OOP's abstractions have make GUI programming a lot more natural. (i.e. a "button" should be a "button" object and not some tangled mess of pointers and functions.
Non-Mobile link: https://en.wikipedia.org/wiki/Software_crisis *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^103606
[this](https://beej.us/guide/bgnet/output/html/singlepage/bgnet.html) book goes into details, but I'm not sure how far you're willing to go.
I'm willing to go the whole 9 yards. Thank.
W. Richard Stevens' Unix Network Programming and TCP/IP Illustrated.
It's a framework for building desktop apps with web languages and APIs. In reality it's Chromium, Node.js, and some boilerplate code packed into an executable that runs a web-app in the same directory as it.
The target_link_libraries needs to come after add_executable unfortunately
Compiling their "hello world" didn't work when I tried it.
Beej's is just a guide to sockets in C, a great one that is but it's just about sockets. I would recommend that you get yourself [Wireshark](https://www.wireshark.org/) a network analysis tool and poke around, check a couple tutorials and just observe packets go to and from your computer as you do stuff. You can see each bytes as they cross your NIC and try to make sense of it. Let your curiosity lead your research. Then read on how tcp/ip/udp/icmp/dns/http work and how they relate to each other. You don't have to know every minute details of the each protocol to understand how they work. Then try to write a C program that builds packets one byte at the time (Not relying on the socket interface to do the packet building) and try to make an effect in the world. For instance, make a tiny program that forges a dns request packet to google dns server 8.8.8.8 and watch for the reply in Wireshark.
The problem with Beej's is that it's too chatty and sometimes silly. Mostly easy to understand but I wish he would cut out all the goofy parts.
THE authoritative source.
If you want to go the whole 9 yards, get the Stevens' book mentioned by /u/raevnos. 
Thanks! I used the second one, because the filename is unknown
You should ask a native English speaker to proofread this for you; the text is riddled with errors. The material itself also looks to be of poor quality. I haven't read the whole thing, but in your section on "string basics," you make the very common beginner mistake of confusing pointers and arrays: &gt; The most important point to understand is that a string literal is a pointer to the first character of the array. In other words `"Hello World"` is a pointer to the character `'H'`. Since `"Hello World"` points to the address of character 'H' , it's base type is a pointer to char or (`char *`). It means that if we have a pointer variable of type pointer to char or (char*) we can assign the string literal to it as: &gt; &gt; char *str = "Hello World"; This is false. The type of `"Hello World"` is actually `char[12]`, which you can easily see by compiling and running the following program: #include &lt;stdio.h&gt; int main() { char *s = "Hello World"; printf("Size of string literal = %zu\n", sizeof "Hello World"); printf("Size of pointer = %zu\n", sizeof s); return 0; } The reason you are allowed to assign a string literal to a pointer variable, and pass a string literal to a function that expects a `char *`, is that an array can be _implicitly converted_ to a pointer to its first element. If you don't know this, or don't understand it well enough to explain it to others, then you are not qualified to teach C.
Bookmarked :)
The guy who made this test suite did amazing job. I remember his article about pitfalls of JSON parsing and I expect Jsong to pass most (if not all) of his tests. That said, I'm currently working on JSON replacement (as a whole) and implementing new file format constructs on top of Jsong. I mean -- replacement or not -- I can't bring myself to just delete these ideas. The new data interchange format is going to be very similar to JSON, but more powerful, easier to use, and with less ambiguities (I hope). I intend to publish and announce it here shortly, as a follow-up to Jsong. Once I'm done with it, I will attempt to integrate Jsong into his test harness and submit a pull request to that GitHub repo you mentioned. By the way, good job on pdjson! Looking forward to make sure Jsong passes all the tests just as well as your project.
Might theoretically need an `fflush(fp)` after `rewind` to make sure everything syncs up with the underlying FD.
`rewind()` does a flush by specification.
What is good about it? Last time I checked (re-checked just now) it is *barely* even a tokenizer: strings are not unescaped (escape sequence are left as is), Unicode surrogate pairs are not processed and thus invalid surrogate pairs are not detected, numbers are parsed just as strings, various invalid input is deliberately accepted (which its author boasts as a feature). Writer (serializer) is absent. The API is neither SAX, nor DOM, but some token array which you need to "parse" again just to make sense of it. 90% of JSON parsing is about correct string and number parsing. *Especially* number parsing: maintaining precision, checking for range errors, using fastest numeric type for the parsed number. You can't just throw it into `strtod` or `strtoimax` and expect results to be any acceptable. It's easy to claim world's fastest and smallest when you do nothing.
Yeah, but it's as easy as a click of a button. Plus it'll allow multiple people to join and talk (or text), with different channels dedicated for different things. I'm fine with kik though if you're more comfortable 
I think both answers are wrong. Both values are below 0x80 (not negative in twos complement). You are right. 
Jsong has to support many parsing scenarios and extensive usage of preprocessor to handle them all and (numerous) related corner cases is unavoidable. Having everything in one huge parsing function allows full control over parsing state, unlike (inline) functions, which limit your scope, and you end up writing *more* boilerplate code just to handle their return values. I do realize it gets rather out of control sometimes, but it's a matter of better code organization and refactoring to fix it. P.s. Didn't down vote you.
Not so fast... would be great if OP posted the code from page 94. To me this looks like a series of shifts on 8-bit signed values, so the answers could well be correct...
Seems like the answer key is wrong.
https://en.wikipedia.org/wiki/Arithmetic_shift#Non-equivalence_of_arithmetic_right_shift_and_division
**Arithmetic shift: Non-equivalence of arithmetic right shift and division** However, arithmetic right shifts are major traps for the unwary, specifically in treating rounding of negative integers. For example, in the usual two's complement representation of negative integers, −1 is represented as all 1's. For an 8-bit signed integer this is 1111 1111. An arithmetic right-shift by 1 (or 2, 3, …, 7) yields 1111 1111 again, which is still −1. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.26
You did not actually help OP. OP seems to know what they're talking about, and it looks like there's an error in the answer key to their book.
It flushes before seeking, but I can’t tell from `man 3posix` if it necessarily leaves the FD’s offset in a well-defined state—e.g., it might leave a file seek for the next read/write operation and fold into some variant of `pread`/`pwrite` syscalls or something. This is what raised the question in my mind (for `fseek`, since `rewind` is defined as that`(0, SEEK_SET)` + error clear): &gt; If the most recent operation, other than `ftell()`, on a given stream is `fflush()`, the file offset in the underlying open file description shall be adjusted to reflect the location specified by `fseek()`. Seeing it predicated like that tweaked my neurosis for by-the-standardsness. :)
Right-shifts on negative values are what, implementation-defined? —I think it’s not full-blown UB. So it would still be iffy.
Indeed, `fflush()` might be necessary in this case.
Such a good resource. 
Here's the practice problem statement: http://imgur.com/m7VGGlC 
Assuming `a &gt;&gt; 3` is meant to read `x &gt;&gt; 3`, those circled examples should have been filled with `0`. Note that shifts in C programming don't correspond exactly to that table. Firstly all shifts are done in `int` precision or higher, the source value is converted to `int` if it was a narrower type. `int` is at least 16-bit in all cases. Secondly, right-shifting of negative numbers is *implementation-defined* which means the compiler may decide to do Arithmetic Shift, or Logical Shift, or even something else entirely. This is so that the compiler can implement the shift as an assembly instruction, but different CPUs have historically had different behaviours for such shifts. *Usually* CPUs operate on negative numbers by means of 2's complement representation, with shifts of signed integers being Arithmetic Shift. 
Discord it is! I would like to try something new. So..um... What do we do next :P I have a simple plan: open new github repo, send the link to you, use discord to decide what do we do as a project. .... I'll setup discord and lets wait for OP to join in :) Any Instructions for discord?
Actually I already set up a discord channel called C_Programming, unless you'd want to host it it's free to join
Great project. Is there some funcionality to call JavaScript or JavaScript callbacks?
Other people tried to explain with code, but just to be clear: the order of the bytes *in the file* matters: you must know if the file is little endian or big endian. But if you know byte order the file uses, then you can use the exact same C code to read and write the file regardless of whether the CPU running the code is little endian or big endian -- as long as you write the code in an endian-agnostic way (which is the code people have been posting here, with shifts and ORs). What /u/FUZxxl tried to explain [here](https://www.reddit.com/r/C_Programming/comments/6ukfbu/makefile_is_there_any_way_to_extract_the_target/dlte4zb/) is that if the compiler is smart enough, and the endiannes of the file matches the endiannes of the CPU you're running on, then the compiler will generate code exactly as if you had read the bytes from the file directly into the memory of your number, with no shifts or ORs. He noted that gcc is smart enough since version 5.0. 
i got it. thanks
You're absolutely correct that they're implementation-defined in C (and I realize this is a C-language sub-reddit) but not in some other languages, e.g., Java (or various assemblers). That's why I asked the OP to share the original problem statement before jumping into any conclusions. Looking at page 94 I think it's pretty clear ("In contrast to C, Java has a precise definition...") that this isn't a C-specific trick question...
Sure I'll join right away
Could you send me the invite link for that server?
That would be really cool. I thought of using websockets/xhr for communication with the core part of the app, but direct JS calls would be also a very good option. I can imagine doing that with Webkit (gtk-webkit, cocoa-webkit), but I'm a complete idiot when it comes to MSHTML, so I can't promise much. Feel free to open an issue or submit a pull request if you figure out how to make it work.
The way I read it is that they explicitly ask for an arithmetic shift (in the header of the column). Thanks to others for pointing out that shifting right on negative numbers is ub. I should have remembered after doing c for 20 years 🤔
sockets are a mess imo a very bad team of developers envisioned them and nobody actually uses them as the creator envisioned 99% of work while using sockets is making epoll or iocompletionports work 
&gt; Buckaroo why is that word so funny?
Can you explain to the uninformed what is a "webview library" in general? Does it make it easier to churn out javascript, HTML and CSS from C code which will be consumed by browsers like google chrome and firefox?
&gt; - How do you manage dependencies that are project specific, or when you don't want a library to be available system-wide ? - How do you access the latest version of a library since pushing/updating a package on Debian does not seems to be a trivial thing and most library maintainers dot not provide a .deb file ? With pretty much every language I use that doesn't include a PM (or package is behind the upstream), I use submodules. For über common/stable stuff, I really on the system PM. All my projects that I have actually released either rely on pkgconfig or custom (included with the build script) logic to locate packages (usually cmake modules). D is a systems level language (e.g. optional runtime with no nonstandard dependencies, ability to perform unsafe or undefined operations if the need arises, and available SYSV linkage) that has a very commonly used package manager, dub, which supports project-scope and user-scope dependencies. It also functions as a build system, so you can provide minimal configuration and let it do the rest. For C, the only options which come to mind cget and hunter. Both of these are, AFAIK CMake plugins.
Oh I definitely agree, need to make the best of the very limited tools C provides. It was a silly joke; your code is very clean!
Say you want to write a cross-platform GUI app. You have your core app logic written in C. Drop in a small embeddable web server (using Mongoose or any other C/C++ web framework) and provide some HTTP or WebSocket API to your app functionality. Now write some HTML layout, prettify it with CSS and drop in some JS to listen to the button clicks etc. Send data to the websocket as the UI is interacted, and update the UI as you receive new data from the websocket (or HTTP API, doesn't matter). This allows you to have a nicely decoupled UI and clean, testable data flow. As a result you get a portable small/fast app with some modern looking UI. The only complex part of adding a webserver may be terrifying for C developers. I only mentioned it because I personally would be using Go for that (this library supports both, C and Go). If at some point I manage to bind UI to the core using javascript (as an alternative to websocket/HTTP API) - then it may become easier for C developers to use.
Oh ok, thanks!
Please don't spam.
Pardon me? What are you talking about?
Your post. It is spam. It is not about programming in C and it advertises both free and paid courses while having an unhealthy amount of advertisement. That makes it spam. I'm pretty sure the subscribers of this subreddit don't want to look at spam, so I removed this post.
Yes, sorry I didn't make this clear. They are definitely asking these questions in the C programming language
Oh, I scanned for keywords before the problem statement was posted—assumed it was C on accounta being in C_Programming. But even in Java it’d have to be sign-extended to an `int` before shifting would sign-fill, something like `(byte)0x80 &gt;&gt; X`. Just `0x80` or `0xD4` or whatever alone would be a 32-bit value with 24 leading zero bits. Meh @ this text.
Alright than don't leave me hanging. What's an alternative than ?
&gt;&gt; You are confusing sections with segments &gt; and you're behaving the way C++ ***** usually behave I am not a C++ anything. I have 25 years of experience with C and 20 years of experience with operating system design and development. The odds are better than even that both the computer you used to post this abusive rant and the computers which reddit use to store and serve it run code that I have written. (Yes, I've been writing C++ on and off for almost as long as I've been writing C, but I vastly prefer the latter.) &gt; code section or code segment or text section or test segment are same in this context Absolutely not. Segments are a feature of *some* computer architectures, most prominently the Intel 8086 and 80386 (but *not* their 64-bit descendants), used to organize and access code and data in memory. Sections are a feature of *most* executable file formats (such as ELF and COFF) used on modern non-embedded platforms. The OS and / or the run-time linker read code and data from sections in the executable file and store them *somewhere* in memory. &gt; simple googling gives you the result: https://stackoverflow.com/questions/2589949/string-literals-where-do-they-go Stack Overflow is not a reliable source of *correct* information (see for instance [this article](https://hackernoon.com/the-decline-of-stack-overflow-7cb69faa575d) or [this one](https://www.embeddedrelated.com/showarticle/741.php) about how SO's karma system encourages a race to the bottom). I would suggest reading [Tanenbaum](https://www.amazon.com/dp/013359162X) or [McKusick et al.](https://www.amazon.com/dp/0321968972) instead. This specific answer is correct only in the sense that the literals are included in the same file as the code. Setting aside embedded platforms and their idiosyncrasies, they are stored in different sections of the file and loaded into different memory locations at run-time. &gt; Where do they go? the same segment where the .text section of the object file gets dumped, which has Read and Exec permissions, but not Write Your information is 20 to 30 years out of date. No modern OS uses segments the way Intel envisioned when they designed the 8086 or the 80386. The former needed segments to escape pointer size limitations when the address bus outgrew the registers, and the latter retained them for backward compatibility and added memory protection features on a per-segment basis. However, modern OSes for the 80386 and its descendants implement memory protection at the page table level rather than at the segment level and use segment registers purely as conveniences for array operations, which is why they were left out when the 80386 architecture was expanded to 64 bits. &gt; But go ahead c++ pleb continue ******** your ******* like your kind always does. I understand that it can be hard to admit that you are wrong, but that's not a reason to resort to that kind of language. 
Shifting signed ints right is implementation defined, not ub. Important difference :-) Shifting signed ints left is ub.
A nit: the result of `sizeof` is a `size_t` and should be printed using `%zu`, not `%d`.
&gt; I'm currently working on JSON replacement There are several already, I would recommend taking a look at [libucl](https://github.com/vstakhov/libucl) before spending too much time reinventing the wheel for the 17th time.
 * Advanced C is a misnomer. The language is quite small, the standard library is not baroque and its evolution has not been drastic. So a standard book like K&amp;R is good enough to learn the language. However Advanced *programming techniques* in C takes some effort to learn. It involves two aspects: * Programming techniques, Algorithms, Data Structures in the language domain and available libraries. * Low-level understanding involving translation to assembly, language runtime system and toolchain, OS system call interfacing etc. This is proper "system" programming. * Advanced C++ is a multi-headed hydra! This is orders of magnitude more difficult to learn, particularly the "modern" C++11/14/17. Because it involves learning Procedural, Object-Oriented, Generic, Template-meta programming techniques and mix-and-matching them. The libraries are huge and require more mental investment. Furthermore you have to be very good in C before you can hope to understand C++ (ignore people who say otherwise). So both require lifelong study. The reward is that you will truly understand how Computers and Systems work, the ability to program tiny 8-bit micro-controllers to 64-bit multicore systems, the ability to write an efficient module and link it to any higher-level language and basically use one(or two) language to do everything. In today's computer language veritable tower of Babel this uniformity is invaluable for true understanding and mastery. PS: The magnitude of the challenge facing you should now be clear :-) If you are still upto it, let me know and i will give you a list of books to read.
&gt; Whatever you malloc(), you shall free() later This sounds like one of the 10 commandments. I love it.
Submodules with git is pretty good.
That's true, I blame mainly copy-pasting the OP for that oversight.
Note that an ELF binary (used on UNIX) has both *sections* and *segments.* The former are used to organize data logically, the latter are used to tell the OS how to load the binary.
Please be civil. And no need to censor swear words. If you think it is appropriate to swear, then swear.
Note that there are segments even in long mode on x86. It's just that most of their features are disabled.
No spam please.
/u/piginpoop was talking about memory segments, though, and sounding like someone who read an early-1990s book about the 80386 and believes that a) it was applicable then and b) nothing has changed since then, both of which are false. To the best of my knowledge, the only operating system outside academia to ever use a significant portion of the 80386 feature set, with call gates / task gates, multiple protection levels etc., was OS/2. Windows used a smaller subset but quickly moved away from most of it; 386BSD used call gates, but its successors switched to interrupts; Linux (newer than 386BSD) always used interrupts. But more importantly, neither of these ever used a segmented memory model, which means they all use page-level protection, not segment-level, and while x86-64 has a per-page execute bit, i386 does not.
I'll just post it here. https://discord.gg/DJdG9k
Hi, Sir. It's not a spam list. It;s 100% legit link. Please check Thank you :)
Your link is advertisement for a paid service. That's exactly spam. I don't see how our readers could find this link useful in any way.
That's a really good explanation. Thanks.
You might want to take a look at [Handmade Hero.](https://handmadehero.org/) It's a good intro to a lot of concepts. 
You can hit ctrl-d, which sends the End Of File signal, to stop scanning. This leads to the rest of your code executing. Alternatively, perhaps you could take the 12 digits as one number, allowing you to use one input into one variable, which could then be parsed later.
Whoever made this problem should be fired. The scanf statement gives me AIDS every time I see it. 
What are you typing? Asking for 12 integers means you need to type 1 2 3 4 5 6 7 8 9 0 1 2 and not 123456789012
You're scanning for 12 decimal numbers instead of 12 digits. Easiest solutions I can think of are either you scan 12 chars separately, convert them to digits, and then do the calculations, or you can scan it as a single integer, and do the calculations in a loop using the modulo operation.
By edit 3, you've got it. When you're doing recursion, there's always some sort of conditional- either you call the function again, or you've reached the terminating condition (in this case, 0 bottles). When you call the function, some sort of operation has been performed (minus one bottle), so when you call the function again with the new number, the same happens again, and will continue to happen until you reach that terminating condition. Once you do, the function returns (or, if it's void like in this case, simply ends), then the function that called it is able to end, then the function that called that is able to end, etc. Some people really like to use recursion, and it is a good thing to know how to do. Unfortunately it can be confusing and is more likely to introduce error, so if you can use some sort of loop (like a for loop) just as easily, that's the way to go. I understand this is probably a practice problem and you don't get to choose, but just a note for the future. You writing your thought process reminds me of a technique called rubber duck debugging. Look into it, it sounds strange but really works, and the fact that you were able to figure out this problem on your own just by explaining it to the internet demonstrates that it will work for you. Also, we use if/else, not if/then- you're in C land now :)
The endorphins are strong! Thank you for your reply!!
Read the EAN code as a string, then do whatever you want on each elemnent of the array.
Thanks for making me laugh
just work through the really difficult problems. It might take you a week but there will be a lot of ah-ha moments, as well as some other useful learning techniques. it's possible that after a week you still might not have it, but you will still be further ahead than you were the day before. However, if you feel like you're wasting time by trying to learn it rather than memorizing what others have done than read others code. I have learned a lot from others code, as well as working through a problem until I solved it. 
How would you write it?
I have no idea why scanf is so popular in this sub, or interactive input. Personally as a long time user of command line tools I'd prefer to use argv. If it has to be interactive then I'd read them as chars and convert.
For player collision you can check directly [week 10](https://hero.handmade.network/episodes#week-10-player-collision).
But it was a free coupon code for the paid tutorials, Sir. 
Read a string with `fgets()`, then parse that.
dunno...but there have been attempts like rio on windows. 
too long didn't read the point is you're quibbling over terminologies OP, me and those at stackoverflow are right you're wrong and you push c++ on a C subreddit
Almost certainly not a stack overflow; function calls consume the stack, and local vars consume the stack, and it gets released when you exit the function again. But you aren't going many function-calls deep, and anyway it usually only happens when you recurse. My suspicion is the first call to *realloc()* at line 45. This function will return *null* if the resize fails, meaning *contents* will be null after this call. You don't access *contents* again till line 54, which is where your error is happening. I've not used *realloc* before, but my suspicion is best practice is to assign the result to a temporary variable. Because if it fails and you blindly reassign to the original variable, then you've got a memory leak - the documentation doesn't suggest that realloc will free the original ptr on failure, which means now that you've just re-assigned it to be null you no longer have a ptr to the original allocation, therefore can't free it! So anyway, line 45 should be something like: tmp = (char**)realloc(contents, ...); if (tmp == 0) return -1; // return negative value to indicate error contents = tmp; // not sure if this is necessary 
You still have to pay $10 even with this coupon.
I would recommend running it under a debugger, it will "spring to life" when the segmentation fault is triggered and then you can inspect the variables at the time. I seriously would invest in getting to grips with using a debugger, they are an awesome tool that don't get the attention they deserve. They show you exactly what your code is doing. I think all the "new kids on the block" have ruined a generation of developers since they usually have crappy debugging options. 
I'll look into that, any suggestions?
I will try that. I've been playing around with it and It only throws the error when I realloc to greater than 6. Any ideas?
What's the platform? Since *contents* is initially malloc'd to be 2\*sizeof(char\*), I wonder if your realloc can only go smaller, and fails when trying to make *contents* be larger. (I might expect such behaviour from the lib of an embedded system, like a 16-bit micro, where such shortcuts in lib implementations aren't unheard-of)
Depends on where you are developing this. If it is using gcc, then gdb. If on windows using visual studio, then the built in debugger. LLDB if you use LLVM. 
Note that `readFile` gets a copy of `contents`, this is because in C everything is passed by value. Even though you're changing `contents` in `readFile`, the value of contents in the caller, `run()`, stays the same ! One solution is to add a level of indirection and make `readFile` take a `char ***`. That's not quite elegant, the other solution is to make `readFile` return `char **` and assign it to `contents` in `run()`. But then `size` has to be passed as pointer. 
im using gcc. I originally initialized it at 2 to compensate for the null terminator (not entirely sure if contents will have one though). Thought of that possibility earlier, [this](https://www.tutorialspoint.com/c_standard_library/c_function_realloc.htm) tutorial makes it seem like the size can be increased, and likely decreased. My point with the null terminator is that if contents need one, and it does not have one, would that cause the problems I'm seeing? It seems like it'd be a likely candidate for an array out of bounds error
I'm using gcc. I started looking into gdb and I've learned a little bit about it. I'll make sure to dive in later. I've been using vim and atom to write code and executing it via gcc. I'll look into visual studio, I'm in need of a good ide. 
I second the recommendation to read in a line at once (probably `fgets` is best) and pull digits out of that—that `scanf` is cancer and absolutely not what you want, and of course none of your input is checked so there’s no telling whether you’ll’ve gotten anything remotely sane even if it does somehow work. (It mostly won’t.) If you’re not comfortable enough with strings to do an `fgets`, you can loop around an `fgetc` to read 12 things into an array, then loop it to clear the line (i.e., until `'\n'` or `EOF`), then subtract `'0'` from each element in the array to get the digit value. Definitely get into the habit of checking *everything* about your input—make sure you’ve actually got 12 digits, make sure each is actually a digit, and make sure any trailing characters are within spec. Using an array and loop also make the summing much simpler—you can check and sum as you go, and once you’ve cleared the line you can just dump the result. Also, `%d` is generally preferred to `%i` in `printf`—you’re already using it in `scanf`—and that `%` operation in the argument might give you a bogus answer if you’re not careful. E.g., if `newsum == 0`, then `newsum - 1 &lt; 0` and the result of `%` is implementation-dependent but usually negative. If you want a straight mod 10 (same as `%` except −1 → 9), you need to check the result from `%` and wrap it if negative. Unless you want a potential `-` sign in the output, in which case never mind.
Everything I've read has made it sound like when I pass 'contents' as an argument of 'readFile' it's passing a pointer. When I run the program it seems to get the correct data. However, not passing it like you're suggesting might be what's causing these problems. I'll mock it up and see what happens, thanks!
The rest of the code will probably execute, but it’s basically undefined behavior as soon as he touches `i2` because anything beyond the first number won’t’ve been initialized and there are no input checks whatsoever.
Are you allowed to change the format of the input? It would make much more sense to read in the number of rooms and creatures first, *then* allocate memory for your array. Something like this? int num_rooms; int num_creatures; printf("Please enter the number of rooms: "); scanf("%d", &amp;num_rooms); printf("Please enter the number of creatures: "); scanf("%d", &amp;num_creatures); contents = malloc(sizeof(char*) * (num_rooms + num_creatures)); Of course, as /u/benjade mentioned, `contents` is passed to your function by value, so you would need a triple pointer to actually modify the contents of `contents`
For small sizes you're lucky it works because `realloc` most likely doesn't have to move the allocated chunk to another mem zone and can just extend the old. So the old pointer is just the same as the new one after `realloc`. There are a couple of other issues: 'null terminator' is when you're talking about strings, yours is an array of pointers so the comparison `if(contents[i] != '\0')` is not correct because `contents[i]` is a pointer, not a char literal. Another bug is that when you're `realloc`ing you're not calculating the new size correctly. contents = (char **)realloc(contents, sizeof(char *)* n + 3); This is likely not what you're intending (why the extra 3 bytes ?), `sizeof(char *) * (n + 3)` perhaps. But still when you're `realloc`ing you're not taking the whole size into account, just the difference (`realloc` works with new sizes, not differences). Also `(char **)` is not needed. This is C, a `void *` is converted implicitly to any other pointer to object type.
Take a look at the code of id Software's early titles (Doom &amp; Quake), they are written in C by none other than John Carmack.
Unfortunately, I can't. I could store the information from the rooms, get the number of rooms and creatures, allocate memory, and then fill in the data.
That would explain why the memory is getting cut off at 6. Ok, that makes sense. I will redo and post. Thanks!
&gt; too long didn't read Too bad, you might have learned something. &gt; OP, me and those at stackoverflow are right In your dreams. &gt; and you push c++ on a C subreddit When have I ever “pushed C++”?
No Fuxxl. It's FREE. You should check again. 
Could you put it on pastebin please ? 
Quick question; when assign values to a position in 'char **contents' should it be 'contents[]', or 'contents[][]'? 
I can try, no idea what pastebin is.
Original code from post: [pastebin](https://pastebin.com/m8EbmXZn) 
Something where you can upload your code 
contents[][] if you want to set a specific char, if that's what you mean.
On the one hand, I don't think your answer is relevant to OP's question, which is really "What else do I need to learn about underlying networking concepts and protocol details, and how can I learn it?" The API used to access those protocols is irrelevant. On the other hand, I'm curious. What is so bad about the Berkeley sockets APIs? To my mind, they're perfectly extensible, which is why they're able to be used not just for IP/TCP/UDPv4, but also for IPv6 and for unexpected uses like [CAN bus](https://en.wikipedia.org/wiki/SocketCAN). The only mistake I can think of was introducing `struct sockaddr_storage`, when they should have just changed the definition of `struct sockaddr` to be large enough to hold any type of address.
200% let me know what I should read, do, and practice. I want to not only get the the level of proficiency you described, but do those things as a career.
First off, compile with debugging symbols (-g if I remember correctly), then just run "gdb &lt;yourprogram&gt;", and "run". When it stops on the segmentation fault, you can print the variables and of course see the exact line that caused the error. You can then set a breakpoint on the line where the variable gets set, and rerun. You can then observe the variables at that time, and single step. If you want to go advanced , you can set a breakpoint with a data change "filter", so you stop only when the variable matches a certain criteria (e.g. When it is null) Hope that made sense and helps. 
What's exactly the question? 
Thanks, noted. I commend you for mocking my efforts, but I think I would, you know, probably reinvent the wheel for 18th time after all. By the way, do you have links to those other 16 replacements as well? I mean I already researched some of them (like HJSon, Json ES5) and they seemed pathetic to me. Never heard about UCL though (surprisingly). Isn't it your project?
Do you have a complete example? I actually didn't realize MinGW supported weak symbols, and I'd like to have a look at this. ~~One thing to keep in mind is that function addresses are always true values (i.e. they are never NULL), and GCC will optimize for this. It will eliminate branches dependent on function addresses being compared to NULL. The two tests you showed almost certainly aren't working as you expect.~~ 
Sure thing, I will give an example as soon as I can. &gt;The two tests you showed almost certainly aren't working as you expect. Could you clarify this? It does exactly what I describe it does. Both gcc and MinGW gives me a warning on the function that is not weak, saying (as you mentioned) that it will always be true, but gives me no warning on the weak function.
Couldn't you just use separate commands to compile and link the test executable and the real one? Something like: gcc -o real main.c regular_function.c gcc -o test main.c test_function.c
Nevermind my second paragraph. Weak symbols can indeed have NULL as their address with ELF binaries. An excerpt from the ELF specification: &gt; Unresolved weak symbols have a zero value. MinGW doesn't use ELF, but I imagine it follows the same semantics. 
It says “Click this link to get Top Courses in C Programming for just $10.” Are you sure you actually read that?
&gt; I commend you for mocking my efforts That was not my intention. &gt; Never heard about UCL though (surprisingly). Isn't it your project? Not at all. What makes you think so?
What I do is close to it. I have a separate project only for testing, which uses the .o files from the project to be tested. So the tested project itself, although having the function defined as weak, have only one definition, but it doesn't work. The test project have two definitions (the real one and the mocked), and works fine. Go figure. EDIT: forgot to mention that the test project (and the tested project for this case) is compiled using gcc. Still, there is the other function that works fine.
It would be better to use function prototypes ; as you have it now the compiler won't diagnose a call with the wrong argument type or count.
Here is the example as promised: weak_example.c #ifndef WEAK_EXAMPLE #define WEAK_EXAMPLE void weakFunction() __attribute__((weak)); #endif weak_example.c #include "weak_example.h" #include &lt;stdio.h&gt; void weakFunction() { printf("First.\n"); } weak_main.c #include "weak_example.h" #include &lt;stdio.h&gt; void weakFunction() { printf("second\n"); } int main() { weakFunction(); } Compiling and running: $ x86_64-w64-mingw32-gcc weak_main.c weak_example.c -o weak.exe $ wine weak.exe In the example above, it will print "second". If you swap the order of the .c files it will print "first". If \_\_attribute\_\_((weak)) is removed, ld complains.
GCC's function attributes are "sticky" (my term). If an attribute appears on a prototype, it's also implicitly set for any definitions that follow it. So, by putting the `weak` attribute in the header, both definitions are weak, and it's arbitrary which one the linker selects. It's just picking the first weak one it sees. To fix this, remove the attribute from the header and put it directly on the definition you want to have overridden. The linker will always choose the other definition when both are present. If you declare it weak but don't provide any definition to the linker, the symbol will get a zero address and the program with crash when it tries to call that function. 
I didn't know that, I'll look it up. Any suggestions?
Oh. That was all c programming link, sir scroll down to the page. YOu will see button GET CODE. Apologies for not explaining this. 
You mean like this? //myfunctions.h void thatFunction(); //myfunctions.c #include "myfunctions.h" void __attribute__((weak)) thatFunction() {} I did so, and the linker complains that thatFunction is not defined. For now (and if I can not get ((weak)) to work), I am using pragma inside a ifdef like this: //myfunctions.h #ifdef TEST_PROJECT #pragma weak thatFunction #endif void thatFunction(); Then I compile it with -DTEST_PROJECT when I want to run the tests. Not ideal and a bit more convoluted, truth be told.
If the version to be replaced is the one that prints "first", then here's what you'd do: weak_example.h: #ifndef WEAK_EXAMPLE #define WEAK_EXAMPLE void weakFunction(); #endif weak_example.c #include "weak_example.h" #include &lt;stdio.h&gt; __attribute__ ((weak)) void weakFunction() { printf("First.\n"); } weak_main.c: #include "weak_example.h" #include &lt;stdio.h&gt; void weakFunction() { printf("second\n"); } int main() { weakFunction(); } The linker now sees two versions of `weakFunction`. One is weak ("first") and the other is strong ("second"), and the strong one has higher precedence. 
Yeah - `int readFile(char **contents);` and `void run(void);`. Although as suggested elsewhere on the thread you probably want to change the parameter type of `readFile`. (My suggestion would be a struct containing `char **` plus the length) 
I'll do that, thank you
You may want to pose the question to /r/c_programming because this is really a question about organization. I would recommend reading "Code Complete" by Steve McConnell sometime in the future as it covers managing complexity. You want to write small functions with a singular purpose. Write the steps it takes to do something. Each step will likely translate into a function. For larger tasks, you can use separate files. It takes practice to become good at this part. You are going to fail. You will over engineer it. You will royalty screw the pooch. But if you can apply what you learn from those mistakes, it will make you a better programmer. Use git and commit a few times a day.
Do you mean /r/programming? Also, read the last line of the post.
No, the sub I mentioned welcomes questions about programming in C. There are many knowledgeable users in the sub who are willing to help.
You literally mentioned this sub
Oh crap. I thought this was /r/roguelikedev 
What is scrolling is your terminal, before it gets to the stdin of your program. You need to change the mode to raw or something like that. Depends on your OS. See https://stackoverflow.com/a/1799024 Edit: but that of course means you have to output stuff. Maybe use getchar. 
Thanks for the tips everyone. All good stuff to look into.
thank you for this resource! will give this a read when i get home :)
Note that this terminal stuff is a bit complicated. Not the best thing to do when you are a beginner.
OP wanted to go in depth with sockets &gt; sockets and how to make them but I want to go more in depth I said &gt; 99% of work while using sockets is making epoll or iocompletionports work So I am 100% more helpful than most of you here. &gt; What is so bad about the Berkeley sockets APIs? Eg. Why isn't there something like acceptex in bsd sockets?
I'm just being redirected to my own videos. Another link?
I'm assuming you're interested in constructive criticism, so a few observations: - most of your macros should probably be inline functions - the `register` keyword has been obsolete for 20+ years - by inserting a header you're potentially messing up your array alignment, which may matter for things like SIMD code, and there may also be other minor performance issues. I suggest padding your header up to a multiple of at least 16 bytes, e.g. maybe make it 4 x `size_t` rather than 3 x `size_t` (just add an extra dummy `size_t` field) ?
Wow this library looks really cool: I am definitely going to use it in a personal project, after having a deeper look into the source code ! I was wondering: why do you use macros for `da_push`, `da_pop`, etc, instead of plain function ? I think it can leads to a performance gain, but it seems to result in more lines of code and it might be less easy to debug with gdb. (correct me if I am wrong) 
Don't bother. This guy goes around to all the programming subreddits and shit-posts his 'tutorials'. Which just include terrible music to him trying to code. Have a look: https://youtu.be/0ifTb-bZ8W4
Thanks I appreciate the criticism. I never even thought of the header alignment issues. As far as the macros go, I tried to use inline functions wherever possible, but in some cases the only way I could find to make the "functions" generic / work for both lvalues and rvalues was to use macros. It's dirty but it solves the problem.
Video linked by /u/Cronizal: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Star pattern 23 in c language//program how to make star pattern](https://youtu.be/0ifTb-bZ8W4)|shivam sharma|2017-08-08|0:05:39|3+ (30%)|198 &gt; like share and subscribe --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/Cronizal ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dm0op7k\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v1.1.3b
If I could have it my way I would do away with all the macros, but without macros in some places I couldn't find a way to make the library truly generic for all types without making the push/pop functions ugly and over complicated. I chose to go with the simpler option since I wanted to make the overall design of the library as simple as possible to use for the end user.
ah yes, just the illustration alone is confusing. i should've clarified that i was practicing with dev c++. anyways i found the way to do it. thank you :)
The `register` keyword still counts when compiling with no optimizations (which is the default for `gcc`, ie: if you omit `-O`!). Test this code: #ifndef REGISTER #define REGISTER #endif int main(int argc,char *argv[]) { for(REGISTER long i=0; i &lt; (1L&lt;&lt;30) ; i++) ; return 0; } With both `-DREGISTER=register` and wihout. And no `-O` flag of course. You'll see a surprising difference. For the reason that his library is a header file and so depends on the compilation options of the end user, i'd leave `register` so that even in the worst case that someone compiles without `-O` his library is still efficient enough. 
I'd use the natural word size of the CPU in [_da_memswap](https://github.com/VictorSCushman/darray/blob/master/darray.h#L299), not `char`s. This would make it several times faster. 
That would be ideal. Any idea how to do that when the contained type has an odd alignment when compared to the natural word length? For instance an array of chars or array of shorts.
That's the thing, you ensure that it is 16 byte aligned like it has been suggested. Then you can go through it with any data type.
You may need to explain it better, I don't think I'm quite understanding what you mean. I'm imagining if you say you want a darray of char, and then you want to memswap two of the characters in that array. If you have anything other than a char as the word length won't you overwrite some other memory unless you do some bit-mask fiddling?
 static inline void _da_memswap(void* p1, void* p2, size_t sz) { #define EXCH(a,b,c) (c=a,a=b,b=c) int tmp; char *a = p1, *b = p2; while(sz &gt;= sizeof(int)){ EXCH(*(int *)a,*(int *)b,tmp); a+=sizeof(int), b+=sizeof(int), sz-=sizeof(int); } for(; sz-- ;a++,b++) EXCH(*a,*b,tmp); #undef EXCH } Something like this, you go through it an `int` at a time until there's no more space left for an `int`. For the remainder, you simply go through it `char` by `char` like you do. 
&gt; That was not my intention. Regardless of your intentions your comment was perceived to be a mockery. &gt; Not at all. What makes you think so? The fact that out of 17 alleged replacements you linked to only one, which seemed to me like you are promoting your project being confident that I'm unlikely to do better. So far no potential JSON replacements have convinced me to be good enough and I politely asked you to post more links (16 to be precise) because I was curious whether any of them might actually change my mind. Now either do actually post them or stay away from my comment reputation and my submissions as well.
Here's some light reading for you: https://www.merriam-webster.com/dictionary/hyperbole https://en.wikipedia.org/wiki/Not_invented_here https://en.wikipedia.org/wiki/Reinventing_the_wheel
**Not invented here** Not invented here (NIH) is a stance adopted by social, corporate, or institutional cultures that avoid using or buying already existing products, research, standards, or knowledge because of their external origins and costs, such as royalties. The reasons for not wanting to use the work of others are varied, but some can include a desire to support a local economy instead of paying royalties to a foreign license-holder, fear of patent infringement, lack of understanding of the foreign work, an unwillingness to acknowledge or value the work of others, jealousy, or forming part of a wider turf war. As a social phenomenon, this philosophy can manifest as an unwillingness to adopt an idea or product because it originates from another culture, a form of tribalism. The term is normally used in a pejorative sense. *** **Reinventing the wheel** To reinvent the wheel is to duplicate a basic method that has already previously been created or optimized by others. The inspiration for this idiomatic metaphor lies in the fact that the wheel is the archetype of human ingenuity, both by virtue of the added power and flexibility it affords its users, and also in the ancient origins which allow it to underlie much, if not all, of modern technology. As it has already been invented, and is not considered to have any operational flaws, an attempt to reinvent it would be pointless and add no value to the object, and would be a waste of time, diverting the investigator's resources from possibly more worthy goals. The phrase is sometimes used without derision, when a person's activities might be perceived as merely reinventing the wheel, when they actually possess additional value. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.26
Oh now I see what you mean. That's a good idea. I'll try to add that in my next update.
Technically, it's always a hint. It's obsolete because, with optimizations on, the compiler will better allocate registers than the programmer's specifications. If optimizations are off, it's generally for the purposes of debugging, so the user probably *doesn't* want the variable stored in a register. If they're trying to debug with optimizations disabled, they're trying to avoid diving into registers and memory, generally speaking. I didn't dig into the OP's code, but I highly doubt their use of it will make the library particularly fast with optimizations disabled. It's not wrong to use, but probably not what you want to do.
You are right, but i'm sure the user wouldn't need to debug library code. If there are no optimizations, the code is significantly faster. If there are optimizations enabled, and it knows better then `register` will be ignored. Yeah, `register` is pretty much useless most of the time. But in this case it makes sense to use it.
As a better alternative, you can simply provide an optional alignment version of the allocate. Some systems might need 1MiB alignment, so are you going to force that down all user's throat? For most uses, you'll be fine with int (not size_t) alignment. If some user wants specific alignment, chances are you won't be able to make it work generically, so don't try, let the user specify. Your code can just handle that alignment on its own. Nothing says your header has to be aligned on the same boundary, either. If someone needs 128-byte alignment because of some platform specific I/O, that doesn't mean your header can't just be a little block before the first chunk that aligns at whatever makes sense on that platform. Oh, and you'll want to think about array member alignment. If the chunks require 128-byte alignment, for example, but each member is 32-bytes, you're gonna have a bad time. 
Your example is contrived to make the register version faster, but, generally speaking, your performance overhead is on the inside of the loop -- certainly not on the "loop part". It's also going to end up being hardware dependent. I would say your example is bad because the best optimization there is to delete it entirely since it does nothing useful. I'm not arguing against the benefit of using register in your example only that in OP's it won't likely make any difference in any real world scenario while adding maintenance and decreasing the ability to debug. If I add a meaningful operation to the inside of your loop, say pushing an entry to the back of the array, the operations involved there are going to be an order of magnitude greater than the loop variable operations.
a4qbfb, your input is not needed. Last time: take your attitude elsewhere.
k
Unless you do operations that are significantly slower than reading from memory (like an I/O operation) it's safe to say the without `register` it's going to be much slower. Simply because on each iteration it reads/writes the same variables from/to memory. I've tested it with filling an array, and it's more than twice as fast with register.
That's not guaranteed. To be clear, specifying register is inherently a hint. The performance benefit or detriment is entirely dependent on what the compiler outputs and the hardware (not the ISA, the hardware architecture itself). It doesn't mean it has to read the variable, that, again, will depend entirely on the architecture. It *might* or *might not*. I'm suggesting there's no point in throwing in register unless you've got a clear use case. In the case of OP's work, I don't think it'll provide any meaningful benefit in real world scenarios -- and the only scenario that this matters is when the code is built with optimizations fully disabled -- doubtful this piece of code is going to be the performance bottleneck there on anything non-trivial. In that scenario, the debugging is what matters most anyhow otherwise they'd build with -O1 (using gcc as the example).
Fair enough.
My guess would be that the two machines use different floating point representations/implementations/whatever and when cross-compiling, the compiler probably also does some optimization (since there is no variables involved in `-13/5 == -2`) and might use the host (machine X) floating point implementation to calculate that.
Thank you. That makes sense. One of the exercises asks you to "fix" this function (without using conditional compilation) so that it will always work as intended. Do you know how it would be done? It seems to me that the compiler might always evaluate the test expression as you suggested, and thus this problem would thus be impossible to solve.
`-13/5` is integer division in C; there is no floating point arithmetic involved at all.
Oh, you're right, didn't noticed that. So my post is now invalid.
 bash &lt;(curl https://raw.githubusercontent.com/junjiemars/nore/master/bootstrap.sh) Executing commands like this is bad. A sneaky `rm -rf ~/` might be in there! Anyway, why should I use Nore? What features, advantages, etc. does it have?
It has to do with constant folding at compile time. The author talks about how this could fail in the face of cross-compilation. The *host* machine is the one running the cross-compiler, compiling code for the *target* machine. Say the host machine truncates toward zero. The host machine's compiler compiled the cross compiler, and folded that constant expression into a constant, so now the cross compiler doesn't perform that check, it just has a "1" or a "0" there. That means that the cross compiler is generating code it wouldn't normally generate, because the check was done on the host machine, not the target machine. When the code (generated by the broken cross-compiler) is run on the target machine, the generated code now reflects the semantics of the host machine's native compiler, rather than the target machine's semantics. There's no issue of floating point representation or anything that low-level going on here, because there's no floating point arithmetic in that program. To fix it so that it would even work in the cross-compilation case, there are a couple of options. You could use the standard `div` function, which has guaranteed rounding/truncation semantics, or you could do some magic. You could write `Arith_div` like this: int Arith_div(int x, int y) { int q = x / y; int r = x % y; if (x &gt;= 0 &amp;&amp; r &lt; 0) q++; return q; } This eliminates the constant test, which would be folded by the host compiler and is the ultimate source of our troubles. Instead, we do the division as normal and also check for the remainder of dividing `x` by `y`. If the implementation truncates toward zero on division, `-13/5` would equal -2. For the identity `q * y + r == x` to hold, that would make the identity be `-2 * 5 + r == 13`, which necessarily makes `q` equal -3. If the implementation rounds toward negative infinity, `-13/5` would equal -3. For the identity to work, then, `r` would have to be positive 2 (because you'd get -15 and have to add 2). So, long story short, if the remainder is less than zero, but the numerator is positive, we need to add one to fudge it back up. Compilers are obligated to be implemented in such a way that the above identity holds, so by exploiting that requirement you can see which way the compiler/implementation rounds. EDIT: This may all be moot with C99, I'm not sure. I seem to recall that C99 mandated that everything round a certain way (toward negative infinity?), but I'm not positive.
&gt;&gt; sockets and how to make them but I want to go more in depth &gt; OP wanted to go in depth with sockets I interpreted that differently. OP's title was "C and *networking*", not "C and sockets". I took that to mean they want to understand in more depth how *networking* as a whole works, not just how to use the sockets API. &gt; I said &gt;&gt; 99% of work while using sockets is making epoll or iocompletionports work &gt; So I am 100% more helpful than most of you here. That's pretty cocky. Others have provided links to books and advice on what else OP should study. You've said what you think the difficult part of working with sockets is, which may not be true for everyone else; not everyone needs asynchronous I/O. Even if it is true, you haven't given any kind of tips or tricks or solutions. So in fact, you don't seem to be helping at all. &gt;&gt; What is so bad about the Berkeley sockets APIs? &gt; Eg. Why isn't there something like acceptex in bsd sockets? You're asking me? I don't know why, because I'm not familiar with `AcceptEx()`. But I can read a manual, so let's see... hmm... The claim is that `AcceptEx()` has lower overhead due to context switching and system calls than separately calling `accept()`, `getsockname()`, `getpeername()`, and `read()`. Is that true? I have no idea. I'd imagine it depends on quite a lot of things. On the embedded network stack I use daily, I doubt it; running on an RTOS, except for some locking we can pretty much go as fast as CPU and RAM will let us, and overhead for context switching is minimal (between tasks) or nonexistent (for system calls, since there is no division between user mode and kernel mode). Why doesn't the standard Berkeley/POSIX sockets API offer an equivalent call? Maybe because they feel that on most other systems that implement these APIs, there isn't enough loss in making multiple function calls to justify needing a specialized API like this. Maybe on those systems, creating the structures behind a socket isn't so expensive. I'm particularly surprised at `AcceptEx()` combining the two addresses and the data into a single buffer; why does the amount of overhead scale with the *number* of buffers such that a single buffer is noticeably more efficient? Memory is memory, and it's not like function arguments are expensive, so unless it's taking extra page table faults or something, I'd be extremely surprised if it actually makes such a big difference. But really, I don't know why I'm talking so much. You're the one who thinks sockets are "a mess", so why don't you explain what's so bad about them? Give us some facts or theories, anything to discuss. Don't just make a blanket claim and then fail to support it in any way.
If your simulation is precise enough that you are concerned with modulo bias, consider a RNG library? 
What I ended up doing is as a device is downloading I update a time stamp, then where I check if we reached the max # of connections and determine if we had / have any in progress downloads I look at the devices in progress counter if we have any I then look at the time stamp if that time stamp becomes 2 minutes old I then do what I need to do which is kill the app and recycle it.
Most prng implementations have a method next_int(range) that takes care of modulo bias for you, returning an int &lt; than range with lineal probability. I hope you are using a decent library because the default "rand" is horrendous.
It's right if you're insecure, you can do this: curl -O https://raw.githubusercontent.com/junjiemars/nore/master/bootstrap.sh chmod u+x bootstrap.sh ./bootstrap.sh The main features of [Nore](https://github.com/junjiemars/nore) is **easy**: debugging, cross compilers, easy to try. There are an example: https://github.com/junjiemars/nore-hi 
Round up to the nearest power of 2 and use this as the modulus (i.e. as a bitmask). If the number is out of range, discard and try again. This eliminates the modulo bias. Also, use your own PRNG and not `rand()` since that one's usually garbage. My favorite these days is [xoroshiro128+](http://vigna.di.unimi.it/xorshift/xoroshiro128plus.c).
1) Sockets in Tcl are breeze. They're not that much worse in C. 2) Many of the problems people attribute to sockets are actually attributable to TCP. 2) You have to think in state machines. It's all the further adventures of the Two Generals Problem. 
Pretty cool, it's basically C++'s `std::vector` in C. I made a pull request to fix a bit of code in the performance test. Currently the performance test is compiled without optimization flags, is this a mistake? To me it seems you'd want to know what the performance is like *with* optimizations on. edit: missed two words.
If you're looking for a simple PRNG that have a function to avoid modulo bias consider looking at the [PCG family](http://www.pcg-random.org/) of PRNGs.
There isn't one. He's suggesting you don't learn to program in the real world because it's not perfect. Pretty much like every other declarative programming fanboy. 
The question doesn't make any sense. When declaring an array of char you can explicitly give it the desired size such that it's large enough to hold the longest string you expect to encounter. There's no need to pad anything. This is probably [an X-Y problem](http://xyproblem.info/). You need to explain what you're trying to do, not how you think you need to do it. 
Your q is a bit unclear, but I'm assuming what you mean is you want to allocate a string and fill in its contents later. If you want to allocate a string with enough storage to hold n characters you'd declare it as follows: char myString[n + 1]; // the plus one is for the terminating '\0' Note, this allocates the string on the stack which means it's only around during the lifetime of the function that declares it. If, for example, you want to return it as the value of a function, then you'd need to do something like: char *myString = malloc(n + 1); If you go this route, _someone_ (presumably, the caller of the fn) has to take responsibility for calling `free`, after the string is no longer needed, to free up the memory it uses.
So basically with Linux the system calls read and write are used as you probably know. I read the data from to my variable char buffer[256] but when I wrote it out it had a lot of weird symbols which I knew meant just random memory I think. I could be wrong on that part so don't quote me lol. Anyway from background in Python i knew that in encryption I had to have a padding function to fit the right size of file needed and I want to do that just with this char array. Idk if that is clear enough. 
It sounds like you tried to print a string that was not null-terminated. All of the functions of the standard library that deal with character strings, such as `printf()`, expect null-terminated strings. `read()` is for working with arbitrary data, not necessarily character strings, and consequently it does not alter the data in any way, including not adding a null terminator. Either the data you're reading must itself contain a null character or you must add one explicitly, which means you need to know where it should go, i.e. you must have some way of determining the length, possibly from the return value of `read()`, possibly from some other source.
Good catch. The performance tests are still under development so I bet there are probably a couple other things that slid by as well. I don't do much C++ development so I appreciate the PR with your fix.
&gt;Anyway from background in Python i knew that in encryption I had to have a padding function to fit the right size of file needed and I want to do that just with this char array. Are you trying to write() a fixed-size block of 256 regardless of how much was read()? So if you read() 10 bytes of data, you want to write() those 10 bytes followed by 246 bytes of some padding value? You may need to look into calling memset() before each read(). What's confusing matters about your question is that a string in C has a strict definition: "A *string* is a contiguous sequence of characters terminated by and including the first null character." A string is therefore a subset of completely arbitrary data (the latter including data without any NULs and data with one or more non-terminating NULs). The system calls you mention and the Python use case you mention suggest you're working with completely arbitrary data, not strings as such.
First note that Career/Job/Market is quite different from Knowledge/Intellectual satisfaction. So you have to keep "earning money" separate from "gaining knowledge" but do both parallely. If you are one of the lucky few who has both aligned in a particular job, you have got it made. Mostly that is never the case and hence you have to work on your Motivation/Enthusiasm and keep hammering away at the difficult subjects. There are no shortcuts :-) I prefer Books to the Internet for study since they are more coherent and less distracting, allowing you to focus better on a subject. Unless newer editions are reqd. buy used/older editions to save money and build a large library. So here is a selection from my library (in no particular order); * [Digital Design and Computer Architecture](https://www.amazon.com/Digital-Design-Computer-Architecture-Second/dp/0123944244/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1503544998&amp;sr=1-1&amp;keywords=digital+design+and+computer+architecture) * [Foundations of Analog and Digital Electronic Circuits](https://www.amazon.com/Foundations-Electronic-Circuits-Kaufmann-Architecture/dp/1558607358/ref=sr_1_11?s=books&amp;ie=UTF8&amp;qid=1503544998&amp;sr=1-11&amp;keywords=digital+design+and+computer+architecture) * [Introduction to Embedded Systems](https://www.amazon.com/Introduction-Embedded-Systems-Microcontrollers-MSP430/dp/1461431425/ref=sr_1_4?s=books&amp;ie=UTF8&amp;qid=1503545700&amp;sr=1-4&amp;keywords=introduction+to+embedded+systems) * [Code: The Hidden Language of Computer Hardware and Software](https://www.amazon.com/Code-Language-Computer-Hardware-Software/dp/0735611319/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1503545753&amp;sr=1-1&amp;keywords=code+the+hidden+language+of+computer+hardware+and+software) * [The Elements of Computing Systems](https://www.amazon.com/Elements-Computing-Systems-Building-Principles/dp/0262640686/ref=pd_sim_14_4?_encoding=UTF8&amp;pd_rd_i=0262640686&amp;pd_rd_r=9BHB4XPMF6NXNQDV9GNX&amp;pd_rd_w=f4XZ6&amp;pd_rd_wg=tfRPP&amp;psc=1&amp;refRID=9BHB4XPMF6NXNQDV9GNX) * [Foundations of Multithreaded, Parallel and Distributed Programming](https://www.amazon.com/Foundations-Multithreaded-Parallel-Distributed-Programming/dp/0201357526/ref=cm_cr_arp_d_product_top?ie=UTF8) * [The Practice of Programming](https://www.amazon.com/Practice-Programming-Addison-Wesley-Professional-Computing/dp/020161586X/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1503546491&amp;sr=1-1&amp;keywords=the+practice+of+programming) * [The C programming language](https://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628/ref=pd_bxgy_14_img_2?_encoding=UTF8&amp;pd_rd_i=0131103628&amp;pd_rd_r=NRCXAS4KSM9SSWSYB1HB&amp;pd_rd_w=wgaKu&amp;pd_rd_wg=WNMP6&amp;psc=1&amp;refRID=NRCXAS4KSM9SSWSYB1HB) * [The C Companion](https://www.amazon.com/C-Companion-Allen-I-Holub/dp/0131097865/ref=sr_1_1?ie=UTF8&amp;qid=1503546616&amp;sr=8-1&amp;keywords=the+c+companion+holub) * [Expert C Programming](https://www.amazon.com/Expert-Programming-Peter-van-Linden/dp/0131774298/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1503546670&amp;sr=1-1&amp;keywords=Expert+C+deep) * [C Interfaces and Implementation](https://www.amazon.com/Interfaces-Implementations-Techniques-Creating-Reusable/dp/0201498413/ref=pd_sim_14_6?_encoding=UTF8&amp;pd_rd_i=0201498413&amp;pd_rd_r=W79VWWSQCHYME1QXXT6K&amp;pd_rd_w=C1vXk&amp;pd_rd_wg=u4w64&amp;psc=1&amp;refRID=W79VWWSQCHYME1QXXT6K) * [Data Structures and Program Design in C](https://www.amazon.com/Data-Structures-Program-Design-C/dp/8177584235/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1503547133&amp;sr=1-1&amp;keywords=data+structures+and+program+design+in+c) * [The Unix Programming Environment](https://www.amazon.com/Unix-Programming-Environment-Prentice-Hall-Software/dp/013937681X/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1503546858&amp;sr=1-1&amp;keywords=the+unix+programming+environment) * [Computer Systems: A Programmer's Perspective](https://www.amazon.com/Computer-Systems-Programmers-Perspective-3rd/dp/013409266X/ref=pd_sim_14_2?_encoding=UTF8&amp;pd_rd_i=013409266X&amp;pd_rd_r=NSNX5PEN2WXJ6553TR1X&amp;pd_rd_w=Fb71G&amp;pd_rd_wg=bMr0x&amp;psc=1&amp;refRID=NSNX5PEN2WXJ6553TR1X) 3rd edition is 64-bit, 2nd edition is mostly 32-bit and a little 64-bit while 1st edition is all 32-bit. * [The C++ Programming Language 4th edition](https://www.amazon.com/C-Programming-Language-4th/dp/0321563840/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1503547330&amp;sr=1-1&amp;keywords=the+c%2B%2B+programming+language) * [Discovering Modern C++](https://www.amazon.com/Discovering-Modern-Scientists-Programmers-Depth/dp/0134383583/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1503547430&amp;sr=1-1&amp;keywords=Discovering+modern+c%2B%2B) * [C++ Templates: The complete guide](https://www.amazon.com/Templates-Complete-Guide-David-Vandevoorde/dp/0201734842/ref=pd_sim_14_8?_encoding=UTF8&amp;pd_rd_i=0201734842&amp;pd_rd_r=STW6J76JZ3P9H84CDJD3&amp;pd_rd_w=O3e50&amp;pd_rd_wg=rhBbp&amp;psc=1&amp;refRID=STW6J76JZ3P9H84CDJD3) * [Modern C++ design](https://www.amazon.com/Modern-Design-Generic-Programming-Patterns/dp/0201704315/ref=pd_sim_14_1?_encoding=UTF8&amp;pd_rd_i=0201704315&amp;pd_rd_r=A3QK3MPP74A1GMCZ6ZV6&amp;pd_rd_w=LQmfO&amp;pd_rd_wg=NU2oi&amp;psc=1&amp;refRID=A3QK3MPP74A1GMCZ6ZV6) * [Scientific and Engineering C++](https://www.amazon.com/Scientific-Engineering-Introduction-Advanced-Techniques/dp/0201533936/ref=cm_cr_arp_d_product_top?ie=UTF8) * [Advanced C++ programming styles and idioms](https://www.amazon.com/Advanced-C-Programming-Styles-Idioms/dp/0201548550/ref=pd_bxgy_14_img_2?_encoding=UTF8&amp;pd_rd_i=0201548550&amp;pd_rd_r=VAEW8KJK3DS0HY43GBSW&amp;pd_rd_w=XnRQ7&amp;pd_rd_wg=lRlew&amp;psc=1&amp;refRID=VAEW8KJK3DS0HY43GBSW) * [Design Patterns](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=pd_sim_14_9?_encoding=UTF8&amp;pd_rd_i=0201633612&amp;pd_rd_r=2E63E3DDT4BMC0MGHAY8&amp;pd_rd_w=v89FL&amp;pd_rd_wg=fB6ZD&amp;psc=1&amp;refRID=2E63E3DDT4BMC0MGHAY8) 
This will be a strict aliasing violation if the array stores doubles. 
This is basically a never ending loop. That prints a "long int" named "nc". Long int just means it can count higher. Regular int can't go as high as long int but goes higher than short int. I think you would cause end-of-file by pressing Ctrl-d while the program is running. 
I think the last line of my comment explains my comment. I get that iocompletionports or epoll are generic and not related to sockets, but they are the major chunk of work of making sockets work. Also there are extensions to bsd sockets (which would not have been required if socket api had been good enough) which perform better. 
&gt; That's pretty cocky. thanks &gt; which may not be true for everyone else; not everyone needs asynchronous I/O yes and those people are noobs who make bad products &gt; you haven't given any kind of tips or tricks or solutions I gave the 2 words which are enough to get him started and more helpful &gt; On the embedded network stack I use daily, I doubt it; running on an RTOS you make the mistake of assuming server os, desktop os and RTOS are radically different. From kernel and low level libraries (like socket, file io) standpoint they're not. There was a need for windows to write acceptex (and a buttload of other api) to make sockets actually work. The same problem exists everywhere. It's just that lazy developers recommend to scale horizontally (just add more boxes) instead of actually improving code. &gt; they feel that on most other systems that implement these APIs, there isn't enough loss in making multiple function calls to justify needing a specialized API like this there you said it. bsd sockets is broken. if it wasn't, systems which implemented bsd socket specification would've been able to get 100% network, CPU and RAM utilization and thus provide the best service to connecting clients or vice versa. but they're not able to do that while following bsd socket specification as the specification is fundamentally broken. thus the discussion is over. &gt; Give us some facts or theories, anything to discuss sometimes I'm in a mood to type a wall of text sometimes I'm not maybe later
`p1` and `p2` are aligned for both `int` and `double`, so i'm pretty sure it is ok. The pointers could alias the same location though, and this prevents some optimizations. For that reason it would be best to declare them with `restrict`. static void _da_memswap(void * restrict p1,void * restrict p2,size_t sz) 
Alignment is not the issue. Strict aliasing means that a `double *` and an `int *` must not point to the same memory location (unless access happens through a union). Accessing one data type through a different pointer is UB. 
Sorry, I don't see how this is related to C programming. Removed for being off topic.
Very well then. So then it's impossible in C to copy more than a `char` at a time from one buffer to another? That is painfully slow.
Yes, that is a problem. Most existing implementations of `memcpy` go one of two ways: Either compiling with `-fno-strict-aliasing` which tells the compiler “I know what I am doing. Just compile this illegal code”. Or have the code copy byte by byte and hope that the compiler vectorizes it correctly.
It says coupon “not required” and [the course](https://www.udemy.com/c-programming-beginners-advanced/) is free in general? WTF?
No spam please.
&gt; Regular int can't go as high as long int but goes higher than short int. You have no guarantee of that. The standard only defines minima, not maxima (§5.2.4.2.1). It does not even impose an ordering, except in terms of conversion rank (§6.3.1.1). On 16-bit platforms like DOS, `short` and `int` are both 16 bits while `long` is 32 bits and `long long` is 64 bits (presumably, since the standard requires it, but in most cases it would have to be emulated). On most 32-bit platforms, `short` is 16 bits, `int` and `long` are 32 bits and `long long` is 64 bits (ILP32LL64). On most 64-bit Unix-like platforms, `long` is 64 bits (I32LP64), while Windows keeps `long` at 32 bits (IL32LLP64). On UNICOS (the operating system that ran on Cray supercomputers before they were acquired by SGI), everything except `char` was 64 bits (SILP64). &gt; I think you would cause end-of-file by pressing Ctrl-d while the program is running. On a Unix-like system, and assuming the program is reading from the terminal and not a file, yes. On DOS or Windows you would press Ctrl-z.
Why has nobody mentioned the obvious solution, which is to use scaling instead of modulo? int j = ((long long)rand() * n) / RAND_MAX; The cast is necessary to avoid overflow in case `RAND_MAX` exceeds `INT_MAX / n`.
Setting aside the fact that /u/Neui is wrong about floating point: there is no way to do that. The obvious answer is “use variables”, but even then the compiler might notice that their values do not change and evaluate the expression at compile time (constant propagation followed by constant folding and dead code elimination). You can *probably* work around that by initializing the variables out of sight (in a different compilation unit) but even that is no guarantee, because the compiler might use an intermediate representation and perform optimizations at link time. EDIT: looks like /u/lorddimwit found a portable solution I hadn't thought of.
&gt; The author talks about how this could fail in the face of cross-compilation. The host machine is the one running the cross-compiler, compiling code for the target machine. Say the host machine truncates toward zero. The host machine's compiler compiled the cross compiler, and folded that constant expression into a constant, so now the cross compiler doesn't perform that check, it just has a "1" or a "0" there. I would argue that performing constant folding according to the host environment's rules rather than the target environment's rules is a bug.
&gt; It's right if you're insecure, you can do this: That makes absolutely no difference.
&gt; Executing commands like this is bad. A sneaky rm -rf ~/ might be in there! Sure, but there might also be a sneaky `rm -rf /` in the application itself. Do you inspect them all, or run them all in sandboxes that block and warn about suspicious behavior? Ultimately, you're going to have to [trust the developer](http://www.ece.cmu.edu/~ganger/712.fall02/papers/p761-thompson.pdf).
The processing is the same, but because download the file first, you had a chance to check the file, then you can make a decision to try or not. It is simple enough but that make someone insecure, so check everything as you can. 
See [my answer](/r/C_Programming/comments/6vkn1u/a_new_toy_for_building_c_program/dm20649/) to /u/Deltabeard.
At no point in this post or in Nore's documentation do you explain what Nore does or how to use it.
Don't refuse the world including __shell__ and __make__, boy, [Nore](https://github.com/junjiemars/nore) is open sourced.
See https://github.com/junjiemars/nore https://github.com/junjiemars/nore/master/README.md
Already read that, it explains nothing.
Not only does that sentence not make any sense at all, but I get the feeling that you did not understand what I wrote. There is clearly a huge language barrier here. What is your native language? Do you speak any other languages besides your native language and English?
Oh, it's so sad. There are an example at https://github.com/junjiemars/nore-hi And there a wiki at https://github.com/junjiemars/nore/wiki did you see that?
The wiki doesn't really explain anything either.
Another reason to use the `register` keyword is to indicate to the reader which variables are performance-sensitive. Also, it doesn't hurt aiding primitive compilers if your code might be compiled by such a compiler.
As pointed out by /u/Rhomboid, the string you wrote out was not null-terminated. As you've not initialized your buffer, you'll end up printing whatever stuff is in memory at that location after printing out the string. There's a couple of ways I can think of right now to handle this. First is to initialize the buffer: char buffer[256] = {0}; The other is to check how many chars have been read, and place the null terminator explicitly: ssize_t chars_read; char buffer[256]; chars_read = read(0, buffer, sizeof(buffer)); buffer[chars_read] = '\0'; --- Edit: in the above I'm assuming you're going to be printing out `buffer` with `printf` or similar. If you're going to be using `write`, you'll need to use the second method, and limit the amount of bytes you write, e.g. `write(STDOUT_FILENO, buffer, chars_read);`. Hope that makes it clearer.
What step had you already done, let me know.
None. As I told you, I have no idea what Nore is for, because neither this post nor the documentation say what it is for or how to use it once it's installed, so why would I install it? I *strongly* suggest that you get someone with better English and communication skills rewrite your documentation for you.
To be sure - but it's not worse than writing a device driver or a serial port handler. Something approximating the socket layer in Tcl that can be used in other languages ( much as Tk has been appropriated by many other languages ) might be a good thing. My experience is that asynchronous code is a taller hill for folks to climb than the complexities of epoll() and that using Tcl does not make that go away .
Oh, oh, oh, * You should not install it exactly. * If you need every documents about Nore then you go, IMO, the best way for you is waiting, just waiting ... * let me count your comments, ***5+***, and more than ***3h+***, but configure and run an Nore's example just less thant ***5s*** . Advice: don't wast your time 
Why would I “configure and run an [sic] Nore's [sic] example” when I still don't know what it's for, because after all those comments and hours that you complain about, you still refuse to tell me?
Did I told you that you should to configuration and run [Nore](https://github.com/junjiemars/nore)? &gt; I strongly suggest that you get someone with better English and communication skills to review our comments, **it's make sense?** In https://github.com/junjiemars/nore &gt; No More than a C building system for clang, gcc and msvc. Using [Nore](https://github.com/junjiemars/nore), it's easy to build C application that can be crossing various C compilers, just that. 
But then you'd have to have a flag for the host compiler saying "I am compiling a compiler for another architecture, use that architecture's rules" (really, just a flag disabling constant folding would be enough, but standard C requires constant expression evaluation at compile time).
The compiler already knows that it's compiling for another architecture.
&gt; Did I told you that you should to configuration and run Nore? Yes, repeatedly. Goodbye.
Right, but you'd need a flag for the host compiler so that when it compiles the cross compiler it uses the other architecture's folding rules. That's the source of the non-portability, that when the cross compiler is compiled, it's compiled as a program for the host architecture. 
No. Constant folding is performed by the cross-compiler. The compiler used to compile the cross-compiler should not matter. It is the cross-compiler's developer's responsibility to ensure that the cross-compiler performs constant folding correctly regardless of where and how it was built. If that means the cross-compiler has to emulate the target's ALU instead of using the host's, then so be it. (I see now that I misunderstood your previous comment)
↑buffer overflow vulnerability; must use `sizeof(buffer)-1` and/or bump the buffer size up to 257. Also need to check `chars_read`, which could be `&lt;0` if there’s an error.
Everyone’s talking about string termination (NUL … so hot right now), but unless it’s actually text, and you’re sure it’s text, you can just use `fwrite` to `stdout` as a substitute for `printf`ing a string. That allows you to use the exact same byte count you got from `read` (assuming no error → ≥0), without needing to bother with terminators.
&gt; It is the cross-compiler's developer's responsibility to ensure that the cross-compiler performs constant folding correctly regardless of where and how it was built. The cross-compiler will fold constants properly *in the generated code*. This constant was folded *inside the compiler's code* by the host compiler. The host compiler is under no obligation to do any different. That being said, it could lead to bugs, so the code for the cross-compiler should be written to account for it...and one of the ways of doing that would be to use a construction like the one I described above. The point of this article was specifically talking about how to work around this exact kind of issue.
Scanf isn't the best at scanning multiple things. Try using a loop to get your multiple inputs. 
The `read` is actually OK buffer wise, it won't overflow. You're right about checking `chars_read`, but people in here don't tend to put error checking in small example snippets. Setting the null terminator is actually where it could potentially overflow, assuming `chars_read` is 256. The easiest way to handle that is to use `sizeof(buffer)-1` in the read though as you have pointed out.
&gt; but when I wrote it out it had a lot of weird symbols Kinda implies the OP's handling as strings. Agree on `fwrite` (or just `write`).
I'm just giving him a general overview. He's very obviously a beginner. And I didn't wanna confuse him more. And in my comment prompt I used Ctrl-d to end never ending loops. 
not sure why are you pushing something managed like tcl here tcl interpreter will just call bsd socket api if it provides network io to its users and will face just the same problems (please read my comments to the other guy)
Yeah, I was talking about the NUL store buffer-overflowing on one end or the other, not the `read`.
&gt; The cross-compiler will fold constants properly in the generated code. That's not constant folding. Constant folding occurs at compile time, *before* the code is generated. &gt; This constant was folded inside the compiler's code by the host compiler. That makes no sense. The host's compiler never saw that code. Constant folding is the cross-compiler figuring out what the result of the expression would be *if it was executed by the target, according to the target's rules* and then replacing the expression by that result to avoid performing that computation (with constant inputs and a constant output) at run time.
Stop spamming the subreddit with your project every week. Don't post this again unless there is a major change in the project.
&gt;"C like" &gt;Features: "Object Orientation" Fuck off
When I said "in the generated code" I meant that when it compiled code for the target architecture, it would fold things appropriately during the compile phase, sorry. I wasn't clear. &gt;That makes no sense. The host's compiler never saw that code. The host compiler saw the code for the cross compiler. When it compiled the cross-compiler *as a program targeting the host* it folded `-13/5 == -2` *according to the host's rules*. Therefore the cross-compiler has in its code for `Arith_div` not `-13/5 == -2` but just a `1` or a `0` that reflects *the host's folding rules*. Then, when the compiler invoked `Arith_div` while it's running, it will assume that the target architecture rounds/truncates the same way as the *host*, which may or may not be true. This is all because *when the cross-compiler was compiled by the host compiler, the host compiler folded that constant expression*. That's what makes the example code non-portable, and why when writing a compiler or something that relies on the exact rounding/truncation semantics, you have to do stuff like I showed above. If the cross-compiler were written like the original example *it would be non portable* because it would generate different code depending on where it was compiled. That was the point of the book, that to be truly portable you have to be aware of subtleties like this.
Understood
&gt; When it compiled the cross-compiler as a program targeting the host it folded -13/5 == -2 according to the host's rules. The host's compiler never sees `-13 / 5`. Only the cross-compiler sees this, and it evaluates it according to the target's rules.
:)
&gt; Only the cross-compiler sees this, and it evaluates it according to the target's rules. You *hope* it does. The book is talking about subtle compatibility issues in seemingly innocuous C constructs. Having found a copy of the book in question, here's the problem statement: &gt; The -13/5 == -2 test used in Arith_div and Arith_mod works **as long as the compiler used to compile arith.c does arithmetic the same way as Arith_div and Arith_mod do when they are called**. This condition might not hold, for example, if arith.c were compiled by a cross-compiler that runs on machine X and generates code for machine Y. This implies that the author of the problem assumes that the compiler doesn't or might not exactly emulate the target architecture's semantics when evaluating constant expressions at compile time. Considering the book was written in 1997 and GCC's documentation for GCC 2.95 (released two years later in 1999) says that it is only "now" possible to cross-compile to different machines with different floating point representations, etc, I would imagine that the author's statement made sense at the time. As a further example, Niklaus Wirth specifically didn't do constant folding in most versions of the Oberon system's compiler, precisely to avoid this sort of problem, and also prevent arithmetic errors during compilation (overflow, divide by zero, etc). More importantly, considering the book is talking about how to write portable code, and highlight subtle cross-platform compatibility issues...and considering that this is a subtle cross-platform compatibility issue...I think it makes pretty good sense in context that the author didn't assume that the cross-compiler code would "get it right."
&gt; &gt; Only the cross-compiler sees this, and it evaluates it according to the target's rules. &gt; You hope it does. I started this conversation by stating that *I would consider it a bug if it didn't*. So yes, I hope it does. And you are terminally confused.
Curl?
I literally quoted the book where he documents the assumption that the cross compiler is potentially generating invalid code (which, yes, would be a bug, nobody's saying it isn't) and gave a contemporaneous example of a compiler that had documented itself as previously generating that exact kind of code. Considering the book is about subtle portability issues and the question was about a subtle portability issue that could realistically arise when writing a cross compiler, I think that everything I said was fairly reasonable. I'm not saying cross compilers *shouldn't* follow the folding rules of the target architecture, I'm saying that *in the context of the question*, he assumes that at least one of them isn't. There's no need to be rude. 
Press Ctrl+D to send EOF. You can also press Ctrl+C to exit the program entirely.
Wow thank you, sorry for being dumb
No need to apologise.
So, you want to implement an algorythm and you already have C++/C# examples. Just follow their logic and implement them. If this is not enough then check out existing crypto libs, i.e. openssl/libressl/many others. Crypting is CPU-expensive, so like 90% of them are implemented in C (or asm, which would be not very simple for you). Use can use these libs themselfs if you just need a hash and have no need in strictly implementing everything.
Here is an [implementation of SHA1](https://github.com/fuzxxl/digest/blob/master/sha1.c) I wrote a while ago. You can use it if you like.
I can't think of anything in a hash algorithm that intrinsically requires object-oriented programming or other C++ features. I'm guessing that the C++ implementation would be very easy to port to C.
I think this sub needs a 'bot that reformats code into some standard style. Also, main() needs to be declared as returning int. Then it needs to actually return an int. #include&lt;stdio.h&gt; int main() { long nc; nc=0; while (getchar() != EOF) nc++; printf("%ld\n",nc); return 0; } Now that the code is readable, I can see that this sets the "number of characters" variable **nc** to zero, and then goes into a loop, reading one character at a time from stdin, and incrementing the counter. The loop exits when it reaches end-of-file and then it prints the number of characters to stdout.
Macro expansion happens in isolation so that what I suspect is happening. I can't tell you the exact sequence though. 
Because the level of difficulty is a lot less than in, say, C
I have a reading disability; so, if code isn't written in a very specific way, I cannot read it (literally), it just looks like jibberish. :) C++ is particularly notorious in that respect, since a lot of people write messy C++ code.
Well, a big problem I find with a lot of the examples, is that I have a reading disability, so if the code isn't written with spaces and double spaces in the right spaces, I have a nearly impossible time reading it. C++ makes it even more difficult, since I don't have anything more than a very, very basic understand of C++. And by basic understanding, I know how to use constructors and destructors, that's it. I will be doing a course on C++ later in the year... but, that doesn't help me now, sadly. :/ But, the major issue is... I don't understand SHA1, and every example/description I've seen explain it in terms I'm not familiar with... basically, I need a Windows API SHA1 explained to me like I'm 5. :P
Thanks! I really like the way you code, it's very clean and not messy. I can actually read it, which is rare! However, out of context, I'm not even sure how I would use your code; or apply it. Like, what does sha1_block() do or how is it used? What does sha1_final() do in comparison? Basically, I need to take a websocket key like this: Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== Concat 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 to the end of it, hash it, and return the result in its own Sec-WebSocket-Key: XXX Basically, this https://en.wikipedia.org/wiki/WebSocket I have the server written, I have the client written, in normal sockets everything works perfectly, but this SHA1 handshake, I feel it's beyond my natural scope of what I understand. A big part of the problem I'm having is... I simply don't understand encryption, at all, or how to use it... 
**WebSocket** WebSocket is a computer communications protocol, providing full-duplex communication channels over a single TCP connection. The WebSocket protocol was standardized by the IETF as RFC 6455 in 2011, and the WebSocket API in Web IDL is being standardized by the W3C. WebSocket is designed to be implemented in web browsers and web servers, but it can be used by any client or server application. The WebSocket Protocol is an independent TCP-based protocol. Its only relationship to HTTP is that its handshake is interpreted by HTTP servers as an Upgrade request. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.26
Then get sued by the FSF* Anyone serious would just use LLVM, like dozens of other languages already have.
Thanks, bot, but I already know THAT part. :D Now, if you could use your AI to explain it like I'm 5 on how to handshake a WebSocket connection, including the SHA1 hash key, I'd be happy as a duck. :P
Learn to use a pretty printer or reformatter to force code to be formatted in a way that is accessible to you.
That might be something that's useful. I'm not sure why I haven't thought of that. Thanks. :D
🙂 Happy to help.
Why would the FSF sue? I don't know much about this stuff. 
I am sharing this at work. I am not sure. I see why GCC claims it does not work, but honesty, am going to need to read the spec on a computer. Hopefully this comment helps me remember to start the debate later, we love stuff like this.
Sadly it's an desktop application desktop built with JavaScript/Electron. Even if the user interface seems great, I don't want to blow up my CPU/memory usage just to edit markdown files...
No.
You must have made some mistake. I have the K&amp;R book and I am able to execute the programs. 
Can you elaborate on that?
&gt; I think that everything I said was fairly reasonable. You claimed that the host compiler performs constant folding in the program compiled by the cross-compiler. That's complete nonsense. You conveniently failed to address that when I pointed it out, instead switching to a different topic. I started by asserting that “if X does Y, then I think that's a bug” and your response was “but you can't assume that X doesn't do Y”, which is strictly true but completely beside the point. The host compiler's behavior is also completely beside the point. The cross-compiler must be written in such a way that it evaluates expressions according to the target system's rules when performing constant folding, regardless of the host system's rules. The host compiler does not know that's it's compiling a compiler, much less a cross-compiler, and there should be no need to pass special flags to it. I don't see the value in bringing GCC into the argument either, even if it is to point out that GCC was a heap of dung at the time (and I'm not convinced that it isn't still a heap of dung).
1. Don't use SHA1. 2. Don't write your own. I'm sure whichever programming environment you're using already has a working implementation of SHA256 or SHA512. Use that instead.
I wouldn't use SHA# anything if I had the choice. I'm not interested in using any of kind encryption at all.... The only reason I need to know is because in order to use a WebSocket to connect from a HTML5 client to my server (written in C), my server has to take the a key from the header file the client sends, hash it with SHA1 and the magic number, and return the hashed key to the HTML5 client for the connection to be completed. Outside of completing this handshake process; the encryption API for Windows is the only thing stopping me, because I don't understand the process, nobody explains it clearly, and all the tutorial code is either messily written or not at all explained. :/ 
nice find, it's undocumented by the C spec afaik but I could be wrong. if you were writing an implementation I reckon support it, perhaps issue a warning as well depending on the verbosity level. (clang could take it a step further in that regard) if you were considering using it in your software, I'd reckon find another way to do it -- even if it were formally supported in the documentation, you'll probably want *real* support from compilers that reject it somewhere down the line (or even GCC right now) and realistically it is kind of a flaky construct. :p
`sha1_block()` absorbs one (64 byte I think) block of input into the `struct sha1_state`. `sha1_final()` takes the last block of input, applies the padding mandated by the SHA1 standard and then stores the hash in `d` if I recall correctly (was a long time ago).
Removed because this is unrelated to the C programming language.
&gt; I wouldn't use SHA# anything if I had the choice. I'm not interested in using any of kind encryption at all.... The various SHA algorithms are message digests (aka hashes), not ciphers. &gt; The only reason I need to know is because in order to use a WebSocket to connect from a HTML5 client to my server (written in C), my server has to take the a key from the header file the client sends, hash it with SHA1 and the magic number, and return the hashed key to the HTML5 client for the connection to be completed. Are you saying that the client is outside your control? If not, you should switch to SHA256 or SHA512. &gt; Outside of completing this handshake process; the encryption API for Windows is the only thing stopping me, because I don't understand the process, nobody explains it clearly, and all the tutorial code is either messily written or not at all explained. :/ I'm not familiar with the Windows crypto API, but every SHA implementation I've seen works in the same manner. Here's what it would look like with OpenSSL: SHA_CTX ctx; uint8_t digest[20]; SHA1_Init(&amp;ctx); SHA1_Update(&amp;ctx, data, len); /* keep calling SHA1_Update() with the rest of your data */ SHA1_Final(digest, &amp;ctx); All that changes from one implementation to another is the name of the functions and whether the initializer returns a pointer to a context or initializes a context that you allocated yourself. Note that the size of `digest` will vary depending on the algorithm used (20 bytes for SHA1, 32 bytes for SHA256, 64 bytes for SHA512...) In your case, you would probably call `SHA1_Update()` twice, once with the key and once with what you call the magic number (I can't tell from context if it's a constant or a nonce), although not necessarily in that order. This is exactly equivalent to first concatenating the key and the magic number and then calling `SHA1_Update()` once with the result; in other words, SHA1_Update(&amp;ctx, "foo", 3); SHA1_Update(&amp;ctx, "bar", 3); produces the exact same result as SHA1_Update(&amp;ctx, "foobar", 6); If the protocol is text-based, you will probably have to encode the digest either in hex or in base 64.
The client code is out of my control, it's an export from an app engine to HTML5 code. So, while I have control over the script within the engine, I have none over the HTML5 output or how it uses websockets. Ultimately, I have to do this: https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake The equivalent Windows API functions to what you posted that I've discovered so far are: CryptAcquireContext, CryptCreateHash, and CryptHashData. I think... I might have it working to the point of doing the hash, but I haven't figured out the Base64 part. :) 
**WebSocket: Protocol handshake** To establish a WebSocket connection, the client sends a WebSocket handshake request, for which the server returns a WebSocket handshake response, as shown in the example below. Client request (just like in HTTP, each line ends with \r\n and there must be an extra blank line at the end): Server response: The handshake resembles HTTP in allowing servers to handle HTTP connections as well as WebSocket connections on the same port. Once the connection is established, communication switches to a bidirectional binary protocol which doesn't conform to the HTTP protocol. In addition to Upgrade headers, the client sends a Sec-WebSocket-Key header containing base64-encoded random bytes, and the server replies with a hash of the key in the Sec-WebSocket-Accept header. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.26
&gt; I haven't figured out the Base64 part. :) [CryptBinaryToString()](https://msdn.microsoft.com/en-us/library/windows/desktop/aa379887%28v%3dvs.85%29.aspx)
Generally variables with a global scope (external linkage in C) is considered bad practice. There is no reason to declare other variables in a .h file either. https://en.wikipedia.org/wiki/Global_variable
**Global variable** In computer programming, a global variable is a variable with global scope, meaning that it is visible (hence accessible) throughout the program, unless shadowed. The set of all global variables is known as the global environment or global state. In compiled languages, global variables are generally static variables, whose extent (lifetime) is the entire runtime of the program, though in interpreted languages (including command-line interpreters), global variables are generally dynamically allocated when declared, since they are not known ahead of time. In some languages, all variables are global, or global by default, while in most modern languages variables have limited scope, generally lexical scope, though global variables are often available by declaring a variable at the top level of the program. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.26
Simple rule: if it's only used in a single compilation unit (.c file), leave it there. If it's used in several compilation units, declare it in a header which they all include. Note that variables should be *declared* (with the `extern` storage-class specifier) in the header and *defined* (without a storage-class specifier) in exactly one compilation unit. Otherwise, each compilation unit that includes the header will get its own separate variable with the same name and type.
I found this at page 29 in your linked document (emphasis by me): &gt; 4\. Preprocessing directives are executed, macro invocations are expanded, and_Pragma unary operator expressions are executed. If a character sequence that matches the syntax of a universal character name is produced by token concatenation (6.10.3.3), the behavior is undefined. **A `#include` preprocessing directive causes the named header or source file to be processed from phase 1 through phase 4,** recursively. All preprocessing directives are then deleted And in phase 3: &gt; 3\. The source file is decomposed into preprocessing tokens and sequences of white-space characters (including comments). **A source file shall not end in a partial preprocessing token or in a partial comment.** Each comment is replaced by one space character. New-line characters are retained. Whether each nonempty sequence of white-space characters other than new-line is retained or replaced by one space character is implementation-defined. So it looks like `gcc` behavior is correct. Since it says "preprocessing token", i'd guess that normal C code wouldn't be affected.
However, if you want a global variable, it should be declared in the header file as extern: /* in foo.h */ extern int my_variable; And should be defined in exactly one source file: /* in foo.c */ int my_variable = 0; Many platforms also accept if you define the same variable without an initializer in multiple translation units (e.g. by putting the definition in a header file) but I recommend you to not rely on this behaviour as it is not mandated by the C standard. Note that global variables are not *per se* a bad thing. As with every tool C provides, they have quite a few good use cases.
Thanks! so imagine I also have a file 'boob.c' that uses 'my_variable'. If the global variable is defined already in 'foo.c' how do I get to use it in 'boob.c'?
You need to declare it: extern int my_variable; This tells the compiler: `my_variable` is a global variable of type `int` that is declared somewhere in the program. As I said above, typically you put the declaration into a header file and `#include` the header file: /* in foo.h */ extern int my_variable; /* in boob.c */ #include "foo.h" The `#include "foo.h"` directive tells the preprocessor to dump the content of the file `foo.h` into the file `boob.c` right there. You can watch what the preprocessor does by running the C compiler with the flag `-E`.
I''ll comment on your [memmove.h](https://github.com/jon-nimrod/42-libft/blob/master/libc_functions/ft_memmove.c). - Your naming scheme is weird. First of, the parameters dont match `man memmove`. But even then you do `dst → dest`, but `src → s`. - There is no need to split declaration and initialisation of variables. That is a very oldschool style. (not your fault). - As `i` is an int, can this function not copy more than 2^31 bytes at a time? - Why do you do `*(dest + len)` instead of the clearer `dest[len]`? - What is the reason behind the parenthesis in `return (dest)`? In C++ that will inhibit RVO. - I don't like your whitespace. - Finally comparing `src &lt; dest` is undefined behaviour if the two pointers come from separately allocated objects. ~~Thus `memmove` cannot be written in C to begin with!~~ &gt; We are simply not allowed to. That is bullshit. Scrap this course and do a different one. --- Some more comments on [ft_lstnew](https://github.com/jon-nimrod/42-libft/blob/master/bonus_functions/ft_lstnew.c). - Why does this function return a `t_list*` instead of a plain `t_list`? - `if (!(list = (t_list *)malloc(sizeof(list))))` ← You have a serious bug here. Since you crammed so much in one line it is very hard to spot. Why do you cast the return value of malloc here? - How to null a structure: `*list = (t_list){0}`. - `if (!(list-&gt;content = malloc(content_size)))` may fail for `content_size == 0`. Also, no cast? - Line 30: Why do you reassign the value? You have much to learn, young padawan.
thanks. would it still be valid if 'my_variable' if instead of being declared in 'foo.h' and 'foo.c', we declared it in 'main.h' as: extern int my_variable; and defined it in 'main.c' as: int my_variable = 0; To access 'my_variable' from boob.c we would just have to #include "main.h". Does this make sense?
Thanks! I'll see what I can do with this all! :)
Yes! Exactly right.
I blame OOP for the hatred of all things global. OOP is my scapegoat for all the world's ills, though.
Mine too. Let's start /r/justnooop.
EOF might count as a preprocessing token.
You only need one resource to really get started with C: *The C Programming Language*, by Kerninghan &amp; Ritchie. It's clear, concise, and written by the stewards of C itself, one of whom is no longer with us. This book is such a mainstay of software culture that many developers simply refer to it as "K&amp;R", after its authors' last initials. I read it once a year even if I'm not writing any C, just to remind myself what great technical writing looks like. K&amp;R is not necessarily an easy book to read. It's concise because it is dense with knowledge, but that makes it perfect for self-education, because you can re-read the first chapter a dozen times and still learn something new each time. Other books that shaped my career: Clean Code, The Design of Everyday Things, Game Programming Patterns, and Ruby Under a Microscope (being written in C, Ruby is a great resource for learning about how to push C, and by extension computing, to its limits). Welcome to the world of programming, and remember: Everything you see on the screen is an illusion! C is the closest we get in modern times to talking directly to the hardware, a privilege quite lost to the newest generation of framework programmers (for better or worse–no judgment here!). Enjoy it, respect it, explore it!
I would subscribe to it!
Genius! Nooope! Trademark it. I'll have graphics mock up a logo. We'll be on rising within a week, I'm sure.
Give me a moment.
About memmove. - I'm using the prototype of http://www.unix.com/man-page/osx/3/memmove/ as we work on OSX at school and I'm currently working from home on Linux, so many of the prototypes differ. - I'm aware about splitting declaration and initialization, unfortunately it's one of the directives I must follow. The same applies with the parenthesis in the returns. - It should be an unsigned int, my bad. - To me *(dest + len) is clearer than dest[len]. - What are you referring to by whitespace here? - Not sure I understand here. Separately allocated objects? - Scrapping the course would be a bad decision considering my current finances. Even if it's not optimal, the environment is stimulating, and I'm learning stuff. For now it will have to do. About ft_lstnew. - The function returns the pointer to the first element of the list. Is it wrong somehow? - Should it be sizeof(t_list *) ? If I don't cast the return of malloc, wouldn't malloc return a void * or make an implicit cast ? - Well my ft_memcpy doesn't allocate memory so I'm doing it first and then assigning the value, is it wrong ? I'm really not comfy at all with linked list at the moment unfortunately.
Thanks a lot! I will definitely take a look at all those books, and I just noticed the resources section on the right side of this sub that mentions it :)
Ok, I was on board with you, but what do you mean by this: &gt;Finally comparing `src &lt; dest` is undefined behaviour if the two pointers come from separately allocated objects. Thus `memmove` cannot be written in C to begin with! Are you suggesting that you can't compare the values of two pointers? And that memmove can't be written in C? Both of those statements are completely wrong. In the first, you'd be right if you try to compare the pointers directly (at least as far as the compiler complaining), so you usually cast it to a native "valueless" type. The underlying data is unchanged, but that type size varies by platform so you cast to unsigned pointer, uintptr_t. Memmove is easily implemented in C. See here for an implementation and the top comment has links to other implementations, the first being Apple's: https://stackoverflow.com/questions/13339582/why-is-linux-memmove-implemented-the-way-it-is
Thanks! I should have paid more attention to the translation phases.
42 in Fremont?
Well unfortunately I'm french so I'm in the Paris campus, but yeah, that's the one.
Try them both for an hour or so and see which you like.
Ironically enough, the new "you're not a real man unless you program in x" language is now c. Some of these subreddits and pop icons (Linus for example) have become a bit too zeleous in my opinion, i'm glad there are still programmers who can hold such a pragmatic view. TLDW: C is a great language but use the right tool for the job and don't be theological about your decisions.
You are right, going via integer types helps. I just checked dietlibc and they also do the incorrect pointer comparison. Other implementations have an aliasing issue… Furthermore, I found the original [paper](https://c9x.me/compile/bib/ubc.pdf) which made me think that `memmove` was unimplementable. But it doesn't say that. Now I am wondering, where I got that idea.
&gt; What are you referring to by whitespace here? Indentation and everything. &gt; Not sure I understand here. Separately allocated objects? I was kinda wrong. See the other discussion. &gt; Should it be sizeof(t_list *) ? If I don't cast the return of malloc, wouldn't malloc return a void * or make an implicit cast? You should allocate as many bytes as the object takes to which you are pointing. That leaves you with two options: list = malloc(sizeof(t_list)) or list = malloc(sizeof(*list)) The cast here is implicit. See http://c-faq.com/malloc/mallocnocast.html &gt; Well my ft_memcpy doesn't allocate memory so I'm doing it first and then assigning the value, is it wrong ? Not wrong, just unnecessary. `list-&gt;content` already points to valid memory (which you allocated in line 28). 
And yet they load their codebases with singletons. 
Well, the pointer comparison is in no way incorrect. Pointers are just numbers, you can do whatever crazy shit you want with them. It's not until you dereference them, or try to let the compiler figure out what you want to do by writing esoteric code, that all hell can break loose. I didn't read that entire paper, but it looks like they're focusing on what's available in the language versus what "mathematically correct, well defined" C is. There is no undefined behavior in comparing two pointers. If the value of one pointer is 0xA and the other is 0xDD452 then the left pointer is obviously smaller. Now, if you try to access the underlying data, there's no guarantee its valid memory. Not sure where the idea that memmove can't be implemented in C was, but both C and C++, by their design, are supposed to be able "implement" their standard libraries with the language itself. A given compiler / OS might provide a more optimized version of a given set of library functionality, but that's not required. In any case, I think the rest of your points are probably valid.
&gt; There is no undefined behavior in comparing two pointers. If the value of one pointer is 0xA and the other is 0xDD452 then the left pointer is obviously smaller. This wasn't always the case. On some architectures a pointer was split in segment + offset. Thus to skip a few instructions during comparison it was defined that, undefined behaviour happens when … &gt; Pointers that do not point to the same aggregate or union (nor just beyond the same array object) are compared using relational operators (6.5.8). ISO C11 Annex J.2 (p. 560)
Are you sure you are programming in C? This subreddit is for C only, please ask C++ and C# questions elsewhere.
In addition FUZxxl's comment, I'll give you the generic programming response: What happened when you tried it?
That doesn't seem to be undefined behavior in the language sense. That annex, at least where I'm looking at it on open-std.org is the section on portability issues. A little further up it also says that a the representation of pointer subtraction can't be represented by ptrdiff_t, which would make the type useless in all situations. It's a low level language so rather than pull down the majority of platforms to meet the need of an esoteric one, it's listed as a portability concern. I'm not seeing that as a valid "undefined" case. This is undefined: i = i++ + i++ + ++i; Pointer comparisons could present a portability issue, but if you're working on that platform, chances are you've rebuilt your libraries or are using a custom compiler. You are right that it's a real concern, though. I've never worked on a platform that represented pointers that way, but nothing says it can't exist.
Do what the video says, know C, but use a higher-level language when it's needed. Not just "use a higher level language".
&gt; A little further up it also says that a the representation of pointer subtraction can't be represented by ptrdiff_t, which would make the type useless in all situations. I think you have to read that as “[Behaviour is undefined if, …] the result of subtracting two pointers is not representable in an object of type ptrdiff_t”. Which, again makes sense if you consider the historic [8086]( https://en.wikipedia.org/wiki/Far_pointer) pointer model. &gt; That doesn't seem to be undefined behavior in the language sense. That annex, at least where I'm looking at it on open-std.org is the section on portability issues. […] &gt; Pointer comparisons could present a portability issue, but if you're working on that platform, chances are you've rebuilt your libraries or are using a custom compiler. A lot of problems in C are portability issues: The weird signedness of `char` (ASCII vs EBCDIC), the signed shifts (twos complement vs. sign bit), and also pointer comparisons. I think we can agree that this discussion is beyond any reasonable C implementation, nowadays. Most of the time pointer comparisons will just work. 
**Far pointer** In a segmented architecture computer, a far pointer is a pointer which includes a segment selector, making it possible to point to addresses outside of the default segment. Comparison and arithmetic on far pointers is problematic: there can be several different segment-offset address pairs pointing to one physical address. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.26
There was a time where we all said : If it can't be written in Fortran then it isn't worth doing. : 1981 The a pile of people ran around singing : Pascal is the new road to perfect code! : 1984 That was shorted lived and everyone got in line with : Everything seems to be written in C now and gee, it works, everywhere. : 1986 Then someone dropped acid and C++ was the rage for a little while along with oop me and oop you andoop this and oop that and we old C programmers just watched them as they tried to park their cars. Crooked. Repeatedly. Then again everything was abstract so they couldn't really instantiate a car nor a parking space and just overloaded the hell out of everything for a while. So we had to debug it. Then toss it. So now everything seems to be in C and it makes me happy. However I also can program COBOL and Lisp and ADA and Java and .... blah blah blah. 
Agreed. At this point, it's purely academic. It's not something the vast majority of the world will run into. It's definitely a fun problem. I like working with weird systems, but then again I actually kinda liked the PS3 SPU's :) Just too bad the GPU sucked.
&gt;So it looks like gcc behavior is correct Forgive me for being silly, but I don't understand how did you come to that conclusion. The first excerpt makes a distinction between header and source files (emphasis mine): &gt;the named **header or source** file to be processed And the second says (emphasis mine): &gt;A **source** file shall not end in a partial preprocessing token or in a partial comment In OP's example, the "partial preprocessing token" is at the end of the **header**, not at the end of the **source** file.
Honestly allot of oop stuff is silly. I dont get how people avoid C because "its not oop". Bitch, need exception handling? Setjmp anf longjmp. Need function overloading, va_args! Need classes/objects? Static variables and methods Need function overridding? Function pointers! All while being incredibly portable. 
Many thanks! 1 more question: Does the same procedure for simple variables applies to structures? I mean, for a struct my_struct would you have to declare it only once in the main.h file as 'extern struct my_struct' and define its body in the main.c file. Then, to access 'my_struct' from elsewhere in the code you would only have to #include "main.h". Is this correct?
Page 182 (emphasis by me): &gt; A preprocessing directive of the form &gt; &gt; # include " q-char-sequence " new-line &gt; &gt; causes the replacement of that directive by the entire contents of the ***source* file identified by the specified sequence between the `"` delimiters.** OP used `#include "test.h"`, and the spec talks about source file, so `test.h` is treated as a source file. Above the text in the spec for the `&lt;xyz&gt;` version talks about headers. Also, I've looked what a header exactly is, and I found this at the bottom of page 199: &gt; A header is not necessarily a source file, So a header might be a source file, but it might also not (eg. implemented in the compiler itself I could imagine)
minGW attempts to give you a Unix environment on Windows. I have seen quite a few post of people having trouble with minGW. Therefore, I would say that xcode/macOS will be easier to work with since macOS is Unix underneath and the compiler is native to the OS. 
Thank you. I'm convinced. You're right.
Note that especially when programming in C, “worked when I tried it” is a really dangerous way to do things due to the abundance of undefined behaviour which might just behave like you expected when you tried, but summons nasal dæmons in other situations.
Here's the strategy I take: control the things you can, write your code so it doesn't care about what you can't control, and then make everything explicit at the interfaces. In practice, that means that if you want to make sure your code can use a certain range of values, you pick a data type that can handle it. And if your code requires a certain data type size, use the `int*_t` typedefs. As for 2's complement and endianness, things you can't control ... your code should not care. It should work regardless of the representation of the values under the hood. With libraries, this strategy generally works very well. You kinda have to assume that the library works on whatever system you're targeting. But that only works internal to your program ... what if your software talks to the outside world, where endianness might matter? At the interfaces, you have to be more explicit. For example, that's where the macros `hton*` macros come into play. These will convert the endianness of your data to a canonical standard (big endian). In practice, all computers use 2's complement, so I'm OK with just assuming that and moving on. The same goes for IEEE representation of floating point numbers.
I thought everything is JavaScript today? :P
ooo ... vomit. I had to help a friend just yesterday with some js crap wherein jquery and all manner of crap was being used and I said "if this can't be prototyped in C then it can't be done" but ultimately with some hacking I was able to find where js has no damn clue if a string is a string or a number or a IEEE 754 double or some sort of array element or what. How the hell do people use that crap with no valid data types?
&gt; Is this even a thing with C? Is it possible to write my C code such that it fails to compile if an int, for example, doesn't map to a 4 byte little-endian 2s complement number? Yes, this happens all the time. The solution is to only expect from your types what is written in the respective standard. For example, ISO/IEC 9899:2011 (the C standard) specifies that an `int` has a range from at least &amp;minus;2¹⁵ &amp;minus; 1 to 2¹⁵ &amp;minus; 1. POSIX specifies two's complement and a range of at least &amp;minus;2³¹ to 2³¹ &amp;minus; 1, so you should not try to store larger numbers in an `int`. You should also try to always use appropriate types for the task at hand. For example, when dealing with object sizes and array indices, use the type `size_t` for your variables. When dealing with file sizes and offsets, use `off_t`, etc. etc. This alleviates many portability problems. &gt; I understand that I can alleviate some of my problems by using standard types like uint32_t and writing my code a certain way, but that won't catch everything. For example, what if I make use of a lib that doesn't use standard types?? Note that types like `short int`, `int`, and `long int` are also types mentioned in the standard. The header name `stdint.h` does not indicate that the types declared there are somehow more standard than others (whatever that means). I recommend you to avoid fixed-size types like `uint32_t` unless you are sure that you require a type exactly that large, no more, no less. Instead, use types like `uint_fast32_t` to give the platform some leeway in picking a larger type if that would be faster. &gt; For example, what if I make use of a lib that doesn't use standard types?? Then use the types specified by the library. &gt; I feel like I can only make code so portable. How do the pros deal with this (if it all)? Mostly, don't try to cut corners. Never assume that the platform can do more than what the documentation strictly says. Additionally, a combination of the approaches listed above, defensive programming (e.g. assuming only the least you need from interfaces you use) and build systems like the autotools that test for the concrete properties of the platform you program for. In very bad cases, a maze of `#ifdef` might be needed to specify different code paths for each platform. One thing you should definitely know: Never ever write code that depends on your platform's endianess. If you need a “byte swap” or something like this, you are most likely doing it wrong. Similarly, the functions `htons` and `htonl` are almost never used correctly. Instead, use code like this to read an integer from a buffer with defined byte order: uint32_t read_little32(unsigned char buf[4]) { return (buf[0] | buf[1] &lt;&lt; 8 | buf[2] &lt;&lt; 16 | buf[3] &lt;&lt; 24); } This does the right thing regardless of the endianess of your platform.
What other option do you have for frontend anyway
simple ... never work on web based projects .. ever. Life is better doing accounting software.
Fuck. Gonna quit my job tomorrow. :"D
&gt;but ultimately with some hacking I was able to find where js has no damn clue if a string is a string or a number or a IEEE 754 double or some sort of array element or what. Stringly typed languages are the best :P
Are those the only two options? Linux is a native C programming environment. Download VMWare Player/Fusion and choose a Linux distro. Ubuntu might be a good place to start if you're also new to Linux/Unix. Every Linux distro comes with gcc. Write your code in vi/nano/emacs and compile with "gcc -Wall". Debug with gdb. C and *nix go together like rice and beans.
If you want to be able to declare variables of type `struct my_struct`, you must include the declaration of `my_struct` in the header file: /* my_struct.h */ struct my_struct { /* Struct members here */ }; /* main.c */ int main() { struct my_struct x; do_something_with(x); /* etc. */ }
Honestly, the comments in this thread are fucking appalling. I would hire you over any of the first-few-level replies you've had. These people shouldn't use a browser, much less give programming advice. Good job, and if this is from starting in July it is absolutely amazing.
The following works: struct Word { int(*length)(void); }; static int length(void) { return 42; } struct Word* word_ctor(struct Word* self) { self-&gt;length = length; return self; } int main(void) { struct Word word; word_ctor(&amp;word); int print = word.length(); } 
I hate any other damn thing that pretends to "know" what data is.
I’m a C programmer. I’m fluent in C. Pointers are natural to me. They are my friends. High level languages are toys I’m sometimes forced to play with. Assembler was great, but in my day I’ve seen so much hardware become obsolete, it’s mostly not worth it anymore. I have interviewed JAVA programmers who could not tell me the largest binary integer that can be held as a bit string of n bits. Who raised these people? I have met programmers who have never seen a control break, because every time they want to do something, they make another pass through a list – instead of computing ten things in one pass. I meet programmers who are math avoiders. What’s it all coming to? Yes yes. You have so much computing power that you waste it trying to dumb things down or simply getting from here to there. When I was coming up we dreamed of far less power than this and vowed that, if we had it, we’d move mountains. Well that’s what I do, and that’s why I need C. [Edit: To all you down-voters: What a bunch of pussies!]
&gt;Need classes/objects? Static variables and methods wat
C is great. I wanted a tool 'lslr' that would follow symlink chains, e.g. $ lslr /usr/bin/vi /usr/bin/vi -&gt; /etc/alternatives/vi -&gt; /usr/bin/vim.basic namei does it, but not in that format. readlink and realpath show the end of the chain, but not the rest. Since namei does it, it was a matter of formatting the output. Script to the rescue namei -v $1 | grep '^[fl]' | cut -d' ' -f 2- | awk '{ printf("%s -&gt; ", $NF)}' | head -c-3 | awk '{print}' It works, so I then tried throwing * globs at it. It was horribly slow. I could watch the lines go by one by one. I then [rewrote the whole thing in C.](https://pastebin.com/iSiBig2v) Much faster. The entire directory spits out before I can see it. It's simple to build too. Just save the file as lslr.c and then type 'make lslr'. I also found it easier to reason about when writing it than trying to glue strings together with awk and friends. 
Thanks for commenting. In hindsight, it likely didn’t compile because I didn’t have the basic libraries or hadn’t configured them right. I was compiling with LLVM (Clang) on Windows and had zero experience. Good to know it’s compiling for others—when I get back to C I’ll pick up the K&amp;R book again. 
You sound like a real man and a real programmer.
To be fair, languages like Java, C#, Python, etc; are far more popular nowadays than C (at least I rarely see people looking for C programmers). So you're more likely to find bad Java programmers than C programmers. That doesn't really say anything about the language itself. Dismissing them by calling them `toy languages` is really foolish. That's the whole point of the video. If you don't have to worry about the low level stuff, why not apply a language that speeds up the development of the product?
you need a second variable to count to `n`. `n &lt; n+1` is always true till n+1 overflows, if you'll think about it carefully ...
Yeah, right tool for the job. I've seen this go both ways. I saw a project on reddit the other day that was using an arduino and an rpi, no doubt python for God knows what on the rpi and C on the arduino. For its functionality it should have only required a micro running C. It may have required more work but that would be paid back in a much simpler design, speed and reliability. Rapid prototyping is great as long as the design moves passed that phase.
Very nice. Well, you’re not wrong.
I need C because I'm tired of feeling *distant from my business domain* for enjoying a little pointer arithmetic in my code.
C is by far the most portable programming language in existence, there are compilers for literally every architecture and OS out there. Anyway, stick to the standard library, seriously do not use ANYTHING not part of the C standard library, even limit your usage of POSIX functions.
Well, if you had a struct called `word` with `length` as a variable, and you decided to call your variable to hold the length `print` it would, but you'd have to add a type in front of the `print` variable.
Duude, Xcode hands down, it's an actual IDE... good luck debugging with notepad++.
thanks!
If it doesn't HAVE to be public, declare it in the source. Yes, even structs. simply typedef them in the header.
"portable" means writing your code so it still works even if `int` is a 16-bit ones complement big endian, or a 64-bit mixed endian, or anything else
First off, I'll say I'm still a student of computer science. What I have seen in my limited experience and involvement with other coders, those of us who have a good understanding of C and its low level concepts, often have a better idea of how a program runs, and optimizations that can increase performance than those with only high level knowledge. That's why, even if I don't always use C, I'm still grateful to have been taught it, because of the knowledge that you acquire while learning to code in it.
you can create "classes" in C using static variables and methodes (can't be "seen" outside the file). then take a step further with function pointers you can do templating with standard algorithms like quick sort. 
does that shit even make sense to u lol
it'll click for ya eventually, as u put ur attention into gettin it to work :]
Y... you're not hiring, are you?...
First off, you have: scanf("%d", &amp;n); x = n; for(n=0; ...) But you can just scanf directly to `x`. Secondly, you already have a variable that counts the position. Print the column headers above the for loop and the you can print `n` and `r` in the loop. 
Bottom line is "value of an array variable is the address of the first element" so studentarray = &amp;studentarray[0], in other words studentarray is a pointer. Given that fact, I don't understand why you are declaring your variables as pointers in main. By default, C passes variables by value, i.e. the function gets an independent copy of value you send it. If you want your program to manipulate the actual data you pass into a function and not manipulate a copy of the data, you have to pass by reference, meaning instead of your function argument being a float, you pass a pointer to a float. Seems like you are on the right track, but you're declaring more floats inside your for loop when you have already passed references to the data you need to work on. Just use them. For example, something like: scanf("%f %f %f", &amp;testOneMarks[i], &amp;testTwoMarks[i], &amp;testThreeMarks[i]); Sorry, but I'm not going to debug your whole source like others might do. I feel like that is the way we learn. Plus your code is a little hard to follow on a Saturday morning, and it seems like you need a little more practical explanation of pointer usage...so I hope this helps. https://www.le.ac.uk/users/rjm1/cotter/page_59.htm
You should use `size_t` rather than `unsigned int`. I can see why you would split declaration and initialization since it is old style, but parentheses in return statements are totally useless. As long as you know it and don't use it for your own code it's no problem though
yea, remove all the pointer operators and address operators from the Array identifiers (including in the declarations). Additionally you can remove float averageMark; float mark1; float mark2; float mark3; out of the loop since these variables do not need to be declared each iteration. Other than that, you should be fine.
C is a good language but it's almost impossible to write safe code with it unfortunately. I think it's good for embedded, performance, or just as a fun language that feels "close to the metal", but security is the one place it completely fails.
Obviously none of those things are replacements for those features
It's like you decided to be the stereotype from the video
Javascript is a really nice and elegant language. It's quite fast too. Probably the fastest and most exotic language in such common usage. Before I learnt it I thought it was some shitty, regular, imperative language, but turns out it's very abstract and functionally powerful.
It's 2017, programmers are having much more issues with bugs and code-correctness than algorithm performance. The point made toward the end of the video was that performance doesn't really matter so much anymore and programmers don't really need to think about those things. 
I'm confused at your examples. What benefits does this bring? Does it support constructors and destructors?
Yes they are, you can do the exact same thing. there's a reason C++ started out as a cross compiler for C. 
Thanks for your reply, I didn't expect a full debug at all. Just a push in the right direction which you definitely helped with, sorry about the horrible code, C is by no stretch of the imagination my primary language (as I'm sure you were able to tell). Thanks again for the help.
They do the exact same thing in a much more inelegant and fragile way that is a lot less useful. Use the right tool for a job, a hammer with a nail taped to it is not a nail gun.
I'm glad it was helpful, i was just being grumpy. Code's not horrible, just tough for me to dissect this morning. As another bit of advice, this is where it becomes important to comment your code, so that other people understand what you're thinking when you implemented it. Hell, it even helps you when you come back to a piece of code you wrote and you can read your own comments. You may have researched the heck out of something when you first implemented a bit of code, but the details were lost after a while. Or you may have better grasped some element of programming style or technique in the intermediate time and wonder...what was I even trying to do here?
Agree completely. In this sort of mode though, one where I'd been trying multiple iterations of code and various things the code begins to look horrible and any commenting practice I try to maintain goes out the window... But I definitely agree comments are always beneficial especially when asking others for help. If you don't mind another question, I've managed to get the values for everything now by following your suggestions and reading up on pointers but in terms printing out the averages in the main function the averages return correctly in this line: printf("Averages are %f, %f, %f, %f \n", testAverageMarks[0], testAverageMarks[1], testAverageMarks[2], testAverageMarks[3]); But as soon as I try to print them out in the for loop I seem to only get what I assume are memory addresses. for (int i = 0; i &lt; 4; ++i) { printf("Average: %f", testAverageMarks[i]); printf("\n"); } 
Hey, thanks for pointing that out, I wasn't sure about this. Even when working with a variable representing a number (ie. ft_itoa) and not the "length" of an object?
Thanks for the kind words! I must say I'm enjoying it quite a lot so that definitely helps.
In your modified code, in your function, did you pass a pointer to testAverageMarks (pass by reference) or did you pass a copy (pass by value)? Pay attention to variable scope inside your function. Usually, you don't want to declare variable inside a function to have the same name as a variable in main, this can get confusing, and under the hood they are completely different data items with different memory addresses on different stack frames. So make sure the pointer variable you pass into your function is named something else. Alot of coders append a p or ptr to pointer variables to keep things straight. So, a pointer to testAverageMarks would become "float *ptestAverageMarks[]" or "float *ptrtestAverageMarks[]" in your function definition. Then in your function call, you would still use "&amp;testAverageMarks" for that argument.
The scope of the assignment is for the function to return an array of averages. So currently the way testAverageMarks gets its data is like this: float *testAverageMarks; testAverageMarks = readData(studentArray, testOneMarks, testTwoMarks, testThreeMarks); And the readData function looks like this: float * readData(char *studentArray[], float testOneMarks[], float testTwoMarks[], float testThreeMarks[]){ float averageTestResults[4]; /* More code here */ return averageTestResults; } So I'm not sure if this would classify as either passing by reference or by value.
Also, are you compiling with warnings enabled (i.e. "gcc -Wall")? This can help you catch alot of mistakes.
Maybe 'data hiding' would be a better description of that, in that case. Also, the whole point of templating is that it is done at compile time so it is safer and faster. Nobody is arguing that you can't do those things in C, just it's often uglier, slower and more dangerous than the direct C++ equivalent.
I'd say use `size_t` for indexing and length of arrays, `unsigned int` when you simply want an unsigned integer for calculations/other things
I agree it isn't great for security but on the other hand in a lot of cases the reason people use it is because it can do unsafe things in a fast manner.
True, I just feel like there is a lot of legacy code written in C that has caused so many security issues through the years
Though I'm primarily a C programmer, I do program JAVA. One of the most common errors I get in JAVA is Null Pointer Exception. Of course there are no pointers in JAVA, but at another level, pretty much everything's a pointer in JAVA. Just because they don't expose them doesn't mean they're not there. It just means that somebody who is not any brighter than you doesn't think that you're bright enough to handle them.
Since you haven't posted your most recent code, I can only give recommendations on what is here and the output you've told me. If you're getting different values for the same variable name, then that suggests some type of variable scope problem. If you've declared a variable, or a function parameter with the same name as a global variable, the local variable or argument takes precedence inside the function. https://www.tutorialspoint.com/cprogramming/c_scope_rules.htm
&gt; Is this even a thing with C? Is it possible to write my C code such that it fails to compile if an int, for example, doesn't map to a 4 byte little-endian 2s complement number? IMHO, this is the wrong interpretation of "portability". Remember that C was designed to overcome machine-specific programming like that. The goal for portability in C is that code you wrote for one machine will run on the next one you buy. With assembly, that isn't possible for reasons you touch upon: early computers had different word sizes, endianness, memory size, and number representations. The innovation of C is that if you have a 16-bit CPU where int is 16 bit wide, and your numbers are getting bigger than that, you can buy a 32-bit machine and run the exact same code! That kind of portability is unheard of in the realm of assembly language. Most C compilers, instead of guaranteeing a size for int, make it so that it's representation is whatever is natively the fastest on the given CPU. So when you're writing code, don't assume that an int is a certain size, just treat it as a natural number (and have your code check for overflow using INT_MAX and INT_MIN from limits.h). Then choose a platform that can deal with your problem size to run the code on. In the end, every program models the real world in some way. When you want a variable to represent something countable, use an int. In decades of programming C, I've hardly ever looked at a variable and said "I want this to be exactly 32 bit wide", because what numbers in real life are like that? And when I *do* want one of those, we have int32_t and the other types in stdint.h, which were added as an afterthought. Just my 2 cents. 
the numbers are stored in the array `num` afterward you grab all this number to obtain `min` and `max` in a similar loop you can process all this number to obtain `sum` Think with a paper and a pencil how you would do to calculate the sum of a list of a number written on a paper. 
Additionally, if you're only using a non-public variable in the one compilation unit where you define it, then make it static, to reduce the number of symbols exported by the compilation unit. 
I'm tired of removing your spam posts. You have been banned from this subreddit.
I just don't understand it unfortunately. I see how the for loop is counting up until the max but how would I have it "keep" each number it counts?
What's wrong with macOS? [it's literally a UNIX](https://unix.stackexchange.com/questions/1489/is-mac-os-x-unix)
Take a look at formal verification solutions such as Frama-C
Agreed, you can never have too many comments. Well you can and they might be annoying sometimes but they definitely help in a few years down the road and it's easier to ignore comments which are not really revelant but if they're not there at all things are not so clear. I'd rather there are too many comments than none.
Couldn't tell you, haven't owned a mac in like 10 years? Not gonna give advice on something I have no experience with.
In my opinion, when you're developing security software, security should be number one overall, which means that you must program in a language which enforces memory safety by design
Well just telling you that macOS is a UNIX, so OP does not need to run linux to have a UNIX experience macOS is just as much of a native C programming environment
I regularly do C dev work on macOS. A few things to remember: 1) it's a *BSD variant so lots of GNU-y references are less than useful 2) the man pages for libc reference can often lie -- link(2) lies about hard directory links; see https://jameshunt.us/writings/linking-dirs-in-macos.html Otherwise, if you don't need specific kernel facilities that are Linux only (like epoll) macOS is a great C dev environment 
Since `averageTestResults` is a local variable, it ceases to exist after the function it's declared in (`readData`) returns. Returning a pointer to it leads to [undefined behavior.](https://en.wikipedia.org/wiki/Undefined_behavior)
I think it's a good point that applies to end-user software that runs in OS environment. For baremetal applications and RTOS formal verification is IMO better as it provides a way not only to prove memory safety, but also check algorithms used by software.
To compute the average of a set of numbers, you need to know (1) how many numbers are in the set, and (2) the sum of all the numbers. So you don't have to "keep" each individual number; you just have to keep track of the sum as you add them all up.
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #define MAXN 1000 #define MIN 0 int main(void) { int n, r, i; int pos = 0; int minpos = 0; int max, min; int num[MAXN]; float sum = 0.0, average; printf("Enter an integer"); scanf("%d", &amp;n); srand(time(0)); printf("\n Pos | Val"); //setting up Pos/Val table for (i = 0; i&lt;n; i++) { r = (int)(((double)rand() / RAND_MAX) * 1000) + 1; printf("\n %3d | %3d", i + 1, r); num[i] = r; } printf("\n"); max = num[0]; //finding the maximum number i = 1; for (i = 1; i &lt; n; i++) { if (num[i] &gt; max) { max = num[i]; pos = i; } } min = num[0]; //finding the minimum number i = 1; for (i = 1; i &lt; n; i++) { if (num[i] &lt; min) { min = num[i]; minpos = i; } } printf("\nMax : %d | Pos : %d", max, pos + 1); //biggest number //while (1); printf("\nMin : %d | Pos : %d\n", min, minpos + 1); //smallest number average = AverageNum(num, 5); printf("The average of the table with random values is %f \n ", average); return 0; } int AverageNum(int table[], int tableLength) { float average = -1; for(int i=0; i&lt; tableLength; i++) { printf("Value %d is =&gt; %d \n", i, table[i]); average += table[i]; } return average / tableLength; } I tried to find a solution for you I hope this help you (y) Output: Enter an integer 5 Pos | Val 1 | 524 2 | 616 3 | 224 4 | 544 5 | 260 Max : 616 | Pos : 2 Min : 224 | Pos : 3 Value 0 is =&gt; 524 Value 1 is =&gt; 616 Value 2 is =&gt; 224 Value 3 is =&gt; 544 Value 4 is =&gt; 260 The average of the table with random values is 433.000000
I feel like an idiot. The new executable wasn't being generated, I had assumed that make would overwrite an existing file but that seems to not be the case. As soon as I deleted the old lrGraphTest binary the new one ran as expected with the updated code Does anyone know if there's a way to overwrite the executable on each build? It's strange as the static library is always overwritten. As a workaround I've created a build.sh in the test project cd ~/Development/C/AI/graph/build make cd ~/Development/C/AI/test/build rm lrGraphTest &amp;&amp; make &amp;&amp; ./lrGraphTest 
You have to calculate partial sum that is the sum of all number from 0 to k. With k taking all values from 0 to the total number. Hint: try to express the partial sum up to k in term of partial sum up to k-1 and of the number k. Eventually you should be able to keep track just a number which is the partial sum up to k.
Good luck on fillit!
The fopen call is relative to the current directory when you run your program, not relative to where your source code is. Make sure that when you run your code, it is from the working directory that contains the input_data directory.
Or relative to the last chdir call. 
 if ( insideFunction() ...
 if (insideFunction(TRUE)) {.... or if (insideFunction()) {....? 
insideFunction doesn't take any parameters, so the 1st one can't be right. The 2nd one will work
the second one doesn't compile with dcc, I tried if (insideFunction) {... but compiler says this will always evaluate to true
You might need to declare *insideFunction* first. What's the complete codefile look like including all your #include lines? do you have a .h header file too? if (insideFunction) {..} This always evaluates true because you're not calling a function here - that requires (). The name "insideFunction" without parentheses is actually a constant, whose value is the *address* of the function: **insideFunction** - this evaluates to the *address* of the function "insideFunction", which is non-zero and hence always true **insideFunction()** - this means *execute the code* at the address referred to by "insideFunction", which of course is the function body.
You reference a parent directory using "..". So if your executable is in program/exe, you want "../input_data/settings.txt"
&gt; the second one doesn't compile with dcc, It should. What is the error?
thank you for the explanation, does that mean neither are doing what I'm intending to do? I.e. int function () { If insideFunction returns TRUE, do A. If insideFunction returns FALSE, do B. }
too few arguments to function call, I had to put a single argument in it
If there are no arguments in the function definition, you don't need arguments in the function call. I just wrote this up: #include &lt;stdio.h&gt; #define TRUE 1 #define FALSE 0 void function(); int insideFunction(); int main() { function(); return 0; } void function() { if (insideFunction()) printf("True\n"); else printf("False\n"); } int insideFunction() { if (1) return TRUE; else return FALSE; } And it compiles fine with no warnings or errors, and runs as expected: :~ $ gcc -Wall -o func func.c :~ $ ./func True edit: alternatively: `insideFunction() == TRUE` also works
It does do what you intend if (insideFunction()) { /*do A;*/ } else { /*do B*/; } or, it may be clearer for you if you write it int result; result = insideFunction(); /* call the function and remember the answer */ if (result) /* see what the answer is */ { /*do A;*/ } else { /*do B*/; } 
If you want to find just sum and average of integers, then program is fairly simple, but i don't know why but i think that's not you want to know here.
That largely depends on the field you focus on. I have worked on a couple system software projects and there for example performance is all that matters. In other projects, say a front end application, it's hard to write something that won't perform on today's hardware, but if it's a game, performance again becomes a main factor. That's why I don't particularly like blanket statements like "Performance doesn't really matter", because they ignore the fact that there are cases where it does.
I typically use the 2-clause BSD license because let's face it: nobody is going to care about your code, so if you want people to use it, just let them do their thing.
Your readData function returns a pointer to characters that were declared locally in the function. This is bad news because it's **undefined behavior**. It might happen to work in this tiny example, but there's no guarantee that it'll do anything close to what you're expecting. (The memory used for variables declared in a function is fair game when the function is exited). What you could do instead is declare an array for your average test results in main and pass the array (which is really just a pointer) to your function. Strings in C are a bit tricky if you're used to other languages. Your studentArray is an array of pointers-to-char. It's a collection of 'references' to other memory locations where there could *theoretically* be a single character or a null-terminated sequence of characters. You never allocate any memory for these names of students (but you don't really use them anyway so w/e). So yeah just remember that there has to be some actual data somewhere that pointers are referring to. That's probably what's confusing you with these testOneMarks arrays which are arrays of pointer-to-float. The only 'real floats' in your program are declared inside the readData function. Again, it is **undefined behavior** to refer to these variables outside of the function where they were declared as local variables. 
Licenses don't matter. The Open Source Foundation won only 6 cases in 20+ years of its existance, and I believe there a thousands of applications violating GPL. So I treat everything on GitHub like it's in public domain. Also, I don't live in US so the probability of me facing any repercussions is basically zero.
Simply add Source/ in front of every C file. Or use something like `$(patsubst %,Source/%,main.c energy.c collisions.c etc)` (didn't try this, from memory) You could also use something like `OBJS = $(wildcard Source/*.c)`. Note that i am assuming GNU make here, not sure how standard that stuff is. EDIT: also note that this makefile will always rebuild the program even if it doesn't need to because you are trying to create the `hellomake` file but instead you create a `Simulator` file. Instead you should replace `hellomake` with `$(OBJ_NAME)`. The `foo: bar&lt;newline&gt;&lt;tab&gt;stuff` syntax for makefile essentially says "to make the file *foo* you first need the file *bar* and then do *stuff*".
Have you looked at how many cases the Free Software Foundation has won?
I like the GPL because I see it as adding regulation to the wild west of FOSS, fighting the "tragedy of the commons". Permissive works when people/companies are smart enough to take the long term perspective and upstream. But most are not that smart. Even if they are forced to give source downstream, many still don't upstream. Leaving them in a mess when they wish to rebase on a newer release. Sigh.
They normal just want compliance and it gets sorted before court.
Could this not be done using the -I option of gcc?
Hah, that's what also Linus said about the BSD license. 
The idea is fine, but your conditional in function is not a conditional, it's an assignment (you used "=" instead of "==") and your function call is not a function call (should be "insidefunction()").
Sorry, I didn't see all the other comments, you got this.
 // Fisher–Yates shuffle w/rejection sampling void shuffle_deck( uint8_t* deck ) size_t i, j, m; uint8_t tmp; for(i = 52 - 1; i != 0; i--){ m = i; m |= m &gt;&gt; 4; m |= m &gt;&gt; 2; m |= m &gt;&gt; 1; do{ j = rand() &amp; m; }while(j &gt; i); tmp = deck[j]; deck[j] = deck[i]; deck[i] = tmp; } } *untested
I have nightmares about it. I'm currently working on get_next_line x).
Prefix all your source filenames with `Source/`: OBJS = Source/main.c Source/energy.c Source/collisions.c \ Source/drawing.c Source/update_motion.c 
[You can do it!](http://letmegooglethat.com/?q=C+official+website)
what specifically are you looking for? for C89/C99 try here https://www.gnu.org/software/gnu-c-manual/ the "offical" specs are probably those sold by either www.ansi.org or www.iso.org
I follow this line of thought all the way through and put all of my personal works in the public domain, usually with the [Unlicense](http://unlicense.org/). I don't want to impose even [a legal burden of attribution](http://www.dancohen.org/2013/11/26/cc0-by/) and avoid any needless complication.
There's also no official sites for FORTRAN or COBOL. (there are 3rd party sites). C++ is just getting more attention than C, and has a lot more activity around the development of its specification. C is currently being worked on as well, by 'working group 14', in the form of C11, or 'C1X'. But trust and believe there just aren't any people who care as much about it the way there is with C++. People who care about C are too busy being happy with it as-is, and writing C code. It works for us. Start your own official site. EDIT: P.S. you typo'd isocpp
Your third line should say : if (insideFunction == TRUE) { that is comparison. 
I flip-flop between BSD-2 and MIT for the exact same reasons. If someone were to actually use my code in production.... God help them
He clearly can't, since there isn't one.
That tells the compiler where to look when including header files, but you can't use it to search for source files in the first place.
I'd be careful about that since I heard there are issues in some countries like Germany where you aren't legally allowed to release your works into the public domain.
Did I ever claim there was one? Literally one of my top result is the [exact same question](https://in.answers.yahoo.com/question/index?qid=20100513025317AASnS23).
Attribution is the only thing important to me because it might land me fame and/or a job. Giving attribution is actually really easy and the article does not make a strong point to the contrary. Note that in my country (Germany), I cannot legally release works into the public domain because some of my authors right's are inalienable, such as the right to a notice of authorship and how it is placed. For example, even if I released a work under the GPL I can still mandate that code printing “Programmed by FUZxxl” must not be changed (or the program altered in such a way that this code is not executed where originally intended) in derivative work because this right cannot be superseeded even by a license contract.
You can find a fair number of things in libraries, but there's no standard set of them you might be expected to have available everywhere. If I used C++ library stuff, I'd not be writing C, would I? Honestly if you find yourself missing those features a lot you should probably find a better language for the task. C is meant to be that way.
There is no official website for C.
If you want to insert/delete data into the middle of arrays, you have probably chosen the wrong data structure. You might want to use a linked list instead. Appending to the end is easy, if I need dynamic reallocation I just man up and write the five lines needed for an exponential back-off resizing strategy. I've never felt that C was lacking anything except perhaps hash tables (though I can usually do well without them).
I think most people just implement the functionality they need when they need it. Glib includes an [array API](https://developer.gnome.org/glib/stable/glib-Arrays.html), and sys/queue.h has some macros for working with linked lists (though I'm unsure if this is standard)
There have been posts here linking some libraries which looked useful. AFAIK, there isn't a typical set, like boost for c++. I sometimes look at the Linux kernel code for some ideas, like linked lists and such
ISO WG14 is the closest you can find. C standardization generally isn't updated for the internet.
c2x is the next version of C, C1X was C11.
I don't fuck around with GPL. BSD and MIT are legit licenses tho.
`cd ..` in the unix world.
Saying "you can do it" is false because he can't do it, so your comment was pretty misleading *at best*. Also, there's no need to be a cunt about it. You could have just responded like any of the other commenters in this thread.
What tutorials would you recommend then? Some I there's no official site to look on. I've heard the c programming language book is the best, but isn't that outdated? If it is, how would I know what I'm doing is right or wrong?
I just wanted an official site, to see what tutorials they'd recommend, like the official cpp website or Python website
C Programming: A Modern Approach by K.N. King is the best C book. Period. It will also point you in the right direction regarding other resources. There's no official website for C. "C: A Reference Manual" by Harbison&amp;Steele is a good widely accepted reference for the language as far I know.
In retrospect, I guess it seemed a bit condescending, which was not my meaning. I guess I just wanted to show that the answer wasn't that hard to find. Again, I did not mean to come across that way...
I don't really recommend tutorials. I learned from cprogramming.com 15+ years ago and have just gone from there. Look at open source projects and utilities, surf stackoverflow (https://stackoverflow.com/questions/tagged/c?page=1&amp;sort=votes&amp;pagesize=15) The only thing I would suggest as far as tutorials go is C programming gamedev tutorials, because gamedev is a multidisciplinary field where all the coding tricks and algorithms come into play, along with math/physics and compsci in general. Programming games from scratch pushes both the developer and the machine.
C is actually a high level language (Assembly is low level).
I'm sure its decent but C Primer Plus by Stephen Prata is the only one I got into. So. Many. Example questions!
&gt;hash tables It's not missing that either... `hsearch(3)` is POSIX. There's also the widely used [uthash](https://troydhanson.github.io/uthash/) if you don't like `hsearch`.
Yeah, but `hsearch()` allows you to have a single hash table for the whole process. I consider this inadequate.
As usual there's a reentrant version, `hsearch_r`, which is also thread-safe.
thanks! that worked!
Happy to help :)
That's not a POSIX function. It's a glibc-only extension.
Linked lists are no better than arrays for this task. Inserting into the middle of a linked takes `O(n/2) = O(n)` just because you have to travel all the way to the middle. Of course if you have a pointer to the insert location then it's `O(1)`, but that's an atypical situation. And taking the lack of locality of spatial reference for linked lists into account it means they're even worse for the job than arrays. And the extra space they take is the same as having an extra array. A good data structure for inserting just before a specified index would be something like a balanced search tree. That's `O(log n)` for insert/delete/lookup for a given index. EDIT: such a data structure is a [Rope]( https://en.wikipedia.org/wiki/Rope_\(data_structure\) ). Even though the article speaks about strings, the concept is applicable to generic arrays.
When you need to insert into the middle of an array, I would say that the typical situation is that you just determined where that spot is by iterating through the array, so you could use a linked list easily.
How do people in higher level languages compensate for their inability to do anything they want and faster than anything else but assembly? I mean, I knew higher level languages were slow and couldn't directly access a lot of things without help from C and assembly but I didn't know they were that slow and restrictive.
&gt; You can find a fair number of things in libraries, but there's no standard set of them you might be expected to have available everywhere. That's what I wanted to know. Thank you.
So, it's every man for himself in C world :) ... thanks for a link.
Aren't you more talking about a Heap structure? Edit: Correct link: https://en.m.wikipedia.org/wiki/Heap_(data_structure) The brackets in the link kinda mess up the fancy way of linking :/
No. A heap is for getting the min/max in `O(log n)`. What i meant is a data structure for efficient `insert x just before index i` operations.
Alright fair enough. One thing though, you mention linked lists using up a lot of space, however it seems to me (forgive me if I'm wrong, never encountered a 'Rope' before) that a Rope takes up even more space. Apart from that, the structure seems pretty useful.
Yes they take more space obviously, but they allow `O(log n)` operations. So you're gaining something for that extra space. For linked lists on the other hand you're taking `O(n)` extra space as well but the insert operations take `O(i)` (`i` being the index of insertion), compared to the `O(n-i)` of arrays, you're not gaining anything, except for fast insertions at the head of the list.
That worked! :)
It's the never ending battle of space Vs speed ^^.
C has standard specs, a few prominent implementations like GCC and Clang. But C is not like Python, where the standard is defined in terms of the official runtime implementation. As a student of C, this is unfortunate. Gotta read a lot of different specs, API documents, and textbooks to learn more C.
must.... learn... more.... C!!!
http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf :) Homepage of the ISO working group: http://www.open-std.org/jtc1/sc22/wg14/ I have to say I really like the design of that page. Faster and easier to navigate than any modern design. 
If you like that you'll love [Richard Stallman's site](https://stallman.org/)
If you want some extra convenience functions and data structures (beyond what's provided in the standard library), I would recommend: 1. [Apache Portable Runtime](https://apr.apache.org/) 2. [GLib](https://wiki.gnome.org/Projects/GLib) Those are probably the top 2 choices for a "kitchen sink" sort of library you can rely on for convenience.
Pointers on C is the best book I've found on it, and after chapter 6 there is a heavy emphasis on pointers, which is great because they're what gives C much of its power. Expert C Programming ("The ugly fish book" as many call it) is a great step after that, and C Traps and Pitfalls is a handy reference to keep around. 
In the book, it read modern approach but is written and published years ago. Does it cover latest developments in C? How does it compare to the C Primer via Prata? Is it more clear and concise for the beginner? Thanks
However inserting into the middle of an array would require shifting all the elements after the insertion point back by one space. Insertion into the middle of a linked list usually only requires fiddling with the pointers to the immediate sides of the insertion point.
I feel like that's sort of a red herring. C may be high level compared to assembly but compared to the other languages we have today it is very close to the metal. Even if we insist on calling C a 'high level' language it seems like a bit of a worthless distinction to make since every other language needs to be labeled as an 'even higher level' language, so we may as well just call C a low level language and save ourselves the effort.
That's why i said 'if you have the pointer'. Otherwise it is O(n) for both linked lists and arrays.
True.
[VPATH := Source](https://www.gnu.org/software/make/manual/html_node/General-Search.html)
I think the answer we'd all like to give to OP is: If you're considering a "high level" script language as the alternative, then you don't even get the choice between a list or an array, and as C programmers, we want that kind of control. Do you know what the internal representation of a PHP array() is? It's probably nowhere near as good as either an array or a linked list. Then again, it doubles as a hash table (in usage, though not performance). The real point of OP's question though is: No matter which data structure I choose, do I have to write it fresh each time? How many times do you write a linked list that stores the exact data type you need (absent generics), or write binary search and sort functions for your array, or hash tables from scratch? Far more often than we do in PHP, that's for sure, but mostly because we care about the performance, and eschew generic solutions like [GLib](https://developer.gnome.org/glib/2.52/glib-data-types.html). It's not unusual to find that a project has 5 different, mutually incompatible, string implementations, especially if said project is cobbled together from different libraries by programmers with different philosophies.
C does not box you into one implementation of a list or an associative array, like a script language does. I write a lot of PHP, for example, and while it's convenient to use the built-in array type (which doubles as both an indexed and associative array), it comes at a non-trivial cost. Convenience is nice, but sometimes, control is what you want (that's why you chose to use C). If you don't want to write your own data structures each time, you could use a library like [GLib](https://developer.gnome.org/glib/). Or take some free or open source code from elsewhere.
C Primer is an introduction to programming in general tough, not only to C, am I right?
I think Prata's books are aimed at beginners, while this book would be good for someone who already has some programming experience. I don't think it covers C11, but C development isn't as dynamic as the development of many other languages like C++ for example. From what I've seen new version add mostly some esoteric or very advanced features that you won't use as a beginner. Funny thing about C is that most of it is still written according to C89 and not C99...
Yeah i believe thats a fair statement 
why not?
Why are you asking this in C_Programming?
There's a [list of recommended C books on StackOverflow](http://stackoverflow.com/a/562377/253056) - it's in the process of being overhauled but it's still useful. See also the [`C` tag wiki on StackOverflow](https://stackoverflow.com/tags/c/info).
This subreddit is about programming in C. Please ask C++ questions elsewhere.
Very strange. This should work. BTW, can you tell me why you use `u8` for the indices?
It processes bitmap file so data in that arrays is bunch of unsigned chars, u8 is just less to type. :)
This is for C programming, not C#. They are not the same thing.
&gt; but in Linux it produces useless output. What does that mean? In what way is memcmp failing?
I recommend you to always use `size_t` for indices. That just performs a lot better.
**C (programming language** From incorrect disambiguation: This is a redirect from a page name with incorrect disambiguation due to a typographical error, a format that does not follow Wikipedia convention or a previous editorial misconception. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.26
It doesn't compare as I expect it to. I've added example.bmp to repo. Here's proper output `./bmp2cgb -i example.bmp` produced with for loop: Tiles used: 124 (836 duplicates removed: 816 normal, 20 horizontal, 0 vertical, 0 horizontal &amp; vertical) And with memcmp instead of for loop: Tiles used: 6 (954 duplicates removed: 638 normal, 110 horizontal, 112 vertical, 94 horizontal &amp; vertical) which is plain wrong.
But how did you get from there to blaming it on memcmp? Is it saying 2 buffers are equal when they're not? Is it saying 2 buffers are different when they're the same? When there's a mismatch, have you confirmed src and dst are both pointing at 64 bytes of initialised memory?
&gt; C may be high level compared to assembly but compared to the other languages we have today it is very close to the metal. No, it isn't. Some people argue that even Assembly isn't close to the metal, because of microcode.
If I replace memcmp with for loop and compare it byte by byte it works as expected, so what else can I blame here? If I knew what's going on I wouldn't be posting here.
While testing with Valgrind it produces proper output. Now that's getting really funny. ==6003== Memcheck, a memory error detector ==6003== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al. ==6003== Using Valgrind-3.10.0 and LibVEX; rerun with -h for copyright info ==6003== Command: ./bmp2cgb -i example.bmp ==6003== Bitmap size: 256 * 240 px Character/Attribute map: 32 * 30 chars Palettes usage: 4/8 slots Tiles used: 124 (836 duplicates removed: 816 normal, 20 horizontal, 0 vertical, 0 horizontal &amp; vertical) ==6003== ==6003== HEAP SUMMARY: ==6003== in use at exit: 0 bytes in 0 blocks ==6003== total heap usage: 8 allocs, 8 frees, 135,150 bytes allocated ==6003== ==6003== All heap blocks were freed -- no leaks are possible ==6003== ==6003== For counts of detected and suppressed errors, rerun with: -v ==6003== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) 
Figured it out: `memcmp()` can return an arbitrary int, not just -1, 0, 1. You're truncating it to `u8` and getting matches (result == 0) where you shouldn't. That's your bug. On Windows it's just not returning a value that wraps to 0. Valgrind hides the bug because it supplies its own memcmp(), which gives you the simpler -1, 0, 1 return.
`memcmp` [returns the difference of the first two differing bytes](http://en.cppreference.com/w/c/string/byte/memcmp) *(Edit: correction -- it returns -1, 0, or 1 for less-than, equal-to, and greater-than)*, which is signed, so maybe that's getting clipped since you're casting it (implicitly) to unsigned due to your functions return type? (And no idea why this would work in Windows at all.) *Edit 2: So I ran a test program and under linux I'm getting the difference between the first pair of differing bytes and not just -1, 0, 1.* The solution would be to alter it to read: u8 pmcmem(u8 *dst, u8 *src, u8 n) { return memcmp(dst, src, n) != 0; }
It doesn't return the difference, it returns something that has the sign of the difference: `The sign of the result is the sign of the difference between the values of the first pair of bytes [...]`. So it could return +256, or +512, or any multiple of 256 that has the right sign ... all of which get truncated to 0 when converting to 8 bits.
And that's why you don't use weird types for your variables!
&gt; what else can I blame here? Something in your code. Which is more likely, a bug in memcmp or a bug in the way it is being used. You have a starting point - memcmp is returning an unexpected result. So stop in the debugger at that point and make sure the two buffers are what you think they are.
Again, that's a useless distinction to make because microcode is not a programming language that is available for the general public to use.
There are utility libraries, but the problem is that you have to pull the whole library for just the 1 function/structure you fancy (and the library has its own style/model that doesn't necessarily fit nicely with the rest of your program, and it is sometimes not as portable as the rest of the program...), which is not in the spirit of a C programmer, who usually doesn't like to 'waste'. A JS dev (and others) would not have any problem pulling a gazillion dependencies for very little use, but a C programmer is generally reluctant about it. 
1, 2 and 4 are acceptable solutions. 3 is no good because you should not pollute the system's error indicator with your lib's errors. Of the three i'd say 1 is the best, because it is the most non-intrusive and you can disable assert with the `NDEBUG` macro. There is no clear answer, and labeling it as 'undefined behavior' in your lib's documentation is the best practice. Here's why: if the function must make some assumptions about its arguments in order to do its job, then it's the caller's responsibility to make sure the conditions are fulfilled! Imagine you're writing a binary search function for arrays. Binary search requires of course that the array being searched is ordered. So what should we do? Should we check in the function each time if the array is sorted? Of course that would be dumb: we turn the O(log n) search into O(n) ! The answer is to leave it as undefined behavior, let the caller handle it.
&gt; microcode is not a programming language that is available for the general public to use It's still something that exists and is under the level of machine code. Somebody inside Intel and AMD writes it, even if you don't get to.
If barely anybody is using it then it's entirely useless to say 'oh well actually assembly is pretty high level compared to microcode' because as I said before, that's not a mainstream programming language.
Why not use? int pop(stack *stack, int *elem); Where the return value represents the status and the `*elem` is the address of a local variable where you want to load the popped value.
You seem to think that the complexity level depends on whether the common programmer has access to it. You're wrong.
Testing the error code is as difficult as testing the return value. And even in case 4, you'll be returning a NULL pointer. I'd just return NULL on failure.This is the most typical way of dealing with things in the std libraries.
How is this different from option 4? Looks exactly the same to me, apart from var/elem
Did someone showed you this? Because syntax looks quite advanced but the execution is poor. These 2 thing don't usually go together. EDIT: Notice how this looks like void exibeMinutos(int n){ (n == 1) ? printf("%s ", hourStrings[0]) : 0; (n == 2) ? printf("%s ", hourStrings[1]) : 0; (n == 3) ? printf("%s ", hourStrings[2]) : 0; (n == 4) ? printf("%s ", hourStrings[3]) : 0; (n == 5) ? printf("%s ", hourStrings[4]) : 0; (n == 6) ? printf("%s ", hourStrings[5]) : 0; (n == 7) ? printf("%s ", hourStrings[6]) : 0; (n == 8) ? printf("%s ", hourStrings[7]) : 0; (n == 9) ? printf("%s ", hourStrings[8]) : 0; } You can bind n to the array[n-1] You can check the validity of n at the start of the function and just write hourStrings[n-1]; if the n is valid. 
You're right... I guess I glossed over it when reading OP. 
Sorry I don't understand, how can I return `NULL` from `pop`?
Seeing the other comments it is a good solution though :D. 
OMG I god a compliment on my syntax!!! [giggle] Being serious now. The code is mine. Check the user on github and here: **g**ustavo**hms**ilva. I was looking for exercises to do on the weekend when I found the chalenge on /r/dailyprogrammer and decided to try it out. I've coded it myself. 
**Here's a sneak peek of /r/dailyprogrammer using the [top posts](https://np.reddit.com/r/dailyprogrammer/top/?sort=top&amp;t=year) of the year!** \#1: [DailyProgrammer is one of the Trending Subreddits for 2017-06-07!](https://np.reddit.com/r/trendingsubreddits/comments/6frugf/trending_subreddits_for_20170607_rdailyprogrammer/) | [7 comments](https://np.reddit.com/r/dailyprogrammer/comments/6ft754/dailyprogrammer_is_one_of_the_trending_subreddits/) \#2: [\[2017-06-27\] Challenge #321 \[Easy\] Talking Clock](https://np.reddit.com/r/dailyprogrammer/comments/6jr76h/20170627_challenge_321_easy_talking_clock/) \#3: [\[2016-11-21\] Challenge #293 \[Easy\] Defusing the bomb](https://np.reddit.com/r/dailyprogrammer/comments/5e4mde/20161121_challenge_293_easy_defusing_the_bomb/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
Instead of coding every possible thing, you can just use some math to get your right numbers instead of mapping values. For example, in `exibeMinutos` (and similar code) can be simply replaced with `printf("%s ", hourStrings[n - 1]);`. Just calculate the index directly from `n`. Also, there is clearly some repetition in lines 86 to 102 that can be easily shortened: else if (minutes &gt;= 20) { int left = minutes / 10; /* Get right digit */ int right = minutes % 10; /* Get left digit */ printf("%s e", hourStrings[15 + left]); exibeMinutos(right); } Everything untested. Also, people would probably prefer using the `if` statement than using the ternary operator (`x ? y : z`). Also, do you really need the `else`-block starting at line 35? If the `if` statement is true (`argc !=2`), it would return anyway (`return -1;`), so there is never any "shared" code, just like you did at line 38 to 41. I hope you understand what I mean.
By returning an *int instead of int, I assume.
Yeah, that's fair, at the end of the day, a call to `pop` when the stack is empty it's "caller fault" and I provide a tool (`is_empty`) to avoid that to happen. I guess I'm going to use this approach from now on and add assertions for debugging. Binary Search example really convinced me =)
&gt; Also, people would probably prefer using the if statement than using the ternary operator (x ? y : z). I went for ternary because I simply hate splitting things in two lines when I don't have to do it. It's kind of a personal thing. If I don't need {} in my if, I usually use ternary. It can ignite a flame war, I know, but it is my humble preference.
&gt; Instead of coding every possible thing, you can just use some math to get your right numbers instead of mapping values. &gt; &gt; For example, in exibeMinutos (and similar code) can be simply replaced with printf("%s ", hourStrings[n - 1]);. Just calculate the index directly from n. &gt; &gt; Also, there is clearly some repetition in lines 86 to 102 that can be easily shortened: &gt; &gt; else if (minutes &gt;= 20) { &gt; int left = minutes / 10; /* Get right digit */ &gt; int right = minutes % 10; /* Get left digit */ &gt; printf("%s e", hourStrings[15 + left]); &gt; exibeMinutos(right); &gt; } I'll try to understand better how to migrate from one to another and will post it here once I complete it and test it. btw, this was one of the things that kind of put me angry about this code. I'm note feeling that he is doing the work for me. It feels like I'm doing the work for it (when coding). I understand that dealing with language it's complicated (specially Portuguese), but This should be a smaller code, not something that big.
That makes sense. I was really surprised at first.
/u/Neui and you pointed me to binding the array and the time. It is curious this was one of the things that got me angry when coding. the extend of such a simple thing. I'll definitely check this out. I think It may be necessary to re-arrange the values on the array as well, in order to ensure the maximum amount of continuity and maximize the binding. Thanks man! That is an awesome tip! 
Oh yes, and in case of success I'll just return `var` in solution 4, that's fair too.
Don't get too giddy. The syntax is quite advanced. But your code understanding is lacking on a basic level. This proves that although you know how to write advanced expressions like, (n == 2) ? printf("%s ", hourStrings[1]) : 0; You don't know what they mean or when to use them. And even if you do. Try to avoid using it. Especially on the beginner level.
Don't forget to use the return statement. So you can write char *get_exibeMinutos(int n) { /* here be checking for the validity of n /* ... return hourStrings[n-1]; } EDIT: &gt;It is curious this was one of the things that got me angry when coding. This is the thing you need to practice. Pointers and memory manipulation and all the cool stuff comes later.
Hey man! A compliment is a compliment, You can't just "take it back" :( #jk My post here is in a way, an attempt to get this understanding level. I'm having problems seeing the best approach to solve certain problems. This has been a pain in my arse and the thing that had been keeping me from getting better... Like this code I did for example. I know it works, I know I treated all the exceptions necessary to the language in question, but I fail to see best methods to achieve the goals. 
Thanks! I've done some testing and now it makes sense. Windows version of memcmp always returns 0xffffffff, 0x00 or 0x01 while in Linux you get different values, so it is exactly how you said. 
Why C? And how long have you studied it? 
Please do not use the ternary operator as an if statement replacement. Compare: (n == 1) ? printf("%s ", hourStrings[0]) : 0; with: if (n == 1) printf("%s", hourStrings[0]); Yes I understood the code but it's like screwing a screw with a hammer. The code ain't even more compact. Like what if the function was a void function and you had to cast the 0 to void. Insanity.
&gt; Why C? And how long have you studied it? I wanted to go completely opposite of everything I've learned before. I code some (shitty) python code to automate stuff at my work that it's just too boring to do it by hand and stay sane, i've learned Pascal twelve years ago but never practiced (and the course I've done at the time was also pretty bad). I've always did some barely functional code tweaks to PHP CMS's like Wordpress and Joomla for the blogs I had over time and stuff like that, but I never had the chance to PROPERLY learn how to code, how to understand memory management, boolean logic and CS. So after some research I've decided to learn C. Got "The C Programming Language" on Amazon, and started messing around. Three weeks later I had a chance to start community college and I took it. Result: I started programming (if you can call it that) in C in January 2017, when I have free time between work and other things I have to do for college. 
Hum. I never though of putting if statements on the same line. It was my understanding that in the absence of {}, if/else would interpret the next line of cone only, not "everything before ;" When should I use ternary then? 
There is enough international law that basically anyone, if served properly, can be sued by someone in America, obligatory I am not a lawyer.
The ternary operator is an expression, whereas the if statement is a statement. ;) That means that you can use it in place of stuff like 1 + 1. For example: if (x &gt;= 1) y = 10; else y = 25; could be more readable like: y = x &gt;= 1 ? 10 : 25; See [here](https://github.com/axelf4/flexLayout/blob/master/flexLayout.c#L115) for more examples in one of my projects. Edit: The reason why you can have 1-line if statements is that the syntax looks like this: if (expression) statement Whitespace is ignored like in any sane language (\*cough\* not Python \*cough\*). Statement can be a *compound statement* like: { printf("HelloWorld!\n"); } But it can just as well be an *expression statement* like: printf("HelloWorld\n");
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [axelf4/flexLayout/.../**flexLayout.c#L115** (master → cba1252)](https://github.com/axelf4/flexLayout/blob/cba1252aa84d0961f2011822e267e3a47aa1d534/flexLayout.c#L115) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dm8vmpz.)^.
FYI, you can write a single-line if statement without `{}`. if (condition) do_something(); else do_something_else();
Hum... This actually make sense. Like if Ternary is a way to do boolean math, while if/else is just a generic way to choose paths not necessarily associated with math operations. Ok. I'll keep that in mind. BTW: I decided to re-write the code from this topic from scratch, having in mind fractioning the task in it's problems and exceptions, then trying to solve them independently the smartest way possible. I'm also rearranging the array in order to maximize the amount of "n-1" to use.
Don't use explicitly-sized or explicitly-signed types except when absolutely necessary, either because you're reading or writing data in a specific format or because you need the semantics (truncation etc.) of that type.
 #!/bin/sh for f ; do echo -n "$f" while [ -L "$f" ] ; do f=`readlink "$f"` echo -n " -&gt; $f" done echo done 
How did you get `ft_swap()` to compile, much less do anything useful?
This is the exact reason why a true boolean type was added to the language in 1999. A similar bug can strike in code that simulates bool using an integer type, e.g.: // buried in header somewhere typedef char bool; // your code bool test_flag(FLAGS x) { return (x &amp; SOME_FLAG); } and SOME_FLAG happens to be outside of range of char. 
As other people have commented, you used the wrong approach with the ternary operator. Also, most of these functions can be simplified and will probably run faster because of it. I'm going to be commenting on version 3 as that is the latest version you have uploaded. In your function: exitbeHora, you still use an excessive amount of ternary operators. If you look at line 16-26 you can see a chronological pattern in the statements. That portion can be rewritten using a simple mod operator. unsigned int check = n % 12; # this forces check to loop around printf("%s", hourStrings[check - 1]; This makes it a lot easier to read and understand. This operator also allows for line 13-15 to be simplified. The complete function would like this. void exitbeHora(unsigned int, unsigned m) { unsigned int check = n % 12; if(check == 0) { if(n == 0) printf("%s", hourstring[12]); else printf("%s", hourstring[11]); } else { printf("%s", hourStrings[check - 1]); } char * minute_format = " "; if(m != 0) minute_format = " e "; printf("%s", minute_format); } Obviously this is just checking individual functions. You should check the code as a whole for a better way to organize it. EDIT: Just a small thing about the 'main' function. in the check for argc if(argc != 2) { printf("ERROR\n"); return -1; } You don't need to use an else statement as the return statement forces termination of the function, so you can remove the line with the 'else' and bring everything from their four spaces back. EDIT 2: It it also possible to eliminate the innermost if statement in that function i've rewritten with some simple math. void exitbeHora(unsigned int, unsigned m) { unsigned int check = n % 12; if(check == 0) { unsigned int array_shift = n % 11; printf("%s", hourStrings[12 - array_shift]; # or the above in one line: # printf("%s", hourString[12 - (n % 11)]; } else { printf("%s", hourStrings[check - 1]); } char * minute_format = " "; if(m != 0) minute_format = " e "; printf("%s", minute_format); } EDIT 3: Small derp on the exitbeHora functions.
The canonical way to handle `pop()` is to have undefined behaviour and require the caller to check `is_empty` first if it's possible the stack might be empty. 
Let's do this in english for an example. I am using ... to show fill in the blanks in the tables because I don't want to type it all. char *hours[12] = { "twelve", "one", ..., "eleven"}; char *numTens[6] = {"", "", "twenty", "thirty", "forty", "fifty"} char *numOnes[9] = {"", "one", "two", ..., "nine"}; char *numTeens[9] = {"ten", "eleven", ..., "nineteen"}; void printTime(int hr, int min) { int hr12 = hr; int minTen = min / 10; int minOne = min % 10; if(hr12 &gt; 11) { hr12 = hr - 12; } printf("%s o'clock %s", hours[hr12], (hr == hr12) ? "AM", "PM" ); if(min != 0) { printf(" and "); if(minTen &gt; 1) { printf("%s", numTens[minTen]); } if(minTen == 1) { printf(" %s", numTeens[minOne]); } else if(minOne &gt; 0) { printf(" %s", numOnes[minOne]); } printf(" minutes"); } } Or something like that.
That's why you read the man page, even if you *think* you know what the function does.
is a GNU only extension.
Sounds like a cool project. Have you heard of Cataclysm DDA? Are planning on taking a this project in a different direction? 
So I'm a day late, but I stumbled across this and wanted to give you kudos for being willing to apologise on the internet. Cheers!
I haven't, but wow, that looks really awesome! Well, nothing is carved in stone, I just have the basics now, and it could be developed into a lot of things.
Can confirm that this will not compile on FreeBSD, since it appears that libvlc-dev is not available for FreeBSD (at least I can't find it anywhere, only binary releases for Linux).
I'm not trying to hate hate but when I'm the C programming subreddit can we use correct terminology. We don't have methods in C programming. In fact methods are very different then the functions we make in c. Im a beginner but this immediately threw me off. 
Oh, that's bad. But is libvlc available? Maybe there is no separate dev package like on Debian (based) systems, and the headers are installed with the base package.
It looks like it may be able to be compiled from VLC source. Can't find much more on it besides that. edit: Sorry, I'm not going to try to do that. There are WAY too many dependencies and such.
Ahh, then I'll add that to my todo list.
I'm sorry if that has caused misunderstandings! Of course when I said "methods" I didn't mean the OOP "methods", but [a procedure, technique, or planned way of doing something](http://www.wordreference.com/definition/method).
I currently own Prata's book and it's great but I was hoping to find a good C book for beginners that used pictures and diagrams of the language use and functional programming methodologies. Visual learning but not lacking in explaination. Does that make sense? 
This defines a variable holding the name of the source folder and uses it to find every `.c` file in it. SRC_DIR := ./source SRCS := $(SRC_DIR)/*.c This version is different as it also looks for `.c` files in subdirectories. SRC_DIR := ./source SRCS := $(shell find $(SRC_DIR) -name "*.c")
&gt;Generally variables with a global scope (external linkage in C) is considered bad practice. There is no reason to declare other variables in a .h file either. You're not smart, are you? [Have a look at my MindFlow project](https://github.com/Garuda1/MindFlow). Look at `source/optab.c`. What is it, you may ask? Well in `source/vm.h`, line 63, I have the following: extern uint8_t (*vm_op_tab[])(t_vm *); I am declaring an array of function pointers, more specifically in the format `uint8_t function(t_vm *ptr)`. I need this array to be accessible from more than 32 different files. Do you seriously think I'm going to bother redeclaring my array in each of those files? That's stupid. C gave a way to do this, extern variables. Whether or not it is bad practice is irrelevant. It was a simple, elegant way to solve my problem. So instead of assuming something is bad practice, consider every use case.
Hum. I never though about splitting in different arrays, this may solve the problem I'm having with the new revision (I actually started rewriting the program in pseudocode and will start everything again with a fresh eye). One point regarding your code vs mine. The portuguese language has a lot of exceptions to it's pronunciations. For example. 1 to 10 is simple, 10 to 15 has no pattern (dez, onze, doze, treze, quatorze, quinze) and 16 to 19 has exceptions (dezesseis, dezessete, dezoito, dezenove). Also, depending on the hour, you should use is or are (é, são). This is one of the things that at first glimpse made me do the stupid version of my code, instead of actually trying to solve the exceptions.
/u/_realitycheck_ Why did you asked this question btw? Just to measure if I'm being a slow or a fast learner? PS: This is a question I would like to know as well. From what I've saw at CS classes, I'm kind of miles ahead of everyone else (while, at the same time, being completely behind every serious programmer on earth haha).
The teens are special in English as are the twenty, thirty, etc. You could do something like this for those in Portuguese. 
&gt; The teens are special in English as are the twenty, thirty, etc. You could do something like this for those in Portuguese. I'll give it a try. I should post a new version today. 
Format your code per the "formatting help" link, otherwise it's mangled by markdown. Putting a type in parentheses is a cast. It's casting the return value from the type `void *` to the type `TrieNode *`. This cast is not necessary in C, as `void *` may be implicitly converted to other pointer types. Whoever wrote that should not have done it. The cast hides mistakes, such as neglecting to include `&lt;stdlib.h&gt;` which would result in an implicit declaration of `malloc()` which returns `int`. 
ahh thanks!
It is just a cast to an pointer to `TrieNode`. In C, this is not necessary here and [may even be avoided](https://stackoverflow.com/a/605858).
I deleted as I saw comments with more thorough explanation
That link actually explains why this *should* be avoided.
That's tricky. But you can always check our Coursera or any other free learning place for tutorials. 
There is some good discussion [here](https://www.securecoding.cert.org/confluence/display/c/MEM02-C.+Immediately+cast+the+result+of+a+memory+allocation+function+call+into+a+pointer+to+the+allocated+type) on whether to cast or not in C specifically.
The equivalent of Ctrl + D on windows is F6. That said good luck! :-)
Isn't it Ctrl + Z?
[count me in](https://github.com/ooqq) ✌️
It seems to me that F6 only works if it was immediately preceded by an enter. Ctrl-Z only works if immediately followed by an enter. Awfully finicky. Having a letter occur right before pressing F6, or a letter right after Ctrl-Z, causes each to be an ASCII 26. Thanks for the luck!
Apparently, it only works if it's Ctrl-Z followed immediately by an enter. If I do Ctrl-Z and then type a different letter and then hit enter, the Ctrl-Z is interpreted as ASCII 26. Here's the program I wrote to test Ctrl-Z on Windows. On the reddit phone app, all the newlines get stripped out apparently and my code looks like a big paragraph. So, view this code on a desktop browser. #include &lt;stdio.h&gt; int main() { printf( "\nBegin typing input. " ); printf( "Program will end upon EOF." ); printf( "\n&gt; " ); int c = getchar(); int has_content = c != EOF; while( has_content ) { printf( "[%d|%c]", c, c ); c = getchar(); has_content = c != EOF; } printf( "EOF" ); printf( "\n\n" ); return 0; } 
This sounds fun. Im intermediate with C and I never been to a study group. So I kinda wana try this.
There are many ways to do that. You can find them all on the web. Just make sure you don't make your code too complex in order to achieve something. Complexity cause errors, and even that you can detect those errors with programs like checkmarx, it is better to try and make a code that doesn't collapse and with less errors as possible. Good luck.
I tend to use minGW as it works pretty good for me along the way. As a new to C, I recommend you to learn as much possible and make no mistakes as C sometimes tend to be a bit complex which causes errors in your code. Those errors can be detected using programs as checkamrx and others and it's very important to detect and solve them. If you can, it's better to do it as you code to save your time. Good luck!
yea i'm definitely interested
&gt; Haskell study group going on I'm more interested in this, since I'm currently leraning haskell.
If this would be noob friendly I would be interested. What time zone would dischord be based out of? 