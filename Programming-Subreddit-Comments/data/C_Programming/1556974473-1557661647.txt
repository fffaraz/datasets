Its probably from the file you open but never close. &amp;#x200B; Your check on file.c:180 is to see if the file successfully opened - on every return after than you are leaving the routine without closing the open file handle.
Prefix just adds one then continues the rest of the evaluation, and postfix creates a copy of the value adds to the original value then returns the copy to the evaluation.
I see. That make sense. Thanks a lot!
The prefix operator is nominally faster than the postfix operator, but it's so negligible that there's rarely a reason to use prefix vs postfix for performance gains alone. It's more important to recognize that prefix and postfix operators are functionally different operations, and you should use the one that's suited for your use-case. If you really, really, really, really want to test performance, set up a test yourself. Ie, write a program that performs X (really, really big number) of prefix increments, and see how long in runs in nanoseconds, and take the average of Y runs, then do the same for postfix increments.
Try with [Compiler Explorer](https://godbolt.org/z/dQrFA8).
True, though here's an implementation of Dear ImGui for SDL2: https://github.com/Tyyppi77/imgui_sdl
As long as your program is correct, it really doesn't matter which you use. It's trivial for compilers to optimize either. It really makes no difference. What you may have heard might have actually had to do with C++, not C. That's due to operator overloading, where the increment/decrement operators may actually be very complex.
There is no difference in performance between these two operators with modern compilers. Choose the one that is most appropriate for your situation.
That's not true these days since compilers can generally optimise the difference away.
But even with C++, copy elision can do away with the difference often.
&gt; calculated at compile time. Beware of variant length arrays.
When the value for postfix isn't used, yes, but what I described is the intended difference between them.
Depends, but in most cases it’s unlikely to be a meaningful difference. As a stand-alone operation or the increment step in a for loop it shouldn’t matter. An optimizing compiler will pick whichever is more efficient on that architecture, and should also turn `x = x + 1` or `x += 1` into equivalent operations. Some architectures have operations that automatically increment/decrement pointers as part of a read or write, so in those cases it can make a difference. If it really matters for a particular piece of code you should test it both ways.
Oh, thanks for the correction!
Even when the value is used there may not be an actual performance difference.
That would be undefined behaviour, %d is the wrong format specifier for size_t
It might not work on other systems
The `FILE` structure is declared in `stdio.h` so macros like `getc` can operate on it directly.
Please be civil. Also, work on your spelling. It's atrocious.
sizeof() is computed at compile time and is very safe and accurate. `sizeof(Foo)` would actually compile to a constant. I do have one caveat though, the size of a structure might not be what you expect. E.g. typedef struct { uint16_t a; uint32_t b; } Foo; `sizeof(Foo)` could be either 6 or 8, depending on whether or not your target cpu needs 32-bit alignment for 32-bit values.
On C++, you could use Qt. But with pure C, it's a complicated question...
Your mileage may vary, but personally I might just make it directly with the Win32 API, if this is all you need.
You may want to use struct inheritance rather than macros for this, rather than: typedef struct Foo { int normal; #ifdef BIGGER int bigger; #endif } Foo; try typedef struct Foo { int normal; } Foo; typedef struct BiggerFoo { int bigger; } BiggerFoo;
where are the data coming from? where are they returned to? shared drive across multiple OS - how is it shared? file locking doesn't work (or has additional complications) on some distributed file systems, iirc.
&gt; where are the data coming from? where are they returned to? 1 single file. It could be a text file or a binary file, but the implementation does not matter. I just need to be sure that when one process opens and modifies the file, it can't be opened and modified by another process. &gt; shared drive across multiple OS - how is it shared? Automatically by AWS (Amazon). It's just a drive that appears magically at the root.
&gt; Automatically by AWS (Amazon). It's just a drive that appears magically at the root. That's not really helpful. What protocol is used to access this shared drive? What sort of file locking does it support? Many network protocols do not support file locking.
&gt; Amazon EFS provides a file system interface, file system access semantics (such as strong consistency and file locking), and concurrently-accessible storage for up to thousands of Amazon EC2 instances. https://aws.amazon.com/efs/faq/
So... this is Amazon EFS? Then file locking should just work. Read the manual for `lockf` for details.
I believe that is called *composition* rather than inheritance.
yes. support for windows is much easier with sdl than gtk, or at least it was back when I used 1.2. it was just a single dll, as opposed to gtk which needed a whole directiry of useless junk in order to run but yeah there's plenty of options like SDL_ttf if you don't want to draw your own fonts and stuff--but you can do that too with bitmapped fontsxand such. definitely have a lot more control over how the interface looks than you do with gtk.
give it a shot
Never accept or offer "magically" as an explanation for a non-trivial implementation detail. The term "magically" is really only appropriate for trivial things that are intentionally hand-waved as part of a teaching exercise. If your data is on an S3, what I *think* you're looking for is an AWS object lock which is a type of reader/writer lock that gives you write-once-read-many (WORM) access to a resource. This is a relatively new feature, and I haven't used it myself, so I'm not sure if it's 100% appropriate for your use-case.
&gt; The interaction between fcntl() and lockf() locks is unspecified. Is lockf() better/newer than fcntl() related locks? And do these functions work on Windows (compiled with GCC in cygwin)?
`lockf` is the POSIX API so it's reasonably portable. The other locks are fine, too. None of them work on Windows as far as I'm concerned.
Jesus, no, this sub isn't for code, it's for asking people to do your 1st year CS homework for you.
According to the authors of the Standard, there was no need for a rule specifying that a statement like \`uint1 = uchar1&lt;&lt;24;\` should behave as though it promotes \`uchar1\` to unsigned, because \*commonplace implementations behaved that way even without a rule mandating it\*. The authors of the Standard didn't want to mandate such behavior on platforms where some other behavior might be more useful, but that doesn't mean they intended that general-purpose implementations for commonplace hardware shouldn't be expected to continue processing such code as they always had.
That's an option?? I've just been stealing from GitHub
Code which assembles a sequence of bytes out of integers will be more portable than code which simply reads and writes structures, but code which reads and writes structures will be portable to any compiler \*which is configured to be suitable for low-level programming\* and targets a platform with the same storage layouts as intended. Given functions like: &amp;#x200B; uint32\_t read\_alligned\_little\_endian\_word(void \*p) { uint8\_t \*pp = p; return pp\[0\] | (pp\[1\]&lt;&lt;8) | ((uint32\_t)pp\[2\]&lt;&lt;16) | ((uint32\_t(pp\[3\]&lt;&lt;24)); } uint32\_t read\_alligned\_native\_endian\_word(void \*p) { uint32\_t \*pp = p; return \*pp; } &amp;#x200B; the former will work on all compilers and platforms, but for many compilers and platforms would generate needlessly-inefficient code. There are some compilers whose optimizers will break the latter code, but will turn the former into the code the latter would have generated if the optimizer didn't break it, and the authors of such compilers seem to think everyone should use the former style so as to showcase their compiler's "superiority". &amp;#x200B; Incidentally, on platforms which don't support unaligned reads, the latter code will fail if \`p\` is unaligned, but the former would work. If the programmer knows that \`p\` is aligned but the compiler doesn't, a compiler that supports the latter would be able to generate more efficient machine code than any compiler could generate for the former.
Some versions of \`&lt;stdio.h&gt;\` may define the structure to allow such usage, but there is no requirement that they do so. Further, some implementations may define a \`struct \_\_FILE\` which includes enough members to serve the needs of \`getc\`, but is only part of a larger \`struct \_\_FILE\_INTERNAL\`, and have many of its functions cast a \`FILE\*\` into a \`struct \_\_FILE\_INTERNAL\*\` for purposes of accessing extra members.
One useful technique is to have some functions which accept a pointer to a structure also accept a parameter indicating the expected size. If a structure must be used with an "init" function before anything else is done with it, the \`init\` function may signal an error if the size isn't what it's expecting. If the initialization succeeds, the client code is presumably using a structure with the expected size. &amp;#x200B; A related technique is to have the first member of a structure be an integer reporting the overall size of the structure. The code that first populates the structure would be expected to set that, and other code that uses the structure could then validate it. If part of the system is compiled with options that would make the structure be the wrong size, and that part checks the size of the structure, it could signal an error before it tries to access incorrect information within the structure.
Fixed my comment. Happy now?
Funny remark in the fcntl(2) manpage (FreeBSD) regarding file locking: "This interface follows the completely stupid semantics of System V and IEEE Std 1003.1-1988 (\`\`POSIX.1'') that require that all locks associated with a file for a given process are removed when any file descriptor for that file is closed by that process."
It is common, but I've worked with implementations where \`&lt;stdio.h&gt;\` contained \`typedef struct \_\_FILE \*FILE;\` but didn't contain any definition for the structure itself, and were designed to allow compiled code to be usable with user-supplied I/O routines that could define the type however they saw fit. If only one compilation unit in a project includes definitions of \`FILE\` objects and accesses members thereof, no other unit will need to know or care about its layout or size.
Since OP may be new to this sub, the answer is: Yes, feel free to post your code and ask questions about problems or solicit feedback. Please try to format your code as such when you post (which means each line should be preceeded by 4 spaces). This will ensure it is (more) readable, and enable others to assist you more readily.
Thanks for the correction
if the programs are started with distinct indices (eg starting at 0 and increasing by 1) then they can all read from the same file. but for writing i would check with amazon's own docs about whether and how locking works.
That actually seems to be useful? I may be misunderstanding it, but it seems like simply closing the file (handle) would automatically release all locks on it.
I think I am going to write a simple console process that just tests all of the file i/o semantics I will be relying upon just to make sure the behaviors I am expecting actually happen the way I think they will.
good luck. testing multi-threaded c code is tricky... (i do it for a living right now).
not if you're locking to protect multiple readers from any writer, i think.
Took a brief look and nothing looks obviously out of place. Can you elaborate a bit on why you created this? Were there some limitations of other c based unit test frameworks?
AFAIK, GTK is portable as in runs on macOS, Linux and Windows.
 I'd just like to interject for a moment. What you're referring to as Linux, is in fact, GNU/Linux, or as I've recently taken to calling it, GNU plus Linux. Linux is not an operating system unto itself, but rather another free component of a fully functioning GNU system made useful by the GNU corelibs, shell utilities and vital system components comprising a full OS as defined by POSIX. Many computer users run a modified version of the GNU system every day, without realizing it. Through a peculiar turn of events, the version of GNU which is widely used today is often called "Linux", and many of its users are not aware that it is basically the GNU system, developed by the GNU Project. There really is a Linux, and these people are using it, but it is just a part of the system they use. Linux is the kernel: the program in the system that allocates the machine's resources to the other programs that you run. The kernel is an essential part of an operating system, but useless by itself; it can only function in the context of a complete operating system. Linux is normally used in combination with the GNU operating system: the whole system is basically GNU with Linux added, or GNU/Linux. All the so-called "Linux" distributions are really distributions of GNU/Linux.
&gt; I'm writing on C# WPF. Then go to /r/csharp/ because this subreddit is for the C language only.
ok, thx
unrelated but i like those books after which you're named.
So, unless I missed it, I don’t think anyone has touched on where what you’re doing can be unsafe. If you have an error in your build scripts and your #define is defined for one cpp and not another when compiling, then the sizeof will be inconsistent. This will be a problem for any memory operations you make that cross the cpp boundary: you’ll end up copying too much or too little depending on where the error is. The issue won’t generally show up until runtime and it’ll be pretty silent, broadly speaking. As someone else pointed out, if you use composition instead, you’ll end up avoiding this potential problem entirely.
Looks like its because the executable was built with [position independed code](https://gcc.gnu.org/onlinedocs/gcc-9.1.0/gcc/Code-Gen-Options.html#index-fpic), and thus can be loaded at any address. [ASLR](https://en.wikipedia.org/wiki/Address_space_layout_randomization) might also be interesting. Adding `-no-pie` made the address "correct".
To be honest I didn't look _deeply_ into other implementations, but what I didn't like in them: * does not fork (more than useful), * it's ""difficult"" to embed and/or it's more thousands of lines (why?), * it's inconvenient or too verbose to add tests (for example, you have to write the test method and then explicitly add it... etc), * uses macro hacks that limits it's usability (for example, it works with line numbers, or has upper limit on tests because of some predefined structure), * works only in newer C standards (may seem absurd, but if I code in C I like doing things in old style), * ...and projects--especially smaller ones--like using its own "homemade" unit tester (so I am, I would like to use it in my new project), * bonus: I don't like the output style. So, after all these, if I can do things better(?), why not?!
The cleanup attribute should handle the close I thought?
can you disable forking so it's easy to step though with a debugger? does it provide output in some standard format so that continuous integration tools can easily display results? those were the two questions i couldn't answer when looking at it quickly. otherwise, looks neat.
``0x00000000000006b8`` may be the file offset.
This is after I added the -no-pie flag. &amp;#x200B; (gdb) run Breakpoint 1, main () at firstprog.c:6 6 for (i = 0; i &lt; 10; i++) // loop 10 times (gdb) disassemble main Dump of assembler code for function main: 0x00000000004004f6 &lt;+0&gt;: push rbp 0x00000000004004f7 &lt;+1&gt;: mov rbp,rsp 0x00000000004004fa &lt;+4&gt;: sub rsp,0x10 =&gt; 0x00000000004004fe &lt;+8&gt;: mov DWORD PTR [rbp-0x4],0x0 0x0000000000400505 &lt;+15&gt;: jmp 0x400517 &lt;main+33&gt; 0x0000000000400507 &lt;+17&gt;: lea rdi,[rip+0xa6] # 0x4005b4 0x000000000040050e &lt;+24&gt;: call 0x4003f0 &lt;puts@plt&gt; 0x0000000000400513 &lt;+29&gt;: add DWORD PTR [rbp-0x4],0x1 0x0000000000400517 &lt;+33&gt;: cmp DWORD PTR [rbp-0x4],0x9 0x000000000040051b &lt;+37&gt;: jle 0x400507 &lt;main+17&gt; 0x000000000040051d &lt;+39&gt;: mov eax,0x0 0x0000000000400522 &lt;+44&gt;: leave 0x0000000000400523 &lt;+45&gt;: ret End of assembler dump. (gdb) info register $rip rip 0x4004fe 0x4004fe &lt;main+8&gt;
Hahaha yeah, they're still my favorite to this day :)
Put it all here. Reddit is your free unlimited storage code repository
Realizing that is essentially what prompted me to make the post, just because I was unsure of the behavior. I've changed the code now fix the issue.
Gotcha, makes sense. Wanted to be sure that was addressed because it’s a real issue. Basically, anytime you have a #define in your header, you now have to leak that definition to every build object in your sources to be safe. It’s definitely a great observation many don’t realize.
Read the man page for fprintf().
What is the actual code you'd like us to analyze? I would also as a small point of order put your NULL pointer check higher and exit sooner. No need to go through all the input if you can't save it. I'm also old school and prefer the safety of ``` IF(NULL == target) ```
mainly the ending code where I'm attempting to put the output from this program into a file thank you for the tip about moving up the null checker - I will make that change
I think I'm missing something. There's only a comment... I don't see any stdio based file io.
I have toyed with this but considering the amount and variety of my output (printing out a table along with summary statements about totals etc.), I didn't know how to use fprintf() for copying more than a sentence or integers. I need all of this info to be sent to another file: printf("\\nMonthly Income: %.2f\\n", income); **for** (i = 0; i &lt; 13; i++) { total\_expenses = total\_expenses + expenses\[i\]; printf("%s: %.2f\\n", expenseNames\[i\], expenses\[i\]); } total = income - (total\_expenses + tax + retirement); printf("\\nTaxes are 15%% of income or $%.2f.\\n", tax); printf("Retirement Savings is 10%% of income or $%.2f.\\n", retirement); printf("You have $%.2f left over this month.\\n", total);
Fixed it. I copied and pasted a slightly different version that I'd been working on instead. In this version, I'm attempting to make this file the source code (is that even possible?) and transfer it a separate file that I'm calling target.
I agree with that. Especially for how you did the parameter
[https://pastebin.com/embed\\\_js/XNCJuHgX](https://pastebin.com/embed\_js/XNCJuHgX)
Read the documentation like Matador told you. Also, if you're getting error messages, show them. And show us the exact code you're testing, not “a slightly different version”.
Your edit will copy all of source into target. However I don't see anywhere that you populate source.
I’m kinda a c noob, so someone correct me if I’m wrong, but I think fprintf is literally printf but for files. You pass in the file pointer you want, then the string and and any variables to format. Just change ‘printf’ to ‘fprintf’, add in the file pointer, and I think your program will be done.
Would you mind copying the link to the page that he is talking about? I looked on the main page and the side bar and could not find the page he was referring to.
That's what I was afraid it would do, but I'm at loss for what function I should use instead. My source is populated by project10.c. This is how I wrote it in my code: FILE \*source = fopen("project10.c", "r");
The problem I'm running into is that I think that will print the entire file and I just want a large chunk instead.
Type `man fprintf` in a terminal. Or Google “man fprintf”. Or look up fprintf in your compiler's documentation.
So your goal is to take the input from the user and store it. You mentioned "tables" in another comment but nothing in your code allows a "table" so there's some misunderstanding on what exactly is being input. Furthermore, a CSV is never going to have tables in it. It's a Comma Separated Value table itself. You can't store a meta object like a table in the data construct. Everything you want to do can be achieved with the stdio library, but you need to figure out how you want to format it in the CSV style. Provide an example of what you expect to see when you open the CSV and we can help guide you to the structure of your fprintf statements.
Oh, I thought this was a resource from Reddit. Yeah, I've looked up fprintf(), read it in my textbook, and none of the examples I've found do what my professor wants me to do in the assignment.
Note: I tried to trim down my code to bare necessities/what's relevant, but if you would like me to post my code it's entirety I'm happy to do that. By table, I meant listing of information. *This is the output that prints to the screen that I need to move to a file.* **Monthly Income: 2500.00** **Electricity: 49.50** **Water/Trash: 49.50** **Natural Gas: 100.25** **Internet: 75.38** **Cell Phone: 64.39** **Car Payment: 56.89** **Student Loan Payment: 869.93** **Car Insurance: 987.23** **Health Insurance: 87.33** **Dental Insurance: 97.33** **Groceries: 743.32** **Dining Out: 97.55** **Mortgage/Rent: 978.88** **Taxes are 15% of income or $375.00.** **Retirement Savings is 10% of income or $250.00.** **You have $-2382.48 left over this month.** &amp;#x200B; As far as CSV goes, that was a professor recommendation. His instructions were "The output file may be either comma separated values so it could be viewed in excel or it may be any easily viewable format you choose." Since I'm working on a Mac and have Numbers instead of Excel - I thought it would be easier to use a csv file, but if there is a better file type out there to use I will be happy to use that instead. I was hoping that could be solved by simply tagging .csv at the end of the file name.
This is bad advice, platform A and platform B may both have different definitions for network types, this leaves stack memory potentially uninitialized
Well after seeing the extreme price difference between linux and Windows OS's on AWS, it looks like I'll have to use linux for this project anyway.
No CSV should be the right file type for that. You just need to figure out how you want it formatted in CSV. If you do each line end with a comma, everything will be in one cell in Excel or numbers. Play around with how your want it to look then where the cell text ends that's where your want to add a comma to the output. Just think of a CSV as text file with lots of extra commas lol fprintf will output each line as you want it. I would recommend just inserting the file IO at the same time you're asking. So a cin should be followed by the printf and the fprintf.
Hmm, I missed that. Yes they should. Attributes like that are a compiler extension, not part of the C standard, so tools like cppcheck will not be able to handle them appropriately.
What are you doing in initialiser? What happens when you alloc a tpolynome, set *prem, then call initialiser?
Unfortunately, I can't use cin because we're only supposed to use functions learned in class. So basically, there's no shortcut for transferring my info to another file. It's basically a line by line job. Ex: **printf("\\nMonthly Income: %.2f\\n", income);** **fprintf(target, "\\nMonthly Income: %.2f\\n", income);** &amp;#x200B; But, can I copy a for loop into a fprintf statement? Would it look like this? **for** (i = 0; i &lt; 13; i++) { total\_expenses = total\_expenses + expenses\[i\]; printf("%s: %.2f\\n", expenseNames\[i\], expenses\[i\]); } fprintf(target, **for** (i = 0; i &lt; 13; i++) { total\_expenses = total\_expenses + expenses\[i\]; printf("%s: %.2f\\n", expenseNames\[i\], expenses\[i\]); });
Thanks for the suggestions. Added `TEST_NOFORK` option, but I'm get stucked with your second question itself. What do you mean by it? Could you show me some example?
Strangely it handles file descriptors, directories, and memory allocations perfectly well! Only falls apart on `FILE *`. Do you know of any good idioms for reading a number from a file other than fopen, fscanf, fclose? I am using dprintf elsewhere in my project, and I enjoy the fd based interface more than FILE anyway.
this is what check does: https://libcheck.github.io/check/doc/check_html/check_4.html#Test-Logging this is the jenkins (continuous integration server) issue that supports reading the above and displaying the results: https://issues.jenkins-ci.org/browse/JENKINS-10909 so when you run c unit tests in jenkins with the check library, lenkins provides you with a pretty web report showing how many test passed / failed. this may be going beyond "small and simple" of course... :)
Look at the return type of your function and the type of the value you return.
Wait wait wait... You've got a file, it has information, but you only want a small set of it? If that's correct, is the information always of the same key? {Key:Value} {"Mortgage:" : $2020} Like on the example you have me there are lines that start with some text and then have a value. It's it always the same lines with the same text key followed by a user input value?
It's an algorithm problem not a mishandling of fprintf. Stop being a dick.
Cool. Doesn't seem too hard to implement, just a bunch of \`fprintf\`-s. :)
Yes, you just need to set it as remote in git `git remote set-url https://reddit.com/r/C_Programming`
Note that it says "any file descriptor", not "all file descriptors". That works differently from just about anything else related to file descriptors.
Where are you blocked at ?
I think the very first blank should be malloc(sizeof(queue\_t)); Currently stuck at the enqueue(): if (q-&gt;head == NULL) { q-&gt;head = q-&gt;tail = malloc(sizeof(node\_t)); \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ = NULL; } else { \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ = \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ = malloc(sizeof(\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_)); \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ = NULL; } q-&gt;tail-&gt;val = val; } &amp;#x200B; I'm having difficulty understanding what would be assigned null if the queue is empty at first.
well u gotta initialise the thing u allocated right?
htons means "host to network order". "Network order" is defined as "big-endian". E.g., the htons, htonl, ntohs, ntohl functions can only convert between native order and big-endian order. They cannot convert between native order and little-endian.
\`if (fp = NULL) { ... }\` is wrong. "Wherever the exe is on your computer is where the file is created" is wrong. I didn't watch the rest of the video but IMO you shouldn't spread misinformation if you're teaching. Not saying you're doing it maliciously, but you should at least take down the video and correct these mistakes (and any others).
You need to work off a script, edit, and review. Not to mention the mistakes in the chunk of code you wrote. Hint, = is not == !!!! And unfortunately a common mistake in C that results in unexpected behaviour. = always evaluates as true in a conditional.
I don't think if there is an error cos I do lot of research on this. Ok, if there is an error now watch the full video and tell me how to fix it then.
It's doesn't always evaluate to true in a conditional. It returns the value of the assignment, NULL, which evaluates to false in this case. Which makes it seem as if it's functioning correctly. It's a bug on top of a bug.
Regardless, the errors remain. I pointed them out in my last comment. What are you confused about that you need help with fixing?
Oops yeah I got it wrong too! Forgot it returned the value assign which can sometime be NULL. Which is what makes it unexpected/undefined behaviour! Unexpected behaviour is best behaviour!
Hint = isn’t typically used in conditionals. Try ==.
Do u watch the codes properly?
You just having fun trolling c programmers on a sat night or what?
Sorry for the pretty late post, but I now have a follow up question. What is the difference between calling pthread_detach() and setting the thread attribute to detachable using pthread_attr_setdetachstate() (before creating the thread that is)?
No error in the code the programs works fine everything is correct I don't need help
`FILE *file = NULL;` `if (file = NULL) {` `printf("The file is NULL.\n");` `} else {` `printf("The file is something else.\n");` `}` What does this print to the console? "The file is NULL" or "The file is something else"?
This is your idea but mine is ok.
What?
Keyboard signals are delivered to the foreground process group. You don't want your shell to receive the signal, thus you have to move it out of the foreground group. To do that you have to create a new process group by calling setpgrp after fork, then calling tcsetpgrp to set the new group as the foreground one. Once the process exits you call tcsetpgrp again to switch it back to the shell. More info at http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap11.html
&gt; Why is now 'count' equal to 836 before defining the value of 'weight'? Because every time you've said the compiler "sets the corresponding bits to 0", you're wrong. An automatic variable declared without an initializer has an undefined initial value.
Also, printf from childHandler can interfere with printf from main.
BTW, I'm still very new to c++ so don't judge. Thanks!
This is for C programming, not C++. That said, there's a lot wrong. Try: if (x == 1 || x == 2 || x == 3) { //....} Also handle negative numbers. Also I'm not even sure if cin to an integer works like that. I'm assuming you can't get your code to run at all right? In the future, place refrain from asking Reddit for help on your programming homework. You need to do it yourself. We all struggle at first but it's the way it is
Consider posting in r/learncpp Also. You’ll get a better response if you ask a specific question. Not just “help”. Something alone the lines of: I want to do X. This is what I’ve tried. This is what’s happening. This is what I expect to happen.
&gt; An automatic variable (of any type, not just a union) declared without an initializer has an undefined initial value. I'll mark in caps this in my notebook. &gt; Careful here. You're likely to be using 16-bit little-endian `shorts` and 32-bit IEEE 754 single-precision `floats`. This means when you store 9 into the `short` you're leaving the remaining two bytes of your union object undefined. So when storing 9 into the `short`, I'm only writing the two bytes of that field and leaving the other two bytes untouched, so I should assume that the union's memory is 0x????0009, right? And it was just luck again that I got `0x00000009` in the example. Thanks very much for your previous answer.
&gt; So when storing 9 into the short, I'm only writing the two bytes of that field and leaving the other two bytes untouched, so I should assume that the union's memory is 0x????0009, right? If you're treating the whole object as a little-endian 32-bit unsigned integer, yes.
There is no difference. The latter allows you to make a thread detached from the moment it is created.
&gt; So when storing 9 into the short, I'm only writing the two bytes of that field and leaving the other two bytes untouched, so I should assume that the union's memory is 0x????0009, right? And it was just luck again that I got 0x00000009 in the example. Exactly.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Please don't post these.
C# is off topic in this subreddit. Please post C# questions to /r/learncsharp instead.
Thanks again
Thanks
You are making a lot of assumptions on undefined behavior. If you do this on a different processor with a different compiler, you might see wildly different results. Generally, on a little endian system your union aliases like so | unused 16 bits | unused 16 bits | top(uint16) | bottom(uint16) | | float | | float | That being said, on a big endian system it could(and likely would) be different, and on a 16 bit, PDP-10 or a novel digital signal processor, it will be wildly different. The usage of a union is to have one section of memory that's reusable with different types of inputs. However, it is up to the programmer to use it in a meaningful manner. My favorite way to use a union is to have a single return, when something might fail (like overflowing int_max) enum safe_values{ value, error } struct safe_int{ enum safe_values type; union { int value, int error } }; So now I can create functions that return an error or a value, similar to C++'s Optional. safe_int safe_add(safe_int v1, safe_int v2); Many times I work with motors or other devices that need to fail safely, so if a value is issued that might cause overflow, the system shuts down before the value leaves my domain. const safe_int sum = safe_add(a, b); const safe_int prod = safe_mult(sum, c); if (prod.type == error){ safe_fail("__LINE__ Math Engine Fail during __FILE__ "); } Anyway, TLDR: **Don't rely on the compiler implementation of Union.** If you see this in coding guidelines, you now understand why.
There are already a lot of good answers, but sizeof is one of the functions that works at compile-time and run-time.
What does the rest of the code look like? Those warnings are there for a reason.
It's simply because "NewEmployee-&gt;prev" is a pointer to a structure, while startlist is also a pointer to a structure (and thus &amp;startlist is a pointer to a pointer). &amp;#x200B; Definition of the structure; &gt;struct Employee { /\* Employee details \*/ char name\[MAX\_NAME\_LENGTH+1\]; /\* name string \*/ char sex; /\* sex identifier, either 'M' or 'F' \*/ int age; /\* age \*/ char job\[MAX\_JOB\_LENGTH+1\]; /\* job string \*/ /\* pointers to previous and next employee structures in the linked list \*/ struct Employee \*prev; struct Employee \*next; }; declaration of startlist; &gt;struct Employee \*startlist; startlist = NULL; declaration of NewEmployee; &gt;struct Employee\* NewEmployee; NewEmployee = (struct Employee \*) malloc(sizeof(struct Employee)); After filling in other parts of NewEmployee (name, sex, age and job), then: &gt;if (startlist == NULL) { /\*No Existing List\*/ fprintf(stderr, "\\nNo Existing List"); NewEmployee-&gt;prev = \&amp;startlist; startlist = NewEmployee; NewEmployee-&gt;next = NULL; } &amp;#x200B; (after the first occurance of this function, the program will never satisfy the if statement)
Show the rest of your code -- we have no idea what `startlist` or `struct Employee` is without more context. If you want us to figure out what your compiler is saying, give us all of the information that your compiler would have! I'm going out on a limb, and I'm willing to bet that `startlist` is a `struct Employee *`, and that you just need to set `NewEmployee-&gt;prev = startlist;`... BUT without any further context, that's just an up-in-the-air guess based on seeing a metric-fuck-tonne of intro-to-comp-sci linked-list assignments....
You would be correct, if the objective was to ensure the types matched up perfectly. startlist and NewEmployee-&gt;prev are both pointers to the structure Employee. But, I *want* memory address of startlist to be moved to NewEmployee-&gt;prev. &amp;#x200B; Definition of the structure; &gt;struct Employee { /\* Employee details \*/ char name\[MAX\_NAME\_LENGTH+1\]; /\* name string \*/ char sex; /\* sex identifier, either 'M' or 'F'; validation later \*/ int age; /\* age \*/char job\[MAX\_JOB\_LENGTH+1\]; /\* job string \*/ /\* pointers to previous and next employee structures in the linked list \*/ struct Employee \*prev; struct Employee \*next; }; declaration of startlist; &gt;struct Employee \*startlist; startlist = NULL; declaration of NewEmployee; &gt;struct Employee\* NewEmployee; NewEmployee = (struct Employee \*) malloc(sizeof(struct Employee)); After filling in other parts of NewEmployee (name, sex, age and job), then: &gt;if (startlist == NULL) { /\*No Existing List\*/ fprintf(stderr, "\\nNo Existing List"); NewEmployee-&gt;prev = \&amp;startlist; startlist = NewEmployee; NewEmployee-&gt;next = NULL ;} (after the first occurance of this function, the program will never satisfy the if statement)
 NewEmployee-&gt;prev = &amp;startlist; This line means, set NewEmployee-&gt;prev to point to where startlist is stored in memory. Are you trying to use the address of startlist as a sentinel value? Or did you actually mean: NewEmployee-&gt;prev = startlist; Or even: NewEmployee-&gt;prev = NULL;
When you are adding the first node of a doubly-linked list, you probably want to set NewEmployee-&gt;next to NULL and NewEmployee-&gt;prev to NULL to indicate that there is neither a next element nor a previous element.
struct Employee { /\* Employee details \*/ char name\[MAX\_NAME\_LENGTH+1\]; /\* name string \*/ char sex; /\* sex identifier, either 'M' or 'F'; validation later \*/ int age; /\* age \*/char job\[MAX\_JOB\_LENGTH+1\]; /\* job string \*/ /\* pointers to previous and next employee structures in the linked list \*/ struct Employee \*prev; struct Employee \*next; };
Why do you want `NewEmployee-&gt;prev` (which is a pointer) to point to an address of a pointer rather than the value of that pointer itself? It doesn't make sense... What am I missing here? I'm pretty certain your understanding of linked lists is off, if your intention is to set `NewEmployee-&gt;prev` to be an address of a pointer rather than the address of a node. I'm *also* willing to bet that the reason that your program seems to be working perfectly when you're setting `prev` to a struct Employee**` is that your traversal &amp; access functions are doing a double de-reference to access the data members...
Why do you want that? It will lead to undefined behavior if you later dereference NewEmployee-&gt;prev. If you actually do want that to happen, which I highly doubt, use: NewEmployee-&gt;prev = (struct Employee*) &amp;startlist;
'truct Employee { /\* Employee details \*/ char name\[MAX\_NAME\_LENGTH+1\]; /\* name string \*/ char sex; /\* sex identifier, either 'M' or 'F'; validation later \*/ int age; /\* age \*/char job\[MAX\_JOB\_LENGTH+1\]; /\* job string \*/ /\* pointers to previous and next employee structures in the linked list \*/ struct Employee \*prev; struct Employee \*next; };'
NewEmployee-&gt;next gets set to NULL already, while NewEmployee-&gt;prev gets set to the memory address of startlist.
&gt; If you actually do want that to happen, which I highly doubt Indeed -- this is one of those "I understand what you're asking for, but that's not what you actually want" type of questions.
&gt; You are making a lot of assumptions on undefined behavior. &gt; &gt; If you do this on a different processor with a different compiler, you might see wildly different results. &gt; &gt; Generally, on a little endian system your union aliases like so &gt; &gt; | unused 16 bits | unused 16 bits | top(uint16) | bottom(uint16) | &gt; | float | &gt; | float | &gt; That being said, on a big endian system it could(and likely would) be different, and on a 16 bit, PDP-10 or a novel digital signal processor, it will be wildly different. &gt; &gt; &gt; Anyway, TLDR: **Don't rely on the compiler implementation of Union**. If you see this in coding guidelines, you now understand why. Thanks a lot for the advice. I'll try to learn more things about the compiler and the compilation process, and of course be very careful when something might result in undefined behaviour. &gt; The usage of a union is to have one section of memory that's reusable with different types of inputs. However, it is up to the programmer to use it in a meaningful manner. &gt; Understood. &gt; My favorite way to use a union is to have a single return, when something might fail (like overflowing int_max) &gt; &gt; enum safe_values{ &gt; value, error &gt; } &gt; &gt; &gt; struct safe_int{ &gt; enum safe_values type; &gt; union { &gt; int value, &gt; int error &gt; } &gt; }; &gt; &gt; So now I can create functions that return an error or a value, similar to C++'s Optional. &gt; &gt; safe_int safe_add(safe_int v1, safe_int v2); &gt; Many times I work with motors or other devices that need to fail safely, so if a value is issued that might cause overflow, the system shuts down before the value leaves my domain. &gt; &gt; const safe_int sum = safe_add(a, b); &gt; const safe_int prod = safe_mult(sum, c); &gt; if (prod.type == error){ &gt; safe_fail("__LINE__ Math Engine Fail during __FILE__ "); &gt; } &gt; I'm just starting to learn about programming (reading my first C introductory book, "Head First C"), and I've only read a few pages about structs and unions (the other three programming books I've read so far are " The Elements of Computing Systems", "Simply Scheme" and the first three chapters of "Structure and Interpretation of Computer Programs", and they didn't deal with unions), and I'm not very sure when it's appropriate to use unions, so thanks very much for your great example, I can see the advantage of using a union in that case.
I think I'll stick with SDL, I've been watching some tutorial videos already and I liked the it. Thx for the suggestion though.
NewEmployee-&gt;prev = (struct Employee \*) \&amp;startlist; &amp;#x200B; I think you should use a *list head* instead, a special Employee that has prev &amp; next like actual nodes, but serves only to reduce special cases when inserting or deleting nodes.
Unions are really cool, but they are not beginner friendly and are always introduced way too early. Cheers mate!
I don't understand can you wright the code for me
One more thing just for future (self)reference. Should it be: enum safe_values{ value, error }; struct safe_int{ enum safe_values type; union { int value; int error; }; }; instead of you corresponding block of code, right?
If you add the line: unsigned char bytes[sizeof(float)]; to your union, you can print out the bytes in the order they are stored: void showBytes(union quantity q) { int i; for(i = 0; i &lt; sizeof(float); i++) { printf(" %x", q.bytes[i]); } printf("\n"); } It's almost guaranteed that sizeof(float) is gonna be 4. Adding a char array of size 4 let's you take a peek at the individual bytes. The char is unsigned because printf sometimes gets confused if you don't. If you are on a little- endian system, the bytes are going to be stored backwards from what you are used to seeing. Your short is probably the first two bytes, your two floats are all four bytes. 32 bit IEEE 754 floating point numbers have the first bit as the sign bit, 8 bits that are the exponent, and 23 bits for the base. There are tons of videos on youtube of people converting numbers on paper.
Why do u need to protect ur own address space?
Because, if I set NewEmployee-prev to startlist itself, it would point to itself, and thus if I ever transversed the list backwards, it would infinitely loop through the same element. My university provided a specification, which even contains useful information on how to implement the program. In which is the picture below. (ignoring the 2nd and 3rd Employees, NewEmployee-&gt;next = NULL, since at this point in the code, there are no employees other than NewEmployee) My version makes prev point to Employee\_list (instead of NULL). If I were to set 'NewEmployee-&gt;prev = startlist', Carol Verderman (NewEmployee) would point to itself, thus looping if I ever decided to look through the linked list backwards.
If you add the line: unsigned char bytes[sizeof(float)]; to your union, you can print out the bytes in the order they are stored: void showBytes(union quantity q) { int i; for(i = 0; i &lt; sizeof(float); i++) { printf(" %x", q.bytes[i]); } printf("\n"); } } It's almost guaranteed that sizeof(float) is gonna be 4. Adding a char array of size 4 let's you take a peek at the individual bytes. The char is unsigned because printf sometimes gets confused if you don't. If you are on a little- endian system, the bytes are going to be stored backwards from what you are used to seeing. Your short is probably the first two bytes, your two floats are all four bytes. 32 bit IEEE 754 floating point numbers have the first bit as the sign bit, 8 bits that are the exponent, and 23 bits for the base. There are tons of videos on youtube of people converting numbers on paper.
....ohhhhh, thank you. Also, how did you get the black boxes, currently I'm just using the quote boxes.... \*blush\*
Would you suggest to create another structure with just two pointers in it, or just use the current definition of Employee (and leave descriptors empty)
In Markdown, you put four spaces at the beginning of each line. In the Fancy Pants Editor, click on the three dots, and select 'Code Block' from that menu, which looks like a rounded rectangle with a T in the top left.
You clearly know how to use `printf()` already; `fprintf()` is exactly the same, except it prints to a file, which is what you wanted.
What you're putting in your linked list are pointers to specific positions in a single buffer, `input`, which is reused for each line of input. You need to store copies of those strings instead. The easiest way to fix your program is to add a few `strdup()` calls in `add()`.
You might have to reverse-engineer the game's code to find out how it interprets the data stored in the files, which is well outside the scope of this subreddit, and definitely not easy in the slightest.
You may have found a bug in cppcheck then. On my system, default cppcheck rules are located under `/usr/share/cppcheck/cfg/` so you might peek around in there and see if you can find the ruleset related to the cleanup attribute. You might find one missing for the FILE pointers, if so you should file a bug report with the cppcheck package maintainer in your distro. For formatted ASCII files, I prefer the stdlib I/O model (i.e. `FILE *`); the `fd` based model you are keen on is part of the Unix I/O model. So that would be open(), read(), close(). One problem you'll run into immediately is that the low level Unix I/O model works in raw bytes. As in, working with binary files. So what kind of files are you working with? ASCII or binary? If you are working with ASCII then I would suggest sticking with stdlib I/O and perhaps using fprintf instead of dprintf.
I was actually thinking about this last night. really all that happens is the size of the largest member is allocated by the compiler, and the other types are just casted from that address.
Hey thanks! I think i managed to do it! How do i handle the free() of the strings?
I'd use a normal Employee, no fuss, just a bit of wasted memory. The textbook way is, I think struct links { struct links *next, *prev; }; struct Employee { ... struct links list; ... }; struct links startlist; That way the employees could be in multiple lists at the same time. It needs manual calculation (offsetof et al) to get the Employee from the pointer to struct links. Gets inconvenient...
r/REGames, r/ReverseEngineering
Thank you for your answer!
Thank you for this. I shall go there. Very informative reply!
Not entirely sure what you mean, but here is the program, [https://drive.google.com/open?id=1On2L8PXYSuyWzq4i5bg6aH7vCbPyJ8W9](https://drive.google.com/open?id=1On2L8PXYSuyWzq4i5bg6aH7vCbPyJ8W9)
it can be a tricky thing if u have no documentation available. a good way to start off is save files. u produce a save file, make a slight change, then compare the 2 versions with a hex editor, and see how the 2 files vary, then over time u can come to understand all the elements of the file for archives, I'd start at least by opening the file with a hex editor (xxd's good on linux) and poking around some of the fields that look obvious. but beyond that I'm not really sure what to recommend.
This was also very informative, thank you man. I will try opening with hex editor and look at the archives. I dont understand how this guy in the forum could do it in a matter of minutes, unless he was lying how quickly he did it of course. He did send proof that he had done it, so he didnt lie about that at least.
One test doesn't affect the outcome of others. Suppose you have made a buffer overflow in one test, but it passes (or better it fails), that makes other test(s) always passing or always failing or sometimes failing. You think it works perfect, however it doesn't test the state you expect. So it tries minimizing the chance of leaving bugs in your program. Plus, it makes very convenient if you want to work with one state of an object multiple times.
Ohh, hadn't thought of that. Thanks
You don't actually need to do the weird, erroneous pointer cast. `NewEmployee-&gt;prev = NULL;` works fine.
time's a funny thing :p all the best,
take the len of each str in add func and malloc them. I think for free you can do it with x.str1, x.str2, etc.
Thanks! I should only free them if i remove them from the list or exit the program right?
 &gt;(struct Employee \*) NewEmployee-&gt;prev = (struct Employee \*\*) \&amp;startlist; &gt; &gt;this no tmake to much sense, because NewEmployee is already declared as struct Employee \*
yes
Thanks a lot, I've been able to print the union's memory bytes using your function.
Uninitialized input\[0\] could just happen to contain 'x'. If input ends for some reason, before the x is received, the loop goes to warp speed repeating the last line. while (fgets(input, MAXINPUT, stdin)) { if (input[0] == 'x') break;
If this is just an exercise, don't bother. It all gets freed when the program terminates anyway. Otherwise, write a `remove()` or `delete()` function that removes a node from the list and then frees the strings and the node, and call it until the list is empty.
https://gamehacking.org/ https://www.cheatengine.org/ There is a near infinite amount of guides and tutorials for game modding and game hacking to be found on the internet.
This subreddit is about programming in C. As your post is not about programming in C, I have removed it.
no-one gets syntax right all the time. if that's what the compiler says then that's what the compiler says. you really don't need to ask about each small typo. learn the difference between what is import and what is just noise.
If you add `-Wall` to your compile flags you will see that the compiler gives a warning every time you use an uninitialized value.
Sorry for that, I didn't wanted to be mean by highlighting other user's typos, but just wanted to confirm that I was getting it right (I'm quite insecure about programming). But yeah, I understand what you mean, and I'll try not to do it next time and waste other people's time.
Yeah, sorry, at the time of posting, I assumed the casting did something else than what it actually does....
&gt; If you add -Wall to your compile flags you will see that the compiler gives a warning every time you use an uninitialized value. When I compile my code with that flag, I don't get a warning when using an union's field not previously initialised. But if I add a variable to my code: int main() { union quantity q1 = {9}; // C89 style printf("Count = %hi\n", q1.count); printf("Weight = %f\n", q1.weight); printf("Volume = %f\n", q1.volume); int i; printf("%d\n", i); .... } I do get a warning: gcc -Wall -Wextra -g unions.c -o unions unions.c: In function ‘main’: unions.c:36:9: warning: ‘i’ is used uninitialized in this function [-Wuninitialized] printf("%d\n", i); ^~~~~~~~~~~~~~~~~
Speaking solely for myself, I won't even attempt to help you because the lack of indentation makes the code too hard to read.
I'll abuse this thread to ask a related question. typedef union { struct { unsigned char bit1 : 1; unsigned char bit2 : 1; unsigned char bit3 : 1; unsigned char bit4 : 1; unsigned char bit5 : 1; unsigned char bit6 : 1; unsigned char bit7 : 1; unsigned char bit8 : 1; }u; unsigned char status; }DeviceStatus; This is a union enabling you to access the bits of a byte. How does this work? As far as I've understood unions, all union members overlap each other in memory. The members of the union is the struct u and the char status. u is 8 times as large as status. Sooooo only bit8 should overlap with status? But as this code indeed does work, I must have a misunderstanding
The compiler isn't as reliable about uninitialized code for unions, because they can be set by any of their symbols. You need to keep track yourself.
The ": 1" notation is a bit field: https://en.wikipedia.org/wiki/Bit_field#C_programming_language
Huh. I don't use unions much. TIL.
Think about how you'll determine the right index for \`BF\_fontMap\` - it starts with ASCII 32 (space), so you'll have to do something with ch first. When you have that, you know which five bytes from \`BF\_fontMap\` to use. After that, all that's left to figure out is how to extract each of the 8 pixels from a byte. Each bit corresponds to a pixel, so the only task left is to extract every single bit from each of the five bytes. Hint: look into the \`&gt;&gt;\` (shift right) and \`&amp;\` (logical and) operators.
Thanks for the clarification.
Added libcheck XML output option (experimental of course). Check out at the bottom of README if you are interested.
I told you to not post these. If you post another one, I'm going to ban you.
I am calling lockf, so it is useful to have the fd available. Converting from the file stream to fd is another step.
AFAIK the union field needs to have a name unless you’re making use of GNU or MS extensions.
The `:1`s allow, but do not per se require, the compiler to pack each field of `u` into a single bit. (You should usually just stick with `unsigned`, not `unsigned char` for those bitfields; IIRC anything except `unsigned int`, `signed int`, and `_Bool` are nonstandard extensions and the `char` part of things would be mostly ignored when the compiler does support it.) `DeviceStatus::u`’s most-packed-possible representation therefore occupies ≥8 bits, rather than the 8 bytes it would occupy without the `:1`s. `u` and `status` are the two members of the union that overlap each other; assuming maximal packing, both have the same size and alignment, and (assuming `CHAR_BIT==8`) each bit of `status` has a name in `u`. As to whether the bit orderings match up—that is, whether `bit1` corresponds to the 1s place in `status`—usually earlier bitfields correspond to less-significant bits, but that’s not mandatory per standards. More generally, the standards specify very little about the in-memory layout of a bitfield beyond that something with a declared size of *n* bits must occupy at least *n* bits. Unless the ABI &amp;c. specify otherwise, the compiler is free to leave those bitfields unpacked, which could leave you with the equivalent of typedef union { struct { unsigned char bit1, bit2, bit3, bit4, bit5, bit6, bit7, bit8; } u; unsigned char status; } DeviceStatus; except the bitfield setup prevents you from querying the address, size, or alignment of individual `bit`s.
&gt; I don't see where that's happening. If you run your code through a debugger, it will stop on the exact instruction that causes the fault. Think about the arguments to this program. The code handling the arguments doesn't match the comment.
A segfault happens when you try to access memory outside of what's available to your application, on a platform with an MMU. (I'm an embedded guy, no segfaults when you don't have segments.) If it's showing address 0 you're probably dereferencing a null pointer. You can always comment out sections and see where it's breaking, or printf() some values along the way. I'm too lazy to look up the sockets API right now, and too high to want to read it anyway.
Without posting any code, we literally are doing your homework for you.
Oh boy, /u/pandabash never posts! (Or always delete's their posts) Their last one was on /r/medicalmarijuana over a year ago, and before that over three years ago!
Sorry, that is my bad do { do { Console.Write("How many marks are you going to enter: "); temp = Convert.ToInt32(); markCount = Console.ReadLine(temp); Console.Write("Please enter the marks, one per line: "); temp = Convert.ToInt32(); mark = Console.ReadLine(temp); } while (markCount == markCount); Console.WriteLine("Thank you, here are the class results: "); Console.WriteLine($"Number of marks: {markCount}"); Console.WriteLine($"Average mark: {mark / markCount}"); Console.Write("Would you like to enter another class (Y or N): "); again = Console.ReadLine(); } while (again == Y); i know my code isn't perfect (am still learning) but I need the nested do while code to be working, cannot fix it.
Respectfully, I'm going to have to agree with /u/whoisthere. Either way we're going to need more background to the problem.
This is not C, this is C-sharp, and they are very different languages. Ask in /r/learncsharp.
There are a couple of reasons why it'll never exit the loop. First, you define `markCount` in the inner loop, hence it's reinitialized every loop. It should be defined in the outer loop. Second, your condition on the inner loop is `markCount == markCount` which will always be true, ergo the loop will never terminate. Solution: What you need to do is move the "# of marks" question and the initialization of `markCount` out of the inner loop. Then, at the end of the inner loop you need to decrement it. Basically treat it as a counter and remove one for each loop iteration. Finally you will need to adjust your inner loop's condition to something like `markcount &gt; 0`. Good luck. :)
Ahh, i understand, sorry for the confusion. Thanks for the help!
So dealing with files is really similar to dealing with the terminal. Most functions that you use in the terminal have an equivalent with files (as I understand it). Specifically addressing your problem, the basic flow is going to be as follows: - Open the input file - read it line by line (or even character by character), saving everything that you want and is useful to you. - do any manipulations on the data you want. - output to the file by “printing” to it using fprintf() and passing it the stores data. You don’t fprintf the whole file. You just store the data you want from the input file, do what you want to it, then print that out. Depending on exactly what way would be most convenient for you to read from the file I would look at a function like [getline](https://linux.die.net/man/3/getline). Or maybe [fscanf](https://www.ibm.com/support/knowledgecenter/en/ssw_ibm_i_71/rtref/fscanf.htm) which as far as I understand it, is kinda like the opposite of fprintf; instead of outputting formatted values to a file, it reads formatted values into variables you supply it. There’s so many more functions for reading from files though. PS. Don’t be intimidated that those are doc pages not tutorial pages. They have example code if you scroll down. Hope this helps. I can expand if you need more explanation on something specific
There's a couple of major problems here. &gt; scanf("%s",&amp;user); The `%s` requires a `char *` argument, but you're passing an argument of type `char **`. Moreover, you haven't actually allocated any space in which the read string will be stored. &gt; user=="POKA" That compares two `char *` for equality. It will always be false. You need to use a C library function to compare two strings. You'll find this in your course notes.
i did not get this. 1st question: my char\* argunment is "POKA" which is a single word.which is working completely fine in my other exercise.Like if wanted to store a string i could have do it like this: &amp;#x200B; // BASAIC DECLARATION EXERCISE // &amp;#x200B; \#include&lt;stdio.h&gt; main() { &amp;#x200B; char\* string; &amp;#x200B; printf("Enter the value of string: \\n "); scanf("%s",&amp;string); &amp;#x200B; printf("The value of string:%s \\n ",&amp;string); } &amp;#x200B; Here i did not have to alocate any space. 2nd: so you are saying in if(condition).Here in codition they can not compare a string?
You're using a char\*\* argument in this line `char* string;` but and passing an ampersand operator to it without initializing it `scanf("%s", &amp;string)`. Scanf requires char\* arguments and you're passing a char\*\* to it as mentioned above. Moreover, when you're comparing "POKA", which is a char\* value, to string, which is not a char\* value, there will be obviously be a mismatch. Overall, I don't know how your IDE allows this, but this WILL result in a stack corruption. Simply change the initialization of the string variable to `char string[10]` and use strcmp() function to compare and it will work. However, if you do insist on using `char* string` aka dynamic memory allocation, you need to allocate memory for it first, you can read about pointers from your course notes for more information.
Anonymous structures and unions were added in the C11 standard of C.
char user[20]; Also strcmp()
There are no strings. `char *` is a pointer; an address: a number of cell in your RAM; that cell will contain the first letter, the cell after it - the second, and so on, until literal `0`. For example: if you have smth like `char *x = 123;` and want to put STR there, your RAM will be like ``` value in cell | 'S' 'T' 'R' 0 --------------------------------------- # of cell | 123 124 125 126 ``` Ofc you cannot simply use `123` as you have no idea whether this address is already in use by other program. You may obtain correct address by doing either `char x[4];` or `char *x = malloc(4);` where `malloc()` returns a correct position in RAM where you can push 4 bytes safely. You should `free()` this address later so the system will be able to give this memory to another program for their `malloc()`s in both cases using `x` - for example, as an argument to `scanf ` - is like saying "here, there's an address of RAM where you can stuff whatever you read from the input". when you have an `int a` and pass `&amp;a`, you also say "there's an address, push values to corresponding cells" - but the rules of reading and using the cells will be a bit different. And `"something"` is just a syntactic shugar for a pointer that points to RAM that will have `s`, `m`... etc.
[Thanks.it](https://Thanks.it) makes more clear about these stuffs
If you want `scanf()` to allocate space for you, use 'm' as modifier in format description: `%ms`. This may not be portable. More information can be found in the manual page for that function. To compare strings, you can use `strcmp()`, `strncmp()` or some other function from that family. `char* == char*` is a comparison of pointers (memory addresses), not strings they point at (memory blocks). There is no way to directly compare strings or any other arrays in C. You have to use either `memcmp()` or a specialised function (like `strcmp()` for strings). Read about pointers and arrays to learn why.
 #include &lt;stdio.h&gt; const char const *user = "POKA\n"; int main() { char buf[20]; fputs("user: ", stdout); fgets(buf, 20, stdin); printf("%p == %p: %s\n", user, buf, user == buf ? "true" : "false"); }
// CONDITIONAL OVERFLOW Exercise // &amp;#x200B; \#include &lt;cstdio&gt; \#include &lt;cstring&gt; &amp;#x200B; int main() { char\* user = new char \[3000\]; int password; &amp;#x200B; printf("Enter username: "); &amp;#x200B; scanf("%s", user); &amp;#x200B; printf("Enter password: "); &amp;#x200B; scanf("%d",&amp;password); &amp;#x200B; if(strcmp(user, "POKA") == 0) { if(password==789) { printf("Login Successful.."); } else { printf("Incorrect password.Login failed"); } } else { printf("User name is not correct "); } delete \[\] user; }
So here is the run down. Also bare in mind I wrote this in a kind of c++ way. Apologies for the heresy I forgot the subreddit I was in (The heresy is the header files I included, and not returning a value which you can do in c++). But I wrote the parts that matter in C. 1.) Understand what a char \* is. User is a pointer that doesn't actually have any allocated space of its own. So you must allocate space and that is where scanf will place the user input. 2.) You can't just compare "strings" by comparing "pointers". The strcmp function will do what you want. Comparing each member of the array 1 by 1 stopping at the null character ([https://en.wikipedia.org/wiki/Null-terminated\_string](https://en.wikipedia.org/wiki/Null-terminated_string)) Caveats &amp;#x200B; I didn't have to dynamically allocate memory.
I'd just go for `break` :) https://www.tutorialspoint.com/cprogramming/c_break_statement.htm
The correct form is ``` input%5 != 0 ``` Also your while loop doesn’t execute, you should try do-while if you want to use that form
&gt; Moreover, when you're comparing "POKA", which is a char* value, to string, which is not a char* value Nitpick: while technically true, the string's type ("n-element array of `char`" for appropriate n) immediately decays to a character pointer. The `==` operator tests pointer equality, it does not know how to compare something to an array.
Do not use floating point types to represent amounts of money. Floats are not suitable for this. Use integers and store your amounts in units of a cent. Or tenths of a cent, hundredths etc. as required by your application. If you put your amounts into integer variabless you can also use the modulo operator.
How does break statement help with this problem? I don't see it.
In addition to everybody else's comments, note that the modulo operator `%` has undefined behaviour if either operand is a floating-point value. It only has defined behaviour when both operands are integers.
 &gt; Here i did not have to alocate any space. - &gt; char* string; A `char *` is 8 bytes. You allocated 8 bytes of space to fit a pointer, wrote 6 bytes *into* said space, and then printed 5 bytes from said space. The only reason this code "works" is because your test case (`"POKA\n"`) isn't large enough to break it in the most horrendous possible manner. You've managed to achieve a perfect storm of problems that cause your code to *seem* like it's behaving as expected when in reality it's not. I modified your code to demonstrate its problems: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; int main() { char *space = NULL; // 8 bytes of space on 64 bit systems printf("space is %p, but &amp;space is %p\n", space, &amp;space); strcpy(&amp;space, "ABCDEFGHIJKLMNO"); // 16 bytes - first 8 will overwrite space, next 8 will overwrite stack cookie printf("wrote 16 bytes to %p. space is now %p\n", &amp;space, space); return 0; // since the stack cookie was overwritten, this will fail }
Don't use floating point for money, count everything in cents, floating point does not prioritise accuracy
The modulo operator is not applicable to floating point numbers.
C# is off topic in this subreddit. Please post C# questions to /r/learncsharp instead.
&gt; user == buf This is always false. You need strcmp.
you code doesn't compile so i cannot test, but you should ignore the sigint signal in your parent process and the attach the signal to the default signal handler for your childs process. &amp;#x200B; Father : signal(SIGINT, SIG\_IGN); &amp;#x200B; Child: signal(SIGINT, SIG\_DFL);
Thank you!
There is the fmod function
Hm. You may be interested in fdopen that opens a FILE from an already open file descriptor. Then you could store both in a struct and use the descriptor when you need to and take advantage of the buffered, formatted I/O in stdlib too.
I'm not a fan of the modular operator but there are good places to use it. This is not one and IMHO using it here causes the following... 1) Hard to read/understand the end goal 2) No maintainable or really portable 3) Hard to test and software that can't be tested well is bad code. If you must do this may i suggest using a boundary condition. Create macros to clearly state low and high boundaries along with a tolerance. Then check that you are within that expected range. The is quite common of a test case scenario when dealing with floats. Try to be more clear than clever in this situation.
This subreddit is about programming in C only. Merely trying to get an audience of C programmers is not sufficient to make your post on topic. That said, your post is just barely on topic.
Your whole question is very opinionated, it makes me feel like you wanted to agitate people for some reason. I'll answer the question "why people dislike C++ or OOP". I dislike C++ because it's janky, has many nuisances and isn't used correctly by the people who write it. If I take part in a C++ project, there's a huge chance it's basically a C project in which people use auto type and io library of C++. I can't speak for why people dislike OOP, as I never met someone dislike it. It is a way to design and develop programs and can be applied with C, too. It streamlines how a program works very well, as you define things and also define how you can interact with them so your code doesn't get all tangled. I advise you to stop caring about when people say and read up on "structural programming" and "object oriented programming" from books. I can recommend SICP and Object Oriented Thought Process. Both are great reads, and SICP is free.
OOP is a design pattern. Some times it's the right pattern for my program, some times it is not. Elevating OOP from a design pattern to a language paradigm forces me to express everything in terms of OOP even when it makes no sense. That's why I don't like programming in languages with enforced OOP such as Java. My problem with C++ is its large set of unintuitive and redundant features as well as its inclination to produce needlessly complex programs. With every language you inherit a culture and the culture of C++ is one of generalisation at every price. This is the anti-thesis of what I think is good software engineering, so I don't like working with C++. I've [written about this](https://www.reddit.com/r/C_Programming/comments/7okycc/why_learn_c/dsamvec/) before. Another issue is the [ambient complexity](https://www.reddit.com/r/C_Programming/comments/7gd437/question_what_are_your_reasons_for_using_c/dqi6rii/) of C++.
Sorry, this just seemed like the easiest way to get some C programmers opinions, since it's the largest sub. Should I delete the post?
Your post is on topic. Please do not delete it. But keep in mind that just wanting to get the opinions of C programmers is not sufficient to make a post on topic. There also has to be some relationship to the C programming language. Since your post can be understood as something to the effect of “why do you prefer C over C++,” that's barely on topic.
Thanks, I didn't intend to agitate anyone. It's just hard to know who to believe. There's great programmers who hate it, and ones who like it. Can I ask what makes you think the question is opinionated though? I'm not basing it off of my own opinion's, just other people's.
Oh, ok. Sorry. I don't really want opinions on why they like or dislike c++, I just want to know why it's used so much, even though many hate it. I'm just split on whether I should eventually learn c++, or just not even consider it.
It is popular because it is really fast and is not restrictive like Java. I really like C++ because for me it is the best of both worlds. I can get the speed of C code and also I don’t have to do everything myself (malloc). I think that overloading operators is really cool as well
Thanks. I suppose it's a mix between being fast, but not as low level as C? So maybe easier to manage large projects?
&gt; The people who hate c++ and OOP, talk about it like it will ruin the way you program. The people you're talking about likely don't exist. At best, the instances of them hating on OOP are caricatures of their preferences. See also: [tabs v. spaces](https://softwareengineering.stackexchange.com/questions/57/tabs-versus-spaces-what-is-the-proper-indentation-character-for-everything-in-e). In the real world, nobody cares so much as to completely eschew a practice that significantly impacts their marketability. If I never worked with OOP I'd never get a job, I'd be laughed out of interviews. Similarly, if I never used tabs for indentation, I'd be significantly limiting the kinds of projects I could work on (because nobody would consider my pull requests if I didn't respect their style guides). Getting to the meat and potatoes of your post: for game development you should take time to learn both languages. There is nothing wrong with learning C++ or C first, but for your purposes I suspect you will be happiest learning C++11 first, and moving on to C99 when you need it. I've chosen the standards I have because they have reasonably good interoperability while still being relatively modern; your mileage may vary. When people talk about C++ or OOP not being good for game development, usually what they mean is that relying on OOP for the entirety of the project can result in serious limitations in throughput. The one that comes most readily to mind is a cache miss caused by iterating through objects to compare aspects they each have, as opposed to designing your algorithm to parse a list of those aspects. Objects will nearly always be larger than native types and processors have been optimized (via SIMD for example) to allow maximum throughput for collections of native types, so organizing your algorithms to work on native types has several benefits. Organizing your code to work on objects, by contrast, will result in a much larger collection of data you need to parse, when you really only need a small fraction of it, and will likely result in a cache miss, which will greatly slow your already subpar algorithm. That being said, OOP is still very helpful for the purposes of reducing repetition in your code base. Designing your algorithm to account for 50+ different possibilities is a real pain in the ass, especially when many of them overlap in their behavior. It makes more sense, usually, to design a handful of classes and allow inheritance to take some of that work off your plate. Modern game development tends to rely on a combination of OOP and what is known as Data Oriented Design (DOD). The goal is to design a piece of software that is maintainable, using objects for encapsulation and simplifying areas with heavy branching, but also performant, organizing critical data into areas where it can be analyzed efficiently. Unreal Engine 4 does this to some extent and its source code is available for your perusal on [github](https://www.unrealengine.com/en-US/ue4-on-github). I hope that helps, but before I go I just also want to say that it sounds like you're pretty new to programming and are looking for guidance. There's nothing wrong with that, but I have to say that your question is a bit premature. Don't worry so much about doing the right thing from the beginning. You're going to make mistakes. You're going to make mistakes everyday. You'll fix them, and you'll be a better programmer for it. The only way you can truly fail is by not doing, and getting hung up on how to start is a great way to accomplish that. So start somewhere. Anywhere. And don't stop.
Seems like you want opinions from C programmers. I'll start with a disclaimer: While having worked on quite a few C projects, like my own libc, "kernel", and virtual machine, I am a chemist and use programming for scientific purposes. **My experience is therefore heavily biased towards scientific computing**. While I have experience in x86 assembly, C, C++, MATLAB, and Python, 90% of my work is in C. Let's go. Before diving into the languages let's dive into programming: you want your code to be clean, structured, understandable, and easily modifiable. If you're working on a big project, you'll want a nice interface. Basically, instead of a bowl of spaghetti, you'll want ordered drawers each containing a single labeled spaghetto. As a scientist you'll be sharing your code, reviewing other code, and unreadable code won't get you far. Some languages fit well with that, some don't. Try BrainFuck'ing a Python interpreter, you'll be getting a tubfull of spaghetti. However writing a basic interpreter in C isn't just possible, it's trivial. I use C because of that exact reason: it fits my work. I want something down-to-earth: no fancy features, no wall of libraries I'll never use, no compiler magic... I want my program to do its fucking maths, *and I want it to do it the way I want to.* C is low level and doesn't have unrequired abstraction. On the other hand, C++ is full of features. They're neat, but using it feels like I'm attempting to unite things that aren't compatible. Using C++ **__properly__** involves a lot of abstraction. It's like putting icing on the spaghetti plate. Sure it'll look neat but it tastes like shit and it's still a messy plate of spaghetti under. Now don't take it the wrong way - C++ can be used correctly. But not for my work. C++ is forcing a paradygm down my throat and I do not want it. Using C++ the way you're using C isn't getting to use the best of both worlds, it's giving up on the best of both worlds. I actually started out with C++ before going with C. As part of my chemistry curicullum, I had to learn Python and MATLAB, but never really enjoyed them. I'm only using Python for cool stuff like `matplotlib` which makes my lab reports more pleasing to the eye. The rest of the time, I'm typing C on vim.
Thanks, one person I know who talks like that about c++ is Casey Muratori, the guy who is making handmade hero, if you've heard of that. Lots of people say to not take his rants too seriously, but it's hard not to when he seems to know what he's talking about. Anyway, I *am* fairly new. I've been messing around with programming for a couple years, but I've never really gotten anything done, just things like tic-tac-toe in the console with c#. But I started getting into C recently, and I'm kind of enjoying it, so far. I don't know much, probably not even enough to make a basic program, but I'm going through cs50 on edx, and I'm liking it. I'm interested in gamedev, not for getting a job, or making anything serious, it's just that low level programming kind of intrigues me, and knowing how software is made at a lower level is just kind of interesting. Handmade hero seemed like something perfect for me, it uses C, which I like, but so many games and tutorials use C++, and the guy who does handmade hero seems to really discourage c++, along with many others. So it's just got me split. Learning c++ surely can't hurt, though, can it? But like I said, the way people talk about it makes it seem like a bad idea to even touch. But I suppose there's people like John Carmack, the programmer for quake and doom, I believe the later games used c++, so there surely has to be a good reason. I have a beginner c++ book, that I bought a while ago, but never really got through much of it. I think I'll probably just get comfortable with C, then probably start reading the book. Anyway, thanks for taking the time to comment!
Thanks for the comment. I see what you mean. You always hear people saying to use the right tool for the job, maybe c++ is a decent tool for gamedev? But yeah, C seems quite nice, it does what you tell it to. Anyway, I've come to the conclusion that learning c++ probably isn't gonna damage the way I think about programming, or anything like that. I suppose it can't hurt to learn the basics, can it? If I enjoy it, I'll continue, if I don't, at least I'll have more experience and be able to understand documentation that uses it, if I ever need to. I'll probably continue with C for a bit, and when I'm comfortable using it, maybe start reading the book on c++ I have.
Don't worry. I started with C++
Thanks for this elaborate list of suggestions! &gt; It would definitely be a good idea to add a man-like ( as in the UNIX man command) page in your GitHub README The synopsis at the top of the readme is all there is to it: "hxl &lt;filename&gt;". A proper man page is also included but it doesn't say anything the readme doesn't. &gt; I highly recommend you post a .gif or photo demonstrating your program at the very TOP of your README I had an HTML 'screenshot' but GitHub doesn't support it. Might add an image at some point. &gt; does not require us to install the Rust and cargo packages. Good point, might mention that as well but I don't consider it a huge barrier. &gt; I also recommend you add flag options for printing the binary and octal representations of character bytes. This is a standard amongst hexdumps like xxd and hexdump that hexyl lacks. You can even add a feature that allows users to arbitrarily set the number of ASCII characters, and their hex bytes, that are printed per row. I won't, this is out of scope. The point was to make a program that outputs this style of hexdump as quickly as I could make it, ideally without generating extraneous control output. &gt; You shoud include an SHA256 Checksum directly in your README to help people verify if they downloaded something correctly. I don't really see the point here. Git takes care of such integrity at the repository level and an attacker who can compromise the .c file can also compromise the readme. It does make sense to sign release tarballs but for now I'll trust GitHub. &gt; I think you should also take the liberty to include a LICENSE and Copyright information There's a LICENSE.md file which is referenced in the .c file and I think that's enough.
Correct way to ask this question would be "what's your opinion on C++ and OOP? I've heard people both like them and don't like them The way you asked is too stirring and ambitious to create healthy discussion.
I suppose. I'm not really trying to look exactly for people's opinions on C++ and oop, just why they're used so much, even though many good programmers don't like them. I just don't like it when good programmers have really strong opinions about a specific thing, because if the people you look up to have strong, completely different opinions, it's hard to know who's advice you should take. For example, one person, Casey Muratori, the guy who is making handmade hero, and worked on the game "The Witness", he seems to strongly advise against C++, and says stuff like the creator doesn't have a clue on how to make a language. He makes it seem like learning c++ and using OOP will mess up the way you make software. And of course people like linus torvalds etc.. But then there's all the games/developers/engines that use c++, and plenty of good programs/frameworks that use it. It's just hard to form my own opinion. One moment I'm really inspired, then I see a really experienced person who has a completely 180° opinion, which tends to discourage me. I know, I shouldn't be taking everyone's opinions to heart, but I can't help it. I suppose I should really just do what I want. As I added into the end of my post, I've come to the conclusion that learning at least the basics of c++ surely can't be bad, and if I like it, that's fine, and if I don't like it, it's just another tool I have, if I ever need to use it.
Never heard of Handmade Hero, but I'll be sure to check it out. My point about those people not existing wasn't meant to be literal. I was trying to point out that people like Casey tend to veer towards hyperbole when talking about their preferences, but rarely, if ever, would I consider their advice to be practical. It is not practical in a modern context to avoid OOP at all costs. It is not practical in a modern context to avoid C++ at all costs. I have a heavy preference for C over C++, and I find hyperbolic statements about personal preference to be incredibly irresponsible. Whether he realizes it or not, Casey has influenced you, a budding programmer, to question whether or not C++ is worth your time, when he should be encouraging you to try it for yourself and make your own decision. Sorry to have assumed that gamedev was your primary interest, it's just that your original post doesn't make mention of any other field, and in my opinion preferences in regards to C and C++ are entirely based on personal experience, so I focused on what I could while trying to leave my preferences out of it. I started learning C for much the same reason you have: I wanted to understand computers at a more fundamental level. For that goal I would argue that C is much better suited than C++. C is the primary language used for operating system kernels because it's fast and portable. C++ is much more common in userland utilities, where I would categorize games as simply high performance user programs. Both are used in embedded environments, with a dialect of C++ that relies on the C standard library becoming more prevalent in recent years. In the end, both can be very low level languages, but C++ has a much larger feature set, so sticking with C for pedagogical reasons has more advantages in my opinion. In general I tend to rely on OOP in instances where I know I will have to deal with a lot of branching, where I know that coupling my data and logic into objects will help more than hinder. Knowing when that will be is something that I think is best learned through experience. I recommend continuing with your education in C and once you're reasonably comfortable with it move on to C++. Hope that helps. Sorry for any confusion.
`for (i = 0; i &lt; 80; i++) { //8 columns` `for (j = 0; j &lt; 50; j++) { // 5 rows` `if(BF_fontMap[(ch-32)*5+i][j] &amp; (1&lt;&lt;i)) {` `drawPixel(fg_colour, x+i, y+j); //BF_fontMap[(ch - 32)*5 + i]` `}` `else {` `drawPixel(bg_colour, x+i, y+j);` `}` `}` `}` &amp;#x200B; What i have but the output isnt as expected. Am i going in right direction
Just to add to this, I'm a C++ programmer (games industry) but I've dabbled with C in the past. C++ has (most of?) the speed of C, and is just as low-level as C when you need it to be (i.e. you can manually manipulate memory, do "unsafe" things, throw in some inline assembly, etc.). The majority of C code can work almost totally unchanged under a C++ compiler, too. However, the reason I prefer C++ to C is that you don't \*have\* to use it at that low a level. You can write classes in a similar way to how you'd write Java (for example) classes, use strings without having to manually allocate and free memory, use generic containers (i.e. \`std::vector&lt;T&gt;\`), use inheritance, etc. And conversely if you don't use a C++ feature, you don't "pay" for it - for example you can choose not to use virtual functions, inheritance, multiple inheritance, etc. However IMO it \*is\* very useful to know the "C way" of doing things, even in C++ - it gives you an insight into that low-level world which gives you a better understanding of how computers work.
Are you running this code as root?
The reason I mentioned gamedev in the post is because c++ seems so popular with gamedev. It's not my primary interest, but it's definitely one of the things that motivates me to learn. But overall, I'd just like to be a good programmer, be it games or just plain desktop software. It's just something that interests me. Also, I'm only a couple episode into handmade hero, not even the main series, just the intro to C on windows, but what you said about casey made me remember that he mentioned that you should try something yourself before forming an opinion, and even though he may go on rants, you should be able to disagree with him, and come to your own conclusions, if it works for you. I suppose I completely blanked on his advice when I wrote this post.
Maybe you should use it and form your own opinion.
As I said at the end, I'll start learning it at some point, and if I like it, then I'll continue using it, and if I don't, then it's just extra knowledge I have.
Gamedev will have instances of performance critical, and not so critical, areas. C++ offers more features than C, and is more widely used for userland software in general, but still provides developers with comparable amounts of performance. This allows developers to create high performance pieces of code where they need it, and take shortcuts where they want. That being said, you can absolutely develop games in C and I recommend trying it out, especially if your interest in the subject helps drive your education.
In my opinion, the main reason why C++ is used so much is that there is no alternative. All other languages are either managed such that you cannot use them for systems programming or to write portably libraries or they aren't as expressive as C++. C++ is the only usable language with high-level abstractions that doesn't require it's own toolchain, JIT, or runtime environment. Just as C, it just works.
Trying on FreeBSD 10, mq\_send does honor the maxmsg attribute. When set at 10, 11th mq\_send blocks (ps shows it waiting at mqsend).
It might actually be that, im running it on a different pc this time
From [mq_overview(7)](http://man7.org/linux/man-pages/man7/mq_overview.7.html) for Linux: &gt; The msg_max limit is ignored for privileged processes (CAP_SYS_RESOURCE), but the HARD_MSGMAX ceiling is nevertheless imposed.
That would indeed be literally the entire point, so he can see what the comparison he wrote is actually doing. Congratulations, you found the point.
Well, first of all, you should really learn to *program*, not learn a particular language. We call this field "computer *science*" because it is, in fact, a science: it derives from discrete mathematics. Once you learn the mathematical laws behind it, those will apply regardless of what language you write code in. However, in the course of studying the mathematical underpinnings, you'll need to learn and practice using *at least one* programming language. (More than one would be better.) And all programming languages have their own strengths and their own weaknesses. Some are more friendly for students to learn, others are not. Some make particular types of work easier or harder. C and C++ are two very different languages. Despite a common origin, they have evolved very differently. For example, to print a floating point number in C, you would do printf("%f\n", value); while in C++ you would canonically do std::cout &lt;&lt; value &lt;&lt; std::endl; Just this simple difference speaks volumes about how these languages differ. C is procedural: you tell it the steps you want to accomplish, and it performs those steps in sequence. The state of the world is usually very directly visible, because it's all contained in variables that you created in your application, or that libraries created under your command. So when we call `printf()` to output that float, we know from the man page that "the number of digits after the decimal-point character is equal to the precision specification. If the precision is missing, it is taken as 6". In C++ however, many things are object-oriented, and OO has a nasty habit of obscuring state and making it very difficult to reason about operations and performance. * How many digits of precision will the C++ statement print? We don't know, because we would have to go backwards and find the last time that *anywhere in the program* did `std::cout &lt;&lt; std::setprecision()` or `std::cout.precision()`. So while in C all the details of what we wanted to do were specified explicitly or implicitly (by omission, therefore selecting default values) in the format string we passed to `printf()`, in C++ the object retains state that determines whether our float is printed in decimal or scientific notation, how many digits of precision, what field width and padding, etc. * What happens when you take a stream object, and left-shift it by a float? It prints text to the screen. Does that sound in any way like what "left-shift" should do? I'll admit it's a clever bit of syntax that gives a nifty visual look, but it's opaque as hell, and doesn't make any sense at all if you expect the left-shift operator to left-shift things. Similarly, addition in mathematics is commutative and associative, but in C++ you will get different results if you say `string1 + string2` or `string2 + string1`. Clearly, what we have is not addition. (C++ is not the only language that makes this particular mistake.) Misusing operators to mean something different isn't the root of this problem; the problem is fundamental to OO, that you can't know what a function does without knowing the exact type of the object it's being run on and (in most OO languages) all of the parameters. Compared to C where you can very easily trace through any preprocessor macros and then jump to the single definition of a function that's being used, it's a lot harder to understand what's happening when reading C++ code. * The template system is extremely powerful, but this can be a disadvantage. It adds multiple layers of complexity on top of the general complexity of doing things using objects. In C, it's not too terrible to trace through `printf()` and read the code that actually formats and write the output, which is all done more or less in one place, but in C++ you have to jump through dozens of templated objects and functions in dozens of files. Since they're all templated, you have to keep a lot of mental state just to understand what the code will do as you read it. All that templated code also results in very lengthy compilation times, and very cryptic error messages. You're right that most modern game engines do use C++, and that's for a good reason: all that OO stuff that I just dissed is very powerful... *if you use it well*. The downsides are well worth it if the advantages outweigh them, and C++ and OO *can* let you write very complex code more quickly, easily, and correctly than C. However, even so, those game engines have to be very careful about how they use their objects. For instance, traditional OO where each object represents a single tangible piece of data is terrible for data locality, since those millions of tiny objects get spread all throughout memory. So a lot of game engines instead arrange their objects in a very different manner, where things are largely organized into high-performance data structures, but as a result breaking apart the data that would have been encapsulated by a single object into multiple chunks spread across different data structures.
I like the idea of forking to protect against the test going haywire and messing up the test framework, and to continue running tests even after one test crashes. Sadly, it won't help on an RTOS or other systems where there's no memory management, and thus no copy-on-write. Your asserts just use `assert()`, which means they'll do nothing if the macro `NDEBUG` is defined. So that makes them no different or better than regular `assert()`; why include them? It's unclear when you'd want to `assert()` and when you'd want to `expect()`. I don't see any ability to have per-test or per-suite setup and teardown functions. I consider both of those mandatory to cut down on what can quickly become a huge amount of repetition.
Aw boo, if you wanna talk, just say so!
I'm probably doing it incorrectly but I went through the debugger and that's where the EXC\_BAD\_ACCESS (code=1, address=0x0) was from. It was the arguments though, thanks for the help!
Commenting helped, thanks for the tip! Turns out it was the port and address bit.
Yes, you're close! There are a few problems left: both your outer loops do not iterate to the maximum value you want them to. `(ch - 32)` is absolutely correct and sufficient for the first index. Get rid of the `*5+i`, although it's a great idea if you were dealing with a one-dimensional array, but here, just let C do the work for you. ;-) The rest should be fine. Bonus points: 1. Getting rid of the `if` by using a ternary operator for the first argument of `drawPixel` to a) get rid of redundancies in your code and b) make your code unreadable 2. Swap the outer loops and fetch each byte once and shift it right eight times in a row, each time checking if the LSB is set when choosing the pixel color (I don't know how smart your compiler is but this might be a speedup!)
got rid of the \*5+i. so its the for loops which seem to be the problem but why? also in the main function, im calling this function like so LCD\_PutChar(200, 100, 3, LT24\_BLUE, LT24\_YELLOW); I'm able to print characters but theyre backwards ?
&gt; that's You didn't indicate what "that" was &amp;mdash; that is, the exact _line of code_ that caused the fault. You just posted the entire program (well, an outline of it, since you'd elided some bits).
Because the people who like OPP aren't the people who think it's terrible, and the people who think it's terrible aren't the people who like it.
You're looping until 79 in the outer loop, to 49 in the inner loop (should be 8 and 5 instead of 80 and 50, it was right in your original question). Also the `3` in your LCD_PutChar call will translate to a negative index for your array lookup, you can only print spaces and up. If you want to print the digit `3`, write `'3'` instead of `3`, otherwise you'll get ASCII character 3 which is less than 32 and thus not printable. I don't know which direction is reversed when printing but you can fix this easily by adjusting `x+i` and/or `y+j` in your `drawPixel` call(s).
Do you think that D, Nim, Rust, etc. aren't viable alternatives to C++? One nice thing about these alternatives is that they have a more unified approach to their standard libraries and tooling. As far as I can tell, the main advantages of C++ over other high-level systems programming languages are 1.) its ubiquity (a huge advantage IMO) and 2.) it's expressive macros. Though the latter is often argued as a weakness because it operates directly on source code rather than on the AST.
Casey moans about *everything*. Object-oriented programming, C++, Windows, Linux, HTML, JavaScript, etc. He's an amazing programmer, and I enjoy his early episodes of HH for the intro to win32 programming, but I had to force myself to not discard him completely when he started being dis-respectful towards Stroustrup in relation to C++.
D and Go are managed. I'm not sure about Nim and Rust. They are both not mature enough for systems programming though. And no, I don't want a unified approach to tooling. That's what I meant with “C++ is the only usable language with high-level abstractions that doesn't require it's own toolchain” When I do systems programming, I want to use the system's toolchain, not the language's own.
Isn't this like hating hammers and nails? For some use cases a hammer is better, and for some a screwdriver and screw is. In a lot of cases both will do the job and in some cases one or the other is better suited. C++ is OOP and low level, which there is a lot of uses for in a lot of different fields. Therefore it is widely used, simple as that (simplified). I have never met a person who 'hates' c++ or OOP but i have met people who prefer other programming languages and paradigms over them. Do these people actually exist in the real world or is it just first year CS students making memes? Anyone who says learning more about a specific subject will make you worse at programming is wrong. I think everyone who has the chance should learn to understand, and program in a high level, low level, object oriented, functional and imperativ programming language.
This subreddit is for C, not C#. Try asking on r/CSharp.
This depends entirely on how much C you know. You could be anywhere between "freshman who's done 1 semester of C" and "senior who can write a compiler".
That's an extremely counterproductive and horrible way to look at it. No one begins programming with the question "should I be team OOP or team functional?" The right way to go about things is learn a language you're going to use, and/or learn a language that helps you learn a concept. Most programmers learn OOP because there's a trend in CS classes to do an OOP-first approach. Why? Well, because it's approachable. It helps make abstract concepts feel more tangible. For many coders, that's it. They get what they need, so they use it. If, however, you want to learn systems programming, you need to learn C. Don't treat this as a "what's better" -- no one cares. Use the right tool for the job.
A raytracer. Makes impressive, pretty pictures, and there are a lot of interesting optimization opportunities available for C in particular. The latter makes it an endless project where you can stop whenever you're satisfied.
Are you relying on the frequency[] array to be initialized to 0s? Also you can write step 2 as: for(i = 0; sentence[i] != "\n"; i++) { if (isalpha(sentence[i]) { int index = tolower(sentence[i]) - 'a' frequency[index ]++; } }
p.s. Watch your single vs double quotes: for(i = 0; sentence[i] != "\n"; i++) Those should be single quotes around the '\n' to denote a character.
Dynamic web server.
Build your own programming language.
Do a good deed: pick your favorite scripting language and wrap a library written in C for it.
What does "system's toolchain" mean as opposed to the language's own? Do you essentially mean msvc/cl on Windows, xcode on OS X, and GCC/clang on Linux? All of the languages I listed above compile to native assembly, and then use the system's native assembler as the backend. So I'd argue that their toolchain is both the language's and the system's. It's not an either/or dilemma. I agree that C is more mature than Go/Rust. (C++ I'd disagree with, but I'm biased in this regard) I don't think this means that Go/Rust are immature for systems programming. Many major players in the tech industry (to name a few: Google, Amazon, BuzzFeed, Dropbox, GitHub, Pinterest, Facebook) use Go and Rust in their backend servers for high volume requests and database management. Certainly they still use C++, but it is worth noting that all of the Go/Rust projects were at one time C++ projects. So there is a clear trend of phasing out C++ where the developers feel that other languages are better suited for the problem at hand.
&gt; Kochan's condition I think you should give a better context to your question. You should give the whole program as reference because otherwise your question does not make sense. Not everyone here has all C books available to them. I have never read the book (but I found something online regarding the code). So, I think I can help you. Several others would be like me, but your question does not provide enough information for them to help you. &amp;#x200B; Continuing to the question itself. For others reading the post, the code is the following. #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; // Modified program to generate prime numbers int main (void) { int p, i, primes[50], primeIndex = 2; bool isPrime; primes[0] = 2; primes[1] = 3; for ( p = 5; p &lt;= 50; p = p + 2 ) { isPrime = true; for ( i = 1; isPrime &amp;&amp; p / primes[i] &gt;= primes[i]; ++i ) if ( p % primes[i] == 0 ) isPrime = false; if ( isPrime == true ) { primes[primeIndex] = p; ++primeIndex; } } for ( i = 0; i &lt; primeIndex; ++i ) printf ("%i ", primes[i]); printf ("\n"); return 0; } &gt; shouldn't this break the loop since the condition is false? It will. But `isPrime` stays true. And the next if statement is evaluated to true. And that sets 5 as a prime number.
Why not pick up a small embedded uC of some kind and build a project around that?
For something that isn't too daunting but also impressive: a handwritten lexer/parser for a custom configuration language. It could start out as something very simple (e.g. TOML), but over time you can extend it to support conditional control flow and functions (e.g. something more akin to Lua).
Simple CPU simulator for something like the RISC V.
History of open source over time. Contributing once to a lot of repos is transparent. A long history on a single project is a lot more impressive. All that said, something you care about. I'm working on replacing the HUD on my Mazda's infotainment system. Because I know I can do better. What broken POS are you using that you know you can do better? That's what you should put on your resume; something that shows ability **and** passion.
Write a basic web server for chatrooms or anything socket related. Look up Beej's Guide to Network Programming to get started.
Hey Rorschach. Thanks for clearing this up. I did include an image of my code but not sure why it get included in this post.
Copy shell tools like cat, ls, ps, top, arp, etc.
Build a universe, from the Big Bang to the recent coronation of Naruhito, without segmentation faults.
&gt; a great impressive project &amp; &gt;put something on my barren resume Okay so basically you want to get hired. Look at the buzz words being tossed about in your particular field/degree and by god/odin play to those so hard you'd cut diamonds. Embedded OS all of your own, something something AI, full stack seems to be a stupid buzzword I've seen in my embedded C job hunts so maybe some of that, hit whats hot and hit it real freakin hard is my point. Prove you can and they, your prospective employer will teach you what you need.
Boasting time: I wrote all the firmware for a satellite in C when I was in graduate school, including a fully featured flash file system. That might be beyond the scope of what is possible though, I had two years and some EEs and MEs to help.
Hey Rorschach I'm still confused regarding how the inner for loop works. Doesn't the inner for loop stipulate that both isPrime &amp;&amp; p / primes[i] &gt;=primes[i] have to be true? The part that I find confusing using above example &amp; subbing variables: 5 / 3 &gt;= 3 is false so shouldn't it break the loop?? for (i = 5; isPrime &amp;&amp; p / primes[i] &gt;= primes[i]; i++)
an operating system that has only the best features of both linux and windows
Create a virtual machine. I did. Fun project.
My programming abilities practically doubled when I wrote my own raytracer. I did it in C++, but the experience won't be much different. I wrote the whole thing from scratch, every line, binary image file I/O (.BMP recommended) and everything. It was deeply satisfying to go from absolutely nothing to a big powerful program that produced cool images, knowing that I had written every line. It wasn't even an optical raytracer, it does X-band radar real-beam ground mapping.
A text editor. It’s something you can regularly use and you can always keep adding new features to it.
Build your own kernel running on QEMU to the point you can run Doom.
I work with embedded systems and robotics, so slightly askew from the normal realm of conversations on this sub. But anyways if that's something you want to get into, there's a ton that you could do that would be impressive to me as a hiring manager. And honestly doing *anything* on your own and not for an internship or job is impressive in and of itself. Specifically I'd create any IoT device. Or a simple robot. Create an interesting and usable UI. Whether that's on a remote, through an app, or a built-in screen is up to you. Try to solve a problem while you're at it. Any problem. No matter how seemingly insignificant or trivial. Failures are okay too. If you can highlight an iterative process where you failed, but learned and were on a road to success that's a-okay. Also have fun! Don't do something you won't or can't find interesting. You'll have much more success and come up with more interesting solutions to the problems you'll face if you enjoy what you're doing.
And once you’ve written a CPU simulator, then you can write a C compiler for it.
What libraries did you use?
Anything that passes Valgrind without errors.
Linux was made with C by a college student.
None besides the Windows.h struct for the BMP file header and the standard math library
Wait is that possible? What would we even do differently from others?
Could you post your github for kicks? Or for people curious about your project
&gt; What would we even do differently from others? Probably nothing, the world doesn't need any new programming languages. As a purely academic/learning experience though it's achievable, I thought lexx/yacc were usually part of compsci courses.
Here are two topics that your curriculum probably does not cover, that are great project opportunities: optimized floating point algorithms (for example, [grisu](https://www.cs.tufts.edu/~nr/cs257/archive/florian-loitsch/printf.pdf)), and finite automata algorithms (for example, implement [regular expressions](https://swtch.com/~rsc/regexp/regexp1.html), or calculate [the minimum levenshtein distance between a regular expression and a string](http://blog.notdot.net/2010/07/Damn-Cool-Algorithms-Levenshtein-Automata) (that's a DFA solution but you can also solve it with an NFA more intuitively, and derive the DFA from the NFA using the NFA-&gt;DFA transformation rules)).
One condition breaks the loop when we know it's not a prime. Another condition ends the loop when we know there's no point looking further.
It's not anywhere public right now and I'm not comfortable making it public in the state it's in (I got halfway through a sparse voxel octree sub-mesh bounding volume hierarchy to manage the terrain mesh search), but I can answer any questions you might have. I used [scratchapixel](https://www.scratchapixel.com/) to get started with the basic idea of how raytracing was actually put into practice and once I had the basic ray-mesh intersection working (I used the standard Moller-Trumbore algorithm), I just ran with it from there. Most of the work was in trying to develop a system that would properly build up an image the way a radar system would. I also got halfway to implementing a terrain reflectivity model but had to return my library books, lol. [Here](https://i.imgur.com/msbd8hX.png) is what it was producing last time it was running properly.
Raytracer as /u/skeeto says. Or look into the demoscene stuff and make something along those lines. Audio/Visual stuff showing off what you do looks more impressive then crunching numbers and printing strings (even if the latter might be more technically impressive)
Or use LLVM for bossmode points
I wrote an AV in uni. Basic sandboxing and signature scanning. A friend of mine wrote a small binary instrumentation framework.
Aha, you’re prob right. Thanks!
RTFS. c++ qs go to /r/cpp.
So basically, a linux port of notepad++?
&gt; so shouldn't it break the loop? I answered this in my original reply. It does break the loop. When it breaks the loop the value of p is 5. This is stored in the primes\[primesIndex\]
Implement few ml algorithms using C
Make memes. ;_;
&gt; Wait is that possible? Who's gonna stop you?
&gt; What does "system's toolchain" mean as opposed to the language's own? What this means is that the compiler produces conventional object files (using the system's assembler) that can be linked into binaries and shared objects in any way desired. This is important if we want to employ symbol versioning or use all the tools provided by the system to manipulate shared objects. This also means that we can access arbitrarily named symbols from within the language.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Yeah write a cool little compiler. Why wouldn't you be able to
In the first example, you have two `kel` variables: one local to `main` and one local to `FahConv`. The latter function does not see a variable that is declared in `main`, but that is OK, because you are passing it by value. No need to pass it by pointer, unless you want to modify the value inside `FahConv` and your modification has to be carried to `main`. In that case, the correct prototype is: ```float FahConv(float *kel)``` and you have to dereference it with `*kel = ...`. In the second example, `FahConv` can't see the `kel` variable defined in `main`, same as before, but this time you are not passing it in any way, so this variant will not work. Both functions have their own, local variables `kel`. Always compile your code with all warnings enabled. Compiler will tell you what is wrong or suspicious.
The code in examples is C. There is nothing specific to C++ in OP's relevant question.
3d erotic simulation games
No this is really great you've really cleared it up for me! I think where I went wrong was the expression: p /prime[i] &gt;= prime[i]; because I was subbing in p=5 and [i] = 3; which would make the expression false. But I interpreted as: for (i = 1; isPrime &amp;&amp; p/prime[i] &gt;= prime[i]; i++) { if (p % prime[i] == 0) { isPrime = 0; } } *the expression being false would cause the program to skip over this block of code whereas: for (i = 1; isPrime &amp;&amp; p / prime[i] &gt;= prime[i]; i++) if (p % prime[i] == 0) { isPrime = 0; } would break the for loop then proceed directly to the following if statement.
Your explanation was excellent! I think I understand where I went wrong. I included a set of curly braces in the inner for loop. for (i = 1; isPrime &amp;&amp; p / prime[i] &gt;= prime[i]; i++) { if (p % prime[i] == 0) { isPrime = 0; } } * My understanding is if the expression = false, the loop breaks, and the block of code is skipped because of the curly braces. whereas: (your method) for (i = 1; isPrime &amp;&amp; p / prime[i] &gt;= prime[i]; i++) if (p % prime[i] == 0) { isPrime = 0; } if the expression is false the loop breaks but the program continues to following if statement.
Why? Because 1 in 10 posts gets it wrong? Do you really think they'll read the sidebar?
The loop executes once for every character you input, but it only increments `n1` if it encounters a newline character. In other words, it counts the number of lines in its input — assuming that every line ends in a newline character, as required by POSIX.
What the loop is actually doing is: * n1 = 0; * c = getchar(); // 'W' * does c == EOF? // No * does c == '\n' // No * c = getchar(); // '\n' (because you pressed Enter after W) * does c == EOF? // No * does c == '\n'? // Yes * ++n1; * c = getchar(); // 'Y' * does c == EOF? // No * does c == '\n' // No * c = getchar(); // '\n' (because you pressed Enter after Y) * does c == EOF? // No * does c == '\n'? // Yes * ++n1; * c = getchar(); // EOF (because you pressed CTRL+Z) * does c == EOF // Yes * print n1 // 2 *
As others have pointed out, you need to initialize `frequency`. There are three ways to do that: provide an initializer, write a loop that sets each element to zero, or call `memset()`. This code does all three: int frequency[26] = { 0 }; for (int i = 0; i &lt; 26; i++) frequency[i] = 0; memset(frequency, 0, sizeof(frequency)); Note that `frequency` is misnamed since it actually contains the number of occurrences of each letter, not their frequency. To get the frequency, you'd have to divide by the total number of characters read. `MAXROWS` is also misnamed, since “row” is synonymous with “line”; you probably want to call it `MAXSENTENCELEN` or something similar instead. Last but not least, `alphabets` is also misnamed since it only contains *one* alphabet, but you don't actually need it at all. Just check if the character is a letter, and if it is, use the difference between it and either `'A'` or `'a'` as an index into `frequency`.
&gt; Wait is that possible? Umm... seriously?
Or a handwritten parser for more points
Ahhhh geez now I understand :O. Thanks alot for the visual representation dude, I really appreciate it.
Ah okay I see, I appreciate the help you have given me . Thank you.
Practically every post that includes code gets it wrong. And the reason why people don't read the sidebar or the posting guidelines is (at least partly) that they aren't visible on mobile.
Why wouldn't it be possible?
I guess my current skills. Just started so I think I’ll have to wait before trying this out,
Masochistic, I approve
I've been writing in C professionally for over 20 years. The blog makes good points. However, I would dearly like to see a newer generation language that offers most or all of the benefits of C but which provides better protection against bugs. Perhaps this is Rust. I'm giving Rust a second go.
No blog spam please.
Considering what u/the_Demongod described, my version shouldn't be very different. You may check it [here](https://github.com/ozy/silhouette).
This is a decent question and didn't deserve to be downvoted. Some of you sourpusses need to remember that you also had to start somewhere
No, because that makes accessing members slower. You don't want any slowdowns in networking libraries.
Not true, you just can't declare on the *first* line after a case label. See here: https://ideone.com/TjvIPy That being said, scoping is clear about what's going on, versus simply having a blank statement, eg (void) 0; or ;
Forking can be disabled by `TEST_NOFORK` if it's slowing down testing too much. These aren't that `assert`-s you are thinking about. These are some macros in `test.h` and these have nothing to do with `NDEBUG`. The difference between `assert` and `expect` is/was only the printing. You can see that I've wrote only 3 builtin `assert`-s and `expect`-s, at first I just wanted to make the core work. But thanks very much the feedback, I think I will drop `expect`-s and replace them with unified, "smart" `assert`-s. Yes, they are missing. I will add them soon.
Then you can put your simulator on your simulated cpu.
From your prospective employer's POV, the risk with hiring someone with a strong embedded C background is that they will program like a C programmer despite the fact that the project is C++, python, etc. So that's what your application needs to mitigate. The most immediate thing you could do is produce a basic application in C++ that showcases you understand virtual functions, template programming, and so on. This doesn't need to be huge, and (ideally, even) it could be something like a game mod or editor plugin, which would showcase you can read a C++ API and implement your own functionality against it.
Once I've used [SDL](https://www.libsdl.org/) for this.
If you're looking for a project that's fun and impresses ***you***, the programmer, I recommend doing something where you parse or interpret some data and at first it doesn't work and then by and by everything comes together. 1. A GIF parser. So much fun to see the result come together from first nothing and then a bunch of garbage on the screen. Add support for animation if you like. Then write a GIF encoder! 2. A simple 6502 emulator, if you're into oldschool hardware. It's a bite more complicated than a GIF parser but very rewarding if you have a disk image at your hands. 3. As others have mentioned, a raytracer! Once you've got some equations ready, go wherever you want. Add textures or ambient occlusion! 4. Write a simple 3D shooter from scratch! I've written one for the Gamebuino, it's also really rewarding. PS. Don't program to impress other people, code to be impressed and share your results!
That's what we did in my sophomore computer architecture class. Good times.
Seconded. It's a breeze to use for what OP is trying to do, and it's cross-platform.
Funny, I have the opposite problem — I find C++ jobs much easier to come by than C jobs.
Yeah but (correct me if I’m wrong) but he was a PhD student at the time. Also, computers were much simpler then. Not saying you can’t do it, but just feels like a false equivalence
Flex/bison are the evolutions of that tools.
We had 3 special tasks at our compilers course: compiler for a language, assembler and binary code simulator for an architecture. Later, author of this architecture invited all who contributed on those to work on his book. Now he sent us some FPGA to test those projects on (nobody knows why he didn't just sent a firmware) So yeah, this proposal is much more applicable than it may sound. Also, the company I had internship at selected candidates by giving a task of making a multithreaded Sobel filter implementation for an NetPBM image format, so that's a thing you can do too.
The system that Linus originally wrote Linux for still exists on modern machines, to some extent.. Install VirtualBox or QEMU and go to town. Writing a kernel, even a simple one, is a great academic exercise.
Compression algorithm. You get the sense of implementing more abstract data structures, you work with data (whether it’s text, binary, etc).
Keep looking for more jobs.
Agreed. SDL2 is actively maintained and improved, ideal for your project. https://www.libsdl.org/
Absolutely. But that’s not really equivalent to authoring Linux at all at this point. Imo.
Probably shared memory. Might be a little complicated to orchestrate, but minimal overhead otherwise.
Hello? Code formatting??
I will edit it
counts lines ('\n') the a=b != c does a = b; b1=c
Interesting I don't seem to have this problem. Where I am there is alot of embedded Linux work and there's more C++ than C. However, I switch back and forth from C++ to C quite often and I'm still able to adopt good OOP design techniques. I'm in the aerospace industry so it's quite common to be switching "gears" and working several projects at once. I spin PCB's and bring up software applications for them which is all C. I also write flight software applications in C++ for spacecraft payloads with a huge emphasis on OOP design techniques. I fart around with COTS products (commercial off the shelf) that usually come with libraries written in C++ as well as C. Sometimes there's even a python library for some of these COTS products I use. From a junior engineer level, if you're learning and having fun "as best as can be expected from a full time career" then be happy with what you're assigned. As you gain experience and integrate more and more into your company new doors will open and new type of work will be assigned. I don't know how your company works but this is typically how it goes where I am and I would expect it's quite common elsewhere. Three years of experience with C seems very "junior" level still in my opinion. With a new company and only threes of experience in C (which at my company would be considered still junior level) don't expect them to just give you something on a silver platter especially if all you have is three years of industry experience in C. Learn from your peers and invest in your company alittle as they're investing in you. Good things will come and if they don't express this concern and your interests to your boss after you've given the above effort. I spent 2 years working a project where I was writing boring test procedures written in some ancient language developed by NASA in the fucking 80's. Regardless I learned the importance of writing good testable software and how doing so can benefit the test engineer and myself. I learned how to formally qualify my own software and the NASA specific processes and procedures we follow for quality assurance. So there's always something to be learned and after those two years I got put on something I really enjoyed due to that experience. I see this more and more now with new recruits coming out of school. They just wanna write in one language and code all day. No one cares about documentation or following procedure or even design work. Not profiling you at all just trying to encourage you to relax and not worry about your situation too much. This is my two cents and it's been from experience and my peers experiences. Its quite opinionated I know and my situation/workplace could be quite different from yours. However, I wouldn't worry too hard about being pigeon holed quite yet. Best of luck ~ S
Windows is the easiest GUI to program for since it's remained unchanged since the mid-90's and there are approximately 10 trillion billion tutorials for it. You don't need a library to code in Windows since Windows **is the library**: http://www.winprog.org/tutorial/simple_window.html There is a reason everyone has done GUI programming on Windows for 25 years and it's because Microsoft has done everything for you, and documented it very well. They have low level functions, high level functions, wrapper functions, and Windows GUI programs written in the 1990's still run fine today on the latest version of Windows. https://docs.microsoft.com/en-us/windows/desktop/apiindex/windows-api-list If you cannot create a Window in Windows then you will definitely not create a window for anything else.
Whoa, what a fool I seem. I don’t even need a dedicated library.
https://github.com/erkkah/tigr Very easy. Exactly what you're wanting
[RayLib](https://www.raylib.com/) is also a nice choice. You can fill a texture with an array of pixels and draw the texture. IMHO it is easier to use than [SDL2](https://www.libsdl.org/) which is also a great option.
This is C#, not C Sorry, the post is off-topic for this sub. Try /r/csharp
That's an option?? I've just been stealing from the Linux Kernel Source
it would be nice for example if the command parameters were consistent and uniform.
Might come across as a total noob here, but I can't use SDL. It won't install, MingW32 gives an error: &amp;#x200B; \`\`\` C:\\Users\\Michael\\Desktop\\SDL2-2.0.9&gt;C:\\MinGW\\bin\\mingw32-make.exe cross for arch in i686-w64-mingw32 x86\_64-w64-mingw32; do \\ make install-package arch=$arch prefix=/usr/local/$arch; \\ done arch was unexpected at this time. Makefile:15: recipe for target 'cross' failed mingw32-make: \*\*\* \[cross\] Error 255 &amp;#x200B; C:\\Users\\Michael\\Desktop\\SDL2-2.0.9&gt;C:\\MinGW\\bin\\mingw32-make.exe cross \`\`\`
Have you been actively using C++ for work and/or personal projects? It's an extremely large language and employers might be skeptical of your ability to pass a modern C++ coding interview if you're not actively using it. If the answer is "yes" and employers are actively preventing you from interviewing as a C++ developer, then I'd keep looking. That sounds odd. If the answer is "no," then you're going to want to get yourself more experience before applying. Do not start over as a junior developer. You don't want that and I've observed that employers generally don't like to hire people into roles below their experience level. As an experienced engineer, you're going to come up to speed on new technologies and languages much faster than a junior engineer is going to gain industry experience. If you take an entry-level role simply because you don't know the tech stack well or have the professional experience on your resume, you're going to quickly outgrow the role and either leave the company or force the employer to create a more senior role for you that they might not have been otherwise ready to requisition. Those outcomes aren't good for the employer and taking a massive pay cut isn't good for you. That said, if you're not having luck getting or passing C++ interviews, you might need to take a slightly lower salary (while retaining your current title) at a company that's willing to gamble on your ability to learn quickly. A startup might be a good example of such a company. They can't typically pay as generously as companies with actual revenue, so they're more...motivated...to find good people. That's a reasonable scenario where you might trade some salary to gain professional experience. But don't take a huge hit. Your experience as a C developer is valuable. Much of that value is in your experience as an engineer--not the language specifics.
Do other things too. Put them somewhere people can see them, like github.
He was an undergrad. It is still possible for one person to write a basic Unix-like kernel.
For streaming data, you could also look into Unix pipes, you open them between two processes and then can shove data and read data basically whenever you want. I’d say it’s better than shared memory for this task because it is more like a streaming concept.
Can I have an example of the user input ?
every time you get a new value from the user, store a copy of it in another variable, e.g. prev_x = x then when you get new values of x, just compare with prev_x some pseudo code prev_value = Null while True: x = get_value() if x == prev_value() print(same value) prev_value = x
Finally something to dethrone nano
The variable is a char that triggers a switch statement, after that the same choice will show (they’re inside a while loop) up again and get stored on the same variable char and run through the switch again. But every time the user gives the same value twice in a row, there must be a different reaction from the program. It’s a beginners code game. Hope that answers your question.
Right! I think that’ll work! Thanks a lot!!
 Thanks for your feedback again. Added conditional tests, smart(er) asserts (removed expects) and hooks (pre/post-suite, pre/post-test and their scope can be global or suite local). Check out the only example if you are interested in what and how changed.
I was thinking about doing just that, but if I ever switch to CUDA shared memory just won't cut it as 100% of the computing will be on the GPU (running on a 1x lane on Thunderbolt 3)
Interesting. With potential CUDA porting shared memory won't be a good thing, so the pipes sound like a good option.
We (my team) escaped C/bare metal embedded by doing C++ embedded on Linux and RTOS for our follow on projects.
Actually, I liked the difference between "assert" and "expect", where one is non-fatal (the individual test continues running even if it fails) and the other is fatal (the individual test immediately stops, although other tests can continue). By removing that, I feel like maybe you've lost a nice feature. The problem, at first, was that I saw `assert` and assumed from the name that it was `assert()` from the standard library. It isn't, and you still have the same problem as before: the name `assert` is already claimed by the standard library. If someone does `#include &lt;assert.h&gt;` followed by `#include "test.h"`, it's going to cause an error. Your other `assert_` family of macros don't conflict, but `assert()` does.
Then you can (theoretically) share the GPU’s memory as well as the system memory.
There wasn't such difference between `expect` and `assert`. As I said, the only difference was the way how they print on the screen. They both `exit()`-ed, so tests always stopped at the first error. But tell me more about this, maybe something is not enough clear from the examples. Why would anybody `#include &lt;assert.h&gt;`? That's useless from the point of testing.
So maintain a count; initialize it to zero; when you enter whatever condition, increment the counter; if it exceeds some limit, {trigger whatever secondary response; optionally reset or saturate the counter}.
C++ is not C
It looks like you're using a single space for indentation, which is making it more difficult to read. Try using 2 or 4 for readability, it's a *lot* easier to see when if/else blocks end.
Is there a C++ sub? I assumed this sub was for all aspects of C given that it is the base subset for everything else
Just looked this up and it sounds really exciting! What resources would you recommend to get me started on building a raytracer? I have no idea how to start but am really excited.
I wish more of the developers I have worked with programmed like a C programmer.
I agree with your advice and think it will help him. Pure embedded C programmers aren't necessarily experienced with higher level concepts so they need to prove that they can. I would also like to add that people can be imitated if you show to many languages in your profile. Focusing on the ones asked for will leave a bigger impact. &amp;#x200B; Moving on.. &amp;#x200B; &gt;they will program like a C programmer despite the fact that the project is C++, python, etc. So that's what your application needs to mitigate. &amp;#x200B; There are good and valid reasons why people don't want C idioms at higher levels. This mostly wraps around pointers and memory(returning a NULL, allocating memory and so on.) That said, the "reason why" has been perverted many times by many and some people have started to be pedantic about the use of minor things like printf, tabs or simple for loops in their fav language... All I have to say about these kind of people is... &amp;#x200B; ┻━┻ ︵ヽ(\`Д´)ﾉ︵ ┻━┻ &amp;#x200B; While a some of the idioms are justified some of the time, not all of them are justified all of the time. &amp;#x200B; ┬──┬ ¯\\\_(ツ) &amp;#x200B; A multilingual C programmer is not going to have problem with virtual functions in C++ nor template programming. While templates are useful, they slow down compilation time if you don't know what you are doing. (There are lot of angry C++ developers that out right ban templates in their C++ code base)... Also, it would be awkward if a "experienced" C++ programmer tried to "one up" a multilingual C programmer on virtual functions given it is like a struct of function pointers. &amp;#x200B; Now to correct your statement: &gt;From your prospective employer's POV, the risk with hiring someone with a strong embedded C background is that they will program like a **embedded** C programmer despite the fact that the project is C++, python, etc. So that's what your application needs to mitigate. &amp;#x200B; You dropped **embedded.** Embedded C programmer will return that NULL, not the normal multilingual C programmer. :'( ^(I promise...)
I come from the exact opposite. I'm currently a cloud/web developer who would like to get into C/embedded development at some point. How do you do it?
I haven't read it yet, but [Ray Tracing in One Weekend](https://github.com/petershirley/raytracinginoneweekend) is often recommended.
I agree with the employer perspective. Used to work at a place that hired a longtime embedded developer as the only front end javascript developer on a new project, and after 6 months they fired him and rewrote the app because it was written using a lot of C patterns, the string manipulation in particular was very strange for javascript. So yeah, definitely try to demonstrate an understanding of higher level language design patterns.
I'm not sure if this is it but ctrl+d is eof not ctrl+c
Your scoping is fine. It sounds like your while loop isn't executing.
Ohhhhhh it does work now. Thanks alot!
Hey man, thanks for you reply. Have already resolved the issue because I shouldn't have pressed Ctrl + C for EOF.
I was hired as a C programmer but 99% of the time I'm presented with problems that I can solve more easily in Python (and C++ 1 time). In my situation I could come back and say we're going to use a different language and it hasn't been a problem. In fact, now I get called upon frequently for Python projects. It sounds like you've been typecast in embedded systems that can only be done in C so I'm not sure if that helps. I wanted to share in case there's a way you can recommend using C++ if you truly think it's a better option.
how large are these companies? my experience with small companies - particularly at the consultancy end of things (and not single-product focussed startups) - is that you end up doing *anything* if someone will pay. so my advice would be to target smaller companies.
Well one method would be first check if the file exists before opening it which would be a if statement. Is this what you're asking?
You can do this, but I would strongly advise against it because it's a huge security threat.
Keep looking, some times it takes a while. It took me about 8 months to get out of a business analyst role and back to a developer role with a higher salary. Personally, I like to switch roles and tools fairly often, otherwise I get bored. If an employer only wants you to do one thing and thinks you are incapable of learning something else and you actually want to do something else, it's fine to move along.
or ctrl+z on windows
Man could you help me again? Your advice worked but turns out I badly interpreted the program. So idk if you read the other comments, but that variable is a char that triggers a switch statement (all inside a while loop) and if the user enter the same value twice in a row, the program must continue the same reaction it did on the first one. And on the third repetition of the same while loop it must take a different decision. So your advice is taking action one step before. Thanks in advance!
https://en.wikipedia.org/wiki/Inter-process_communication Another hacky method that works is using Sockets and reading/writing over 127.0.0.1 with UDP. Or memory-mapped file i/o with shared files. GPU's and CPU can share memory as well. The **best** way would be the fastest way, which is going to be IPC with shared memory, so that one process writes to memory while another process directly reads from it, without needing a memory-copy operation.
**Inter-process communication** In computer science, inter-process communication or interprocess communication (IPC) refers specifically to the mechanisms an operating system provides to allow the processes to manage shared data. Typically, applications can use IPC, categorized as clients and servers, where the client requests data and the server responds to client requests. Many applications are both clients and servers, as commonly seen in distributed computing. Methods for doing IPC are divided into categories which vary based on software requirements, such as performance and modularity requirements, and system circumstances, such as network bandwidth and latency.IPC is very important to the design process for microkernels and nanokernels. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I see, then use a repetition counter. Keep the prev_value() part as before if x == prev_value() counter++ else counter = 0 if counter == 1 trigger = 1 if counter == 2 trigger = 2 switch trigger case 1 case 2 etc
That sounds like the employer’s screwup, though. Were there code reviews? Mentoring? Onboarding? Anything approaching style? Or was this just a really small workplace that couldn’t get those?
Yeah I tried that. But the thing is that the counter must be returned to its initial value after the programs decision, otherwise the it wouldn’t work on the next repetitions. Look I’m going to throw the whole explanation so I don’t waste your time again. The program is game that have multiple strategies and in each one of them the computer (which represents the second player) takes a different kind of decision. This decision I’m having trouble figuring it out, is called “an eye for two eyes” so basically the user have to make a decision and their answer is stored on that char variable, while there’s no two same of the same answer in a row from the user, the program runs an rng based decision (%2) after those, the program must take its decision based on the two choices of the user taken in a row. The thing is: if the user take a different decision another two times in a row, the program must then take another reaction. I tried the counter but it’s values increments must be returned to the original value after the programs decision ( so it doesn’t grow to a point where two choices in a row of the user don’t pass the point), it doesn’t work properly on the next two decisions in a row. Get it? Thanks again! And sorry for long response.
Thanks man, I just try to not pay attention to those guys. Shows that I’ve got a lot of room for improvement tho!
Firstly, a meta point: no one wants to look at images. Copy and paste your code into reddit, and look at how to format it properly. That being said, neither of your programs enter into an infinite loop. The first program's loop never runs, and it immediately exits. The second program prints out what you're after, but you want to use "\n" instead of "/n" to get it into a table like you're after.
If by backwards you mean starting at 0 and working your way up to 300, try this: ``` for (fahr = 0; fahr &lt;= 300; fahr = fahr + 20) // the rest the same as before ```
actually from 300 to 0 is what i'm after.
ah i'm sorry i'll learn to do that. also the first one does. the first one was my attempt to have it start from 300 to go to 0. it just kept chugging out numbers and wouldn't stop till i exited the terminal :(
C++ is a different beast altogether, pretty complex to learn properly. I'd get comfortable with C for a few months before trying it. A nice idea for a project is a terminal game! Good chance to learn about thread, escape sequences, memory allocation and pointers, more complex data structures, and some game logic.
Hmmm, that seems to be exactly what your program gives me. Changing the '/n' to a '\\n' as u/computerarchitect mentioned, as well as adding \`int\` to the return type of main and \`return 0;\` at the end of the program I get this: \`\`\` \#include &lt;stdio.h&gt; &amp;#x200B; int main () { int fahr; for (fahr = 300; fahr &gt;= 0; fahr = fahr - 20) printf("%3d %6.1f\\n", fahr, (5.0/9.0)\*(fahr + 32)); &amp;#x200B; return 0; } \`\`\` And it gives me [this output](https://imgur.com/a/xOAzq87). Protip: when you're compiling, use \`-Wall\` (turn all warnings on) and \`-Werror\` (All warnings become errors) to help yourself find possible mistakes in your code. You can see how I've done this in the screenshot I linked above!
You can try out any programming language you want, you just might not ever progress past beginner level if you don't build something.
ohhh yeah i didn't see the /n to \\n error thanks so much. however, i didn't know you had to define main as an int? the kernighan book that i am using right now doesn't do that? is that something i should get in the habit of doing? also the program runs just fine now thank you :)
What did you emulate?
No problem! As far as my experience goes, it's good practice yes (but not required). You'll notice that [you got a warning](https://i.imgur.com/aKrXBJv.png) in your second image after you compiled your program. When I turn `-Wall` and `-Werror` on, [it becomes an error](https://imgur.com/a/vb3WlyQ) and the code fails to compile. With the warnings as errors, you would have picked this up before you ran your program!
ahh so that's why. that's cool i'll definitely keep that in mind
MIPS R4000. We then built the entire logic and circuitry using Altera Max Plus, then wired and built the entire computer, wrote an assembler and executed code on it. The only thing I didn't get working was floating-point division. Advanced Computer Architecture I &amp; II. He was a great professor. His name was Nagi Aboulenein. I can't tell you how much I learned from him. He is at Intel now.
Agreed, employer's mistake. But it was a brand spanking new startup, so no to most of those things.
Thank you for the suggestion! I think I’ll try that now.
You’re right. I think I should try some projects for a few months before I go off to do C++. Thanks!
Check your parentheses on the while line.
Would this also be a good project for someone kinda new to C++ as well?
One thing: get into the habit of including the arguments int argc and char **argv into your main: int main(int argc, char **argv) { //main function } This allows you to pass command line arguments to your function. argc is the number of command line arguments, and argv is a string (char array) of command line arguments (where the first value of argv is the name of the binary). For example, if you wanted to rewrite your code to allow you to pass the Fahrenheit value and convert it to Celsius, your code could be something like int main(int argc, char **argv) { float fahr; float cels; if (argc &gt; 0) { fahr = atof(argv[1]); // read Fahrenheit value from command line cels = (5.0 / 9.0) * (fahr - 32); } else { printf("Error: no command line argument passed\n"); return -1; } printf("%f Fahrenheit is %f Celsius\n", fahr, cels); return 0; } Then, after compiling gcc fahrenheit.c -o fahrenheit you can call it with, for example, 22.8 degrees Fahrenheit, with the command: ./fahrenheit 22.8 One thing to notice is that I am more liberal with my use of whitespace than you are. In particular, you write (5.0/9.0)*(fahr-32); where I write (5.0 / 9.0) * (fahr - 32); You'll notice that the latter is more readable. And, as someone mentioned earlier, if you compile with -Wall and -Werror, you'll generally write better code.
Learn one language well, doesn't matter which one. Then learn another, and keep learning new ones, until you no longer care or notice which language you're using. Make sure to learn Lisp. After you learn to read and write lisp, you will never complain about any other language ever again. It may be beautiful in concept, but it is the ugliest language that takes itself seriously.
Shop around for your favorite style guide. If you want to compile with C++ interoperability, the [Google style guide](https://google.github.io/styleguide/cppguide.html) is a good one for you. If you're sticking to straight C, there's a lot of wisdom [here](https://github.com/mcinglis/c-style). Regardless, pick something and stay consistent.
Like others have said, I’d really really recommend staying in the world of C and really absorbing it. Learn the standard libraries, write your own implementations of data structures, really get to understand pointers, learn how to make 2D and 3D arrays, find out how function pointers work, learn var args, learn some cute bit twiddle tricks. Check out “The Algorithm Design Manual” which is a fantastic book and is all in C. It may be a bit much if you’re still in CS classes, but if you are at least familiar with it, you’ll be a BAMF when it comes to those interviews. Remember that C has been around for decades and is still the go-to for so many things for a reason. It has its warts but trust me when I say that the time spent learning C is useful, flexible knowledge. I’ve learned a ton of languages (it’s a bad habit of mine lol) but so much of it all comes back to C. C++ has a lot of cruft and is really a hamfisted approach to Object oriented programming. You’ll get there eventually, but focus on the fundamentals early.
Tbh it s not that different from C. I think the only difference is C++ has few additional concepts and a little difference in the syntax. I never studied C and only C++. However, I can easily understand C.
First you have to decode the image data into some basic colour space (like RGB). Then you reallocate pixel colours and encode everything back to whatever format you want.
Tbh it s not that different from C. I think the only difference is C++ has few additional concepts and a little difference in the syntax. I never studied C and only C++. However, I can easily understand C.
Careful! Once you go down the rabbithole of /r/roguelikedev it's difficult to appreciate any other kind of game. ;-)
How would to decode the image data? Sorry im new to C, would you start the data into a struct?
Depends on what you want to use this knowledge for. Private projects - stick to whatever language you like the most, but don't be afraid to try others. Programming professionally - there is more demand for C++ programmers, so I would go that way. Electronic projects (microcontrollers for example) - stay with C. Etc...
Terabytes of data, at what rate ?
There's a myriad of formats in the wild. Short answer - read the file format specification or study the source code of some Open Source library and write your own decoder. C is relatively low level language. It doesn't have a "magic" decodeImagePlease() function. If you are limited to standard library, you have to do everything yourself. It won't be an easy task, unless input format is simple, like BMP without compression.
The input is .bmp without compression actually, I'm simpley stuck on how to start it off, as I'm struggling to find any examples on this and my knowledge isn't vast
The input is .bmp without compression actually, I'm simpley stuck on how to start it off, as I'm struggling to find any examples on this and my knowledge isn't vast
The Wikipedia page is actually pretty detailed, I'd start there: en.wikipedia.org/wiki/BMP_file_format
BMP (without compression) is trivial. It is basically a header followed by a series of triplets (pixel colour description) in RGB. Newer formats may be a bit more complex. You can practically process per-pixel data in stream, without loading everything into memory. Google "bmp file format" and you will find many articles, with pictures and detailed description about each header field. It's a very old format, well documented.
Wrong sub :)
Depends on what you consider "the basics" and what your goal is.
I’d say there is more than a few additional concepts...
Typically, gigabytes per minute.
C is not C++ try /r/cpp_questions/
There’s a lot of masochism required to enjoy C++. But if that’s your thing, go ahead
\&gt; it is the ugliest language that takes itself seriously &amp;#x200B; (format t "\~v@{\~A\~:\*\~}" 9999999 "no u ")
Quite large - local branch has 200+ developers, while in the world there are 10.000+ employees.
Thanks for a thorough response! The problem with the company I applied to is that, once I get assigned to embedded/C project I won't have a chance to code anything in C++, because there is another team for that, no switching "gears". &gt; but three years of C experience would be considered still junior level at my company Agree, but in my country there are a lot of "seniors" that have 4 YoE. Young market.
Why?
Simplest way to learn what languages like C++ offer is to write C in OOP style. After writing C in OOP, don't just try C++, explore other OOP languages as well. The extra features don't matter and are not going to be a problem. You can learn them in a day or so by simply doing. OOP concepts are harder and take longer to digest fully.
Did you follow a tutorial while making the thing?
I’ll try :)
If you like C then try out Go instead of C++
That’s good advice. I’ll take a look at lisp some time down the line. Thank you!
That just made me postpone learning lisp another couple of years
Gotcha, I’ll check the book out! I haven’t even started my cs classes actually XD I’m about to go to college this year, but I decided to start learning some programming last year.
&gt; Then, I tried linking it with: gcc ./includes/libft.h main.c libft.a -o test Header files should not typically listed on the GCC command-line. (They can be, but that's when you're creating a precompiled header file, which you're not doing here.) This is because header files are normally used through `#include`. &gt; Why am I getting implicit declaration errors? Have you used `#include` to include your header file?
Yes actually need to include the header files. You can't link them like you are trying to do. Add `#include &lt;libft.h&gt;` The reason you're getting an implicit declaration warning is because when GCC is compiling main.c, is had absolutely no idea what those function signatures are (the ones declared in the header file). Once you get to the linker stage, it's still able to find said functions in libft.a, which is why it's only a warning and not an error. TL;DR: include header files, don't try to link or compile them.
Try using ` gcc main.c libft.a -o test` instead. You are giving the compiler a `.h` file, but those should only be used through `#include` statements in your source files. I usually do this in my makefiles: SRC_DIR := ./ SRCS := $(shell find $(SRC_DIR) -name "*.c") That way, you have the variable `SRCS` containing all the source files in all subdirectories and the current workind directory.
Thank you for this! :D Another question, however. I was actually using an include for libft.h in ALL of my .c functions that were compiled into the .a file. Should I remove all of them, since any main I use will now contain libft.h anyway, or should that include stay inside functions that use other functions from libft.h?
Oh god I thought I had seen terrible things but this is a whole new level NEVER do that again. Use **one include statement per header per file.** Put it before everything else in your source file. Once. Not in every function!
Thank you very much for your help. I understand that this is nightmarish to a good programmer, but I did start in the last few months! I'm trying to rush into things, and learn as fast as I can. Thank you for directing me down the right path! You've been a great help.
Don't worry, we've all had our share of war crimes. Ultimately you'll have to find your own coding style, but keep in mind that sharing code requires it to be readable and some things are instant red flags
Thank you again. As a small sub-question, due to how amazingly helpful you have been, I would like to explain my structure a bit more, and ask you on that. As an example, I have a lot of programs that compile into my libft.a file that use size_t, which is actually included in my libft.h file as the &lt;string.h&gt; include. Since I will always be using the libft.h, which does define size_t, should I just ignore that a lot of my functions now give warnings about size_t being undefined? Or do you think it would be better practice to include &lt;string.h&gt; in each individual function that uses size_t.
You are explicitly using `size_t`, so you should explicitly include its header. Never imply anything! The correct header for `size_t` is `stddef.h`, though you can also use `string.h` among others.
So, I should include a header that defines size_t in all functions that need it, even if I know it will be defined for them later? So, say I have 12 functions that all use size_t, I should include a library that defines it in all of them? I know this may be a weird question to ask, and I know double-inclusion is protected against. I just don't know what good practices are here!
Regardless of your library using `size_t`, you should include in your program a header defining `size_t`. Isolate everything, don't have a monolithic library that include everything for you
Thank you. You have been an incredible help!
Okay, I'm sorry to spam you with questions like this, but I do believe this is the final one. If I have a function, (In this case, my own atoi function) that includes another function, should I #include it inside of ft_atoi, even though both functions will be put into a .a library together? It uses a function called ft_iswhitespace. An obviously simple little program. Is having the prototype for ft_iswhitespace enough, since libft.a will have both functions, or should I again, #include "ft_iswhitespace" at the top of the atoi function?
Eh, this one is for you to figure out. Find your own style, it's not that outrageous in any case.
You can't avoid C++ completely, it's worth learning it as much as it's possible to learn it. Within reason. The big thing to learn is the modern stuff like std::shared_ptr and std::thread. Boost is a good one to look at what is Boost today is standard tomorrow. There is no single C++ though really, some places just do C with classes, others use all the STL and Boost available, others use a completely different set of libs.
Thank you.
I think the standard definitions of the word sum it up rather well (from ([https://www.merriam-webster.com/dictionary/formal](https://www.merriam-webster.com/dictionary/formal)): &gt;**1a:** belonging to or constituting the form or essence of a thing*formal* cause**b:** relating to or involving the outward form, structure, relationships, or arrangement of elements rather than content*formal* logica *formal* style of paintinga *formal* approach to comparative linguistics &gt; &gt;**2a:** following or according with established form, custom, or rulelacked *formal* schoolinga *formal* dinner party*formal* attire The arrangement and essential character of the arguments the function will take. display\_name, generally speaking, doesn't care if it's current\_user\_name or any other name, provided they're just strings to be printed. It gives the "standard form" of a function, rather than any specific "content", as in actual arguments. Note how this is in contrast to "actual arguments", which are the actual arguments supplied at the calls-site, so that word is also nicely descriptive.
It might be worth looking into ifndef: &gt;One common use of ' #**ifndef** ' is to **include** code only the first time a header file is **included**.
great working as expected, but now trying to print a string. Could you give me some ideas on how to approach that? &amp;#x200B; This is what i've got &amp;#x200B; void LCD\_PutStr(int x, int y, unsigned char \* string, unsigned short bg\_colour, unsigned short fg\_colour) { int i, j, n; int len = strlen(string); for (n = 0; n &lt; len; n++) { for (i = 0; i &lt; 16; i++) { for (j = 0; j &lt; 10; j++) { if ( BF\_fontMap\[string\[n\]\]\[j\] &amp; 1 &lt;&lt; i) { LCD\_drawPixel(fg\_colour, x+(i\*n), y+i ); ResetWDT(); } else { LCD\_drawPixel(bg\_colour, x+((8\*n)+j) ,y+i); ResetWDT(); } } } } }
It will be easier to install [MSYS2]()https://www.msys2.org/ (this is a distribution that contains both MinGW32 and MinGW64) on Windows and use the included package manager to install GCC and SDL2. Even easier, if you have a 64 bits Windows install the [nuwen](https://nuwen.net/mingw.html) fork of MinGW which comes with GCC and SDL2 directly.
See it’s stuff like this I don’t know about. How do ya’ll know about the existence of this stuff? How would you google for it?
Never put an `#include` directive inside a function. Ever. Put it at the top of the file. If you have a book that tells you otherwise, burn it. I would also strongly recommend that you do not `#include` standard library headers inside your own. If your header uses `size_t`, just `#include` a header that defines it in every file that uses your header.
That's a C subreddit. I think this kind of general topic/algorithm would fit perfectly in other subs, but IMO it's unrelated to this sub.
Yup, considering how C++ has some modern abstractions and it's being heavily used for games, it should fit very well :)
&gt; There is a reason everyone has done GUI programming on Windows for 25 years ...and that is because Microsoft illegally acquired and then exploited a quasi-monopoly on desktop operating systems. There are other GUI libraries out there that are equally comprehensive and equally well-documented as the Windows API; Qt, for instance.
&gt; I don’t even need a dedicated library (besides windows itself). Sure, if you want to write a program that only works on Windows and you don't mind its many, many idiosyncrasies. SDL is cross-platform and much easier to use if all you want is a 2D or 3D canvas.
yeah, that's big. if you can find a job in a company that's like a dozen people or less you'll get a lot more variety (but also the risk of a lot less professionalism).
You should post the whole makefile.
It's such an obvious problem I'm surprised I've never run into it in practice.
The first line will take what is in $SRC and for each whitespace delimited token will add $OBJDIR to the beginning and replace anything ending in ".c" with ".o". So if $SRC == "foo.c bar.c" and OBJDIR="build/", after running the line, $OBJ will contain "build/foo.o build/bar.o" The second line will do the same replacement of ".c" with ".o" https://www.gnu.org/software/make/manual/make.html#index-addprefix https://www.gnu.org/software/make/manual/make.html#Substitution-Refs
Thank you very much for the explanation. I was not expecting makefiles to have so much complexity to them. So, if I am understanding correctly: SRC=ft_*.c OBJ=$(SRC:.c=.o) This would make OBJ = ft_*.o?
I'd recommend leaving `LCD_PutChar` as it is and then write a function `LCD_PutString` that calls `LCD_PutChar` for every character in the string. This way, it's harder to make mistakes.
Yes I would say that classes (virtual or not,inheritance), polymorphism, templates, references, copy/move semantics and the STL are already more than quite different than C!
Every bit of advice you got so far regarding the relationship between C to C++ seems to be misinformed. About the only link remaining between them is the computational model. Do NOT use C as a stepping stone to learning C++. It will cause you to pick up very bad habits when using the language. Instead use C++ to write C like code (not C code, C like), learn the pitfalls, and expand into other features.
And now with C++20, C++ has "concepts"!
Yes.
A queue isn't an array(though you can use an array to implement a queue) and offers no random access. It's a first in first out data structure. You can only queue and dequeue and peek at the element at the top/bottom of the queue. If it offers random access then it's an array and not a queue [https://www.tutorialspoint.com/data\_structures\_algorithms/dsa\_queue.htm](https://www.tutorialspoint.com/data_structures_algorithms/dsa_queue.htm) [https://en.cppreference.com/w/cpp/container/queue](https://en.cppreference.com/w/cpp/container/queue) &amp;#x200B; queueType doesn't mean anything in C++ unless this is a locally created class. &amp;#x200B; In the code above you store data in name but you never put name in the array that you search. Unless you're filling names with names somewhere else in the code you're just comparing the string name against 100 junk values as the original array/queue is uninitialized.
&gt; people can be imitated if you show to many languages in your profile I assume you meant “irritated”? I knew three languages plus x86 assembler before I started college, and had classes in six different languages, Bourne shell, and assembler for two different CPU architectures. In my professional life, I have written significant amounts of code in five different languages, not counting script languages or DSLs. I would expect an applicant to be fluent in two or three languages and familiar with at least two or three more.
I remember writing mine from this guide: https://docs.microsoft.com/en-us/windows/desktop/gdi/bitmap-storage
Thank you!
Any chance you can post the code?
How are we supposed to help you if you didn't gave any code to review? In your first part you said the reaction is randomly until user gives the same answer twice. You have two vars that store the actual answer and previous answer, it's enough to know if you should react randomly or not. Why are you using "the difference of those counters" to know if the decision should be rng or not?
Because, besides rng there’s two other reactions, in case reward or punish the player.
You didn't explain how you opt between those reactions. How it relates with how many yesses or noes the user has given?
Build some programs with programming concepts like linked lists, reading and writing files, sorting, trees, user terminal input, etc. Learn Make and Makefile concepts for compiling and linking. Create a library and use it in a separate project where you need to link it into the build. Create your own string manipulation functions, like string copy, compare, split, parse, etc. These could be your library. Create a program to take user input from terminal to catalog some sort of data, say movies. Data is stored in a linked list or tree structure. User function to save data to disk when finished. Program reads data file and populates structure on start. User can sort by title or genre, etc. User can add, delete. User can list movies by actor name, where program has to search through you list or tree structure. This is a good little project which hits several major programming concepts.
For \*some\* scenarios, me too. In general, C programmers are generally very careful in their API design because the language has fewer facilities to let them bloat APIs with \`AbstractConnectionFactory\` instances. They also tend to understand the underlying system (protocols, OS) in \*much\* more detail than high-level developers. &amp;#x200B; However, in \*most\* scenarios, a company would like (for example) a developer to spin up a webserver, database, and throw a UI on top of it all. Achievable in an afternoon with Ruby on Rails, or several days in C. People on the other side of the hiring table know this - a C programmer's understanding of the difference between \`xor eax eax\` and \`mov eax 0\` will not help them ship a product outside of an embedded environment.
Pipe or a Unix-domain socket should pass a gigabyte per second easily.
I see your points, but I can't help but feel that using the name "multilingual C programmer" to describe a dev that competently understands C, C++, python, javascript, etc. is just describing a "multilingual programmer": a programmer that can comfortably deliver sizable projects written in many different languages. If we're talking about a "multilingual C programmer" who only knows C but knows it across embedded, systems, game dev, etc. then, sure, they might *conceptually* understand C++ template programming (it's just C macros!) and virtual functions (it's just a struct of function pointers!). However, I would argue that their extremely low-level (probably inaccurately mapped) understanding of those concepts will not automatically make them good C++ developers. Those developers will make extremely C-centric assumptions like "lets ban template programming because it slows down compilation time" (despite the fact that the slowdown is still in the millisecond range even if we ignore incremental builds).
As I mentioned in my other comment, there's a website called scratch a pixel which explains how the main building blocks of raytracing work, but other than that I did it all myself. The specific case I was trying to solve was fairly different from the standard optical raytracer so I had to do a lot of things differently. The entire pipeline of actually taking the information from each raycast and building an image from it had to be done differently.
2 yes’s = reward 2 no’s = punish
This is not the right subreddit for this post.
Setting the bar high, I see
I think well-formatted Lisp is absolutely gorgeous.
It irks me that the authors of the C Standard have never defined any intrinsics to read/write various-sized integers as a series of octets in explicitly-specified big-endian or little-endian format, from storage that is explicitly specified as having known or unknown alignment. An operation like "take a big-endian sequence of four octets which is known to be aligned to a multiple-of-four offset from the start of an aligned block, and convert it to an "unsigned long" would be meaningful and useful on any platform, regardless of its word size. In fact, it would be even *more* useful on platforms with unusual word sizes than on those with common ones. Generating efficient code for such intrinsics would be much easier than trying to generate efficient code for all the constructs programmers use to work around their absence, but for some reason some compiler seem to prefer the latter approach.
appreciate the input
You recognize there are two mainloops in your main, only the first loop has effect ?
I know this post is old, but intermediate-mode renderers such as ImGUI (cimgui for c bindings) and Nuklear (pure C) work with OpenGL and create pretty decent GUIs out of the box. You can use SDL2 as simply a way to create an OpenGL context. If you use ImGUI they provide good details on setting things up, with Nuklear I can send a link to my project that I set up. I’ve done this before, and had no problems with Windows, Linux and Mac because OpenGL 3.3 is on all of them.
A tip for formatting code on Reddit: using triple backticks doesn't apply code block formatting like Discord does. Instead, you have to put 4 spaces before each line of code, *then* you can use any indentation you would normally use. \ Something like this (without the backslash) Becomes something like this.
ok should i just place the code for the LCD inside the first mainloop?
don't forget LCDinit() before the loop.
Thank you so much sir i appreciate your help
No. They are completely different language. Learn C properly, make a big project in it, then learn Assembly.
Do you need to count the entire yesses and noes ? If not, you can reset to 0 those two variables when you choose one of those reactions. You then guarantee only one of those at max will be 2 at any single time.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
&gt; The scanf accepts both floating point and strings. It doesn't. It expects a string *and then* a floating point number. The way to solve this is to read *only* a string into a buffer that is big enough - 4 characters isn't enough for the string "help" or for many floating point numbers I might want to enter e.g. "2.71828182845" Once you have a string use strcmp to see if it is "help", if it isn't use [atof](http://www.enseignement.polytechnique.fr/informatique/INF478/docs/Cpp/en/c/string/byte/atof.html) to convert it to a double.
I reckon if you want to learn C++ then best to get started right away. It's very difficult to replace C++ constructs in C, and most likely you would just find more streamlined and less flexible ways of doing things. If you want to build small modular libraries, then C is good to know. If you want to build big applications, then C++ is a good option.
&gt; Yeah I tried that. But the thing is that the counter must be returned to its initial value after the programs decision why? I don't understand. You want the counter to keep track of repetitions so that the computer can respond appropriately. You should only be resetting it to 0 if the user provides a new char value.
If I reset them to 0 the rng step returns again.
I believe you can do that. Check out the `inotify` function.
Because say, counter_yes has value 2, so the user choose yes two times in a row two times. Next the user chooses “no” two times in a row, counter_no now has value 1. But counter_yes is still higher(the if statement compares the difference of them), so instead the program choosing the reaction to the “no” answer (which would be punishing the player) it would keep rewarding the user. Plus when both counters have equal values, the difference is 0, so the rng step gets triggered again. By deducting the increment after the reaction that doesn’t occur, but I get limited to only one repetition of that reaction. So I have no idea what to do.
Also the position of the code is a bit messy, and instead of comparing the current user reply(variable char) with the last one (prev_value) I’m using 2 statements each increases the counters if the prev_value is either ‘y’ or ‘n’. I honestly don’t remember anymore why I had to do that.
If in the next iteration after a reward/punish reaction you still need to take in count what was the previous answer, you decrement by one the yes/no counter that you choose and the other is 0.
So using inotify, could I use inotify_add_watch? That watches specific files, but is there a way I could do it so it would notify me only when files that have specific lines of code within them are executed?
Hmmm... Wait... You have contradiction between the title and the question. Do you want a program, that reads a file and displays an alert when certain string is found in them or do you want to run a program, that monitors executed files and alerts when a certain string is found within that executable's image? Because these are two different things. Generally, you won't find strings like 'print("")' in a binary, unless it is not stripped (rare) or has that string as a static data (even more rare). You can find something like that in scripts, but they are not really executed. Instead, an interpreter (actual binary) from shebang is executed and given the script contents to process. If there's no shebang in the script, regular shell is used as an interpreter. You would have to monitor all executable files for OPEN_READ (i.e. with inotify), then figure out what it is and why it was opened for reading before parsing. Are you sure there isn't some other, more suitable way of doing what you want to do?
My bad. I want a program that will read a file and display an alert when a certain string is found in it.
Read a file as it is being executed, that is.
can you just take a screenshot or photo of your assignment and upload it? I don't understand what the program is supposed to do. I need to read the original instructions. I don't think you even need counters. The user only supplies a 'y' or a 'n' right? so you just need x and prev_x. take a look at this python3 code and see if this makes sense. Hit "Run" at the top and it will prompt you to play at the console https://onlinegdb.com/BJg8Vse34
In that case, the reading and searching part is quite easy. The simplest (and a bit dumb) way is to open the file, then read characters until you stumble upon the first character in searched string, then continue reading but this time comparing character-by-character with the searched string. If it's what you are looking for, great. If not, back out and repeat. Do that until you find something or the file ends. The alert box part is not that easy. You have to either use ASCII characters to display your alert box in the terminal or some graphics library to display a nice window-managed dialog. For programs started in the background, terminal isn't an option.
You could look through a file for a string, if the string is found, pop up a message. Then you could execute the file. I'm not clear on whether the execution is conditional on whether the string is there or not. The whole thing would be fairly simple.
So the first 5 lines of the code has me confused haha. i don't fully understood the concept yet but i'll try to thanks for the advise. i'll also keep the whitespace advise in mind too thank you.
I'm still not clear on exactly what you mean. "executed" has a very precise definition, which I'm not sure if you mean to use. When you say that a "file" is being executed, do you mean, when a program (executable code) is being run, your program can be notified, then read that binary? It almost sounds like you want real-time antivirus protection type functionality. Is that what you are going for? Or are you talking about any file that is opened (maybe a word document being opened by microsoft word, for example)?
lol I always felt there was a lot of masochism required to enjoy rust (cause the borrow checker). But I could see how 10,000,000 lines of error messages when you make a typo in a template might not be everyone's cup of tea.
Nope c is the only good language. But joking aside, just learn c++ for what it is and not how it relates to c. C++ comes with a lot of job opportunities, though my lease stressful professional language has been c#.
I started writing my c code like that when I was 21, and now I can't stop. Parents: talk to your kids about oop before a professor does.
First, let me remark that I made a small mistake above. The if statement should check if argc is greater than 1. Let me elaborate on the first five lines: float fahr, cels; we declare float variables to hold our Fahrenheit and Celsius values if (argc &gt; 1) { argc is the number of arguments passed when you run the output file from the command line. We include this basic check to make sure *at least* one argument is passed. fahr = atof(argv[1]); // read Fahrenheit value from command line argv[1] is the value you pass through the command line. However, this will be a string (a char array), so we call the atof function to convert it to a float. else { printf("Error: no command line argument passed\n"); return -1; } when no argument is passed in the command line, we should print an error. Hope this helps. Let me know if you have any questions.
Thanks, I got there in the end. On mobile I’m able to just put in the triple backticks, but I guess on desktop it’s different, so it took some googling to figure it out!
Actually, I just checked using the new interface and it works properly there, the old Reddit interface doesn't work though. Seems like both options are available!
LLVM
I'm not really sure what you are asking for. The language spec imposes very few requirements on the memory model of the underlying hardware. Basically none before C11, other than that "memory is addressable" and "if you write to an address and then read from it you'll get the value you wrote back" (assuming single threaded operation).
I posted this about a year ago, but have made a lot of changes since then. &amp;#x200B; Let me know if you have any suggestions for what can be improved. Thanks.
tbh, i would expect that in a piece of malware
&gt; I see your points, but I can't help but feel that using the name "multilingual C programmer" to describe a dev that competently understands C, C++, python, javascript, etc. is just describing a "multilingual programmer": a programmer that can comfortably deliver sizable projects written in many different languages. &amp;#x200B; It is not just your feeling. I don't know how anyone can completely understand anything. &amp;#x200B; &gt; If we're talking about a "multilingual C programmer" who only knows C but knows it across embedded, systems, game dev, etc. then, sure, they might *conceptually* understand C++ template programming (it's just C macros!) and virtual functions (it's just a C struct of function pointers!). However, I would argue that their extremely low-level (probably inaccurately mapped) understanding of those concepts will not automatically make them good C++ developers. &amp;#x200B; True, but it also doesn't automatically make them bad either. &amp;#x200B; &gt;Those developers will make extremely C-centric assumptions like "lets ban template programming because it slows down compilation time" &amp;#x200B; I don't know. I can't speak for others and I wouldn't ban any feature of any language. &amp;#x200B; &gt;(despite the fact that the slowdown is still in the millisecond range even if we ignore incremental builds) &amp;#x200B; I'm sorry, but you can't really make that claim if you don't know how or how much templates are used(or abused). &amp;#x200B; &gt;However, I would argue that their extremely low-level (probably inaccurately mapped) understanding of those concepts will not automatically make them good C++ developers. &amp;#x200B; True enough. I'm for example a horrible C++ developer. I simply cheat by hiding the ugly shit in C. I know not to return that NULL though.
&gt; What issues can it cause if assert is simply over-defined? That's easy: at best, it's a compiler warning that can't be turned off (in GCC). At worst, if someone is compiling with `-Werror`, then it's a compilation error. &gt; Why would anybody #include &lt;assert.h&gt;? That's useless from the point of testing. Very often code in the real world isn't as clean and nice as our pet projects. I've seen quite a lot of libraries that put all of their possible dependencies into a single header file, so that each source file only needs to `#include "my_library.h"`. If that means that `assert.h` gets included, so be it. After all, what harm should it be included a header from the C standard library? Obviously, the problem is if someone then tries to write some test code by doing `#include "my_library.h"` followed by `#include "rebanc_test.h"`. Kaboom. And no, changing the order of the includes won't help. "Well, they shouldn't blindly include `assert.h` without knowing whether they need it! They should refactor their header files!" you cry. Perhaps. But perhaps you shouldn't stomp on a name that's claimed not just by some other project but by the C standard library itself. If someone was trying to use your unit testing library and ran into this problem, they would have three options: alter their code (if feasible; the effort required could be minimal or enormous), alter your library, or abandon your library and find a different one that works without having to modify any existing code. Make of that what you will. &gt; What purpose would be a non-fatal assert or expect? If something gone wrong, it is wrong, isn't? Yes, if something went wrong, then the test case should report failure. But it can do that at the end, after running more of the test case. The user might want to see what *else* fails in that test case. Maybe the individual test case uses `expect` a dozen times to check an assortment of related variables and statuses. In that case, it might be useful to know whether one `expect` failed, or half a dozen of them did... but if the test exits fatally as soon as the first one fails, the user only ever knows that one `expect` failed, and has no information about the rest of them (unless of course the one that failed happened to be the very last one in that test case anyway). I've definitely come across scenarios like this doing VoIP, such as call transfers. You have a call between A and B, and you want A to transfer the call to C. At the end of the test, you expect that A will be idle, B will have a call with C, and C will have a call with B. If the test case gives up as soon as one expectation fails, you miss out on knowing whether any of the other expectations were met or not, which can be very useful for figuring out what went wrong. (I'm not trying to convince you that you ought to implement this, just explaining how it could be useful, since you asked.)
Bbbbllllleeeeuuuggghhhhhh!
The sooner the better. Every language has cruft, and lisp is basically made of cruft. Desensitizing yourself early will pay off quickly.
Serious question: Why? Bonus question: Why do you allocate the bookkeeping structures using malloc? That on itself is a deal breaker for me as a C++ enthusiast.
Would love to see a single header version of this!
&gt; I assume you meant “irritated”? Why not both? I don't know why, but keeping it relevant seems to work better. &gt;I would expect an applicant to list fluency in two or three languages and familiarity with at least two or three more on their CV. I agree, but lets face it, not everyone thinks like that. Some people would love to hire someone who is equally or smarter than them self, others don't. To bypass this nonesense, you focus on what is relevant. Of course you want to list these other things, and that is where github/something else comes to play.
Probably because writing containers over and over again gets boring.
doesn't the gnu library have any?
Then why are you in /r/C_Programming?
Not that I know of. And most of the non-posix/c-standard extensions are gpl. And not everyone wants their code to be gpl. MIT allows you to license your own code however you want.
&gt;C++ enthusiast It is a C library, not a C++ library.
Why?
I like the single header library style (like stb\_image.h) [https://github.com/nothings/stb](https://github.com/nothings/stb)
The real question is how else do you do it?
You realize new calls malloc, right?
He probably uses malloc because is a C library and not C++.
Unnecessarily pedantic man flies in, "not necessarily", then flies away.
I did write a tool one time that takes a list of source files and condense it into a single file. I forget how good it was before I got bored.
I am talking about bookkeeping structures like struct internal_array.
I’ll try man, I’ll try.
Gotcha, thanks for the reply!
I am talking about bookkeeping structures like struct internal\_array.
Create a precompiled header. Don't include header files you don't need. It just increases build times.
ok so i watched a 10 min youtube video on this and reread what you said and i think it's starting to make sense? for argc is how many values are stored and char\*argv is just like the position? like let's say in a list of 1,2,3,4. argc would be 4 and like say argv(2) would be 2 corresponding to its position in the list? so is this like a stylistic thing for organization then? would this come after the already written commend that solves for the Fahrenheit and celsius numbers?
What can a virtual machine do that a real machine cannot?
&gt; After all, what harm should it be included a header from the C standard library? Totally convinced me. It just was not a good idea to make name collision. I have to prepare for everything. &gt; If the test case gives up as soon as one expectation fails, you miss out on knowing whether any of the other expectations were met or not... Also convinced me, and would be a nice feature too. &gt; (I'm not trying to convince you that you ought to implement this, just explaining how it could be useful, since you asked.) I just have some ε real world experience, so I'm very grateful for you to reply and I can learn from it. Thanks.
To piggy back on this, because it’s a valid concern... Using malloc basically hard codes your structure to use the heap. If that fits your use case then fine.. but what about those of us who would rather have the ability to pass in a block of data or a custom allocator? You don’t have to use malloc you can allow the user of the API determine how they want their memory allocated.
I work at a large engineering firm writing high performance nuclear software - focusing on analytical math like calculus won't help you build better software. 98% of the time i don't use more than highschool algebra. What will help is studying the math in computer science. Look for some material on discrete math if you want some theoretical stuff. But a comp sci specific algorithms and data structures course would be best. You probably would benefit from a machine organization/architecture course too.
Discrete math and linear algebra mostly. Maybe the binary number system and various bases like hexidecimal. More important is learning about data structures and algorithms specifically and problem solving techniques in general.
This subreddit exists to desocupas the C Programming Language. Please redirect C++ related content to r/cpp_questions.
If you may me I will point you on the right direction, this reddit is for c programming, not C++
[This](https://www.reddit.com/r/C_Programming/comments/b7t36w/best_ways_to_improve_as_an_intermediatelevel_c/eju1ff2?utm_source=share&amp;utm_medium=web2x) is my response to someone asking for resources to make them a better programmer in general. It's a list of textbooks that I found helped me a lot in writing more efficient programs that fully utilized the tools my hardware and operating system already provided. For making your algorithms more efficient you should have a passable sense of proof based mathematics. Aside from some edge cases, you likely won't need a knowledge beyond discrete math. For programming specific pointers on efficiency I highly recommend the first book from my above link: CLRS. It's the most highly recommended algorithms and data structures text I've ever seen. It's a dense book, with loads of language agnostic examples, but the first chapter or so focuses explicitly on algorithmic complexity analysis. Having a grasp of proof based mathematics will help you, but the beginning of that book should get you up to speed on everything you'll likely need. Hope that helps.
Oops my apologies, thank you
When writing code, you need to be clear about the logical relationships between concepts/objects. Then you should learn to isolate individual problems and to tackle them with minimal dependencies to other code. The logic behind your code is far more important than the coding style.
Can you name me a single implementation of standard library that new doesn't call malloc? Good luck with that.
Yea, don't do this.
No not really. I mean you can always define your own allocator that uses something like a static memory pool. But idk any off the top of my head that don't wrap malloc by default.
Why? Sqlite does it. You don't maintain the code as a single file, it's just a preprocess to compilation. It'll actually help the optimizer. In my case it was because I was working on a crappy compiler that could only compile 1 file... I curse the person who invented dynamic-c.
Actually that's a good point. A lot of embedded developers don't touch malloc. Lol maybe you can restate the question outside of this parent comment that has been down voted to oblivion.
1. If you're going to use this code, you're going to compile into a library. You should use it as a library. How often are you going to update this code? Not often. 2. Compiling into a single file is going encourage others not to use it as a library. They're going to create other painful projects. 3. No one uses the SQLite amalgamation. I have no idea why they did this, but my guess is to deal with some very specific embedded issues. There are probably 3 people using that in production. 4. Just because someone else does something, doesn't mean you should. &amp;#x200B; Also, the malloc argument someone made, is someone that has no idea what they're talking about.
1. Yeah but the library will potentially have better optimization as a single compilation unit instead of several. The output can still be a library. 2. Just don't check the single file into version control. That's what I did for my crappy dynamic c project. 3. That's funny, cause both companies I worked at that used it, used it as a single file. Albeit at least one of these companies had some way bigger issues than using single file sqlite. The other more organized company compiled Poco like 8 times resulting in build times upwards of an hour. Lol and they wanted to solve the problem with distributed building servers. 4. Yeah. True.
Or even in an anti-malware program.
1. Where did you come up with that? 2. I'm not sure where you're going with this. 3. If Albeit was using in a single file, they had some pretty novice developers. Build times are a problem, that is why we link libraries. We don't compile the code over and over. 4. I'm glad you agree.
The build times for our sqlite using code was like 2 seconds. It wasn't a big deal. Even with the cross compiler. Also https://en.m.wikipedia.org/wiki/Single_Compilation_Unit
Desktop link: https://en.wikipedia.org/wiki/Single_Compilation_Unit *** ^^/r/HelperBot_ ^^Downvote ^^to ^^remove. ^^Counter: ^^256444
**Single Compilation Unit** Single Compilation Unit (SCU) is a computer programming technique for the C and C++ languages, which reduces serial compilation time and allows the compiler to perform certain program optimizations even when the compiler itself is lacking support for whole program optimization. The technique can be applied to an entire program or to some subset of source files; when applied to an entire program, it is also known as a unity build. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
"Who would ever use an array based binary tree?" - me, eight months ago. Guess what I am working on right now.
&gt;byrongo &amp;#x200B; For 1. &amp;#x200B; From your link on wikipeida: &amp;#x200B; "These optimizations are often not possible in many compilers, due to independent compilation, where optimization happens separately in each translation unit during *compilation,* but the "dumb linker" simply links object files, without performing any optimizations itself, and thus interprocedural optimization between translation units is not possible." &amp;#x200B; I would like to know which compiliers (the many and often) they're refering too, because Intel, MSVC++, Clang/LVMM and the gnu tool chain don't have this problem. &amp;#x200B; Like I said, 3 people. This is an embedded issue that you unlikely to run into today. &amp;#x200B; For instance, Microsoft VC++ has a whole program optimization flag, as does g++, gcc, clang, which uses the [\-fwhole-program](https://stackoverflow.com/questions/15606993/g-optimization-flags-fuse-linker-plugin-vs-fwhole-program), which is enabled by default with -O. &amp;#x200B; Also, SCU includes all header entries, etc. This might be beneficial for something like the MicroC compiler, which doesn't like libraries. These tool chains exist for PIC processors, and other embedded type targets. &amp;#x200B; If you're using one of those, then "malloc is bad" and they're not going to use this library.
This sub is about C programming, not C#. See r/csharp.
You are my angel guardian! Thank you quite a lot!
Not impressive but a bit fun: you can build a bourne-like *nix shell with support for (environment) variables, background/foreground jobs, pipelines, i/o redirection, etc.
If the differences are just a few lines of code preprocessor directives might be the best choice. Annother way would be to define a unified api for the different platforms. A good example might be the threads API of gSOAP: https://www.genivia.com/doc/guide/html/group__group__threads.html
The easiest way is to have a single header file for functions of each module, but different source files for each operating system's implementation. Either use the preprocessor or build system to decide which version to compile. There really isn't much to it. Mark which modules of your code that have to be platform specific, design a wrapper API around them, and then write the implementations for them. A quick tip: sockets on Windows and Linux are nearly identical except for a few minor quirks, you could possibly get away with only one implementation using the preprocessor for a few platform specific switches.
I do this a lot when planning code, write the code out like /u/HughMacdonald did then write it for reals, it helps you visualize things. Any time you can't figure out a loop like this try it, I've found it helps me a lot, even after doing this for 20 years.
&gt; So using inotify, could I use inotify_add_watch I think so. &gt; hat watches specific files, but is there a way I could do it so it would notify me only when files that have specific lines of code within them are executed? No, that's not possible. Can you explain or give an example for what you mean when you say “when files that have specific lines of code within them are executed?” I have a hard time imagining what exactly you mean. Depending on how you mean this, it can be impossible to do what you want or their could be alternative solutions.
Ive used amalgamation. Noone is a bold claim
http://infolab.stanford.edu/~ullman/focs.html
&gt; &gt; &gt; people can be imitated &gt; &gt; I assume you meant “irritated”? &gt; Why not both? I don't know why, but keeping it relevant seems to work better. Wait... did you actually mean “intimidated”? That makes more sense.
Which Gnu library are you taking about?
the standard C GNU library. I would expect to have some basic containers everybody could use.
I once wrote [a program/library that used dynamic bit vectors](https://github.com/gcross/CodeQuest) and after profiling I discovered that it was spending 75% of the time doing memory management. It sufficed for my purposes to create a template that could specialize either to a dynamic bit vector or a static bit vector of a given size and then to instantiate it for bit vectors with size 1-256.
Does your allocator use malloc? If not, you can LD_PRELOAD a shared lib that provides the malloc/free interfaces that use your allocator and just run real programs (gcc, sqlite, etc). Otherwise, I'd look for a "normal" c++ app and replace default new.
Sounds complex. But thanks for the reply! I can't improve something I can't understand.
Well... do you know of any small + influential programs then? Compression comes to mind (pkzip is smallish + influential) but they usually use a large fixed-block of memory, or their own custom allocator anyhow. So no go there. Replacing "new"... wow. Its an idea.
Boost unit tests?
Boost is quite large?
Apache web server cache. Apache is currently the most used webserver across the board, and is open-source. Build a quick-and-dirty dynamic web app that would benefit non-trivial from caching, then build a benchmarking tool. Set up servers running Apache's vanilla cache, and running your own allocator, then stress-test using common benchmarking tools. Publish your results.
Quite. But its unit tests should be isolated.
Try the *binary tree* benchmark from the compiler language shootout game.
Oh... thats a really good one!
&gt; binary tree benchmark from the compiler language shootout game perfect start thanks. However, once that's done I'll need more :) But its a great starting point.
By the way, if your allocator doesn't do anything to enable concurrent operation (e.g. keep a mutex for allocations), the results are going to be rather meaningless as repeatedly locking and releasing the mutex consumes a significant amount of time.
Ah... good point.
&gt;r Bold claim? &amp;#x200B; I suggest you start with a book. Compilers: Principles, Techniques, and Tools. Some call it the dragon book. The new edition covers this very topic around the middle of the book under optimizations.
You almost have it. Let's say we have some program, called main, and we run ./main 1 2 3 4 argc would be *5*, because the first value of argv is always the name of the program. argv is then {"main", "1", "2", "3", "4"} One more thing: arrays in C (and most programming languages) are *0-indexed*, which means we count the first value of an array as the 0^th element. So in the above, we have argv[0] = "main" argv[1] = "1" argv[2] = "2" and so on.
Lua, the programming language, [requires the caller to supply an allocator function](https://www.lua.org/manual/5.3/manual.html#lua_Alloc) when you initialize an interpreter state. The prototype looks like: typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize); You could provide that interface to Lua, then benchmark some Lua programs that make lots of garbage and see how your allocator does under that load. Side note: That's actually a pretty generous interface as the allocator doesn't need to keep track of the size of the memory it has allocated. Lua tracks that information itself and provides it via that `osize` parameter.
The code wouldn’t fit the picture. And that python code would take action one step before. But hey I figured it out man! What I need is two prev_value’s variables one = the current answer and the other = the previous one. Then just an if statement. Thanks a lot! I wouldn’t be able to get to this without your help!
Never mind, it returned to the rng step again.
Anything that uses [SQLite](https://www.sqlite.org/). The entire library is contained in a single file, and it hides all its memory management, so you can trivially modify it to use your allocator while the application continues to use the OS's allocator.
find a more entertaining use for C your ideas of what you should use programming for are makin me sleepy
awesome, glad you got it working! great job
I did this in my [Tulip Indicators](https://tulipindicators.org) library too. The Makefile can compile to a library or it can compile to one huge C file. I found it much easier to integrate one huge C file into other projects and ensure that it works on every compiler and build system. For example, if you're making a node.js extension, then you really need to fit your code into their build system. It's much, much easier to fit one huge C file into that than a hundred small ones.
c programming geeks for geeks derek banas thenewboston
https://github.com/rby90/Project-Based-Tutorials-in-C
You might find this website and code helpful: locklessinc.com https://locklessinc.com/articles/allocator_tricks/
Thanks.
I'll look into this thanks.
Use fgets(string, 256, stdin);
Read the manual for `scanf`. There it says why `%s` won't accept spaces. There's no excuse for not reading the manual.
I would recommend starting with Let US C then go to ANSI C by Dennis Ritchie (don't go to it straight you will get tensed) then do data structures using C by Tanenbaum. This is what I am following. It's a long road but the destination is Disneyland.
Just for future reference: if you are going to post this large of a code snippet, it's more helpful if you do a pastebin and then just provide the link.
&gt; I would also strongly recommend that you do not #include standard library headers inside your own. If your header uses size_t, just #include a header that defines it in every file that uses your header. That's a common approach, and it avoids some problems but creates others. For example, if one add a new function to one's header file that accepts a `va_list` argument but doesn't include `&lt;stdarg.h&gt;` within the header, that will break any existing client modules that don't include `&lt;stdarg.h&gt;` themselves, even if they would never care about the existence of any of the functions that use a `va_list` argument. It's too bad the Standard didn't specify standard-reserved macro names that headers should define (e.g. `__STDC_STDARG_H`) so as to allow a header file code to say, e.g. #ifdef __STDC_STDARG_H void myFormatter(char const *restrict format, va_list vp); #endif and be compatible with clients that either include `&lt;stdarg.h&gt;`, or don't include it but don't try to call `myFormatter`. Given that it did not, however, I don't know any approach better than having the user-code header include `&lt;stdarg.h&gt;` and hoping that doesn't break the client.
I like your suggestion. Any idea how I would get started with this? I've never used lua and have no idea where to start! haha. I mean... I downloaded it, and did "sudo make install". I guess I should join their forums and ask them :)
for that I have added \[\^\\n\].
didn't solve the problem. any more ideas?
Yeah. That works. But remember, that the directive is `%[^\n]`, not `%[^\n]s` in this case.
You can also use getline.
 scanf("%\[\^\\n\]s",name); // error in this line instead of %\[\^\\n\]s %s works but it can't accept names with space &amp;#x200B; use this: &amp;#x200B; scanf("%\[\^\\n\]",name);
Thank you. Wow I have never seen this website of geeks for geeks. It looks easy to understand.
What do you mean? Anyway , thank you for responding to my post :)
That didn't work also. Any more ideas?
This didn't work.
how?
Put space there scanf(" %[^\n]", name);
It should work. Please post your updated code. Also post what input you exactly gave, what output you expect and what output you received instead. Lastly, make sure your code is formatted to be readable. If you can't get the formatting right on reddit, upload your code to a paste service of choice and post a link.
scanf(" %\[\^\\n\]s", name) worked. Strange! space between " and % ? Really C is this what you really wanted from 1 week. Any explanations man?
s is also required. without format specifier how it is supposed to work.
I don't really know why, but our profesor told us to always pu space. I think it is because of linux terminal. I've never put s behind it, but it always worked.
Your last scanf is for a number. That leaves a \\n in the buffer. Next %\[\^\\n\] will then immediately see the \\n and return "". When you add a blank, scanf will skip any amount of whitespace, including newlines.
Lua is intended to be an embedded, so don't fret about grabbing the Lua sources and getting your hands dirty. It's part of the fun! Here's what I would do: Grab the source tarball, open `lua.c`, and on line 608, or whatever it is in your version of the source, change the line with `luaL_newstate()`: https://github.com/lua/lua/blob/389116d8abcc96db3cfe2f3cc25789c089fe12d6/lua.c#L608 To a call to `lua_newstate()` with the function pointer to your allocator. You'll need to supply a prototype or include a header or whatever. The `luaL_` prefix means it's part of the "auxiliary" library, and this function will provide `lua_newstate()` with an allocator that uses `malloc()`, etc. Build Lua and statically link it with your allocator library. Then you'll have a version of the command line interpreter that uses your allocator. I don't know many good Lua programs to test offhand. Here's a fancy one you could try: * https://github.com/jcjohnson/neural-style A couple of my own: * [maze generator](https://gist.github.com/skeeto/b9fb23ac1e1d9c508ceaf87420f87a43) * [stream cipher](https://gist.github.com/skeeto/4b2e8d55c75d6d5e28f1afafa82df284) (though this tries to avoid allocating as much as possible) Just tweak them to run in a loop or whatever. It's hard to avoid generating garbage in Lua.
Prior to C11, do you know if there were any restrictions on valid C programs being able to address their own text segments, i.e. rewriting their own instructions?
There are lots of suggestions in the thread about methods and pointers to other benchmarks. The benchmarks mostly measure the CPU cost of the allocation, or the wall-clock execution time of a benchmark program. Useful things to measure but I wanted to point out some other things to consider: * How memory-efficient is it? That is, what is the value of (bytes allocated from the operating system / bytes available to the application) for your benchmark? Some allocators "strand" memory in thread caches belonging to idle threads (or threads which just don't need large amounts of memory any more). * In a long-running server, when memory usage spikes up and down, how quickly does the allocator release freed memory back to the operating system? * How resilient is it so buffer overrun/underrun? * What's the overhead of a small allocation? That is, if the application wants to `malloc` an 8-byte struct, what's the memory cost of doing so one million times? * Can you do memory profiling with it? That is, suppose your program uses 1.7 GiB of RAM. Where did it go? Which functions allocated it? Why? (The "Why?" can often be answered by examining the call stack at the point the allocation is made).
have you tried [getline](http://www.cplusplus.com/reference/string/string/getline/)?
sounds like python. i remember trying to learn python a while back and came across this same concept, thanks!
Not sure I can answer all your questions but I'll try. * What's the overhead of a small allocation? : Around 1%, regardless of the type. Although big objects actually can waste more. * Memory profiling... my system keeps track of everything but doesn't give you that information just yet. Depending on if I get actual users with real interest... I could add it! But yes it's not too hard to collect statistics (for me if I were to modify the code). * releasing speed: Mostly right away... although it will try to "hold on" to a little bit of memory to avoid thrashing! About 1MB max is "held onto". * Allocation efficiency... well... again around 99%. Almost all the memory we get from the system, is available to the app. In fact, using C-style coding, we can get further space-savings over what C++ does. * Because C++ has to store the "Class-type" along with the object. Whereas my system, allows to store the class-type "per-block", meaning a block of objects of the same class... their class is stored once per the entire block. So that's potentially 4-bytes saved using C over C++. * We can also store a "Shared object" across a "memory-layer" (an invention of mine). Let's say you are parsing an XML document, and all the XMLnodes share a pointer to the root "XMLdocument" object. So that's 8/4 bytes wasted per-object to all point to the same thing. My system allows create a "memory-layer", where you create all your XMLnodes (or some other class) using that "memory-layer", and the memory-layer points to the XMLdocument. So, that's like... maybe 12 extra bytes saved over C++! By allowing smaller-structs. Ontop of the around 1% overhead.
Depends on the compiler and platform. In general, writing to anything that is not inside a non-const variable is either undefined or implementation-defined behavior. I imagine most modern OSes will have those memory pages marked as read-only -- they're probably memory-mapped chunks of the executable file that can be shared across all instances of that same process, so letting anything modify the data in memory would be very bad. If that is the case then trying to write to them will raise some kind of segmentation fault or other access violation exception. With an OS/hardware that doesn't do that it would probably let you write new instructions in there.
how? example?
These projects look great. I'd love to give it a go! Thanks so much! can't do it today as I'm pretty beat, but... when I'm feeling energetic I'd love to see how well my allocator works with lua! and test it on neural-style.
https://www.tutorialspoint.com/c_standard_library/c_function_strtok.htm
You should checkout the strtok function from string.h, that would be my starting point for this kind of thing.
By reading the man pages =\]
Read file into a single string or mmap. Locate field separators (. and \n). Read fields and store as field + \0. Assuming there's no escaping. Alternatively just tokenize the file as single characters, iterate and collect fields. For collecting the characters, perhaps you could use talloc or another nice memory management library.
Hey, I like your suggestion of letting the user specify how to use malloc, calloc, realloc, and free. Feel free to create an Issue in the GitHub repository with all the information.
Hey, I like your idea of combining all the headers into one, to give the user of the library an option for which way of including headers they would like to use. Feel free to create an Issue in the GitHub repository with all the information.
I wish I could find the article about how you shouldn't roll your own CSV reading code. Once you get into it it's far more difficult that it at first seems.
Oh, can I ask how long have you been mastering the craft of C?
What alternative is there to malloc? I see no reason not to use it
Three allocations just for insert one node(for the node itself, key and value) is not good - [https://github.com/bkthomps/Containers/blob/master/src/map.c#L294](https://github.com/bkthomps/Containers/blob/master/src/map.c#L294), [https://github.com/bkthomps/Containers/blob/master/src/map.c#L300](https://github.com/bkthomps/Containers/blob/master/src/map.c#L300), [https://github.com/bkthomps/Containers/blob/master/src/map.c#L306](https://github.com/bkthomps/Containers/blob/master/src/map.c#L306).
Most C implementations that target real machines offer no guarantees whatsoever about what will happen if a program invokes certain forms of Undefined Behavior. Virtual machines can guarantee that even if a program invokes Undefined Behavior, it will never be able to do anything worse than choose in Unspecified fashion from among the actions the VM supports.
I'd say that there is no difference between the two variants. A VM sufficiently advanced to execute C code is also a VM that can do exactly the things native code can do. Thus there is no closedness in behaviour gained.
Yeah, Python is also 0-indexed. C arrays are similar to Python lists. The main difference is that Python lists don't require every element to be of the same type and that Python includes some functionality (like list.append()) to take care of the heavy lifting where in C you would need to manually allocate memory.
Your data looks like period-separated values. Did you mean to use commas? Anyway, be aware that a CSV can contain commas and even newlines within a quoted value. Because of this, you will probably want to parse character-by-character using a state machine to track whether you're in a quoted string or not. It'll be a lot easier to find a good parser online somewhere.
I am talking about bookkeeping structures like struct internal\_array. These should be stored on the stack. Doing it otherwise increases the heap fragmentation, reduces the runtime performance due to increased number of allocations, increases the number of cache misses.
I'm just guessing here...but it seems the semaphore might be used for some sort of shared data structure. Like maybe the user input thread puts stuff into a buffer and then another thread processes the buffer while the semaphore ensures accurate concurrency for buffer access.
LOL! Yas!... But I'm just going to be *bold* and say, why not all three? Think about a interviewer that just needs to learn everything that is on the applicants CV! This is going to take a lot of time and effort from the interviewer so the applicant is just being wholesome if.. and ... no? O.k. I will see my self out. :'(
good to know. i'll be learning more about python in computer science one during the next semester. Which is why i'm trying to learn C atm then try to move on to C++ and then transition to python by the beginning of the semester.
I would stay far away from channels like thenewboston. The sheer amount of content he produces should be a red flag, he never learns things properly and just regurgitates other tutorials. The few programming videos from him I've seen were riddled with terminology mistakes and minor errors. There's so much high quality material out there that there's no reason to stoop as low as thenewboston. I might watch a thenewboston tutorial when I need to know what to click on in a program I'm unfamiliar with, but definitely not for programming.
For logging, what you probably want to do is create a queue of messages to be logged. (A [circular buffer](https://en.wikipedia.org/wiki/Circular_buffer) is a useful data structure for a queue. You can probably get away with making it fixed-size, but if that's not acceptable then you can dynamically enlarge it if it fills up.) With a queue, you have two basic operations: enqueue and dequeue. Both operations need to be synchronized (i.e. ensure exclusive access using a semaphore) to ensure that only one thread accesses is reading from or writing to the queue at a time. The logging itself can be done outside of the synchronized portion of the code. Just get the message (with the dequeue operation), then log it and free any associated memory when you're done. I'm not clear on how the other threads are supposed to interact, but a similar queue system may also be needed. The idea is to have the threads do as much of their work as possible in the non-synchronized code, and synchronize only when threads need to interact (i.e. use shared data).
Absolutely right. I really wonder why your original post has been misinterpreted that much. Any decent library should take allocation and free functions in their initialization and accumulate/keep auxiliary buffers in a stack-allocated state object for reuse in subsequent calls. Same holds for C++ naturally, with major libraries failing these requirements,
This sounds like a simple homework assignment, where it's OK to assume clean, simple, input (i.e. no spaces, quoted data, etc). In that case, you're likely expected to know about finding tokens and splitting into arrays (those are keywords that should help your research). Also, look at the functions available in [string.h](https://en.cppreference.com/w/c/string/byte). Hint: you'll likely need to use a loop break a string up into an array.
If you had the effort to read any manual instead of spamming all the suggestions here with "how? give me code." you would got your answer to that. - C string that contains a sequence of characters that control how characters extracted from the stream are treated: - Whitespace character: the function will read and ignore any whitespace characters encountered before the next non-whitespace character (whitespace characters include spaces, newline and tab characters -- see isspace). A single whitespace in the format string validates any quantity of whitespace characters extracted from the stream (including none).
It's good to know all three languages, but do note that this isn't a natural progression or anything; C++, C, and Python are all different languages with different use cases (though they are all general purpose). I am fond of [hackerrank](https://www.hackerrank.com) for learning to code. They have good tutorials in Python and their algorithm questions are both good for learning CS concepts and for practicing your favorite language.
yeah no i realize that they're different i'm just doing it more to get comfortable learning and understanding languages. i bookmarked hackerrank i'll be sure to make use of it later when i'm more proficient :)
https://www.reddit.com/r/cpp/
Awesome! Enjoy learning to code!
I think you might need to use semaphores for signalling. For example one thread waiting on a semaphore while another thread get a data from somewhere and put it into some shared structure then increase semaphore so the thread waiting for the semaphore be signalled and take the job. Note that you probably need to use mutexes for critical sections since you are using semaphores for signalling.
No one wants to look at pictures. You can format your code on Reddit making it much easier for us to read.
https://www.gnu.org/software/libc/manual/html_node/Line-Input.html If you don't understand how to read the examples and implement it into your program you need to stop and find at least one function of stdio.h you do understand at least a little bit of. You'll find its entry in the libc manual is written in the same way with similar simplified examples of how to implement it. If you're still struggling just google "getline c stdio.h strings input" someone will have a worked example online.
1) Wrong sub 2) There's no need for a "best way" you don't need to crash course years of programming at your age. Learn the way you enjoy it the most. You don't NEED to learn it so keep it entertaining and the way you like it.
Did you type "Bush did 9/"?
i'm doing that. going to reformat it. i tried but it didn't come out as intended i apologize. i thought i had the post hidden.
Don't worry, just know some people like me are on small devices like phones and can't read code on screenshots without developing eye cancer.
lol yeah.
nope i can't see to format it correctly i'll just delete it ;(
Did you close the stream, using Ctrl-D (Unix) or Ctrl-Z (Windows)?
what do you mean close the stream and i'm sorry that you have to look at poorly formatted code. i just can't seem to get it right. i'm surrounding the code with backticks and indenting 4 spaces but it doesn't look like it should.
First, I'd advise using a makefile to automate ruining your tests. Secondly, you can redirect stdout using pipes
It's because you're reading in from STDIN. Until you close the stream, it won't reach the EOF character it's looking for
Type your “thanks did nothing wrong” (or whatever) in the console Press Enter Press Ctrl and Z at the same time Press enter (I think?) Because you while not getc() a EOF until you reach end of *file*. (If you wanted to count char on a line, you should stop at ‘\n’, not EOF). Also, to format code in reddit, either surround it with 3 backticks, or indent all the block by 4 space (with a new line before and after the code block)
i'm using the ritchie and kerninghan book and it doesn't mention this :/ he just talked gave the code sorta explain it but didn't show what it was supposed to output *sighs*
Why would the interviewer have to learn everything on the CV? It's not a quiz show or a police interrogation. The interviewer will only test skills that are relevant for the position. But I'd be highly skeptical of an applicant who only listed one or two languages.
ok ctrlz z closes it and gives me an output number which im guessing is the total characters inputed? i wish this book would have stated that :/ as for the formatting the backticks and indents don't work :/
`#ifdef va_start`
I understand your confusion. This Ctrl-d/Ctrl-z is outside of the scope of C, and a characteristic of the environment (specifically the shell). For instance, you could have your program count the number of characters in a file by typing: MyProg.exe &lt; myfile.txt The handling of ‘&lt;‘ if not managed by C, but by the shell (terminal) you use.
That would be true of a VM that allowed programs to do everything a that non-portable C programs could do. If, however, one only wants a program to do a fraction of the things that non-portable C programs could do (e.g. one doesn't want the program to do anything other than read and write files within a particular virtual disk partition) one can construct a VM which would be *incapable* of doing anything else. In many real-world situations, one would need a program that would abide two requirements: 1. When given valid input, produce valid output. 2. When given invalid data, even if it is maliciously crafted, refrain from doing anything harmful beyond producing meaningless output. Many C implementations process a dialect where marginal amount of programmer effort required to meet the second requirement (while also meeting the first) would often exceed the cost of meeting just the first. An implementation running in a suitably-designed VM, however, would reduce the amount of effort required to zero (since it would be impossible for a program to do anything beyond producing output that may or may not be meaningful).
Yes, the number is the number of chars. On the code formatting, if I type: \`\`\` this is some code \`\`\` I get: ``` This is some code ```
i see would have been helpful to have a mention of that in the book though but thank you :)
i must be stupid then because it doesn't work for me wonderful.
It's completely understandable. K&amp;R is a great book, and definitely worth a read. However, it's not as beginner friendly as you might think. A quick search on this subreddit may help you find a better book for now.
&gt; automate ruining your tests oddly appropriate typo
Copy/paste: let’s see if \`\`\`THIS\`\`\` works. In your answer. It shoulld display:
it's fine i rented it from my school library before it got out. i might as well stick with it. i'll try to use the internet to understand. i would say this subreddit too but i can't figure out the code formatting to save my life haha....
&gt; ```THIS``` ```THIS```
` ` `this` ` `
wtf it works now
Great job!
A regression test is a very specific type of test which you write when you find a bug in your code, and before you fix it. The purpose of the regression test is to reliably trigger the bug, so you'll know if you accidentally reintroduce it later. Regarding diff: it will return an exit code of 0 if the files are identical, and non-zero if they are different or an error occurred.
The curse is gone!
nope lmao it doesn't work when i try to make a post lol. might be a glitch if i need something clarified again i'll try and hopefully it works then. thank you for taking the time to answer my question it helped a lot.
How do you send formatted codes?
/r/cpp_questions might be handy too
 if(n!=1 || n!=2|| n!= 3 || n!= 4 || n!= 5) When the user enters 2, say,then the expression `n!=1` is true and the complete if statement looks like if(true || false || true || true || true) which is true. This if statement is *always* true.
All my life I‘ve thought regress test is about ensuring old application/software scenarios work same way after applied changes and now here you‘re.. Ruining everything I knew(
It's in the name... the purpose of the regression test is to tell you if you're regressing from a working state to a non-working state.
That is exactly what I said and it has very little to do with „bug test“. Bug-test means poor understanding of software requirements(TDD is here) OR test-writing practice missing in a project.
You could write a custom string parsing function that manually goes through each line. BTW your CSV file might be improperly formatted because there are different numbers of commas/columns per line (3, 2, 3, 4 commas).
Right! Thanks!!
Fixed the commas. Cheers.
Also, a quick google revealed that `strsep` is a replacement for `strtok` that recognizes blank tokens: https://linux.die.net/man/3/strsep
Well I know how to simulate random mouse movements, so there's a chance it might land a kill. Other than that, you could consider getting good at the game. I'll PM my bitcoin address.
what about you make something that’ll work and be consistent, then i’ll put $250 of btc in your address big man.
Tell you what, I'll email you an audio recording of me shouting motivational chants to inspire you to get good at the game. More consistent than any cheat, and completely, 100% guaranteed, undetectable by anti-cheats. And I'll do it for half of what you're offering.
woah dude!! that’s a genuine funny 🤩🤣🤮🥵😊🦷🦷🦷
I have no idea what you're trying to say here. The purpose of regression tests is to exercise known defects. Tests that exercise intended behavior are unit tests and integration tests.
I‘m trying to say that one better‘d not speak about things that he doesn‘t know for sure... I advice you at least look for definition of regress test then read some stuff about pyramid of tests too. Seriosly, give it a try. That may change your point of view.
Screw it I'm leaving it
Dude... I've been doing this for 20 years.
strsep
Ah okay. Thanks a lot for your answer and explanation, really in depth. Will keep this in mind.
Oh okay I see. Thanks for the suggestion, will follow this approach.
Please do not use \`\`\` to delimit code blocks. It does not work in all Reddit clients. Indent code blocks by four spaces instead. &gt; `printf("Starting program...\n");` That line does not even appear in the code you've provided, so the code you're debugging does not match the code you've shown us.
I'm a student and from what I know from lectures and stuff, you use them so no two threads enter a critical section which would make shared variables have unexpected values and stuff. Idk how helpful.it would be but I could dm you some lecture slides and stuff. It's entirely possible you have a pretty good understanding of this stuff, though.
My bad. Done and done.
The crash is because of line 29. That array is way too big for the stack
That was actually the problem. Can you give me an explanation on why it happened and how it affects the `printf` call?
&gt; That was actually the problem. Can you give me an explanation on why it happened and how it affects the printf call? `printf` needs to push a return address onto the stack. The stack pointer has been pushed out of the region allocated for the stack into memory that can't be written to.
Wow, $250! That's like... Worth two whole hours of work!
I thought the heap and stack were able to resize according to the available space. I guess I was wrong.
You'd have to get the exact instruction to know for sure, but the crash either happened when initialising a local variable - the int at line 41 say, or at the call to printf either when a parameter was pushed to the stack, or the call instruction itself which pushes the return address to the stack.
&gt; heap and stack were able to resize according to the available space They are limited by the OS and hardware.
Stacks do grow on demand, but there's a limit which is typically 8Mb. You were writing 12Mb down.
&gt; I thought the heap and stack were able to resize according to the available space. I guess I was wrong. You don't have any code to resize them.
that c++ sorry forgot to mention
&gt;i use a function called void KillerEnemy::Move That looks like a C++ class method. This subreddit exists to discuss the C programming language, please redirect your post to r/cpp_questions. As some free advice, you may want to provide more context, like what a "time step" is, how it affects moveCount, or which, if any, libraries you're using.
 char* p = malloc(100); //free(p) Any memory allocated must be freed. If you don't free it, you have leaked memory.
Thank you, but what is leaked memory?
Hope this isn't a homework question. When a program is running, it writes stuff to memory and reads it back later. After reading it back, if the data is no longer needed, the program is supposed to free that memory store so it can be used by other applications. A memory leak is when data is written to memory and never cleaned up. If there is a bug in a program it can cause memory to be "lost" and never told to be cleaned up, keeping that memory store blocked forever until the program closes, or there is literally no memory left and the operating system fails. Think of it like tables at a fast food restaurant. When the restaurant opens, you get your food and sit at a table. When you are done eating you clean up your table and leave. Some people don't clean their table before leaving. Now that table cannot be used by anyone else. A memory leak would be like a busload of people all leaving trash on the table, filling up each spot until there are no tables left and lots of people standing around holding their food.
When you dynamically allocate memory (using malloc) you are designating a chunk of memory that will stay reserved until explicitly freed. The way you work with such memory is by using pointer variables to access the data stored there. So if you dynamically allocate some memory in a local scope (like a function body) using a pointer, do whatever calculation you need, and exit the function without calling "free", then the pointer goes out of scope and gets destroyed, but the allocated memory remains without any way to access or free it. This is called "leaking memory" because that memory block becomes effectively useless.
This is not what I meant either. This sub is hopeless. By the way, C++ standard containers do take allocation and deallocation functions as optional template parameters in the form of an allocator.
Leaked memory is memory that is 1) no longer accessible, 2) hasn't been freed/deallocated. void function() { char *p = malloc(1024); return; } int main(int argc, char **argv) { function(); // memory is allocated by the malloc call, but never freed. // do a whole bunch of other stuff without being able to access the malloc'd memory above return 0; }
It's memory that your program asks for with `malloc`/`calloc`/`realloc`, but that isn't returned to the operating system when your program no longer requires it, often due to the programmer forgetting to add a call to `free`.
A memory leak is simply dynamic memory that you allocate, but then never free. A consequence of this is that your program will slowly eat up memory over time, potentially causing a crash if you completely run out of physical memory _and_ your swap gets completely eaten as well. So this is technically a memory leak: int main(void) { void *some_memory = malloc(400); // rest of program... // some_memory is never freed } But this is not: int main(void) { void *some_memory = malloc(400); // rest of program... free(some_memory); } Of course, this is a bit of a trivial example. More commonly, memory leaks occur in loops where several chunks of memory are allocated, but not all memory is freed. A common one is if you have a dynamically allocated struct containing a pointer to a dynamically allocated string - if you `free` the struct but forget to `free` the string, that's a memory leak. But note that your OS will clean up any allocated memory when your program terminates, so it won't permanently affect your memory. If you never exceed your memory limits in at any point during the program exceution, you can get away with only allocating and never deallocating. In fact, this was a strategy employed by NASA when writing the code that drove the key modules of their spacecraft - they'd use static analysis to mathematically prove that their code had a concrete upper bound on memory usage, and then they ensured that the memory they installed was sufficient to handle the code.
&gt; This is not what I meant either. It seems like it though. I just added a few points. I'd restate that the user should be able to decide whether user facing data (handles to internal state) are allocated on the stack or heap. As some data structures require internal allocation, an allocator should be provided. As for C++, the allocator spills into the container type, making that approach more or less unusable if one doesn't want to work with templated code only.
Also need to fix your `printf()` call. The spec and argument don't match. You could get closer to what you're after by including the length value in the `printf()` so you see the cost for a given distance. You can't really get cost per mile because `costofpainting()` is called with different length arguments.
Thank you for your feedback about allowing allocation and deallocation functions. Feel free to create an Issue in the GitHub repository with all the information.
Thank you for your feedback about allowing allocation and deallocation functions. Feel free to create an Issue in the GitHub repository with all the information.
What do you suggest instead?
Thanks.
hey quit cheatin yer ruinin the game for the rest of us gamerz ban pls
You can't correctly parse a CSV file with strtok because it won't deal correctly with quoted fields (which can contain commas).
If you think you gave memory back to the OS, but you actually didn't, it's a leak. &amp;#x200B; If you built a struct with pointers in it: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct node { void *nd_ptr; }; int main() { struct node *p; void *ptr; p = malloc(sizeof(struct node)); p-&gt;nd_ptr = malloc(32); snprintf(p-&gt;nd_ptr, 32, "This is a test\n"); ptr = p-&gt;nd_ptr; free(p); // the memory is still there, but without ptr, I wouldn't find it printf("%s", (char *) ptr); return 0; } If I wouldn't use \*ptr to save it's address, the memory would still be allocated, but I wouldn't find it again, so it's a leak :) &amp;#x200B; Output: This is a test
Is that Let US C by Yashwant Kanetkar? If so, please for the love of God, avoid that book like the plague. It promotes terrible ideas and is wrong in way too many places.
Just want to say if you do gdb -q to put in quiet mode it won't print that little copyright thing.
-fsanitize=address would tell you
If your code is GPL and if you don't mind fiddling around a little with autotools, gnulib is an absolute beast of a compatibility library. It let's you write code as if you're on a Unix system and then at compile time switches it for native libc calls completely transparently.
What does the code for storing the int into the node look like?
This is the best answer I've found. Nice
 new_list -&gt; content = malloc(sizeof(content)); if (new_list -&gt; content == NULL) return (NULL); memcpy(new_list -&gt; content, content, content_size); new_list -&gt; next = NULL; If you'd like more, let me know. I'm sorry for not posting everything, but I have everything seperated into a LOT of functions, and it would be a lot of redundant code if I tried throwing it all up here.
What type is `content`?
Oh yes I need it to print a float not an int. But isn't it called with same length arguments? I am passing in x miles and want to break it down by cost per mile, which is what retval is supposed to represent.
If ints are 32 bits, 4 bytes, the array would only be 12000000 bytes, or roughly 12 megabytes. Is this really too big for the stack on modern hardware?
Oh yes retval is an int and I need a double.
content is a void *, a pointer to anything. content_size is the size of what that thing is, so that I can malloc accordingly. You are also correct, but thankfully it works both ways, my way just looks silly. I managed to get this working btw. I did something like this. int *temp = head-&gt;content; int tmp = *temp;
`int temp = *(head-&gt;content);`
It works both ways if you're storing integers, but it doesn't work if the number of bytes of content is greater than the size of a pointer (4-8 bytes).
&gt; Is this really too big for the stack on modern hardware? Not at all. The OP's issue has nothing to do with their hardware. The default stack size for Linux is typically 8 MiB. You can make it bigger if necessary... but obviously fixing the program so it doesn't store that much on the data would be a better approach.
&gt; -fsanitize=address would tell you Sure, but I was really wondering if GDB, given an arbitrary program, could tell you what kind of machine fault generated the SIGSEGV signal. I don't think it can, since as far as I know the `siginfo_t` structure doesn't even contain that information.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Fuck off, cheater.
That usually means you are missing a curly brace. Make sure you closed them all.
Your first if has `;` behind it. This is interpreted as an if followed by a single empty statement.
You have a semicolon after your if statement. Probably what the problem is.
Make sure you enable all warnings in your compiler. My compiler emits: warning: this ‘if’ clause does not guard... note: ...this statement, but the latter is misleadingly indented as if it were guarded by the ‘if’ pointing at the `if` line and the immediately following `else`. This assistance would also have helped you find the problem.
Interesting NASA tidbit!
Yes, limited by the OS ad hardware, in that order. The OS can set a lower limit than the hardware can handle, as we see here.
No, it isn't. It talks about reading and writing, which have nothing to do with memory leaks. Programs can (and often do) leak memory that they've never read from or written to. Memory leaks when and only when you allocate a chunk of memory that you don't need, or fail to release a chunk of memory that you allocated after you no longer need it. If your program is short-lived or doesn't allocate much to begin with, it's no big deal. The operating system will reclaim everything when the program terminates. But if the program runs for a long time and / or allocates large amounts of memory, it can run out of address space or even RAM and crash.
If the stack is being limited, can't you just `malloc()` the space needed instead?
You want to know how to read in a seat from the user?
please pastebin what you have so far.
When you are confused about something that doesn't compile, you should look closely at the error message as it will tell you what the issue is. And if you don't understand what it's telling you, include the compiler error in your question.
The storage for `incoming` is local to `communicateWithServer`. Once the function returns the storage is freed and can be overwritten from the call to `printf`. There are multiple ways to deal with buffers in C. Simplest way is to pass the buffer and size in. const char *communicateWithServer(char *message, char *incoming, size_t buffer_size){ //Send and receive logic return incoming; } char incoming[BUFFER_LENGTH]; communicateWithServer(message, incoming, BUFFER_LENGTH);
This code doesn't compile. What is your actual code?
&gt; To a call to lua_newstate() with the function pointer to your allocator. You'll need to supply a prototype or include a header or whatever. The luaL_ prefix means it's part of the "auxiliary" library, and this function will provide lua_newstate() with an allocator that uses malloc(), etc. Hi, I'm not entirely sure? I got lua hosted... no problem. But I'm linking to lua compiled as a library. The line 608 is within "main". int main (int argc, char **argv) { int status, result; lua_State *L = luaL_newstate(); /* create state */ ... return (result &amp;&amp; status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE; } I don't get it though. I have my own main. Surely libraries don't have a main function? Oh wait, is lua.c the actual command-line interpreter? I don't need to alter that :) I can test lua as being hosted from within my own app!
You can't declare or define an array of an incomplete type. You can however declare or define a pointer to an incomplete type. To use the second form, you need to have the full definition of `struct bar` in scope.
&gt;I tried googling for 1-2 hours now, and I believe my code is the same as here: [https://stackoverflow.com/questions/1496313/returning-c-string-from-a-function](https://stackoverflow.com/questions/1496313/returning-c-string-from-a-function) but it just doesn't work and I have no idea why. If you read the accepted answer for that question it explains the exact problem, under "Longevity Of Data". You wrote code equivalent to their example: const char * myFunction(const char* name) { char szBuffer[255]; snprintf(szBuffer, sizeof(szBuffer), "Hi %s", name); return szBuffer; } &gt;...your program will crash because the compiler (may/may not) have released the memory used by szBuffer by the time the printf() in main() is called. (Your compiler should also warn you of such problems beforehand). &gt;There are two ways to return strings that won't barf so readily. &gt;1. returning buffers (static or dynamically allocated) that live for a while. In C++ use 'helper classes' (eg. std::string) to handle the longevity of data (which requires changing the function's return value), or &gt;2. pass a buffer to the function that gets filled in with information.
So the answers in the FAQ are wrong? And why does C++ think it is ok?
&gt; The reply I receive is correct, as I have tested it before. Returning a locally defined variable like that is undefined behaviour, which means sometimes it might work, sometimes it might not. Just because it worked for you when you tested it doesn't mean it'll always do the right thing. As others have said you either need to use some storage that will persist after the function has been called e.g. something created with `malloc`, or pass in the buffer and size and write to that in the function.
The answers in the FAQ are wrong? &amp;#x200B; and why does C++ think it is ok?
You're getting the current values because `retval` is an `int`, so the calculations are being truncated to integers. And note that `retval` is the total cost of the length given, which is not necessarily one mile. So when `length &lt;= 3`, the cost per mile is $160.50. What is it when `length &gt; 3`? You need to calculate it in that case.
Thank you, this fixed my issue.
The answers in the FAQ are not wrong. You changed the example from an built in type to a user defined type which adds an extra detail that you are stumbling on. As the error states, you have an `incomplete type`. What this means is your code says there's a struct called bar but you have not provided it's definition: struct bar { .. }
What do you expect 'ls' to do with STDIN? AFAIK it doesn't have any need for STDIN.
which is exactly the problem I had, thank you for pointing that out
Yeah, I guess `va_start` is guaranteed to be a macro, so this particular case could be handled using that. I'm not sure if all cases where some headers would need types defined in standard headers could be resolved that way, though.
&gt; Oh wait, is lua.c the actual command-line interpreter? I don't need to alter that :) I can test lua as being hosted from within my own app! Yup, I was only suggesting using that instead of writing your of main().
Thanks for detailed explanation. I just don't understand that why C++ accepts it but C doesn't.
[read](https://pubs.opengroup.org/onlinepubs/009695399/functions/strcmp.html)
Thx
The most common cases are `&lt;stdarg.h&gt;`, which we've already covered, and `&lt;stdio.h&gt;`, which (amongst many other macros) defines `stdin`.
&gt; The answers in the FAQ are wrong? No, the answers in the FAQ are not wrong. You can use `foo *bar` and `foo bar[]` interchangeably in a function prototype. The FAQ just omits the additional detail that in the latter case, `foo` must be a complete type, because it wasn't part of the question, and because the examples use scalar types, which are always complete. &gt; and why does C++ think it is ok? I don't know that it does, but that's irrelevant since C++ is a different language. Once more for the people in the back: **C and C++ are different languages.**
"true" in C is any value that is **not** 0. strcmp returns the difference between the two strings (more precisely defined in the manual). 0 means no difference -&gt; the strings are identical.
Writing `if (!strcmp())` is bad form. It's *correct*, but unnecessarily confusing, especially if you're used to languages or constructs in which an equals-comparison returns a true/false Boolean value. It's much better to write `if (strcmp() == 0)`, and keep in mind that you can also use `&lt;`, `&gt;`, `&lt;=`, and `&gt;=` in the comparison. If you *really* feel the need to write `if (!strcmp())`, then write `if (streq())` or `if (strequals())` instead and define `streq` as a macro or inline function: #define streq(a,b) (strcmp(a,b) == 0) static inline bool streq(const char *a, const char *b) { return (strcmp(a, b) == 0); }
I think I am starting to see, but using my original post as the example, why am I printing: 192 1222 481
facts thank you
cool. Didn't really answer my question but thanks I guess.
http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2346.pdf https://gustedt.wordpress.com/2018/11/12/c2x/
Bookmarked! I haven't seen a paper on "Remove K&amp;R function declarations and definitions" -- did I miss that? This is a change I've wanted to see for a while.
thanks.
What would the practical results of that be? Compilers will still support it for legacy code.
Ya, sorry, I was assuming you already knew the answer from the other replies, and was giving a reason why it shouldn't be written the way it was in the example, and how it could be improved. :)
I'll include it later in my code
I'd have no objection to making them optional, along with many other things. At present, the One Program Rule exempts implementations from any requirement to support any constructs in *useful* fashion. IMHO, it would be more helpful to recognize a category of implementations that isn't required to usefully process most C programs, but would be required to: 1. Document a set of environmental requirements, and means via which the implementation would indicate an inability to process a program according to the Standard. 2. Guarantee that if the environmental requirements are satisfied, the implementation will behave consistent with the Standard unless or until it indicates a refusal to do so by the above means. An implementation could be suitable for many purposes without bitfields, 64-bit types, recursion, or floating-point math. While it's certainly reasonable to have a Standard indicate that such things should be provided when practical, there's no reason not to specify the behavior of programs that don't need such features, running on platforms that can't practically provide them. An implementation that supported none of those features, but could guarantee that no program which builds successfully would ever have a stack overflow would be for many purposes superior to one that supports all of those features but offers no such guarantee.
Yeah, most compilers will probably have a switch to allow the old style as an extension. I don't have a problem with that, as long as I can disable it (using `-Wpedantic` or whatever). Even legacy code can benefit from the slight modifications to bring it "up to date." K&amp;R-style has been deprecated for 30 years! If we can't remove it now, we might as well make them an official, alternate form of declarations.
removing K&amp;R function declaration and definition means putting the type of a parameter / return value after the name like in languages like OCaml, F#, go etc. ?
 [https://pastebin.com/gkmHYAQr](https://pastebin.com/gkmHYAQr)
No. You're probably used to function definitions that look like this: int foo(char* a, double d) { return 42; } Nothing about this would change. K&amp;R style is how C originally used function parameters: int foo(a, d) char* a; double d; { return 42; } This older style is almost completely obsolete, and the standard has warned that it will be removed in a future version. 30 years later ... it's still there. A bigger problem are empty parameter lists (which is very closely related). In other words, given a function declared as: int bar(); This doesn't mean that the function takes no parameters (`int bar(void);`), but rather that it takes an unspecified number of parameters. So you can call it with `bar(10);` or `bar("Hello, world!");` or `bar(1, 2, 3, 4, 5);` -- the compiler usually won't complain, even if this mismatches the actual function definition. Worse, the parameters undergo the default argument promotions, with surprising results. And if you get this wrong, that's undefined behavior.
Sorry it was a little wordy but yeah that was one of them and replacing that specific seating with an 'X'
Look up the scanf and write a small program to prove you know how to use it. Right now you probably have a double for loop without an array, right? Now you need to keep state, so you need a 2d array of chars all initialized to zero. If someone types in A3, you will need to translate that into an X value and a Y value, then set seats[x][y]=1 Then in your inner loop, you need an If statement If(seats[x][y]) printf ("x"); else //whatever you did before
Answered like a true C programmer!
The `strchr()` function in the standard library has the same problem. It just casts the `const` away and it's up to the caller to be careful.
Your function is fine as is. Its API contract with the user is that it takes a readonly structure and returns a readonly pointer. That's all the function needs to know and is responsible for. The principle of least necessary power says that the function needs no more than these capabilities to do its job, therefore it should assume no more capabilities than necessary. The API consumer, however, is in charge of the *context*. If the contest requires it, they can choose to treat the readonly pointer as read-write by casting away `const`. That's the consumer's prerogative because they're supposed to know at some higher level about what semantics are in play when it comes to using the list. They're in the position to break the rules, but the lowlevel function should abide by them.
That makes sense, thanks. Originally I was thinking of casting away const as poor practice, but I guess it's more of a "Trust me, I know what I'm doing" thing?
Essentially yes. In my view, the low level functions should stick to the bare mimimum of assumptions needed to do the work (like const correctness: a pointer is only writable when it *needs* to be to do the function's job), but higher levels of abstraction gradually have more room to define their own set of rules about how and when to access "their" data. To put it tritely, with great power comes great responsibility. The corollary is that functions at the bottom of the stack should assume no power, since they carry no responsibility.
This function doesn’t need ‘const’. Even if ‘node’ were const, node-&gt;next isn’t.
&gt; An implementation that supported none of those features, but could guarantee that no program which builds successfully would ever have a stack overflow would be for many purposes superior to one that supports all of those features but offers no such guarantee. The dream.
It’s not entirely possible atm, because C99 introduced some parameter array gunk for which some parameter orderings requires K&amp;R definitions at the very least. E.g., void foo(array, size) size_t size; int array[static size]; {…} If they loosen the rules on parameter ordering (i.e., the following beomes possible: void foo(int array[static size], size_t size); ) then they can safely deprecate K&amp;R decls/defs. —Not that all that many people are using the C99 parameter array size gunk, but it wouldn’t be C without unsettling corner cases.
A `SA_SIGINFO` signal handler’s third argument (`void *extra` to a `ucontext_t`) has basically all the information the kernel could collect about the fault, including the CPU trap number: #undef _GNU_SOURCE #define _GNU_SOURCE 1 #include &lt;ucontext.h&gt; #include &lt;signal.h&gt; void signal_handler(int signo, siginfo_t *siginfo, void *extra) { const ucontext_t *const uc = extra; const greg_t trapno = uc-&gt;uc_mcontext.gregs[REG_TRAPNO]; … }
Some real-world compilers I've used achieve that (though they included 32-bit floating-point support and bitfields, I've never made use of such support).
Ah, I wasn't aware of that. I wonder if GDB can show that when processing the signal being delivered to its tracee.
Note: 1. There are a lot of things I haven't done yet (PIPE support, shell terminator, more commands, running external .exe file and so much more) 2. If you are interested in joining, or purely reviewing the code, please let me know :)
I am a visual type of learner and because of that, I first started on building a correct mindset on programming. So, when I first started programming (it was C++), I thought of programming like an electric circuit, to which I think of it like a waterfall. In C, the "battery" of my code would be "int main(){}" and the "return EXIT\_SUCCESS;" is the ground. Another one is a schematic (forgot the name of it since I no longer use it): int main---int x=0----while(x!=5)----------------------------------------------------------------DONE! | x=x+1 | if(x==5)-----------if(x==6) | | printf("%d\\n",x) printf("how the hell did you get here\\n") &amp;#x200B; The current way I do is to imagine how my code or parts of it should behave, then translate it down in a pseudocode format on a text editor without paying much attention to syntax, because that is something I'll do later. Finally when you're done, transcript it on Visual Studio. Has you practice more, you won't need the Visual Studio much and you could directly compile the text file directly on the terminal.
Different languages behave differently.
Content is a void *.
https://lmddgtfy.net/?q=strcmp
Cast it and you'll be good: `int temp = *((int*)(head-&gt;content));`. I wanted to demonstrate how to dereference a structure member and casting makes the example code hard to read.
You can also dynamically allocate your string and return that. Just free it after you are done with it.
Why? Because I can only guarantee a "shallow const-ness", so it isn't worth it?
&gt; Why would the interviewer have to learn everything on the CV? It's not a quiz show or a police interrogation. I was just trying to crack a joke at my own expense because I was a little embarrassed. Just ignore it. &gt; But I'd be highly skeptical of an applicant who only listed one or two languages. Maybe somewhere in between would be the best way to go. List what you want, but put a special emphasis on what is asked for.
I got some early success! lua has a lot of overhead due to how it allocates memory and error-checking, handling out-of-memory etc... But I'm getting some nice numbers out? Using your maze kruskal.lua app. jb: 0.246145s basic: 0.292740s jb: 0.202321s basic: 0.262085s jb: 0.211053s basic: 0.261794s So about 30% faster operation? I did however modify your code ;) i commented out "render()" and doubled the width+height to give it more work to do. Otherwise the speed difference was almost nothing. Not bad? I'd say its a good early success??
Nope, C++ is unnecessary difficult and not safe in many senses. Learn Rust or Go. These are the languages of the future. Or continue with C. You never can code C well enough
You're doing something horribly wrong. You've declared newCar on the stack, but it has a flexarray at the end, so the passengers array inside it will be zero-length (the allocation will stop after the "name" field). Then you're passing a pointer to that to createCar and that is setting fields in the passengers array (which doesn't actually exist). At that point you're writing past the end of newCar, and scribbling over other stuff on the stack.
hah that sounds about right. &amp;#x200B; So with the malloc you wrote, why is it +3? Is that for the passengers array? What happens if you have more than one flexarray in the struct?
strcmp will also consider one string to be of a lesser value than another. This is useful for sorting string values as well.
Correct; that's for the passengers array. The C standard doesn't allow more than one flexarray in a struct and it must come at the end. I suspect that if you try to define a struct with more than one it will fail to compile.
In a linked list situation, 'const' assures the caller that you won't modify what's pointed to by the argument they pass in, but the 'const' doesn't propagate down. For example, it says nothing about node-&gt;next or node-&gt;next-&gt;next, and in this case, adding 'const' is causing problems and making your code more difficult to follow. It's a hint to the compiler that really doesn't add value in this case.
Ah okay that's interesting. Thanks for all the help, I guess I should really read over my book again lol. &amp;#x200B; As a side note, I ran this code through valgrind and it only complained about my lack of a free. Is there any easy way to detect/catch yourself doing this type of horrible stuff? Or is it just a case of "don't be bad"?
Try changing 3 too 100 in the for-loop that writes to the array, and see what happens.
Is there a way to have a function pointer to a _Generic ?
That's why I'm curious about the current proposal. I'm curious if they're addressing these issues and how.
No. `_Generic` is *not* a function, it's a macro. All occurences of `_Generic` are resolved at *compile time*.
You have the wrong subreddit. This is for C programming... for C# you might want to check /r/dotnet
Ahh, sorry!
I disagree, if you typedef your function pointer it is a valid type that can be evaluated at compile time For example: `#include &lt;stdio.h&gt;` &amp;#x200B; `typedef void(*functionPointer)(void*);` &amp;#x200B; `void printfuncptr(void *ptr)` `{` `printf("address of function pointer:%x\n", ptr);` `}` &amp;#x200B; `void printint(int a)` `{` `printf("int's value:%d\n", a);` `}` &amp;#x200B; `#define test(X) _Generic((X),\` `int: printint,\` `functionPointer: printfuncptr)(X)` &amp;#x200B; `int main(void)` `{` `functionPointer asd = printfuncptr;` `test(1);` `test(asd);` `printf("address of printfuncptr:%x\n", printfuncptr);` &amp;#x200B; `return 0;` `}` Will work fine and print the address of printfuncptr
We seem to be answering different questions here. Sure, you can use function pointers as parameters to `_Generic`, however I read the question as if the goal was to have a pointer to something defined using `_Generic`, like `test` in your example.
Just be careful passing things like: `i++` because the increment operator will be evaluated several times as it is passed through the macros.
I was editing my answer when the notification popped up, you are totally right, I made my edit reflect it before anything else. tbh I just used to lurk around reddit, didn't really posted so this is out of this world for me rn(all the editing for eg) just thought someone might find this technique interesting as I didn't really stumpeld upon anything like this here or elsewhere
i++ is passed to a function, my quick(and maybe inaccurate) test's showed that it shouldn't expand to multiples of this operations/shouldn't affect it if it does(pass by value test), also tried pointers meanwhile and you will have to typedef your pointers(at least on GCC) because it was failing for me with int\* as the type I tested with the previous (out of context) function, calling it like int a = 1; test(++a); output was 2, with a++ it prints 1 but a will equal to 2
&gt; Without that, the speed difference was almost nothing. Yeah, the render function is just a bunch of IO calls without allocation so that makes sense. &gt; Not bad? I'd say its a good early success?? It's certainly a good start. However, I wonder if your gains are at least in part due to operating under relaxed constraints. The `malloc()` you're competing against is almost certainly designed for use in a multi-threaded process, so it has to enter and exit a critical section during its operation even though it's all single-threaded. With glibc I believe this is implemented using a futex, which is really cheap in the absence of contention, but it's still not free: atomic operations using locked instructions (on x86). Another allocator to benchmark against is [jemalloc](http://jemalloc.net/). &gt; I'm happy to provide my work so you can test it yourself? Sure, I'll take a look.
Indeed, and that is how it should work. However, in your original code, `magic` is not a function - it is a macro. Macros are not functions and they have unique behaviors that you need to be aware of before you use them.
You have a gain posted something that is not about programming in C. If you post off topic content again, I'm going to ban you.
C# is off topic in this subreddit. Please post C# questions to /r/learn_csharp instead.
I don't really need it, just a random question. But let's say you have a function pointer like void(*func)(int arg) and you would want to assign it to some printInt function. It obviously is compile-time possible, C just doesn't support it :/
tbh I still don't get what would that accomplish. Could you elaborate please? Is there something specific that it would do? for eg:'I want polymorphism' or 'virtual functions'. What really is interesting is that you said it is compile time possible, so what would you want? return the address of the called function by a \_Generic macro?
&gt; It's certainly a good start. However, I wonder if your gains are at least in part due to operating under relaxed constraints. The malloc() you're competing against is almost certainly designed for use in a multi-threaded process, so it has to enter and exit a critical section during its operation even though it's all single-threaded Good points. I see LuaJit uses dlmalloc internally, single-threaded. So it might be a better comparison? Also the "unfairness in the tests" works both ways. My system is designed to allocate objects of classes, where we pass some kind of "class*" to allocate an instance of. That's how I'm using it for my own projects. This saves memory and gives us useful (cheap) introspection on the object type. Trying to wrap that into something like realloc loses us a lot of speed. To fit jb_alloc to Lua's memory-model, I made it so "all objects of size-N are the same class". Considering this makes my code 3x slower, its impressive I'm still seeing useful gains! What platform do you code for? I'm working on OS X. I assume it won't work for other platforms without some minor changes... I can make those changes if I know your platform :)
Debian 9 "Stretch" (Linux)
Understand that malloc can return NULL and that int is not always 4 bytes. Then, get your hands on some real embedded hardware and learn how programing patterns adapt to such systems.
If you mean hardware embedding, then first get a microcontroller and a programmer (a device for writing compiled binary into microcontroller EEPROM). Second: a good literature. For beginners, I recommend Arduino boards, which are very simple and use C++ with heavy macros and libraries. Then switch to "bare" ATmega (without Arduino runtime and bootloader) and pure C. After that... STM32 maybe? Very interesting topic, but also quite low level. You work on registers, there's lots of bit twiddling and very limited resources. Immensely fun.
`_Generic` is not a macro. It has to be evaluated after the preprocessor is finished running as it works on the type of its expression.
Is this a problem? Do people accidentally cast things that aren't sockaddr pointers? This is interesting, not completely useless, but I don't see the point of it.
Once you've received SIGCHLD call waitpid with WNOHANG and pid -1 in a loop. It will return one pid at a time for a child that exited. If you have many children you have to use WNOHANG since you might only receive a single SIGCHLD even though multiple children have exited.
You should probably flush your buffers before calling fork.
tried to add: fflush(stdin); fflush(stdout); fflush(stderr); before calling fork() and I'm still seeing the problem
Since some functions specifically require a struct\_sockaddr pointer, I think this is just clarifying the cast from various different struct pointers. Not sure though. Personally, I used sockaddr\_storage a lot, but casting it to different pointers to use in and in6 variant. Therefore I think that this macro itself is not that useful, but it can be used as a base for writing more specific casting macros (or better: inline functions).
Arduino.
To go further, dynamic allocation is usually discouraged in embedded systems. So you probably won't find much malloc anyways.
I wanted a generic Linux `system_call` function that could take a system call number and 0 up to 6 arguments. So I wrote a `system_call(long n, ...)` prototype and the implementation follows the architecture's `varargs` ABI for up to 6 arguments.
Take a look at the MSP 430 launch pad(g2 series is a great start). Good starter and hw debugging making life nice and easy. Can use c/c++. Has plenty of example code, both for c and ASM.
No. Well, not in my opinion anyway. Great for projects where you have a simple real world to microcontroller input or output but it purposefully obscures how the microcontroller actually works in order to keep it as simple as possible. Get a decent PIC, maybe its demo board so you have a kind of easy to follow and implement lesson plan and of course a pickit to program it all. You'll be presented with a format thats more structured and super detailed manuals that explain exactly how each register works which will teach you more about how embedded c works in most scenarios. To setup SPI on a PIC you have to setup the appropriate registers, maybe setup the interrupts and read up on how to handle any buffer registers and then workout the logic to pass data in or out of the microcontroller, that will teach you way more about how embedded systems work. For Arduino you can just type #include SPI.h and pass it the pins you want to use and then import someone elses library on the part youre trying to interface with and use their worked examples to get you up and running asap.
Actually it's a primary expression. However it is rarely used outside of macros.
This musl macro would've saved my life on the appropriate function calling convention, as this backward thinking as seen in \_\_SYSCALL\_NARGS was what took me about an hour to get and approach correctly. And seeing the post about trying functions named from 1 to N having to push N values to all of them is a real problem here too(see void \*dumpData), so in the kernel's optimization context if I took it correctly this is a no-go, but for my use case(game engine ***tooling*** development) which is horribly error prone on the arguments due to the changeable nature of the architecture and it doesn't require the deepest of optimizations, it works for me. Just thought someone could find it useful too. btw have you worked on the kernel? (didn't bothered to check I should be sleeping) Or lurked around like this? I am craving for these techniques as I implemented my own namespacing(apart from minimal memory overhead, it is virtually none, on higher optimization levels it's literally zero) my own smart pointers(aka allocations that free themself after going out of scope) and I just really want to gather everything that can boost my productivity, maybe even wrap them up after shipping in a nice Open-source package
But you can also do that with an Arduino. I have been using one with Atmel Studio to learn embedded C by programming the MCU via registers. It's great fun actually.
Arduino is not hardware, its software though and though from boot loader to IDE. Recommend Atmel Studio if you're going to recommend it, you'd recommend it for precisely the same reasons I'd recommend a PIC and MPLAB.
&gt; btw have you worked on the kernel? No. I've read a lot about the Linux kernel and read a lot of source code but never worked on any patches. &gt; I am craving for these techniques The kernel contains lots of really good C code. Look at [`nolibc`][nolibc], for example. It lets you write code with just the Linux kernel as a dependency. While I worried about function ABIs, the kernel hackers sidestepped the entire problem by using a [compound statement] instead. [nolibc]: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/include/nolibc/nolibc.h [compound statement]: https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html
right off, for array_append it allocates one fewer element than is needed
Oh my god all those ***asm volatile*** statements with architecture(not OS!) specific inline assembly. I am so greatfull for [`yeslibc`](https://www.gnu.org/software/libc/) and that I can write my code and cry about OS differences while these kernel devs cry(or enjoy) about hardware and their architectures. Getting into these make you appreciate C as cross-platform assembly language so much, but for my work I would rather try to optimize my memory access patterns, my SSE(and the likes) intrinsic code first and maybe, ***Maybe*** after that take on the burden and technical dept of writing inline assembly(happened with specific hot spots, here's hoping x86 and ARM are enough for my requirements and will work across different silicons too)
It's not a big deal. The inline assembly code just puts things in specific registers and executes a system call instruction to switch to kernel mode so that Linux can perform the system call. All C libraries contain the exact same code. I think most of the problems with C actually come down to its historical baggage so I adopted freestanding C and wrote my own Linux system call library instead. In my opinion, Linux programs should be written to take advantage of as many Linux features as possible instead of being limited by what's available in the C library or POSIX standard.
On some platforms, it can be useful to have a "function of unknown arguments" type for use when calling code written in other languages. It is also useful to have a type of "pointer to function of unknown type". A pointer to a function with unspecified argument list would seem more appropriate than a pointer to a function with a phony or explicitly-empty argument list. While it would be reasonable to treat the ability to pass arguments to a function which was declared using \`()\` syntax as an optional feature, I see no reason to prohibit it on a platform where it might be useful for whatever reason.
Firstly, the function `array_append` is problematic, and it is probably causing some of your memory problems. char** array_append(char** a, char* s, int len) { char **p = malloc(sizeof(char*) * (len)); memmove(p, a, sizeof(char*) * len); p[len] = s; return p; } In this function, you first create a copy of `a` (lines 1 and 2 of the body), then you write the new item *past its end* (line 3), and then you return the copied array. This function is called in `str_split`: ret = array_append(ret, ns, len); This line allocates a new array, appends the item, and then replaces the old array reference with the new one *without freeing the old array*. What you should do instead is use `realloc` to resize the array, which avoids the need to copy the contents yourself, and frees the old array if the new array was successfully allocated: char** array_append(char** a, char* s, int len) { char **p = realloc(a, sizeof(char*) * (len + 1)); if (!p) { /* Memory allocation failed, but a is still valid */ return NULL; } p[len] = s; return p; } The same thing applies to your `append` and `append_word` functions.
no dats an old language itz not wats in fashion nowadays n i wanna look sexy for da employas
Then I think python is better for you.
As many others have said before, dynamically allocating memory with functions such as malloc(), calloc(), and realloc(), but not using free(), will cause a memory leak. One thing I’d like to add to this is a little more of why it happens. When you dynamically allocate memory, it’s stored on the heap rather than the stack. When a function returns, values on the stack memory are reclaimed. However, the heap memory doesn’t get reclaimed. With that said, the used memory in the heap just takes up space indefinitely. It’s comparable to using fork() to make a process but not using wait() on the child process, which effectively creates a “zombie process” which just takes up space in memory after it has concluded because it’s not being reaped by the OS. That’s a memory leak and why it’s important to free() dynamically allocated memory when you don’t need it anymore. Unfortunately for C, there isn’t an automatic garbage collector like Java that reclaims unused memory. But I find beauty in that.
I’m not seeing any direct means of getting that information, although I suppose it could (under duress, and with an obscene amount of effort) delicately walk the process through receiving the signal and get the `trapno` field that way. The interface GDB uses is based on the `user_regs_struct` defined in `&lt;sys/user.h&gt;`, which doesn’t have the same format as `mcontext_t` in `&lt;ucontext.h&gt;` (because of course) so there’s no field corresponding to `REG_TRAPNO`.
Definitely STM32 board
r/embedded
If you’re actually catching the `SIGC`[`H`]`LD`, then register your handler with [`sigaction`](https://linux.die.net/man/2/sigaction) using flag `SA_SIGINFO`, and the `siginfo_t` should contain the PID that caused the signal (qua `si_pid`). Using `wait` or `waitpid` is still necessary to reap zombies, but you can at least get the PID etc. before doing that. [Here’s an example of a basic `SIGCHLD` reaper.](http://www.microhowto.info/howto/reap_zombie_processes_using_a_sigchld_handler.html)
Cool response. Can you tell me the difference of heap vs stack. Also can you tell me what you mean by "When a function returns, values on the stack memory are reclaimed. However, the heap memory doesn't get reclaimed?"
Dynamic memory management is the embedded world's big elephant in the room: everyone knows they shouldn't use, they know why, but they still use it. Kinda like Javascript.
If you’re working on a config parser because it’s an interesting exercise to learn C, then that’s a great idea. It will teach you file handling, memory management and a little bit of data structures. Cool! If you’re working on a config parser “because it will be useful for other programs”, then you’re wasting your time. Here’s a whole bunch of different config file parses which you can find with 5 mins of googling: - https://github.com/compuphase/minIni - https://michaeldipperstein.github.io/ezini.html - https://github.com/hyperrealm/libconfig - https://github.com/martinh/libconfuse - https://github.com/rxi/ini In this case, you really need to ask yourself: Why do we need another config file library? How does this work compare to all the other config file parsers out there?
Had a quick look over your client code. It looks ok. Nothing you need to change to work on a “public IP”. The only thing I’d warn you about is firewalls can get in the way if you use “exotic” port numbers.
I gave my friend my client code while I acted as server, and connected via his public IP, but I was unable to. It was bind() that failed. I’m out now, but I’ll go back to my computer and try again and report the exact error.
The basic difference between a stack and a heap are that the stack is used for static memory allocation such as local variables and the heap is used for dynamic memory allocation, which is meant to outlive a procedure’s lifetime. When you call a function in C, a new stack frame is created to hold the variables local to that function and then there’s a link to the parent function that called it. After the function concludes and returns to it’s parent function, the memory in the stack frame is reaped, but memory allocated to the heap is not since it stores stuff unrelated to the lifetime of the procedure. C doesn’t have built-in techniques for managing the heap so we have to do it explicitly. Aside: As far as explicitly managing memory, it seems somewhat stone-age compared to garbage collection in Java and Python. However, it has some edges over automated garbage collecting. Having a garbage collector can bring unpredictable delays since the program will need to pause at certain moments to check for garbage.
Okay, what would the bind() call look like to listen on any?
https://stackoverflow.com/questions/16508685/understanding-inaddr-any-for-socket-programming
Change line 33 to sockStruct -&gt; sin_addr.s_addr = INADDR_ANY;
Thanks a ton!
Thank you! Hopefully this will solve my issue
I changed line 33 to this, but after running my client on my server at home and attempting to connect with the server running on my laptop, I don't get the bind() error anymore, instead I get an error when running connect(). I used port 8080 to test, would the firewall be the problem here?
Sorry, but: &gt; running my client on my server and &gt; the server running on my laptop At the risk of pointing at the obvious, is there a reason you're not running the server on your server? Does your laptop have a publicly addressable IP? The most likely scenario here is that at least one of your devices is behind a NAT.
They’re both behind NAT. I’m just not the best at networking sorry, I suppose that’d mean that I’d have to do some pier forwarding and whatnot right?
Yeah add one more port forward for the server you're testing.
Okay, I’ll set the server side up on my server (lol) and set 8080 as the default, and remove the option for a manual port set client side.
There’s a few shell commands I’ve played around with in writing. For example, I’ve re-written “ls”, “rm”, “rm -rf”, “mkdir” (essentially just having a c program call mkdir), “rmdir”, and “cat”. There may have been more, but I know off the top of my head that I’ve done those. Ironically, I’ve come across writing those just for the sake of some of the C projects I’ve written more recently. A lot of them are simple! As far as writing a C program that runs another program, all you would have to do is fork() to create a child process, set up an if statement to check to see if the process is the child or not, then if it is just run execv() to wipe the current execution context and reallocate the process with the new executable instructions. Just some food for thought!
I think there's a proposal for a function pointer type that's exactly for this purpose, instead of inappropriately re-purposing empty parameter lists. Basically a function version of `void*`. Empty parameter lists aren't really meant to be used as a generic function pointer -- it's tempting, because they're already generic to a point. But that empty parameter list doesn't just mean "unknown arguments." The default promotions are a "gotcha," and I've seen more than one bug in legacy code come up from this (and none were easy to find). The only that that empty parameter lists do is a tiny bit of (misleading) self-documentation that the arguments are unknown ... assuming the reader even knows about this "feature" (which, in my experience, few do). I don't mind giving that up, even if the replacement doesn't pan out. Besides, I would expect that they'd go the C++ route and make `void (*)()` be a synonym for `void (*)(void)`, so it wouldn't break any code using it as a generic function pointer anyway (except for code that's likely already broken). &gt; On some platforms, it can be useful to have a "function of unknown arguments" type for use when calling code written in other languages. I haven't encountered this, but it seems strange to me. Every time I've interfaced with other languages (C++, Java, Fortran, Ada, Perl, Python, Matlab) the function types must be clearly defined, sometimes from a specific set that are known or otherwise special. But always clearly defined. I can't think of any other language which has the default argument promotions (a historical relic in C), nor would I want that. Can you be more specific with this?
In this type of job you would be required to know, * Memory management: I suggest you find out how explicit free lists are created and managed by malloc(), realloc() and free(). Understand the concept of splinters, internal fragmentation, buddy allocation system, and reference counting. Understand the difference between static and dynamic allocation as well as the memory hierarchy structure. You may also need to understand the fecth, decode, execute cycle (instruction cycle) on a processor so you can understand the concept of a "cold cache" and how much it costs the CPU to fetch memory address that aren't contiguous such as nodes from a linked list vs a dynamic array. * Linux system calls: You must have an understanding of Linux system calls such as open(), write(), read(), pipe(), fork(), execve(), wait(), close(), dup(), dup2(), how file descriptors are managed by your application, and how signal processing works. As well as understanding errno codes and how to set them in your functions when you want to signify that an error occurred. * Network programming: How to create a socket(), bind() it to an address, make it listen(), and accept()ing incoming connections. And how to connect() to a connection-oriented server (TCP) as well as the differences between socket streams &amp; diagrams, how to convert from host-byte-order to network-byte-order using htons() and ntohs(), how to create a nonblocking socket using fcntl() or select(). * Concurrent programming: Apart from network programming this job will require you to understand concepts such as semaphores (semaphore.h), mutex, and threads. How to identify critical sections in the program, and synchronize it so that two threads aren't accessing the forbidden region in your program. This is all covered by Computer Systems: A programmers perspective by Bryant O'Hallaron, chapter 9-12. But I'd recommend that you read the entire book as it covers two's complement, endianess, integer overflow, buffer overflow and some concepts/problems that are not so obvious to the novice programmer. Apart from reading this book which will turn you into a "power programmer" (sic) you should look into programming devices like arduino and raspberry pi which btw run on linux so you will still have access to the POSIX api taught by the aforementioned book. I would also recommend getting a book in arm assembly programming which should introduce you to the entire architecture of the processor.
Not only for sockaddrs, but for any situation where a type changes to a less spesific one. Little value, I just thought it was mildly amusing.
I forgot to mention my shell is for Windows. I wanted to implement them using Win API when I could. The point is to run those things by yourself (at least it was for me). Other than that, thank you very much, and I'll try considering it looking forward.
Also, beware the problems with catching signals. Other ways to skin the cat: Pass an open pipe end to the child, which does nothing with it. Then you see the pipe closing when the child exits.
Ahhh, I see. When I usually think of shell, Linux comes to mind since I run off a Mac. However something cool in the works is that Microsoft is releasing Windows Terminal, with Linux capabilities in the near future
 printf("Server disconnected, exiting now...\n"); break; The break makes the **child** process continue rest of client main(). Might cause wtf moments later.
Your problem is that this: while( 1 ) { if( !concurrent_queue_empty( g_service_queue ) ) { p = concurrent_queue_pop( g_service_queue ); /* ... */ } } is a race condition: multiple threads can simultaneously pass the "queue is not empty?" test, but there may not be enough queue entries to actually satisfy all of those threads. Moreover, when the queue is empty, every thread ends up busy-looping! You'd be better off having a _blocking_ operation that pops the next queue entry, i.e.: while (1) { p = concurrent_queue_pop(g_service_queue); if (!p) break; /* queue has been shut down */ /* ... */ } You'll note that I've also provided a way for your threads to be cleanly shutdown: have the queue return `NULL` from this pop function to indicate the queue is empty and will never return more entries. To implement a blocking queue, you'll need to use a mutex and a condition variable. It'll probably be simpler than a rwlock.
Hey there, thanks for your response. I don't think I would wanna shutdown the thread, but I will most definetly google for some documentation on pthread condition variables.
&gt; I don't think I would wanna shutdown the thread Presumably you want to have some way to cleanly stop your program. But regardless, you can add that functionality later.
Oh yea, true. My plan is to send a sighup and kill those threads in the pool.
sigquit*
How can I make a blocking queue with pthread_cond? Why won't a rwlock work?
&gt; Oh yea, true. My plan is to send a sighup and kill those threads in the pool. Careful with signals and threads. You're best off make sure all signals are blocked while you create your threads, and only unblock them in your main thread. Without this it's indeterminate which thread will actually handle the signal. Of course, this is if you plan to handle signals at all. If you don't, a `SIGTERM` (or a `SIGQUIT`) will just terminate the whole process, since that's the default action for those signals. But handling the signal means that threads can exit _in between_ handling requests, rather than stopping them smack bang in the middle of a request. But think about what happens if they're blocked on the queue: the queue needs to indicate that the program is shutting down, otherwise your thread will never wake up and exit! That's why I suggested handling shutdown in that manner. Anyway, I suspect you'll discover all this as you experiment.
&gt; How can I make a blocking queue with pthread_cond? Why won't a rwlock work? Well, for one `pthread_cond_*` needs a mutex. That's just how it works. And once you've got a mutex, you won't need a rwlock. The mutex is acquired only for short periods of time.
So do you mean something like, 1. acquire mutex 2. wait on conditional var 3. release mutex 4. critical section 5. acquire mutex 6. broadcast conditional avr 7. release mutex 8. return Because if so, then I think that's exactly what rwlock is doing. Can you please clarify or describe it in pseudo terms?
&gt; So do you mean something like No. &gt; Can you please clarify or describe it in pseudo terms? Something like: shutdown() { lock mutex set shutdown flag if queue is empty? { broadcast condvar } unlock mutex } push(entry) { lock mutex if shutdown flag is set { error } else { push entry onto queue signal condvar } unlock mutex } pop() { lock mutex until shutdown flag is set? or queue is not empty? { wait on condvar } unless queue is empty? { pop entry from queue unless queue is empty? { signal condvar } } unlock mutex return entry }
Maybe I haven't written C in too long, but won't `name` decay into a pointer if you just use `scanf("%c", name);` (writing to `name[0]`), and what you have now will try to write to the _address_ of `name`? If that still gives a warning, I think that char *p; p = name; scanf("%c", p); should remove it.
Look at what the warning is telling you: `scanf` is expecting a `char*` but you're giving it a `char (*)[100]`. Those are not the same type and the compiler is right to warn you about it. `%c` expects a pointer to a single char, ie `char*`. You're handing it a pointer to an array of 100 `char`s. If you really want to read a single character then specify where in the array you want it written, for example: scanf("%c", &amp;name[42]); If you wanted to read in a whole string of characters then you need to use the correct specifier `%s`.
`scanf("%c", name);` Because you've declared your `name` as an array of characters, the compiler will (kind of) automagically understand that whenever it sees name, it's really going to be a pointer _to_ a hunk of 100 bytes. So, when you your scanf on strings, you don't need to pass the address of your array, as it's "already" a pointer. Another thing is that if you scan for more than 100 bytes, you'll overrun the buffer. So, you should probably use something like `scanf("%100c", name);`. You might want to check the exact syntax of that.
%c is a single character so no chance of overrun.
%c stores just one char so if u want to store a string, you have to use a loop to store it char by char, or use smth like getline()
hmm i tried %s but I am getting the same exact error.
So apparently I found a simpler solution, I added a global mutex "g\_mutex" and then I perform the following, 1. Acquire g\_mutex 2. Set is\_empty to concurrent\_queue\_empty( service\_queue ) 3. If not is\_empty then set p to concurrent\_queue\_pop( service\_queue ) 4. Release g\_mutex 5. Check if is\_empty, if not then proceed Here's my code [http://paste.debian.net/1083574/](http://paste.debian.net/1083574/) I still need an rwlock since I'm push()ing and pop()ing simultaneously.
Sorry I should have been more specific. Using \`%s\` still expects a \`char\*\`, if you want to pass a \`char\[\]\` in a way that satisfies that you just pass the array: scanf("%s", name); Arrays are somewhat special and will convert into a pointer without problems by just using the name. It's the equivalent of passing the address of the first element: scanf("%s", &amp;(name\[0\]) );
This doesn't solve the busy-looping issue I noted in my first comment.
Cleanly exiting programs are overrated. Your server needs to be crash-safe anyway, e.g. by flushing the logs every so often, and at that point you should just be able to exit() at any time. Some systems like Erlang or iOS force you into this. It is especially useless to free memory, close files, etc before exiting. C++ programs are bad about this since they'll politely destruct everything.
&gt; Cleanly exiting programs are overrated. It's polite for a web server to finish its existing HTTP requests, within a reasonable period of time. You're right: it isn't _necessary_. But it is polite.
Does it a pose a serious performance problem?
Follow-up: I was able to create the blocking queue. I didn't use a shutdown flag as you suggested (will look into it later) but the blocking queue works pretty much the way you described above. Here's my valgrind output for the meantime, ==7931== HEAP SUMMARY: ==7931== in use at exit: 0 bytes in 0 blocks ==7931== total heap usage: 291 allocs, 291 frees, 53,964 bytes allocated ==7931== ==7931== All heap blocks were freed -- no leaks are possible ==7931== ==7931== For counts of detected and suppressed errors, rerun with: -v ==7931== Use --track-origins=yes to see where uninitialised values come from ==7931== ERROR SUMMARY: 53 errors from 3 contexts (suppressed: 0 from 0) I know I have a lot to do, but it's a start! Thanks a lot. Also I added a handler for SIGINT to kill the threads, even if they're in the middle of servicing, but later on I'll find a better way kill them while not servicing by using the proposed shutdown flag. I ran with 96 threads in the pool.
Do not post this content please.
True, but hopefully his process writes entire requests back at once. …Actually, I've always assumed if you called exit() while another thread was writing to a socket, the write would still complete. Maybe it doesn't?