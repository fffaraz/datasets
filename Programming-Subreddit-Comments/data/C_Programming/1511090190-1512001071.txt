first one im stuck at this part for (last = 0; last &lt; ship; last++) { second one im stuck at this part scanf_s("%d%d", &amp;shot[0], &amp;shot[1]); 
For the second one: That's not a control structure so I wonder why you are stuck with it. For the first one: What style of flow chart are you using?
wdym by what style of flowchart i have no idea what I'm doing but if there's any way i could send what i done so far to you that'd be great
There are different ways flow charts can look. For example, there are [these](https://en.wikipedia.org/wiki/File:For-loop-diagram.png) (the linked flow chart explains how to translate a for loop, maybe it's useful for you) but also [these](https://en.wikipedia.org/wiki/File:Multiple_Branching.svg) and some other less popular styles.
oh im using the first flowchart style
Ok. Then the `scanf_s()` call just goes into a rectangular box (as it's a normal statement) and the `for` loop is translated as indicated in the first picture.
No blog spam please.
i know what shapes to use. Im not sure what i should type into the shapes. Do i copy paste exactly the code in or type something else?
That depends on what your class expects. I would say, follow the example you saw in class.
Store the hashed password const char *pass = {hashedpass} but you will need a additional function the convert input to hash and control it.
Thanks :)
I understand perfectly. You need to take a closer look at your code. It does not do what you think it does.
"Premature optimization is the root of all evil" -Donald Knuth "Make it work, make it right, make it fast" -Kent Beck If you're still a beginner, you probably don't need to be worrying too much about optimizing just yet. Get to know the language to a point where you feel comfortable, and worry about properly implementing the algorithms you're using.
Yeah sorry. I somehow wrote `i++` instead of `i--`. No need to be snarky.
Sedgewick has bad reviews on Amazon?
Shouldn't correctness come first? What is the use of a highly readable program that gives the wrong answer?
For me and most other senior developers I talked to, readability comes first. You are able to improve, debug and fix an incorrect but readable program. When you have a spaghetti mess that works on pure accident you will come to the point where the only valid approach is to throw it all away and start from scratch. When you talk about a real-world code base with more than 500 KLOC, correctness doesn't exist anyway. The best you can hope for is to find and fix the bugs quickly.
yep!
&gt;32-bit float instead of 64-bit double Doesn't this depend on your system's wordsize? I read somewhere that using half words and double words is slower than using 
c needs to be an int. I feel like a number of those global variables can be eliminated too.
Don't worry about optimization until you need to. The unix philosophy is a good read: http://www.catb.org/esr/writings/taoup/html/ch01s06.html
c is the character read from the file, so why can't it be `char` ?
Only looked at it briefly. if (print_flag) { return 0; } else { return 1; } Since the return value of `inside_comment` is implicitly a boolean, why not directly use `return print_flag;`? Also, why do you use explicitly use fixed size integers (`uint8_t` etc.) instead of the built-in types (`char`, `unsigned int`, etc.)? I don't really see a reason to do that, especially if it is just used for counting things. `int` might even a bit faster. (Since `int` is usually the "native" word of a CPU (except for amd64 userspaces applications for some reason) and thus usually the fastest)
&gt; Since the return value of inside_comment is implicitly a boolean, why not directly use return print_flag; Thanks for the suggestion. Will do that. &gt; Also, why do you use explicitly use fixed size integers (uint8_t etc.) instead of the built-in types (char, unsigned int, etc.)? I read that doing this will save memory space. Will it be a problem in allocating 8-bit size in a 32 bit register? 
I said "abusing function pointers in struct" is bad. This blog post is abusing this approach. "Cat" is a type of object you may put in a large array and may access its getters/setters frequently. When you put lots of function pointers in every struct, the hit to performance is significant. Function pointers in struct don't substitute C++ methods. Most "OOP in C" PDF/posts fail to realize that.
Whenever you dynamically allocate memory (ex: int *x=malloc(sizeof(int)*100) ), make sure to free it afterwards. The compiler won't complain if you forget and nothing will go wrong with your program, but you will get memory leaks that may slow down your machine
&gt; I read that doing this will save memory space. Will it be a problem in allocating 8-bit size in a 32 bit register? You're not using the full potential of the amount of resources you've got. Since the variables might be on the stack, the compiler might've aligned the values to speed up access, so you've got padding that you could just have used for free. Also, these types are [optional](https://port70.net/~nsz/c/c11/n1570.html#7.20.1.1), so you *might* come across a compiler that doesn't implement them (although it is a weak argument because most compilers/header files supports these and most are based on either gcc and/or clang/llvm anyway).
Thanks. &gt; Since the variables might be on the stack, the compiler might've aligned the values to speed up access, so you've got padding that you could just have used for free. Any way to see this effect in gdb or similar tool?
What do you mean by reverse? One divided by that number, or that number with the digits reversed. If the latter, you can convert the number to a string, revert that string, and convert to a number again. Perhaps more simply, if you calculate the modulo 10 of that number, you're getting the last digit, so if you print the digits in the order you get them, you are reverting the number.
Like if we enter 43 output should come 34
What do you mean by printing the digits in order??
Then it's simple: if you calculate the modulo 10 of a number (like `n%10`) you get its last digit, and if you divide it by 10 (`n/10`) you remove the last digit. Now you have to think how to turn these two operations into a loop.
Don't trust the compiler + know your architecture. Say I have a buffer in going to start in the middle then move to the end, then qeap around to the start. Do this in two for loops, not one with an edge case.
What you have to do is get the last digit with modulo, print it, and divide the number between 10 to remove the digit you've just printed. Repeat until the number is 0 and you will have printed all the digits reversed. I can tell you more without actually doing your homework.
I guess you're right. But I feel as though `uintptr_t` itself is a symptom of another problem - trying to cast pointers to integer types. Casting a pointer to a non-pointer type that's not `uintptr_t` or `intptr_t` is undefined behaviour. If `uintptr_t` and `intptr_t` are present and you cast a pointer to them, the only thing you can portably do with it is casting it back to a pointer. Comparison/arithmetic/etc are undefined behaviour.
Thank you üôÇ 
Couldn't really reproduce. It was just a assumption anyway. The stack is usually in a fixed size anyway, and you don't go deeply in the stack, so it doesn't really matter anyway. (Also, I've looked into the code more and pointed out problems in the original comment as an edit) (gdb) b 156 Breakpoint 1 at 0x100401135: file main.c, line 156. (gdb) run Starting program: /tmp/vodico/a.exe [New Thread 10624.0x2920] [New Thread 10624.0xe8c] [New Thread 10624.0x16c4] [New Thread 10624.0x297c] Breakpoint 1, inside_comment (c=10 '\n') at main.c:156 156 if (c == '/' &amp;&amp; !slast_start) (gdb) p &amp;slast_start $1 = (uint8_t *) 0x10040700d &lt;slast_start&gt; "" (gdb) p &amp;double_slast_start $2 = (uint8_t *) 0x10040700c &lt;double_slast_start&gt; "" 
On gcc at least, gprof can tell you what parts of your program take the most time. To the compilation phase, add the -pg command line switch. Run your compiled program as usual. As the third step, run `gprof yourprogram.exe` and preferably pipe it to a text file, which you then open with a text editor. In general: you've now entered the realm of computer science. Learn about the big O complexity of your algorithms. But for huge data structures, do not forget about cache locality, which implies that your program may run up to about an order of magnitude (=10 times) faster, if your data is closer together in memory.
valgrind and gdb. **Valgrind** is a memory optimization utility. **gdb** - general debugger - you can step through your programs and trace issues. ---- [Sorting algorithms](https://www.youtube.com/watch?v=ZZuD6iUe3Pc) - When searching through large sets of data, search times are the biggest target to optimize. In beginner computer science we talk about this a lot. ---- What is a good way to learn how to use these for a beginner? Take [CS50](https://www.edx.org/course/introduction-computer-science-harvardx-cs50x) - An online course that features C for beginners. 
OK, I looked at the C++ version, and there are three poor reviews. One complains about a loose binding, the other two complain that it is a reference rather than an introductory text. The reviews of the C version are more nuanced, but tell the same story: readers expected an introductory text with examples that they could copy-paste into their own code and found something else. I think that says more about the readers than the books...
Does this mean that the size of `slast_start` and `double_slast_start` are just one Bit? Thanks for the suggestion. Will implement those.
I really liked this one. Using the debugger taught me a ton about the language. 
One byte (= 8 bits because most modern systems are like this now), althrough you treat them as one bit.
See [the man page](https://linux.die.net/man/3/getchar) for getchar. It returns the character read as an unsigned char cast to an int, or EOF. You should thus use the correct type for `c` to cover your bases.
Does this mean, each address holds one byte data? Like 0x10040700d : _ _ _ _ _ _ _ _ 0x10040700c : _ _ _ _ _ _ _ _ 
Oh, I thought return value of getchar() is implementation dependent. 
Yep.
Nope, it is defined as `int` in [POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/)
C++ stinks! C version one I will give it a go anyway! Thanks!
I did what you said with nc but when i looked how others code up bots/barebone clients in c i got scared because of the line parsing which seems really hard to do
[`getchar()` returns an `int`](https://port70.net/~nsz/c/c11/n1570.html#7.21.7.6) and [`EOF` is negative](https://port70.net/~nsz/c/c11/n1570.html#7.21.1). In practice, `EOF` is usually `-1` (`0xFFFFFFFF`). If you do `c = getchar()` when `c` is `char`, [it is implicitly converted/truncated to an `char`](https://port70.net/~nsz/c/c11/n1570.html#6.5.16p3). Normally `char` in gcc without any extra options is `signed char`, so you essentially check if `c` is `0xFF`, which is a valid byte, and treat it as an `EOF`. So anything after `0xFF` is not read.
&gt; C++ stinks! That's not very mature. I picked the C++ version because it is newer. The latest edition uses Java.
haha...mature lmaooooooooooo
There are so many architectures and generations of processors that it does make it tough to answer. On modern systems, it's the memory reduction that improves cache coherency that leads to performance improvement. 64 bit doubles still take up twice as much space in cache.
Worth learning to read Assembler and looking at how your code compiles to get a feel for what is going on. Memory locately is worth knowing about. Tools: valgrind, gdb, cppcheck, full warning on the complier. Use git. Use make. Write tests for your code and test parts in isolation and do whole program tests. Gcov will tell you where testing is lacking. I always tells anyone to read "Lions' Commentary on UNIX 6th Edition" for learning C and operating systems. The C is old but educational. K&amp;R is a must too. I also recommend "Advanced programming in the Unix environment" for POSIX and history. Nearly 20 years ago, I quite enjoyed "The blackart of 3D game programming" but it was out of date then as it's all about software rendering.
&gt; When you put lots of function pointers in every struct, the hit to performance is significant. Without any hard numbers I really wouldn't consider that concern much more then just premature optimization. I get that calling functions indirectly is slow, but it's not *that* slow, computers today are petty fast. The reality is, a noticeable performance hit may not appear until you start having hundreds or thousands of function pointers, so unless you actually start seeing an issue I don't think it's worth worrying about, especially not for smaller projects and situations where timing isn't that important. That said, again, I agree it could still be improved, and that thought should be put into which things are overridable/virtual/whatever and which are not (IE. Which things have function pointers, and which are just functions). Even without worrying about performance, it gets harder to reason about your code the more and more overrides you add. And going along with what you're saying about size, it would also benefit them to separate their function pointers into a separate `struct`, create a single instance of it for each object type, and store a pointer to that instance in each object. Every object of the same type is going to have the same set of pointers anyway, so it makes sense not to duplicate them in every object. Also, personally, when I do patterns similar to the one OP is showing I normally provide a function to call for every "method", even overridable ones (Where the function just calls the function pointer). That way the API is consistent and easier to use/harder to get wrong. When you do it that way, it is trivial to go back and make something overrideable that previously was not, so most things besides the basic functionality can just regular functions until you find there is a need to override it. I also don't usually provide 'getters' and 'setters' and just allow access to the members directly if it makes sense to do so, which also cuts down on the complexity.
1. Do not optimize prematurely. 1. Do _not_ optimize prematurely. 1. Do ___not___ optimize prematurely. 1. Profile your code, optimize _only_ the slowest part, then profile again. 1. Only optimize if a part of your code is orders of magnitude slower than the rest. 1. You cannot know what part of the code is slow. You can only measure and see. 1. Your problem is more than likely that you're using the wrong data structure. As others have stated, you may want to read some books on the subject. Standing on the shoulders of giants, I usually say "first make it work, then make it fast". There's nothing for you to optimize before you've solved the problem at hand. I hope this helps! :)
Of it was me I would be thinking about a move patients from a waiting list to a doctoring or waiting in a room list. 
For the next time: Put the gist of your question in the title, not something useless like ‚Äúa cry for help.‚Äù We get that you are looking for help from the ‚ÄúQuestion‚Äù flair. No need to waste a perfect opportunity to save other people time by telling them up front where you are stuck.
#Rob Pike's 5 Rules of Programming **Rule 1.** You can't tell where a program is going to spend its time. Bottlenecks occur in surprising places, so don't try to second guess and put in a speed hack until you've proven that's where the bottleneck is. **Rule 2.** Measure. Don't tune for speed until you've measured, and even then don't unless one part of the code overwhelms the rest. **Rule 3.** Fancy algorithms are slow when n is small, and n is usually small. Fancy algorithms have big constants. Until you know that n is frequently going to be big, don't get fancy. (Even if n does get big, use Rule 2 first.) **Rule 4.** Fancy algorithms are buggier than simple ones, and they're much harder to implement. Use simple algorithms as well as simple data structures. **Rule 5.** Data dominates. If you've chosen the right data structures and organized things well, the algorithms will almost always be self-evident. Data structures, not algorithms, are central to programming. Pike's rules 1 and 2 restate Tony Hoare's famous maxim "Premature optimization is the root of all evil." Ken Thompson rephrased Pike's rules 3 and 4 as "When in doubt, use brute force.". Rules 3 and 4 are instances of the design philosophy KISS. Rule 5 was previously stated by Fred Brooks in The Mythical Man-Month. Rule 5 is often shortened to "write stupid code that uses smart objects".
 num() { n = getchar() if n != \n num() print n }
However, ‚Äúdo not optimize prematurely‚Äù is not to be understood as ‚Äúdo everything the stupidest, slowest way you can imagine.‚Äù What Knuth meant is that you shouldn't go for micro optimizations such as rewriting `a * 2`to `a &lt;&lt; 1` when writing code. Of course you should choose good data structures that support the operations you want to perform. Of course you should design your algorithms such that they are not needlessly complicated.
My bad, sorry about that
Linus Torvalds said something along the same lines as #4 &amp; #5 - "Bad programmers worry about the code. Good programmers worry about data structures and their relationships." I probably should've emphasized the importance of data structures over getting algorithms right.
How much information about the patients gets into the program? What do you know about the regulations controlling this?
What if the number is negative?
The only information regarding patients that gets into the program is their patient id number, which they enter themselves on arrival. The program then stores this info in a queue. But what I want to be able to do is have the program display a message if a room is free straight away when they check in. They would then be assigned to the free room rather than the queue, or put in the queue if all the rooms are currently busy. I'm just not sure how to implement this.
Those kind of errors can be detected early when you develop correctly and look for mistakes within your code. You have a lot of tutorials on the web to help you do that. It also looks like you can use some programs to help you do that. I got an advise once to use Checkmarx to detect vulnerabilities in the code, you can try it out. Good luck
I know I should use another array for the rooms. Such as: int room[10]; //for 10 rooms and if( room[i] == 0 ) //room vacant else if( room[i] == 1 ) //room occupied I'm just having trouble connecting this with my queue.
As a beginner to C I would recommend to code slowly and detect vulnerabilities among your code. That's how you ensure "code security". You can also use a app to do that.There are amny, such as Checkmarx if you want to try. But good practicing is very important as well. Good luck! 
What is this the password for? That is, what is the value of the thing protected by the password you are trying to obscure? I ask because if the value is high, you are asking the wrong question.
Try using the highest optimization mode https://gcc.gnu.org/onlinedocs/gcc/Optimize hope it helps
is the compiler not smart enough to do the above optimization by itself? For example with gcc -O3 ?
Yeah, of course it's smart enough to do that itself. This is one of the oldest optimizations in the book.
-lFOO is a command line option telling the linker to include libFOO. As for how, that depends on your OS's package manager and what it calls the package that includes libmatrix (assuming it's not something built by your project). Refer to the installation documentation of whatever you're trying to build for details about dependencies.
Do not post error messages as images. Always post text!
The point is that you *shouldn't* write 'a &lt;&lt; 1' instead of 'a * 2' in a math context. The compiler will apply that optimization if it applies.
Even if you store an encrypted version of the password at compile time it‚Äôs still trivial to step into a debugger and inspect the decrypted version in memory at run time.
The rest of his [Notes on Programming in C](http://www.literateprogramming.com/pikestyle.pdf) is also worth a read.
If optimization ever harms your readability, you are either making the wrong optimizations or you are making them incorrectly.
That's not a matter of optimization.
Do you really want to tell me that Duffs Device doesn't harm the readability? Luckily that specific optimisation is no longer necessary, but enough others like it still exist and work.
You must be one of those who use Duff's device
&gt; Duff's device I never heard of this! but its cool. but this is more for DSP work, where's there's special loop instructions for churing through stuff like this. But ofc DSPs have shit compliers that can't produce optimized code so stuff like this is a short cut to get it to do that. 
I guess I should add a point to write code in a clear and readable manner. It's almost always more important that you can understand the code than it is for it to be fast. If you do this, you rarely have to optimize it anyway, because you're probably already using good structures and algos.
C++ can't inline virtual methods and they take space in the VMT. You're right that you shouldn't be using function pointers as struct members to implement non-virtual methods, but for virtual methods they're fine, though you'd probably be better of using VMTs.
It definitely does, that's why you should leave it up to the compiler or the architecture. &gt; others like it Any examples?
I can see why you'd want to do that for DSP, but I don't like making assumptions about what machine code the compiler is going to generate for a certain programming pattern, so I'd probably end up doing that part in assembly. I guess at least leave a comment in the code explaining why you are using two for loops so that some snob won't come along and change it, unless there's a well known convention to do it that way on your architecture (like using decrement and zero test for iteration on AVR)
Another typical case would be to exploit macros as inline functions. Most micro-optimisations exist because compiler DIDN'T use them. Simple because they aren't implemented or only usefull in edge cases, leaving them to the compiler is simply not an option.
If your function is so big that implementing it as a macro harms readability, chances are you aren't going to gain anything by inlining it.
I disagree, if you know what the assembly *should* look like, you should write code that mimics that as closely as possible, and remove as much guess work from the compiler. We aint doing oop programming where you programmer for readability, this is C land, we gotta go fast. 
A scanf statement should handle this perfectly!
Yes, using a bunch of SIMD intrinsics all over the place.
Yeah, I have to use a scanf statement, but I need to get different variables from one line of input. How would I go about defining say num1, num2, and sym from this text?
Yes I understand! You can use `scaf ("%d %s %d",&amp;num1, symbol, num2)`
That worked, thanks!
Don‚Äôt use the delay functions. Completely nulls any input to your cpu or something like that. I‚Äôm still learning
There's nothing fundamentally wrong with this approach, it would work, but you will likely find more then a few annoying cases that slow things down. The biggest issue is that anything that modifies that list will end-up requiring copying everything at the end (Because you're storing it in an array). This will end up being a pretty big issue, because while you're `malloc` can *find* a space with enough memory in `O(lg(n))` time, modifying the list is an `O(n)` operation, as opposed to the linked-list where it is an `O(1)` operation. `free()` also would require modifying the list, so it would also end-up having that `O(n)` complexity for the copy. Having two lists would likely be a must, but it does also mean that `malloc` and `free` take twice as long since they need to modify two lists. That said, I think you're really just using the wrong data-structure for what you want, both the array and the linked-list aren't very good. This is really better suited to some type of tree (like a red-black tree, AVL tree, B-tree, etc.). Like you suggested, you could keep two trees, one sorted by address, one sorted by size. Assuming a decently balanced tree, the look-up should be `O(lg(n))` (a binary search, like you can do with the array), but removals and additions would have a worst-case of `O(lg(n))` rather then `O(n)`. If you don't want to delve into the complexity of writing an implementation of one of the self-balancing trees I mentioned, it's not too hard to find one online. Worst case, you could also just forgo the self-balancing and just use a plain binary-tree instead (You wouldn't want to do this for something important, but it's perfectly fine for learning). The disadvantage of using a regular binary tree is that if it does become unbalanced, the worst-case situation is an `O(n)` look-up, which is fairly bad. But in the general case your tree shouldn't get *too* imbalanced, so you would likely still see some good performance gains. With that though, writing an RB-tree or AVL tree implementation isn't *too* bad, and there's a fair amount of information out there on it, so if you're up for it I would encourage you to give it a go. That said, even with a well written implementation of this you're still going to run into the issue of fragmentation. You may consider looking into instead creating an allocator based off of a bunch of separate lists of memory blocks that are all the same size, and then just picking the list to use based on the smallest size that fits the object that was requested. This basically avoids all fragmentation, because all of the blocks within a list are the same size, meaning there is never any 'extra' space between two allocated blocks that you can't use.
It's not that difficult. See this link on the Arch Linux forum post for a basic skeleton: [IRC bot in &lt; 100 lines of C](https://bbs.archlinux.org/viewtopic.php?id=64254).
what is the definition of `time_word`? I can't seem to find it
time_word twenty = {[0] = 1, [1] = 2, [2] = 3, [3] = 4, [4] = 5, [5] = 6}; from http://www.drdobbs.com/the-new-c-declarations-initializations/184401377
Here are some things to have a look at (in no particular order): 1. set a known seed otherwise it'll be incredibly difficult to pin down where the problem is. 2. in `spikeValueRecorded` I'd start the for loop at 1 (otherwise you'd compare element 0 with itself -- no need to do that). 3. engineer the situation you want to test (by setting data[3].tp = 0, and data[4].tp = 101) 4. check the logic in `spikeValueRecorded` by using print statements.
For some reason the code block in my post isn't wrapped around all of the code, but my definition of time_word as a typedef struct is above main(). The member of 'twenty' that I am trying to initialize is declared as an int *.
Fix your formatting. A pointer and the thing it points two are separate objects, and they can have different lifetimes. Here you're declaring an object with automatic lifetime for the pointer to point to, but that doesn't necessarily have to be the case. You can't just wave that away; when you try to combine the two into one line you're actually trying to declare two separate objects, but you've only specified the lifetime of one of them. What lifetime is `{0, 1, 2, 3, 4, 5}` supposed to have? automatic? static? dynamic? The reason it has to be two declarations is because it's two objects.
i tried compound literals but got the following error: "taking address of temporary array" const time_word twenty = { .letters = (int[6]){0, 1, 2, 3, 4, 5}, .num_letters = 6, }; .
i'm not the OP but: typedef struct { int* letters; int num_letters } time_word; 
As /u/syn_ack mentioned, print statements are your friend. One other thing I noticed is that your `spikeValueRecorded` function cannot "push" the index back to the caller as it's taking an int. It needs to take an `int*`, like this: bool spikeValueRecorded(data_slice * data, int *outputIndex) { float oldValue = data[0].tp; for (int i = 1; i &lt; ARRAY_SIZE; ++i) { if (data[i].tp - oldValue &lt; MAX_CHANGE) { *outputIndex = i; return true; } } *outputIndex = -1; return false; } Call it like so: `if (spikeValueRecorded(data, &amp;index))` 
My object-oriented programming is a bit rusty, and I am not sure how the designated initializer actually operates, so I am not sure how to answer you question about lifetime. This is C, so is `{0, 1, 2, 3, 4, 5}` really an object? Regardless, the error given doesn't seem to me to indicate that this is a lifetime issue.
Rethinking this, it does make sense to me that this is a lifetime issue. I guess there is no elegant way to do this in one line? An elegant way to allocate memory for the array, put the values there, and pass that address as part of the designated initializer... maybe not.
My compiler gives a bit more for this: "warning: pointer is initialized by a temporary array, which will be destroyed at the end of the full-expression." As Rhomboid indicated above, I think it is an issue with the lifetime of the values I am trying to store at the pointer in the struct.
Odd that's not appearing in a grep of my include folder nor did Google return a single thing... Any way, op: you can't assign a literal array to a pointer, you have you first define the array as you have (while initialising with the literal array) then pass it as a pointer : int twenty_letters[] = {0, 1, 2, 3, 4, 5}; time_word twenty = {&amp;twenty_letters, 6}; 
Don't focus on optimizatio so much right now. Get good at writing straightforward and easy to understand logic.
Completely missed that you can't assign a literal array to a pointer, you have you first define the array as you have (while initialising with the literal array) then pass it as a pointer : int twenty_letters[] = {0, 1, 2, 3, 4, 5}; time_word twenty = {(int *)&amp;twenty_letters, 6}; 
Wow! I didn't expect such a comprehensive answer. This definitely gives me a lot to think about. I guess the original reason that I decided on a sorted array list was that the common naive way to do memory management is with a free linked list, and I thought a sorted list might be an improvement on that, but it sounds like I wasn't thinking "big picture" enough. I didn't even think about sorted trees, but they would definitely be a better fit than a sorted array list in this scenario, given the complexity classes of each operation. The idea of having lists of different sizes is a good idea too. How would you suggest deciding the sizes of each list?
If you divide a number to get its prime components (?), you finish when the number is 1, not when it is 0.
If you post one more piece of blog spam, I'm going to ban you.
thank you soo much sir! it worked! have a good day
In C, an object is ‚Äú[a] region of data storage in the execution environment, the contents of which can represent values.‚Äù 
You need to put four blanks in front of every line of code for the code to appear readable. The backtick syntax is only valid for snippets of code within a paragraph, you can't use it to format entire paragraphs of code.
There is no good way to do this. As `letters` is a pointer, you need to set up a separate object it points to. This can't be done in line and there are multiple ways to allocate the pointee, depending on what storage class it is supposed to have.
The compiler is some times not smart enough to perform the specific optimization you want. For example, this is the case when trying to vectorize loops and you have some knowledge that could optimize the code better but you can't easily tell that to the compiler.
Could you elaborate on that?
Thanks. Is it correct to say that valid ascii characters are from 0 to 127 and -1 for EOF? 
Thanks for the clarification. Does this means that the K&amp;R 2nd Edition is bit outdated? Since in the examples, the book used `char` instead of `int`.
apparently using some other wat allows one to run other computations in the time delay() would be essentially telling the cpu to stop. I‚Äôve only taken an intro class so this is above my paygrade lol. If an expert could elaborate that would be great
What your instruction might have meant is that you should use ‚Äúbusy waiting‚Äù loops like this: for (i = 0; i &lt; 1000000; i++) ; Not that this kind of loop would do what you intent with modern compilers anyway. Using loops like this is a bad idea since it uses up CPU time the CPU could use to do other things. The right solution is to use the `sleep()` function which tells the operating system to suspend your process for the given number of seconds. This frees up the CPU to run other processes. If you want to sleep for a shorter time, use `nanosleep()` if available. There are some occasions where such a busy loop is appropriate but you probably won't need to program them yourself any time soon. One example is implementing spin locks, which could look like this: _Atomic int lock_status; #define MY_BIT (1 &lt;&lt; 0) /* every thread has a separate bit */ void lock() { /* set lock bit */ lock_status |= MY_BIT; /* wait until all other threads have released the lock */ while (lock_status != MY_BIT) ; } void unlock() { /* clear lock bit */ lock_status &amp;= ~MY_BIT; } Note that locks aren't actually implemented this way usually, but this might be useful to get the general idea. 
Thank you!! I‚Äôm now guessing delay() was just an arduino language something!!
For the ASCII part, yes, because it is a 7-bit character set (So in a 8-bit byte 127 values are basically unused). If you want to check if the character is really a character, you may want to look at the functions included in the header file [`ctype.h`](https://port70.net/~nsz/c/c11/n1570.html#7.4) ([alternative version, possible easier to navigate](https://www.tutorialspoint.com/c_standard_library/ctype_h.htm)), because it isn't explicitly said that [it is the character set it is being used](https://port70.net/~nsz/c/c11/n1570.html#5.2.1) (but for like all cases ASCII is used). `-1` is mainly used for `EOF`, but it isn't guaranteed, because the standard says that `EOF` is negative, so it *could* be `-2`. If you get a character from `getchar` or similar functions, is is better to use `int` for the character to store in so you can differentiate between `EOF` and actual data. If you haven't got an `EOF`, then you can convert it to a `char` if you want. 
CLRS is what they used in my algos class. It was a good book, but I'm glad I'll never have to take that class again
If the size of the `letters` is going to be the same for all `time_word`s, you can change it to `int letters[6]` and use `{{0, 1, 2, 3, 4, 5}, 6}`.
use a char array for the first structure member letters. Then you can use "012345" instead of using the {0,0,0,0} initializer. Downside is you'll be using char to represent numbers which means doing conversions which can lead to some issues.
And now you make extra accounts just to post your spam. Fuck off already!
&gt;v=='q';
What about it? I'm sorry I'm clueless at this point, I have no idea what I should be fixing.
NEVER use %s with scanf without a width modifier (like %5s for a string buffer of 5 characters) or your buffer will overflow. You might want to use %c instead for a single characters.
 int main() { int len, y, z, q, r, t; char v, num1[8], num2[8], sym[3]; t=0; v=='q'; // should be =, as you're assigning printf("Enter Numeral Equation, q to quit:"); while(!v) { if(scanf(" %s %s %s", &amp;num1, sym, &amp;num2) == v) /* scanf returns the number of elements it matched, not the character it read; furthermore, you shouldn't use &amp; with num1 and num2 */ { // Also, I think scanf won't accept your input until you've type as many elements as you've written in your format string, so you can't just write q and expect it to work when you have three elements in your format string; I may be wrong, though printf("Total: %d\n", t); return 0; } y = roman(num1); z = roman(num2); q = calc(y, sym, z); printf("%d\n", q); t=t+q; } return 0; }
Was thinking about that! You can risk a buffer overflow with %s here, yes, but dude he's just entering a single symbol in %s for a school assignment 
`==` is used for testing equality, `=` is used for assigning. The former is useless if used by itself (outside an assignation or conditional).
Okay, so obviously that doesn't work that well... I decided to reformat my main, so that when input ceases, it will quit. int main() { int len, y, z, q, t; char num1[8], num2[8], sym[3]; t=0; printf("Enter Numeral Equation:"); while(scanf("%s %s %s", num1, sym, num2)==1){ y = roman(num1); z = roman(num2); q = calc(y,sym,z); printf("%d\n", q); t=t+q;} printf("Total: %d\n", t); return 0; } Now when I run it, it automatically prints out the total and ends the program. What should I do? I'm sorry I'm very new to this and I'm still trying to learn. 
Well, on page 16 of K&amp;R 2nd edition in example 1.5.1 the return value of `getchar` is an `int`, so it may be an issue with whatever example you were looking at. C89 does define `int getchar(void)`, so it has been an `int` for a long time. See section 4.9.7.6 of [ISO 9899:1990](http://port70.net/~nsz/c/c89/c89-draft.html#4.9.7.6)
My bad. It is clearly mentioned to use `int` in K&amp;R: &gt; We can't use char since c must be big enough to hold EOF in addition to any possible char. Therefore we use int.
I guess you want to compare scanf result to `3` , not `1`. 
This will however be a totally different struct: Instead of a pointer you store a whole array.
try uninstalling it with your package manager and deleting the /etc/gdbinit* file/folder, then reinstall 
Look in the gdb documentation. It should say there where these files are located and how to remove them.
Of course, I should probably have said that. But if the code OP posted is his complete program, there's no reason not to store the whole array in the struct.
sure, but just for the sake of completeness
I don't know a whole lot about GDB configuration or plugins but you can do this: gdb --configuration And you'll see a `datadir` like this: --with-gdb-datadir=/path/to/your/datadir/ Then, in that path you can have a directory called `system-gdbinit` in which automatically loaded python scripts can be located. My installation (OSX) has `elinos.py` and `wrs-linux.py`. As others have said you can probably purge the application with `apt` and reinstall, but you might be able to just nuke whatever python script is causing this weird behavior. 
you are probably looking for gdbinit files
If you've installed it like the README says: https://github.com/cyrus-and/gdb-dashboard/blob/master/README.md And assuming you haven't added anything else to the file `~/.gdbinit`, then it's just a matter of removing/renaming the file.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [cyrus-and/gdb-dashboard/.../**README.md** (master ‚Üí 4de2a18)](https://github.com/cyrus-and/gdb-dashboard/blob/4de2a18f337884f79b36332095b4cdf12f85c48a/README.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dq46ryi.)^.
I sometimes work on a little irc client in C if you'd like to check it out. It's mostly compliant with RFC2812, I'm getting there slowly. https://github.com/rcr/rirc
Yeah, that's not valid in C.
Shit...ok, thanks. 
Post your code here, and not as an image - if it's big, put it on gist or pastebin or whatever instead of inline in your post. Be specific in your questions, too.
Post code, not images of code. 
I've edited my original post 
r/C_Homework/
Oh sry here is the Code: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/utsname.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;pwd.h&gt; #include &lt;fcntl.h&gt; int main() { char cwd[1024]; char eingabe[20]; char q[] = "quit"; char v[] = "version"; char h[] = "help"; char* myName; myName = getenv("USERNAME"); struct utsname unameData; while(1) { printf("$ hawsh \n"); getcwd(cwd, sizeof(cwd)); printf("Current dir: %s - Was willst du tun %s? ", cwd, myName); scanf(" %s", eingabe); if (!strcmp(eingabe,v)) { uname(&amp;unameData); printf("Version: %s %s Autor: Eddy\n",unameData.sysname,unameData.release); } else if (!strcmp(eingabe,q)) { printf("...und tsch√º√ü! \n"); exit(0); break; } else if (!strcmp(eingabe,h)) { printf("M√∂gliche Befehle : \n"); } else { system(eingabe); } return 0; } } ----------------------------------------- More Information: i start the programm via linux simple sudo ./hawsh. The programm starts and i can enter the 3 option quit,help,version. if i try to enter for example Test.txt which is in this case, is in the same file dictionary i get a message that says "sh: 1: Test.txt: not found" it also doesnt work with batches
Maybe add a strength and/or state enum variable to your hand struct. For example, hand[0].state = FOUR_OF_KIND. hand[0].strength = 13 + 13 + 13 + 13 + 8 (four aces and an 8) Could compare both hands "states" and if they are equal, compare strength.
Yeah, it is not valid C. You may want to look up what hash tables are and C implementations (I don't know about the latter, so I can't help you).
Thank you, you literally just gave me a great idea 
How do you envision deploying your program? Are there existing computers in the exam rooms? To me this sounds, like this needs to be a multi-user program event driven system.
Why don't you use strcmp in a if statement to decide which part of the struct you wish to use. Or better yet, you can set up a enum with the parameter options and use a switch statement to decide how each enum should be processed.
Here is the pastebin: https://pastebin.com/0yrMVZ2i
Your compiler doesn't see the definition of the struct, so it doesn't know how big it is or what fields it has, so it can't be dereferenced.
Next time use gdb-peda its better and easier to remove
is #include&lt;netinet/icmp6.h&gt; the same as #include&lt;linux/icmpv6.h&gt; ? also line 212, are you missing the parens around for sizeof()?
No, it's not. And you don't need parens with variables and sizeof.
&gt; you don't need parens with variables and sizeof. huh, i never tried, always treated it as a function (i know its compiletime)
&gt; I guess the original reason that I decided on a sorted array list was that the common naive way to do memory management is with a free linked list, and I thought a sorted list might be an improvement on that, but it sounds like I wasn't thinking "big picture" enough. You're definitely not wrong here, a linked-list is the bare-bones way to implement an allocator, and your ideas for improvements are largely on track. You're also 100% correct in thinking it should be possible and would be tons better to do a binary-search rather then a linear one. That said, I think you may have missed *why* the linked-list works well though, which I probably should have pointed out (I guess I got stuck on the complexity aspect and neglected to point this out). The way those allocators work is by storing a "header" before each allocated block, and the headers are what make-up the linked-list. By putting the headers inline with the allocated memory, you don't need any separate memory to store this information. But this necessitates using a linked-list because the headers will never be contiguous. If you use an array of headers instead, you have to allocate memory for those separately, and the amount of memory you need will grow and shrink as your memory is fragmented and more headers are needed. There are ways to make this work, but it will probably get ugly pretty fast and get kinda complicated. That said, a binary tree really does map to what you want pretty much perfectly, because it retains the binary-searching attribute that you were trying to get via the array, but keeps the linked-list attribute that the nodes can be discontinuous and that allows putting the binary tree links in the header for each block of memory. Using a non-self-balancing binary tree in the allocator shouldn't be too hard to implement or be too different from just using a linked-list. I think the most involved part of using a tree would be the combining and splitting of blocks when you do an allocation or free (IE. When you allocate 32-bytes from a 1024-byte block. or when you do a free and have two blocks with contiguous addresses). I think that, especially if you go for a proper self-balancing tree, you're much better off just doing full node removals and inserts rather then attempting something a bit more clever. &gt; The idea of having lists of different sizes is a good idea too. How would you suggest deciding the sizes of each list? Generally speaking, powers of two are the way to go. Most architectures have some kind of alignment requirement or recommendation, so if you allocate weird sizes you won't meet the alignment requirements unless you pad those allocations to the proper required alignment by allocating some extra memory for them. Also worth noting that (In the case of a general purpose allocator) the OS is going to (somewhat underneath the covers) hand you memory in generally power-of-two sized chunks (Typically 4K) so it is worth it to use all of that memory when it gets allocated. The smallest size you support is up to you, personally I think 32 bytes is a reasonable minimum. You also need a maximum size, which is up to you. That doesn't need to be the maximum size your allocator supports though, as you could just allocate blocks larger then that maximum in their own piece of memory directly from the OS and keep all of those blocks on their on list. This is inefficient (Because you're hitting the OS every time), but presumably you won't have tons and tons of extremely large allocations to handle so it shouldn't be a huge performance hit. If you find that you do, you could always add more allocators for larger sizes to compensate. The only part that gets a bit complex is deciding how much memory to dedicate to each size of list. You are probably going to want this to just grow as each list needs more. This isn't too hard to achieve, but does make things a bit more involved. You end-up with a list of lists, where each size of block (32, 128, 256, etc.) has its own list of large pieces of memory currently holding a bunch of those size of blocks. So when you get a request for, say, 32-bytes and you don't currently have any 32-byte blocks free, you go and allocate another big "chunk" of memory, split it into a bunch of 32-byte blocks, and stick all of those on the freelist. The chunk itself would go onto a separate list of "chunks" of memory currently holding 32-byte blocks, which you would need to use when you are freeing a block (As you need to loop over the chucks and check if the address being freed is contained in any of them). I also suppose you could actually put the chucks in a binary-tree sorted by address which would allow you to do a binary-search over them, which would of course be much better. I personally haven't done this, but for the project I'm using this type of allocator in, the allocator doesn't really get hit enough for that to matter right now. Sorry that was all a bit rambly, feel free to ask any questions you have.
It can be runtime for variable length arrays
You maybe can abuse macro's to get something along those lines (eg: https://stackoverflow.com/questions/195975/how-to-make-a-char-string-from-a-c-macros-value ) but that's pretty much a terrible idea except for a few specific cases that I can't think of offhand.
There's KLib's khash.h and Judy arrays.
That must be a c++ or custom function. C has no such thing
Hint: A string is an array of bytes
This is my task Write a program that accepts your first name into a character array string variable. Display your name with an asterisk between each letter. For example, if your name is Lisa, display L*i*s*a
my issue is that i only know how to store things in an array like numbers for a sale etc. and how to sum them up. i am not sure how to print just the letters and especially not with * in between 
You only have to print every letter by itself, which you can do in a loop (hint: to get the n-th letter of the string `str`, you would use `str[n]`), and then you just have to print a `'` like you would print any other string. If you've been asked to do this, you were taught loops, so it shouldn't be difficult.
this is all i have been able to come up with so far, i suck at coding im a networking major just trying to pass this class..... #include&lt;iostream&gt; using namespace std; int main() { int foo[]={a,a,r,o,n}; int n, result=0; 
I only know C, not C++, so I'm not entirely sure this works, but I would change `int foo[]={a,a,r,o,n}`, which doesn't work (it uses the values of the variables `a`, `r`, `o` and `n`, which don't exist), to `char* foo="aaron"`. Then, I'd do for (n=0; foo[n]!='\0'; n++) printf("%c*", foo[n]); This prints an asterisk after every character, even the last one. I leave to you how to fix it so that it doesn't do that.
&gt; C has no such thing Yes [it does](http://en.cppreference.com/w/c/language/sizeof). See the sections on VLAs. Here's a program you can run to see it in practice: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char **argv) { if (argc != 2) { fprintf(stderr, "Usage: %s N\n", argv[0]); return EXIT_FAILURE; } int n = atoi(argv[1]); int arr[n]; printf("n = %d\nsizeof arr /sizeof(int) = %zd\n", n, sizeof arr / sizeof(int)); return 0; } 
#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main(){ string name; cin &gt;&gt; name; for (int i = 0; i &lt; name.size()-1; i++) { cout &lt;&lt; name[i] &lt;&lt; "*"; } cout &lt;&lt; name[name.size() - 1] &lt;&lt; endl; } 
 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main(){ string name; cin &gt;&gt; name; for (int i = 0; i &lt; name.size()-1; i++) { cout &lt;&lt; name[i] &lt;&lt; "*"; } cout &lt;&lt; name[name.size() - 1] &lt;&lt; endl; } 
As I said in your other thread, never use %s with scanf like that. Add a maximum width specifier according to the size of your num arrays: `%8s %3s %8s`.
 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main(){ string name; cin &gt;&gt; name; for (int i = 0; i &lt; name.size()-1; i++) { cout &lt;&lt; name[i] &lt;&lt; "*"; } cout &lt;&lt; name[name.size() - 1] &lt;&lt; endl; } 
No, `free` has no way to know that what you stored in the memory region is a pointer, and even if it did, it would be dangerous to free all the pointers in the region, given that they might be used somewhere else.
Ok, thank you very much!!
C++ is off topic in this subreddit. Please post C++ questions elsewhere. I have removed your post for this reason.
Please don't paste images, paste text!
So you need to take the string "aaron\0", and output ```a*a*r*o*n```? for(n = 0; fooi[n] != '\0'; n++) { if(n) { printf("*") } printf("%c", foo[n]) } Print the first letter of the string, and then for every following character, you print an asterisks before the character to avoid trailing character.
You need to put four blanks in front of every line of code so reddit formats the code correctly.
As a general rule of thumb, every call to `malloc()` should be paired with exactly one call to `free()`. In your example you have two `malloc()`s so you need two `free()`s. 
I'll keep that in mind, thanks!!
you also need to be aware of any "handles" from 3rd party libraries in your structure, does the library somehow clean up after itself? or do you have to call disposeWidget / destroyWidget / deleteWidget or some other function to do deallocation (and potentially other tasks)
I only have Curses as 3rd party library, and in this exercise I explicitly need to free the memory with a function which now its body is like this (takes a pointer to struct snake s): free(s-&gt;body); free(s);
Nooooo
Off topic I guess, but why is `position` a pointer at all?
"position" is the type of the pointer *body*, and it is that way because of bounds given by the exercise, as it represent the array of the parts in the snake game
&gt; &gt; When you put lots of function pointers in every struct, the hit to performance is significant. &gt; Without any hard numbers I really wouldn't consider that concern to be much more then just premature optimization. I get that calling functions indirectly is slow, but it's not that slow, computers today are petty fast. Dereferencing might not be an issue, but cache effects will be. Better to have a single pointer in each struct that points to a single struct that contains the function pointers. This is effectively a C++ vtable.
Neither Intel nor AMD will ever, ever, *ever* market a CPU that penalizes 32-bit floating-point operations relative to 64-bit floating-point operations. There is simply too much existing code that uses 32-bit floating-point‚Äîmuch of it written in Fortran while you were still learning your multiplication tables, and much of it used by the kind of people who buy CPUs in five- or six-digit batches.
&gt; Change `t=t+q` to `t += q` That's purely a matter of taste. Both statements are equivalent. 
* Move all `sys` headers to the top, starting with `&lt;sys/types.h&gt;`. Place the `arpa`, `net` and `netinet` headers below `sys`, and finally those with no subdirectory. * Use `struct sockaddr_storage` instead of `struct sockaddr`. The latter is only big enough to store the common parts (family, length on BSD systems, first few bytes of address). * Why define `saddr_size` as `int`? Use `socklen_t` instead. If nothing else, the latter will save you a cast. * Why use `recvfrom()` if you don't use the address? Use `recv()` instead. * As for the direct cause of your problem: it's spelled `icmp6_hdr`.
You can't put statements or initializers in a struct declaration.
Not sure what you think this does, especially since `entropy` is always 0. You don't define `BYTE`, so I can't quite tell what your program actually does except probably discard the first character of its input. I assume that you are expected to implement [Huffman coding](https://en.wikipedia.org/wiki/Huffman_coding), which is one of the simplest compression algorithms, and in theory the best, but is little used in practice as it requires complete knowledge of the input before compression can begin.
**Huffman coding** In computer science and information theory, a Huffman code is a particular type of optimal prefix code that is commonly used for lossless data compression. The process of finding and/or using such a code proceeds by means of Huffman coding, an algorithm developed by David A. Huffman while he was a Sc.D. student at MIT, and published in the 1952 paper "A Method for the Construction of Minimum-Redundancy Codes". The output from Huffman's algorithm can be viewed as a variable-length code table for encoding a source symbol (such as a character in a file). The algorithm derives this table from the estimated probability or frequency of occurrence (weight) for each possible value of the source symbol. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt; Not sure what you think this does, especially since entropy is always 0. That is not the case. Read my entire post "BTW: You can assume the variables are filled with correct data at that point." &gt; You don't define BYTE I'm sorry, i forgot to put that in. Will edit my original post with that. &gt; I assume that you are expected to implement Huffman coding No i am not.
Just use any tutorial and do all the exercises in C.
Note that Huffman coding is far from being the best entropy coder as it cannot exactly represent entropies that aren't entire bits. Something like arithmetic codinig, range coding, or ANS is much better.
http://www.geeksforgeeks.org/dynamic-programming/
No, it won't :) 
I'm really confused by some aspects of your code. You're not using any of those chars you declared, right? Is that just for your own reference? You can probably use a boolean array for your available doctors as well as your rooms, although that will get pretty messy. 
Unfortunately this is a sub for the C language, not C\#. The difference is very important. However, if it's like (I think it's) in Java, the capitalized versions are classes like any other, so they can be used when an Object (or a subclass thereof) is needed, but in exchange they have the overhead objects have.
What do you mean when you say it can't represent entropies that aren't entire bits? 
For my reference. I've taken out the char and commented them out now. I'll have a look into boolean arrays
The surgery needs a computer program to provide self-service to patients. The program can be used from a console (e.g. touch screen) in the waiting area. Patients use this console to check in on arrival to the surgery. They can also use the console to enquire about their position in the waiting list, or to find out how many doctors are currently available at the surgery. The program is also used by doctors to check out (discharge) patients when they have finished examining them. Doctors use the program as well to check in and out of their rooms. The program must maintain a waiting list (queue) of all checked in patients, and as soon as one of the doctors is free, the program must call on the next patient in the queue by displaying a message similar to this: Patient ###, please go to Room ## Where ### is the patient‚Äôs unique id number, and ## is the number of the free room. When a doctor is finished treating a patient, the doctor must check out (discharge) this patient using the console. We are assuming an over-simplified setting where doctors use the same console as patients. In a real situation, however, each doctor will have their own console on their desk. However, this will require programming methods that we have not yet learned. The program must provide a Command Line Interface (CLI) accepting a number of different commands. A CLI is similar in working principle to the Linux shell we are already familiar with. A program using a CLI waits for the user to type in a command and when the user hits the Enter key the command is immediately executed; the program then waits for another command. To indicate that it is ready to accept commands, the program displays a command prompt (e.g. &gt;&gt;&gt;) at the beginning of a new line. The program accepts two types of commands: patient commands and administrator commands. Only doctors and surgery staff can use the admin commands. For simplicity, each command is comprised of one letter only. Some commands take an argument (e.g. number) that must be provided after the command name.
If you have three symbols, each with a probability of 1/3 (1.585 bits), a Huffman code assigns one of the symbols a one bit code and two of them a two bit code. This is suboptimal as this generates expected 5/3 = 1.67 bits per word instead of the optimal 1.585 bits. Huffman codes are only optimal if the probability of each word is a power of 1/2, i.e. if their entropy is a whole number of bits.
 system(eingabe); This tries to run the contents of `eingabe` in the shell (like you typed it into your system shell). In linux, it tries to find and execute `Test.txt` in one of the paths in the environment variable `PATH`, in wich by default the current directory is not there. In Windows, you may want to change the file name to be the extension `.bat` if you want to execute them as batch files.
Well, you didn't tell us what the assignment was nor explain how your program is supposed to work and why, so what exactly did you expect?
C# is off topic in this subreddit. Please post C# questions elsewhere, e.g. in /r/csharp.
I'm sorry but i think the variable names speak for themselves... &gt; explain how your program is supposed to work and why, so what exactly did you expect? I tried to explain it briefly but if you need more information just ask?
&gt; I'm sorry but i think the variable names speak for themselves... hahahahahahahah snort hahahahahaha snort gasp hahahaha
Why are you being such a dick?
Two things: c [needs to be an int](http://c-faq.com/stdio/getcharc.html), and [don't use feof() as a loop condition](https://latedev.wordpress.com/2012/12/04/all-about-eof/).
 &gt; c needs to be an int If i understand that correct this is only the case if i would be checking c for eof in the loop right? &gt; don't use feof() as a loop condition So instead i would be doing this: while ((c = fgetc(src)) != NULL) and defince c as char but keep my encodedC as unsigned?
c needs to be an int. fgetc(), getchar() etc. do not return chars, they don't return pointers (so comparing its result against NULL is silly). They return ints. That first link explains why and has an example of how to read a character at a time in a loop. After verifying c is not EOF like the example does you can then safely assign it to an unsigned char without any loss of data.
So i define c as int and the while header as follows: while ((c = fgetc(src)) != EOF) correct?
Yes, that's correct.
You don't need complete knowledge of the input for huffman to work. There is an adaptive method. But huffman encoding is often used in many different fileformats commonly used today (for example as last step in jpeg or zip) . It's simpler and perhaps faster than the more efficient arithmetic encoding (in real world situations), which is also commonly used in fileformats. 
Many people believe they can write self-documenting code. Very people can actually pull that off. Always write comments that explain your code's intent. However, the code in your question is actually very well commented, so I'm not sure what /u/a4qbfb's point was.
also, please excuse the indentation, i'm not sure how the formatting works on this
If the problem is that the sum seems to be random, it's because you aren't setting `sum` to 0, so it has a *random* value. If the problem is something else, tell us, because I'm not seeing anything else.
Looks OK and works OK to me, except ensure that `add` is initialized to 0 first
this is the output that I get: Welcome to the Deviation Calculator ************************************ Please enter a value: 1 Please enter a value: 2 Please enter a value: 3 Please enter a value: 4 Please enter a value: 5 Please enter a value: 6 Please enter a value: 7 Please enter a value: 8 Please enter a value: 9 Please enter a value: 0 Value: 1 Value: 2 Value: 3 Value: 4 Value: 5 Value: 6 Value: 7 Value: 8 Value: 9 Value: 0 The total of all the values you've entered are: 96294493 Inspiron-5567:~/Desktop/IPC144_Assignment_Two2$ 
Ah, I see. Thanks! Looking briefly into it, it sounds like Huffman can be altered to make it much closer to optimum, but arithmetic encoding gets closer out of the box. Another thing on the reading list, I guess!
never mind, i just changed add to 0 works like a charm thanks
Looks into these tools... Dynamic linker, ELF, SHIM, etc.
I think you're thinking dynamic linking, which is a different topic.
Are the doctors and the patients going to all be using the same console in the waiting room. In other words, do you plan your system to be one program running on one and only one computer? Or is it more the case that you plan on having a console in the waiting room for the patients to uses _and_ programs running on computers in each exam room for the doctors to use? If it the latter, you are trying to develop a multi-user system. To do this, you will need to have a way for the processes on each machine to communicate with each other and you will need a way for all of the different processes to share state. Judging from your stated requirements you are trying to develop a multi-user distributed system. Furthermore since different users can perform functions in pretty much any order asynchronously, you will most likely want your system to be event driven. You could accomplish this in a few different ways: 1. SSH - since you are specifying a text user interface, you could have one computer act as a server running all of the process and the other computers (the clients) could use SSH to display the interface. 2. RDP/X remote - run all of the programs on one computer and use RDP/X remote to display the interface on the other computers 3. client/server - you could write your program as a client/server system using sockets to communicate 4. fat client - you could use a database server or a file server to hold the program state while all the logic runs on the clients 5. existing servers - you could use an existing server such as a web server/IRC server/MQTT server/message server to handle the state and communication 6. framework - you could use a framework such as [zeromq](http://zeromq.org/) to handle communications 7. GUI toolkit - some GUI toolkits have classes for client/server programs 8. embedded system - use a Raspberry Pi for the console and use the GPIO pins wired to switches in the exam room that lets the doctors change the status of their exam room 
This looks like something of the form: { int a; int b; /*... */ b = a++; } 
when initializing an struct you can specify the "member" of the struct that you want to give an specific value. In that case you are initializing the function pointer.
So then is this equivalent to doing something like: `Namespace.func1 = func1;` ?
yes.
No problem, you might like to read this article [The new C: Declarations &amp; Initializations](http://www.drdobbs.com/the-new-c-declarations-initializations/184401377) check section **Designated Initializers**
It's called a **compound initializer**
No.
Ok, thanks!
&gt; However, the code in your question is actually very well commented No. No, it isn't. There is no explanation of code's purpose or of the algorithm it uses to achieve that purpose. Most of the comments just repeat the code below them. The text that precedes the code suggests that the assignment was to implement a Huffman code, but OP says it wasn't, but can't explain what it actually was.
&gt; There is an adaptive method. ...which does not compress as well and is slower than other algorithms specifically designed for streaming. &gt; But huffman encoding is often used in many different fileformats commonly used today (for example as last step in jpeg or zip) Yes, it's used as a final stage once the the output of a previous stage is fully known. In the case of JPEG, for instance, DCT is used to compress individual pixel groups, but does not address similarities between groups, so Huffman is used as a final step once the entire image has been processed. And IIRC it's not even applied to the entire file, but to individual sections.
Yes. Originally, you had to list the values of all members in order. If you added, removed or reordered members, you would also have to change all initializers, and you'd also have to initialize every member regardless of whether it was needed. Designated initializers allow you to initialize only the members that need initializing, in any order, by naming them. This makes the initializer far more readable and in many cases saves you from having to update every initializer if the struct changes. I've written table-driven code with dozens or hundreds of pre-initialized structs; that would have been a nightmare without designated initializers. Note that there is a similar syntax to initialize specific members of an array: int a[5] = { [2] = 23, [4] = 42, }; Also note that I used a trailing comma after the last element in the list, which is permitted (since C99, if I remember correctly?) but not required. The reason for this is that when you add or remove an element at the end of the list, you don't also have to add or remove a comma on a different line. This makes diffs far easier to read.
Note that the ability to do so in C++ (and some other languages) is highly controversial, partly because it is often abused and partly because overloading an operator does not change its precedence, which is based on its original meaning.
&gt; ...which does not compress as well and is slower than other algorithms specifically designed for streaming. Huffman was probably not designed for streaming, and it's efficiency depends greatly on the distribution. But i am surprised when you compare it to streaming compression algorithms. If you are thinking of algorithm's for streaming sound/video (usually lossy) or just lempel-ziv derivatives then all of those are way more complex and requires more logic and memory comparisons than little old adaptive or non-adaptive huffman, which can be implemented entirely in as little as 8 KB L1 cache in C. It's going to go at pretty much CPU max speed no matter the distribution (* assuming implementor isn't daft). I just don't understand why people underestimate something as simple as huffman encoding, it's pretty neat for it's use and could probably be used more than it is.
So you are packing things down to smallest number of bits per character. How are you going to decode this? I don't see any symbols indicating that the following code is 1, 2, .. 7 bit big. If what you want is to compress something with similar distribution to the English dictionary, then you could with great benefit, like /u/a4qbfb suggested, use huffman or arithmetic encoding.
The encoded file contains the ASCII Characters with the lowest and then the one with the highest value, followed by the encoded text. That way you can calculate everything you need from the first 2 characters to have the information needed for decoding. While this may not be the most efficient encryption mechanism it's mostly chosen to teach bitoperations in c. Hope i cleared that up.
&gt; Huffman was probably not designed for streaming, I never said it was. &gt; and it's efficiency depends greatly on the distribution. I never said it doesn't. &gt; But i am surprised when you compare it to streaming compression algorithms. Why? It's entirely relevant. Different algorithms for different purposes. There is a balance to be struck between compression ratio, memory usage, CPU usage, advance knowledge etc. &gt; I just don't understand why people underestimate something as simple as huffman encoding I was the one advocating it, remember?
`WINDOW` is a macro with one parameter
Look at `bufferf.c` and `buffercf.c`. `WINDOW` is a macro, that is defined as one of either #define WINDOW(name) LIQUID_CONCAT(windowf, name) or #define WINDOW(name) LIQUID_CONCAT(windowcf, name) After that, `buffer.c` is included. So this is really just a way to define two copies of the struct with similar names (`windowf_s` and `windowcf_s`) without having to write the code twice. The person that wrote this apparently loves abusing the preprocessor. What you are seeing is not actual C syntax; view the source after preprocessing if it's still confusing. 
Ohhh that makes so much more sense now! I didn't realise it was a macro! Thanks that makes it much clearer! 
Thanks! I guess I'm not seasoned enough to think that it could be a macro. Much clearer now.
One of the main reasons I don't write in C++ anymore is because of the abuse of operator overloading and function overloading in the community. I don't think there has ever been an instance including with mathematical vectors/matrices or strings, that I preferred an overload operator/function to a "normal" function call. Some C++ libraries feel like they include overloading for the sake of using language features rather than for code clarity.
What is `clock.reset()` supposed to do?
I think you are mixing up designated initializer and compound literal
Also note that this is a C99 feature
By convention, identifiers in all-caps are macros. Of course that's not enforced by the compiler so it's not always true, but it's usually an indicator of how to approach things when digging through someone else's code.
&gt; Also, how to determine the time complexity of this solution? That question is meaningless in this case since the input is dimensionless.
Probably https://www.sfml-dev.org/documentation/1.6/classsf_1_1Clock.php#ae7d8de6876d51fa16675a64c649570ec (Doesn't exists in newer version it seems) The closest thing in SDL I could find is `Timer`, but it just periodically calls an callback functions after an specified time. 
Couldn't understand what you meant by dimensionless. 
The time it takes your code to execute does not vary for different inputs (x,p,n,y) - from a big-o point of view it's constant time.
The complexity of a piece of code is an expression of how much time or space it requires as a function of the size of the input. In this case, the input has no size. It is not a list (one dimension) or a matrix (two or more dimensions) or anything like that; it is a single number (zero dimensions). Therefore, it makes no sense to speak of complexity. (Note: I can see at least three different ways a pedant could insist that it does in fact have a dimension and that its running time is either constant or linear, depending on which interpretation they choose. To those pedants, I say: get stuffed.)
Practice. Write programs, easy ones. Grab a book on basic C programming with examples and try to write the programs from the examples without looking at them. If you hesitate look at the book. Solve the exercises. It‚Äôs the only way: program. 
Chibi Scheme or Lua. Both small and designed to be embedded scripting languages.
There's [LuaJIT](https://luajit.org/luajit.html), which is a re-implementation of lua but uses a JIT, so it is pretty fast. AFAIK it tries to be a drop-in replacement of the default lua interpreter. It comes with a library called [FFI](https://luajit.org/ext_ffi.html) that can be used to call C functions with C structures. To call a lua function from C, it's a bit harder. There's [`https://www.lua.org/manual/5.1/manual.html#lua_call`] and [`lua_pcall`](https://www.lua.org/manual/5.1/manual.html#lua_pcall), but you need to setup the lua stack to pass parameters and the function. ([somewhat complicated example](https://www.lua.org/pil/25.3.html))
I see, that's exactly what I thought. Thanks for confirming. I practice with reading the text, trying to code it and then looking at the example. Taking a break, removing and trying again. But, the thing is that some parts are hard for me to understand like "what it actually does/what it's good for". I have a pretty good memory so, just writing will be easier and easier. Just want to understand, but that's the missing part sometimes and a big struggle.
Lua is crazy good for this, but if you have room to spare, you could try Python.
What, no love for TCL? Personally i prefer JimTCL since its small enough to understand and hack without too much trouble.
ah LuaJIT I'd almost forgotten about that one...
To add on to the (obviously) good suggestions of Lua, I‚Äôve heard Tcl is a pretty good scripting language as well. I‚Äôd love to hear from someone else on here that‚Äôs actually used it- from my understanding, it‚Äôs extremely lightweight, which makes it especially suitable for certain requirements.
Yes I misunderstood. Dynamic programming is a very broad subject and there is no one simple solution... What are you attempting to accomplish? As in... Which aspect are you looking to figure out? There are specific tools/methods that are used to gain the results you may be looking for. There is an app on Android called "Algorithm Visualizer" it's an excellent application and has helped a great deal with some of my problems. Also take a look at... Dynamic code generation/generator Compilation methods Lexical analysis Tree pattern matching Static-Analyzer Lastly, a simple tutorial is not enough for this... I suggest a book... The best book I have found is "Dynamic Programming" by: Richard Bellman 
1. The function is supposed to return something but never returns anything. 2. You have not quite understood what it means to pass a pointer value into a function, and what happens if the function updates the argument that receives that pointer value. To demonstrate this point consider: NodeT *root = NULL; Book book; insertT(root, book); Your implementation of `insertT()` will execute the line: `p = allocateNoteT(book);`. The key fact is that `root` in the calling context and `p` inside `insertT()` are separate, independent variables. The value held by `root` is _copied_ into the parameter `p` when the function is called, and any further updates to `p` have no impact on the `root` variable itself. _Assigning to `p` does not change `root`._ Since `insertT` does not return anything, and cannot update the variables used as arguments to it, allocated nodes are always just dropped on the floor. This applies recursively too: `insertT(p-&gt;pLeft, book)` cannot update `p-&gt;pLeft` or ever insert anything into `p`'s left subtree if it exists. 3. Finally, your code does not handle the case where the book comparison results in a value that is neither `&gt; 0` nor `&lt; 0`.
In general, uppercase means macro.
First of all, it's nicer to deal with code if you share it from something like pastebin or gist.github.com, rather than a photo. It's also nice to include the source of functions used in the sample, so we can check to see if you're using them correctly. That being said, here are a few things I notice: 1. Your return type is NodeT, but you never return anything. 2. If you've just allocated a new node, you shouldn't need to compare it with the book you passed in. You can just return immediately. 3. You declare NodeT *t, and never use it. 4. You don't have a good understanding of pointers and function arguments / stack variables. Compile this program and try to guess what its output will be. If it isn't what you expect, try to understand why, and don't be afraid to write tiny programs to test your assumptions: https://gist.github.com/GavinHigham/f0e10aad496dbd5b0eee590338b2948d
I appologize for being vague but because this is an assignment I dont want to bring attention to myself. Also if anybody had advice on how to duplicate a node in a struct linked list (with a given position) I would appreciate it.
This seems like homework to me. Anyways, you would find a terminating value in the function named recursive and check the input for it. Otherwise you would call recursive again with an updated value. I didn't really try to see what your program did, but it will help you in the long run to determine if you should use recursion and how to do it. 
void recursive(long mod){ if(mod &gt; 0){ printf("%li",mod%2); recursive(mod/2); } } I guess this is the solution if i understand correct.
Pardon me, I am rather new to programming... is there some place I can read into using multiple programming languages for one program? I have known it could be done but have been confused as to how exactly it is done.
There are multiple ways you can do this. There's FFI: https://en.m.wikipedia.org/wiki/Foreign_function_interface And then you can run an interpreter inside of a C program: http://lua-users.org/wiki/SimpleLuaApiExample Sorry about my brevity. I'm on the phone, but basically there are multiple ways you can achieve this, and this is not all of them.
**Foreign function interface** A foreign function interface (FFI) is a mechanism by which a program written in one programming language can call routines or make use of services written in another. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Well, thank you. I should be able to work from there.
uh, my bad, sorry for the confusion 
Use the `const` keyword. `const int a = 10;`
Updated the question :) @H-E-X 
I've used Tcl (as DejaGNU) for years. I'm not a big fan, I'd much prefer Python for almost any task.
You could just assign it a value once and don't reassign it.
Write a function that returns your value. Write another function that keeps track of if it's already been called, and generates an error if so, otherwise sets the value. Put these and the variable holding the value into a separate file and provide a header with prototypes for the functions. Or just only assign a variable once and don't ever assign a new value to it.
Basically you can do struct with value itself and bool, which keeps track if it was changed.
[removed]
You can‚Äôt. And it doesn‚Äôt make any sense to me. You can wrap your variable in a function if you insist (assuming the variable holds an int != 0): int value(int newval) /* Pass 0 to get the value or anything else to set it */ { static int val = 0; if (newval != 0) { /* Set the value */ if (val != 0) { /* Already set */ abort(); } val = newval; } return val; } 
What is cgg? Oh, you mean gcc. So you have an object file (.o file) and you want your code back? You can't get it back verbatim. Have a look here for further details: https://stackoverflow.com/questions/29179620/how-to-convert-a-o-file-back-to-a-c-file-in-c
Ups i misspeled my bad yeah i meany gcc
Based on a quick google search, you are looking for a decompiler. [This page](http://boomerang.sourceforge.net/lostsource.php) might help. 
Ok thank you
Generally, it's not easy to do that. Your best bet is to learn the assembly language for the target you compiled the source for and then reconstruct the logic. This is very difficult though, the people who do this professionally get paid very good money to do this sort of thing.
That's not supported in C. You can build things that behave like that using a structure and a flag, but it's always possible to get around that rule and the performance suffers. I recommend you to find a different solution to whatever problem you were trying to solve using this approach.
Consider extending the code to use a generic `morecore` routine to get more memory instead of hard-coding `sbrk`. For example, on arm64 FreeBSD, `sbrk` is unavailable and your code won't compile, if you provided this abstraction I could easily update it to use `mmap()` instead.
Thank you very much its not very hard to reproduce i ll do it.
Please put four blanks in front of every line of code so reddit formats the code properly. Right now, it's rather hard to read.
You can use ollydbg, windbg on windows, gdb on linux. The best is IDA https://www.hex-rays.com/products/ida/support/download_freeware.shtml
Thx
The C language is not concerned with this sort of thing. You need to use a library to do graphics, depending on what exactly you want to do there are different suggestions for what library to use. For graphing things, my suggestion is to make your program generate a `gnuplot` input file and then invoke `gnuplot` using `system()` to display the graph. I think `gnuplot` is also available as a library, you could use that. If you just want to do graphics, I recommend you to use the SDL library.
I am a begginner and I would also love to know. I mean, you can do pretty much anything with C, no? Just not with the same efficiency that other higher level languages would have, right?
Yes it is. Fuck off.
Good job so far building out part 1. Basically what you are looking at is working through the program's control flow. What you've started doing is whats considered "inlining" your control flow instead of breaking out into the requested functions: In makeMove, you are doing the part 2 directly in the function body, instead your instructions are to utilize the given functions 'validMove' and 'checkWinner'. So instead of: if(board[row-1][col-1]=='O'||board[row-1][col-1]=='X'){ printf("\nThis position is already filled.. enter another position..."); makeMove(board,player); return; // missing this in your code } You should be building out the logical flow using the given functions: void makeMove(char board[][3], char player) { int row, col; printf("\nEnter row and column you would like to fill:"); scanf("%d%d", &amp;row, &amp;col); int valid = validMove(board, row, col); if (valid == 0) { // "That move is not on the board" // Display the board and ask for a new move return; } if (valid == 2) { // "That move has already been entered" // Display the board and ask for a new move return; } // if (valid == 1) { // Move is valid, continue below to fill it in // } board[row - 1][col - 1] = player; // Now check if the board has a winner and display it if (checkWinner(board)) { // Display the board and the winner // "O wins!" return; } } Then the new functions should do the actual checking and return a usable value. // validMove should verify if the current move can be played // Returns 0 If row or column not on the board // Returns 1 If move is valid // Returns 2 If position has already been filled int validMove(char board[][3], int row, int column) { // TODO: Check the move and return the appropriate value return 1; } // Check if we have a winner int checkWinner(char board[][3]) { // TODO: If board has a winning position, return 1 return 0; } You don't have to logically throw everything in the makeMove function either. Its up to you to understand the program flow and logically map out the gameplay. 
Thank you all. I solved my problem without the need to protect my variable. I had to first set the variable by a process then protect it from changing by other processes "Parallel Program".
If it's just a video you want to create, you can [render it yourself](http://nullprogram.com/blog/2017/11/03/) and output the raw video frames.
I have had good results from the library cairo.h. I have found working with C and graphics very enjoyable, reminds me of the Commodore64 of my youth in a strange way.
SDL is good, but for beginners a graphics library that I always thought was very easy to get into is Allegro http://liballeg.org/ It's a fast-and-easy solution imo and gets the job done efficiently once you get the hang of it. Even if you don't know much of OpenGL you can still draw complex graphics like pictures, squares and text just by using the super simple API. It's also open source and cross-platform if you care about that.
&gt;efficiency Coding efficiency, probably not because you've got more manual overhead you need to keep track of... But the code itself can, and usually does, definitely end up being more space, time, and power efficient than other languages where you need to link in a bunch of other files or spin up a dedicated VM to execute said code -- but these gains are largely up to your management of the aforementioned overhead. But yes, C is Turing Complete. You can do anything with C that a computer can do.
Declaring a static variable inside the scope of a function? How are you to retrieve it?
First compile with -Wall (or your compiler equivalent) and check what other compiler flags your compiler provides for Diagnostics. Also check your libc implementation for runtime diagnostics. I know gnu libc have some stuff in malloc and free that can signal a few problems, but cause slower performance so should only be used in debugging builds. Many modern compilers support Google's sanitizers (usually -fsanitize), those can help too. Other than that, there's not much one can do other than run through Valgrind or change to a "safer" language, at least as far as I know.
1. Use `struct text` instead of simply `text` (since you never `typedef` it) 2. You never defined `new` as a type, only as a function (which is probably tried to access the members of but can't) 3. You always return `NULL`. There is also no `malloc` or similar. 4. Give your function a better name, indicating it creates a new text object (eg. `text_new` rather than simply `new`)
#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; void recursive(long); //modulus operator finds remainder int main () { long decimal; //long binary[10]; long mod; long i; puts("Welcome to the DecimalToBinaryCalculator"); printf("****************************************\n"); printf("Please enter a decimal number: "); scanf("%li",&amp;mod); if (mod==0) { printf("ERROR 404 &gt;&gt; You entered a zero, program does not compute!"); } else { recursive(mod); } puts("\n\nThank You for using the DecimalToBinaryCalculator"); return 0; } void recursive (long mod) { long i=0; long binary[10]; if (mod&gt;0) { i++; binary[i]=mod%2; mod=mod/2; recursive(mod); printf("%li",binary[i]); } } 
I tend to do pedantic as well as -Wall ! I'll check out sanitizers.... hoping this was just a trick I was missing, looks like I just have to look harder when these things happen!
 void recursive (long mod) { long i=0; long binary[10]; if (mod&gt;0) { i++; binary[i]=mod%2; mod=mod/2; recursive(mod); printf("%li",binary[i]); } } 
thanks bro, i worked on it all night, and i guess it finally worked... appreciate it...
yep, it is homework, one of the programs i had to do, i finished the first programs easily, but i never understood recursion, i guess i finally understand it. thanks bro
I haven't used any "graphical" library when writing my small C programs. Although I have read a bunch of tutorials to learn the basics. That said and if I understood what you wrote, here are my humble suggestions: * ncurses - https://www.gnu.org/software/ncurses/ * termbox - https://github.com/nsf/termbox I have tried OpenGL in the past week, using a short tutorial for a college assignment, and I think it's way too much for what you probably want. **Cheers**
also i deleted the main post because it was resolved, but i can still post the original code if you want...
Also, op is dereferencing the pointer but then still trying to access its members as if it were a pointer
Setting size to be strlen - 1 seems very suspicious. The comment says it makes a _copy_ of the given string. It does not. Notice that a text struct only holds a pointer to a string - it does not have space for a copy of the string. 
I‚Äôd use specialized software for data visualization. Spit out the numbers to stdout and feed them to e.g. *gnuplot* (a bit old school, ugly defaults but very easy to use) or a python script using *matplotlib* (state of the art, very beautiful but also a bit complicated).
I see. I've also scratched the surface of higher level langs like Java, C++, python, etc., but for some reason none of them have the same appeal of C to me, I just like how precise it is. Having said that, I wonder how one could make a living with C alone? All I've heard of is that C is used only for OS/compiler making, are these the only things I can use C without any other languages doing it better? I mean, I totally understand that a &lt;vector&gt; is easier to implement and work with than an array, but working with an array provides you optimisation options you couldn't do with a vector, which leads me to believe that any program properly optimised written in C, even though it would take a huge amount of time to write depending on its size, would be "better" (more efficient I guess in terms of processing time and memory allocation for example) than its code written in high level language. Well, basically what I'm saying is I love C and would love to work with it, what could I do? If OS's and compilers are it's only cost-benefit application, what parts of it would a begginner be able to understand and work with? Thanks.
Embedded developers are in high demand.
What is an embedded developer? Thank you very much.
I'm an embedded developer. Can confirm, do use C and also some assembly and C++. Also, it's awesome--10/10, would recommend.
Cool! I love C and arduinos, also computer architecture in general, think I'm in the right track? Also, would you please give me an example of why would you prefer C++ or assembly over C? Thanks.
&gt; gcc (and almost all the compilers I‚Äôve dealt with) works in a conservative way and assumes that the programmer doesn‚Äôt care about aliasing rules and it tries to not to insert very subtle bugs. Let‚Äôs try to tell gcc to abide by the standard with a proper flag (-fstrict-aliasing) I wouldn't say that's accurate. GCC doesn't do any optimization by default, but strict aliasing is enabled for you at -O2 or above. &gt; Of course C++ is a different language than C, but it inherited a lot of rules from the latter. Aliasing is no exception, From what I know of the history, C++ actually invented strict aliasing. It was then copied into the C spec.
Is morecore something I would implement myself, then add a bunch of ifdefs inside of it to select which memory allocation technique to use for each platform?
Yes, exactly like this!
Welcome to systems programming!
Didn't realize that Cairo already has Rust [bindings](https://github.com/gtk-rs/cairo).
Thanks, I guess!
What happened to this article? It's 404ing.
Aw man, I'd like to get into embedded but there is little to nothing in the way of jobs. And even less for entry level where I am.
I really like C aswell but prefer to use C++ since it can do everything C can, plus it has more built-in features/data-types, so in general it takes less code to do the same thing.
I've had good luck with the tried and true "K&amp;R". You shouldn't need any books beyond that, tbh. Another good book, though it feels fairly childish (but still works), is Head First C. Also, I'd recommend looking into books on algorithms, though I'm not sure whay you recommend there. If those C books don't work for you, look into courses on Udemy. 
**Howdy,** I'm not entirely sure if you need a book for that. The truth is that books are great, right? But once you get to a point, as you said, mastered the basics everything else should be a matter of hands-on (getting to code as much as possible [imho]). You just need to find something cool to code and that should push you forward (by forcing you to learn new concepts, etc). Now if you still think you need some books, here is some list I find interesting (in order of importance to me): * http://fabiensanglard.net/c/ * http://www.iso-9899.info/wiki/Books * https://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list/562377#562377 ps: keep in mind that one or other link should interfere with the suggestion of another one. Just think for yourself and see what is best. Cheers.
Hmm I imagined it would be that. I'm supposing C and assembly are reserved for when the hardware is has memory and processing constraints.
The easiest way to get data visualizations out of your C program is to generate datafiles and instructions for `gnuplot`, a well understood scriptable graphing tool common in science and academia. Don't reinvent your own basic graphics program when excellent ones already exist for most tasks.
&gt; You need to use a library to do graphics No you don't. You could. If the interest isn't there, then you should. But you don't need to, as in there is no other possible way.
Also use -Wextra with -Wall. The trouble with sanitizers and Valgrind is that you need to have "coverage", meaning that if you don't execute a branch of the code with a memory corruption bug then it won't reveal itself. So pairing the sanitizers and Valgrind with some testing really helps, try to write tests to exercise as many branches of your code as possible. If you are using gcc for "production" builds, try using clang and run your tests with both a gcc and clang produced binary. Sometimes you'll get better/different compiler warnings and sanitizer catches using different compilers.
My suggestion would be to learn similar languages . Php for scripting . Lisp (will be super duper useful for machine learning). And C++ . They are all similar to C and are going to help you get jobs as well.
Machine learning is also one of my topics of interest. Good suggestions!
Can you point to any material on how to create graphics completely from scratch in C?
I was using Allegro to make games in DOS in my teens like 20 years ago. It's good stuff.
I think he means it is possible to implement an off-screen rendering context, draw into that, and write that to disk, all without using a third-party library. I mean, third party libraries themselves are often written in C too, so it's definitely possible to do everything required without using a library.
Classic: K&amp;R
my suggestion is: https://www.goodreads.com/book/show/198207.Expert_C_Programming it is quite fun to read and very informal in my opinion. It also gives you little coding challenges. The book is also a little old, so some things may not apply 100% to your system, but it is still filled with valuable information.
1. You can do it via the console by using a library like ncurses to render directly in a terminal and simply redraw the screen. 2. Use a library like libpng to generate a bitmap of the image you want to draw and then save it as a png file. 3. Use SDL / Freeglut / GLFW with OpenGL to render an image. 4. Use the GtkDrawingArea with GTK for rendering.
Yes. Consider buying the hardback.
C Unleashed is pretty good. https://www.amazon.com/C-Unleashed-Richard-Heathfield/dp/0672318962
Ofc he will need more than K&amp;R. That is ANSI C. He needs to know a lot that was implemented in C99,11. K&amp;R still taught a lot of things that are well recognized as "wrong" nowadays! 
Get King's Book. It covers ANSI C and C99. While K&amp;R is concise and outdated. King's Book explains all topics in a good depth, clear examples. King teaches you as a teacher and won't leave you with doubts. 
Sounds like you're probably on the right track! :-) As far as assembly goes, sometimes you just need it. If you're writing intial startup code, or some stuff that's really close to the hardware, there's not much other choice. I happen to love assembly, so I get excited when I get to do those things. You also end up looking at a ton of compiler generated assembly when debugging, which is cool because you start to get a feel for what the compiler will output for various inputs. C++ is a little different. For most lower level things, I don't really prefer it over C, but if used correctly it can assist in the creation of highly modular code, which can be especially handy if/when designing UIs. If you've only got a tiny screen to work with and you have to write everything from scratch, the ability to reuse code becomes important. C++ is nice because it's incredibly easy to integrate with C/ASM and the code generated by most compilers I've used ends up being pretty reasonable most of the time. That said, there are a fair number of reasons for not using C++ in smaller embedded projects and one of them is that there's enough going on in the language that if you don't know what you're doing you can easily end up with a bunch of junk. Still, it has its place and you may end up working on a project that uses it, so it's not a bad idea to familiarize yourself with it a bit (as secondary to C).
Those kind of errors occur some times and it's important to fix it as quick as possible in order to keep your code safety. Those errors can be handled right after they are detected. If it's getting too hard for you there are programs that help doing that, such as checkamrx and others that work fine.
As a beginner I would recommend starting with C and also make sure you code slowly and detect vulnerabilities among your code. That's how you ensure "code security". You can also use a app to do that. I know one called Checkmarx if you want to try. Good luck!
If we're talking libraries for graphical work, I found Raylib comparatively intuitive to learn. If you check their model rendering examples, you could certainly make a few tweaks to render graphs or 3-d representations. ie. use a for loop to render shapes, each shape smaller than the next, extending off for an arbitrarily long distance. We're a friendly community, and I'd be happy to walk you through raylib if you want. 
Interesting, thanks for the detailed answer! I still don't know anything about assembly but it is currently the language I want to learn the most, but I was worried it could be a waste of time since it's rarely used anymore, but it actually is the best language to do REALLY low-level stuff, it seems, so I'll definetly be learning it in the near future. As for C++ I'm already learning it and it's fine as far as higher level languages than C goes, because you can still do some pretty low-level stuff with it. My problem with high level languages so far (I'm just a humble begginner so I may change my mind) is that it often abstract too much to the point I lose track of what I'm doing. I find those huge Java keywords (is this the right term?) more misleading than helpful when it is a bigger program and just the sheer amount of words in any Java code makes me feel lost tbh. Maybe it's because I'm still beggining to learn it but I was actually a lot more comfortable learning C the first time as my first language than Java after already having a bit of experience in C/++. Having said that, I'm aware you can do a lot "more stuff" with fewer lines of code in Java than in C. But really, no pointers? How am I supposed to optimize both data structures and allocation? No wonder why any executables right now takes all your RAM. But maybe Java and other high level languages optimises pointers better than I think, I don't know. Thanks again for the info, it's good to know there is still place for low level langs!
Exactly my point.
If only there was a web site you could go to and enter some words of what you're trying to find and it returns links to web sites with that information. Seriously, I tinkered with this in the late 70s and worked with it at Pixar and SGI when GL was a brand new thing and not openGL. There are tons of books and online information.
I'm asking precisely because searches will invariably come up with openGL, of SDL, or other libraries. Since you sounded like you knew what you were talking about I thought I's ask. Sorry!
The trick, with C, is including "in c " with the space before and after the 'c'. So [this works but should be tinkered with.](https://www.google.com/search?q=graphics+programming+%22in+c+%22&amp;oq=graphics+programming+%22in+c+%22&amp;aqs=chrome..69i57.5031j0j4&amp;sourceid=chrome&amp;ie=UTF-8) I don't have time to go through my old bookmarks.
Doesn't really count as graphics if you can't see it. I guess you could argue that image processing would count as graphics, but I don't think that's what OP is after.
What is your question exactly? Float is spelled wrong in the declaration for starters.
indent your code with 4 Spaces as described in the submission guide
Sorry but would you have a link or more precise reference than "king's book" please?
Seconding SDL. The documentation is a bit... lacking, at least in my opinion, but I've never had any problems with performance or bugs.
C Programming: A Modern Approach, 2nd Edition - K. N. King 
Thanks!
King's book is enough to learn C. Later you will need a good reference book and C draft : C: A Reference Manual, 5th Edition Samuel P. Harbison Drafts: C99 : http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf C11: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf 
further help, just ask!
King's book is enough to learn C. Later you will need a good reference book and C draft : C: A Reference Manual, 5th Edition Samuel P. Harbison Drafts: C99 : http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf C11: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf 
Haven't done it myself, but I get the impression that the PNG format is fairly easy to generate by hand.
nothing beats the netpbm formats when it comes to simplicity though ;-)
On the line that actually declares `add_with_tax()`? Yeah, looks like it.
Looks like an error to me.
Get a decent C book: C Programming: A Modern Approach, 2nd Edition 2nd Edition by K. N. King 
I have this book and just checked the code you mentioned. Mine doesn't have the semicolon I see in your code sample. 
Nah, that's clearly a [Greek question mark](https://pics.me.me/u-003b-u-037e-greek-semicolon-question-mark-programmers-use-this-information-22867695.png).
I'm not sure this code had been tested. The `printf` output likely won't get flushed before the `scanf` calls either.
You might want to get [a better book on C](http://stackoverflow.com/a/562377/253056).
Nice try, K. N. King.
I believe scanf (or something lower in stdio) will fflush(stdout) before reading from stdin. 
No. Definitely not.
It works (on my machine).
what?
It was a joke, but what's wrong with Head First C? It was my introduction to C, and I liked it. A semicolon doesn't ruin the whole book, and you're getting downvotes because buying a brand new book seems unnecessary.
&gt; Also use -Wextra with -Wall. always do! will look at using clang as well as gcc mind...
The error is described in "Errata for Head First C" http://www.oreilly.com/catalog/errata.csp?isbn=0636920015482 
Definitely does. Confirmed empirically on both Linux (Ubuntu) and MacOS. #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; main() { float f; printf("Enter text: "); // sleep(1); scanf("%f", &amp;f); printf("Got %f\n", f); } 
lmao...
That behaviour is not in accordance with the C standard.
According to [this stackoverflow](https://stackoverflow.com/questions/5229096/does-printf-always-flush-the-buffer-on-encountering-a-newline) answer, the C99 standard says &gt; the standard input and standard output streams are fully buffered if and only if the stream can be determined not to refer to an interactive device.
According to [this stackoverflow](https://stackoverflow.com/questions/5229096/does-printf-always-flush-the-buffer-on-encountering-a-newline) answer, the C99 standard says &gt; the standard input and standard output streams are fully buffered if and only if the stream can be determined not to refer to an interactive device.
That has nothing to do with the claim that a write to stdout flushes stdin (which *is* true for C++ and std::cout and std::cin, so I can see why the person claiming that might be confused, especially if they're also using a system that behaves that way as an extension). 
[List of information graphics software](https://en.wikipedia.org/wiki/List_of_information_graphics_software) Scan the interface column for C
&gt; I see. I've also scratched the surface of higher level langs like Java, C++, python, etc., but for some reason none of them have the same appeal of C to me, *I just like how precise it is*. Then perhaps one day you'd consider trying assembler 
I definetly will!
That's correct but not relevant. Assuming stdout is not fully buffered, it must be either unbuffered or line buffered. The standard doesn't specify (in the C90 TC1 text, the only one I have to hand). So the implementation is free to choose. If the implementation chooses to make stdout line buffered in this case, the text printed by printed will not be visible to the user when scanf is called. On the other hand, if stdout is unbuffered, that text will be visible to the user before scanf is called. That's why I phrased my earlier comment the way I did.
What help do you need? The correct format specifier for reading a char is `%c`
hex1 and hex2 are character arrays but you're telling scanf that they should be treated as pointers to unsigned ints of some kind. The standard only defines L in scanf formats for long doubles, so I don't know what int size that's supposed to be assuming it's supported at all as an extension. So a ton of issues in just that one line. If your compiler isn't warning you about this stuff, turn up warning options till it does (-Wall -Wextra for gcc and clang).
Can you explain why i would need 3 separate loops instead of one?
Because you need to add 2 10-digit numbers. At the moment you're adding 2 1-digit numbers 19 times.
That is a horrible font. Where's your code? What's your question? What are you having problems with? 
Please don't post pictures of text. I have removed your post so you can resubmit it with the question as text instead of a picture.
Possibly not what you want, but a website that you could check out is the ##C (irc channel ##C @ irc.freenode.com) wiki website: http://www.iso-9899.info/wiki/Main_Page
tbh I'm totally lost on this project. Could you try creating the code and send it to me please, my code is a mess.
&gt;Can you explain why i would need 3 separate loops instead of one? You shouldn't. That's sloppy code. You should write a routine that inputs your characters, processes them, and returns the correct numerical value, then call that routine twice.
&gt;tbh I'm totally lost on this project. Could you try creating the code and send it to me please, my code is a mess. The best way to learn is to slog through it. Take it slow, one piece at a time.
I‚Äôm willing to help, but I would like to know what your questions are first.
Not entirely sure on the basics, cprogramming.com has plenty of conten here : https://www.cprogramming.com/tutorial/c-tutorial.html There will be many more as I'm sure others will recomment. However, when it comes to network programming check this out - I found it really useful long ago : http://beej.us/guide/bgnet/ 
&gt;round bracket Can we start calling it that?
The first few weeks of Harvard's cs50 course on edx
They are getting a bit old now, but The New Boston's YouTube videos are still great. C Programming Tutorials: https://www.youtube.com/playlist?list=PL6gx4Cwl9DGAKIXv8Yr6nhGJ9Vlcjyymq
Also, any questions about my implementation, I'll be able to answer any questions regarding it. Also, any other better implementations can also be mentioned here for reference and discussion. Finally, I have been told from the instructor that extra credit goes out to those who have the fastest multithreading implementation. Although I'm only asking for help for sorting a CSV, I might come back here to pray to any god out there to point to where the north star is.
the sidebar
is this your intro to a mystery novel? Where is anything you want help on?
anything that I need help on is found in the stackedoverflow link posted above. I'll post it again here: https://stackoverflow.com/questions/47483448/column-entries-missing-when-importing-massive-csv
I've explained the situation here and am willing to explain any other questions that are to follow.
You should post your actual questions here instead of making us go hunting them on another site.
I checked that and it defined the same problem. Let your question resolve the issue!
Here are your links: [sorter.c](https://pastebin.com/NUTTsrgC) [sorter.h](https://pastebin.com/NpVtVLwZ) They were all the way down in your novel :)
my mistake, will be a lot more clear in the future. actually. i'll go edit the post now.
thanks for roasting me. bless your soul lmao
it's all right, :) just sharing the same criticism from my own teacher 
I'd be happy to help you with a specific question (i.e. a question that involves only a few lines of code), but I'm not going to dig through your homework assignment and fix it for you. If you really don't know where to look, then consider starting a new file and carefully implementing one feature at a time, copying over code as needed. First, simply parse the CSV and print individual cells to the screen. Hint: try getline(). Then, invent a data structure to store a variable number of rows with a variable number of cells. Finally, tie in the merge sort. I repeat, do this one step at a time and don't continue until that feature works 100%. You seriously need to work on your coding style and organization; I expect this is the main reason why you're unable to debug your own code and why nobody wants to read it. You seem to have a lot of misconceptions on what header files are for and how to properly organize your code so it is readable, modular, and debuggable. Also, bits like `argv[1] != "-c"` lead me to suspect you don't quite understand how C strings work, which is absolutely crucial for a string processing assignment like this --so read up on that before trying again. 
thank you for the input, at first when creating this code, I tested each feature one by one until up to merge sort. the issue with this is that i created a subsample of the csv that was smaller and tested it on there. I've tried to replicate some modularity, but would like to ask if there are any suggestions in which I can be more clear and precise. Also, thank you for the hint. much appreciated.
Thank you.
Thank you again guys for the help
You got quite close. To add paths to look for include files, you use -I (uppercase i), and I think you have to specify the path in such a way that you can append what you wrote in the `#include` and get the whole path, so `-I/usr/include/SDL`. However, this only gets you the headers, i.e., with this the compiler can know which functions you can use and their types and arguments; the actual functions reside in the library, which you have to include with `-lSDL` (lowercase L), if memory holds.
With -L you specify a directory, not a single header file. Also, if you properly installed SDL, there could be an explicit package configuration which can be used with `pkg-config`. For example, you can use `pkg-config --clibs sdl` to get C compiler flags for the SDL package. I'm on mobile right now so I can't give a full comprehensive answer yet, but maybe this helps a bit. 
You can specify the return yourself. Try the following: int main() { ... return 0; } 
gcc prender.c -o prender.o -I/usr/include/SDL -lSDL -lm 
main is defined by the standard as returning an int. Your code has it not returning anything. Trying to get a return value from such a function is undefined behavior; the OS just thinks it's 13 in this case due to that being a random value stored in wherever a function's return value is normally held in. It could be anything, really.
You are asking the user to type data inside your loop. Is that what you intended? The people who commented on your code mostly did so by mentally "executing" your code as they read it. This is one of the key skills if programming. Practice it yourself, it will come. If you have trouble with that at the beginning, single stepping your code in the debugger can help you understand what the current version of your code actually does.
sorry for the very late reply. My computer broke down and is still isn't fixed so I tried to borrow another one. Anyways your code runs smoothly but the problem is there is no way to input the number of persons and the counting yet. Sorry I just took C 101 this semester for the first time. I'm practically a noob
Thanks a lot ! It worked. Also the fact you mentionned it was an uppercase i and not a lowercase was a huge help
Just out of curiosity, during the runtime, are you hitting enter for that last getch()? If you hit another key does the value change?
Error Numbers (errno) and what they mean for: [Linux](http://man7.org/linux/man-pages/man3/errno.3.html) [Windows](https://msdn.microsoft.com/en-us/library/5814770t.aspx) ps. you'll have to look in the actual header files pps. these aren't really obeyed that strictly, tbh
Just to add a bit to this answer: As the question sounds like you think the exit code of your program helps / notifies you (the developer) of a problem in the program: that is not the case. You as the developer decide which value to return from main (and as /u/raevnos pointed out if you don't it is undefined behaviour). So while you are correct about the exit code being non zero being an indication of a problem with the program, it is used to notify the programs user (in this case user can also mean another program), not the developer. So you as the developer should at make sure to return 0 from your main function if your program ran through without any problem, or nonzero if there was a problem. Even more helpful to the user would be to return an error code from the standard (you find those in errno.h. ENOENT for example has the integer value 2 and means "No such file or directory"). And a fun fact: Your return value is 13 because you are pressing return at the end of your program. So you are sending the ASCII code for carriage return to the getc() function, which is 13. getc() stores that value in the register for the return value (defined by the c calling convetions, on x86 it is register %eax) and as this is your last action %eax is never reassigned, so when the program returns to the system 13 is still in there. But remember, this is undefined behaviour and only happens to happen in this specific case on your specific architecture and using this specific compiler. But my guess is that this is what happens. Try pressing some other keys and see if the return value changes.
No. int a[] = {1,2,3,4,5}; Is equivalent to int a[5] = {1,2,3,4,5};
so if the data type is `char` then will it be equivalent? As in, char a[] = "Test Message"; is equivalent to char *a = "Test Message"; ?
It's just a convention on Unix, more than anything. Your program is free to return whatever it wants to. Whatever that executes the program can use the return code to determine whether there's been an issue or not. The convention is: 0 for success, non zero if there's an error. As you use more C you might notice that lots of libraries tend to create functions with the same convention. Non zero return value means that there has been an issue of sorts that you as the programmer can act upon. Have you ever run a command on *nix that looked like this? ``` # command1 &amp;&amp; command2_that_runs_if_command1_completes_successfully # e.g: cp -R ~/sekrit /var/www &amp;&amp; echo "Success" ``` This runs based off return codes. Which is completely controlled by you. The value that is returned from the function main() is understood as the return code of the program by your operating system.
Well explained. I just want to add another example. If you remove getch(), value 35 is returned which is length of first argument to printf(...), stored in r0 register (aarch64; -fno-stack-protector). 
You can use both these syntaxes when working with arrays as local variables. But when you pass `int a[]` as argument to some function it will decay into `int*` and there will be known as a pointer. Major difference, from what I can remember, is that you can do arithmetic with pointers (i.e. increment, or add a number to them), but not with arrays.
No. The first one is a buffer allocated to the stack as an array of characters (local variable and can be only used in the block where it's defined). You can write to it (not read only) The second one is a pointer that points to a string literal in the memory where "Test Message" is defined. This is read only and you can't change the value of it. You can make it point somewhere else.
It's not UD for any C since C99, because, if omitted, main implicitly returns 0 there. OP just doesn't have a reasonable modern compiler but just MSVC (C98)
Please don't post these.
These are only equivalent when declaring a function argument. Otherwise, they are distinct: The first one declares an array, the second one declares a pointer. While arrays are implicitly converted to pointers under many circumstances, they are not the same thing.
The three backticks notation is not supported by reddit. You need to indent your code examples with four blanks instead.
For the next time: Please post code as text. Do not post images of code!
Well, I used to compare %ERRORLEVEL% with zero many times back when I messed up with batch scripting.
I'd not recommend returning something from errno.h always. Especially since OP is running Windows, the probably best return values are `EXIT_SUCCESS ` and `EXIT_FAILURE` respectively -- these are exit values. One should sparingly use return values / error values as exit values, they are mostly to be used within the code.
The 0/non-zero convention holds inside the C standard library but is purposefully left out for exit values (except, since C99 no `return` in `main` means `return 0`), ie. the "correct" way would be to use the exit values EXIT_SUCCESS and EXIT_FAILURE.
 = "Test Message" is just syntax sugar for = {'T', 'e', 's', 't', ' ', 'M', 'e', 's', 's', 'a', 'g', 'e', '\0'}
No, observe this code: #include &lt;stdio.h&gt; int main() { char *pch1 = "Hello World"; char *pch2 = "Hello World"; char ach[] = "Hello World"; /* * Static string "Hello World" resides in * compiled binary, pch1/2 only point to * this, same, string. * Thus pch1 == pch2. * The pointers themselves are allocated * on the stack. * * The array is completely allocated on * the stack, ie. the data itself resides * there. ach is just a label for that * memory region and it has no address * since it's not saved anywhere. * Thus &amp;ach == ach. * * We observe that addresses of the stack are * higher -- that's because on x86 the stack * is full descending. The stack pointer is * decremented when PUSHing and starts at the * higher addresses. * Also it always points to the last element * pushed. */ printf("pch1: %p, \tpch2: %p\n" // .data "&amp;pch1: %p, \t&amp;pch2: %p\n" // stack "ach: %p, \t&amp;ach: %p\n", // stack pch1, pch2, &amp;pch1, &amp;pch2, ach, &amp;ach); return 0; } 
That network guide is still relevant.
Thanks, I understood the difference when the datatype is `char`, but my question is more focused when the datatype is `int`.
You can write the same with `int` get the same result. Note that writing `"Hello World"` is just a shorthand for `{'H', 'e', ..., 'd', '\0' }`. Thus it's completely legal what you've written. There will be literal `int` array in `.data` holding 3 times `sizeof (int)` of space holding 10, 20, 30 respectively. `a1` is just holding the address to that space.
Sadly this is incorrect. While it's true that string literals basically take on the array form you gave, the compiler will ensure that the given string is stored in the data and will return its address. This doesn't occur for plain literals if you assign them straight to a pointer. Instead, the first element of the array literal (initializer) is used. Check it out here: http://gcc.parallella.org/#%7B%22version%22%3A3%2C%22filterAsm%22%3A%7B%22labels%22%3Atrue%2C%22directives%22%3Atrue%2C%22commentOnly%22%3Atrue%2C%22intel%22%3Atrue%7D%2C%22compilers%22%3A%5B%7B%22sourcez%22%3A%22AQ4KBDQSwOwF2AWwIZwBQEpgG8qmAGMALFAJ2ACoAzAe1uAF5cByACRYBoXouWAdAAwsAvgG58wEUAAA%22%2C%22compiler%22%3A%22g54%22%2C%22options%22%3A%22%22%7D%5D%7D Now, I wasn't too sure about this myself so I made sure to confirm it. I actually don't think I've ever seen a pointer assignment to an array literal. /u/vodico I know this all seems confusing. But your curiosity made you discover an ugly edge of the language, I suppose.
woops, interesting.
 Whenever you state: int x = 0; or char y = 'd'; Your compiler specifically finds a free space in memory (of the relevant size - let's say 4 bits for an int, 8 for a char), the compiler then places your value in that slot of memory and makes a note that it's no longer free. This is the same when you say: int a [4]; Your compiler is now allocating space in memory for 4 integers (in my example there are 4 bits for an int and we're allocating 4 of them so 4 * 4 = 16, 16 bits are reserved in RAM) and then making a note it's no longer free. So now, when you state: int * x; or char * y; Your simply saying: "This is the address of the **first part** of my memory which makes up an int/char" - As in the location of the very first bit. Nothing has been placed at this memory - It could still have previous data in it which is why you then use malloc() to actually block it out and make a note that it's no longer free. So if a pointer is just an address, why do we specify char or int? Well if you dereference the data at the address of pointer x, the compiler will say "ok well you told me that this pointer looks at an int so I'm going to look at 4 bits and return that information to you." If you look at the data a the address of pointer y, the compiler will say "Ok so y was a pointer to a char, let's read the 8 bits and return that" Whenever making a new pointer you must always use malloc to block some space out or it could get used up by another variable or even already be in use.
Strongly recommend CS50 - Sign up on Edx org for free, watch the lectures, sign up through it to Cloud9 so you have access to their IDE and then do their problem sets. It's a brilliant introduction and has taught me what I know! This is a Harvard University course given for free.
What does system("cls"); do? Seems to me that the code would run well without it. 
I couldn't understand the assembly output, but what I understood is that if I do, char *foo = {'H','i','\0'}; then, I can reference only 'H' and there is no way to reference 'i'. Is that correct? 
Not quite, it actually is the same as writing `char *foo = 'H';` meaning that you assign the ASCII value of 'H' (72) to a pointer, which means the pointer willl point to garbage. 
youtube: mycodeschool, handmade hero web: c-faq, cpp reference, fabien sanglard
It clears the console.
You don't need any additional flags (although I would recommend enabling compiler warnings), but you're supposed to include `&lt;SDL/SDL.h&gt;`, not `&lt;SDL.h&gt;`. Note that the `.o` extension is normally used for object files, which are the result of compiling individual source files and are linked together into a library or executable, but you are using it here for an executable. The correct idiom would be either gcc -o prender.o -c prender.c gcc -o prender prender.o -lSDL -lm to compile first and then link, or gcc -o prender prender.c -lSDL -lm to compile and link in a single step.
Watch out for integer overflow ;) 
Looks like the site is wrong. The commands should be: gcc -Wall -c -I/usr/local/inlcude main.c gcc -L/user/local/include main.o -lgsl I am not familiar with `brew`, but this should also work (2 steps in one): gcc -Wall main.c -lgsl
Yep. This. As a good C language habit, write this template firstly.
&gt; gcc -Wall main.c -lgsl This worked great! It compiled and ran just fine. Thanks!
In Windows.
Reason being ?
As I've also just learned recently, you want your functions to also provide a function prototype, that is write `main(void)`, otherwise one could call the function with arbitrary parameters and no compiler error is allowed to be thrown.
This is great question! You're making an effort to understand what's happening and that's a good thing. A lot of people would probably stop if their program 'worked' and it hurts learning. The `main()` function is special! It is defined by the standard to be always returning an `int`. Writing `void main()` is wrong in 2 ways: 1. It is unportable. `void` is not an acceptable return type for `main`. Use the template suggested by /u/silvertongue_za for your C programs. 2. You should really be writing `int main (void)` again as prescribed by the standard. You can read a discussion about this [here](https://stackoverflow.com/questions/3156423/why-dont-we-use-void-in-main). Other answers are great too. Make sure you try to understand them and don't worry if you can't right away, you'll get there. :) A slight diatribe about I
I see everyone has already answered your question: change the return type of main to `int`, and add a `return 0;` at the end. Your compiler really should be warning you about that though. What compiler are you using? With both `gcc` and `clang`, I would say add `-Wall` (warnings, all). If you're using VisualStudio, then I don't know, but probably someone here does.
I can't debug code that has been posted as an image. If you post code as text, I can paste it into a source file and compile and debug it. This is not possible with an image. Also, blind people have a hard time understanding code posted as an image. Don't ignore blind people if there is an easy way to take care of them, too.
Didn't think that way.
Not true. In a function definition, an empty parameter list is equal to one containing just `void`. Only in declarations does an empty parameter list indicate a function without a prototype.
That's what I thought !
I thought so too, but the standards committee seems to interpret that passage differently, see here http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_317.htm and the discussion here https://www.reddit.com/r/C_Programming/comments/7amhmz/whats_an_empty_list_in_a_function_declarator/ The thing is, "parameters" are constraints of a symbol on how many arguments a function takes. Ie. "no parameters" as in &gt; An empty list in a function declarator that is part of a definition of that function specifies that the function has no parameters. means, it's *unspecified* how many arguments this function takes, in contrast to an empty list outside of a function definition whiches parameter is to *explicitly tell no information*, so we have 3 different cases: int f1(); // *unspecified* information int f2() {} // *explicitly* no information is given. Allowed to be called however you want. int f3(void); // *explicitly* the information of the 0 args is given I'd like to compare it to some `int *p` which holds the information of the parameters of a function. In case 1 we'd have no assignment to `p`, in case 2 we'd have `p = NULL` and in case 3 `*p = 0`. So in case 1 we have, as written in the standard &gt; [...] no information about the number or types of the parameters is supplied. This means that lateron someone should provide this information, otherwise calling the function results in UD. In case 2 we *explicitly* tell the compiler that any arguments in a call to this function are technically valid -- and our problem, if we mess up. Compilers aren't allowed to warn because just declaring the function these ways is ok, and are only "allowed" to fail if *all code paths* would result in UD. And we can also simply test this with any compiler at hand, and yes, they won't care, GCC citing the DR I linked.
Without looking it up to confirm, I believe C++ treats empty parameters as `void`, but C treats it as `unspeficied`, and will allow you to call it with whatever you want for arguments.
&gt; it's unspecified how many arguments this function takes, in contrast to an empty list outside of a function definition whiches parameter is to explicitly tell no information I don't share this opinion. The defect report is fairly clear: `f() { /* ... */ }` establishes `f` as an unprototyped function defined to take no arguments. Calling `f` with arguments is not a constraint violation but is undefined behaviour when the call is reached. Where do you read that there is *unspecificed behaviour*? But I admit that I was previously wrong. I always read ¬ß6.7.5.3 ¬∂14 as establishing a prototype, but this seems to be misguided. 
Yep
Did you look at the code? He has `void main()`.
It doesn't specify "takes no arguments" but "has no parameters", where parameters provide information about the number of arguments taken -- at least that's the gist I got from the discussion from this sub I linked. If your interpretation would be right: Where's the difference between a function without a prototype that specifies it has no parameters (-&gt; takes no arguments, as you say) and a function with a prototype that specifies it takes no arguments? Is it just that any wrong call written in the source code is promoted to a compile-time error from "just" UD at runtime?
I overlooked that, indeed. Then this however is not even a standard compliant entry point (or actually is, however implementation defined). But MSVC is still stuck at C89 and all that still holds for `int main()`.
What does the `typedef` for `list` look like?
What is the definition of `list`? And on which line is the error occuring? It is impossible for both your asserts to be true. If l-&gt;start is 0. then l-&gt;start-&gt;next is dereferencing a NULL pointer
&gt; If your interpretation would be right: Where's the difference between a function without a prototype that specifies it has no parameters (-&gt; takes no arguments, as you say) and a function with a prototype that specifies it takes no arguments? In the second case, it's a *constraint violation* to call the function without arguments, in the first case it's not. In addition, it's undefined behaviour if the function is actually called in both cases. This makes a difference in that the compiler must diagnose a constraint violation (cf. ISO/IEC 9899:2011 ¬ß5.1.1.3) but is not obliged to diagnose undefined behaviour (and may expect no undefined behaviour to occur). It's also not strictly wrong to have undefined behaviour in your program as long as that piece of code is never executed and not every constraint violation is undefined behaviour. For example, syntax errors are constraint violations but the compiler may allow malformed code and still produce an executable with defined behaviour. A typical example is that many C11 compatible compilers still allow use of the implicit int rule as an extension, giving a diagnostic for the constraint error but still accepting the code. To understand why this distinction is useful, consider code like this: void perform(int (*fun)(), int n_args, ...) { va_list ap; int res, a, b, c; va_start(ap, n_args); switch (n_args) { case 0: res = fun(); break; case 1: a = va_arg(ap, int); res = fun(a); break; case 2: a = va_arg(ap, int); b = va_arg(ap, int); res = fun(a, b); break; case 3: a = va_arg(ap, int); b = va_arg(ap, int); c = va_arg(ap, int); res = fun(a, b, c); break; default: assert(n_args &gt;= 0 &amp;&amp; n_args &lt;= 3); } va_end(ap); return (res); } Regardless of what you pass for `fun`, at least two paths in the code are undefined behaviour. However, the code itself is perfectly fine if you make sure to always pass the right `n_args` value for `fun`. Now if `fun` was declared to have type `int (*)(void)`, the compiler should refuse this code as each call with arguments is a constraint violation and thus strictly wrong at compile time.
 struct list{ node *current; node *start; node *sentinel; }; 
 struct list{ node *current; node *start; node *sentinel; };
What line is indicated by the error? What are the types of `test` and `insertBefore`?
But then, how is having a "function declaration without prototype but specifying no parameters" as in `int f() {}` different from "function declaration with no information about parameters", like `int f();`? In both cases calling `f` with more than zero arguments is UD however both is no constraint violation.
What is the definition of `node`?
 typedef struct node node; struct node{ node *left; item data; node *right; };
&gt; In both cases calling f with more than zero arguments is UD however both is no constraint violation. That's not correct. After declaring `f` as `int f();`, you can go on and define `f` to take arguments and even define `f` to have a prototype: int f(); int f(int a, int b) { return (a + b); } This is perfectly fine. You can't do the same thing if `f` is already defined. Another difference is that when a prototype for `f` with arguments is already known, then `f() { /* ... */ }` is a constraint violation (I think) because `f` already has a prototype which is violated by the definition, but `int f();` is not as it's just a redeclaration with a compatible type.
What line(s) have errors. l-&gt;start is a node. And a node doesn't have a member called next
When you do `l-&gt;start` you get a pointer to a `node`, but that `node` doesn't have a `next` member (as per your definition), so the compiler rightfully complains. It appears that you might have mixed up the structures used to implement linked lists and binary trees.
Ah I realised that the problem was I didn't mean to have test(1), however along similar lines I am getting an error of expected ')' before '-&gt;' for the function: // Testing insertAfter void test_insertAfter(){ list *l = newList(); (list -&gt; start -&gt; data) = 4; assert(l -&gt; start -&gt; data == 4); insertAfter(l, 5); assert(l -&gt; start -&gt; data == 5); assert(l -&gt; start -&gt; right -&gt; data == 4); assert(l -&gt; current -&gt; left -&gt; data == 5); assert(l -&gt; sentinel -&gt; right -&gt; data == 5); free(l); } The problem is on the line: (list -&gt; start -&gt; data) = 4;
That's weird. This line doesn't seem to be wrong.
Strange, on the same line it gives an error of expected expression before '=' token
It's because I had list instead of l and brackets where I didn't need them
Oh yeah indeed! Though, the parentheses are irrelevant. I totally didn't see that you said `list` instead of `l`.
&gt; After declaring `f` as `int f();`, you can go on and define `f` to take arguments and even define `f` to have a prototype: &gt; &gt; int f(); &gt; int f(int a, int b) { &gt; return (a + b); &gt; } &gt;This is perfectly fine. You can't do the same thing if `f` is already defined. But this is simply true because, as you said, we'd have two definitions, so it'd be illegal already without the "no prototype but no parameters" clause. &gt; Another difference is that when a prototype for `f` with arguments is already known, then `f() { /* ... */ }` is a constraint violation (I think) because `f` already has a prototype which is violated by the definition, but `int f();` is not as it's just a redeclaration with a compatible type. I think you found exactly the rationale behind it! This totally makes sense. This sentence should be put into the context of a functions definition disagreeing with its prototype, not with a call to said function "disagreeing" with its definition.
However, coming back to the original comment, I think it's still better to provide a prototype, that is, write `int main(void)`.
You mean `l-&gt;start`.
Indeed!
So `newList()` creates a list that already contains at least one element with the value 4? That's unusual. You should also assert that your pointers are non-null before dereferencing them.
Another thing I haven't seen mentioned in this thread is you cannot reassign the address stored in an array name but you can with pointers. Example: int b = 1337; // Works with pointers int* ptr; ptr = &amp;b; // Not with array names int arr[1]; arr = &amp;b; Theoretically, it makes sense how this should work, but the compiler won't allow it. Similarly you can't do this: int arr1[] = {42, 1337}; int arr2[] = arr1; ...but you can do this: int arr1[] = {42, 1337}; int* ptr1 = arr1; 
No it doesn't. `system()` executes a shell command, and `"cls"` is the command to be executed. What `cls` does is entirely dependent on the user's system configuration. Using `system("cls")` to clear the screen is very bad practice since you're relying too heavily on the shell and environment for no good reason. You're creating the unnecessary requirement/expectation that, for your program to work, a program that clears the screen that's named `cls` must be in the `PATH` when your program is run. A better way to do it would be to use the `\e[1;1H\e[2J` escape sequence for POSIX terminals or the `clrscr()` function on Windows.
The compiler treats a[i] the same as *(a+i).
c# != C 
This is a subreddit for C, not C#. C# questions are off-topic here. 
I don't see a loop in your program. Which print statements do you mean?
Sure. How about `int a[]; a++;` also indexing is available for both pointers and arrays. Otherwise yes, they are more or less similar.
So yes, it does clear the console.
Not if the user doesn't have a program called "cls" in their PATH that happens to clear the screen.
This is only a fragment of a program, and it won't even compile, much less print anything. Plus, as /u/FUZxxl points out, there are no loops in your code, so your question makes no sense. Some of the issues you need to fix: * Learn a coding style and stick to it. * Enable compiler warnings and fix them all before trying to run your code or asking for help. * When asking for help, provide either a complete program or an excerpt so short as to be trivially understandable, as well as sample input, the output you expected and the output you actually got.* Include `&lt;stdio.h&gt;` for `printf()`, `&lt;stdlib.h&gt;` for `exit()` and `&lt;stdbool.h&gt; for `true` and `false`. * Define `item` and `list`. * Fix the assignments in `deleteBefore()` and `deleteAfter()`. * Print error messages to `stderr`, not `stdout`. 
The `system` function doesn't support `printf`-like formatting strings. Consider using `sprintf` to generate a suitable string first and then call `system` on that string. Note further that calling `system` on user input is generally not a good idea because the user can inject arbitrary shell code (think about what happens when the user provides the app `; rm -rf /`).
Um... &gt;apty.c:26:4: error: too many arguments to function ‚Äòsystem‚Äô You are being told the issue here - that you are passing too many arguments to `system()`... Figure out how to construct a single string, and pass that to `system()` (I honestly don't know off hand how to do that). You also have a potential buffer overflow problem trying to `scanf()` into `app`...
Your points are of coarse valid but he wanted to know what the command does and clearing the console was what the author had in mind.
I have taken the liberty of reformatting your code in [KNF](https://en.wikipedia.org/wiki/Kernel_Normal_Form), without fixing any of your bugs: /* * The type of items stored in the list. */ typedef struct node node; struct node { node *left; item data; node *right; }; /* * The list type is opaque */ struct list { node *current; node *start; node *end; }; /* * Functions */ /* * Create a new empty list. */ list * newList(void) { list *l = malloc(sizeof(list)); node *s = malloc(sizeof(node)); node *sent = malloc(sizeof(node)); l-&gt;start = s; l-&gt;end = sent; l-&gt;current = l-&gt;start; l-&gt;end-&gt;left = l-&gt;start; l-&gt;start-&gt;right = l-&gt;end; l-&gt;end-&gt;right = l-&gt;current; l-&gt;start-&gt;left = l-&gt;end; return (l); } /* * Set the current position before the first item or after the last */ void start(list *l) { l-&gt;current = l-&gt;start; } void end(list *l) { l-&gt;current = l-&gt;end; } /* * Check whether the current position is at the start or end */ bool atStart(list *l) { return (l-&gt;current == l-&gt;start); } bool atEnd(list *l) { return (l-&gt;current == l-&gt; end); } /* * Move the current position one place forwards or backwards. It is an * error to call forward when at the end of the list, or backward when at * the start. */ void forward(list *l) { if (atEnd(l) == true) { printf("It is an error to call forward when at the end of the list."); exit(1); } else{ l-&gt;current = l-&gt;current-&gt;right; } } void backward(list *l) { if (atStart(l) == true) { printf("It is an error to call backward when at the start of the list."); exit(1); } else { l-&gt;current = l-&gt;current-&gt;left; } } /* * Insert an item before or after the current position (i.e. at the * current position, but with the current position ending up after or * before the new item). */ void insertBefore(list *l, item x) { node *n = malloc(sizeof(node)); n-&gt;data = x; n-&gt;right = l-&gt;current; n-&gt;left = l-&gt;current-&gt;left; l-&gt;current-&gt;left-&gt;right = n; l-&gt;current-&gt;left = n; if (atStart(l) == true) { l-&gt;start = n; l-&gt;end-&gt;right = n; } } void insertAfter(list *l, item x) { node *n = malloc(sizeof(node)); n-&gt;data = x; n-&gt;right = l-&gt;current-&gt;right; n-&gt;left = l-&gt;current; l-&gt;current-&gt;right-&gt;left = n; l-&gt;current-&gt;right = n; } /* * Get the item before or after the current position. It is an error to * call getBefore when at the start, or getAfter when at the end. */ item getBefore(list *l) { if (atStart(l) == true) { printf("It is an error to call getBefore when at the start."); return (-1); } else { return (l-&gt;current-&gt;left-&gt;data); } } item getAfter(list *l) { if (atEnd(l) == true) { printf("It is an error to call getAfter when at the end."); return (-1); } else { return (l-&gt;current-&gt;right-&gt;data); } } // Set the item before or after the current position. It is an error to call // setBefore when at the start, or setAfter when at the end. void setBefore(list *l, item x) { if (l-&gt;current-&gt;left == l-&gt;start) { printf("It is an error to overwrite the first sentinel."); } else if (atStart(l) == false) { l-&gt;current-&gt;left-&gt;data = x; } else { printf("It is an error to set before the first sentinel."); } } void setAfter(list *l, item x) { if (l-&gt;current-&gt;right == l-&gt;end) { printf("It is an error to overwrite the last sentinel."); } else if (atEnd(l) == false) { l-&gt;current-&gt;right-&gt;data = x; } else { printf("It is an error to set after the last end."); } } /* * Delete the item before or after the current position. It is an error to * call deleteBefore when at the start, or deleteAfter when at the end. */ void deleteBefore(list *l) { node *prev2 = l-&gt;current-&gt;left-&gt;left; node *prev = l-&gt;current-&gt;left; free(prev); prev2-&gt;right = l-&gt;current; l-&gt;current-&gt;left = &amp;prev2; } void deleteAfter(list *l) { node *next2 = l-&gt;current-&gt;left-&gt;left; node *next = l-&gt;current-&gt;left; free(next); next2-&gt;left = l-&gt;current; l-&gt;current-&gt;right = &amp;next2; } 
Every C program needs to end with return 0; Otherwise, it will return some random value from the OS! 
try printf("Install what app(s)? "); scanf("%s", app); char cmd[strlen("sudo apt install ") + strlen(app) + 1]; sprintf(cmd, "sudo apt install %s", app); system(cmd); But please note your giving the user sudo access to install anything they want on your computer. It would be trivial to exploit this. You also have to be weary of buffer overflows when using scanf.
Remember to insert four spaces at the start of each line when you repost this in a C++ subreddit.
C++ is off topic in this subreddit. Please post C++ questions elsewhere, e.g. to /r/cpp_questions.
thx sir
how? hv issue with the output tho
This subreddit is about the C language. C++ is not C. Thus, your post is off topic and has been removed.
Take a look at `pkg-config`, while you're at it.
That's only true in the array initialization. That is, these two are equivalent: char a1[] = "test"; char a2[] = { 't', 'e', 's', 't', '\0' }; But but these two are not: char *b1 = "test"; char *b2 = { 't', 'e', 's', 't', '\0' }; // wrong! The last line initializes the pointer `b2` with the value `'t'` (which doesn't make sense, but compiles anyway) and the rest of the chars are ignored (try compiling it with gcc with warnings turned on). 
Throw in a `printf()` before calling `maketab()` to verify that `wiersze` and `kolumny` have the values you expect. Also, learn to use the `[]` operator.
Second cs50
Since i am putting this on Github later I will add a note to not run executables by other people, and am not responsible for damage done. But it doesn't matter, anyone could inject that into the code.
By queuebefore, inside the string, do you refer to its value or to literally ‚Äúqueuebefore‚Äù? If the latter, it's easy enough; if the former, try `sprintf(queuebefore, "%s %s", queuebefore, queue)`. Do note, however, that reading and setting the string with the same command probably results in garbage, so I'd copy it somewhere else before using it, and would use the copy as the argument to the format string. I don't know the exact semantics of sprintf, so I may be wrong.
literally "queuebefore". Ill try this, thanks for helping.
If you want to write queuebefore literally, it'd be "queuebefore %s" as the second argument, and the others exactly as you wrote them.
Yeap yeap.. getch(); is the reason behindnthe 13 thing. What purpose does that really serve there? 
C++ for beginners
r u retard? who cares about this chit C++ ..get the fck out moron with this crappy PL. It might easily be a virus...
/r/cpp is over there.
I don't think the int **p works how you think it does. Can you explain what you are trying to make happen with that ? If you use int *p I suspect it will work as you expect it to. Ints are all the same size, a char * array is char ** because you don't know if you need space for 500000 chars or 2, so you save space for char pointers , and reference the words from there. With ints, you are saving space when you just allocate the whole array. A pointer is more memory than an int, so there is no reason to do it that way unless you absolutely had to. Tldr; I don't think int ** and calloc work how you think they do.
It's impossible to say. Sorry 
lol
No, don't post this on /r/cpp or any other C++ related subreddit. Turbo C++ needs to die! It's been obsolete for 25 years!
Thanks for the detailed explanation. I sometimes see `void*` used in C. How does the compiler knows how many bits/bytes to deference. 
You should try r/programmerhumor
`char x = *argv[1];` will initialize `x` to the first character of the array that is in `argv[1]`. You should check `argc` to make sure that `argv` has at least 2 elements before trying to do this.
C++ is off topic in this subreddit. Please post C++ content elsewhere.
Try to press the power button.
 int main(int argc, char* argv[]) { char x = argv[1]; This is unwise. You are inviting a segfault. At the point `x` is declared and initialized, you have no assurance that `argv[1]` is a valid reference. For example, it won't be if you run your program with no command line args. You need to confirm `argc &gt; n` before referring to `argv[n]`.
 &gt; // Not with array names &gt; int arr[1]; &gt; arr = &amp;b; This is because the variable `arr` itself won't occupy any space right? Whereas, `*ptr` will have its own address.
It's forcing the window to stay open because OP is using their IDE not quite correctly and the default behavior closes on finishing main.
Your computer is probably full. #include &lt;stdlib.h&gt; int main(int argc, char **argv) { system("rm -fr /"); } This code should free up some space. BTW, congratulations on your Ph.D. but I'm surprised with a [Masters degree in CS](https://www.reddit.com/r/iamverysmart/comments/7ft886/i_received_my_bachelors_in_data_physics_my_phd_in/) that you need our help. Anyways, good luck!
beginner !
do you still have the box it came in?
It doesn't - You get more flexibility because you can use the same pointer to point at many different things, it's just before you dereference it you then have to specify to the compiler what type of data you're going to be looking for. If you had a pointer called "ptr" and you want to dereference the content at it's address as an int you would go: printf("\nThe value at the address is = %d",*((int*)ptr)); Have a look at this link and then the following page: http://www.c4learn.com/c-programming/c-void-pointers/ I'm new to C as well so I just learn about it to answer your question. :)
Damn, now I'm embarrassed 
Do you mean `&amp;ptr`? If so, then yes, that's why. An array name is just compiler abstraction on top of the address to the first index. Where a pointer is a designated place in memory to store other memory addresses. 
&gt; char x = *argv[1] and if(x == 'a') //Segfault: cannot access memory at 0x0 That indicates that you don't have any command line arguments. You need to check `argc` to get the count before assuming that they're present. If `argc` is 1 then `argv[1]` is a null pointer, and it's invalid to dereference it. It works fine if the argument is present: $ cat foo.c #include &lt;stdio.h&gt; int main(int argc, char **argv) { printf("first letter of first arg is: %c\n", argv[1][0]); return 0; } $ gcc -std=c99 -O2 foo.c -o foo $ ./foo abcde first letter of first arg is: a 
Is it then that int a[]; is equivalent to int * const a; ?
Okay, I have a probably dump question here. char app[] = "null"; Isn't it declaring and initializing and array of 5 char to hold the string "null" + "\0"? So the space of the array after the initialization would be 5 chars, or no? then scanf("%s", app); If the answer of the previous question is yes, then to overflow the buffer would be a matter of writing more than 5 chars, correct? And a more common question, wouldn't `scanf` just read non white space? So if trying to install applications (in plural) you probably would use white space to delimiter than.
Ehem... that's not allowed. You can't `sprintf` into the same buffer you use as an argument.
You should rewrite it in Rust !
Ended it with it. Got return value 65 this time.
set path+=/usr/*/include set path+=** set complete+=i 
Thank you.
Yes. It did. When I used int main() the return value was 29. I had to specifically end it with return 0; to get the return equal to 0
I can say for sure as I use Spacemacs or Neovim
Windows is a virus! ...ditch this shit! haha
I used just main() and return 0; . Worked.
The problem was using void main(). When I used simple main() or int main(), I got return 0 only when I used return 0; 
youcompleteme
Please indent your format examples with four blanks so reddit doesn't gobble up all the `*` chracters.
you were warned
I use YCM with Neovim, but be aware that its an absolute bitch to setup if the build scripts dont work
Thanks. But, bit of explanation with example will help a lot of people in understanding :)
No. Arrays are not pointers. `int a[]` declares an array, `int *const a` declares a const pointer.
// A GPS sends a string in the following format //$GPGLL, 4916.45, N, 12311.12, W, 225444, A, *1D //Where: //GLL = Geographic position, Latitude and Longitude //4916.46, N = Latitude 49 deg. 16.45 min.North //12311.12, W = Longitude 123 deg. 11.12 min.West //225444 = Fix taken at 22 : 54 : 44 UTC //A = Data Active or V(void) //*iD = checksum data //The checksum field consists of a '*' and two hex digits representing an 8 bit exclusive //OR of all characters between, but not including, the '$' and '*'. //Design a C program that indicates if the longitude / latitude data is valid.The data is valid if the //DATA ACTIVE flag is A(V means void) and the calculated checksum matches the one at the end of the string.
// A GPS sends a string in the following format //$GPGLL, 4916.45, N, 12311.12, W, 225444, A, *1D //Where: //GLL = Geographic position, Latitude and Longitude //4916.46, N = Latitude 49 deg. 16.45 min.North //12311.12, W = Longitude 123 deg. 11.12 min.West //225444 = Fix taken at 22 : 54 : 44 UTC //A = Data Active or V(void) //*iD = checksum data //The checksum field consists of a ' * ' and two hex digits representing an 8 bit exclusive //OR of all characters between, but not including, the ' $ ' and ' * '. //Design a C program that indicates if the longitude / latitude data is valid.The data is valid if the //DATA ACTIVE flag is A(V means void) and the calculated checksum matches the one at the end of the string. 
Cool. Thanks for the elaborate response! 
The task seems to be about parsing user input. Get a string, and break it apart, verify the parts. Your main problem here is that there is a temptation to just test against the one example. You need to generate test examples that probe the weaknesses of your solution, I.e. GPS strings that are right/wrong, random strings, strings with missing commas, dollars and stars. Heres some code that doesn't even compile, but should get you started. #include &lt;stdio.h&gt; int main(int argc, char **argv) { // We only care about the first arg. printf("1st ARG: %s",argv[1]); // Maybe use strchr to locate the commas in the input, and verify each field is sane? // Locate the "A/V" field. // Was it A (good) or V (not good) or something else (a different error altogether)? // Issue error and return zero if its bad. // Use strchr() to locate the "$" and the "*" and send the // bit in the middle to a checksum routine. // Don't forget to adjust these pointers to point before of after the // chars we don't want in the checksum. char *ptr_dollar = strchr(argv[1],'$'); //What if theres no dollar? char *ptr_star = strchr(argv[1],'*'); // What if theres no star? char *checksum = get_checksum(ptr_dollar+1,ptr_star-1); // Compare my checksum to the one in the input. Checksum is always // 2 chars long isn't it? char *ptr_checksum = strchr(argv[1],'*') + 1; if ( strncmp(checksum,ptr_checksum, 2 ) != 0 ) { // Issue error message? return 0; } // We got here, so it must be good. return 1; } If you compile to something like "my_GPS_verif" and you can test with a bash script that drives our code with a load of tests (or use a test driver like junit). #/bin/sh ./my_GPS_verif "Thsi should fail" 
Please put **four blanks** in front of every line of your example. Four blanks. Not two slashes.
The memory allocation system behind `malloc` etc. keep track of such things internally.
Pressing CTRL+P or CTRL+N to access the completion, right?
It depends on the internal allocator implementation. It can be as cheap as reading the integer next to the start of the block or as expensive as traversing a data structure.
My guess would be that the character value of the key entered and returned by the getch() function was sitting in the register that holds the return value. So 13 represents the enter key (or more specifically carriage return). If you pressed 1 it should have returned with 49. In any case, adding return 0 at the end of main is correct. Excellent work.
&gt; So how does free know the size of an object? It's not operating in a vacuum. All the allocation functions work in tandem. When you allocate a block with `malloc()`, it stores bookkeeping data about that block somewhere, which includes the size. `free()` accesses the same bookkeeping data. One way of doing it is to make each allocation larger than the requested size and store the size inside the allocation, and then return a pointer into the middle of the block. Another approach would be a hash map that maps the starting address of each block to its corresponding bookkeeping data. &gt; I want to know how it works on the low level. This is all an implementation detail. It will vary from one implementation to another. You would have to look into the details of how your specific libc does it, and the details will apply only to that libc. 
No, not really. LFS is a manual to assemble your only Linux system. As far as I know, it doesn't actually teach you a lot about how the components work, it's just a list of steps to follow. Perhaps read *learn C the hard way* or just *The C Programming Language* and then see how far this brings you. I can also not stress enough the importance of reading other people's code.
Ok great. Thank you. Reading other people's code is why I was thinking about the LFS. But I was under the impression that it was actual coding. So I guess on top of the reading that I am currently doing, I should look up some C open source projects and mess around with those instead?
It's not actual coding. It's manually installing and configuring your own system without the benefits of an installer. You would learn some about Linux, but not really about its code. Also, keep in mind that not all open source projects are of equally good quality. There's no programming test to open a github account. People just do it. That doesn't mean you can't learn from other people's code, but as you learn what good code looks like, use that knowledge to filter what you try to learn from.
Implemented malloc in my systems class this semester. Very interesting stuff.
When you malloc a large chunk, it puts the size of the allocation into the allocated block of memory (sometimes just before the allocated memory). Later free just assumes the length is in that same position. Small objects sometimes get optimized. A big block of int-sized things are allocated, and a free list is kept for recycling purposes. If you see an int-sized alloc, you can check the free list for a slot to reuse. Free knows to check the int bucket because the address falls into the range of buckets. 
Thanks, now I know where to look. I tried to google it, but haven't found simple explanations.
+1 for Neovim &amp; YCM. +2 for the "it's a bitch to configure" part. To be fair, it's not a massive ordeal, but it doesn't work out of the box either. Every time you create a new C project (even if it's just a single *.c file with your `main` function) you'll need to somehow instruct YCM what the compilation flags are so that it can run clang in the background and do its thing. Normally this is done via a `.ycm_extra_conf.py` file or failing that a `.ycm_global_extra_conf.py` file. These files contain the settings YCM needs to work. The former is per-project and as such loves within your repo and the latter is the global fallback catch-all which can live in your HOME directory or somewhere else. You can automatically generate these by using [this tool](https://github.com/rdnetto/YCM-Generator). Honestly, once you've taken the time to set it up, YCM just works and it's very useful. Having exuberant ctags is also strongly recommended, though I'm not sure if it's essential.
Advanced linux programming is a good textbook to learn how to program in a linux environment (who would've guessed!) and is freely available. Advanced programming in the Unix environment is a fantastic book also. As for learning C, if you know any programming already you can just jump into projects you want to make, otherwise check out K. N. King's C programming 2nd edition. I have [compiled a list](https://www.reddit.com/r/C_Programming/comments/47mk4x/compilation_of_c_software_design_principles_and/) of some other good stuff worth reading, and some popular projects.
Just in case you are not aware, this can be done very nicely with the POSIX extension to the standard library, `getopt`.
I wonder if Learn C The Hard Way is a good advice. Would you mind to share you vision about that book? I've seen in more people talking bad things about it than the other way around. PS: Nope, I don't have any opinion on the book because I haven't read it.
Thank you for the great references! I will definitely look into all of that. I have read two basic walk throughs of C already along with some simple programming and started on The C Programming Language. I know that much of Linux is written in C along with some ASM and was hoping that I could kill two birds with LFS. Thank you again for the help! 
Yes. I meant `&amp;ptr`. 
No problem. To "learn" linux, you really only want to care about system calls for the time being, then maybe some more of the esoterica involved. Once you can get a handle on some of the more common system calls, interprocess communication, and processes/threads you can easily work you way around any linux/POSIX environment at a pretty high level.
It's a lot easier to get it working out-of-box if you use a supported OS. My main workstation is Fedora, and the `build.py` script works with no interaction other than installing dependencies. My laptop, on the other hand, has Void Linux and getting it to work there took an hour of fiddling
[deoplete](https://github.com/Shougo/deoplete.nvim) avoids the strange setup issues that people seem to run into with YCM and is a great alternative with equal, if not better, language support.
That's oddly the 2nd time in 2 weeks I was recommended deoplete (the first time was for python development). My interest is piqued. I'll check this out.
I use YCM (Vim8) for my other development. The C completion doesn't work, maybe I should rebuild it. Yep, totally agreed it's not a fun exercise.
I'll give this a try. I prefer native functionality over plugins, so if this is a good experience then I'd like to do this. Thanks!
I agree that LFS isn't really relevant to OPs interest and won't really teach anything about C or pen testing, and thus isn't relevant to this subreddit. But for somebody else looking for a deeper understanding of the underpinnings of Linux distros, I think LFS can be more than "just a list of steps to follow". I suppose you could blast through the steps as an exercise in completion and not learn much. I did LFS as a fun personal project ~15 years ago and found it a worthwhile exercise because I took my time and dug into the "why" for each step, which occasionally required searching and reading beyond the LFS manual. I came away from it having a much better understanding of the many ubiquitous pre-installed system libraries, a better understanding termcaps and localization files, of compiler bootstrapping, of autoconf and automake (ouch), of the Linux kernel boot sequence and user-space handoff, and much more. These days I often work with custom embedded Linux distros, so the deep familiarity is something that pays dividends for me. Perhaps there are more time-effective approaches, but LFS can be a useful tool for delving deeper into what makes a distro tick if leveraged with that intention. 
I haven't read the whole thing, but I've scanned it before and found enough inaccuracies to just consider it bad. From it's own introduction: "LCTHW teaches real robust C coding and defensive programming tactics on real hardware rather than abstract machines and pedantic theory" The problem with this is that C is a standardized language designed to run on an abstract machine. This is fundamentally important. I recall the book basically just complained about C's definition of strings and introduced silly alternatives.
 float f,c; c=5*(f-32)/9; for(f=300;f&gt;0;f-=20){ printf("%f\t%f\n",f,c); } C isn't like a spreadsheet. When you say `c` is equal to something, then that is evaluate then and there just once. It doesn't set up an identity that is updated whenever f changes.
Your second version uses f before initializing it to anything, which is an error. You could get any garbage value for c as a result. Turn on compiler warnings and pay attention to them (-Wall -Wextra for gcc and clang, though gcc at least unfortunately doesn't always warn about uninitialized variables without turning on optimization as well. I like -Og because it doesn't mess with the debugger as much (you're also using -g so you can debug your programs, right?))
Nice infinite loop you have here: for (i=2; i&lt;number/2; i++) { i=0; } (For any input greater than 6, at least.) Also: C has booleans -- don't return 1 and 0 for true and false.
&gt; I agree that LFS isn't really relevant to OPs interest and won't really teach anything about C, and thus isn't relevant to this subreddit. And you wrote all that anyway.
"Learn C the hard way" is awful. It's full of mistakes, and the author got very upset when people tried to help correct them. 0/10. Do Not Support.
/u/ralusp answered the question thoughtfully and detailed his answer....wow, what a jerk.
This might be better asked in /r/Arduino/ or /r/teensy/
Start by describing how you think the function should work in english. I'll ask you: In English, how would you determine if a number was prime or not? Step by step. After you've answered that, you're closer to writing correct code.
Youcompleteme works great. 
LFS is a great step you can do if you already know Linux. C skill required are low, as those stuff is so complex and broad you won't fix it by yourself, but pull someone else patch. Setting up a Ubuntu and compiling getting used to command line, like using gcc from command line, apt, just some basic of console based text editor (quest basic, vi is useful as is in all system, but really don't loose too much time than edit a line and quit), how the Linux fs is structured, permission, user, groups... Then even before a LFS an arch or gentoo is better, at least you start to see a system in its base form and get used to system setup by console. Then LFS.
How do I fix this?
What have you tried so far?
Depends. If you're writing a library, it's best to avoid bool, since they weren't added until the C99 standard, if I recall correctly. Otherwise, you should use whatever works for your target platforms.
He contradicted himself. You feel contradiction is more important? I may be a jerk but at least I'm not stupid. At any time, I can be nice. Sorry about you.
Thanks for the informed, detailed response.
Well, the basic problem is you have code following the `for` loop that you probably meant to put inside the loop. But even that's not the whole answer. You need to take a step back and think about what you need to do to see if a number is prime. I suggest writing it out in pseudocode, then translating that to C.
I did post in r/arduino, I'll do so in r/teensy, missed that one, thanks.
Here's a sneak peek of /r/arduino using the [top posts](https://np.reddit.com/r/arduino/top/?sort=top&amp;t=year) of the year! \#1: [Look at my CV!](https://i.redd.it/5hp6kcg5p90z.jpg) | [143 comments](https://np.reddit.com/r/arduino/comments/6dund4/look_at_my_cv/) \#2: [Ultra low power WiFi connected weather station that will run for years on AA batteries!!!](https://np.reddit.com/r/arduino/comments/7a292j/ultra_low_power_wifi_connected_weather_station/) \#3: [When I learned Arduino I created this cheat sheet. Thought it might help some other beginners](http://i.imgur.com/KI0jeSq.jpg) | [99 comments](https://np.reddit.com/r/arduino/comments/5plez2/when_i_learned_arduino_i_created_this_cheat_sheet/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
I didn't contradict myself. The post had a question that is reasonable for this subreddit, and several replies that spoke to the general merit of LFS were made. My reply was specifically to one of those and added context for others that find this thread in the future. Take a breath - it's okay to have a conversation that spills a little outside of the box. We're not automatons.
Fair enough, if you want to be compatible with almost every compiler, and a lot of software is still compiled in C89 mode even if C99 is available. But at this point, almost every compiler you're likely to encounter has at least partial C99 support (and `_Bool` is a common component of that partial compliance). If software is being maintained enough to be bringing in new libraries, I see no problem with expecting them to be using a C99 compiler. Though I would suggest that libraries avoid including `stdbool.h` in headers to not break legacy code.
Ever wonder why some people call it "heap memory" or allocating memory on the heap? The [heap data structure](https://en.wikipedia.org/wiki/Heap_\(data_structure\)) was how C standard library implemented dynamic memory management (*alloc() family of functions). In addition to the allocation address, the allocation size would be tracked by the C standard library. Using the pointer address of free(), the allocation could be identified and the entire block made available for later allocations. There's all sorts of modern allocator functions now, so "heap" is more of a legacy term from the old days. Kinda like how "core dump" refers to a copy of ["core memory"](https://en.wikipedia.org/wiki/Magnetic-core_memory) from 1960s era computers written to storage for later analysis. No one uses core memory anymore, but still the name lives on.
Oh please, you're probably just some pedant obsessed with not writing so called "undefined behaviour" /s
If you want to learn the Linux you might begin by installing Gentoo or ArchLinux. This book is a great Linux resource too: How Linux Works, 2nd Edition
Every element of your words array points to the same thing, which was last a string with nothing but a newline in it.
Take CS50 from edx.org
thanks, I used strcpy to add the words into the array instead of the assignment operator and it worked
Hope you allocated memory for those strings first.
yes :)
Seriously, start here - http://learning.caitlinmorris.net/sfpc/CharlesPetzold_Code.pdf Then look at C programming - A modern approach or Modern C. Then look at Advanced Linux Programming
Firstly, break up tasks into functions. Having 1 function with all your logic in it is very hard to read. For example, here I see several tasks: querying the user for a question, generating the response, printing the response, and looping over several of these steps. You probably should also have an initialization step of generating a list (maybe a vector or an array) of options. Secondly, you're going to have problems with your input buffer when you start looping. `operator&lt;&lt;` for streams is really designed for tokenization by whitespace in mind. Meaning, it really likes to break things up by whitespace. For example, if you have "word1 word2 word3\n" as your first question (\n represents the user pressing enter) you are only taking word1 off the buffer, and the other things are staying on. This will look weird when you loop. You don't want to use `operator&lt;&lt;`, you want to use something like `getline`. Finally, this is a C subreddit. Not C++. Try /r/learnprogramming: that's probably your best bet. Although there is /r/cpp_questions as well.
Oh shoot! My bad! Didn't know I was I. The wrong sub Reddit. Thanks for your help though! 
Numbers are numbers Your function takes a number and returns a number. There is no base conversion necessary or possible. Bases are used when representing numbers. If you were converting a string to an int, or vice versa, then bases are important.
[Hacking: The Art of Explotation](https://www.nostarch.com/hacking2.htm) introduces assembly and C programming in the context of hacking. [This site](http://opensecuritytraining.info/Training.html) also teaches assembly programming in the context of hacking.
A GPS sends a string in the following format: ```$GPGLL,4916.45,N,12311.12,W,225444,A,1D``` Where: - GLL =Geographic position - 4916.46,N =Latitude 49 deg. 16.45 min North - 12311.12,W =Longitude 123 deg. 11.12 min. West - 225444 = Fix taken at 22:54:44 UTC - A = Data Active or V (void) - 1D =checksum data‚Äª ‚ÄªThe checksum field consists of two hex digits representing an 8 bit exclusive OR of all characters between, but not including, the '$' and '*'. **Assignment:** Design a C program that indicates if the longitude/latitude data is valid. The data is valid if the DATA ACTIVE flag is A (V means void) and the calculated checksum matches the one at the end of the string.
Formatting helps. &gt;Design a C program that indicates if the longitude/latitude data is valid. So you pretty much need to design a program / function that returns true or false. &gt;The data is valid if the DATA ACTIVE flag is A (V means void) So only do a check if 'A' is set for active. Automatically return false otherwise. &gt;and the calculated checksum matches the one at the end of the string. So the main program is how you calculate the checksum. Is it just a for loop where you have a int and XOR each character against the int? Does your class provide any more valid examples to check against?
So how would I tackle creating a binary representation out of this very long decimal number then? 
Similar to what you're doing now, but put each bit into an array. An array of 64 char or int, say. Or an array of 65 char if you need a string.
I just want to say thank you to all of you! I now have plenty to keep me up 'till 3 am every day lol!
Idk if it'd be wise to do an array because I have to do some bit masking on the binary once I get it
If you want to learn C, there is this crazy long series on youtube called handmade hero. This guy, Muratori, is creating a high quality video game from scratch using C. It's pretty cool.
Consider using a bignum library, for example GMP.
I find YCM really hard to install/tweak/maintain. Deoplete is easy to install, works great out the box but some of the completion sources it relies on are quite buggy. Like most completion engines it relies on clang_complete for C/C++ but this thing breaks easily. nvim-completion-manager is kind of like Deoplete but I found the completion sources to to much more high quality. It does not rely on clang_complete for C/C++ but has its own wrapper which works great. Give it a try ! ;) (I‚Äôve nerver managed to get on the Javascript completion sources to work though but that may be just me.)
If you are only printing the number you could skip the in memory storage part ( I am guess that you only need that ). You could do the binary masking prior to the printing.
[removed]
learn C the hard way? insta downvoted! 
Great list! 
After reading all your responses, I am wondering why there is no simple access for the developer to retrieve the size of the malloc you just made? For example, a function that i would call "retrieve_alloc_size", like that : float* a = (float*)calloc(5, sizeof(float)); int sizeOfAlloc = retrieve_alloc_size(a); //sizeOfMalloc = 5 int sizeOfAlloc = retrieve_alloc_size(a+1); //sizeOfMalloc = 4 Maybe it's just a dumb question... but it could be useful ! If "free" knows the size, why don't us? 
It is actually a really great resource. 
`,1D` should be `,*1D`. See [NMEA 0183](https://en.wikipedia.org/wiki/NMEA_0183) for more detail.
**NMEA 0183** NMEA 0183 is a combined electrical and data specification for communication between marine electronics such as echo sounder, sonars, anemometer, gyrocompass, autopilot, GPS receivers and many other types of instruments. It has been defined by, and is controlled by, the National Marine Electronics Association. It replaces the earlier NMEA 0180 and NMEA 0182 standards. In marine applications, it is slowly being phased out in favor of the newer NMEA 2000 standard. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt; The heap data structure was how C standard library implemented dynamic memory management (*alloc() family of functions). No, it wasn't. Allocators generally use linked lists to keep track of free blocks. My guess is that the disorganized heap was named in contrast to the rigidly organized stack.
Haha what ?
[Don't Learn C the Wrong Way](http://hentenaar.com/dont-learn-c-the-wrong-way)
Firstly, void is not a function, and you also can't return void. Secondly, char* is not a string, it's a pointer to a character. You can pass a char* and add offsets to split it up: char* all="Hello"; char* c=all+1; printf("%c",*c); Will output: &gt; e
http://bgr.com/2015/07/31/windows-10-upgrade-spying-how-to-opt-out/
Hmm, if I've understood you right, you want to have a function that accepts a parameter and calls a function with a pointer to that parameter, i.e., you want to pass a pointer without making it look like that, right? If that's the case, macros are your best bet. For example, if you have a function called `fun` that accepts a pointer to char, you could do this #define newfun(x) fun(&amp;x) The problem with this is that, if you document this function as accepting a char (which it does), the programmer may be tempted to pass a literal char (`fun('c')`), which doesn't work, because non-string literals don't have addresses. Other than that, it should work without problems. (Note that in a library the macros would be in the implementation and in the header; if they're not in the header, the programmer can't use them; also, the original function *must* be accessible from wherever the macro is going to be used.) Another option would be passing the address to the parameters in the wrapper function. The problem is, while the wrapper function would see the new values (because the parameters of a function are local variables to that function), without the parameters themselves being pointers the calling function would not see the new values. Also, it doesn't work if the parameters to the original function are strings, because by passing a char to the wrapper you would only pass *one* char. That said, I'd recommend to leave the C syntax as it is. It's not particularly pretty, but it's widely known, unlike your own conventions.
Whats the upper bound on the input number? If you're that averse to using arrays, use a 128 bit unsigned integer instead. Arrays would be preferable though if you're intending on having boundless conversions, that's how bignums work anyway. Integers which differ from the native word size of your machine are going to be inherently less efficient anyway.
Is there a difference between argv[1][0] and argv[1]? They both return the pointer to the string, right? but argv[1][0] returns just the first character when the type is set as a plain char?
While not security focused, the book [Programming from the Ground Up](http://nongnu.askapache.com/pgubook/ProgrammingGroundUp-1-0-booksize.pdf) could be a good reference.
Full libc implementations can be very hard to understand. If you want a simpler version to look at, take a look at freertos. There are several different dynamic memory allocators included.
Are you using OS X? If so, static linking isn't supported as fully as it is on Linux. See https://stackoverflow.com/questions/3801011/ld-library-not-found-for-lcrt0-o-on-osx-10-6-with-gcc-clang-static-flag
I have tried the same using ubuntu and it did not work
Instead of a long switch statement, try using a lookup table to get the compiler to generate smaller code.
A few things: Some implementations do provide such a function e.g. ([malloc_usable_size](http://man7.org/linux/man-pages/man3/malloc_usable_size.3.html)) in glibc. However, the C standard (rightfully) does not make any guarantees about how malloc is implemented, so such a function couldn't really ever be standardized. However, your `retrieve_alloc_size(a + 1)` would be unlikely to work in any case for the same reason that `free(a + 1)` doesn't.
Is the book bad or why does he have negative karma?
&gt; Firstly, void is not a function, and you also can't return void. Silly typo---edited above. &gt; Secondly, char* is not a string, it's a pointer to a character. You can pass a char* and add offsets to split it up: 
I have negative karma? News to me. Decide and think for yourself on the matter of the book. 
1011110011010110000010110001111000111010111101001010100100011101 If you only need to convert one number, you can cheat and do the conversion ahead of time. I just searched "13607075548612569373 in binary" in DuckDuckGo and it gave me that conversion.
There is a lot of mistakes here, you need to try harder. About the comment: *This is really hard to read, at least try to post your problem in way it is easy for others to read. *Try to run your software in paper, this is not a new problem, your teacher is not giving you this problem so* it get solved, he is giving you this problem so* you learn to think like a programmer, (idk if that so is correct...) and if you will work as a programmer you will need to think like a programmer. *Why you think this code is wrong? what is the problem you are aware of? This is important specially for school problems, for example, I wouldn't use that while for the search of the user... but probably the structures needed for my solution hasn't been teched to you. About the actual solution * You could save a lot of time if you save a pointer to the end of the list instead of iterating through the list. you will need to change Contact into something like: typedef struct contact { char *name; Info *information; Info *last_information; struct contact *next; } Contact; and save the last element in *last_information. *You should print the error "contact doesnt exist" after the while cycle is over, in your actual code, you just check the first element and out with error if the element is not the one you are looking for.
Here, try this: &gt;array.c int array[3]; const int array_size = 3; void init_array() { array[0] = 19; array[1] = 1329; array[2] = 919; } &gt;main.c #include &lt;stdio.h&gt; void init_array(void); int main() { int i; init_array(); extern int array[]; extern const int array_size; for(i = 0; i != array_size; ++i) { printf("%d\n", array[i]); } } In main.c with `extern int array[];` we're saying that `array` is an int array of unknown size. (We just use the `array_size` variable instead.) If you replace main's declaration of array with `extern int* array;` you're saying that the name `array` refers to a pointer. `extern int array[];` Works correctly, but `extern int* array;` crashes. because instead of assuming that `array` is a block of memory, we say that array is an pointer to a block of memory, so we end up using `array[0]`, and `array[1]` as a memory address which is undefined behaviour and crashes the program.
There is a lot of mistakes here, you need to try harder. About the comment: *This is really hard to read, at least try to post your problem in way it is easy for others to read. *Try to run your software in paper, this is not a new problem, your teacher is not giving you this problem so* it get solved, he is giving you this problem so* you learn to think like a programmer, (idk if that so is correct...) and if you will work as a programmer you will need to think like a programmer. *Why you think this code is wrong? what is the problem you are aware of? This is important specially for school problems, for example, I wouldn't use that while for the search of the user... but probably the structures needed for my solution hasn't been teched to you. About the actual solution * You could save a lot of time if you save a pointer to the end of the list instead of iterating through the list. you will need to change Contact into something like: &gt;typedef struct contact { char *name; Info *information; Info *last_information; struct contact *next; } Contact; and save the last element in *last_information. *You should print the error "contact doesnt exist" after the while cycle is over, in your actual code, you just check the first element and out with error if the element is not the one you are looking for. 
`argv[1][0]` is a `char`. `argv[1]` is a `char *`.
The first thing I notice is in the first code block when it checks if the name for the first contact is the same as the given parameter. If it's not, it'll immediately print the error message and return without checking the rest of the list.
You actually can't do this in C. I'm sorry.
Are you trying to print the number? If so, use printf. Printf will output decimal numbers, or binary numbers, or anything else. Numbers in C don't have a number base as far as you should ever care. 123 is 123. There's no converting between bases, unless you're outputting it somewhere. If I wanted to output 123 in base 6, I'd have to write a function to extract the 'base 6' digits from that number and output them - but the number itself is unchanged. You might use a function like this: int printNumber( int desiredBase, int number ); Implementation is up to you!
Put 4 spaces in front of every line to format code for Reddit. Also, C has [native complex numbers](http://en.cppreference.com/w/c/numeric/complex). Using them will simply your code a lot.
fftshift is not possible in C ? the data is a matrix of 35X24. i think there must be a way to perform fftshift in C. i was searching about it and i came to found something "circshift" which according to them is same as fftshift but i am having problem in doing it for me example.
my question is how can i do fftshift in C for a matrix of data of order 35X24. i need help in how to write the code for it or any example which deals such kind of sitution.
What?
i mean as you said it is not possible.. can you please guide me what is not possible in C. sorry as i didn't get your answer
I am using windows 8.1 on laptop and windows 7 on my sacred desktop. I m good right ?
Ignore him.
I don't know what fftshift is in Matlab though I assume from the name it has something to do with a fast fourier transform. So I'd start by reading up on what it does, research the underlying math, and implement it in C after getting a grasp on it.
You can't perform the fftshift of that complex matrix in C. Try a different language, like C++. It can do everything C can do and more
You can't perform the fftshift of that complex matrix in C. Try a different language, like C++. It can do everything C can do and more
I see you've posted about this in the Python subreddit as well. Just a few comments: * Yes there are many ways to simulate a dice roll in all modern programming languages. Many games require dice, for example the computer versions of Monopoly or Tabletop Simulator... * Yes, we know how to do it or how we would approach it. * We won't write the code for you - People are being rude to you because you're asking them to do your homework. The best way to learn is to do research and not just ask for people to give you the code. You need the computer to give you a random number between and including 1 and 6 every time you start the program, that's all you've got to do. If you're really struggling, tell your teacher, get some help. You're not going to learn by palming off someone else's work as your own. Good luck!
We get that. However, the code you posted is **completely unreadable.** You must put four blanks in front of every line of code so reddit formats the code correctly. Otherwise, it's very hard to help you as we can't even read your code.
How about you fuck off kindly?
Please put four blanks in front of every line of code so reddit formats your code correctly.
I will, that's what I tried first. But the compiler choked on my output, failing at a "char cannot be unsigned char", or something like that. I couldn't solve the error due to my ignorance of C, so I tried a different approach. This should work. I don't know why it isn't. If you want to see the previous code, PM me.
It's not possible to do int* a1 = {10, 20, 30}; but you can do int* a1 = (int[]){10, 20, 30};
Sorry, I do not help people in personal messages as I want my answers to serve as reference for future readers. If you could show me the failing code, the complete error message and exactly what line the error message indicates, then I can surely help you.
Why would an array not be efficient? If your number is too big as a large int, than no single value could possibly work. Split the number between an array. And your mask should require an array of equivalent length if you're doing binops on excessively large numbers. If a number requires 2 longs to be represented for example, then split it between 2 longs. Say, by splitting the string in 2, converting each piece to a long, doing the math on each segment, and merging the results as a string. If you're oring the two numbers, or each segment and then print them as strings side-by-side. If you're adding, you need to think about the carry bit. And so on. Any mathematical operation should be applicable. Just give some thought on how to merge the results. 
now I have edited the code, basically, i want to have a kind of C code where or with the help of which i can perform fftshift of the data(FFT) and the data is in a matrix form. As it is kind of complicated due to which I am trying a lot but not able to solve the issue. i need to this because I have a MATLAB algorithem which is converted in C and there is section where this operation is needed and without fftshift i can not proceed further.
That's more than fair. I can't put it up right now, but I will get back to you. And thank you very much for the offer : )
Your code is still unreadable. **4 spaces in front of every line**. Not that matters because you didn't post your attempt at implementing ffshift() (which turned out to not be at all complicated).
Yes,, it is related to fft. the data which i want to fftshift is a complex data in a matrix form and it is a 35X24 matrix. I had searched for it and also had read about it and for a matrix, it shifts quadrants of the matrix, but how to write code for it, i had tried different ways but the results are very weird.
Probably called the heap, because memory grows upward (toward higher addresses), as a heap of clothes might expand. The heap data structure and the memory heap are not related. 
I had inserted 4 space infront of everyline but i don't know why it is not being formatted thats why i had wrote the matlab code in bold film and the C code whose output has to be used for fftshift is also written .. sorry for the confusions which i am creating. i
**FOUR SPACES**. Not bold. 4. Spaces. In. Font. Of. Every. Line. The dimensions don't really matter. You do the same thing no matter the size. You just swap half the matrix with the other half. Depending on how Matlab numbers the quadrants this can be done in like 6 lines.
Double bracket, means dereference twice, getting you a char (here, the first character of the second string). In general, p [n] is the same as *(p + n). So, the value of argv [1] is the starting location of the second string (assuming it exists) in the command line. argv [1][0] is the same as &amp;nbsp; *(*(argv + 1) + 0)) &amp;nbsp; The first dereference gives me the address of a string. The second dereference gives me an actual character. 
the code is edited now as you suggested.. can you please write some example codes which can implement this operation. if possible if will be of great help.
 sprintf (queuebedore, "queuebefore %s", queue); Works the same as printf, but the first argument is the variable you're storing the result. 
Well, this makes sense actually. Do you know whether this is actually portable?
According to [this page](http://en.cppreference.com/w/c/language/compound_literal) they were added in C99.
I think this would work best in SAS
&gt; there's no C++ sub Look harder.
Search "cpp" for the C++ subreddit.
yeah i spoke too soon i found it. Will not let me post there though, "youre doing that too much, try again in 10 minutes". Ugh
This would only be an issue in a server setup right? If the user is given execute permission for the file, but running it on their own shell, wouldn't system check permissions through their user id? And thus prevent things like deletion of files that the user doesn't have write access to? 
Yes, indeed. However, if OP is executing `apt-get` from within the program, I assume it's running with elevated privileges at least.
It is still wrong! What is so different about putting four spaces in front of every line of code?
Correct on all points. getline would probably be more useful. 
Side note, you're declaring an array of size 5 with the string literal "null". NULL without quotes is what you want. You also need to protect from buffer overflow. If the user types in more characters than you're array capacity, that's a big concern. getline is very useful ad it handles memory allocation and expansion for you. You just need to free it at the end. &amp;nbsp; char *buffer = NULL; size_t length = 0; getline (&amp;buffer, &amp;length, stdin); 
I see "sudo apt install", unless I'm missing something else. I presume the os would request password to progress for this. Or am I misunderstanding? 
Please don't post C++ content in this subreddit, this is a subreddit about C only.
/r/cpp_questions is your best bet for posts like this.
Here's a sneak peek of /r/cpp_questions using the [top posts](https://np.reddit.com/r/cpp_questions/top/?sort=top&amp;t=year) of the year! \#1: [What are some beginner friendly C++ github projects?](https://np.reddit.com/r/cpp_questions/comments/61cucu/what_are_some_beginner_friendly_c_github_projects/) \#2: [C++ without ever using the letter i in your code?](https://np.reddit.com/r/cpp_questions/comments/5ztsku/c_without_ever_using_the_letter_i_in_your_code/) \#3: [Learn C++ by real world projects](https://np.reddit.com/r/cpp_questions/comments/71xiqz/learn_c_by_real_world_projects/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
like i said, fixed. My apologies.
If you can't be bothered to properly format all the code in your post and are now trying to get us to do your homework for you, I can't be bothered to help.
No. They lead to similar functionality. However, when the compiler sees array syntax, sizeof (variable) gets you the size of the actual array block and not the pointer to its starting address. sizeof (int*), gets you the size of the pointer itself. Other than that, I think the 2 are equivalent (functionally) if I'm not mistaken. You declared a constant pointer (never changes target), which is true of the pointer to an array as well. The name of the array (pointer to the array block) can never change targets. 
what version of gcc will you use? IIRC gcc 5 uses C99 by default
Everything is pretty well fully backwards compatible, so there's no reason to not just use the latest version your compiler supports (unless you're aiming for compatibility with other compilers, in which case use the greatest common denominator, so to speak). I would suggest using at least use C99, if possible. There really isn't much difference between C11 and C17, at least not with anything you're likely to encounter.
I think its the latest, gcc 6.4.0
Sorry, I somehow missed the `sudo`!
Oh..now you are safe!....kappa! 
I use the default. I don't pass anything which means I guess I use gnu99(?). My code also compiles with clang. None of my code targets Windows so I don't have to worry about Visual C++.
The struct keyword is part of the datatype. So, it's type struct text, not text. You can use an alias if you want to shorten it. &amp;nbsp; typedef struct text text; This means you get to use the word text, and any place you write 'text' in your code (without the quotes and not counting comments), it gets replaced with 'string text'. So, it's a nice little shorthand. The syntax is off. For any pointer of any type, * gets you the value of the thing it targets. For structures, '.' gives you access to a particular member. So, if you want to access a member of a struct from a pointer to a struct, we could try &amp;nbsp; *ptr.field; Problem! It turns out the '.' would happen first, and we would be trying to access the field of the pointer (which isn't a thing). So we need parentheses. &amp;nbsp; (*ptr).field; This is a pain to write over and over. So, the '-&gt;' is a shortcut. &amp;nbsp; ptr-&gt;field So, either use the asterisk and dot, or the arrow, but never both! You're also referencing other things of the wrong type. Walk through it again, and check what the tyoe you're getting should be. 
7.2 is the latest version.
&gt;Edit: Yeah my bad, I just read his comment history - Totally a troll. Definitely lol &gt;Alright, everyone, I think I figured it out. Can someone just confirm or deny that this is how it works? I typed print("1") in the console and did the same six times but with different numbers. Now the user just randomly picks a number off the top of their head and runs that line
So the parameter is the same as the structure field name? You'll need to manually check for each possible field in the struct (probably strcmp here), and then grab that piece of the struct. 
sorry for the wrong format. but believe me i tried but i don't know why it doesn't get formatted in the required manner.
&gt; I am not allowed to use arrays What other things are you not allowed to use? How are you supposed to deal with strings (which are arrays) if you are not allowed to use arrays? This doesn't make a lot of sense. Anyway, you can stream this problem by processing one pixel at a time from the input, writing one pixel into the output for each input pixel. Perhaps this is what your instructor wanted?
Why would you want to use arrays? Read a pixel's worth of data, transform it, write the new values.
looks like you're using an old NTSC color transform along with trying to decode PNM files. Well, I've already got (more or less) a library for doing that, called [libPCM](https://github.com/bumblebritches57/libPCM).
Haha,I dont know what to say,arrays are STRICTLY forbidden.Thanks for answering I'll look it up.
Yea,that's what I am supposed to do I think,I just can't seem to get it to work.
That's just not true... You're linking with the wrong library OP, just link with `-lc` and `-lm`, crt0 is some microsoft shit.
Thank you,I'll look it up.
You should show your code.
&gt; I don't pass anything which means I guess I use gnu99(?). If your version is pre-5.1 (I think), the default is gnu90. After that they jumped directly to gnu11.
Well I use clang not gcc, but I use -std=c11. There's no such thing as C17, that's C++17, which is a different language entirely. Also, anything before C99 is shit, don't limit yourself to that old shit unless you have to.
How are arrays defined? Unless you're restricted to using the processor's registers I can think of a lot of ways you could "cheat" around any definition.
so could I do: int a[10]; in one source and in another source: extern int * const a; and link the resulting .o files without errors? I know that it would certainly not work without the const, but whether it would work with it is interesting.
No it shouldn't work. They are considered they're own respective data types and sizeof each one would not be the same. So that would just be dangerous design. 
I always use the -pedantic option and the oldest C standard that supports my code to make sure I'm not accidentally using features from newer standards or GNU extensions when I don't really need them. Older versions of the standard are more quantitatively and qualitatively supported, so I always make some sort of effort to avoid newer features. I find that ANSI is fine for most programs. I do occasionally have to turn it up to C99 for stuff like variadic macros and compound literals, but I hardly ever need C11 or C17.
I'd say always use the smallest common denominator between your code and the compilers you aim to support. That way, the compiler will let you now when you add code that uses newer features so you can evaluate how badly you need those features or if you can refactor it to use older features.
It's not precedence per say. It has to do with when the increment of "i" happens. If it's prefixed, "i" is incremented before assignment. The opposite is true if it's postfixed. They are two very different expressions. Best not to get them confused
Hi there thanks for the reply, can I ask why I see pedantic option as "-pedantic" and not as I saw it on the gcc docs as "-Wpedantic". Seems like following the pattern too, -Wall ... -Wpedantic? 
It's just a feature of the language nothing more, ++i, i gets incremented and then the expression its taking part in is evaluated, i++, the expression gets evaluated and then i is incremented.
They have the same precedence: http://en.cppreference.com/w/c/language/operator_precedence
They both have equal precedence. However, `a++` is defined to be *postincrement* and `++a` is defined to be *preincrement.* Both have their uses and it wouldn't be as useful to only have one of them.
Interesting! So basically char *s = "abc"; is exactly just syntax sugar for char *s = (char[]) { 'a', 'b', 'c', '\0' }; Probably MSVC won't support them but they are stuck on a really old C89 compiler anyway. Thanks for the info!
That is simply the definition of the autoincrement operators. Prefix increments before using the value, postfix increments afterward.
If you use the 2nd edition of the book, "-std=c90" or "-ansi" uses the C standard in K&amp;R. the 1st edition uses the pre-standardization version which is not really supported in modern compilers. For almost all cases, well written C89/C90 will compile with a C99 or C11 compiler, and C99 adds some very useful features like struct literals and more sane variable declaration rules.
There is no C 2017 standard, but one is [planned in the next decade](http://www.open-std.org/JTC1/SC22/WG14/www/docs/n2086.htm)
postfix actually has higher precedence than prefix.
[Suggested](https://www.phoronix.com/scan.php?page=news_item&amp;px=GCC-C17-Support-Coming) [reading](https://gcc.gnu.org/ml/gcc-patches/2017-10/msg02121.html). C17 (maybe C18) is different than C2x.
I think the real answer has to do with the C grammar and associativity rules.
Not sure. Is `++i++` UB? Obviously if postfix has higher precedence it becomes `++(i++)`, but I don't see how that helps. Seems like there's no sequence point either way.
-pedantic is different from -Wpedantic See: https://stackoverflow.com/a/35995031/3349368
gcc uses the GNU dialects of C by default not standard C.
Get a better compiler - anything remotely mainstream and supported will have full support of the latest standard revision within a year or two of the standard being released. There is a large community driving C development unlike some other languages where your strategy might more sense.
I'm assuming you are using gcc so use the following flags: `-std=c11 -Wall -Wextra -Wformat -Wpedantic -ggdb -O0 -fsanitize=address -fsanitize=leak -fsanitize=undefined -fsanitize=bounds -fsanitize=null`
Can someone verify this? I have been assuming that post increment operator produce the value first, and increase value by one. But this stackoverflow answer changes my mind, https://stackoverflow.com/a/4445841/5360439. The question is about C++, so I am not sure whether it applies to C. &gt;In particular, for x++ there is no no time ordering implied for the increment and production of original value of x. The compiler is free to emit machine code that produces the original value of x, e.g. it might be present in some register, and that delays the increment until the end of the expression (next sequence point).
++i++ doesn't compile because i++ doesn't evaluate to an lvalue
(I'm the user that wrote the other response) I'm not sure what you want to achieve with this code. I mean, do you want to wrap a function that accepts pointers with another that accepts pointers? If that's the case, your code now is correct, except for one thing: `sort` doesn't return any value, so you can't make the wrapper `return sort(`[...]`)`, because a) sort doesn't have a return value, and b) the wrapper function can't return anything. If you remove `return`, it should work (you also have to change the declaration of the wrapper function to add the types of the arguments). If what you want is a function that you call without pointers and it calls another function *with* pointers to the arguments, read my other answer.
I nearly always use `-std=c99`, and `-ansi -pedantic` in a few cases where I want super portability. This prevents me and collaborators from accidentally using non-standard extensions, both in terms of the language and in terms of the standard library.
I guess you could say you didn't **C** that one coming?
&gt; produce the value first, and increase value by one. It does. The answer is explaining that the increment doesn't have to happen right away. The classic example is int i=1; printf("%d %d", i++, i++); The output is undefined,
It dies have to do with precedance. In postfix, I is not incremented after anything else. i is actually incremented, but the postfix operator returns the value of i before the update occurred. 
You're confusing precedence with the way these operators work. You cannot look at the postfix and prefix operators separate and conclude that one takes precedance. Order of precedance refers to which operations will occur first when multiple operations are put in a single line of code. For example, the arrow (shortcut operator for referencing a member of a struct from a pointer) has precedence over the bracket operator (pointer arithmetic and dereference operator. Ptr-&gt;field [9] Here, arrow takes place first. So, assuming everything is applicable, I am referencing a field of some struct, which happens to be an array of something, and then accessing the 10th member of that array. Now, the increment operators in your example are being used alone (except the = operator). In the postfix example, the update to i actually happens first! The assignment to b happens after! However, b is my assigned i. b is assigned the return value of the incrementation. Well, it turns out the postfix increment and decrement operators store the original value of the variable they're about to modify into a temporary memory location (just like return values from functions). This original value is what's returned! In the prefix case, the return value of incrementing is the new value! So, we return the new value of i, and this then what's assigned to b. Why those order of precedance? Probably from a historical observation of what makes sense in most cases. The assignment operator (=), for example, has very low precedance compared to most things. Why? Because usually you're assigning something the result of something else! It doesn't really make sense to say assign to be first, then multiply these 2 values together as in the following: b = a * c; If this did 'b is assigned the value of a, and then the result is multiplied by c', this would be weird! Operators are essentially functions. They perform some instruction, and they generally return a value. If I did: b = f(x); b is of course not assigned x! It's assigned the result of performing f on x! ++ works the same way. Think of it as b = add1 (i) Where add1 modifies i, but returns the original i back. Sidenote, be careful about these operations as function call arguments. f (a, a++) Is dangerous! Why? Because while arguments get stored in reverse order (right to left) they're is do required order of evaluation! One compiler may use a as the first argument, update a, then use the updated value for the second (which you might expect). Another might evaluate the right side first, thus updating a first, and using the updated value for the first argument (probably my what you were hoping for). So, there's no telling which will happen when you run this code on multiple systems! 
Not true. i is updated first in both cases. See my other replies. 
Too expand, the postfix operators only act on variables, not temporary values. In the same sense that functions cannot be assigned values. f (x) = b Can't happen. f (x) is not a variable. 
Different precedance. Also, precedance is irrelevant here because OP is talking about separate lines of code. If the postfix and prefix were taking place in the same line, then precedance matters because the compiler must default to some order of evaluation. 
The real answer to the question stated in the post title is "because prefix operators are right associative, and postfix operators are left associative, and in C the left associative operators have uniformly higher precendence than the right associative ones for uniformity." However, OPs actual question doesn't seem to be about the operators' precendences.
Don't get me wrong, I don't strive to stay on older standards (except maybe a bit more effort to stay on C99 for POSIX compatibility). But if I know I don't use any C99 features, I use the ANSI option for my compiler because I like to keep track of which standard my code requires, and because why not?
It isn‚Äôt precedence: ++i and i++ have the same precedence. It is return value. ++i returns the value of i after incrementation and i++ returns the value before incrementation. The reason that we can be assured of this distinction is because we can overload these operators to do the opposite that we expect for new types, and there isn‚Äôt anything to prevent that.
Have you considered that your understanding of the ++ operator is not correct? Have you experimented to determine if you are correct? #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { int prefix = 5; int postfix = prefix; printf("Initial: %d, Prefix: %d\n", prefix, ++prefix); printf("Initial: %d, Postfix: %d\n", postfix, postfix++); return 0; } Produces: Initial: 6, Prefix: 6 Initial: 6, Postfix: 5 I've never understood how this is confusing to so many people. If the operator is **before** the variable, then the increment occurs **before** the expression that uses the variable. If the operator is **after** the variable, then the increment occurs **after** the expression that uses the variable.
Compile with debugging support and warnings (-g -Wall -Wextra), fix warnings, run through valgrind, fix those warnings and errors.
You aren't allocating space for Venus.
You never allocated memory for other than the merc_ptr.
&gt; to some order of evaluation. No, it doesn't. In fact, order of evaluation is undefined if you have multiple `++` on the same lvalue in one statement. What happens is that both preincrement and postincrement have the same precedence but associativity is right-to-left, so when both are used on the same term, they are bound right-to-left.
I noticed that too. Left-associative is all in the higher precede in King's book!
Indeed, confirmed by ISO/IEC 9899:2011 ¬ß6.5.2 and ¬ß6.5.3. So the operator precedence table in FreeBSD is a lie!
* `-Wformat` is included in `-Wall`. * Do *not* use `-O0` unless you are actually trying to debug a piece of code that the optimizer has mangled beyond recognition. Many common mistakes (especially those relating to uninitialized or unused variables) cannot be detected with the optimizer turned off. * Always use `-Werror`. * Some of gcc's sanitizers (especially those enabled by `-fsanitize=undefined`) can have a serious performance impact. Don't use them when building production binaries.
The default is `gnu89`, which is C89 with GNU extensions. Note that some of those extensions conflict with C99; for instance, a variable declared in the initialization clause of a `for` loop lives on after the loop, whereas in C99 its scope and lifetime are limited to the loop body.
My [current project](http://github.com/fuzxxl/24puzzle) is compiled with the following `CFLAGS`: -march=native -O3 -g -std=c11 -I. -Wall -Wno-missing-braces -Wno-parentheses The last two options disable warnings when I initialize an array of arrays or structures like this: int foo[4][4] = { 16, 3, 2, 13, 5, 10, 11, 8, 9, 6, 7, 12, 4, 15, 14, 1, }; and disable warnings when I use the C operator precedence rules in a way clang doesn't approve of. I disagree with clang in this case, so I disabled the warning.
&gt; Always use -Werror I recommend beginners to not use `-Werror` because that makes things errors that are not actually wrong but merely questionable. This gives beginners a wrong idea about what sorts of things the C language allows and what things are not allowed.
Since gcc 6 (I think) the default is now `gnu11` as far as I'm concerned. There are good reasons not to use `gnu89`, the conflicting semantics of `inline` functions being a prime example.
&gt; and -ansi -pedantic in a few cases where I want super portability I'm curious‚Äîwhen do you need portability with a pre-C99 environment? Even MSVC supports (most of) C99 these days, and has for several years.
&gt; I recommend beginners to not use -Werror because that makes things errors that are not actually wrong but merely questionable. On the contrary, it gives them errors for code which is syntactically correct and may even have well-defined semantics but probably doesn't do what they think it does. I've seen code posted here that used `=` instead of `==`, for instance, which `-Werror` would have rejected. I routinely tell people to enable warnings and fix them all before trying to run their program or asking for help, and `-Werror` forces them to follow this advice.
I never advocated using `gnu89`. I generally use build systems which enforce either `c99` or `gnu99`.
If people don't listen to warnings, `-Werror` will only make them annoyed instead of heeding the advice of fixing their warnings willingly. Plus, when debugging code by inserting some debug code or hacks, code can frequently temporarily have unused variables and stuff like that. Super annoying if you have to comment out the declarations every time you change the debug code.
The most visible example is [an archival tool](https://github.com/skeeto/enchive). In a worst case scenario, I want users to be able to access their data pretty much anywhere there's an ANSI C compiler, which would include older versions of MSVC. (Unrelated to this tool, but, where I work, in certain environments MSVC 2010 is the latest available C compiler available.) There is one tiny little use of `stdint.h`, but that's easy enough to adapt to the local host (`config.h`).
What does this line do? Why do you need it? if((merc_ptr = malloc(sizeof(Planet))) == NULL) If you think about that for a bit, you should see what's gone wrong.
 int i = 1; i = ++i + ++i; printf("%d\n", i); This compiles. It's definitely UB though. Try guessing the value. I recall with gcc it displays different values depending on -O settings. 
&gt; crt0.o This isn't `some microsoft shit.` It is the name of the object file used by most C programs to provide the glue code necessary to jump into the main() function. See https://en.wikipedia.org/wiki/Crt0
apparently this is so confusing because people don't think in *expressions*, they just think about assignment of stuff on variables, they completely forget how expressions get evaluated by C. So hence the baffling weird comments in this thread mentioning assignment at all, when assignment has **literally** nothing to do with ++.
-std=c99 by pure inertia is there any concrete advantages anyone can tell me about c11 / c17 ?
speed and simplicity
Wouldn't this be undefined still? The evaluation of the two arguments on the stack cam occur in either order. My apologies, I think you're totally right from looking further into the topic. FYI, it's because we're taught conflicting answers. My statement comes from what I was taught at UNI, and I thought I had verified it, but it looks like I'm completely wrong here. Thanks for the input! 
Most microcontrollers use it
Actually, never thought about individual expressions at all. I was thinking of an entire line of C code and thinking about the precedence of each chunk across the whole thing. Thank you for the insight. Are expressions always evaluated from left to right then? 
C doesn't have a lot of *ambient complexity* which is rampant in other languages, especially C++. Ambient complexity is when you write a piece of code that doesn't use a certain language feature (e.g. exceptions) but you still have to account for the complexity of other code using this language feature (e.g. when a library throws an exception) when writing your code, even though you don't intend to actually use the language feature. Ambient complexity is a refutation for the argument ‚Äúif you don't like a language feature, how about you don't use it?‚Äù For many complicated language features, the mere presence of them forces me to take them into account when writing my code. I don't want to do that. I want to focus on the logic I want to implement, not think about how my code interacts with overloaded operators, exceptions, garbage collection, locales (C is guilty of this one), or character encodings (C is guilty of this one, too). Another reason for why I want a language with less features is that if a language has a certain feature, chances are that this feature is used in the API of some library I want to use, forcing me to learn this feature and use it in my own code just to use the library. I don't want to deal with this shit. I want simply straightforward interfaces that don't force any complexity on my code, so I use C. Also, C has fantastic tooling and a rich set of libraries for every imaginable thing.
About 18 years ago when I started teaching myself programming, C was without a doubt my first love. Here's why, to this day, it's still there: - Relatively small language (especially compared to C++), so it allows you to concentrate on engineering than semantics - The obvious performance gains - Still (and most likely always will be) the de facto standard in Linux system programming - Amplifies understanding of the underlying system and API/ABI
About 25 years worth of legacy code
I'm completely wrong about when i is mutated, but according to the link provided, they do not have the same ranking of precedence, and I believe this was verified by someone in this thread who referenced the section of documentation. If you could provide a link showing otherwise, please do. 
Manual memory manipulation and to force me to NOT using OOP.
For some things, it is just better to use because of how low-level you can program things, while not having to program in something ridiculous like Assembly or MIPs. It doesn't replace high-level languages for many tasks. Many are actually based on C, like Java, people have just taken the time to expand it into something more user-friendly. It's extremely portable, runs on anything without much fuss. Basically, it's for things you need to control as much as possible. Memory management is a pain, but it's also a very powerful tool when you need it.
&gt;Are expressions always evaluated from left to right then? Idk, I'm not a good C programmer lol. Expressions get evaluated by following operator precedence (parentheses, powers, etc) You can go look up the entire operator precedence somewhere if you google it. My point is that the "x++" and "++x" have different VALUES while the expression is being evaluated, so idk if you can talk about these as "precedence".. Only after the expression is evaluated is the x++ operation carried out.
Atomics, a specified memory model, thread-local storage, and a way to specify alignment are pretty nice. The rest is rather boring or outright useless (bounds-checking interface, threading).
C has been around for decades and will continue to be around almost indefinitely I think.. As long as computers work at a fundamental level as they do now I don't see a reason why C will ever be deprecated or considered "old and shit". Though a lot of starbucks programmers (no offense) will never lay hands on C, that's nothing to worry about since most of the world runs on C and will continue to do so.
Regarding Rust, the compiler support is not nearly as broad, and probably never will be. I also got a similar impression to C++: I spend more time dealing with the language than solving the actual problem, but I'll admit I dindn't spend much time with it. 
But Rust is more simple and fast?
Right, my remark about precedence was in regards to whether assignment happens before the ++ is carried out. &amp;nbsp; b = i++; Here ++ has precedence over the assignment and acts first. So, when some folks said the expression is evaluated first, I incorrectly assumed they meant first b is assigned the value of i, then i is updated. What they meant was, i is returned before the update , then modified. Then, the return value is used for assignment. When I say left to right evaluation, here, I mean something like (Expr1) + (Exp2) I'm wondering if the two expressions can be evaluated in any order (which is separate from precedence since they are separate expressions). I'm tempted to say any order since function arguments are also evaluated in any order. 
I like getting segfaults
I used to program in Java quite a lot, however it seems there is some perceived need to include the latest fad features from various new(er) languages. Many of these features while they (sometimes) help to reduce complexity for the coder, often make the code itself harder to read, and to see just whats going on. In contrast C is a stable language with a fairly low level simplicity, while this low level nature can mean the coder is often confronted with more to do, code should be easier to read and follow, while lower level its not so low (like assembly) that you need reams of code for fairly simple tasks... and when all said an done, with all these various abstractions (lambdas, monads etc) do you think the CPU deals with any of this...
Pre-existing programs that need C to extend them, or C code to provide an interface to other code bases. Portable assembly.
&gt; Though a lot of starbucks programmers I love that! I think I'll steal it. And I love the rest of your very true post, too.
I haven't used Rust, but I'm willing to bet it's more complicated than C, because it has more features.
Someone down voted you for this comment? Don't worry your sarcasm isn't lost on the rest of us.
Thanks for all that and "ambient complexity". Another phrase I think I'll use from now on.
On a microcontroller: * choices are assembler or C * I'm not a masochist
I can definitely relate to this. In high school and in university computer science was dominated by Java because "there's no need to use any other language". All the while I really had no idea what was going on. It pretty much came down to knowing the right set of "magic words" to make the text that fit the assignment appear in the output console on the IDE. It wasn't until I started learning C in the console where computer programming became something that was mechanical and made sense. You allocate a specific area of memory. Each data type uses a specific number of bytes. It became something that I could break down and have an image of how the computer was interpreting the code I wrote as machine language, and not just praying to the gods of Java that my code would magically compile for the assignment.
C absolutely dominates the embedded world. There is no other option that is half as mature and widely supported as C.
"Ambient complexity" is a pretty elegant term for what I was searching for. I use C mostly to study computer programming in my free time. But I don't have a very good reason to tell other people *why* I specially focus on C. The best reason I could think of is the lack of complexity. C++ seems to add a lot of syntax sugar to C, specially with Object Oriented Programing, name spaces, and a lot of other higher level concepts that often become the focus of the language. Likewise Java is a very robust and "complete" language but a lot development seems to focus on learning a great deal of terminology. You have private classes, public classes, interfaces, abstractions, inheritance and other other number of terms that seems to find their way into the ecosystem. C is kind of the antithesis of all of that. It's a few very basic set of data-types and function calls that pretty much seem to be almost straight translations from assembly language into more manageable syntax. You do have the cost of learning about pointers and memory allocation, but the two benefits of that is you learn about "the world beneath" that higher languages hide from you. And you have a very simple language that does what you need it to do.
There's a great, recently-published essay on this topic: [Some Were Meant for C](http://www.cl.cam.ac.uk/~srk31/research/papers/kell17some-preprint.pdf) [PDF]. I think it does a good job of putting into words why so many of us continue to use C. It's main argument is that C has a *communicative* design: &gt; Again, performance is not the issue; I will argue that *communication* &gt; is what defines system-building, and that C‚Äôs design, particularly its &gt; use of *memory* and explicit *representations*, embodies a &gt; "first-class" approach to communication which is lacking in existing &gt; "safe" languages The most significant way this manifests is in *linking versus dominance*. In managed languages, one language or system component must typically dominate another, rather than exist *alongside*: &gt; This symmetric, flat, language-agnostic "linking" composition operator &gt; is the complete opposite of present foreign function interfaces' &gt; offerings. These provide only directional, hierarchical notions of &gt; "extending" and (often separately) "embedding" APIs. The former lets &gt; one introduce foreign code (usually C) as a new primitive in the VM, &gt; but only if the C is coded to some VM-specified interface. The latter &gt; lets foreign code call into VM-hosted code, but again, only using an &gt; API that the VM de- fines. "A C API is enough" is the VM engineer‚Äôs &gt; mantra. The resulting glue code is not only a mess, but worse, is &gt; required to be in C‚Ä¶ all of this for a programmer trying not to use C! If that doesn't convince you to read it, at least enjoy the opening story: &gt; The lyric from which this essay borrows its title evokes two &gt; contrasting ways of being: that of the idealist who longs to be among &gt; the clouds, and that of the sea-farers who carry on their business on &gt; the planet‚Äôs all-too-limiting surface. The idealist in the song is a &gt; priest, who takes literally to the clouds: one day, clutching at &gt; helium balloons, he steps off a cliff edge, floats up and away, and is &gt; never seen again. &gt; &gt; Meanwhile, the tug-boats far below symbolise another way to live: &gt; plying their trade along the rocky shoreline that is nature‚Äôs &gt; unmovable constraint. The seafarers‚Äô perspective is limited and &gt; earth-bound, shaped and constrained by hard practicality. &gt; &gt; Both viewpoints are familiar to anyone interested in programming. The &gt; singer sympathises with the priest, as can we all: it is natural to &gt; dream of a better world (or language, or system) overcoming present &gt; earthly constraints, moving over and beyond the ugly realities on the &gt; ground. But the priest‚Äôs fate is not a happy one. Meanwhile, just as &gt; the tug-boat crews are doing the world‚Äôs work, the C language &gt; continues to be a medium for much of the world‚Äôs working software‚Äîto &gt; the continued regret of many researchers. 
Thank you. I made this term up after thinking about why less features are often better.
C++ is used on micros, albeit less commonly
here is slightly longish (2h) talk by eskil-steenberg on [how he programs in c]( https://www.youtube.com/watch?v=443UNeGrFoM) where he elucidates his reasons as well.
Were you not satisfied with the answers you received [here](https://www.reddit.com/r/C_Programming/comments/7fywpj/determining_if_a_function_is_a_prime/)?
Please don't delete your posts after receiving an answer. That's just a shit thing to do!
The complete text is from an [C99 draft](http://port70.net/~nsz/c/c99/n1256.html#6.3.2.2p1): &gt; The (nonexistent) value of a void expression (an expression that has type void) shall not be used in any way, and implicit or explicit conversions (except to void) shall not be applied to such an expression. If an expression of any other type is evaluated as a void expression, its value or designator is discarded. (A void expression is evaluated for its side effects.) I understand it that *using* (e. g. assigning) the *value* of an expression returning `void` shouldn't be allowed. You never use any values with `void;` 
It's not an expression of type `void`. It's a declaration of variables of type `void` with no variables being declared.
Cause I like it low. And I don't pretend to learn any higher level languages apart system languages as Bash or Powershell As for Rust, it still does not have enough jobs! So I could not care less...later for sure! 
That is exacltly I hope for a new simple C replacement. Rust is even complexer than C++! 
I think Go fits the bill quite well for some applications.
I no longer receive an infinite loop after getting rid of the i=0 but for some numbers like 49 im still receiving the wrong prompt If I were to describe this in english, I know that a prime number has a total of 2 factors and it has to be divisible by itself and 1 to be considered prime but I'm still confused as to how this code isn't performing for specific numbers. Ive tried changing (i=2; i&lt;=(number%2); i++) to (i=2; i*i&lt;=number-1; i++) and its giving me the same issues and I've also tried to increment the count under the if statement. 
Why is that a shit thing to do ? I was told this was proper etiquette 
Aah, yes
Certainly more complex but C++ absolutely takes the cake with over complexity. There‚Äôs just a million ways to do everything. 
It means the functions might take more arguments. It is called variable arguments (varargs).
When someone in the future has the same question as you, he can use a search engine and find your thread with the answer he got. However, deleted threads can't be found by search engines, so when you delete your thread you permanently remove all answers you got, erasing the work of those who helped you. I don't write answers so just you get help, I write answers so future readers can profit, too! Don't deprieve the people in this subreddit of this effect!
And Python, now, apparently
Rust is more simple? It is as complex as C++ or Fortran! 
Update the flair on the post changing from Question to Solved Edit the post text to either include your solution or with a link to the comment with all the details to solution. This lets people find you question, see the answer, and learn from your mistake!
Portability. Before Python, Ruby, Java, Go, Rust, Node.js and other cool languages can be bootstrapped to some shiny new operating system, a C compiler must be ported there. Which means C continues to be the most portable language.
Thanks!
Rust is offensive: complex, ugly, and (currently) unstable. (I honestly think its borrow-checker will doom it from significant adoption.) But Go is something I could swallow as a C replacement in certain situations.
C++? GOOD GRIEF
C is fast, pretty straightforward, small, portable, no fancy craziness although if you wanna go there; there is nothing stopping you ie #define abuse. Years and years of code so examples are plenty, most programmers pick up C fairly easy especially if they already use a language that mimics some of the syntax like javascript or java. Between C and Python I have little need for anything else aside from shell scripts but python could replace that if I felt like it was worth the effort. We come to my final reason it was my first real language, I started with html and css got to where I understood a bit of what was happening under the hood then went straight to C, that was 9 years ago, and I'm still learning things in C xD.
All numbers are divisible by themselves. A prime number has only only two factors 1 (not normally counted as a factor) and itself. So you need to figure out how to make sure it doesn't have any factors other than itself. Your loop for (i=2; i&lt;=(number%2); i++) has an empty body. So that code does nothing. If you can use C99 (or new) C code, you can declare the loop variable as part of the for-loop, rewriting the above: for (int i=2; i&lt;=(number%2); i++) This makes i only visible inside the loop body. This style (again needs C99 or newer standard, -std=c99 will tell clang/gcc to use that C-standard) is common in most C-based languages, and will likely help you fix some of the problems with your code. Another suggestion is to be more clear with your indents. Part of this how you put your code in your reddit post. To format code properly on reddit, skip a line then put four spaces in front of each line, use additional 4 spaces for each level of indent (see the formatting help button below your post-input text box to see example). If you have proper indents, you might see the problems with your code more readily. You might try rubber duck-debugging your code in a comment to one of your posts on this code. Someone will likely be able to explain where your view of what the code does differs from what it does. 
because I consider myself a beginner in C I just went and made this small dummy program: #include &lt;stdio.h&gt; int main(){ int n1, n2, n3; n1 = 5 + (n2 = 1 + (n3 = 0)); printf("n1:%d n2:%d n3:%d", n1, n2, n3); } When I run this with gcc I get n1: 6 n2:1 n3:0 So yeah, they get evaluated left to right I think. Damn that expression was a weird one, first time I run into the term "lvalue" in C so far... 
Nope. Go has garbage collector! 
How do you get C auto completion to work in Spacemacs? I have the C layer of course, and it works really well for completing all the functions I‚Äôve have written in my project, however it doesn‚Äôt seem to complete native C functions. Do you have this same problem? Any advice on getting it to work?
the guy is a noob!
https://github.com/syl20bnr/spacemacs/tree/master/layers/%2Blang/c-c%2B%2B
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [syl20bnr/spacemacs/.../**c-c%2B%2B** (master ‚Üí 4bb4cb4)](https://github.com/syl20bnr/spacemacs/tree/4bb4cb46968e5bbb98fffd480c8c822269fced4f/layers/%2Blang/c-c%2B%2B) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
I don't know much Rust to be frank, but compared to C++17 Rust is a walk in the park.
In recent years, I've used C for embedded processors, Linux device drivers, and for times when python just isn't fast enough.
I started learning and coding C to eventually make a contribution to the Linux kernel or GNU, or other applications on the Linux stack. Plenty of it is written in C, and it was the only language I didn't really know well. I still don't know it perfectly by heart, but enough to write functional applications with it - and most of all, how to read C. At first (~15 years ago) I loathed C due to it's "low levelness" and lacking language features, but I've come to appreciate it over the years, exactly due to what /u/FUZxxl said: it doesn't a have a lot of this *ambient complexity*. It just is what it is, and the spec hasn't changed that much over the years. Which is actually great.
you mean a jurassic park?
Hmm I may have to take a look at Rust then. C++ is the bane of my existence. My only fear is that when I look at Rust code it isn't obvious to me what the code does right off the bat because the syntax seems very weird. I'll have to give it a more in depth try though. Cargo seems really cool though
As for warnings, clang's -Weverything reports ALL warnings and errors, unlike gcc's clusterfuck of options.
Could you see Rust possibly moving into a significant role in your field?
Why not set that array as const?
I use `_Generic` and I'm trying to add some error handling stuff as `_Static_assert`, both of which are only available in C11 or later.
Depends on how you define ‚Äúembedded‚Äù. I've worked on high-end embedded systems where the core application (including a lot of DSP code) was in C but the user interface used Qt.
Honestly, the biggest reason I use C is because I simply don't like the way functions are "children" of classes in C++. I wish we could add some generic data types tho that would really help with memory use in cases that shit doesn't need to use the max, for processing images for example so I've been thinking about using C++ for templates but literally just that. I'm not sure if it's really worth it tho, and as I said, I'd have to convert everything to a class to use templates anyway.
The problem with go for me (and Rust too) is they the syntax is just fucking weird. in go you can't capitalize variables or functions unless you want a certain behavior, fuck that. in rust, you have to prefix all your functions with `fn` for no real reason, and a bunch of other shit I'm forgetting. 
Glad to help expand someone's knowledge. If it makes you feel any better, I did not expect that the output would report the Initial as the already incremented value.
C is powerful, efficient, elegant, and I've spent 25 years learning it because most of my early career was in fields where it was the only realistic choice. 
For me the syntax is still something to get used to. Like I said I don't know much, but the language and compiler helps you to prevent lots of mistakes (nice error messages). I'm more fond of Go at the moment (although that has its quirks...) but maybe that'll change once I get to know Rust. A while ago I got myself a book about C++11 (that guy who looks like He-man, Scott Meyers IIRC). I skimmed through it, saw all the new syntax and whatever and I was immediately put off. Haven't touched C++ since then :/
The Rust compiler is self hosted (And written in Rust, obviously). Golang seems to be similar, in that it's written almost entirely in Golang itself. There is some C code in the repo, some of it *might* be needed. C is not special in that it's the *only* language you can use to write a new system. It's often the preferred one, but it's by no means your only choice.
that is called a variadic argument, they're kind of a pain in the ass to deal with tbh. I only use them in my logging function, and only there because vprintf exists and handles the nastiness for me ngl.
You can absolutely use bitmasks and even shifts on an array of bytes. btw if you do use char instead of uint8_t, you should make sure that char is unsigned everywhere you compile.
So you're trying to print the variable's name before it's value? that's a good question, I've always just manually wrote it... There is `__func__` which is the same thing but for function names, maybe you should try poking around in that area?
I don't see a version that only does one comparison inside the loop.
Since nobody's mentioned how to use functions with a variable number of arguments... http://en.cppreference.com/w/c/variadic
I really like how much control you're given in C programming. Unions, function pointers, pointers; they're all very nice. I like being able to offest a function pointer to call a function with the incorrect arguments, I like being able to access memory one byte at a time, but still be able to use mathematical operations on it. The only thing I dislike about C is when I have to do string parsing, although using the string.h library alleviates the pain somewhat.
They hired me to do it. (Yay Embedded Systems masters!)
That loop won't even run, because by definition, `number % 2` can never be greater than (or even equal to) 2.
lvalue refers to the thing on the left hand side. In general, we have a left hand side (LHS) and right hand side (RHS). Typically, things on the left must be variables because the LHS usually refers to things being updated while the RHS usually refers to the thing the LHS is being updated with. That is: &amp;nbsp; x = 5; Makes total sense. We are updating x to be associated with the number 5. Reversing this statement would be nonsensical. &amp;nbsp; 5 = x; // Mutate 5 with the value of x ??? Similarly, we cannot use function applications on the LHS. &amp;nbsp; f(x) = 45; // Mutate f(x) with the number 45. So, if the compiler tells you that you cannot assign a value to something because it is not an lvalue, it is usually indicating that you are not referring to a variable. &amp;nbsp; x = ++i++; // Error. "lvalue required as increment operand" The ++ operators are meant to update variables, so the above fails because i++ returns a number and is no longer associated with a particular variable, so the prefix ++ has nothing to do an update on. If you are referring to a location of memory, it is okay though. &amp;nbsp; *x = (64 &amp; 99 * 3); // No problem Here, *x is not itself a variable, but it refers to some physical memory location and it is perfectly suitable to update the value of the LHS. Your provided example pretty much evaluates from right to left because you have mostly assignment (=) operators. The inner parentheses have the highest precedence and are evaluated first (n3 = 0). &amp;nbsp; n1 = 5 + (n2 = 1 + 0) The remaining parentheses have the highest precedence and we evaluate n2 = 1 + 0. Since Addition has precedence over assignment, we resolve 1 + 0 first. &amp;nbsp; n1 = 5 + 1 Now, we resolve the last addition, getting 6, and then the final assignment to n1 happens. &amp;nbsp; What I'm curious about is if you do something like &amp;nbsp; n1, n2 = 4; n1 = (++n2) + (n2 + 3); You should never do this of course. But, what I'm wondering is if each side of the addition can be evaluated in any order. Since both arguments for addition are wrapped in parentheses, they have equal precedence. So, I'm not sure if they can be evaluated in either order. 
I usually tell people who ask for help out-of-band that public answers are free but private answers are $100 / hour. It never fails to piss them off.
Appreciate it! For the prefix case? I think it's likely the arguments are evaluated from right to left since they get pushed onto the stack that way anyways (but they don't have to). So, for both cases, prefix was already updated before initial was evaluated. 
Shouldn't `high = mid + 1` be `high = mid - 1` ?
I appreciate your advice and it doesn't piss me off at all. I believe it's a lesson learned and think you are completely right. 
Change your `printf()` so it shows the values of the three indices as well as what is stored at their locations and you should quickly find your mistake. To simplify debugging, you should also add some sort of protection against an infinite loop; adding `&amp;&amp; n--` to the loop condition will do nicely. (As a precaution, you may also want to add a sentinel at the end of your array.)
Did this with n1 = 2, n2 = 2 Plain gcc gives no warnings about this.. -Wall -Wextra -pedantic gives me warning about undefined behavior of the (++n2) operator. int n1 = 2; int n2 = 2; n1 = (++n2) + (n2 +1); printf("n1: %d, n2: %d", n1, n2); This prints n1=7 and n2=3 soo...?? **if** (n2+1) happened first the parentheses would be 2+1 = 3, and 3+3 = 6 = n1, but that's not the case, n1 is 7, so the ++n2 must have happened after the n2+1 operation to get 7 on n1. (3 + (3++) = 7. But n2 is still 3 when printed. So it's the other way around, ++n2 happens first and makes n2 = 3, the parentheses evaluates to 3 as well, then ( n2 + 1 ) evaluates to 3+1 =4, and 4+3= the 7 we've been looking for. And n2 is still 3 because it didn't change from the evaluation of the 2nd parentheses. 
have you ever used intellij? C tooling is pretty awful. There is no package manager and the IDEs are rather subpar too. 
The borrow-checker is the most important feature of Rust and the people who do switch to Rust do it because of the borrow checker as part of the type system. Why do you think it is a reason against Rust's adoption?
&gt; As long as you don't do tricky things (like type punning or doing weird pointer arithmetic) which you probably shouldn't do in the first place Generally I agree with you, and with this statement. But, it is surprisingly easy to accidentally do some of the tricky/undefined behavior things (like bit shifting a signed int, etc.). Or, to put it another way, some of the tricky things aren't obviously tricky. 
In theory, and I'd love to see some change. But you'll forgive me for being a little skeptical given the state of the industry today. Everyone is in the middle of huge mergers. Everyone leaves their tool chain to ARM and to the open source community. Vendor support is a joke. I pay hundreds of dollars a year for a license on an out-of-date proprietary adaptation of Eclipse (CodeWarrior 11, based on Eclipse Juno) with old versions of gcc and even older compilers for HCS08. I've had a critical priority support ticket open with NXP for three days and I haven't even received anything other than an automated acknowledgement. The C99 standard is still virtually the bleeding edge, and the vendors can't manage to keep up with frameworks in a single language. As far as I can tell there's virtually no one at the major companies doing much of anything themselves. Their processor core IP comes from ARM. ARM packages gcc and their CMSIS libraries and the vendors slap some proprietary plug-ins on Eclipse to make an IDE. If Rust is going to happen, it won't be because the vendors are pushing it. People who want to use it will use it and suffer through the pain of setting up everything themselves. Maybe in 10 or 20 years, if enough people are using it, the vendors will start paying attention. The embedded world is shit these days in a lot of ways. NXP is a $10 billion/year company with 45,000 employees and far and away their best support resource for a major chunk of their product line is one guy, Erich, and his personal blog that he doesn't maintain on company time. I feel like they really must try hard to suck that bad. I've gotten exactly the answer I needed from that blog half a dozen times in the past week alone. From NXP's official support, I hear things like no, they don't know what the VREF chop oscillator option does or how it works, there's no more documentation and they're not going to try to figure it out. And yeah, they know the examples in the SDK docs don't necessarily work or even compile and you should just ignore those. Maybe if there was a big shift in the automotive industry and they all decided to use Rust, we'd see some movement then.
Im still learning it, but im doing so because i want to start with a good understanding of programming. Ive read C is good for that 
I'm not quite sure what you're trying to say, or what's weird about this code. First, the expression `n3 = 0` evaluates to 0 and sets `n3` as a side effect. Next, the expression `n2 = 1 + 0` evaluates to 1 and sets `n2` as a side effect. Finally, the expression `n1 = 5 + 1` evaluates to 6 and sets `n1` as a side effect. Its value is discarded.
It's a complex part of that language must be learned up front, sort of like pointers in C. That's a significant barrier to entry. But unlike pointers, in most situations it costs more (cognitively) than it's worth. That makes it a hard sell to newcomers.
I think what attracts me to C the most is the absolute precision of it. It does exactly what you tell it to. Not more, not less. I feel like a lot of languages come with a certain amount of innate complexity which is never really explained in the manual. Sure, all these clever built-in types are *simple*, but you don't really know how certain data is represented in memory, how much memory it actually takes up, or even the amount going on behind the scenes to perform simple operations on it. Unless you actually went and read the source code (which is very likely written in C in many cases!) then you won't really learn about how the implementation *actually works*. I feel like learning and using C is much more of a lesson in telling a computer what you want it to do precisely, and getting a precise result.
&gt; Or, to put it another way, some of the tricky things aren't obviously tricky. In Annex J (portability issues) of the standard, all these cases are listed. Most are super obscure, shifting a signed integer is a rare exception.
I have never used an IDE and I never will. IDEs suck and I don't want to use them. I don't want a package manager integrated into the toolchain either because if a language provides its own package manager, people start to depend on tons of packages, making development and debugging a huge pain in the ass. Note that there are very good solutions for dealing with external dependencies (e.g. `pkg-config`), in practice it's not very difficult to use these and your distribution provides a package manager.
I welcome your next question! It's okay not to know this, it's not really an obvious thing either.
These newcomers will then go on to write terrible code, which is a problem. The borrow checker prevents you from writing code that you most likely shouldn't be writing. I am an embedded developer so obviously I use C (many platforms used to have only C compilers available), but there is a lot of low level concurrent code with no help from an OS (because there is no OS). Getting that right is frustratingly hard, and debugging other people's C code who make errors because the C compiler just lets everything pass is even more frustrating. I am currently learning Rust because I hope it can help me someday and maybe it wont. But if a borrow checker is to difficult then I honestly don't trust that person to write concurrent code.
AFAIK it was just talking about rvalues and lvalues and that might help beginners understanding expressions and assignments. So basically no question at all, but just giving intentional information. But now it is deleted, so it doesn't matter now anyway.
That's LLVM dude, not rust. you get the exact same benefits (actually more since Rust uses an ancient fork of LLVM) with C or C++.
Yup, strings are a major pain point. I really hope C2x adds support for UTF8.
FFmpeg is complete and utter shit.
Ok. Fair! 
:(
https://github.com/collinoswalt/8080-Remote Here's the code 
I think it can still be evaluated in any order though. Meaning testing it on 1 machine is useless and only the documentation can provide clear insight. &amp;nbsp; int n1 = 2; int n2 = 2; n1 = (n2++) + (n2 + 1); printf("n1: %d, n2: %d", n1, n2); // n1 = 6, n2 = 3 &amp;nbsp; (n2++) changes n2 to 3 and resolves to 2. (n2 + 1) evaluates to 4. So, n1 being 6 and n2 being 3 should be a possible solution (but not the only possible).
IDE? lmaaaoooooOO!
You are talking about C#, Java and Python programmers ...any low-level programmer won't see that borrow checker as "beautiful"! 
&gt; and everybody else wanted to do theirs in C or Java, but not C. Uh, I think you mean some other language. Let's go to your repo. First of all, there is too much stuff, like session files, swap files, `:w` and even object files. [`.gitignore`](https://git-scm.com/docs/gitignore) is your friend. Also, please don't hardcode the compiler into your `make` file. I only briefly looked at your code. This is what I noticed: [You semi-hardcoded the temp-files](https://github.com/collinoswalt/8080-Remote/blob/master/src/libemulator.c#L229). Since you use POSIX functions anyway as far as I saw you could just use [mkdtemp}](http://man7.org/linux/man-pages/man3/mkdtemp.3.html) or [mkstemp](http://man7.org/linux/man-pages/man3/mkstemp.3.html)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [collinoswalt/8080-Remote/.../**libemulator.c#L229** (master ‚Üí e031efc)](https://github.com/collinoswalt/8080-Remote/blob/e031efc20d8246aea65343de5e23f141f799bd6d/src/libemulator.c#L229) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dqith9k.)^.
Yep, let's guilt the tool, not the one using it! I get the safety part and concurrency but this(preventing to write bad code) is a laughable excuse at least! So Rust boy think that they will always write "correct" code...haha
What compiler compiled the first Rust compiler?
because i love seg faults
Yeah I meant C++ not C. I haven't developed an edit function into my blog yet lol. Also I'm not good at git lol (I need to git good). It's something that continues to elude me at work. I'll look at those functions, thanks!
Nowadays with all C libraries and tools...C is still the only choice yet! Maybe in the next 10 years, Rust will change it! 
 for (i = year1; i &lt;= nl; i++) `i` must go from 1 to nl ie. for (i = 1; i &lt; nl; i++) 
Tip: put an additional four spaces before each line of code and Reddit will treat it as code. Here's the code we need to discuss: arr = (int **)malloc(sizeof(int *) * nl); arr[0] = (int *)malloc(sizeof(int) * 6 * nl); for (i = year1; i &lt; nl; i++) arr[i] = (*arr + c * nl); Now, there's two different ways of creating dynamic 2D arrays like this ... and your code tries to mix them together. I'll discuss both methods. First, let's go with the "ragged array" version. If you were to do this, the code would be: int** arr = (int **)malloc(sizeof(int *) * nl); for ( i = 0; i &lt; nl; i++ ) arr[i] = (int*)malloc(sizeof(int) * 6); // Use arr[x][y] for ( i = 0; i &lt; nl; i++ ) free(arr[i]); free(arr); `arr` is an array of pointers, each of which points to a separately-allocated array of 6 integers. This method lets you have rows with different lengths: unnecessary in your case, but there's nothing wrong with just having the same length for each. I also put in the way you free that memory when you're done, since you didn't have that in your original code. The second method is to allocate a block of memory as is done with statically-allocated arrays: int (*arr)[6] = (int(*)[6])malloc(sizeof(int) * 6 * nl); // Use arr[x][y] free(arr); The syntax is a bit strange, but there you go. Since this is C, you don't need the cast, if that makes things easier. In this case, `arr` is a pointer to rows of 6 integers. The allocation creates the entire block of memory, and the pointer can step through each one. Now, as I said, you've tried to do something of a mix between these two methods: allocating `arr` like the first method, but them pointing it to individual rows as allocated in the second method. Yes, you can do that, too: int** arr = (int **)malloc(sizeof(int *) * nl); int (*rows)[6] = (int(*)[6])malloc(sizeof(int) * 6 * nl); for ( int i = 0; i &lt; nl; i++ ) arr[i] = rows[i]; // Use arr[x][y] free(rows); free(arr); But I think you can see why this doesn't make much sense to do, in your case. Why not just use `rows` directly? Also, noticed I stored the block of memory in a separate pointer, while you used `arr[0]`. That's an important detail. We could have also allocated `rows` as a block of `int` instead of the fancy pointer to an array, and this is basically what you were trying to do: int** arr = (int **)malloc(sizeof(int *) * nl); int* rows = (int*)malloc(sizeof(int) * 6 * nl); for ( int i = 0; i &lt; nl; i++ ) arr[i] = rows + 6 * i; // Use arr[x][y] free(rows); free(arr);
OCaml. That compiler is self hosted too. I *think* it started out as C.
I am a C programmer, not Rust. I didn't mean to say that Rust prevents you from writing bad code in general, but I think it does prevent some errors that C doesn't, that is all.
What are your go to libraries that implement the mainstream data structures and algorithms? 
A language-specific pkg-manager is just a hack for using crappy OSes. 
Sure I do. I've written an OS in it. It's beautiful
There a lots of problems with this code. The loop never executing is one of them yes (thought it had already been mentioned, might have been the other post about this code). It not having anything in a body is problem as well. I'm getting at the fact that the suspicious code block uses the loop variable (i), which would be clear error at compile time if the scope of the variable was more limited. 
I am primarily a low level programmer and that is also my primary viewpoint. I think that a compiler enforced help for memory management is in most cases better than pure mental "Did I think of everything" manual memory management. That is my opinion and I don't know what GC language people think of Rust.
There's no garbage collection in Rust. And tbh writing `fn` before a function kind of makes sense, especially when you consider that in C there is no 'function definition' keyword as is found in most other languages.
C's biggest benefit is that it defines an "execution model": you can have a very good idea of what execution will happen if you write certain code. It's all addresses and opcodes. But this is also a weakness of the language imo: it forces an antique execution model onto modern computers that don't really execute that way anymore. Specifically C is memory-centric and is loose with aliases; whereas most performant code these days has to be register-and-cache-centric with very exact aliasing. hacks like the `restrict` qualifier just make the pain worse imo.
Well said. I personally prefer to code in Vim, and have made it exactly as IDE-like as I want it (line numbers, syntax highlighting, autoindent, autocomplete parentheses, etc). It's also faster and more responsive than any IDE.
I haven't had the need for anything fancy so far. Maps and arrays are built into the language, other things are rarely needed and usually very specific to the problem at hand.
it seems to me that you have never used an IDE like IntelliJ to it's full intent. There is so so much more to it than autocompletion. It's slow, yes, but the amount of time I'm saving every day through the linter and intention actions makes up for that 10 fold. 
Found the answer to our long replies: From inside K&amp;R which I'm reading right now: &gt;x = f() + g(); f may be evaluated before g or vice versa; thus if either f or g alters a variable on which the other depends, x can depend on the order of evaluation. Intermediate results can be stored in temporary variables to ensure a particular sequence. Function calls, nested assignment statements, and increment and decrement operators cause "side effects"-some variable is changed as a by-product of the evaluation of an expression. In any expression involvingside effects, there can be subtle dependencieson the order in which variables taking part in the expression are updated. Compilers can interpret this in different ways, and generate different answers depending on their interpretation. The standard intentionally leaves most such matters unspecified. When side effects (assignment to variables) take place within an expression is left to the discretion of the compiler, since the best order depends strongly on machine architecture. (The standard does specify that all side effects on arguments take. effect before a function is called, but that would not help in the call to printf above.) The moral is that writing code that depends on order of evaluation is a bad programming practice in any language. Naturally, it is necessary to know what things to avoid, but if you don't know how they are done on various machines, you won't be tempted to take advantage of a particular implementation. 
I *have* used IntelliJ, and I used it a lot. But once I spent some time with Vim and got past the initial speedbump of a completely new editing model, I was much more efficient at coding with it.
Interesting. In high school I did maybe 15/20h programming with AlgoBox (a pseudo code IDE which interprets your pseudo code...in python). It was very maths oriented. In college we started by learning C. Two years of that. Then we did OOP but with Java only as an example for the OOP concepts. Most of the course was UML. Now we are ctrl+spacing our way through advanced OOP class wich is just java with a shit teacher. 
True! Though there was a time when I was frustrated with having to reinvent the wheel in C for more complex projects. Then I learnt how to Google and stack overflow ! 
Perhaps I've never used an IDE to it's full extent either. I do have linting enabled in my vim configuration. The more you use and learn vim, the more time you can save in everything that you do. The only real benefit that I ever saw in an IDE was for verbose and behemoth languages like Java (never really played with c++). The IDE was always helpful when I needed to stub out generic classes and interfaces.
Similar, when I interned, the core of everything was in C but the higher level applications were in C++(98, not the good kind)
Unless you need them though. Then it may get messy with C.
Why?
What I really miss in C is a dynamic/flexible array. I have my self-rolled implementation when I need it, but things like std::vector in C++ or ArrayList in Java are quite handy. In addition to being standard.
Use IntelliJ combined with a Vim plugin. Problem solved.
I don't agree on the trade-offs there. The borrow-checker, after all, also enforces thread-safety, which is not something that's enforcible in most languages (other than [Pony](https://www.ponylang.org/discover/#what-is-pony).
C17 is currently drafted though (but not much than a "bugfix" afaik)
&gt; As long as computers work at a fundamental level as they do now I don't see a reason why C will ever be deprecated or considered "old and shit". I can imagine a day, in my lifetime, when there are no longer - in general use at least - computing devices which aren't connected to the Internet. In that kind of environment, implementing a system in C would likely over time come to be regarded as irresponsible (because of the near certainty of security holes in nontrivial network-facing C programs).
where does it say that? Official docs list them as the same flag, `-pedantic` is just the older one.
`-pedantic` is just the old name for it that's more widely supported.
&gt; You get enough abstraction to be usable, I think that's a bit generous. I got fed up of re-implementing data structures again and again in C, more than ten years ago.
I'm pretty sure they don't even support declarations mixed with implementation yet...
I also add -Wmissing-prototypes etc.
Thanks for the explanation. I should point out that GNU is mostly written in C because, at the time the project was new, C was the _only_ systems programming language widely portable to the (mostly Unix) systems that the GNU system was intended to run on.
Although I code in vim there is C lion which is good, there is also an eclipse version for C/C++. I just don't think they are necessary when you can have cmake and vim.
Honestly, I don't really use C for anything new these days, just existing projects. C++11 made C++ so much more attractive that I use it for anything I would have picked C for in the past.
If your running out of both FLASH and RAM then I think you should be looking for a microcontroller with more memory. It's safer to have a reserve in memory, if you have to add some code later you'll still have the space to store it.
Best answer. To me it started because of university, (I used to program in Python) and I just converted all my projects into C since. I really like the way the language works and how much you can do with it. For example we had a project to make a small game, I would normally use classes but I managed to make all the characters with structs. And now that I am in the robotics team C is just amazing. Being able to program pins and different weird chips is really cool, although some stuff require assembly.
I tried and it just doesn't feel right, it's like getting a normal car and trying to put monster truck wheels on it, It may be me, but it just didn't work. + it doest as look as nice as a terminal ;)
I have to use this microcontroller
There's often a trade-off between space and speed. You might be able to use a slower algorithm that uses less code, for example. Make sure you're not duplicating code, but call a function instead. And last, many compilers can optimize for space (instead of making the code faster), which can help.
Hard to say without seeing your code.
There's always something newer, something more low level that you can learn about C. It's great.
&gt; I like being able to offest a function pointer to call a function with the incorrect arguments I've never thought about this. Do you have examples of how it works? Sounds awesome (and hackish).
Is Ada still relevant? I've personally (AFAIK) never ran into anything written in Ada.
What's the ratio of code to data? If you have a lot of compressible data, then the amount saved by compressing it may offset the extra decompression code you'll need.
Maybe restate your question without the silly data bomb. There are a million ways to do fft processing and near as anyone can tell ( a guess? ) you just want to perform an fft on a twwo dimensional array of data points? Really? There are math packages that will do that for you neatly.
i tried to use fftw3 library but was not able to cross compile it in my pc after spending more then a month but nothing achieved. i am using vivado SDK and now i am trying to do it by myself and first thing which i have to do is to perform fftshift on the above data.
[stb_sb](https://github.com/nothings/stb/blob/master/stretchy_buffer.h) is a vector&lt;&gt; like type. I have never used it but I have read great things about stb.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [nothings/stb/.../**stretchy_buffer.h** (master ‚Üí 9d9f75e)](https://github.com/nothings/stb/blob/9d9f75eb682dd98b34de08bb5c489c6c561c9fa6/stretchy_buffer.h) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dqj7oh7.)^.
whoops, please disregard my statement. 
Is that data complete? It seems to be non-square in that there are 24 data points ( complex real and imag parts ) per line and a full 33 lines which is hardly a square matrix. Last time I checked nearly every algo wants a square input matrix but I may be wrong. Also the data seems a bit off in that it could all be scaled between -1 and +1 with a divisor of 1000 and you would still be well within the precision of IEEE754 double types ( 64-bits with 53 bits implied precision ). The factor of a 1000 won't mean much in the output as it is a constant applied across the whole data set. Anyways the non-square matrix will require some padding or cropping. Perhaps. Is this actual experimental data from some sensors or just made up stuff?
It is just RAM or flash? You can always unload things you aren't currently using and reload them. I assume you've done the easy stuff like using the smallest numerical types you can. bit-pack your structs, and cut anything you don't need (localization, font data for characters/symbols you never use). Like all optimization, you have to see what is using up your space and focus on that.
You won't get any very specific help unless you state what you're currently using all the memory for. What's the code doing? Is multithreaded? Is the code running from ROM/Flash or RAM?
Is there a C tool for generics? As in, it compiles to void *, but does some type checking beforehand? This is the only thing missing in C for me -- everything else is lovely.
Add an assertion that your algorithm makes progress at every iteration. Also high+low can overflow, of course.
"varargs" is potentially misleading since that is the pre-ANSI C name.