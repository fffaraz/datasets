Basic electronics, reading and understanding datasheets, understanding communication protocols (UART, SPI, I2C etc) and understanding bare metal hardware. I'm an embedded engineer coming from a software background. It wasn't easy to transition, but with a background in C development and an interest in electronics, you should learn very quickly.
you could use ---&gt;&gt; for (int i=0;i&lt;100;i++){ scanf( "%c", &amp;name\[ i \] ); } ------&gt;instead of 100 u can put number that is below 100 so u dont have to write all 100 letters or u could do this scanf( "%s",&amp;name );
Do your own homework /r/csharp/
If a light is coming on then you are setting up the registers which is a great start for AVR's, go you! Your two big problems, By calling while(1) this is saying execute the loop while the contents of the brackets is true. And 1 is always true which is why program is stuck flashing only 1 LED as you have created an infinite while loop. Even if it did break that loop you are then calling return 2. A return statement is a way of exiting from a function and then returns the value stated to whoever called this function. By using return in the main function you end the main function which will exit the program. Hopefully this will put you back on the right path! Good luck
Scanf(" %s", name) Space is key
The solution uses dynamic programming to avoid excessive yet unnecesary recursive calls. The storage for dynamic programming depends on the indices of the input string and of the input pattern, therefore it should be a 2D array. However, whoever made this solution uses a 1D array (allocated in line 12 with sufficient size to be used as a 2D array) and uses the IDX macro to compute the linearized index given the row and column indices. If you want to learn more look up dynamic programming, multidimensional arrays, and linearization of multidimensional arrays. Good luck!
you're fucking helpful :') good to know you understand jack shit
Thus sub is for programming in C. Try r/csharp
Wrong sub :) https://old.reddit.com/r/csharp/
You're in the wrong sub, genius.
Nope! Heap and stack don't map to pointer or not pointer that way. Strictly speaking they're not even C concepts - the specification only speaks of dynamic and automatic (and static) memory allocation. Automatic memory is what you'd call the stack - you don't need to do any manual allocation, stuff just works out because of scope. Things pop off the stack when their scope ends, roughly. Dynamic memory is the heap, essentially - it's dynamic in the sense that you get control over when it's allocated and deallocated. That's where `malloc` and `free` come in, which do return pointers. But a pointer can also point to automatic memory, and the memory being pointed-to doesn't make it dynamic or change its location in the memory model.
This is a key idea which can be very powerful if used correctly. For example if you have a downstream function that requires access to foo (created on the stack) and foo is sufficiently large or you want to update values inside foo you can still pass the pointer to your downstream function. There are many good use cases for this but it’s a powerful idea for how to manage memory in your application.
It all depends on what you did with all of those variables.Let's take this snippet as an example: struct foo_s { char *mychar; int myint; }; int main(void) { foo_s *foo = malloc(sizeof(foo_s)); char c = '5'; foo-&gt;mychar = c; foo-&gt;myint = 2; } Here, since it is a variable declared inside a function, foo will be located in this function's stack. Since it's value has been malloc'd, *foo is an address on the stack, as well as foo-&gt;myint and foo-&gt;mychar. But, as foo-&gt;mychar is a pointer to a variable declared in this function, i.e. on the stack, so *(foo-&gt;mychar) is on the stack.
Removing } return 2; while (2) { would toggle two leds
This is probably not the best idea, but hey.
Socket writes are always interruptible, so when the main thread exits any other threads in `write` will be terminated midway through that operation.
/r/Tall would love you
Does this perform better than a non-AI solution written by eyeballing the data?
I'm sure there are other ways to do it. After all, I had to eyeball the data to get this to work! But, now that it works, it can be expanded to include many more fields and many more records. It can also express confidence in the prediction and weight some features as better predictors than others.
The code, at this stage, would probably predict that every member is male. But, the whole point is for the code to learn from its mistakes and learn how to predict with greater and greater accuracy.
MOTHEFUCKER THINKS THERE ARE ONLY 2 GENDERS LOLLLLL
suckacock little bitch
The network is just a nonlinear function estimator. A simple polynomial regression will perform exactly the same way, and is a lot easier with such low-dimensional input. This is a neat showcase of how these networks can actually estimate any function depending on the data you throw in there, though.
I know this is a shitpost, but given that it outputs gender as a float from 0.0 to 1.0, I would say that it interprets gender as a spectrum.
Remove the ampersand. There is no need for it there because an array in a pointer to the first position of an array. Your code should look like this: `scanf("%c", name);` Note: This only applies when dealing with arrays.
Cool project! Just a thought, using sex instead of gender would make a lot more sense for this purpose. If a biological male identifies as a woman, that’d throw off the neural network. Also, I’d imagine that age would be an important factor - I’d expect a 17-year-old to weigh a lot less than. 45-year-old of the same height and shoe size. Where are you getting the data from?
We're not here to do your homework. Do you have any specific questions related to how you would complete this assignment?
More spaces would be nice.
You just need to use the thread safe version of functions, e.g. strtok_r instead of strtok. Also ensure you don't have race conditions by using mutexes.
Ah ok thanks bud!
I think I found my crash source, I was using localtime() and asctime() in all of my threads. They are called rarely so I think I will just wrap them into a critical section rather than use the thread safe variants!
[removed]
[removed]
I wouldnt hire you at min wage
I’m not all that familiar with Windows with their threads and specific thread safe functions, but here’s something that can help with clashing: If you have any critical sections in your code (code where there may be shared values between threads), it would be a good idea to incorporate a synchronization mechanism to prevent race conditions. In short, on most computer architectures, changing a value takes 3 steps. Threads can be switched at any point and cause trouble. Although you aren’t using pthread.h for making threads, that library has a synchronization mechanism called a mutex (mutual exclusion). You can use them to lock down critical sections of code so threads can only access it one at a time. You may have already known about this, but I’m just putting it out there since it may help. You can certainly use thread-safe functions but in the event that one doesn’t exist or you’re using your own functions and want to play it safe, mutexes are a good way to go. Just some food for thought. Good luck on your program!
This clears the error, however my code now just doesn’t work so i changed it back lol. Changing it to scanf(“%s”, name) makes my code do all sorts of weird things. Sometimes I have to hit enter twice to bypass the scanf(), sometimes I get a segfault. Keep in mind I am using the name field to pass information to a struct. Ugh someone would probably have to see my actual code to see what is going on because it is quite complicated. I also am using a call to scanf(“s”, trash) to clear the buffer between each time I want to get some kind of information from the user.
Please do not post this kind of content.
Why ?
REEEEEEEEEEEEEEE
There is a general ban on beginner tutorials except if they are exceptionally good. There are thousands of tutorials out there and if I wouldn't constantly remove them, people like you would constantly spam our subreddit with every single episode of their tutorials. Check out /r/cprog for what this would look like. Experience has shown that our users are universally not interested in random beginner's tutorials. Also, many beginner's tutorials, especially videos, are full of omissions and errors. If people attempt to learn from such shitty resources, we have to clear up all the misconceptions later on. I don't want people to suffer like this. For that reason too, we remove all beginner's tutorials unless they are known to be very good.
C# is off topic in this subreddit. Please post C# questions to /r/learn_csharp instead. Also, mind your language.
Not even all that disgusting!
Yes, the child process does continue the rest of the read() calls until killed a few ms later, however, once the disconnect packet is sent to the other, stdin is not read anymore from the other end, so there won’t be anything read if that makes sense.
\&gt; I haven't encountered this, but it seems strange to me. Every time I've interfaced with other languages (C++, Java, Fortran, Ada, Perl, Python, Matlab) the function types must be clearly defined, sometimes from a specific set that are known or otherwise special. But always clearly defined. I can't think of any other language which has the default argument promotions (a historical relic in C), nor would I want that. Can you be more specific with this? &amp;#x200B; I don't have a huge amount of experience with this sort of thing, and the experience I have is ancient, but I'll offer what insight I can. Most of the systems where such issues were relevant are unlikely to be seen except in museums, but I don't see that as a reason not to at least specify how code for them should work. &amp;#x200B; On some systems, the normal calling convention is to have called functions pop their arguments. In pre-standard C on such systems, calling "printf" and not using all the arguments would frequently cause a crash, since the unused arguments would be sitting on the stack where the return address was expected to be. Such systems can be accommodated in conforming fashion by having callers treat functions with an ellipses argument as though the ellipsis were an argument of type \`va\_list\`, put the arguments into the format that \`va\_args\` would expect to see them, and pass a pointer to that data structure. Note that if a function didn't expect a va\_list-style pointer, but expected to be responsible for popping a variable amount of information from the stack, it would need to be invoked with the old \`()\` \[non ...\] syntax. &amp;#x200B; Further, on many older systems things like device driver libraries would often have a single function that would then use its first argument to determine what action to perform, and what arguments should be expected for them. That function may be a machine-language wrapper that invokes a number of functions written in a high-level language. Almost all such libraries written since the publication of C89 now take a fixed list of arguments and require that callers waste time pushing dummy unused arguments, but before the Standard was written, libraries could be written more efficiently by simply relying upon programmers to pass arguments appropriate for the action being performed.
theres no one right answer but this is what I do.... SRC:=$(wildcard src/*.c) OBJ:=$(SRC:src/%.c=obj/%.o) here all my files are in src but theres no reason you couldn't have multiple directories OBJ just in effect changes the directory and file extension I have 2 main rules (and a bunch of other stuff) cLogicFun: $(OBJ) $(CC) $(OBJ) -o cLogicFun $(LDFLAGS) $(OBJ): obj/%.o : src/%.c $(CC) $(CFLAGS) -c $&lt; -o $@ the first one is to link the second one actually compiles all the objects to be honest though, I \*really\* recommend reading [https://www.gnu.org/software/make/manual/make.html](https://www.gnu.org/software/make/manual/make.html) almost in its entirety as its actually worth reading!!
You need to show the code you've already written so we can help you, but at the moment I'm almost certain you have a misunderstanding of strings and ASCII.
Because there are many more non-trans people than trans people, gender and sex are highly correlated. A predictor of one would be a decent predictor of the other.
Can you elaborate on why the storage for dp depends on the indices of the string and pattern? There are even calls to something like [IDX(-1, j)], with -1 as the number of rows? Why is this required?
RIP gender ideology
Everyone with a functioning brain thinks there are only 2 genders
The problem is you have rules to make obj/%.o, but the object filenames look like obj/gen/display/%.o. I don't know how other people solve this, but I do this. Disclaimer, I don't know make well so this might be utter pants-on-head. SRC=$(wildcard gen/display/*.c gen/logic/*.c man/*.c) OBJ=$(SRC:%.c=obj/%.o) define compile $1: $2 @mkdir -p $(dir $1) $(CC) $(WHATEVER) $2 -c -o $1 endef $(foreach src,$(SRC),$(eval $(call compile,$(src:%.c=obj/%.o),$(src)))) This makes a new rule for every object file. It's a lazy, brute force way of doing it, but it works. You could also define a set of directories that your source files are in and foreach that, maybe also to call wildcard or something, but I think it's easier to just iterate over your list of source files and figure it out from there.
Yeah I do feel confused because I try to read it from the PowerPoint while doing the problem.I’ll try to write it out first until I get stuck.
You are so rude. Don't expect everyone to agree with your point of view
You are so rude. Don't expect everyone to agree with your point of view
Hi man, I looking for that kind of job, if is not too much trouble, where are you looking at?
1 for man, 0 for woman. Such a sexist AI.
I like how the summary is "Prefer f(void) in C to potentially save a 1B instruction per function call " , as opposed to "Prefer f(void) in C to avoid potential undiagnosed UB".
Yes. Everybody knows there is male, female and null.
Not sure if this is the most suitable sub for questions like these cause your questions are less about C and more about the approach to solving leetcode problems like these, but let's see how far we get. &gt; Can you elaborate on why the storage for dp depends on the indices of the string and pattern? Although I said this solution uses dynamic programming, the specific type of dynamic programming approach used here is the bottom-up approach (like said, to learn more about this, look up dynamic programming). The idea is to save the state of the partially solved problem (with some base case(s) initialized) and use it to keep solving parts until we've solved the full problem. The "state" in this leetcode problem is denoted by the progress of pattern matching the pattern (p) to the input string (s). Now, would it make sense to use only the index of either input or pattern to denote our progress in terms of matching? No, you need both to really have an idea of your progress in terms of matching. Your index over the pattern is used to denote how much of the pattern we've matched so far, and the index over the input string is used to denote how much of the input we've matched so far. I hope it makes a little bit more sense that we need both of these indices. &gt; There are even calls to something like [IDX(-1, j)], with -1 as the number of rows? Why is this required? The dp array is allocated with 1 extra row and 1 extra column to accommodate for the base case(s). The extra row and column are considered in the IDX macro using an offset, `IDX(-1,-1)' will evaluate to 0 because the offset of the extra row and column. If you really want a better understanding for this implementation, try to take an easy pattern and input string (for example, s= 'aa', and p='aa*'), draw the dp storage as a 2D array/table and fill in the values as you go through the code manually. Good luck!
The section titled "An explanation" is not very explanatory: the author seems to be overlooking the C++ feature of function overloading (which he describes as "spooky"). And it certainly is not something inherited from C.
There are only 2 genders.
Thanks for your help dude! &amp;#x200B; It now rotates the 3 colours plus with all of them combined so 5 colours in total (blue/blue\_green/blue\_red\_green/green\_red/red). thanks heaps &lt;3
thanks a lot bro, &amp;#x200B; that actually helps out heaps!. I wll keep messing around and will show you guys the update.
In practice, the expression to the left of the comma will have a side effect, but you don't care about the evaluation result. Here's an example in a loop: struct list { struct list *next; }; /* ... */ long length = 0; for (struct list *p = head; p; p = p-&gt;next, length++) ;
A string is a `char[]` or `char *` (or `const char[]` or `const char *` etc. etc.); the `char`s contained (`[]`) or pointed to (`*`) are usually 8-bit integers, which are used to encode ASCII characters (or some superset thereof, like ISO-8859-1 or UTF-8) in virtually every remotely-modern compiler. *Very* rarely you’ll run into encodings like EBCDIC, but thankfully that’s almost dead. So if you have a string (of either sort), all you have to do is index into it (`string[i]` or `*(string+i)`) to get an ASCII character code.
You have 2 examples of the comma operator here: bool is_palindrome(char const * const string) { int i, j; for(i = 0, j = strlen(string) - 1; i &lt; strlen(string) / 2; i++, j--) { if(string[i] != string[j]) { return false; } } return true; } I think you are missing a concept: the result of the operand is discarded but the side effects of it are still executed. In a assignment operator, the right value is still assigned to the left value but the whole expression has a value that is discarded that in this case is the right value too. One way to use that result is if(foo = x)
Often, the left-hand site has a side-effect that is useful. For example, consider this file-reading loop: int c; while (c = getchar(), c != EOF) { ... }
`xor %eax, %eax` is actually two bytes, not one.
&gt; Not sure if this is the most suitable sub for questions like these cause your questions are less about C and more about the approach to solving leetcode problems like these, but let's see how far we get. https://www.reddit.com/r/ProgrammingBuddies/comments/bnvtb1/looking_for_someone_to_help_with_leetcode/ I made the above because you mentioned this lol. Be my programming buddy?? ;) Otherwise I don't really know what to do. I feel like I'm stuck in the beginner phase of programming forever. I've heard going through this: https://cses.fi/book/book.pdf will help cover leetcode algorithms but I don't know how long it will take for me to get through, etc. Thanks for the explanation though! I think the real problem I was having is that I didn't know that this solution was trying to create a flattened 2D array. Now I understand and can depict this better. Thanks for the help so far.
Forgot about that (man, too much time in C land...), updated!
But UB is your friend; helps make bad code go fast. :P
C# is off topic in this subreddit. Please post C# questions to /r/learn_csharp instead.
Do not spam.
The `foo` case is also two overloaded functions
you're right! updated
...but why does the compiler zero EAX before calling f() at all? If the definition isn't variadic then AL shouldn't matter – and if it is, then calling it without arguments is certainly undefined behavior anyway. What am I missing?
I'm not sure if it's actually him, but it's funny to read this exchange thinking about that truly being the man who is the K in the K&amp;R C book and the K in awk.
I have a link to the source in my code. The training data set is small; the objective is for the neural network to make a prediction from the data it is given. It can be expanded to include a lot more data and many more fields. The model could learn how to weigh fields based on which ones are the most accurate predictors.
For readability, you mean? I'm new at sharing my code, so I'll make adjustments.
So; the compiler is converting calls to f() into f(0)? Why would it do that?
I initially had it the other way around, but I changed it while troubleshooting: higher numbers to higher number and lower numbers to lower number.
&gt; I certainly think `f()` is prettier than `f(void)` I definitely disagree there
 for(int ch; ch = getchar(), ch != EOF;) { ... }
&gt; ...but why does the compiler zero EAX before calling f() at all? If the definition isn't variadic then AL shouldn't matter – and if it is, then calling it without arguments is certainly undefined behavior anyway. What am I missing? The x86_64 ABI says that a prototype-less function is variadic. The C standard just says the behaviour is undefined; it's permitted for an ABI to define the behaviour nonetheless.
&gt; the compiler is converting calls to f() into f(0)? No, on x86_64 the first function integer or pointer argument is passed in `%rdi`.
See [point #3](http://nickdesaulniers.github.io/blog/2014/04/18/lets-write-some-x86-64/) or better yet the [ABI docs](https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf) (on PDF page 23, labeled page 22, under section 3.2.3 under "Passing"): &gt; For calls that may call functions that use varargs or stdargs (prototype-less calls or calls to functions containing ellipsis (...) in the declaration) `%al` is used as hidden argument to specify the number of vector registers used. &gt; If the definition isn't variadic then AL shouldn't matter Right, Clang can deduce this when the *definition* is within the same translation unit (or probably during LTO), but it must be conservative when just given the *declaration*.
I prefer the bikeshed to be... \*rolls dice\* blue!
ooo dat's a nice loop u got der did ya get it frum zhivagoogoo?
Indeed
It can be helpful to use that syntax if you’re going to use it that way, but most of the time you have to pass a length parameter when using it that way, which communicates the same thing.
Oh really? I've never seen a length specified when using an array in a parameter, how would that break down into a pointer?
The commenter means that you pass the length as a separate argument.
With strings you might expect the caller to end the string with \0. With other kinds of data or arbitrary bytes for which there is not some terminal value, you usually need to pass a length parameter _in addition_ to the pointer, so the called function knows the bounds of the array.
Ah alright
The only relevant part of the function is int x2 = x; int timesComp = 0; end: return x; It initialises `x2` and `timesComp`, then returns. Is there a reason you want to use `goto`? A `for` loop would be much clearer.
I believe what roxven is saying is that instead of just passing arr[] to the function you would do something like: int foo(int arr[], int arr_length) Requiring the arr_length parameter in the function implies the function will treat the pointer passed in as an array even if the function had instead used: int arr* I personally think the difference between the two is mostly for clarification between treating a pointer as a single item or an array of items. Apologies for any formatting errors. I'm currently on mobile.
Bad example, IMO because you could just do `for(int ch = getchar(); ch != EOF; ch = getchar())`. Slightly repetitious with the `getchar()`, but more clear.
I just wanted to learn how to use it. So if I were to put end at the end that wouldn't happen?
`argv` can be either a pointer to an array, or a pointer to a pointer. It's enumerated by its own variable, however: `argc`. `envp` (or the more portable `extern char **environ`) is a null-terminated array of strings, unlike the `argc`/`argv` pair. It's more flexible to use pointer notation.
It's compiled and executed line by line. Yes, you put end at the end.
Or even if you have to handle data which contains NULL (0x00) as a valid element in the data. Such as 0x30, 0x31, 0x00, 0x30, 0x32 etc.
Since array parameters decay to pointers, there's no technical reason why you'd want to do that for 1D arrays. However, I think it's more clear that the parameter is an array and not a pointer to a single int. Especially in C99 where you can do this. int do_thing(int n, int arr[n]); That can't be any more clear. It's not a pointer to an int, it's an array of n elements. For 2D arrays, you _need_ the row length or it can't calculate offsets. It's the only way to pass a 2D array to a function without doing manual offset calculation. int do_thing_2d(int width, int height, int arr[height][width]); The only alternative to this is to cast the array to int* and index it like `arr[y*width+x]` instead of just `arr[y][x]`. Depending on compiler optimizations, the second could possibly produce faster code as well as it being much more clear.
If you designed your program correctly, it should be able to learn to output 0 for men and 1 for women.
I do not understand anything about it.
It will be very helpful if you can tell me how to start I haven’t worked with threads before so I’m lost
...Please use the thread-safe variants. &amp;#x200B; If you are using the non-thread-safe variants, missing even a single instance will introduce bugs just waiting to happen. Making this worse, the same applies if someone else's code happens to use the same function (eg. an included file). If you are using the thread-safe versions, you can at least be assured that your code will not be the source of interference, should such interference occur.
You mean `_Generic`?
&gt;xact error. - First, I recommend reading about [exactly what scanf does.](https://en.cppreference.com/w/c/io/fscanf). - Second, remove the potential buffer overflow vulnerability (would occur whenever someone types a string of greater than 99 characters. ```scanf("%99s", name);``` - Third, if you don't want it to stop scanning whenever it hits whitespace, use direct character scan: ```scanf("%100c", name);``` - Fourth, optionally adjust the scan to consume leading whitespace (eg. earlier times that the user pressed "enter") by adding an initial space: ```scanf(" %100c", name);``` Your call `scanf("%s", trash)` suffers from similar issues. If you really do want to trash some input, use `*` to prevent assignment: `scanf("%*s", trash)`. Ideally, use a length constraint as well, in case the internal implementation of `scanf` suffers from buffer overflows.
&gt; `f` could be written in something other than C. Ah, that makes sense, though the article states: &gt; f() is not necessarily “f takes no arguments” but more of “I’m not telling you what arguments f takes (but it’s not variadic).” which I suppose has to be wrong, or at least very confusing.
Please see the code below which I have adapted from what you wrote. You had a really good start, but as stated earlier by others, when the instructions are executed line-by-line, your label for END was being executed before any of the other labels and was instantly returning from your function before anything could happen to modify your variables. With that said and as others have suggested, I moved it down to the bottom of power() so that it is the last label to be used. With some general housekeeping/conventions, it is easier to use labels when they are all uppercase and left-justified. Like I said, you were really close, just had to move END to the bottom. &amp;#x200B; Aside: In case you're interested, I have a little bit more information regarding history/uses of labels and goto/if...goto. So in Assembly, the concept of labels was huge. Previously in machine language, jumping to a different line of code meant actually having to know the address of that line within your program and using that specific address to jump to. Every time you add a new line of code, the address of where you want to jump to within your code may be affected. With labels, you are essentially creating a variable to an address location within your program and don't have to worry about keeping track of the addresses you are jumping to. Regarding goto statements, they are considered to be an unstructured control flow. They can sometimes be used in the wrong manner, be abused, etc. Also things can look messy very quickly, which is why we adopted a structured control flow such as for loops, while loops, etc. When C code is compiled and turned into Assembly, all those loops and other control structures are actually converted into gotos/jumps. One very valid application to using goto statements is to get out of a hairy mess if you are in a deeply nested structure and encounter an error. Say for instance, you have 4 nested loops (for God knows why) and encounter an error in the inner-most one. You would have to individually break out of all of those loops to get out.....or you could just use a goto and hop over to a label within your function that can be used to handling errors. There's probably more I could drone on about, but I will leave it here for now! Good luck on your coding adventures! `int power(int x, int y){` `int x2 = x;` `int timesComp = 0;` `TEST:` `if(timesComp == y)` `goto END;` `if(timesComp != y)` `goto increment;` `INCREMENT:` `x *= x2;` `timesComp += 1;` `goto TEST;` `END:` `return x;` `}`
argv is also a NULL terminated array of strings, at least in POSIX.
In general I think this is a good idea, limiting the ways in which users can get things wrong. The poor mans approach to this is using a union and avoinding any casting.
I thought about it and tested if the compiler is able to achive my goal: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void func(char f_string[]) { printf("sizeof(f_string): %lu\n", sizeof(f_string)); // prints the size of a char * } int main() { char string[rand() % 10 + 1]; printf("sizeof(string): %lu\n", sizeof(string)); // prints the size of the whole array func(string); return 0; } The compiler comes with the warning: make test4 cc -O2 -pipe -o test4 test4.c test4.c:7:49: warning: sizeof on array function parameter will return size of 'char *' instead of 'char []' [-Wsizeof-array-argument] printf("sizeof(f_string): %lu\n", sizeof(f_string)); ^ test4.c:5:11: note: declared here func(char f_string[]) ^ 1 warning generated. /tmp/test4-db17a1.o: In function `main': test4.c:(.text+0x33): warning: rand() may return deterministic values, is that what you want? So the array gets formed to a char \*. Readability should be the only reason to do so... &amp;#x200B; My rand() is arc4random(), so don't get confused by the warning
Nope, it is more than just a _Generic selection you linked, this achives function overloading which means a function print() can have different implementations with different return types and argument lists
`gcc -Wstrict-prototypes` would detect `int func()` and whine about it until you made it `int func(void)`. (or is it `-Wold-style-definition`?)
It is indeed quite wrong. But my earlier comment is wrong too! I thought that UB was invoked when passing arguments to a function without any prototype in scope. This is not always the case. The rules are essentially the same as the way ellipses work in variadic functions. For a function declared without a prototype: * If the number of arguments does not equal the number of parameters for the function, the behaviour is undefined. * Otherwise, all arguments undergo default argument promotions. If any argument is not compatible with the corresponding parameter, the behaviour is undefined. * Three exceptions exist to the previous rule: a signed integer type and an unsigned integer type are deemed to be compatible if the value is representable in both types; qualified and unqualified `char *` types are deemed to be compatible; qualified and unqualified `void *` types are deemed to be compatible. So it turns out that calling a function declared without a prototype _can_ actually have defined behaviour. You just have to call it correctly.
As a stylistic note: labels are indented one less level than the code surrounding them. They should stick out to the left, like bookmarks. This is best visible if you use a full tab for indentation.
Yall keep using an int instead of char...
Start by writing a program that calculates the averages without using threads. Then add threads.
Yes I did that. How do I incorporate threads to the program?
It will only cost you a few seconds to use `localtime_r()` instead of `localtime()`. As for `asctime()`, you should use `strftime()` instead regardless of whether your program is threaded.
Because `getchar()` returns an `int` in the range [-1,255].
I got it working on Linux, minor changes. However I re-ran the tests on Linux, and the speed differences are only 25% for raw allocation. I assume Lua will not be sped up much at all. The speed remains around 10x faster on OSX. I literally had no idea Linux was so much faster. I thought on the whole OSX and Linux are mostly equivalent. Its possible that speed difference will drop to 0 on Linux, once I add multi-thread support. Still, its a good allocator and I do most of my work on MacOSX, so it definitely helps here! I'll put the code up eventually just in case anyone wants to look at it.
Who doesn't use `((c = getchar()) != EOF)` ?
No, it sets `%al` to 0 in case the function is variadic, to indicate that no arguments were passed.
What's UB?
Because it looks super ugly. I try to avoid using side-effect causing functions in complex expressions as that leads to unclear code. The comma operator indicates a clear sequence of events, leading to greater clarity. It also avoids useless parentheses.
I always just pass the pointer to the first index.
Undefined Behaviour.
A declaration is a prototype if it includes a parameter list (which can be `void`). A definition is a prototype if the parameter types are declared inline or there are no parameters. There can be zero or more declarations, but only one definition. Any or all of these can be prototypes. You can call a function for which no prototype is available if and only if a) it is not variadic and b) the types of the arguments after promotion are compatible with the types of the parameters. In practice, it is so easy to be tripped up by the promotion rules, and so easy to provide a prototype, that it is best to always do so. I would be very happy if C2x made prototypes mandatory and got rid of K&amp;R-style function definitions.
&gt; int foo(int arr[], int arr_length) No. That is indistinguishable from `int foo(int *arr, int arr_length)`. What they meant was `int foo(int arr_length, int arr[arr_length])`.
&gt; When C code is compiled and turned into Assembly, all those loops and other control structures are actually converted into gotos/jumps. Not necessarily. ARM has predicated instructions: you can specify that an instruction should be executed if and only a specific condition is true, e.g. based on the outcome of a prior comparison instruction. If the condition is false, the instruction is either decoded but not executed, or decoded and executed but not retired. This avoids the pipeline stalls that often follow from a jump.
We can't help you with code we can't see.
Ahhh, hadn't thought of that.
I know what you mean. I should’ve specified that I’m talking about older architectures that didn’t have predicated instructions since they weren’t really popular in the US until the ~1980s/~90s. Although I should note that it has been a well-known topic beforehand and popular in European markets, it just didn’t really hit hard on consumer markets in the US until the ‘80s/‘90s. But you’re right, and predicated instructions are actually great since the program is broken down into chunks in which it’s corresponding code will run if the predicate is unified
power(2,0) ought to be 1, btw. gets his coat,
Ah, I know what you're talking about. Yeah, that would be broken, and IIRC this was one of the reasons why the feature was left in the standard in the first place. What I wonder is if any such "museum" system even uses a C99 compiler ... if not, I wouldn't cry about breaking this particular egg in C2x.
This has absolutely nothing to do with US vs EU.
I wasn’t saying it was anything to do with that....I was just providing some historical context
They're equivalent. Just use whichever form you think best expresses your intent to the reader.
I'm wondering if you think "end" is somehow special to the compiler, and gets executed at the end, no matter where in the function it actually appears. But there's nothing special about "end", it could have been "foo" for all the difference it makes. Statement labels are literally just that: labels. They provide a target for a "goto" statement and nothing more. As other posters have pointed out, if you had set the warning level higher, you would have been informed that nothing after the "return x" is reachable. You should also have been warned about the function reaching the bottom without a return statement, but either the warning level was too low for even that, or the compiler realized that you were never going to reach the bottom anyway.
...which you pulled out of where, exactly? It's pure fiction.
Damn this thread has so much knowledge. Trying to comprehend you guys' replies one by one.
Thanks for the example and response. I think I understand it better now.
Ohhhh I see I see. Thanks for the example you have shown, I understand that the left side evaluation has side effects now.
Oh! Nice example, I understand from your example.
Here is a source from [Clemson University](https://people.cs.clemson.edu/~mark/epic.html) which has a section called "Historical precedents for predication (conditional execution)" that shows a timeline of the development of predication. In particular, it mentions the MAILÜFTERL, Zuse Z22, ZEBRA, and Electrologica X-1 (all European), which experimented with early forms of predicated instructions.
Oh wow, off-by-one strikes again. Thanks for the example! Re-allocating the same array seems more intuitive than how I was trying to go about it.
Remember what places are taken and reroll if computer gets one of them. EDIT: OK, there's a better way of doing this. Don't roll the place number, roll how many jumps over free places you have to do, so for example: first round (computer starts), roll a number between 1 and 9, second round betwen 1 and 7 (two places were taken in the previous round), third round 1 and 5 and so on. Each time when you roll a number, jump over fields and increment a counter when you hit a free space. When counter equals rolled number and the place you are over is free, place a mark and save it as taken. That way computer won't roll over and over and over and over.
I don't know why it's complaining about an "integer constant expression" here but the real problem is that `1 &lt;&lt; 31` is undefined behavior on systems with 32-bit `int`. You can't shift a 1 into the sign bit, so that's probably confusing GCC. Change that to `1U &lt;&lt; 31` or `1UL &lt;&lt; 31` and the warning goes away.
hey, question: is there a reasong for int n to be int, vs uint, since it will always be positive? is it convention to have it as in?
Shouldn't it be available\[9\] in UserInput() for the first round with empty table? Then, in ComputerInput(), your random ought to be not %9 but ...
You can, but it doesn't really do anything in C. You could do this. void print(size_t n, int arr[n]) { for(int i = 0; i &lt; n; i++) printf("%d\n", arr[i]); } int main() { print(-1, (int[]){1,2,3}); } No warning and nothing good happens. It's also not a good idea to use mixed signed and unsigned values in expressions, as the results can be unpredictable. It's the convention to use int in many places in C, it's best to stick with int unless you're going to thoroughly scrub your code for signed/unsigned mismatch and even then, it's easy for errors to slip in since that doesn't generate warnings.
Increase the warning level for your compiler until you see something like this: warning: format specifies type 'float *' but the argument has type 'double *' [-Wformat] This is telling you that `scanf` was told to expect a `float` due to the `%f`, but the variable is actually a `double`. Use `%lf` instead. As an aside, you use this pattern a lot: (c+i)-&gt;bal It's more idiomatic to do: c[i].bal
Is your space key broken?
Thanks. I was using gcc -lm -o out b-b.c. After using gcc -lm -Wall -o out b-b.c I got the warnings. It fixed the issues. Thanks. I am using (c+i)-&gt;bal because I like pointer notations.
I don't understand the point of `available`. Just get the user's or computer's move, check if the corresponding square is already occupied, and if it is, ask again.
&gt; I don't know why it's complaining about an "integer constant expression" here Really? &gt; but the real problem is that `1 &lt;&lt; 31` is undefined behavior on systems with 32-bit int. You just answered your own question. &gt; You can't shift a 1 into the sign bit There is no sign bit in two's complement.
&gt; The "but it's not variadic" bit is indeed quite wrong, since the C standard makes no such assertion. See 6.7.6.3/15: &gt; If one type has a parameter type list and the other type is specified by a function declarator that is not part of a function definition and that contains an empty identifier list, the parameter list shall not have an ellipsis terminator and the type of each parameter shall be compatible with the type that results from the application of the default argument promotions.
The MSB is the sign bit. It’s not a standalone feature like sign-magnitude has, but it’s definitely a sign bit. ISAs like the x86 even have a sign flag as output from arithmetic/logic operations that’s a copy of the result MSB.
As well as what other people have mentioned, you can use `static` in a parameter array’s size to assert that the pointer passed is nonnull, which you can’t do with pointers alone, although somtimes the compiler supports stuff like GNU `__attribute__((__nonnull__))`.
why?
&gt; There is no sign bit in two's complement. In two's complement the high bit is still often called a sign bit. E.g. ["In the two's complement representation, the sign bit has the weight −2^(w−1) where w is the number of bits."][1] or ["The most significant bit determines the sign of the number and is sometimes called the sign bit."][2] [1]: https://en.wikipedia.org/wiki/Sign_bit [2]: https://en.wikipedia.org/wiki/Two%27s_complement
&gt; The MSB is the sign bit. No. It's a bit that happens to be set if and only if the number is negative, but it's not a sign bit. Flipping it won't negate the value without changing its magnitude.
Thank you, its getting late so I will try it tomorrow!
Because there are almost no spaces (or blank lines, for that matter) in your code, which makes it unnecessarily hard to read. Use indent, clang-format or similar to reformat your code, then try to stick to the same style.
Right, it indicates the sign, and changing that bit changes the sign. Flip bit→negate value is not a requirement for a sign bit; flip bit→change sign is.
k
You are right, 'available' is for the user that prints out the squares left. So if you picked 3, in the next turn it will print: choose between 1, 2, 4, 5, 6, 7, 8. I thought I could use it somehow for the computer to pick a random number from but I haven't figured it out yet. I will try tomorrow.
The warning says that that `1 &lt;&lt; 31` is not an integer constant expression. Except for the undefined behavior, it *is* an integer constant expression. I'd expect to see that warning/error in a case like this: const int zero = 0; switch (expr) { case zero: /* ... */ } Not when the expression has undefined behavior. &gt; There is no sign bit in two's complement. The C standard says there is: &gt; In a two's-complement representation, there is no actual change in the bit pattern except filling the high-order bits with **copies of the sign bit** if the unsigned integer has greater size.
On every turn, swap the chosen position with the last free position in the array, and reduce the modulus operand by one. Then "rand() % x" (where x starts at 9 and decrements every turn) will always yield a free position.
You don't need `available` for anything.
Thanks! This seems to be the case here. But that means if I am shifting a `enum` value like: #include &lt;stdio.h&gt; enum { ZERO, ONE, TWO, }; int main(void) { switch(0x80000000) { case (1 &lt;&lt; 30): puts("something"); break; case (ONE &lt;&lt; 31): puts("another thing"); break; } } The solution to this warning is to `case ((unsigned int) ONE &lt;&lt; 30):`. For this example it is really simple, but for the original code which sparkled this question, I have a long `enum` list, so fixing it will be ugly (or not so portable). Thanks again. EDIT: typo
It is not a valid integer constant expression because, in the absence of a cast or suffix, `1` receives type `int` (C11 section 6.4.4.1 paragraph 5), and `1 &lt;&lt; 31` is not representable as an `int`, so it violates the constraint that a constant expression must evaluate to a constant within the range of its type (C11 section 6.6 paragraph 4).
That paragraph is talking about how C determines whether two functions are compatible. I don't see how that has anything to do with *calling* a function. C seems to be quite clear on its treatment of a function declared without a prototype: the function may be variadic, or it may not; it may have parameters, it may not; any parameters it does have are simply unspecified.
c[i].bal is a pointer notation. But more than that it tells us just by looking at that we are traversing an object with set length and each of its elements contains an item called bal. (c+i)-&gt;bal only tells us that if you use pointer arithmetic you will arrive at a memory location i places beyond c which contains an object that contains an item called bal. One is straight forward and easier to parse. The other is not. There is a reason that the industry uses one over the other. Learn they are equivalent in most use cases, but then also learn to code in a common way to increase your code readability.
Wait … I just thought about it a little more. Do variadic functions have an argument counter as the first parameter? Or does the compiler just pass a zero, gambling that the called function stops fetching arguments when it hits a zero?
&gt; I like pointer notations You're in luck! The C standard defines the array subscription operator `[]` in terms of pointers only. Indeed, it actually says that the expression before the operator must have a "pointer to complete object" type. The fact that this operator actually works when given an array as its left-hand argument just falls out of the way arrays decay into pointers in most expressions. Fundamentally, though, `[]` is an operation performed on a pointer.
From the System V ABI AMD64 Architecture Processor Supplement, section 3.5.7: &gt; When a function taking variable-arguments is called, `%rax` must be set to the total number of floating point parameters passed to the function in vector registers.
&gt; That paragraph is talking about how C determines whether two functions are compatible. I don't see how that has anything to do with calling a function. See 6.2.7/2: &gt; All declarations that refer to the same object or function shall have compatible type; otherwise, the behavior is undefined. So, you're technically right -- this isn't strictly about *calling* the function. You don't even have to call the function: as soon as you have this mismatch between the declaration and definition in your source code, that's UB. Though, in practice, I don't think it will matter in this case until you call the function. That's when the ABI will be assumed for the function, and where UB would manifest.
You already received good recommendations, I won't repeat what they said. Just another thing though: you are using a floating point type for a monetary value. This can lead to errors and confusion. You're better off representing amounts of currency in (long) integers. Then store your amounts in cents, or even tenths of a cent, hundredths etc. as required by your situation.
&gt; You don't even have to call the function: as soon as you have this mismatch between the declaration and definition in your source code, that's UB. Ah, you're talking about if the function's definition is in C. I was considering this situation: int foo(); /* linked to non-C code */ That is, when there literally is only one declaration. The C standard is silent on this since it only talks about linking translation units written in C. Calling this function has unspecified behaviour, not undefined behaviour. The x86_64 ABI defines this as being variadic. But this works even if the function actually is non-variadic, since the call sequence for a variadic function on x86_64 is compatible with non-variadic functions.
&gt; Except for the undefined behavior, it is an integer constant expression. That's like saying: except for having 4 sides, a square is a triangle.
Technically the requirement to be a "sign bit" is that negative values have the bit set one way, and positive values have the bit set the other way. Flipping the bit might cause a trap representation or no change to the value, in the case of zero , for sign-magnitude representation. ( C doesn't allow integer negative-zero to be a distinct value).
If you're thinking of relying on undefined behaviour instead of having ugly code, bear in mind that on common systems `1 &lt;&lt; 31` will resolve to a negative number , and so the large positive number `0x80000000` (which will be signed long long) won't match it. The same issue would arise for `TWO &lt;&lt; 30`. If you're going to use these purported constants in multiple places the tidiest option might be macros, e.g. `#define FLAG_FOO ((uint32_t)ONE &lt;&lt; 31)`. The major compilers all implement an extension that if you define an enumerator with unsigned constants larger than `INT_MAX` then it allows them and the enumerators retain their declared type, although Standard C doesn't allow that.
Why do you call it bad form? I prefer having both parts of the comparison close to the left (be it `!` or `not` or `0 ==`), otherwise it can happen that if the expressions being compared are long, then the `== 0` bit has gone off the right-hand side of the editor and will take longer to read.
&gt; Why do you call it bad form? Because it is extremely misleading. `!` is natural for *boolean* values and is not natural for integer values. Saying `!something` is true is to say that `something` is false. `strcmp()` does not return a true/false boolean value. It returns integer =0 for equality, &lt;0 for less than, or &gt;0 for greater than. The integer 0 returned on equality is neither true nor false; it's an integer. Yes, `!` is defined for integers, and it's useful sometimes for converting a nonzero "truthy" integer to a Boolean true (1). But it should never be used with `strcmp()`, because it doesn't return a truthy integer.
I thought that was an idiomatic choice. I mean if you’ve read up on Id softwares work, especially basically rewriting the entire c++ standard library, u find that their work is praised for its beauty and conciseness; part of which included minimising vertical space when required. I read an article on it. Frankly I’m not sure whether that’s true or not, I also find the lack of vertical separations to cause code to bleed together but I’m not averse to the idea of it. Edit: [here’s](https://www.google.com/amp/s/kotaku.com/the-exceptional-beauty-of-doom-3s-source-code-5975610/amp) the article. P.S. OP does appear to be using proper spacing, he’s just following the 2-space convention which has become pretty popular in a lot of other languages. I don’t really see why you’d use it in C though. The only reason it’s used in languages like ruby or JavaScript is because u have tendency to nest a lot of blocks, to write callbacks and the like. U don’t really do stuff like that in c or c++ so 2 spaces feels meaningless. But then again, to each their own.
Insert callous joke about how i[c].bal is just as valid here. v(≖‿≖v)
&gt;But it should never be used with strcmp(), because it doesn't return a truthy integer. If you're checking for equality then it does. Zero is equal, non-zero is not equal, in that context. The different possible not-equal values don't matter there.
Ahhh, that makes a bit more sense.
But you see, that's backwards. You're looking at a *falsy* value, not a truthy value. `!` is for boolean values (0 and 1) and for truthy values (zero and nonzero). It is not for falsy values (nonzero and zero). `strcmp()` does not return a truthy value on equality; it returns a falsy value on equality. For this reason, if you write `!strcmp()`, people will curse your code. Comparison with `==` or `!=` is clearer. Just because C lets you get away with writing `!strcmp()` doesn't mean you should.
The `!` transforms it from falsy to truthy (to use your terminology). My normal function design is to return zero for success and non-zero for error, so typical code would be: if ( foo() ) return ERROR_CODE; // carry on... or if the function has multiple error conditions that we want to log or behave differently for, then for example: error_code = foo(); if ( error_code ) { log(error_code); return FAILURE; } This seems preferable to me compared to functions returning 0 for failure and 1 for success, but then you have to access a static variable to get the failure reason (e.g. `GetLastError` in Windows).
Always use `-Wall`, always insist your programs compile with 0 warnings and don't blindly guess at methods to make the warnings go away, make every effort to understand why the warning is occurring and fix it. A warning means there's something you're not understanding about the language.
Huh? Not even close.
&gt;So in C, 1 &lt;&lt; 31 is equal to 0, False, it's actually undefined behaviour. Also the capacity of int, on common systems, is 32, not 31. Your joke would make slightly more sense for `1 &lt;&lt; 32` (which is still undefined behaviour however). &gt; since the compiler treats all unqualified numbers as "int". No it doesn't. For example `5000000000` is `long long` on common systems.
Can you actually walk us through the loop step by step? What does `p;` do?
That's being used as the condition. When the end of the list is reached, p will be null, and so it will evaluate as false.
Looks like you're reading the ADC as many times as you're reading your own code.
Just pick a random number from available, not all 9. Move your rand call below the loop where you calculate available, and just do something like `ComputerMove = available[rand()%j];`.
look into Unions.
Typo in the withdrawal subtraction.
"Void not ignored" Did you accidentally write `void fn()` instead of `void *fn()`?
This is one of those places where a win vm with full visual studio makes a ton of sense.
You want to try /r/csharp This is for C, quite different.
Thanks, i'll try it
&gt; OP does appear to be using proper spacing I'm not talking about indentation, I'm talking about spaces between tokens.
You should start by reading and understanding the error and warning messages you're getting. Feel free to ask us for help if you can't figure them out, but we need to see the code and the messages.
You can do anything in C, but wouldn't you rather play with [one that already works](http://svtsim.com/moonjs/agc.html)?
I knew that online computer , I have been learning how it is actually working currently
Worked like a charm!
It is mathematically proven that C is capable of doing **anything**. You can emulate and AGC, but the amount of research and time it will consume is sure to rebute quite a few programmers. I consider the implementation of an emulator+assembler+disassembler suite one of the best exercise for C programmers.
Yes , Time is crucial factor to move forward.I just imagine that a visual program which is made in C Programming Environment.Thanks for your comment.
&gt; It is mathematically proven that C is capable of doing **anything**. If you're thinking of Turing completeness, that's not the same as *anything*. If you're thinking about something else I'd like to know what.
Mathematically proven that it can do anything? So it can reverse the flow of time? How?
I've got another problem: Now the computer doesn't overwrite the users imput, but when the user has used the last square left it still runs through the ComputerMove and tries to pick a square when there isn't anything left and then crashes. How do I prevent this? Here is the Code: void drawGrid( char*); void UserInput (char a[], char* PlayerPtr); void ComputerInput (char a[], char* ComputerPtr); int checkForWinner( char a[], int cnt, char *playerPtr ); int main() { srand(time(NULL)); char grid[9] = {'0','1', '2', '3', '4', '5', '6', '7', '8' }; char Player = 'X'; char Computer= 'O'; drawGrid( grid ); int done=0, counter=0; while( !done ) { UserInput (grid, &amp;Player); done = checkForWinner( grid, counter, &amp;Player ); ComputerInput (grid, &amp;Computer); drawGrid( grid ); } } void drawGrid( char a[] ) { printf( "\n" ); printf( " %c | %c | %c \n", a[0], a[1], a[2] ); printf( "---|---|---\n"); printf( " %c | %c | %c \n", a[3], a[4], a[5] ); printf( "---|---|---\n"); printf( " %c | %c | %c \n", a[6], a[7], a[8] ); printf("\n"); } void UserInput (char a[], char *BAJS) //Fixa detta!!! { int available[9]; int i, j = 0, choice; for (i=0; i&lt;9; i++) if( (a[i] != 'X') &amp;&amp; (a[i] != 'O') ) //Kollar vilka squares är lediga available[ j++ ] = i; printf("\n Its your turn. Choose your move"); for( i = 0; i &lt; j; i++ ) printf( " %d", available[i]); scanf( "%d", &amp;choice); a[choice] = 'X'; } void ComputerInput (char a[], char *ComputerPtr) { int available[9]; int ComputerMove=0; int i = 0, j=0; for (i=0; i&lt;8; i++) if( (a[i] != 'X') &amp;&amp; (a[i] != 'O') ) available[j++] = i; ComputerMove=available[(rand()%j)]; a[ComputerMove] = 'O'; } The program crashes at line: ComputerMove=available[(rand()%j)];
It's much easier for us if you post an example
unsafe { main() { ( ... ) } }
Yeah, fair enough. I was talking about Turing completeness
I've got another problem: Now the computer doesn't overwrite the users imput, but when the user has used the last square left it still runs through the ComputerMove and tries to pick a square when there isn't anything left and then crashes. How do I prevent this? Here is the Code: void drawGrid( char*); void UserInput (char a[], char* PlayerPtr); void ComputerInput (char a[], char* ComputerPtr); int checkForWinner( char a[], int cnt, char *playerPtr ); int main() { srand(time(NULL)); char grid[9] = {'0','1', '2', '3', '4', '5', '6', '7', '8' }; char Player = 'X'; char Computer= 'O'; drawGrid( grid ); int done=0, counter=0; while( !done ) { UserInput (grid, &amp;Player); done = checkForWinner( grid, counter, &amp;Player ); ComputerInput (grid, &amp;Computer); drawGrid( grid ); } } void drawGrid( char a[] ) { printf( "\n" ); printf( " %c | %c | %c \n", a[0], a[1], a[2] ); printf( "---|---|---\n"); printf( " %c | %c | %c \n", a[3], a[4], a[5] ); printf( "---|---|---\n"); printf( " %c | %c | %c \n", a[6], a[7], a[8] ); printf("\n"); } void UserInput (char a[], char *BAJS) //Fixa detta!!! { int available[9]; int i, j = 0, choice; for (i=0; i&lt;9; i++) if( (a[i] != 'X') &amp;&amp; (a[i] != 'O') ) //Kollar vilka squares är lediga available[ j++ ] = i; printf("\n Its your turn. Choose your move"); for( i = 0; i &lt; j; i++ ) printf( " %d", available[i]); scanf( "%d", &amp;choice); a[choice] = 'X'; } void ComputerInput (char a[], char *ComputerPtr) { int available[9]; int ComputerMove=0; int i = 0, j=0; for (i=0; i&lt;8; i++) if( (a[i] != 'X') &amp;&amp; (a[i] != 'O') ) available[j++] = i; ComputerMove=available[(rand()%j)]; a[ComputerMove] = 'O'; } The program crashes at line: ComputerMove=available[(rand()%j)];
It can be (ab)used to form an iterator like this: footype *FooArr; size_t FooNum; ... for(footype Each,*_Ptr=FooArr,*_End=_Ptr+FooNum;(_Ptr&lt;_End)?(Each=*_Ptr,1):(0);_Ptr++) { //A local variable "Each" does not expose its index (unlike "FooArr[idx]") } `#define` can hide its messiness, but what an evil thing.
 #include &lt;setjmp.h&gt; ^(&lt;/badjoke&gt;) Happy birthday :)
It's not matter of good practice, it's a matter of necessity. There are times when you *need* a void pointer.
Nevermind, I solved it :)
You want to turn an integer into a string to print it. You start with the low order digits, but in text they are written at the right, while print functions start printing from the left.
so, the convention is "use int to catch the off-chance the user passes a negative value and the programmer not bright to check for overflow"?
&gt; Would anyone who understands this excerpt possibly explain this excerpt to me? It might be best understood if you try out a short exercise for yourself. How would you implement this function: /* Prints x as a decimal number to standard output */ void print_int(int x); given that you can only using `putchar` or `putc` from the standard library?
This subreddit is about programming in C only. I have removed your question as it does not seem to be about that.
C# is off topic in this subreddit. Please post C# questions to /r/learn_csharp instead.
Do not spam.
Homework time?
You might want to try /r/avr/ instead. This subreddit is about C, not microcontroller peripherals.
I'm not really sure of what's happening in that excerpt, are you obligated to transform the int to a char by char array of it? Or can't you just easily use sprintf(...) to bring an integer into a char\* buffer?
I don't know C that well, but if you thought about going through the exercises in the book then you should just do it. Great place to start. &amp;#x200B; Never look for the "best" way of doing stuff, just do it. That is my tip.
Whether or not K&amp;R style declarations should be included in the Standard would depend, I guess, upon what the purpose of the Standard is. Unfortunately, there has never been any consensus on that subject, and the lack of such consensus has served to severely stifle innovation for decades. &amp;#x200B; To my mind, two "language implementations" X and Y process the same language if every input which X can process in defined fashion and that Y can process at all, will be processed by Y in a fashion consistent with that definition, and vice versa. Note that it is not necessary that either implementation be capable of processing all of the inputs that the other can, but merely that if an implementation can't process some inputs in a fashion consistent with the other implementation's definition, it refrains from processing it at all. &amp;#x200B; If a piece of code has meaning today, it should continue to have that same meaning. Later versions of a language should be supersets of earlier versions, by the definition above, whenever practical (noting that this does \*not\* require that implementations be capable of processing all code processed by implementations of previous languages). Unabridged dictionaries deliberately include words which have, for hundreds of years, never been used in print outside unabridged dictionaries, word puzzles, or similar contexts. I'd have no problem relegating K&amp;R syntax and trigraphs to an annex for "features that compiler writers shouldn't be expected to worry about except perhaps in response to particular customer needs", and would make a practicality concession to allowing implementations to change the meaning of \`"Is this a pipe or two question marks and a bang ??!"\`. I see nothing impractical about allowing implementations to process old-style declarations if they see fit to do so, nor specifying how implementations that accept such declarations must process them. That does not, however, imply that the Standard should regard code containing such declarations as meaningless. &amp;#x200B; While Undefined or Unspecified behaviors complicate things a little, it may be reconciled by recognizing that if two implementations X and Y are identical except that one specifies that it will process some input I in fashion P or Q, chosen in unspecified fashion, while Y specifies that it will process it in fashion Q or R, also chosen in unspecified fashion, both process a superset of a language processed by an otherwise-identical implementation Z that would choose in unspecified fashion from among P, Q, and R. Any input that would yield acceptable behavior on Z, and could be processed by X and Y, would yield acceptable behavior on both of them. &amp;#x200B; Viewed in that light, I think it would be both practical and useful for the Standard to specify a language which is sufficiently powerful to accomplish most of the things which can be done using Ritchie's language without any reliance upon extensions nor unspecified, undefined, or implementation-defined behavior, and yet would--for purposes of processing such programs--be a subset of the language processed by most implementations (bearing in mind that implementations are not required to be capable of usefully processing all such programs in a fashion consistent with the specification, but merely refrain from processing them in a fashion inconsistent with it). &amp;#x200B; Even many embedded systems tasks could be accomplished by such a language, again without needing extensions, if it included a directive "process this code according to the 'embedded machine behavioral model' or don't process it at all", and that model specified that given something like: \`(uint32\_t volatile\*)0x12345678 = 0xABCD4321\`, the implementation must generate a store of the data 0xABCD4321 to CPU address 0x12345678 using the CPU's most natural way of performing such a store, with whatever consequences result, even if such consequences may include immediate external accesses to any objects whose address has been exposed to the outside world. Implementations where such concepts would have no meaning would simply be required to reject code specifying that model. &amp;#x200B; Such code might only be useful on one particular piece of target hardware, but from a language perspective its meaning would be unambiguous on any implementation that accepted it \[if run on the wrong platform, its meaning would still be to perform the indicated store, with whatever consequences result\]. Right now only an infinitesimal fraction of tasks done by freestanding implementations can be accomplished using only features specified by the Standard. Enriching the Standard enough to raise that to 100% wouldn't be practical, but recognizing that the Standard can and should define things without implying that all (or even most) implementations should support them would make it practical to raise it above 50%, and if one accepts that principle, there would be no reason to drop old-style K&amp;R definitions.
And, there are certain early video games that relied on analog components. Those are very tricky to fully simulate, in that the real-time requirements need specialized hardware that "simply coding in C" won't do.
Well, not with *that* attitude, you can't!
Turing completeness is a much less useful concept than people think. It does not model I/O, for instance, and it assumes infinite memory.
With certain precision though...
Oh, yeah that implicit boolean stuff I always forget about, ok.
Vim, tmux, bash, make.
Yep. And basically all major programming languages are touring complete. Even shitty ones like brainfuck are touring complete.
Eclipse, but the C Version is a bit... poor
Currently I’m using code blocks, considering eclipse as welll
Currently Emacs.
I use nano
Fun fact: C is actually not Turing Complete. The core reasoning around it is that `sizeof` returns a fixed number which prevents simulating a Turing machine with infinite memory. https://cs.stackexchange.com/questions/60965/is-c-actually-turing-complete
I use stand alone utilities .. Kate and gcc tools
CLion =D I urgently need to learn vim.
I’m surprised no ones mentioned Visual Studio Code. It’s by far my favorite IDE for any programming.
VS code, and `make`.
U love c programing ..I back to it after 20 years ..I needed a refresher too ..but no available source teach it the way I learned in college ..man c is kind of low programing u cannot read about it as other high level lang. I had to learn assembly to get closer to the machine where I feel home ..I learned a lot of assembly and now I back again to my love ..the c lang..I found a book which relate c to assembly ..really the best book I read for a while .. we ntroduction to computer organization by Robert plant which is available for free ..happy learning
What arguments do you provide for both calls?
I tend to use Sublime Text 3 for anything that isn’t c# because it’s extremely fast and looks nice. Even just watching people use emacs and vim give me a migraine due to their looks. Sometimes I use Visual Studio (I’m a windows developer) if I’m working with a big library that benefits from Intellisense
In the first version, you save the array before writing to it, which means that in the second loop, you can modify the data freely because you will never change the data you're reading from. On the second version, you're saving the data as you write to it, which means that you are reading from data which may have been changed on a previous iteration. If you still don't understand why it's wrong, pick up a piece of paper and draw the contentes of temp, src and dest as you go step by step in the algorithm.
`memmove()` allows the input buffers to overlap, and it behaves as if the source is first copied to a temporary buffer, then from there to the destination. That's what `temp` is for. (In practice, it's more clever than this, but it's not possible to implement efficiently in strictly conforming C.) I assume your function should have the same semantics. The second version of your function doesn't handle overlap properly. You may be overwriting the source buffer while you're still using it. Consider how you're not really making good use of `temp`, and you could even omit it without changing the behavior of the function. That's the sign something is wrong. Side note: `temp` is a variable-length array (VLA), meaning it's allocated dynamically on the stack. This allocation may fail, but there is no mechanism to detect this failure. This makes `ft_memmove()` dangerous. It may cause the program to crash without any hope of recovery, and it may even open it up to a vulnerability called *stack clashing*.
&gt; It is mathematically proven that C is capable of doing anything. Part of the appeal, at least for me, to learn C is its capability to do **almost** anything. I'm still wrapping my head around what it can actually do. Like, could I write a csv to json converter in C? I'm sure that'd take a significant amount of code.
Every five seconds, someone on reddit asks this question. Every 10 seconds, someone on reddit replies with the same answers.
Emacs, if you consider it an ide.
&gt; Never look for the "best" way of doing stuff, just do it. Good advice. I always look for the "best" way to do things in C, but this isn't the language that can optimized on the fly. I find more success just building something to get it off the ground then go back and optimize.
Notepad
VSCode + gcc + CMake.
emacs is anything you want it to be.
Visual Studio 2019 CE for C++ &amp; .Net stuff Visual Studio Code for front-end, js and Python
Apple TextEdit
You can't do that. There's other ways around this (return a special `double` value, use an output parameter, return a structure, etc.), but to give more specific advice we'd need to know a lot more about your situation.
Visual Studio Code
Can you please link the documentary?
Thank you so much for the informative response. I really do appreciate how you've phrased this as well, and if you wouldn't mind, could you guide me through this to some extent to help me further understand it? I'm fairly new to programming, and I have a misunderstanding somewhere along the lines in my code, but I can't quite place it. Let's say I make a scenario like this: ft_memmove("Hello", "World"); (Just pretend that these are modifiable strings containing Hello, and World. I know the above example wouldn't work.) As I understand it, my code works like this: * create temp array. WHILE1() * Iteratively place data "World" into temp. WHILE2() * Iteratively place "World" from temp to the start of "Hello" Firstly, why does the way this function is written not overwrite Hello with World? When saying dest[i] = temp[i] Shouldn't this completely overwrite 'H' with 'W'? My lack of understanding may be rooted all the way at the very beginning of this functions works.
You could use “=iferror” or “=ifna” and test the condition first
Thank you for this incredibly informative response. I really do appreciate it. I definitely have learned from your response, but still find myself confused in some ways. I know this is a lot to ask, but could you please help me understand one thing? You're brilliant at explaining things, and clearly have a great fundamental understanding, so I would appreciate it more than I could put into works. My misunderstanding actually may lie here: while (i &lt; size) { ((unsigned char *)dest)[i] = temp[i]; i++; } Considering the case where temp holds "World" and dest holds "Hello", wouldn't this statement simply overwrite the 'H' of Hello with the 'W' of World? Why does it instead push it in this case?
I feel this has to mentioned here: CuriousMarc and AGC restoration project [https://www.youtube.com/playlist?list=PL-\_93BVApb59FWrLZfdlisi\_x7-Ut\_-w7](https://www.youtube.com/playlist?list=PL-_93BVApb59FWrLZfdlisi_x7-Ut_-w7)
To add to this, you could also have your function return a pointer to a double, if your condition is not met, just return a NULL pointer.
One crazy way would be to double fn() { return (NAN); } int main() { double d = fn(); if (d != d) printf("I am not a number!\n"); }
https://learnxinyminutes.com/docs/c/
Oh how DARE you use commercial IDEs? /s To each their own, I love Visual Studio as well.
*Turing and only in theory, cf. infinite memory.
It's a memory hog, but it works fairly well. Team integration for CVS, SVN and git is good if not perfect, and support for debugging apps (remote and local) is very good.
You can't solve the halting problem with a Turing Machine either (A theoretical one with infinite tape).
Pass the double in as a pointer to the function. void my_function(double *d) { if (whatever) *d = wanted_value; else *d = NULL; }
The Syntax error detection is not the best, and I don't need team integration because I work alone
Um ... a pointer to *what* double? That's a can of worms that shouldn't be opened.
Pass in the double to the function and set it to NULL. &amp;#x200B; void my_function(double *d) { if (whatever) *d = value; else *d = NULL; }
 I also used to have a sour taste in my mouth for Vim, but one of the things I started to love about it was it's customizability. There are plenty of themes out there to make it look however you want, and plenty of extensions to help out with small tasks. Thanks being said, I'm a VS Code man.
You can't do that, and if you need any double value to be possible (so you can't return -1 or something to indicate a failure), you can either return a struct or pass in a bool that indicates if the function was successful. double my_function(bool *is_valid) { if (whatever) { *is_valid = true; return double_value; } else { *is_valid = false; return -1; } } int main() { bool is_valid = false; double d = my_function(&amp;is_valid); if (is_valid) { do_whatever(d); } }
I use nano, dvtm, bash, make. Trying to switch to [vis](https://github.com/martanne/vis) thought. But I love nano.
Pointers aren’t a can of worms, especially with something simple like this. You could malloc(sizeof(double)), return that and free your pointer to that space when you’re done. Maybe there’s a better approach but If I’m wrong about this one, feel free to correct me.
That seems the best way. Another way would be setting `errno` if the value returned is invalid.
Pointers are a can of worms. What you're describing is a classic pattern that leads to memory management errors. You have to decide who is responsible for deallocating the memory and when. There are many, many, many ways to screw that up. And to do this for just returning a double is a lot of risk to bite off for a simple task that's easily solved in safer ways. It's also a lot of performance overhead to incur - malloc is not a cheap function on average. Pointers and heap-allocated memory certainly have their place, but using them for returning a simple double from a function is not one of them.
I see, that makes sense when looking at it from a wider perspective. I agree that this is an overly complex approach compared to other possible solutions, thanks for the explanation.
KDevelop (KDE dependent)
It should do what you're describing. Try the following: \`\`\`c \#include &lt;stdio.h&gt; \#include &lt;string.h&gt; &amp;#x200B; void \*ft\_memmove(void \*dest, const void \*src, size\_t size) { size\_t i; &amp;#x200B; if (size == 0) return (dest); &amp;#x200B; char temp\[size\]; &amp;#x200B; i = 0; while (i &lt; size) { temp\[i\] = ((unsigned char \*)src)\[i\]; i++; } i = 0; while (i &lt; size) { ((unsigned char \*)dest)\[i\] = temp\[i\]; i++; } return (dest); } &amp;#x200B; int main(int argc, char \*argv\[\]) { char a\[\] = "Hello"; char b\[\] = "World"; ft\_memmove(a, b, sizeof(a)); puts(a); return 0; } \`\`\` If you run this, it will output "World".
https://en.cppreference.com/w/c/numeric/math/isnan
Currently Sublime Text 3.
I use visual studio for windows development even though it's terrible software and on linux I use nano and gcc
Take this with a pinch of salt as I'm not a veteran C programmer, but wouldn't this be better due to removing the use of a global variable and also ensuring that double doesn't have any previous value clobbered in the event that the function cannot return a new (valid) value? bool maybe_double(double *d) { if (whatever) { *d = double_value; return 1; } else { return 0; } } int main() { double d; if ((maybe_double(&amp;d) &lt; 0) { panic() } go_about_business(d) }
Usually split my terminal with tmux and edit .c file on the left and .h file on the right in vim. Sometimes I use nano when the program I am writing is less than a screenfull. Sometimes when I am on Windows I use Pelles C when I need to do something in like 3 or 4 source files that there's no reason to set it up so other people can compile it.
Emacs + global
I really like Clion with vim. Just feels like the best of both worlds
The post asks about IDE and everyone respond with text editor. Maybe I am dumb and I use visual studio with resharper plugin.
That would be a fairly simple affair, IMO, because lines in a CSV only have one level of structure.
Then why is it that in my program, (The very first pasted, working program) , it moves the memory, rather than over writes it? That's why I'm so confused.
&gt; Are void pointers good practice? Generally speaking? No. There are rare exceptions to this, one of which is interpreters. However, there are alternatives (such as unions) which may or may not be better depending on your use case.
A man of culture truly it is.
Quite right. I just find that condition so peculiar, that I could not resist.
The force is strong with this one. Big fan of those tools sets as well 👍
How do you both feel about joe? I do all my work in vi but i find joe to be a really nice editor. I find it strange that it somewhat disappeared after the mid 00's. It used to be the goto editor on linux afaik.
I would say try find another way to solve your problem. There are floating point numbers that are Not a Number but if these aren't caught they can make a mess of everything because any floating point operation that takes a NaN returns a NaN. Producing a NaN isn't very portable either, depending on your compiler you may need to manipulate bits.
If you "forgot" C, you likely didn't know it well at all to begin with. I'd suggest starting over as you suggested. You can't really rush learning a programming language, spend time with the text and even more time with the exercises. I'd also suggest getting a better text. K&amp;R is very terse and not up to date at all, look at the K. N. King book instead.
I recently "discovered" GNOME Builder. It is a simple IDE with basic features, just what I need for C. Makefiles are supported. Debugger isn't the best, but I prefer Nemiver anyway.
I updated the code and then read this right after, haha. I just woke up and I was a bit groggy and OP asked for the function to return a double so I had written it like that in-case for some reason it was a hard requirement for the function to return a double since he hasn't given us much info, but it's definitely better to return a bool overall. Also, regarding using ints over bools for the return type, pretty much any function that I use that needs to return multiple different types of error codes, I will return an int. But anything that is simply true or false (such as this case, it's either NULL or valid), than I use a bool.
Seconding this. Along with vrapper for eclipse for vim bindings. Integrates with my company's Make system pretty well (most likely because the person who wrote the Make system used eclipse) &amp;#x200B; I don't really agree that CDT is bad. I can't really think of any editors/IDEs that handle C better especially wrt autocomplete. RAM is... not an issue for me.
I'm not in a company and I don't use a make system so, sorry no plus points for me, even if I really really like Eclipse
This post is firmly on topic.
Nice one. But it does not seem scriptable, am I mistaking?
Can you send me the full code? I suspect you're copying one less character then you should, making the string lose the null terminator which means that when printing, it will go on printing the rest of the stack which includes the other strings, making it seem as if it's repeating.
ed is the standard text editor.
If I develop for Windows, Visual Studio, hands down. Nowadays you can even cross compile with things like mingw with VS. So Linux development is possible. But if my main target is *nix, it really depends. Given that I'm not able to use emacs and I'm not that good with vi(m)... If I want to stay "free", I use NetBeans, but it's by no means my favorite. If I can spend money, I definitely prefer CLion.
Abstract interpretation to the rescue
I also use Sublime Text 3, but don't have any C projects over 5000 lines of code, so it's always seemed perfectly manageable.
VS Code, Gvim, or just vim (depending on how I feel) with Make and gcc through the terminal.
Recently just took CS I at college and my boss of a professor made a very descriptive backtracking program, comments galore. If you want to DM me for the zip Also look into n-queens and farmer/fox/goose/bag of beans problems
It's a great program but the IDE part is a little bit weak.
Vim+st
I'm a big fan of Emacs with Evil mode, but lately I've been working on Windows and found Visual Studio 2017 with VsVim plugin to be really useful... I'm not as fast as I am with my Emacs config but I at least don't have to look at the MSDN every time I want to call CreateFile()
VSCodium https://github.com/VSCodium/vscodium
DOS Editor.
That would be great if you could!
Thank you. Please send it!
Clion + IDEAVim is where it’s at, if I’m using Cmake.
Visual Studio :)
Some people say, and some people have, turned emacs into a complete environment where it's as if emacs is the operating system and they never leave it. In what way do you think emacs is only a weak IDE?
Vim with you compete me works great for my C projects
Adding on: If there’s an overlap, you may need to reverse the direction of your copy, since the on-stack VLA isn’t safe (and a `malloc` could easily fail). That’s where the overlap-vs.-no-overlap distinction between `memmove` and `memcpy` comes from; `memcpy` can copy entirely in one direction, whichever that is, but `memmove` might not be able to.
Tttttheoretically everything can be done with `char *` (for backwards compatibility to a time before `void`), though it’s annoying af to try.
Real programmers use Ed, get with the times. Seriously though, most of my work is c/c++ and nothing beats visual studio for me coupled with Visual Assist. Jump to definition, find references, and the various refactoring it offers plus the ability to open files from a hotkey (not ctrl+o--it searches the whole solution), etc. We have about 240 projects or so in our current solution for our product and Visual Assist handles them perfectly. You also get a lot of handy completion, so if you do something like declare a function or a method in a class, when you are writing the definition of that function, VA will fill out the params for you. I honestly would like to find something else for *nix projects; I'm totally blind and part of the issue for me is that I love hacking on kernels and other projects where things like VA or code completion would be really handy, but most IDEs apart from VS are simply not accessible or just suck. I do have the ability to use Emacs, although it has to be through a terminal and the speech support via Emacspeak is pretty terrible.
I used VIM and gcc compiler to learn C, then switched to Visuak Studio and its huge IDE with things like Debbuger(best tool I've ever learned to use).
VsCode, Geany, Pycharm and Intellij
The typical way of converting an integer into a string is to do i%10 to get the least significant digit then i/=10 to move onto the next digit. The problem is that you print the least significant digit _last_ so you need to buffer the digits in an array somewhere, and then when you've generated all the digits you want, iterate over that array backwards to print them out in the correct order.
Visual Studio 2017
It's a common joke on vim/emacs war, the actual quote goes "[emacs is] a great operating system, lacking only a decent editor"
Yea, if you're in the 1980s.
I'm going to try this, thanks.
I'm going to try this, thanks.
Emacs has at least 3 vi the implementations. Evil, vile, and I forget the rest.
Says the Notepad user.
If I'm on Windows, Visual Studio. I'm partial to CLion as well.
That is about like claiming you are using vim. It might be fine for a few config files, but your productivity is going to suck. After 35+ years of software development and engineering, I can easily assert you're full of it if that is your tool chain of choice.
Like I said, it's a joke, so you shouldn't take it seriously.
Neovim
We didn't have Notepad in the 1980s. It was called MS-DOS Editor, or edit for short. I didn't bother with it then, because it was MS-DOS. I had an Amiga and used MicroEMACS. The Irony though, I went to work for M$.
Surprised that no one has said Qt Creator! Beautiful IDE, built-in support for the Qt framework (for C++), has a neat plug-in system, cool analysis features with Clang and Valgrind and a **beautiful** debugging workflow. It also allows you to cross-compile projects for other platforms really easily. I'd say give it a spin!
vim, bash, make for most languages. For java: vim, bash, eclipse.
Atom: Hackable Text Editor I've used Nano, Gedit, Vim, Visual Studio, MSVC, Sublime, PyCharm, Eclipse, and many more and by far Atom is my favorite. I actually used Vim the longest before I came across Atom. Vim ruined me in a good way, but its nice not having to worry about multi cursors in Vim any more. It was the one thing I didn't enjoy... And yes, there are plug-ins, but they're limited. I like Atom because I can just tweak it to do whatever I want and I'm familiar with the languages that Atom uses. When I do code in C, I can use the compiler to lint on the fly, in Atom, so I'm not surprised by compiler errors when they do happen. I learned how to code on Linux using the Terminal, so it was a natural move for me to use terminal tools like Vim. One of these days I'll have to take the time to learn tmux.
Nope, that's just laziness. If you know the type and size of any variable, it's best to use it.
Dude the code in the OP is literally C...
Yes , sure https://youtu.be/9YA7X5we8ng
Thanks
It's good to note that compilers can sometimes use the extra freedom provided by undefined the behavior on signed int overflow to optimize code when the index is `int` as opposed to `unsigned int` (where the overflow has defined behavior). It's hard to give a small example, the best I can think of right now is this, which seems kind of contrived: #include &lt;stddef.h&gt; void g(double x); void f1(double *p, unsigned int i) { g(p[i++]); g(p[i++]); g(p[i++]); } void f2(double *p, int i) { g(p[i++]); g(p[i++]); g(p[i++]); } void f3(double *p, size_t i) { g(p[i++]); g(p[i++]); g(p[i++]); } See the generated assemply here: [https://godbolt.org/z/sK3HXu](https://godbolt.org/z/sK3HXu). It might be surprising, but if you check the generated assembly, you can see that both gcc and clang generate better code for `f2()` than `f1()`, because they don't need to handle the case of `x` overflowing on 2^32 (so they just use 64-bit registers directly). [Just for fun, I included `f3()` to show that, since the overflow behavior for `size_t` is exactly the behavior of the native 64-bit registers, the function can be compiled almost exactly as `f1()` which has no overflow guarantees] So, the moral of the story is: when everything else is equal, it's better to use signed integers because it gives the compiler more freedom to optimize. Just think very hard to make sure everything is indeed equal (i.e., overflow won't happen).
edlin was better. &amp;#x200B; M$ edit sucks. It was the leftovers from a failed intern on the Qbasic team.
Make is an IDE? Can someone explain?
It's just one component of [Unix as an IDE](https://sanctum.geek.nz/arabesque/series/unix-as-ide/).
Oh I see! Thank you!
I use Vim/JOE depending on my mood and what I need, GNU make is my build system of choice, GDB's text user interface, I also use git when I need version control. All on my Debian and FreeBSD installs. I also sometimes write with Windows 7, in which case I use Notepad++ and the tools provided by MinGW.
One that's not big and bloated and slow. So basically not VS. I hear VSCode is pretty good though but I ran DevC++ back in the day until I stumbled across MinGWStudio, which is a DevC++ clone that's actually stable - and I could run it right off a USB drive. Super fast/nimble but lacks certain features like auto-complete. I just learned to get by without it. Eventually though I had to start making 64-bit builds, and there was no way to do it with MinGWStudio so I finally made the leap to CodeBlocks almost a year ago. Even after all these years it's still glitchy and unstable but it was the easiest way for me to get up and running so that's what I use now. But I still prefer MinGWStudio, all day.
St is what?
I can vouch for Qt Creator but I have never used it for my own projects. I did have to download and use it to compile a C# program I wanted to modify and it was quite a clean and effective system for creating cross-platform programs.
Up your game and switch to zsh ;) This is pretty much my setup as well plus I have 30+ plugins and plugin manager also using ctags and cscope
I can understand what the author is saying. I think a developer on Unix needs to be able to survive without a bunch of extra fancy tools, but you will be left behind in terms of productivity if you swear off all plugins. Especially plugins that bring git integration to vim such as fugitive and git gutter. The plugins just make the task of staging commits and understanding code bases much easier.
There's a vim plugin for that! https://github.com/nims11/vim-nano
Supposedly Dennis Ritchie used ACME https://en.m.wikipedia.org/wiki/Acme_(text_editor)
You should just spilt your vim instead. I would still run it in tmux.
Mine as well. I like Visual Studio if I’m in Windows, but any kind of *nix and its tmux/vim/zsh/etc.
Probably, he means non-GUI vim on **S**uckless **T**erminal ?
:O. I will try it out, thank you.
Okay I see, and thank you.
Ah I see... I am still learning basic C so I don't really understand but I'll try.
Yös
For one thing, it means you can use a pointer to iterate over an array. If a pointer points to an array element, then doing `++` on the pointer will point to the next array element. This all seems very sensible doesn't it?
&gt; from what I understand, *(pa + 1) holds the contents of array[1] because (pa + 1) holds the address of array[1]. `*(pa+1)` is entirely identical to `pa[1]`, which is (blech) entirely identical to `1[pa]`. In `pa[i]`, `pa` starts with type (say) `int[N]`. Since there’s nothing like `sizeof`/`_Alignof` actually using `pa` as an array in that expression, the `int[N]` decays (optionally through `int[]`) to an `int *` to its first element. `pa[i]` is then interpreted as `*(pa + i)`, which is an access to the `i`th element (not byte) after the start of `pa`. &gt; But what is the logic behind "the address of the next element in the array is the address of the current element + 1" ? Why 1? I’m not sure what aspect of this the question is focused on, but if it were &lt; 1, then `p+0 &gt; p` which makes no sense, and if C required you to fully calculate the address of an array element with `array + i * sizeof(*array)` it’d be annoying af to accomplish anything complex. If things didn’t work this way, array indexing would have to be done by a completely different mechanism than pointer indexing, even though `&amp;p[i]` should reasonably give you something like `&amp;p[0]+i`, so there’s no reason for them to be different. The type system would be more complicated than it already is, you’d probably need two sets of string/buffer functions, etc.
St is the suckless or simple Terminal Made by guys at suckless.org. It's my Terminal Emulator on linux
It’s 1 because that’s the index you’ve given. If you gave a[3] then that’s equivalent to *(p+3) The number is translated to the size of the pointer. This is called “pointer arithmetic” if you want to look it up. Most other languages don’t support it. It’s a low level feature of C
Type safety. Consider when you have a type like: struct foo { int n; char c; } And you also have an array and pointer: struct foo arr[SIZE]; struct foo* p = arr; Now we want to define pointer arithmetic and need to figure out what `p + 1` points to. If we just increase the address by 1, it will point into the middle of the object so it no longer would be of type `struct foo*` and would be of some indeterminate type.
I believe this resource on [pointer arithmetic](https://www.tutorialspoint.com/cprogramming/c_pointer_arithmetic.htm) can help! You can basically access pointers like you would with an array, just with different notation. So array\[x\], where x is an arbitrary value, is the same as saying \*(array + x). By default, array already points to the first element. As for pointer arithmetic, you are actually offsetting the address by x-bytes (dependent on the data type and size of the data type on your machine). Let's say that you have an integer pointer that points to an integer array, and assuming that an integer is 4 bytes, doing ptr++ will offset the pointer by 4-bytes and be at the second element of the array. Similarly, you can fo ptr++ again and be at the third element in the array and then just output it by dereferencing the pointer. The link I posted above has some good examples and can explain it better than I can. I hope I helped answer your question!
Arrays are stored in continuous memory location. That is if we have an integer array, say int a[5] And if a[0] is stored in memory location 1000, then a[1] will be stored in next integer memory that is 1004, a[2] will be in 1008 and so on... So pointer pa will point to a[0]. Doing pa++, will point to next memory location. As we have integer array, it will move forward by 4 bytes and point to a[1].
&gt; Is it just how the language was built? Well, technically speaking, yes. The array subscription operator is _defined_ as being an operation upon a pointer. Specifically, x[y] for appropriate expressions `x` and `y` is defined as being _exactly_ the same as: *((x) + (y)) That is, an array subscription is defined in terms of pointer arithmetic. But I suspect your question is more about how the value `1` works given that the objects in the array may be larger than 1 byte in size. This is because pointer arithmetic in C, like the one I've just shown you here, should be thought of as _having nothing to do with memory addresses_. OK, let's say you've got some object in memory, and you have a pointer `p` whose value points to that object. Adding 1 to `p` would change the pointer so that it refers to the next, adjacent object of the same type in memory, if that object exists. "Next" and "adjacent" are key words here. Similarly, subtracting 1 from `p` would change the pointer so that it refers to the previous, adjacent object of the same type in memory, if that object exists. Again, "previous" and "adjacent" are the key words. Finally, given two pointers `p` and `q` of the same type, subtracting `p` from `q` will yield the number contiguous, adjacent objects in the half-open interval between `p` and `q`. Key words: "contiguous", "adjacent". Now I picked out these key words "next", "previous", "contiguous" and "adjacent" for a specific reason. The _only_ well-defined way of getting a set of objects of the same type in memory such that they're all adjacent in memory, such that you have contiguous sequence of objects, is to use an array. Pointer arithmetic is essentially only well-defined on pointers to array elements. Any use of pointer arithmetic on pointers to objects not in array has undefined behaviour. Note that I've defined the pointer arithmetic involved here without any mention of memory addresses! That's important: memory addresses are implementation details, and when C programmers use pointers correctly they do even need to think about memory addresses.
&gt; which is (blech) entirely identical to 1[pa]. It's semantically identical.. but not entirely. The type of the pointer matters for arithmetic, so 1[pa+1] may easily _not_ be the same thing as 2[pa].
Valgrind is good but let's hear it for the -g flag.
vs &gt; all for windows.
Up *your* game and switch to Fish! :D I swear, when I switched, I was utterly blown away- not just by the features it comes with out of the box, but how *goddamn fast* it is.
Just started using vim, man that shits powerful, I've never been as quick with any IDE integrated editor than I am with vim.
I like Xcode.
It's just how the language was built. But it's also how almost every language every has been built, and it's also how people wrote code *before* programming languages were built, so it's not the fully story if you just say "that's how C was built". Imagine you have a region of memory between addresses 1000 and 2000 and you need to store 3 different values in there. You *could* store them at addresses 1973, 1205 and 1688, but...why? Wouldn't it make a lot more sense to just store them at 1000, 1001 and 1002? That way it's very easy to keep track of exactly where they are. And how, exactly, do you keep track of exactly where they are? Well if you have a variable x that's equal to 1000 (in C we call this a "pointer"), then the first element is at x+0, the second element at x+1, the third element at x+2, etc. Pointer arithmetic in C was just formalizing what people had been doing in machine language for decades, which was organizing and retrieving data in the simplest way possible.
Acme is very nice, certainly when used with the 'plumber'. I've used it for a while on plan9 and it was a real joy to extend it like that. The whole lot of plan9 is actually very nice imho :)
No indeed but nano also isn't so that's why i thought of it as a more 'friendly' editor. If you want a small scriptable editor i'd recommend jed, it has s-lang as an extensionlanguage and is very emacs like otherwise.
You can also check the value of the first element of a struct that a void * is pointing to. The C language requires that the first element of the struct is at the struct space's starting address, IIRC.
CLion and the *ideavim* vim emulation plugin is where it's at.
Vim and clang at the moment.
wham, bam , thank you, ma'am
You are already using pointers. Arrays passed to functions by value decay to pointers. Anyway, pointers should be used in cases, where: * you have a large data to pass to a function (passing a pointer avoids copying entire value), * you want to modify a value from within a function, * you want to allocate memory in function and return it outside scope (for example: dynamic instancing), * you want to pass the far end of an array, including c-string, to a function (for example, you can pass a middle of an array and function won't even know there's something before that), * you love pointer arithmetic and cannot contain yourself, * you have some other, more exotic needs.
Why is it a good idea to make copies, exactly? What if the global variable changes while you are working on it? Do you not want to take these changes into account?
&gt;Do you not want to take these changes into account? No. Unpredictable changes lead to all sorts of hard-to-debug errors and can really screw you over unless you are extremely careful. If the new change is really that important the ISR should be pushing it into some kind of queue to be handled later, not changing a variable in the middle of a non-reentrant function. If you want to work with raw volatile variables without the protection of a mutex you better have the sequence point rules down cold because Murphy is guaranteed to screw you over in the strangest way possible.
Yes, you are speaking of a queue, but the OP did not. I know and use the idea where a queue is treated safely and the worker threads work on at most one element of the queue at the same time. But how does this relate to OPs question? What even is OPs question?
Would it be possible for you to send it to me too?
But a char pointer implies a pointer to char, while a pointer to void implies nothing about it
&gt; Arrays passed to functions by value decay to pointers. Alright thanks. Do you have any idea how I might implement structures to my game? Its one of the requirements too.
You could store `grid`, `done` and `counter` in a structure and pass it between functions (by pointer), but in this program it doesn't have much sense.
That's a good idea. I think I got in the habit of doing that because I had a hard time remembering which key did that in tmux so I was trying to use it whenever I could.
It's hard to tell for sure since you don't say how the LEDs or joystick are wired, but it looks to me like you are constantly toggling all three LEDs as long as the button is pressed; then you turn them off when the button is released. This should manifest itself as all three LEDs shining at a reduced intensity, or even flickering if the loop is slow enough (try adding a 100 ms delay at the top). To avoid this, use `|=` instead of `^=`. If you want to cycle through each LED at each button press, either use a variable to keep track of which one should be lit or use multiple loops within a larger one: loop until the button is pressed, turn the LED on, loop until the button is released, turn the LED off, loop until the button is pressed again, turn the next LED on, loop until the button is released, turn the LED off...
No, it's C++.
&gt; I either wrote a badly readable code or I forgot the concepts Probably both. &gt; Should I go through K&amp;K and do all exercises? That's not a bad idea. Then look at your own code again, hopefully you will understand it better. The most important lesson to draw from this is that if there are two (or more) ways to write a particular piece of code, choose the one which will be easier to read and understand later. Most of the time, making your code more easily understandable by humans also makes it more easily understood (and optimized) by the compiler.
&gt; Surprised that no one has said Qt Creator! This subreddit is about C.
Could you help me out with this? I've spent all day on this and I dont have a clue even after going through the textbook. Here is what I've done: struct Game { char *grid[SIZE]; int *done; int *counter; }; Now how do I declare the variables? Do I do it in the main function like before? How do I pass it to the functions?
Yeah, and Qt Creator is perfectly fine for C. It's not just for C++. I've used it for a lot of C assignments for University and its debugging has saved me a lot of trouble.
Backtracking is not a C concept, nor is it particularly complicated: it just means “keep going in one direction until you either find a solution or realize that it is the wrong direction; if the latter, return to an earlier state and try a different direction”. In order to do this, you need: 1. A record of the path you've taken so far 2. A record of the problem state at every step along that path 3. A record of all the paths you have already tried If you're using recursion, 2. and 3. are automatically taken care of by the call stack, but they are lost when you unwind, so you may want to store them separately anyway. How you keep track of 1. will vary from problem to problem; in some cases, recursion might take care of it for you as well. A backtracking progam might look a little like this: // Attempt to solve the problem starting in the given state. If a solution // is found, the state structure is updated to reflect the solution. // Otherwise, it is left unchanged. bool solve(struct problem_state *state, int *path, int step, int direction) { if (!can_move(&amp;modified_state, dir)) return false; struct problem_state modified_state = *state; update_state(&amp;modified_state, direction); path[step] = direction; if (is_solution(&amp;modified_state)) { *state = modified_state; // record solution path[step + 1] = -1; // mark end of path return true; } else { for (int dir = 0; dir &lt; NUM_DIRECTIONS &amp;&amp; !solved; dir++) { if (solve(&amp;modified_state, path, step + 1, dir)) { *state = modified_state; // propagate solution return true; } } } return false; } Note that in this case, we do not need to keep track of paths that didn't work out, because we test all possible path in a deterministic order.
I can give you a working example how to use structures and pointers. You have to figure out yourself how to use it in your program. ``` #include &lt;stdio.h&gt; struct ExampleStruct { int val1; float val2; }; static void print_val1(struct ExampleStruct *es) { /* Print `val1` from struct `es`. Notice we use `-&gt;` here because struct variable is actually a pointer */ printf("Val1: %d\n", es-&gt;val1); } static void print_val2(struct ExampleStruct *es) { /* Print `val2` from struct `es`. Notice we use `-&gt;` here because struct variable is actually a pointer */ printf("Val2: %f\n", es-&gt;val2); } int main(void) { struct ExampleStruct s; /* Initialize values */ s.val1 = 42; s.val2 = 5.78; print_val1(&amp;s); print_val2(&amp;s); return 0; } /* vim: set ft=c sw=4 sts=4 et: */ ``` The result after running the program: ``` Val1: 42 Val2: 5.780000 ```
Nothing is being pushed. What happens is this: You have (keeping in mind that `src` and `dest` overlap) src: HelloWorld_____ temp: __________ dest: World_____ You want src: HelloHelloWorld temp: HelloWorld dest: HelloWorld In the first version, you start by copying `src` into `temp`, then copy `temp` into `dest. The first loop goes like this: src: HelloWorld_____ temp: H_________ dest: World_____ src: HelloWorld_____ temp: He________ dest: World_____ src: HelloWorld_____ temp: Hel________ dest: World_____ ... src: HelloWorld_____ temp: HelloWorld dest: World_____ The second loop goes like this (once again, keeping in mind that `src and `dest` overlap): src: HelloHorld_____ temp: HelloWorld dest: Horld_____ src: HelloHerld_____ temp: HelloWorld dest: Herld_____ ... src: HelloHelloWorld temp: HelloWorld dest: HelloWorld In the second case, you merge both loops, and what you get is this: src: HelloHorld_____ temp: H_________ dest: Horld_____ src: HelloHerld_____ temp: He________ dest: Herld_____ ... src: HelloHello_____ temp: Hello_____ dest: Hello_____ src: HelloHelloH____ temp: HelloH____ dest: HelloH____ ... src: HelloHelloHello temp: HelloHello dest: HelloHello To fix this, you need to check if `src` and `dest` overlap, and if they do, pick the correct strategy: 1. If `src == dest`, you don't have to do anything. 2. If `dest &lt; src`, you can copy `src` into `dest` from left to right since you won't overwrite anything you haven't already copied. 3. If `dest &gt; src`, you have to copy `src` into `dest` from right to left to avoid overwriting data you haven't yet copied. Note that there is no difference in performance between the two non-trivial cases, or between them and the non-overlapping case (which is identical to the second option), so you don't really care if the buffers *actually* overlap; just compare the pointers and copy from left to right if `dest` is to the left of `src` and from right to left otherwise.
This is C++, not C. For a C solution, look at gets; `char firstname[128]; fgets(firstname, sizeof(firstname), stdin);` will read an entire line (up to 128 characters) into firstname. Alternatively, you could look into the readline library, which gets a bit more complicated (especially since it looks like you're on Windows), but offers a better user experience. For C++, you may want to look at [the getline function](http://www.cplusplus.com/reference/istream/istream/getline/) (though fgets and readline will work in C++ too).
I find it strange that so many people have answered, yet none of them have thought to ask you why it *shouldn't* be 1. So why shouldn't it be 1?
I'm very sorry. I assumed both programming languages are allowed here. Thanks for the help though.
For what it's worth there's also getline(char**, size_t, FILE*) in C which is often nicer than fgets for user inputs IMHO.
&gt; Pointer arithmetic is essentially only well-defined on pointers to array elements. Any use of pointer arithmetic on pointers to objects not in an array, or pointers to objects in different arrays, has undefined behaviour. Technically if you're very careful about the alignment rules (or you use compiler-specific extensions to disable struct padding) it should also be well-defined between members of a struct or union. Like if you do this: struct sort_of_an_array { int val1; int val2; int val3; int val4; }; sort_of_an_array my_var; You could treat `&amp;(my_var.val1)` as if it was a pointer to the beginning of an array of integers of size 4.
Idk why but CLion is just unreasonably slow for me on mac. Also I get a lot of "File is too complex to perform data-flow analysis" even in a reasonably normal project
If you have "volatile" (whether due to ISRs, other threads, memory-mapped HW, etc.) data that you need to work with consistently, you have basically two approaches: 1) "lock" the data (disable interrupts, take a mutex, etc.) and then run your processing like that. 2) "lock" the data only long enough to make a local copy of it, and run processing on the local copy. If it's impossible or too slow to run the processing while things are "locked" then you have to make a local copy of the data. If this data is more complicated than just one or two simple variables I would suggest packing it into a struct and passing that (or a pointer to such a struct) to your processing function(s). Then you end up with something like: struct complex_data { ... // complicated stuff you're gonna read from a volatile place under lock }; void get_consistent_data(struct complex_data* out) { lock_data(); // disable interrupts, take mutexes, etc. ... // read into (*out) unlock_data(); // re-enable interrupts, release mutexes, etc. } void process_data(const struct complex_data* data) { ... // use stuff from (*data) to do something }
Fish was neat, but it's scripting is a lot different from bash. There are a few zsh plugins that bring that fish goodness to zsh. Like as soon as I start typing it starts showing me a similar command from my history.
It's unrelated to your problem but please, when asking programming questions, don't ever post pictures of your code. People will most likely want to copy-paste your code to test it, fiddle with it and it also avoids having to click a link to a service that may not keep your images for as long as your question. Posting your code directly, properly indented, greatly increases your chances of good answers no matter what platform you're asking on.
I like the suckless philosophy. I currently use unicode rxvt 256 color multi language. What's the main reason to switch?
I just type :sp or :vsp and I just use ctrl-w ctrl-w to switch between them in vim. I also use the tmux pain control plugin which uses pipe and underscore to split
At least use notepad++
I like Their philosophy too. My main reason was that I Wanted a lightweight Terminal for my Laptop that supports truecolor in order for my vim colorscheme to be displayed properly. Konsole was way too Resource heavy and st was One of the few that natively Support true color. I am using the config.h from luke smith, if you want to look it up on his github
There's no need to use strcmp or any function at all. You can do it like this: char *str = "Hello world"; if (str[0] == 'h') { //whatever } But, if you really do want to use those functions you could use strncmp: strncmp(str, "h", 1); See the reference here: http://www.cplusplus.com/reference/cstring/strncmp/
If you only care about the first char, test str[0] == 'h' If you want to compare the first several char, test strncmp(str, "hello", 5) == 0
A string is simply a pointer to the first character, so you can just write, `str[0] == 'h'` to check the first character of str. But bear in mind that if you want to check subsequent characters, you have to make sure the string is long enough.
"strings" in C are just an array of `char` values. You can get character constants to compare against like this: const char * my_string[] = "hello world"; if (my_string[0] == 'h') { ... } Or, equivalently, comparing against the ASCII numerical value of lowercase h: if (my_string[0] == 0x68) if (my_string[0] == 104) There's also a `strncmp()` that takes a length argument, so you could do: const char * compare_string = "h"; if (strncmp(my_string, compare_string, 1) == 0) { ... }
Sorry. I'm a beginner in both programming AND programming subreddits so it's nice people are pointing this out. Thanks for letting me know.
Me 2!
 1. `#include&lt;stdio.h&gt;` 2. `#include&lt;string.h&gt;` 3. `void main()` 4. `{` 5. `char str[100],c;int i,lenf=0;` 6. `printf("\nenter a string:");` 7. `gets(str);` 8. `len=strlen(str);` 9. `printf("\nenter a character to find its position:");` 10. `scanf("%c",&amp;c);` 11. `for(i=0;i&lt;len;i++)` 12. `{` 13. `if(str[i]==c)` 14. `{` 15. `printf("character position:\n%d",i+1);` 16. `f=1;` 17. `}` 18. `}` 19. `if(f==0)` 20. `{` 21. `printf("\ncharacter not found");` 22. `}` 23. `}`
Don't worry, everybody has to start somewhere :) Keep at it!
Thats a pretty good insight. Never thought of it that way.Thanks!
It's [still around](https://joe-editor.sourceforge.io/) and while it's not scriptable, you can pipe selected text to external programs with the output replacing the selected text. You can also run programs and have its output appear in the current buffer.
Yeah it's even been updated to hold up very well. I was just curious why linux all of sudden decided that nano would be a good replacement. I've seen arguments about ctrl-c exit being the other way around and the lack of help but i'm not convinced. Joe always stated how to get help in a big bar on top of the screen and the exit command shouldn't be ctrl-c. I guess i wished it was the default on many systems instead of nano haha
This is the exerpt from the following book (**chapter 12.3**): &gt; C Programming, A Modern Approach - K. N. King: [Imgur Pic](https://imgur.com/a/r43iZsh) Hope it helps.
Message me an email I can send it to 👍🏼
Message me an email I can send it to 👍🏼
Adding `1` to a pointer in order to increase the address by 4 / 8 / what have you is something that bothered me, because I prefer abstractions not to obscure the underlying behavior overly much, and the actual assembly code produced does use offsets of the size of the array items, not offsets of 1. However, it's not an entirely unreasonable abstraction to make the language use, because you generally shouldn't ever be working with pointers that point between two things, and abstracting pointers to point at "items" instead of holding "addresses", where incrementing the pointer retrieves the next "item" is a decent way of preventing people from fucking their offsets up and pointing in between two things by mistake. Plus, if you really do want to increment an `int` pointer by `1`, it's still possible to do it via casting.
Eventually I just switched to XCode, I found it much more stable performance-wise. I use it for C++ though not C. It's missing code folding but it's not that big of a deal It's weird because I haven't had any performance issues with IDEA or WebStorm, only CLion
I worked on something similar years ago in Lua, but it could only detect addition or multiplication with a constant number (x^ny or x+ny). Remembering the pain that was, hats off to you!
If you're using something that doesn't have that kind of protection, like Apple OS, you get unpredictable things. Reading some addresses could trigger hardware (like making a speaker click). Writing some would change the data, which could do anything or nothing. It's interesting to look back to a time when the OS and device drivers and the command-line interpreter, were in ROM. You couldn't crash the computer unless you really tried.
Interesting, Apple OS doesn't have this protection? If I were to assign a pointer to a heap-allocated object, and destroy that object and then try to use the pointer again, Xcode wouldn't complain?
Thank you! And, I haven't given up on finding a Deep Learning solution to this, either....
This is a matter of taste, but you will eventually learn that your procedure parameters names tend to become more generic the more useful they are. You can start with a funcion that does some complex stuff with file paths and it's ok to be like this: int foo(char * path); But then you realize you want to do the same work with other kind of strings that aren't paths, it's good practice to reduce the meaning of the parameter to avoid misunderstandings. int foo(char * str);
What’s your data formatted like? Maybe make an array representing a function. Consider the generic templates of a + bx + cx^2 + dx^3 + ex^4 ... (?)x^99 a + b^x a + blogx You could make an array GenericFunc[], where GenericFunc[0] would represent a, [1] = b, etc. And you could make the arrays for logarithmic and exponential functions just as well. Maybe you could make an array where each index represents a,b,c,d respectively. You would feed the ai an array of datapoints and the function array, and it can figure out connections perhaps. In the future, you could maybe do some weird metaprogramming that allows you to insert some generic formula as x, so you could detect something like 5 + 7^(2x-3) And remember that manual tinkering and “aiding” or “guiding” the ai can lead to stagnant development :)
Nothing would brick the machine as in, render it completely useless. But you could do interesting things. For instance you could overwrite addresses for Operating System functions like disk reads. Put your own code in their place to do something cool like caching data, or perhaps getting around disk-based Copy Protection systems, and then call the old handler as if nothing happened. Really neat things. You could also just write into the screen buffer to display things. The inadvertent effects were just things like the OS locking up, the CPU issuing a HALT because ya done goofed like writing to address 0. There was no failsafe. On the old home computers it was a lot of fun to goof around in memory spaces you had no business in. DOS was much the same. I kinda miss those days, although these days I wouldn't have the time for that kind of play. And of course today computers with modern OS' do so many things so very well and fast, I wouldn't go back in that respect.
What do you mean by alphabet?
The English alphabet but in capital letters
I need it shifted to the right by a value that I enter in
I don't think I understand what you mean
If I need to use both the original value of the parameter and a modified value, I usually use a \_arg suffix for the parameter so it's clear that they're related and which is which. &amp;#x200B; int doStuff(int value_arg, int type_arg) { int value; if (!type_arg) { value = value_arg; } else { value = doSomethingElse(value_arg); } if (value &lt; 0) { value = value_arg; } return(value); }
I have to move a string to the right by a certain value
I have to move the string to the right by a certain value. And then show the new transformed string underneath the original string
caesar cipher?
Yh
I was talking about the Apple \]\[ era, before Mac.
If I understand correctly you want to move each letter in the string by the value of an int. A string in C is an array of chars so add to each char the value of int and make a new string with these chars.
Okay. That makes sense. Thank you
Don't forget to check if the result char gets out of the alphabet. You could use a mod to start again from 'A' if that happens.
...what?
A lot of early micros required an acknowledgement signal to indicate that the data from the memory was ready to be read. If you accessed an unassigned part of the memory the ready signal never got asserted and the processor would hang. To recover you'd need to reset the processor. A better solution was to have a failsafe circuit that would force a ready signal if nothing else did. That made accessing unassigned memory slow, but it wasn't catastrophic.
Ohhh
Hm, now I think about it, this already happened to me, I had a function and I used some parameter for multiple things, and then the parameter's name didn't really make sense anymore. Thanks for letting me know!
Post. The. Code.
"Access" as "read from it"? The way you access memory is just by writing and address on the address bus, and all the peripheral knows what memory range is their, and they write back on the data bus that response. A pointer could be in malloc'ed memory, or in something completely different (say non-malloc'ed emory), or in address ranges used by peripherals. In fact, using pointers this way was the way to, for instance, read from the screen on a Apple ][, a C64, a Atari ST, an Amiga, a Macintosh, or even an early PC. In many cases some bits of addresses were ignored, which gave you the impression that memory/peripherals were "looping over". So, using a random pointer would return you garbage (generally 0x00 or 0xff) if the address was mapped to no-one, or you could end up in some peripheral memory (for instance the screen, the speaker, the keyboard, the RAM or the ROM). So, for instance, ```*(char *)0xc000``` on a apple2 would return the character pressed on the keyboard as would ```*(char *)0xc010``` or ```*(char *)0xc020```. (I know, there should be a volatile here). On some architecture, like the early 68000, you could not access 16bits at uneven addresses, so ```*(char *)1``` would be fine, but ```*(short *)1``` would be a bus error. If you started writing to random addresses, then funny stuff would happen, from crashes (you could remove your own executing code), to weird stuff drawn on the screen, random sounds, garbage written to the disk, etc... (note that you could do funny things just by reading from some memort-mapped registers [like changing the video mode on an apple2, iirc], but it was rare). Writing could crash the system (in many cases there weren't even a OS on it), but rarely anything that a reboot wouldn't fix (understand that, as a manufacturer, if random writing was bricking your computer, you would have quite a high support cost). Computers used to have a boot rom, and a cold reset would put back everything together.
Interesting, I might use this to avoid confusion and to generally have clearer code, thank you!
&gt; It's interesting to look back to a time when the OS and device drivers and the command-line interpreter, were in ROM. You couldn't crash the computer unless you really tried. You could *crash* them very very easily. It was much harder to *brick* them, though, which I what I think you meant.
Poster is talking about Apple ][ systems (in the 80's), or even early MacOS (but the system was not 100% in ROM). Note that, even today, most compilers won't complain if you allocate an object, delete it and use it after. The behavior is undefined, but it probably won't crash immediately due to memory protection. Memory protection would generally only fire when you access a pointer that is not in the *address space* of your process.
Visual studio is fine, otherwise use GCC (mingw).
I'm not completely sure what you're asking. Like a decoder key where A is originally 1 and Z is 26, but our new key displays A as 10 and Z as 9? If that's the case: Have an char of the current letter (initially A) and loop from the new value of A (10 in our example) to that value minus 1. Have an if in your look to check if the current value is 65+26 (one character past ascii 'Z'), and if it is, subtract 26 from that value (giving us ascii 'A'). This restarts us at the beginning of the alphabet, but we'll continue to match up with the original alphabet. At the end of each loop iteration, increment our current character. Store these characters in an array or something else that works.
Nothing good happens. Imagine another program reaching in and writing arbitrary values to some of your data. Nothing stopped programs from stepping on each others toes in early computers, you just had to know not to do that and a misbehaving program could corrupt data in RAM for all manner of things on the computer. This can crash the OS, but the "OS" in those days usually took a back seat to your program anyway. Your program had complete control of the machine, and your program asked the OS to do things for you. If you were really brave and wanted to interact with hardware manually, you could overwrite the OS in RAM and just never call the OS. It wasn't an instant crash or anything. Bricking a computer was much harder, though. It's possible to do it on an IBM PC, but it won't happen by accident. You can flash the BIOS from software and erasing the BIOS program from ROM will render the computer unbootable, but this required a very specific sequence of events to take place, it's not something you do by accident. There were no MMUs on most early computers. They didn't even have a way to detect that anything was wrong. It was up to the operator to realize something was wrong and investigate. Just like there are no MMUs on most small microcontrollers. Your program is the only thing running anyway, an MMU would be a waste of silicon.
The best compiler is the compiler provided by your system.
&gt; Computers used to have a boot rom, and a cold reset would put back everything together. They still do... but they used to have the *whole OS* in ROM/EEPROM. You kinda had to, if your computer didn't have any built-in persistent storage. Some modern systems have an extremely minimal fallback OS in their BIOS. At an old job I used to deal with SUN Microsystems workstations, and those (90s vintage) could boot up from nothing with a minimal shell and enough functionality to do things like fix configuration files (hope you're good with vi!) or reimage the system from an external hard drive or network install server.
Old fashioned Macs back in the 80s lol, not OSX.
What do you mean? I am currently using a windows 10 laptop, is there a native C compiler? from what i've tested I can't seem to find it if there is.
Netbeans wit mingw
On windows visual studio is the easiest option. It supports c99 (majority of it, at least). On linux there are clang and gcc, you can install them on windows too, but it's not as straightforward as visual studio.
&gt; I know this is perfectly legal, because a local variable gets dumped once the function is over Every variable in C has three properties: linkage, lifetime and scope. You're confusing lifetime and scope here. * Lifetime is how long a variable stays alive. An automatic variable, such as a function parameter, is only alive for the duration of the function. * Scope is where in the program text a variable can be referenced by name. A function parameter, for example, can only be referenced by name from within the function. It's okay to do this because the code that called the function cannot reference the function parameter by name since it's out of scope. It's also okay to have a variable of the same name because of scope, when you reference the variable X, it starts in the scope you're in and searches upward. It looks at the scope that the current scope is in (such as the function a for loop is in) for a variable called X and so on all the way up to the file scope where file scoped and global variables live. It never searches the scope of a different function for a variable called X, so there's no danger of accidentally referencing the parameter of a different function by name. It's commonplace to have a local variable and the parameter to a function with the same name. If you're computing the size of something to pass as the size parameter to a function, it makes sense to call it size. It makes it very clear that that is intended to be the size parameter for that function. What isn't good practice is shadowing variables. Shadowing is what happens when you have two variables with the same name that are both reachable from the same scope. Consider this. int x = 42; void func(void) { int x; for(int x = 0; x &lt; 10; x++) x += 3; x = 9; } What does `x += 3` do? You have three variables named x, and it searched upward from the current scope for a variable named x. It finds one (the one declared inside the for loop) and modifies it. The x declared at the top of `func` is inaccessible, there's no way to refer to it by name from inside the for loop. Similarly, the x declared above `func` is inaccessible from inside `func` because the local x variable shadows it. Shadowing is bad practice. It's confusing, you often think you're modifying one `x` when you're really modifying a different one. It's clear(ish) what's going on here, but in a large function of 100 lines, it can be difficult to see that the function has shadowed a variable with file level scope that you really intended to access.
No one can answer this question, you haven't given enough information. This also sounds like homework, you should post any work you've done instead of asking for answers.
The native C compiler is MSVC, the compiler shipped with Visual Studio.
* Don't use `scanf()` for parsing user input. * Read input as a string, then convert to integer with `strto*()` family of functions (for example `strtol()`. * Always compile with warnings turned on to absurd levels and fix all problems first. If some problem looks unimportant, fix it too. Compiler output must be squeaky clean. For gcc, I recommend `-Wall -Wextra -pedantic -pedantic-errors`. * Don't forget to break the case.
Smells like introduction to ROT-13. Copy characters from one array to another with offsetted index and make sure you turn over upon reaching the end of an array. C-strings are terminated with a nulbyte (`'\0'`)... ...or be creative and figure out how to move characters in original array (if mutable). Keep in mind: overwritten characters cannot be recalled... ...or just move along the array with offset and print out characters instead of copying or moving them. This is the simplest solution. And yes, don't forget to turn over. So many solutions... :)
Indeed. In fact, GCC and Clang both provide `__attribute__((__packed__))` now, and I rely on these to give me packed structures in certain cases — for example, when I want a large array of odd-sized objects (12 bytes each, say) or when I'm accessing the elements of a memory-mapped file header. And to ensure that I'm not making any incorrect assumptions about the compiler, I use `_Static_assert` right below the structure definition to ensure that the resulting structure that the compiler creates is *exactly* the size in bytes that I need/want. If ever the size changes, I'll know immediately because my code refuses to compile. Here's an example which defines a 96-bit integer type and requires it to be exactly 12 bytes: define STATIC_ASSERT_SIZE_BYTES(type, bytes) \ _Static_assert(sizeof(type) == (bytes), "sizeof(" #type ") is wrong") typedef struct PACKED { uint64 v0; uint32 v1; } uint96; STATIC_ASSERT_SIZE_BYTES(uint96, 12);
I just just it. I did a simple struct that calls for a name and then displays the players name if they won. Thanks for helping me out!
For simple programs tcc is enough - works even without installing anything!
Hey... If the compiler is smart enough to know that the target is little-endian (say), and it knows for sure that you're calling the stock `strncmp` function and not your own replacement for it, can it just read the 64-bit value `*(uint64_t)str`, do a bitwise-and of that with `0xFFFFFFFFFF`, and compare the result for equality to `0x6F6C6C6568`? Because damn, that would be fast.
So the thing to understand is that all letters have numeric values. For instance, the letter 'A' has the value 65, 'B' has the value 66, etc. C is allows you to convert back and forth with minimal effort: char c1 = 'A'; int n1 = c1; // n now has the value 65 int n2 = 66; char c2 = n2; // c2 now how the value 'B' Note: I am simplifying quite a bit and technically the details above depend on something called an encoding but for your homework that should be enough.
If possible, you should ensure that no variable which could be written an enabled interrupt will ever be written by anything else when the interrupt is enabled. Instead of e.g. having a counter which is incremented by main-line code and decremented by the interrupt, use two variables--one of which counts how many times the main-line code has done something that should increase the value, and one of which counts how many times the interrupt has decreased it. It's important to be aware, however, that while many languages with a "volatile" keyword would guarantee that they would process something like: volatile unsigned char interrupt_owns_data; int data; Interrupt code: if (interrupt_owns_data) { do something with the value of data; interrupt_owns_data = 0; set the value of data; } Mainline code: if (!interrupt_owns_data) { set the value of data; interrrupt_owns_data = 1; do something with the value of data; } in such a way that `interrupt_owns_data` can serve as a polled mutex, the C Standard doesn't require compilers to uphold such a guarantee in situations where it wouldn't be useful, and expects that people writing compilers for various purposes will seek to them useful for such purposes without regard for when the Standard would require them to do so. Unfortunately, neither clang nor gcc seems to provide any option to reliably uphold that guarantee without disabling many optimizations or using compiler-specific directives on most platforms *even if they only have one processor*.
Sort of. `signed`/`unsigned`/default `char *` and `void *` can freely alias, which isn’t true of any other types; the `char *` aliasing rules are left over from when `void` wasn’t a thing, and stuff like `memcpy` just used `char *`.
A lot of C programmers do write "C" but compile it with a C++ compiler. The problem with C++ is it offers too many ways to solve the same problem, so when it comes to using other peoples code, it can become a nightmare.
There is alas a huge difference between the notions of "should be well-defined" and "is reliably treated as well-defined by clang and gcc". In the language invented by Dennis Ritchie, a write to an object would affect the storage at its address, and anything that affected that storage at an object's address would affect that object's value. The language processed by clang and gcc, however, take a different philosophy. They only believe they should recognize the possibility of a pointer being used to access in object in cases where both (1) the Standard requires them to recognize it, and (2) they can easily distinguish the access pattern from others where the Standard would not require them to recognize it.
Many I/O addresses on the Apple II would perform actions when accessed, without regard for whether the access was a read or a write. If memory serves, two stray reads could cause whatever track was under the floppy drive's head to be erased.
I see what you mean. But in the end if I had to give people a reason to use void* as opposed to char* when appropriate I would say it's less confusing because I suppose some people tend to associate char* with null-terminated character strings while void* could point to anything, which is exactly the case mentioned by the OP.
A related question I saw a blog but I forgot the name from a pure C developer with a lot of examples and info about how develop C++ an other oop in pure C. I can't find that blog no matter how much I try Any advice?
Yes, this can potentially create aliasing problems if you mix reads and writes to, say, `my_var.val3` and `*(&amp;(my_var.val1) + 2)`. If the compiler cannot (or is not required to) recognize that a pointer refers to a particular variable's address, it might reorder (or, in some cases, elide) reads and writes in such a way that it does not behave as one would intuitively expect. You can get problems like this with arrays as well, if you create pointers to array elements via pointer arithmetic or pass around pointers to both the array and individual elements within it.
C is antiquated and inferior in many ways. However, there are still reasons to use it. * C is simple. The C standard is readable and understandable, I can't say the same about C++. Some people prefer to use chisels and hand planes instead of CNC machines. It's the difference between really understanding what you're doing and merely learning to operate a machine you don't really understand. The CNC machine is more capable, but if anything goes wrong with it then you're boned. It's no joke when I say that many C++ programmers who have been programming professionally for decades sometimes don't understand compiler error messages. * C code is understandable by mere mortals. This is an extension of the previous point, but I rarely read C code that I don't understand. Sometimes things can be written in a terse way that makes it harder to understand, but the language is never standing in the way of understanding. C++ is often wrapped in 5 layers of templates and abstractions and the actual solution to the problem is spread out all over the place. They wrote it that way for a reason, because it's more correct, type safe, efficient, etc, but it doesn't help anyone understand the code. Maybe I'm just not experienced enough in C++, but it seems like it goes out of its way to make things difficult to understand sometimes. * Legacy code is bountiful. Many projects are written in C and won't change any time soon. If you're working with these projects, then you're working with C and you don't have much choice. And it's not always legacy code. Linux is written in C. Most programming languages are written in C. Most popular libraries are written in C. If you're dealing with any or all of these things, sometimes it's easier to just use C. * Embedded and C go very well together. C is a simple tool for a simple job. While C++ and Rust don't have much runtime overhead, they still have some. C++, for example, has RTTI and exceptions which all take memory. It's also very easy to write code that balloons to ridiculous sizes in C++. To use C++ on embedded you have to restrict yourself to a small portion of the C++ language, and at that point you might as well use C. As for Rust and memory safety, memory safety can be achieved through careful coding and testing. For small-scale programs on embedded platforms, this is acceptable. Not ideal, but acceptable.
GCC or Clang would be a better choice for C. MS' support for C has been very limited in the past and it isn't a priority for them today. They just got around to implementing C99 features _a few years ago_. They were almost 2 decades late on it. If what you're doing doens't need any graphical libraries or anything, I recommend installing WSL, the Windows Subsystem for Linux. There you have access to native GCC on Linux instead of dodgy Windows ports. WSL2, when it comes out, will also fix a lot of the performance problems WSL currently has. If you need a C compiler on Windows, MingW-W64 is probably what you're looking for. It's an up to date 64-bit port of GCC for Windows. I don't know what IDE and stuff you'd use with it, though, I just use vim.
I really fail to see how offering multiple solutions to a problem is bad. I get that this means every developer has their unique approach to solving the problem which makes it difficult to read code that isn't well documented, like you mentioned, but IMO, that has more to do with C++ Devs not being experienced enough/organized enough. Think about languages like java or JavaScript(Hell Java script introduces new frameworks and syntaxes almost every year), there's a hundred ways to do stuff in these too, but the community banded together to decide on some fixed standards and best practices, and follows through in it. Even the Dev tools like IDEs follow these conventions. Even with C++, there are some fixed best practices that are designed to optimize performance and make code readable, that most serious Devs use, the problem is it doesn't have any big organization backing those conventions(like Oracle for Java for eg), so most newbies just do it however they want. Getting back to my point, having multiple solutions to a problem shouldn't be a disadvantage on any given day.
Oh yeah, you’d never use `char *` for a memory block or general-purpose buffer nowadays if you can help it. But you can’t do stuff like increment or access a `void *` (except per GNU/ish dialects), so you often need to use it at least internally and transiently, or else just use `char *`. E.g., shifting bytes: void *p = start; char x; … *(char *)p = x; p = (char *)p + 1; x = *(/*optionally*/ const char *)p; …which is a situation f’which I’d probably just go with `char *p`, or else macro/inline-function it up. The other option for the arithmetic part of things is `uintptr_t`, but that’s not guaranteed to exist. —Although IIRC POSIX requires `long` and `unsigned long` to convert round-trip to/from any pointer.
any gcc version.
you can use codeblocks on windows. tried and tested for c. comes with gcc.
pointer to string.
use pointer to string. point to base address of char array and then do what u like.
I agree with everything you said. I've witnessed it multiple times, atleast the C++ part. Which is exactly why I mentioned, that you don't necessarily have to do things the 'C++ way'. Unlike Java that has some pretty rigid restrictions in code structure and coding conventions, it doesn't have to be that way in C++. You can write C++ code that is entirely class-less/with no OOP or templating and it will just as fine. If it can run in C, it can run in C++, all the extra stuff that C++ gives you is a exactly that, extra. Try and understand my point, wouldn't it be nice if I could write the code for some embedded applications where memory safety is peak priority, and I'd write it exactly how it's expected in C, with one exception, I can use smart pointers. STD::shared_ptr&lt;&gt; or other such constructs are a boon, and almost single-handedly remove most memory leaks in your program. This is the standard philosophy of C++, you don't pay for what you don't use. If you don't want to have unreadable code under multiple templated layers, don't do it. Write simple code but make your life easier by using boost or std::vectors. The same goes for exception handling.if you're gonna have some code that you can't debug graphically and hence want to avoid stuff like polymorphism or exception handling...then don't write it. Now as for namespaces I would argue they actually make the code much more readable if anything. A namespace tells me exactly where a particular variable or function is coming from and what permissions it has. Imagine looking for the declaration/initialization of some variable for 1 full minute only to realize it's coming from some nested dependency. Then imagine having to manually figure out which nested dependency. As for the overheads that you mention. Again valid points, RTTI,as well as C++ std libraries are larger and cause more overhead but that's only during compilation. At runtime there's no overhead. Finally the legacy code part. As I mentioned, the syntax in the two languages are so similar you could completely port code over from C to C++ with one regex command (vice - versa is not true ) Besides that's not even important. C++ has high interoperability with C, even if the legacy code is written in C, I can write the patches in C++, and make use of the newer features without compromising system performance.
should be ok,as long as that memory is unused
gcc propably
due to a ton of platforms and it beeing fairly bug free
Alright, also I would probably just use notepad++ as it supports .c Edit: Do you think it would be worthwhile to set up linux on a spare laptop I have lying around? It’s not as powerful but still works fine
'a' +1 shifts a to b. But be carefull with z as it would turn into the succeeding asci char which might not be a letter
I use clang because it provides better error messages.
WSL works fine, Windows is Linux now. There's basically no reason to run Linux natively on laptops and workstations unless you need Linux to have access to hardware. WSL is so easy to set up, too, you literally just install Ubuntu from the Windows store.
&gt; Nothing would brick the machine as in, render it completely useless. With memory-mapped I/O, you could easily damage or destroy hardware by writing to the wrong address, and there are rumors of early computers that could self-destruct (by overheating) if fed the wrong sequence of instructions.
&gt; I really fail to see how offering multiple solutions to a problem is bad. I get that this means every developer has their unique approach to solving the problem which makes it difficult to read code that isn't well documented... It's not about reading code. If I use someone else's library and they decided to make use of exception handling, now I have to make use of exception handling, even if I don't want to. If they use templates, or this, or that, now suddenly I have to use that stuff as well, even if I don't want to. It gets real annoying real fast. More options does not mean better.
Ah alright, I’ll definitely look into it then thanks!
compilled c++ code has often a bigger codesize as functions get included which might not be used. And in some cases c++ compillers are unavailable. Obviously that c++ code could be compilled to c and then to the target Platform, but thats quite a hastle and might result in poorer performance when deployed.
https://en.m.wikipedia.org/wiki/Killer_poke
Desktop link: https://en.wikipedia.org/wiki/Killer_poke *** ^^/r/HelperBot_ ^^Downvote ^^to ^^remove. ^^Counter: ^^257290
Take a look at http://canonical.org/~kragen/memory-models/ https://web.archive.org/web/20151123133211/http://marek.vavrusa.com/c/memory/2015/02/20/memory/
What everybody else is saying, but be sure to check that the string is pointing to something: if (string) { if (string[0] == 'h') { /* Go wild! */ } }
&gt; C++ has almost exactly the same syntax as C, save for a few keywords. You could literally port all code with one quick regex script. No. Absolutely not. C and C++ share a common subset, but there are significant differences in semantics: `const` and pointer casts, for instance.
A really good explanation. Thank you
Alright, fair point about the OOP concepts being used in a library would force you to do the same. I'll give that to you. &gt;Compiler options are command lines and not tags inside the file themselves ... You could just use a build system like CMake if you wanted to specify it in text file tags but whatever. &gt;C++ does not address any of them. Instead it an OOP ideological circle-jerk designed by ivory-tower assholes who have never had a programming job in the real world with deadlines,16 hour workdays, etc. Jesus man, who hurt you....
I don't need c++, that's pretty much why. When I program C style in C++ it just feels like I'm doing something wrong. I'll still use C++ say if I'm working with a C++ code base or am using C++ libraries (directx). I can read C better and I can write C code better so I'll stick with it. My biggest issue with C++ is that it tries to do too much so that when I try to read C++ code I end up learning new C++ syntax (when I'd rather just figure out how the code itself works). I guess I just don't like the fact that C++ has no clear design goal and that they just add stuff they think is cool. With C I'm left with a restrictive tool set that just breeds creativity instead of making me rely on programming patterns. Edit: grammar
C doesn't have either of those IIRC. I'm talking about going from C to Cpp would mainly involving replacing printf and scanf with std::cout and std::cin lol. Obviously, going from C++ to C would be a pain in the ass. It's not about syntax anymore there's so many constructs in C++ that don't exist in C, classes, templates, namespaces.
So far, this is the only correct answer. The rest of the answers presume computers didn't exist before 2010 and everything had an OS.
&gt; The C language has many long-lived short-comings: the lack of macro support, the lack of larger integer types like uint128_t and uint256_t, the fact that fixed-width datatypes are an include file and not a part of the language itself, compiler options are command lines and not tags inside the files themselves, etc... &gt; But C++ does not address any of them. *Those* are the C shortcomings you choose? Really? There's many other, more important problems than large integer support ... and several of them C++ does improve on.
&gt; compilled c++ code has often a bigger codesize as functions get included which might not be used. That's not why C++ produces larger files. The compiler and linker should remove unused functions in C++ just as well as they do C. Templates are more problematic, as it's common in C++ to create functions that are specialized exactly for the type, which means another function needs to be instantiated for each one. Exceptions are a problem as well, as every function needs some exception handling code just in case one is thrown (even if it's actually impossible).
&gt; it should also be well-defined Yes, it "should be", in the sense that "life would be great if it were". But using pointer arithmetic to do this has undefined behaviour. The C standard only defines the result of pointer arithmetic on pointers to array elements; pointers to other objects are treated as if they were arrays of length 1. There is no well-defined way to go "off the end" of one array and end up in an element of another array. Of course, if you use a C implementation that guarantees well-defined behaviour when you do this, you're fine.
If you’re talking about access to hardware, some stuff did have protection mechanisms implemented so (e.g.) you couldn’t access certain parts of the bus if the CPU wasn’t holding its supervisor-mode line high; that would usually cause an interrupt of some sort if there’s non-supervisor access to a blocked range. Most of the really old stuff didn’t bother wasting the transistors for that kinda thing though. If you’re talking about sending addresses onto the bus that nothing is listening for, then a few things can happen depending on how the bus is engineered/implemented. On older stuff, reads would usually either get back a pattern (all-0, all-1), noise, or whatever leftover latched data (which may be from an unrelated access). If DMA is going on in the background, you could see all sorts of data-static as it shuffles things around. Writing to dead address space usually does nothing; at most you may get an IRQ, an NMI, or a machine-check fault, but that usually took more hardware than it was worth in the olden days. When scanning for RAM, the BIOS used to just write its way up the address space; if the address held a value across two NOTs, it was assumed to be RAM. Writing to dead space was how it knew there was no more RAM in that area. More generally, you were expected to be turning your computer on and off frequently, and it was probably only running one program at the time, so it was fine/-ish if everything got trashed anyway. The 80286 era was around when protection mechanisms started hitting the PC world, although the 286 segmentation sucked compared to the 80386 era’s virtual memory mechanisms, and it didn’t find much actual use outside of OS/2 and Xenix. So on x86 unprotected: - There were effectively three kinds of real-mode address, near, far, and huge. Near addresses were 16-bit and only worked within a specific segment. They were garbage when referencing any other segment, so if the compiler or programmer fucked up an ABI handoff, the program could get very lost. Far addresses were 32-bit SEGMENT:OFFSET pairs (bus address = 16×seg + offs, because fuck everything); because the segment ranges overlapped, 0:0x10 was the same as 1:0, although the pointers would look different. Huge addresses were 20-bit, computed just like bus addresses; they were unique and could work around the 64-KiB limit, but actually accessing something with them meant you had to pull apart into SEG:OFFS. All this meant that slight pointer/addressing glitches could spam all over the place with very little provocation. - The CPU had a few special addresses. 0 was the start of the interrupt vector table (later IDT), which was just an array of SEG:OFFS pairs the CPU would `PUSHF` / `CALL FAR` to when an `INT` instruction was executed. Overwriting a vector (common for far/huge `NULL` accesses) would break things the next time a syscall/interrupt/fault occurred. 0xFFFF0 was where the CPU first starts executing. The 16 bytes there were expected to contain a `JMP` instruction into the BIOS startup routine, so you could reboot the computer by `JMP`/`CALL FAR`ing that address. It was ROM, so you couldn’t overwrite it. Post-186, there was a small chunk of memory called the HMA (high memory area) outside the 8086’s 20-bit range, which you could access by using segment 0xFFFF and going beyond offset 0xF. On the 8086, the address calculation would overflow and those accesses would wrap around to zero. On the 80286+, the CPU would generate addresses outside the 0–FFFFF range in real mode, but the A20 line could be disabled (because some programs relied on the wraparound behavior, because fuck everything). If enabled, you had an extra 65520 bytes of HMA for things like TSRs. - You could write to the BIOS data area (0x400–0x5FF IIRC, usually as 40:0 and 40:1FF) and confuse the BIOS; this was a common way to do some light twiddling. The BIOS itself was in ROM or RAM-mirrored ROM, and even if it was RAM or an EEPROM, writes to ROM wouldn’t stick. The BDA held the current screen mode and cursor position, some basic detection stuff (e.g., is there an 8087? is there a CGA or MDA screen? how many serial and parallel ports? how many floppies? how much RAM?), information about whether shift/ctrl/alt were down, whether caps/scroll/num lock or insert mode was on, the FDC/HDC/serial-port/parallel-port states, and possibly a special reboot code to do things like skip initialization of RAM (0x1234). It was accessed either during a BIOS-trapped IRQ/fault handler or a BIOS `INT`/`FAR`-call/-jump, so until one of those things happened and used the relevant data nothing unusual would occur. Some BIOSes had an “extended” data area (EBDA) that had important tables or other BIOS data in them, usually at the top of RAM or in the 0xE0000–0xEFFFF range. - If you had expansion cards, these would sometimes take a chunk of high address space; usually 0xA0000–0xEFFFF, although 0xA0000–0xBFFFF was taken by the video card, 0xC0000 was usually video BIOS, and 0xC8000 was the HDD ROM if there was one. Cards would usually have a ROM onboard, and during startup the BIOS iterated through that part of the address space until it found 0xAA55 at the end of the first 512 bytes (just like a disk image), in which case it would call into the expansion BIOS to get the hardware and its part of the BIOS set up properly. They might have RAM as well. For example, 0xA0000–0xAFFFF was the color graphics-mode video framebuffer RAM, 0xB0000–0xB7FFF was the MDA/HGC text+graphics framebuffer, and 0xB8000–0xBFFFF was the color text mode framebuffer. Twiddling those areas would cause pixel(s) to change on the screen if in graphics mode, or characters and their colors to change in text mode, and you can read them (possibly with some assistance from I/O port-based registers to change bitplanes etc.) to see what’s currently on the screen. - On the x86, most hardware is controlled via I/O ports, which were basically in a separate memory space that used special instructions (`IN`, `OUT`, `INS`[`BW`], `OUTS`[`BW`]) for access, and it was only 65536 bytes wide. Ports were where most of the fun could be had. Usually `IN`s didn’t do anything especially bad, although you could break things if you pulled something out of a PIO queues/latch. Writes could reboot, fuck with the disks in all sortsa ways, click or buzz the speaker, set the DRAM refresh and timer tick rates, enable/disable NMI, mask/unmask/reroute/ACK IRQs, start/stop a DMA transfer, send/receive via serial/parallel port, peek at joystick, diddle with DAC/ADC or MIDI, look at the joystick state, look at/change the keyboard state, enable/disable turbo mode, (on ATs+:) read/write CMOS RAM and the RTC, sleep/power down the computer, park/idle/sleep the hard drives, etc. Most stuff nowadays is over MMIO, but most modern hardware still has to emulate the old shit to some degree so pre-EFI stuff can boot. The 286 added protection for ports as well as memory; IIRC the 386 added the ability to enable/disable specific ports. - The DOS kernel was usually installed low, IIRC starting somewhere from 0x600 to 0x1000. It was basically a library whose interface was `INT 21h` instead of `CALL FAR`; it mostly used BIOS features to manage disks and ports. Anything beyond that—graphics, mouse, sound, drive operations other than file or sector stuff (e.g., eject CD), CPU stuff (e.g., mode changes, feature detection/enablement)—had to be dealt with by the program itself; all of that was roll-your-own. Fucking with the DOS kernel was like fucking with the BDA; could break things at the next syscall, keypress, timer tick, or other DOS-handled event. - IIRC the usual DOS shell, COMMAND.COM, installed a “resident” portion lower in the address space and a “non-resident” portion higher; overwriting the lower portion’s code/data could break things as soon as the program exits, but overwriting the higher portion would generally not matter especially, and COMMAND.COM would just reload the high portion before attempting to do anything with it. (At least in theory.) - DOS (IIRC→) ≥2.0 supported TSRs (Terminate and Stay Resident), which were special programs that were started normally, and they would set up, free unused memory, and call a TSR-exit syscall. DOS would leave their remaining memory in place, and if they’d hooked interrupts or whatever, they’d be able to handle those events. When there was an HMA, you’d usually load these up there out of the way if you could. The mouse driver was usually a TSR that hooked INT 33h, and there were some things like CDROMs that could only be used if the TSR was loaded. Fucking with TSRs was basically the same as fucking with the kernel, although some of them did provide “public” memory areas that were safely twiddleable. Rebootable crashes could come from any of the above, but it would be very difficult to actually brick a computer in pre-flash-ROM days; you usually had to fuck up a direct write to the hard drive or something like that, and that was still fairly recoverable (though your data mightn’t be). You could glitch things by setting the DRAM refresh rate too low, but a reboot fixed that. You could sometimes fuck with monitors by setting the CRTC registers wrong; some of them would clickclickclickclick or whistle or bounce-and-roll, and you could set the MDA or HGC horizontal+vertical total to 1 to focus the CRT’s electron beam on a single pixel to burn it out after a bit. Lore tells of someone doing that to the top center pixel and setting some papers on top of the monitor aflame, but that’s apocryphal. Newer BIOSes often have the ability to set CPU &amp; DRAM frequencies and voltages, so they can potentially (ha) fuck up the hardware more easily. All ROM is now flash ROM so a broken firmware update can brick individual devices or the computer as a whole. Most potentially-physically-harmful stuff is only accessible from SMM or a mobo-manager microcontroller.
&gt; Those are the C shortcomings you choose? I'm at work, I didn't make an exhaustive list for ya :p
I like using Pelles C, it's tiny, free, and has many features you would want in a Windows C compiler. I also use Cygwin &amp; GCC, but it is a bit more complicated to install and get set up if you're new to programming. Microsoft Visual Studio also has a C compiler, and I **think** it might be free? Or have a free version. But it is HUGE HUGE HUGE and runs slow, so I do not use it very frequently. I do use it to do CUDA programming from time to time though.
Wow thanks for the very detailed response
&gt; C doesn't have either of those IIRC. Are you for real?
I remember those Suns. NeXTs had the same thing. Then you had [OpenFirmware](https://www.wikipedia.org/wiki/Open_Firmware) mostly on Sun and Apple until pretty recently. You could write drivers for bootable devices in forth... it then morphed into [UEFI](https://www.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface) that boots most machines and is in fact a complete operating system that continues to run when your real OS is booted... and, while talking about the “operating system in ROM”, let’s not forget that [all modern *CPUs* run minix internally](https://www.zdnet.com/article/minix-intels-hidden-in-chip-operating-system/)... so you have a rom based Unix kernel running AND the UEFI OS AND whatever OS you actually use...
You never set `is_input_ready` back to false when you "consume" it so it constantly thinks there's input after the first input.
Yes, many I/O adresses were triggered on access, so read was enough to do whatever it mean (hence my example using a read on 0xc000 to trigger the speaker). I think to remember that if you *wrote*, it accessed the address twice, so you have to be careful. Never heard of erasing a track with a double read, but it could completely be possible (ie: passing the drive in write mode while to motor was running would probably write a constant value around the track, due to the cleverness of the [WoZ machine](https://www.wikipedia.org/wiki/Integrated_Woz_Machine)).
That ... actually makes alot of sense. Yeah that pretty much answers my question.
It depends on the machine, and on it's current operating mode. For a lot of IBM-compatible machines (Intel x86), reading from a non-existent memory address would still work, and still provide a number (usually 0 or -1). Memtest86(+) has a guide or FAQ somewhere I read a long long time ago explaining the difficulties of testing the memory on all types of systems since the behavior is neither consistent or standardized anywhere. IIRC they have to write a specific value to memory with the cache's turned off, and read it back to see if that memory page actually exists.
I was referring to the const_cast&lt;&gt; and static_cast&lt;&gt; syntax of C++,and I thought those didn't exist in C, considering they're templated. Am I wrong?
I am referring to the fact that the semantics of `const` and of pointer casts are different in C and C++. You can absolutely *not* transform an arbitrary non-trivial C program to valid C++ with only regular expressions.
gcc
The language spec promises certain things about alignment of elements in structs (I don’t have it handy to know the exact rules), so manually offsetting into a struct or between struct elements is not UB in the language sense if you follow those rules. (You could also compute offsets between struct elements with `offsetof`.) However, in practice you really only want to do that with a compiler that you know does what you want, and as the other commenter mentioned you can write static asserts involving `offsetof` to make sure things are aligned the way you think they are.
i didn't post the code ,because for every switch case it happens
yep understand
Ideally, I would like to give it inputs and outputs only. No formulas, because I want it to be able to solve sequences that I can't. So, I need to know all the steps our brains would follow. For this project, step 1 was calculating the 1st and 2nd differences between the inputs. But, I then tested those differences against known rules. I want to solve rules that I don't know, so I need to figure out how a math student goes through a sequence and writes the rule as the answer to a question on a test.
Ok, noted. Def possible but not common. Early monitors had zero refresh rate or overscan protections.
yep, you just have to want it enough :)
I bound split commands in tmux and vim to be the same but with different leaders. Makes it easier to remember. vertical ctrl-a | ctrl-w | horizontal ctrl-a - ctrl-w -
&gt; so manually offsetting into a struct or between struct elements is not UB in the language sense if you follow those rules My reading of the language standard is that it yields undefined behaviour. The issue is related "pointer provenance". It is specifically discussed [here](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2263.htm#q86.-are-provenance-checks-only-on-a-per-allocation-granularity-not-per-subobject). The reason I think the standard says the behaviour is undefined is contained within the description of the `+` and `-` binary operators. In 6.5.6/7: &gt; For the purposes of these operators, a pointer to an object that is not an element of an array behaves the same as a pointer to the first element of an array of length one with the type of the object as its element type. That means if you have an object of structure type: struct pseudoarray __attribute__((__packed__)) { int a, b; } o; pointer arithmetic behaves similarly as if it had been defined: struct pseudoarray __attribute__((__packed__)) { int a[1], b[1]; } o; So far so good. The question is "can you take a pointer to `o.a`, do some arithmetic on it, and write to `b`?" I assert that this is _not_ well-defined by the standard. The reason is in 6.5.6/8: &gt; When an expression that has integer type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the pointer operand points to an element of an array object, and the array is large enough, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and original array elements equals the integer expression. [...] If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined. **If the result points one past the last element of the array object, it shall not be used as the operand of a unary `*` operator that is evaluated.** The only way to get to `b` from `a` would be to use unary `*` operator (or, as discussed earlier, an array subscription operator). The pointer you have is derived the array `a`, and this pointer would be the "one past the last element" of that array. You hit the "shall not be used" clause in this paragraph.
I consider it a M-x tetris player :)
We don't know the problem in your code if we don't know what your code is in first place.
Instead of doing whole stuff in C++, I'd rather combine C (library) with C# (interface). Because C provides the more sane ABI, C# provides the more sane OOP.
&gt;Microsoft Visual Studio also has a C compiler, and I think it might be free? Or have a free version. Yes, the C compiler is cl.exe and it can be run from within a developer command prompt. The only prerequisite is installing the MSVC toolset, and activating developer mode in Windows.
`scanf` doesn't consume the following newline. TO deal with this you could call `getchar()` in a loop until the result is either `EOF` or `'\n'`.
I just told you ;) We write down a template and then solve for the unknowns. The problem os picking out the right one. My suggested input was training data. Of course when you actually use the program you’d only enter am array of numbers.
 char buf[100]; printf("Enter a 6 digit account number: "); fgets(buf, 100, stdin); if (strlen(buf) != 6) // Error for (int i = 0; i &lt; strlen(buf); i++) { if (!isdigit(buf[I])) // Error } int account = atoi(buf);
But, I want it to solve for templates and formulae that I don't know. I want it to figure those out on its own.
Good point. Thanks I tend to forget it
Oh I see. Well that approach does seem a lot harder, but also more versatile
It's like asking how Isaac Newton invented calculus. I have no idea. But, that's the goal, albeit with sequences instead.
If you're looking for a book, as opposed to the standard itself, then take a look at C: A Reference Manual by Harbison and Steele, but sadly it hasn't been updated for C11 yet.
Incredible post thanks for sharing
Mostly looking for books that could improve my C and low-level programming skills I proposed the idea of a canon so it’d be more a list of books to work through, as opposed to one single book
OK, then two more books for you: C Traps and Pitfalls and Deep C Secrets.
Don't know if i'd necessarily call it 'canon', but how about "[The Practice of Programming](https://en.wikipedia.org/wiki/The_Practice_of_Programming)", by Kernighan and Pike?
C is one of the simplest languages. The only difficult thing to understand is pointers, because of their confusing syntax and unclear purpose. The rest is just a handful of operations, a small set of rules you have to remember and that's all. C++ - **in my opinion** - started as simple and clean objective superset to C, but was eventually turned into a feature-creep bloatware mess. For compiled OOP I prefer Go language because it's a "C on steroids" - simple, improved, modern and clean. The only thing I am not too fond of in Go is garbage collector. There's nothing catastrophically wrong with it, I just don't like garbage collectors in general.
and you can do a&lt;=b rather than a&lt;b+1 That is way cleaner
maybee look at other peoples c code(without a ton of inline asm) and when you dont understand something google that. Or look at c operators on Wikipedia.
If the VCS was in C, it might be mentioned in [this list of version control systems](https://en.wikipedia.org/wiki/Comparison_of_version-control_software#Technical_information) (which can be sorted by language).
[CVS](http://www.openbsd.org/opencvs/)
A book I C^(lol) recommended a lot recently is Modern C. I've been meaning to read it for a whole, but I'm seen a number of glowing reviews. I think any book which claims to show a modern approach to C is making a fairly bold claim (i'm not a c veteran though so take this with a pinch of salt) so the fact it has such good reviews says a lot I reckon. &amp;#x200B; Deep C Secrets gets recommended a lot. It's both funyn and informative. Sort of "cringey-funny-but-you-know-it's-supposed-to-be" sort of funny. There's also a few things in there I didn't know before; I could be wrong, but I think that's the first place I found out about initialisation using {0}.
No. It was a completely a black site.
Sorry I forgot to mention, that was the first place I looked. I did not find the site I was looking for.
Choose a value that will never occur for measured parameter, for example -1 or 9999. When you encounter a missing data, instantiate the structure with this value to mark it as "measurement unsuccessful".
I always liked "ANSI C" from K&amp;R (the creators of C language). It is slightly outdated, but excellent book for learning C. No fluff, just concrete information with examples and exercises. It is also very short. You can consume everything in a single, long evening... maybe except some optional appendices.
If there isn't a value that you can fill in to signify invalidity (maybe 0, -1, INT_MIN, HUGE_VAL, NULL), you can have a separate field for whether something was successfully measured. For example: #include &lt;stdbool.h&gt; struct measurement { bool valid_temperature; double temperature; bool valid_air_pressure; double air_pressure; }; If you don't want to use bool, look up [bitfields](https://en.wikipedia.org/wiki/Bit_field#C_programming_language).
&gt; Which is exactly why I mentioned, that you don't necessarily have to do things the 'C++ way'. If you program for yourself as a lone wolf, there is no problem with this. But once other programmers enter the picture, it is very hard to avoid having to deal with parts of your program “doing it the C++ way.”
just the 1st 1 has all ya need
the question is how will u process the recordings...
so u don't have c++ features to lean on
Git is written in C, but I doubt it's the one you're struggling to remember.
OP already mentioned it. It's called *The C Programming Language*. And Kernighan had nothing to do with the creation of C.
Again, another ungrateful deletes their post after getting the answer.
Working my way through Modern Approach currently. It’s really quite good. They teach to C99 (second edition was only 2008!) so, not entirely modern. I preferred it to the K&amp;R which, while important, is not something for complete beginners. I will pick back up K&amp;R once I’m through with Modern Approach.
Yup. It was an all black page, had a terminal like feel.
one pattern I often use (especially with menu's) is to point a group of callbacks at the same callback and decide what to do based on the widget, this mean I end up having initializer functions for each callback source that takes a gtkBuilder instance, that way the globals I do have are encapsulated by the source for the sub window they are for... using this method I've not actually needed to send any structs to a callback as yet and they are all defined within glade. Its a shame you can't seem to define any custom data in glades callback userdata selector (as far a I can see?) it seems to really limit it, some kind of non visual "widget" that could contain different values would be great for this....
just a thought, you could abuse a liststore for this with a single row and bunch of columns for each data type, but accessing a list store is a little long winded.... within glade you can select a liststore as userdata....
Funny story about the interrupt vectors. Memory address 0 was usually the high byte of the interrupt vector 0 and on a standard x86 machine that first entry was the divide by zero interrupt. The value at that location was always 0 because that handler was in low memory space. I worked on a large code base written in C that had many uses of **strcpy** that did not check if the source pointer was null (value 0). Because **strcpy** stops on the first '0' byte, if the source pointer was null, that meant it was pointing at memory address 0, which was value '0' of the address in the interrupt vector table so **strcpy** would simply terminate with no errors. I was involved in porting that code off the real-mode x86 operating system (DOS, early Windows) over to an OS/2 machine that used protected mode. In real mode the OS did not prevent you from accessing restricted memory locations as /u/nerd4code mentions, you could basically set a pointer anywhere in memory and read/write it. But protected mode did stop your applications. So after compiling for OS/2 and running the code it would regularly fail with access violation errors caused by these **strcpy** calls (and some other bad ones as well) and we had to go clean all that code up. Took a while but we could never be sure we covered all such conditions.
1. Conceptually, main is the entry point, so it doesn't return anywhere. When main returns, the program ends, and the exit status of the process is set according to that return value. In practice, however, C compilers usually generate some extra code that calls main and, when main returns, performs the required cleanup (for instance, calling functions registered with atexit), so that's where main returns. 2. Use int main(void) if you are not going to read command-line parameters, and int main(int argc, char \*argv\[\]) if you are. Don't use void main(). 3. To provide an entry point for the program, a place to put the code that should run when the program starts. In some languages, like Python, you can use most statements outside a function, so you don't need a main() function. However, you can't do that in C.
Not sure why Clion doesn't have a free edition. But I get it free for being an open source project. &amp;#x200B; [https://www.jetbrains.com/clion/buy/#edition=discounts](https://www.jetbrains.com/clion/buy/#edition=discounts)
thnx
Fantastic link, totally missed this, thank you.
Do it a modern way, use JSON serialization :D Writting GTK applications using precepts of The Art of UNIX Programming. Hmmmmm... Let's think about it !
Nice!
Oh, you are right. I must have missed it. Sorry.
Anybody who uses a malloc on 4/8 bytes is an asshole.
This is possible.
I agree, this does seem possible.
//if i put "c" as input , program crash &amp;#x200B; \#include &lt;stdio.h&gt; int main() { int num; scanf("%d",&amp;num); switch(num) { case 1: printf("Case1: Value is: %d", num); break; case 2: printf("Case1: Value is: %d", num); break; case 3: printf("Case1: Value is: %d", num); break; default: printf("Default: Value is: %d", num); } return 0; }
Note that `main` does return somewhere. The C runtime function `main` returns to looks like this on Unix: exit(main(argc, argv, envp));
CLION provides free license for studends and teacher..
I've read a similar solution, and you are right that it would be a bit tedious. I wonder why Glade doesn't allow for non-widget data to be passed as user data.
Apparently this is... complicated? I guess it depends on whether you read the spec as saying one instance of a struct is an "object" or not, as opposed to each element of the struct being an "object" that you cannot index out of. https://deathandthepenguinblog.wordpress.com/2016/01/19/apparently-this-is-legal/ https://www.reddit.com/r/cpp/comments/42cbd2/i_think_pointer_arithmetic_on_struct_members_is/ http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2222.htm#q34-can-one-move-among-the-members-of-a-struct-using-representation-pointer-arithmetic-and-casts sez: &gt;The standard is ambiguous on the interaction between the allowable pointer arithmetic (on unsigned char* representation pointers) and subobjects. Many programs and libraries rely on being able to construct pointers to struct or union elements via `offsetof` (by, in my example, doing something like `(int *)(((char *)(&amp;my_var)) + offsetof(struct sort_of_an_array, val3))`). Although I could imagine implementations where that might not work without explicitly casting to `(char *)` in between, if e.g. pointers were tagged in some way based on the type of thing they point at. But given that you ARE allowed to use `(char *)` pointers to treat an object as an array of bytes, it seems like `(((char *)(&amp;my_var)) + offsetof(struct sort_of_an_array, val3))` and `(char *)(&amp;my_var.val3)` have to be indistinguishable... right? And then casting either of those to `(int *)` should generate pointers that are the same? The spec says: &gt;A pointer to an object type may be converted to a pointer to a different object type. If the resulting pointer is not correctly aligned for the referenced type, the behavior is undefined. Otherwise, when converted back again, the result shall compare equal to the original pointer. I guess it sort of depends whether "the struct" and "a member of that struct" are considered distinct "objects". They share storage, so it's hard to imagine a practical implementation where those pointers wouldn't be indistinguishable, but then https://kristerw.blogspot.com/2016/03/c-pointers-are-not-hardware-pointers.html says that gcc sometimes optimizes away pointer compares if it "knows" the pointers are not part of the same object, so possibly an implementation could decide they are not actually the same pointer?
I know I'm living 15 years in the past with this stuff. This is probably the last C program I'll ever write. I'm afraid the only thing I know about JSON is what it's an abbreviation for.
Nooooo, don't betray C...
I like *The Standard C Library* by P. J. Plauger. Each chapter covers a standard C header, and he presents not only the C standard, but goes into the history of the functions and why they are the way they are, and he presents an implementation of said functions to show how they might be implemented. On the down side, it only covers C89, but I still refer to it from time to time (mostly to figure out why something is the way it is).
Have you checked your browser's history?
😃 So sweet of you. Elementary. I totally forgot about that. Yes, found it. Its [cgit](https://git.zx2c4.com/cgit/). My memory was wrong, only the homepage is black, rest is all white. And its not a VCS, just a web-based GUI for Git.
[cgit](https://git.zx2c4.com/cgit/about/), a web based GUI for Git.
Is this the entirety of the code and are you sure you're running the right program on your computer? You said in title that your code infinitely loops, but now you're saying it's crashing, so which is it? Also, you have not checked the return value of scanf.
scanf is trouble. Use fgets to get an input line. Then strtoul, it gives the number and you can verify that the endpointer is line + 6 and contains only "\\n".
What exactly are you expecting your code to do? Do you not want "please enter numbers.." for the string "33e3e"? If so, it seems like your braces are misaligned and your indentation is misleading. This is basically what you have right now with corrected spacing: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char buff[100]; char trash[100]; int accountno; int vall = 1; while (vall == 1) { printf("Enter your six digit account number: \n"); scanf("%s", &amp;buff); fflush(stdin); if (strlen(buff) != 6) { printf("Not 6 digits"); fgets(trash, 100, stdin); } else { accountno = atoi(buff); } if (accountno == 0) { printf("Please enter numbers not letters\n"); } else { vall = 0; } } }
It must be done.
Additionally, according to atoi's manpage, the function returns 0 when *no* character can be processed. So it could return a nonzero value on the input "33e3e3". atoi basically does no errorchecking, so please don't use it as an errorchecking method. Also your program is susceptible to a buffer overflow attack, since your buffer is 100 characters, but a user could easily overflow that buffer.
1. The return value from `main()` is passed to whatever other program started your program. Usually this is passed to BASH, where it's stored as the shell variable `$?`. Typically, this is used for an error code - 0 is normal operation, with other values to indicate errors. 2. Last I checked, `void main()`, while it might work, is always improper. Always use `int main()`. 3. `int main()` provides a function (since C only allows code inside of functions), which is the first function the program runs when opened (what is sometimes called an 'entry point').
https://www.youtube.com/watch?v=zAYyj3mPVD4
Use functions instead of objects.
Read ‘Object Oriented Programming with ANSI C’ by Axel Schreiner. Often you can just make functions that take your ‘object’ (struct) by reference as its first parameter. When you can’t (e.g. polymorphism) you need Axel.
As part of your error checking, you could iterate over the string and make sure that it only contains digit characters.
Well many of these solutions use `getchar`, which read from `stdin`. So you could copy and paste your C source into the terminal, or you could (if you have a unix like enviornment) cat `source.c` | ./remove_comments To redirect the contents into `source.c`. Otherwise, you can look at `FILE*`, opening your desired file and reading it byte by byte. Its not that hard ;) Also notice one solution says they use `getline` which is also defined in K&amp;R. Good luck!
Because maths. (x-y) = -(y-x)
C'est la vie.
A use-after-free doesn't automatically cause your program to crash. In fact, your program may even still exit with the correct output. That's part of what makes those so tricky to debug without something like ASAN or Valgrind. So it's likely this program still exhibited use-after-free but it just happened to go undetected (e.g. not crashing).
heres an idea. You can store the 3 values in an array using the modulo operator, then compute the codon and reset the array, to fill it again. void make_codons( char* sequence, int length ) { if ( length % 3 != 0 ) { //error return; } //count how many nucleotides of 3 you have found and what index to put it in //the first goes in 0, then 1, then 2. //Then we are done, so compute the result and reset the counter. int nucleotides_found = 0; int set_of_three[ 3 ] = { 0, 0, 0 }; for ( int i = 0; i &lt; length; i++ ) { switch( sequence[ i ] ) { case 'A': case 'a': set_of_three[ nucleotides_found ] = 0; break; case 'C': case 'c': set_of_three[ nucleotides_found ] = 1; break; case 'T': case 't': set_of_three[ nucleotides_found ] = 2; break; case 'G': case 'g': set_of_three[ nucleotides_found ] = 3; break; default: //invalid char found, error return; } nucleotides_found++; if ( nucleotides_found == 3 ) { //calculate using the array } } }
What have you done so far? Usually when I don't have a good idea of how to start a program, I will start by writing basic code that accepts the input and prints it out. Once you have that you know that you are reading the input correctly and that you are able to access the input in a useful way. Then start writing your main logic one step at a time testing at each step. The important thing is to write and test small amounts of code at a time. It is much easier to debug 5-20 lines of code then it is to test 100 lines.
It also showed a stack buffer overflow and a heap buffer overflow depending on the web request. I expected THOSE to cause a crash. It’s a C web server and when running it in GDB there is no crash. It’s definitely a pain.
You can use OO paradigms in C. Just realize that instead of objects you have structs, and instead of methods you have functions. Things can get messy if you need some kind of runtime reflection or dynamic dispatch, but it is definitely doable with union types and function pointer tables.
I don't know enough about how ASAN works, but certainly it changes the program's stack usage. I could see it causing a stack overflow that wouldn't have otherwise happened. That doesn't necessarily mean it's ASAN's fault, though, since the program itself would already be cutting it close.
Undefined behavior ≠ automatic crash.
There are plenty of reasons why a legitimate bug such as a buffer overflow might go unnoticed. For instance, consider this code: char buf[5]; int i = 3; strcpy(buf, "hello"); printf("%s %d\n", buf, i); There is a buffer overflow here, since the buffer is only five characters long while the string written to it is six characters long including the terminating zero. However, you will probably never notice, because (assuming a mainstream 32-bit CPU and no optimization) the compiler will insert three bytes of padding between `buf` and `i` to ensure that `i` is aligned on a four-byte boundary. An address sanitizer will still warn you about the bug, and possibly set things up to force the program to crash when that code is executed. Larger stack buffer overflows are nasty because the stack grows down, so there is almost always something important shortly after the buffer. Heap buffer overflows, on the other hand, can go completely unnoticed because it is entirely possible, and even quite common, for the memory that follows the buffer to be unused. The important lesson is this: just because you don't notice a bug doesn't mean it's not there. Some bugs are truly benign (e.g. a single-byte buffer overflow, which is quite common when dealing with strings in C), some have symptoms that are easy to miss, and some have no effect at all except under very specific circumstances that don't arise during testing. That's the whole point of sanitizers — to warn you about bugs you might otherwise not notice.
So far i've only written the loop that iterates over what has been entered by the user the issue im having isnt so much coding it its the logic of how it happens if that makes sense while (ch = getchar() != EOF) i wrote this loop to check over it and im guessing just an IF statement to check the character and store it in an array? and once the array is filled i can do the math that follows?
I'm having trouble setuping the gcc flag `-fsanitize=address -fno-omit-frame-pointer` on the Windows subsystem for linux. Anybody made it work?
An array would be a good choice to store the nucletoide sequence. Input validation is also a good idea. Finally, if your are using reading from the terminal, the user will have to enter ctrl-d to send your program a EOF. Using `(c = getchar()) != '\n'` will give you better results. &gt; while (ch = getchar() != EOF) i wrote this loop to check over it and im guessing just an IF statement to check the character and store it in an array? A `switch` statement is probably a better choice. &gt; once the array is filled i can do the math that follows? Yes. Once you have the entire sequence, you would loop over your array and do the calculations. A good way to think about a program is the [input-processing-output model](https://en.wikipedia.org/wiki/IPO_model).
**IPO model** The input–process–output (IPO) model, or input-process-output pattern, is a widely used approach in systems analysis and software engineering for describing the structure of an information processing program or other process. Many introductory programming and systems analysis texts introduce this as the most basic structure for describing a process. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Kinda important, but buried pretty deep: "This implementation does, however, impose a slight restriction to the code that uses protothreads in that the code cannot use switch() statements itself. "
You haven't shown all the code. My guess is that your nodes are holding pointers to the local strings in main - so they're all pointing at the same data
I agree with him. I appreciate all the work that went into valgrind, but it was of limited utility. Basically "I know there's some memory that's leaking. Where was it allocated from?" and not much more than that. Now that sanitizers are here and can do so much more with so much more precision, valgrind feels obsolete. I don't think I've used it in years.
I just did add the whole code! Hope it helps! I think what you explain is right! new node and head always have same address.. if it is the problem??
Determine exactly what this line does: studentDetail = *createNode(studentID, firstname, lastname);
This is usually done via "opaque structures" - the header file contains only a declaration of a structure but not a definition. All methods operate on a pointer to the object structure, rather than the object itself. This "hides" the details of what is inside the Object within another. I think inheritance is usually done by composition instead. Object.h: // Opaque structure struct object_t; // Functions for working with the object // Note that these only take a pointer, so the user does not know // implementation details. // You can use a typedef to hide the pointer type if you like. struct object_t* create_object(); void set_object_content(struct object_t* object, int value); int get_object_content(struct object_t* object); void free_object(struct object_t* object); Object.c: #include "Object.h" // Actual definition of object structure here struct object_t { int value; }; // Functions for working with the object struct object_t* create_object() { struct object_t* object = malloc(sizeof(struct object_t)); object-&gt;value = 0; return object; } void set_object_content(struct object_t* object, int value) { object-&gt;value = value; } int get_object_content(struct object_t* object) { return object-&gt;value; } void free_object(struct object_t* object) { free(object); } main.c #include "Object.h" int main(int argc, char* argv[]) { struct object_t* object = create_object(); set_object_content(object, 5); printf("Object contains value: %d\n", get_object_content(object)); free_object(object); }
Did it crash because the sanitizer \_forced\_ a crash at that point? With ud2 opcode, for example.
That’s what it seems like.
You could do fgets(str + strlen(str), sizeof (str) - strlen(str), fp). Also, check out fseek, ftell, rewind and fread.
Oh how stupid I am? You meant other c files? 😅 cause I felt like posting that long ass code would be annoying many people so I only added that part.. I guess i have to fix it myself anyhow 😊
You are using "File GET String", in terms of C, string is a \0 terminated sequence of bytes, so you want to read all content don't use functions with \0 delimiter
Structures were objects long before OOP.
That's not true, this entry point defined by standard library implementation, but you can disable it, for example in gcc gcc -nostdlib pure.c In this case you have to specify entry point, by default complire will look for _start defined object
Yes. Generally when you pass a configuration/input file to a program in C, you load it in memory first. This is done using `fread`. /* Get its size */ fseek(input_file, 0, SEEK_END); input_file_size = ftell(input_file); rewind(input_file); /* Allocate memory for the code */ if ((code_buffer = malloc(input_file_size)) == NULL) { args_free(&amp;args); fclose(input_file); fprintf(stderr, "Memory allocation error (%s:%d)\n", __FILE__, __LINE__); return (EXIT_FAILURE); } /* Load the code to the buffer */ if (fread(code_buffer, sizeof(uint8_t), input_file_size, input_file) != input_file_size) { args_free(&amp;args); fclose(input_file); free(code_buffer); fprintf(stderr, "Memory allocation error (%s:%d)\n", __FILE__, __LINE__); return (EXIT_FAILURE); }
Your method is wrong. `sizeof(str)` is a constant, unless your string is not dynamically allocated (which it should be)
This doesn't actually run anything in parallel/concurrently. But it does provide a sort framework for doing co-routines / multiplexing for your code.
Imagine if we have 4 childs and 2 of them got terminated, but we don't know that. So, we repeat waitpid 4 times. What would happen if we do that? What would waitpid return when there is no more, terminated child?
Start by writing down in detail, in English, how you would do it by hand.
What is not true, exactly? main is defined in the standard as "the function called at program startup" in a hosted environment. With "-nostdlib", you get a freestanding environment, where the entry point is defined by the implementation.
Your code is C++, not C. Please try asking in /r/cpp_questions instead (and be sure to properly format your code for Reddit by inserting four spaces at the beginning of each line).
If you really need objects for method calls, and it's just one or a few, you can put a pointer to the method in the struct. If there are many, you can create one array of function pointers for the class, and put a pointer to this array in a field of the struct.
&gt; I am currently using a windows 10 laptop https://nuwen.net/mingw.html
This feels so wrong. But yeah, I'm taking a read on that.
This actually seems to be a broader solution. Specially the idea of having a strut within a strut. I might be able to make do without objects with this.
I'm sorry I'm not that knowledgeable in C than in Java, so having a strut that can't have an interface, or be extended, or even have its internal methods don't seem like the object from OOP.
Yeah! I'm not sure if this works 100%, but I can have a strut called circle, which when calling a function drawCircle returns a strut of points that can be passed forward to another function that would draw it. But I'm so used to OOP that having a Drawable interface of something seems to be the easiest solution.
That seems complicated! I think I can make do without. Could you expand on the last line tho? &gt;A method call would be a bit convoluted, though you might use a bit of macro trickery for syntactic sugar. I've heard of macro trickery but I know little about it.
It can be used in (mostly) the same way. You can have almost all of the concepts you just mentioned using structures, they're just not features of the language. As someone said in an earlier comment, read about OOP in C if you want the exact answers. If you're still concerned about interfaces, there are plenty of books of designing them in C as well.
To tag on a smaller point: C++ being a larger language means it's harder to write compilers for it. While most people aren't having to go through and make their own compilers for every platform, it's still something to keep in mind when it does happen. It makes C much more portable in comparison.
&gt; that having a Drawable interface of something seems to be the easiest solution. You can do it (but should you?). Some example code (my C is a bit rusty, so this is not guaranteed to be free of undefined behavior): #include &lt;stdio.h&gt; /* Drawable */ struct drawable; typedef void (*drawFunction)(struct drawable*); struct drawable { drawFunction draw; }; void draw(struct drawable* dr) { dr-&gt;draw(dr); } /* Circle */ struct circle { drawFunction draw; int radius; }; drawFunction drawCircle(struct circle* cr) { printf("This is a circle. Its radius is %d pixels\n.", cr-&gt;radius); } void initCircle(struct circle* cr, int radius) { cr-&gt;draw = drawCircle; cr-&gt;radius = radius; } /* Rectangle */ struct rectangle { drawFunction draw; int width; int height; }; drawFunction drawRectangle(struct rectangle* rt) { printf("This is a rectangle. It is %d by %d pixels.\n", rt-&gt;width, rt-&gt;height); } void initRectangle(struct rectangle* rt, int width, int height) { rt-&gt;draw = drawRectangle; rt-&gt;width = width; rt-&gt;height = height; } /* Main */ int main() { struct circle c; initCircle(&amp;c, 5); draw(&amp;c); struct rectangle r; initRectangle(&amp;r, 10, 15); draw(&amp;r); return 0; }
True. My assumption was that the file would have a reasonable size limit.
Please do not delete your post after receiving an answer. Do not erase the work others did for you.
Nothing wrong about it.
&gt; but should you? I guess this is the central question. Since I'm used to the paradigm of oriented objects it's customary for me to depend on pattern related to that. I'm not sure if I like the pointer-&gt;function thing. It just feels like something that's gonna be harder to debug.
Honest question, to me it seems like you are to emulate the fratures of an object-oriented programming language, so why not use one ? Like C++
It shouldn't That's literally how every programming language which supports objects does it. The only difference is, they try to hide it from you.
Is there no way to run my program against another program then? Like, run removecomments.exe against removecomments.c, for example? I saw for linux users they have ./removecomments.exe &gt; removecomments.c, is there something similar in Windows?
Don't want to override but are objects the best solution in these kind of cases? Is there a functional way to do graphics and game programming?
What error message do you get?
Doesn't valgrind tell you where the memory was allocated?
I don't know. The restriction on using C comes from my professor
If at all possible, I think you should avoid runtime reflection. C is data-oriented by design. Certainly you can still keep to OOP principles, but C lends itself more naturally to things that are "closer to the metal;" for example: composition rather than inheritance, and objects rather than classes. Unlike languages like Python or Java, you can't hide complexity behind abstractions. You have to specify to the computer exactly the data format and the corresponding instructions to produce a desired behavior.
AFAIK Windows CMD is somewhat similar to Linux/(ba)sh in that case. `./removecomments.exe &gt; removecomments.c` redirects the output of `./removecomments.exe` to `removecomments.c`. The `|` thing should also work, if you replace `cat` with `type`. (actually untested)
it looks like there's a typo in array in your printf. it says arra\[i]
Without the source code, there's not much we can tell from that screenshot.
Upload the code, how else are we supposed to know? Maybe it’s just shitty code.
It's worse than that. Consider something like: int x1,wow,x2; int fun(int *p) { int *q = 1+&amp;wow; x1 = 1; x2 = 1; if (p == q) *p = 2; return x1+x2; } If the compiler were to arrange things so that neither `x1` nor `x2` immediately follows `wow` in storage, then the write to `*p` could not legitimately affect `x1` or `x2`. In the language processed by clang and gcc, though, the equality comparison between `p` and `q` will cause the compiler to assume that because the expression `*q` can't legitimately be used to access `x1` nor `x2`, the expression `*p` can't either.
It always help to post the actual code here, just put it on Github Gist or Pastebin and include the link here.
oh for some reason when i copy over from visual studio it seems to add random dashes in all over the place that is not actually in the code
That has something to do with reddit's editor. Very annoying.
I'm amazed at the persistence of the myth that a store to $C030 clicks the speaker twice. When BASIC does a `PEEK` or `POKE`, it uses the `(zp),y` addressing mode. When using that addressing mode, the processor will read two bytes (I'll call them L and H) from zp and zp+1, and then access H:(L+Y). If (L+Y) exceeds 255, it will then access (H+1):(L+Y). When reading using that mode, the processor will use the result of the first read if L+Y was 255 or less (and skip the second). If it was 256 or greater, it will ignore the first read and do the second. Since the CPU can't undo a write of an incorrect address, however, stores using indexed addressing modes will do a read from the maybe-right-maybe-wrong address before doing a write of either H:(L+Y) or (H+1):(L+Y) as appropriate. Essential things to note: 1. Stores using certain addressing modes will do a read and a write, but stores using other addressing modes won't, and 2. Two accesses a microsecond apart will cause the speaker flip flop to switch for one microsecond, which won't produce *any* click. Thus, while there's a grain of truth to the myth, it has never been true as stated.
how are you entering EOF?
Here you go while ((ch = getchar()) != EOF) Without that second set of parentheses, it gets parsed like this: while (ch = (getchar() != EOF))
I'm not actually sure what you mean sorry
The biggest problem is here: while (ch = getchar() != EOF) There's two operators here: `=` and `!=`, and when that happens you need to know the operator precedence (aka "order of operations). In this case, `!=` has a higher precedence than `=`, so it's as if you wrote: while ( ch = (getchar() != EOF) ) It's unfortunate, but this is legal C code, so your code compiles fine. But it doesn't do what you want. Move the parentheses to change that. There are a few other problems, though. You're advancing the counter regardless of whether it matches those characters, so you're leaving whatever happens to be in the array at that slot. The information there is very likely garbage. Either fill it with something meaningful (a space, perhaps?), or don't advance the counter. There's a similar problem if you don't use the whole array. The counter will provide the used length, instead of using the array size. But a lot of this depends on what you're going to do with the data after you read it, so that's up to you.
Personal preference.
Maybe it's just my lack of anatomy knowledge, but those function/variable names makes me think this belongs in r/programminghorror
I made your change and its still printing out nothing
Post the build commands, or the Makefile if you've got one, as well as the specific errors the compiler is giving you.
I can't download the code from the page you linked to, but from what you pasted, the issue isn't syntax, the issue is there are missing definitions for various crap. Are you building all the files that need to be linked together?
Cool, thanks, I'll give it a shot. I know from trying that ./whatever just comes back with an error saying ". is not a supported...". I'll keep playing around and see. Thanks!
One is an IDE, one is a programming language.
Nah, that looks pretty typical for code produced by mathematicians or scientists. Not that that excludes it from r/programminghorror \- some of the ugliest C code I've seen was written by a pioneering computer scientist.
Because what the other commenters have mentioned is also important. Specifically, how are you inputting the EOF character - there probably isn't a key labeled "EOF" on your keyboard. &amp;#x200B; If you're running a Unix machine, you can send EOF with ctrl-d. If you're using windows, it's ctrl-z. &amp;#x200B; also, please read what [boredcircuits](https://www.reddit.com/user/boredcircuits/) mentioned about incrementing the counter
On Windows CMD don't include the `./` thing (except in PowerShell).
`Type error`
ohhh i understand now what he meant about asking what im using to send EOF thank you very much i also changed the counter to only increment if the IF statement happens because im looking to ignore any characters that arnt those 4
Thank you very much i changed the counter so it only increments after the IF statement is executed
FYI, there's also nothing stopping you from writing outside the buffer if you get more than arraysize characters before EOF. Add a check that you're still in bounds to your loop.
No idea how to do that unfortunately (Never touched C, just trying to call this in R), but it does have a Makefile. I uploaded the source in the Google drive since old link wasn't working.
Ignoring the reliance on implicit ints, "kappa" isn't defined anywhere.
Simply start thinking in terms of functions operating over data. To bounce a ball around all you need is its mass, position, velocity and acceleration over time. Think of a function that takes just these values and updates them over time.
Could definitely be something I am doing wrong with the building. I uploaded the source code with a working link.
the project is silly in the sense that my professor will be checking it against 100 million characters we havent learned dynamic array size based on input so hes basically okay with us just making the array a massive size bad practice i know but baby steps right the sizes i have right now are not what they'll end up being
The posted code is incomplete and the ftp links on the university website timeout. If that's all the code you have, then there's no way to make this work. If there's more code you haven't uploaded, you'll need to post the whole thing somewhere before anyone will be able to help.
I think I uploaded all I had on the Google drive (unless that is missing stuff as well)
Lol true. I was learning from a professors code for neutral network back propagation in c. The proof padded all the arrays so they could be 1 indexed instead of 0. Anyways the padding was off and caused segfaults if the arrays were heap instead of stack allocated. And all variables were 1 letter, but that was a given.
you mean visual studio?
Let me try to see if I can write a patch for you.
The file with all the errors in it isn't actually being compiled with the supplied Makefile. I suggest you to compile the project with the provided Makefile instead of trying to import it into some IDE. It compiles fine without any errors if you do so.
I get that that its a silly exercise, but this is a very good thing to learn to pay attention to when parsing untrusted input. In production code this would be a serious bug - at best you might crash or segfault, at worst if this is a function in privileged code an attacker could modify the stack frame to jump to malicious code that could do all sorts of bad things when you return from the function and voila, critical security vulnerability.
It seems you aren't supposed to compile `ninfomat.c`, it is never referenced in any build scripts. (But `ninfomat.c` is) You could try using the Makefile by cding into the directory in the shell and then executing `make` (or similar, like `mingw32-make CC=mingw32-gcc`, it looks like you're on windows and it might be Code::Blocks, which AFAIK ships with mingw). Alternatively you could read the Makefile. It's built like this: WGTCFG = wgtcfg.$(O) getcic.$(O) io.$(O) header.$(O) misc.$(O) zeroin.$(O) wgtcfg$(E) : $(WGTCFG) $(CC) $(CFLAGS) -o $@ $(WGTCFG) -lm which builds `wgtcfg` out of `wgtcfg.c getcic.c io.c header.c misc.c zeroin.c` and links in the math library (`-lm`). To the code, it's possible the author used a compiler that has a extension that it can auto-declare variables. (The Makefile for the "DOS" version seems to use Borland C, maybe something about it?)
I actually came across some discussion about this while looking for sources related to another comment on this post. `int *q = 1+&amp;wow` is not a valid pointer, and can be assumed to not compare equal to any valid pointer. `p` is assumed to be a valid pointer, so the compiler can optimize your comparison to `false`. You're off in UB territory if you try to do anything with an invalid pointer. On some hardware platforms apparently even *computing the value of q* could cause an exception, if the address where `wow` was placed is at the end of a chunk of segmented memory.
The Makefile in the base directory didn't work for me, but the one in `src` compiled and appears to work without needing any modifications: On a fresh CentOS 6 system: # Installed compiler [root@36545db6deb2 data]# yum install -y "@Development Tools" ... # Compiled stuff in src [root@36545db6deb2 data]# make -C src ... # Ran abcml [root@36545db6deb2 data]# ./src/abcml toy/toy.bdf toy/home.cfg toy/toy.cnt # ABCML # Analysis of Bone Counts by Maximum Likelihood # by Alan R. Rogers # Version c0.18 # Type `abcml -- ' for help #Cmd line: ./src/abcml toy/toy.bdf toy/home.cfg toy/toy.cnt #Estimating attrition parameter, beta #Output is : not verbose #Number of agents : 1 #Number of parameters : 2 #Number of skeletal parts : 2 #Sensitivity to attrition : 0.28084047551266133613 / density #Parameter initializatiton : fixed # ### Dataset 1 #Initial params: kappa=1074 beta=0.25 #Reducing dimension by Principal Components Enter dopc #Using 2 / 2 dimensions. rowlbl mni kappa beta alpha[0] ChiSq Estimate 537 1079.754251 0.000000 1.000000 491.364145 StdErr *** 35.569767 -nan *** *** # 100% of a whole animal would survive attrition # Residuals: #label y mu y-mu Z #Skull 537 323.926202 213.073798 11.838783 #Femur 942 1403.680104 -461.680104 -9.934908 # ### Dataset 2 #Initial params: kappa=1098 beta=0.25 #Reducing dimension by Principal Components Enter dopc #Using 2 / 2 dimensions. # rowlbl mni kappa beta alpha[0] ChiSq Estimate 549 1107.776002 0.000000 1.000000 483.783154 StdErr *** 36.041631 -nan *** *** # 100% of a whole animal would survive attrition # Residuals: #label y mu y-mu Z #Skull 549 332.332775 216.667225 11.885204 #Femur 983 1440.108658 -457.108658 -9.711326
Yep that looks great! How did you compile the Makefile? I googled it and it appears you just run "make" on the command line?
Look at quadratic_form(). He's using counter variables but doesn't have them declared in the function. It'd be kind of surprising if these were global variables defined in some other file, no? Not saying that he isn't missing sources, but it doesn't look like that's the sole problem.
The code never worked, all the functions have the `void` and I am not seeing global variables being declared anywhere. So either use global variables or fix the function arguments.
Exactly! That should just work.
The main reason we stick with C for embedded at work is that it's the lowest common denominator of hardware compatibility and programmer ability. If someone knows C, they can read and maintain pretty much any C code. C++ is a vast, complicated language and you're going to have a hard time finding someone who is fluent in more than some subset of it. If there's such a thing as "idiomatic C++" I'm not sure what it looks like, every C++ shop seems to allow and disallow different subsets of the language and heavily leverage various 3rd party libraries. And for smaller, embedded projects, C++ simply doesn't buy you very much. Much of the STL and language features like exceptions and RTTI generate unacceptably large binaries compared to their C equivalents, and the compiler doing god knows what behind your back is rarely desirable. You can certainly use C++ in a way that avoids these issues, but at that point your code looks a lot more like C, and at that point IMO it's better to just stick to the lowest common denominator and not leave room for your junior programmers to get clever with fancy OOP architectures.
This is the most clear, concise and we'll explained answer I've gotten, thank you so much.
You could try cs50's IDE because it has like a built in debugger or use CS50 Sandbox for a temporary environment
Evaluation of `1+&amp;wow` may not be defined in the language the authors of gcc and clang want to process, but it is defined according to the published draft of the C11 Standard (N1570), From 6.5.6 (Additive Operators) paragraph 7 &gt; For the purposes of these operators, a pointer to an object that is not an element of an array behaves the same as a pointer to the first element of an array of length one with the type of the object as its element type. and from paragraph 8: &gt; Moreover, if the expression P points to the last element of an array object, the expression (P)+1 points one past the last element of the array object, and if the expression Q points one past the last element of an array object, the expression (Q)-1 points to the last element of the array object. Section 6.5.9 (Equality Operators) paragraph 7 is analogous to 6.5.6p7 above, and paragraph 6 explicitly specifies the behavior of comparing a pointer that's "just past" one object with a pointer to another object. While the authors of clang and gcc may wish to treat as UB a comparison between a pointer "just past" one object and a pointer to another, the Standard explicitly and unambiguously defines the behavior in that case. An implementation may place the objects consecutively or not, at its leisure, but if it chooses to place them consecutively it must allow for the possibility that they might be consecutive.
Just scratching my own itch mostly. This project is still very bare bones but it's at the point of 'useful' for me so I figured I'd post it. Very similar to Protothreads ([http://dunkels.com/adam/pt/](http://dunkels.com/adam/pt/)) but I chose a different approach which solves some of the issues. Namely: \- Protothreads have no way to share code apart from macros because all your WAIT\_UNTILs need to be top level, cocc has subroutines \- Protothreads require you to use global/static variables for context with cocc you have local context
So far as I can tell, the authors of the Standard have never reached a consensus on what exactly the term "object" means, since no single definition can be sensibly applied everywhere without breaking the language.
Well... you can say it's "explicit and unambiguous" all you want, but not everyone agrees. See a long discussion of it here, linking to even more recent long discussions: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61502
&gt; but those function/variable names makes me think this belongs in r/programminghorror I'm from aerospace, not computer engineering, but I honestly prefer coding like this. Sometimes we are dealing with formulas or physical data, and this type of variable naming helps because it makes your code easily readable by someone who might not be well versed in programming, as well as being dead-easy to spot mistakes in formulas and algorithms. But hey, I'm no programmer (I know how to code, know my way around programming quite well but I'm no programmer) so... take with with a grain of salt
Here's a sneak peek of /r/programminghorror using the [top posts](https://np.reddit.com/r/programminghorror/top/?sort=top&amp;t=year) of the year! \#1: [eeeeeeeeeeeeee ee eeeee](https://i.redd.it/750uuvj9vd321.png) | [100 comments](https://np.reddit.com/r/programminghorror/comments/a4smlz/eeeeeeeeeeeeee_ee_eeeee/) \#2: [Had to fix this at work](https://i.redd.it/zsv03c9rv4521.png) | [203 comments](https://np.reddit.com/r/programminghorror/comments/a7hek1/had_to_fix_this_at_work/) \#3: [I thought "documenting" was cool back when I first started...](https://i.redd.it/ov7tn96ln6211.jpg) | [196 comments](https://np.reddit.com/r/programminghorror/comments/8oqq0g/i_thought_documenting_was_cool_back_when_i_first/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/afd0dd/blacklist/)
&gt; I've been using a linux virtual machine, but I'd rather code on my main os. You may think so, but windows APIs are notoriously abominable.
Unless you're coding some kernel driver, don't worry about it. Worst thing you can do without trying very, very hard is crash your process.
Well... both things seem to be "objects", they just don't really discuss what it means in terms of allowed operations on pointers if one "object" is wholly contained inside another "object". You're allowed to create pointers within an object (at least `char *` pointers), or between array indices, but you're disallowed from moving "between" objects via pointer arithmetic. So depending on how you interpret it you either are or are not allowed to portably do this. It seems to me the intent is that you can only do pointer math to synthesize pointers when the language guarantees a specific relationship between the addresses of the two objects. Arrays and structs both do that -- assuming you know or force that there won't be padding in the struct members, or take the padding into account.
First off, I'd recommend posting to /r/cpp_questions (C++ is technically off-topic here, although it's probably okay as your question isn't cpp-specific) Try`servaddr.sin_addr.s_addr = INADDR_ANY` rather than binding to `127.0.0.1`, and let us know if that works? INADDR_ANY has the value `0`, so it binds to *any* IP address. There's a chance that RDS is finicky about binding to the loopback IP.
Okay i added a check to make sure the counter was less then the size of the array to make sure it doesn't go out of bounds
If pointer `q` is derived in a way that would not be valid if it pointed to `*p`, then a compiler doesn't need to allow for the possibility that an access to `*q` might affect `*p`, but **the code here never accesses `*q`!**. The compiler is assuming that because `p` and `q` happen to compare equal, it may replace the legitimate access to `*p` with an access to `*q`, and then use the fact that the latter is illegitimate as an excuse to ignore the possibility that the former would have been legitimate. BTW, from that thread you linked, compare the principle quoted in that thread: &gt; edge cases should generally be resolved in the way that is convenient for optimization rather than the way that is simplest to specify. with the Spirit of C quoted in both the Standards Committees' published Rationale and Charter documents: &gt; Don't prevent the programmer from doing what needs to be done. If the authors of clang and gcc want to invent a C-like language which is easier to optimize, I'd have no objection to it *provided they stop trying to pretend that it's C*.
Don't run anything as administrator.
Hello, thanks for responding! Yes, I have tried INADDR_ANY. It didn't work as well. Same error. Once I checked the man page (which I have linked in my post), they specifically mentioned that RDS doesn't allow the usage of wildcards and INADDR_ANY. And thanks for letting me know about this being a bit off-topic. As you said, since I thought that this is not C++ specific, but rather a general network programming oriented question, I posted it here. I'll also try posting it there, and I'll keep this in mind while posting in the future.
Also, to give some perspective, one of the most important codebases at our company has to run on 4KB of ram shared between data and machine instructions. Needless to say, any kind of OS or dynamic memory or anything like that are completely out. Everything is statically allocated, and code size is by far the most important consideration - every instruction is precious. This isn't the most visible software domain, but tiny computing systems with single/double-digit KB of memory are still everywhere, and C, for all its warts, is pretty hard to beat here, since it maps closely to the hardware and an experienced programmer can visualize how any C language construct maps to the generated machine code - without ever having to touch hand-coded assembly. The remarkable thing about C++ is that you *could* successfully use it here if you have a good compiler for your architecture, but most of its features are beside the point at this scale.
&gt;Don't prevent the programmer from doing what needs to be done. On the flip side of this... if the folks writing the language spec want pointers to always be treated and compared as raw numeric values or bit patterns, with everything guaranteed to be in one big address space, the spec should say that. There's a large amount of latitude given to the implementation in terms of what pointers are and how they work under the hood. e.g. one could imagine an implementation where pointers are something like an `(index into a hashtable of allocations, offset)` pair, with every single object dynamically allocated separately, and pointer compares always return false if the index is unequal -- even if `(allocation_table[index] + offset)` might happen to evaluate to the same numeric address.
Do not post pictures of code. I have removed your question so you can repost with code as text.
So 100% no accidentally corrupting anything or crashing my pc?
I don't mean for the windows api, for now. Just for basic console programs. It's just an inconvenience to have to boot up a slow vm to write tiny small c programs.
Are you sure this is actually C? Looking for example at function quadratic_form(), the compiler complains that **i** isn't declared. This is true, **i** isn't declared anywhere, and no C compiler ever would have allowed this. Also, "real" isn't a C type. Also, this doesn't look like an old syntax at all. Looks pretty modern to me. I'm guessing this code was supposed to have been run through some preprocessor first. Or there's a missing header file.
I mean, I guess it's *theoretically* possible to create some Rube Goldberg-ian bug that ends up making unintentional syscalls that do stuff you could do without being root, but it's essentially impossible unless you're trying. From your program's perspective, it's surrounded by a big wall that separates it from other processes and the OS. It can't do anything with the memory the OS hasn't allowed it to use. Unless you run as root, the OS won't let you do too much damage.
Also builds fine on FreeBSD, using clang (changed CC=gcc line in Makefile, otherwise left alone).
I’m personally a guy who likes gcc. It never did me wrong. Ok... it has but you know what I mean.
Windows 10, oh yeah code blocks is actually good on that. I miss that. Although I do like atom editor on Linux.
Most likely, your prof has a program that will automatically run your program, send it data then capture the input. So you will want your program to read until EOF. You can test your program using redirection to send a file with test input to your program. You can accomplish this by creating a text file with your test input and piping it to your program: &amp;#x200B; On a \*nix system, like Linux/Mac/BSD/WSL?, this would be accomplished as follows: &amp;#x200B; $ cat input.dat | ./yourprogram &amp;#x200B; Not a Windows user, but Google tells me you can do the same thing on Windows like this: &amp;#x200B; C:\\ yourprogram.exe &lt; input.dat
Not true. Very old C compilers assumed implicitly that would be an int.
&gt; Also, "real" isn't a C type. It typedef is in mytypes.h.
seriously. worked with some data scientists at my last job, super smart folks, worst code I've ever seen.
Oh of course, I've totally done that before to send cmd output to a text file. I'll give it a shot, thank you.
Ahh, so it is.
is the output of your compiler kosher to something like throwing the kitchen sink against it? CFLAGS=" -march=x86-64 -m64 -Wfatal-errors -fmax-errors=5 -g -Wall -Wextra -Wunused -Werror -Wformat=2 -Wno-format-extra-args -Wno-format-zero-length -Winit-self -Wimplicit -Wimplicit-int -Wmissing-include-dirs -Wswitch-default -Wswitch-enum -Wunused-parameter -Wdouble-promotion -Wchkp -Wno-coverage-mismatch -Wstrict-overflow -Wformat-nonliteral -Wformat-security -Wformat-signedness -Wnonnull -Wnonnull-compare -Wnull-dereference -Wignored-qualifiers -Wignored-attributes -Wmain -Wpedantic -Wmisleading-indentation -Wmissing-braces -Wmissing-include-dirs -Wparentheses -Wsequence-point -Wshift-overflow=2 -Wswitch -Wswitch-default -Wswitch-bool -Wsync-nand -Wunused-but-set-parameter -Wunused-but-set-variable -Wunused-function -Wunused-label -Wunused-parameter -Wunused-result -Wunused-variable -Wunused-const-variable=2 -Wunused-value -Wuninitialized -Winvalid-memory-model -Wmaybe-uninitialized -Wstrict-aliasing=3 -Wstrict-overflow=5 -Wsuggest-attribute=pure -Wsuggest-attribute=const -Wsuggest-attribute=noreturn -Wsuggest-attribute=format -Wmissing-format-attribute -Wdiv-by-zero -Warray-bounds=2 -Wunknown-pragmas -Wbool-compare -Wduplicated-cond -Wtautological-compare -Wtrampolines -Wfloat-equal -Wfree-nonheap-object -Wstack-usage=120000 -Wunsafe-loop-optimizations -Wpointer-arith -Wnonnull-compare -Wtype-limits -Wcomments -Wtrigraphs -Wundef -Wendif-labels -Wbad-function-cast -Wcast-qual -Wcast-align -Wwrite-strings -Wclobbered -Wconversion -Wdate-time -Wempty-body -Wjump-misses-init -Wsign-compare -Wsign-conversion -Wfloat-conversion -Wsizeof-pointer-memaccess -Wsizeof-array-argument -Wpadded -Wredundant-decls -Wnested-externs -Winline -Wbool-compare -Wno-int-to-pointer-cast -Winvalid-pch -Wlong-long -Wvariadic-macros -Wvarargs -Wvector-operation-performance -Wvla -Wvolatile-register-var -Wpointer-sign -Wstack-protector -Woverlength-strings -Wunsuffixed-float-constants -Wno-designated-init -Whsa -std=c99 -D_POSIX_SOURCE -D_POSIX_C_SOURCE=200112L -D_XOPEN_SOURCE=700 -pedantic-errors" btw awesome idea, wonder if the C Committee would support co-routines natively.
If the code is doing filesystem calls, then it could theoretically alter any files which were accessible by the owner of the process. That's not really a realistic concern in most cases. Go ahead and code as much as you want.
If nothing else in a program uses the addresses of \`x1\`, \`wow\`, and \`x2\`, an implementation could treat the comparison in the above example as always returning false and I'd have no problem with that. The problem, as perhaps I failed to make clear, is that if the function is passed the address of \`x1\` or \`x2\`, clang and gcc will sometimes \*evaluate the comparison as true and perform the store\* but still evaluate the expression \`x1+x2\` as though \`x1\` and \`x2\` couldn't have been accessed.
You could probably send an email to the original author. Don't want to dox anyone, but it wasn't hard to find contact information after a quick google search.
You could probably send an email to the original author. Don't want to dox anyone, but it wasn't hard to find contact information after a quick google search.
You could probably send an email to the original author. Don't want to dox anyone, but it wasn't hard to find contact information after a quick google search.
You could probably send an email to the original author. Don't want to dox anyone, but it wasn't hard to find contact information after a quick google search.
You could probably send an email to the original author. Don't want to dox anyone, but it wasn't hard to find contact information after a quick google search.
You could probably send an email to the original author. Don't want to dox anyone, but it wasn't hard to find contact information after a quick google search.
You could probably send an email to the original author. Don't want to dox anyone, but it wasn't hard to find contact information after a quick google search.
You could probably send an email to the original author. Don't want to dox anyone, but it wasn't hard to find contact information after a quick google search.
You could probably send an email to the original author. Don't want to dox anyone, but it wasn't hard to find contact information after a quick google search.
You could probably send an email to the original author. Don't want to dox anyone, but it wasn't hard to find contact information after a quick google search.
You could probably send an email to the original author. Don't want to dox anyone, but it wasn't hard to find contact information after a quick google search.
Looks like the original author is listed in one of the files you uploaded, you could probably send an email to them to see if they had a specialized compiler that made sense of the funky syntax. Don't want to dox anyone, but it wasn't incredibly difficult to find contact information after a quick google search.
Rewrite it in C++. JK JK
Rewrite it in C++. JK JK
Rewrite it in C++. JK JK
From `mytypes.h`: #define START_COMMENT '#' Heh.
From `mytypes.h`: #define START_COMMENT '#' Heh.
From `mytypes.h`: #define START_COMMENT '#' Heh.
The intention of Dennis Ritchie when he documented his language in 1974 was that an expression like \`foo-&gt;bar\` be evaluated by taking address \`foo\`, adding the offset in of \`bar\`, and loading or storing a value of \`bar\`'s type from/to the associated storage. The 1974 C Reference Manual defines the semantics in those terms. Such behavior is, rather conveniently, consistent with a higher-level abstraction of the actions, but one of the things which made C very useful for many low-level programming tasks is that the higher-level abstractions could be used when they fit what the programmer needed to do, \*and ignored in cases where they did not\*. &amp;#x200B; As for the Committee, there is no single "intent". No doubt the intent of \*some\* of the people on the Committee was to view the language as being defined solely by the high-level abstraction, but that was hardly the consensus intention of the Committee. Looking at the published Rationale documents, it's obvious that at least some members of the Committee clearly recognized that " the ability to write machine-specific code is one of the strengths of C" and they consequently did not want "to preclude the use of C as a “high-level assembler”. &amp;#x200B; The Standard makes no attempt to mandate that all implementations be suitable for any particular purpose, nor any purpose at all for that matter. The authors assumed that compiler writers would support "popular extensions" in cases where doing so would be useful, without regard for whether the Standard required them to do so. As acknowledged in the Committee's Charter and Rationale Documents, the first two principles of the Spirit of C is "trust the programmer" and "Don't prevent the programmer from doing what needs to be done". There is no way that the Committee could be reasonably expected to know more than programmers about "what needs to be done", and it thus makes no effort to specify what is necessary to make an implementation be suitable for any particular purpose. &amp;#x200B; It would be literally impossible to write \*any\* program which all implementations would be required to process in meaningful fashion. A strong claim, but with a simple proof: consider two implementations that store functions containing an even number of lines in a separate symbol table from those that don't (a weird behavior, but perfectly allowable), and they will release nasal demons if either symbol table's capacity limit is exceeded (also allowable). One of the implementations limits the sizes of those tables to 5,000 and zero entries, respectively, while on the other the sizes are zero and 5000. It would be possible to write a program for either implementation which exercises all of the translation limits given in the Standard, and that it would process successfully. No program could possibly be processed successfully by both implementations. The notion, then, that programs should be written in such fashion as to work correctly on \*all\* conforming implementations is faulty; the best one can hope to do is write programs that will work on implementations that are suitable for the task at hand.
The intention of Dennis Ritchie when he documented his language in 1974 was that an expression like \`foo-&gt;bar\` be evaluated by taking address \`foo\`, adding the offset in of \`bar\`, and loading or storing a value of \`bar\`'s type from/to the associated storage. The 1974 C Reference Manual defines the semantics in those terms. Such behavior is, rather conveniently, consistent with a higher-level abstraction of the actions, but one of the things which made C very useful for many low-level programming tasks is that the higher-level abstractions could be used when they fit what the programmer needed to do, \*and ignored in cases where they did not\*. &amp;#x200B; As for the Committee, there is no single "intent". No doubt the intent of \*some\* of the people on the Committee was to view the language as being defined solely by the high-level abstraction, but that was hardly the consensus intention of the Committee. Looking at the published Rationale documents, it's obvious that at least some members of the Committee clearly recognized that " the ability to write machine-specific code is one of the strengths of C" and they consequently did not want "to preclude the use of C as a “high-level assembler”. &amp;#x200B; The Standard makes no attempt to mandate that all implementations be suitable for any particular purpose, nor any purpose at all for that matter. The authors assumed that compiler writers would support "popular extensions" in cases where doing so would be useful, without regard for whether the Standard required them to do so. As acknowledged in the Committee's Charter and Rationale Documents, the first two principles of the Spirit of C is "trust the programmer" and "Don't prevent the programmer from doing what needs to be done". There is no way that the Committee could be reasonably expected to know more than programmers about "what needs to be done", and it thus makes no effort to specify what is necessary to make an implementation be suitable for any particular purpose. &amp;#x200B; It would be literally impossible to write \*any\* program which all implementations would be required to process in meaningful fashion. A strong claim, but with a simple proof: consider two implementations that store functions containing an even number of lines in a separate symbol table from those that don't (a weird behavior, but perfectly allowable), and they will release nasal demons if either symbol table's capacity limit is exceeded (also allowable). One of the implementations limits the sizes of those tables to 5,000 and zero entries, respectively, while on the other the sizes are zero and 5000. It would be possible to write a program for either implementation which exercises all of the translation limits given in the Standard, and that it would process successfully. No program could possibly be processed successfully by both implementations. The notion, then, that programs should be written in such fashion as to work correctly on \*all\* conforming implementations is faulty; the best one can hope to do is write programs that will work on implementations that are suitable for the task at hand.
The intention of Dennis Ritchie when he documented his language in 1974 was that an expression like \`foo-&gt;bar\` be evaluated by taking address \`foo\`, adding the offset in of \`bar\`, and loading or storing a value of \`bar\`'s type from/to the associated storage. The 1974 C Reference Manual defines the semantics in those terms. Such behavior is, rather conveniently, consistent with a higher-level abstraction of the actions, but one of the things which made C very useful for many low-level programming tasks is that the higher-level abstractions could be used when they fit what the programmer needed to do, \*and ignored in cases where they did not\*. &amp;#x200B; As for the Committee, there is no single "intent". No doubt the intent of \*some\* of the people on the Committee was to view the language as being defined solely by the high-level abstraction, but that was hardly the consensus intention of the Committee. Looking at the published Rationale documents, it's obvious that at least some members of the Committee clearly recognized that " the ability to write machine-specific code is one of the strengths of C" and they consequently did not want "to preclude the use of C as a “high-level assembler”. &amp;#x200B; The Standard makes no attempt to mandate that all implementations be suitable for any particular purpose, nor any purpose at all for that matter. The authors assumed that compiler writers would support "popular extensions" in cases where doing so would be useful, without regard for whether the Standard required them to do so. As acknowledged in the Committee's Charter and Rationale Documents, the first two principles of the Spirit of C is "trust the programmer" and "Don't prevent the programmer from doing what needs to be done". There is no way that the Committee could be reasonably expected to know more than programmers about "what needs to be done", and it thus makes no effort to specify what is necessary to make an implementation be suitable for any particular purpose. &amp;#x200B; It would be literally impossible to write \*any\* program which all implementations would be required to process in meaningful fashion. A strong claim, but with a simple proof: consider two implementations that store functions containing an even number of lines in a separate symbol table from those that don't (a weird behavior, but perfectly allowable), and they will release nasal demons if either symbol table's capacity limit is exceeded (also allowable). One of the implementations limits the sizes of those tables to 5,000 and zero entries, respectively, while on the other the sizes are zero and 5000. It would be possible to write a program for either implementation which exercises all of the translation limits given in the Standard, and that it would process successfully. No program could possibly be processed successfully by both implementations. The notion, then, that programs should be written in such fashion as to work correctly on \*all\* conforming implementations is faulty; the best one can hope to do is write programs that will work on implementations that are suitable for the task at hand.
The intention of Dennis Ritchie when he documented his language in 1974 was that an expression like \`foo-&gt;bar\` be evaluated by taking address \`foo\`, adding the offset in of \`bar\`, and loading or storing a value of \`bar\`'s type from/to the associated storage. The 1974 C Reference Manual defines the semantics in those terms. Such behavior is, rather conveniently, consistent with a higher-level abstraction of the actions, but one of the things which made C very useful for many low-level programming tasks is that the higher-level abstractions could be used when they fit what the programmer needed to do, \*and ignored in cases where they did not\*. &amp;#x200B; As for the Committee, there is no single "intent". No doubt the intent of \*some\* of the people on the Committee was to view the language as being defined solely by the high-level abstraction, but that was hardly the consensus intention of the Committee. Looking at the published Rationale documents, it's obvious that at least some members of the Committee clearly recognized that " the ability to write machine-specific code is one of the strengths of C" and they consequently did not want "to preclude the use of C as a “high-level assembler”. &amp;#x200B; The Standard makes no attempt to mandate that all implementations be suitable for any particular purpose, nor any purpose at all for that matter. The authors assumed that compiler writers would support "popular extensions" in cases where doing so would be useful, without regard for whether the Standard required them to do so. As acknowledged in the Committee's Charter and Rationale Documents, the first two principles of the Spirit of C is "trust the programmer" and "Don't prevent the programmer from doing what needs to be done". There is no way that the Committee could be reasonably expected to know more than programmers about "what needs to be done", and it thus makes no effort to specify what is necessary to make an implementation be suitable for any particular purpose. &amp;#x200B; It would be literally impossible to write \*any\* program which all implementations would be required to process in meaningful fashion. A strong claim, but with a simple proof: consider two implementations that store functions containing an even number of lines in a separate symbol table from those that don't (a weird behavior, but perfectly allowable), and they will release nasal demons if either symbol table's capacity limit is exceeded (also allowable). One of the implementations limits the sizes of those tables to 5,000 and zero entries, respectively, while on the other the sizes are zero and 5000. It would be possible to write a program for either implementation which exercises all of the translation limits given in the Standard, and that it would process successfully. No program could possibly be processed successfully by both implementations. The notion, then, that programs should be written in such fashion as to work correctly on \*all\* conforming implementations is faulty; the best one can hope to do is write programs that will work on implementations that are suitable for the task at hand.
when u get the *c o c c*
when u get the *c o c c*
when u get the *c o c c*
when u get the *c o c c*
Windows can't be fucked up accidentally, and even intentionally it's pretty tough. Just make sure System Restore is enabled and has a decent amount of memory to store backups in (it's enabled by default, so unless you turned it off you're safe). I also recommend downloading Pelles C IDE and compiler, it's free, tiny, and very well made.
Windows can't be fucked up accidentally, and even intentionally it's pretty tough. Just make sure System Restore is enabled and has a decent amount of memory to store backups in (it's enabled by default, so unless you turned it off you're safe). I also recommend downloading Pelles C IDE and compiler, it's free, tiny, and very well made.
Windows can't be fucked up accidentally, and even intentionally it's pretty tough. Just make sure System Restore is enabled and has a decent amount of memory to store backups in (it's enabled by default, so unless you turned it off you're safe). I also recommend downloading Pelles C IDE and compiler, it's free, tiny, and very well made.
Windows can't be fucked up accidentally, and even intentionally it's pretty tough. Just make sure System Restore is enabled and has a decent amount of memory to store backups in (it's enabled by default, so unless you turned it off you're safe). I also recommend downloading Pelles C IDE and compiler, it's free, tiny, and very well made.
TBF computer science is a branch of math, so he was a mathematician.
You can try using WSL.
You can try using WSL.
You can try using WSL.
You can try using WSL.
Turn on developer mode, install Linux subsystem for Linux, and install distro of choice. Install CLI tools that you need, and you're all set. Its no where nearly the same, but solves your problem from a very basic perspective.
Turn on developer mode, install Linux subsystem for Linux, and install distro of choice. Install CLI tools that you need, and you're all set. Its no where nearly the same, but solves your problem from a very basic perspective.
Turn on developer mode, install Linux subsystem for Linux, and install distro of choice. Install CLI tools that you need, and you're all set. Its no where nearly the same, but solves your problem from a very basic perspective.
Turn on developer mode, install Linux subsystem for Linux, and install distro of choice. Install CLI tools that you need, and you're all set. Its no where nearly the same, but solves your problem from a very basic perspective.
Turn on developer mode, install Linux subsystem for Linux, and install distro of choice. Install CLI tools that you need, and you're all set. Its no where nearly the same, but solves your problem from a very basic perspective.
&gt; I set the following socket option. &gt; `getsockopt(...)` `getsockopt` does not set socket options. Note that the `rds(7)` manpage indicates there is no need to set the transport explicitly, since it will be set when you bind the socket. &gt; `servaddr.sin_family = PF_RDS;` Technically speaking this should be `AF_RDS`, since that field is the address family, not the protocol family. However, on Linux address families and protocol families are essentially interchangeable: they happen to use the same values. &gt; The manual page of bind() says that EINVAL error occurs when the socket is not a part of AF_UNIX family. That's _one_ of the reasons EINVAL can be returned. It's by no means the only one. The manpage simply doesn't document all the possible ways a particular error code could be generated by all possible socket types and address families. Now, to answer your question, I said above you should use `AF_RDS`, not `PF_RDS`. *This is wrong.* You actually need to use `AF_INET`, because you're binding an IP socket. You can see how this would have produced your `EINVAL` error by examining the kernel function that handles `bind(2)` on a `PF_RDS` socket, [`rds_bind`](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/rds/bind.c?h=v5.1#n163).
&gt; I set the following socket option. &gt; `getsockopt(...)` `getsockopt` does not set socket options. Note that the `rds(7)` manpage indicates there is no need to set the transport explicitly, since it will be set when you bind the socket. &gt; `servaddr.sin_family = PF_RDS;` Technically speaking this should be `AF_RDS`, since that field is the address family, not the protocol family. However, on Linux address families and protocol families are essentially interchangeable: they happen to use the same values. &gt; The manual page of bind() says that EINVAL error occurs when the socket is not a part of AF_UNIX family. That's _one_ of the reasons EINVAL can be returned. It's by no means the only one. The manpage simply doesn't document all the possible ways a particular error code could be generated by all possible socket types and address families. Now, to answer your question, I said above you should use `AF_RDS`, not `PF_RDS`. *This is wrong.* You actually need to use `AF_INET`, because you're binding an IP socket. You can see how this would have produced your `EINVAL` error by examining the kernel function that handles `bind(2)` on a `PF_RDS` socket, [`rds_bind`](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/rds/bind.c?h=v5.1#n163).
&gt; I set the following socket option. &gt; `getsockopt(...)` `getsockopt` does not set socket options. Note that the `rds(7)` manpage indicates there is no need to set the transport explicitly, since it will be set when you bind the socket. &gt; `servaddr.sin_family = PF_RDS;` Technically speaking this should be `AF_RDS`, since that field is the address family, not the protocol family. However, on Linux address families and protocol families are essentially interchangeable: they happen to use the same values. &gt; The manual page of bind() says that EINVAL error occurs when the socket is not a part of AF_UNIX family. That's _one_ of the reasons EINVAL can be returned. It's by no means the only one. The manpage simply doesn't document all the possible ways a particular error code could be generated by all possible socket types and address families. Now, to answer your question, I said above you should use `AF_RDS`, not `PF_RDS`. *This is wrong.* You actually need to use `AF_INET`, because you're binding an IP socket. You can see how this would have produced your `EINVAL` error by examining the kernel function that handles `bind(2)` on a `PF_RDS` socket, [`rds_bind`](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/rds/bind.c?h=v5.1#n163).
&gt; I set the following socket option. &gt; `getsockopt(...)` `getsockopt` does not set socket options. Note that the `rds(7)` manpage indicates there is no need to set the transport explicitly, since it will be set when you bind the socket. &gt; `servaddr.sin_family = PF_RDS;` Technically speaking this should be `AF_RDS`, since that field is the address family, not the protocol family. However, on Linux address families and protocol families are essentially interchangeable: they happen to use the same values. &gt; The manual page of bind() says that EINVAL error occurs when the socket is not a part of AF_UNIX family. That's _one_ of the reasons EINVAL can be returned. It's by no means the only one. The manpage simply doesn't document all the possible ways a particular error code could be generated by all possible socket types and address families. Now, to answer your question, I said above you should use `AF_RDS`, not `PF_RDS`. *This is wrong.* You actually need to use `AF_INET`, because you're binding an IP socket. You can see how this would have produced your `EINVAL` error by examining the kernel function that handles `bind(2)` on a `PF_RDS` socket, [`rds_bind`](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/rds/bind.c?h=v5.1#n163).
&gt; The manual page of bind() says that EINVAL error occurs when the socket is not a part of AF_UNIX family. That's _one_ of the reasons EINVAL can be returned. It's by no means the only one. The manpage simply doesn't document all the possible ways a particular error code could be generated by all possible socket types and address families. Now, to answer your question, I said above you should use `AF_RDS`, not `PF_RDS`. *This is wrong.* You actually need to use `AF_INET`, because you're binding an IP socket. You can see how this would have produced your `EINVAL` error by examining the kernel function that handles `bind(2)` on a `PF_RDS` socket, [`rds_bind`](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/rds/bind.c?h=v5.1#n163).
&gt; I set the following socket option. &gt; `getsockopt(...)` `getsockopt` does not set socket options. Note that the `rds(7)` manpage indicates there is no need to set the transport explicitly, since it will be set when you bind the socket. &gt; `servaddr.sin_family = PF_RDS` Technically speaking this should be `AF_RDS`, since that field is the address family, not the protocol family. However, on Linux address families and protocol families are essentially interchangeable: they happen to use the same values.
&gt; I set the following socket option. &gt; `getsockopt(...)` `getsockopt` does not set socket options. Note that the `rds(7)` manpage indicates there is no need to set the transport explicitly, since it will be set when you bind the socket. &gt; `servaddr.sin_family = PF_RDS` Technically speaking this should be `AF_RDS`, since that field is the address family, not the protocol family. However, on Linux address families and protocol families are essentially interchangeable: they happen to use the same values. &gt; The manual page of bind() says that EINVAL error occurs when the socket is not a part of AF_UNIX family. That's _one_ of the reasons EINVAL can be returned. It's by no means the only one. The manpage simply doesn't document all the possible ways a particular error code could be generated by all possible socket types and address families. Now, to answer your question, I said above you should use `AF_RDS`, not `PF_RDS`. *This is wrong.* You actually need to use `AF_INET`, because you're binding an IP socket. You can see how this would have produced your `EINVAL` error by examining the kernel function that handles `bind(2)` on a `PF_RDS` socket, [`rds_bind`](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/rds/bind.c?h=v5.1#n163).
&gt; I set the following socket option. &gt; `getsockopt(...)`
&gt; I set the following socket option. &gt; `getsockopt(...)` `getsockopt` does not set socket options. Note that the `rds(7)` manpage indicates there is no need to set the transport explicitly, since it will be set when you bind the socket. &gt; `servaddr.sin_family = PF_RDS` Technically speaking this should be `AF_RDS`, since that field is the address family, not the protocol family. However, on Linux address families and protocol families are essentially interchangeable: they happen to use the same values. &gt; The manual page of bind() says that EINVAL error occurs when the socket is not a part of AF_UNIX family. That's _one_ of the reasons EINVAL can be returned. It's by no means the only one. The manpage simply doesn't document all the possible ways a particular error code could be generated by all possible socket types and address families. Now, to answer your question, I said above you should use `AF_RDS`, not `PF_RDS`. *This is wrong.* You actually need to use `AF_INET`, because you're binding an IP socket. You can see how this would have produced your `EINVAL` error by examining the kernel function that handles `bind(2)` on a `PF_RDS` socket, [`rds_bind`](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/rds/bind.c?h=v5.1#n163).
&gt; I set the following socket option. &gt; `getsockopt(...)` `getsockopt` does not set socket options. Note that the `rds(7)` manpage indicates there is no need to set the transport explicitly, since it will be set when you bind the socket. &gt; `servaddr.sin_family = PF_RDS;` Arguably this should be `AF_RDS`, since that field is the address family, not the protocol family. However, on Linux address families and protocol families are essentially interchangeable: they are, as far as I know, always the same values. It appears the kernel internally uses `AF_*` constants even when referring to protocol families. &gt; The manual page of bind() says that EINVAL error occurs when the socket is not a part of AF_UNIX family. That's _one_ of the reasons EINVAL can be returned. It's by no means the only one. The manpage simply doesn't document all the possible ways a particular error code could be generated by all possible socket types and address families. Now, to answer your question, I said above you should use `AF_RDS`, not `PF_RDS`. *This is wrong.* You actually need to use `AF_INET`, because you're binding an IP socket. You can see how this would have produced your `EINVAL` error by examining the kernel function that handles `bind(2)` on a `PF_RDS` socket, [`rds_bind`](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/rds/bind.c?h=v5.1#n163).
&gt; I set the following socket option. &gt; `getsockopt(...)` `getsockopt` does not set socket options. Note that the `rds(7)` manpage indicates there is no need to set the transport explicitly, since it will be set when you bind the socket. &gt; `servaddr.sin_family = PF_RDS;` Arguably this should be `AF_RDS`, since that field is the address family, not the protocol family. However, on Linux address families and protocol families are essentially interchangeable: they are, as far as I know, always the same values. It appears the kernel internally uses `AF_*` constants even when referring to protocol families. &gt; The manual page of bind() says that EINVAL error occurs when the socket is not a part of AF_UNIX family. That's _one_ of the reasons EINVAL can be returned. It's by no means the only one. The manpage simply doesn't document all the possible ways a particular error code could be generated by all possible socket types and address families. Now, to answer your question, I said above you should use `AF_RDS`, not `PF_RDS`. *This is wrong.* You actually need to use `AF_INET`, because you're binding a socket using an IP address and port. You can see how this would have produced your `EINVAL` error by examining the kernel function that handles `bind(2)` on a `PF_RDS` socket, [`rds_bind`](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/rds/bind.c?h=v5.1#n163). Note that if the socket's address family is not `AF_INET` or `AF_INET6` it will error out.
&gt; I set the following socket option. &gt; `getsockopt(...)` `getsockopt` does not set socket options. Note that the `rds(7)` manpage indicates there is no need to set the transport explicitly, since it will be set when you bind the socket. &gt; `servaddr.sin_family = PF_RDS;` Arguably this should be `AF_RDS`, since that field is the address family, not the protocol family. However, on Linux address families and protocol families are essentially interchangeable: they are, as far as I know, always the same values. It appears the kernel internally uses `AF_*` constants even when referring to protocol families. &gt; The manual page of bind() says that EINVAL error occurs when the socket is not a part of AF_UNIX family. That's _one_ of the reasons `EINVAL` can be returned. It's by no means the only one. The manpage simply doesn't document all the possible ways a particular error code could be generated by all possible socket types and address families. Now, to answer your question, I said above you should use `AF_RDS`, not `PF_RDS`. *This is wrong.* You actually need to use `AF_INET`, because you're binding a socket using an IP address and port. You can see how this would have produced your `EINVAL` error by examining the kernel function that handles `bind(2)` on a `PF_RDS` socket, [`rds_bind`](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/rds/bind.c?h=v5.1#n163). Note that if the socket's address family is not `AF_INET` or `AF_INET6` it will error out.
&gt; I set the following socket option. &gt; `getsockopt(...)` `getsockopt` does not set socket options. Note that the `rds(7)` manpage indicates there is no need to set the transport explicitly, since it will be set when you bind the socket. &gt; `servaddr.sin_family = PF_RDS;` Arguably this should be `AF_RDS`, since that field is the address family, not the protocol family. However, on Linux address family constants and protocol family constants are essentially interchangeable: they are, as far as I know, always the same values. It appears the kernel internally uses `AF_*` constants even when referring to protocol families. &gt; The manual page of bind() says that EINVAL error occurs when the socket is not a part of AF_UNIX family. That's _one_ of the reasons `EINVAL` can be returned. It's by no means the only one. The manpage simply doesn't document all the possible ways a particular error code could be generated by all possible socket types and address families. Now, to answer your question, I said above you should use `AF_RDS`, not `PF_RDS`. *This is wrong.* You actually need to use `AF_INET`, because you're binding a socket using an IP address and port. You can see how this would have produced your `EINVAL` error by examining the kernel function that handles `bind(2)` on a `PF_RDS` socket, [`rds_bind`](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/rds/bind.c?h=v5.1#n163). Note that if the socket's address family is not `AF_INET` or `AF_INET6` it will error out.
Hah, absolutely not. It already produces warnings that will be errors if you do -Werror However I follow the wisdom that states "if something is useful, release it." I definitely want to clean up the warnings in the future.
Hah, absolutely not. It already produces warnings that will be errors if you do -Werror However I follow the wisdom that states "if something is useful, release it." I definitely want to clean up the warnings in the future.
&gt; I set the following socket option. &gt; `getsockopt(...)` `getsockopt` does not set socket options. Note that the `rds(7)` manpage indicates there is no need to set the transport explicitly, since it will be set when you bind the socket. &gt; `servaddr.sin_family = PF_RDS;` Arguably this should be `AF_RDS`, since that field is the address family, not the protocol family. However, on Linux address family constants and protocol family constants are essentially interchangeable: they are, as far as I know, always the same values. It appears the kernel internally uses `AF_*` constants even when referring to protocol families. &gt; The manual page of bind() says that EINVAL error occurs when the socket is not a part of AF_UNIX family. That's _one_ of the reasons `EINVAL` can be returned. It's by no means the only one. The manpage simply doesn't document all the possible ways a particular error code could be generated by all possible socket types and address families. Now, to answer your question, I said above you should use `AF_RDS`, not `PF_RDS`. *This is wrong.* You actually need to use `AF_INET`, because you're binding a socket using an IP address and port. You can see how this would have produced your `EINVAL` error by examining the kernel function that handles `bind(2)` on a `PF_RDS` socket, [`rds_bind`](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/rds/bind.c?h=v5.1#n163). Note that if the socket's address family is not `AF_INET` or `AF_INET6` it will error out.
Not knowing PF\_RDS at all... **setsockopt** sets, getsockopt just queries stuff. Is this a problem.
Not knowing PF\_RDS at all... **setsockopt** sets, getsockopt just queries stuff. Is this a problem.
Not knowing PF\_RDS at all... **setsockopt** sets, getsockopt just queries stuff. Is this a problem.
Not knowing PF\_RDS at all... **setsockopt** sets, getsockopt just queries stuff. Is this a problem.
Not knowing PF\_RDS at all... **setsockopt** sets, getsockopt just queries stuff. Is this a problem.
Not knowing PF\_RDS at all... **setsockopt** sets, getsockopt just queries stuff. Doesn't match the comments
Not knowing PF\_RDS at all... **setsockopt** sets, getsockopt just queries stuff. Doesn't match the comments
getsockopt? Shouldn't it be setsockopt
Shouldn't that be **s**etsockopt?
You can use WSL.
**s**etsockopt should be used?
&gt; I set the following socket option. &gt; `getsockopt(...)` `getsockopt` does not set socket options. Note that the `rds(7)` manpage indicates there is no need to set the transport explicitly, since it will be set when you bind the socket. &gt; `servaddr.sin_family = PF_RDS;` Arguably this should be `AF_RDS`, since that field is the address family, not the protocol family. However, on Linux address family constants and protocol family constants are essentially interchangeable: they are, as far as I know, always the same values. It appears the kernel internally uses `AF_*` constants even when referring to protocol families. &gt; The manual page of bind() says that EINVAL error occurs when the socket is not a part of AF_UNIX family. That's _one_ of the reasons `EINVAL` can be returned. It's by no means the only one. The manpage simply doesn't document all the possible ways a particular error code could be generated by all possible socket types and address families. Now, to answer your question, I said above you should use `AF_RDS`, not `PF_RDS`. *This is wrong.* You actually need to use `AF_INET`, because you're binding a socket using an IP address and port. You can see how this would have produced your `EINVAL` error by examining the kernel function that handles `bind(2)` on a `PF_RDS` socket, [`rds_bind`](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/rds/bind.c?h=v5.1#n163). Note that if the socket's address family is not `AF_INET` or `AF_INET6` it will error out.
Hello, thanks for responding! It was really helpful to narrow down where the problem is. First, as /u/oh5nxo and you have mentioned, I've tried changing getsockopt to setsockopt. Asking out of curiosity, the man page always says "...getsockopt and setsockopt manipulate the socket options...". Practically showcasing them as the same. Is that the case? Next, I made a mistake in my if condition while setting the option. so both getsockopt and setsockopt returns -1. Hence, The program stops right where I try to set the transport. And yes, as you have mentioned man page does not require us to set the transport. But I want the RDS to work over TCP. So isn't it necessary to set the transport? Last, I tried without setting the transport, and directly binding it with AF\_INET. As you said, it binded successfully. So, since I'm a starter with network programming, I have a doubt. Mentioning the address family as INET and protocol family as RDS while creating the socket, will still make the server function as RDS? Here's the link to the current full code - [https://pastebin.com/dF4CJkTY](https://pastebin.com/dF4CJkTY) &amp;#x200B; Thanks again for responding!
&gt; First, as /u/oh5nxo and you have mentioned, I've tried changing getsockopt to setsockopt. Asking out of curiosity, the man page always says "...getsockopt and setsockopt manipulate the socket options...". Practically showcasing them as the same. Is that the case? I don't know which particular manpage you're looking at, so I can't comment on it. `getsockopt` retrieves socket options. `setsockopt` sets socket options. They are quite distinct. &gt; Next, I made a mistake in my if condition while setting the option. so both getsockopt and setsockopt returns -1. Hence, The program stops right where I try to set the transport. And yes, as you have mentioned man page does not require us to set the transport. But I want the RDS to work over TCP. So isn't it necessary to set the transport? Read that `rds_bind` code I linked to. You'll note that it sets the transport if it is not already set, or verifies the transport if it is. That mirrors the `rds(7)` you linked to, which says: &gt; A new RDS socket has no local address when it is first returned from `socket(2)`. It must be bound to a local address by calling `bind(2)` before any messages can be sent or received. This will also attach the socket to a specific transport, based on the type of interface the local address is attached to. &gt; Mentioning the address family as INET and protocol family as RDS while creating the socket, will still make the server function as RDS? It's important to distinguish "protocols" from "addresses". I could come up with a new network protocol, completely unrelated to IP, that just so happens to use IP addresses as the names by which endpoints are bound. It would make perfect sense to use `AF_INET` addresses in this case, even though the protocol isn't `PF_INET`. But RDS, when running over TCP, _does_ use IP, since TCP is an IP protocol. So giving your RDS socket a full TCP address &amp;mdash; that is both an IP _and_ a TCP port &amp;mdash; makes perfect sense.
&gt; Unlike languages like Python or Java, you can't hide complexity behind abstractions Well You *can* You can have all sorts of fancy runtime polymorphism and reflection It'll just be really verbose and you'll have to fight the language all the way to get it Not really worth it But that's what the code *of* the python compiler and the java compiler do, basically
I'm trying to experiment with a particular vulnerability that was identified in Linux kernel recently. CVE-2019-11815. Since the vulnerability itself is on rds_tcp kernel module, I must understand how to setup RDS over TCP connection, in order to study to vuln. So that's the motivation for me to use RDS over TCP and to set socket option to specifically use TCP, and not InfiniBand. Thanks for your explanation regarding protocols and addresses. Now it makes sense. As I mentioned in my previous comment, setsockopt is returning -1, when I attempt to set transport as TCP. I'm yet to identify the problem there. I'll read rds_bind to understand how they're setting the transport exactly. I'll keep this thread updated regarding my progress.
&gt; As I mentioned in my previous comment, setsockopt is returning -1, when I attempt to set transport as TCP. You haven't shown the code you're using to do this. Don't forget that `setsockopt` takes a _pointer_ to the option's data, and that applying the `sizeof` object to a preprocessor constant is meaningless.
Is this pronounced "co see see" or "cock"
Cool project! The name is a mouthful though...
-Wyikes
cocc is a mouthful? As it should be.
This sounds fantastic. I've tried exercism in the past, but several of the learning threads don't get responses.
I don't think this post fits the sub. It would fit in other subs mentionned in the sidebar. That's without even taking into account the "`(JavaScript, Java, C#, Python) and also in C and C++`" which implies C isn't even the *main* goal of this community.
It does not imply that. C and C++ aren't real backend languages for the web - the sentencing is just formatted such that it would be incorrect to write C and C++ there.
Cool! How do you pronounce it though?
lol. anything that can read from stdin and output to stdout can be a backend language. the absolute state of webdevs...
-Wtf
I met a webdev who could tell you anything you wanted to know about php, but he didn't know what a microcontroller was and had never seen any real C code until I showed him my senior project. Crazy times
I'm not saying it isnt possible; it makes absolutely NO sense to use C or C++ for that purpose.
~~rewrite it in rust~~ don't run as admin and just becareful with syscalls and loops; learn about common antipatterns [like this](https://en.m.wikipedia.org/wiki/Fork_bomb)
Worked fine on Ubuntu 18.04 as well.
Both [Google and Yahoo use C](https://en.wikipedia.org/wiki/Programming_languages_used_in_most_popular_websites) as a backend language. Also lots of low-cost embedded devices. But i get your point.
**Programming languages used in most popular websites** The most popular (i.e., the most visited) websites have in common that they are dynamic websites. Their development typically involves server-side coding, client-side coding and database technology. The programming languages applied to deliver similar dynamic web content however vary vastly between sites. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Yes, you're right. setsockopt needs a pointer to the option's data. So, this is what I did. `int optval = RDS_TRANS_TCP;` `int sockflag = setsockopt(rds_soc,SOL_RDS,SO_RDS_TRANSPORT,(void*)&amp;optval,sizeof(optval));` And this time, it seems to work without any errors. I'm yet to complete the entire code. So, once I progress further, I'll know if all is set, or if I'm missing out on something. So again, I'll keep updating this thread regarding the progress. &amp;#x200B; Here's the entire code as of now - [https://pastebin.com/gaFUUe7S](https://pastebin.com/gaFUUe7S)
Yep these companies are using it for code optimalization (aka for very difficult algorithms). The average developer is able to write more efficient code in other languages such as C#, though, just because it is quite hard to be efficient in C. And even if you are able to write more efficient code in C, you should in almost every case not even care about the difference in efficiency between the languages. Except for these big companies of course.. :D
The intention of Dennis Ritchie when he documented his language in 1974 was that an expression like \`foo-&gt;bar\` be evaluated by taking address \`foo\`, adding the offset in of \`bar\`, and loading or storing a value of \`bar\`'s type from/to the associated storage. The 1974 C Reference Manual defines the semantics in those terms. Such behavior is, rather conveniently, consistent with a higher-level abstraction of the actions, but one of the things which made C very useful for many low-level programming tasks is that the higher-level abstractions could be used when they fit what the programmer needed to do, \*and ignored in cases where they did not\*. &amp;#x200B; As for the Committee, there is no single "intent". No doubt the intent of \*some\* of the people on the Committee was to view the language as being defined solely by the high-level abstraction, but that was hardly the consensus intention of the Committee. Looking at the published Rationale documents, it's obvious that at least some members of the Committee clearly recognized that " the ability to write machine-specific code is one of the strengths of C" and they consequently did not want "to preclude the use of C as a “high-level assembler”. &amp;#x200B; The Standard makes no attempt to mandate that all implementations be suitable for any particular purpose, nor any purpose at all for that matter. The authors assumed that compiler writers would support "popular extensions" in cases where doing so would be useful, without regard for whether the Standard required them to do so. As acknowledged in the Committee's Charter and Rationale Documents, the first two principles of the Spirit of C is "trust the programmer" and "Don't prevent the programmer from doing what needs to be done". There is no way that the Committee could be reasonably expected to know more than programmers about "what needs to be done", and it thus makes no effort to specify what is necessary to make an implementation be suitable for any particular purpose. &amp;#x200B; It would be literally impossible to write \*any\* program which all implementations would be required to process in meaningful fashion. A strong claim, but with a simple proof: consider two implementations that store functions containing an even number of lines in a separate symbol table from those that don't (a weird behavior, but perfectly allowable), and they will release nasal demons if either symbol table's capacity limit is exceeded (also allowable). One of the implementations limits the sizes of those tables to 5,000 and zero entries, respectively, while on the other the sizes are zero and 5000. It would be possible to write a program for either implementation which exercises all of the translation limits given in the Standard, and that it would process successfully. No program could possibly be processed successfully by both implementations. The notion, then, that programs should be written in such fashion as to work correctly on \*all\* conforming implementations is faulty; the best one can hope to do is write programs that will work on implementations that are suitable for the task at hand.
-Woof
Do not spam.
The cleanest way is with an event dispatcher. Pseudocode: main() { while (running) { ev = next_event(); dispatch_event(ev); } } The implementation of `next_event` depends on whether it is possible to block waiting for both a timer and an X event. I have not done any X11 programming, but if it uses an fd for talking to the X server then `select` can be used. To use `select` with the timer you use the signal handler + pipe trick. Less hackish is to use polling: next_event() { for (;;) { ev = poll_xevent() if (ev) return ev; ev = poll_timer() //compute delta time, check if &gt;= than timer value if (ev) return ev sleep_ms(50) } } This is less efficient if the event rate is low as it will take CPU time regardless, however doing this every 50ms makes the overhead unnoticeable and program is still responsive enough.
Love a mouthful of cocc
You can select/poll on descriptor ConnectionNumber(dpy). Or use Xt just for the XtAddTimeout(), for the periodic routines.
Traditionally, the compilation process involves the following four steps: * *preprocessing* where a binary named `cpp` (the preprocessor) evaluates preprocessing directives, translating your source file into a preprocessed source file * *compilation* where a binary named `cc1` (the compiler) compiles your code into an assembly file * *assembling* where a binary named `as` (the assembler) turns the assembly file into an object file * *linking* where a binary named `ld` (the link editor) links many object files into a binary You can observe the intermediate output of all stages with the `-save-temps` option to `gcc`. Some compilers like clang leave out some or all intermediate representations, opting instead to proceed directly to the next step in one program.
Ok cool. So if I didn't use -save-temps, would all those pre-compilation files just be deleted immediately after compilation was completed?
Exactly! They might not even be created in the first place: depending on how gcc is configured, it might use pipes to pass intermediate output to the next stage.
BRB asking if "there is any way to use C safely" over on r/rust. 🤣
Thank you for your answer. &gt; but if it uses an fd for talking to the X server then select can be used You are correct, `select` is used by the solution I found.
Thank you for your answer. This helped me narrow down my internet search and I found something using the descriptor I could adapt to my use case.
You can FD\_ZERO just once, before the loop, to save some cycles. But who's counting
4k contiguous blocks
[This link](https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/) is a nice introduction but if you're really interested read [understanding the heap by breaking it](https://www.blackhat.com/presentations/bh-usa-07/Ferguson/Whitepaper/bh-usa-07-ferguson-WP.pdf) The very short version is that you can implement the heap many ways, and many programs use custom allocators such as jmalloc to benefit from different strategies, so it's not like as if there were a single answer. However the gist of it to differentiate between small and big allocations by putting them in different pools of chunks of memory of different sizes. Each chunk needs to know its size so that if needed you can extend it or reallocate it.
Some good articles that I can personally recommend: https://arjunsreedharan.org/post/148675821737/memory-allocators-101-write-a-simple-memory https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/ https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/ https://sourceware.org/glibc/wiki/MallocInternals More resources: https://reverseengineering.stackexchange.com/questions/15033/how-does-glibc-malloc-work
Yeah, that's kind of what I was trying to say, although it didn't come across very well. In Python for instance, duck-typing looks very simple and natural, but you wouldn't be able to introspect what is happening under the hood without looking into the source code of the Python interpreter itself. In C however, the complexity would be more "visible" to the developer; you would find yourself directly implementing the complicated web of union types, function pointers, and hashmaps that allow duck typing on class types.
A simple allocator to implement is the [buddy memory allocator](https://en.wikipedia.org/wiki/Buddy_memory_allocation). Modern methods are more complicated and often employ [slab allocators](https://en.wikipedia.org/wiki/Slab_allocation). Refer to [jemalloc](http://jemalloc.net/) for a good open source implementation.
Thank you. Actually that helps quite a lot: The solution I found works, but if the Xserver sends more than a few events, it struggles. Everything is fine when I change from an empty desktop to another empty desktop, but if their are windows on them, there are more XEvents send by the window manager (like `_NET_ACTIVE_WINDOW`). I have to see if I can better filter out any events I don't need...
What's the code?
https://notabug.org/Leon_Plickat/barclay Ignore the hacky code for getting the current desktop: For now I have copied a function from `wmctrl` as I did not want to streamline it before I was sure this project is something a beginner / hobbyist can do. It looks rather slow (as `XInternAtom` is called everytime instead of once globally), but in a "pure" XEvent loop it was definitely fast enough. I believe that `while(XPending(dpy)) XNextEvent(dpy, &amp;xevent);` simply drops all XEvents received while the previous one is handled.
Ok, I think I fixed it by also looking at the XEvents dropped by `XNextEvent()`.
man 2 execl
Ah ty.
With fork, you configure the parent process for the new child process, `fork(2)`, maybe do some more configuration in the child process, then maybe finally `exec(3)`. The reason `fork(2)` doesn't take any parameters is because the configuration for the new child process happens via separate system calls before and after. `CreateProcess()` on Windows and `posix_spawn(3)` on POSIX have a *spawn* interface and so take the entire process configuration at once in a single, complex system call. Each form of process creation has advantages and disadvantages. In general spawning is more efficient than fork+exec, even with copy-on-write. Fork by itself enables some capabilities not possible with spawn (e.g. fork servers), and it's also much easier to use. There's also the now non-standard `vfork(2)` that [has its own advantages and disadvantages](https://gist.github.com/nicowilliams/a8a07b0fc75df05f684c23c18d7db234).
I wrote a simple memory allocator that can be used like a heap and works via many of the same concepts. It lacks certain features implemented by the actual program heap, but it might help you get a basic idea: https://github.com/intruder-kat/Proof-Of-Concept/tree/master/vheap
You could create a dummy input-only window to each desktop, and watch MapNotify events for those windows. Maybe overcomplicated.
The problem with that approach is to get the window manager to map / unmap the window but without drawing window decorations. I believe I fixed the problem by also handling the XEvents otherwise dropped at the end of the outer loop.
You are right (I still had to try it :)
Again the linked list, the thing that novices think is only academic any not worthwhile IRL.
Well, linked lists in the real world are rarely *just* linked lists, it's often combined with other systems (hashmap to link-listed buckets...) or each node is actually part of multiple linked lists (doubly-linked lists, multi directectional linked lists...)...
The UNIX philosophy is that things should do one job and do them well. The fork system call does exactly one call and you're expected to follow it up with more system calls that do one thing. The CreateProcess function takes 10 parameters and it is a lot more flexible, but it would just be an obscene eyesore in a UNIX OS. &gt; It seems to me to be the most bizarre function call ever, or dumbest method to accomplish anything useful. If you think this, you should probably study UNIX more closely. You might not like it, but things are done this way for a reason, and it's worked very well for them for the past (almost) 50 years. &gt; First odd thing is it's frequently claimed that it's used to create new processes, and it is like Windows' CreateProcess(). This is clearly not true since it takes no parameters and returns nothing other than an integer. Never mind what it's "frequently claimed" to do, what does it actually do? It creates a new task (or whatever the kernel calls processes at that level) with the same memory map as the first. The return value is just used to tell if it was successful and whether you're in the parent or child process. It's a very simple system call that does one simple thing as simply as possible. This is a pattern you'll see repeated all over the place in UNIX, they don't pile functionality into one system call or one program (at least not in early UNIX history), you're expected to string these system calls and programs together to do something useful. &gt; CreateProcess() takes parameters, one of which is very important; **what process to create**! The newly created process on Windows has it's **own memory** (not existing copied memory), and it's own binary code. fork() takes no params, and it cannot execute another process. It does not create a new process either, it clones an existing process (why?), including it's memory usage (why?). You should study before asking questions like this. The answer to all of that is a google away. A forked process does have its own memory, the actual fork system call achieves this by copying the descriptor tables of the original process and implements a "copy on write" system, where only pages written to after the fork in either process are copied to either parent or child process. This gives parent and child identical memory for a very low cost. As for why it clones an existing process, again, fork does one thing. You're expected to call other system calls after fork and you can't do that if you discard the program you're executing by creating a new blank process. That's also why all the memory is brought over to the new process, it needs to remember its state to know which system calls to call next. It's a pretty cheap operation, too, since the memory itself is not being copied, just the descriptor tables that tell the MMU which virtual addresses map to which physical addresses. So no, it's not a holdover. You need to read about UNIX if you want to know why things are done this way. But just think about how it would be to implement these things. In a simple operating system, fork can be implemented in tens of lines of code, maybe as little as 30. The entire system call. You can barely list CreateProcess' parameters in that space, let alone interpret them and implement the whole thing. Yeah, it can't open a new executable file and run it, but that's what the exec system call is for, which is similarly simple.
Are you aware of Gabriel Kerneis' CPC? [Continuation Passing C](https://github.com/kerneis/cpc) I think this was done as thesis work at the University of Paris, Diderot. Really interesting stuff. They had an example of a Bit Torrent server that was very clean. Seems to be suffering a bit from bit rot at this point. It has been several years since I looked into CPC, but I think it uses a similar method to Protothreads.
PTs (Protothreads) are used in Contiki, an embedded OS by Dunkels. I have used a spin on them (in C++) in a commercial project and it really cleaned up some code. There are various forms of PTs floating around the Internet. There are some that do not have as many restrictions as Dunkels' version. These kinds of things seem to be variations on [Duff's Device](https://en.wikipedia.org/wiki/Duff%27s_device) and there are other cool-but-a-bit-crazy things you can do as [Simon](https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html) [Tatham](https://www.chiark.greenend.org.uk/~sgtatham/mp/) points out. Tatham is the creator and maintainer of the PuTTY SSH tools for Windows.
Er... yeah. I definitely have used Valgrind to find out where errors occur. One thing I did find with Valgrind is that the behavior of threaded programs often seems to differ a lot when I run them under Valgrind vs. not. The behavior often seems more like one thread gets all the CPU and the others never get much. I suspect this is due to the slow down that Valgrind creates. Where I still use Valgrind heavily is when trying to capture problems with memory de-allocation and use after free in one of my libraries. In that case I have memory blocks (and other resources) that could be cleaned up in one of several threads and only when the timing is right do I find the bugs. So far the sanitizers either fail to catch the problem or always give a false positive. So I use both. At least for my use cases, they both provide a lot of value.
There is no single means of implementing a heap; usually they use a mix of tables, bitmaps, and/or linked lists to track allocated blocks and their sizes. However, some embedded systems just have something along the lines of extern volatile char _edata[]; static char *brk = (char *)_edata; void free(void *ptr) {(void)ptr;} void *malloc(size_t amt) { void *const ret = ptr; ptr += amt; return ptr; } void *realloc(void *ptr, size_t size) { return ptr ? NULL : malloc(size); } which uses no structures whatsoever.
The trick with fork() is that it allows you to prepare the newly created process in arbitrary ways before you execute a new program. You do this by first forking off a new process, then in the new process, you manipulate the environment as you need it and at last you call `execve` to replace the process with a new one. With the Windows API, CreateProcess() takes a gazillion arguments to capture every single way you might want to change the environment of the new process. And if there is something new, they have to change the way `CreateProcess()` works. This is fragile and complicated. With the UNIX approach, adding a new attribute to processes does not require modification of existing system call and you can use the same functions you use to set attributes normally to prepare attributes for a new process.
The language which became popular in 1990s was the language defined by that book--\*not\* the C89 Standard. The two are close, but cases where the book defined the behavior of some action and the latter characterized it as "Undefined Behavior" were generally viewed as omissions in the Standard. Unfortunately, some time after the next "official" standard (C99) came out, an attitude emerged that behaviors which had been defined by the book but not C89 were never really "defined", and that any inconsistencies between the book and the C89 Standard were a result of defects in the book.
UNIX went with `fork` because there are so many possible potential configuration options for starting a new process, even if you’re just `exec`ing after it starts. `fork` was also how you did things in parallel on UNIX before threads, and it’s still a useful way to effect a security boundary between parent and child processes; e.g., fork a child, it sets up root privilege, it does something as root, and then it exits. Or conversely, if the parent is running as root, it can fork off a child process as non-root so if it’s compromised, the effects will be contained.
Run `gcc` with option `--verbose` and it’ll show you everything it’s doing.
Thanks for this - I had never seen that "buddy" algorithm before but it seems highly intuitive. The slab concept makes sense too. I learn so many things on this subreddit.
On which line does it crash? Note that your assignments to `vx` and `vy`, within the `build_bezier_ribbon` function, will not affect the `vx` and `vy` variables you had declared earlier.
My pleasure!
See https://en.wikipedia.org/wiki/Heap_memory#Details
I've got a mix in my embedded code. I've got one set of alloc functions that just uses an RTOS queue loaded with fixed-size buffers. It takes a size parameter, but only as a safety check, and for possible future expansion to use multiple pools. When a task needs a buffer, qalloc() grabs one from the queue. qfree() puts it back on the queue. It's really handy for things like very short-term packet buffers because it can't ever get fragmented and the queue mechanism has a built-in timeout, so the qalloc() calls can block briefly without extra code on the calling side. Fragmentation and memory leaks are a major concern when a device is expected to be able to run for years without rebooting and has very little memory to spare. The fixed-size allocation doesn't prevent leaks, but it makes it obvious pretty fast when you've got one!
Of course! I have to take them in as pointer to pointer. Thanks!
(Not a data structure)
Post your full code, it's impossible for us to know where you went wrong otherwise.
Just did, thanks.
You declare your sum and product as pointers, but don't allocate them on the heap.
Change "sum" and "product" to just doubles (not pointers to doubles), and change your call to analyse to: analyse(&amp;product, &amp;sum, double1, double2); Or, alternatively, allocate space in the heap for sum and product with malloc. You're passing uninitialized pointers to your call to analyse.
Malloc worked wonders, thank you! Still, why did the second pointer work just fine even without being allocated memory first?
Thank you! That has fixed the issue.
If you're getting a segfault at the line you marked, how do you know it worked? The stack is filled with random values, BTW. "*sum" might have contained a value that just so happens to point into your address space. Doesn't mean it's "working".
What i meant by working is the error does not appear anymore and the value at the pointers addresses are successfully changed and i am able to access them with the given pointers outside of the function. Genuine question, isn't that considered as working?
I'm talking about the second pointer working.
Oh. Sorry. I know because when i swap the parameter positions of the pointers the marked line works and the one that prints the sum gets the segfault.
Right. Because you are using the same uninitialized value from the stack.
By the way, you should just write two functions, "product", and "sum", and return doubles directly from them. And avoid the pointer silliness.
The problem is on this line: &gt; int ribbon_size = 0; I'll leave why that's the problem as an exercise to the reader/OP.
Try this, it'll work: int main(void) { double double1, double2, sum, product; printf("Please enter your first number:\n"); scanf("%lf", &amp;double1); printf("Please enter your second number\n"); scanf("%lf", &amp;double2); analyse(&amp;product, &amp;sum, double1, double2); }
What's you platform? Libc? &gt; strangely enough, with the mallocs uncommented, realloc seems to fail, I get the messages on the console, but the drawing works fine! I can increase the resolution, and the curve becomes smoother... This is weird, if I'm not mistaken realloc should return the pointer back even if it didn't have to change the size of it. It only return null if it really failed or the requested size is zero. A good test would be to replace the initial malloc with a realloc and see what happens.
Thank you, but the other commenter already pointed me in the right direction. I was passing the pointers into the function, which allowed me to change the values in the list (which is why it still worked), but to change the pointer itself with realloc I had to pass them as references, receive them as pointer to pointer.
That's the solution, yes.
Which is correct, they should not be "allocated on the heap".
It's not correct, because they point nowhere. You can 1) either declare them statically, and then pass them as &amp;sum, &amp;product respectively, or 2) declare them as pointers, and then allocate them dynamically. This is C programming 101.
I've looked at a lot of C programs and wondered why they used linked lists. Then I started writing programs with linked lists, and realized the power (or convenience). Just like pointers, it's one of those things you need to get experience with before you can understand it.
The code is wrong because the pointers point nowhere, but the correct solution is not to put the pointers in the heap (i.e. allocate them dynamically), nor allocate them statically. If that seems like a good idea to you then maybe you need to retake C programming 101. [ahminus's solution](https://www.reddit.com/r/C_Programming/comments/bqb6iu/problem_with_a_pointer_as_a_function_parameter/eo2vdk2/) is a good one, where there are not even any pointer variables. I hope/suspect you actually are trying to say the pointers should be automatic and point into dynamically allocated storage. Which would be a possible correct solution, but a suboptimal one because it uses dynamic allocation where the problem can be solved just as well (in fact, better) without dynamic allocation.
https://www.memorymanagement.org/mmref/alloc.html
This is because it's undefined. &amp;#x200B; \&gt; (C11, 6.5.7p3) "If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined"
In what sense is 31 "greather than or equal to the width of the promoted left operand", when the promoted left operand has type `int` and `sizeof(int) == 4`?
During the evaluation of constant expressions by the preprocessor, "all signed integer types and all unsigned integer types act as if they have the same representation as, respectively, the types `intmax_t` and `uintmax_t` defined in the header `&lt;stdint.h&gt;`" (6.10.1/4). On your system, I suspect `sizeof(uintmax_t) == 8`.
Good point; your other comment combined with mine gives the fulls story.
Yes, except for the bit where you said "it's undefined". It isn't.
The C preprocessor is a 1-pass. SHOULD\_BE\_ZERO doesn't expand to the integer constant '0', it expands to the string constant which is bigger than zero. '((\~0U &gt;&gt; 31) &gt;&gt; 1), which is bigger than zero.
The preprocessor does all calculations using the largest integer types available[1], so in the `#if` calculation it's really doing something equivalent to ((~(uintmax_t)0U &gt;&gt; 31) &gt;&gt; 1) &gt; 0 which is true. But when the calculation is done in the `printf` line, `0U` is a normal `unsigned int`, so the value is zero. [1] From the [C11 standard](http://port70.net/~nsz/c/c11/n1570.html#6.10.1p4) (section 6.10.1 paragraph 4): &gt; For the purposes of this token conversion and evaluation, all signed integer types and all unsigned integer types act as if they have the same representation as, respectively, the types intmax_t and uintmax_t defined in the header &lt;stdint.h&gt;. Read also the [footnote 167](http://port70.net/~nsz/c/c11/n1570.html#note167) which gives an example not too dissimilar to yours -- on a machine where int is 16 bits, 0x8000 signed for the preprocessor, since it's a `long int` (or even larger type), but `unsigned int` according to the normal rules of integer constants from [section 6.4.4.1 paragraph 5](http://port70.net/~nsz/c/c11/n1570.html#6.4.4.1p5).
I see, I was looking at this problem the wrong way. Thanks for the correction.
The question is not really about what it expands to, but how the preprocessor _evaluates_ to when used within an `#if` directive. On a C implementation where `unsigned int` is 32 bits, `((~0U &gt;&gt; 31) &gt;&gt; 1)` will indeed evaluate to zero by the C compiler, but _not_ necessarily by the C preprocessor.
Better is a matter of opinion. This code looks like it's part of an academic exercise, not a NASA space shuttle. I offered the solution that would require no changes to the function call or declaration, which I figured to be more in the spirit of what OP wanted. The technically \*simpler\* solution is to use static declaration, sure, but not necessarily "better" in this context.
i better say its crash and it all because of scanf return integer .so when i put character as input ,the program crash .so to solve this i change scanf("%d") with scanf("%c") and take input as character like '1' , but now the problem is getch take only one character and the the output of '11' and '1' will be same
// if i put 11 as input output be case1:value is 1 instead of default: value is 1 //so help me to display default if i input 11 and also not letting program crash &amp;#x200B; \#include &lt;stdio.h&gt; int main() { char num; scanf("%c",&amp;num); switch(num) { case '1': printf("Case1: Value is: %c", num); break; case '2': printf("Case1: Value is: %c", num); break; case '3': printf("Case1: Value is: %c", num); break; default: printf("Default: Value is: %c", num); } return 0; }
fname in main should be longer.
How strict are your compiler settings in terms of standards compliance?
I don't really know, I use gcc on ubuntu.
&gt; string constant Wrong. No strings there.
https://stackoverflow.com/questions/288441/variable-declaration-placement-in-c Turns out that in straight C98, you must declare all variables at the start of a scope block. You can initialize them whenever, but the declarations need to be "hoisted" to the top of the scope. I _think_ this is what's happening to you, but without compiler flags etc it's honestly just a guess at this point :)
You are using the * operator on an uninitialised pointer, that’s why you are getting the seg fault error. When you use *product and *sum in the function they aren’t pointing to anything. Instead of using a malloc like the other guy said I’d opt for a more clear and easier solution... change the type of sum and product to doubles (not double pointers) and pass their address with &amp; when passing them as arguments in the function call
Char c1 is problem, you must declare variables at the top just under main function.
1) All caps title are considered clickbait junk 2) Learn to use google 3) The answer is `strtok`
1) Don't link to question. Ask questions. 2) Provide **formatted* code 3) /r/titlegore
&gt;I guess it's theoretically possible to create some Rube Goldberg-ian bug that ends up making unintentional syscalls that do stuff A classic: `while (1) fork();` A favourite of mine: `while (1) kill(rand(), SIGSEGV);`
k
&gt; It creates a new task (or whatever the kernel calls processes at that level) with the same memory map as the first. From the program's point of view, it creates a new process with a deep copy of the parent process's memory space and a shallow copy of the parent process's descriptor space. &gt; A forked process does have its own memory, the actual fork system call achieves this by copying the descriptor tables Be careful with the word “descriptor”. In Unix terminology, it has a very precise meaning which is completely different from what you're using it for here. Do you mean “page table”? Finally, you forgot a very important point about `fork()`. The OP assumes that the only purpose for creating a new process is to start a new program, but `fork()` is often used to implement “heavy threads” where the child performs a task for the parent that involves operations which would be disruptive if performed in the parent (e.g. switching credentials) or which would expose the parent to risk (e.g. communicating with an untrusted party).
Part of the problem is that the solution you suggest is *more* complicated, not less, than the obvious alternative of defining `double1` and `double2` as `double` rather than as pointers. The second part of the problem is that you talk about “allocating the pointers on the heap”, but the pointers already exist. What needs to be allocated is memory for the numbers, which the pointers can then point to. The third is that you do not seem to have a good grasp of the difference between static, automatic and dynamic storage. I can assure you that automatic variables are covered in every introductory C course; in fact, I would expect to encounter them in the very first chapter or lecture, although possibly not under that name.
You should use `poll()` instead of `select()`. For bonus points, you should check how much time actually elapsed and adjust the timeout accordingly so you don't perform your periodic task unless at least one second has actually passed since the last time.
How do you invoke the compiler?
Not in C99 or newer, and that is not the error gcc would give for that.
That is not the error message gcc would give for that.
Finding out those details is what the manual is for. I don't have that in my head so to answer it I have to look at the manual as well. Here's the POSIX manual page: [https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html#tag\_16\_645\_04](https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html#tag_16_645_04) It says: \&gt; If *waitpid*() was invoked with WNOHANG set in *options*, it has at least one child process specified by *pid* for which *status* is not available, and *status* is not available for any process specified by *pid*, 0 is returned. &amp;#x200B; So you don't call waitpid 4 times, you call it until it returns 0 (or if an error occurs it might also return -1). Once 0 is returned, there's no more children to report status for at that point of time.
Instead of internal look try to used printf format where you can dynamically specify the width of the string. this will only work if padding char is space. Exampe. printf("%s%\*s", border\_char, width, border\_char);
Yeah I'd like to provide formatted code but I hesitated to put all my code since I don't think anyone would like to read it. so I kinda gave people a choice to look at my code or not through my link. Would you be kind to read my messy code if I post them? 😅 annnnd I don't know why you think my title is cringe? 🤷‍♀️
thank you! that really helped. really appreciated.
Show us your code.
Have you tried doing your homework yourself? If you have concrete questions, feel free to ask. But do not just dump your assignment here.
Any other warnings/errors? Could there be a crazy macro that garbles token "char" ? Can you see the program after it's been thru cpp?
I've used sqlite before and it works quite well [https://sqlite.org/capi3ref.html](https://sqlite.org/capi3ref.html)
That's not a script, it's a program.
I find it interesting that both you and /u/moefh responded within a minute of each other and each referenced the same section in the C11 standard, bravo! For some reason I assumed that the preprocessor and compiler handle expressions in the same way. Follow-up question(s) if that is fine by you. Do you think this equally applies to C89/C90? Because I notice that the standard references uintmax\_t/intmax\_t in &lt;stdint.h&gt;, which wouldn't be required on a C89 conforming system. I'm assuming that instead of e.g. uintmax\_t it would be unsigned long? Also, if what you say is true, then what about systems that define UINT\_MAX in &lt;limits.h&gt; to be (\~0U)? My current system defines it as 0xffffffff, but I've seen systems before that define it as (\~0U), and then INT\_MAX is (UINT\_MAX/2) and INT\_MIN is (-INT\_MAX-1). These would all be interpreted correctly by the compiler, but they wouldn't play nicely with the preprocessor. So I suspect these systems I worked with may not have been fully standards conforming.
Show us the full code. Compiler says there's a problem in lines 61-63 and your code is only ~20 lines long. There's probably some other issue.
Good luck, have fun 👌
The code in the Stack Overflow link write a struct to a file. You can use `fread()` to read the file by reading the data into an array of structs. Be aware that if your program changes any of the data, you will need to overwrite or create a new data file. [This webpage](http://faculty.winthrop.edu/dannellys/csci325/03_record_IO.htm) should get you started.
[phkmalloc](http://phk.freebsd.dk/pubs/malloc.pdf) Older malloc implementation used in BSDs in late 90s and early 00s, which is not suitable anymore because it does not scale with large memories and it uses only single lock.
I don't understand your question, but if you were suppose to copy a string from X to Y using malloc then you'd want to do something like: char* cpystr(char* input) { char* ret = malloc(strlen(input) + 1); strcpy(ret, input); return ret; }
You're not giving enough information for either. For the first one, just malloc, then strcpy. For the second... Provide full code with a description that makes sense.
A text file is for storing textual data in lines. If you open a file as text, the C standard library translates the host's convention of representing lines of text into lines separated by `\n` for you and back. You may not write NUL bytes into text files. You should use `fgetpos` and `fsetpos` to navigate through text files. Binary files do not have this translation but also do not have any restrictions. You can use `ftello` and `fseeko` to navigate through them.
In binary mode, you read the bytes as they are, but in non-binary ("text") mode, some conversion of characters might happen behind the scenes. The prime example is line breaks. On Windows/DOS a newline is represented by both LF (linefeed) and CR (carriage return), while on *nix systems only LF is used, and on older Macs, only CR was used. Opening a file in text mode makes it so that line breaks are converted to `'\n' `, regardless of system-specific representation. Opening in binary mode will leave everything precisely as it was on disk, so that a newline on Windows is two characters, for example.
Break out the entire problem into discrete tasks. Be specific. If certain tasks rely on other tasks, you now have an order of what you need to do. Once you have your list of tasks, start coding then testing each one before moving onto the next. A task can be something like: "prompt the user for input", "store user input in local variable", "open filename X for writing", "write X to file Y" etc. Also, read this: https://idownvotedbecau.se/noattempt/
problem 1 is to receive an input string from user of dynamic length. then that string is to be pointed by a pointer variable of type char.
Will strcpy add the nul terminator?
`man strcpy` says yes.
&gt; I'm assuming that instead of e.g. uintmax_t it would be unsigned long? Yes, under C89 the preprocessor uses the types are `unsigned long` and `long`. &gt; Also, if what you say is true, then what about systems that define UINT_MAX in &lt;limits.h&gt; to be (~0U)? My current system defines it as 0xffffffff, but I've seen systems before that define it as (~0U), and then INT_MAX is (UINT_MAX/2) and INT_MIN is (-INT_MAX-1). These would all be interpreted correctly by the compiler, but they wouldn't be evaluated correctly by the preprocessor. Does this mean the system was probably not standards conforming? There's no requirement that the compiler and the preprocessor evaluate a constant expression to the same value.
Yup of course, all string functions are based upon it.
It really depends on your application. The biggest advantages of linked lists are their O(1) splice/join and their simple implementation. But otherwise they are space inefficient and slow, and most linked list implementations out in the wild are notoriously memory unsafe.
Most by deployment or most as written? Postgresql internals are permeated with linked lists. As seen here, malloc implementations use them. Linux kernel has a unified linked list implementation for dozens of internal modules to use. But yes, simple to understand, somewhat less to implement in a bulletproof fashion, but is a central underpinning of computing.
Most by deployment or most as written? Postgresql internals are permeated with linked lists. As seen here, malloc implementations use them. Linux kernel has a unified linked list implementation for dozens of internal modules to use. But yes, simple to understand, somewhat less to implement in a bulletproof fashion, but is a central underpinning of computing.
&gt; First odd thing is it's frequently claimed that it's used to create new processes, and it is like Windows' CreateProcess(). This is clearly not true since it takes no parameters and returns nothing other than an integer. It does not create new processes, it's not true! It's BULLSHIT it does not create procceses. It does *nawwwt*. Oh, hi, manpage.
What do you mean by “recall”? SQL is a query language, i.e. a language for formulating a question which a database system answers by looking up and cross-referencing data that it has previously stored and indexed in a specific way to facilitate efficient lookup and cross-referencing. There are many different database systems which support SQL, and some (like SQLite) are embeddable and server-free, so you wouldn't have to use a separate program. You could even write your own, although that would probably be far outside the scope of your assignment. But ultimately, I suspect that all you are expected to do is read back data which you previously wrote to a file so you can continue where you left off. That should be pretty easy if you picked a sensible file format. A good start would be to take the same code that you use to write the file, change the `fopen()` call so it opens the file for reading instead of writing, then change `fwrite()` or `fprintf()` to `fread()` or `fscanf()` (be careful with format strings and argument types). The first iteration probably won't work, but keep tuning it and you'll figure it out. You'll probably have to tune the the code that writes the file to make reading it back easier, but that's all part of the process.
text mode appends a newline at the end. that's it.
Check your environment's documentation for `realloc()`.
This is a general programming question that, while can be solved by applying C techniques, is better left to other environments and solutions. This has nothing to do here.
They don't know in advance how long the string will be.
Not really. This is one of the parts in C where implementation differs on the platform you're working with. /u/gastropner explained it well.
&gt; , and on older Macs, only CR was used. Pretty sure all macs (even new ones) still do this, as do all other *nix systems
So C isn't the right programming language for this? I can imagine the timers would be difficult to deal with. I have no knowledge of what you can bring into a C environment. I'm slightly more familiar with Python. I actually hoped it'd be a little simple.
And why do you want to do this in C? Python is much more suited for this type of application.
Well, you're not wrong, but... What's the problem? This is a C programming subreddit, not a scripting subreddit.
What you're talking about is product management. You have the vision for a product, and you're listing out a userflow and a bunch of features. What you're looking for is a developer who can build you what you're looking for, and decide the best way to do it. Neither are on-topic for this sub. Furthermore, I don't think you'll have much luck finding a developer who wants to build you your product. What you're talking about is small-potatoes personal project. We all have plenty of our own small-potatoes personal projects on the backlog. This is a good project for you to go build yourself. You'll learn a lot from it... or you'll give up and decide coding isn't right for you.