 His Frame pointer was in a different thread...
Also the `strcpy` allows a potential stack overflow exploit if you pass an `argv[1]` whose length is &gt;254. …Not sure why you did that anyway; you’d maybe want to `str`[`n`]`cpy` (after checking length or with an explicit NUL termination!) if you needed to alter the string’s value, but if you’re just reading from it it’s already there in `argv[1]`. (Hell, if you’re shortening it even, you can do it in-place within `argv`, though that’s bad juju.) Try [`strtoul`](https://linux.die.net/man/3/strtoul) instead of `isdigit`: unsigned long num; pid_t pid; char *p; num = strtoul(argv[1], &amp;p); // Note: `p` now points either to terminal NUL or garbage. pid = num; if(!*argv[1] // “Empty number?” (Would false-negative the next check) || *p // Garbage at `p`? || pid &lt; 0 // Bogus conversion to PID || (unsigned long)pid != num) // ditto { fputs("error: invalid PID\n", stderr); return 1; }
Again in my pseudo code, which I laid out in the beginning. #import io = stdio(Version 1.01).printf; Is that still not covering what you are saying? I never said anything about auto updating.
Perhaps I don't. Do you advocate some sort of tight coupling to specific dependency versions? That's horrible!
[x86 is a high-level language](http://blog.erratasec.com/2015/03/x86-is-high-level-language.html)
There is tight coupling of dependencies when you change the api. I'm arguing that it would be great if that hard problem was handled in a great way. Certainly you wouldn't have to define a tight dependency, but if you didn't you would introduce breaks on changes. But if you wrote and maintained your library in a smart way, I'd use it. If you wrote sloppy dependencies it wouldn't help much. It is exactly the same now, except many projects use a variety of build tools. So we have a problem of integrating other projects without understanding their dependencies, their dependency dependencies, and splitting out their compile tool into our build system. There is a reason we have different package managers and multiple build systems. Or would you argue further fragmentation helps interoperability?
Also in my argument I mentioned builtin build system, same language for runtime as compile time. One of the major benefits of this is compile time introspection. If (io.version &lt;= 1.6.01) { // handle complexity } else .... 
I want to be able to not break the API. I don't care about features that make breaking the API more comfortable. I must not break the API. Anything else is inacceptable.
This looks comfortable at first until you realize that you really don't want to version your whole API because there can be multiple vendors implementing the same API. So really, you want versioning for every single symbol (as ELF does) and there the whole clusterfuck begins.
Sure, it may "technically" be a high level language but that's just being pedantic.
I mean it sounds like we're arguing for the same thing. I'm not arguing I have the best answer, I'm saying this is a real hard problem. So given a magic wand, I'd like it fixed. Why waste my wish on generics. Unless you're arguing that multiple ways of handling this problem is more interoperable. 2 package managers, 2 build tools? 3, 4 idk? But I think 1 builtin would be the most optimal number.
When benchmark results don't have a standard deviation column you can expect bad statistics. They ran the tests 10 times. Run something that takes a second to execute 10 times on your computer. Wait half an hour and do it again and see what happens. That's not nearly enough, specially with execution times that low (the tables are in miliseconds). And they arbitrarily removed "the furthest outliers", without quantifying how many were removed in each test. Moreover I don't see any appendix with the standard deviations as the paper claims. And unless I'm mistaken they did not randomize the tests - running mandelbrot.c 10 times in a row yields completely different results than running mandelbrot.c interleaved with fasta.c, etc. These results are short of meaningless.
The paper appendix url points to the link I posted. Under [2]Complete set of results, they have the data you ask. Finally, the right most tables under Results - A. Data Tables contain the standard deviation and average values for our measured CPU, DRAM, and Time, allowing us to understand the variance. In mathematical terms, x̄ is average and σ is the std. dev. 
Thanks, I only saw the paper. 
The direction you write bits from, which bit (the leftmost or rightmost) is considered the least significant bit... SPI (used in SD Cards) is most significant bit first. so yeah go right ahead and get the snark outta your post, and take a look around the world and realize some people know things you don't and that you're not the arbitrator of whats true in the world.
You're trying to access memory you don't have permission too. Use a tool like valgrind or gdb to find out where. $ gcc -g -o mergetest mergetest.c $ valgrind ./mergetest 
Thanks but I figured out the issue. %d to %f solved it
Try to get rid of: condition ? option1 : option2 You may see the code better. I think the issue may be on the line of malloc
You allocate/free a buffer on each merge. Maybe you don't care, but this can be implemented allocating only a single buffer that's half the size of the array being sorted. 
yeah i was going to say that being 'one of the most' of something could actually mean the least of said thing.
You can use [conan](https://conan.io) for it: - It is OSS, MIT license, with a big community behind: github.com/conan-io/conan - It includes an OSS server that can store packages recipes and pre-compiled binaries - It has first class Windows support, with support for CMake, but also direct for Visual Studio: http://docs.conan.io/en/latest/integrations.html, and other build systems. It can also be extended for other build systems - It can do cross-compiling well too: http://docs.conan.io/en/latest/howtos/cross_building.html - It is used in production by many companies, here an example: http://blog.conan.io/2016/10/24/conan-at-work.html
RPM is a system package manager, it works brilliantly, as well as other system package managers like deb packages, homebrew for OSX. If you are looking for a language-package manager, something that typically can handle dependencies per project, being able to use different versions in different projects without polluting the system, and that you can easily create and host your own packages even privately, you might want to know : Biicode is dead, closed from a long time ago and unmaintained For hunter, clib, conan, buckaroo, cget, etc. I am not going to say my opinion (disclaimer, I am maintainer of conan, so I am biased), just enumerate the things that are important to me, and I usually check in tools before deciding: - The community and popularity: as they are all OSS projects, this can easily be checked as github stars. It is maintained, how often they release? How many core maintainers? How many contributors to the codebase? - The supported platforms: does it run on the systems that I am interested? Does it work well with my tools? Check the integrations described in the tood docs. For a C package manager it is important to get support for your build systems. - The list of features, and the UI. For a C package manager, you might be interested in a package manager able to manage binaries, or not really because you will always build always from sources. Cross-compiling? Version management and conflict resolutions? - The status of the tool: Is it production ready? Is it an alpha, beta? are there companies using it? 
http://blog.biicode.com/ biicode is quite dead
oh, TIL
That's not an attribute of the platform, that's an attribute of a specific transport protocol which the C standard doesn't know about. So no, it doesn't make sense to specify this.
Get yourself a good tutorial.
I am flowing à udemy cours :)
Works for me with gcc on linux x86-64. That weird formatting makes it look as if the code is okay, but your `main` function is ending before the `printf` statement due to an extra closing brace. I removed that, and it prints `10 11`.
I was surprised that Rust beat C in some samples, like *k-nucleotide*, so I checked out the implementation. For *k-nucleotide* ([here](http://benchmarksgame.alioth.debian.org/u64q/knucleotide-description.html#knucleotide)), it's basically a measurement how fast your languages hash table implementation is. Since C doesn't have one built in, the rules state that it must use a library. IMHO if you're writing performance-critical C you're going to want to write a custom hash table exactly tuned to your needs, and disallowing that is somewhat arbitrary. Requiring the use of a library also adds function call overhead and such, which is a little unfair.
Thanks for your really helpful answer ! I am going to look more deeply into both RPM and Conan :)
Stackoverflow recommends MinGW, although that's going to be separate from your IDE: https://stackoverflow.com/questions/116368/c-compiler-for-windows
is there any way I can get a compiler that will let me work on the VSC IDE?
I am assuming you are running Windows. The Microsoft c/c++ compiler should come with visual studio. You may need to add it as a package to your current visual studio install. For the newer versions you are expected to do that in visual studio itself. There isn't really an easy way to get the Microsoft compiler and linker by themselves. 
You are dividing by zero here: if (N/sum == 0){
Yeah,Windows
wat
the CodeRunner extension might be a good way to go: https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner *disclaimer: I'm on Linux and generally have no idea what I'm talking about so ymmv*
Notepad++ is a good general text editor on Windows. Notepad++ and mingw is a decent start. Though quickly you'll want packagement of libs and at that point, every Linux (or BSD) is a better place to be.
Nope. When execution reaches that `if` statement, `sum` is `1`. Actually I have no idea what OP's trying to do. That `if` statement checks whether `N` is 0, which is not possible because he initializes it to 10 and doesn't touch it again.
Except it has to be the compiler to specify this because it knows the target's byte and bit order that it's compiling for. the macros only specify the current host's byte and bit order.
Processors do not have a bit order! Bytes are the least addressable unit, there is nothing like a bit order in processors as far as C is concerned. 
Oh, I didn’t see that while there because of the non existent indentation… Also that program doesn’t even compile because there is a stray } before the last printf.
YOU HEARD HIM! &gt;I am flowing à udemy cours
Beats me. There are no floating points in your program.
Ok, yes, I agree with that, and that's how I do things. (And just to be clear, I *never* just cast a blob of data received into a struct, or vice versa, that's just asking for trouble.) I can't shake, then, that the bsd sockets api is doing it *wrong*. At least for their `struct sockaddr` stuff, they are forcing you to fill in a struct with a specific endian-ness. Granted they give you helper functions to (possibly) swap it appropriately, but I feel like that should be taken care of at a lower level and the whole `htns()` thing was the wrong way to go about it. History probably has an explanation... PS: Sorry about the downvotes, wasn't me.
Yes, the BSD API is wrong and inspired generations of programmers to do it just as wrong. See Plan 9's `dial()` for how to do it right.
Visual Studio comes with a C compiler.
The course uses clang in a web IDE. They also use a [C library](https://github.com/cs50/libcs50) they developed, mostly for strings and user input. I would guess that libcs50 uses standard C and should work on Windows. Here is [stackexchange](https://cs50.stackexchange.com/questions/2872/problem-including-cs50-h-with-visual-studio-2013) with more information.
I don't see a problem in using a library, as both C and Rust use the same hashing function `x ^ x &gt;&gt; 7`. But your point about call overhead is valid, rust inlines everything that's possible (because it compiles everything at once), while C must use linked libraries (and I think the example was compiled without link-time optimizations). However it's worth to point out the compile times: Rust: 11.10s C: 0.41s
Thank you all guys. I just retyped everything and it worked. Pretty weird.
Well, you've still got stuff like how many buckets you need, or whether to preallocate some space inside them. Then there's often space/time tradeoffs like having flags as chars instead of bits; stuff like that. &gt; However it's worth to point out the compile times: Yeah, compiling rust is *slow*. I've developed a habit of writing C and then recompiling the entire unit for every line I edit, as a lazy way of catching mistakes and correcting warnings early. Since it's so fast it works quite well. With rust, that's not really practical – I found that pretty annoying when toying around with it.
For me download netbeans ide it have c/c++ plugin
I will check it out, thanks!
I have NetBeans siting on my machine here. Didn't know it has support for C. I basically consider it as java environment. 
Actually i am a terminal user now but when i had new to programming i was using netbeans for c programming.
Download the Visual Studio 2017 Community edition from here. https://www.visualstudio.com/vs/community/
MinGW afaik hasn't been updated in ages, and it needs to be the x64 variant anyway.
A naïve (and maybe not applying) solution could be to use an older C standard, like C99. This can be passed to gcc as '-std=c99' and would thus work on any GCC in which this standard is included. I don't know if that's actually a viable solution, but it might be worth a try :)
This should be good enough, compiling against a particular standard shouldn't change over time (as it's a standard!).
A few alternatives: 1. Build GCC 4.1.2 from sources on your computer. 2. Probably the easiest solution, install CentOS 5.7 which has GCC 4.1.2 as the default GCC. You can install it in VirtualBox or Vmware. Here is a link to the iso images for CentOS http://vault.centos.org/5.7/isos/ . There are already build VirtualBox images for CentOS 5.7 here https://virtualboxes.org/images/centos/ 
They're not a native English speaker.
You could switch to visual studio community if visual studio code doesn't have the vc++ compiler. Otherwise i recommend compiling via the commindline with mingw.
[what you seek](http://www.zombo.com/)
Tips for C programming 
If you listen to the whole thing it applies to C. 
Are you sure those (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42) are the first 20 elements of this series? According to the example with 1729, none of these seem to apply. E.g. 27 -&gt; 2+7 = 9 and 9×9 is 81, not 27. I don't understand the task. But regardless of what the first 20 entries are and going by the example of 1729 - with a blunt approach - I'd turn the numbers into string, then play with them to construct each element of the series and stop at the nth element.
[crosstool-NG](http://crosstool-ng.github.io/) is a great tool to build diverse compiler toolchains, including cross-compilers and older compilers, even if for your native architecture. You might want to check it out and compile your gcc 4.1.2 with it.
This is the simplest solution and should be good enough. The only thing to watch out for would possibly be using C99 features that may not have been implemented as of 4.1.2 or have changed since 4.1.2. However, there appear to be very few of these [according to this table](https://gcc.gnu.org/c99status.html). 
[proper indentation and a decent editor help avoid this kind of thing](https://i.imgur.com/go0x23U.jpg)
GNU style brackets are awful
 %macro macro_name number_of_params &lt;macro body&gt; %endmacro How high?
Why don't you just `ssh` onto the school servers and work on your projects remotely? Then you can use the environment they use. 
Not a helpful response here, but I am dumbfounded why schools wouldn't want to be at least somewhat on a newer side of things when teaching something like programming. I don't get what teaching someone like that would gain.
good Point
Oh my good lord. If you write the number 91 with bit0 being on the right side aka least significant bit, you'd write that number as 0x5B. For bytes that are written with the bit0 on the left aka most significant first aka bit7 in LSB, you'd have to write it as 0xDA And it absolutely matters when you're writing with sub-byte precision. And yes there is for exchanging information. Did you miss the IO library thing?
You could also use c89 by that way (ansi89 ?)
&gt; Are you sure those (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42) are the first 20 elements of this series? According to the example with 1729, none of these seem to apply. E.g. 27 -&gt; 2+7 = 9 and 9×9 is 81, not 27. I don't understand the task. OP unfortunately chose a bad example of a harshad number. It's required only that the number be divisible by the sum of its digits. So for the example given, 1 + 7 + 2 + 9 = 19 and 19 ∣ 1729. {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42} are the first twenty harshad numbers in base 10. Incidentally, there are only three such harshad numbers &gt; 1 with the stricter property you have in mind: 81: 8 + 1 = 9; 81 = 9 x 9 1458: 1 + 4 + 5 + 8 = 18; 1458 = 18 * 81 1729: 1 + 7 + 2 + 9 = 19; 1729 = 19 * 91
But not Visual Studio Code.
Thanks. I did that for a whole semester, but I wanted to use an IDE like netbeans this time instead of something like nano or vim. 
Many thanks. I think that will do the trick :)
Many thanks sir!
It's easier for professors to force students to use the outdated things they're used to, rather than update their classes for the sake of the students
I use the latter.
The CS50 IDE is also available as a download for [off-line use](https://manual.cs50.net/ide/offline). 
I tried it earlier on as it requires Docker which is available only for 64 bit machines. Mine is 32 bit. But I'll look into the setups once more in case had miss anything.
 for (;;) printf("does it look like I care? ;-P\n");
Just double-checked and it only runs on 64-bit machines. As /u/MR2rick said, the library is available [here](https://github.com/cs50/libcs50). IIRC,VS wasn't setup for C but you can compile it using the C++ compiler by simply using a .c extension, but you lose a lot of support. Also you can use [the command line](https://msdn.microsoft.com/en-us/library/bb384838.aspx). [Here](https://www.reddit.com/r/C_Programming/comments/5s129a/which_is_the_best_ide_for_c_programming_and_their/) is a discussion on IDE's for C. Are you against using Linux?
Either roll your own data structure or look at something like sys/queue.h on POSIX machines, I'm sure you could adapt something using that framework
[CS50](https://www.edx.org/course/introduction-computer-science-harvardx-cs50x). 
Until you show an attempt, nobody is going to help you. Give it a solid effort, come back and post your code with some specific questions. 
Not at all. Am just falsely stuck to use Windows at the moment 
Out of curiosity, why can't you use the online IDE? Will you not have Internet access? 
argv is an array of char pointers. He's ok on that.
I have internet access. fact is, I used the online IDE few hours ago. Am looking for offline compiler because I plan on going deep into the C families even after the whole CS50 show's over and having and knowing how to set it up would be part of the experience. 
What TheGrandSchlonging said is what I meant. Sorry for the bad example.. 
&gt; Did you miss the IO library thing? No I did not. However, the bit order is a property of the line protocol or controller you use, not of the CPU or ISA. The smallest quantity the CPU can manipulate is the byte. If a peripheral (e.g. an I²C controller) sends the bits of a byte in a certain order, that's a property of that peripheral, not of the CPU. The C compiler can't possibly know the conventions of every single peripheral and the conventions might differ between peripherals on the same CPU. The C language doesn't care about peripherals, that's your job. &gt; If you write the number 91 with bit0 being on the right side aka least significant bit, you'd write that number as 0x5B. &gt; &gt; For bytes that are written with the bit0 on the left aka most significant first aka bit7 in LSB, you'd have to write it as 0xDA In C, 91 is always written as `0x5B` to memory because these two are literally the same number. This is because the C language has the byte as the least addressable unit. C could be implemented on a base-256 computer and it would work exactly the same way. If your compiler writes 91 as `0xDA` to RAM, it is a broken compiler. Show me some code where a difference can be observed that doesn't use non-standard features and we can talk.
But I didn't really understand your approach. Could you be more specific? Or you notice any error in my coding? Probably easier to solve the problem. I am new to programming so I only know really basic stuff so far. Thanks.
`sys/queue.h` implements a macro set for linked lists, not priority queues.
What operations do you need to perform? What runtime complexity do you need? Try and implement binary heaps, they are pretty simple and usually good enough.
Is this the real code you're running? printf('\r'); should be printf("\r"); Otherwise it can segfault and won't do what you expect anyway. Also, the "%ld", fed with something which is not a `long`, may print anything and not the expected value. 
Printing a carriage-return character does not clear the current line, it merely positions the cursor back at the beginning. When output goes to a terminal, you can then overwrite the current line with blanks to erase it. So, to correct your code, you might need to do something like this: printf("\r \r"); fflush(stdout); Note further that you passed `'\r'` to `printf`, this is wrong and likely causes your program to crash. String literals are in double quotes, like `"\r"`.
You could maybe `sshfs` the project. :-)
Thanks for the help now i know where i was going wrong.thanks again.
Learn English first.
Pro tip: learning english helps very much: * makes it easier to memorise keywords * makes it easier to read comments * makes it easier to get answers when asking for help * makes it easier for people not to hate you at first sight
Obvious troll is obvious.
There is `cargo check` in Rust which will type check without compiling and it is much faster.
I've never seen the explicit '&amp;' used in any production code. Generally, with well written code it's easy to see that you are dealing with a function and the '&amp;' would just clutter things up unnecessarily.
wat u said?
frien sorry.. im from bangladesh..we dnt spik english here bt i try frien..can u answer my question nw frien pls?
I suspect you of trolling because your spelling is wrong in a way that I can only assume is intentional. Please try to use normal English spelling or it will be hard for us to give you good answerrs.
sry frien my english is coma, apology my english frien...me from bangladesh frien..cn u answer my Q nw frien?
i normal y u think i abnormal? i hd ques if u cnt answer ok dnt call me abnormal, bye...i don liek such ppl...bye
Even as a professor though, you'd think you'd want to be on the edge of learning. I suppose it depends on the overall attitudes of everyone involved in department.
Is it impossible for you to use normal spelling? For example, your comment in normal spelling (without the grammatical errors fixed) would be: &gt; I normal why you think I abnormal? I had question if you can't answer ok, don't call me abnormal, bye... I don't like such people... bye
What language features are you using that GCC 4 isn't good enough? In an odd way, this is a good exercise. The take-away here is that you should always code for the most ancient compiler, the most ancient operating system, and the slowest computer you want your code to run on. When you use the latest features, you're in effect saying "I want this to run on as few customer machines as possible."
IMO not only are they equivalent but there is no reason to prefer one over the other, for readability purposes. 
&gt; …with execution times that low (the tables are in miliseconds) The fact that "the tables are in milliseconds" does not tell us that the execution times are low.
This definitely has to be done in C, not C++? It's pretty straightforward in C++.
sorry, C++!
I'm assuming here that 'n' is some global variable whose declaration is not included in the source you posted? I added it in my own code... After running this, all that happens is that I enter a value and then it sits there. Let's see why: So I enter a number, say 15, into the program. We enter the first while loop. At this point, i == 1 and n == 15. So the loop begins. We then enter the second while loop. At this point, (t != 0) is true, so that loop also begins. remainder is assigned the value of t % 10. Since t == 1, remainder now == 1. Then sum is set to itself + remainder. sum was 0, now sum == 1. t is assigned the value of itself divided by 10. Since t &lt; 10 and we're dealing with ints, that value becomes 0. The loop ends, and it does not loop through a second time because (t != 0) is now false. Now we check our if() statement. N == 1. sum == 1. N/sum == 1. So the if() statement is false, therefore we do whatever is in our else{}. N is incremented by 1. The while() loop ends, so we check the condition again. i&lt;=n is still true, so we go back to the loop. t is still == 0, so we skip the second while() loop. for the if() statement, the result of the test is now 2 because we incremented N, so that is still false. N is incremented again. The while loop ends. This continues forever until N increments to a point where it loops around via overflow and reaches a value of 0. At that point, the if() statement becomes true, so we then increment i as well as N. Depending on your CPU and the number you entered, this will take quite a while to happen. Here's my heavily commented correction: https://pastebin.com/wwS8z7FB And here's a version without any of the comments so you can see it more clearly: https://pastebin.com/GvcgYr3K IMPORTANT NOTE!!!! This is not actually the correct code for your assignment. The number you input is not the number of elements in the series. Rather, it will just display the raw numbers from 1 up to whatever you input. IE if you enter '20', it will only check up to the value of 20 and it will not list 20 elements. You will have to do some significant modification to get the desired result, as I did not want to do your assignment for you entirely. I just wanted to give you some pointers on your code. The thing you'll have to 'fix' in this code is to have the user enter the number of elements, then do what you were doing before: Increment some counters. However, you will ALWAYS be incrementing one counter, and only increment the other when you have a 'hit' in your if() statement. There is still no need for an else() statement. I suggest your new counting variable(s) also have more descriptive names so you'll know exactly which one needs to be incremented at which time, and so that other people reading your code will be able to see more easily exactly what you're using them for.
dude, you deleted the other thread and reposted the same question. Don't do that. I replied to your post and it was deleted like 10 seconds later. I will repost my previous reply: I'm assuming here that 'n' is some global variable whose declaration is not included in the source you posted? I added it in my own code... After running this, all that happens is that I enter a value and then it sits there. Let's see why: So I enter a number, say 15, into the program. We enter the first while loop. At this point, i == 1 and n == 15. So the loop begins. We then enter the second while loop. At this point, (t != 0) is true, so that loop also begins. remainder is assigned the value of t % 10. Since t == 1, remainder now == 1. Then sum is set to itself + remainder. sum was 0, now sum == 1. t is assigned the value of itself divided by 10. Since t &lt; 10 and we're dealing with ints, that value becomes 0. The loop ends, and it does not loop through a second time because (t != 0) is now false. Now we check our if() statement. N == 1. sum == 1. N/sum == 1. So the if() statement is false, therefore we do whatever is in our else{}. N is incremented by 1. The while() loop ends, so we check the condition again. i&lt;=n is still true, so we go back to the loop. t is still == 0, so we skip the second while() loop. for the if() statement, the result of the test is now 2 because we incremented N, so that is still false. N is incremented again. The while loop ends. This continues forever until N increments to a point where it loops around via overflow and reaches a value of 0. At that point, the if() statement becomes true, so we then increment i as well as N. Depending on your CPU and the number you entered, this will take quite a while to happen. Here's my heavily commented correction: https://pastebin.com/wwS8z7FB And here's a version without any of the comments so you can see it more clearly: https://pastebin.com/GvcgYr3K IMPORTANT NOTE!!!! This is not actually the correct code for your assignment. The number you input is not the number of elements in the series. Rather, it will just display the raw numbers from 1 up to whatever you input. IE if you enter '20', it will only check up to the value of 20 and it will not list 20 elements. You will have to do some significant modification to get the desired result, as I did not want to do your assignment for you entirely. I just wanted to give you some pointers on your code. (EDIT: actually I was confused about the assignment, so I did actually think I was doing your assignment for you, but after rereading I realized I was incorrect. My confused statements in my comments reveal my confusion :P I *thought* I was doing your assignment for you, but it turns out I wasn't, which is a relief to me) The thing you'll have to 'fix' in this code is to have the user enter the number of elements, then do what you were doing before: Increment some counters. However, you will ALWAYS be incrementing one counter, and only increment the other when you have a 'hit' in your if() statement. There is still no need for an else() statement. I suggest your new counting variable(s) also have more descriptive names so you'll know exactly which one needs to be incremented at which time, and so that other people reading your code will be able to see more easily exactly what you're using them for.
what the fuck is this post? I'm not even gonna waste my time trying to compensate for your laziness.
Shit, that's still not right. &gt; I'm normal, what makes you think I'm not? if you can't answer my question that's ok but don't call me weird.
I have intentionally not fixed the grammatical errors.
&gt; functions decay to pointers implicitly like arrays do, so the &amp; operator is optional. The &amp; operator actually inhibits the decay of a function designator. It's one of three scenarios in which this inhibition occurs. The other two scenarios (sizeof, C11 _Alignof) lead to constraint violations. The special-casing aspect of &amp; may influence your style decision. Another thing that may influence your style decision is the form you use to invoke the function via the function pointer. Ultimately, these are highly subjective considerations.
Your troll spelling needs to be more consistent. You struggle with basic three-letter words but easily manage 'apology', 'mastering', 'answer', 'abnormal', 'question'. 'starting' and 'strted' 'sum' and 'sm' 'sorry' and 'sry' 'dnt' and 'don' 'cn' and 'can' 
ok i keep in mind wat u say frien. M sorry if i wrong.
i want code advies M sorry if i say it wrong.
i not lazy frien...i was type from mobile frien...so i was type short frien can u help me frien?
So you don't want to spend enough time using proper spelling but you expect us to invest time giving you an answer? What a lack of respect!
:'( u all hate me ..M sorry if i wrong..i try code good...bye every1 hate me here no help.
Nope. I don't think so.
Hello Squiggly_P! I was surprised by how much efforts you put in to help me out. A huge thanks! I figured out the mistakes I made in my coding from you going though the code. It really helped! The tips as well! And sorry I deleted your comment with the post. I did not see it and I thought other people will not look at my question if there are comments already and I really wanted to solve it as soon as possible xd but wont do that again :)
What have you done so far?
Absolutely nothing idk even know why I thought I could do computer programming 
Wait does C even have classes...? Did you mean C++? And if that's how you feel it might be wise to drop the class tbh. You'll probably just be setting yourself up for more pain in future assignments 
Idk than I won't get any credits
Are you sure it is C and not C++ or C#?
Oh whoops wrong sub Reddit 
No problem, glad to help.
Thanks, so i only need to worry about the order of the bits when I write them and not on the decode side?
You can implement a custom comparator for the container that compares the first elements. Note that for STL ordered containers (set and map) you are not allowed to modify the stored value if that would modify the ordering of the container. Check out priority queues or heaps for an asymptotic efficient algorithm. Sorting function example `template &lt;typename Container&gt; struct CompareFirst { bool operator() ( const Container&amp; lhs, const Container&amp; rhs ) const { return lhs[0] &lt; rhs[0]; } };` This is just an example. You can use this struct in functions that take a comparator as an argument, or classes that take it as a template parameter. Take care for the case your arrays are empty as `operator []` would cause undefined behavior!
Your stack trace tells you the problem is in strcpy. Temp is uninitialized; you're strcpying n-&gt;data to a bogus location. But if you're sorting a linked list, you should be manipulating just the list pointers, not messing with the nodes' contents.
What does your createWord function look like? However, at the end of the day, you will probably have to printf every pointer you create with "malloc" and printf every pointer you delete with "free", then tediously compare the two, to see where the mallocs and frees aren't lining up. 
If this function is the reverse of the allocation function (allocating an array of pointers, then allocating an array of char for each position) then this looks okay, 2 points though 1. Why are you checking array[i] for NULL? If some elements can be empty, are you explicitly initialising them to NULL in the allocation function? 2. Some heaps errors only manifest themselves when malloc or free happen to use corrupted data. So it is very possible and likely that your bug is somewhere else. It may not even be the data that is associated with this structure that is corrupt. Use a tool such as valgrind or app verifier - they may help
If you have a linked list A -&gt; B -&gt; C -&gt; D -&gt; E and want to swap B and D A -&gt; D -&gt; C -&gt; B -&gt; E you'll see 4 pointers change; A's, B's, C's and D's.
Where are smarty and i coming from? And you have a memory leak in the `word-&gt;array == NULL` case. 
I didn't even realize, that smarty and i were errors on my part. I just fixed it. How is that giving me a memory leak? 
Yes, in the create function I allocate the word-&gt;array first, and then the arrays of strings (e.g. word-&gt;array[0], word-&gt;array[1], etc..). When I create the array of pointers, they're all initialized to NULL. So, empty slots in the array would be NULL. 
&gt;How is that giving me a memory leak? When do you free `word`?
Oh, right! I don't know how I missed that x_x.Thank you. 
I may be wrong, but i think array[0] and array are pointing to the same thing, and as such when one is freed, freeing the other becomes undefined? Maybe try starting that if at 1, or check if array == NULL before you free it to make sure it isnt already freed? Ill be honest, pointers to pointers are not something i enjoy doing :p
Show the create fn - it's likely the problem is there. You're allowed to pass `NULL` to `free`. Your fn has three return statements. Your fn _always_ returns `NULL` - why have a return value? Here's a tightened up version: if (word != NULL &amp;&amp; word-&gt;array != NULL) { for (int i = 0; i &lt; word-&gt;length; ++i) { free(word-&gt;array[i]); } free(word-&gt;array); } free(word); Also, it's not really a 2D array. It's an array of strings or an array of char*'s. 
I wasn't aware that you're allowed to pass null to free(). I was given the function prototypes and my task is the write the definition. That's why I need a return value. I know it seems useless but I'm not allowed to alter the prototypes. 
The post you're replying to was saying that an implementation doesn't have to offer a 64-bit type at all. It could offer only 8, 16, 32, and 128 for example. 
&gt; It just takes double the CPU cycles to access them. I suspect more than double in the case of division
No, you need to worry on both sides. However, that order solely depends on the peripheral you use, not on the ISA and thus is outside of the domain of the C standard. If you write data to RAM or a file, you won't ever have to worry about bit order because such a thing doesn't exist in byte-oriented storage.
Doesn't 'free()' require a pointer, and '[0]' dereferences the pointer of 'array', so if 'array[0]' doesn't point at *another* pointer, then you'll get an error? So 'free(array)' and 'free(array[0])' free two different things. What a mess of a sentence.
`array[0]` is syntactic sugar for `*(array + 0)` or `*array`. It doesn't point to the same address as `array` but `*array`.
This is my create function ('len' is the length of the array (number of strings)): Word *makeWord (int len) { int x; Word *newWord; newWord = malloc(sizeof(Word)); if (newWord == NULL) return NULL; newWord-&gt;array = malloc(sizeof(char*)*len); if (newWord-&gt;array == NULL) return NULL; newWord-&gt;length = len; for (x=0; x&lt;newWord-&gt;length; x++) { newWord-&gt;array[x] = NULL; } return newWord; }
Are you on Linux? Use valgrind. In general, that's an incredibly useful tool to find leaks (And a lot of other unwanted behaviour), write some code that initalises some words, then destroys all of them. If valgrind says anything is still allocated or leaked, then look there.
You never `free` `newWord` when the allocation for `newWord-&gt;array` failed (thus creating a memory leak when that happens). `sizeof(char*)*len` can overflow on a large enough `len`, so maybe use `calloc` instead.
Let's see that code that allocates the individual strings.
read_base2 is missing the parens. Edit: On second glance, you acutally have all kinds of issues with the code. The values in the parens are for passing in values, do you understand how the workflow for function calls and returns work?
float get_base1 (float) { printf("\n Please enter the first base of the trapazoid: "); return 0 ; } What do you think this does? How do you think the user input is getting read?
I'm having some issues with it. I tried to follow my instructors example but I know I'm missing key factors.
Yeah, I need more exposure to pointers to pointers. Maybe I'll write a little program that uses tons of them so I can get some practice.
It should be asking for a user's input, I'm guessing it's missing the part where they can input. 
so functions have a return type, a name, pass in values, and then the function code. If your function is not returning anything, the return type is "void", if your function doesn't need any passed in values, you would either have "void" in the parens or just leave it blank. So for example, the display_results funciton wont need to return anything, so you can change it to void return type. But the more I look at this, the more I realize that you have very little understanding of how C programming works... which is OK. It just means you have a lot that you need to learn to get stuff working. For example. You declare variables (base2, base1, height) in functions, and expect to be able to use them in other functions.... C doesn't work like that. As soon as you exit the functions, you no longer have access to those variables. 
You are almost on the right track though, in that you are returning them, you just need to have variables in your main code to store them in, and not try to access them by name like you are.
Its not ideal, but you can leave it as is with a couple changes. 1) There is no need to "return" anything from a function like this, so just make it a void type and get rid of the return statement. 2) a better name might be "prompt_for_base1" that way it doesn't imply that it is getting the value from the user. 3) you aren't passing in a "float" so get rid of that in the parens. 
&gt; not sure why it's not working. In what way isn't it working?
When I run the program, it breaks. I try it with a text file I have and want it to show the contents of the file. The contents are just a string. So I look for it to output the string, but it doesn't and gives me a exit code of 9.
Your program doesn't read from the file. It tries to open the file. If it succeeds in opening the file, it prints the filename, then ends. To read from the file once it is opened, use the `fread` function Also, fname only has space for 29 characters in it. If you're entering a longer filename, then things may "break".
Holy Jesus I've never seen that before but it looks like Jqeury in C. God help me.
First line of read_base1(): There should be a semicolon at end. Also, the functions are called within main(), I assume?
C++ is off topic here. Please ask elsewhere, for example in /r/cpp_questions.
Could you put the code in a gist? I don't want to download your code. Right off the bat, your file is a text file
Please paste your code into the post instead of linking to a file hoster. Make sure to put four blanks in front of every line of code so the code comes out readable.
Updated post
Another option is to use a table. This probably works best if you have a small set of events that are common across states. Write up and example: http://www.embedded.com/design/prototyping-and-development/4442212/2/Implementing-finite-state-machines-in-embedded-systems 
 read_base1(); This does nothing to the local variable base_1. Since read_base1() is defined as a returning a float, you need base_1 = read_base1(). Secondly, float read_base1 (void) { float base_1 = 0.0; scanf("&amp;f", &amp;base_1); } this reads input into a local variable called base_1 (this variable `base_1` is completely unrelated to the local variable in `main` that has the same name), but doesn't return anything. You need a return statement.
Updated the post
I added a return statement but I'm still having the same issues
Rob Pike gave an interesting talk on [Lexical Scanning in Go](https://www.youtube.com/watch?v=HxaD_trXwRE). Even though it's ostensibly about GO, it's close enough to C that you can use the ideas directly. I thought the interesting idea was that instead of the usual enum of states he uses fn pointers. I.e. instead of a fn returning the next state (and using a switch statement to dispatch), you return fn pointer representing the next state and you simply call it. The result is a fairly clean design. Normally you'd probably break your code up so that there's a fn per state. This dispenses with the switch statements.
My comment that &gt; this variable `base_1` is completely unrelated to the local variable in `main` that has the same name should give you a clue about what is wrong with `display_top` Whenever you find a bug always check your code for other places you've made the same mistake - you'll save a lot of time by remembering to do this.
There's a relatively populated IRC channel (as in not just User (dis)connected messages all day long) on freenode, I believe it's \#\#\#c? I haven't participated more than a week, but from what I gathered it's mostly people doing small projects and asking stuff and newbies and some guys helping them.
I'll take a better look at this on my computer. You are severely over commenting your code to the point of unreadability.
It's not my choice. Unfortunately, the professor wants me to include my algorithm as comments 
They're rather quirky. Passing a pointer to a function, using malloc to set its size, and then passing values from the same function into that array either broke me or helped a lot. I'm not totally sure which.
When I have to use state machines in C, I like to define functions elsewhere, and then use the switch statement to (obviously) select between the functions. Having good names on the functions really helps. This makes the switch statement smaller, but costs on size elsewhere in the code. 
really not following you, I'm new to this stuff. 
I didn't even consider IRC - that's a great suggestion. Thanks much for pointing it out; I'm going to give it a look
By the way, I updated the code in the OP
UPDATE: Corrected my issues, had "&amp;f" instead "%f" and left out some assignments for the read statements I feel silly
check out discord too.
Disregard, I corrected my issue
Well you've now removed `display_top` so my comment is not relevent any more. But you had void display_top() { float base_1 = 0; printf( base_1 ); } which would always print 0, because base_1 wasn't the same base_1 that you had just set in `main` When it comes to functions, you should notice that read_base1, read_base2 and read_height are identical. You should have a single `read_float` function.
typedef defines a type, not a variable. 
Remove the `typedef` on line 5.
Not allowed for this assignment otherwise I would've had a single read float statement 
There are variations, the two simplest being case statements and lookup tables of function pointers. These can be blended if the states lend themselves towards it. For example you could do a `switch` on the low 16 bits, where each case uses the higher 16 bits to index a table of function pointers (each table specific to that case). Or, somewhat simpler, each case clearly calls a function, where that function is a `switch` statement. 
TLDR; It is not dead
??? So ur saying having a program compatible with win95 is important?
Really don't need to watch a video to determine whether [the most popular languages used today](https://spectrum.ieee.org/computing/software/the-2017-top-programming-languages) are dead. Enjoy the downboat and try to do some research before you make a 30 minute video. **Edit:** Oh geez, gold? Thanks! I never expected to get it from this comment.
As an aside and a note of good practice, try and get into the habit of using strncpy, not strcpy. strncpy allows you to specify how many bytes to copy, which should never be bigger than the chunk of memory you are copying into. For example, you should never copy more than 11 bytes into char phone[11] - and remember that one byte at the end might be your null byte for terminating the string. 10 letters plus your null-terminator is 11 bytes. strcpy isn’t that careful and if the string is bigger than the chunk of memory you’re trying to copy into, may result in an overflow which is how application crashes and some security vulnerabilities happen. 
Just don't mention anything POSIX there, they'll eat you alive ;) 
I don’t like strncpy. It is very unintuitive to use because it does not necessarily null terminate a string and it also copies a bunch of unnecessary nulls if the source string is shorter than the destination.
For POSIX go to ##posix.
Expecting every single string to be null-terminated also comes with problems - it is not really any safer to assume that every string is null-terminated and then plod along with functions like strcpy, especially from user input, which is always unpredictable. You should always be prepared to cover yourself with maximum length boundaries. It's not really strncpy's job to null-terminate the string for you! As for unnecessary nulls being written, that may be true, but the target chunk of memory is the same size regardless as you've already preallocated it, therefore the memory usage is the same. As for the negligible cycles needed to write more null bytes, this might actually be desirable in some cases as it will ensure the rest of your chunk of memory is "clean" and does not contain garbage data from previous allocations which you may accidentally overflow into later. There are actually even better functions like snprintf, and in some worlds, strncpy_s, but they add even more complexity where it may not strictly be needed.
We are still new to video making but I believe if you watched the video you would agree with the points that my colleague makes. He made this video because of his love of the language and in response to a growing anti C sentiment among developers.
Yeah, ##c is very active and has knowledgeable users. Been on there for years
I work on a lot of code with various state machines interacting. Beyond a certain number of states, just using a single enumeration to represent your state becomes unwieldy. At this point, often the best thing is to use several separate variables to describe the state, and make decisions on how to progress using logical combinations of those variables. For example, you may have a flag that represents error encountered. You then have to do a bunch of clean-up work before you can try to make forward progress again. So whenever you're in a state with the error flag, you're only working on clean-up. If you reach state where you've done all the clean-up, you clear the error flag, and the state machine gets redriven, and goes down a good-path branch. 
Don't forget facebook and snapchat
strcat is an intuitive alternative. You just have to set the first char of the destination array to `'\0'` But I guess it may be "insecure" like strcpy. Those functions aren't insecure if you do some quality control, e.g. check length first. Right?
If you still feel like down boating feel free. I just felt most people didn't get the message of the video from the original title
Some people's thumbnails haven't updated it now says "Is C/C++ dead, No it's not"
Unfortunately this is fairly common for most programming courses, but heres a list of programming resources from /r/learnprogramming https://github.com/Michael0x2a/curated-programming-resources/blob/master/resources.md#c-1
&gt; How can i learn c++ on my own? C or C++? This is /r/C_Programming, which is for C. Better subs for C++ would be /r/cpp_questions, /r/Cplusplus, or /r/cpp. Regardless, /r/learnprogramming is a good place to get help while learning. In general, I would recommend finding a good book (a lot of school textbooks aren't good, in my experience) and practicing a lot.
thanks 
Please post content relevant to subreddit. This post is not related to C_Programing.
C++ is off topic here. Please ask in /r/cpp_questions. 
Spam
Your `main()` function isn't doing anything, so no tests are going to run. Have a look at the [tutorial](https://libcheck.github.io/check/doc/check_html/check_3.html), especially the parts where they create the test suite with `srunner_create()` and run it with `srunner_run_all()`.
it prints 12 of them. (e)x(amine)/12 (he)x h(alfwords). 
Please consider reading the GDB manual. Doing so is much more fruitful than asking a question about every single problem you encounter.
Thank you
Thanks but in the tutorial for check they show something like this, is it incorrect? **edit** realised you linked to the same tutorial I had been following 
C instagram, with just photos of C code?
Thank you so much, I'm a total moron. Once I knew that this test setup should not in fact work I managed to get there by moving to the next section of the tutorial and fixing some compilation errors and other problems with the cmake setup that then showed up
This has been discussed many times. Use what suits you best.
Sure - I can google or spend time trying the numerous different options out there, but since this is a discussion site, I’m interested in what other readers on this sub-reddit think.
I'm sure you can find older posts on this subreddit discussing the same.
Fair point
In general (and not just for C), I prefer editors (vim) for projects consisting of single or only a few files and IDEs (with a vim plugin) for large projects even if the IDEs are usually bloated as hell. Starting IntelliJ and loading the project takes a minute at worst on my system. Maybe I could customize vim to the point where it can do most of what I like about IDEs, but that would probably be quite cumbersome.
I bless you http://darkdust.net/files/GDB%20Cheat%20Sheet.pdf enjoy.
The answer to your first question is no. They're not programmable and simple devices like that use single-purpose ICs. The answer to your second question is yes, you can certainly make your own wristwatch. [Mine](https://imgur.com/EAnIleU) is a little chunky because it has a GPS receiver in it and it's a power hog. It was built for use at Burning Man, and its main function is to tell me my current street address and where home is. The current version also tells me where the nearest toilets are, assuming I've got accurate coordinates for them. There are some [dev kits](https://store.ti.com/EZ430-CHRONOS-915-Chronos-Wireless-development-tool-in-a-watch-P1736.aspx) in watch form if you don't want to build the hardware from scratch.
&gt;I know there is a microchip inside but what is happening inside that microchip. Can I possibly run C code on that microchip? Maybe, but I doubt it. Digital watches are ubiquitous enough and simple enough that they might actually be running on some non-programmable asic. All of the watches I've owned seemed like they were all built on top of the same system, which increases the likelihood that that system is not programmable. &gt; Or even better, is there any way I can make my own digital watch ( wristwatch size) from scratch? Yes, all you need is a microcontroller, a few seven-segment displays and maybe a serial-in-parallel-out shift-register (in the likely case that the microcontroller doesn't have enough pins). Ideally the seven-segment display will use LCD (because of low power consumption), but I've only ever seen LED-based displays for sale at hobbyist stores. I'm not sure if that's because the LCDs are harder to work with or if it just means that I'm not looking hard enough but I imagine that the LEDs will eat up coin-cell batteries much faster, so that's a potential pitfall to watch out for.
They're using programmable micro-controller inside, especially nowadays when they're dirty cheap, and short product cycle, no one will produce a non-programmable mask version. In fact I'm working in the low level programming for my life, many many years ago when we finished a program, after get approval, we need to give the code to factory, wait for a month, pay a masking charge, and they will put the code into a mask to produce the chip actually. Nowadays most of them are flash base so we only need to program it in our production line before the assembly. However this doesn't mean that they're designed to re-programmable in the end user. Return to your question, for your casio watch, most likely it is using a 4-bit MCU, due to the low power consumption and low costing. This means the program inside was written in assembly instead of C. And yes, if you go for a 16 or 32bit MCU, you can using C to write a program for a watch, but most likely they will consume much more power from the battery. In fact, when designing such a low power product, one will need a deep knowledge on the hardware level of the MCU, the compiler and the overall system to archive a long battery life. 
-lcurses tells gcc to link curses library to your program. Without it the program wont compile giving error such as function definition not found etc. Its just like -lm flag which tells.gcc to link math.h library to you code. Psst : why not use ncurses? Curses is old.
These are flags for the linker used in gcc so that It can link required libraries according to program requirements 
Thanks for the feedback. I don't understand why it is necessary to do this though? Doesn't linking happen with any header files that you include? What makes this one special? Also, I read that ncurses was pretty similar to curses. Do you happen to know the main differnces? Is it simply the same functions with different implementations?
Spacemacs or Neovim! 
Why not [strlcpy and strlcat](https://www.sudo.ws/todd/papers/strlcpy.html) instead? It's been around for 20 years now. Better than strncpy. Safer than milk.
The short answer is that the .h file contains a declaration, just enough to tell the compiler 'these functions exist, this is how you invoke them.' There's (usually) no actual code in it though. When the compiler works though, in order to produce a binary it needs to know the definition of those functions, it needs their actual code. -lcurses tells it to pull in the code inside the curses library into the code generated from your source, fulfilling that requirement and making everything work properly. There are details I've skipped over and that's not the only way to make use of libraries but it should be good enough for a foundational understanding.
First, I just want to point out that linking doesn't have to happen with *any* header files you include. For example, imagine you have the following: header.h: void function(void); main.c: #include "header.h" int main(int argc, char *argv[]) { function(); return 0; } void function(void) { } Here, despite `function` being defined in a header, the linker won't have to look anywhere else for that function; it's already in main.c. So, more specifically to your question, the `-l` option tells the linker to link against a particular library. Given the option `-lXXX`, the linker will search a series of directories for `libXXX.so` (or `libXXX.a`). Apparently there's no easy way to see what that series of directories is for the standard `ld`, but using [this Stack Overflow answer](https://stackoverflow.com/a/9929507/5679797) as a basis, you can use `ld --verbose | grep 'SEARCH_DIR` to find them. The reason you normally don't have to specify `-l` options is because the vast majority of the standard library functions are contained within `libc`, and because the vast majority of desktop C programs are going to use `libc`, the compiler is implicitly adding `-lc` for you. However, because curses is in a different shared library and not every program needs it, if you want to link against it, you have to explicitly ask for it by using `-lcurses`. It's the same as with the `math.h` functions; they're contained in `libm.so`, not `libc.so`, and that's why to use them, the compiler requires `-lm`. I'm not sure if that clears anything more up for you, but I hope so.
I've looked through header files many times and I've learned a bit about preprocessor directives and popular conventions within header files. I still don't know where the library functions are located though. So is -l (lowercase el) a gcc option and it finds the library curses after it? Or is the actual library called lcurses or lncurses?
From 2013?
Thanks for the detailed response. It helps a lot. They never taught me this stuff in my computer science course on C Programming. I also read a book called Pointers on C from cover to cover and these things were never mentioned. Also, I think you just answered one of my question that I had in another response. So if I can find the location of these libraries, am I able to read the source code or is it all precompiled object files or something? The .so file extension makes me think it is source code. I can always google this stuff now though. 
Yeah, this stuff isn't always covered very well. Some courses that go under titles like "Systems Programming" (often using the book *Computer Systems: A Programmer's Perspective* from CMU) will touch it, but mine never did. That's fair though I think; it's not exactly a computer science thing, or even so much a general programming thing, it's more about the UNIX environment and ecosystem. The `libXXX.*` files are compiled libraries, yes. The `*.so` files are "shared objects" or "dynamic libraries" and `*.a` files are "static libraries," but they're both compiled versions of the library. I can give you more detail if you want, but that's a general overview of what the files are.
I'm currently taking a class in Systems Programming. We are using this [book](https://www.amazon.com/Understanding-UNIX-LINUX-Programming-Practice/dp/0130083968). I read the first 200 pages, so I'm very far ahead of my class currently. I did some fun things earlier like writing random bytes to the speaker device file. There was one more thing that I was confused by. When I was looking up how to compile this file that used the curses library, I googled the problem and noticed that one person was using an option called "-static". This word always confused me a bit in C programming because it seems to mean many different things depending on the context it is in. I've read about all of its contexts in Pointers on C. It seems to be used when it comes to linkage, storage class, and affects scope. I think static linkage is implied or something depending on where certain variables are declared. I'm probably missing something. My problem is that I can never seem to remember what exactly is going on when "static" is used or recognize cases where I should be using it because I have never had to apply this knowledge. How am I ever supposed to learn where this keyword is applicable when it seems like all of the problem I've come across don't require its use or can be solved without it?
I haven't actually read the curses header myself, but yeah, the .h files for complex and/or older libraries can be a little black magic. Read the man pages or the library docs for an overview and api listing more suited to us mortals. Your first summary is right. -l is a gcc option and must be immediately followed by a library name, in this case curses.
The ill-fated Pebble smartwatch platform has an SDK in C. Pebble Times can be had on Amazon for around $50 if you're looking for a fun weekend programming project.
Let me get the `-static` option out of the way first, as it doesn't really have anything to do with the use of the `static` keyword in C. I actually didn't know this, but I just looked it up in the `gcc` man pages, and it forces the compiler to use the static library instead of the dynamic library. Normally, if both `libXXX.so` and `libXXX.a` both exist in the `SEARCH_DIR` path, the linker will link against the `.so` version, but `-static` forces the use of the `.a` version. The `static` keyword is definitely a little goofy to wrap your head around for a while. Part of the meaning has to do with the storage *duration*; if something has "static storage duration," it exists for the life of the program. For example, you can have the following: file.c static int my_int = 10; int function(void) { static int my_local_int = 37; my_local_int++; return my_local_int; } Both `int`s exist for lifetime of the program. The `my_int` variable will have its value assigned when the program begins and will always be accessible within file.c (more information on this in a bit); `my_local_int` will be assigned its value the first time `function` is called (or at least it will appear to; I don't know the exact implementation details of when the assignment happens), but every time `function` is called, it will retain its value from the previous call, because it has "`static`" storage duration. So, function will return 38, then 39, then 40, etc. (Note that, to this point, I've never yet found a real need to use the local version of a `static` variable.) However, `static` also affects the scope of a variables declared at the top level of a file. Essentially, `static` restricts the scope of variables declared at the global level to that particular compilation unit, which is essentially that file. That is, because `my_int` was declared as `static`, no other file can use the name `my_int` to access that variable. If the variable had not been declared as `static`, that any other file or program could access that variable by making a forward declaration of it. Also note that functions can also be declared as static: second_file.c: static int second_function(void) { return 10; } Which means that `second_function` cannot be used from outside of second_file.c. You're right that basically its never *required*. It's a way of enforcing separation of concerns and encapsulation. For the scoping, think of it like using `private` members or methods in a class in an object-oriented language. No, it's not necessary, but it keeps your interface clear and implementation details hidden. That's basically the main usage of static; to hide information in modules that you don't want to expose outside that module. Finally, I just wanted clarify some of what I wrote above; namely, I want to point out it is still possible to *access* static functions and variables from outside the file in which they're declared by getting pointers to them, but they can't just use the name. For example, this is perfectly valid: file.c: void increment_other_static(void) { int *other_file_variable = get_static_variable(); *other_file_variable = *other_file_variable + 1; } other_file.c: static int other_file_variable = 0; int *get_static_variable(void) { return &amp;other_file_variable; } It's just not valid to do: file.c: extern int other_file_variable; void increment_other_static(void) { other_file_variable = other_file_variable + 1; } other_file.c: static int other_file_variable = 0; Again, hope that helps!
There's no trick to it, and there's only 1 rule. USE. WHATEVER. THE. FLYING. FUCK. WORKS. FOR. YOU.
Yeah, like the other 2 in the last week alone.
&gt; However, static also affects the scope of a variables declared at the top level of a file. Essentially, static restricts the scope of variables declared at the global level to that particular compilation unit, which is essentially that file. According to what I've read from my textbook, this is called internal linkage. I think [this section](https://imgur.com/gallery/eSoZA) covers everything pretty well. So if I'm understanding it correctly, static is just a way of enforcing encapsulation by making things less visible or accessible. This isn't intended as some sort of security, right? It's specifically meant to help ensure the integrity of the software? Also, I understand what's going on in your examples perfectly well. The idea of creating object files and linking them together still seems kind of fuzzy to me since I've never really done it myself. I think we may have covered it in the C programming class, but it was such a small part that it was easily forgettable. When I initially looked at your example about variable scope across files, I read this: &gt; I want to point out it is still possible to access static functions and variables from outside the file in which they're declared by getting pointers to them, and I thought you meant that you could pass pointers to functions declared as static in order to access them from another file. I understand that you meant static variable now, but is it possible to pass pointers to functions in order to access them? A section from *Pointers on C* says this: &gt; The compiler always converts function names to function pointers wherever they are used. The ampersand (in front of a function name) does explicitly what the compiler would have done implicitly anyway. So if you had a function with external linkage in a different file that returned a pointer to a function with internal linkage within that same file, could you call that external linkage function in order to call the static function from a different file? It seems like all you would need to do is have the external linkage function return the internal linkage static function's name and it would work. Thanks again for your detailed responses. I really appreciate it. I want to be an expert at this stuff. 
Are there any clean ways to return a function pointer to the next state? As it's technically a recursive type you can't express it directly. One option is to cast the returned function pointer on use, e.g. typedef void fn(void); typedef fn *state(int arg); state *current = ..., *next; next = (state *)current(42); and maybe you could use a helper function or macro like `state *step(state *current, int arg);`, but that kind of defeats the point, or you can wrap it in a struct struct state { struct state (*doit)(int arg); }; struct state current = ..., next; next = current.doit(42); but are there other ways? If you could forward declare a typedef then you could do something like extern typedef statefn; /* imaginary syntax to forward declare type */ typedef statefn *statefn(int arg);
You're right that you can't easily just return the fn as the value. But, there's other info your likely to need to pass in/out of your state fns so you can bundle it all into a struct. Something like: struct Context_T; typedef void (*StateFn_T)(struct Context_T *context); struct Context_T { int result; StateFn_T state; ... }; 
Curses is a standardized interface. Ncurses is one implementation of curses with a very small amount of proprietary extensions. By linking to `-lcurses` instead of ncurses, your code is more portable as it works on other curses implementations, too.
Although your question has already been answered I just wanted to let you know that in UNIX based systems we don't give the same significance to filename extensions as some other systems. `.exe` doesn't really mean anything here, and conventionally compiled programs have no extension at all, e.g.: gcc hello1.c -o hello1 -lcurses ./hello1
&gt; Doesn't linking happen with any header files that you include? To make it clear, linking is a concept, entirely different from header files. First, as has been said, the compiler links the standard library automatically to your binaries for convenience. You can actually tell gcc to not do that with `-nostdlib`. This is *very* rarely useful because, well you can't use any of the c standard library functions. There are some articles around where people try to make the smallest possible c compiled executable and they do stuff like that to bring the size down, random example I just googled: http://timelessname.com/elfbin/. But you really don't have to understand everything there, because that's quite advanced. Now header files are really just standard c files, nothing special. You usually have declarations like void foo(int bar); in them, but nothing prevents you from putting the implementation of the function in there: void foo(int bar) { printf("%d\n"); } edit: In fact there are "header-only" libraries that have all their code in header files. [glm](https://glm.g-truc.net/0.9.8/index.html) is such an example. With those you basically "copy" the entire source code of the library into your application every time you include its header. That means for every function declaration in the headers, there's also an implementation and there's no need to link anything further. You may know the name of the declaration of a function without an implementation as a *forward declaration*. You can put these in your .c file too: void foo(int bar); void foo(int bar) { printf("%d\n"); } Of course this really doesn't do much. The forward declaration in the first line only tells the compiler to create an entry for a function `foo` with an `int` parameter in its symbol table and at this moment probably doesn't do anything more with it. (At a later step the implemented function will be matched up with the forward declaration based on its "prototype" or "signature"). Now what happens if you `#include &lt;math.h&gt;` and write `double a = sqrt(2);`. math.h will probably include something like `double sqrt(int number);` or something like that, I haven't checked. Since `#include` causes math.h to be regarded as if it was copied at the top of your file you have your forward declaration and are allowed to call `sqrt(2)`, but at this point the compiler doesn't have an implementation of `sqrt()`. The compiler only has an entry for sqrt() in its symbol table that you can use. That's where linking comes in. If you don't use `-lm` you now get some error that will tell you that the implementation of sqrt() is missing. You can now either write double sqrt(int number) { return 2; //a tiny bit inaccurate for most numbers != 4 } or you can tell the compiler to look for an already compiled version of such an implementation in a shared or static library. In this case sqrt would be in libm.so, and for some reason you shorten `lib` to `l` and remove the `.so` suffix when giving the name to gcc, so `libm.so` becomes `lm`. Now compiled libraries are not great to inspect. Apparently shared libraries have two symbol tables that tells the compiler what functions are in there. One of them is used for debugging and can be removed from the binary with the `strip` utility and linux distributions like to do that with most libraries because it decreases their size. Then they have a "real" symbol table that the compiler uses to look what functions are in there. For example with glibc 2.26 libm.so is really libm-2.26.so and you can see that sqrt is in there with `objdump -T /usr/lib/libm-2.26.so | grep sqrt`. As I said, not great to inspect but the point is that your compiler knows how to read this symbol table. There should probably be info about return type and parameter types in there somewhere. There's also a bit more magic, like the exact memory address offset of the function inside the file the cpu can actually jump to the beginning of sqrt() to execute it and stuff like that, but that's only stuff your compiler really needs to know. In the end your application will not contain the compiled binary code for sqrt(), but it will contain a reference the libm shared library that contains the binary code. You can view all the libraries your own executable is linked to with `ldd`: $ ldd a.out | grep libm libm.so.6 =&gt; /usr/lib/libm.so.6 (0x00007f71dc956000) Now whenever you *start* your application, the linker is involved in loading the shared libraries and making sure your calls to sqrt() will go to that library. Apparently it was done this way because if you have multiple applications running at the same time and many of them use `sqrt()` the operating system only needs to have the libm.so library in memory once, and all the applications can use this single instance of the compiled sqrt() machine code. As for `gcc foo.c -lwhatever -static`, that's using *static linking*. This tries to *not* take a shared library like libwhatever.so, but a static library like libwhatever.a. This does not cause your program to have a reference to libwhatever.a that will be searched and loaded when you start your application, instead this basically copies the machine code of the functions from libwhatever.a into your compiled application. This is not used very often, mostly by applications that are supposed to be distributed in compiled form to a wide variety of systems where not all libraries will be available in all versions. But sometimes people also use shared libraries and simply distribute all needed libraries with their application.
Is there an implementation of Plan9's networking for other systems, possibly even "transparently" abstracted so one could rather easily switch the API? This could be interesting
If you want to learn the .NET framework your only choice is Visual Studio. It also comes with C, but it's gotten a bit slow over the years yet it has fantastic UI builders (especially for .NET). You could also try IDE's by JetBrains, Rider for .NET or CLion for C.
Go's network API is modeled after the Plan 9 API. There are also plan9port and Plan 9 from User Space which provide API translation shims.
Please do us a favour and don't post these. I see that you are very enthusiastic about your newfound knowledge, but the subjects you make videos about are so simple that they just bore everybody in this subreddit.
What book are you using, out of curiosity?
You're overthinking this. General C/C++ development doesn't require anything more than simple tools. One of the worst things you can do is get bogged down by your tools.
How did you build yours?
I 3D printed the housing. I've also got a prototype that I machined from aluminum, but I never finished it. Most of the code was borrowed from previous projects, and the circuit is fairly straightforward.
RemindMe! 5 day “Book"
I already have what works for me - I’m curious about what works for other people, but thanks for the insightful comment.
Hey. First, having a factorial function (even worse: one that takes and returns doubles) is TERRIBLE. `x!` is defined for the natural numbers. Since we're not dealing with the gamma function, don't consider any other use case. So you can just create an array of precomputed functions instead of having a TERRIBLE algorithm. [Here is my factorial implementation](https://github.com/Garuda1/unixlib/blob/master/source/math/my_fact.c) Now, let's focus on this line: for (k = 0; ((pow(-1, k+1)*fatorial(6*(k+1))*(545140134*(k+1)+13591409))/(fatorial(3*(k+1))*pow(fatorial(k+1), 3)*pow(640320, (3*(k+1)+3/2)))&lt;=pow(10, accuracy)); k++) Other than being IMPOSSIBLE to read, it's also impossible to compute: `fatorial(6*(k+1))` won't output anything meaningful for `k&gt;1` on 32 bits machines. Just see for yourself: the result is *too big*. Overhaul, your algorithm just can't work. And even if it could, it's terrible. Look into other ways to do it, and if you really want accuracy, go with **GNU mps** **EDIT:** Yes, I'm not saying anything about what you *should* do, just pointing out the errors. You're the one who has to do the homework.
Thanks for this. I did this in a rush so I guess my program is really terrible, haha. Will redo it. However, I can't really change the [algorithm](https://en.wikipedia.org/wiki/Chudnovsky_algorithm). Any tips on making this work? I'm using a 64bit machine.
&gt;Any tips on making this work? I'm using a 64bit machine. Unfortunately, series-based approximations are often limited by the factorial function. Try to make the load smaller and think about clever tricks! That's optimising.
Did you use a microcontroller or?
It's called [Understanding Unix/Linx Programming: A Guide to Theory and Practice](https://www.amazon.com/Understanding-UNIX-LINUX-Programming-Practice/dp/0130083968)
I did learn that extensions mean almost nothing. However, I'm using Ubuntu and the OS seems to treat certain file extensions differently. For example, a file with the extension .html will always open with my web browser unless I specify to open it with gedit. Do people usually compile executables without the .exe file extension?
Sorry, I thought that part was implied. Yes, this project used a ColdFire v1 MCU, specifically the MCF51JM128VLD. It's outdated now and you could do better with a Cortex-M4. If you're going for long battery life you'll want something specifically designed for low power. You don't need a lot of processing power for a watch. The closest thing I've built is a 3-digit LCD countdown display using an 8-bit MC9S08LL16. It could easily be adapted as a regular timepiece with an appropriate display. That one is powered by a CR2032 battery and should have a battery life of around 7 years. The oldest examples I have are only 4 years old, but they're still going. One early prototype with a larger display and a much smaller battery died after about 2 years.
Hm, this could be interesting, also bringing the API to other languages perhaps. I've not yet looked into plan9port that closely yet but this seems to be promising, since I don't like the "common" network APIs at all.
I think this is making much more sense. I still have a few questions though. I'm just going to try to reiterate to see if I'm understanding what you are saying. So, shared libraries are used during compile-time by default unless it is specified with the -static option, and they also have pre-compiled function definitions that the compiler will link to references of the functions within the header file or any source code that you write. You said that this section of memory is called the shared library because multiple processes running will be accessing the same physical locations in memory regardless of the fact that it can be two completely separate processes. You said that a static library is simply a copy of a shared library that is contained within the code that you compile for yourself and so it does not need to reference this same section of memory. This is done in order to reduce the amount of memory required. Please let me know if I got something wrong or I said something that suggests I misunderstood. I have a few questions now. Is the shared library stored on the hard disk or in RAM while the computer is running? From what I've read in my systems programming textbook so far, it seems like it is a bad idea to store it on the hard disk since accessing the hard disk increases the run time of the program dramatically when looking at it at a relative scale. Does the kernel load the library into main memory whenever the program is run? If this is the case, then are the only purposes of a static library simply to reduce the size of the executable that you produce and make programs distributable to people who don't necessarily have the libraries that you used? Also, I had another question that is a little unrelated. I looked at the file directory tree of my Ubuntu computer and I noticed that there are many different compiler directories that seem to be scattered all over the place. I can't remember if this is something that I did while I was trying to get the C compiler working a long time ago, but I think my Raspberry Pi also has something like this. There are many lib and include directories all over the place. What is the point of having all of these different directories? Why wouldn't it simply all be in one directory? Thanks for your detailed feedback. I'll read what you have to say as long as you are willing to provide it.
&gt; First, having a factorial function (even worse: one that takes and returns doubles) is TERRIBLE. Why? Having a function is fine (other than it being misnamed). Using doubles is unnecessary, but not harmful in this case. &gt; Here is my factorial implementation There is no reason to pre-compute large tables of anything for something as simple as a factorial. There's definitely no excuse to mix up types when defining a table. You YELL at a beginner for using doubles when computing factorials and then you do the same thing? Amusingly enough the only two constants you expressed as doubles are also the only two factorials that are outside of the range where doubles can represent all integers. &gt; fatorial(6*(k+1)) won't output anything meaningful for k&gt;1 on 32 bits machines. Why? Pretty much every architecture in use today has 64 bit doubles. i386, which I assume you mean when you say "32 bit machines", has 64 bit doubles with 80 bit internal representation. 
You probably can't program a very basic digital watch as they use custom asic to keep the power level and production costs down, but a slight step up like the [EZ-430-Chronos](http://processors.wiki.ti.com/index.php/EZ430-Chronos) and you can easily program them in C.
If OP doesn't need arbitrary precision, gsl has a nice factorial function that is easy to use and usually goes up to 170!
You bless us all
&gt; So, shared libraries are used during compile-time by default unless it is specified with the -static option Yes, that's just how gcc behaves: gcc -lfoo will search for a shared library. I think it offloads the actual search to the linker, because I think if you set LD_LIBRARY_PATH=/foo/bar and /foo/bar/libfoo.so does exist it should link to the library in that location. (LD_LIBRARY_PATH is an environment variable that the linker prioritizes over the configured library search paths in /etc/ld.so.conf or /etc/ld.so.conf.d/*) &gt; You said that this section of memory is called the shared library because multiple processes running will be accessing the same physical locations in memory regardless of the fact that it can be two completely separate processes. The libfoobar.so file is called shared library. Btw, I'm not *really* sure about some of this stuff, but it should be like this. So what really happens when you run your compiled application is that the linker is invoked first. The path to the linker is actually in the executable program you compile with gcc. Try `objdump -s hello1.exe | head` and there should be something like Contents of section .interp: 0238 2f6c6962 36342f6c 642d6c69 6e75782d /lib64/ld-linux- 0248 7838362d 36342e73 6f2e3200 x86-64.so.2. /lib64/ld-linux-x86-64.so.2 looks like a shared library but it's actually an executable program too: You can manually run your program with `/lib64/ld-linux-x86-64.so.2 /whatever/hello1.exe` and something like this happens behind the scenes anyway. If you were to move /lib64/ld-linux-x86-64.so.2 away from what is hardcoded into all the binaries (only those not compiled with `-static`), maybe into /foo/ld-linux-x86-64.so.2, all those binaries would not start anymore with some error message. But you'd still be able to run them with `/foo/ld-linux-x86-64.so.2 /path/to/binary`. Just a short excursion. So when you start your program, first the linker starts, it examines your program to see what libraries you linked it to, then it searches for those libraries and makes sure function calls from your program can go into that library. With glibc's linker at least you can see exactly what it's doing when starting your application with an environment variable: LD_DEBUG=libs ./hello1.exe About the memory usage, a stupid linker would just every time you start an application, load all linked libraries into some part of the ram and give the application access to it. A smarter linker can keep track of what libraries it has already loaded into ram and not load it again. There is of course a lot of magic involved to make sure this actually works. &gt; You said that a static library is simply a copy of a shared library that is contained within the code that you compile for yourself and so it does not need to reference this same section of memory. This is done in order to reduce the amount of memory required. I meant if you have many programs using the same set of the shared libraries running at the same time, this will result in more free ram. If you statically link a static library, your application gets bigger. If you have the machine code for sqrt() in a shared library libm.so, every program that uses sqrt() and links to libm.so can share this one machine code. If you have the machine code for sqrt() in a static library libm.a, every program that uses sqrt() from it, gets the machine code copied into itself. That first makes the application a bit larger and means that every program that does this will have its own version of the machine code of sqrt() in ram somewhere. As always, that's only half the truth. https://sta.li/faq is a project/linux distribution that argues that linking everything statically can be done in a way that is actually better. So control questions: &gt; Is the shared library stored on the hard disk or in RAM while the computer is running? Shared libraries themselves are just the files /usr/lib/*.so. &gt; From what I've read in my systems programming textbook so far, it seems like it is a bad idea to store it on the hard disk since accessing the hard disk increases the run time of the program dramatically when looking at it at a relative scale. Does the kernel load the library into main memory whenever the program is run? Every time you start any program that is linked to shared libraries, the linker will load them. How, where, and how often is at the linker's discretion. I mean yea, theoretically you wouldn't even need them in ram, the linker could do something like mmap() and then execute the machine code directly from the file (not sure if mmap()'ed memory is actually marked executable, just the theoretical idea). But then calling sqrt() from your program could be much slower... Maybe in the not so far future we can abandon RAM altogether once SSDs get fast enough access times. &gt; If this is the case, then are the only purposes of a static library simply to reduce the size of the executable that you produce and make programs distributable to people who don't necessarily have the libraries that you used? For the moment, you can just forget about static libraries. Or maybe [wikipedia](https://en.wikipedia.org/wiki/Static_library) or so helps. You usually never really *need* to use static libraries. You use them when you want a "self contained" binary that has very few external dependencies, for whatever reason you would want that. &gt; There are many lib and include directories all over the place. What is the point of having all of these different directories? Why wouldn't it simply all be in one directory? People thought up a [FHS](https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard) and so far it does what it does mostly well. The thing is, in windows you install e.g. java and java.exe will be somewhere in C:\Program Files\java\java.exe or something. Or you install python and it will be in C:\Program Files\python\python.exe or so. That has a bit of a disadvantage that if you want to run your python script with `python.exe foobar.py` from the command line, you either have to do that from the C:\Program Files\python\ directory or add that directory to the global PATH environment variable. And that is for every application you install. On \*nix people thought it would be nicer that if you install python and java, they both put their binaries into one /usr/bin/ directory, so you have one directory in the $PATH environment variable and running applications gets much easier because they are all in one place. The same goes for libraries in /usr/lib or headers in /usr/include. If you are developing something and want to use a couple of different libraries so you link to several libraries and include several headers it "just works" if you just `#include &lt;lib.h&gt;" and then link with `-llib` because they are usually installed in these default paths. Of course nothing goes so smooth and there is also /lib/ and /sbin and then you have to have a precedence which one gets loaded first if the same filename exists in several of those; and what if two libraries have headers with the same file name, so you make subdirectories for them and then have to include them like `#include &lt;GL/gl.h&gt;`. And most importantly, how do you handle different library versions and the headers of those different versions... Of course there is a linux distribution that is experimenting with a hybrid layout: https://www.gobolinux.org/
**Static library** In computer science, a static library or statically-linked library is a set of routines, external functions and variables which are resolved in a caller at compile-time and copied into a target application by a compiler, linker, or binder, producing an object file and a stand-alone executable. This executable and the process of compiling it are both known as a static build of the program. Historically, libraries could only be static. Static libraries are either merged with other static libraries and object files during building/linking to form a single executable or loaded at run-time into the address space of their corresponding executable at a static memory offset determined at compile-time/link-time. *** **Filesystem Hierarchy Standard** The Filesystem Hierarchy Standard (FHS) defines the directory structure and directory contents in Linux distributions. It is maintained by the Linux Foundation. The latest version is 3.0, released on 3 June 2015. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
&gt; So if you had a function with external linkage in a different file that returned a pointer to a function with internal linkage within that same file, could you call that external linkage function in order to call the static function from a different file? Yes, exactly.
Check Wikipedia, literally first link that I found has a nice iterative derivation that avoids the use of factorial: https://en.wikipedia.org/wiki/Chudnovsky_algorithm . I suspect that you used the first formula from the same article, use the iterative formulas, lower on the page. A simple way to asses the error of your approximation is to calculate the difference between two consecutive approximations, when this is lower than your desired error you should be OK. Alternatively, simply compare the value of PI with 7 or 9 decimals with your successive approximations, stop when the difference is small.
**Chudnovsky algorithm** The Chudnovsky algorithm is a fast method for calculating the digits of π. It was published by the Chudnovsky brothers in 1989, and was used in the world record calculations of 2.7 trillion digits of π in December 2009, 5 trillion digits of π in August 2010, 10 trillion digits of π in October 2011, 12.1 trillion digits in December 2013 and 22.4 trillion digits of π in November 2016. The algorithm is based on the negated Heegner number d = −163, the j-function j(1+√−163/2) = −6403203, and on the following rapidly convergent generalized hypergeometric series: 1 π = 12 ∑ k = 0 ∞ ( − 1 ) k ( 6 k ) ! ( 545140134 k + 13591409 ) ( 3 k ) ! *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
How would you return a pointer to a function anyway? What would the function signature be? My best guess is something like this: int (*f)() getstaticfunc() So f is a value that when dereferenced results in a function that returns an integer. So getstaticfunc() returns a pointer to a function that returns an int. This seems wrong though since I'm basically declaring a variable as a return type. I can't think of anything else though. Is there a data type that represents a function?
Go to google and look up C array sorting. Then change your code to use arrays for the heights and either implement a sort function or just use an existing one. Depending on your sort criteria the shortest will be either the first or last in the array. 
No blog spam please.
Given that there is only one with the shortest height.
how about "should I send u/m37driver a dollar" (answer is yes) but it's really just limited by your imagination.
Instead of computing factorials, try to remove as many common factors from both sides of the fraction as possible. This way, you don't loose any accuracy.
&gt; For example, a file with the extension .html will always open with my web browser unless I specify to open it with gedit. This wil most likely happen when you double-click it using your file manager. The association of file -&gt; program is probably registered somewhere there (or in your desktop environment) and the file manager acts upon that association. &gt;Do people usually compile executables without the .exe file extension? On Linux, Unix, and probably BSD: yes. On Windows: no. For example, take a peek in `/usr/bin/`. You'll see plenty of extensionless files there, the majority being compiled binaries. You can inspect them using the `file` command, for example: file /usr/bin/yes /usr/bin/yes: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=a18dce4d10d23a88ee9b95f83666203a80ead36f, stripped 
What is the purpose of this post?
What is the purpose of this post? Do you think it's useful to anybody but those who study at your university?
Is every intro to C class on the planet now including a "make a stupid video tutorial and post it on Reddit" assignment? 
Aren't you a mod? Can the sub be configured to not allow YouTube links?
Thank you 
You could use a variable `float shortest` that you initialize with a value which is higher than the input, e.g. 5 meters for human individuals. Read the heights and compare to `shortest`, if it's less than the current value, set `shortest` to the new value. Example: `if (H1 &lt; shortest) shortest = H1;` And so on. This way you don't need an array, as you don't need to save all heights in order to determine the shortest one.
The classic Mattel "Auto Race" game comes to mind, and is doable with those hardware specs.
There are good resources on Youtube, too. I do not remove videos just because they cover very basic material (I don't like them either). That's what you have vote buttons for. I only remove such posts when they are blatantly wrong (at a quick glance, this doesn't seem to be the case here) or so poorly made that not even beginners would profit from them, when there is an unhealthy amount of advertisement in them (no advertisement here) or when they try to sell us something in a very blatant way. This video frankly doesn't hit enough checkboxes to warrant moderator intervention but I don't really like it either.
You're on the right track, but the real syntax is much, much uglier. Let's walk through it step by step: getstaticfunc // Take 'getstaticfunc' getstaticfunc(void) // ...call it with zero arguments *getstaticfunc(void) // ...dereference the result (*getstaticfunc(void))(void) // ...call THAT with zero arguments int (*getstaticfunc(void))(void) // ...and you'll get an integer An alternative to this is to use a typedef: typedef int (*funcptr)(void); funcptr getstaticfunc(void); ...which has the added benefit of making variable declarations simpler as well: funcptr fp = getstaticfunc(); printf("static function returned %d\n", fp());
Thx, I am using Jetbrains's, it's far less bulky then MVS 2017.
How can I play that gave at 60FPS?
I did tetris single player on similar hardware. You can try multiplayer.
Rust looks quite good, might start using it
AFAIK the standard excel format is proprietary, the easiest way would be to use CSV which excel can also read.
You have to use a lot more than malloc. I'd look for an existing library that can read xlsx files as a starting point instead of trying to implement the spec yourself. 
It would much easier to read if you save the Excel file as a comma-separated values (CSV) and read that instead. Otherwise, you can use the Excel ODBC Driver and the ODBC API (https://docs.microsoft.com/en-us/sql/odbc/reference/syntax/odbc-function-summary) assuming you're running Windows.
So, the declaration of getstaticfunc is "int (*getstaticfunc(void))(void)"? Does this mean that you can do the same thing with variables? For example: typedef int *intpointer; intpointer getintpointer(void); or int *i getintpointer(void); Breaking it down, getstaticfunc is a value that when dereferenced results in a function that takes no arguments and returns a value that is a function that takes no arguments and returns an int. So, getstaticfunc is a pointer to a function that returns a function that returns an int. This stuff gets more confusing when I think about the fact that the compiler implicitly replaces function names with a pointer to that function. Does the compiler transform that statement at all, or did we already do it? If we already did it, could we have done it a different way that the compiler would have taken care of for us? Something like this: int (getstaticfunc(void))(void)
Who could have guessed that the curses header file involved black magic.
i made an implementation with a csv that i can print the data i want in the screen. how can i add new data(whole new line in excel) with the csv?
&gt; `int *i getintpointer(void);` You can't declare a function and a variable at the same time. The equivalent declaration without the typedef is just `int *getintpointer(void)`. &gt; So, getstaticfunc is a pointer to a function that returns a function that returns an int. No; `getstaticfunc` _is a function_. Its return value is a pointer to a function. Remember, operator precedence rules apply to declarations. Calling a function has higher precedence than dereferencing a pointer, so when you see both without parentheses, it's a function returning a pointer, not a pointer to a function. &gt; This stuff gets more confusing when I think about the fact that the compiler implicitly replaces function names with a pointer to that function. This is the wrong way to think about it. When you use the name of a function _in an expression_, it _evaluates to_ the address of the function. The compiler is not re-writing your code behind your back.
CSV is typically in the format: x,y,z a,b,c You can use a function like *fprintf* to insert a new line at the end for example. Just open the file in append mode. It is like printing data on the screen, except that you write them in a file (don't forget to add the commas). 
If it is a newer version of MS Excel, then it is likely the document is in .xlsx format - which is Office Open XML - not proprietary at all. You can simply unzip the .xlsx file; it is a zip file with XML code inside. Also any embedded files, such as images, are easy to extract because they are just files with the unzipped directory structure.
&gt; You can't declare a function and a variable at the same time. You actually *can,* but definitely *shouldn't.* The syntax is: int *i, *getintpointer(void); or, equivalently, int *getintpointer(void), *i;
It's not proprietary.
I've reopened your question. I'm really tired right now, this is all I can do for you.
Looks like you're missing `k++;` in the `while(i &lt; n1 &amp;&amp; j &lt; n2){` loop.
We will use **arrays** for this task, Arrays are basically like pockets, instead of buying different pockets to store things, we buy a pant that has many pockets, the pant collectively gets a name and the pockets get their respective numbers. This is a huge help in cases like this.. int height[4]; // array to hold 5 heights, remember arrays start at 0 for ( int i = 0 ; i&lt;5 ; ++i ){ // loop to input all the heights by incrementing the pocket number by one. scanf("%d",&amp;height[i]) //read the inputs } int min_height = height[0]; //ASSUME 1st height to be the smallest. for ( int j = 0 ; j&lt;5 ; ++j ){ //loop to compare the pockets and maybe prove our assumption wrong if ( height[j] &gt;= min_height ){ min_height = height[j]; // if a smaller height is found, min_height will be given it's value } } 
Vim + Ctags/Cscope + Arch Linux is my ideal workflow for C programming.
Some stuff targeted specifically at Solaris, and some stuff intended to compile/run across Solaris, Linux, and FreeBSD.
I use C only once in a while at my day job, and it's mainly for server/embedded. 
trading software that targets linux
**Scanf format string** Scanf format string (which stands for "scan formatted") refers to a control parameter used by a class of functions in the string-processing libraries of various programming languages. The format string specifies a method for reading a string into an arbitrary number of varied data type parameter(s). The input string is by default read from the standard input, but variants exist that read the input from other sources. The term "scanf" is due to the C language, which popularized this type of function, but these functions predate C, and other names are used, such as "readf" in ALGOL 68. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
Non-Mobile link: https://en.wikipedia.org/wiki/Scanf_format_string *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^113636
Not sure if it counts but I write in a proprietary derivative of C for my day job. I program Crestron and AMX control processors for commercial A/V applications. I write C proper at night. 
Interesting - is it a low-latency trading platform? Or just a legacy system that happens to be written in C? i assumed by now all latency-sensative strategies had migrated to FPGA's.
&gt;I write C proper at night. Me too :-) I spent a couple of months recently playing with Rust, but the learning curve is massive. I quickly reverted to my security blanket...C :-)
Linux? fcking yeah! Server/Embedded? oh yeah, baby! AND system intrusion! haha 
Fair point. I suppose I ought to have said "with the same declarator."
It's a low latency trading platform. Certain markets and strategies are still profitable to trade through software rather than hardware. 
&gt; edit: I'm using c++ btw Then you want /r/cpp_questions. This sub is for C. But yes, switches within a switch works just fine. Post your code (to that other sub) if you want more directed help to your specific problem.
There should be no problem nesting switch statements. I think you may be expecting behavior that is different from what switch and break do for you. Here is an example (not a complete function, but taken from a real project): switch ( rx_state ) { case RX_INITIAL_ST: rx_log_idx = 0; Array_Index_Check( rx_log_idx, 100 ); rx_log[rx_log_idx] = c; switch ( c ) { case AMULET_MASTER_ADDR: rx_handle_transaction_as_slave = 0; rx_state = RX_RECEIVED_AMULET_ADDR_ST; break; case AMULET_SLAVE_ADDR: rx_handle_transaction_as_slave = 1; rx_state = RX_RECEIVED_AMULET_ADDR_ST; break; default: /* Ignore this character since it is not the expected start of a message; we hope to realign with the message stream on the next character. Remain in the initial state. */ rx_invalid_initial_char++; break; } break; case RX_RECEIVED_AMULET_ADDR_ST: rx_log_idx++; Array_Index_Check( rx_log_idx, 100 ); rx_log[rx_log_idx] = c; switch ( c ) { case LCD_OP_GET_BYTE: /* FALL THROUGH */ case LCD_OP_GET_WORD: /* FALL THROUGH */ case LCD_OP_SET_BYTE: /* FALL THROUGH */ case LCD_OP_SET_WORD: /* FALL THROUGH */ case LCD_OP_GET_BYTE_ARRAY: /* FALL THROUGH */ case LCD_OP_GET_WORD_ARRAY: /* FALL THROUGH */ case LCD_OP_SET_BYTE_ARRAY: /* FALL THROUGH */ case LCD_OP_SET_WORD_ARRAY: /* FALL THROUGH */ case LCD_OP_SET_STRING: rx_op = ( LCD_RxHandleState_e )c; rx_state = RX_RECEIVED_OP_ST; break; default: /* We don't expect this message! */ rx_unexpected_op++; rx_state = RX_INITIAL_ST; break; } break; ... So when we come into the switch on rx_state, if rx_state is RX_INITIAL_STATE, then depending on the value of C, we take some action. The break after case AMULET_MASTER_ADDR breaks out of the switch on c. When we hit the break we escape from the brackets and then hit the end of case RX_INITIAL_STATE, and break from the upper-level switch. Post some code if you have something that isn't working the way you expect and maybe we can help. 
Webserver and utilities on an AS/400 written mostly in C and ILE RPG.
I'm new to this subreddit. I write Pro*C, C with embedded sql for Oracle, targeted at linux. At home I write straight C targeted at linux.
I write C for firmware in network cards. The target market has historically been traders (low latency).
*I write C for firmware* *in network cards. The target market has* *historically been traders (low latency).* ______________________________________________________________________________ ^^^-english_haiku_bot
I think I see exactly where I went wrong. For some reason I was thinking that a function data type was necessary, but that is silly. The information about there being a function involved is conveyed by the paretheses. I also got the precedence wrong, so thanks for pointing that out.
Solaris and AIX servers
Strangely enough, we use tabs (\t) for the separators in the CSVs we output. This is because, if you open a tab-delimited file with a .csv extension in Excel, it properly places the data into columns. It doesn’t do so with comma-delimited files (have to use text to columns) Yes, I realize this is a hack and you can copy paste any tab-delimited string into Excel and it will put it into columns.
I mostly use Linux, but some of the stuff I work on will end up running on some weird 24 bit or even 40 bit CPUs no-one ever heared of.
Proprietary RTOS running on a Blackfin BF516. Although some of it does end up running on Windows, Linux, iOS, and Android. And whatever embedded hardware our customers might try to compile our code for.
I think the best thing you can do is copy merge sort in C from Rosetta code and replace the less than operator with your own comparison function. 
Uefi drivers. 
Fun! I spent several years writing C for RTOS-based BF537 and BF547 platforms.
Lately, RTOS and Linux based systems running on the ARMv7 cores of a Xilinx Zynq. And bare-metal code on an Atmel XMEGA microcontroller.
Yes, they work just fine. The break statement only gets you out one level. C and C++ don't have a way to break out of multiple levels. If you need to do that, use goto. Just to keep your sanity, do not, under any circumstances, google "Duff's device"
Exactly what I was missing, thanks so much!. Solved! 
Bare-metal C plus our own APIs (our own OS, at the core based on L4) for drivers/applications (which have a standard/custom linker script). ARM SoCs.
Window and Linux kernels, specifically the filesystem and block layers.
I write code for Embedded Linux running on ARM Processors. Some device drivers and some applications. 
ya know, I was never going to Google it, I didn't know that existed, but now I have to, I'll come back if still sane. 
good news, I don't know what it means yet so I'm still sane
In server how do you use C? 
Neat! Care to share what type of applications you were using Blackfin for? My company uses it for various VoIP products.
linux; filesystem for enterprise storage
All embedded. Mostly Kinetis (Cortex M4) these days, plus legacy code on ColdFire v1 (a descendant of the Motorola 68000) and HCS08 (a 6800 descendant). Edit: Forgot the hardware. It's mostly GPS trackers, LED hula hoops, poi, repeater controllers, weather stations, protocol translators, radio modems, and that sort of thing.
&gt; If you were to move /lib64/ld-linux-x86-64.so.2 away from what is hardcoded into all the binaries (only those not compiled with -static), maybe into /foo/ld-linux-x86-64.so.2, all those binaries would not start anymore with some error message. What do you mean by "move away from what is hardcoded into all the binaries"? Are you saying that it matters where this executable is located with relation to the binary files? Also, what do you mean by "binary" file? Are you refering to files that aren't "text" files, or are you saying that the executables that were compiled with the linker executable in one place can't function if the linker executable were to be moved after these executables were compiled? &gt; If you have the machine code for sqrt() in a shared library libm.so, every program that uses sqrt() and links to libm.so can share this one machine code. If you have the machine code for sqrt() in a static library libm.a, every program that uses sqrt() from it, gets the machine code copied into itself. What is the point of having two separate files for this? Couldn't you have just one library file stored on the hard disk and either load it into memory as a shared library or statically embed it in the machine code of the executable. Also, I think I might have a bunch of unnecessary libraries or something back when I was trying to figure out how to get a C compiler working on this old laptop that I installed Ubuntu on. [This](https://i.imgur.com/sMINbgc.png) is what my /usr directory looks like. It has the include directory as expected, but it also has two directories in it called i686-w64-mingw32 and x86_64-w64-mingw32, which also have their own include directories. These include directories are filled with mostly linked header files and a little bit of C source files. One more thing. I think I did something strange on this laptop. I don't need "./" to run executables in the current directory. If I'm understanding it correctly, "." refers to the current directory. My raspberry pi does require the "./" in front of executables though. I'm not sure what I did to make this happen. Thanks for your response. 
We have a custom web server written in pure C at my work. It doesn't really do anything (we've moved to the cloud late last year) but the boss wants it maintained in case we need it in the future. 
Arm7, custom OS.
This book called [The C Programming Language 2nd Edition](https://i.imgur.com/iK5m3Tn.png) says that the source code must be in a file that ends with the extension .c on Unix systems.
Kate, on Win 10 and on Linux.
Boring Linux x86 Servers. 48 core, 256GB RAM, stuff like that. We had some SPARC machines but they are all gone but one that I think they just keep as some stupid joke, and to test that this stuff still works on big endian in case that becomes popular again, I don't know. Some of our stuff uses inline assembly in places. New hires think we are insane, until they realize that if it was written in Java we would need so many more machines. A lot of people point out C++. Our codebase predates Boost and many of the nicer libraries and features of C++ so at the time C was the only reasonable choice. That, and I think the new hires are right, some of my coworkers are madmen.
Low level hooking library for Android devices.
At work it's pretty much C/C++ on x86_64 Linux among many other things, but at night lately I'm working on an 8-bit-computers-in-space type game with Unreal Engine. While the emulators are written on Windows in C/C++ (for easy integration into UE4), I'm using sdcc to compile code for the Z80 CPU's that we emulate, target platform is initially CP/M 2.2, but later on will hopefully be Fuzix as well once we get that running. https://i.imgur.com/2nagJS4.png
Oh geez, is that still a thing? I haven't touched that in close to 20 years. More often I was working in Pro*Cobol at work, but I remember messing around in C with Oracle Spatial when it came out.
Anyone who recommends Java is a madman or gives two shits about system resources and overhead.
EDA software that targets Linux :D
Why do something in O(n) when you can do it in O(n log n) or worse. 
linux...rhel, sles
At home, I use FreeBSD. At work I write scientific code in C under Linux and take care to make it sufficiently portable so it is portable among UNIX systems; mostly so I can work from home. The scientific code some times uses MPI to run on large compute clusters. That's a lot of “fun” to program.
Yeah! Solaris! I used to do an internship where I developed a Solaris distribution, so this operating system has a special spot in my heart.
Let me pin this thread as it's very interesting to our readers.
C++ is off topic in this subreddit please ask elsewhere, e.g. in /r/cpp_questions.
Microchip PIC 24 series mostly but some 18 series aswell. Fun times
Mostly ATmega168/328 and Atmel SAM4E. But In the last months i tend to write more C++ than C for them.
Are you trying to parse tar files?
Binary, executable, compiled code, all mostly means the same. &gt; or are you saying that the executables that were compiled with the linker executable in one place can't function if the linker executable were to be moved after these executables were compiled? Yes. $ ls -l /lib64/ld-linux-x86-64.so.2 lrwxrwxrwx 1 root root 10 12. Sep 19:47 /lib64/ld-linux-x86-64.so.2 -&gt; ld-2.26.so $ sudo mv /lib64/ld-linux-x86-64.so.2 ~ $ cat $ zsh: command not found: cat $ /lib64/ld-2.26.so /usr/bin/cat That works. Also I'm realizing that was a bad idea because it looks like sudo or su need to load some shared libraries on their own and need the linker in this place to actually work. Gotta have a shell with root rights already open, then you can just `/lib64/ld-2.26.so /usr/bin/mv ~/ld-linux-x86-64.so.2 /lib64/` again. I might have to boot from an usb flash disk to fix this. Oops. &gt; What is the point of having two separate files for this? Couldn't you have just one library file stored on the hard disk and either load it into memory as a shared library or statically embed it in the machine code of the executable. I don't really know. I think shared libraries don't contain enough information to do that. It would have probably been possible to specify a file format that can be used for both, but they didn't... &gt; mingw32 mingw is a separate version of gcc that only creates windows executable. If you want your output to be a .exe file you can run on windows, then you use mingw's gcc. &gt; If I'm understanding it correctly, "." refers to the current directory. Yes, `./` just is to explicitly tell the shell that you're giving it a relative path. `ls hello1.exe` and `ls ./hello1.exe` really does the same thing, except that the shell can see the `./` and may regard what follows as a path to an executable. On windows if you go into a directory that contains hello1.exe and type hello1.exe, it will happily run the executable from the same directory. On \*nix they thought that was a bad idea and you are required to specify a path for everything that is not in the $PATH variable. `echo $PATH` will probably show that your "current directory" is in that search path for binaries. 
atoll, but that's for ASCII.
My day job actually involves programming Java. I picked up C the past year, all in my free time. Mostly because I want to make contributions sometime to either the Linux Kernel or GNU software or whatever what's written in C.
I maintain a development environment written in C for Windows, Linux, and macOS desktops. The Windows version is using Win32 API, while the Linux and macOS versions use GTK+ (with some relatively minor differences for each OS). It's fun to work with a large, cross-platform codebase written in C!
I don't think this is very useful to our readers. Why do you make and post these?
it depends on how big the number is. I guess you read from stdin so you can try: int number; scanf("%d", &amp;number); if the number is too big for a unsigned long long int (maximum value 2^64 ) then you need to think of something different entirely. It also depends on if your number can be negative. Give us more information to help you more, if you need it.
Blackfin/uclinux. Does audui shit, infuriating to debug. 
Simulator running on the Linux/Intel platform
Man, I haven't touched an AS/400 in about 13 years. That was COBOL though for me.
Definitely a ton of embedded stuff; led drivers, Hvac systems, controller boards for machinery. I also enjoy programming in c for Linux stuff; such as ncurses console apps. 
Plus, it tells people to use scanf instead of scanf_s
By itself it's useless. It's generally used to declare *pointers* to functions, as a lot of people find C's syntax for pointers to functions to be difficult to parse. For example, which is more readable: int *(*foo(int *(*)(int *)))(int *); or: typedef int *f(int *); f *foo(f *); They're equivalent, but the second is typically easier to read. The typedef introduces a new type which you can conveniently make a pointer to.
You aren't using typedef "as" a function. You are defining a type alias for the type pointer-to-function which is easier to read and easier to use. Function pointer syntax gets hairy fast. Which is more readable? typedef int (*callback_t)(char *, int); ... void some_func(int foo, callback_t cb) { ... } Or this: void some_func(int foo, int (*cb)(char *, int)) { ... } Or how about: callback_t foo = some_func; vs int (*foo)(char *, int) = some_func; Not to mention the hoops you have to jump through if you want to have a function pointer as the return type; which do you prefer, this: callback_t returns_fptr(long); or this: int (*returns_fptr(long))(char *, int); Note that in the second example you are declaring a function that returns a function pointer, not int. The int is what the pointed-to function returns. Using a typedef is almost mandatory at that point. 
How is this more useful than just typing out the code? Is there a way to report these spam accounts on a site level or just particular posts?
`scanf_s` is a useless function as is all of Annex K. Don't use these, they are a terrible idea. See [this article](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1967.htm) for some arguments as to why I advice not to use them.
Do not use `%d` to print pointers. That's undefined behaviour. Instead, use `%p` or cast the pointer to an `int` (better, `uintptr_t` or `size_t`) before. On my machine (amd64 freebsd), the code works if you do that.
Instead of executing the `sort` program, I recommend you to use the `qsort` standard library function. &gt; I think I may have to save the data in a text file (with 2 columns) and then call sort on it, but I'm not 100% sure. Yes, that's correct. If you have never worked with `fork()` and `execl()` before, I recommend you to read the documentation. In your particular example, you might also want to clear the environment in the child process so `sort` sorts according to the C locale (usually, that's what you want). Your `execv` call is going to look like this: execl("/usr/bin/sort", "sort", "-o", output_file_name, input_file_name, NULL); You can also use `sort` as a filter by attaching a pair of pipes to it, but that's a bit more tricky to program. Read the documentation of `sort` (type `man sort`) to find out how to specify what key to sort by. Really though, try to use `qsort()` instead. Much easier to program.
I think you've found a bug in the Linux loader! First, the example makes a mistake about printing pointer as an `int`. It should be cast: printf("size: %zu\n", (size_t)&amp;_binary_blob_bin_size); Unfortunately this is not the source of the problem. The problem arises because your system has PIE (position independent executable) enabled by default. This causes the loader to relocate the absolute symbol, which defeats the purpose of the symbol being absolute. You can fix this by passing `-fno-pie` to the compiler and `-no-pie` when linking. This process of linking binary blobs like this has always been flaky business, and seeing it get screwed up even further makes me never want to use it again. You should [serialize to C](http://nullprogram.com/blog/2016/11/15/) instead via a helper program. That's both portable and reliable, unlike GNU's `ld -r -b binary`.
Congrats! You used an artificially contrived example to make a quite simple concept appear very difficult. You probably make a good teacher. /s
Oh! I didn't even think about this absolute symbol business. It's not really a bug though, rather, the ELF standard should be fixed to define two kinds of absolute symbols where one is relocated in shared objects or PIE binaries and the other is not.
I technically work on a cross-platform graphics driver, though I'm usually focused on working on the Windows side (unfortunately).
If that's true, then the ELF standard is buggy. ;-) Still, I want to find where it says absolute symbols are to be relocated. Under "Symbol Table": &gt; `SHN_ABS` The symbol has an absolute value that will not change because of relocation. But under program loading it says this with the term "absolute address": &gt; The dynamic linker relocates the memory image, **updating absolute addresses** before the application gains control. Although the absolute address values would be correct if the library were loaded at the addresses specified in the program header table, this normally is not the case. And: &gt; Position-independent code **cannot**, in general, **contain absolute virtual addresses**. So does this mean the dynamic linker to *supposed* to relocate absolute symbols?
Thank you, that is it! That will help me out greatly, not sure I would have figured that out on my one. I will give your link a thorough read. Thank you again :)
ARM Cortex-M, bare metal (though usually with an RTOS) 
I've been programming C for over a decade and apparently have never returned a function pointer. That syntax just broke my brain!
I love that LED hula hoops is thrown in there. :)
It'd be a lot simpler to use qsort() if you organize your data in a single array of structs, instead of multiple arrays each with a single component of each record. 
Embedded, specifically Cortex M4 (STM32F3) and Xtensa (ESP32).
Honestly those are at least 50% of our revenue these days!
The standard sounds contradictory. Perhaps file an interpretation request?
Embedded devices using different kinds of processors, some with OS (nucleus, linux) some without.
generic linux 
If you are using `scanf()`, why do you think you need to use a while loop? Consider using a formatting string like this: scanf("%d ", &amp;num); to scan the number. Then use `fgetc()` to read characters until you encounter the `=` character.
[removed]
typedef HGLOBAL (WINAPI *GlobalAlloc)(UINT, SIZE_T);
You're right. When I read OP's post, my first thought was highly optimized OOG.
I'm still going to make a real effort to learn Rust because it is so intriguing, but it is by far the most difficult language I have ever attempted to learn -- by a mile. I'm old now and have written production code in a dozen languages or more (Pascal, Object Pascal, VB, C#, C, C++, Python, PHP, etc) and nothing is even close to as inscrutable as Rust. Early on I was really excited that Rust might realistically be a "safe C replacement" but I think this is less and less likely as time goes on. When you really need to optimize something to save every cycle you'll still use C or even ASM, and if you can be a bit more lax with performance Go is probably fast enough (and 100 times faster to develop in). I'm not sure where Rust fits. It's still cool though. 
Pretty much the same way, with bitwise and and shifts.
You do the same thing, with bit shifts and masks. The difference is that your mask will have more than one bit in it and you'll be shifting 8 bits at a time. unsigned long mask = 0xFF; // Eight bits in mask unsigned long value = 0xFEDCBA9876543210; return value &amp; (mask &lt;&lt; 8 * bytes); (Pedantic note: not all systems have 8-bit bytes, and `unsigned long` might not be 64 bits. Whatever, this is just to illustrate what needs to happen.)
Oh shit, I'm sorry your computer got messed up while trying to answer my questions. Does the shell program also use those libraries, and does that mean that your computer won't boot? I hope you don't end up losing any important files. I remember messing with the PATH environment variable at one point when I was trying to figure out how to get started, but when I print out all of the directories in the path, I get [this](https://i.imgur.com/Pt9GXA9.png).
Wrong quantities.
Are you working for nvidia?
Primarily programming an OSD/HUD board for R/C vehicles for an ARMv5TE SoC (Fujitsu MB86R01) using FreeRTOS and proprietary device manager, drivers, and such that I have written myself. Development environment is Eclipse CDT + Hardware GDB Plugin for code writing and debugging, JLink JTAG, and GCC `arm-none-eabi`v4.8.3 toolchain. 
Heh, no problem I just had to boot another system from a usb flash disk and move that file back. I wanted to update my EFI and had to reboot anyway. Yes, the shell is just another application, most are written in c or some maybe c++. More importantly systemd's init uses shared libraries and doesn't run without a linker. So no, it doesn't start. I haven't tried it but using the kernel command line `init=/lib64/ld-2.26.so /usr/bin/bash` could work (but probably it has to be one command without spaces). Interesting that your directory really isn't in path and you can still run it. If `which spwd.exe` displays that same ~/Documents/CS355/spwd.exe path, that's a mystery.
I was working on battery-powered radio and sensing systems for a defense contractor. I enjoyed working with Blackfin - good documentation and a nice blend of capabilities.
sizeof(char) isn't right either.
You've exactly summed up my thoughts on Rust, and I'll likely give it another try at some stage mainly because it's so "intriguing" as you say. I think Rust has a lot of promise, but I feel its complicated syntax will prevent a bigger uptake in the longer term. 
&gt; I'm old now and have written production code in a dozen languages or more (Pascal, Object Pascal, VB, C#, C, C++, Python, PHP, etc) and nothing is even close to as inscrutable as Rust. Have you tried a functional language like Haskell or a Lisp dialect (e.g. Scheme) before? If not, I'd suggest to do so one day. They are a very different experience from the usual suspects we use to write programs.
Do you need a lot of domain knowledge to go into scientific programming? I don't know yet which specific route I want to go after my CS studies at university but Scientific Programming looks interesting (among other fields such as Embedded...), I haven't taken any physics (or other natural sciences) courses yet though (planning to take classical mechanics next semester), besides the usual mathematics courses. Did you also study CS or did you study Math/Physics/Chemistry/Biology etc. and went into programming as a career changer?
Because when those signatures get really complicated, and you have a million that need to match, this allows the compiler to better validate your work
I'm currently studying computer science. This is the first subject I study, you can find my CV [here](http://fuz.su/~fuz/cv/cv.pdf). As a side job, I work in a research institute doing computer science research. My current topic is heuristic search in huge implict graphs and I'm going to write my bachelor thesis about that. No prior knowledge about this subject was gained at university (beyond the basics of graph searching you learn in the introductory classes), I got interested in this subject through chess programming. I wrote a [tablebase for Dobutsu Shogi](http://github.com/fuzxxl/dobutsu) and used the knowledge found while writing this to design PDB heuristics for graph search.
OP code typedef a function type, not a function pointer type.
It makes no difference to the compiler - the main purpose of typedef is to help the programmer
I have...i played around with Haskell for a couple of months about 3 years ago (personal side projects). It took a while for me to get my head around the type system but i could see the attraction of it. I wonder if the reason it hasn't gained traction in industry is simply the dominance of C-type languages. Regarding Rust, you can see the influence of OCaml and Haskell in Rust - which makes me think it will affect the adoption of it....but maybe I'm too old school and set in my "C" ways :-) 
`foo` is another name for the type `int (char *, int)`, i.e. function taking `char *` and `int` returning `int`. Functions do have a type , in case you'd never thought about it. You can use `foo` to declare functions of that type, e.g. `foo a, b, c, d;` declares 4 functions. Also you can use `foo *` for the type "pointer to function of type `foo`. There are examples of function pointer use else where on this thread, but many experienced C coders prefer to avoid hiding pointer types behind a typedef as was done in those examples. We all know what `*` means, but it makes the code harder to read if `BAR b;` turns out to actually be a pointer declaration. 
You badly misunderstand me.
Maybe you should do a better job of explaining what you mean then?
I guess I feel like that's probably good enough. Have a nice day
&gt; My current topic is heuristic search in huge implict graphs &gt; I got interested in this subject through chess programming. Yeah, I can imagine that being one application where you have to deal with huge state spaces or structures in general. Graph theory was definitely one of the more interesting courses so far. We have a special elective course here about common algorithms, theorems and proofs. A bit more challenging than others, but also a lot of fun. In case you are interested, the course was mostly based on Turau's "Algorithmische Graphentheorie" (minus several errors in the proofs - as our lecturer liked to point out). I can see that you're also German. I see from your CV that you study Mathematics additionally. Are you doing a 2-Fach-Bachelor or a double Bachelor? I also considered studying Mathematics after school and I still feel like I should do (or at least unofficially attend) more math courses. They (e.g. probability and measure theory, at least for me) are harder than most CS stuff and they probably train the brain a lot more, at least the assignments are more demanding in my opinion.
&gt; Yeah, I can imagine that being one application where you have to deal with huge state spaces or structures in general. Indeed! The subject of my bachelor is that I found a way to get results comparable to those you get with a very huge (1 TB) lookup table using a bunch of smaller tables in combination. The idea is that each table covers some part of the state space well, by taking a bunch of smaller tables you can cover as much as one large table covers but save a lot of space at the expense of some runtime offset by the better scalability. I also have some future ideas in mind as outlined [here](https://www.reddit.com/r/math/comments/70w06g/what_are_you_working_on/dn85ch0/). I started both a Bachelor in mathematics and one in informatics at the same time because I wasn't sure what to choose and enrolling in two subjects without a *numerus clausus* is easily possible. I have since almost dropped the bachelor of mathematics. I am very interested in graph theory and this year I narrowly missed participating in the course *graph algorithms,* but hopefully, it's going to be available again in the winter.
Before I started with C, I have actually extensively programmed in Haskell. So much in fact that I got the golden Haskell badge on Stack Overflow. I really like the ideas in Haskell, but I eventually realized that Haskell is unsuitable for professional software development because the entire tooling is a huge pile of shit. None of the interfaces follow coherent ideas and everybody does everything in a different way. One of the key things that made me give up was realizing how there are three or four string types popular in Haskell libraries, so if you are using a bunch of libraries, you need to convert your strings back and forth everywhere. Error handling is really nasty too since the Haskell standard library embraces exceptions in all the wrong places. It really sucks to have exception-based monadic IO, I can tell you. Also, Haskell programs can have crazy performance deviations from the most innocuous changes due to the complicated and wholly non-obvious optimiser. That's just something I can't have when developing provessional software.
In addition to the reasons you and /u/user_not_permitted stated, another one is probably that functional features slowly creep into existing languages, lessening the urge to go all in with functional languages. For example, [this talk](https://www.youtube.com/watch?v=1OpAgZvYXLQ) demonstrates the functional features that were added to Java. It's not Haskell of course but it's something. However, I have mixed feelings about it. It does lead to more readability in some cases but does make things more obscure if it's overused (like in parts of the Java project, my team is currently working on... one member is quite the enthusiast). I also don't fully understand how it works internally... while OOP is straightforward, functional programming is pretty far removed from the C way of doing things. But as an academic curiosity, I see no problem with FP, and Quicksort for example is definitely shorter and easier to understand in Haskell than the typical implementation in C. :) quickSort [] = [] quickSort (x:xs) = theSmaller ++ theEqual ++ theLarger where theSmaller = quickSort (filter (&lt; x) xs) theEqual = filter (== x) (x:xs) theLarger = quickSort (filter (&gt; x) xs)
In practice, apis typically typedef a *pointer* to a function type: typedef int *(*f)(int*); declared as f foo = a_function; rather than typedef int *f(int*); f *foo = a_function; probably because unlike every other value in C, assigning a function name to a pointer implicitly provides a reference to the function, rather than requiring the `&amp;` operator.
The old excel format is proprietary. MS Office file formats have used the open standard [Office Open XML](https://en.wikipedia.org/wiki/Office_Open_XML) since 2007.
**Office Open XML** Office Open XML (also informally known as OOXML or Microsoft Open XML (MOX)) is a zipped, XML-based file format developed by Microsoft for representing spreadsheets, charts, presentations and word processing documents. The format was initially standardized by Ecma (as ECMA-376), and by the ISO and IEC (as ISO/IEC 29500) in later versions. Starting with Microsoft Office 2007, the Office Open XML file formats have become the default target file format of Microsoft Office. Microsoft Office 2010 provides read support for ECMA-376, read/write support for ISO/IEC 29500 Transitional, and read support for ISO/IEC 29500 Strict. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
Sublime text is my go to. 
Depends on the floating point format I guess. There's things [like this](http://www.delphibasics.co.uk/RTL.asp?Name=Currency) is various languages.
May I ask how low latency? I work with trading software as well, so for comparison.
Hey sorry you're getting buried in downvotes, but I think you have a good point. The `signal` function call probably would have been a better example.
Any time you have "linked" data that's a strong hint that you should use a struct. That way you can store the teams in an array of structs and sort them together, just like u/raevnos said. No need for forking new processes or anything fancy. typedef struct team { char *name; int score; } team;
For simple programs emacs. For large application some ide like eclipse.
dozens of microseconds
Our stuff is also targeted for Solaris, although we're trying to switch away from that (given that it's pretty much dead at this point) towards Linux. 
C deals a lot with system files and shit. Reading input from text and outputting as a simple execute file. It's similar in capabilities to java but with a lot more technicality basically because it's old
I made a shitty pong game today with the curses library. https://www.youtube.com/watch?v=RV-SIlKBG5Y
Those code snippets are being displayed as one line. Please reformat it or link it to where it is formatted if you want people to actually read it.
The `signal` handler is easy: void (*handler)(int); Note the `*` indicating a pointer. There are parentheses around `*handler` so this is not parsed as void *(handler(int)); i.e. `handler` is a function taking an `int` returning a pointer to `void`.
Except the code has abysmal runtime as it is not in place and you filter the list thrice instead of once, wasting a bunch of time and stopping the code from streaming well. It's actually surprisingly difficult to get this function right, I dimly recall an article about exactly this example but I forgot where it is.
Format code for display on Reddit by putting 4 spaces in front of every line.
I am not sure what point you're trying to make. As I understand it, OP already understands the syntax of a typedef of a function pointer but doesn't know *why* it would be useful. The top-level comment tried to give an example of a case where such a typedef might be useful, namely a function that takes and returns a function pointer. And the reply to your comment (the grandparent of this comment) was referring to the `signal` function itself, not the handler type. **EDIT**: A word
Doesn't the series diverge for |x| &gt; 1? Maybe you should base the Taylor expansion on the nearest integer i.e. exp(2.14) should be based around exp(2).
Firmware for elevator control panels and low resources VPN clien for IOT.
That's still IEEE 754, they just multiply everything by 10,000 behind the scenes so the rounding errors occur at or beyond the fifth decimal.
That is not C. It could be C++ or C# or something else, but whatever it is, it's off-topic here. 
Random is not a value type. Its a class which you have to instantiate by the keyword new. But yes, offtopic. That code is not C /r/csharp is excellent if you are looking for C#
i put the code on github
You could also use pointers and a one-byte type, that'd be my preference to masking. int n = 0; // the byte we wish to extract unsigned long long ull = 0x8899AABBCCDDEEFF; // arbitrary data unsigned char * ptr = (unsigned char *)&amp;ull; // pointer to the beginning of the data for (n = 0; n &lt; sizeof(ull); ++n) { printf("byte: %d\tdata: %d\n", n, ptr[n]); } Do take note that in this instance the endianness of the system would matter. For instance, on my PC (little endian) this will print out 255, 238, 221 etc. 
Slight modification to the existing stuff: unsigned long value = 0x0123456789ABCDEFULL; return (input &gt;&gt; (8 * byte)) &amp; 255; That’s to find the C “`byte`th byte”, which is the `byte`th least-significant byte regardless of how it’s stored in memory. (Note that `byte` must be bounded per standard to 0 through bits_in_long−1, or otherwise you get implementation-defined behavior. Most arches take the shift mod 64 or mod 32, depending on size of `long`, but the optimizer might not.) If you want the actual memory representation (including little-endian/big-endian transforms), there are two options. First, C89+ compatible: unsigned long value; char data[sizeof(value)]; memcpy(data, &amp;value, sizeof(data)); return data[byte]; This avoids pointer punning, which can bork an optimizer. The `memcpy` is probably ~free. C99+ option: const union { unsigned long value; char data[sizeof(unsigned long)]; } u = {input}; return u.data[byte];
I am still a bot confused, so if foo is taking in a char* and int then how does it know what variables are being sent over from some_func? why do I see this for a better example int (*foo)(char*,int) foo getSomething();
so if it's a pointer to a function how am i supposed to pass variables to the function? or does f* just hold the variables I will end up passing over?
It's usually not a good idea to do this, since this code only works on little-endian architectures. The method described by /u/nerd4code is more portable.
The Taylor series should converge mathematically, but that is not the same as converging in gloating-point math. In floating point math, for example, it makes a difference what order you perform summation in (the phenomenon to worry about it called [precision loss or loss of significance](https://en.wikipedia.org/wiki/Loss_of_significance)). I think in your case the problem is that the terms in the sum get very large before they again get smaller, which causes floating-point precision problems. I suggest it is better to compute exp(-x) as 1.0/exp(x). Also you might find it helpful to read https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html (don't be put off by the oracle.com URL, it was originally published on Sun's website). 
**Loss of significance** Loss of significance is an undesirable effect in calculations using finite-precision arithmetic. It occurs when an operation on two numbers increases relative error substantially more than it increases absolute error, for example in subtracting two nearly equal numbers (known as catastrophic cancellation). The effect is that the number of significant digits in the result is reduced unacceptably. Ways to avoid this effect are studied in numerical analysis. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
&gt; gloating-point math I love this! My answer is better than yours! 
Read a c++ article in a C subreddit? Are you lost?
what
The code you just posted doesn't compile , I'm not sure what you are asking sorry.
**NEW C++** 
good bot
How about fuck C++ and it's incredibly complicated syntax.
Mac/POSIX and Windows but they still don't support _Generics so they're on the back burner, well they've always been on the back burner...
If I continue on with my example, here's how one might use pointers to functions of type `f`: // Here I create two functions of the same type. // These functions don't do much of interest. int *func1(int *x) { return x; } int *func2(int *x) { int *y = malloc(sizeof (int)); *y = 0; return y; } // Now I'll make a function which has a parameter which // is a pointer-to-function. It also returns a pointer-to-function. typedef int *f(int *); f *foo(f *func) { if (func == func1) { return func2; } else { return func1; } } // Now we can try using those pointers-to-functions int main(void) { f *a = foo(func2); int x = 2; int *y = a(&amp;x); printf("%d\n", *y); return 0; } You can try out the code (assuming I didn't make a typo). The main function calls the `foo` function, giving it an argument of a pointer to the function `func2`. The `foo` function checks to see whether the parameter is pointer to `func1`. It isn't, so it returns a pointer to `func1`. The main function's `a` variable then is pointer to the function `func1`. When we call the function `a`, then, we are actually calling the function `func1`. It's not a very useful snippet of code. If you've never seen pointers to functions before, you may well wonder what the *point* of it is. However, you can still understand the mechanism for how it works even if you don't understand the point of it. There are a few uses for pointers to functions. The most common use (probably) is to give a function a pointer to a "callback function", which is a function to be called in case some event happens. It fits into a paradigm of programming called event-driven programming. Sorry that this explanation is probably unsatisfactory, but it's a lot to explain in one reddit comment. If you have questions about how to use event-driven programming, I would recommend reading some tutorials on event-driven programming ([here's one](https://sourceforge.net/projects/eventdrivenpgm/files/)). Another common use of pointers-to-functions is polymorphism. This is best demonstrated by the standard `qsort` function in C. `qsort` looks like: typedef int compare(void const *, void const *); void qsort(void *, size_t, size_t, compare *); The first 3 parameters to `qsort` describe an array to be sorted (a pointer to the first element of the array, the number of elements, and the size of each element). The 4th parameter of `qsort` is a bit different. It's a pointer to a function that `qsort` can call whenever it wants to compare 2 elements. By having a parameter of this sort, `qsort` can sort elements of *any* type, so long as a comparison function is defined (i.e., `qsort` is polymorphic).
Rewrite C++ in Rust
Rewrite rust in go
Rewrite Go in C
I'd agree with the caveat of "it depends". If I was developing an application that I wanted to be cross platform at some point, absolutely. If I know where my code will be run and can prepare it for big/little endian architectures or am doing some weird data-specific things I'd much prefer it this way. Maybe it's just me but my eyes start going crossed when I'm trying to read through people's bitshift logic. (edit: not trying to argue, just saying there are cases where I'd much prefer this method)
1. "if variable equals value" is more legible. 2. That doesn't prevent something like `if (a == b)` (two variables) 2. With gcc, `-Wparentheses` (included in `-Wall`) warns you about `if (i = 8)`
It's not used because it doesn't make sense grammatically, that is, with how questions are phrased in natural language. No one asks "is the blue sky?", they ask "is the sky blue?". Almost universally, it's "is unknown equal to known", not the other way around. Frankly the fact that assignments are allowed in expressions is probably a mistake, but modern compilers can warn you for doing so.
Good thought but it's already a thing. It's called a Yoda notation. [Yoda condition](https://en.m.wikipedia.org/wiki/Yoda_conditions) Some people do use it but uncommon because of the awkward way it reads. It's usually a team/project preference. 
Non-Mobile link: https://en.wikipedia.org/wiki/Yoda_conditions *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^114306
**Yoda conditions** In programming jargon, Yoda conditions (also called Yoda notation) is a programming style where the two parts of an expression are reversed from the typical order in a conditional statement. A Yoda condition places the constant portion of the expression on the left side of the conditional statement. The name for this programming style is derived from the Star Wars character named Yoda, who spoke English in a non-standard syntax. Yoda conditions are part of the WordPress and Symfony coding standards. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
These are colloquially referred to as [Yoda Conditions](https://en.wikipedia.org/wiki/Yoda_conditions). My team uses them in all of our code, but the argument made against them is, "they're sometimes less readable, and often times the compiler will toss a warning your way if you mess up a non-Yoda condition." For example: if(a = 5) { /* etc. */ } Can return a warning in compilers like gcc and clang (depending on your warning level). That said, the following won't generate a warning: if((a = 5)) { /* etc */ } Because of the extra set of parentheses. We work in a big old code base with a ton of assignments inlined into all manner of places. Using Yoda conditions probably saves us a few hours of debugging every now and again, and (like most style idioms) stop being less readable after working with them for a short while.
Here is the PDF from the original : http://www.itu.dk/~sestoft/bachelor/IEEE754_article.pdf
We use them too, but we have lots of different compilers, some with better reporting then others. It really isn't that hard to get used to reading. You gotta be pretty green or stubborn for this notation to effect your ability to read the code. We also enforce comparing all "booleans" to false (0).
While this is one of my weaker areas, I would like to try and contribute. There are some things traditional checkers will pick up, like potential array overflows and out of bounds memory accesses which could be buffer overrun attacks. But, there is a whole area of implementation specific / compiler gotchas you have to worry about. http://www.daemonology.net/blog/2014-09-04-how-to-zero-a-buffer.html At the end, he is still struggling with CPU architecture for ensure secure data has been removed. It seems like a deep subject.
I've seen it advised in some code style guides, however I don't use it because it seems less readable to me, and most if not all compilers that I've used will generate a warning if there is a non-parenthesized assignment in a conditional.
Rewrite lisp in lisp
This subreddit is about programming in C. Please post C++ content elsewhere.
It feels a bit unnatural to have the constant on the left side.
This book seriously must be quite old. It uses K&amp;R-style function definitions. The code looks okay though and should work. If the `gauleg` routine wasn't ending, how did you get any printout at all? I suspect that the error is in your code, not the `gauleg` routine. Could you show us what you wrote?
Do you know how to calculate a factorial using a loop? If you do, it shouldn't be too difficult to adapt that to the binomial coefficient.
Actually I've just discovered that the function wasn't matching with my code ,i remade some lines of the function and finally worked. Indeed this book is really old,but there's a lot of interesting stuff there. Thank you for trying to help me.
When the value is a long expression, I think it's more readable to have the comparison first: if(0 == some_very_long_function_here(with_some_arguments_that_take_up_a_lot_of_space)) ... Because otherwise the comparison to 0 is just hidden away very far in the expression syntax.
My pleasure.
Good bot
Thank you lakshayg for voting on WikiTextBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
Fun fact: in Greek (and probably other languages as well) you can use whatever word order you want. SVO is still the most common form but it wouldn't sound weird to say "is blue the sky?". I am not using this as a counter argument, I agree with you. 
I do this. Particularly for NULL comparisons. 
I'd prefer splitting it up into multiple lines at that point. Example: some_condition = some_very_long_function_here(with_some_arguments_that_take_up_a_lot_of_space); if(some_condition == 0) { // ... }
Some people use this to allow the compiler to catch a typo it otherwise wouldn't. If the literal is on the left and you accidentally type a single equals, your code doesn't compile. 
Computing the binomial coefficients via factorials will quickly exceed the precision of your numbers. Use the algorithm from Wikipedia instead. 
Wikipedia's "multiplicative formula" was basically what I had in mind. I didn't say OP should use factorials directly, only that if they knew how to do factorials then it would be easy to adapt it. (My next step would've been to have them derive the formula from the usual factorial definition.)
I haven't seen this is C/C++ but I have seen (and use) something similar in Java: if (CONSTANT.equals(variable)) instead of if (variable.equals(CONSTANT)) because the former won't crash if the `variable` is `null`
Exactly, this allows for better readability, debug printing and possible reuse.
Might be worth looking up idiomatic code.
The place I used to work mandated this and it annoyed the shit out of me. They went so far as to not allow `if (x &lt;= 4)` And instead require `if (4 &gt;= x)` Which IMO makes a logic error far more likely than the original problem they were trying to solve. I think there is minimal benefit to flipping the order like this, and these days there is absolutely no excuse for insufficient unit tests. If a missing '=' makes it to production, it wasn't tested properly, period.
Try to load your module. If it loads succesfully, that means the curl dependency could be satisfied by the dynamic linker. If not, `dlopen()` fails. You can retrieve the error reason using `dlerror()` and present it to the user. Generally though, if the user can compile your utility, that means `curl` is available. So unless you want to distribute your tool as a binary on platforms that don't have curl by default (e.g. Windows), why don't you just look for curl in a configure test?
Well, unfortunately I'm not too good with the various build methods, and just want to keep it simple. Currently I can easily distribute it to Linux via simple tar packages. But yeah, you're right to compile it from source will need it anyway. 
In my experience anyone that has started programming with C uses ( 0 == x ) where anyone that started off with Java or other languages closer to natural language ( hah! java! natural!) tends to use ( x == 0 ). Since coming across the ( 0 == x ) and starting with C I have tried to use this convention myself but slip back into the more natural ( x == 0 ) (I'm a java boy)
Using Yoda conditionals, as they call it, is part of the WordPress PHP style guide, so that seems like one reason to avoid it. There is the accidental assignment argument, but in my life I think it's happened to me twice, maybe.
&gt; gloating-point math Oops. I'll leave it uncorrected :)
This indicates that `g` contains a NaN (not a number). I suppose this occurs when `sin(gg-pow(m,2*r)-r)` results in a negative value as exponentiation of a negative number by a real number generally yields a complex number. C can also do complex math, but I don't think the Microsoft C compiler supports this as it's a relatively new feature.
The problem is that you're passing the result of `sin`, which may be negative, as the first argument to `pow`, and [`pow` only accepts positive numbers as its first argument.](http://port70.net/~nsz/c/c99/n1256.html#7.12.7.4p2) You will need to find a different way of calculating _sin^r_ in order to make this formula work.
Thanks a lot for a clear answer, FUZxxl. Strange. I use Code Blocks with the MinGW GCC C/C++ compiler. Do you know how to resolve this problem? Cheers 
Thanks, Snarwin for answer.
Well, don't take real powers of negative numbers. There following solutions seem possible: * rewrite your formula to not take the power of a negative number * rewrite your code to use complex numbers. Confer the C standard for how to use complex numbers in C. * if your C compiler does not support complex numbers (it's quite a new feature), you could implement complex arithmetic manually, but it's a bit complicated with transcendental functions.
 I included complex library(#include &lt;complex.h&gt;) and wrote double complex g=pow(sin(gg-pow(m,2*r)-r),r); But now i have a question, how do I print the result of g? printf("g=%f%f\n",creal(g),cimag(g)); doesn't seem to work Thanks again for your help.
Infineon Aurix. Used to do Arm variants. Don't see any automotive posts on here yet. Get to deal with quirky compilers, poorly written documentation, and very confused HW engineers. I'd say the SW team is 50% EEs, 30% CSs, 20% CEs.
This subreddit is about C only. Please ask C++ questions elsewhere, e.g. in /r/cpp_questions.
“doesn't seem to work” is not an error description and completely useless for me to help you. Anyway, do you think `pow` magically returns a complex number if you cast the result to a `double complex`? I don't think so. Try using the complex power function `cpow()`.
hahahaha wtf
I didn't think about using a compiler as a solution. This makes sense because logical operators have higher precedence than the assignment operator, which means that the lack of parenthesis in an conditional that uses assignment is usually a red flag.
Something added in 1999 is quite a new feature? 
If you don't want to directly use the complex versions of math functions for some reason, you have to use [tgmath](http://en.cppreference.com/w/c/numeric/tgmath) to make sure they're called. All your variables should be complex too, of course. 
Well, for Microsoft at least.
If you want to decide whether to use `libcurl` or not on runtime, then you cannot link your executable with it. That means you won't be able to use it from your C code as you normally would, because it would result in undefined references. So the runtime interface to the dynamic linker is pretty much the only option you have. `dlsym` isn't very convenient, because you'll need to try to `dlopen` the desired library, and if it is present, you'll have to set up a number of function pointers to `curl` functions that you need. It seems like a lot of work, but if you define these function pointers as global variables then using then calling them will look identical that if you linked your program with `curl`! (Except that these pointers may be uninitialized, so be careful not to reference them before you set them with `dlsym`s). Some large libraries come with tools that help preparing such pointers (e.g. OpenGL/GLEW/GLUT) if such library tends to be loaded on runtime. That's not the case for `curl`, so you'll need to prepare such function pointers on your own.
You can make this into a dynamic library (liblibrary.so) by adding SHARED. library/CMakeLists.txt: set(SOURCE_FILES library.c library.h) add_library(library SHARED ${SOURCE_FILES}) target_include_directories(library PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}) It's been a really long time since I've worked in C or cmake, so I might have missed something here. It seems to work though.
Like others have suggested you're better off linking the ID and name by using a struct. Since I'm bored and waiting to do a brunch thing I went ahead and wrote a small example on how you might sort those structures. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef struct team_t { int id; char name[255]; } team_t; /* Compare two team names */ static int teamNameCompare(const void *a, const void *b) { team_t *t1 = *(team_t**)a; team_t *t2 = *(team_t**)b; return strcmp(t1-&gt;name, t2-&gt;name); } int main(int argc, const char **argv) { int i, teams, id = 0; team_t **team; if (argc &lt; 2) { fprintf(stderr, "Pass number of teams\n"); exit(-1); } teams = atoi(argv[1]); if (teams &lt; 1) { fprintf(stderr, "Pass at least one team\n"); exit(-1); } /* Randomly create some teams */ team = malloc(sizeof(team_t) * teams); for (i = 0; i &lt; teams; i++) { team[i] = malloc(sizeof(*team[i])); team[i]-&gt;id = id++; snprintf(team[i]-&gt;name, sizeof(team[i]-&gt;name), "team%d", rand() % 1024); } /* Sort them */ qsort(team, teams, sizeof(*team), teamNameCompare); /* Print them out */ for (i = 0; i &lt; teams; i++) { printf("ID: %d, Name: %s\n", team[i]-&gt;id, team[i]-&gt;name); } /* Clean up */ for (i = 0; i &lt; teams; i++) { free(team[i]); } free(team); /* We're done */ return 0; } Note that this is sorting an array of struct pointers. You can do the same thing with an array of structs but you'd be moving more memory around in each comparison. 
Thanks for that, i figured static libraries are much simpler to use so went with static to start. I'll definitely add commented sections for shared or fork a separate project. Prior to adding check I had a local shared and static version
OK, how about: if(0 == long_function_a(with_some_arguments_that_take_up_a_lot_of_space) || 0 == long_function_b(more_arguments_here)) You want the short-circuiting, so you don't want to eagerly name it prematurely. If you name the whole short-circuiting or, you still have less readability with equalty on the right-hand-side.
in my opinion shared libraries are actually easier, because .so files include their linking to other shared libraries and any static ones are already linked in, so you won't get any "dependency hell" when linking an application to it. Code-wise you don't need to do anything different to use shared libraries
Because Clang will tell me if I make a mistake, and it looks absolutely retarded.
Good bot
bad bot
Could you add the functionality as a compile time build flag?
Depends on why you want short circuiting, I suppose. For "performance" would be premature optimization, and if it's crucial to the behavior of the code I'd call that an anti-pattern. 
The newer versions have upgraded to c-like c++. Essentially c99 esque syntax.
Ok, but you also can't strip shared libraries, and they'll include shit you don't need. For exmaple, let's say you have a png library, and you you only want to decode PNGs, not encode them. In a static library, with LTO at least, all the encode functions will be stripped, if you link your program to a dynamic library, the dylib will include the encode functions even if they're never used by anything in the system.
What you are saying is that short-circuiting is an anti-pattern. I can't imagine having written a large C program and believing that. &gt; For "performance" would be premature optimization This attitude is killing software quality. "Premature optimization" refers to micro-optimizations that may actually lie in the realm of the compiler. If I have a *known-expensive* routine - it's not premature optimization to avoid calling it unnecessarily (and easily!). Not to mention - that short-circuiting out the evaluation here may be the result of profiling showing it is a bottleneck. The response "premature optimization" to *anything* involving efficiency is a really bad knee-jerk and in this case non-sensical. &gt; if it's crucial to the behavior of the code I'd call that an anti-pattern. Consider: if(ptr == null || bad(ptr-&gt;field)) What would you consider a better pattern?
a small price to pay for not having all the encoding functions duplicated across all programs using them :)
I know you said you got parts 1 &amp; 2, but I suggest you start making if/else statements for good practice. First if should check parameters: If x &lt; 0: Print(Can not enter negative numbers) Else if(x&lt;=15): Do something Else: Add extra rate When dealing with if/else statements, you want to deal with all possibilities. That way you won't find any bugs in your code later. Also, using two if statements for the same parameter check really isn't great practice. I'm not sure what #3 is asking but maybe find how many times 500 goes into the total distance than multiply by the charge. And if you have to charge even if it goes over 500 a little, look into the "mod" operator %. The mod operator will tell you the remainder. Ex: 11%5 will return 1. Also, some advice... Don't label variables as "isMyVariable" or "distanceTrue" (unless they're boolean variables) because that can get pretty confusing. And even that, don't name a boolean variable True because it might be set to False at some point.
and an OS, and a standardized library for functionality X*
I'm also a full stack dev working on my C, here's several things that have really gotten me excited about the language. http://mikeos.sourceforge.net/ - Simple, understandable Assembly OS with instructions on writing your first OS in assembly (http://mikeos.sourceforge.net/write-your-own-os.html) https://kernelnewbies.org/ - Getting started working on the Linux kernel. It will talk you through setting up and compiling the kernel and committing your first patch The raspberry pi / beaglebone / other micro pc - there's a wealth of resources out there but if you want to get down and dirty with electronics and C I'd highly recommend the pi or a beaglebone board and a good book to go with it. I recommend http://derekmolloy.ie/raspberry-pi/ Browse github, check out some project ideas. Try to write your own version of linux commands - whatever floats your boat. The most important thing is to enjoy what you're doing. I also have found that making myself commit to github every day has been a very good thing. I'll not feel like coding at all but boot up my IDE to do a simple project or a small bit of refactoring in order to keep up my commit streak. Several hours later I'll have gone off on a tangent and be doing something interesting :) 
My God (a) why are using a useless variable `SOURCE_FILES` and (b) why on earth is the header specified?
Or don't specify either `STATIC` or `SHARED` and let the user do it with `BUILD_SHARED_LIBS`...
Just a couple more comments: * Never set `CMAKE_BUILD_TYPE`, this will break any multi-configuration generator (also, why are you setting it to what is already the default?) e.g. Windows which you later check for other things so... Yeah this is already broken. * Never override a variable like `CMAKE_MODULE_PATH`, now a user can't modify this and is going to spend ages debugging who overwrote his module path. At the _least_ you could append instead. * Your macro `ck_check_include_file` seems unnecessary, you couldn't use `CheckIncludeFile` etc. directly? * Using `${CMAKE_CURRENT_SOURCE_DIR}`is almost always redundant, like in `configure_file`, it's the default. * Never use `include_directories`, only ever use the target version so you're not relying on side effects (e.g. globalish directory variables). * Ditto about `add_definitions`. * Finally (well probably not but I'm going to stop here), `ADD_TEST` is misplaced since the test your adding is created in a totally different file. I don't want to come across as rude, though I know this will, but honestly you should take this down until you've fixed it. You're providing an example *full* of bad practices.
Pick a library, say libcurl, libevent, or even LuaJIT and make them do something. Not only is it fun, but it will give you some ideas on how to structure your own library. 
This is an amazing comment, thank you! I am about to spend so much time to writing an os. Just wondering, what IDE do you use? I'm still a student and have access to InteliJ and C Lion, would you recommend it, or do you use something like Atom / Sublime and a terminal to compile? 
I'm not OP, but I would recommend you start to use the terminal to compile. You will end up with better control over all. Once you do that, then it doesn't matter what editor you use. I have used notepad for quick projects before. My current favorite editor is VS Code. I highly recommend it. Second would be VIM. I am just starting out and it's quite a pleasure to not have to take my hands off of the keyboard. 
If you would like to get into the world of electronics. I would highly recommend PIC microcontrollers. That's what I majored in, and I love every second of it. You get to program in assembly, or C, and watch your program interact with the real world. It is a hell of a lot of fun. 
Develop a mode13h VGA 3D gfx engine! Michael Abrash's Graphics Programming Black Book is a tome of a read that is rife with juiciness. You'll have to run your work in DOSBox or have a DOS VM you can fiddle around in.
The C development community is not really a "thing" like the web development (I assume this is what you mean by "full stack", but it's probably not what a C programmer thinks of first) community is a thing. Professional C programmers are spread throughout a number of disciplines and those are in a number of different industries. Many do embedded systems programming, which includes industrial, automotive, and some parts of the consumer electronics industries. Some do DSP programming in various audio-related industries. Some do operating systems or compilers work, either for desktop/server platforms or embedded platforms. These various groups don't necessarily use C the same way, or even communicate with each other very much. Personally, I think small embedded systems (i.e. the sort that you'd put an ARM Cortex M processor in rather than a Linux-running Cortex A) are the most rewarding place to get started with C. You could start with an Arduino, but since you seem interested in the lower-level bits, I'd recommend something like a STM32 Discovery board instead, as they're fairly cheap and there are lots of people using them for hobby projects, so there's a lot of example code to help you get started.
If on Linux, why not use something like a named pipe (`mkfifo`)?
I could, but I'd like to implement to be a bit more flexible, to easily distribute the binary. 
Make a game boy advance game maybe. 
First of all, ~~append~~ prepend four spaces to your code to properly format it. It's rather unreadable right now. Second, `SmartArray` is probably a typedef to a struct like this? typedef struct SmartArray { char** array; int size; int capacity; } SmartArray; In this case, `array` is an array of strings. So if I get things right, I think the `put` function is supposed to append the `str` argument to the `*smarty`'s array, as if it's a dynamic array. In that case, you will need to use `realloc` to reallocate the block of memory with an increased size. Also, in your `put` function, you are returning the typedeffed `SmartArray`, which is rather wrong.
Seconded terminal use, I use CLion for my own stuff but started with vim, GCC and gdb. After that I learned very basic cmake and then I started using CLion. I'm a JetBrains fanboy with an annual sub so I wouldn't just go on my recommendation for an IDE. I still just use vim if I'm attempting kernel stuff. CLion helps me a lot with debugging, I will say that.
In my most recent C(++) job, the target platform was Javascript in the browser (via Emscripten).
look at chip-8 project. or look at creating linux from scratch or virtual machines, emulators etc.
prepend, not append.
How about trying to write your own hobby os? [Osdev](http://www.osdev.org) has an amazing wiki and an active forum where you can talk to likeminded people. It might be a huge project depending on how extensive you want your OS to be. On the other hand [The Eudyptula Challenge](http://eudyptula-challenge.org/) takes you from writing a small Hello World linux kernel module to more complex tasks such as writing a driver a network filter etc, they're not currently taking any new developers but you can find all the "assignments" [here](https://github.com/agelastic/eudyptula)
If you program for Linux, don't expect to distribute binaries. Just distribute source code, that's how software on UNIX-like systems works best.
Maybe you are right, but what kind of problems usually pop up when binaries are distributed? If I have 32 and 64 bit builds, those should work on most of the Linux systems, right?
Don't forget .dylib Why not just link it statically?
Different Linux systems have different shared library versions. If the other system doesn't have the same library version, your binary won't run. 
No not rude at all I do appreciate the feedback, the problem here is that the vast majority of the Cmake files are taken verbatim from the check examples at https://github.com/libcheck/check/tree/master/doc/example which I assumed to be a good reference for how to do things I'm happy to change these files, is there a "good cmake citizen" guide I can refer to somewhere? And yes there are absolutely problems that I added to these Cmake files as well like the ADD_TEST you pointed out. For now I've edited the post to make it clear cmake is badly set up so I think that with the original disclaimer should do. This is not intended to be "the" seed, it's a simple starter project other beginners like me can use to quickly write tested code and easily re-use it in another project for things like myFirstList etc.
Just reminding myself of this post later.
VIM is amazing! Our professor really wanted us to get good at it. I love being able to navigate our production environment in Terminal and pull up config files in VIM in the office, it's quick and impresses people. 
Speaking of fun and vim another kind redditor linked this to me a while back https://vim-adventures.com
I recommend [this](http://kylehalladay.com/gba.html) as a quick introduction (start from bottom link).
Cheat on games. It is so insanely fun.
Don't forget that the classic Quake was built in C and the branch clients are still active today; https://github.com/ezQuake/ezquake-source Just a thought.... ;)
I have an interest in PIC controllers. Do you have any resources for tutorials or beginners guides?
This helped me out a lot: http://voices.canonical.com/jussi.pakkanen/2013/03/26/a-list-of-common-cmake-antipatterns/ And this is pretty good: https://rix0r.nl/blog/2015/08/13/cmake-guide/
Thanks again. I replied to the wrong comment earlier I was hoping you could expand a bit on these points, I don't quite get the alternative "Never use include_directories, only ever use the target version so you're not relying on side effects (e.g. globalish directory variables). Ditto about add_definitions." I've pushed my changes so far to the repository, it would be great if you had the time and patience to take another quick look through. 
Great spirit suggestions 
Cool stuff to do in C and ASM : 1. Embedded Linux (Pi is a good start but there are plenty of other boards like Olinuxino) 2. Micro controller programming :) 3. Audio processing with DSP. Most audio FX are built with ASM code and use great instruction set like MAC (Mult And Accumulate).
I like the convenience of it. It's installed in almost any Linux distro. So I can easily navigate anything without a problem. 
Be sure to read "Smashing the stack for fun and profit". It's a really old article from 2600.
So very particularly, a key point of CMake is that build variables like include files, compiler definitions, etc. are all set on a per-target basis. Then they're automatically figured out at build time from the dependency graph. So if you have some library foo that requires including foo/include and defining -DUSE_FOO, you don't tell your program this information. You see it all for the foo target, and then when you tell CMake target_link_libraries(myprogram foo), it's all figured out by CMake. But using folder level commands like include_directories instead of target_include_directories breaks all of this and pretty much takes you back to the dark ages of manually managing build data.
I'm also always wondering what they mean by full stack. As an embedded dev, to me it sounds like protocol engineering, but I'm pretty sure it's something completely different. 
Since this is /r/c_programming and not /r/cpp_questions, IMO it doesn't really matter and it's mostly a matter of style. If the only thing in that statement is a pure `i++` or `++i`, then they do exactly the same thing. That's the case in your `for` loop, for example. In a more complex situation like `foo(i++);` vs `foo(++i)` there's a specific difference, and the one you choose will depend on the behavior you want. If we were talking about C++, however, things are different. In that case, our loop might be using an iterator rather than just a simple index, with an overloaded `operator++`. In that case, the implementation of this operator will probably make a useless copy of the iterator every time through the loop, which is a bad thing. Compilers are pretty good at optimizing this copy away when possible, but it's considered to be best practice to use pre-increment instead of post-increment to just avoid the issue entirely. And then you get people like me, who use both languages a lot. And I like to be consistent in how I write code between the two, even if it doesn't technically matter. So it's not surprising to see the pre-increment style spill over to C.
`++i` will immediately increment i, while `i++` will increment i after the current statement has been executed int a = 0; int b = 0; printf("%d %d\n", ++a, b++); printf("%d %d\n", a, b); prints 1 0 1 1 The prefix has very convenient uses, just as postfix has -- pick the right one for the right situation.
Hey guys, Thanks for the clarification. And the example was perfect. Appreciate the simple direct answers. I noticed this is the C forum. Is there a specific forum for C++? I'm new to reddit. And all I saw from the options for C forum. So I don't know if you guys really just focus on C specific code.
&gt; This has been slightly confusing to me. I've heard the safest way is ++i E.G for (int i=0;i &gt; size;++i) In this context there is no difference. The loop is initialized, compared, stuff happens, and then incremented. It wouldn't matter here if you used pre or post. There's no difference there because the statement is not doing anything other than incrementing the variable. It begins to matter if you're using the variable for something while you're doing your increment: while( astr[ i++ ] ) { ... } Why it matters is because what index you wind up using comes into question. If we rewrite your loop: for( i = 0; i++ &lt; 10; thing( i ) ); You get different results here if you switch the incrementation around. tl-dr; if all the statement does is increment a variable, it doesn't matter. Otherwise it might matter. Neither one is better, it comes down to what you are trying to do.
When I code i I code in linux environment preferrable for linux as well. But when it comes to open source I prefer portable plattorm agnostic code. From my experience I would build sw tor all targets on one platform. That means also fross-compiling. Such thing makes sense for example when you need things like jemalloc or tcmalloc setting them up on windows is possible but it is a real pain. Also it provides better API compatibility.
&gt; Is there a specific forum for C++? /r/cpp_questions for questions like this. /r/cpp for discussions about the language.
**Here's a sneak peek of /r/cpp_questions using the [top posts](https://np.reddit.com/r/cpp_questions/top/?sort=top&amp;t=year) of the year!** \#1: [Most beautiful piece of C++ code you've seen](https://np.reddit.com/r/cpp_questions/comments/5c6wwj/most_beautiful_piece_of_c_code_youve_seen/) \#2: [What are some beginner friendly C++ github projects?](https://np.reddit.com/r/cpp_questions/comments/61cucu/what_are_some_beginner_friendly_c_github_projects/) \#3: [C++ without ever using the letter i in your code?](https://np.reddit.com/r/cpp_questions/comments/5ztsku/c_without_ever_using_the_letter_i_in_your_code/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
Basically, you are doing with pipes the following: +-&gt; parent -+ | | +- child &lt;-+ The problem is that most likely, both the parent and child processes are using Standard C IO. Under Unix, STDIN, STDOUT and STDERR are line buffered *only* if the source/destination is a TTY (i.e. the command line). Otherwise, the standard library will do full buffering on STDIN, STDOUT or STDERR of they are anything *but* a TTY. And a pipe is *not* a TTY. What each process needs to do is for each stream that is a pipe, call `setvbuf(stream,NULL,_IOLBF,BUFSIZ)` (and for the child process, this needs to happen *in the child process,* and not after `fork()` and before `exec()`). The reason the OP is only getting output after the child process ends is because when a C program ends (normally and not through a signal), the standard library will flush any pending output that might be buffered; the child process isn't generating enough output to fill the output buffer while its running. 
&gt; while i++ will increment i after the current statement has been executed Not after the current statement but before the next [sequence point](https://en.wikipedia.org/wiki/Sequence_point).
**Sequence point** A sequence point defines any point in a computer program's execution at which it is guaranteed that all side effects of previous evaluations will have been performed, and no side effects from subsequent evaluations have yet been performed. They are often mentioned in reference to C and C++, because they are a core concept for determining the validity and, if valid, the possible results of expressions. Adding more sequence points is sometimes necessary to make an expression defined and to ensure a single valid order of evaluation. With C++11, usage of the term sequence point has been replaced by sequencing. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
If you are writing an OS, then an IDE will be useless to you, as you can't use any standard C library call (since the system it depends upon doesn't exist), nor can you use a debugger to debug your OS (again, because the system a debugger relies upon doesn't exist). So my advice, ditch the IDE, use an editor (vi, emacs, joe, nano, there are many to choose from) and learn to debug without a debugger (which gets harder when you can't even rely upon `printf()` to exist!). 
Ignoring the fact that you're writing C++, not C .. When making your random numbers, make sure they're different. int word1; int word2; word1 = rand() %5; do { word2 = rand() % 5; } while(word2 == word1); Your constant `5` is also incorrect.
To add to what the above reply said, CLion usually doesn't have an issue with GNU C extensions after a refresh to the code inspector. It does trip up with the imaginary float suffix, but that's not related to your problem here.
&gt; while i++ will increment i after the current statement has been executed This isn't necessarily wrong, but I think it is worth clarifying that the order of when the increment happens in relation to the statement it is in is not defined. So a statement like `i = i++` is invalid (for a variety of reasons) even though `i = i + 1` is perfectly fine - the increment of `i` could happen before the assignment, or after the assignment, and the order is not guaranteed. All that is guaranteed is that the increment has to happen before the next sequence-point (Generally the next statement).
You never assign a value to segmentdefault. So basically, when you use the modulus operator, segmentdefault will have a random value, and make your if statement behave incorrectly.
You've declared segmentdefault, but you've left it unitialized.
Oh my goodness XD. I knew it would be so simple, Thanks alot!!
C++ is off topic in this subreddit. Please ask elsewhere, e.g. in /r/cpp_questions.
Read the error messages.
Some additional comments: 1. `const char * argv[]` is an unusual declaration. I don't think I've ever seen anyone do that before. The strings pointed to are required to be modifiable, which is why `char *argv[]` is the canonical form. The standard allows "equivalent" forms, footnoting the popular `char ** argv` as one example, but it's not clear how loosely "equivalent" should be interpreted. If this were any other function, it wouldn't matter, but C programmers typically recommend an excess of pedantry and caution when it comes to `main`. 2. "%d" is generally better to use than "%i" for the `scanf` family, unless you're deliberately allowing hex and octal representations in addition to the decimal representation. 3. As a matter of readability and statement of intent, if nothing else, you should probably use the `if...else-if...else` construct for the mutually exclusive price calculations. 4. Unlike with the `scanf` family, the `printf` family can use "%f" for both floats and doubles (reason being that the *default argument promotions* apply here, and floats are converted to doubles). In fact, "%lf" wasn't allowed until C99.
use libxl you can find cracked versions all over the internet
Auditing is significantly easier than exploitation, but it still requires a deep understanding of the C programming language, at least if your goal is to progress beyond the usual 20-year-old toy programs containing strcpy()/sprintf() overflows and unsanitized system() input. If you can't name, say, a security-relevant peculiarity or two of the safer strncpy() that may still bite someone in the ass, you're better off mastering the language first. Crude assumptions made when learning the language, such as that basic arithmetic on integers is mathematically robust, begin to break down when you confront real-world platforms with finite object sizes. Then you start seeing the effects of integer overflow, a common problem being that adding/multiplying two integers to determine how much space to allocate with malloc() and friends results in a sum/product much smaller than expected. If that weren't bad enough, you have to contend with signedness issues, not only via simple assignments (e.g., signed -1 being assigned to an unsigned type such as size_t) but also via the *usual arithmetic conversions* in expressions: Otherwise, the integer promotions are performed on both operands. Then the following rules are applied to the promoted operands: If both operands have the same type, then no further conversion is needed. Otherwise, if both operands have signed integer types or both have unsigned integer types, the operand with the type of lesser integer conversion rank is converted to the type of the operand with greater rank. Otherwise, if the operand that has unsigned integer type has rank greater or equal to the rank of the type of the other operand, then the operand with signed integer type is converted to the type of the operand with unsigned integer type. Otherwise, if the type of the operand with signed integer type can represent all of the values of the type of the operand with unsigned integer type, then the operand with unsigned integer type is converted to the type of the operand with signed integer type. Otherwise, both operands are converted to the unsigned integer type corresponding to the type of the operand with signed integer type. Even many experienced C programmers couldn't tell you those off the tops of their heads, yet they're extremely important from a security standpoint. To go even more deeply into the language, circa 2008 the public became more interested in the behavior of optimizing compilers when confronted with some fairly common constructs that the standard regards as undefined. You know those integer overflows I mentioned above? Well, some folks, aware of those problems, have had the bright idea of checking for signed integer overflows by relying on common platform behavior of "wrap around," but the standard leaves signed integer overflows as undefined, allowing anything to happen, so as far as an optimizing compiler is concerned, no such "wrap around" should ever occur, and the checks can therefore be optimized away, reintroducing the integer overflows (reintroducing a security vulnerability as the result of undefined behavior is consistent with the idea of undefined behavior). Even the dereference of a null pointer, which in the vast majority of cases can't do anything more than crash a program, has been locally exploitable on some kernels. In short, I recommend mastering the language before trying to audit programs written in it. Otherwise, you may fall victim to false negatives and decide that insecure code has no problems. The good news is that some security knowledge gained from C is applicable to many other languages. Most languages contain simple wrappers for system() or for POSIX popen(). C's string representation with its null character has led to problems in Perl, PHP, and other languages. Interpreters written in C (there are many) can be audited to expose unexpected behavior in languages believed to be memory-safe.
Many of the errors should be self-explanatory. If you are unsure, post the error you get as well as the code you wrote so we can explain what the mistake is.
If you have an idea for a project you would otherwise implement in a different language, try doing it in C. If it's for fun and the learning experience, reinvent as many wheels as possible. Since you're a full stack developer, maybe write something related to that, say a CGI program. Maybe a Wiki? Dive into the RFCs, write a request parser, read requests from STDIN, find a decent way to represent and serialize the response header, maybe try writing a JSON parser... Doesn't really amount to anything special, but it might give you a more intimate understanding of the lower levels of a request-response exchange and give you an opportunity to tangibly learn from early design mistakes and give you the confidence to approach something more advanced. Or go for something higher level and utilize what's available in terms of great libraries from the start. What got me started was graphics programming. I learned how to change the video mode with an interrupt from DOS, how and where the frame buffer and palette settings were stored and started plotting pixels. Slowly, but I gradually optimized the routines. It's a fast track to rewarding results, because you get to *see* them, and you get to tackle problems on a pretty low level that still isn't overwhelming. In my spare time I've gone deeper and deeper, and these days I find assembly programming for old 8-bit platforms to be very rewarding on a level that transcends utility :)
On the pedantic note, `limits.h` will have the `CHAR_BIT` and `UCHAR_MAX` macros suitable for writing this in a portable way, because `char` is always a byte and `sizeof (char)` is always 1. Also, if your longs are eight bytes wide, shifting by eight bytes will shift the mask out of the range of the integer. A robust implementation to return ms byte: unsigned char msbyte(unsigned long v) { return (v &gt;&gt; (CHAR_BIT * (sizeof (unsigned long) - 1))) &amp; UCHAR_MAX; } 
Thanks ! I'll post when I'll need some help :) I would like to build and interface for all supports. Is C coding good for pls? 
&gt; part of the WordPress PHP style guide, so that seems like one reason to avoid it There is nothing worse in this world than Wordpress. Nothing. Not even Jquery.
Right now I am learning how to program in Xlib using the C programming language and am also developing an ncurses media player, also written in C. In a couple of days I will get a Raspberry Pi from university and will hopefully start doing low-level programming in C on it.
&gt; I would like to build and interface for all supports. Is C coding good for pls? I'm sorry, but I don't quite understand what you are asking.
QNX. Embedded in that the target (40+ x86 cpu) system is imaged for one purpose. Won't fit in a toaster. 
I almost exclusively go for terminal editors as long as i'm developing with relatively low-level stuff like, say, Xlib. For anything higher-level like full-blown GUIs, games, etc I always choose Qt Creator.
No wonder you're struggling so much... My advice, is to learn English first and foremost. that's where 80%+ of your trouble is coming from.
It appears that you have been shadow banned. Please talk to the admins to rectify this issue.
C++ is off topic in this subreddit. Please post C++ content elsewhere, e.g. in /r/cpp.
Oh please it's 2017! Why are you still using Turbo C??
what is it you're trying to do exactly for your homework? 
Fix the errors in the following C code (https://repl.it/L1uv). The indentation indicates the desired behavior for the if statement. (Hint: A program will not compile until all syntax errors are corrected. Identify the syntax errors and fix them. Don’t delete any variable. The output is not a matter. The final output can be like the following figure.) That's the post from the PDF file our professor gave us. Nothing more, nothing less
Furthermore, is anyone else confused as to how this is valuable to anybody? What's the benefit of watching someone slowly type out some shitty C code to terrible music. There's got to be about a thousand posts on how to do this on stack overflow. I just don't get it.
You wanna just do the rest of the homework? About 10 more problems XD But thank you for the help, much appreciated
Just stop.
Your professor's job is to give you challenges. It's your job to figure them out. Think of him as a guide, not a teacher. It's a different model than most high schools.
It's like challenging someone to do a marathon when they have no legs. This is suppose to be an intro class but we're treated as if we know coding already. No explanation to anything
Unfortunately, yes. Yes it is.
Sorry, but your posted exercise is in no way a marathon. It's entirely appropriate for a beginner class. Do you have a text book? Do you have the internet? If so, get reading.
I feel like someone is trolling me, but I'm too confused to protest. Music reminds me of Dune (the movies or the video games). 
You should watch [faster](https://www.youtube.com/watch?v=MvDtr3cNaLU) versions :)
Give yourself legs by reading a C tutorial like everybody else who starts learning this language.
https://learnxinyminutes.com/docs/c/ Read that and then apply it to the rest of the homework problems.
I always got taught deal with the first error message first! 
Instead of asking for homework help, it tends to help a lot if you ask specific questions about a given language, like &gt; Why can't I do XYZ? &gt; Is it possible to implement "doohicky" in language X? If I use a whizzimijang, does it make my program do cartwheels? For what it's worth, it looks like this assignment is structured to make you actually try and "compile" the code yourself, then read the resulting error messages from the compiler one by one and fix errors. Assuming you've already covered some basic syntax of the C Language in your course, it looks like the goal is to have you comprehend what the error messages are telling you is wrong with the program. Some of the errors in the code you provided will not necessarily show up as compilation errors -- instead, they may appear as warnings. If you have the "GNU Compiler Collection" installed (which you will, if you use GNU/Linux or macOS/X), you'll be able to enter the following into a terminal or "command line prompt", from within the same directory as the "source code" file that you saved the above as. ``` gcc -Wall &lt;source_file.c&gt; -o &lt;homework_assignment_xyz&gt; ``` which will compile your program. You can then run it with ``` ./homework_assignment_xyz ``` Hope that helps you get started, but you would have probably been given the same information in class. Cheers! Good luck on your programming adventure!
Or learn to use a tool like http://valgrind.org/
A "full stack" developer in the web development world is usually someone who can write both web back-end code (i.e. web server software, usually on top of something like Rails or some other rich web app framework that provides libraries to help out with HTTP, URL parsing, database access, etc.) as well as web front-end (HTML, CSS, and Javascript, often also with rich app frameworks like Angular). For something that used to be pretty simple, it's now remarkably complex with all sorts of layers and package managers and build tools and deployment tools and preprocessor tools. Frankly, although microcontrollers are getting more complicated these days, life is a *lot* simpler in the embedded world with respect to the amount of tool churn and layers of complexity. Things are challenging in different ways, though.
&gt; `cin &gt;&gt; choice;` Error: C++ code detected. This sub is for C code, not C++. You want /r/cpp_questions or /r/learnprogramming. The problem you're encountering is that `cin` is trying to stuff a letter into an `int`, which is an error. This leaves `cin` in an error state until you do something about it. Since you're not doing anything and just try again, it keeps failing in an infinite loop. So, what's the answer? The first step is to detect a problem. You can do this with `if ( !cin )`. Easy enough. The second step is to do something about it. In your case, I would suggest printing an error, clearing the error state, and then dumping all characters until you get to the end of the line. I suggest using [`cin.ignore()`](http://en.cppreference.com/w/cpp/io/basic_istream/ignore). A complete alternative, and usually a much better pattern to follow, is to always read a line of text from user input (using `std::getline`), and then parsing that string for what you want. This is much more robust and it's easier to deal with bad input.
This belongs in /r/cpp_questions. Replace the first part with something like this. int choice; for (;;) { printMenu(); if (cin &gt;&gt; choice &amp;&amp; choice &gt;= 0 &amp;&amp; choice &lt; 5) { break; } cin.clear(); cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n'); cout &lt;&lt; endl &lt;&lt; "Invalid menu choice" &lt;&lt; endl; }
Not exactly the answer to your question, but why not learn Swift? It's easier than C (especially for beginners) and can teach you a bunch of useful basics).
&gt; with an overloaded operator++ Can't we overload the pre-increment operator in C++? 
Stop posting these.
Yup, and both are called `operator++`, just one takes a dummy `int` parameter.
For the next couple of hours there a humble hacking bundle that might be a good primer: https://www.humblebundle.com/books/cybersecurity-wiley?utm_source=Tumblr&amp;utm_medium=Link&amp;utm_campaign=Cybersecurity_Tech_Books_Announce
forgetting for a min how stupid that dummy int parameter thing to identify pre from post is, so if pre-increment can be overloaded why do c++ people recommend ++i? 
An example might be in order: struct Foo { Foo&amp; operator++() { some_value++; return *this; } Foo operator++(int) { Foo copy(*this); some_value++; return copy; } std::vector&lt;int&gt; some_large_vector; int some_value; }; This is a class that implements both pre-increment (`operator++()`) and post-increment (`operator++(int)`). They do exactly the same thing: increment the `some_value` member. But in order to return the non-incremented value like a good post-increment operator should do, it has to make a copy of the current state. In this case, there's a large vector inside of the class, which makes copying the state very expensive. If all you're doing is `i++` without actually caring about the return value, then this copy is completely unnecessary (you never use it) ... but can the compiler figure that out and remove the dead code? If it can't, and this increment is inside a loop, that's potentially a big problem. The end result is that `++i` is the preferred version, at least whenever `i` is of some user-defined type.
You want [fgets()](http://en.cppreference.com/w/c/io/fgets).
okay, how do i use fgets to parse individual lines in a multi line input?
Read lines in a loop that stops when it returns NULL. There's an example in the documentation I linked to. If your maximum line length is 1000 characters (Counting the newline?) you need an array of at least 1001 chars to store them in. Just remember that fgets() doesn't strip out the newlines. 
if you can only use these two functions i'd use getc (or getch but that isn't ansi i believe). You'll need to think about a couple of things, a place to hold MAXLEN characters, call it an array, a place to hold a single character and a loop to read characters until a newline (or EOF). You should also see what happens if you don't add a '\0' character as the final character in the array and you try to process that (like printing it). So don't forget to add that! Also see what happens if you just put one at the end of the array and read string of smaller sizes into it. After this you'll have a string in your array of characters which you can process and start the reading part all over. For the stop signal you can test if the first character you read is a newline ('\n') but you should also test (each time) if it's not an EOF character to be safe. Or, if the strings don't contain any whitespace you might use scanf. But there's really no official way to tell it to read a maximum number i think. (but i believe the format string '%1000s' will do it). So that's why fgets is a better solution as already mentioned, it does basically all the work for you and you can specify a maxlen also. So win win but not for the assignment i guess.
This sub is for C, not C++.
Writing modular code is good practice regardless of the programming language. A modular codebase is easier to maintain, understand, and faster to compile (if your build system is set up correctly). Here are some slides I found specific to modularity in C: http://www.cs.princeton.edu/courses/archive/spr03/cs217/lectures/Modules.pdf
I see you're new to C, so I'm going to keep my answers limited to your question. The generic answer is function "parameters". parameters are passed on the stack (or directly in a register, worry about that much later). by passing the *value* as a parameter funcPMSD cannot modify or see the variable in main.c. It only has access to the copy that was passed through parameters. In the header double funcPMSD(int pmsdMath, double number0, double number1); Which must have the same layout in the .c code double funcPMSD(int pmsdMath, double number0, double number1) { .... To call it in main.c ..... scanf("%lf", &amp;usernumber1); printf("The result is %f\r\n",funcPMSD(pmsd, number0, number1)); 
You can write C code in one file but outside of small utils or hello world type of apps you really shouldn't. The general trend is to put each class/module/unit into a separate file.
"Full stack" == "Iceberg tip"
You can write object oriented C, gtk+ is based on it, you just won't have the compiler to help you. A very effective OO approach in C is using structs as "objects" and functions that operate on the structs as "class methods". You won't get inheritance or polymorphism tough. Edit: I didn't mean that you can't do polymorphism and inheritance in C, you surely can, gtk+ has it, I meant that the simple way I described won't have them. But if you *really need* those advanced OO features you should either use C++ or gobject.
Really my dude? Make a struct, create setter/getter functions for it. Put it all in one file. Boom, you've got a module.
That's a good practice. Especially if you actually use the modular components of your programs in other projects. For example, I wrote a customized pseudo random number generator program awhile back that uses three functions, and now I use that file/header in any program that needs a random number function. The two internal functions are static, and the function that generates the number is extern.
You absolutely should make it modular, it just takes some different techniques to do it. [C Interfaces and Implementations](https://www.amazon.com/Interfaces-Implementations-Techniques-Creating-Reusable/dp/0201498413) covers that topic in some depth.
It feels like things have gotten broader, but not deeper, necessarily. With the exception of Node, I'm unaware of any tools that let you do *more* than you were previously able(obviously, even there you could have done it yourself, but that's kind of beyond standard web stuff). For the most part it's in the name of making things easier. Ironically, the 'easier' things get, the more you have to memorize. Do we *really* need JS, PHP, Angular, Node, Jquery, CodeIgniter, CSS, XML, SQL, Greensock, and Wordpress just to produce HTML? For a fair amount of it, I end up feeling like they're piling on just for the sake piling on.
1. Do your own homework. 2. The question isn't about C at all; you're asked to draw a flowchart. 3. Why do you expect us to do your work for you, when you can't even be assed to type out the question itself nor spend 10 seconds fixing that horrible image crop?
If you want OO in c you can try this: https://www.cs.rit.edu/~ats/books/ooc.pdf I like this book, it gave me a lot of tips without following the complete strategy. 
nvm i figured it out. thanks for replying tho
I don't see where you call transfer(), so this is complete speculation... What if you call it with the address of a pointer that is set to NULL?
&gt; The compute throws a SIGSEGV when trying to access Free via the transfer function, and for some reason, gdb shows that Free points to NULL ... yet the code you posted never calls transfer.
Might be interested to read: - [Handmade Hero](https://handmadehero.org/) - [Semantic Compression](https://mollyrocket.com/casey/stream_0019.html)
I'm a CS student but I mostly code for Linux but some BSD or other UNIX too when I'm lucky. Platform is generic from embedded to desktop but I don't write much of applications. Hardware is ARM and x86. For a living I currently teach a bit of C and x86 Assembly.
Try /r/cplusplus or /r/cpp. This sub is just for C.
Yes! That's a very good thing to do. Keep up with that!
This subreddit is about programming in C, C++ is off topic here. Please post this elsewhere.
Gobject does have some form of inheritance iiuc. Isn't gtk built on it? 
If you post one of these again, I'm going to ban you.
You can do single inheritance fairly easily by letting the first element of an inheriting struct be the inherited struct. struct car { ... members (can include function pointers for virtual method calls) }; ... struct truck { struct car car_inherited; ... other members }; This allows you to cast any truck into a car normally: struct truck *truck1 = truck_create(); // assuming you have implemented a create function that allocates a new truck. struct car *car1 = (struct car*)truck1; So you can have polymorphism and virtual methods. Multiple inheritance is a little harder. You would have to do something like what C++ does with "thunks," that is, calculate the offset of each inherited class within the inheriting class, then do that address translation on the pointers. If you want to be a little more efficient, you can also implement class structs, so for this example, they would be struct car_class and struct truck_class, that holds the vtables. It's a little more tedious in C than in C++ or other OO languages, but it's possible. Edit: I figured I'd post a reference to a book that I've been meaning to read for a while, now, that outlines how to achieve OO designs in C. I've skimmed it in the past, and it seems like it would be a fairly good reference based on what I've read of it. Hope it helps: https://www.cs.rit.edu/~ats/books/ooc.pdf
I think that typedefing structs and putting them in separate .h files get you a fair bit of destrucuring. Then have functions that operates on your types. Functional style programming actually comes very natural in C. The biggest problem with this style is memory management. Who is responible for creating structs? Who disposes them? This must be explicit.
You can make classes in C and use a modular approach! For an object, you would use static methods and vairables to define their visibility, and only expose the ones you want as non static methods/data types in the header.
Allocate a 1001 character buffer (max string length + 1 for the terminating null character). Read lines one by one (with `fgets`) and process in a loop until the input line `strcmp`s to the the terminating empty line and close the file. The more general way would be to read until there is nothing left to read (as indicated by the return value of `gets`), make sure that it stopped reading due to EOF using `feof`. On a POSIX system you could also set the buffer size to the system-defined maximum line length with the `LINE_MAX` macro from `limits.h`.
I do the same thing. Also due to my Python background I always use the struct as first parameter and call it self... Fairly sure that might be bad practice :/
Of course it is, just enter a break whenever someone types it. Just for you know that the do while loop is a bit more complex. Just make sure you do everything exactly when needed. Otherwise, it might be a problem to detect the bug. There are programs that might help, like checkmarx, but if you do everything right you won't need to. Good luck.
As long as you use an finite number of numbers there won't be a problem. It starts to be complex using an infinite amount of numbers as summing them makes a big complex in the program, which might lead to bugs and errors that are hard to detect. There are programs who helps doing that, such as checkmarx, but it is recommended to know exactly what you do in order to avoid those. Good luck.
I'd suggest CLion, it has awesome features, and JetBrain products has probably the bast code completion and navigation. AFAIK it's free for students. OFF: Couldn't someone put a link to a similar 'right IDE' thread in the sidebar maybe? :-)
There are tons of these kinds of programs. Here is a competition of obfuscated C programs you may find enjoyable: http://www.ioccc.org/years.html
As far as I remember, this was some sort of school programming assignment with shitty line number requirements, not a competition entry.
Yeah then I'm not too sure.
Just start doing it. Create new project and run. Fine main(). What's the mental block? Just do it.
Just to note, the reason why it can be faster to compile is that if you modify a source file, then only that unit has to be recompiled. If you modify a header, only the units that depend on that header have to be recompiled. Obviously in a big project it's good to not have to recompile the entire thing for every little change.
Man... I get stuck at the very beginning of the interface. Idk if I should chose "empty" or what ti pick to just start coding. I wish I could use Xcode because I love the cleaner look it has but again, I have no idea what to choose or how to do it.
Just pick C console application. Shit pick every option and run eqch of them and look at the output. Read about the IDE and learn how to compile and debug. Find where your binary is made. Figure out how to set breakpoints and step debugging. You're really at the easy part. Just timebox an hour for each if you're still undecided. Run a simple printf hello world.
Please put four blanks in front of every line of code so your code appears readable.
 #define p printf Do not do this. It makes your code much harder to read and understand. All caps cryptic variable names don't help either.
&gt; the problem with my program is that the average cannot display the decimal/remainder That's because you're doing integer division here: AU=TU/NoC; &gt; and i cannot display the course that has the highest or lowest units i could only display the highest or lowest units Well, you just need to keep track of `i` whenever it finds a new highest or lowest so you can display it later. Other commentary on your code: *Please* indent your code like /u/FUZxxl asked. It's so hard to work with what you've posted. Don't do this: #define p printf It's awful, awful, awful, for about a thousand reasons. Don't be lazy, write `printf` and `scanf` when you mean it. Your variable names are likewise bad. Give things meaningful names. It makes it easier for everybody, and shortening them like that is just laziness.
HPE NonStop. Payment processing to Visa, Mastercard etc..
This [C programming course with CodeBlocks](http://www.technobyte.org/c-programming-course/) should get you started.
That's good practice. I used to use "this" (like C++ uses) but then a colleague had to use my C library in a C++ project and the C++ compiler objected strongly... So I use "self" now. It also makes sense because you have to explicitly list it in the function declaration, very much like Python.
This subreddit is about the C programming language, C++ is off topic. Please post this elsewhere.
Yup. We do the same thing using macros to define the attributes of the structures. As for polymorphism... I'm just as happy modifying (e.g.; subscripting) the names of the different signatures - just as a compiler would. Less confusion, if you ask me. 
I have used both. If you have a mac, you should be using Xcode. Xcode is a excellent tool. Codeblocks is good but no reason to use it if you have mac.
I think effects are effectively undefined on variables outside the loop unless you’ve explicitly used a data-sharing construct to dictate how the variable should be accessed. In this case, you’re probably going to want to compute `curcol` on-the-fly privately in each iteration of the outer loop. (Who knows, the compiler may well optimize it to do just that before anything OpenMP-wise takes over, in which case no problem.)
You either need to specify that curcol is private in the omp block, or make a local variable somewhere in the body of the block. https://computing.llnl.gov/tutorials/openMP/#Clauses for more.
Thanks for the link, I will take a look. 
Even without OpenMP, isn't that code wrong? That is you never reset col to 0. Or is the idea that col just keeps incrementing across rows? In that case, if you declare it private, you'd end up with a copy that writes the first set of elements to all rows. That would be wrong if the above code is correct. If it's meant to be sectioned (that is, you write columns 0-9 in the first row, 10-19 to second row, etc as an example), then I'm not actually sure how to handle that unless you make column an offset based on row index.
This is a a dumbed down snippet of a reference code that I am implementing with another programming model so I can't speak to its correctness, but your response gives me some ideas so thank you! 
No worries, those are actually important to understand. Both cases are perfectly parallel, but they have extremely different results.
Instead of `-Wl,-subsystem,windows` you can use `-mwindows`. (I find it's easier to remember.) With Mingw-w64 you don't get C99 printf() by default for unknown (read: undocumented) reasons, but you *can* get it by defining `__USE_MINGW_ANSI_STDIO` to 1 before including any headers. Not specific to C99, but you can't access non-ANSI filenames on Windows from any C library I've ever seen. Nobody's ever written a decent C library for Windows — not even Microsoft. The only way around this is to talk to Win32 directly or use a Microsoft extension (even on Mingw-w64). The whole situation is pretty crummy. Lastly, and also not specific to C99, GDB only partially works on Windows, so debugging there can be a pain. The best workaround I've found is to debug Windows-specific issues under Wine on Linux when possible. 
You know you've finished with the letters and are at the words when you read in a string that is more than 1 character long. Use strlen to find the length of the string you just read. You can read them into a 1D array and, once you know the row width, do a little maths to work out what letter is where.
Hmm. Okay! I'll definitely try that! Thanks for the advice! :)
If you want to post a link, please just post the link. That's much better than posting a self-post with a link embedded.
[removed]
And you're asking this in a C sub? Why? 
There is not a single IRC network. You have to say on which network that channel is.
[removed]
Thanks, it's at freenode.
My preference is C++ but I am open to other options too
the latest version of MSVC supports C99... why would you go this route?
Yes but why C? A language with no built-in OOP facilities. It's not impossible but if you want to get acquainted with OOP first, I think it's the wrong choice.
Oh well you see, I didn’t know that. I was under the impression that this applied to all widely used languages! Thank you for that. 
Well gobject is an oop library for c so you can try that although it has a lot boilerplate code
If you want OO in c you can try this: https://www.cs.rit.edu/~ats/books/ooc.pdf I like this book, it gave me a lot of tips without following the complete strategy.
I really enjoyed this online book: http://composingprograms.com/ it uses python but it teaches the concepts in general. So after learning some abstractions you learn what is OO and how to build OO facilities in a language that doesn't have them (here it simply ignores they exist in python and builds them, using the abstractions that it taught you before), using an easy to understand language (python). So you will have less trouble doing OOP because you also grasp the theory behind it, and you will be able to understand how you can do OOP in C way more easily since you will already have the concepts down. It also has some projects with included tests for each exercise, they're quite scripted so it's easy to go along. These don't take up too much of your time but I've found them useful to sediment the concepts before going on with the theory. I've looked at some OO in C stuff and it's really more complicated syntax so I suggest starting with something easy like Python to learn the concepts, and then go back to C if you want to do it in C. 
I'd ask this in /r/python or /r/cpp
Doesn't Clang automatically vectorize loops? so OpenMP isn't nessicary, at least for some cases? and can anyone tell me what those cases where it is nessicary?
OpenMP here is about multi threading, not vectorization. Some compiler can sometimes maybe do auto (thread) parallelization.
Thanks man! I’ll look into it now!
Oh duh fuck.
Learn how to write titles. and not from the Buzzfeed school of clickbait, either.
I have no idea what the actual input file looks like (formatting!), but I’m guessing the initial letters are in rows. Use `fgets` instead of `scanf` (and check either! Files end, inputs are borked, people type wrong!) to read an entire line at once (including `\n\0` if you actually reached the end, but possibly just `\0` if you didn’t), and then you can work through character by character (again, checking) and fit things into your maximum-sized, preferably `static` two-dimensional array. The number of characters on the first line will give you something to check against in later rows. Also, `scanf` borking doesn’t necessarily return `EOF` if it fails (that’s one possible mode of failure), it just returns less than the number of things it was supposed to read. Which usually includes `EOF` because `EOF` is almost always &lt;0, though IIRC not necessarily according to the Standards. And `cat X | foo` == `foo &lt;X` without the extra step.
Because Windows is an alien environment (to me) and I really didn't want to wrestle some IDE I'm completely unfamiliar with, when I can boot windows make a few makefile modifications, compile and run.... 
It's worth noting that OpenMP can also be used to vectorize loops, though. Or both parallelize and vectorize one. 
Yeah i use a Mac primarily, that doesn't mean you shouldn't make a damn project file for each OS you intend on compiling for.
How about the entire year of 2022
[June 12^th](https://en.wikipedia.org/wiki/Research_Unix)
**Research Unix** Research Unix is a term used to refer to versions of the Unix operating system for DEC PDP-7, PDP-11, VAX and Interdata 7/32 and 8/32 computers, developed in the Bell Labs Computing Science Research Center (frequently referred to as Department 1127). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
Approx. 1675281507 +/- 2592000. /estimate
+1 And what an event that date should be (but won't!). C isn't a shiny, hip, new language; it doesn't add to you resume, and likely won't get you a job in any Silicon Valley web startup. You won't find blogs or news sites pushing C. But the concepts behind it underpin the very basics of computer science. What a shame...it's almost an unsung hero in the programming language landscape. 
Anything. C is a high level general purpose programming language
Ok, I get that but who really uses c other than people who make things like compilers ?
No one uses C? Nobody told me. Your instructor is very wrong. There are probably more Java or JavaScript programmers out there, but there is still lots of room for C. Most systems code (OS kernels, device drivers, language runtimes, core OS libraries, compilers, system daemons, firmware, etc) I’ve seen has been in C or in some descendant of C like C++ or Objective-C.
Sorry. I should have been more specific.
Anyone who does embedded stuff (sensors, microcontrollers, firmware). Somebody has to program your washing machine, microwave oven, car alarm, etc. 
I once read a blog that compared C and Java. The Tl;Dr is that it’s very difficult to build a skyscraper if you have to make the bricks yourself! C is used for making the bricks - very efficient bricks, but still bricks. If you want to construct a skyscraper, use something that gives you the basics for free and lets you focus on the big picture. Sure, you can build everything in C, but choose your tool to suit the job at hand. 
OSes are written in C. Many libraries you use (ie. OpenSSL, CURL, OpenGL, etc). Microsoft Word. Chrome. Firefox. Server stuff, like Webservers (Apache, IIS), Databases (MySQL). All drivers used in your OS. Anything security/crypto related, generally. Antiviruses. The list is long... The jobs are plentiful. Job security in C is higher than some other languages (which see a downward trend in usage, such as Perl).
After the inner loop completes, the value of 'a' is zero. What's the value of 'a' the next time the inner loop is encountered?
Duuuuh. Thanks 
bootstrapping safer compilers
&gt; ...it doesn't add to you resume... An experienced C programmer can make *a lot* of money. Web developers are, comparatively, a dime a dozen. Someone who knows how to rework your network stack or write a device driver are considerably rarer and thus more valuable. 
I think "high level" is a relative term and can not be applied to C any more. C is a low level programming language in 2017.
Why the video? It's just 22 minutes of someone typing code into visual studio, when a tutorial would be so much more preferable. I can't help but feel that this is someone entering code from an existing DLL injector project from github ( of which there are many ) and claiming it's his original work. Calling standard headers such as 'Windows.h' libraries was a bit of a tip off. Long story short : It uses the well known 'CreateRemoteThread' method of DLL injection. Googling 'DLL injector source' would be a much lesser waste of time.
I know that most part of the Linux kernel and git are written in C. Some databases like MySQL and Postgres are written in C as well. 
I've always thought of it as more of a portable assembly language. You can do almost anything in C with a few machine specific compiler extensions or a little inline assembly.
&gt;My dream is to make an operating system. Now when I say this people usually think I'm being naive You are
In what way?
[C is the second most popular language in the world](https://www.tiobe.com/tiobe-index/) Whether one wants to use that as a reference or not, C is one of the most used languages around the world and easily ranks among the top few.
Please don't post this sort of content. Nobody needs this.
not necessarily, Osdev.org will help you get started with that 
Embedded software. Operating systems. Aerospace, Automotive, Defense industries. Some people use C++ as "C with classes" meaning they just ignore most new features. C's strengths and weaknesses have been well known for 20+ years. Makes it a good choice for applications that cannot afford "surprises".
Linux kernel is written in C. A lot of embedded applications are written in C. Android has fair amount of c code. Anything running directly on hardware is most likely running C. Filesystems are written in C, all the filesystems middleware is written in C. If you move towards graphics/gaming applications that is more C++ than C 
As others have said, C is still widely used... everywhere. I’ve worked as a professional programmer for a while now, and I’ve never worked a job where there wasn’t C *somewhere* in our codebase. That said here’s some places it’s used: - drivers - firmware - pretty much anything on an embedded device will include some C somewhere (smart fridges etc) - low level parts of OS’s (much of the upper layers are written in C++ or managed languages) - many games (or at least pieces of them) - many Unix command line utilities There are (obviously) more places it’s used. These are just examples I’ve personally seen it used. Your teacher is very incorrect about it being antiquated and dying.
While you are busy applying your lessons in C, you can simultaneously learn to ignore shitposting trolls like CountyMcCounterson. If you want to make an operating system, then go for it! Personally I think a great place to start is to look at OpenBSD source files. That is some of the cleanest C code you will ever see. And you can use your C skills to pitch in and help out that project. Be careful, though; make sure you read the stuff on their website before diving in to the mailing lists. But seriously, it would be a great place to get your hands dirty helping out on an actual operating system. Ports always needs help. There are always device drivers that need to be written. You're young and full of energy and optimism. We need more of that, not less.
Yeah. I just use cmake and didn’t have to change anything when I moved my latest project to windows. 
Everything above assembly is by definition high level, but I get what you mean
A lot of the back end infrastructure stuff is in C. Or if you look at software that was being written since over 20+ years ago, it'd be c/c++ etc. I work in enterprise rdbms development and its all c &amp; c++. 
anywhere where speed matters or resources are limited
I don't see anything obviously wrong... why is it buggy?
Seconded.
Drivers for Windows, Linux, and Android. Embedded systems. POS systems. These are mostly written in C with interfaces or wrappers written in C++. But usually just C. Go to the store, use your credit card on that card reader. What's it running? If it's a FirstData or Verifone, I know those are C (newer Linux ones too obviously) from personal experience. Obviously you know Linux is written in C. That's very big and actively being developed.
He's shifting a uint8_t by more bits than it is long. Even if it gets promoted to an unsigned int it still goes over that size.
I always laugh when our in house Java guy says "javas on everything!" I always say, "oh yeah? Running on what, C?"
The first thing you should have is a text-editor. Since you are on the terminal you can use for example vim (feature-rich but steep learning curve) or nano (not that many features but very easy to learn). Depending on your Linux-distribution you'll have to install these editors yourself. Having an editor you can start writing your code. To execute it you need to have a C-compiler, GCC for example. Many Linux-distributions already have the GCC installed. If not you need to install it manually. Using GCC you can compile your code to binary files which are executable. This are the very basic steps to write simple C-files and execute them. Edit: To learn how to use the tools you can always consult Google. Especially for the code-editors you'll find a lots of resources.
I used it almost every day to program system-on-chips, microcontrollers and other embedded electronic devices. Simply put, most electronics around you (phone, TV, MP3 player, etc) were very likely programmed in C. 
reset value of 'a' after inner loop terminates
C is not an object oriented programming language. C and C++ are extremely different 
That's a very unfriendly thing to say
Notepad++ to edit code and compile using the gcc terminal/command prompt is all you need.
By whose definition? I've never heard that definition before.
Why do you think, nobody needs this?
&gt; Depending on your Linux-distribution you'll have to install these editors yourself. It sounds like OP is using a shared server, i.e., without any superuser access. It's quite likely installing their own editor is going to be extremely difficult (needs to compile it from source and install it in their home directory) to impossible (not enough disk quota to even hold the source code). OP's instructor should have given them instructions on which pre-installed editor to use.
I've noticed C being listed now and then in the job market, but here is a slightly more detailed list. Software development using C/C++ is simply a small tree in a giant forest of JavaScript/Java applications out there. -- Just because of costs and portability. (From what I've gathered. Trust me I'm pretty sure with some macros and well-placed unit testing or a legit GUI framework, this wouldn't be a problem for most.) - VOIP Industry. (Sort of a mixed bag of tech. C, Erlang, PHP, Pascal, etc. ) Just got hired for one of them funny enough. - OS (of course) - Firmware (Microchip, Atmel, etc...) - Drivers (Pretty much almost everyone) - Web Servers (Nginx) - Interpreters (lot of them written in C++, but I can imagine one being written with C) - High-Performance Applications using CUDA. - Bitcoin Industry - Pretty much any high demand Unix tool or program. - Older Computer Games (idTech 1) Lot of newer game engines are written in C++. However, most API's these game engines use ARE written in C. e.g: DirectX, OpenGL.
run this. is this result what you are trying to accomplish? #include &lt;stdio.h&gt; int main() { int j; for(j = 0; j &lt; 10;j++) { for (int i = 10; i &gt; 0; i--) { printf("%d,", i); } printf("\n"); } } edit:extra comma;
Yes, that's the issue which arises when valueCount &gt; 4. I guess I should have specified I'm on a LP64 system. The code would "work" on ILP64. What actually happens under LP64 is undefined behavior - so even in that case it might seem to work depending on your system. It can be fixed by adding a cast: result |= (uint64_t)values[i] &lt;&lt; 8*i; 
By Wikipedias definition: https://en.m.wikipedia.org/wiki/High-level_programming_language
**High-level programming language** In computer science, a high-level programming language is a programming language with strong abstraction from the details of the computer. In comparison to low-level programming languages, it may use natural language elements, be easier to use, or may automate (or even hide entirely) significant areas of computing systems (e.g. memory management), making the process of developing a program simpler and more understandable relative to a lower-level language. The amount of abstraction provided defines how "high-level" a programming language is. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
[Tanenbaum's bible](https://www.amazon.com/Modern-Operating-Systems-Andrew-Tanenbaum/dp/013359162X) will most likely be the course literature for your upcoming operating system class at university. It's a bit pricy, but I'm sure your local library or pirate bay has a copy. Doesn't hurt to dig into it early. That said, modern computers can be a bit overwhelming. Banging directly on hardware was commonplace for any program back in the C64/Amiga days. If you have any interest in retro computers, these are very well documented by now. Edit: I guess I was actually thinking of [this book](https://www.reddit.com/r/C_Programming/comments/73az13/what_is_c_used_for/)
You need to re-zero `sum` after each day. You can do this with `sum = 0;` either at the beginning or end of the outermost loop. Hope this helps. 
I think someone might have answered this question for me here before, but I just want to make sure. Endianness doesn't factor into this at all, right? It's simply the compiler's responsibility to make sure that everything works?
From Dennis Ritchie himself: "By early 1973, the essentials of modern C were complete." See http://csapp.cs.cmu.edu/3e/docs/chistory.html for more details and dates. If you want something with a specific date, publication of "The C Programming Language" was Feb 22, 1978 (https://www.amazon.com/Programming-Language-Brian-W-Kernighan/dp/0131101633). 1978 was also the year *pcc* was released, which made it much easier to port C to other systems (both other machine architectures and non-Unix platforms) and eventually shipped as the official C compiler with Unix.
Endianness is not a consideration here - the shift operators always work the same regardless.
Wow that's so obvious I feel kinda silly thanks man
Others have already mentioned that C is widely used, so here goes some information on "how to write an OS": * start simple. Don't think that you reuse any of the code for that first OS ever again. Target one platform (cpu, board, ...). Use an embedded board (like ARM), they have some great instructions going on * osdev is a website with some resources, just dive in * don't be frustrated if it doesn't work, come back to it later * take a course in your University if available. I took one and wrote a small kernel last year. It was definitely fun and taught me a bunch of things I learned theoretically how they actually work :)
In the beginning all you want is results. In the end all you want is control. That's why Java and C exists.
&gt; I'm taking my first C class (...) on our college I assume that an appropriate programming environment is provided for this class, so you should ask your course instructors/tutors/colleagues/documentation. It is not easy to make your first program run if you are new to programming. Maybe there are also some detailed description how to create and compile a simple program in your environment.
It's essentially a search problem in a [graph](https://en.wikipedia.org/wiki/Graph_\(discrete_mathematics\)). Consider every configuration of the cube a *node* and every move an *edge*. Now you can apply a [search algorithm](https://en.wikipedia.org/wiki/Search_algorithm) like [BFS](https://en.wikipedia.org/wiki/Breadth-first_search) or (even better) [A*](https://en.wikipedia.org/wiki/A*_search_algorithm) onto it. A* is especially efficient, because you can use your `check` function as a heuristic. If you are more into the specific problem, have a look at [„Optimal solutions for Rubik's Cube“](https://en.wikipedia.org/wiki/Optimal_solutions_for_Rubik%27s_Cube). Good luck!
**Graph (discrete mathematics)** In mathematics, and more specifically in graph theory, a graph is a structure amounting to a set of objects in which some pairs of the objects are in some sense "related". The objects correspond to mathematical abstractions called vertices (also called nodes or points) and each of the related pairs of vertices is called an edge (also called an arc or line). Typically, a graph is depicted in diagrammatic form as a set of dots for the vertices, joined by lines or curves for the edges. Graphs are one of the objects of study in discrete mathematics. *** **Search algorithm** In computer science, a search algorithm is any algorithm which solves the Search problem, namely, to retrieve information stored within some data structure, or calculated in the search space of a problem domain. Examples of such structures include but are not limited to a Linked List, an Array data structure, or a Search tree. The appropriate search algorithm often depends on the data structure being searched, but also on any a priori knowledge about the data. Searching also encompasses algorithms that query the data structure, such as the SQL SELECT command. *** **Breadth-first search** Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a 'search key') and explores the neighbor nodes first, before moving to the next level neighbours. BFS and its application in finding connected components of graphs were invented in 1945 by Konrad Zuse, in his (rejected) Ph.D. thesis on the Plankalkül programming language, but this was not published until 1972. It was reinvented in 1959 by E. F. Moore, who used it to find the shortest path out of a maze, and discovered independently by C. Y. Lee as a wire routing algorithm (published 1961). *** **A* search algorithm** In computer science, A* (pronounced as "A star") is a computer algorithm that is widely used in pathfinding and graph traversal, the process of plotting an efficiently directed path between multiple points, called nodes. It enjoys widespread use due to its performance and accuracy. However, in practical travel-routing systems, it is generally outperformed by algorithms which can pre-process the graph to attain better performance, although other work has found A* to be superior to other approaches. Peter Hart, Nils Nilsson and Bertram Raphael of Stanford Research Institute (now SRI International) first described the algorithm in 1968. *** **Optimal solutions for Rubik's Cube** There are two common ways to measure the length of a solution to Rubik's Cube. The first is to count the number of quarter turns. The second is to count the number of outer-layer twists, called "face turns". A move to turn an outer layer two quarter (90°) turns in the same direction would be counted as two moves in the quarter turn metric (QTM), but as one turn in the face metric (FTM, or HTM "Half Turn Metric", or OBTM "Outer Block Turn Metric"). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
I once did a tool to solve the rubik's cube as well. Well it was rather a tool to simulate it. And it was only the 2x2x2 version, because of the reason how my solution works. My approach to the mechanics were to store it in a 2d-array by using a 2d representation of the cube like this: http://www.ivlabs.in/uploads/5/1/1/3/51135457/17191026659-b6056ed287_orig.jpeg I guess this makes it somewhat easier. However I didn't really bother to implement the classic solutions like layer-by-layer method or roux or cfop. Maybe as you said it could be done by recursion if the code goes through every possible solution method and chooses the one with the lowest move count. My method was to spam random moves until it was in a solved state. It was more of a experimenting to see how long it takes on average. The average of 100 result was about 1.7 million moves with a lowest of 8 and a highest of 20 million. It was quite fun to do but very useless I guess. Remember that this was for a 2x2x2 cube, since I thought that the normal version would simply take too long to calculate. You might want to check out r/cubers. It's a pretty active sub with a very friendly and helpful community and there are some people over there who already wrote code to solve cubes.
&gt; Even if it gets promoted to an unsigned int uint8_t is guaranteed to be promoted to an int because an int is guaranteed to be able to represent the values 0-255. You seem to be thinking of some exotic cases for character types. 
&gt; for example vim 100% agree thats a setup that he should end up with in the end. However, who runs a class and thinks its a good idea to teach the participants C, vim, and remote access all at the same time?! Setting them up for failure, you want to show them stuff one step at a time, this is not throwing them in the deep end, but throwing them in the sea in a hurricane.
&gt; I guess I should have specified I'm on a LP64 system. The code would "work" on ILP64. &gt; &gt; What actually happens under LP64 is undefined behavior - so even in that case it might seem to work depending on your system. It's undefined behavior on ILP64 too for values[7] &gt;= 0x80. values[7] will be promoted to a 64-bit int for the shift, and the value (&gt;= 0x80) * 2^56 isn't representable as a 64-bit int. 
Because if people want a DLL injector, they can look up a project from github where they can simply use the code instead of watching a 20 minutes video where you don't really do anything except typing the code out. That's just useless.
Quite interestingly, this is the topic I currently write my Bachelor thesis about. The algorithm you'd typically use to find (optimal) solutions is called [IDA\*](https://en.wikipedia.org/wiki/Iterative_deepening_A*). This algorithm requires a heuristic function that tells the algorithm something about how far the current configuration is away from the solved configuration. There are multiple well-known heuristics, but they can be a bit tricky to implement.
To parse command line options, look up the `getopt` standard library function. Your code looks really nice btw.
&gt; for example emacs FTFY
Chrome and Firefox are mostly C++.
Sure, you can use the bricks that Java or Python give you, even if they're not quite the bricks you need or like. But inevitably those not-quite-right bricks will influence how your skyscraper looks and feels. On the other hand, you can take some time to build exactly the bricks you need and use them to build the skyscraper of your dreams. It may not be the most efficient way to build a skyscraper, but if you're doing it for yourself, as a hobby, it can be a lot of fun.
Apart from editing the files on that server with a terminal based editor of the admin's choice you could look into file transfer over ssh (checkout winscp), or possibly set up an bare git repository in your user space and connect to it using ssh. But if all you need to do is write a helloworld c program, using nano as editor will be more then sufficient.
Thank you! Actually I found out `getopt` when I had just finished writing my parser and I didn't really look into it because mine was working. Next time I'll use it though.
It takes less than a minute and a few paragraphs to learn how to use vim to edit any text file. Anyone who says vim has a steep learning curve has never learned vim.
You can learn how to use all that, except C, in a few minutes. It's easy. Even a redditor can do it but, now, I'm not so sure about that. I'll ask my 10-year old son who learned it all one night a few years ago right before I went to bed.
The class is just used to structure the C++ code. Instead of a class, you could just use a `struct`.
if you program microcontrollers without a full OS you use C. 
No he's not, many people write their own OS. It's an academic experience. He didn't say he wanted to write a commercially successful operating system, just that he wants to write one.
Anyone who needs absolutely top performance. As someone who works in algorithmic trading, milliseconds and microseconds matter. I don't want a cache miss. When you want the most from each CPU, you use C. You don't use C++ and the STL, because many containers in STL do dynamic memory management. You're going to want to avoid memory allocations in your processing loop, your going to want bounded memory, etc. If your project's performance means dollars, and you have the time to do it in C, that's when you use C. 
AFAIK `getopt` isn't a standard library function, or do you mean [POSIX](http://pubs.opengroup.org/onlinepubs/009695399/functions/getopt.html)?
POSIX is a standard, too and getopt is part of the POSIX libc.
K, but it's not part of the actual C standard library aka "the standard library". I mean, that's just imperialism through ignorance that you're pushing.
https://stackoverflow.com/questions/8671366/undefined-reference-to-pow-and-floor. Google should be your best friend for these errors. 
Great thanks, I wasn't sure if the class was required in order to instantiate the threads in the library and as I said I know nothing about C++
What the other comment said. Also, there is no pause command on linux. 
Thanks a ton, I thing I understand what you mean :P Now comes the hard part of coding it, and since I'm not that great at that, it'll be hard. But its going to be fun! :D Thanks again! :) 
Thanks, I just hope I'll be able to code it before the deadline :P 
You're so dynamic you help me. I hope you have a nice day!
good bot
Thank you 1234567890qwertzuiop for voting on WikiTextBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
And firefox is slowly transitioning to Rust
Also, allegro3 is C based, so you could always use that.
$166.83? You US folks have a really messed up publishing industry. I paid 69.95€ for the german translation. And that's already considered somewhat expensive for beginners textbook. High-quality mathematics textbooks cost somewhere between 20€ to 50€ here.
eh, as someone who uses vim a lot for my school work, it's not very intuitive. Learning C can be hard enough -- getting frustrated by an unintuitive text editor can detract from the learning process for someone just starting out.
While I'm not going to claim this means it has a steep learning curve, I am going to say that I couldn't ever wrap my head around the whole modal thing. As a result, I know about as close to the bare minimum as possible, which obviously does not lead to using Vi efficiently. I don't think Vi is a *bad* editor, just that my brain is far more compatible with the Emacs model/workflow.
I think what you're after is nested loops. You already have the outer loop that runs j = 0; j &lt; 10;. On each iteration of the outer loop you want to run an inner loop that runs i = 0; i &lt; j; Also, the comment `/* n is an array of 10 integers */` is not correct - it's an array of characters.
Note that the C standard contains the UNIX libc with all OS specific bits.stripped out. POSIX simply adds many bits back to the library. You can ignore POSIX but you just make it harder for yourself.
&gt; Also, the comment /* n is an array of 10 integers */ is not correct - it's an array of characters. Yeah my bad, I copy pasted from a different website, modified without changing all the comments. Careless error. 
This subreddit is about programming in C only. Please post C++ content elsewhere.
You initialize `n` with 11 stars. If you don't see a compilation error then reconfigure your compiler . Seeing error messages is important. 
It’s ridiculous. Our textbooks are stupid expensive and we put out new editions every year or so. You pay $100-200 for one and you get maybe $50 back if you sell it back at the end of the year. Sometimes you can get international versions of the text in English for a reasonable price but that may be questionable legality. #MURICA
It appears that you have been shadow banned. Please talk to the admins to rectify this issue.
&gt; low level parts of OS’s The high-level parts as well. X and Gnome are written in C.
&gt; Personally I think a great place to start is to look at OpenBSD source files. That is some of the cleanest C code you will ever see. I looked at a random source file: https://github.com/openbsd/src/blob/master/sys/kern/kern_bufq.c There are almost no comments, which would be fine if it wouldn't lead to some guess work. struct buf *bp; This probably stands for buffer pointer. Is it a pointer to the whole buffer or just part of it? void bufq_drain(struct bufq *bq) { struct buf *bp; int s; while ((bp = bufq_dequeue(bq)) != NULL) { bp-&gt;b_error = ENXIO; bp-&gt;b_flags |= B_ERROR; s = splbio(); biodone(bp); splx(s); } } int s? splbio? biodone? splx? I definitely hope not that is some of the cleanest C code I will ever see. People love to shit on Java for its verbosity, but at least I can actually read the code there without having to look up the definition of everything all the time.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [openbsd/src/.../**kern_bufq.c** (master → f613d02)](https://github.com/openbsd/src/blob/f613d021389fcd97e4b28685a300193deaf29133/sys/kern/kern_bufq.c) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dnqdmwn.)^.
Sure there are upper level components written in C too, it’s just a lot less common. Especially in macOS and Windows.
&gt; "oh yeah? Running on what, C?" C++ At least for Oracle JDK and OpenJDK. I don't know about exotic implementations. There used to be a GNU Java Compiler though you can argue [whether it was ever really alive](https://stackoverflow.com/a/4040404).
Try not to copy paste codes from somewhere else. And write your own code.
Talking about the OS.
Oh, and also your printf call is wrong, and you have declared the variable *i* that is never used #include &lt;stdio.h&gt; #define MAXARRAY 10 int main(void) { char array[MAXARRAY] = {"**********"}; int i; for (i = 0; i &lt; MAXARRAY; i++) { printf("%c\n", array[i]); } return 0; } In C when you are dealing with chars and strings, the previous way to initialize it's risky b/c you are ignoring the null terminating char. In such cases It's best to leave the lengh unespecified and declare the initializer, so the compiler will append the '\0' for you at the end char array[] = {"**********"}; results in: * * * * * * * * * * * * \0
You can initialize a char array with a string literal, even in C89.
I'm sure redditors everywhere will not claim emacs is easier to learn than vi or vim.
So you struggle finding i-j-k-l-h on your keyboard like most redditors, eh? The statement was that he thought learning vim was hard, not that it was not intuitive. vim may not be intuitive but vim is not hard to learn.
Find another job before potential employers start to think all you can do is web dev. That's it, just start applying to entry level jobs. It's a good thing you are doing python and mobile dev at least.
You're right, I didn't know. ty :)
Start writing code and getting it into the kernel tree. Nothing is gonna give you mad street cred like listing 5 or 10 patches commited into the kernel tree. Its the ultimate peer review and stamp of approval.
Hmm. I started life as an EE and only did assembly. I was dragged into using C, kicking and screaming, when our manager forced us into it. So everything I've done since then was writing assembly and C for the hardware devices I designed, embedded through full blown medical computers from the TTL level. So don't think working in electronics means you don't use C. I, too, like to stay as close to bare metal as I can get and now own and run a web dev company making high performance web sites, especially for two companies that you probably visit about once a month. Guess which language we use.
I did EE with a major in Power, but I've been working for a firm in enterprise RDBMS development since even before I graduated (started as an in intern in the firm). Its all low level C and C++ with over 30 million lines of code. Massive product and a lot of fun to code! 
Other than applying for another job, which other redditors suggested, why not start playing around with microcontrollers (Arduino, or other small boards). Do some side projects. And throw your code up on github. As someone that interviews people often, if the candidate has a github link on their resume, I always check out their code. Seeing what you work on and how in-depth your projects are factors in greatly into my company's hiring practices.
&gt; Guess which language we use. Javascript
This is the best advice. It’s ridiculous how quickly you can get pidgin-hole’d.
Yea but underneath JS is C++, so pretty much C
If my memory serves me right, I paid the equivalent of 33€ for my [20y old 2nd edition](https://imgur.com/196MZMD).. but that was in a currency that hasn't existed for 15 years.
Such bullshit.. the whole article is just a pile of crap to advertise the next hipster puke.. not even new thoughts about disruptions
today in internet world you dont need to refer so many books to learn the coding just think what you want to learn and google for that code than you will get it, to improve the coding skills analysing the examples is a good idea. you will get lot of examples of c on [c examples](https://cexamplestutor.blogspot.in)
I see 2 thing happen: First, your first scanf in the guard reads in a string, but you don't do anything with it. It will get lost. Second, you probably think the str variable gets appended, but it gets overwritten every time. A tip, use a different variable for scanning in this case. Something like: `char ca; scanf("%c ",&amp;ca); someArray[i] = ca; i++;` This scans in the next character c, in variable ca. Assign that variable to the i'th element of the array. Also some thing to be careful about is spaces and newlines. These are also considered characters, so scanning for a character can read a space/newline.
`s/kernel/linux kernel/g`
Those kind of errors occur some times and it's important to fix it as quick as possible in order to keep your code safety. Those errors can be handled right after they are detected. If it's getting too hard for you there are programs that help doing that, such as checkamrx and others that work fine. Wish you well.
Very much this. I have done full-stack Java enterprise for 4 years professionally (working with C, Python etc. on private projects a lot) and decided to change to embedded programming and do real engineering instead of bloat. It's not easy convincing people that you can do it, but I anticipated that and started putting together a portfolio of projects on GitHub. It helps somewhat, but it's still hard. Also, only a handful of embedded jobs do not require XYZ years of experience. But do not give up, it will work out, patience is required.
&gt; he thought learning vim was hard Thats incorrect by the way. My statement was that subjecting learners to C programming, vim, SSHing into a remote desktop and maybe even have them use linux for the first time all at the same time is insane and setting them up for failure.
&gt;[**WATCH THIS IF YOU WANT TO BECOME A WEB DEVELOPER! - Web Development Career advice [20:24]**](http://youtu.be/zXqs6X0lzKI) &gt; [*^LearnCode.academy*](https://www.youtube.com/channel/UCVTlvUkGslCV_h-nSAId8Sw) ^in ^Science ^&amp; ^Technology &gt;*^431,168 ^views ^since ^Feb ^2014* [^bot ^info](/r/youtubefactsbot/wiki/index)
Spam
Yet another extremely low quality programming blog from India. Seriously, what's the reason people keep churning these out? Issues: 1. Extremely confused terminology. "email", "username", "server", "domain" — none are used correctly. 2. Lazy potential buffer overflow in *scanf* 3. Terrible char-by-char printing of the results 4. Email addresses may contain @ characters in the local-part, it they are quoted. The program doesn't take that into account. 5. Email addressed doesn't need to have dots anywhere; "a@to" is totally valid. If that is entered the program will cause undefined behaviour. 
look at my blogger www.getlets.blogspot.in
This all assumes that the machine is correctly set up for C development with a compiler and manual pages. Open a terminal prompt. Run `cc`. It should present an error output. `cc` is the C compiler. It is in the executable path, so you don't need to write its path to execute it. You can see where in the file system it resides by typing `which cc`. It produces an error because it hasn't been invoked properly. To compile a program, it needs at least to be supplied with a list of source file names to compile. Open a text editor and write a small program, say #include &lt;stdio.h&gt; int main(void) { printf("hello\n"); } It can be any text editor. Running either `$VISUAL` or `$EDITOR` in the terminal should invoke the default text editor, but a desktop system usually includes a non-default editor that is easier to use for a newcomer. Save it with a .c extension, maybe in its own directory. For the sake of the example, as "hello.c" in "Documents". Now you can use `cc` to compile the program code into an executable file: in the terminal, navigate to the directory where you saved the program source and run `cc -o hello hello.c`. The path is normally "~/Documents", "~" being a short way to address the user's home directory. If all goes well, `cc` will have compiled the source and linked it into an executable in a single step. There should now be an executable file in the same directory, named simply "hello". The name of the executable is specified with the `-o` option, and it is built from the supplied list of source files (in this case, only "hello.c") and any file those might have included using preprocessor directives. You can launch an executable by typing its path, in this case, the current working directory, so "./hello". You could also type "~/Documents/hello" or "/home/&lt;username&gt;/Documents/hello" -- these are just different ways to address the same path in the file system. Running it should print "hello" to the terminal. Make a change in the program and invoke `cc` again. Make a breaking change, for example by removing a bracket, and note the error output of the compiler. It will normally display a line number to point you in the right direction. If you need help on any of the library functions, you can use `man` to read the associated manual pages. The third section contains library function information, so to see how `printf` should be invoked and a description of what it does, you would use the command `man 3 printf`, which will open a pager application so that you can browse the documentation. The first (and default) section contains information on tools and utilities, so it will contain information on most of the commands you find yourself using in the terminal. For example, you can run `man ls` or `man mkdir`. When you are comfortable with the basics, you can start thinking about how you want to edit and arrange your files, and if you start working on a larger project, you can think of ways to automate and minimize build times by partial compilation, source control etc., but this should be enough to get started.
I'm a die-hard Vim user. I don't think it's hard, but learning it takes an effort that is entirely orthogonal to the effort of learning the C language. Also, if all you do in Vim amounts to i, j, k, l and h, there's no reason not to use any other editor, except maybe `ed`.
1. This isn't a primality check. It checks whether a number is odd or even. 2. The video quality isn't all that great, visually speaking, and using a text editor to give commentary is a major YouTube pet peeve for many people -- and that's before we add horizontal scrolling to the text editor. 3. Use `int main(void)`, and call `fflush(stdout)` after prompts without terminating newline characters. The stdout stream will typically be line-buffered for an interactive device, and not all systems will automatically flush stdout when user input is requested on an interactive stdin.
This subreddit is about programming in C. Your post is not about C and thus off topic.
Please don't post these.
the effort you put into this video could have gone into a better program.
Trying to compare learning vim to learning c has nothing to do with anything in this thread, or the rest of the world for that matter.
I won't look back up this thread, so I don't know if it was you who I'm referring to, but someone at least implied that learning vim was difficult.
"At least we're not coding JavaScript." ~Fast food workers, probably
Don't make jokes like that on reddit. It will confuse 80% of them who will take it as serious and run with it, destroying their lives, and committing themselves to a life of working fast food.
Programming is programming. I find web dev isnt any different than C coding. Instead of learning some api, youre reading tech sheets on how to use the pins etc. The only difference really comes down to web davs hardly care about performance and good design (for most web shops, not a complete blanket statement)
You don't. Typically, APIs specify that pointers to entries are only valid until the next operation on the data structure. Note further that the suffix `_t` in identifiers is reserved by POSIX and should not be used by applications or libraries. I recommend just sticking with `struct hashtable` instead of introducing a typedef. 
Wow no wonder there didn't seem to be any implementations dealing with this. Thanks! 
My pleasure! I really like how well-commented and structured your code is. Also, I like how you use the correct indentation style.
Thanks! I'm trying to develop good habits.
I *so* wish you do it in assembler and C, just because fuckit.
I want to disagree vehemently. There is a vast difference between writing software for people and writing firmware for electronics. You have to *think* like the consumer of your software - like a human or like a machine - and whereas people are fickle and unpredictable, machines are precise and unforgiving...and do not have *any* sense of humour or irony.
That's very good! I see, you have the right attitude to become a very good programmer.
no its not, the embedded software I work with is customer facing to some extent. We need to worry about UX as well, we actually have a webUI for the thing because customers hated using vim to edit the configuration. Programming is Programming, doesn't mater the language, its all the same shit. Its not different mucking around with DSPs and massaging audio to get sent out, compared to bouncing an HTML string around php to generate a web page. Just in we care about performance. 
Kind of an anecdotal, somewhat irrelevant comment: I'm an experienced C programmer, and I've found that most driver engineers don't write good C code. I don't know why, but I've found it to be the norm. 
Javascript: not even once.
trust me, its 10x better than most web shops. I work on an application that was made to work first, then shit we should try to reduce technical debt after the fact. I would take this code base over the webshop's code base anyday. 
I've always worked on embedded systems, so I will take your word for it. 
Well, of course there are many implementations in C++, where the equivalent of a pointer to a `struct tableentry` is an iterator. And any mutation operation on the container invalidates all the iterators pointing into it. STL offers maps, which don't invalidate iterators on insert (because, essentially, they are not hash maps).
hey i need some help? why when i running this program it will only generate 6 as a random number. while it random the score. can someone tell me where to fix it? please
K, but it's not cross platform. it's not available on non-unix based OSes... I mean, that's specifically why I wrote my own command line parser, [CommandLineIO](https://github.com/bumblebritches57/BitIO/blob/master/libBitIO/src/CommandLineIO.c)...
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [bumblebritches57/BitIO/.../**CommandLineIO.c** (master → 6121ae8)](https://github.com/bumblebritches57/BitIO/blob/6121ae8f0cdcdbd0455c584bc1680076214cd17f/libBitIO/src/CommandLineIO.c) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dnri5mb.)^.
Make the following call, once, before using `rand`. srand((unsigned)time(NULL));
tq. and now when i run it. they score seems weird. any idea?
C. One of the first projects we had only had an interface with C and PHP. PHP was too slow, and we didnt' really know the language, so C it was. For fun, I did write some of our routines in assembly back in the day during some down time. It actually helped cause we needed to use a dial up modem for faxing from the web and I had found an assembly routine to do it.
If you’re reading a grid of letters, read them line-by-line and process the strings individually. `scanf` has its place, but this ain’t it. Something like this might work better: static char grid[MAX_ROWS][MAX_COLS]; static char buffer[MAX_COLS*2+1]; unsigned row = 0; while(fgets(buffer, sizeof(buffer), stdin)) { char *p, *q; q = grid[row]; for(p = buffer; *p &amp;&amp; *p != '\n'; p++) { if(*p != ' ') { assert(q &lt; grid[row+1]); *(q++) = *p; } } } If you’re really desperate/mandated to use `scanf`, you could probably use `sscanf` on each scanned line. It’s mostly a terrible set of functions to try to use in anything remotely real-worldish though.
I'm reminded of a quote from The Simpsons ["We've tried nothing and we're all out of ideas!"](https://www.youtube.com/watch?v=lkKwyjsJGxk) "Weird" is not much of a description. What do you expect score to be? What does score actually turn out to be? As you step through your program, how does the value of score change? The process of debugging your program is posing and answering questions like these. That's how you learn to program.
Some code fixes: **ht_create()** `ht-&gt;load` not initialized to 0; you're not really using this for anything other than incrementing/decrementing, at least in the code you've presented, but you may find it working by accident on Unix/Unix-like systems if your malloc() implementation is backed by an anonymous mmap() and if your kernel zero-fills anonymous mappings memory leak if `ht-&gt;tab` allocation fails; free `ht` before returning NULL `ht-&gt;tab` is a double pointer, so change `sizeof(tableentry_t) * size` to `sizeof(tableentry_t *) * size`; if this is going to be used in production code taking an arbitrary `size`, there's the potential for this expression to overflow; a crude defense is to impose an upper bound on `size`, and while you're checking for that, you may as well ensure it's &gt; 0 **alloc_te()** it's not clear why calloc() is being used, but if it's to initialize the pointers, note that calloc()'s all-bits-zero initialization isn't guaranteed to be the representation of a null pointer; you're better off simply replacing calloc() with malloc() and initializing all three pointers with NULL immediately after the malloc() if it succeeds (deleting `te-&gt;next = NULL` later in the code) `te-&gt;key` will involve a null-pointer dereference if the calloc() fails; this kind of thing can be handled in a structured way, but it's a widely accepted design for a function with multiple failure points and a common clean-up block to use `goto`; note that this design may result in free() being called on an all-bits-zero `te-&gt;val` if the `te-&gt;key` allocation fails, and if that's not the representation of a null pointer, you'll have problems -- see the first fix it looks cleaner and more consistent with the internal API to replace the call to free_te_list() with a call to free_te(); this will result in null-pointer dereferences if free_te() is being called with a null pointer as a result of a failed `te` allocation, so you'll need to add an `if (te)` guard somewhere, preferably in free_te(); incidentally, note the second assumption of an all-bits-zero null-pointer representation in free_te_list(), this time for `te-&gt;next` -- see the first fix **ht_insert()** doesn't check for NULL return of alloc_te() **delete_te()** there's a superfluous comparison made against the bucket head, which may or may not bother you; if you decide to fix this by adding `te = te-&gt;next` before the loop, you'll also need to replace `te = ht-&gt;tab[hashval]` with `prev = te = ht-&gt;tab[hashval]` **ht_delete()** unused variable missing return value **resize()** doesn't check for NULL return of ht_create() memory leak: if ht_insert() fails, NULL gets returned before memory allocated for the new hash table is reclaimed
When you resize your hash table, re-use the old entries instead of creating new ones. This not only solves the problem at hand, it is more efficient since you avoid unnecessary allocs and frees. Of course, this will mean your resize code becomes more complicated.
Write a C program that simulates a guessing game. Each turn you choose among 9 possible guesses. As many as five guesses may be made a turn. For each turn the program will generate a random number between 1 and 36. Each correct guess will be rewarded with points based on how many of your current points risked. A game board divides the numbers into rows and columns. The board provides the basis for your guesses. You can guess whether the random is even or odd. In this case, you get 1 point for each point risked when you guess correctly. You can guess whether the number is low (1-12), medium (13-24), or high (25-36). In this case, you will get 2 points for each point risked. You can also guess left, center or right. In this case you get 2 points for each point risked when your guess is correct. Finally, you can guess a specific number between 0 adn 36. In this case you get 36 points for each point risked when your guess is correct. To make the game more interesting each round allows up to five guesses. That was the question. Right now the scored is suddenly become random and does not follow the code given. if example when i risk my point 5 for odd guessing. if i got it right it should give me 10 points. but now when i run this program the scored become a million.
literally me irl. I'm not professional yet, the way I've been doing it is to made libraries and apps, and put dat shit on my resume. My problem tho is how to find companies that do C so I can submit my resume?
This answers so many questions I had. Thank you!
I'll have to look at the assignment again, but I'm pretty sure I am forced to use scanf unfortunately. But if not, I'll definitely try it this way. Thanks!
Lel. You're delusional if you think the vast majority of webdevs even know how to write an algorithm. They're just library using monkeys.
Fuck web startups, and conflating startup with web. Here's the thing buckaroo. most of the webdev "languages" are more or less just massive libraries on top of C, with a few syntax changes. the only difference is, with C you can choose which libraries you need and which you don't.
Everything? Python is written in C...
Well, I'm writing a few media codecs in C...
Sorry dude, but [my code](https://github.com/bumblebritches57/BitIO/blob/master/libBitIO/src/CommandLineIO.c) is by far the cleanest looking C code I've ever seen...
&gt; For fun, I did write some of our routines in assembly My kinda guy!
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [bumblebritches57/BitIO/.../**CommandLineIO.c** (master → 6121ae8)](https://github.com/bumblebritches57/BitIO/blob/6121ae8f0cdcdbd0455c584bc1680076214cd17f/libBitIO/src/CommandLineIO.c) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dnrpbfi.)^.
Dude, that's just fucking ignorant. News flash: structs are a thing! with them you can make bigger and bigger modules, and then it's literally just as high level as the latest fad language.
A large scale website/web app requires lots of programming knowledge and design know how. I'm not talking about babies first webpage, I'm talking about a full php system, with login, back end databases, load balancers etc. 
That blog post seems pretty clear to me; I wouldn't know what to add to that without more specific information about where exactly you're getting stuck. Here's something you could try: Draw a small framebuffer (&lt; 50 pixels, you'll see why in a moment) and inside that, draw a right triangle that has a horizontal and a vertical side (i.e. parallel to the X/Y axis respectively). Pick a couple of points inside the framebuffer (e.g. one inside the triangle and one outside) and figure out how to compute (manually) on which side of each of the three lines those points are, with the help of [Wikipedia: linear equation](https://en.wikipedia.org/wiki/Linear_equation). Some hints: The answer will depend on the order in which you plug the two end-points of a line segment into a formula. Not every form from the above-linked page will work for every line. If you get tired of doing equations, you can speed up the process by using something like Wolfram Alpha or a spreadsheet. Then, do a desk test of your code applied to your drawing, i.e. compute the result yourself instead of letting the computer do it. This should make the math clear, or at the very least help you formulate a more specific question. In case you have questions about the C code you wrote, don't forget to post that code.
**Linear equation** A linear equation is an algebraic equation in which each term is either a constant or the product of a constant and (the first power of) a single variable (however, different variables may occur in different terms). A simple example of a linear equation with only one variable, x, may be written in the form: ax + b = 0, where a and b are constants and a ≠ 0. The constants may be numbers, parameters, or even non-linear functions of parameters, and the distinction between variables and parameters may depend on the problem (for an example, see linear regression). Linear equations can have one or more variables. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
Thanks! I'll see if i get time to try it out tomorrow!
Instead of copying the string that the user inserts make it the users responsibility to manage that allocation. Your hash table shouldn't need to know what data is inserted. This uses less memory, has less memory copying, is easier to make thread safe, etc. That's how pretty much every general purpose data structure I've worked with deals with it (because I refuse to use inefficient hash tables, trees and such that copy data all the time). The only disadvantage is that you need to free things if you're removing values in bulk, but that can be done with some kind of "foreach" function.
As others have said, you typically don't, as that invalidates your pointer into the hash table. Take a look at C++'s [std::unordered_map](http://en.cppreference.com/w/cpp/container/unordered_map) and look at the stuff about iterator invalidation. (In C++, an iterator is anything that implements the * deference operator.) You could probably implement a hash table that does deal with that though. It's all about trade offs. I haven't completely read through your code, so forgive me if I make a bad assumption about it. One possibility is to add a level of redirection, and have an array of entry pointers instead of entries. When you resize, you copy pointers around, but all references to the entries themselves remain valid. It's also possible to implement a persistent hash table. Persistent data structures are popular in functional languages. The idea is, all operations on the data structure return a new struct, but the old structure remains valid. One way to do that is just to copy it every time, but that's obviously inefficient, so there's lots of clever tricks to share parts of it. This is easier to implement in garbage collected languages though, since they don't have to deal with cleaning up.
Thanks! I'll get to fixing those.
Did you use one of the C web frameworks (like Onion, Klone, Kore, etc)? Or roll your own? 
What assistance do you need? Or are you asking this sub to do your work for you?
It's not updated to the same tune as VS, it will work for 2015 but they haven't dropped a 2017 version yet, maybe after 5.10. Also if you're new to Qt, I'd recommend just going with Qt Creator for the time being, the integration is good and it will spare you the hoops of jumping between designer, debugging and moc issues etc until you get used to it.
I'm not sure how to do the problem. Can someone link a website that cab explain how to go about doing this. It's not even HW. I just need to know this 
You have inspired me to use reddit as my IDE. That was beautiful.
We write all our own code. We are a custom shop. We do have our own library of some things but we piece things together to do what we wish. We have never taken any significant amount of code from one project and used it in another except as components that are almost always modified in some way. We love all thing Unix and BSD and everything we do uses the standard utilities there.
Cool, thanks! 
You didnt even make the minimal effort to link to the assignment, you linked the actual file on your PC. And it's your first assignment. Good luck with your life. It's going to be a difficult one. 
I think the process is supposed to be to take the sum of the *squares* of all of the digits, right? It does look like you're squaring the first digit there. At a glance... you're checking if (sum == 1) after you've only squared and summed a single digit. It looks like you ought to be repeating that first 2-line section until the number divides down to nothing, and *then* you can check the sum. If you enter 91, for example, it's going to square the 1 and quit before it does anything else. If you're only using 'i' as a counter, you might as well get rid of it and use cycle_no as the counter. Just make sure you initialize it.
I’m definitely keen! Web developer moving over to programming with a little experience in python and C. Open to learning! 
This subreddit is about programming in C only. Please ask C++ questions elsewhere, e.g. in /r/cpp_questions.
You might receive better answers in /r/visualstudio.
I've been implementing my own hashtable as a learning exercise as well, but I've chosen to do the resizing by modifying the pointer to the original hashtable (using a double pointer, see [here](https://github.com/krpors/cfiddle/blob/master/hashtable/hashtable.c#L170)). Other than that, I'm no full blown experienced C programmer, but I find your code easy to read, even though it's not my favorite coding style :)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [krpors/cfiddle/.../**hashtable.c#L170** (master → 791da5c)](https://github.com/krpors/cfiddle/blob/791da5c2b07c0c7078d6b3d218b85dbbfbd20132/hashtable/hashtable.c#L170) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dnsju2h.)^.
interested in algorithms and compilers. as for language I can do C/C++ , python , java
Interested in algo and low level stuff. As far a language..I know C, Java. Keen to work with someone to improve my knowledge. 
C is a write-only language. Once the source code has grown to a hundred files or so it becomes impossible to make heads or tails of it. Man, I'm glad I was born after the assembly era.
Start by editing your post and inserting four spaces at the beginning of each line, even those that already begin with spaces.
1) ask user for rainfall amount 2) determine water needed 3) display water needed
So, I'm looking for a few people to give me advice on a few things. How do I get my library 'out there', was wondering about submitting to have it as a Debian package but apparently it's hard. Was wondering if someone could have a quick read through the source too and point out anything I would've missed.. cheers! Feel free to throw me a star too ;)
Yeah, I was thinking about using doxygen type comments. They are just there in case libc isn't linked at all, it's kind of silly really, but I wanted to write something which had no dependencies at all.
In your re-implementation of some libc functions accepting a `size` parameter, you can decrement `size` till it is `0`, avoiding the need of the `i` variable, if I see correctly. Also, in your `lib.h` you define `memcpy` to your implementation if `NO_LIBC` is set, but you don't do it for other functions and in the actual `rini.c` code, you also explicitly check for `NO_LIBC` instead using the macro. Also, in at least `rini.c`, most of the time, if there is one statement to be executed in `if`, you use parentheses (`if (xyz) { stmt; }`), but other times, you do not (`if (xyz) stmt;`). Somewhat inconsistent. And to your CMake file: Why such a high version requirement? Your CMake is so simple, it easily can be version `2.8`. Also, put `C` after the project name, so CMake won't look and check an C++ compiler you don't use. You can also put the source files directly into the `add_library` call, and you don't need to explicitly say `${MyProject_SOURCE_DIR}/`, since it is wrong anyway (Your project isn't named `MyProject`). And if you want to make your library more usable, try [`install`ing](https://cmake.org/cmake/help/v3.0/command/install.html) files with it. Oh, and BTW, the platform independent command to build is `cmake --build .`, not `make`. I haven't really looked the core of the thing.
Shit man I'm wondering the same thing.
Seriously, don't reimplement the libc. That's really bad style.
OK maybe this is a stupid idea: I see lots of `#ifdef NOLIBC` followed by `#else` and `#endif`, for ex. #ifdef NO_LIBC rini_memset(line, 0, MAX_NAME); #else memset(line, 0, MAX_NAME); #endif Isn't it a somewhat nicer solution to code these `#ifdef` macro's inside the function definitions itself? Like: inline void* rini_memset(void* dest, char set, unsigned size) { #ifdef NO_LIBC char* dest_buf = (char*)dest; for (unsigned i = 0; i &lt; size; i++) { *dest_buf++ = set; } return dest; #else return memset(dest, set, size); #endif } I'm curious to what people think about this.
Best would be to just get rid of these useless wrappers. The only plausible reason to have these is as an educational exercise and those don't belong into a professional project.
I partly disagree. On the one hand these #ifdefs make the code more complicated, on the other hand it allowes me to use the library in a freestanding environment without much of a hassle. Isn’t this a reason for a library to exist? To abstract away complexity from user code so you don’t have to look at it if you don’t need to. If your library uses lots of libc functions, sure. Go ahead and have a hard dependency on libc. But if you just use a couple—if any at all—libc functions, a way to use the library without a libc widens the possible audience. Maybe personal bias.
Even freestanding environments have a basic C standard library containing these functions. And more importantly, if you are in a freestanding environment, you often really do not want every library to bring their own implementations of these functions as you are typically restricted in space.
Looks better. And instead of NO\_LIBC use \_\_STDC\_HOSTED\_\_ (only available since C99)
Not a single function is mandated by the standard for a freestanding environment, only constants and types. These simple functions *might* be compiler intrinsics however. The space restriction is a real concern though.
I love this site because it made me rich
This is what I was thinking originally, but after all of these comments I think in the next release I'll be removing it completely.