There's no reason to use `1==1` because it's just a more complicated way to say `1`. Why don't they just use `(0+1)` or `(2/2)` or `(743-744+2)`? Because while all those things are the same thing as `1`, they're all more complicated than saying `1`. 
I don't often use VLC so I'm not familiar with any features it has. I don't have to use C, it's just what I was in the process of learning but if it's not effective for this type of project that's fine :) As for UI I don't think it'd be that complex. It would essentially be one big drag and drop panel with 3 buttons below it (play, stop, clear). Drag whatever song files you want into the main panel, it displays those songs in a list form. Push play to start playing those songs. Stop/pause to interrupt and then clear to remove all songs from playlist. 
The first version you gave is equivalent to the chained assignment. The value of the expression `a=b` is `b`, and `a=b=c` is evaluated as `a = (b=c)`.
My man, thats precisely what I'm curious about :) Just because its "more complicated" from one perspective doesn't mean its wrong. Someone made the decision to use 1...I want to know *why*. Thats not me calling it out as bad. (1==1) may be more complicated according to the spec in that it isn't the most simple expression and it can be reduced but at the same time it doesn't require you to know anything other than the language syntax itself. So it *specification wise* is complicated but *syntax wise* is simple. This is purely and truly a fools argument to say there is no reason to use one or the other as they both satisfy the spec. At some point someone said "go with option A" and my morbid curiosity can't see why one would be used over the other and hopefully someone can point out an objective reason that (1==1) simply cannot or should not ever be used so I can learn something.
To answer questions like this, consult the [operator precedence table](https://en.wikipedia.org/wiki/Operators_in_c_and_c%2B%2B#Operator_precedence) and note that assignment is right associative. 
yes. Don't forget to also initialize next to (struct data_node *) NULL. I've found useful to always keep pointers to the head and the tail of the list, but depends on the usage.
you mean second_node-&gt;next = NULL; like that?
Why didn't they use `(63+19-4-(122/2)-(1==2?1234230948234:4*2*2))` instead of `1`? It's purely and truly a fools argument to say there is no reason to use that over `1` since they both satisfy the spec. Hopefully someone can point out an objective reason why `(63+19-4-(122/2)-(1==2?1234230948234:4*2*2))` simply cannot or should not ever be used so we can learn something.
 ... first=insert(&amp;first, 5); That smells of undefined behavior to me, since first is passed by reference and could be modified by insert(). It's like doing i = i++. See also, [sequence points](http://en.wikipedia.org/wiki/Sequence_point). I might be wrong though. I usually am in /r/C_Programming these days.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Sequence point**](https://en.wikipedia.org/wiki/Sequence%20point): [](#sfw) --- &gt;A __sequence point__ defines any point in a [computer program](https://en.wikipedia.org/wiki/Computer_program)'s [execution](https://en.wikipedia.org/wiki/Execution_(computers\)) at which it is guaranteed that all [side effects](https://en.wikipedia.org/wiki/Side_effect_(computer_science\)) of previous evaluations will have been performed, and no side effects from subsequent evaluations have yet been performed. They are often mentioned in reference to [C](https://en.wikipedia.org/wiki/C_(programming_language\)) and [C++](https://en.wikipedia.org/wiki/C%2B%2B), because the result of some expressions can depend on the order of evaluation of their subexpressions. Adding one or more sequence points is one method of ensuring a consistent result, because this restricts the possible orders of evaluation. &gt; --- ^Interesting: [^C ^\(programming ^language)](https://en.wikipedia.org/wiki/C_\(programming_language\)) ^| [^Feynman ^point](https://en.wikipedia.org/wiki/Feynman_point) ^| [^Comma ^operator](https://en.wikipedia.org/wiki/Comma_operator) ^| [^C99](https://en.wikipedia.org/wiki/C99) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cisk88i) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cisk88i)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
yeah, you should do that when you create a new node. unless you are adding them to the head of the list, instead of the tail.
I've heard that it was, but haven't acted on it. I think I'll pick one up.
You are still missing the point. I get that you say (1==1) is more complicated and therefore its the same as....whatever you have there. I know that internally C uses 1 to represent "true" and it is the most simple expression but I'm not talking about how to represent the spec. I'm talking about how to define it to the programmer. One can simply just say "sure, true is 1" just as much as one can say "sure, true is (1==1)" or "true is (63+19-4-(122/2)-(1==2?1234230948234:4*2*2))" because either way they can get their job done. Complexity is relative. There is a distinction between representing and defining. I want to know why they chose 1 to define "true" in the header because it relies on the internal representation picked by the spec. If the spec defined "true" as 0x34 then whatever thats fine as well. If you picked *any* expression that results in "true" then you don't need to rely on what the spec pics for the internal representation. The spec could change tomorrow and the code would still work. (1==1) will always work regardless if the spec chose 1, 0xDEAD or -390242992752987429389238. You can't answer my question and it appears that nobody here can. Thats fine. I'll hope to one day find it.
The function evaluation is a sequence point. See bullet point 5 of the Wikipedia page you linked.
Ok. Well if VLC will get what I need done I'll look for another project. Thanks for your input :)
The `!`&amp;nbsp;operator returns 1 if its operand is&amp;nbsp;0, and it returns 0 otherwise.
n%3 is n mod 3. And "!" is boolean not. So if n is divisible by 3, your function will return TRUE. If n mod 3 is 1 or 2, your function will return FALSE. I would prefer to write it more plainly, as: if (n%3 == 0) return 1; else return 0; I suspect a decent compiler would turn this into the same code as return!(n%3). 
Instead of "an integer other than 0", in fact you can rely on `!0 == 1`, so `!(n%3)` returns 1 if `n` is multiple of 3 and 0 otherwise. So in brief it's returning "`n` is a multiple of 3".
It essentially reads as "Is n divisible by 3?"
not sure what the context of the question is, but one could rewrite this in one line as: (n % 3) ? return [int other than zero] : return 0; if one so desired EDIT: As pointed out below by spaz, this should actually be: return (n%3) ? [int other than 0] : 0;
Right idea, but it's actually return (n % 3) ? 1 : 0; Or [int other than zero] in place of the 1.
Clarification request: 1.) What are you trying to do exactly? 2.) Does struct Team really need a pointer to its struct Players, or should that just be: stuct Team {char country; struct Players players;}; ~~3.) Why the need for a double ptr to teams?~~ EDIT: I think I see what you're going for with 3.
I'm trying to figure out how to fill the struct inside a function.. And yes you are right struct Player should not have the pointer. Sorry, for my bad English.
Good call there. Typed too fast haha
What you might be going for is a team struct which holds a group, or collection, of players. An array is suitable for holding a collection of items like this. Here is an example program that runs and will print out every member of team one. However, I only defined one player on this team so you will get some garbage output for the other players. #include &lt;stdio.h&gt; #include &lt;string.h&gt; #define NAME_LEN (30) #define COUNTRY_LEN (30) #define NUM_PLAYERS (11) struct Player { char name[NAME_LEN]; int number; }; struct Team { char country[COUNTRY_LEN]; struct Player players[NUM_PLAYERS]; }; void main(void) { int i = 0; struct Team one; strncpy(one.country, "Germany", COUNTRY_LEN); strncpy(one.players[0].name, "Mesut Ozil", NAME_LEN); one.players[0].number = 8; printf("Team %s\n", one.country); for (i = 0; i &lt; NUM_PLAYERS; i++) { printf("%d - %s\n", one.players[i].number, one.players[i].name); } } Here is what was printed out on my machine: Team Germany 8 - Mesut Ozil 0 - 1572764568 - àÂ¯: 32601 - -2138900504 - 0 - 0 - àÂ¯: 32767 - 0 - ÿ÷ 32767 - 4195376 - e@ 
Someone already posted a solution, but I already had written mine so I thought I'd post anyway. If you wanted to do it with dynamically allocated memory, this is a bit ugly but should get you headed in the right direction. Between this and the other posted solution you should be well on your way. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main(void){ struct Player { char *name; }; struct Team { char country; //char here? struct Player *players; //array of player structs }; struct Team *teams = NULL; int numTeams = 2; int numPlayers = 2; //number of players per team //allocate space for teams teams = (struct Team*)malloc(sizeof(struct Team) * numTeams); //allocate space for players on teams teams[0].players = malloc(sizeof(struct Player) * numPlayers); teams[1].players = malloc(sizeof(struct Player) * numPlayers); //allocate space for player names teams[0].players[0].name = (char*)malloc(12); teams[0].players[1].name = (char*)malloc(12); teams[1].players[0].name = (char*)malloc(12); teams[1].players[1].name = (char*)malloc(12); //assign countries teams[0].country = 'a'; teams[1].country = 'b'; //assign player names char temp[12] = "test name"; strcpy(teams[0].players[0].name,temp); strcpy(teams[0].players[1].name,temp); strcpy(teams[1].players[0].name,temp); strcpy(teams[1].players[1].name,temp); printf("Team country: %c\nTeam Players: %s, %s\n",teams[0].country,teams[0].players[0].name,teams[0].players[1].name); printf("Team country: %c\nTeam Players: %s, %s\n",teams[1].country,teams[1].players[0].name,teams[1].players[1].name); return 0; } Output Team country: a Team Players: test name, test name Team country: b Team Players: test name, test name Also be sure to free these when you're done with them! 
Start with the simple and build up. Struct in function: void f( void ) { Team team; team.country = 'x'; } Pointer to Team: void f( Team* team ) { (*team).country = 'x'; team-&gt;country = 'x'; // equivalent } Pointer to pointer to Team: void f( Team** team ) { (**team).country = 'x'; (*team)-&gt;country = 'x'; // equivalent } If your pointer to pointer to Team is really a pointer to the first element of an array of pointers to Team objects: void f( Team** team, int i ) { team [i]-&gt;country = 'x'; } 
 x = a&lt;b ? a : b; is equivalent to if ( a &lt; b ) x = a; else x = b; 
If u/gblargg and u/\_simu_ didn't simplify it enough for you, always read ternary as (condition) ? (val if true) : (val if false) The brackets here are for macro safety and a great example of problems with macros. For eg if you called min(x+y, c+d) and min was defined without brackets it would become x + y &lt; c + d ? x + y : c +d where (do not quote me on this, but it would be similar) the ternary would become d ? x : c 
The ternary operator works like this: logical_expression ? value_if_true : value_if_false If logical_expression evaluates to true, the ternary operator evaluates and returns value_if_true. If, instead, logical_expression evaluates to false, the ternary operator evaluates and returns value_if_false. The test code you've pasted defines two macros. The first one, max, boils down to the following expression: a &lt; b ? a : b So, the ternary operator evaluates (a &lt; b). If it's true then the expression returns (a). Otherwise, it returns (b). The other macro, max, follows the same principle. The remaining expressions correspond to nested evaluations of the ternary operator, which return, respectively, the largest and smallest element of the set. 
&gt; char country; //char here? char has at least 8 bits of storage according to ANSI C, so it's at least 256 values. Considering that the number of countries in existence is &lt; 200, char is an appropriately sized data type for the job. The other option is an enum, which the compiler will likely resolve to being appropriately sized for the platform (in this case, either char or int - ints are often faster to deal with on a number of architectures, so the compiler will often prefer them). You could argue the enum gives you better type safety, but *shrug*, it's C anyways.
I think i understand how Ternary operator work. What I'm confuse is the define variable and how it was use in this case. The line, #define min(a,b) ((a) &lt; (b) ? (a) : (b)) Is min(a,b) a variable? as in, you can just call it minab? also, how is the expression to find the biggest and smallest work, i can't understand the logic. How does this translate in if-else statement. Thanks. 
 // macro #define min(a,b) ((a) &lt; (b) ? (a) : (b)) void f( void ) { int x = 1; int y = 2; int z; z = min( x, y ); z = ((x) &lt; (y) ? (x) : (y)); // macro expands into this z = x &lt; y ? x : y; // eliminate unnecessary parenthesis if ( x &lt; y ) // equivalent z = x; else z = y; // If x is less than y // set z to x // else // set z to y } 
&gt;char has at least 8 bits of storage according to ANSI C, so it's at least 256 values. Considering that the number of countries in existence is &lt; 200, char is an appropriately sized data type for the job. Bookmarking this post for when the 257th country is admitted to the UN, and bombs unexpectedly explode 
The problem is to find the even valued terms. You are finding the terms which are even. You need to add a counter for number of terms and add to sum if that counter is even. 
Try setting setting firstnumber before you set secondnumber. Otherwise you're setting firstnumber and secondnumber both to nextnumber. In other words, flip lines 20 and 21. Edit: you should also initialize your variables for sum and nextnumber. 
that worked! thank you!
I haven't looked at it in detail but right off the bat I see that variable sum isn't initialised. I'm not sure if sum defaults to 0 but I personally always initialise/assign it to be explicit about it. Next oddity is that you're assigning secondnumber to nextnumber and after that you're assigning firstnumber to secondnumber. So this means that after one iteration firstnumber and secondnumber are exactly the same.
the clipboard is a feature of the OS, and a C library could be created.. SDL has clipboard functionality, but you would be adding SDL to your project (rather overkill, IMO).
Since you did mention the OS, I don't know what kinda support C has, but it's pretty easy in [Objective-C](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/PasteboardGuide106/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008099) and [C#](http://msdn.microsoft.com/en-us/library/System.Windows.Forms.Clipboard_methods%28v=vs.110%29.aspx) due to their OS integration
is this a joke?
&gt; printf('&amp;i' f); You missed a comma, it should be printf("&amp;i", f);
lawl
For windows: http://msdn.microsoft.com/en-us/library/windows/desktop/ms649016(v=vs.85).aspx
Which clipboard do you mean? On a typical Unix with X11, there are usually at least two different clipboards available. How do you want your data to be represented? Data in the clipboard usually comes with a mime-type so that things like formatting sequences can be preserved.
Pretty much any full-featured GUI toolkit will give you clipboard access, although it is highly OS/system-software-dependent. GTK, FLTK, or wxWidgets might be things to look at.
If he wants cross platform code, SDL would be a good fit anyway.
I prefer writing code like this, unless you can expect really long strings and have to allocate the memory for them, preallocation makes code so much easier to read and it isn't like we're sitting on only 64k memory to play with. Some wasted memory == easier to write code, not a bad trade off.
Also, notice that at least on X11 (the windowing system Linux and Unix use), there is no buffer in the display server for the clipboard. If you want to put something into one of the clipboards you send a message to the display server that you want to override the clipboard. The display server acknowledges it and might ask you later on about the contents of said clipboard. The sad result is that the content of the clipboard is lost when the application that wrote into it terminates.
Could you upload your code to a pastebin? It's difficult to compile and debug code that comes in image format.
Looks pretty good, but I think I'm missing something: what data is being hidden, and why is it important to hide it?
On Mac OS X accessing the "clipboard" is done using the NSPasteboard class (in AppKit), which would require you to use Objective-C. I'm no aware of a way you can access it in pure C.
Hmm -- I prefer to add a couple of functions to my list implementation to make it a stack instead of writing a complete / single use stack.
That would check if the result of the function, when called with parameter x is unequal to 0. If you want to check the pointer's value, use this syntax: if (fun != 0) { } or even better: if (fun != NULL) { }
If by "check that the function doesn't equal zero" you mean "call the function with the parameter x and check that the value it returns doesn't equal zero", you want: fun(x) != 0 If by "check that the function doesn't equal zero" you mean "check that the function pointer is not NULL", you want: fun != NULL (Functions and function pointers are invoked using the same syntax; i.e., with parentheses and an argument list.)
I'm probably a monster, but I will often just do: if (fun) { } or if (!fun) { } depending on what you're trying to do.
The point of that is that it's not very obvious and a reader might think (and the compiler will warn) that you forgot the braces for the function call.
I think i spotted it; It happens when the input has more then maxrep repetitions (why my testcase didn't had this i don't know, it must have been weekend :) $ hexdump -C in.dat 00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 0000012c $ hexdump -C out.dat 00000000 03 00 00 00 03 00 2b |......+| 00000007 so i think it's related to the compression function and more specific to the &lt;= maxrep. When maxrep is 0xFF this will overflow and using &lt; maxrep fixes it. That's all folks, have a nice weekend and sorry to have bothered ya'll. 
http://xkcd.com/979/
[Image](http://imgs.xkcd.com/comics/wisdom_of_the_ancients.png) **Title:** Wisdom of the Ancients **Title-text:** All long help threads should have a sticky globally-editable post at the top saying 'DEAR PEOPLE FROM THE FUTURE: Here's what we've figured out so far ...' [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=979#Explanation) **Stats:** This comic has been referenced 248 time(s), representing 0.9401% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcdcomic/)/[kerfuffle](http://www.reddit.com/r/self/comments/1xdwba/the_history_of_the_rxkcd_kerfuffle/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_civr80w)
If you want, you can use ungetc instead fputc right under if (next == EOF) break; in compress. You'll then check again for repeats.
Question to experienced C programmers that have been doing this as part of their profession. Do you find canaries/magic values useful?
I encourage you to read the [GNU libavl documentation](http://adtinfo.org/libavl.html/). It is almost structured like a course that answers all the practical questions regarding C, namespaces, dynamic libraries, distribution, etc. It also has quiz/exercises so you truly understand what is being said.
Thanks for the reply. I'm just going to write a c library that makes a call to pbpaste/pbcopy. OS dependent, but there doesn't seem to be any other way.
Check if function is not zero: if(fun != 0){...} Check if function call doesn't return zero: if((*fun)(x) != 0){...}
You don't need to dereference fun before calling it. The C standard has a rule that a function pointer is automatically dereferenced as many times as needed when calling the function behind it.
So think about it like this: Each "Node" object, is just a container storing the actual data that you want to hold. If you have 100 nodes, but no way to access them initially, what is to say that the node that you access is the first one? Each node has exactly the same type of information, there is no bool isHead; Technically you could do it without the struct binary_tree{} or linked_list{} but it just is more organizationally correct. edit: You can use either a pointer or a variable, there is no version that is more or less correct. theseoafs is correct, if you want to store an int, you must use int, but if you want a pointer to an int (idk why you would want that, it is just an additional 4bytes of memory for no reason) then you can use a int*. If you use a int* then you can access the value of the data with a name_of_node-&gt;data , but if you just use an int, it will be a name_of_node.data This is because the C++ compiler combines dereferencing of a pointer as well as a . operation with -&gt;
There is no need for the binary_tree structure. Having an extra structure with only a single member is confusing and can only complicate your implementation unnecessarily. As for whether you should use a pointer or an integer: yes, it absolutely matters. If you want to store integers, use integers, and if you want to store pointers, use a pointer. 
&gt; So, my question is, are there any techniques to get a balanced tree So many. My recommendation would be googling "balanced binary search tree". I just did that and here's the first thing that came up: http://en.wikipedia.org/wiki/Self-balancing_binary_search_tree
1. Yes and 2. Now go and build one, it's doable in not a lot of code.
AVL trees are simpler, Splay trees even more so(IMO). Another interesting structure with O(log n) insertion/search/deletion complexity would be Skip list, it might be even simpler than the above but it's composed of lists and is not a self-balancing tree.
First of all, this is r/c_programming so I wouldn't assume op is using a c++ compiler. That being said, it doesn't really make much difference in this case so that's mostly nitpicking. However, if he uses a pointer to an int, name_of_node-&gt;data will get him the int's address and not its value (assuming name_of_node is a pointer). The -&gt; operator dereferences the left hand argument, not the right right hand arg. In this case he would need to do something like *(name_of_node-&gt;data).
The problem is that you never assign tgt-&gt;head to a sln_node. It looks like you're trying to do that is with this piece of code: `ntgt = n` But this is just assigning the pointer ntgt to point to a different node. What you would need is something more along these lines: `tgt-&gt;head = n` Now this will cause tgt-&gt;head to actually point towards a node. Now this will only work for the first node you find since it would overwrite tgt-&gt;head every time with each node you find. Therefore, I would suggest first checking if tgt-&gt;head is null, if it is add the node using the above code and assign `ntgt = tgt-&gt;head`, otherwise you would want to append the node using `ntgt-&gt;next = n`. Assuming that ntgt points to the last node in the tgt list, the above code will append the node n to the end of the list. Also, this code will only work if tgt-&gt;head starts is null initially, so don't forget to initialize it. 
Ok, so in the average case if I take a list of numbers they're going to be randomly distributed, i.e. *not* sorted. This will give us the expected cases. If I give the BST a sorted list then I get the worst case performance. There are two solutions to this --- either keep the tree balanced (RBT or something similar), or to shuffle the input (which can be done in constant time --- IIRC) before you insert into the BST.
a stack is defined by the semanthic of its operations, push and pop, pop retrieve the last element pushed, if your data structure has this semantic and different names, yes it is a stack.
A stack is a LIFO data structure: last in, first out. The operation of "popping" an element off a stack removes and returns the item that was most recently added ("pushed") to the stack. This is the distinguishing behavior of a stack. Any data structure that supports operations to add an element ("push") and remove and return the most recently added element ("pop") can be used as a stack. In order to be a useful stack, the data structure should be able to do these operations efficiently. An efficient implementation of a stack should be able to perform the push and pop operations in constant time, regardless of the number of elements in the stack.
thanks 
Push and pop are the other way around...but yes. Edit: he fixed it
Ack. I got them the right way around in the first paragraph, and then somehow got them backward in the second. Thanks for the catch.
&gt; I'm wondering because for in order searching it says on wikipedia to traverse the left subtree, the visit the root, then traverse the right subtree. In-order is an *ordering* of the nodes of a tree. It itself is not a search algorithm. And in-order is not the order in which the nodes are first visited by a depth-first search, nor is it the order in which the nodes are last visited by a depth-first search.
The most obvious way would be to not use linked lists; they tend to negate the usefulness of your cache. But that's kind of fundamental to this code... You're making things worse by having multiple arrays rather than a single array of structs. This loop: if (currentMap) do { if (mapId[currentMap] == id) return mapPtr[currentMap]; } while ((currentMap = mapNext[currentMap])); has to go off to main memory (maybe just L3) for each component; your cache won't help at all. Meanwhile, if you had: struct Entry { uid id; var32 ptr; map next; } mapThings[MAP_SIZE]; ... if (currentMap) do { if (mapThings[currentMap].id == id) return mapThings[currentMap].ptr; } while ((currentMap = mapThings[currentMap].next)); Now reading the `id` will also bring `ptr` and `next` into cache, so you only have to go out to main memory once per iteration of this loop rather than twice. Most of these should only cost you on one pass, but you can also get rid of a lot of these elements: If you're going to hash every cons cell, you can directly embed the cons cell into the hash bucket and you don't need `mapPtr` or one of the `NewPtr`s. But then you don't need `mapId` either, since the contents are right there and you can cheaply recalculate it. You don't need the other `NewPtr` separately because none of the other fields are used in unallocated cells so you can reuse one of them to make a free node chain. So you can replace: var32 nodeLeft[NODE_SIZE]; var32 nodeRight[NODE_SIZE]; var32 nodeNewPtr[NODE_SIZE]; uid mapId[MAP_SIZE]; var32 mapPtr[MAP_SIZE]; map mapNext[MAP_SIZE]; map mapNewPtr[MAP_SIZE]; with: struct Node { var32 left; var32 right; var32 next; } nodes[SIZE]; 
indeed, even the the check for eof can be replaced also. I never used ungetc that much so i never think about that. Thanks for the tip!
Thanks, that is usefult, but I'm still confused: depth search in-order it goes like this dfs(node): if(node != null): dfs(node.left) do_work(node) dfs(node.right) Does if(node != null): check/peek at the root node first, visit all the other nodes and then come back to the root node/visit the root node?
I included the nullity check so the recursion can terminate cleanly. It doesn't really look at the node but rather whether the node actually exists. I suppose, you could rewrite it like this to keep the lookup inside the parent: dfs(node): if(node.has_left_child) dfs(node.left) do_work(node) if(node.has_right_child) dfs(node.right) Of course, we now assume that whoever uses the function doesn't supply it with a null pointer. So yeah, technically you could do write it without looking at the node first, as long as you store information about its actual existence in the parent (which is of course always stored explicitly when you work with pointers). The way it is written now doesn't look at *all* other nodes first, but only at the nodes on the leftmost path from there. So, `do_work` would be called on the nodes in this order (excuse my shit drawing skills) when calling `dfs` on the yellow root node: http://imgur.com/SFkaMCv EDIT: I just realized I can't count. 6 should be 5, 7 should be 6 and so on... By the way, even if you put `do_work` at the end, you're still traversing the tree in a depth-first manner. In general, it just means that when you're at a node you put all its successors into a LIFO queue (i.e. a stack). This means that you'll always look at a lower level in the tree before you look at a sibling. That's really all that depth-first means.
Have you done any profiling to figure out what parts are actually slow? It's probably best to figure out what needs improvement vs. guessing. You can use something like gprof to do this, the following page is a pretty good start: https://www.cs.utah.edu/dept/old/texinfo/as/gprof.html Once you determine which parts are slow it may be nice to update your post with the results of your profiling so others can more precisely focus on what to improve.
Since you said you had trouble with gprof I ran it on [your code](http://pastebin.com/gWSAtXiX) for you, compiling it with: $ gcc -g -pg cons.c -o cons Then running it: $ ./cons Which generated the gmon.out file which I then used to produce the [analysis](http://pastebin.com/yLD1wAEc): $ gprof cons gmon.out &gt; analysis.txt More specifically, I ran the [line-by-line analysis](http://pastebin.com/bNrasFH1) with: $gprof -l cons gmon.out &gt; line-analysis.txt Maybe later I will look at it, perhaps someone else can use this data to help you out in the meantime... Goodluck!
There is a trivial way to build a balanced binary search tree (or AVL tree if you are so inclined) if you have the input in sorted order and know the amount of the input. It involves building the binary tree from leaves up. Each even node is a leaf. Odd leaves are the compacted to make the next level which is made from the even nodes. There is a bit of logic required to handle an incomplete leaf row, but not much. It is also interesting to note that one can traverse a BST economically, so there is no disadvantage to saving/loading in sorted order. Add a little Red-Black or AVL logic to keep it balanced and it is really a cheap way to handle data.
What does the "?" do? Sorry for the noobishness.
https://pay.reddit.com/r/C_Programming/ EDIT: downvotes galore!
Not sure if this is the sort of thing you're looking for but I like [comp.lang.c](https://groups.google.com/forum/#!forum/comp.lang.c). 
I'm afraid that's a bit like asking for a most active site for english speakers. You probably need to be more specific.
Because `case` statements only mark *entry* points into the body of a `switch` statement. So, because `x == 0`, the body of the `switch` statement will begin executing at the statement labeled `case 0`, and then normal execution will continue from there. A `case` statement does not mark an *exit* point! The program will not stop executing code just because it reaches another `case` statement—it will keep going. If you want to break out of the body of the `switch` statement, you need to use a `break` statement.
You need to add a break statement to each of the case statements otherwise you will 'fall through' to the following case statement .. which is why you get both strings printed. I'd also recommend getting into the habit of adding a default statement to your switch statements. I'd also like to see you return an int .. something more like this #include &lt;stdio.h&gt; int x=0; int main(void) { switch(x) { case 1: printf( "One\n" ); break; case 0: printf( "Zero\n" ); break; case 2: printf( "Hello World\n" ); break; default: printf("some default string\n"); } return 0; } 
Interesting comment re enums - thanks, I didn't think of it. I must admit I'm probably aiming advice at the level OP is currently at with C .. I think it's good practise (that's just my opinion and reflects how I was taught - not stating it as right or wrong) to drill in breaks and defaults etc first .. then more 'subtle' cases later. Same thing with main. From the C FAQ: &gt; Under C89, the return statement at the end of main() is required, whereas under C99 if no return statement is present, return 0 is implied. However, it is good programming practice to always use a return statement, even if you don't have to.
So if the program executes code at a case statement it will then execute at every case statement that follows if there's no break after it or after any of them?
Thanks!
Where's the most active website to talk about C programming?
Thanks! I've also heard a lot of sucky things about Google so I avoid using Google products as much as possible. Also being a Trisquel user :D 
comp.lang.c is a newsgroup that has existed since the early 90's, if not earlier. Google happens to have a service for viewing newsgroups, but it is otherwise unaffiliated.
Ah cool! What are your thoughts on Stack Overflow? 
I think what OneOfTooMany is trying to say is that you should focus on a specific project that uses C. For example, the Wine project is almost entirely in C and the developers mailing list is pretty good to read. Also LKML, OpenBSD, FreeBSD mailing lists. Also the suckless community mailing list. 
are you aware that is just a link back to reddit?
What are some other methods for viewing and interacting with newsgroups?
Yeah I knew that, why? It seems this is one of the most active places for C programmers, and no you did not fool me ;) 
This is the ternary operator. You can read more about it below: http://en.wikipedia.org/wiki/%3F:#C However, in simplified terms, you have a boolean expression. If the expression evaluates to true, then the entire line will evaluate to the first value, else it will evaluate to the second. So if you have a boolean expression and two values A and B: int myVar = [boolean expression] ? A : B; If boolean expression evaluates as true, the entire line is just: int myVar = A; Likewise if boolean expression is false, then the line becomes: int myVar = B;
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 5. [**C**](https://en.wikipedia.org/wiki/%3F:#C) of article [**%3F:**](https://en.wikipedia.org/wiki/%3F:): [](#sfw) --- &gt; &gt;A traditional if-else construct in [C](https://en.wikipedia.org/wiki/C_(programming_language\)), [Java](https://en.wikipedia.org/wiki/Java_(programming_language\)) and [JavaScript](https://en.wikipedia.org/wiki/JavaScript) is written: &gt;This can be rewritten as the following statement: &gt;As in the if-else construct only one of the expressions 'x' and 'y' are evaluated. This is significant if evaluation of 'x' or 'y' has [side effects](https://en.wikipedia.org/wiki/Side_effect_(computer_science\)). The behaviour is undefined if an attempt is made to use the result of the conditional operator as an [Lvalue](https://en.wikipedia.org/wiki/Expression_(computer_science\)). &gt; --- ^Interesting: [^MIME](https://en.wikipedia.org/wiki/MIME) ^| [^E-flat ^major](https://en.wikipedia.org/wiki/E-flat_major) ^| [^No. ^3 ^Squadron ^RAF](https://en.wikipedia.org/wiki/No._3_Squadron_RAF) ^| [^LMS ^Fowler ^Class ^3F](https://en.wikipedia.org/wiki/LMS_Fowler_Class_3F) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ciz3hk2) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ciz3hk2)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I might be wrong but I think you need something like a usenet newsreader. Thunderbird can do that too. [Here](http://en.wikipedia.org/wiki/List_of_Usenet_newsreaders#Free.2Fopen_source_software) is a list of open source newsreaders.
I'm a little surprised someone with your posting history would ask that, but fair enough, it's a pretty antiquated technology. Newsgroups have been in continual usage for longer than most other services on the internet. The comp.* groups were first started in 1987, and Google's Usenet archives go back to 1981. To access newsgroups, you'll need a newsreader, and a newsgroup account. Google Groups allows you to read and post to newsgroups with your Google account, but for more advanced features you'll need a dedicated client and a paid newsgroup subscription. There are a number of companies you can get a subscription from, among them are GigaNews, Astraweb, UseNext, etc. My preferred newsreader is GrabIt, which is more oriented around downloading files, but you can also use Mozilla Thunderbird or Outlook. Downloading large files from Usenet is an exercise left to the reader.
You need to understand the concept of an input stream and how the standard I/O functions read characters from the input stream. &gt; c = getchar(); That line grabs only the next character from the input stream. If you type the character&amp;nbsp;`1` and then press Enter, you are adding two characters to the input stream: the character&amp;nbsp;`'1'` and the newline character&amp;nbsp;`'\n'`. The call to `getchar` will read the character&amp;nbsp;`'1'`, but the character&amp;nbsp;`'\n'` will still be in the input stream, waiting to be read later. Likewise: &gt; scanf("%s", &amp;string); This call to `scanf` will skip leading whitespace in the input stream, then read a token of non-whitespace characters, and stop just before reading a whitespace character. So if you type, say, `hello` and press Enter, you are adding the characters `'h'`,&amp;nbsp;`'e'`, `'l'`, `'l', `'o',&amp;nbsp;`'\n'` to the input stream. The `scanf` call will read the characters `'h'`,&amp;nbsp;`'e'`, `'l'`, `'l'`,&amp;nbsp;`'o'`, but the `'\n'`&amp;nbsp;character will remain in the stream to be read later. This character is what will be read by the following call to `getchar()`.
ctrl + c
I emailed Sam Harbison about a C11 update for 'C A Reference Manual'. Basically he told me that the publisher doesn't think it can sell enough copies. He suggested writing the publisher. Been tossing the idea of a Kickstarter campaign... BTW, I prefer Harbison &amp; Steele's book to K&amp;R as well edited: added BTW...
I personally find the list a bit Linux heavy, but some of the references I've found useful are: * C A Reference Manual, Harbison &amp; Steele (mentioned once already) * Programming Pearls, Jon Bentley * The Practice of Programming, Kernighan &amp; Pike * Secure Coding in C and C++, Robert Seacord * http://en.cppreference.com * Safer C, Les Hatton Something Eric Raymond mentioned in an article some time ago; learn a different language. He suggested Lisp for a mind bending exercise, and I have to agree with him edit: formatting
BTW, your code can legally print nothing, since you don't print a newline after everything.
Thanks. I didn't write this code. It came up as a part of an exercise on a site I'm learning from. I just wanted to make sure my understanding of the switch case was correct.
So is it normal to just make another call to getchar to clear the buffer? Or is there a more elegant solution? 
What you probably want to do is to skip leading whitespace in the buffer and read the next single non-whitespace character, right? scanf(" %c", &amp;c); Note the space in the `scanf` specifier string. A whitespace character in the specifier string instructs `scanf` to read and discard whitespace characters in the input stream until the next character in the stream is a non-whitespace character.
I thought scanf() ignores leading white-space by default? At least I'm pretty sure that's how it's defined in the standard. 
Use the arrays, Luke. 
I cant. Arrays are taught in chapter 7.
Also cant.
Alright, so scan as a string, then iterate over each character, subtracting the character '0' from it (or 0x30 hex) and use the resulting value (let's call this "v") for your "switch" indexing. If v &lt; 0 or v &gt; 9, it's an invalid value. You might wish to iterate the entire string to make sure you have no non-numeric characters first, and print "invalid". Once you've done that, you can iterate the string a second time and print all the values. 
Not for the `%c` and `[]` specifiers.
Kochan havent taught that yet either :/ What is wrong with my code anyway? Why it doesnt work as intended? 
&gt; Kochan havent taught that yet either :/ Taught what? There's nothing I'm doing that isn't available in the list you've got in the post. 
It just did with C11 when they added atomics, threading, and generics. The basic idea is that if it's not terribly difficult to implement it doesn't belong in the standard library, I think.
What i tought ( and wanted to) would happen: Lets say i type 547, the program will % by 10 that value type the last digit and then % again until it is not possible. By entering another variable (left_digit) i wanted the program FIRST to reverse the whole number and store it in the variable right_digit, then take the number stored in the right_digit variable ( in this example it would be 745) % by 10 and THEN do what i wanted it to do.
I'm just explaining why what you wrote does not work. The code you wrote does not correspond to what you've explained here -- there is no reversing happening anywhere in this code. As the other person mentioned, it would be much easier to work with the value as a string than as an integer. In string form you already have it broken out into digits, and you can iterate over those digits forward or backward trivially just by writing a simple loop that either increments or decrements an index. If you want to reverse the digits while working with actual integers, you will need to write a separate loop that first does the reversing a digit at a time before you can enter the loop that is going to print the English word for each digit. 
Just for the sake of information Kochan gave an algorithms in chapter 5 that reverts the digits of a number. The algorithms is: do { right_digit = number % 10; printf ("%i", right_digit); number = number / 10; } while ( number != 0 ); I tought about using the same algorithms to reverse the number, storing it and then displaying the digits of the reverse number.
&gt; the compiler keep saying the program has an error I can't do anything with that. You need to show us the code that generated the error, and what the error was. We can't guess at what you might have done wrong. Also, it's possible to solve this without ever reversing anything and without using strings. It's possible to get the digits of an integer from largest to smallest (right to left) by using modulus and division, you just have to know how many digits the number starts out with, and that can be determined with a simple loop. 
This is what i wrote previously: //chapter 6 ex 6 #include &lt;stdio.h&gt; int main (void){ int value, right_digit, left_digit; right_digit=0; left_digit=0; printf("Type a value\n"); scanf("%i", &amp;value); do {right_digit = value % 10; value=value/10; do {left_digit=right_digit %10; switch (left_digit){ case 0: printf("Zero"); break; case 1: printf("One"); break; case 3: printf("Three"); break; case 4: printf("Four"); break; case 5: printf("Five"); break; case 6: printf("Six"); break; case 7: printf("Seven"); break; case 8: printf("Eight"); break; case 9: printf("Nine"); break; default: printf("Not supported"); break; } right_digit = right_digit / 10; } while ( value != 0 ); return 0; } }
It already did. Into C++.
Your formatting is atrocious. Proper care must be taken to always indent code properly. Here is your code formatted sanely: #include &lt;stdio.h&gt; int main (void) { int value, right_digit = 0, left_digit = 0; printf("Type a value\n"); scanf("%i", &amp;value); do { right_digit = value % 10; value = value / 10; do { left_digit = right_digit % 10; switch (left_digit) { case 0: printf("Zero"); break; case 1: printf("One"); break; case 3: printf("Three"); break; case 4: printf("Four"); break; case 5: printf("Five"); break; case 6: printf("Six"); break; case 7: printf("Seven"); break; case 8: printf("Eight"); break; case 9: printf("Nine"); break; default: printf("Not supported"); break; } right_digit = right_digit / 10; } while ( value != 0 ); return 0; } } Is it not much more clear now what the problem is? Your outer `do` has no `while` clause. And you're returning in the middle of the inner loop, which makes the outer loop completely pointless. Even if you fixed those, this would still not work, because you're doing the same thing that I explained earlier: right_digit = value % 10; ... left_digit = right_digit % 10; `left_digit` and `right_digit` will *always* be the same value. You nested one loop inside of the other loop, which is not what you want at all. You need to finish reversing the digits before you can begin printing anything. As it stands now, you're trying to print something in the middle of the loop that reverses the digits. 
Thanks for reformatting. I am having trouble with keeping my codes tidy. But exactly how do i finish reversing before i print the display? I am completely lost.
I didn't realize threading was added in C11 too. Although it looks like pretty much no one implements it yet.
I'm aware of C99 and C11. Although if there's a C1y being worked on, I'm not aware of that.
There is lots I'd love to remove from libc though, starting with wchar.h
C++ is not a super set of C. It is also not backwards compatible with C. But yes, C and C++ are very different languages.
C11 new standard does show that C needs updating to ensure the safety of civilization http://www.drdobbs.com/cpp/the-new-c-standard-explored/232901670.
For something along those lines, you should check out gnulib. They provide a lot of data structures and 'canned' portability solutions, and they integrate beautifully* with autotools. *Except for being the only part of my build that uses recursive make.
At least gets is gone now in C11. Its a start.
Thanks for the reply. For the warnings; I'm working in CodeBlocks with the warnings enabled, I just ran the program again and it didnt return any, not sure why. So if I want to have any array that consists of positive and negative ints and floats, do I need to change the array type? From your comments it seems like I'm waaaaay off track here. The idea for the fscanf loop being: read a number from the file, write that number to the 0 value in the array, increment the array number, read the next number in the file, assign it to 1 value in the array...and so on until I have filled 75 spot in the array with 75 unique numbers. I'm not sure which functions to use because the file contains ints and floats of random length. Do I need to somehow detect the white space instead? Can I accomplish that using the for loop example I provided? EDIT: I changed the array type to double, the fscanf and printf to %lf, and it is able to pick up the first number in the file(and no errors/warnings). Ill let you know if I'm able to completely populate the array. EDIT2: Fuck ya, got it to populate.
It's not gone, it's just optional.
The C standard describes a language that can be implemented on as many platforms as possible. C intentionally does not provide an enriched API because that would make porting C to other platforms harder. It's easy enough to write your own code for these things. Now there is indeed a second standard that cares about expanded functionality, POSIX. POSIX, the portable operating system standard, specifies extended operating system functionality so you can hopefully do stuff in a portable manner across all operating systems. The goal of neither POSIX nor C is to provide a large language though, you're supposed to use your own libraries for that. A larger standard (and both C and POSIX are all about having an identically behaving platform everywhere) is much more difficult to implement than a standard that only contains necessary stuff.
Being very new and unexperienced in C, I have a question for you: what does the first line in your code do? #define _POSIX_C_SOURCE 200112L 
Right now it does nothing usefull. I just forgott to remove it. I needed it for the function [nanosleep](http://linux.die.net/man/2/nanosleep). nanosleep requires at least _POSIX_C_SOURCE &gt;= 199309L It is needed for the [feature test macros](http://linux.die.net/man/7/feature_test_macros).
Nope. Annex K is the bounds checking interface. Wide characters are in section 7.29. And now that I've looked again, wide characters are still mandantory. Where did you get the information that wide characters are optional in C11?
I didn't review it deeply, but first thing I noticed is that you are using `/dev/urandom` to get random numbers. I don't know if there is a special reason for that, but I recommend you to use [`rand()`](http://www.cplusplus.com/reference/cstdlib/rand/). Good work!
C was designed for low-memory and low-powered devices. Expand it in 2014 would simply be pointless, when there are powerful languages as C# or Python. The point of C is a sort of "KISS": keep it simple, stupid (and minimal). Thanks to this peculiarity, developers chosed C and expanded it with their own libraries. In 1999 the language was updated with a lot of stuff. Despite this, ANSI C is still more used than C'99 :)
Ah yes, gets has been completely removed from C11.
http://i.imgur.com/axJmn.gif
I think the sentiment is that C is supposed to be simple, and the value of simplicity is often underestimated. What are some of the things you feel would be worth adding to the standard library?
*/dev/urandom* was just the first coming to my mind. But I guess rand() is better since it does not limit me to Unix-like systems. Thank you for your time :)
That is true, by any language that is lower level, that is only ASM. Really every other language is higher level than C. Fortran is arguable to be equal. Saying ASM is obsolete is not terribly true since it is still used in rare cases. Large systems still rely on it, such as the GDT in an OS's kernel.
What do you have against wchars?
[Wikipedia](http://en.wikipedia.org/wiki/C89_(C_version)#C99) says "In March 2000, ANSI adopted the ISO/IEC 9899:1999 standard. This standard is commonly referred to as C99.". But perhaps you mean C89.
"autotools" and "beautiful" should not be used in the same sentence.
Actually, balanced binary trees are [part of POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/functions/tdelete.html) so your argument is not that valid. The point is not that it's hard to port these things to other platforms, the point is that every vendor of a C implementation has to implement all these APIs to be conforming. The more APIs you have to implement, the harder it is to implement C on a platform. Especially since C is the lowest common denominator for computers (virtually every platform has a C compiler), it must not be too hard to implement C – making the API more complex will just make it harder for other people to implement the standard which is hard enough already. And since many implementations of common data structures exist, you can just use any of the existing implementations in your own program which can then be ported easily to every platform that supports C.
Those libraries exist since C is fast. It is true that not all programs require only basic C. What I meant was, people use C not for everything, although it can do everything, which is amazing for a relativly small language. C is used in specific places where it makes sense, and often, those places do not require any additional libraries from what there are now, that is why they are not expanding.
Neat, I didn't know POSIX had a binary tree. Still, POSIX isn't the same as the standard library. C11 and C++11 both added threads, despite pthreads already existing. 
Yep, both '89 and '99 are "ANSI", but usually C '89 is called "ANSI C", while C99 is "C '99" :)
UPDATE: I was able to populate the array and fixed some of the other slop in my code. My problem now is how can I do work on the array in a function, and return that work to main. In other words, I would like have a function which populates the array, sorts the array, and then returns it to main; from there I would like to be able to send the sorted array to other functions. I'm not sure how I would be able to do this, can I make a pointer to the array and do work through the pointer? EDIT: As far as sorting goes I figured it out and feel like an idiot. I just did a bubble sort in a function, then sent the array to a printing function and it printed out in ascending order. No pointers needed. EDIT 2: What the hell, just noticed that there is an extra zero in my array. Not sure where it is coming from. I am keeping a count of the values scanned into the array. There are 25 values in the file and counter says 26, I think it has something to do with the bools I am using in the for loops. Updated Code: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define FLUSH while(fgetc(fp) != '\n') FILE* getFile(char fileName[]); void bubbleSort(double numArray[], int counter); void printArray(double numArray[], int counter); double sumArray(double numArray[]); int main(){ FILE* fp; //pointer to the file input by user char fileName[256]; //array used to store the filename double numArray[75];//array to be filled with scanned numbers int rc;//for error checking scanf/fscanf int counter;//keeps a count of elements in the array int sum;//calls function sum array which returns the sum. fp = getFile(fileName);//runs function getFile, which opens file and assigns it to fp counter = 0; for(int i = 0; i &lt; 75; i++){//Scans the File and populates numArray rc = fscanf(fp, "%lf", &amp;numArray[i]);//read a number from the file, assign it to array counter++; //printf("%f\n", numArray[i]);//print the number assigned to array value "i" if(rc == EOF)break;//break at the end of the file else if(rc != 1){//if the scan hits a value other than a %lf FLUSH;//go to the end of the line in the file printf("Error in the input, discarding rest of line.\n");//print that a bad value was scanned. }//else if }//For loop //printf("\n%d\n", counter);//prints number of elements in the array bubbleSort(numArray, counter);//Sorts the array printArray(numArray, counter);//Prints the sorted array sum = sumArray(numArray); fclose(fp);//close the file at the end of the program } FILE* getFile(char fileName[]){ FILE* fp; int rc, rc2; printf("\nEnter file name: "); //prompt user to input a file name rc = scanf("%s", fileName); //scan the file name if(rc != 1){ //if user inputs EOF or no file name. printf("\nError: No file name entered.\n"); exit(0); } fp = fopen(fileName, "r"); //attempt to open the file if(fp == NULL){ //if file fails to open printf("\nError: Could not open file %s for read.\n", fileName); exit(0); } /*rc2 = fscanf(fp, "%lf", test); //attempt to scan a value from the file if(rc2 != 1){//if there are no numbers in the file printf("\nThere were no numbers found in file %s\n", fileName); exit(0); }*/ return(fp); } void bubbleSort(double numArray[], int counter){ int temp; for(int c = 0; c &lt; counter; c++){ for(int walker = counter; walker &gt; c; walker--) if(numArray[walker] &lt; numArray[walker - 1]){ temp = numArray[walker]; numArray[walker] = numArray[walker - 1]; numArray[walker - 1] = temp; }//If statement }//For c return; }//bubbleSort void printArray(double numArray[],int counter){ int i; for (i=0; i&lt;counter; i++){ printf("\n%f\n", numArray[i]); } } EDIT 3: Changed counter to (counter - 1) in the functions and it now prints the 25 items I want. Boom. Hopefully this is the correct way of fixing the problem.
We should remove (some of?) the string handling functions then, they're way too easy to implement.
You increment the counter _before_ you check for EOF and bail. 
I mean from about 89 on. Those are only in the language because they were in k&amp;r C.
Well, if you don't use locales in your program, ctype.h becomes a neat API to classify ASCII characters. And even if you do, you are not bound to the locale the user wants. Every program can use its own locale. Neverthless, I agree with you that the wchar interface is horrendously broken. Now if they had implemented an API like Go's... (which has a rune type that is not entirely unlike wchar_t but the API is much more sensible).
The problem is that C11 threads differ from the more established POSIX threads in some minor points which makes implementing them slightly harder than just wrapping pthread functions. Some people say this was a deliberate design decision by Microsoft (co-author of the C11 threads) to sabotage the standard.
Actually they aren't. While a naïve implementation of strcpy() is something anybody can write, it's impossible to write a strcpy() that performs well on every platform. Moving large blocks of data is something that requires knowledge of the target platform to be efficient, which is why such a function has to be part of the C language.
Full acknowledge.
Can't it be done in terms of memcpy? Also, I was thinking more about functions like strcmp, though I guess that may be implemented more efficiently on some platforms too...
The problem is that you not only want to have extra APIs, you also want them to interact with one-another which complicates the implementation even when you don't use the extra APIs. For instance, consider the hypothetical case that C would provide a low-level API for IO that is like the one provided by POSIX (i.e. read(), write(), open(), etc.). If you have a FILE\*, you want to be able to extract a file descriptor using fileno() to operate on the FILE\* with low-level functions. This is no problem on a platform that actually uses integers to identify files but a total catastrophe for platforms that don't do so, like IBM mainframes or micro-controllers. For instance, imagine a micro-controller that provides two UARTs and an SPI bus. A C implementation for that micro-controller could provide access to these peripherals using the FILE\*-API, which is perfectly suited for that sort of thing. The implementation could even implement an fopen() that returns a FILE\* for the UARTs for file names "uart0" and "uart1" and one for the SPI for file name "spi". Neverthless, it would be highly complicated and useless to provide a read() and write()-based API because the available devices neither have file numbers assigned to them, nor is it possible to provide a meaningful close() or detection of invalid file numbers. What I try to say is the the applications of C are so vast, that it is really hard to design an API that is both useful and that does not restrict the fields of application for the C language too much. If an API is useful but it can only be implemented sensibly on a certain kind of implementations, it might be more purposeful to standardize the API in a different standard for that kind of implementation (like POSIX).
Annex K (the bounds checking interface) has a very poor design that makes it impossible to use this interface in libraries, since it depends on a global constraint-violation handler. The comitee should have added BSD functions like strlcpy and strtonum. Have you actually read what the functions of the "Bounds checking interface" do? None of them provides anything that makes error handling easier. It's just protection against forgotten error checks. Funny how they think they can make people think about error checking by adding a set of *optional, error checking functions* that you have to *use explicitly* to get error checking.
I believe anonymous structures are part of the C11 standard, and most compilers have had them as extensions for years. Anonymous functions would be a huge addition to the C standard, considering how much attention functional programming is getting nowadays. Clang's block extensions (similar to gcc's nested functions) provide full anonymous function and closure support, and would be a good model for a standardized version. That being said, the C standard is designed so that it can be used to program anything from a toaster to a Mars rover. As such, keeping features as minimalistic and portable as possible is a must for the standards committee. The key is using library and compiler extensions to create an environment that suits your needs.
The nested function is a gcc extension. clang doesn't support it. See [here](http://clang.llvm.org/docs/UsersManual.html) &gt; clang does not support nested functions; this is a complex feature which is infrequently used, so it is unlikely to be implemented anytime soon. 
i think if you want this c++ would be a better choice, that hasn't been compatible with itself since it's inception so another thing which no other compiler supports(templates in the earlier days, the stl) or incompatible(a simple compiled library) wouldn't be an issue. In fact, i believe it's in c++11.
Thanks for the explanation. Although I feel we went on a bit of a tangent here, as I was originally just making fun of Ubertekk's basic idea (even though now I have an additional reason to do so), I didn't know how sensitive some architectures are to boundaries. I'm still not sure how memcpy is inadequate for the job though, doesn't it have to respect page-boundaries too?
memcpy() doesn't have to figure out where the string ends which is the main thing that makes a strcpy() so complicated.
That's simply not true. Folks like the OpenBSD project did actually try to improve the security and versatility of C. For instance, they developed the functions [strlcpy and strlcat](http://www.openbsd.org/cgi-bin/man.cgi?query=strlcpy&amp;sec=3&amp;arch=amd64&amp;manpath=OpenBSD-current) that allow you to safely copy strings without having to worry about missing NUL termination. The also developed the [strtonum](http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man3/strtonum.3?&amp;manpath=OpenBSD-current&amp;sec=3&amp;arch=amd64&amp;query=strtonum) function that eliminates a lot of the boilerplate you usually have when converting strings to numbers (i.e., setting up variables, running strtoul, checking pointers, checking against the range you want). Why weren't these pulled into the standard? Mainly because Ulrich Drepper didn't like the idea of having safe functions and thus refused to put them into the glibc. He invented [asprintf](http://www.openbsd.org/cgi-bin/man.cgi?query=asprintf&amp;apropos=0&amp;sec=3&amp;arch=amd64&amp;manpath=OpenBSD-current) though and that's a good thing. (while not part of C11, asprintf() is part of POSIX.1 2008) Finally, some things are extremely hard in C as it stands right now. For instance, there is no easy way to figure out if the product of two intmax_t values overflows. A common mistake that can cause large security holes is code like this: size_t count; struct problem *problems; count = get_problemsize(); /* read user input */ problems = malloc(count * sizeof(*problems)); if (problems == NULL) { perror("Try a smaller problem"); fail(); } /* insert business logic here */ See where the problem is? the multiplication in the malloc()-call can overflow resulting in a small value that causes malloc() to succeed. The program thinks everything is fine, but in reality it just starts to randomly crap all over your memory. Now if the user can control "crapping all over the memory", this is a perfectly exploitable security hole. Luckily, the OpenBSD guys developed a function reallocarray() that does this multiplication for you and fails if it overflows. Guess what useful function didn't make it into the standard. 
I agree that c++11 is much better suited for this kind of stuff. Personally, I'm using these nonstandard exstensions more for rapid prototyping than for production code. I plan on porting the final product to standard C or C++. I would say the more esoteric clang extensions could find use in iPhone or Mac development, where they are more a part of the ecosystem. 
I think C's strength is offering good low level CPU abstraction. That's why C didn't change much in the last years because basic CPU architecture hasn't changed very much. The new thing is SMP and C clearly lacks features there. Another feature that has become common on most CPU are SIMD instructions. Right now I have to use intrinsics or assembler that are specific to SSE, Altivec or Neon and compilers have different names for them. Yea, portable SMID in the C std would be very nice. 
I agree that ChoHag's quote wasn't well chosen, and didn't apply to the situation as well as some other quotes, like these for example: "Measuring programming progress by lines of code is like measuring aircraft building progress by weight." -- Bill Gates "One of my most productive days was throwing away 1000 lines of code." -- Ken Thompson It's also true that using pithy quotes in place of well reasoned arguments detracts from discussion, but they also take less time to read. ChoHag's quote rejected what seemed to be a misguided assumption by OP, namely the idea that software should be constantly expanding and if it doesn't something must be amiss.
You can do the same thing with regular function pointers. So I don't see what using blocks is gaining you here. (But I'm not an expert on blocks, so perhaps it could be used to gain you something. Could you capture the "this" pointer so that you don't have to pass it in explicitly?) Take a look at [gobject](https://developer.gnome.org/gobject/stable/chapter-gobject.html) for an example of a nontrivial C object system without blocks.
why not just use structs and functions in the first place i wonder, it seems to me quite a bit of work for prototyping and reverting to it eventually. I assume you don't want to build vtables and function pointers in c, that's just not worth it imho.
i'm interested in simd as well but isn't that the job of the compiler to handle? Also, for multiprocessing c has openmp bindings on the platforms where it helps?
One related thing that stands out to me is that you're opening /dev/urandom in one function and closing it in another. It's good discipline to handle opening and closing in the same scope or level of the program so that you don't accidentally forget to clean up when you refactor. 
If you want to perform a web request you'd have to implement the HTTP protocol, or at least the client side of it. The examples on the page you linked are just very basic socket examples, they don't implement any kind of protocol, which would involve a lot more work. For very simple requests it wouldn't be very hard to write a HTTP client by hand, but for anything serious you should forget about that and just use an existing library like [libcurl](http://curl.haxx.se/libcurl/). 
Why is the time to read such a desirable thing, when the content fails at what it's set out to do in the first place: explaining things. Are we here on reddit to discuss or just to shut each other up? Also, I still stand by what I said, quotes have no place in a discussion, they preach to the choir and the rest are left in the dark. For example, Gates' quote is a mere attempt to ridicule the opposition while failing to address the why's, and Thompson's is just an anecdote that still fails to address the why's. Would you expect someone with no programming experience to infer from these two lines that more code is more places for errors to hide, or the reasons why Thompson deemed those 1000 lines unnecessary, but not other lines? Does Gates mean to say that more code makes programs slower, with no exceptions? (here's one: memoization) Am I supposed to be scared if my solution to a problem has an extra line or two? You can't tell what someone on the receiving end is really thinking when they get one of these as an answer, and it makes it (for them) all the more difficult to find the right way to proceed with a reply. And oh yeah, these don't apply to C's library either, in case you were suggesting that, the reason it's small is not out of concern for the library implementers, it's because portability and performance have to always be kept in mind when adding stuff.
Anonymous structures are different then what I am suggesting. I am suggesting nameless structures. Basically... struct s0 { int a; }; struct s1 { struct s0; int b; }; int main(int argc, char *argv[]) { struct s1 test; test.a = 10; /* accessing field of nested struct */ test.b = 5; /* accessing field of parent struct */ return 0; }
It is/could be, but compilers are not as of yet capable to do a fantastic job with it, so people do vectorize their code manually with intrinsics. Something like clangs vector extensions would be nice in the C standard, IMO.
&gt;Would you expect someone with no programming experience to infer from these two lines that more code is more places for errors to hide, or the reasons why Thompson deemed those 1000 lines unnecessary, but not other lines? If the reader *can* infer the reasons behind the quote, then it can be more effective than a lengthy description because the reader didn't waste time reading things they already knew. In the case of /r/C_Programming, we can assume some programming experience. In the specific case of the original "perfection in engineering" quote, I would tend to agree with you that its potential for confusion outweighs the contribution to the discussion. It's a horrible thing when unexperienced readers come upon quotes that leave them with not even enough information to formulate a follow up question. &gt;And oh yeah, these don't apply to C's library either, in case you were suggesting that, the reason it's small is not out of concern for the library implementers, it's because portability and performance have to always be kept in mind when adding stuff. What do you mean? What makes you think Ken and Bill's reasons for reducing source code are for the sake of implementors only?
&gt;What makes you think Ken and Bill's reasons for reducing source code are for the sake of implementors only? Never meant that, I meant they don't apply to OP's question with regards to why the C library is not expanding. The only lines of code that would be saved by keeping it small are the LOC that the library implementors won't have to write, which is a moot point – it's up to whoever implements the standard library to follow coding best practices, not up to the specification.
Ah yes, I didn't realize we were talking about a specification. That's a good point.
http://www.reddit.com/r/C_Programming/comments/2b5z79/c_programming_notes/
Take this with a grain of salt -- it was published in 1994. There's a fair amount of stuff about SunOS and MS-DOS, for instance. And naturally there's nothing about all the changes in C99. And this is probably a copyright infringement anyway. 
in what way does it not perform as expected? is the problem that print_list only prints one element? instead of the whole list? void print_list (struct node *actual) { printf("the list:\n"); while (actual != NULL &amp;&amp; actual-&gt;prochaine != NULL){ printf("\n%d\n", actual-&gt;key); actual=actual-&gt;prochaine; } } 
You don't assign to *premier in ajouter_node(). When you set actual to nouveau, you don't initialize prochaine yet access it in the loop after. Your insertion code has lots of special cases that complicate understanding. Here's an (untested) approach that avoids special cases by iterating using the pointer *to pointer* to current element: void ajouter_node (int numero, struct node **premier){ while ( *premier != NULL ) premier = &amp;((*premier)-&gt;prochaine); *premier = (struct node *) malloc(sizeof(struct node)); (*premier)-&gt;key = numero; (*premier)-&gt;prochaine = NULL; } Also, probably simpler/more general to let the caller initialize the element: struct node* ajouter_node (struct node **premier){ while ( *premier != NULL ) premier = &amp;((*premier)-&gt;prochaine); *premier = (struct node *) malloc(sizeof(struct node)); (*premier)-&gt;prochaine = NULL; return *premier; } ajouter_node(&amp;first)-&gt;key = 5; 
there are some really helpful tools for starting programming in c. one is **gdb**. you might not need it in the very beginning but there will come a point when having it in your bag will save you hours or days. **valgrind** is another. it will point out memory errors which will include some cases that produce undefined behavior which will make you sad especially if you run your code on your machine and the graders (i presume this is for a class) use a different machine. finally get the compiler to do as much work for you as possible. if you are using gcc add the flags: **-W -Wall -Wextra -Werror -g -ggdb** (if you are using clang you'll have to look up the equivalents but i know by default clang gives more error messages than gcc).
You make a fair point. I suppose my desire is to generate functions for use by function pointers without filling the global scope. Which is possible with named static functions inside source files. IF possible just having unnamed static functions would be nice, but would require a syntax change as well, where as nested functions don't require a major syntax change (for the programmer anyway).
&gt; The way it looks to me, is that i is the only number that changes. The variable `p` changes, too. It's assigned a new value during each iteration and keeps this value until the next iteration.
There are two i variables here. The i in main when passed to power is the exponent. The i in the power function is used to increment from 1 to the exponent (n). This isn't exactly true, but when you enter the power function the i variable will always be 1. As the for loop iterates it will increase by 1 until it's equal to n.
The problem I have with this (it's a sample problem from a book about C ) is that it doesn't ever say that the power function loop keeps anything. It just seems to return p. I was thinking it didn't make sense because p couldn't change. I mean look at the power function. If I was going to run this by itself and get my numbers from standard input (keyboard), it wouldn't do anything. I could put -3 in and I would just get -3 out. 9 in 9 out. Now realizing that p is going to hold it's value between iterations, it just makes sense. I just wish that the book was more explicit in that detail. 
Figure out when unix time will end
Actually I'd say avoiding `rand()` is generally a good practice. In C++ I always recommend `&lt;random&gt;` instead. In C there's probably a decent RNG library somewhere too. If you don't use a library and instead write your own (such as you've sort of done here) there are some things I would recommend. - Make it easy to change the source of randomness between something like /dev/urandom and a deterministic RNG. For testing you do want to be able to get repeatable results. - Factor the RNG functionality out: - Have a struct that holds any necessary data (such as a FILE*) - have an initialization routine, have a de-initialization routine, and pair them like any resource allocation/deallocation functions.* - For small programs and limited reusability you can write functions that directly access the source of randomness to produce random numbers, but for more serious use you want to separate the function for getting random bits from functions that take any source of randomness and produce random values. \* I notice that the program does not try to keep its allocation/deallocation pairings symmetrical. E.g. you open /dev/urandom in initGame(), but simply close it at the end of mainLoop(). If you have an initGame() function that allocates resources then you should have a deinitGame() function called in the same scope that deallocates those resources. initGame() should call a createRNG() function which opens /dev/urandom and dinitGame() should call a destroyRNG() which closes it. struct RNG { FILE *file; }; void createRNG(struct RNG *rng) { rng-&gt;file = fopen("/dev/urandom"); } void destroyRNG(struct RNG *rng) { fclose(rng-&gt;file); } int randomInt(struct RNG *rng, int min, int max); struct globalGameState { struct RNG rng; int speed; int foodChar; }; void initGame(struct globalGameState *state) { createRNG(&amp;state-&gt;rng); state-&gt;speed = 40; state-&gt;foodChar = '!'; } void deinitGame(struct globalGameState *state) { destroyRNG(state-&gt;rng); } int main() { globalGameState state; initGame(&amp;state); mainLoop(&amp;state); deinitGame(&amp;state); return 0; }
Ok. This is exactly what I came here to find out. How does p become larger? If p is 1 and nothing at all tells p to become larger then how does that work? Does p return to the top of the for loop in power()? Also, please try and leave out the negativity. I realize something is wrong with my understanding. That is why I asked the question. 
scratch your own itch...or maybe start doing [Euler](https://projecteuler.net/) problems
Write a program that takes as input the source of another program (in a language of your choice) and reports whether that program halts or runs forever. 
I like your style ! This should get him busy enough :)
He'll surely do some tests (unit testing maybe?) of his program. And I'm hoping his tests will cover...all the cases ! 
thanks
Agreed on negativity (and it was due to Rhomboid not understanding that your "If I was going to run this by itself and get my numbers from standard input (keyboard), it wouldn't do anything." was referring to *your* understanding, not reality. Obviously your understanding differs from reality, and that's why you are giving us a window into it so we can guide you from it to reality. I wonder whether you get this yet: i in power() is a different variable than the i in main(). Also, each call to power() gets fresh local variables. Once power() returns, all its local (automatic) variables are destroyed. Not that this is critical to understand in this case since are all initialized before use, and thus even if they did retain their values between calls, the old value would be overwritten with the new one the next time it was called.
Here has some challenges http://www.reddit.com/r/dailyprogrammer/
See /r/dailyprogrammer for tri-weekly programming challenges with a range of difficulties.
When you're done you could just run your program on its own source. Cool!
Looks like some of your fread/fwrites are going off the end of your buffers, clobbering whatever is past the array bounds. E.g., the prototype for fread() is: size_t fread ( void * ptr, size_t size, size_t count, FILE * stream ); where size is the size of each individual element, and count is the number of such elements. Also, filesize is in bytes, but sizeof(int) is probably 4 bytes, not 1. So you have to watch your math when allocating your buffers.
Write a Chess engine that properly implements all the rules of chess (including castling, en passant capture, and the 50-move draw rule), board representation, and endgame status. Optionally, write an AI that can beat you.
i posted this in another thread recently but it's worth mentioning here: there are some really helpful tools for starting programming in c. one is **gdb**. you might not need it in the very beginning but there will come a point when having it in your bag will save you hours or days. **valgrind** is another. it will point out memory errors which will include some cases that produce undefined behavior which will make you sad especially if you run your code on your machine and the graders (i presume this is for a class) use a different machine. finally get the compiler to do as much work for you as possible. if you are using gcc add the flags: **-W -Wall -Wextra -Werror -g -ggdb** (if you are using clang you'll have to look up the equivalents but i know by default clang gives more error messages than gcc).
&gt; FILE *input_file = fopen(filename, "wb"); Looks like it's a file deleter to me that then writes a useless XXMB file with the same name to different areas of the disk. You might have better luck actually erasing the old contents on disk by using "r+" for the file mode. EDIT: r+, not a+.
Ok I am starting to see now. for (i = 0; i &lt;= n; ++i) is telling p = p * base; to run "n" number of times. Every time that p = p * base is ran a new value is given to p and is multiplied again by base until the loop runs "n" number of times. On the first iteration p = 1 so it is 1 * base (let's say -3) and on the second iteration of it is new p (-3) * base(-3) and then on the third iteration it is the new value of p (9) * base(-3) so on and so on until n is equal to i. Once "n" is reached, the loop ends and the value of p is sent back to main() and directed towards standard out. Do I have it now? I appreciate your time and patience /u/Rhomboid. 
 I do believe that I get this now. /u/Rhomboid replied again and this time I am seeing it fairly clearly. I see now that I was thinking of this all wrong. I knew that i was not the same in both functions. I just wasn't fully grasping exactly how n was affecting the loop. It seems pretty obvious now. n is the counter for the loop. I saw that n would get bigger with each passing of main() into power(), I just didn't quite grasp that it was multiplying p = p * base over and over. I've got it now I believe and will be trying the exercise for that section. Thanks for your help and understanding!
Thank you for your help :) I will refactor my programm a bit. Managing my resources symmetrical seems to be good practice.
You might like to check out all his class notes/exercises/answers etc by going [here](http://www.eskimo.com/~scs/cclass/) 
thanks !
thanks 
thanks
Write a computer vs. human tic-tac-toe game.
thanks
Here is a small task inspired from a real-world problem I'm having: Write a program that reads in a couple of new-line separated words of arbitrary length like this: foo bar baz quux reddit snoo iam outof ideas Your program should figure out how many columns your terminal has (you can use the TIOCGWINSZ ioctl for this or assume that it has 80 columns if this doesn't work) and print the words out in as many columns as possible so that each column is as narrow as possible. Write your program in a way that it can print the entries both across and down depending on a command line flag. Here is an example for across-output: foo bar baz quux reddit snoo iam outof ideas and another example for down-columns output: foo quux iam bar reddit outof baz snoo ideas Of course, your program cannot assume that the text can always be distributed equally into columns, so the last few cells have to remain empty. Program a solution and discuss its efficiency. Can you prove that your solution is as efficient as possible?
Several comments: * You're not doing anything using 50 MB chunks unless sizeof(int) is 1 byte on your platform (unlikely). Your code is using 50 million * sizeof(int); likely either 32 or 64 bits depending on your machine architecture, meaning 200 MB or 400 MB (at least in hard drive manufacturer MBs). * You are unnecessarily allocating and freeing heap memory (which is an expensive operation) on each pass through your various loops. Just re-use the same memory. * You aren't checking the return value from calloc. This is madness. Any time you allocate heap memory, you need to check the return value from malloc/calloc to ensure that you actually got the memory you asked for before treating the pointer as valid (passing it into subsequent functions). * As /u/crookedkr notes, calloc zeros the returned memory. In addition to his point about debugging, there is a performance cost for zero-ing the memory (especially when you're doing it in a loop, as you are); given that you are immediately overwriting the content of the memory region with random data, there is no point in paying this performance cost; just use malloc. * Your usage of your filesize function is flawed. You correctly handle the case in filesize() where stat() returns an error and return -1 in such cases; your client code in main() however fails to check for a -1 return value, and incorrectly processes it as though a valid filesize &lt; 1024 bytes was obtained successfully. * Your file size ranges for your "if/else if" chain are overlapping. You are using &lt;= and &gt;= in such a way that the "or equal" values can be true for two of the if guards. While this is not an actual bug (the first true case will be handled, the else case ignored), it is poor style and should be made non-intersecting. Your question about "dynamic memory" (presumably the heap allocations with calloc) versus "a regular array" (presumably with automatic storage on the local stack frame): *Usage*, meaning reading from and writing to, these two areas will have very similar performance. There is a tiny performance advantage to usage of an array versus a pointer, as one layer of indirection in resolving the memory addresses to interact with can be avoided. More meaningfully, stack memory *allocation* is far faster than heap memory allocation. That said, 50 (or 200 or 400) MB of RAM is too much to assume you can allocate it safely on Intel x86 architecture, given the nature of how its stack works. (On SPARC it would be fine.) You essentially need to use the heap in this type of use case. In your particular use case, I would encourage you to investigate memory-mapped I/O. (man mmap, then do a bit more reading on the internet if needed.) Best of luck.
A debugger is a good tool for stepping through code. You can get a better understanding of whats going on using a debugger.
Where can I get one of those? 
The canonical source of preprocessor macros and other interface specifications are header files.
The canonical source for C and POSIX are their respective standards documents. Compiler headers often contain a large amount of nonstandard cruft.
If you are using an IDE, it may already have a debugger. On linux I've used GDB.
What do you try to achieve? To you want to colour function names differently depending on what standard they are coming from?
I explicitly don't want to highlight function names, that'd be too much overhead. :) I just want some built-in syntax highlighting information that doesn't depend on parsing the headers at run-time. And functions available are already documented in the man pages. Well, I want a user to have the option to *only* highlight a specific set of standards, like C99 + POSIX.2001, and really only the data types, constants and storage classes available. It's an on-off switch. Something like `set c.syntax c99,posix-2001`. It'll only be a simple visual guide to guess what standards are being used or to restrict yourself so if a type or constant is not highlighted, you'll know it's not in the standard. I guess I'll just fish the constants and types from the relevant standards. Sadly the GNU definitions are way too many and too little documented to for them to be included. I'll probably have only one `gnuc` option with a relevant subset that people care about (that GCC and clang provides).
Yes I thought about doing it a with the pre-processor and `feature_test_macros`, but it's afaik only available in the GNU libc and I don't know if they are strict in regard to the namespacing that much. So some GNU stuff might slip into the standard tokens. I've remembered that the musl libc had some kind of API coverage pages and I found them: for [POSIX.1-2008](http://nsz.repo.hu/git/?p=musl-tables;a=blob_plain;f=tab_posix.html;hb=HEAD), [C99](http://nsz.repo.hu/git/?p=musl-tables;a=blob_plain;f=tab_c99.html;hb=HEAD) and [C11](http://nsz.repo.hu/git/?p=musl-tables;a=blob_plain;f=tab_c11.html;hb=HEAD). They'll provide a good enough starting point I think. Just have to filter the parts I care about ...
If you want to do that, that's a good thing. But you should also highlight function names because it's important to know which functions are part of which standards.
**Tl;dr** - you're trying to change the actual address of value1, which doesn't work, since value1 already occupies an address in the stack specified by the compiler. ----- &gt; printf("Value 2 equals %i\n",value1); should have the second argument of printf as value2, not value 1. &gt; value = &amp;value3; What you're trying to do here is change the actual address of value1, which I don't think you can - though I'm not 100% sure about this. What you can do is the same as what you did three lines above, as such: *value = value3; ----- I digress a little bit in the section below. ----- Note: you can't pass changeValue a pointer to an integer, make it point to value3, then de-reference it outside of the main function because value3 would no longer exist after changeValue is done running(unless it's a static variable). In other words, the following would not work: int main() { int * ptr1; changeValue(ptr1); printf( "%i\n", *ptr1); } since the value that was created in changeValue that ptr1 is pointing to no longer exists. But if you change changeValue to the following: int changeValue(int * p) { static int value3 = 500; p=&amp;value; } the code above should work, but I digress.
This is the simplest and most straight forward explanation of const i've seen.
1. Quotes are include files you created yourself 2. Those are a bit harder to track down. IIRC, anything that include a .h file can define the functions, if they haven't be defined elsewhere. 3. The easiest way to do it would be to have the header file, .h, in the same folder as the main program you're compiling. From there, you can do two things: 1. (easiest way - but doesn't scale well) Define the functions directly in the c file where your main program is, or 2. ('Better way') Define the functions in a separate c file, and when you're compiling do the following: gcc -o main main.c definitions.c Make sure to include the header file in your main program - #include "---.h" 4. Yes, as I mentioned above, you have to include that header file where ever you're going to use it with #include "asdf.h" 5. I think it's because some libraries, including string.h, is automatically included during compilation. 6. I'm not sure, I've never tried. 7. I'm just speculating at this point, **someone please correct me if I'm wrong**, but I think if you have a central folder where you keep all of your projects, you can have a folder there, and you should be able to access them there via #include "header_folder/header.h" but I could be wrong. Or your compiler might have a directory where you can put your headers. 
- Q1 when using quote signs the preprocessor will look in the current directory as well as some sort of global include path(location of which is dependant on configuration as well as environment, you can add a path using -I&lt;directory&gt; flag in GCC for example) while with the angle brackets it will only look in the global include path - Q2 - usually applications in modern Linux distros only come with binaries and includes, you can also, using package manager(apt-get with Ubuntu), install packages with source. Then they are placed in distro-specific location, like /usr/src - Q3 a) To do so you use #include macro of the preprocessor. It's a dumb tool which copies the whole content of file into your .c file just before preprocessing it. As mentioned before you can add frequently used include folders using -I option of the gcc(or whatever your compiler uses). b) There are various ways of providing libraries. You can use source-based ones or binary-based ones. With binary based libraries you simply generate appropriate .o files and pack them into .a files using ar tool. With source-based you usually provide some sort of build script, like simple Makefile or autotools script, which will compile your library when given command. You should have a build script anyway. Another way to distribute packages is with package managers in form of rpm or deb files. edit: The only thing in your .h files should be things like types and functions used by the clients of your library. No code should go there if the client shouldn't care about it, for example no implementations of functions. - Q4 Yes, for example when using .a library, say libmytools.a located in /usr/lib, you would also pass -lmytools to gcc. You can also specify additional directories using -L&lt;directory&gt; parameters. - Q5 Linkers include certain libraries by default(possibly due to legacy - Q6 You might not have privileges to write in this directory. Assuming you have sudo configured(comes out of the box with Ubuntu) try issuing your command preceded by "sudo", like sudo mv /path/to/something /somewhere. - Q7 - /usr/lib is quite a good place I would love someone to check this post on whether it contains some errors, it's been a while since I touched C. edit: Some tools you might want to take a look at: - make - program executing makefiles. You are pretty much expected to have some idea about these if you deal with C - autotools - a set of tools built upon the above - more complicated but frequently encountered - ar - tool to make one .a file out of several .o files so that the library is easy to link - gcc - a set of tools for compiling and linking C files, you should learn some of its options like previously mentioned -I, -l and such. - gdb - the GNU debugger - when your code doesn't work but should. You should at some point probably at least get familiar with how to make executables which you can use with gdb. - git - version control software. Not related to your problems, but can be quite handy if you butcher your code and want to roll the changes back. Some remarks - there are also .so library files - when linking program with .a files these are glued together with the executable code. It can lead to redundancy when several programs use the same library, so when visiting /usr/lib you'll probably encounter .so file - you can compile programs so that they don't have the library glued to them, but rely on them being located in /usr/lib. They are somewhat similar to .dll files in Windows. By default dynamic linking is used by gcc(which means .so files). You can use -s option(I think) to link statically(glue .a files).
Thanks!
Thanks!
Thanks!
Pointers are hard... drawing some pictures with boxes for variables and arrows to show what pointers point to helps BTW, putting your code somewhere like github and providing line numbers makes these discussions easier to follow. Changing "value" to something like "paramPointer" also helps clarify the code a bit in main, when you call changeValue(&amp;value1) you are passing the memory address of value1 to changeValue as a pointer. [Note that since value1Pointer = &amp;value1, you could have equivalently written changeValue(value1Pointer)] in changeValue, the parameter "value" is initially a pointer to (contains the memory address of) value1. Therefore the line *value = 30 changes the value of "value1" back in main. However, when you then assign "value = &amp;value3", value no longer points to value1 in main, it now points to the local variable in changeValue, and so prints 500 in the last printf( ) in changeValue Now back in main, the statement *value1Pointer = &amp;value4; stores the **address of value** (not the value stored in value1) into value1 (since that's where value1Pointer points). When you print this with %i you get the long negative number that you see there. The statement " *vallue1Pointer = value4" would store 100 into value1. 
That looks really nice. I'm not sure if I can understand all of it, so I might try to write my own. I'll learn how it works that way anyway.
Just do really simple things. They don't have to actually be practical. Make a command line vending machine or something. Try any sort of simple task.
I don't see the context of your comment.
It's supposed to be this: `iam outof ideas`
have you tried gcc with -O3 or -ftree-vectorize and -ftree-vectorizer-verbose=6? I think using these intrinsics is more like assembler then c imho. Not that it's bad but it would be unportable unless you also provide a generic way. All this extra work.. e: -S -fverbose-asm is neat too. Or if not available, -Wa,-alh although less information.
Stroustrup was actually considering a *writeonly* keyword way back, but it wasn't deemed necessary (thankfully).
I wonder if that would have somehow helped with optimisation back before compilers were smart enough to analyse execution paths. Knowing a variable was write-only may have helped remove some redundant reads maybe. I don't know what I'm talking about.
I haven't tried in recent times, but about a year ago I did a relatively comprehensive survey where I tried optimizing a physics simulation (for surface friction) using gcc, icc and clang. Hand-vectorized code usually still came out being faster somewhere between 2-3% (icc) or even 100% (clang, which couldn't really vectorize at all back then.) I agree it's kinda low-level, but especially if you're doing C++, you can encapsulate it pretty nicely into classes with overloaded operators and tons of inlined functions to keep overhead to zero. SSE not being portable is of course an issue, but clang (others too, maybe?) now offers a generic vector extensions that gets translated into the underlying SIMD primitives of each platform.
Wouldn't that just write extra data to it? Also what do you mean other areas of the disk?
Hi, thanks so much from your reply. I think I am getting a LITTLE confused between address pointers addresses themselves and the values that they hold (the memory address of other variables). Would you mind clarifying... int numbers[]={1,2,3,1000}; printf("numbers array variable address located %p \n", numbers); printf("numbers array first element located %p \n", &amp;numbers[0]); so, numbers is an array variable which also is equal to &amp;numbers. HOWEVER... How do I find the address of the numbers array variable? as both numbers and &amp;numbers equal the address of the first element of the array that the point to? Thanks!!! I feel like i'm being a bit thick here, but i'm finding it slightly confusing.
[Programming Challenges](http://www.reddit.com/r/learnprogramming/wiki/index#wiki_programming_challenges), from the /r/learnprogramming wiki, lists many challenge/exercise websites. Additionally, consider [Do It Again To Learn](http://c2.com/cgi/wiki?DoItAgainToLearn). \* Also, if you have access to it, do all of the exercises in the ANSI C K&amp;R.
Hi. Thanks for your help, but i'm still a little confused. Hopefully you have time to further clarify. have you typed here when referring to statement: *value1Pointer = &amp;value4; You stated: &gt; stores the address of value (not the value stored in value1) into value1 (since that's where value1Pointer points). *"stores the address of value"* : eh... which value? Do you mean stores the address of value4? Apologies. If so, why does it put the address of value4 into value1 when the earlier statement: int *value1Pointer = &amp;value1; printf("Value 1 pointer equals %i\n",*value1Pointer); successfully prints out the value of value1 not the address? Thanks so much - I'm probably being thick here I am just finding this harder to get my head round the more I think about it!!!!
I can clarify that for you, the confusion you're running up to is really just a slight inconsistency with the language for convenience sake. It's probably best seen to understand it. this line: int *value1Pointer = &amp;value1; Does the same thing as these two lines: int *value1Pointer; value1Pointer = &amp;value1; You're right in understanding that "int *value1Pointer" means that "*value1Pointer" is of the type "int". The reason the statement is slightly confusing is because the assignment still assigns to the *pointer*, not to where the pointer is pointing too (Even though the "*" operator is technically in the statement).
Posing trick-questions to beginners ain't no fun.
&gt; You can use -s option(I think) to link statically(glue .a files). In GCC &amp; Clang, `-s` is a linker option that will strip symbols. If you want to link statically, there are a few ways to do so: * Pass `-static` option when linking (I think this is what you probably meant). e.g. `cc -o mybin mybin.o -static -lmylib`. * On the linking option, just add the static library directly to the command. e.g. `cc -o mybin mybin.o /usr/bin/libmylib.a * On your library search path, remove any shared objects so that the static library is used when doing `cc -o mybin mybin.o -lmylib` * Pass an option directly to the linker asking it to link statically. e.g. `cc -o mybin mybin.o -Wl,-Bstatic -lmylib` or `cc -o mybin mybin.o -Wl,-static -lmylib`.
Yup, I meant -static. I didn't have the gcc's manpage handy and was lazy enough not to google it.
The address of the i^th element of the array would be &amp;numbers[i]. So the address of the 3^rd entry of 3 is located in numbers[2], so it's address would be &amp;numbers[2].
You can also see some other examples in this site: http://www.lemoda.net/c/index.html
note that it's fine to have inline function implementations in your header file. this was outside of OPs question and is a little ambiguous in your answer.
Also, check out W Richard Stevens' Advanced Programming in the Unix Environment.
Cool, thanks! There's is such a simplicity to C that I love. . . need to really learn it some day.
OK, showing my C newbness. . . I was looking at http://lawlor.cs.uaf.edu/~olawlor/ref/examples/unix/fork.c and wondering why doWork returns a void*. Couldn't its return type just be void and then it wouldn't even need the return call after the printf statement? It's not like it does anything with the result.
This is pretty good for a first program, congrats. Instead of discussing the details of the implementation, i would suggest some exercices/updates based on the code you already produced. Some ideas: - add a game menu - add colors ( i think you can do this with ncurses ) - have a body alternating two colors, or two different shapes - add a bomb element that will kill your snake when touched. - play with 2 snakes ! - write a demo mode where your snake is controled by an AI I think these exercices are a good way for you to "test" your program structure. With each update you will probably have to refactor some parts of your code, some updates might be easy, some others might be very difficult. I hope this helps, and that you will learn from these exercices. 
No problem man, but it seems like you have the right mindset from your previous post. Sorry I didn't get back to you about the second part of that message, but here goes. &gt; The difference in my mind is that number[0] has the actual VALUE of '1'. Yes, this is exactly it. &gt; number is a pointer to the address of number[0]. Yes, like I mentioned, number points to the start of the array, which is the array element number[0]. ___ To continue from what I said previously, the reason why 'number' gives you the address of the first element in the array is that 'number' is treated as a pointer. So printf("%i", number) gives you the starting address of that array. 'number[0]' gives you the value instead of the address of that array, ie. printf("%i", number[0]) prints out the value instead because that 'number[0]' says is, give me the value held in the address that 'number' is pointing to with the *offset* of 0. Likewise, 'number[1]' is the value held in the address that 'number' points to with the *offset* of 1. The way that this *offset* works is that the compiler knows how much space each element of 'number' occupies, so to access the n^th element of the array 'number' points to, the address of that element is calculated as such: address 'number' is pointing to + (size of one element of number)*n Heck, you can even use 'number+1', number+2', etc. to refer to each element of 'number', though I don't remember if that'll give you the actual value held in that element, or just the address - you're going to have to play around with that. Now, the reason why '&amp;number' gives you the address of the start of the array is because in this case, 'number' is being treated as the array itself, instead of a pointer. With that said, it seems like you have the interest in learning C, and the willingness to get into the nitty-gitty part of it. I hope you stick with it, as it gets even funner/fun? later on. Keep up the good work :)
I used 'Data Structures and Algorithms" by Goodrich, Tamassia, and Mount. I thought it was a pretty decent book, and you can skip through the first two chapters, as those are intros to C++ or something of the sorts. Even though the book is aimed towards C++, the actual data structures implementation carry over to C.
Thank you for your suggestions :)
Your analysis is correct. You can't return void, but the function returns something. You can return a void pointer, though, and I'm guessing that it was used with some debug output earlier on to prove that the function was working. 
Great, thanks. I would have removed the return statement but your explanation makes sense. . . the void* probably made sense with an earlier version of this code. This is the kind of thing that drives me crazy though, I second guess myself a lot and sometimes look for a deeper reason for a chunk of code, because I assume I just don't understand it.
OK so that's it, just for the debugging macros then?
Well, `__LINE__` is a [built-in compiler macro](https://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html). All the `CALL_ZLIB` macro does is call a function and check the return value for errors. The only thing it does that couldn't be done from a function is print the line number where an error occurs: if it was a function, `__LINE__` would always refer to the line number in the function.
This is a sort of debug code, usually used as a custom assert code to help debug programs and identify where the bugs are happening. Macros are expanded by the preprocessor to appear in code where the macro is called from. So for example if we have the macro: #define MACROFUNC printf("Hello"); Then in our code we have: int a = 4; MACROFUNC a = a + 6; The code which gets passed from the preprocessor to the compiler would actually be: int a = 4; printf("Hello"); a = a + 6; If MACROFUNC was a function call, it would just be a call to the function. Now why is this important? For the __LINE__ expansion. Since the macro is literally being injected (copied as code) into the code by the preprocessor from where you call it, you'd see exactly where in code the error was occurring. (ie: __LINE__ would be equal to where you called the macro from) If it was a regular function, you'd always see the same __LINE__ being called from inside that function, which is useless for debugging.
`__LINE__` is magic, it always expands to the line number that it's invoked on. Try this two-liner: #include &lt;stdio.h&gt; int main () { printf("%d\n", __LINE__ ); } This prints `2` because `__LINE__` is on line 2. If you wrote instead (same code, different linebreak), #include &lt;stdio.h&gt; int main () { printf("%d\n", __LINE__ ); } it would print `3`. Macros are always "copypasted" into the final code by the preprocessor. Because of this, a macro that uses `__LINE__`, such as the one in your example, will be expanded on or near the line where the error checking occurs, so that the proper line number gets printed. If you use a subroutine, all the error checking would be done in the same routine, and would all print the same line number (from inside the routine).
The debugger will stop where the macro is CALLED, as it is not even in the code in "macro" form.
Wow. char *test = "this is a test"; printf("%c \n", test[1]); Guess what this prints? If your answer is 't', you should probably buy the book in the menu on the right...
Read up on printf format specifications. You're requesting a print of a string (%s), and you're giving it the address of the second character in test (&amp;test[1]) to start that string print from. What you want is %c (character), and you also need to specify a character value (e.g., test[1]) to print.
Thanks, I realised that this was a kinda mega derp ...
Thanks by the way for the replies. I think I've gotten a decent solution... What's the harm in using c = getchar(); while(getchar() != '\n'); to clear extraneous characters from the buffer if I only want the user to enter exactly one character?
That's pretty much correct. The '*' means "a pointer" when used in a declaration. However, with this: *value1Pointer = value4; The '*' instead dereferences the pointer and ends up setting value1 to value4. Whereas: *value1Pointer = &amp;value4; This sets value1 to the *address* of value4, not it's value.
In order to understand C, you need to think about all data as numbers stored sequentially in memory. A string is a series of bytes representing your characters, plus a nul byte to terminate the string, a byte made up of eight zero-bits. That nul byte is important. It's the only way c knows that a string had ended. Your pointer to a string knows nothing except the location it points to (the beginning of the string), and the type of days it points to (chars). It is up to you, the programmer, to treat it like a series of characters. If you have the word "hello" in a variable, char *cp, this will write six bytes in memory: 'h', 'e', 'l', 'l', 'o', and '\0'. If you ask for cp[3], you will get a pointer to the fourth byte in the sequence, and when you read it as a string, that is, sequentially until you hit a null byte, remember, you will get back 'l', 'o', '\0'. As others have pointed out, in order to get back a single character, you need to ask your format string for a character, rather than a string. The '\0' thing will also be important to remember (and annoying) when allocating space for a string. A string always needs one more byte than you want to give it. Mind you, this isn't the only way to define a string, but it is the one used by C's standard library functions and string literals. Alternatively you can create a struct that explicitly stores the length alongside a non-nul-terminated sequence of characters. but then you have to write all your own string handling functions, or find an external library that does it for you. The important thing is that you need a way to identify the end of the string, or else you will end up reading past three memory you intend to use, and cause all sorts of evil problems, including security bugs.
You aren't doing anything wrong. I think maybe what is confusing you is that &amp;test[1] points to the second character of the array. &amp;test[0] would be the same as just using test, so: &gt; char *test = "this is a test"; printf("%s \n",&amp;test[0]); or &gt; char *test = "this is a test"; printf("%s \n",test); would probably be what you want. Just remember that in C arrays start with element zero.
&gt; ... I program via Linux (Ubuntu). Check out these [tutorials](http://www.g-choo.com/lupg/tutorials/index.html) at the "Little Unix Programmers Group (LUPG)'s Little Site"
As I read it, the function doesn't only want positive numbers; it just returns the same value for equivalent positive and negative inputs.
Another option is `printf("%.1s\n", &amp;test[1]); which means to print at most 1 character.
Improve in what regard? Speed, correctness, readability? For readability, I would use separate variables doe the absolute values of u and v. Also, did you intend to return the absolute value of u, but not v in the 0 case?
I don't think this is any faster, but if (u == 0 || v == 0) return (u|v); // EDIT: Fixed u||v to u|v. would be a more condensed way to write if (u == 0) return (v); if (v == 0) return (u);
My personal preferences for altering this code fall into a few general categories: * initialize all variables to zero if no meaningful value is known yet * use defensive equality checks * always use braces with control statements * comment uses of the conditional operator and try not to nest it within statements * use parenthesis more often to make your intention explicit and to avoid unintentional behavior * comment your code Also, you are performing bit shifting on signed integer which is implementation defined. This means that if you compile this code with two different compiler then you could get two different outputs when calling the function. Unless you're using a specific feature of your implementation of the C standard then you shouldn't be performing shifts on signed ints. ffs() will return 0 if no bits are set. It doesn't looks like this will ever be encountered by this function since u and v are checked for 0 before performing any bit shifts and when t reaches 0 the loop will terminate. However, I mention this because performing a negative shift results in undefined behavior. Lastly, your absolute value calls result in different results when passing the same arguments in a different order, for example: gcd(-6, 0) =&gt; -6 gcd(0, -6) =&gt; 6 I have no idea exactly how the loop is working on the numbers at the bottom, and I don't feel like figuring it out right now (comments would've helped here!) so I left those as "magic". Also, uu and uv aren't terrible good variable names either. Since you already wrote the function, and it appears to work, I've pasted the version as I might've written it. No guarantee that my comments are even accurate or that I didn't introduce some bugs or odd behavior though! #include &lt;stdio.h&gt; #include &lt;string.h&gt; int gcd(int u, int v) { int k = 0; int ufirst = 0; int vfirst = 0; int t = 0; unsigned int uu = 0; unsigned int uv = 0; /* GCD is always positive and bit shifting on signed ints is * implementation-defined */ uu = (unsigned int) abs(u); uv = (unsigned int) abs(v); /* GCD of x and 0 is x */ if (0 == uu) { return uv; } else if (0 == uv) { return uu; } /* Find first set least significant bit places of u and v */ ufirst = ffs(uu); vfirst = ffs(uv); /* Get the minimum of the first variables */ if (ufirst &lt; vfirst) { k = ufirst; } else { k = vfirst; } /* Account for ffs() being 1-based instead of 0-based */ k -= 1; /* Shift off k unset bits from both u and v */ uu &gt;&gt;= k; uv &gt;&gt;= k; /* Loop counter is the even one of the two, if an even one exists */ if (1 == (uu % 2)) { t = -uv; } else { t = uu; } /* Do the thing */ while (0 != t) { /* Shift off unset bits from the loop counter */ t &gt;&gt;= (ffs(t) - 1); /* Magic */ if (0 &lt; t) { uu = t; } else { uv = -t; } /* More magic */ t = (uu - uv); } /* Reset uu to its original value */ return (uu &lt;&lt; k); } 
extern is the default storage class specifier for functions so it has no affect on the code here since it is equivalent to: int gcd(int u, int v); As for only accepting positive numbers, the greatest common divisor can be taken on negative numbers, so taking in "ints" is perfectly valid. However, the result is supposed to only be positive which is not handled correctly by the implementation in the original post. 
The "magic" works because the sign of t will tell you whether `uu` or `uv` is larger. If `uu` is larger, then you want to replace `uu` with the difference `t = uu-uv`. Otherwise, you want to replace `uv` with the difference. If `t` is positive, then you know `uu` is larger and if `t` is negative, then you know `uv` is larger. The line `t &gt;&gt;= (ffs(t) - 1)` is to make `t` odd.
My point was that if it requires a paragraph to explain then it should have comments. Thank you for explaining though, I didn't particularly feel like figuring it out right now :-)
I've implemented an algorithm from a textbook. I don't think code requires further comments when it's a one-to-one translation of a provided algorithm. I'm also not that much into "defensive programming". The compiler will warn me when I use a variable uninitialized. Catch-all initializing variables to 0 will lead to warnings (Variable set but not used) and badly-readable code (is that 0 a meaningful initialization or just a catch-all?). The last thing about this code returning wrong results for pairs of 0 and negative value is true though, I've already fixed the code, see updated post. Last but not least, you're including the wrong headers. abs() is declared in stdlib.h and ffs() is in strings.h according to POSIX.1 2008. While some systems also declare it in string.h, you generally shouldn't assume that.
Thank's. I used if (u == 0 || v == 0) return (u | v); for now because both gcc and clang don't seem to be smart enough to replace u || v by branch-free code.
No, that's not intented. See updated code.
The gcd function can also take negative values, see the source I provided in the original post for more details. I explicitly write extern so it's obvious that the function has external linkage and so that's obvious that I did not forget the storage-class specifier.
Yes, I know that it's the default, so in this case it does not affect anything. However, seeing a definition as extern still seems odd to me. And true, it does make a difference if any of those are negative while the other is zero.
That will cause the program to wait until it reads a newline character from the input buffer. If there isn't a newline character in the buffer, the program will wait until there is. If the program reads EOF before reading a newline character, then you have an infinite loop.
I saw that you did not change to use unsigned integers for the variables which are having bit shifts performed on them, is there a particular reason for that? The headers were incorrect due to having printf() and forgetting the s on "strings", but it still works, on my machine at least. Are you going for speed, size, portability, etc.? You never mentioned what improvements you were going for and seemed to throw out most of my suggestions, which is fine, but if you can give us a more concise goal then we can also give you more useful feedback.
In this code, I am performing two kinds of shifts. First, I am performing right shifts in two places. The original algorithm contained language similar to the following: &gt; Divide t by 2 until t is odd. Since t can be negative, for example when t is assigned from v, it is important that the right-shift is an arithmetic one and correctly takes care of the sign bits. Second, I am performing one left shift. This could be a problem in theory since it is undefined behavior to left shift a negative value or to left shift something into the sign bit. This cannot occur since for positive u and v, it holds that gcd(u, v) &lt;= max(u, v). Since both u, and v are representable in an int, the left shift will not cause undefined behavior. I am not a big fan of casting every and each value whereever it appears. Except in the specific case that I can prove that I need the extra numeric range or the well-defined behavior (which is not needed as shown above) the cast provides, I generally don't cast. Casts cause trouble as they change the range of valid values. After casting, I have to reason about two value-ranges instead of just one. In a comment further above, I specify what I am optimizing for. Most importantly, the code must be portable to all POSIX.1 2008 compatible platforms. Second, the code should perform reasonably well. Third, the code should be readable. I don't think that readability is archieved by throwing defensive initialisations and comparisons around. The compiler checks if I use a variable without initializing it and also warns me if I assign to a variable in a loop condition.
&gt; Since t can be negative, for example when t is assigned from v, it is important that the right-shift is an arithmetic one and correctly takes care of the sign bits. &gt; Most importantly, the code must be portable to all POSIX.1 2008 compatible platforms. I don't believe the behavior of an arithmetic shift right on a signed integer is specified by POSIX.1 2008, or any other C standard (if it is then nevermind, of course). But, since you say this behavior is so important I'm surprised you would rely on something which is isn't guaranteed. Obviously it's working for you though. It just seems like you're picking and choosing where you want to prevent undefined or implementation defined behavior, just trying to help. 
The C standard ISO 9899:2011 says &gt; ISO 9899:2011, §§6.5.7.4–5 &gt; &gt; 4 The result of E1 &lt;&lt; E2 is E1 left-shifted E2 bit positions; vacated bits are filled with &gt; zeros. If E1 has an unsigned type, the value of the result is E1 × 2^(E2), reduced modulo &gt; one more than the maximum value representable in the result type. If E1 has a signed &gt; type and nonnegative value, and E1 × 2^(E2) is representable in the result type, then that is &gt; the resulting value; otherwise, the behavior is undefined. &gt; &gt; 5 The result of E1 &gt;&gt; E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned type &gt; or if E1 has a signed type and a nonnegative value, the value of the result is the integral &gt; part of the quotient of E1 / 2^(E2) . If E1 has a signed type and a negative value, the &gt; resulting value is implementation-defined. "implementation-defined" means that the ABI of the target platform has to define the behavior of the operation. It's important the implementation-defined behavior is not undefined behavior. Now, it's important to know the intent of the C comitee before dismissing right shifts of signed integer types as not portable. The C language specifies three possible representations of integers, one's and two's complement and sign-and-magnitude. Whereever behavior between these possible implementations differs, the C standard contains an "implementation defined" to make all three possible. While it is technically possible that my code runs on a one's-complement or sign-and-magnitude architecture, no such architectures are in use today (except for some exotic super-computers and the occassional VAX). All architectures that are capable of running a sufficiently advanced Unix use two's complement and their ABIs all implement right-shifts of signed integers with arithmetic semantics (i.e. the sign-bit is being honored).
Gotcha! Thanks for explaining all that out. I prefer VAX.
Sorry, I was wrong in the comment above. I remembered that incorrectly; the VAX does actually use two's complement. See [here](https://en.wikipedia.org/wiki/Signed_number_representations) for more details.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Signed number representations**](https://en.wikipedia.org/wiki/Signed%20number%20representations): [](#sfw) --- &gt; &gt;In [computing](https://en.wikipedia.org/wiki/Computing), __signed number representations__ are required to encode [negative numbers](https://en.wikipedia.org/wiki/Negative_number) in binary number systems. &gt;In [mathematics](https://en.wikipedia.org/wiki/Mathematics), negative numbers in any base are represented by prefixing them with a − sign. However, in [computer hardware](https://en.wikipedia.org/wiki/Computer_hardware), numbers are represented only as sequences of [bits](https://en.wikipedia.org/wiki/Bit), without extra symbols. The four best-known methods of extending the [binary numeral system](https://en.wikipedia.org/wiki/Binary_numeral_system) to represent [signed numbers](https://en.wikipedia.org/wiki/Signed_number) are: sign-and-magnitude, ones' complement, two's complement, and excess-*K*. Some of the alternative methods use implicit instead of explicit signs, such as negative binary, using the base −2. Corresponding methods can be devised for [other bases](https://en.wikipedia.org/wiki/Positional_notation), whether positive, negative, fractional, or other elaborations on such themes. There is no definitive criterion by which any of the representations is universally superior. The representation used in most current computing devices is two's complement, although the [Unisys ClearPath Dorado series](https://en.wikipedia.org/wiki/UNIVAC_1100/2200_series) mainframes use ones' complement. &gt; --- ^Interesting: [^Method ^of ^complements](https://en.wikipedia.org/wiki/Method_of_complements) ^| [^Floating ^point](https://en.wikipedia.org/wiki/Floating_point) ^| [^Least ^significant ^bit](https://en.wikipedia.org/wiki/Least_significant_bit) ^| [^Binary-coded ^decimal](https://en.wikipedia.org/wiki/Binary-coded_decimal) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cj9c48y) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cj9c48y)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Post the code...
How is your code structured? One file or multiple files? If you have "static int sv;" in multiple files, that definition of sv is limited and unique for each file. What you probably want is int sv; defined at the global scope in one file, and extern int sv; declared in the other files.
It's unwise to distinguish between "file" I/O and "keyboard" I/O, because C doesn't distinguish between those concepts. C&amp;nbsp;has only the concept of a stream. And there's no way to guarantee that standard input is coming from a keyboard, anyway—the user can redirect the contents of a file to standard input when they run your program, which means that calls to `getchar` in your program will actually be reading characters from a file, not the keyboard.
the 'static' keyword applied to a global variable has different meaning than if it is applied to a local variable. With a local, it means that it gets special treatment and it is remembered between runs/calls of that function. With a global, it means that the scope of that global variable is limited to the file that you are currently in; otherwise it behaves the exact same as any other global. So either you are using multiple files and have declared the same global name in each file (so that things compile) and things aren't doing what you thought they were OR you are using 'static' unnecessarily and something else is wrong with your code.
For what it's worth, actually you don't want global variables. Seriously. Declare all your file level variables `static` and puzzle out how to get them to talk to each other (hint: don't try too hard, there's a reason each variable is in its own file).
&gt; do static variables have to be declared in each function they appear in No. And that's the problem with globals, they're global. But it's going to be really hard to diagnose what you're doing wrong without a minimal example.
The answer to both questions is [Github](http://github.com) Yes it's common to create a portfolio, how will others know what you've been doing? If you're looking for actual jobs, you'll want to eventually step away from small programming challenges and toy problems (though they are a good way to learn the language) and you'll want to start writing useful applications. The applications don't have to be huge, but the employer should see that you work on your own stuff in your spare time. Example On my github, I have various code. One is all of the programming challenges I've done, and the rest are applications I've built, including a MIDI file parser, image converters and also a bruteforce directory searcher. I used to have games on there but since they were incomplete I removed them. Here's my github if you're interested https://github.com/JoeReynolds1 At the beginning you'll probably think there's nothing to make, it's all been made already!. I can guarantee you it hasn't, think of something that needs improvement, and improve it.
You could always use something like [github](https://github.com/) or [bitbucket](https://bitbucket.org/) which gives you free version control and an easy way to share your code with other people. You'll also have the opportunity to learn git if you aren't familiar with it already. Another option might be [Google Code](https://code.google.com/), though I've never personally used it and am not actually sure if it works in the same way as the other two I mentioned.
Thanks for your information and the link to your github!
Thanks!
Also, the last time I was looking around for positions one could also link to one's Ohloh profile (Now [OpenHub](https://www.openhub.net/)). You can claim contributions to projects or list your own on there and it will generate a profile of projects and languages you've worked on/with. It allows you to claim contributions on repositories that are publicly available not only on GitHub but a variety of other version control systems and sites.
Well, the first weird thing that I notice is this: &gt; if(input1[i] == '\n') &gt; { &gt; input1[i] = '\n'; &gt; &gt; } Why do you have that code? What do you expect that code to do?
By the way: &gt; string's &gt; &gt; character's &gt; &gt; array's There is no apostrophe in a plural. The plural of "string" is "strings," and the plural of "character" is "characters," and the plural of "array" is "arrays." None of these has an apostrophe.
&gt; One is all of the programming challenges I've done ... Just ensure you aren't publishing solutions to challenge sites that explicitly request you not do so. It's poor form, and in many cases against the terms-of-service/user-agreement. One way to get around that is to make those challenge repositories private, and simply mention that you can make the repository available to prospective employers upon request for inspection. &gt; At the beginning you'll probably think there's nothing to make, it's all been made already! Even then, one can always [Do It Again To Learn](http://c2.com/cgi/wiki?DoItAgainToLearn) — that's more applicable to a project you've completed, though.
Do you know of any private repos available? I have some euler stuff up there which I guess should go private but the github one costs.
To add to that, if MAX is supposed to be the maximum array size, you end up writing 2 bytes beyond MAX, which will write into invalid memory if you pass the array length for MAX. Also, capital letters like MAX should only be used for macros, not function arguments.
[Bitbucket](https://bitbucket.org/) offers unlimited private repositories. Really great service.
Library functions are notoriously tricky to duplicate. Be sure to account for all possible cases, like zero length strings.
You are misunderstanding how pointers work a bit. Any value you pass via argument is ALWAYS passed by value in C. That includes pointers. Since the pointer itself has a value, the value being the address of the value it points to. Pointers are not magical, they just point to a memory address, everything else is exactly the same as a normal value. Pointers are just syntax sugar to make your life a lot easier. What you are doing is basically asking why this doesn't work. int main(int argc, char *argv[]) { int a = 10; printf("%d\n",a); /* 10 here */ change(a); printf("%d\n",a); /* 10 here too, because... pass by value */ return 0; } void change(int a) { int b = 20; a = b; /* Does this make any sense? No, I didn't think so. */ } Now this statement is wrong for different reasons. It isn't because it doesn't work, it's because you don't understand pointers. *value1Pointer = &amp;value4; This is basically saying "assign the address of value4 to the integer pointed to by value1Pointer", basically you are assign the address of value4 to the value that the pointer points to. If you just wanted to change the value of value1Pointer. Do this. *value1Pointer = value4; If you wanted to change the pointer to instead point to value4, do this. value1Pointer = &amp;value4; Just repeat after me, "Pointers are just values that hold an address that points to another value." The only confusing part is that the type of a pointer refers to what it points to, rather then to itself. As it is a pointer, and all pointers are exactly the same. For example this is 100% legal (though you shouldn't do it). char str[5] = "4000"; int *ptr = (int *)str; *ptr = 0x21574F57; printf("%s\n",str); /* Prints "WOW!" */ Just keep in mind if you changed the first part to this, it becomes illegal, and will likely segfault. char *str = "4000"; As now you are getting the pointer to a constant (compile time) value, which you shouldn't change.
Nobody cares, actually. A teacher needs something to keep student busy, an assignment where you're asked to implement a library function is the way of least resistance. Nobody is going to bother test it extensively either, a quick glance through the code is enough to figure how a student does. StackOverflow is full of questions like this. 
In addition to shvr's recommendation, you could use cgit and host it locally (i.e., upon request you turn on your server). * [cgit](http://git.zx2c4.com/cgit/about/): A hyperfast web frontend for git repositories written in C.
Oh nice, thanks for letting me know :D
The gist of it is to pay attention to the *resources* that you're using: CPU time (operations), RAM (number and size of variables), disk space (if applicable), bandwidth (if applicable), and logic. The last one is where more gains are likely to be found. Improving (read: simplifying) your logic will usually lead to less comparisons and thus less branches, which means less *everything*, including the time you spend reading and understanding your own code. Let's take a simple scenario: you have a program that needs to figure out if a given number is even or odd. Ignoring the fact that this is generally simple, there are a number of ways you can do this, and all of them vary in complexity and readability: int is_even(int num) { if (num % 2 == 0) { return 1; } else { return 0; } } That's pretty straightforward, right? It's correct, too. But is it efficient, compact, and readable? Compare it to this and you tell me: int is_even(int num) { return (!(num % 2) ? 1 : 0); } Again, this is a trivial example and shouldn't be outsourced to a function; that's not the point. I'm not saying you should shorthand everything, but instead think about which things could be simplified and achieve the same results. More branches and more loops will bog you down faster than anything else, imo. They also make the code harder to read. A single branch or loop isn't bad. Nesting 4+ deep or getting even more complex is a recipe for disaster unless you know exactly what you're doing. I'm not an expert (kind of a newbie really), but the above is what I strive for in my code: readable simplicity. I don't have any books to recommend, sorry. :( 
Is your assertion that the second code snippet is more readable? Personally I find it more confusing. Why do you negate the (num % 2) when you could just switch the 1 and 0? Or, if you're just going to return an integer and not a boolean, why not just return !(num%2) ? To me, the first form seems cleaner (apart from the two return statements) and easier to understand. I mean no disrespect - I get comments about my code all the time because I prefer more verbose code (like the first example) because I think the shortcuts C programmers use tend to make the code less self-apparent. I'm interested to hear other opinions on this matter.
Write a multiprecision integer arithmetic library. Be sure to include unit tests as you implement each operation (addition, multiply, division, modulo, etc.). Once you're happy with that, implement Miller-Rabin primality test.
No. column(1) uses a simpler approach where each column has the same width. It is easy to compute the column count when each column has the same width: Take the longest name, that's your column width. In the task above I specifically ask for every column to have the smallest possible size. A much more difficult task.
10/10 times I'd pick your first solution, if I had to pick between those two. Otherwise I'd pick bool is_even (int num) { return (num % 2) == 0; } (Or more likely, replace it with a macro or an inline function where appropriate.)
There are no built-in 'booleans' in C (stdbool.h gives you constants but no real distinct type). Also !anything is already 1 or 0 I think.
C99 has bool as a built-in type.
In C99 it is an actual built-in as the type '_Bool'. stdbool.h just typedef's it to 'bool'. Being built-in and a distinct type is why non-zero values are all converted into 1, just like wrapping !!() around stuff. If it was just a typedef'd int or char that conversion wouldn't happen.
You're right. I was thinking 'bool,' didn't think about '_Bool.'
Why not `return !(num &amp; 1)`? I don't like comparisons to 0 :-)
I prefer the same, but I followed the style of the parent post. Well... except for bracket placement. :)
That is helpful. Thanks! For the second issue regarding the 'struct http_header *' instead of 'struct http_header []', could getting the size of the first element be good?
Start with the fact that void http_header_format(char *out, struct http_header headers[]) is treated by the compiler as really being void http_header_format(char *out, struct http_header *headers) From there you can see that you must pass the size of the array as a separate parameter (or use some terminating element, or a global, or...), and then you don't need to use sizeof at all, at least in the callee. The caller might choose to do so. 
Unrelated to previous comments -- HTTP headers are supposed to be separated by "\r\n", not just "\n". 
Thanks. I changed the definition of http_header_format to this: void http_header_format(char *out, struct http_header *headers, int size) And that works fine and passes with -Wextra and -Wall. :) 
Thanks, fixed that too :)
You can also always use a !!var to convert anything to boolean
While we're on about this, why are you taking the size as an `int`. [There's literally a type devoted to sizes.](http://www.embedded.com/electronics-blogs/programming-pointers/4026076/Why-size-t-matters)
Ah roger. Not to take away from your original task, but patching in the needed functionality to column and contributing it upstream would also be a good task.
It would be a bad idea to simply patch that in as that would change the behavior of column which is otherwise stable. Perhaps there are programs that depend on the output-format of column. It could make sense to add an extra option that implements the new behavior though.
&gt; It could make sense to add an extra option that implements the new behavior though. That was the intent.
I think personal preference and more importantly, experience really matters wrt readability. If you're more experienced, reading that might be easier. And based on other comments in this thread, there are other ways to express what I did, arguably better and more readable! That's just my lack of experience in C showing, and it's cool to see multiple ways to express it. I think the example, despite being trivial, revealed through the replies that there's a lot that can be done to change code to one's taste for readability, and multiple efficient ways to achieve something. So despite my example being mediocre, I'm happy to see other takes on it which proved my point. :)
I hadn't thought of bitwise operators! That's a good idea. :D
code the "module" (list, database etc.) unit test and profile it (white box or black box) goto sleep get a new idea in shower or while driving rush to laptop and improve code profile it again to objectively prove the improvement to yourself 
Yeah I don't try to second guess the compiler and sacrifice readability. If you're coding in C, it's highly likely the compiler knows better than you do how to write the best code for your platform. In this extremely simple case I don't think it matters as much, but "(n % 2) == 0" reads better to me since that way I don't need to think about the binary encoding or reason through the logic - it's purely a "divisible by 2" test and not a "least significant bit set" test (though I'd definitely argue is_lsb_set() should be written (n &amp; 1) == 0). It's pretty much the mathematician vs the computer scientist argument though.
It means wat it says. Your glibc is too new or (more likely) outdated. What does `ldd --version` say? Anyway, [ASan](http://code.google.com/p/address-sanitizer/wiki/AddressSanitizer) is superior to valgrind in any regard. If you can, use it instead.
You should install the valgrind binary package from your distribution's package manager rather than trying to build it from source.
If the tutorial explains Valgrind, maybe he should use Valgrind.
Well assuming OP is more or less a beginner, he may not have known about `size_t`, and if you don't know about it then `int` is the most logical one since size is probably not going to be a decimal number
I suppose it's a matter of taste. A better example when bit-trickery is useful is when [checking if a number is a power of 2](http://www.exploringbinary.com/ten-ways-to-check-if-an-integer-is-a-power-of-two-in-c/). The compiler is unlikely to optimize a naive solution. 
How would a signed type ever be the logical choice for a size? 
&gt; my [friend](http://ideone.com/gNsHt9) mistakenly set the first char array to have size 10 instead of 20, you would expect it to fail That program has **undefined behavior**, which means you have absolutely no guarantees about the behavior of any part of the program. You should not "expect it to fail," nor should you "expect it to succeed." You have absolutely no guarantees about its behavior in any way. It may work some of the time on some systems under some compilers, and it may fail in other cases. The C&amp;nbsp;standard is a contract between the programmer and the compiler. The compiler is obligated to produce an executable program that behaves in a specified way as long as the programmer follows the rules in the standard. By writing beyond the bounds of an array, you, the programmer, have violated the rules in the standard, and so that contract is no longer in force. The compiler is under no obligations to produce a program that behaves in any particular way.
There's no runtime bounds checking in C, so strcat() just went and trampled all over some other poor variable's memory. 
&gt; it worked anyway It did not. It *appeared* to work anyway, but it invoked undefined behavior. What you've witnessed is the equivalent of someone saying, "I didn't look both ways when I crossed a busy street, and I didn't get run over." What you should take from that is not that what the person did is in any way sane or safe, but that they were just merely lucky that the phase of the moon was just right such that they weren't hurt. Don't mess with undefined behavior. It will ruin your day. 
So that if the local header files require something from the system header files but fail to `#include` the appropriate system headers you will catch that mistake.
Makes sense! Thanks.
Another analogy that I've read is that of somebody saying, "I heard that in basketball you can't run while carrying the ball, but I got a basketball and tried it and it worked just fine." (From [A Guide to Undefined Behavior in C and C++](http://blog.regehr.org/archives/213); the original source is [Roger Miller, via Steve Summit](http://www.eskimo.com/~scs/readings/undef.950311.html).) The point is that the game of basketball has certain rules, and one of those rules is that you are not allowed to run while carrying the ball. In the same way, the C programming language has certain rules, and one of those rules is that you are not supposed to write beyond the bounds of an array.
strcat, in general, can be dangerous. Some recommend never using, and it uses strncat, or even better [strlcat](http://www.freebsd.org/cgi/man.cgi?query=strlcat&amp;sektion=3&amp;apropos=0&amp;manpath=FreeBSD+6.2-RELEASE), if it's available on your platform.
Once you fix the off-by-one bug in the loop which makes the program have undefined behavior, you have a chance of it, but you'll need to save the original pointer value. More conventional to just index via i and not change your pointer. Put simply, one free for each malloc. There's only one malloc here, so only one free is needed. EDIT: was wrong before; rewrote to take into account incrementing of hashvalue.
Thanks! 
You allocated the block of memory with one call to `malloc()`, so it is freed with one call to `free()`. It's impossible to free part of an allocation -- it's all or nothing. From the standpoint of the heap manager, there is only one object allocated here, which happens to be a blob `sizeof(int) * k` bytes in size. The fact that you can treat it as if it was subdivided into individual integers is irrelevant to how it's managed. 
Make a simple function hooker/hook! It will help you understand the language a little bit more under the hood, how the code is generated, how functions are called, how stack works, what call conventions are there and so on. Stuff like this will give you much more insight and in-depth knowledge about the code flow and how it all works and its very practical aswell! :) (hooks are used pretty much anywhere, from 3rd party plugins/apps, cheats, hacks or malware) Heres a link where the basics are explained pretty well: http://jbremer.org/x86-api-hooking-demystified/
Or simply and boringly hashvalue[i] = 19;
Thanks 
The Towers of Hanoi thing was only done for #pragma directives. The standard says that a #pragma directive causes the implementation to behave in an implementation-defined manner (the only exception is if the first part after #pragma is STDC). This is so vague that it allowed GCC to start Towers of Hanoi and still remain compliant with the standard.
I'd like to help but that code is beyond readable. I'm not wasting my time.
It would be super useful if you could format your code before posting. Well-formatted code is much easier to read and makes it easier for us to understand what went wrong in your code. Here is your code formatted according to the KNF style: #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main() { int prime = 0; long div = 2, fac = 2; long long ans = 0; float tar = 0, sq = 0; printf("\nSpecify a number between 2 and 1'000'000'000'000\n\n"); scanf("%f", &amp;tar); sq = sqrt(tar); for (fac = 2; fac &lt; sq; fac++) { if (tar % fac == 0) { for (div = 2; div &lt; fac; div++) { prime = 0; if (fac % div == 0) { prime = 1; break; } } if (prime == 0) { ans = fac; } } } printf("\nThe Largest Prime Factor is %lld!\n\n", ans); } Also, turn on warnings. Usually, there is a flag -Wall to turn on all important warnings. If the compiler warns you about something, it's usually a mistake. For instance, you forgot the type specifier for main. Instead of main() you should write int main() even though the former compiles; not specifying a return type is deprecated and doesn't work in C99.
Barring that, if he were to call free() on the original pointer, the answer to his question is yes, it will free all data in that pointer.
Neat, both of your questions are answered in excruciating detail here: http://en.wikipedia.org/wiki/IEEE_floating_point
&gt; How would a signed type ever be the logical choice for a size? To quote Chandler Carruth: "Use signed integers unless you need two's complement arithmetic, or a bit pattern." (see http://channel9.msdn.com/Events/GoingNative/2013/Interactive-Panel-Ask-Us-Anything @ 12m10s) A size doesn't need two's complement arithmetic, and it's not a bit pattern. Chandlers knows compilers, and compilers love signed integers. 
Except that the data isn't "in" the pointer in any meaningful way. What's in the pointer is an address. The memory freed is at that address, and is only "in" the program's heap. 
I don't think you're gonna like what happens when hashvalue is scaled by sizeof(int). That equivalence works for char[] or other 1-byte types. 
Couldn't you just make this a macro and avoid the function altogether?
Another recommendation: look past any animosity you may see in the responses about formatting, and heed the advice given. Well formatted code isn't just to look good, it really aids with code maintenance and review. 
`i[hashvalue]` is equivalent to `*(i + hashvalue)`, so it will still scale `i` by `sizeof(int)`, not `hashvalue`.
Modification to hashvalues is already being "scaled" by sizeof(int) since it is an int*. x[y] is truly identical to y[x] as long as one of x/y is a pointer type and the other is an integral type. Anything else (both integers, both pointers, one is a float, etc) won't compile. (Overloaded operator[] is another story entirely)
All this is... just wrong.
Oh crap, I didn't think. I even saw that it was incremented. Using i as the loop value is such a common convention for *indexing* that I couldn't think that it wasn't being used for that. Power of convention.
&gt; Q: How is it possible that float and double can store such large numbers, when for instance int and long long can not? 1x10^15 versus 1000000000000000 . But, 1234567890123456 is only approximated by 1.23x10^15. &gt; Q: How is C (and languages in general) storing float and double as binary? As far as I understand some amount of bits are used for the integer part, but then how can a float / double store larger numbers? 1.23x10^15 can be stored as two integers:123 and 15.
The easiest way to wrap your head around the huge range of floating point numbers is that IEEE floating point format can't represent *all* numbers from their min to their max (like an integer can). The most amount of unique values a 32-bit float can represent is 2^32, just like a 32-bit integer. Since there are some duplicate values possible (positive and negative zero, NaNs, and some "normal" values which can be represented in two different ways), the amount of unique values is actually less than an *int*. So the only way for this system to have a wider range is to simply not be able to handle all possible values in the range.
1.23x10^15 would be 123 and 13 would it not?
Sure, that's clearer, though of course representations can be anything. I was assuming an implied decimal after the first digit, as floating-point uses a variation of.
When a number is converted to float-point, it is always converted into a format of a single leading '1' (This is, of course, for the number written in base-2, not base-10. Base two numbers can always be written starting with a 1, except for the number zero). It then becomes something like this: 1.000101110101 * 2 ^ 50 (That's approximate since 1.23 is actually a repeating decimal in base-2) When it's stored as a float or double, the leading 1 is dropped and instead you just store the '000101110101', and you add 127 to the exponent (Getting 177, '10110001'). When you convert the float/double representation to a number, you add 1 to the decimal and subtract 127 from the exponent. This allows for negative exponents to be represented, and requiring the single leading 1 makes sure that every number can only be represented in a single format.
Depends entirely on how it's programmed. If the code detects the end of the linked list by the presence of a null pointer, then yes. If the code stores the list length separately, then it might not be necessary.
Okay thank you. 
Vice versa. Increments s and then assigns that value to next. Think about this: Int next = 4+4; Would it assign next to 4 and then increment to 8? no. It calculates the declaration then assigns. 
First of all, did you mean: char *s; char next = *s++; If so, this is the same as char next = *s; s += 1; If on the other hand you meant what you wrote, ie char s; char next = s++; then this is the same as next = s; s += 1; To answer your final question, one of these is the answer (depending on the type of `s` you meant): next = s[1]; or next = s + 1; The question seems too trivial to be answered like this...
No, rooky mistake sorry. I meant char *next;
 char *next = s; next++; this solves it doesn't it?
No. C strings are a *convention*. Other possible convention is: struct mystr { int buf_len; char *buf_len; } Instead of operating on `char *` types, you can implement a string API using the above struct. You don't need a dummy trailer node, but [it can lead to efficiency gains for very specific operations.](http://www.ics.uci.edu/~pattis/ICS-23/lectures/listprocessing/lecture.html)
As a heads-up, this is the really important part to keep in mind with working with float-types, is that they don't represent all values in their range, and that there can be very important rounding errors. This causes a couple issues when comparing two floating point values, and the finite precision can cause some very odd things to happen, when it comes to order of operations.
&gt; char *next = s++; &gt; &gt; This statement assigns s to next and then increments or vice versa? In other words, what is the order of operations? char *next = s; s = s + 1; &gt; Is there a way to assign next to the following element of s without actually incrementing S? Element of s? I'll assume you mean the value s would have after s++, as your previous question was asking: char *next = s + 1; 
Yep, you start seeing non-existing patterns
I think you're confusing NULL character with a NULL pointer. While they achieve the same thing, by convention you would point a node pointer to NULL via ptr = NULL; whereas a string would be terminated as string[n] = '\0' NULL is not a character, but '\0' is, so only '\0' is used to terminate a string, whereas NULL can be used indicate an empty pointer of any type.
That said, I'll take time-saving conventions over having to decipher odd code where every loop uses a different structure. Not that I'm blaming someone learning programming for not following conventions. It's nice to have something unexpected to catch you off guard.
In the first program, there is only one x and all calls of prime() access the same variable. In your modified program, each invocation of prime() has its own x which is set to two in the beginning. Each invocation of prime() accesses a different x and the result isn't shared. This is why you don't see x increasing. Try something like this: Replace void prime(int num) { int x=2; by void prime(int num, int x) { and the first invocation of prime(num); by prime(num, x); and the second invocation by primte(num, 2); to get a behavior that is similar to the original behavior.
&gt; I suppose my desire is to generate functions for use by function pointers without filling the global scope. That's not really a huge argument – static functions have translation-unit wide scope. If you run out of names in a single translation unit you might want to consider splitting that translation unit. If what you want to do is to have nested functions where the inner function cannot access the stack frame of the outer function – that would be easy to implement but doesn't really pose enough advantage to warrant an expansion of the standard. Also, the issues I pointed out in the parent comment still apply.
The answer is the SCOPE. Variables declared in a block, like a function, are only visible to that block. When you are calling prime AGAIN (recursively) you are creating a new frame, and the new block has a different x. Exception is static, which behaves like global (check out readelf from your files.) You could also just follow your won instructions to see how computer deals with it. So in this example you start in main: main -&gt; prime So you start executing prime. First thing you see is x=2. So you write it down in the memory. later you do some comparisons and then you call prime: prime -&gt; prime So you start executing prime again, and what is the first thing you write down? That x=2. Even though it has the same name as other x, it is a different variable. If you are using some GUI based developer tool you can start a debugger and you can see what is exactly happening in the computer's memory. If not there is a tool called GDB, but with this one you first have to checkout the commands that are available for the debugger. I hope that helps, but for more information go to wikipedia and check out variable scope. 
I'm sorry, I didn't realise you were an expert programmer from day one... fucking ass. I realise my code isn't great, but I only started Monday, so cut some slack, and realise that everyone starts from the bottom rung, and learns from there.
As others have said, indentation matters a lot... as no one else has mentioned, it can be done for you. Check out the tool "indent" (available on most *-nix stuff). Also, some editors can help with this. Without *completely* changing your program (I did change several things), I restructured what you have as this, which works (though it could still be vastly improved...): #include &lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;stdlib.h&gt; int isPrime(long long val) { long long divisor; long long stop_at; if (val &lt;= 1) { return 0; } else if (val == 2 || val == 3) { return 1; } else if (val % 2 == 0) { return 0; } stop_at = (long long)sqrt((double)val) + 1LL; divisor = 3; while (divisor &lt;= stop_at) { if (val % divisor == 0) { return 0; } divisor += 2; } return 1; } int main() { long long tar; long long sq; long long fac; printf("\nSpecify a number between 2 and 1'000'000'000'000\n\n"); scanf("%lld", &amp;tar); sq = (long long)sqrt((double)tar) + 1LL; for (fac = sq; fac &gt;= 2; --fac) { if (tar % fac == 0) { if (isPrime(fac)) { printf("\nThe Largest Prime Factor is %lld!\n\n", fac); return EXIT_SUCCESS; } } } printf("\nNo prime factors found. (Was the input value prime itself?)\n"); return EXIT_SUCCESS; } I'm hoping that this is a useful transformation that you can compare with. Here is an example usage: Specify a number between 2 and 1'000'000'000'000 9999999999999999 The Largest Prime Factor is 5882353!
Yeah, you're right; I just got that wrong. I was thinking that [] meant something special in the expression, implying which one was the pointer and which one was the integer, but it clearly does not.
The use case is mentioned in the text -- a struct with a flexible array member. Such a struct cannot be instantiated as `struct foo f`, because the whole point is that you want to allocate extra space after the struct for the last member to grow into, hence the need for the extra `size` parameter. 
Formatting is really easy. Here are a couple of simple rules that make your code 100% more readable: 1. Put spaces around binary operators (e.g. 1 + 2, a = b). Do not put spaces between a function and it's arguments (e.g. printf("foo")). Put one space after a comma or semicolon. Do not put spaces after unary operators like !. 2. Everything that belongs to the same block (the things you surround with curly braces) is indented by the same width. If you start a new block inside another one, it is indented one tab further, like this: int main() { level_one_statement(); another_one(); { level_two_statement(); another_one; } } It's very important to do this as it makes it much easier to follow what the code is doing. This is perhaps the most important rule. Also, the closing curly brace generally goes onto its own line. 3. Place a space after keywords that look like function calls like return, if, while, for, switch, and do. This makes it easier to distinguish them from function calls. 4. Place a line break betwen the closing parenthesis of a function definition and the opening curly bracket of the corresponding block. 5. Place an empty line after variable declarations. If a function does not declare variables, place an empty line just after the opening curly brace. 6. For names, use only lower-case letters, numerals and underscores. Names that begin with underscores are reserved and should not be used. Make global names descriptive and local names brief. Give names to your variables that speak for themselves. 7. Comment things that are not immediately obvious. Your comments should explain what the code does, not how it does what it does. Comment not only for others but also for all your future selves who forgot what the code is supposed to do. If you expect help, please go the extra mile and format your code. It's the single thing that will make others not skip your questions. Many people feel insulted when presented with unformatted code as it shows that you put absolutely no effort into it. Being a beginner is not an excuse for not formatting code. Even the textbooks do so.
That's one use case I mentioned. The example in the code is for a type that is only forward-declared, often called an opaque type. Used in libraries quite a bit to allow the type to be changed without breaking the ABI.
&gt; while char is free to alias any object, any type cannot necessarily alias char. I'm not sure I understand this - I would assume aliasing is a bidirectional property?
The reason is probably that a single `char` pointer would throw strict aliasing optimization out the window for *every* pointer in that function.
I copy &amp; pasted it into codeblocks, and your program gets stuck in an infinite loop if you input anything bigger than 999. 999 works fine, 1000 does not. I checked with the debugger and you need to decrement `index` somewhere (it gets stuck in the `while (index &gt; 0)` loop)
Just a note: 100 is spelled `one **hundred**`. You have an extra "e" in there. I can tell English isn't your first language, so it's not a judgment or anything. Just helping. :) Line 92: The `else` is unneeded. Otherwise I like how you used the enum to store your data. Simple and workable. However, the main loop feels a little messy. I'm not sure how I would do it, and it seems to work, so you must've done something right! :) 
That doesn't sound right, it works fine for me (i don't use codeblocks though, but I suppose that shouldn't make any difference). I decrement index with the function GetDigits that's implemented right below the function translate. Did you copy that too? 
I just ran the program via Ubuntu (Linux) trying both 1000, 1001, 1002, 1000000, 1000001 and all of these works perfectly fine for me; even copied the code i uploaded and recompiled it - still working. So that's really weird.. I wonder why that is, anyone else had this issue?
Hm well I don't know. I compiled it on Windows
Oh yeah, that's right! Is that rather an aesthetic thing or are there more benefits removing the else notation? Thanks for pointing that out!
Compiled using clang on fedora. Generally works fine but large numbers have an issue. Is there a limit? e.g.: Enter an integer: 1000000000045 two billion one hundered fourty seven million four hundered eighty three thousand six hundered fourty seven 
What's output is INT_MAX and OP is using an `int`, so yeah you went outside of the limit.
iconv is part of POSIX, not C89. Important difference.
It may be part of POSIX, but, that doesn't preclude the possibility of him using it. What kind of a moron sticks to using strictly C89 interfaces. It is quite likely he can find a library to implement this functionality without reinventing the wheel.
OP asked how to do this in C89. POSIX is a superset of C89 and the function you wanted OP to use is not part of C89. Instead of rambling about how POSIX is ubiquitous (it isn't. Ever seen a microcontroller that implements POSIX?), you could have provided a factual answer about how to emulate the part of iconv(3) OP needs. Instead, you chose to be unhelpful.
&gt; What kind of a moron sticks to using strictly C89 interfaces. The morons who want their software to be extremely portable?
What do you mean by "encoding"? Do you mean conversion between these encodings? What's your actual use case?
&gt; And yes, I have seen microcontrollers that implement POSIX. I worked on one that got deployed to Mars. Must have been a huge one.
Yeah, pretty huge. Like, from another planet.
[This problem is begging you to use a stack](https://gist.github.com/cleure/4758cc9d7a7d6d76362a). Much simpler math, absolutely no floating point, simpler logic, and guaranteed O(N) runtime (with N being the number of digits, ala floor(log10(number) + 1)).
There is always going to be some contention here, many people already avoid typedef on principle. That said, what you're doing is fairly common practice. The Linux kernel uses it's own shorter types u8/u16/u32/u64, technically these predate C99 &lt;stdint.h&gt;. Unfortunately, many developers have adopted these for userland applications without the appropriate stdint typedef mappings, or worse, just map them to unportable primitive data types. It may be possible to configure your IDE to auto-complete stdint with a special combo, if you're unable to deal with the inconvience of a few extra key keystrokes.
What's wrong with the C99 typenames? If you value clarity of code to communicate to other programmers, don't introduce gratuitously different names. Every C programmer will know what a uint32_t is. Also, those extra typedefs are lines of code which don't directly solve your problem. It is bad style, like unnecessary words in a sentence or chartjunk on a plot. 
&gt; There is always going to be some contention here, many people already avoid typedef on principle. That said, what you're doing is fairly common practice. Avoiding typedef isn't answer here because its indirection is serving an essential purpose: to map a stable name to an implementation-defined type. uint32_t might map to unsigned int, unsigned short, unsigned long, unsigned char, or some special compiler-specific type. The only alternative is a macro (which doesn't obey scope) or to make the code dependent on a certain compiler/platform.
Most generally, you're concerned about the convenience of *writing* your code. You want to achieve this by using non-standard names for the types. This comes at a cost for everyone *reading* your code who knows the standard names but not necessarily your personal ones. Standards have a lot of value for making code more accessible and interoperable with other code. I wonder whether your environment has aliases where when you type one thing, it replaces it with another once you put a space or other non-identifier character. Sidestepping your whole question, often I see code use these types where it's not appropriate. Do you need a type with exactly that many bits, and with unsigned overflow characteristics? Often most of the code can use *int* or *unsigned int*, and then pack and unpack them into four-byte integers in the desired byte order when going between external representations.
Agreed. I guess I interpreted "many people already avoid typedef on principle." as they don't use it. I'm trying to find exactly what "avoid x on principle" means but failing (usually the ESL boards have an explanation).
http://www.reddit.com/r/learnprogramming/comments/2ckbfc/c_sorting_an_integer_within_an_array/
So I tried doing this, where numpass is the number of passes, sortnum is the number of integers in the array inputted by the user (sort[]), and I am splitting each number into the array part[]. How do I get the number of integers in each array for part[] so I can create a for loops for it? for (numpass = sortnum - 1; numpass &gt;= 1; numpass--) { for (x = 0; x &lt; numpass; x++) { part[x] = sort[x] % 10; sort[x] /= 10; } } 
Why are you doing anything with an *array* of integers entered by the user at this point? Your aim should be just to write a program that can sort the digits of a *single* integer. There's no point in trying to work with an entire array of user input until you can successfully work with a single integer. You can figure out how to extend the program to sort the digits of each integer in an array later. Likewise, you shouldn't jump right in and try to write a program that can sort the digits of an integer. You need to break that task into smaller tasks. The first smaller task is to split an integer into individual digits. So don't write a program to sort the digits of an integer until you can write a program that can successfully split an integer into individual digits. Don't try to do everything at once. You need to break the task down into smaller tasks, and break those smaller tasks down into even smaller tasks, and so forth. Then focus on those smallest tasks one at a time. Write a small program that just does a tiny piece of the whole problem, and make sure that small program is working correctly, before you move on. You can't write the whole program all at once. So your first goal should be to write a program that can split a single integer into individual digits. Can you do that?
&gt; What kind of a moron sticks to using strictly C89 interfaces. You may be completely oblivious to the software development world, but you should still know that just because a new standard is published it doesn't mean that all the software platforms in the world are magically updated to the latest and greatest, and new implementations and upgrades magically descend from the heavens. Moreover, C99's adoption rates are very thin. C99 hasn't even been adopted by major compiler makers such as Microsoft, in spite of the company controlling the standardization process. So, anyone who has to use C to write more than pet projects in his weekend warrrior moments is forced to limit his choices to either targetting C89 or wasting his time tracking exactly which platform has to be supported and what features and limitations it can count on it. And if time has any value, the default choice is targetting C89.
&gt; C89 doesn't provide you with very much, and that leaves you writing lots of code yourself.. Welcome to the software development world. Regarding the original question, are you actually able to help? Because posting comments like "gosh you need to write code to do that" adds nothing to any discussion.
&gt; Why reinvent the wheel coming up with yet another new interface? Because iconv isn't available in some platforms, and the software needs to run whether iconv is there or not. What's actually available in some platforms is accessing byte streams and being able to process them. Moreover, if a task is to parse long byte streams in an efficient manner, whether its in a platform with all the processing power in the world or the tinyest embedded toy, then it doesn't make any sense to add an arbitrary conversion layer between the data stream and the parsing.
Sorry for not being more precise. I'm trying to figure out what's the best standard data type (or data structure) to store raw strings following the UTF-8, UTF-16 and UTF-32. The use use case is that a raw string stream is received, which is encoded following one of those character encoding schemes, and the stream has to be parsed. For UTF-{8,16,32}, the c89 standard indicates that the char, int and long int (respectively) comply with the data storage requirements. Nevertheless, there's more to this than data storage requirements. Due to endianness issues there may be advantages in encoding each UTF-16 and UTF-32 code unit as a set of char objects. If anyone has any experience in this field, any suggestion is appreciated.
&gt; C99 hasn't even been adopted by major compiler makers such as Microsoft Latest Visual studio supports c99.
How about wint_t c = fgetwc(filestream or whatever)? With appropriate setlocale(LC_CTYPE, "UTF-8"). That's what I use for UTF-8 at least. 
I wrote this post asking why it is bad style described in detail since on the IRC chat I was on yesterday just yelled at me :). A u32int and uint32_t are not too different and introduces little unclarity to the code. I would interpet their usage as a style difference. A good example would be, would you call using Lisp coding style in C a bad way to communicate to other programmers. Lisp C coding style is a legitimate style and all it requires is getting used to it, so does the usage of u32int over uint32_t.
Try looking at how [ICU](http://userguide.icu-project.org/strings), basically the reference unicode implementation, does it.
How exactly is the input encoded? In what encoding do you want to represent your data internally? I highly suggest you to use UTF-8 for your internal encoding. It's quite easy to iterate over an UTF-8 encoded string getting individual characters along the way. Also, it takes much less memory than UTF-32 and isn't such a huge mess as UTF-16 is.
He was talking about C89. fgetwc is not part of C89.
No, the compiler is not fixing anything for you. I may be missing something but you are probably just getting lucky. You machine won't seg fault at run time unless you do something that makes it unable to continue: dereference a NULL pointer for example. Writing or reading arbitrary memory space will only fail if there is an actual problem. current-&gt;children[-58] is just dereferenceing the memory sizeof(children) * 58 before the pointer current-&gt;children. Depending on what is there you could just be getting lucky (it's probably part of the heap that you either already use for something or doesn't have anything critical to your program). Run your program under valgrind to see what is wrong. 
C has no run time array bounds checking. As noted elsewhere, it is only luck that there is no segfault.
&gt; Why would this not set fault at run time? You are never guaranteed a segfault. Your question shows that you are looking at this the wrong way. The C&amp;nbsp;standard does not guarantee that if you do something wrong you will get a segfault. The C&amp;nbsp;standard only guarantees how the program will behave if you write your code *correctly*. By attempting to access an array element outside the bounds of the array, your program has *undefined behavior*, which means that you have absolutely no guarantees about the behavior of any part of the program. The program could do anything at all—it might crash immediately, or it might crash later, or it might run correctly, or it might continue running but produce wrong results. You, the programmer, have violated the contract between programmer and compiler by not following the rules in the C&amp;nbsp;standard (which prohibit attempts to access array elements outside the bounds of the array), and therefore the compiler has no obligations to produce a program that behaves in any particular way.
Thanks. I did not do this intentionally but realized it after the fact that I needed to specify a certain index value when encountering an apostrophe. I see now that it must just have been luck that an index value of [-58] in an array of size [27] did not break the program. Valgrind also showed no error or leak. Being new to C, I wanted to see if I was missing something obvious with respect to an erroneous index value that may be getting "fixed" during compilation. Clearly that is not the case.
I'm still curious as to what kind of code involves such regular use of these types that a shortcut is a significant time saver.
total = m * (m + 1) / 2;
Seems a [bit off.](http://codepad.org/qvZz6Wm9)
And thank you too, you had the same answer, it's just that /u/zomgreddit0r got there first. It took the particular function (running 10 million times) from 18.5ish seconds to about 0.1 seconds.
Explanation [here](http://nrich.maths.org/2478)
So you can save a few keystrokes? I GUARANTEE you the bottleneck in your code composition is not typing out `_t`.
More explanation, and various ways to arrive at the result: http://betterexplained.com/articles/techniques-for-adding-the-numbers-1-to-100/
If valgrind doesn't show an error then the -58 reference is in your allocated heap space. You can add a call that prints all of your heap space and you will see what is getting overwritten 
Problem 1. getchar() Returns a ASCII value. So, when you print it with"%d", you are printing the decimal value of the ASCII code. You really want to use "%c". Problem 2. What is "b" for? Problem 3. Your loop fetches a char from stdin and then you throw it away in the == EOF test. Your need to save it so you don't have to do another getchar() inside the loop.
I forgot to take out the b int from something i was trying earlier. So i use getchar() to get the character from stdin and that converts it to an int with the characters ascii value. shouldn't I just then be able to print that value and loop over the whole thing until EOF occurs? I tried: #include &lt;stdio.h&gt; int main() { char c = getchar(); while (c != EOF) { printf("%c\n", c); } } but then my code just does nothing..
I got it to work! using a completely different approach: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define N_MAX 100 int main() { char line[N_MAX] = {'\0'}; int c = 0; int n = 0; c = getchar(); while (c != EOF &amp;&amp; n &lt; N_MAX) { line[n] = c; n += 1; c = getchar(); } for (int i = 0; i &lt;= n - 1; i++) { printf("%d\n", line[i]); } putchar ('\n'); return EXIT_SUCCESS; }
Don't ever assign getchar() to a char. A char cannot hold all characters and also EOF. Next, even if you use an int for c, how could your loop ever stop if c is not EOF?
Consider that the legend tells that Gauss discovered this formula in primary school :)
I liked your original approach better. #include &lt;stdio.h&gt; int main(void) { int c; while ((c = getchar()) != EOF) { if (c != '\n') printf("%d\n", c); } return 0; }
Place for spaces before each line to format them as code.
This, [Arithmetic Series](http://mathworld.wolfram.com/ArithmeticSeries.html) in Wolfram, it's explained well!
No. 
It's probably a lot faster than 0.1 seconds unless you're using a 1960s CPU running in a freezer
A little bit of context might be helpful and it might open routes for better solutions. *Why* are you adding consecutive numbers? What's the significance of 10,000,000? How big might "m" be? (i.e. would it be possible or advantageous to trade space for time and pre-compute the numbers and store the answers in an "m" sized lookup table.) Are there particular values of "m" that might be more common? Would caching common values (or already calculated values) help? Is the start always "1"? Might there ever be gaps in the numbers you're adding?
Why would accumulating them into an array (with limited size, and therefore its own problem...what happens when you test with more than 100 characters) be better? Think about what you're trying to do as you're trying to express it in C.
I don't really understand the question -- of course you can address individual bytes in standard C. That's what `char` is, an integer type that is one byte. The standard does not specify the width of a `short`, but it requires that it's large enough to hold at least a 16 bit value, and that `sizeof(short) &lt;= sizeof(int)`. In most cases that means it's a 16 bit integer. 
We can use int8_t, int16_t, int32_t and int64_t today! With all compilers! It's amazing!
If you have size restricions using char would be beneficial. Using int will likely give you better performance. In this case unsing a smaller type will give no advantage because the union's size is defined by the largest member, which is equal or bigger than int. Note that since C99 there is a _Bool type. 
No, because Value is a union, so all instances will take up the same amount of memory as the largest member.
But if that's the case then how will I feel superior to Linux?
Not sure what you mean, but functions in C must be at least declared above main. They can also be implemented there. Look up styles and follow the guide that suits you or your school/company follows.
I mean if there's a function, macro or constant that is not directly used by main; but used by other functions that main is using. Is it then better to put these function declarations, constants and macros (that main doesnt need directly) below main and right before they are actually needed, or should all prototypes, constants and macros be declared in the start of the program - even though main don't need access to all of them? (And if it wasn't already obvious I'm intending to have main as the first function)
Yes, but that's not my question. My question is if I have the current situation: main: uses the function foo() foo: uses the function bar() Main needs to have foo() declared, but not bar(). Is it still "better style" to declare both foo() and bar() before main, or should one only declare the functions that main acually needs (in this case foo) and then declare bar() right before foo() is implemented?
Define better style :P Again it depends which guide you are following. If they are asking you to declare functions in certain manner do it the way they ask you. Usually you would pull in functions from the .h file which is above main and the local functions are static. Check out the guides here: http://www.maultech.com/chrislott/resources/cstyle/
Thanks for link :)
&gt; Does this mandate that the smallest C data type that the Lua VM can use is an int, or can we go lower and use a short, byte etc? This is a Lua question, not a C one. It depends on how it uses the members, what it attempts to store and retrieve. What is your practical goal? Is your program too slow, using too much memory? Are you attempting to learn more about Lua and/or C by experimenting?
&gt; This is a Lua question Without context, it might seem so. I'm only interested in why any VM would use a C int to store a boolean. &gt; What is your practical goal? Just academic.
You can still feel superior. MSVC does not implement C99.
Word-wise memory access (i.e. access to variables of type int) is faster on many architectures than byte-wise access. The union is at least as large as an int anyway (because of the pointer), so why go for a smaller yet slower type?
&gt; I'm only interested in why any VM would use a C int to store a boolean. Basically, int was how you stored booleans, and doing so didn't pose any relevant costs in terms of space/speed, so that's what they use. About the only reason to use a different type is to save memory, where you might pack CHAR_BIT booleans inside each character of an array. On my machine (x86-64) _Bool is one byte, so using the standard C99 approach it's already only using a byte for a boolean in memory. This would make no difference in memory usage since your example puts it in a union, whose size is that of the largest member.
I see. I didn't know about the memory access speed thing.
It's a union that includes pointers, so there's no reason to go smaller than an int. Those pointers are what's going to determine the memory usage of this data. Also, even if it was a char, it's going to be handled as an int when you use it. 
My god, OP is asking a style question, not a correctness question.
If the source file containing main() is so large that this is an issue, it would probably be better to move those helper functions into a separate source file. And as for what goes in a header, *only* that which is needed by *callers* of the functions defined in the corresponding source file. Don't put internal things in the header unless the caller needs them (e.g. a public struct includes an internal one and thus needs its definition in the header). This includes #include directives; only those needed to process the header file.
Gah! headers[1] and you are accessing element 1 of it. That's a big no no. 1 means it only has 1 element, element 0.
Yes; everything scoped to the file goes at the top of the file. That way you know where to find it.
I'd say chapter 5 here is a pretty good reference to follow regarding typedefs. [Linux Kernal Coding Style](https://www.kernel.org/doc/Documentation/CodingStyle)
Thanks!
How would you want it to work on logical values?
Unless there's no difference between logical XOR and the XOR-operator; there is. In C XOR-operator is " ^ ". For more information regarding bit wise operators in C, head over here: http://en.wikipedia.org/wiki/Bitwise_operations_in_C 
You might want to allocate space for the new node, instead of dereferencing a NULL pointer... sln_node* n= NULL; n -&gt; key = curr -&gt; key; 
**tl;dr:** Use ``^``. When given "true" (1) or "false" (0) values, the ``&amp;`` and ``|`` operators behave very much like the ``&amp;&amp;`` and ``||`` operators. Practically speaking, one *could* use ``&amp;`` and ``|`` in many places that ``&amp;&amp;`` and ``||`` are used. (As an exercise, verify for yourself that the "logical" and "bitwise" operators will result in the same behaviour when used with simple values in an ``if`` statement. Recall that ``if`` views any value which is non-zero as "true".) There is one key difference though: short-circuit evaluation. Suppose you have two functions, ``f()`` and ``g()``. The expression ``f() &amp;&amp; g()`` will only result in ``g()`` being called if ``f()`` returns a "true" value; if ``f()`` returns "false" then the result of "false AND anything" is always false. Sometimes it is desirable that ``g()`` be called even if ``f()`` returns "false". This is usually because ``g()`` has some side effect which must happen independent of ``f()``. In this case one could either a) assign the return values to variables and use ``&amp;&amp;`` or b) (and less obviously) use ``f() &amp; g()`` which does not short-circuit. So, ``&amp;&amp;`` does not evaluate its right-hand side if the left-hand side is false because false AND anything is always false. Similarly ``||`` does not evaluate the RHS if the LHS is true because true OR anything is always true. **BUT** what would your hypothetical ``^^`` operator do? Remember that the practical difference between ``&amp;&amp;``, ``||`` and ``&amp;``, ``|`` is the short-circuiting. Can one do that with XOR? Can one say that "true XOR something" or "false XOR something" will always have a known value? No, you can't. And, hence, there is no need for the "short-circuiting" operator ``^^``.
 if ((c != ' ') &amp;&amp; (c != '\t')) putchar(c); What I want is to print ``c`` if ``c`` is not whitespace OR a tab char. ALSO, in my code, why ``&amp;&amp;`` worked instead of ``||``?
There's no comparison-operator like that. However, if i understand what you are trying to do correctly, this should be equivalent given A and B are statements that can either be true or false: ((A &amp;&amp; !B) || (!A &amp;&amp; B))
I mean "logical" not "bitwise"
BAHAHAHHAHA. You want some gold?
Why do you care? Tons of people ask for help online. It is simply part of the learning process!
Yes, yes thank you. I realized it just now. :))
Help me plz.
I'm taking a stab at this too, hope you don't mind. Increment `x` and add `y`? I believe it should be left to right but I don't know which has higher precedence `+` or `++`. So I guess it could also be `x` plus incremented `y`?
It's not about precedence, but about tokenization. C has a "maximal munch" principle to tokenization, so `+++` is always `++ +`, regardless of surroundings. 
`(!a) ^ (!b)` gives logical XOR of `a` and `b`.
Interesting, thanks.
If you actually take the time to try to solve the problem first and post your code with an explanation of what you're stuck on you might actually get some helpful responses. Simply asking people to do your homework for you is not the right way to go about this.
``x+++y`` will indeed be parsed as ``(x++) + y`` because tokenisation happens first before any parsing and tokenisation is a "maximal match" process. Now, consider the following: int x = 1; x = x+++x; What is the value of ``x``?
Or `(!a) != (!b)`.
You need to malloc n!!! Now, if you want each key to be visible twice (not sure if that's what you mean by repeat) you have to keep in mind that you are appending a node after current node without checking where the next node was, so you lose the pointer to the rest of the list. Also, you move current only once, placing current in newly created (copy) of the node. This can go on until you run out of memory and you will just have a list with same key over and over again.
Logical XOR is the same as logical "not equal to." So just use `!=` with Boolean values. Because C treats all nonzero values as true, you might have to do `(!a) != (!b)` to accommodate cases like `a == 1`, `b == 2`, for example. EDIT: But if the two operands of the XOR are the results of comparison or logical operators (`&lt;`,&amp;nbsp;`&lt;=`, `&gt;`, `&gt;=`, `==`, `!=`, `&amp;&amp;`, `||`, or&amp;nbsp;`!`) then you don't have to worry about putting the&amp;nbsp;`!` there, because the results of these operators are always 0&amp;nbsp;or&amp;nbsp;1. So if you want to express (a&amp;nbsp;&lt;&amp;nbsp;b)&amp;nbsp;XOR&amp;nbsp;(x&amp;nbsp;≥&amp;nbsp;y), then just write `(a &lt; b) != (x &gt;= y)`.
3?
&gt; The difference ignoring short-circuiting is: &gt; &gt; 1 &amp;&amp; 2 == (!!1) &amp; (!!2) &gt; 1 || 2 == (!!1) | (!!2) &gt; 1 ^^ 2 == (!!1) ^ (!!2) &gt; &gt; XOR just happens to be the only one of the three that gives the wrong answer if you remove the '!!'. No: `1 &amp; 2 == 0`, so AND also gives the "wrong answer" if you remove the&amp;nbsp;`!!`.
Oop!! I'm not sure how I missed that, I wasn't paying attention. You're completely right, I'll add an edit to my comment.
&gt; strcats() of the form: strcat(a, b) Aren't all strcat calls of this form?
The way I understand it, `strcat` should generally be avoided, in favor of `strncat`. Even then, one should probably do a bounds check on tte destination string/buffer to ensure there's enough room for everything. I'm not an expert so take this with a grain of salt.
``3`` x = (x++) + (value of x after increment ) (I cheated) 
Yes, I realized that when I run this code ``printf("%d", (c != ' '));``` prints either ``1`` or ``0``
Nope, it's undefined. It could be anything or nothing. The compiler could literally delete your entire hard drive and send rude pictures to your mother and still be within the letter of the standard. The C standard mandates no order on evaluation in expressions: in the expression ``f() + g()`` the compiler is free to call ``f()`` and ``g()`` in whatever order makes sense to it. Thus in ``(x++) + x`` the compiler is free to look at ``x`` before doing ``x++``. Now is the right time to point you to this set of blog posts: http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html
See my reply to /u/zjhun who also suggested 3.
&gt; I agree with everything you've said, but I think the '^^' operator would still have use. You're right in that it can't be short-circuited, but '^' doesn't act the same way if you consider a logical XOR vs. a bitwise Yup. I admit to more than a little bit of weasel wording above by using "simple values" to avoid talking about cases other than 1 or 0. :) 
Do your example exists in real world? I mean, I hate ambiguous questions like yours. I've read somewhere to try not to be ambiguous in writing code I do even add parenthesis to separate expressions, even though I know the order of precedence of operators. Tell me they don't.
&gt; Do your example exists in real world? Do you mean, "do people write code which relies on undefined behaviour in real world systems?" Yes, yes they do. It's relatively hard to avoid. Even ``a + b`` is undefined if ``a`` and ``b`` are signed integers with the right values. C gives one much power but much danger. If you write something in C which means "go forth and scribble over random bits of memory" then the compiler will trust you know best. Humans are very bad at knowing best, unfortunately.
&gt; Yes, yes they do. I wanted to cry 
[Here is the comment](http://www.reddit.com/r/C_Programming/comments/2c2zgc/i_made_a_small_program_that_stitches_http_headers/cjc3p81?context=3) it seems. 
&gt;just stick a null in the nth byte so you know how long it will be Because the rest of the string just doesn't matter. I swear, some of the suggestions I see...
strncat silently truncates. In most situations, truncation causes incorrect operation and one wants an error instead. strncat won't generate this error for you, thus the recommendation to do the bounds check yourself.
Even if strncat is safely used in the current program, it's fragile and easy to cause it to be unsafe without any noticeable evidence.
Yep, if truncation isn't a problem, one can replace the whole function with out [0] = '\0'; Little worry of the output buffer being big enough either.
For this example, the problem is that the program's basic definedness (not even correctness, just whether it invoked undefined behavior, which can manifest in any way imaginable) depends on multiple things being consistent, without any checks of that consistency. Any time any item is changed, the programmer must remember to verify consistency (and not make any errors doing so).
It's probably even easier to use strlcat. It may not be part of your libc so you may need to grab a (freely available) copy of the function for yourself.
I didn't know that `strncat` did that. Good to know!
Try this: char * find_num(const char* c) { char * p; p = c; while (p[0] != '\0') { if ( p[0] &gt;= '0' &amp;&amp; p[0] &lt;= '9') { break; } p++; } return p; }
Use an anonymous union for aliasing within the struct or if you know the data doesn't overlap e.g read bytewise to s % sizeof(size_t) &amp;&amp; *s and then ws = (size_t *)s; is fine.
This will segfault when passed NULL
It's actually before it even starts reading. You tried to dereference a null pointer in the condition of the while loop. Instead, you need to assign something to p before you start the loop. Try this modified setup: char* p = &amp;a[0]; while(*p != '\0') { //process the current char ++p; //you can increment pointers without assigning an address to them }
You are setting p to NULL then immediately trying to dereference it, that is why you get a segfault. You need a case when there is no number found (probably return NULL)...try posting the whole code since you say something about s but that's not in your snippet.
const char * means the char is const not the * (pointer). So you can modify the pointer but not what it points to.
Which is unrelated to the segfault.
What's the best way to take care of this case? Explicitly checking for it before I enter the loop?
That fixed everything! Thank you. I had no idea that C would distinguish between a read only and a read-write pointer. So I'd be correct in saying that because a was called with const char* a, that other pointers have to be read only to make sure we don't mess with it? It's kinda weird because adding const to my p pointer made it happy, but didn't change what I was doing at all.
`const char *` does not "*add const to [your] pointer*", it adds `const` to the **pointee**: `const char *` is a **pointer to const**. `char * const` is a **const pointer**. `const char * const` is a **const pointer to const**.
Yeah, you would have: if( c != NULL ) { while(...) { ... } }
Although it doesn't have to be, on most systems the null pointer is zero. Zero is just the beginning to the virtual address space, and reading from that location doesn't have to fail. Most operating systems trap any read on that location and throw an error, but that is just a convenience for the programmer.
&gt; Here is the comment is seems. That is indeed it. 
Yes, that's it. Of course all calls are of this form, if you only look at the immediate context.
You probably shouldn't load the entire file into memory line by line. You actually end up possibly losing whatever end of line encoding your system does and might convert CR to CR+LF and vise versa. This is an unintended side-effect. I think reading into memory only makes it harder and the way you do it makes end of line boundaries tricky to handle. The state machine in remove_comments_r() is ugly. Check out the following article on implementing state machines: http://www.conman.org/projects/essays/states.html That isn't the only article on it and state/event arrays have been my go-to technique for implementing finite state machines.
Here is my very ugly implementation. It could be adapted for use with a buffer. I think the main loop that strips comments is much clearer, more concise, and overall more correct. There is one special case where we defer printing a forward slash if we think we might be starting a comment. If it turns out we're not starting a comment I print that missing slash. I just wrote this in a few minutes while in bed with my 4 year old sleeping on me so I accept if it is buggy or ugly. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { enum comment_state { CODE=0, LINE_COMMENT, START_COMMENT, BLOCK_COMMENT, END_BLOCK_COMMENT_SENTINEL, END_BLOCK_COMMENT, OUTPUT_SLASH }; enum comment_token { FORWARD_SLASH=0, ASTERISK, END_OF_LINE, ANYTHING_ELSE }; int state_machine[][4] = { /* CODE */ { START_COMMENT, -1, -1, OUTPUT_SLASH }, /* LINE_COMMENT */ { -1, -1, CODE, -1 }, /* START_COMMENT */ { LINE_COMMENT, BLOCK_COMMENT, CODE, -1 }, /* BLOCK_COMMENT */ { -1, END_BLOCK_COMMENT_SENTINEL, -1, -1 }, /* END_BLOCK_COMMENT_SENTINEL */ { END_BLOCK_COMMENT, BLOCK_COMMENT, BLOCK_COMMENT, -1 }, /* END_BLOCK_COMMENT */ { CODE, CODE, CODE, CODE }, /* OUTPUT_SLASH */ { CODE, CODE, CODE, CODE }, }; int state = CODE, token = -1, previous_token = -1; for (int c; (c = getchar()) != EOF;) { switch (c) { previous_token = token; case '/': token = FORWARD_SLASH; break; case '*': token = ASTERISK; break; case '\n': token = END_OF_LINE; break; default: token = -1; break; } // TEST COMMENT if (token != -1) { int new_state = state_machine[state][token]; state = new_state != -1 ? new_state : state; } /* printf("state = %d, token = %d, c = %c\n", state, token, c); */ if (state == OUTPUT_SLASH) { putchar('/'); state = CODE; } if (state == CODE) putchar(c); } exit(0); } 
Also, your program is incorrect. It doesn't correctly treat continuation lines. This is a one-line comment that has to be removed completely; your program only removes the first line: // first line \ continuation line This is a multi-line comment that your program does not detect: /\ * being sneaky here */ Have a look at the specification to understand how comments in the C language work.
so I could say newstructinstanceofstruct-&gt;int = 1;?
well say I have struct new_struct{ int k; }; do I write new_struct-&gt;k = i;?
&gt; int* array = malloc(sizeof(int) * h); If all you want to do is create an array that can be used to hold `h` integers, that's fine.
Well `struct new_struct` is a type, not a declaration of a structure. Let's say you declared a structure of that type like so: struct new_struct s; Then you would initialize it like this: s.k = 1;
Let's hope no-one ever puts /* in a string...
yes, true. edited.
Malloc allocates a static number of bytes, meaning after you call malloc, the array *space* it returns cannot be modified (directly) (see realloc for how to do that). So I didn't understand what you meant by, "decrement/increment h." Similarly, malloc cannot be used to append space (or remove it) from an existing array. 
I don't really understand if by ...-&gt;int you mean to write ACTUALLY int or it is a convention for using an int variable. The former is wrong. As seen in my example, when you have a struct with int x inside, you can use it like this: instanceOfStruct.x = whatever, NOT like instanceOfStruct.int = whatever. The second is obviously wrong, for example what if you have a struct with 2 int variables?
&gt; Similarly, malloc cannot be used to append space (or remove it) from an existing array. However, of course, `realloc` can.
Thanks! :)
Thank you!
Your syntax is correct, but consider writing it this way, instead: int *array = malloc(h * sizeof *array); or, if you really feel the need to add unnecessary parens after the sizeof operator: int *array = malloc(h * sizeof(*array)); That way, if you should happen to change the type of "array" later, your allocation would still be correct.
int is a keyword in c so you can't have a variable called int in your struct. As a couple of people have pointed out you have to name your struct variable. To access a member of the struct you use . or -&gt; the difference is if the struct instance you are using is a pointer or not: typedef struct foo { int bar; } foo; foo instance_of_foo; foo *ptr_to_foo_instance = &amp;instance_of_foo; instance_of_foo.bar = 5; ptr_to_foo_instance-&gt;bar = 7; 
Given how OP is trying to use p, I would have to entirely disagree with you.
Indeed, right now I'm working on some embedded CPUs, and 0x0 is the start of the vector table. It feels weird to not get some sort of fault when dereferencing 0.
Explain to me (pretend I'm a rubber duck) why you would increment or decrement h
You could just do: int array[h]; That might not meet your requirements, but you didn't really give any.
The title makes using malloc a requirement.
Whoops, I reread the content and missed the title.
How did you declare and define the struct?
OP's question was why the segfault happens: &gt; So far when I try go through it, I get segmentation faults. [...] But when I do it, I get segmentation faults. Assuming that the string pointed to by s has a null terminator, can anyone help on understanding why this happens? You seem unable to focus on parts of the problem in isolation. The segfault is due to the null pointer access. Full stop. OP's problem is much deeper than this, and OP's program is brokenness on many levels. Full stop.
That's the point, though -- if you've already done the bounds check and you want to generate an error rather than silently truncate, *there is no reason to use `strncat`*. The only thing you're going to get out of doing a bounds check and then calling `strncat` is a less efficient program.
&gt; The only thing you're going to get out of doing a bounds check and then calling strncat is a less efficient program. strncat gives some robustness. A flawed bounds check wouldn't allow memory corruption, only silent truncation. Given the tendency of programmers to prematurely optimize programs, it wouldn't be surprising if the bounds check wasn't robust or relied on cached information, whereas strncat looks at the actual strings every time.
What happens when that multiplication overflows? 
You know what's less robust and more error-prone than keeping the length of your strings around and doing bounds-checking? The C stdlib's reliance on trusting you didn't forget the NUL terminator. I'm all for `strncat` and the extra safety it provides, but honestly it's pretty confounding that the C programmers visiting this thread think "bounds-check and then call `strncat` because `strcat` doesn't bounds-check" is a sensible idiom.
Why is it sizeof(*array) instead of sizeof(array)? I thought it should be sizeof(array) because he wants an array of ints, not an array of pointers to ints.
I am not a fan of this syntax. I understand sizeof doesn't actually dereference the int, but you are actually calling out for a dereference of an unitialized pointer, which feels like a dirty trick.
Because in the example, `array` is a pointer and `*array` is an int.
I don't see how it's a "dirty trick". It says exactly what it means: "sizeof what is pointed to by array", which is (currently) _int_.
_array_ is a __pointer__ to an int, not an array of ints. So "sizeof *array" means "sizeof what is pointed to by array", which is an int.
Actually, sizeof is an operator.
Your comment only reinforces the point I was making about symptoms and causes; it does not refute it. Further, I now have to point out that writing "Full stop." is entirely contentess, implies a lack of reason in the argument which contains it, and points to a weak mind.
OK, maybe I'm just totally off here. Let's go back to your first message: &gt; const char * means the char is const not the * (pointer). So you can modify the pointer but not what it points to. If OP looks at the usage of const in the code, this will solve the segfault?
 char anotherletter = 'a'; is supposed to be: char anotherletter = 'z';
So, say if I want to cat the string b to a dynamically, I need to do something like: char *a = NULL; char *b = "and more string content"; a = malloc(strlen("string content")); strncpy(a, "string content", strlen(string content")); realloc(a, strlen(a) + strlen(b)); strcat(a, b); [do stuff to a] free(a);
 (anotherletter - 'a' - 5)%26 The part within the parentheses evaluates to -5. Unfortunately the modulus of a negative number does not give the result you expect. There's a trick though: (anotherletter - 'a' - 5 + 26)%26 By adding 26 you make sure the result in parenthesis is never negative. And this does not change the result of the modulo operation.
% is not the modulus operator, it is a remainder. Your math is not right in either case, but the bug only shows with the lowercase letters. 'a' - 'a' - 5 is equal to -5. -5 % 26 is equal to -5 You are then indexing into the array with a negative index You need to change your math
Ok, that makes sense. Thanks!
How is `%` not the modulus operator? By definition, the modulus operator *is* the remainder, your distinction doesn't make sense.
Sigh -21 mod 4 = 3 -21 rem 4 = -1 %, in c/c++, is therefore remainder 
Your code has a bug in that you don't account for the terminating null character when computing the new size, so it's going to invoke undefined behavior. But that aside, you could use something along those lines, but that's going to have a lot of overhead as every string operation requires a reallocation, which can be avoided. What you really want is a dynamic string that maintains both a size and a capacity, and which performs geometric resizing, e.g. struct dynstr { char *data; size_t size, capacity; } struct dynstr *dynstr_new(void) { struct dynstr d; d.size = 1; d.capacity = 16; d.data = malloc(d.capacity); d.data[0] = 0; return d; } void dynstr_free(struct dynstr *d) { free(d.data); } void dynstr_cat(struct dynstr *dst, const char *src) { size_t src_len = strlen(src), new_size = dst-&gt;size + src_len; if(new_size &gt; dst-&gt;capacity) { size_t geom_cap = dst-&gt;capacity * 3 / 2; dst-&gt;capacity = new_size &lt; geom_cap ? geom_cap : new_size; dst-&gt;data = realloc(dst-&gt;data, dst-&gt;capacity); } memcpy(dst-&gt;data + dst-&gt;size - 1, src, srclen + 1); dst-&gt;size = new_size; } ... struct dynstr *str = dynstr_new(); dynstr_cat(str, "foo"); dynstr_cat(str, "bar"); ... dynstr_free(str); (Completely untested, off the cuff code.) 
If you're interested in stuff like this you should look into lexers
Thanks a lot for this. One question about my code: What is the bug? It's not that I forgot the `\0`-byte in the strings, is it? Isn't `strlen()` supposed to account for that, so I should have one extra byte? I wonder, if this is such a good idea, why there aren't simply standard libraries that do this. It seems inefficient that each programmer has to reimplement something like this in his program, just for string handling to be safe. Could you also explain to me what `size_t geom_cap = dst-&gt;capacity * 3 / 2;` is doing? Where do these numbers come from?
No, `strlen()` does not count the null terminator as part of the length. `strlen("foo")` is 3 for example. Geometric resizing means that you multiply the capacity by some amount rather than adding some amount, which gives O(1) amortized performance. The factor used lets you trade off wasted capacity vs. fewer reallocations. 1.5 is a common choice. (Read more [here](http://en.wikipedia.org/wiki/Dynamic_array#Geometric_expansion_and_amortized_cost).)
This will print the complete prime factorization of a number provided on the command line, in order from least to greatest, one per line. Could be trivially modified to provide different output, only print largest prime factor, etc. No need to check square root since factors are automatically prime and loop will only check up to largest prime factor. The downside is that it can get slow if the number itself is a *very* large prime, or if it has a *very* large prime factor. /* TODO: Error checking */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main (int argc, char **argv) { unsigned long maxn; unsigned long prime_factor; if (argc &lt; 2) { puts("Usage: maxpfac NUMBER"); return 1; } maxn = (unsigned long)atol(argv[1]); prime_factor = 2; while (1 &lt; maxn) { if (maxn % prime_factor == 0) { printf("%ld\n", prime_factor); maxn /= prime_factor; } else { prime_factor++; } } return 0; } 
&gt; I want to learn as much as possible! (legally) [Free Programming Ebooks](https://github.com/vhf/free-programming-books/blob/master/free-programming-books.md) There's probably something pertaining to lexers in one of those ;)
Thanks!
Ahh thanks, I thought I should be able to do it without the Arrays but then I wasn't sure what I should be using % with. Finding C really hard to work with coming from Java : (.
&gt; while(fgets(buffer, 80, fp) != NULL){ } That is a loop that continually overwrites the contents of the variable `buffer` for as long as `fgets` does not return `NULL`. Notice that the body of the loop is empty. You read something into `buffer` with `fgets`, and then the body of the loop does nothing, and then you read something else into `buffer` with `fgets`, overwriting whatever was there previously.
&gt; I must also be going of the end of the array b ecause I'm printing random characters that don't belong. That's because you are always printing all 80&amp;nbsp;characters in the array `buffer`, even if the last call to `fgets` read fewer characters than that. You don't want to print all 80&amp;nbsp;characters in `buffer`. You want to print characters from the array until you reach a null character,&amp;nbsp;`'\0'`. That is exactly what the `%s` specifier for `printf` does. So replace this entire loop: &gt; for(int i = 0; i &lt; 80; i++){ printf("%c", buffer[i]); } with just this `printf` call: printf("%s", buffer);
Wow that was really dumb on my part, thanks. 
This part I'm still not sure about. My understanding is that I read into the buffer with fgets until it hits null, then I stop. The body of the loop might be changed in the future, but leaving it blank shouldn't change anything right now as far as I can comprehend (I'm aware I'm wrong, just not sure). My text file shouldn't return null until it hits the very end of the text file, but maybe its returning null every time I hit a new line? Changing the last line in the text file makes buffer take the entire input, eg last line = super super test will print the "super super test".
Ahh okay thank you! So I need some kind of if loop for how many lines I have to read in to get fgets to work? The examples I've seen use while loops &gt;.&lt;;
And they process each line as it's read.
Yeah most of the ones I've seen just print the line. Why is it so difficult to store it all with fgets?
I'd be glad to help, Senior majoring in CS with a concentration in C/C++, message me for my email.
You're not dumb, just learning. It's valuable to make these mistakes now as you'll utilize this knowledge in the future. I had a hard time with i/o programming when I first started, and I'm sure most people did too. Keep programming and practicing. 
What are you really trying to *do* here? If you want all the lines of a file available, you'd need more than a single string. You'd need something like an array of strings, one for each line, and a loop that reads each line into successive elements of that array. But most of the time you don't need that. Which is why this really comes down to *what are you really trying to do?* 
valgrind tells you where the code crashes?
You need to set a breakpoint to break the program from where you can then step the program. Breaking on main would be a good place for small programs.
Use `start` instead of `run`: From the [docs](https://sourceware.org/gdb/current/onlinedocs/gdb/Starting.html): The ‘start’ command does the equivalent of setting a temporary breakpoint at the beginning of the main procedure and then invoking the ‘run’ command.
Well, like it says, the program has to be running before you can step. The `run` command starts execution, but if you haven't placed any breakpoints (and there's no opportunities to `^C` back into the debugger, such as waiting for input) then it will just run until completion before you ever get a chance to return to the debugger. You want to set a breakpoint somewhere in your code. There are lots of ways to set breakpoints and you should read about all of them in the manual.(*) The most basic forms are setting a breakpoint on a function (e.g. `b foo`) or on a line of a source file (e.g. `b file.c:12`). You can also use the `start` command, which is kind of like setting a one-time breakpoint on `main` followed by the `run` command. Once the program is running you can then step through it. You'll want to familiarize yourself with each of the following, as they are all useful in various situations: `next`, `step`, `continue`, `until`, and `finish`. The latter is useful because it displays the return value of a function call. Note that all commands can be shortened as long as it's unambiguous. Then learn about conditional breakpoints, which really make life easier. The `display` command makes it easy to display something every time the debugger stops, and `list` is useful for seeing the source around the current position. `bt` is good for a stack trace, and `info locals` can also be quite useful. There are a lot more things to learn, and gdb has tons and tons of ways to help you, so read that manual. (*) gdb has an [actual manual](https://sourceware.org/gdb/current/onlinedocs/gdb/) which is separate from what you get with `man gdb`, because it's far too long and comprehensive to fit into the man page format.
As the old adage goes... RTFM! From the (non-exhaustive but still useful) man page: run [arglist] Start your program (with arglist, if specified). What would you expect to happen when you run the program? Why would you expect it to halt execution if you don't tell it to? Run is no different than calling `./my_program` outside of gdb (except for the different exec environment and other things gdb imposes, like you will soon see). Well, let's investigate some other commands. break [file:]function Set a breakpoint at function (in file). That's promising. A breakpoint in GDB will pause the execution at the given point. You can tell it a *function name* like main, or you can give it an *address*. break main // Pause execution at the first instruction in 'main' break *0xdeadbeef // Pause execution when EIP = 0xdeadbeef (if it gets there) So try this instead. break main run And notice that execution has halted at the first instruction in main. *Now* you can single step. Another trick- say you want to stop execution right before you call some function in main. Here's a good way of finding where that breakpoint should be. disassemble main // Show the instructions of main // Now find the address of the instruction where you _call_ your function... break *0x[address] continue // Continue execution (program has to have started running already). manual pages may seem archaic and complicated, but they really are the *best* source of information for a program. I strongly recommend you get comfortable reading manpages, as you will need manpage literacy as a serious C programmer. 
That's awesome! I'm not a frequent gdb user, but that is a handy command.
Thanks for the tips. I will take it up
Don't feel bad, i've been using gdb for ~20 years, and didn't know this.
&gt; Why is it so difficult to store it all with fgets? ? Elaborate please.
I found this [answer](http://reverseengineering.stackexchange.com/a/1936) on the Reverse Engineering stackexchange to offer a very, very, informative overview of gdb.
Writing to one member of a union and then reading from a different member of the union yields implementation-defined behavior. The code you have written here is not portable.
If this is true, then it's disappointing. It would also be surprising, considering that there are is no implementation-specific typing involved (nothing opaque whatsoever, in fact). Can you point us to documentation on this subject?
Section 6.5.2.3 of the C99 standard: &gt; With one exception, if the value of a member of a union object is used when the most recent store to the object was to a different member, the behavior is implementation-defined. One special guarantee is made in order to simplify the use of unions: If a union contains several structures that share a common initial sequence (see below), and if the union object currently contains one of these structures, it is permitted to inspect the common initial part of any of them anywhere that a declaration of the completed type of the union is visible. Two structures share a *common initial sequence* if corresponding members have compatible types (and, for bit-fields, the same widths) for a sequence of one or more initial members. Also, no conforming implementation should give the behavior you seem to describe. If `MyColor.is_blue == 1`, then setting `MyColor.is_red = 1` should not cause `MyColor.is_blue` to become&amp;nbsp;`0`. This would violate the semantics of a bit-field.
Since as others have cited, this fails on two accounts, what made the straight forward approach undesirable? color_t MyColor = color_green; MyColor; // color_green MyColor &amp; color_green; // !=0 MyColor &amp; color_blue; // ==0 MyColor = color_blue; MyColor &amp; color_green; // ==0 MyColor &amp; color_blue; // !=0 MyColor |= color_red; MyColor; // color_red | color_blue MyColor &amp; color_green; // ==0 MyColor &amp; color_blue; // !=0 MyColor &amp; color_red; // !=0 
No. Watch these instead and don't read about the man speaking and then it's ok https://www.youtube.com/watch?v=Jlbs8ly6OKA&amp;list=PL76809ED684A081F3 Despite what he's done, these are very good tutorials and seem to be one of the few reliable sources of a good video tutorial on C
Unfortunately I do know about Carl... I've just been sat here wondering whether or not to go through his videos. I may give it a go. Could you tell me why The New Boston's are no good? Thanks for helping this C 'newbie' :)
I'm learning from K&amp;R 2nd Edition book, aka the C Bible. 
C Primer Plus is a book, but it's not dry at all. Download it and try a few pages. It's also for people who are more or less new to computer science, so it might be too slow paced if you know about programming, specially lower level stuff. If you just want something with less CS101 and more learning the syntax and how to do stuff with tons of exercises, I suggest K&amp;R C. If you really want to stick with videos, I don't know what to say (I think it really limits your choices so I invite you to reconsider it). You could do Carl's "CS for everyone", but the truth is that it stops in the middle of nowhere (since he got arrested and all) so you'll just end up with a vague knowledge about some basics. You will pretty much end up with nothing. C Primer Plus teaches a lot of stuff Carl did just as well. 
&gt; C Primer Plus Thanks, I'll definitely check it out! I have read books on other languages that are engaging, I think I just need to find the right one. I'm reading "Learn C The Hard Way" as we speak from Zed Shaw, and it's the kind of thing I can happily read. 
What is it like?
Read through [Learn C The Hard Way](http://c.learncodethehardway.org/book/).
Well I personally haven't gone through the C videos of his so really I guess you could give him a go. I'd find Carl a bit more reliable since he has a decent history of programming whereas The New Boston's page seems to be filled with various how to's on pretty much everything. Sorry I can't give a good answer :(
I didn't know looked it up oh no :(
So far it's been fine and it's probably one of the best C books out there. It's also written by the C authors themselves. Though, I'd not recommend it to anyone that has no idea what computer programming is. I've been through a few languages such as Python, Ruby, C++, C#, etc and even C itself, all of which I only have a noob skill but it was made it easy for me to learn from the book. 
Your insight is still useful! I do wonder about TNB as they do have videos on everything, the whole quality/quantity debate.
&gt; With one exception, if the value of a member of a union object is used when the most recent store to the object was to a different member, the behavior is implementation-defined. This quote is not actually present in the C99 standard. It was carried over from C89 into the N869 C99 draft but removed before publication, presumably because it conflicted with 6.2.6.1 which says (even in the draft) &gt; When a value is stored in a member of an object of union type, the bytes of the object representation that do not correspond to that member but do correspond to other members take unspecified values And in J.1 (Unspecified Behavior): &gt; The value of a union member other than the last one stored into (6.2.6.1) C99 TC3 went on to add a footnote in 6.5.2.3. &gt;*) If the member used to access the contents of a union object is not the same as the member last used to store a value in the object, the appropriate part of the object representation of the value is reinterpreted as an object representation in the new type as described in 6.2.6 (a process sometimes called "type punning"). This might be a trap representation. All of these have been carried forward into C11. edit: last quote was cut off
Ah, okay. I don't actually have the C99 standard, because that costs money—what I have is one of the drafts, which is freely available.
I don't know about the C videos, but the Objective-C videos were just him going through a book (I forget which one at the moment. It may have been the Big Nerd Ranch one) and repeating its contents in video form. But he would leave details out that the book explained and hand-wave a lot of things away with "just do this now and it'll make sense later." Better off with the book, I think! Carl, on the other hand, actually explains everything. Not only that, but he starts at the very bottom and explains fundamentals that seem like they aren't relevant, but then you're introduced to a concept later that clicks immediately because you have that foundational knowledge. However awful he may be as a person (allegedly, I dunno), his tutorials on C are very informative. I'd go that route over TNB.
That sounds crap for Objective-C! Thanks for the info. I may go with Carl but as others have pointed out, he leaves everyone in the lurch and doesn't complete the course due to his current situation. 
Seconded. This was my first source for learning C and it was fantastic. The most practical lessons I have come across without any filler.
Curiosity got the better of me and I looked. God damn.
Best if you want a sweet looking library. Not best if you actually plan on reading it.
[For the lazy]( http://m.waaytv.com/mobile/appnews/accused-child-abuser-carl-herold-facing-charges-in-new-york/article_8cb0a1ca-d6f9-11e3-b1d3-0017a43b2370.html )
From what I've seen of him, thenewboston is an amateur teaching amateurs. There's no depth. You'll probably pick up some bad habits if you learn programming from his videos, so they're not really worth watching. 
Wow, so that's why I haven't see his name on reddit in a while...
&gt; C Primer Plus I picked up the new edition and started going through it as well. Great stuff, it makes sense why this thing has existed in one form or another since the mid 80s. Much better than the other books I looked at for beginners (obviously K&amp;R is great, but it's not helpful at all if you don't have a basic knowledge of programming).
No. * Free all memory that you have allocated with `malloc`, `calloc`, or `realloc`. Free it exactly once, and do not access it after you have freed it. * Do not free anything else.
Cool so that is what I was messing up. Thanks
None of those examples are valid, because none of them used `malloc()`/`calloc()`/`realloc()`. You can't pass any old random pointer to `free()`, you can only pass a pointer that you received from calling one of those functions. 
Automatic variables are... *automatically* allocated and deallocated by the compiler-generated code. Automatic variables are those declared inside a function and without the *static* keyword. One can add the *auto* storage specifier (the opposite of *static*) to be explicit about it. Note that if you have an automatic pointer, only the pointer's lifetime is handled by the compiler-generated code; whatever the pointer points *to* is up to you to manage, if it points to something allocated with malloc/alloc.
What do you mean? 
You only need to `free` if you `malloc`. If you didn't `malloc`, you don't need to (and in fact, must **NOT**) `free` it. When I say `malloc`, that also refers to `calloc` and `realloc`.
Allocation and deallocation don't imply any specific mechanism. Nested function calls are a form of allocation, and the stack pointer *is* an allocator, albeit of strict FILO discipline. It's not the same allocator as used for malloc() and related, which must handle requests in any order.
&gt; When given "true" (1) or "false" (0) values, the &amp; and | operators behave very much like the &amp;&amp; and || operators. Practically speaking, one could use &amp; and | in many places that &amp;&amp; and || are used. (As an exercise, verify for yourself that the "logical" and "bitwise" operators will result in the same behaviour when used with simple values in an if statement. Recall that if views any value which is non-zero as "true".) This is not correct, exactly because any non-zero value is considered "true". Bitwise operators act on bits, as opposed to logical operators which act on this concept of "true". if (1 &amp;&amp; 2) puts("true"); else puts("false"); if (1 &amp; 2) puts("true"); else puts("false"); 
Literally the very first thing I said was "when given "true" (1) or "false" (0) values". 2 isn't one of those. :)
&gt; My point is that "true" isn't the same as 1, as you imply in the first sentence. It is anything non-zero. I agree that true, "true" and `true` are all different in C but I didn't think that the OP would've appreciated a long segue on this! Hence my weasel-y use of "true" and "false" throughout. But, of course, you're right. As developed elsewhere in the comment thread, one would need to decorate everything with `!!` if you wanted to replace `&amp;&amp;` with `&amp;` *everywhere* as opposed to "in many places".
Yes. But please do not split your question into separate chunks unnecessarily, continue all your discussion in one thread for the same problem. Note that the max range of rand() is library dependent. 
Assuming that; * bf is a pointer to a struct * that struct has members a and b * the types of a and b are int[] or int * then yes.
http://stackoverflow.com/questions/1033898/why-do-you-have-to-link-the-math-library-in-c At least try a little research.
thank you, i searched before ask but i search for "-lm" instead of "link" ^^ 
Note that the return value of `rand()%PRIME` is almost certainly not uniformly distributed.
It is just a historical quirk of GCC. Other compilers don't have the same problem (unless they tried to copy GCC's commandline interface!) 
To elaborate, check out http://stackoverflow.com/questions/2509679/how-to-generate-a-random-number-from-within-a-range .
My guess: a long time ago, when memory was precious, the size of the math library was such that you didn't want to link it in if it was really needed. Whereas libc is pretty much needed by all programs. 
Can you really learn idiomatic C from this book?
I'd say that book is okay in any aspects of C programming ;) 
books are heavy yo. I can fit an ereader in my back pocket and forget it's even there! Also, I can read it in the dark.
Not to save size, but to save link time. In most cases with static linking (what was used before shared libraries were common), if a symbol wasn't referenced, its object file in the library wouldn't be pulled in (so no additional size). The more libraries you had listed on the link line, the more work (i.e. object files to load and read) for the linker having to search through to find a symbol. So anything that wasn't frequently used (like libm) was put into its own library to avoid link time costs. Another reason that libm was its own library was you'd pick which libm to link against depending on your architecture. Sometimes libm's implementation was completely emulated using integer algorithms (slower and often lower precision) for those systems without an FPU. Other times different libm's would support different FPUs (x86's 8087 vs. 80287 or the 68k's 68881 vs. 68882). Depending on the compiler, sometimes you picked manually depending on what you expected to run on (e.g. -lm68881). 
If it's that cheap and your teacher suggests it to you, chances are that it's a really good book.
Yes Knuth is awesome but Tanenbaum is also quite a big name and perhaps the suggested book is best as excerpts may be contained in his course material which you can elaborate but using the book. Whichever book you get learn it well as a properly designed data-structure reduces your workload and headaches by a large amount.
Its especially stupid if you search for just a flag, you'll get 0 results and no indication of why. They should at least put "searching for pages without funroll-loops" or something so you know what's happening.
Yes, definitely. Most of Google's search options aren't publicly known, which is stupid because they're so useful. 
Yes. If the suggested book was $80 and a good but different one was $1 it would be significant. But this is cheap.
A bracket class is a type of conversion operator, like `%s` or `%d`. That is, it must be used like `%[...]`. You can't just spew brackets anywhere in the string -- this isn't a regular expression or a glob. Also, you should always be checking the return value -- that's the only way to know whether the operation succeeded. You're getting garbage in the string because only the first conversion was successful and the string value was never touched, which you would have known if you'd looked at the return value. Here's an example: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(void) { char input[] = "43;foobar;$12.34\n"; int i; double d; char s[256]; if(sscanf(input, "%d;%255[^;];$%lf", &amp;i, s, &amp;d) != 3) { puts("Error - scan failed."); exit(1); } printf("i = %d, s = '%s', d = %g\n", i, s, d); return 0; } Notes: - You have to use `%lf` for a `double`. `%f` is for a `float`. - ~~I have no idea what you're trying to do with things like `%20`, but that's just invalid.~~ Edit: brain fart -- that's a maximum width specifier, and you should totally use that to constrain the length and prevent buffer overflows. My bad. Editied the example. - Don't try to extract the newline at the end. Remember that `%d` conversions eat all leading whitespace, so as long as you apply this same conversion format string again repeatedly, the leading `%d` will eat all the trailing whitespace from the previous line. 
I would use read and make a structure and use. If flat txt file use atoi style functions on the fields. If data is already in int for Mr then read is it. Can use fgets as well-my favorite for flat txt files (Sorry wrote on kindle)
Don't forget to seed 
So history, changing this would break builds, and the cost of not changing is minor.
&gt; Another reason that libm was its own library was you'd pick which libm to link against depending on your architecture. This. Also the stackoverflow thread linked above says that one might use a faster one that traded accuracy for speed. So not just hardware, but selectable design tradeoffs without having to alter one's source code.
Well, if you're getting col = 7 after findCity() your problem is most likely in getMap() as findCity() with the input you've given so far produces the correct result (row=0, col=6).
my get map function is void getMap(){ for(int therow = 0; therow &lt; rows; therow++){ for(int thecol = 0; thecol &lt; columns; thecol++){ scanf("%c", &amp;map[therow][thecol]); } } } and map is just a global defined as char map[80][80]= {{'\0'}}; Not sure what could be going wrong. Since get dimensions is run first I assumed it ate the first two numbers 2 10 Is it possible that now what is left is actually \n......E... RRRR..R.. ?
Yeah, probably something like that. scanf() won't eat a newline without being told to do so. I would guess map contains the following: \n......E.. .\nRRRR..R. and you are losing the last two(?) dots. So you should make sure you're properly discarding the newline characters (assuming the input has only newlines and no carriage returns). Also you might want to consider allocating map using the dimensions you read in in getDimensions(). you can confirm that this is what happens by dumping map: for (int i = 0; i &lt; rows; i++) { for (int j = 0; j &lt; columns; j++) { printf("%d ", map[i][j]); } printf("\n"); } This will print the ASCII values of every character your findCity() function iterates over (for reference: \n's ASCII value is 10). Generally I like to debug simple stuff in C by just putting printf()'s everywhere. For this specific problem, my first instinct would have been to put a `printf("%d\n", map[i][j])` just before the `if(map[i][j] == 'E')` in findCity(). Alternatively learning how to use a debugger is a very good thing for more complicated situations.
Mmm I am working on it, most of the stuff I copied here I took out my print f functions, I was chucking printf on everything I was getting back. Normally what I do is I just do things function by function and ensure that one is working before moving on to the next one, but I didn't catch this until far later (once I'm working on moving through the map) :( I'll post again when I fix up my code, but thank you for your help. Using ASCII values is a great idea, I didn't actually think about that. I've been printing them as characters, I should have been tipped off when it was printing new lines without me specifying -_-;
Its also important to note that not only is the memory still allocated, unless you have another pointer to it (another way of finding it), it is essential lost. This is called a memory leak and is loads of fun.
Yeah, especially in a routine that you're likely to call often, like fetching things from a database...
I dont imediately see what is wrong. My gut says permissions on the files when you make them. One thing that would probably be helpful is to catch the return value of fclose and if it has an error get the erno.
Your code is a bizarre mishmash of C&amp;nbsp;and&amp;nbsp;C++. C&amp;nbsp;and&amp;nbsp;C++ are two very different languages. You should be writing either all C&amp;nbsp;code or all C++&amp;nbsp;code. This subreddit, /r/C_Programming, is for&amp;nbsp;C, not&amp;nbsp;C++. That being said, there is hardly ever a need to use `rename` and `remove` in properly written programs. What you should be doing in the `actualizarProducto` function is: 1. Open `"Producto.txt"` for reading and writing. 2. Find the specified product in the file. 3. Seek to the appropriate position in the file and write the new record. 4. Close the file.
A central tool in debugging that's helped me countless time is to relentlessly remove parts of the program until you're left with a very small one that has the same problem. Make a copy of your source, find something that seems unnecessary, delete it, then see if the program still has the problem.
I think I found your error. I surmised that you had an fopen() without a matching fclose(), so searched for each instance of fopen() in the source. I came to this: float devolverPrecio(int codPro) { producto pro; FILE *f; f=fopen("Producto.txt","r"); while(fread(&amp;pro,sizeof(pro),1,f)) { if(codPro==pro.cod_prod) { return pro.precio; } } fclose(f); } It returns a value without closing the file. You're using C++ so could have employed [RAII](http://en.wikipedia.org/wiki/RAII) to avoid the possibility of this. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**RAII**](https://en.wikipedia.org/wiki/RAII): [](#sfw) --- &gt; &gt;__Resource Acquisition Is Initialization__ (__RAII__) is a [programming idiom](https://en.wikipedia.org/wiki/Programming_idiom) used in several [object-oriented languages](https://en.wikipedia.org/wiki/Object-oriented_programming_language), most prominently [C++](https://en.wikipedia.org/wiki/C%2B%2B), where it originated, but also [D](https://en.wikipedia.org/wiki/D_(programming_language\)), [Ada](https://en.wikipedia.org/wiki/Ada_(programming_language\)), [Vala](https://en.wikipedia.org/wiki/Vala_(programming_language\)), and [Rust](https://en.wikipedia.org/wiki/Rust_(programming_language\)). The technique was developed for [exception-safe](https://en.wikipedia.org/wiki/Exception-safe) [resource management](https://en.wikipedia.org/wiki/Resource_management_(computing\)) in C++ during 1984–89, primarily by [Bjarne Stroustrup](https://en.wikipedia.org/wiki/Bjarne_Stroustrup) and [Andrew Koenig](https://en.wikipedia.org/wiki/Andrew_Koenig_(programmer\)), and the term itself was coined by Stroustrup. &gt;In RAII, holding a resource is tied to [object lifetime](https://en.wikipedia.org/wiki/Object_lifetime): [resource allocation](https://en.wikipedia.org/wiki/Resource_allocation_(computer\)) (acquisition) is done during object creation (specifically initialization), by the [constructor](https://en.wikipedia.org/wiki/Constructor_(object-oriented_programming\)), while resource deallocation (release) is done during object destruction, by the [destructor](https://en.wikipedia.org/wiki/Destructor_(computer_programming\)). If objects are destructed properly, [resource leaks](https://en.wikipedia.org/wiki/Resource_leak) do not occur. &gt;Other names for this idiom include *Constructor Acquires, Destructor Releases* (CADRe) and *Scope-based Resource Management* (SBRM); this latter term is over-specific and inaccurate, since RAII ties resources to object *lifetime,* which may not coincide with entry and exit of a scope (notably variables allocated on the free store have lifetimes unrelated to any given scope). However, using RAII for automatic variables is the most common use case. &gt; --- ^Interesting: [^Resource ^Acquisition ^Is ^Initialization](https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization) ^| [^Destructor ^\(computer ^programming)](https://en.wikipedia.org/wiki/Destructor_\(computer_programming\)) ^| [^Memory ^leak](https://en.wikipedia.org/wiki/Memory_leak) ^| [^Comparison ^of ^Java ^and ^C++](https://en.wikipedia.org/wiki/Comparison_of_Java_and_C%2B%2B) ^| [^Resource ^management ^\(computing)](https://en.wikipedia.org/wiki/Resource_management_\(computing\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cjpnvn6) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cjpnvn6)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Good catch. It's also worth pointing out that if `codPro` is not found in the file, then that function (and hence the whole program) has undefined behavior. OP, you should have all warnings turned on in your compiler, and pay attention to what they say.
This would be easier to read if it were properly indented. ;)
Also this code is not portable at all and main should return an int.
&gt; A variable is composed of a value and the memory address that holds that value. A memory address is not a variable because it is composed of one value and that value is itself which is constant. A pointer, on the other hand, is a variable whose value is the reference of the memory address of a given variable. With that definition in mind, a pointer is composed of a value, which is the address of the variable being pointed to, and its memory address as well. Because a pointer is a variable, a pointer can have its value changed when its value is reassigned the memory address of another variable other than the initial one. Also, due to the way a pointer is structured as a variable it can point to another pointer can be pointed to as well. The pointer is then abstractly by means of reference pointing to memory addresses, in essence. Pointers are a data type just like characters, integers and floating numbers are also data types due to the fact that the their value is a reference not the kind of values expressed in characters, integers and floating numbers. Whether a pointer is pointing to a character, a pointer or a floating number, the pointer is of data type pointer — not the data type it is pointing to. Wow. I think this is the most confusing explanation of pointers I have ever read. An *object* in&amp;nbsp;C is a "region of data storage in the execution environment [i.e., a location in memory], the contents of which can represent values." A *variable* is an object that has a name. So a variable is a named location in memory. To say that it is "composed of a value and the memory address that holds that value" is misleading—it makes it sound as though a variable has two parts. But it doesn't. A variable is a named location in memory, and the *contents* of that location in memory may represent one or more values. It is important to distinguish between pointer *types*, pointer *values*, and pointer *variables*. The explanation above confuses these three related but distinct concepts. Pointer values and memory addresses are the same thing in&amp;nbsp;C. The C&amp;nbsp;language has no concept of memory address apart from pointer values. A pointer value need not be the memory address of a variable. It might be the memory address of an unnamed object, or it might be a null pointer. A pointer variable is a variable whose type is a pointer type. Therefore, the value of a pointer variable must be a pointer value. As long as the pointer variable is not `const`, its value can be changed, just like any other non-`const` variable. There are many pointer types, not just one. There is no type that is just "pointer." For every type&amp;nbsp;T, there is a corresponding type "pointer to&amp;nbsp;T." The types "pointer to&amp;nbsp;`int`" and "pointer to&amp;nbsp;`double`" are distinct types, for example.
Run it with valgrind or similar. It has at least one instance of undefined behavior: char* hexValue = malloc(sizeof(char)); //holds a single hex value ... sprintf(hexValue, "%x", rand() % 16); Next, your program hides errors: if (pid &lt; 0) { //failed return 0; } ... exit(0); //shouldn't get here, but just in case } 
Yeah, OP needs to bother to fix code formatting before anyone's going to bother to examine it.
You don't technically have to ensure the first octet is 00, but can be almost any even number (e.g. 02: or 04: ...). Where do you check if the result is all zeros (00:00:00:00:00:00) or (ff:ff:ff:ff:ff:ff) then it's invalid. You could just go as easy as xor'ing each octet of your real mac-address with a random even octet value or generate a full random values with all even octet numbers, but you still need to check for all zeros and all ones. Perhaps you could look at it like numbers and instead of strings and randomize 6 bytes that you convert to a string. 
A couple of issues off the top of my head: You are not freeing 'spoofed' or 'hexValue'. 'hexVal' isn't big enough. sprintf will fill two chars (char and \0). I would just use a local array. 
Fixed it for everyone #include //wtf are these includes for? #include //what are you including?... void main() { int a[100],n,k,i,j,l; int count=0; clrscr(); printf(“enter size\n”); scanf(“%d”,&amp;n); printf(“enter elements\n”); for(i=0;i&lt;n;i++){ scanf(“%d”,&amp;a[i]); } for(i=0;i&lt;n;i++) { k=a[i]; for(j=i+1;j&lt;n;j++) { if (a[j]==k) { for(l=j;l&lt;n-1;l++) { a[l]=a[l+1]; } n–; j–; count++; } } } printf(“\narray\n”); for(i=0;i&lt;n;i++) { printf(“%d\t”,a[i]); } getch(); }
one of the includes is &lt;stdio.h&gt; the other is probably conio.h but i'm not familiar with that extension
Those are good points! I'll think about that and work it in to the program.
Thanks! I did a bit more work on the program since posting it, running it with valgrind made me aware of all 3 of those actually, I'm glad that you verified that for me though.
ok, i've already commented here too many times but now i feel compelled to try to help. OP, why are you posting this? are you looking for help with the algorithm? with style?
Never more than one char? Are you sure? Think about it...
You should only call srand once per program. One significant flaw in having it inside the getMac() function is if you decide to make back-to-back getMac() calls. There is a high likelihood you'll get the same mac.
@crookedk No I am not looking for help. I want to help others in learning C programming. I admit that I have committed some mistakes in the source code But never the less I will soon correct them 
Is the MAC address the *only* identifier provided by a WiFi client (aside from the DHCP assigned IP address)? Are the other identifiers, if they exist, subject to alteration? 
Lots of issues. &lt;conio.h&gt; isn't standard C. The program assumes ASCII (doesn't use &lt;ctype.h&gt; functions). It repeats the capitalization code. It uses gets() so has UB if user enters a string that's too long. Try this as a cleaner approach which suffers from none of the above issues: #include &lt;stdio.h&gt; #include &lt;ctype.h&gt; int main( void ) { printf( "enter string\n" ); char str [100]; fgets( str, sizeof str, stdin ); int i; for ( i = 0; str [i] != '\0'; i++ ) { if ( i == 0 || isspace( str [i - 1] ) ) str [i] = toupper( str [i] ); } printf( "output:\n%s\n", str ); } 
What about that pesky '\0' character?
Is this an elaborate attempt at trolling? This blog entry is so shitty, it isn't even funny anymore.
Now you're limited to 100 chars. My take on the problem: #include &lt;ctype.h&gt; #include &lt;stdio.h&gt; #include &lt;assert.h&gt; int main(int argc, char** argv) { assert(argc == 2); char* str = argv[1]; for (str[0] = toupper(str[0]); str[0]; str++) // always capitalize first char if (isspace(str[0])) str[1] = toupper(str[1]); // this works becasue of NULL terminator return puts(argv[1]) != EOF; } use with quotes: `./a.out "the lazy fox jumped over the brown fence"`
Basically you have to ensure the 1. bit in the 1. byte is 0 which means unicast address - otherwise you're generating a multicast address. And to be nice, you should also set the 2. bit in the 1. byte to 0, since you're not generating globally unique mac addresses. see e.g. http://en.wikipedia.org/wiki/MAC_address And there's blocks of MAC addresses reserved or used for special purposes - See http://www.iana.org/assignments/ethernet-numbers/ethernet-numbers.xml If you generate any of those, ethernet switches might treat them specially.
I'm not really sure what you want to accomplish, but I think you should have a look a mmap.
You don't have to write a new filesystem to store something in memory. You already have such filesystems on Linux (tmpfs...) and I guess there is also something similar for Windows.
I thought so too but apparently not. I was just curious how other people might approach the issue.
Yeah that would be a typical way of doing it but I can't write it to file (whole point of my doing this) and I can't pass raw data to the browser API. Also doesn't help when the html references images. Where does it get them from?
Instead of trying your best to seed `rand()` appropriately you could get some bytes from [arc4random()](https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/arc4random.3.html). If you really want to do things right, instead of `exec()`ing ifconfig, there should be [some sort of OS X `ioctl()` call](http://stackoverflow.com/a/6792388) that accomplishes the same thing. That's what ifconfig itself is doing. 
The API sucks. I can pipe a html file into it from memory but really that is just handing it a string. When it references images or css, It falls over.
You could write the files into a temporary directory during startup and reference them from there. You could also turn all image references into Base64 encoded data URLs.
~150 chars seems to be a barrier (162 for this): #include &lt;ctype.h&gt; #include &lt;stdio.h&gt; int main(int c,char**v){char*s=*++v;if(s){*s=toupper(*s);while(*s)if(isspace(*s++))*s=toupper(*s);}return !*v||puts(*v)&lt;0;} Without error checking, 141 chars: #include &lt;ctype.h&gt; #include &lt;stdio.h&gt; int main(int c,char**v){char*s=*++v;*s=toupper(*s);while(*s)if(isspace(*s++))*s=toupper(*s);puts(*v);} 
What's this browser API you're using? Maybe you could make your program act as a local HTTP server and just direct a real browser to connect to your program. Then your program is completely in charge of how the response data is stored, and keeping it in memory and never touching the disk will work fine.
It might be helpful to state what the program is supposed to do, and what command line arguments you expect. It looks like you are trying to print out a table of sine values with different formatting options, but I'm not entirely sure. Also I think the while loop could be written a lot more clearly. It seems like you won't print the list headers if the initial degree isn't zero, which is probably unintended, so I would move all of the stuff with (degree == 0) outside of the loop. Finally when you have two command line arguments, you never set the value for increment. 
In brief, it's more idiomatic and makes the reader ask fewer questions about what the code is doing, avoids having to search for the increment operation.
Unfortunately `M_PI` is non-standard, so using it makes your code less portable. ANSI C has no defined pi constant. 
* Consider using getopt.h for argument parsing. * `increment` is an integer so it doesn't make sense to compare it to 0.999999. * Your program is one giant function. This is fine while you're learning, but you should strive towards breaking your programs into a bunch of well-designed short functions. No more than about 20 lines per function. 
[Here is a discussion about why TheNewBoston is discouraged as a learning resource, if you haven't already found it.](http://www.reddit.com/r/learnprogramming/comments/11ubro/28_ways_to_learn_programming/c6ppc38?context=1)
Instead of increment &lt;= 0.999999 use increment &lt; 1
Thanks!
This is what I was most concerned about. I have to look at programs with high modularity but that have simplistic function so I can learn. Are there any you could suggest?
The Linux kernel is some really excellent C. Despite being perhaps the most complex C program ever written, since it's written well it's easy to dive in almost anywhere and understand what's going on. Here are some examples: * [bitmap.c](http://lxr.free-electrons.com/source/lib/bitmap.c), [bitmap.h](http://lxr.free-electrons.com/source/include/linux/bitmap.h) * [klist.c](http://lxr.free-electrons.com/source/lib/klist.c), [klist.h](http://lxr.free-electrons.com/source/include/linux/klist.h) * [kref.h](http://lxr.free-electrons.com/source/include/linux/kref.h) 
The [Gnu Page](http://gnu.org/software/gcc) is very usefull !
Also a cooler loop: char *p = a; while(*p++ != '\0' &amp;&amp; ++i);
For gcc, yea. Any other program still needs a general search. 
If you're going to include all of the files to be served at compile-time, then they have to be *known* at compile time. Either your HTML-to-C-array program needs to be smart enough to parse the HTML and determine what other files are referenced (very hard) or it needs to be given a complete list of all files that need to be converted, including images, CSS, JavaScript, etc. We use something exactly like this at my company for embedded devices, where the files need to be compiled in to the firmware. There's a file that lists all of the files for the web source: HTML, images, etc. If something isn't listed there, it won't make it into the firmware. We also do some other tricks: for most files, we gzip them, and set a flag in the array indicating that the content is compressed. The HTTP server then sends the file with "Transfer-Encoding: gzip", and the browser transparently decompresses it. This saves us both space and performance in the firmware, since the extra work is done ahead of time (compression) and by the client (decompression).
Well, the easiest solution (for clarity, portability, and maintainability) would be to use toupper() and tolower(). If you didn't want to use those, then as long as you're not on an old IBM mainframe that uses EBCDIC instead of ASCII, you can convert case by using 'a' - 'A', which just gives you the difference between the character codes for lowercase and uppercase letters.
Many people use strcat() when it's not the right tool for the job. sprintf() is often far better. Using multiple strcat()s to build a string has O(n) performance, since you have to start from the beginning of the string every time. You could keep track of where you were and adjust the pointer (and length, if you're using strncat(), which you should be)... but if you're using successive sprintf()s to build your string, which is sometimes necessary, you'd have to do this anyway. Generally, building a string with sprintf() is much clearer for future maintainers to read.
DRY (Don't Repeat Yourself) applies strongly here. Beyond that, it's personal preference. I tend to put all macros, constants, global/static vars, and typedefs at the top of the file, so they're easy to find. I *never* prototype functions within a file unless I need to (because they reference each other). Why? DRY. Having a prototype and a definition means they have to be maintained separately. Why use both when you can do the same work with only one? This means that functions must be defined in the correct order: if main() calls foo(), then foo() must be defined before main(). No biggie. Anyone who reads and writes C is used to this. Note that none of this is "scope". Everything declared at the file level in C has either file scope (if it's declared static) or global scope (if it's not declared static).
`int_fast8_t` is only available starting with C99 (ISO 9899:1999). Since many implementations of the C programming language do not / do partially / do incorrectly implement the C99 standard (like Microsoft Windows) many portable projects, including Lua, restrict themselves to the C89 / ANSI C standard where this type is not available. If you go for C99, you can always use `_Bool` or `int_fast8_t`.
That is my current problem. Handing the data to the rendering engine without a file path. Thank you for the useful advice :)
I, too, would be interested in examples.
I can't think of a worse project to start with than OpenSSL. Or rather, OpenSSL is the perfect antithesis of what you are searching for: https://www.peereboom.us/assl/assl/html/openssl.html The site's certificate is self-signed; you'll have to push through the browser warning. Edit: Compiz is an example of needing to build multiple components --that reside in separate directories (maybe even repositories IIRC)-- that all work together to yield the final program. I don't have a URL to the repos handy atm though.
[WMII](https://code.google.com/p/wmii/), which is an old Suckless project, contain several components.
This is one I used in a smallish project some time ago. It builds the objects in the same directory structure as the sources. http://pastebin.com/QWMP91bk
It's impossible to exactly represent the value 4.2 using IEEE binary floating point numbers. The nearest representable number is 4.19999980926513671875. When you type 4.2, what gets stored in `change` is 4.19999980926513671875. When you multiply that by 100, the result is 419.999980926513671875, which is also a number that can't be represented exactly. The nearest representable number is 419.999969482421875. That's the value of `change` after you multiply by 100. You then subtract your sixteen quarters and one dime, leaving you with 9.999969482421875 left in `change`. That fails the test `change &gt;= 10`, so you then go on to subtract a dime and then four pennies, leaving 0.999969482421875 in `change` at the end. That's where your 22 coins come from. When you multiplied by 1000, the result was 4199.99980926513671875, which is yet again a value that lacks an exact representation. But this time, due to pure chance, the nearest representable value is 4200.0, and from there everything proceeds as you'd expect it to. I know these numbers seem strange and arbitrary, but that's only because you're seeing them in their base 10 representations, but they are really numbers in base 2. Everything would make a lot more sense if you did all the above math in base 2. As an analogy, in base 10 it's impossible to represent the value 1/3 in decimal with a finite number of digits. We have to pick the nearest representable number, which will be something like 0.3333 or 0.333333 or whatever -- it depends on how many digits are available. The same thing happens in base 2, except that in this case we have examples of numbers that *can* be represented exactly in base 10 but which *can't* be represented in base 2. (Since 2 is a factor of 10, that means that all real numbers with an exact and finite representation in base 2 also have an exact and finite representation in base 10, but not vice versa.) Numbers like 4.2 are examples of these. In fact, any decimal number that doesn't end in 0 or 5 can't be represented exactly with a finite number of digits in base 2. So 0.1, 0.2, 0.3, and 0.4 are all inexact, but 0.5 *is* exact. [This site has more information on IEEE floating point numbers](http://www.floating-point-gui.de/). Anyway, you just got lucky here that it happened to work using 1000. You could have also used a `double`, and it would have worked with the 100 multiplier, simply because doubles have so much more precision. (By the way, why on earth are you using `float`? They are more trouble than they're worth. Always use `double`, at least until you understand the intricacies of IEEE binary floating point math.) But fundamentally that still relies on chance -- it's luck that the rounding goes the way you expect it. You don't want to rely on luck for these sort of things, you want to work with integers: #include &lt;math.h&gt; ... double amount = GetDouble(); int pennies = round(amount * 100); Now you have an integer number of pennies, and it's guaranteed that it's correctly rounded. From that point on, work only with integers. If for some reason you must continue to use `float`, then you'd have to use `roundf()`, and likewise the version for `long double` is `roundl()`. See [here](http://pubs.opengroup.org/onlinepubs/009695399/functions/round.html) or any other reference to the C standard library if any of this is news.
Thank you for your answer. I will see if I can use a debugger of some kind from now on.
Thank you very much for your thorough answer. Since I posted this question I got some more information about this issue and because of that your answer makes much more sense to me. You are absolutely right, it's smarter round the number or use doubles and so I will.
If you want to be close to K&amp;R's description you won't want Windows. Get VMWare Player and an .iso of Ubuntu or something similar so you can use the terminal for programming. It will seem a little more daunting than an IDE but will be better in the long run. You'll need to follow a short tutorial on terminal use (in Ubuntu you can use Ctrl+Alt+T to open a terminal window; I recommend Learn Programming the Hard Way's "CLI Crash Course" which will show you how to do all of this). As for actually practicing the language, you will want to do the exercises in the book, but expanding upon them with your own ideas will be good too. There are many other good sources of programming practice problems available once you understand the material in the book.
in addition to the suggestion to install linux (as either a VM or directly) i would say to skip the IDE all together and just use a powerful editor (which in a way is like an IDE but without the graphics and will less automatically done for you), vim or emacs (both of which are ridiculously flexible. you will learn the basics in a week or so and then you can keep learning about them for months or years). for exercises you might try project Euler. If you start from the beginning and work straight through you can do a number of them without finding the "trick". there are a lot of other exercises out there. you could also pick up a hiring practice book like cracking the coding interview and walk htrough the exercises.
Be sure to tackle the exercises in the book, and be mindful of the errata, which can be found online. I chose to put my exercise answers in a git repo, but you don't have to do that. It's hard to recommend much else aside from using an OS that encourages and facilitates building software, i.e. not Windows.
Basically just try avoid using floats unless you absolutely have to, and then for only as long as that remains true (or incredibly convenient, which here it isn't).
Please don't use an IDE. Use a command line and a text editor. That's more than enough. You will not learn anything when you use an IDE.
&gt; Always use double, at least until you understand the intricacies of IEEE binary floating point math. If you're not moving a lot of data double is fine, but as someone working with DSP I'd say: Always use float unless you need a signal-noise ratio greater than 144.49 dB. :) 
[Lua](http://www.lua.org/download.html), [Plan9](http://plan9.bell-labs.com/plan9/) and [SQLite](http://www.sqlite.org/download.html).
I read the K&amp;R book, did the exercises in the book. I used vi as an editor and gcc to compile the examples. I use my Mac for this, but if you're in Windows use VMPlayer or VirtualBox with Linux. I quickly got bored with the book exercises, so I found these on the cplusplus.com forums. I've done up to the pancake one so far. They've made me actually *think* about the problem and solve it mentally before I type out any code. Plus they're fun. http://www.cplusplus.com/forum/articles/12974/ 
Would add Redis to that list also
[GDB is your friend](http://darkdust.net/files/GDB%20Cheat%20Sheet.pdf). Once you get used to its console commands, its really easy to examine the values of variables at any given point in the code, even those embedded in arrays or structs. ninja: [here's](http://www.unknownroad.com/rtfm/gdbtut/gdbtoc.html) a pretty thorough tutorial of GDB.
If you want to learn C and **NOT** C++, IMO your best bet is this: http://www.mixsoftware.com/ Get + Power C + Power C Trace Debugger The debugger really makes everything clear as the programs are running. They run in a DOS window - you can use DOSBOX (which is free).
If you don't want to deal with setting up a virtual machine, you can use [Cygwin](https://www.cygwin.com/), which implements a [Unix-like](http://en.wikipedia.org/wiki/Unix-like) environment inside windows. Use cygwin's installer to install [gcc](https://gcc.gnu.org/), which is very well documented and very similar to the compiler Kernighan and Richie had in mind when they wrote their book. As a point of history, the reason people recommend learning C in a Unix-like operating system (Mac-OSx or Linux) or toolset (cygwin) is because Kernighan and Richie invented C for developing the original Unix operating systems back in the 1970s. As such, even though C can run on anything from a space station to a toaster, it's really designed the Unix OS in mind.
A simple editor like sublime text has worked great for me. VirtualBox and an iso for ubuntu works great for the initial setup as well. 
Not to be tooting my own horn, but you might like taking a look at my cmips project. I designed the build system and directory structure off of various smaller C projects and the Linux Kernel build system. Most of my projects have a system like this one but a bit modified. I point out cmips in paticular because while it's still not a huge project, it shows basically everything this paticular Makefile setup can do (Ex. multi-level deep directory structures for files, unit-test system, and building multiple executables from varies pieces of the code). The biggest things used as the basis for this setup is the idea of every directory getting a coresponding object file of the same name, which has the object files of everything inside of the directory linked into it. It allows you to reference 'parts' of the project as object files rather then having to specify every file for each part everywhere, and it also allows you to naturally expand single files into multi-file affairs without having the change the name of the object file (Just give the directory the same name). Ex. The mips core is in the 'src' directory, and both executables ('cmips' and 'ncmips') link ./src.o into themselves. Generating multiple executables is just a matter of getting a list of what object files are needed and then using gcc to create the executable. The test system is basically the same, generating executables via a list of object files and the source file with the tests inside. The list of objects and directories is generated off of a base directories included directly in the main Makefile and then 'include'ing the Makefile's inside of those directories, gathering the variables, and then 'include'ing all of the Makefile's in the subdir's put into the 'subdir-y' directories. For example the [parser](https://github.com/DSMan195276/cmips/blob/master/src/parsers/Makefile) Makefile. It's in ./src/parsers, and gives definitions for the 'parser.c' file to be compiled ("obj-y += parser.o"), as well as the 'in' and 'out' directories to be included. (And thus, you could specify the ./src/parsers/in.o file to reference everything inside of ./in). The main Makefile does basically everything and is only ~160 lines long. There's also some definitions in ./config.mk, and then each directory has a small Makefile for specifying directories and objects. Along with that, each 'project' (Executable basically) has it's own ./config.mk which set up project variables so the Makefile knows what and how to compile the executable. ./test/Makefile also has some extra stuff for setting up testing. https://github.com/DSMan195276/cmips
You don't need one but learning one will help you in the long run. I recommend eclipse cdt.
Why would you pay 40 dollars for a closed-source C toolset that does not run on any modern operating systems when there are exceptional free compilers/debuggers out today like gcc and clang? If he really wanted to get a feel for the computing world of K&amp;R, he should just run a Unix distro like FreeBSD in a virtual machine without a desktop manager. MS-Dos is to classic Unix as a Yugo is to a '65 Mustang -- not even worth comparing.
google "design by contract"
Actually, in this case OP should have used fixed point math. float point math and currency is a big no-no. I agree that beginners should stick to double, but they should be made aware that float has it's uses in some scenarios. Running into these kind issues is part of learning C and I don't think shielding beginners from that makes them better programmers.
You get the compiler, debugger, and books. The book that comes with the compiler is a complete course in itself. And the debugger is brilliant - I've never seen a better one on Windows, DOS or Unix. Anyone who can teach themselves as well with adb or sdb needs no training. Don't knock it unless you've tried it. I've used all these systems - and taught C programming.
Using an IDE for practice in your situation would be similar to using a quarry truck to prepare for an MVC exam. Therefore, a good text editor (by *your* definiton of "good") and a decent shell (google on how to set up cmd so it's actually usable) is all that you need at this point. There are exercises after every chapter, they're good, try to solve them. After you done with a book this way you'll get a foundation solid enough to make your own decisions. 
I don't think you need to bring in the complexity of cmake for most of the exercies in K&amp;R. I like cmake, especially compared to autotools, but it's a bit overkill to add learning the ins and outs for on top of working the exercises. Straight gcc on the command line should cover pretty much everything you need for learning.
This is all the build system you need: gcc -std=c89 -pedantic -Wall -Wextra example.c &amp;&amp; ./a.out 
I use mingw since i use windows. if gaming was better supported on linux. id have a linux os for day to day use. there's lots of choices and most require you to know some linux basic CLI commands. I also run a VM with ubuntu and arch...and have cygwin. and after setting up mingw I havnt looked back. there are tons of pros and cons for using any method. it just depends on what you're looking to achieve and, most importantly, what affects how you achieve it. since I use windows for gaming and i wanted to learn C without needing to know any C++, I skipped over any major IDE because they require knowledge of the IDE themselves and the libraries included with the langauge(s) it supports. MSVB is big on C++. And most IDEs have a built in compiler and debgugger. There are plenty of sources and methods. But I found mingw to be the simplest. plus it's free. which was a biggie for me. it packs a baisc kit together with an easy enough to use install (as long as you read first and then follow the install directions). it uses gcc, gdb, and supports c, c++, ada, fortran, and pascal (I'm not sure about the last one, it might be lisp). it runs right inside of cmd or you can run the terminal shell if you install it. only downside is the command man isn't included. cygwin does have man included. when you compile with mingw, the a.exe file belongs to the os, not the shell like with cygwin. gcc for cygwin binds the a.exe file to the cygwin environment. as my editor I use jedit and it runs on JRE. it does syntax highlighting and handles file managememt pretty well. all the extra features are a bonus. plus it supports a ton of languages. using these two pieces of software has enhanced my learning experience.
OK so I started Introduction to Computer Science(the Harvard one) on EDX. Followed their instructions to get Linux using VMWare and everything seems to be working great thanks!
No. OP should learn how to use make correctly. Real make. It's important to know the concepts you have to deal with before doing something different.
If you are in *nix terminal/shell, ctrl+d combination sends EOF ascii character. This is frequently used when user needs to enter multi-line string and ENTER key cannot be used to signal you're done. This short example compares the pressed key with EOF constant and returns 0 if EOF is encountered.
I just don't understand why getchar() != EOF is 0 when you press Ctrl + D and is 1 when you press ENTER. Am I close in saying it has something to do with the return value of getchar?
I don't know what the misunderstanding is, so here's my best guess at explaining. When you press Ctrl+D in a terminal, the terminal informs your program that there is no more input available, and hence end of "file" (EOF) has been reached. The `getchar()` function obtains the next character from the standard input stream, which can be anywhere between `0` and `255` for a modern computer. *However*, if there is no more input available, it will instead return the special value `EOF` (as defined in `stdio.h`). Hence, the comparison `getchar() != EOF` returns `1` if end-of-file has *not* been reached (which occurs if you enter a character), and `0` if end-of-file *has* been reached (which occurs if you hit Ctrl+D). Note: the part about Ctrl+Z does not apply to Linux. Rather I think it refers to Windows, which uses Ctrl+Z for EOF.
!= makes it a boolean expression. 1 is true. 0 is false 
thanks for your answer!
The comparison operators (`==`, `!=`, `&lt;`, `&lt;=`, `&gt;`, `&gt;=`) always evaluate to either 0 or 1. When you press Ctrl-D, `getchar()` returns `EOF`, and `EOF != EOF` is false, so it evaluates to 0. 
If you can permit piping the text in, you can have a valid program in 134 characters (including the required new-line for ISO C) :) #include &lt;stdio.h&gt; #include &lt;ctype.h&gt; int main(int c,char*v[]){int b=1;for(;(c=getchar())!=EOF;b=isspace(c))putchar(b?toupper(c):c);} gcc crap.c echo "the quick brown fox jumps over the lazy dog" | ./a.out
I've been using this for all my projects for the last couple of years... you just list the source files explicitly in a variable - it handles creating objects and dependencies and all that junk. https://github.com/nickappleton/digest/blob/master/digest/Makefile
To clarify, "no more input available" is a particular state that the stream tried to read and failed. It's different from the stream being blocked waiting for input.
In all fairness, figuring out how to kill vim so you can get back to the shell is great practice for killing your first infinite loop...
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**End-of-file**](https://en.wikipedia.org/wiki/End-of-file): [](#sfw) --- &gt; &gt;In [computing](https://en.wikipedia.org/wiki/Computing), __end of file__ (commonly abbreviated __EOF__ ) is a condition in a computer [operating system](https://en.wikipedia.org/wiki/Operating_system) where no more data can be read from a data source. The data source is usually called a [file](https://en.wikipedia.org/wiki/File_(computing\)) or [stream](https://en.wikipedia.org/wiki/Stream_(computing\)). In general, the EOF is either determined when the reader returns null as seen in Java's BufferedReader, or sometimes people will manually insert an EOF character of their choosing to signal when the file has ended. &gt;In the [C Standard Library](https://en.wikipedia.org/wiki/ANSI_C_standard_library), the character reading functions such as [getchar](https://en.wikipedia.org/wiki/Getchar) return a value equal to the symbolic value (macro) EOF to indicate that an end-of-file condition has occurred. The actual value of EOF is system-dependent (but is commonly -1, such as in [glibc](https://en.wikipedia.org/wiki/Glibc) ) and is unequal to any valid character code. Block-reading functions return the number of bytes read, and if this is fewer than asked for, then the end of file was reached. &gt; --- ^Interesting: [^Brainfuck](https://en.wikipedia.org/wiki/Brainfuck) ^| [^Polyvinyl ^chloride](https://en.wikipedia.org/wiki/Polyvinyl_chloride) ^| [^The ^Loco-Motion](https://en.wikipedia.org/wiki/The_Loco-Motion) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cjui599) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cjui599)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
IDE? I think the best ones are emacs or vim. Also, you can try solve the problems from project euler using C for practicing.
ctrl D sends EOF signal via command line.
Oh duh! Here's yours taken further, leaving out the #include since I believe all macros have function versions which are implicitly defined. EOF I believe is also guaranteed to be negative. 80 characters: int main(){int c,b=1;for(;(c=getchar())&gt;0;b=isspace(c))putchar(b?toupper(c):c);} 
Help us understand your view so that we can correct it. What do you expect this program to do that is different from what it does?
Nice. Would love more gdb
`int main(){}` and `int main(void){}` are identical in C. The only difference is for function prototypes. For prototypes, empty parenthesis means that the function takes an unspecified number of parameters, and `(void)` means that it takes no parameters. See §6.7.5.3/10: &gt; The special case of an unnamed parameter of type `void` as the only item in the list specifies that the function has no parameters. And §6.7.5.3/14: &gt; An identifier list declares only the identifiers of the parameters of the function. **An empty list in a function declarator that is part of a definition of that function specifies that the function has no parameters.** The empty list in a function declarator that is not part of a definition of that function specifies that no information about the number or types of the parameters is supplied. But yeah, loads and loads of errors on that page!
In ISO C90, that clause does not exist. It is stated that empty parenthesis in a function *declaration* means that the function has no parameter specification (which means that it can be called legally with any number of arguments) (C90-6.5.4.3) - some compilers will issue warnings at higher warning levels for declarators like this. But yes, you have corrected me for the case of main(); I cannot find a reference in neither the C90 nor C99 specs which talks about empty lists in function definitions being a problem... so thanks!
`stdin` and `stdout` are file-descriptors. They describe whatever file the process that called your process opened for you. Often they both describe `/dev/tty` (your controlling terminal), but that's by no means mandatory. You will often have programs where these descriptors go to entirely different files. You should, as a programmer, not make assumptions about where these go but rather just use them as designated. Furthermore, many embedded systems do not even have the notion of files. Some of them use `stdin` and `stdout` as an abstraction over an UART so they can communicate with the debug console. Others do not provide `stdin` and `stdout` at all.
very sexy
*The Art of Computer Programming* by Donald Knuth. $20 used.
Initial values: a:0 b:0 c:100 result = f(&amp;a,b): //This line sends the address of a, so that the function (f) can change the values. int f(int *a, int b){ //i changed these to reflect the earlier call (*a) = b+1 //a is now = 1 b = (*a) +2 //b is now 3 (*a) = b+3 //a is now 6 return (*a) + b //this should return 9 The key thing here is to note that when you send an address of a variable to a function, that function can modify its contents. When you dereference a pointer, (*a) = 5353; you are setting the value of the varable (that the pointer points to).
Try replacing `f` with a simpler function: int f(int *x, int y) { *x = 17; y = 23; return 29; } Run the program with that function. Do you understand why the program behaves as it does? If not, what specifically is unclear?
Oh, I just put it in my pocket without taking a look at any of the information. Good thing someone else found the errors already, I'm deleting that now. 
`int main(){}` and `int main(void){}` are not *quite* identical. The latter provides a prototype; the former does not. C permits recursive calls to `main`. This: int main(void) { return main(42); } is a constraint violation, requiring a diagnostic. This: int main() { return main(42); } has undefined behavior, but since there is no prototype defining the number and type(s) of `main`'s parameters, no diagnostic is required. Aside from that, the form with empty parentheses is *obsolescent* (which is basically a warning that it may be removed from a future version of the language).
Symbols in identifier names *may* be permitted. clang and gcc both happen to accept `$` in identifiers, but other compilers may or may not. To print a pointer value with `printf`, you should use the `%p` specifier *and* convert the value to `void*`. `%p` specifically requires an argument of type `void*`; passing an `int*`, for example, has undefined behavior (though it's very likely to "work").
Thanks for the response. would you recommend it for a novice C programmer? How useful is it alongside K&amp;R? 
Rather than making us read the whole assignment and wade through all of your code, can you just describe the problem you needed to solve and the way you solved it (i.e., what data structures and algorithms did you use)?
I needed to create an address book,and I have attached the full problem.I have used linked lists and sorting algorithms
I have used insertion sort and selection sort algorithm.Thats exactly what my teacher said about linked lists but I didnt know how to write the code of binary search trees :/ Edit : Can you please explain me further why linked list is not efficient?
&gt; I have used insertion sort and selection sort algorithm. These are inefficient algorithms: they run in quadratic time in the worst case (and in the average case). You should use a more efficient sorting algorithm, such as merge sort or quicksort. These are going to be challenging to implement properly for a linked list, though. The fact that it is challenging to properly implement an efficient sorting algorithm for linked lists is another reason you shouldn't be using a linked list here. A linked list is really not the most appropriate data structure for the operations that your program needs. &gt; Thats exactly what my teacher said about linked lists but I didnt know how to write the code of binary search trees :/ Well, then, I guess you should learn. Binary search trees are fundamentally important data structures. You say you are in a course specifically focused on data structures. If you come out of that course without understanding how to implement a binary search tree, then I would question what you got out of the course.
&gt; Edit : Can you please explain me further why linked list is not efficient? For what operation? Searching? A linked list is not efficient for searching because the only search algorithm you can do with a linked list is [linear search](https://en.wikipedia.org/wiki/Linear_search), which requires looking at every single node in the list in the worst case (and linearly many nodes in the average case). This is worse than a sorted array, for which you can use [binary search](https://en.wikipedia.org/wiki/Binary_search_algorithm), which requires only logarithmic time. A balanced binary search tree also allows logarithmic-time search. A properly implemented [hash table](https://en.wikipedia.org/wiki/Hash_table), with a good hash function, can even support constant-time search in the average case.
Thank you very much.Im going to study binary search trees right now!
Then what is the quoted clause (§6.7.5.3/14) referring to?
Why not use [libuv](https://github.com/joyent/libuv) instead of this thing? libuv is portable (it'll happy run on embedded ARM devices, Windows x86, etc), uses epoll/kqueue where it makes sense to as opposed to just being a fat wrapper over `select(2)`, which is not the most efficient way to do asynchronous I/O and will choke once you start going near a thousand+ filehandles concurrently.
&gt; she told me it was correct and she accepted it. Then she missed the flaming bug in the very first function `theSmallest()`. It looks like it's supposed to return something other than 1 sometimes, but it never does. (It's dead code, which partially explains the failure to detect the problem.) `sort()` and `sortLike()` both have memory leaks, and shouldn't need to allocate memory at all. Many of your functions are tail-recursive, when that's no an optimization you can depend on in a C compiler. I'm completely passing over the buffer-overflow bugs everywhere...
`x` is the address of an int. `*x` means the int which `x` is the address of. 
Please use four spaces at the beginning of a line instead of a bird-track. This will select a monospaced font. It makes your code much easier to read if it's indented correctly.
Can you try to indent your code in addition to formatting it this way? This makes reading your example much easier.
There is a huge difference between this declaration: void foo(a, b, c) char a; short b; float c; { /* ... */ } and this declaration: void foo(char a, short b, float c) { /* ... */ } namely, that in the first example the compiler will perform K&amp;R-style argument promotion (promoting the `a` and `b` arguments to `int` and the `c` argument to double) upon call, as if you declared the function without argument specification. I'm not quite sure but I think the compiler will convert the arguments back to the types you declared immediately after the function has been entered. This might make a difference if back-and-forth conversion does not behaves like the identity function (like in case of a badly-designed FPU) and also makes stuff like thus undefined behavior: /* in a.c */ void foo(a, b) short a; float b; { /* something */ } /* in b.c */ extern void foo(short a, float b); foo(10, 1.0);
It's always good to hear the wisdom of the ancients.
i would read it if you haven't. you'll probably learn something interesting and if you don't it will at least be a quick read.
I think you could get some stylistic advice, at least, from K&amp;R. It's a bit of a double edged sword though. The book uses a very terse coding style, for an example: for (i= 0; i &lt; lim - 1 &amp;&amp; (c = getchar()) != EOF &amp;&amp; c != '\n'; ++i) { s[i] = c; } From what I understand, idioms and a terse style like that are valued by C programmers, and it offers readability in a different way than overly long variable names or splitting things into different lines / functions. On the other hand, I see how one could argue that code like that is unreadable. Just my two cents. I only read a couple of chapters some time ago, but intend to read the whole book some time, since it seems so valued by "hardcore" C people.
Eh, if you're solid in the areas you mention, The New Testament won't give you much, if anything (as much as I love the book, and recommend it as a nearly ideal first tutorial and reference).
I bet this is influenced by the fact that the editor they used was ed.
I second this! I recently read through the whole thing and picked up some valuable knowledge even though I considered myself to already be very familiar with C. It's made me a more confident C programmer and now I've got K&amp;R checked off of the nagging list in the back of my head. You certainly won't lose anything by reading it.
Piggy backing on this, if you're interested in a deeper understanding of the language then reading the standard itself is a good way to do that; the cheapest way to get it is [The Annotated ANSI C Standard] (http://www.amazon.com/dp/0078819520). However, the annotations themselves are often inaccurate, so the book really only serves the purpose of providing the standard. Corrections to the annotations are found [here](http://www.davros.org/c/schildt.html).
What do you mean by this? 
There is a freely available draft of the ANSI C standard online. For all practical effects, it's as good as the ANSI C standard document itself, as far as I know. http://flash-gordon.me.uk/ansi.c.txt However, I've only mentioned ANSI C because of K&amp;R2, which covers that version of C. If someone is interested in learning C professionally to the level of accuracy the standard provides, some book like H&amp;S (http://www.amazon.com/Reference-Manual-5th-Edition/dp/013089592X/), which covers C99, is probably more recommended, or even the standard document itself. I only know one book which covers C11, and I'm not sure if it's a good book (http://www.amazon.com/Beginning-5th-Edition-Experts-Voice/dp/1430248815/). Draft versions of the standard which are released right before the standard itself are as good as the real deal, and are free. A professional C programmer probably can afford to buy the standard document however.
Nice! Since you mentioned that I went back through my bookmarks and figured I'd leave some links as well: [ANSI C Specification, html version](http://eli-project.sourceforge.net/c_html/c.html) [Mirror of ansi.c.txt] (http://web.archive.org/web/20030222051144/http://home.earthlink.net/~bobbitts/c89.txt) (named differently but same document) [ISO 9899:1990](http://read.pudn.com/downloads133/doc/565041/ANSI_ISO%2B9899-1990%2B[1].pdf) (taking forever to load for me right now) [C Books broken down by skill level](https://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list) [Random C Stuff](http://www.quut.com/c/)
Cool. I really like the ##c @ irc.freenode.com channel wiki. http://www.iso-9899.info/wiki/Main_Page It has a compilation of serveral stuff on C programming and related. The IRC channel itself is somewhat good. It's pretty hostile, but if you're like me and don't mind that very much, it can actually be a fun place to be.
The issue is that it isn't much readable in C either. It's how, however, people write code in C. You don't have to do it like that though. As for the given code by /u/phail3d, it's not really that bad. In my opinion, stuff like this is way worse: #include &lt;stdio.h&gt; int main(int argc, char **argv) { while (argv[1]) if (*(*++argv)++ == '-') printf("option: %s\n", *argv); else printf("non-option: %s\n", *argv-1); return 0; } Invoking it like __./a.out -a -b 123 -d12__ prints option: a option: b non-option: 123 option: d12 I remember back when I used to write and like code like this. Now I have the strangest sensation when looking at this: it seems wrong (but I still think it's pretty cool). Today, I'd at least put {} around the loops and conditionals. For weird C code, you could always look at that obfuscated C code contest, but I was trying to come up with something that one could actually find in projects out there.
That's an interesting thought. It never crossed my mind. I wonder if that's really the case.
I've used systems where that was the only editor. *vi* -- in your dreams!
I love using pointers like that, much more faster to write and you save extra memory by not declaring any iterators (int i, ...)
it's a good book for going back through the basics. I am somewhat familiar with basics of C, but i still need a refresher now and then.
I don't know if there's much point to "JIT"ing bf (there isn't really any DFG to be constructed, no different datatypes, ...), but you can just convert bf to C and compile it with an optimizing C compiler (or go directly to assembly, doesn't really matter...) If you want to get fancy, however, there are two (relatively challenging) things you can do: - Optimize the bf code, by pre-computing certain "functions" or otherwise optimizing them. For instance a "[-]" really just sets the current memory cell to zero, so that "pattern" can easily be matched and turned into "*ptr = 0;" or so. - Make a "safe" interpreter that has defined behaviour for overflow, moving the instruction pointer below cell zero et cetera, but then analyzing the code and proving parts of it to be "safe". Then you can use that kind of analysis to omit bounds checking whenever you can prove that underflow/move-below-zero cannot happen, to speed up the code. Optimizing bf compilers (in C and other languages) already exist on the net, so you can google around for inspiration.
You can pull a lot of ideas from [here](http://vay8.net/ubi). I haven't looked at my bf interpreter in many years though--if it's broken let me know. EDIT: Just read over it actually, it's really broken. Maybe I'll go back and fix it. Still, lots of good ideas there.
May I just state something about MAC addresses? Each one is consisten with a brand. If you want this to be functional, lookup the brands (Dell, Intel, etc) and notice there is a common first 5 or 6 characters. Implement it in such a way that it will request a brand (or detect it if you feel frisky) and then output a realistic MAC address for that brand. For example, mine starts with e0:db:55... so I know it's a dell based on just that. If you are interested, here is a website with the lookup functionality. http://www.coffer.com/mac_find/
Lua and SQLite are pretty amazing projects to read through the source of, quite beautiful :)
Here is mine with a debugger, it's not a state of art but hope it helps! http://www.github.com/boramalper/brafin
Just created a data structure to replace the o(n) lookup and it appears to be running around 280x faster :). Go check out my pull request!
Without just giving it away - let me ask socratically, how many possible values are in the range?
86 in my example... rand() % 32 + 86
Or maybe rand % 32 + rand % 86
This is very close! However, this will generate a number in the range of 86-117 which isn't the full range that you desire. You already know how to generate a number from 1-100... how would you generate a number from 0 to (highNum - lowNum) which is 85 in your case?
This is a good thought but this will give you numbers from 0-116.
 rand() % 117 - 32? I am seriously just guessing anymore. I know i covered this in a visual basic class years ago, but completely forgot.
 rand % 86 So then I just need to add my minumum, which is 32? rand % 86 + 32?
Yep. rand_range (min, max) = rand() % (max-min + 1) + min;
Yes, scanf takes pointers to the variables you want to read into. That is, the expression '&amp;i' evaluates to the address of 'i', which is what you pass to scanf. This is important because parameters are passed by value; the called function only gets a copy of the argument. If you simply passed 'i' to scanf, it could use it's own local copy of it, but not alter it's value in the caller's stack frame. This will make a lot more sense if you learn about stack frames in detail.
Stop guessing and break the problem down. You know how to generate a number in the range 1 through 100: rand() % 100 + 1 how about 2 to 101? 1 to 99? 32 to 117? 
BINGO! Since we subtracted the minimum number from our original range then we add it back to the zero based range to get back to our desired range. A generic form (with your values inserted) is like so: int highNum = 117; int lowNum = 32; int randNum = 0; randNum = (rand() % (highNum - lowNum + 1)) + lowNum; Good job! Edit: Forgot the + 1, thanks /u/gblargg 
&amp;i is the address of i. You pass this to scanf so it can store the scanned number into i. When values are passed to a functions, any changes made to them in that function do not get reflected outside the function. Thus, if you passed i to the function, you would not be able to see anything stored to it. Similarly, if the function tried to change the pointer with the address of i in, you would not see it change. However, the address of i can be used to access the memory of directly, allowing the value to be seen.
EOF is not part of the ascii standard, it is implementation defined.
 randNum = (rand() % (highNum - lowNum + 1)) + lowNum; 
Good on you for showing him the path instead of the destination!
If you use modulus to adjust the range of `rand` you're -- in most cases -- ruining the uniformity. Don't do it. 
Why not submit this to /r/codereview?
`scanf` needs a format string.
Replace the `scanf` call with this: scanf("%99s", dataFileLoc); You might want to do error checking, but this should be good enough for now.
`scanf` requires that you provide a format string so that it knows how to parse the input, and a variable number of arguments which it parses the string into. Right now you're only passing it an uninitialised format string and no other arguments. All the information you need is in the `scanf` man page (you can also google for examples).
Ah right. Thanks for the information. I come from more of a C# background, so this "format string" nonsense is all new to me. I'm used to just declaring a string variable and reading it straight in.
Cool. Many thanks!
I think the confusing part is (maybe) that str is passed, not &amp;str. As str is a char-array str is like the pointer to the first element of the array...
Better yet, if you can avoid using floating-point math entirely, do that. US currency is always handled with 2 decimal places (certainly for a simple example like this) so parse the string and do all of the math in pennies using ints, with no floating point math at all.
You don't want to use % to get the lowest bit of a random number, because it will be less random. You want to do something like what the Java rand implementation does (because they provide pseudocode in the documentation, so you can have a look, but I'm sure there are already snippets in C you can reuse from somewhere instead, and if you use the code directly from Oracle's documentation I don't know if they could sue you or something anyway): http://docs.oracle.com/javase/6/docs/api/java/util/Random.html#nextInt%28int%29 Of course if it doesn't have to be very random, just do the % + offset thing most others suggested.
Also there are many random functions in the standard-lib for C++11 (or in boost for older C++ compilers). Depending on your environment it might be trivial to call a function in C++ to do the random stuff for you to save you the trouble of making a correct uniform random generator yourself.
Note that the `99` in `%99s` is quite important here. It specifies that your buffer has space for 99 `char` (plus a nul-terminator). Without it, you might write past the end of the input buffer and then undefined but probably bad things happen.
Downvote you! You suggested a robust solution and that's not right!
&gt; this "format string" nonsense is all new to me. I'm used to just declaring a string variable and reading it straight in. Any reason you aren't using C++ instead?
It's a university assignment. I wondered why we weren't using C++, too, but hey ho.
Change the third line to fgets(dataFileLoc, 100, stdin); This will read up to 100 characters (including the '\0' terminator) from the user into the buffer.
That's what `fgets` does, although you have to specify a maximum length as standard functions don't allocate memory for you. Only use `scanf` when you want formatted input . 
Ah, I see. Thank you much!
"Programming Windows" by Charles Petzold is the best book I know for Windows API in C.
Make sure to get the fifth edition; the sixth edition is all about Metro instead of Win32.
Tx
Yes, it's possible. It's called a firewall. Look into IPTables.
I do know about iptables, but it's actually one of the reasons that I'm looking to just be able to run my own daemon. Apparently the server that I'm renting has a very low limit on the number of iptable rules, which was quickly exceeded in a manner of a few weeks. Using this daemon, I wouldn't need to set a rule for each IP or block of IP's, I could just handle it case-by-case. Main reason I don't really need to set a blocking rule is because it's often a different IP every time. I rarely see the same IP more than once, so blocking every single one is wasteful. Since each of these IP's will have a similar feature (country of origin) it will be easier to just terminate the connection based on that. Thanks for the suggestion though! Just for some clarification, I'm looking to block any IP that I can assuredly say has come from China (as there are 10 or more ssh hacking attempts from there every day). Utilizing the whois information, I can find out if the IP is coming from China or not (in most cases, not all), and if so, kill the connection immediately.
I'll take a look into authentication keys, but the other 2 suggestions are only temporary solutions, which is why I was wanting to create this daemon instead. Thanks again.
For editors I'd say Sublime Text 2 or Vim. You may optionally want to add a linter, such as SublimeLint or Syntastic, to catch compile-time errors in your editor. As for compiling, understanding objects is key for any C programmer. I'd get started learning about Makefiles. Books for reference: K&amp;R and Advanced Programming in the Unix Environment. Good luck!
Mac OS X includes vim as their vi(1), which has syntax highlighting. There are also BSD man pages for the C library functions and Unix utilities. Apple has switched to a Clang/LLVM compiler, if you install the development tools (Xcode?) you should get all the command-line stuff with it. http://opensource.apple.com/source/vim/vim-53/ https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/
Maybe you are just being loose with terms but c is not object oriented. Vim should be suggested with the caveat that it has a steep learning curve.
Yeah, if you're learning C just install Xcode, start a new project (OSX-&gt; Command line tool, choose C), and start hacking away at the main.c file. The IDE and debugger are very helpful as you're learning. You can learn about cross-platform development, using Autotools and the rest from the console once you've got a better handle on the language itself, I think. 
If I were going to be grilled on C I'd start by reviewing: "C Traps and Pitfalls" by Andrew Koenig. It's based on a [paper](http://www.literateprogramming.com/ctraps.pdf) which is available on the web. If you have more time: "Expert C Programming: Deep C Secrets" by Peter van der Linden. There are also a bunch of articles on the web covering undefined behavior in C - [for example](http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html). Undefined behaviors can be a fertile topic for q's if they're going to really probe your C expertise.
I had previously used DenyHosts, but left it after it started acting up where it was blocking my connection, even when I wouldn't get the password wrong. No clue what would cause that to happen (even with my IP in the hosts.allow file), but it caused enough trouble to the point where I didn't want it anymore. So I was just looking to see if I could create my own code to examine an incoming IP, and deny it if it originates from China. From what I can tell, I cannot do what I would like to without modifying the kernel, which, this being a rented server, I doubt I would be allowed to do that =P. Thanks for the suggestion though!
Well, Can you load a kernel module? In that case, you can look into net filters. http://www.linuxjournal.com/article/7184 A easy way to capture packets in the kernel and /sys can be used to write to this module about changes in configuration, a new IP to be blocked or something similar to that. 
You can embed Assembly into it, which allows you to use a (barely) higher level language for most tasks, and dropping to Assembly for the really intensive tasks. I doubt that counts as trivia, but some people may not know it. EDIT: This is wrong. See below.
He might want XQuartz too. I don't know.
So you're not going to suggest an alternative way to solve the problem?
I learned vim (which is bundled with OSX) based on [this tutorial](http://vi-improved.org/tutorial.html). I recommend you first spend an hour or two familiarising yourself with a decent editor and continue from there. Btw - that tutorial is probably one of the best I've come across.
You seem to be correct, asm is not in the keywords list in paragraph 6.4.1 of the C99+TC1+TC2+TC3 draft: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf
"Windows system programming" is nice.
http://www.iptables.info/en/iptables-matches.html#HASHLIMITMATCH
the C language can not do that, it's not part of the language. It's just a non-standard compiler feature.
The comma operator needn't be forgettable like gets() or 'register' storage. 'return errno = EFOO, -1' is perfectly legitimate. 
I think it's kinda cool that the index operator `foo[i]` is really just short for `*(foo + i)`. Addition is commutative, so you can write it as `i[foo]`.
Yep, hence 2["Hello, world"] is 'l'... I love C
Windows API is something of a massive pain. But if you have to do it, I recommend "Programming Windows" by Charles Petzold. It's a bit old, but so is the API.
I'd suggest using [MacVim](https://code.google.com/p/macvim/) instead of the stock vim version.
nmemb = number of members size = size of each member total bytes written will be size*nmemb The ptr is to the first member - the members are assumed to be stored contiguously in memory - i.e. an array of members. Note that calloc has similar args. I don't know why some fns take a total size (e.g. malloc) and some take a count + size of each element. I'm assuming there are historic reasons for this inconsistency.
Size is how big the thing ptr to points to is. nmemb is how many of them there are. size might be sizeof(*ptr). nmemb might be 1 if you're only writing 1 of it, or more if ptr is actually a pointer to the beginning of an array.
Also, this is all explained in the man page, which you could google for. [This](http://linux.die.net/man/3/fwrite) is the first hit I found.
If fwrite is anything like calloc, having separate parameters for size and number of members allows fwrite to check for overflow when multiplying the two to determine the total size to write.
ST should automatically set the build system for any C and C++ source files. What happens when you select Tools -&gt; Build? You have MinGW installed and added to your path yes?
This is the error I get: &gt;'gcc' is not recognized as an internal or external command, operable program or batch file. [Finished in 0.3s with exit code 1] I have downloaded the MinGW and since it came in archive I extracted it to C:\MinGW and that's all I did. How to add that path?
Yeah, that could be the problem. I have extracted the MinGW to C:\MinGW but it is not working. Maybe I should have extracted it somewhere else? And how do I configure my editor to invoke it?
I had this same problem and was able to configure Sublime to compile C files by simply pressing Ctrl + B. However, you still need to run the compiled program afterwards either using Windows Explorer or the command line. First, make sure that you've added the MinGW folders to your Path environment variable so that you can access them globally. 1. Right-click **Computer** -&gt; **Properties**. 2. On the left side, [click **Advanced system settings**](http://i.imgur.com/B1pzwv9.png). 3. Click the **Advanced** tab -&gt; [**Environment Variables...** button](http://i.imgur.com/xEQn4WV.png). 4. In the bottom list, [scroll down to **Path** and click **Edit...**](http://i.imgur.com/oy3ScIh.png) 5. At the end of the path, you're going to append **;C:\MinGW\bin;C:\MinGW\msys\1.0\bin** (adjust accordingly if you installed MinGW in a different location) so that it [looks like this](http://i.imgur.com/1fC6SJV.png). Click OK repeatedly and close all the windows. Once you've done that, now we can configure Sublime to compile C files: 1. In Sublime, click **Preferences** -&gt; [**Browse Packages...**](http://i.imgur.com/0N8ocyo.png) 2. Double-click the [**C++** folder](http://i.imgur.com/GvoDODM.png). 3. Look for the [**C++.sublime-build** file](http://i.imgur.com/X5Bb4VJ.png). Right-click this file and select [**Open with Sublime 2**](http://i.imgur.com/IWrlS9s.png). 4. In the text, highlight **source.c,** *including* the comma and delete it. Here is what the file will look like [before](http://i.imgur.com/tX9cniD.png) and [after](http://i.imgur.com/9ibUKAQ.png). 5. Now [save and close](http://i.imgur.com/9UIesV7.png). 6. Click **Tools** -&gt; **Build System** -&gt; [**New Build System...**](http://i.imgur.com/FelANwz.png). 7. Now highlight and copy the following text: { "cmd": ["gcc", "${file}", "-o", "${file_path}/${file_base_name}"], "file_regex": "^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$", "working_dir": "${file_path}", "selector": "source.c" } 8. Go back to Sublime and press [**CTRL-A** to highlight everything](http://i.imgur.com/wCaVDKh.png). 9. And then paste the text you highlighted in step 7. It should [look like this](http://i.imgur.com/3fKofuJ.png). 10. Click **File** -&gt; [**Save**](http://i.imgur.com/MEy1m9a.png) 11. Highlight [**untitled** in the filename](http://i.imgur.com/DGqtOdW.png). 12. Replace *untitled* with the capital letter **C**. It should [look like this](http://i.imgur.com/BwzelJX.png). Then click Save and close the file. Now test to see if it works by opening a C file and pressing **Ctrl + B** to compile. Or click **Tools** -&gt; **Build**. Let me know if you have any trouble getting that to work.
Thanks for the effort you put in making this guide. In the first 5 set of steps I got stuck on 4th. I don't have [path](http://imgur.com/O9djxNI) variable in the list. What should I do?
I actually ssh into a virtual box guest with ubuntu installed and hack around there with emacs. I am interested mostly in working specifically with linux and practicing with emacs and the terminal, so this works well for me. Maybe not for you though! 
Which version of Windows are you using? Double-check to make sure that it's not there, and if it isn't, click New and create a Path. If you create a new Path, you don't need the preceding semi-colon used in my example above. For a **new** Path, copy and paste the following instead: **C:\MinGW\bin;C:\MinGW\msys\1.0\bin**
http://www.computerhope.com/issues/ch000549.htm
From googling that error, my best guess is your Windows is either 32-bit or 64-, and your version of MinGW is the opposite. You might try uninstalling your version of MinGW and identifying whether your Windows is 32- or 64-bit, and then downloading that version of MinGW.
I've never heard of that. Have a reference for that?
On mobile so don't have a link, but just have a look at the source for calloc and fwrite. Early on there are checks that size nmemb won't overflow when multiplied.
You are probably missing libraries. Make sure you include them. e.g -L/usr/local/lib -lyour_lib_name 
You're going to want to look into [ipset](https://wiki.archlinux.org/index.php/Ipset).
As someone new to C, undefined behavior seems like something to be avoided, since compilers will disagree on how it should be handled. However, a comment in the article stated that UB is part of how/why C came to have fast, efficient compilers. How much truth is in that statement? Is there no value in a compiler option that errors or warns on UB? I think making UB more visible may help people like me become better programmers and more familiar with C.
&gt; However, a comment in the article stated that UB is part of how/why C came to have fast, efficient compilers. How much truth is in that statement? Not determining what the compiler should do with, say, overflowing integer arithmetic means the output code can be faster since it doesn't have to check what happens to the integers at run-time. I imagine the concept of "undefined behaviour" was invented by the standardizers as a way of describing what C compilers did. I don't think the early C compilers were designed with the notion of "undefined behaviour". So this is not really a true statement, but there is a kernel of truth in it. 
Can't stand seeing "C/C++"...
there is a big difference between undefined behavior and implementation defined behavior. The former is such that the compiler can do whatever it wants and may choose to do something that results in nondeterministic run time behavior (because it was never meant to do what it is being asked to do). That said most compilers do something reasonable when you ask them to do something unreasonable. Implementation defined behavior ([for example](https://gcc.gnu.org/onlinedocs/gcc/C-Implementation.html)), on the other hand, should have a reasonable and consistent behavior within the generations of a compiler. However, it makes your code less portable. As for becoming a better c programmer, if you use gcc you can compile with: -W -Wall -Wextra -Werror -pedantic i'm sure other compilers have similar flags
Thanks for the breakdown! I'll look into those flags and run some code through the gauntlet :P
Thanks for clarifying. Is there a way forward for the standardizers to better define undefined behavior as something independent of how compilers happen to operate at the time of drafting?
C as a language has the big advantage of being able to be compiled into machine instructions which "look like" the C code does. That is why it's very fast, because it doesn't have safety features. Some people really need that speed, which is why C is still around when other, safer, languages also exist. Adding "safety features" to C will frustrate these people because it will make C much slower. So I suggest that, rather than thinking about trying to change C, you should think about what you want to do and try to find a suitable language for your tasks. 
Everyone should use -Wall, but not everyone should use `-Wextra` and `-pedantic`. Please read about what they do and then decide for yourself if you want to use them. `-Werror` is just irritating in development, it's really for production code when you need to halt compilation if there is any warning. But having said that, a "warning" from the C compiler is often something akin to a fatal error in other languages. 
&gt; Please read about what they do and then decide for yourself if you want to use them. I planned on it, but thanks for the heads-up!
Ah, okay. So you're saying compilers can create faster binaries because they don't have to check for things like data boundaries, and that makes the compiler and binary faster? That makes a lot more sense, since I was under the impression one should be bounds-checking, sanitizing input, `free()`ing data you don't need, etc. anyway. Here I was thinking that some people used UB as hacks to make things faster. :P
A lot of compilers do warn when they detect obvious undefined behaviour, but sometimes it is impossible [or very difficult] to detect at compile time. For example, the following code only exhibits undefined behaviour when the user has not entered a valid number as input: #include &lt;stdio.h&gt; int main() { int i; scanf("%d", &amp;i); if (i == 4) return 1; } 
Another example is using signed vs unsigned integers in loops. for (i=0; i&lt;=n; i++) { .. } If i is an unsigned integer, then the compiler must assume that n may be max_uint, which will result in an infinite loop. If i is a signed integer, integer overflow is not allowed (UB) an the compiler may assume that you checked that n is not max_int and thus will not overflow. It doesn't matter if you actually did, it will always assume you didn't intend to invoke undefined behaviour.
-Werror and -pedantic together is asking for a world of pain. Especially when you start to do absolutely anything with function pointers and it starts to whine that void * and void (* func) (void) are not technically the same, even though it will work on everything made in the past 30 years (and is basically required to work, see dlsym() and friends). But hey, nobody said C was supposed to be "friendly" so there you have it.
It is not "*basically required to work*", it actually is required to work on POSIX and Windows, but assuming it works on anything else without separate guarantees is foolish since you don't have a guarantee. 
No. Just no. If you want a language "friendlier" than C, there are plenty from whicb to choose. C continues to be useful exactly because of its "unfriendly" nature. Further, I argue that C is friendly. As has been said about Unix, it's simply very selective about its friends. Of course, I welcome warnings about code which invokes undefined behavior. More static analysis is always welcome, assuming it can be disabled when necessary.
i and n have types that the compiler will check. If they are not the same type you will get a warning about the comparison. One that you won't be warned about is if n is an int32_t and int8_t. I had this bug in some code and it wasn't fun to find.
There's nothing "*unfriendly*" about it. Harvard architectures exist (or existed, or could exist), they're allowed by the ISO C standard, so if you don't have a guarantee external to the ISO C standard (e.g. the guarantee that POSIX gives) you can't/shouldn't rely on this behaviour. This is not an issue with C, this is an advantage/the purpose of C, i.e. it is high-level assembler. What you want is a platform-specific assumption baked into the language. That is not the purpose of C.
Imagine two robots; one is strictly programmed to follow a set of motions based on a timeline. Whatever happens, it will execute those exact motions. The other robot is a very sophisticated one that has a 3D camera on top of it, can dynamically correct for mistakes, has touch-sensors everywhere on its body, et cetera. The robot that simply follows timed commands is much stronger, lighter, simpler to understand, simpler to program, requires less power, is less fragile in a sense. But on the other hand, it is also quite dangerous; if you do not put the boxes it's supposed to move from A to B in the exact right place, it will just throw them around, and if you put your head in its pincers, it'll just crack your skull. The robot that is more sophisticated gives you more safety, and can understand more about what's going on and about it's environment. It will not accidentally crush your head -- but it also costs more to build, is harder to program and understand, requires more power and is slower (because it constantly has to stop to scan and process its surroundings.) Of course in the digital world, "crushing your head" is not the worst thing in the world, in most cases -- that's why using a "barebones" language like C is still favored when e.g. performance/size/simplicity is a requirement. And with "sufficiently smart programmers" and a lot of QA, you can produce a product of equivalent stability.
For windows code IMO there is very little advantage to C over C# (apart from extreme performance stuff). Probably obfuscation is the biggest one in a corporate settings :P That said, the Win32 API is just completely different to .NET ones (which you can call from C++ AFAIK)
&gt; printf(number + "\n"); This is not how the `printf` function works. And you can't convert an `int` to a string, or concatenate it to another string, with the `+`&amp;nbsp;operator. You aren't in Java any more, remember. In&amp;nbsp;C, the `+`&amp;nbsp;operator always denotes numeric addition (or pointer addition). If you aren't adding two numbers together, then you don't want the `+`&amp;nbsp;operator. You need to review how the `printf` function works. &gt; while ( number !=0 ); &gt; sum = sum + number; &gt; printf("Type in a number \n"); &gt; scanf("%d", &amp;number); Your indentation is misleading. See the semicolon on the same line as the `while`? That is an empty statement. A `while` loop always applies to the immediately following statement only. So the body of your `while` loop is an empty statement, which means that it will continue doing nothing, over and over, for as long as the condition `number != 0` is true. So first of all, remove that semicolon. If you want a `while` loop to apply to more than one statement, then you need to combine the statement into a single *compound statement* by surrounding the statements with braces `{ ... }`. This is exactly the same way that `while` loops work in Java, by the way. You should turn on all warnings in your compiler, and pay attention to what they say. My compiler will warn me about empty loop bodies.
Win32 is a C API. There is no need to use C++ so long as you stick to it. Having said that, you still have the option of using C++ if you so desire. There are a number of Windows APIs that are built on top of win32 that are C++-based, such as MFC and ATL. As for your question, your code will probably look very different if you decide to use C or go down the C# route. C# is object oriented so the Windows APIs are wrapped around managed objects and things might be grouped together depending on their purpose. In C you have the full win32 API exposed, basically, as a collection of functions that operate on opaque types. Both styles are valid, it really comes down to your business requirements and/or personal taste. 
I meant you can call .NET APIs from C++, obviously you can call Win32 from C/C++/C# (but it's a pain from C#!)
 #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { int sum = 0; for (int n; ((printf("%d&gt; ", sum), fflush(stdout), scanf("%d", &amp;n)) == 1) &amp;&amp; (n != 0); sum += n) ; printf("sum: %d\n", sum); } 
Assembly is not part of the C specification. See your compiler for its syntax and use. You can use inline assembly for anything you could use standard C for(assuming your compiler supports it). edit: Inline assembly is generally discouraged, unless used for learning, due to its inherenet non-portable *ness*. **Some** applications might benefit from inline assembly. But, honestly, if you have to ask when to use assembly then you shouldn't be using it.
It's used when you need to access registers directly (e.g. on x86 it's common for the operating system to use the FS and/or GS segment registers to store a pointer to thread- or process-local data structures for quick access), or when you want to use processor-specific instructions (e.g. SIMD, but in that case it's better to use the compiler's intrinsics than inline assembler), or when you just want maximum control over the sequence of instructions. As to the second question, I have no idea what you're asking. Of course it's different than the surrounding C code. Are you asking if inline assembly is different than normal assembly (i.e. what you'd write in `foo.asm` or `foo.s`)? Yes, it can be different. It depends on the compiler. Gcc (and clang by extension, since it emulates all of gcc's extensions) requires that you annotate all the side effects of the instructions so that you don't step on the optimizer's toes. This requires extra syntax; [see the manual for details](https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html). The upside of that extra work is that the optimizer can work around your assembly, whereas the alternative is to just have the optimizer be completely unaware of what you're doing, making the assembly completely opaque to it. This requires e.g. spilling everything before and reloading after (since it can't know what was clobbered) which is bad for performance but it lets you write assembly without the extra annotations. That's the route that MSVC took. So, it depends. This is all incredibly non-portable, since not only does it depend on the hardware architecture but also the compiler. 
Does anyone know similar article for vim?
&gt; Is the inline code and the plain code the same, or is it written different or something? The important difference, aside from the syntax, is the way stack usage is managed between function calls. In bare assembly code (i.e. in .asm or .S files), authors take care of stack usages between function calls. In C code, when you inline an assembly, the prologue and epilogue will normally be added for you. There are, however, functions that can be marked as "naked" - meaning they don't have the prologue and epilogue code.
You would use it for something you cannot do in C. Most processors these days support virtual memory, but the C specification knows nothing of it. If you need to change the page tables, you would write a C function and use some inline assembler to make the processor specific calls. 
These problems look like a lot of fun! Is there an accompanying set of test cases I can use to verify my solutions?
Seconded. I'd like to know if I'm actually doing them correctly.
These are a couple of gifs that show some of the features of howm: http://imgur.com/a/8aqD9
Actually, I would probably use a ".s" file for that (and any other cpu specific code I needed).
I'm not sure if the answers are provided somewhere. I found this book file while searching Google with those advanced searching functions. This seems to be the course homepage http://ocw.metu.edu.tr/course/view.php?id=141
The question was about inline assembler.
It seems this is the course to which these problems accompany: http://www.ceng.metu.edu.tr/course/ceng140. 
&gt; my tool needs to use the capabilities of cp or mount, is the proper way to include cp's source files and call like an API, or not re-invent the wheel and use system('cp ...') ? ? Neither. Calling out to an external program with `system()` is fraught with shell quoting issues that can cause your program to contain shell injection vulnerabilities, although this can be mitigated by using a different API such as `fork()`/`exec()` or `posix_spawnp()` that don't involve the shell and its word splitting. Still, if you're going to be doing this more than a few times, the overhead of creating a whole process to copy a file is pretty ridiculous. And neither would you want to try to use parts of GNU coreutils. `cp` has more options than you can shake a stick at, and it covers all kinds of cases that are likely to be irrelevant to you, like SELinux contexts and POSIX extended attributes. It will also force your code to be under the GPL. I would expect any self-respecting C utility to do its copying itself. Open the source file, open the destination file, copy a chunk at a time in a loop. It should take several dozen lines at most. &gt; I need to create a C tool for linux which manages a certain type of file across N number of network shares (Samba/CIFS or iSCSI). The tool needs to be able to mount, unmount, read, and write. In Linux, this is all saved for superuser. Why on earth are you trying to use C for this? Why can't it be done with a shell script? That's what shell scripts are for. 
Looks very cool, although you should seriously organize your code better. Split it up in source and header files. EDIT: I missed the vim-like part. I will definitely check this out once I get on my laptop :)
It's my first C project beyond small programs from K&amp;R- thanks. :-)
Looks amazingly clean for a first C project. But it's clear he's done development before :)
Most of these programs are just wrappers fo system calls, I believe. try just using the system calls.
What you've posted is totally invalid C. You made a mistake transcribing it. The [actual](http://www.exploit-db.com/exploits/13688/) line should be (*(void (*)()) shellcode)(); The difference matters. `void (*)()` is a type. Specifically it's the type "pointer to function that takes unspecified arguments and returns void." Let's call it just T for sake of readabilty. This is a cast: (T) shellcode `shellcode` is an array of char that decays to a value of type "pointer to char." This is a cast, which casts that value to that above type. Next: (*(T) shellcode) This dereferences that function pointer, resulting in an object of type "function that takes unspecified arguments and returns void." Finally: (*(T) shellcode)(); This calls that function. There is really no "slipping" going on here. This program defines an array of some bytes and then casts that address to a function pointer, calling it as if it was a function. On architectures like x86 -- so called [Von Neumann architectures](https://en.wikipedia.org/wiki/Von_Neumann_architecture), in contrast to [Harvard architectures](https://en.wikipedia.org/wiki/Harvard_architecture) -- there is no distinction between data and code -- it's all just bytes. You can jump to any address in memory and the processor will interpret the bytes there as instructions. (Well, assuming that the page there has been mapped with the execute permission set. It's common to mark the stack non-executable which prevents this kind of thing from working.) Also, this is technically invalid C according to the standard, so there's no guarantee that this will work. You even get a warning from it from gcc at the highest diagnostic level: $ gcc -Wall -Wextra -pedantic -std=c99 -O2 foo.c foo.c: In function 'main': foo.c:24:7: warning: ISO C forbids conversion of object pointer to function pointer type [-Wpedantic] (*(void (*)()) reboot)(); ^ There's no real reason that you'd ever want to do this. You can accomplish the exact same thing without any trickery by merely making the syscall the standard way: reboot(LINUX_REBOOT_MAGIC1, LINUX_REBOOT_MAGIC2, LINUX_REBOOT_CMD_POWER_OFF); Obfuscating that by using type-punning tricks doesn't really accomplish anything. 
Yeah, the code looks really nice! You might want to break howm.c out into different files. 2,200 lines of code is pretty intense. I'm sure there's a way to split that up nicely.
Thankyou for taking the initiative to try testing it and telling me the error present. You said according to the *standard* there was a warning so it could still technically slip for older GNU compilers. (correct me if I'm wrong) I have no idea why you compared two architecture sets. I am sure both have the same functionality, i.e. it's all just bytes in the lower level. (again correct me if I'm wrong) Also the real reason I want to do this is for injecting code via a shellcode launcher. As below: http://www.securitytube.net/video/7881 You heard of [Shellstorm](http://shell-storm.org/shellcode/). Well every shell code script (or nearly) uses that same methodology of conversion to object pointer from function pointer type ect.. I just wanted to know how it worked, hence I'm asking.
&gt; so it could still technically slip for older GNU compilers. There's no guarantee. It works by luck. Invoking undefined behavior means that anything can happen, and the compiler is under no obligations. A future version of gcc might behave differently. &gt; it's all just bytes in the lower level. I wouldn't have mentioned it if that was the case. Read about the Harvard architecture. Code and data use completely different address spaces and it's impossible to execute data as if it was code. 