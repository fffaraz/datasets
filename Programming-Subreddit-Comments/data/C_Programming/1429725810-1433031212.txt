Well, sure you could implement exceptions yourself, but I doubt that's what OP is looking for. 
You can use setjmp and longjmp, but since C doesn't have stack unwinding and destructors called like C++ exceptions, you'd have memory leak issues unless you're very, very careful.
Yeah. I think I'll give it a miss lol. I thought that if they were easy to do, then it might be a quite nice addition to my code which might garner some additional marks, but yeah. 
Put the print statement directly after the closing brace of the if statement. If the guess is correct, it will break out of the loop before then, but each time it's an incorrect guess, it will print it out before restarting the for loop. Hope that helps!
You usually try really hard to make sure that -1 cannot be a valid result of the function to avoid that complexity.
If you've come across assembly, it might help to think of C as portable assembly.
Change it so that it does: Guess a number (%d to %d) or q to quit: 
The problem with your code is that you are not changing the value of `ptr` in the function; you are changing a local variable. But you have to explain what `isn't allowing` means for you if you want real help.
I think you are misunderstanding how pointers work. Pointers point to data, but are themselves a normal value. Think of a pointer as an integer. void assign(int link) { link = 0x4F5920; //some value you are assigning it } As you can probably assume, assigning a value to that integer has no effect on the integer that was passed to it. You can solve the problem by instead passing a pointer to the node to the assign function (without having to get into pointers to pointers). void assign(struct Node *node) { char *string = "hello"; node-&gt;ptr = string; } In this case you are passing the node by pointer, so you access it's internals, you are accessing the actual object, which if you change will change the memory the original object uses. So you are changing the value of the data that the Node pointer points to, and at the same time changing the value of the pointer inside the node. Alternatively. You could just pass a pointer to the pointer and change the data of the pointer you passed to the function to change where the original pointer points. void assign(void **link) { char *string = "hello"; *link = string; } // ... snip ... assign(&amp;new.ptr)
Thank you!
First, (0&lt;=y&lt;=3) is not valid C code... you would need to write 0 &lt;= y &amp;&amp; y &lt;= 3 So in this case if y is between 0 and 3 inclusive, the value of the expression is 1, otherwise the value of the expression is 1 / x The general conditional expression (not statement) works something like a short-hand "if" statement (some_boolean_condition ? value_if_condition_is_true : value_if_condition_is false) (parens are optional if there's no ambiguity) For example x = y &gt; 7 ? 10 :12; is completely equivalent to the "if" statement if (y &gt; 7) x = 10; else x = 12; 
Please do everyone you ever work with a favor, and never ever ever use these "idioms".
errno is thread safe at least. :-) 
That is certainly true, but I tried to keep my code as close as possible to what he had. :)
Not sure what you're talking about, I don't see any leak in your code? Also, are you leaking 20 bytes every time you call PollEvent()? If not, why would you care about leaking 20 bytes once? That's insignificant... Also, don't trust or care about leaks valgrind reports in lower-level libraries (like X11) that may handle memory in various "magic" ways (IPC, SHM, hardware drivers, ...) that valgrind may not understand. 
What you're building there is called a "linked list". That term should help you find lots of info about them. I don't follow what you're doing with the pointers. Normally you'd define the nodes like: typedef struct node { int value; struct node *next; } node; node *oneNode, *twoNode, *threeNode; After allocating memory for them you can fill them out like: oneNode-&gt;value = 1; oneNode-&gt;next = twoNode; twoNode-&gt;value = 2; twoNode-&gt;next = threeNode; threeNode-&gt;value = 3; threeNode-&gt;next = NULL; Normally you iterate through a list with a loop, but if you want to directly refer to threeNode from oneNode you'd write oneNode-&gt;next-&gt;next for example: i = oneNode-&gt;value; // i gets set to 1; i = oneNode-&gt;next-&gt;value; // i gets set to 2; i = oneNode-&gt;next-&gt;next-&gt;value; // i gets set to 3; oneNode-&gt;next = oneNode-&gt;next-&gt;next; // oneNode gets linked to threeNode. twoNode cut out from list.
Check if that continues going on after running your program for a while, and whether any of them are in places other than X11/SDL. Check if after a long time, the memory usage of your program actually goes up, or whether it stays constant. As mentioned, those might just be false reports, due to low-level system libraries doing memory management in special ways, IPC/SHM or interacting with drivers/hardware. If you really are leaking 100+ bytes every time you call SDL_PollEvent(), and you are calling PollEvent() at 60Hz, your memory usage should increase by 20MiB per hour at least.
Same result with lsan. It still leaks : http://pastebin.com/xAkyHefy
The memory usage does go up. Depending on how long I wait it leaks: 1. 800 bytes 2. 9062 bytes 3. 10877 bytes This was not professionally timed and more depending on my feelings.
I think the main difference is that due to process creation (or similar things) the shell version add randomly sleep, context switching, ... which lead to different behavior in your multithread program Welcome to the multithread hell !
It still might be a harmless one-time allocation. Now can proceed in two ways: Either build SDL with debug symbols and dig into it yourself. Or file a bug report after checking this hasn't been reported yet. By the way, the error report should print line numbers, did you compile with -g? edit: Why are you not using SDL_WaitEvent()? The way you loop is written now it would constantly loop, maxing out the CPU.
Time it for longer (like a few hours) and see if it continues to grow or whether it stops after those 10KiB or so. You could make a bugreport, but unless you have some numbers, the devs probably won't care.
To be extra sure, always compile with -Werror and -Wextra: $ gcc -Wall -Wextra test.c test.c: In function ‘main’: test.c:17:9: warning: unused variable ‘myNumber’ [-Wunused-variable] int myNumber = n; ^ test.c:15:9: warning: variable ‘correct’ set but not used [-Wunused-but-set-variable] int correct = 0; 
The tears are real.... 
could do something like so: #define ONE_HOUR 60*60*CLOCKS_PER_SEC long start = clock(); if(clock() - start &gt; ONE_HOUR ) { //...tell user.... 
You're welcome. Regarding the use of typedef, it might seem weird to imagine but code has "fashion" that changes over time, just like fashions change over time in clothes, music, or spoken language. The popular thing to do at one time or within one group of people may be unpopular later or in a different group. The development of modern IDEs and editors with all their autocomplete and instant look-up conveniences had a big impact on what was popular in coding. The tight, highly abbreviated code I learned in the 80s and 90s gave way to a longer, more self documenting style because autocomplete made working with very long names for functions and variables less tedious and error prone. The programmer in your stackoverflow link is expressing a similar fashion preference for more explicit, longer code. For our example it's a trivial argument. Not using a typedef on that struct just means you'll have to type out the struct keyword more often. In my example only one line would change: node *oneNode, *twoNode, *threeNode; //would become... struct node *oneNode, *twoNode, *threeNode; It doesn't matter here which way you do it. As you get into longer projects you'll develop your own preferences. 
Nice! So simple! Thank you very much!
Well, I think you're a little interested or you wouldn't have read it and replied with all that good info and those insights :) I didn't want to not follow up with a source that I had referenced in my "not sure about it but..." comment, especially since I found it so fast. Thanks for the information.
Some questions: * What type is ``files[i]`` in ``main`` and what type does ``test()`` expect? * What is your thinking in using ``return main`` in ``test()``? It looks like you don't know what ``return`` does. Or that maybe you would rather use [a language](http://en.wikipedia.org/wiki/INTERCAL) with ``COME FROM``. ;&gt; * Does the code compile with no errors or warnings? * Returning from ``main()`` exits the program. Why have you put ``exit(0)`` in the program? And, as a general note, you should compile with warnings which will save you headaches. GCC's flag for this is ``-Wall``. As you can see, there's plenty of output and the code you posted doesn't even compile: $ gcc -Wall -o foo.o -c foo.c foo.c: In function ‘main’: foo.c:19:9: warning: implicit declaration of function ‘test’ [-Wimplicit-function-declaration] test(files[i]); //of file to test function ^ foo.c: In function ‘test’: foo.c:34:23: warning: passing argument 1 of ‘fgetc’ from incompatible pointer type while ((c = fgetc(file)) != EOF) ^ In file included from foo.c:1:0: /usr/include/stdio.h:531:12: note: expected ‘struct FILE *’ but argument is of type ‘int *’ extern int fgetc (FILE *__stream); ^ foo.c:36:16: warning: passing argument 1 of ‘fclose’ from incompatible pointer type fclose(file); ^ In file included from foo.c:1:0: /usr/include/stdio.h:237:12: note: expected ‘struct FILE *’ but argument is of type ‘int *’ extern int fclose (FILE *__stream); ^ foo.c:37:5: warning: return makes integer from pointer without a cast return main //return main and continue loop ^ foo.c:39:1: error: expected ‘;’ before ‘}’ token } ^ 
Sounds an awful lot like a homework assignment. If you're in school and learning and stuff, try not to cheat by using this code but come up with your own version. In any event, I **think** this does what you want. #include &lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;stdlib.h&gt; static int randomInt(int max) { return (rand() % max); } static int wrap(int val, int min, int max) { if (val &gt; max) { return min; } if (val &lt; min) { return max; } return val; } static int nextpos(int cur, int min, int max) { int move = (randomInt(2) == 0)? 1 : -1; int next = wrap(cur + move, min, max); return next; } static int sum(int* beg, int* end) { int s = 0; int* p = beg; while(p != end) { s += *p++; } return s; } void main() { int positions[10] = {0}; int min = 1, max = 10; size_t count = 0; int cur = 1; while( sum(positions, positions+max) &lt; ((max+1)-min)) { cur = nextpos(cur, min, max); positions[cur-min] = 1; printf("%d\n", cur); count++; } printf("\nThe number of steps is %d\n", count); } I get 97 w/ seed set to 1 but we could have different random number generators so who knows whether it's what you get too.
A general style point might help with some of these problems, C is fussy with needing semi-colons in the right places and the right number of braces. An error message like the following usually indicates such: foo.c:39:1: error: expected ‘;’ before ‘}’ token An error like this can cause cascading error messages further down, so it's an easy fix to sort these out first. Always end a statement that does something with a semi-colon. I notice the following line appears to be missing one: return main There's another problem with this line as the return command is for sending a value (return code) back to the part of the program the function was called. Your function either "returns" a computed value if the function does a calculation of some kind, or a number which indicates whether the function er... functioned correctly. The following returns an integer zero for some reason that your program understands elswhere. return 0; To make it easier on yourself to find missing/extra braces, be consistent with the style in which you prefer them to be formatted. e.g. either: for(i = 0; i &lt; argc - 1; i++){ do something; } or for(i = 0; i &lt; argc - 1; i++) { do something; } but don't mix/match them.
:)
It depends on how `scanf` is exactly implemented. Short answer, both answers are correct... Longer answer. `char a` would be (usually) somewhere on the stack - since it is a simple program there is probably plenty of room available for the rest of 3 bytes that is gotten from `scanf`. Although that operation may overwrite some other value on the stack. For example try running this program: int main(int argc, char const *argv[]) { char a, b, c, d; a = '#'; b = '#'; c = '#'; d = '#'; scanf("%d",&amp;a); printf("%c|%c|%c|%c\n", a, b, c, d); return 0; } // e.g. // f:\x\mainc&gt;a.exe // 214212521 // ®|♀|─|¤ Essentially the program will work - but it is unlikely that it will do what you wanted it to do. Of course, if the compiler is smarter - it might check that you shouldn't be passing a char pointer as an integer pointer and fail to compile. Alternatively it might crash at runtime as well, if some additional checks are provided.
`scanf("%d", &amp;a)` invokes undefined behaviour because of an argument type mismatch (cf. ISO 9899:2011§7.1.4/1): The directive `%d` requires the corresponding argument to be a pointer to a signed integer, i.e. an `int` (cf. §7.21.6.2/12) but you supply an argument of type “pointer to character” which is undefined behaviour. The `printf` call is fine: You supply an argument of type “signed integer” (due to argument promotion) which is what `%c` expects.
After bit of experimenting: `gcc 4.8.1` compiled and ran the program with no specific errors for this. With`gcc 4.8.2`and `clang` shows an error for doing it: main.c:6:6: note: include the header &lt;stdio.h&gt; or explicitly provide a declaration for 'scanf' main.c:6:17: warning: format specifies type 'int *' but the argument has type 'char *' [-Wformat] scanf("%d",&amp;a); ~~ ^~ %s So if you have turned warnings into errors (`-Werror`) it will fail to compile. Compiling it with address sanitizer (`gcc -fsanitize=address main.c`) will make it crash at runtime. tl;dr; the behavior is unspecified by the C standard and hence the behavior is unspecified.
The standard (C11 7.21.6.2 The fscanf function /10) says that: &gt; If this object does not have an appropriate type, or if the result of the conversion cannot be represented in the object, the behavior is undefined. There **is** a problem with the code, as *scanf* has no way to know at run-time that `&amp;a` is a pointer to a char rather than a pointer to an int. As "the behavior is undefined", the program is technically free to do whatever (["it is legal for it to make demons fly out of your nose"](http://www.catb.org/jargon/html/N/nasal-demons.html)). It depends on the compiler, OS and so on. It probably won't actually crash, at least not immediately. Rather, it will write an int to the stack instead of a char, overwriting whatever is after the place where the char should be (assuming that `sizeof(int) &gt; sizeof(char)`, which is very likely). That might make the program crash later, or it might have no effect and go unnoticed (that is, until you switch to a different compiler which does things in a slightly different way).
There could be a crash. you're allocating a single byte (a). The scanf will write 4 bytes to that location. That means it will overwrite the 3 bytes following the 'a' variable. Whether the program will crash or not depends on what data is stored in those 3 bytes.
Your teacher is wrong in that there is no guarantee of crashing, right in that this is a malformed program. In c you cannot always just observe the behaviour of the code at runtime, as you end up observing a single instance of an implementation. This example invokes undefined behaviour in the call to scanf as the format string and variable type do but agree. The correct answer here is that the code might kill your cat.
It's technically **undefined** ("use of a nonportable or erroneous program construct or of erroneous data, for which this International Standard imposes no requirements") rather than **unspecified** ("use of an unspecified value, or other behavior where this International Standard provides two or more possibilities and imposes no further requirements on which is chosen in any instance"). The distinction is important: * Undefined: This is wrong. Don't do it. * Unspecified: Be careful and don't rely on it working this way. It may be different in other implementations. Example from the standard: "the order in which the arguments to a function are evaluated".
Yes, I stand corrected.
I see, thank you. Was hoping for easy way out !
Gave it a try in Xcode on OS X. The scanf call hangs indefinitely. Interrupting it with the debugger you find execution stopped on a jae instruction in a function called read_nocancel. 
I just tried this and my neighbors house caught fire and burned to the ground. 
I'm using gcc 4.9.0 on a Gentoo system. From other tests I've done with gcc, I know that it reorganizes variables on the stack to provide faster access to them. I guess for whatever reason 4.9.2 reorganizes these variables slightly and puts `d` in the memory location directly after `a`. Since they're never used it doesn't really matter the order.
No. A char in the stack will typically be of size 1. Probably because the function call alligns the stack that it causes no error. But run a code like int main (void) { char d, c, b, a; a = b = c = d = 'a'; scanf("%d", &amp;a); printf("%c%c%c%c\n. a, b, c, d); return 0; } When calling a function, though, a char and an int will have the same size in x86_64 on Linux and OS X for sure (don't know Windows). Edit: I know in GCC 5 the ABI is changed, but I don't know how. This example may be affected.
I'm a physics student at university, and I use C fairly frequently with that. It's a low-level language, which makes it good for writing performance-critical software, like simulations and whatnot where slow algorithms and poor memory management can result in runtimes measured in years rather than minutes. Things that have to run in tiny amounts of memory or have to run as fast as is at all possible are good candidates for C programs. C programs can also generally be compiled on any piece of hardware ever created - it's one of the most (if not *the* most) portable langauges. More modern langauges have a lot of features which make it easier to write programs, but at the expense of speed and memory usage. C can be used to write anything really, but unless memory or speed are critical or the hardware you're writing for doesn't support anything else, there's probably a more modern language which is easier to write quickly with.
What's the purpose of calling your `destroy` function rather than just calling `free` directly?
I am more comfortable doing it that way as well, but for the sake of this project it has to be done with a function.
You have to free everything you allocated. This means that you need to call `free` as many times as you called `malloc`, no more, no less.
Wouldn't it only need to be used once in the destroy function? Since each pointer is being passed through it.
&gt; Since each pointer is being passed through it. What do you mean by this? Do you mean that a pointer to *each node* in *every list* is individually being passed to the `destroy` function? Where is that happening? Or do you just mean that a pointer to the *first* node of each list is being passed to the `destroy` function? Because if that's what you mean, then you are freeing only the first node of each list.
No, this isn't freeing all the memory. Specifically, it's freeing the memory in the specific node passed -&gt; the first node in list. You probably want to iteratively (or recursively) go through each node and free them from bottom up
Cool. We are learning it in uni as a must language for EE. It's best to program microcontrollers with it(as far as I know). But it is possible to do it with C++ as well. And well, with javascript (node.js) too recently. C seems to have slow learning curve though, especially at pointers. By the way, when allocating memory to a char within struct array. How to free it afterwards? with loop? while(condition == 1) { struct_a_buff = (struct_type *)realloc(*struct_a, sizeof(struct_a) * (i+1); struct_a_buff[i].string = (char*)calloc(30, sizeof(char)); struct_a = struct_a_buff; i++; } and freeing: for (count = i; i ! = 0; i--) { free(struct_a[i].string); free(struct_a_buff[i].string); } free(struct_a); free(struct_a_buff); Is this valid? 
It needs to be dynamically called exactly as many times as malloc. That is, you don't need to have as many free() calls in the source code, but during runtime you need it to happen as many times as malloc. For a quick debug test, add these to the top your file: static int a; void * malloc_(size_t s){ a++; return malloc(s); } void free_(void * p){ a--; free(p); } use `malloc_` and `free_` in your code instead of the originals, and then add a `printf("%d\n",a);` to the end of main. If it's not zero, you have a problem. To fix this, `destroy` (which is a bad name, if it's a function meant to clear lists, call it destroy_list instead) has to iteratively or recursively walk over the list.
Please come back with detailed questions. This is not the right place to ask others to do your homework (you might find that such a place does not exist). Also, stop putting things in ALL CAPS, one exclamation mark is enough, too.
 void destroy(Linky *p) { Linky *n = NULL; while (p != NULL) { n = p-&gt;nextPtr; free(p); p = n; } } Starting with a link pointer (which might be null): record the next pointer, free the current element, make next current. You want to stop whenever the pointer you are about to dereference is NULL. 
I tried implementing this but it seems to loop infinitely. I've only been programming for a few months, and I'm really struggling with pointers and addresses. I did append a few print statements to break down what is going on in your loop and it appears to be on the right track. I'm attempting to modify it now to terminate properly.
HELP
Two issues: 1) Your `fill_array` function doesn't do what you expect. It isn't even using its arguments. 2) You are passing `a[10]` to `fill_array` but `a[9]` is the last element in the array.
You need to add &amp; in the scanf line scanf("%d", &amp;undersok); Also passing n to frekvens is unnecessary as you know the array is of size 10. Also you are only filling the first 9 elements of the array. Edit: fill_array is completely misbehaving.
.
There's also something weird about your string: thing is 5 characters long but strlen( &amp;thing ) is 3.
Yes, thanks.
1. The fillarray function will not actually fill any array in main. You are passing two integers to it, and filling the array in a local variable. You should make this function better fillarray( int arr[], int n) Call it with fillarray(arr,n) 2. The value of n should be set before calling this function.
The example has four explicit characters as `\0` represents the NUL character. C strings are NUL terminated, so it doesn't consider the explicit NUL part of the string, thus strlen returns 3 for `h`, `e` and `l`. A C compiler will automatically add a NUL character to a string literal so specifying it is usually redundant.
Improve the error checking first. * check if `malloc` does not return `NULL` * check that `scanf` returns `1`. (It may return `0` or a negative value depending on which failure mode occurred) * The scanf must include buffer overflow protection: "%29999[^\t]". Your first `for` loop is confusing and has a redundant test, I guess you meant: for (int j = 0; j &lt; 27; j++) alphamatch[j] = 'a' + j; Not sure if you meant `27` or `26` . (the former will include one character after `z`). In the second loop, I don't see why you put `-1` on `strlen(buffer)-1`, it just means you won't process the last character. Using `l` as a variable name is very unreadable; suggest any letter other than `l` or `o` (or `I` or `O` either). The `(isalpha(buffer[l]) != 0 &amp;&amp; isspace(buffer[l]) == 0)` could just be `isalpha(buffer[x])` because no alphanumeric characters are spaces. In fact I am struggling to see what the point of this whole loop and `alphamatch` are instead of just using `isalpha` .
Those casts are redundant, the operands of `-` are promoted to `int` if they are of a type narrower than `int`.
That's why it's weird.
Arduino is literally meant for basic robotics and basic (to complex) electrical circuits additionally it's meant to be ***cheap***. Though you don't actually work on a Arduino you work on a laptop with the arduino developer environment then load (flash) your program to the arduino board. RPI can do basic robotics but it's more geared complex systems plus it's more expensive for the break out board and what not. You would be writing C code on the RPI its self and executing it from the RPI since it's a literal self contained computer. I see a lot of people play with Arduino's first and build cool and silly devices and then for more serious projects (Home Theatre, Classic Arcade Machine, Home Automation) use RPI. Also, if the RPI isn't powerful enough for your needs, there's always an oDroid. 
Great, thanks!
Having used both for simple and complex projects, I would definitely choose an arduino to learn electronics / robotics. Much easier to work with, cheaper and very well documented.
Mmm maybe I should have been a bit more clear. The size would still be 1 byte on the stack, but there will be additional bytes padding the 1-byte to be aligned with the register size (or memory size). Which means when scanf is called with an int the extra bytes on the stack over-written will be the padding, so nothing bad will happen.
&gt;The Arduino language is called "Processing", and is very C like but not straight C. It's a mix of C and C++. You can write plain C for the arduino.
If that is literally what you have, then `struct X` does not mean the same as&amp;nbsp;`X`. In `struct X`, the tag&amp;nbsp;`X` is completely unrelated to the meaning of&amp;nbsp;`X` defined by the `typedef`, because they are in different name spaces.
It might help if you post the whole code in question.
Take a look at the resources listed in the toolbar. Since you have already taken an intro to Java course, you'll already understand many of the basic concepts. 
Unless they're in another file, you're never defining those variables.
i have an assignment where we have to time how long it takes for 2 different programs run and are only given the 2 for loops and the dst line (the other program is similar but the i and j's are swapped around). i have all of the other stuff figured out (i hope) but cant for the life of me figure out how to declare the dst and src in the program. due to a change in how our class track changed i learned basic java but now they teach c instead and this class expects you to have learned c (which i didn't) so im kinda in a rutt :P i just don't know what type it is. tried declaring it as an int and a char but neither compiled correctly. here is the picture of the whole program so you can get a better idea http://i.imgur.com/PzOWZZ8.png
&gt; Hi, I did this program for my class, now i have to change it all to pointer notation. Im having trouble with replacing "array[i]" with pointer notation in my functions.. how do you increment pointers like you do with a for loop array[i]? -thanks I didn't take the time to read your code because of the formatting and the size. If you're asking a simple question, you should post a simple, well formatted piece of code, and then turn an answer about that piece of code to your larger project. `array[i]` is by definition `*(array+i)`. Arrays can be converted implicitly to a pointer to the first element of the array. To explain: If you say `*array` that is the same as accessing the first element of the array since `array` will be converted to a pointer to the first element then dereferenced. Pointers have some special arithmetic operations, called pointer arithmetic. `array+1` will be a pointer to the second element of the array. For example, suppose `array` is an array of 4 ints (and say ints are 4 bytes) arranged in memory as: 10 40 -23 145 0x10 0x14 0x18 0x1C Then: printf("%p\n", array); // prints 0x10 printf("%d\n", *array); // prints 10 printf("%p\n", array+2); // prints 0x18 printf("%p\n, array+4); // prints 0x20 Note: it's okay to take the address of the "one past the end" of the array, but it is illegal to dereference it. 
If you are assigning the thing like `dst[i][j] = ...` what kind of object by `dst` be?
that my problem. i have no idea. if i knew that then i could figure it out but i haven't encountered something like this before o.0
That's a bit different because here they have been given the line that has `dst[i][j]` and they need to declare the variables.
`dst[j][i]` is also something you were encounter in Java, although you declare it differently in Java. `dst` is called an array (specifically a two-dimensional array). 
Have you been asked to do this assignment before you've been taught arrays? That seems strange, but if so, then I guess you're expected to search for something like "C square brackets", which gives you loads of results about arrays.
yea sorry i should have been more specific.. heres what im talking about.. void strfilter (char *arr, char *s2,char c) { for (int i=0; i &lt;= 20; i++) { for (int q = 0 ; q &lt;=40; q++){ if (s2[i]== arr[q]){ arr[q]= c;} else continue; } } } ///////// how do i take "if (s2[i]== arr[q])" and replace it with pointers and still be able to increment them. and with your answer im thinking of trying this "if (*s2+i== *arr+q)" 
its hard to explain. depending on your specific major they altered the course tracks differently. originally i wasn't supposed to be taking this class but after they messed with everything i ended up in it. i was supposed to be taking 3 semesters of java but ended up with only 1, no class on C, but then ended up in a class where they expect you to already know C before going into it. so they expect you to already know arrays and such but a handful of us know nothing about them. this is more of a hardware/assembly course but they throw C projects at us and we either have to already know it or figure it out :/
You cannot use variables in declaration of array. At the beginning of the code you must precisely assign its value. It's a 'beauty' of C. You can also make dynamic array but you must use pointers and function like malloc to assign a field in memory. I recommend you read e.g. K&amp;R's book
did a bit of research, made up an array, and got it to compile but get an "segmentation fault (core dumped)" error. i read up that it means i tried to access memory that i do not have access to but not quite sure where the error lies. anything in particular jump out at you? http://i.imgur.com/SkpbM9r.png
You are only declaring the arrays to be 3 by 3. In the for loop you going way outside of that, for example, by assigning to `dst[511][511]`
&gt; didn't know that if you didn't specifically define something it would just take it as a 0 It doesn't. This is very specific about when you are initializing an array using that brace notation, if the number of elements you specify is less than the number of elements in the array you are declaring, C will make the rest 0's. Do not generalize this fact please. &gt; thanks a lot for the help man, i really appreciate it :) No problem.
note taken
Why do you have hard copy reference material? Seems it'd be faster to get information online. 
A talented programmer is someone who knows their shit and writes quality code in reasonable time. This has nothing to do with relying on reference material and google searches (though, tbh, if you need to look up how to code a for loop everytime, you're probably not talented). Knowledge of using search engines and reference materials is a vital real-life skill in itself. As a side note, the word "talented" is a pet peeve of mine, since it implies an inborn ability, while in reality skills like this are an acquired feat.
Hope your cancer treatment is going well and that you are kicking its ass!
I'm pretty new to writing code, but I thought they were being defined with 'extern char' in global.h. I suppose that's not the case? Where and how should I go about defining these variables? This is some older code that I have updated to a newer architecture so I can change a couple lines out for our new firmware chip.
&gt; I thought they were being defined with 'extern char' in global.h. I suppose that's not the case? No. Those are declarations, not definitions. The whole point of using `extern` in this context is that it turns a definition into a declaration. And that's what you want in a header, because a header is meant to be included in multiple translation units, and if it included definitions then that would result in multiple definition errors. (Note: some systems put global definitions in common sections which masks this error, but it's still an error.) In C, if you want to use a global variable, you need a *declaration* in every translation unit that will access the variable, and a *definition* in exactly one translation unit. That's usually done by putting a line like `extern int foo;` in a header which is included in every TU that accesses the variable, and then by putting a line like `int foo;` in exactly one .c file, not a header. That takes care of the definition. The definition is what actually causes memory to be allocated for the symbol, and for it to exist in the symbol table as 'defined'. Symbols that are never defined result in undefined symbol errors from the linker. Symbols that are only ever declared exist in the symbol table as 'undefined', which means when the linker needs to resolve the address of that symbol it cannot, because nobody ever allocated it anywhere, hence the undefined symbol error. 
Well, I got main.c to compile by adding "char" followed by my variables, but I'm still having trouble in the assembly file. I tried adding "export" and my variable names at the beginning of the file, and that seemed to work until I fixed the errors in main.c. Now they're back again.
I've never met a baby that could code.
In what city do you see "Talented C Programmer" all the time? In the last 5 years I have maybe seen one job requirement list C but most of the time they specifically want C++ or an entirely different language like C#/Java or Python. While C is pretty popular in open source I haven't seen it advertised "all the time" online in local job boards.
Please don't advocate piracy in this forum. It gives programmers a bad name.
Because books aren't commercially available in PDF... Welcome 2015, nice of you to join us.
As far as I can determine, there is no legally available PDF version of K&amp;R. There is a Kindle version. Do you know otherwise? If so, please share where it can be found. Otherwise, leave the grown-ups alone.
PDF/MOBI/etc all readable on a tablet. Thanks for splitting hairs, gramps.
&gt; methods NOT HIRED. ;)
It was actually released with much fanfare.
K&amp;R book, and Unix Network Programming.
It's not "pointer 2 `int`", it's "pointer to `int`". As in, "this pointer points to an `int`". I assume you've only ever heard it being said, not read it. "Pointer to `int`" and "`int` pointer" are synonymous. The `&amp;` operator is the "address-of operator". Quite simply, it gets the address of an object. That is, `&amp;x` gets you the address of `x`. Pointers store addresses. So if we have `int x;` and then do `int* ip = &amp;x;`, we are getting the address of `x` and storing it in the pointer `ip`. The `*` operator is the "indirection operator" (also known as "dereferencing"). It does the opposite of the address-of operator. That is, you give it an address and it gives you the object at that address. The whole point of pointers is to implement what we call *reference semantics* or *indirection*. Variables are named objects which are scoped to a particular region of code and we can only access the object within that region by using the variable's name. What if we want to access an object from some other bit of code? Consider the following: void increment(int y) { y++; } int main() { int x = 0; increment(x); return 0; } What is the value of `x` at the end of `main`? It's still 0. When we pass `x` to `increment`, we pass only its value. The `increment` function has no way to actually modify `x` itself. However, we could pass the address of `x` to `increment`, which gives `increment` a way to access the original object (through its address): void increment(int* p) { (*p)++; } int main() { int x = 0; increment(&amp;x); return 0; } Read this carefully. We declare an `int` called `x` which we initialise with value `0`. We then take its address with `&amp;x`. We pass the address to `increment`, which takes a "pointer to `int`". Inside `increment`, we perform indirection with `*p` to get the original `int` object, and then increment it with `++`. If I were you, I'd avoid looking at C++ resources right now because it might confuse you further (`&amp;` has an additional meaning in C++).
Unfortunately, it means whatever the person saying it wants it to mean. :P
Probably be better off with C in a Nutshell and/or Understanding and Using C Pointers IMHO. 
&gt; I would laugh at someone This sub is about helping one another. This type of comment is not only unhelpful, but rude. Please consider this before making future posts.
"Understanding and Using C Pointers" ... how did you arrive at the conclusion that I don't understand pointers?
+1 for noting the usual/correct use of talent/talented — it's a *natural* ability.
PDF. EPUB. HTML. TXT. MAN. ?? No? But carrying dead tree references are good weight-bearing exercise I guess. BTW, look at [Dash](https://kapeli.com/dash) for a sweet reference utility if you use a Mac.
That is a gracious response to a childish comment.
Jeez, many people like to have hard copy of books, both books for pleasure and books for learning. It's impractical to own hard copies of every reference work you're going to need, but for the essential ones that are also a pleasure to read, I can imagine going through a phase of wanting to have a hard copy to dip into when I'm not working, maybe I'm sitting on the bus, or at home when I don't want to have the computer/tablet in my hands.
So far, I figured how to print out the correct number after all guesses have been used. However, I am now, at the moment it seems, stuck on printing out how many guesses remain after guessing incorrectly. Am I going the right direction? Outside of the IF statement there is the printf("Try again. Number of guesses left: %d\n", MAX_GUESSES - 1); However, i'm not sure if that's entirely the right track to go on.
That doesn't make it a good reference book.
That is definitely on the right track. The only problem is `MAX_GUESSES - 1`. That would tell you how many guess you have left if you had only guessed `1` time and will always give you the same number. How would you change this to tell you how many guesses you have left if you have guessed `guessCount` times?
Thank you, I was able to figure it out. I decided to add MAX_GUESSES - guessCount, and that straightened it out. My only issue is how do I go about including the guesses? Like, how would I be able to start the program and then it say that I have 3 guesses to solve? When I ran, all it did was count down from 3, and not include 3 itself
Yeah, that's what I did. I just added a printf() at the start to state that there are 3 guesses, and hopefully it'll be implied that you are on guess 3. Thank you for your help!
That's not what I meant. I meant put the `printf("Number of guesses left: %d\n", MAX_GUESSES - guessCount);` line at the beginning of the loop (*inside* the loop). I've just changed the message to not say "Try again". If you do want it to say "Try again", you'll need to put `printf("Try again.\n")` at the *end* of the loop (inside the loop).
OP is not bothered by carrying books. OP is bothered by what the term "talented C programmer" may mean: "someone who has C ingrained in the brain and rarely needs to look at books, or manuals, for reference. Someone who rarely Google's for help on coming to a solution to a problem." OP is not boasting about carrying reference materials. OP is saying that he disagrees with the aforementioned interpreation of "talented C programmer". Presumably (and I would agree), OP thinks that one need not be a master of every nuance of the language in order to be considered talented. OP is not saying he may be off base about carrying books. OP is saying he may be off base with his thoughts on what it means to be a "talented C programmer". Your response is off-topic because it does not address the main point of the thread: what the term "talented C programmer" means. Instead, you missed the point entirely (i.e. that OP uses reference materials instead of memorizing the nuances of the language), and you make fun of OP's choice to use physical, rather than digital reference materials. I'm a professional C programmer. I understand bluntness. Here's some bluntness: You misread OPs original post, and then made fun of him. You're a jerk.
I applied at Robert Half, thought was just going in for paper work, next thing I knew I'm taking a test on the computer, to see how "talented" I was. They want that shit quantified. Tons of interviews, no job. I suck at interviews
Was 10 years ago, and .NET. I don't remember any of it, and I'm sure it has changed since then. Was multiple choice though.
Neither is really ideal imo for learning, due to the weird quirks you will run into on both of them, but they are both good choices if you want hobbiest/robotics etc. type things. Which you go with depends on what you want to do. RPi is better for complex projects that you want to turn into an appliance. Like, for example, if you wanted to make a web controlled thermostat. It is closer to an actual computer. The Arduino is better if you wanted legit robotics. As in servos, motors, infrared remote controls etc. You can sort of cross over a bit between the two, but it can be awkward. i.e. you can make a super basic http api on the arduino, but it would be much easier to do on the pi. Similarly, you can control motors with the pi, but you may get glitchy controls (due to a non ideal timing circuit).
Bithush, I own the C# 5.0 Nutshell book and I have to admit I do turn to it more than my Addison Wesley, and Microsoft, versions. It's very well written and formatted. I've just checked out the C Nutshell book and it does look great and very in depth. I've put one on order ... PAPER version :p Thanks for the suggestion :)
Compare your description: &gt; Writing a program for class that must read a string/line from a user with this line of code: scanf("%s", string1); This line only reads in a single *word* of text from the user, stopping at the first whitespace. If you want the whole line, you should probably use `fgets()` instead. The reason the sum and the hash are the same is that the sum of all the characters in the first word are smaller than 509.
thanks guys appreciate it! 
Use fgets() to read an entire line and not die horribly when the first word is 100 or more characters wrong.
Thanks
Thanks
I got 9/10 on the test. The question I got wrong was: Which of the following items should generally be declared using C's volatile keyword? Response: A memory-mapped peripheral status register A global variable used within an interrupt service routine A global variable used by multiple tasks in a multi-threaded application All of the above My gut feeling ended up being the correct answer, but I actually chose the first answer :( I also took a bit of an educated guess on the question: Which ANSI C compilers allow a variable to be declared both volatile and const? And got it right. My background is programming ASM &amp; C(++) for about 18 years now. I have done lots of embedded as well.
Hey, I'm just finishing a C class right now meant for UG students that have ~2 courses in Java, which is basically where you are. PM me and i'll send you the course website, which contains every lecture, ppt, and 10 assignments. It sounds very appropriate for you. 
&gt; awaits corrections from people far more experienced and intelligent than me Naw, i think you did a great job. I would only add a small note on the irony that a function called 'getchar' returns an *int*. Crazy, right? heh. Humor aside, that fact could one day have an important ramification for your/someone's code, however unlikely. 
To be talented you have to be fluent in C. You have to be able to write clear code without looking at references, and be able provide accurate estimates of how long something will take. Beyond that talent is subjective. C is a fairly easy language to pick up and the majority of what is considered talent is really about getting things done which is all about understanding the tools and the libraries. It is not enough to ask someone if they are talented in a language, you have to also understand how they have used it in the past and if they understand the types of coding projects they will likely work on in the future. 
&gt; 1) What is the significance of the c in char c. I put a, b, c, or d in it's place and it gives me the same results. There is no significance. 'c' is just a variable name and you could have used nearly anything you want. 'my_character', 'foo', 'banana', etc. It is just a name. &gt; 2) How would I chance it so that it changes all the characters inputted instead of just the first one? &gt; You would use a loop of some sort. But remember -- you actually have to enter more than one character to get this program to work. You have to enter a character then hit the enter key. Imagine what would happen if you had a second getchar() call in there. It might be an interesting experiment.
Wow, I feel idiotic. I didn't even think of that....Bah, I still got what I generally needed, but I will keep this in mind for future projects.
Edit. Just realized you said c++. You can disregard my comment. To use a struct in C, you have to say struct nameOfStruct varname; So for example. struct point { int x,y; }; struct point myPoints[5]; Because of this it is common to use a typedef. typedef struct { int x,y; } point ; point myPoints[5]; 
`char c;` should be `int c;` . To understand why, read the documentation for `getchar`. Which is a good idea to do in any case. To get help with code, post the code you are having trouble with. Nobody knows what you did when you "try to add more than 1 character". 
You don't have to type struct every time you use it.
Replace the "while" with an "if"
strchr() doesn't replace anything. You're doing that with the following line. 
Your struct doesn't have a default constructor. Therefore `Reading temps[50];` won't work.
Just a few comments on the code, not really that helpful: What if I only have two initials? What if I enter a non-int value for my age (a decimal/real number or a word for example)? Just some thoughts on the design of the code, they don't answer your question but they're worth thinking about.
Try breaking the scanf_s line into separate lines (one for each input). That way, if there's anything wrong with the combined line, it'll be easier to track down. Edit: also, I didn't mean to find off as mean or passive aggressive with me original comment. I've seen plenty of production code that doesn't cover the 'what if' cases, so I thought I'd bring it up.
scanf was unsafe because it takes *anything* the user enters and attempts to ram it into wherever you told it to. You might ask "Enter your full name:" and you pass in a buffer you think is large enough to hold names, but the user might enter the full text of war and peace and boom there goes your program. User entry needs to be treated like the plague, you have NO idea what the user will enter or how long it will be. I don't recommend scanf_s either, to my understanding that's a microsoft only half measure. You should use fgets.
&gt; I would only add a small note on the irony that a function called 'getchar' returns an *int*. Crazy, right? heh. Isn't it because chars are internally represented as ints because they used to be the same size? Also, because chars are ints. 
yes that's true, and to refer to the struct within its declaration (e.g. for a linked list) you need to use "struct point" since the typedef hasn't finished yet
They're just decimals. Somebody was too lazy to type 0.0 or 1.0 They're in there because the author is trying to force the expression to be handled as a floating point calculation.
ok, thank you
TIL. Thanks!
Ah, of course you are right, I didn't realize that.
ok that makes a lot of sense!
`0` is an `int` literal. `0.` is a `double` literal. If they had written `0/0` that would have been integer division, which would have invoked undefined behavior.
Shouldn't you know this if you wrote it? If you didn't write it, and you copied and pasted it from somewhere, then you shouldn't do that. Never copy/paste stuff that you don't completely understand. 
It's because the return value has to be able to represent `EOF` in addition to any valid character, so a type wider than `char` must be used. 
[Juniper's JunOS.](https://en.wikipedia.org/wiki/Junos) 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Junos**](https://en.wikipedia.org/wiki/Junos): [](#sfw) --- &gt; &gt;__Juniper Junos__ is the [FreeBSD](https://en.wikipedia.org/wiki/FreeBSD)-based operating system used in [Juniper Networks](https://en.wikipedia.org/wiki/Juniper_Networks) hardware routers. It is an [operating system](https://en.wikipedia.org/wiki/Operating_system) that is used in Juniper's routing, switching and security devices. Juniper offers a [Software Development Kit (SDK)](https://en.wikipedia.org/wiki/Junos#Junos_SDK) to partners and customers to allow additional customization. The biggest competitor of Junos is [Cisco Systems](https://en.wikipedia.org/wiki/Cisco_Systems)' [IOS](https://en.wikipedia.org/wiki/Cisco_IOS). &gt;==== &gt;[**Image from article**](https://i.imgur.com/1MBGtzX.jpg) [^(i)](https://en.wikipedia.org/wiki/File:Junos_sw_logo.jpg) --- ^Interesting: [^JUNOS ^– ^Young ^liberal ^NEOS](https://en.wikipedia.org/wiki/JUNOS_%E2%80%93_Young_liberal_NEOS) ^| [^Yuzu](https://en.wikipedia.org/wiki/Yuzu) ^| [^Juno ^Awards ^of ^1975](https://en.wikipedia.org/wiki/Juno_Awards_of_1975) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cqsjlcd) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cqsjlcd)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
If you don't have the struct tag attached then you've either typedef'd it or you're not using a c compiler.
A third case: fgets *doesn't* completely replace scanf *and* there's still no situation where you want to use scanf. scanf can chop input up into variables using what's called a format string. fgets can't, but that's not an acceptable reason to use scanf. You can read the user input with fgets then chop it up once you safely have it in memory.
Make a default constructor for Reading by adding default arguments: Reading(int h = 0,double t = 0):hour(h),temperature(t){};
You read your names into `namesArray2`, and then every node you create just stores a pointer to the string contained in this array. As you read new names into `namesArray2`, the nodes continue to point at this array and therefore see the new name. By the end of this program, this means that every node's `name` pointer is pointing at the last name you read into `namesArray2`. If you only ever create one array of characters into which you read names, how could each node possibly have its own string? You're going to need to create arrays of characters for each node and copy/read the names into them.
`double complex* z = malloc(sizeof(double complex));`
z-&gt;member = something
Changed wrap() to return val[3] how do I resolve my issue with nextpos()? thank you
Yes I am only allowing movement to the six nearest neighbours strictly along x, y, or z - no diagonals so to speak I am unsure how to resolve the issue with wrap() now given that returning val[3] is wrong. Maybe is is val[]? I am new to C programming, apologies for the slowness
Correct. I can't imagine why I typed that. Whilst I didn't mean malloc[0], I thought it took an extra size parameter and just grew into the dest buffer, but it looks like it doesn't. I'm probably thinking of the myriad of _strcat_s_super_Safe_ variants. [0] strdup is the only one I know off the top of my head that will call malloc for you
Ok, it's been a while since i've played around with C so bear with me! (Maybe think about commenting your code! Will help us see what you're trying to do exactly :) ) So let's look at the wrap function. If the position (an array of size 3) goes outside the limits in any direction, we would like it to wrap around. Instead of copy pasting look into using loops like so: static int *wrap(int val[3], int min, int max) { int i; for(i=0; i&lt;2; i++){ if(val[i]&gt;max) val[i]=min; else if(val[i]&lt;min) val[i]=max; } return val; } So nextPos takes the current position and returns an adjacent one, right? static int *nextpos(int cur[3], int min, int max) { int randvar = randomInt(6); int next[3]; for(int i=0; i&lt;2; i++)//copy current position next[i]=cur[i]; if (randvar == 0) {//up next[1] +=1; } else if (randvar == 1) {//down next[1]-=1; } else if (randvar == 2) {//left next[0]-=1; } else if (randvar == 3) {//right next[0]+=1; } else if (randvar == 4) {//forward next[2] += 1; } else if (randvar == 5) {//backward next[2] -=1 ; } return wrap(cur, min, max);//and wrap the position before we return } Now, to simplify sum a little bit. You want to take a start position and end position (array of size 3), yes? So there's a couple small things. In main where you call sum, you are passing it 2 arguments: a 3dimensional array (10x10x10) as the first argument, and for the second argument you are trying to add 10 to this same array. Are you trying to add 10 to every element of the array? If so, then you might want to iterate through the array and increase each element by 10 (Google nested loops + multi arrays ). When passing an array as an argument, there is no need for the square brackets, just use the array name. For sum, you have defined it to take 6 arguments, which you use to make 2 arrays. I think you want to use 2 arguments which take the form of arrays, maybe something like this: static int sum(int beg[3], int end[3]) { int s = 0; int p[3];. . . . . . Hopefully this will help you along some of the way... There's still plenty for you to learn. Maybe go through a few more C tutorials. Google the error messages your compiler gives you too... This is also gonna give you grief: positions[cur[]-min[]] = 1; Hint: To access an element of positions you need an integer in the square brackets. Another tip: [Rubber duck debugging!](http://www.rubberduckdebugging.com/) 
You are going to need to define "proficient in java". Since there are many concepts in java that are mirrored in C, abet, most are covered up with nice syntax sugar. Basically, pointers act almost exactly the same way as Objects do in java (in terms of passing and such, C doesn't have member functions/methods). They have the same semantics, they just have different syntax (which CAN be confusing). They are also more dangerous! Since you can do pointer arithmetic. Just try not to unless you really understand pointers. Example time kiddies. Java // ... inside some class static class Foo { int x; int y; } void doSomething(Foo bar, int n) { bar.x = 10 * n; //set x bar.y = 10 * n; //set y n = 10; //does nothing bar = null; //does nothing to passed Foo } void callIt() { Foo bar = new Foo(); doSomething(bar, 5); } C struct Foo { int x; int y; }; void doSomething(struct Foo *bar, int n) { bar-&gt;x = 10 * n; //set x bar-&gt;y = 10 * n; //set y n = 10; //does nothing bar = NULL; //does nothing to passed Foo } void callIt() { struct Foo *bar = malloc(sizeof(struct Foo)); //C does not have 'new' doSomething(bar, 5); free(bar); //it lacks a GC as well, so you need to clean things up yourself //every call of malloc and calloc needs a call to free } void callIt2() { //if you only ever use Foo in this function you can instead do this struct Foo bar; doSomething(&amp;bar, 5); //&amp; means 'address of' //cleaned up automatically, as it was a variable } A gotcha here is that if you pass a null to the Java one, you get a NullPointerException, where as in C, you get 'undefined behavior', usually this will throw a segmentation fault, but it doesn't have to. Something to note in the C version here is that to use a struct you must either typedef it or prefix it with "struct ". So you could have done `typedef struct Foo { /* snip */ } foo_t;` and just use `foo_t` in place of `struct Foo`. The `_t` isn't required, you can name it anything you like (except things already with the name). Another major difference is that in C you don't pack a single primitive inside a class or an array of 1. void retByRef(int[] n) { n[0] = 55; } C void retByRef(int *n) { n[0] = 55; //*n = 55; is also acceptable here }
 complex double *z = malloc(sizeof *z); *z = 1.0 + 2.5 * I; printf("%f %f\n", creal(*z), cimag(*z));
You're the one that told it to print when it does. If you want it to wait until eof, you can read until the end, and then output it instead of doing it every line. You'll have to handle reallocing memory; it's much easier to have a buffer, read into that, process it, and then reuse it. But if you want to slurp everything into memory you'll have to handle resizing the memory.
This program is C++, not C. My C++ skills are pretty rusty. I don't recall much about cin/cout (since I use C io even in C++, because C++ io streams are stupid imho). while (!(answer == "yes" || answer == "no")) You poor sod, just use... while(answer != "yes" &amp;&amp; answer != "no") Also `while (!(cin &gt;&gt; tempCredit))` will probably not work the way you expect it to. 
&gt; I don't know how to read the reviews and compare them to the lists. any help would be greatly The basic idea is that you iterate through the movie review, and for each word you search both lists. So your program needs a notion of a 'current word' as you read through the movie review. You can do this by reading through the movie review file character by character, building each 'current word' as you read it, and discarding the word it when you're ready to move to the next one. One way is to start with the 'current word' being an empty string. Start reading characters from the file. When you read each character you decide 'is this character part of a word?' If it is, then you modify your 'current word' by adding the character. If it's not part of a word, then that means you've read in a whole word, and now you can search the lists of positive and negative words. After searching the lists, you're done with your 'current word' and can set it back to an empty string, so you can start reading in the next word.
If you know how to read in the words to the linked lists, what don't you know about how to read in the reviews?
Keep in mind that there are many ways to do this. Depending on the size of your lists of words, it might be easier to loop through the linked lists searching for each word in the reviews.
An `int**` is used in relation to an `int*` for the same reason an `int*` is used in relation to an `int` - it's just a level of indirection. The same is true no matter how many asterisks you have.
I once had to use quad dereferencing. ***foo(****bar); It was used in an old DOS app, where I had to translate between several different 'printers'. We defined a common printer language, and then had to translate that to the configured printer. All this in 64k of data and code (wheeee, 16bit programming). I had to get creative with memory and code savings.
Let's say that you have pointer to a node in a list and a function that tells you what pointer you want. You can pass the address of the pointer to the function. Then, the function can change the value of the pointer in that address.
This. I live by gcc and it's super easy to get running on OSX.
A 'double pointer' is really just a pointer to a pointer. Most often, they're used for multidimensional arrays. For example: const unsigned x = 8, y = 8, z = 8; int ***array_3d = malloc(x * sizeof(int)); for(int i = 0; i &lt; x; i++) { array_3d[i] = malloc(y * sizeof(int)); for(int j = 0; j &lt; y; j++) array_3d[i][j] = malloc(z * sizeof(int)); } EDIT: sizeof(int) should be sizeof(*int)
 int main (int argc, char *argv[]) { ... } is just another way of writing int main (int argc, char **argv) { ... } where argv is an array of char *, where each char * points to an argument string.
1. This is C++. You've posted in a C programming subreddit. 2. You probably want to look at the seekp() function, or the app mode of open(). Each time you call the Add() function, you will be overwriting the existing records. It's going to be difficult to write a simple Delete() function with your current data formats. You might want to consider writing functions that convert the data file to and from an array of Inventory objects. Then your Add/Delete/Edit functions can just read in the current file, work on that array, and write the array out the array. 
I edited my post, I wrote the wrong thing at first. Thanks, that's enlightening. These slides i'm looking at certainly make it seem like x should be something different. https://imgur.com/uwn9TbW.jpg
Yes, makes sense. Thanks. I don't think I have any questions, but if that changes I'll let you know. Did you see the slide I put up? edit: wait, so x is only ff? it's 4 bytes, so is the rest 0x012345ff? 
What happens to the other bytes in x if y is 255?
When you assign a value to an `int`, you are assigning a value to the whole `int`, not just some little piece of it. If you assign the value&amp;nbsp;255 to&amp;nbsp;`x`, then you are assigning the value `0x000000ff` to&amp;nbsp;`x`, because the value&amp;nbsp;255 is represented as `0x000000ff` in a 32-bit `int`.
* You only need to call listen() once, not every time through the loop. It's like bind() that way. * You never touch Connect_Count so there's no limit on how many processes are running at once * You never reap the child processes when they exit so eventually the host's process table fills up with zombies. * You don't fclose() F, though that's not a huge deal since that process exits anyways, but it will be an issue with threads * You don't do any verification of the file before opening (What if I ask for /etc/passwd?), which again isn't a huge deal in a toy web server that's only going to bind to localhost, but if you're ever going to expose it to the internet at large is a must. * It's a web server. Files are files. Data is sent the same way, but the Content-Type header needs to change for different data. /etc/mime.types on linux has a huge list of content type and file extension mappings, or you could roll your own. 
 char c = 0xff; int i = 0xffffffff; c = i; /* value of i cast to char */ What does i now equal? is it 0x000000ff or 0xff? 
If you're not already, use the types in &lt;stdint.h&gt; for specific widths, instead of assuming that int, long, long long, etc. have a given size. int32_t, int64_t or whatever. If you also #include &lt;inttypes.h&gt; you can use those types with printf like so: int32_t foo = 1; int64_t bar = 2; printf("foo is %" PRId32 "\nbar is %" PRId64 "\n", foo, bar); 
Thank you for the fixes! So if i run an mp3 through the current code would it work just be labeled incorrectly in the Content type header?
Your browser wouldn't be very happy when it tries to treat a mp3 as if it was a jpeg, but yes.
even if i were to run it with localhost:port/SongName.mp3 it would still treat it as jpeg?
That's what the server is telling the browser that the data it's getting is supposed to be.
I don't understand what you mean. The value of the variable&amp;nbsp;`i` is an `int` value, because it is declared to be an `int`. If `int` is a 32-bit type on your machine, then the representation of&amp;nbsp;`i` is always going to be 32&amp;nbsp;bits, because `i` is an `int` and an `int` is 32&amp;nbsp;bits.
I think you've made some good very technical points. I did read that technically a char is an int, or a kind of int. And beats me if they used to be the same size. Could be. The int grows about 16 bits per decade or so. And char is growing too. I think the standard may say it's 8 bits wide somewhere, but that's getting blasted by WCHAR/TCHAR, and eventually they'll likely merge into a new, 16 bit standard for one, universal char. And you'll blink your eye, 20 years have gone by, and a char is now 32 bits, but yet is still the smallest atomic type for C.... [It's already kinda sorta happening](http://en.wikipedia.org/wiki/Wide_character)
Although triple indirection is somewhat rare and people are going to call you a triple star programmer if you use it.
Can you please put four spaces in front of every line of code so the code comes out readable? It says so for a reason in the submission text.
 int *a = NULL; createArray(a); /* a == NULL here. */ EDIT: [Example](http://ideone.com/6Zm01O)
If a single level of indirection is used the function cannot point that pointer to a different block of memory. Two levels are needed because the function needs to point the caller to a different memory address. Just as `int*` allows you to point to a new `int`, `int**` allows you to point to a different `int*`.
Thanks but i figured out how to do it without writing a bunch of code. I just push the 2 halfs of the long long into the stack contiguously and printf reads the 8 bytes as a single long long even though its 2 separate things. 
I have used ***** before, does that make me a 5-star programmer?
* **Dynamic two-dimensional arrays**: With an `int**`, for example, you can allocate an array of `int*` (first dimension), then allocate the different rows of `int` (second dimension) and point the `int*` to those rows. * **Modifying a pointer in a function**: Passing a pointer to a pointer allows one to set that pointer. For example, `strtod` takes a `char**` so it can modify the `char*` behind it.
This isn't correct. When you want to pass a variable into a function, modify it within the function, and have the modified value reflected in the calling context, you need to pass a pointer to the variable. Otherwise, the variable is being passed by value (i.e., the function operates on a copy of the variable and doesn't modify the original). In this case, the variable itself is a pointer, so you need to pass in a pointer to a pointer, thus a double pointer, and then you need to dereference it to properly modify the value. Otherwise, you're only modifying a copy of the pointer.
 if(input == "w") input is a char. You're comparing it to a string. Try 'w'
Sounds good. What have you done?
What exactly are you needing help with? Do you have any code written that isn't working? Are you looking for help on how to break down the problem into smaller manageable pieces? No one here is going to just outright do your homework for you, but we can help if you are stuck at a certain point.
need help breaking the problem down.
I haven't used SDL before, but I think this [tutorial](http://gameprogrammingtutorials.blogspot.com/2010/02/sdl-tutorial-series-part-6-displaying.html) is what you are looking for.
http://grisha.org/blog/2013/04/02/linus-on-understanding-pointers/
The assignment requires use of SDL for whatever reason. I have SDL_TTF in use and I know how it works, it's how I can make it render just a single character from an array multiple times on one line with a set spacing in between each one I'm stuck on.
you have to use a one-dimensional array and it has to be stored internally and it has to be an array of chars. we were told this too about using fgets: I'd mentioned today that I didn't recommend fgets() for the program. It turns out that fgets() WILL stop reading as soon as it encounters a newline, so the logic problems I was envisioning are not really an issue. I still recommend using getc(), but you can probably get fgets() to work if you prefer.
I don't see a problem with fgets() because it'll return NULL if it encounters an error or you're at the eof. Something along the lines of this would work: while(fgets(buf, sizeof(buf), fd)) { /* ... */ } For a homework this is probably alright, but I wouldn't use it in production code because it doesn't handle variable line lengths and fgets() doesn't tell you how many bytes were read. As for the reversing, in your case I'd just get a pointer to the end of the line and then use strrchr() to scan backwards for the start of the previous word, until you're at the beginning of the line. But there are a lot of ways how to actually implement this.
Simple algorithm: For each line Reverse entire line. // tnaem si atad tupni sihT For each word in line Reverse word // meant is data input This
Double/triple pointers are never needed for arrays. That is why the array constructors exist. You can just do `void* array_3d = malloc(x*y*z*sizeof(int));`, no need for the for-loops and multiple malloc calls! [See my previous post on multi-dimension arrays](https://www.reddit.com/r/C_Programming/comments/2xoeql/dynamic_allocation_and_iteration_of_2d_pointer/cp2mh5t). **Edit**: And you are re-allocating more memory than needed. A 3d array of int-size `8*8*8` should only need 2048 bytes of storage. Your loops will allocate 2336 bytes I think.
Personally, i think the code is well organized and easy to read. I'm unsure about that extra semicolon on line 97, so I'll just assumed you're using it for the sake of NOP. The only thing I can suggest is checking the return value of system(), but that would make the program more complicated :P
Okay thanks! but Sleep(); or sleep(); is not working but the quit on line 101 is not working... any ideas? Edit: got Sleep working!
You can combine the printf statements for readbility, something like this : printf("This is an example\n" "of how to simply\n" "your menu");
Harvard's CS50 
Where do you go to find the CS50 class? I have looked around the site but cant find the place to actually start.
That was it! Thank you so much. And I apologize about the spacing issue when I originally posted this. It appeared fine on my page however now I see that It caused issues. Anyways now the code is working perfectly.
its a C version of my python script I just did this because why not :)
Also, check out reddit.com/r/cs50 . Very awesome sub
thenewboston? Ive said it before and ill say it again, he is not a good teacher at all. He is inconsistent, and awful at explaining non-trivial things. People get hooked on his tutorials because the first few are easy enough, then he gets to classes and objects and all the other abstract things in programming and he degrades to a "just do what i do and youll get it" kind of teacher. The best way I can recommend is a book. I still find them unmatched in terms of going through anything thoroughly. Tutorials are often made by people who do it on their free time, therefore they have little incentive to make a good one, whereas if you write a shitty book, it just wont sell, simple as that.
Your argument still stands, I personally wouldn't say one is inherently easier to read then the other but that's just my opinion, but as a note compilers like `gcc` will actually optimize `printf` statements that only print a single string along with a ending `\n` into `puts` statements for you.
Overall I think it's good. There's a few things here or there I'd personally do different, but how you did it is perfectly readable. The only thing i have a hard time reading is the case statement really. Personally, I'd really advocate not putting a statement on the same line as the `case` statement, and also at the very least put a blank line between the last `break` and the next case. Something like this: switch (choice) { case 1: info(); break; case 2: Snapchat(); break; case 3: Unlock(); break; case 4: printf("Quitting program!\n"); exit(0); break; default: printf("Invalid choice!\n"); break; } This is definitely a bit wordier, but personally I think it's *much* easier to read when there's more spacing and the code is indented directly below the case. Some of the less important things you could get away with leaving, like not indenting the `break`. I think that having stuff like `break`, `case`, and `exit(0)` all in line with each-other without any spacing in-between makes it very hard to read what's actually happening though.
thank you, I am actually going to memorize this. This is closest to the spirit of what I was trying to do. I figured it was impossible.
To each their own, personally I prefer using `printf("string\n");` because it's consistent with everything else. I tend to forget that `puts` includes an extra `\n` (Admittedly because I don't usually use it), and I usually end-up adding format information to my `printf` statements anyway.
you are very welcome. i hope u enjoy it as much as i enjoyed writing and testing it. I don't know why i love low-level string manipulation so much; i don't know why i love C so much. Some things just *are*.
Pointer to an array of char pointers. Think of an array, where each index points to a string. 
Just a heads up, you say quit is choice 0 but then later on you use check for choice 4. It should be one or the other.
No, it is not. The result is implementation-defined or an implementation-defined signal is raised.
An integer variable takes 4 bytes(which are sequential in memory), and a char variable takes 1 byte. When you stored the address if 'hello_world' in x, you basically gave it the address of the start of the string(which is occupied by 'H'), which you then passed to 'adr'. Since 'adr' holds the address of the integer, when you dereference it, the value you get would be the value of the byte you stored in 'adr'(which is 'H'), as well as the next three subsequent bytes('e', 'l', 'l'), because integers are 4 bytes long. Therefore, arr[0] now holds the chararcters h,e,l,l. Now, when you print a string using a char array, it would print all the characters in the array(not quite sure, someone correct me if I'm wrong). As previously mentioned arr[0] = 'h','e','l','l', and arr[1] = '?', giving you 'hell?'.
AHH shit, that's good to know. Thanks!
I see it now
Now that your code works perfectly, what happens when you input a player name that is longer than the size of your players array? I would expect a segmentation fault. This is because ``gets`` will happily write past the end of the buffer and into memory that it shouldn't. To prevent writing buffer overflow vulnerabilities, use ``fgets`` instead.
Nice! I don't know what genre I'd class my music as but people seem to enjoy it. I do it for fun, purely because synthesizers and samplers are my "other" main hobby: https://soundcloud.com/base2music/midnight-star-curious-base2-remix
no the original type is char which is assigned a number that causes it to overflow, 0xff. This overflow is undefined which in some cases causes it to be -1. the rest of this code is correct and not implementation-defined.
Nicely done, sir!
I just tried running your program and it seems to work properly. The one tricky bit is that, in order to exit, you actually need to put a number and the x, like "0 x" This is because of the way you wrote your scanf function. You might think about splitting it up into two separate scans, one for the number and one for the operator. That way you could check for the 'x' being the first character on the line.
I'm not sure what you're looking for. What's wrong with using fgets with the file pointer you received? Would ftell() and fseek() help?
Alright, then it seems, by my teacher's requirement, to be working. My only issue, is getting it to print out the total. When I run the program, it only does: &gt;&gt;2s followed by another blank spot. Any reason for that?
fgets() does just that... Or you can read and discard a character at a time till you get a newline, I suppose.
Your scanf format string contains a space, so you need a space between the number and the operator. You could also remove the space from the format string and it should accept what you have there. Also, you're not printing out the accumulator value inside the while loop, so I'm not sure what you're expecting to see...
The third line does not compile because `(*s)` is a `char`. The `++` simply returns the same `(*s)` (but increments the value), so it is still a `char`, not a `char*`. The second line works because you are casting. By the way, you shouldn't assign a literal string such as `"h"` to a `char*`. It should be assigned to a `const char*`, assigned to an array, or `strcpy`-ed to dynamic memory.
&gt; The third line does not compile because (*s) is a char. The ++ simply returns the same (*s) (but increments the value), so it is still a char, not a char*. The second line works because you are casting. the second line DOESN'T WORK
Yes, if you try using whatever `t` points to (such as `puts(t)`), you would get a segfault, because `t` points to the memory location 0x00000068 ("h" has an ASCII value of 0x68), which is probably invalid/not owned by your program.
String constants in C are usually put in read-only memory, hence the segfault. 
He just needs to check the return value of scanf.
This was it! Thank you so much now the 'name_string' is allocated a place in the HEAP in the main, and free'd in the main too. So much easier to follow the code now too.
~~Okay, wait....~~ char* s = "h"; ~~Lemme confirm, you want to set a variable (which is a character) to the letter 'h', and then you want the pointer of that? Because that's not what's happening - right now, you're making a variable (which is a pointer to a character) which holds 'h' (translated into some random number).~~ ~~Perhaps you want this?~~ char r = 'h'; char* s = &amp;r; _____________________________________ I think I understand now; I completely didn't realize you wanted a string (I haven't played around with strings for months for some weird reason). You aren't allowed to modify strings, hence why they're called "immutable". Unfortunate, but it's just one of the properties of strings. Characters ARE mutable, which is why my example worked.
Never mind. I only read briefly over your code. Now I see what said yesterday is wrong. very naively from to think this way. 
ok, that sort of works :) 
Its totally virtual. Actually there is not a physical implementation. However I begun to do some stuff on VHDl to implement the cpu
Alternate title: *Pointers are giving me hell*
I would say other people screwed up with their answers. Especially when learning new stuff it is crucial to note faulty *thought* process. It would be way more useful to modify this function to highlight the mistake. "s = s2, means that the end of s1 is now pointing at the beginning of s2, so shouldn't this satisfy the conditions of the function?" This is not only completely incorrect, the code modifies 's' prior to that and relvant effect is not expected by the author at that time. while(*s != '\0') s++; &lt;------ HERE, equivalent of s = s + 1; s = s2; With '++' expanded it is immediately obvious teh code could not be right and possibly the author could have worked it out from there.
Is that compiler implementation specific?
I wasn't going to post because there are already lots of good examples, but I just ran across a piece of code where I used one and I think it's a pretty good example. for both cases, the double-pointer is used to simplify some linked-list modification code. It's easy to mess-up linked-list code if you haven't done it a ton of times because there's a special case when you're modifying the beginning of the list - If you change which node is first in the list, then you have to update the 'head' pointer, which points to the first item, to point to this new first item. This usually requires some extra cases at the end of any modification code. But, if you use a double-pointer, that special case completely falls away, because you can simply start with a double-pointer which points at the 'head' pointer. Then, when you iterate through the list, you move this pointer to point at the 'next' pointer in every link. Thus, when you set the value of the pointer that your double-pointer is pointing at, if that pointer points to the first entry in the list, then writing to this pointer writes the 'head' pointer like you want, and if not, then it writes to the 'next' pointer like you want. The code I was looking at: This is part of the implementation of a 'slab' allocator. What that is isn't important, but the key here is that we're attempting to add the entry with the key 'obj' from the linked-list pointer at by 'freelist', that's contained inside of the 'frame' structure. They 'key' happens to be the actual address of each entry in the list, but that's unimportant. The key-comparison is the code inside of the 'if' statement: static void slab_frame_object_free(struct slab_page_frame *frame, void *obj) { struct page_frame_obj_empty *new = obj, **current; for (current = &amp;frame-&gt;freelist; *current; current = &amp;(*current)-&gt;next) { if (obj &lt;= (void *)(*current) || !*current) { new-&gt;next = *current; *current = new; return ; } } } Normally, there would be a special case involving handling writing to the beginning of this list, and modifying the 'freelist' pointer in that case. With the double pointer, if we do have that case, then 'current' points to 'freelist', so the code inside that 'if' modifies 'freelist' as needed. If not, then it modify that 'next' pointer of the previous entry, which is the normal way to insert into the list. You can basically think of it doing one of the two following pieces of code: new-&gt;next = frame-&gt;freelist frame-&gt;freelist = new; or new-&gt;next = prev-&gt;next; prev-&gt;next = new; The double pointer simply turns them both into the same thing by having the double pointer correctly point at either 'frame-&gt;freelist' or 'prev-&gt;next' depending on where in the list we are. This is a pretty simple case, but there's lots of places where simply holding onto a pointer to something, instead of checking which thing to use later, allows you to skip lots of special cases.
fwrite() should do what you want
You can call C functions from C++ code just fine and most C code is valid C++ code, too.
Changing the gcc from the makefile to g++ gives me errors, I once fixed all of these but some of them are in the .o files which I can't edit
The very first thing your program does is block the SIGUSR1 signal…
I used opencv on a raspberry pi before without any problems. I think what I did was download the source code for opencv then just run cmake, make, make install.. Then when you make your project that uses opencv just give g++ the path to the c headers and shared objects. What are the errors you are getting?
Well currently Mat, namespace, etc aren't working because it's C code, if I replace the gcc with g++ I get errors in another file, these can be fixed easily (it's something with badly placed }'s and you need to move some variables around, nothing hard) but then I get errors that I can't remember from a file that I can't open nor edit. Is there a tutorial I can follow like you did? Or is that literally the only thing you did.
Okay i looked at the module you were talking about on github, i think i see the problem. When you run make on their code it should generate a libraspicamcv.so file correct? if so then I think you should hopefully be able to build your program by doing something like g++ -L/path/to/sofile -I/path/to/headers -lraspicamcv -o outputname yourfile.cpp EDIT: changed -llibraspicamcv to -lraspicamcv
This is an interesting assignment. I suspect that the compiler is actually going to screw you over (I'd be curious to know if this is noted in the assignment, but more on this below), but regardless the task isn't too daunting and I'm just going to ignore the issue that I'll note down below. The first thing you need to check is are you supposed to be writing literal '1' and '0' characters to the file (Which I highly doubt) or are you actually just trying to write the bits for each of these pieces of data to the file? The first case does require some code to convert to a string, but with the second case you actually already have the data in a binary representation ('values' just points to some *binary* data which is the contents of the structure). You can literally just write what's contained at 'values' byte-by-byte to write the int's, short's, and char's to the file. Do you have some type of format you're supposed to follow? That will greatly influence how you go about handling the file itself. In general, you're going to have a simple format that you follow for writing and read that information you described to and from the file. If reading the data back into a structure isn't a requirement then you can be a bit more liberal on your fileformat. Since you mentioned that 'c' is 01, 's' is 10, and 'i' is 11, I suspect you have some type of format to follow. I would recommend first reading over the assignment again, looking to see if they have any tips or etc. on the file-format, write-out exactly how the file is supposed to be laid out - make a diagram that lists each entry in the file and how many bytes it will take. You will probably have variable length sections, make note of them and how they're laid out (IE. "This section is a list of entries defined below. The number of them is defined above in entry 'blah', which entry each is, is defined above by entry 'blah2'"). For example: Len (bytes) | Entry 4 | Number of entries (nentries) 4 | Number of extra entries (neentries) nentries * 4 | nentrie number of 4-byte integer values for foo neentries * 4 | neentrie number of 4-byte integer values for bar Obviously that's just a random example, but I think that once you have that written out you'll have an easier time proceding with the assignment. Once you have this done, you'll want to start going one-by-one down the list and creating the file one piece at a time. You'll want to take a look at the 'f' functions to do this with a FILE. Specefically, `fwrite` will be of use to you, because it allows you to write a piece of data 'as binary' to a file. You could, for example, take an int and write it directly to a file as 4-bytes using `fwrite`, instead of just printing the digits like with `fprintf`. And my note: If you try to write actual defined `struct` variables this way, you'll probably find it doesn't work. The compiler will insert "padding" bits into your struct to keep things aligned - For example, in general int's are 4-byte aligned. That means if you put a char and then an int, the `char` itself will only be 1 byte long, and then 3 extra bytes of empty space will be inserted so that the next `int` falls on a 4-byte boundary. I would probably recommend ignoring this unless your professor has actually mentioned something in the assignment or a lecture, etc. You can get around this by simply not using a `struct` and instead creating the 'values' buffer by hand. If your professor didn't say anything about this but shows test code sending the address of `struct` variables for the 'values' argument though, I'd ask him/her about it, as it might be something they overlooked. 
interesting. When I get the chance I will put this through the compiler.
Could you try to make a minimal, self-contained example? Your code is quite long and much of it doesn't seem to pertain the problem you experience. Maybe you can cut it down a bit?
What do you need `conio.h` for? The sentence “why do you include `conio.h`” does not mean “remove `#include &lt;conio.h&gt;`;” it means “why do you include `conio.h`.” So why do you include that header? &gt; what else should i use ? What is it that you need replaced?
if I make my own cpp file, it can't find #include cv.h and highgui.h with this line: g++ -L ~/git/robidouille/raspicam_cv -lraspicamcv -I ~/git/robidouille/raspicam_cv -L ~/git/raspberrypi/userland/build/lib -o Car Car.cpp 
The problem is that these gcc files are all pasted on the same line and I'm new to this.
if I change the gcc to g++ I get several errors. This was part of the errors that was easily fixable: &gt; MMAL_PARAMETER_CAMERA_CONFIG_T cam_config = { &gt; { MMAL_PARAMETER_CAMERA_CONFIG, sizeof(cam_config) }, &gt; .max_stills_w = state-&gt;width, &gt; .max_stills_h = state-&gt;height, &gt; .stills_yuv422 = 0, &gt; .one_shot_stills = 0, &gt; .max_preview_video_w = state-&gt;width, &gt; .max_preview_video_h = state-&gt;height, &gt; .num_preview_video_frames = 3, &gt; .stills_capture_circular_buffer_height = 0, &gt; .fast_preview_resume = 0, &gt; .use_stc_timestamp = MMAL_PARAM_TIMESTAMP_MODE_RESET_STC &gt; }; &gt; mmal_port_parameter_set(camera-&gt;control, &amp;cam_config.hdr); The .max_stills_w lines said they were expecting a primary-expression before the . token, I had to remove those lines and set them afterwards After fixing these errors I got even more in files that I couldn't edit anymore EDIT: found the errors after editing the main file, things I did to the main file to get this error: &gt; added cv::Mat x; &gt; added cv::cvtColor(cv::Mat(image), x, cv::COLOR_BGR2HSV); &gt; (image is the original IplImage image you get with raspiCamCvQueryFrame(capture);) &gt; Changed 3 methods to put text on "&amp;x" instead of "image", and one that shows the image now has a cast &gt; cvShowImage("RaspiCamTest", static_cast&lt;CvArr*&gt;(&amp;x)); Compiling gives me this error: &gt; pi@raspberrypi ~/git/robidouille/raspicam_cv $ make &gt; g++ -c -Wno-multichar -g -I/usr/include/opencv - I/home/pi/git/userland/host_applications/linux/libs/bcm_host/include - I/home/pi/git/userland/host_applications/linux/apps/raspicam -I/home/pi/git/userland - I/home/pi/git/userland/interface/vcos/pthreads -I/home/pi/git/userland/interface/vmcs_host/linux - I/home/pi/git/userland/interface/mmal -MD RaspiCamCV.c -o objs/RaspiCamCV.o &gt; RaspiCamCV.c: In function ‘MMAL_COMPONENT_T* create_camera_component(RASPIVID_STATE*)’: &gt; RaspiCamCV.c:231:8: error: expected primary-expression before ‘.’ token &gt; RaspiCamCV.c:232:8: error: expected primary-expression before ‘.’ token &gt; RaspiCamCV.c:233:8: error: expected primary-expression before ‘.’ token &gt; RaspiCamCV.c:234:8: error: expected primary-expression before ‘.’ token &gt; RaspiCamCV.c:235:8: error: expected primary-expression before ‘.’ token &gt; RaspiCamCV.c:236:8: error: expected primary-expression before ‘.’ token &gt; RaspiCamCV.c:237:8: error: expected primary-expression before ‘.’ token &gt; RaspiCamCV.c:238:8: error: expected primary-expression before ‘.’ token &gt; RaspiCamCV.c:239:8: error: expected primary-expression before ‘.’ token &gt; RaspiCamCV.c:240:8: error: expected primary-expression before ‘.’ token &gt; RaspiCamCV.c: In function ‘RaspiCamCvCapture* raspiCamCvCreateCameraCapture2(int, RASPIVID_CONFIG*)’: &gt; RaspiCamCV.c:464:26: error: invalid conversion from ‘int’ to ‘MMAL_STATUS_T’ [-fpermissive] &gt; Makefile:45: recipe for target 'objs/RaspiCamCV.o' failed This is easily fixable by changing the cam_config lines to &gt; MMAL_PARAMETER_CAMERA_CONFIG_T cam_config = { &gt; { MMAL_PARAMETER_CAMERA_CONFIG, sizeof(cam_config) } &gt; }; &gt; cam_config.max_stills_w = state-&gt;width; &gt; cam_config.max_stills_h = state-&gt;height; &gt; cam_config.stills_yuv422 = 0; &gt; cam_config.one_shot_stills = 0; &gt; cam_config.max_preview_video_w = state-&gt;width; &gt; cam_config.max_preview_video_h = state-&gt;height; &gt; cam_config.num_preview_video_frames = 3; &gt; cam_config.stills_capture_circular_buffer_height = 0; &gt; cam_config.fast_preview_resume = 0; &gt; cam_config.use_stc_timestamp = MMAL_PARAM_TIMESTAMP_MODE_RESET_STC; &gt; mmal_port_parameter_set(camera-&gt;control, &amp;cam_config.hdr); as for the other error, just gotta cast it correctly &gt; RaspiCamCV.c:464:26: error: invalid conversion from ‘int’ to ‘MMAL_STATUS_T’ [-fpermissive] &gt; MMAL_STATUS_T status = (MMAL_STATUS_T)-1; And then the first g++ line compiles but I get this on the second g++: g++ objs/RaspiCamTest.o libraspicamcv.a -lopencv_highgui -lopencv_core -lopencv_legacy -lopencv_video -lopencv_features2d -lopencv_calib3d -lopencv_imgproc -lpthread -lm -L/home/pi/git/userland/build/lib -lmmal_core -lmmutil -lvcos -lbcm_host -lX11 -lXext -lrt -lstdc++ -L. libraspicamcv.a -o raspicamtest &gt; libraspicamcv.a(RaspiCamCV.o): In function `default_status': &gt; /home/pi/git/robidouille/raspicam_cv/RaspiCamCV.c:126: undefined reference to `raspicamcontrol_set_defaults(RASPICAM_CAMERA_PARAMETERS*)' &gt; libraspicamcv.a(RaspiCamCV.o): In function `create_camera_component': &gt; /home/pi/git/robidouille/raspicam_cv/RaspiCamCV.c:332: undefined reference to `raspicamcontrol_set_all_parameters(MMAL_COMPONENT_T*, RASPICAM_CAMERA_PARAMETERS const*)' &gt; collect2: ld returned 1 exit status &gt; Makefile:57: recipe for target 'raspicamtest' failed &gt; make: *** [raspicamtest] Error 1 
Yes, but I have no idea which is offending or how to edit the flags since it's more of a script, the compiling lines are all formatted like this: $(OBJS)/%.o: %.c gcc -c $(CFLAGS) $&lt; -o $@ the source is in the tutorial link
OH! this fixed it! thanks alot!
Does the makefile for raspicamcv create a the file libraspicam.so? Are you using opencv in your project? or are you just using raspicamcv? If you are using both than you need to add the paths for opencv too. This is getting kinda complicated which is why people use makefiles or IDEs, but this is the command you would need in that case.. g++ -L/path/to/sofile -Lpath/to/opencvsharedobjects -Ipath/to/opencv/headers -I/path/to/headers -lraspicamcv -lopencv_highgui -lopencv_core -o outp outname yourfile.cpp I think that is all you need.. basically you have to tell the compiler where all the shared objects are using -L and tell the compiler where all the headers are using -I and tell the compiler which shared objects you are using with -l
I think it does, I am not sure though since the makefile is a script that I can't seem to understand, but I managed to get it working with somebody elses help, had to put an Extern "C" { } around one of the includes
Looks like a homework assignment.
It's a fairly meaningless task, since indexing an array is just pointer arithmetic in disguise. Nonetheless, `a[i]` is equivalent to `*((a) + (i))` - just use that rule to translate your code.
Depends. Some libraries let you redefine their allocation functions, or you could configure the GC library to redefine malloc/free/etc.
That's not true. An array and a pointer are different. It is only when used as a function argument type that an array is treated as a pointer.
Woops. My memory failed me, then. Sorry. Please, post the correct answer though, don't just point the wrong. Op will be thankful. Thank you!
A recursive function is one that calls itself. Basically you do some work that means you can reduce the problem size, and then call the function on the new part. I'm not going to answer the problem for you, but think about what bubble sort does. After one pass through of swaps what can you say about the end of the array? Could you call the function on a smaller part after each round of swaps? Note that recursive functions need a base case. This tells the function to stop calling itself. At what point can you realise the array is sorted? If you're really struggling, google recursive bubble sort and you should find plenty of resources. Don't copy them though, because algorithms can be considered intellectual property and as such may get you in trouble with your schools academic honesty rules.
You might want to allocate some memory for the char pointer to point to, before you copy data to the memory section the char pointer points to.
ok, this is pretty clear :)
thanks, I read this answer carefully. I tried this: char* t = "tsrnesteirnt"; strcpy(t, "hello"); I left plenty of room after the t pointer for "hello", however there is still a bus error?
thanks I've learned so much from this thread. one question: since "hello " is a string literal, does char *t = "hello "; decay to: const char *t = "hello"; ? 
What do you mean by decay? The first one is simply incorrect.
&gt; the end condition of the for loop would be met and the for loop would break, right? No. That's not how for loops work. The loop continues as long as the condition is true. If `*s1 == *s2` is true for the first time through the loop (as in your example) then the loop continues, advancing both `s1` and `s2` forward to compare the next two corresponding characters and so on until a difference is found (or the nul terminator is found) at which point the loop stops. 
Okay thank you :)
No, they're not equivalent. Think about what happens on the last iteration when `*s` is zero, i.e. at the nul terminator. In the case of `while(*s) s++;` the loop body will not be run, so `s` will not be incremented and will continue to point to the nul terminator after the loop is done. In the case of `while(*s++);` it is still incremented when `*s` is zero, so it points to the character after the nul terminator when the loop has concluded. 
I have no idea what you're asking. Are you asking about the part after the opening parenthesis and before the first semicolon? It contains nothing. There is nothing to initialize, so there is nothing to put there. Any of the three portions of the statement can be left empty, for example this is an infinite loop: for(;;) { ... }
No. So to break this down into smaller steps: p is set to the address of the terminating zero of s1, by adding the number of characters. (This assumes that s1 is a properly terminated string). The while loop actually breaks down sort of like this: Write a character from memory pointed at by p, from the memory pointed at by s2, unconditionally The pointers are both incremented _after_ the copy is done Then the while() condition is tested. The condition being tested is "was the character we just copied non-zero?" If so, we want to write at least one more character, either the next legitimate character in the string, or the terminating '\0' character. So this is sort of confusing, because the standard idiom of a while loop is that the condition is tested to determine if it should execute the body of the loop. In other words, a while loop generally means a loop body can execute zero or more times, while a do loop will always execute at least one time. But in this case the loop body is empty, no {}, just a semicolon indicating a "null statement," and the condition tested is the result of an assignment, with two post-decrements. At least one copy is always done. The value at *p is not tested before being over-written. The test will fail _after_ the terminating zero as been copied from the second string to the first. This is less confusing when you've read a lot of C code, since this is a "standard idiom." It is used in K&amp;R as an example of how concise C can be. Although, keep in mind, this implementation can go off and do unsafe, undefined things if the strings are not terminated correctly, if the pointers are not valid, if they overlap, etc. So in modern production code you would probably not want to use plain strca()t. There is strncat(), which takes a length and provides some additional protection, and strlcat(), which is not standard but is safer. Really the answer is that plain old strings in C are not safe unless the code very carefully manages all the things that can go wrong. 
Ah, so it is kind of like saying: [C PSEUDOCODE] char e; while(e = (*p++ = *s2++)){ if (e == '\0) break; } or maybe that is all wrong Thanks for your explanation :)
Just discussing. I'm fairly new to this stuff. Wouldn't for( ;x == y; whatever) just be written as a do-while loop? 
You might want to read this [StackOverflow answer](http://stackoverflow.com/a/1335836). Note that char *t = "hello"; and char t[] = "hello"; are not the same thing. The **former** allocates a *static* `"hello"` array, which is often stored in *read-only* memory (i.e. the operating system forbids you from altering them). The array is created exactly once: at the beginning of your program's execution. In contrast, the **latter** allocates a *local* array on the stack that contains `"hello"`, so it is essentially equivalent to: char t[6] = {'h', 'e', 'l', 'l', 'o', '\0'}; This array is allocated every time you enter this scope and deallocated every time you leave, just like ordinary local variables. It can be modified (unless you declare it with `const`) *as long as you stay within the bounds of the array*. The size of this array, like any other array, is fixed ahead of time and cannot be changed. Attempting to read or write beyond the bounds can corrupt memory, crash the program, or [do anything really](https://en.wikipedia.org/wiki/Undefined_behavior) (a common source of security vulnerabilities). Personally I would never write the former as-is, preferring the safer alternative via `const`: const char *t = "hello"; This prevents you from making this same mistake :)
Yes
Yeah, I think that is equivalent. It is also equivalent to while ( 0 != ( *p++ = *s2++ ) ); Basically, in the condition of a while or an if, you're in a "Boolean context," which causes the compiler to test for 0 as false, or != 0 (any value other than zero) as true. I just edited my answer because I realized my version written as a do loop as not correct. I wrote: do { *p++ = *s2++; } while ( *p != '\0' ); But that will not actually copy the terminating zero. You'd need an extra step: do { *p++ = *s2++; } while ( *p != '\0' ); *p = *s2; Really, just about any other way to write it is less concise, although maybe clearer to people not used to idiomatic C.
You can write any kind of loop in terms of any other kind loop, more or less. But if the "whatever" in your example is not empty, it usually makes more sense as a for loop than a while loop. `for(;foo;)` would certainly be unidiomatic, though. 
 #include &lt;string.h&gt; int main(){ char c[40] = "hello"; const char* c2 = " world"; char* p = c + strlen(c); do { *p++ = *c2++; } while (*p != '\0'); *p = *c2; printf("%s\n", c); return 0; } Actually, this doesn't seem to work - if prints "hello w". I think I need to init the value of p. 
That's because it's wrong. You're checking `*p` after it's been incremented, which means it's checking some value of `c` that hasn't been assigned to yet, just as you worried about originally. In this case, every character in `c[]` except for the first five are initialized to nulls, which means the loop stops after one iteration (copying the `' '`) and then the `*p = *c2` copies the `'w'`, and then by sheer luck the string is nul-terminated after that because of the fact that it was initialized with all nuls due to providing an intializer shorter than its size. But in general that won't be the case and this will go all haywire, reading potentially uninitialized data.
Yeah, sorry. See my correction. It's a good reminder that I should always test even seemingly trivial code. Especially when it's late and I'm tired...
I wanted to chime in here. One of the things that helped me out tremendously is when I learned "test driven development" (TDD). I'm not suggesting you write tests for everything first, but you should write tests for the code you have now. With tests, you can break the code up into small functions that make sense and be able to assert a proper output after each one. That way you accomplish 3 things: first you would have documented the current functionality through tests. Second, your code would be broken up into reusable small functions that will be easier to debug. Third, you will be able to make changes with confidence, (if current functionality is broken the test will be too). I like to make the tests a separate executable that runs unit tests on all the functions. I put this in a folder called "tests". Then I like to make another set of executables in a folder called "demo". This folder contains nice, simple code using your internal library of functions in different scenarios and asserting the results. I guess these are more formally called end to end tests. Finally, run your unit tests and demos under valgrind to find some bad code and leaks. Its more work upfront but you and your customers will appreciate the polish this puts on your code and the ease with which you will be able to add new features or things like threading to the application without introducing bugs or breaking the app for long periods of time. Also, you will be able to point to the tests and demos as examples of how to modify your code and proof your code works.
I don't think you can increment an array. Assign c2 to a pointer and try that.
that works! I have no idea why though :)
Please don't write so much stuff in a single line, because it makes your code hard to read. Instead of this: for( ;*s != '\0' ; *s = (*(p+i) = *(c2+i)), i++); write something like this: for( ;*s != '\0' ; i++){ *(p + i) = *(c2 + i); *s = *(p + i); } Try removing `i` while it is in this form, you'll find it much easier. Also, think about the loop you are using. Could you perhaps use `while` instead of `for`?
you are quite right, I will take this into consideration
I'm not sure with what code you're testing the function. It does not seem to be working here, so please provide some additional information.
Probably it is a better idea to use strncpy and fixed buffer sizes/allocations instead of strcpy to reduce the chance of overflow? 
see my edit. I wrote this function last June and have tested it extensively since then.
Kind of. The function gets an independent copy of `s1`. Changing the value inside of `my_strcat` will not have any visible side effects after the function call is complete. Note that "changing the value" here means something like this: s1 = NULL; It does *not* mean something like this: *s1 = 'A'; The latter modifies the memory pointed to by `s1` and most decidedly has visible side effects. That's the whole point of `my_strcat`, after all.
so s1 inside the function has its own space in memory? So the when you pass in a value into a function, the function copies the value into its own space in memory? And this is what is meant when it is said that all c functions' arguments are passed by value not reference?
Yep. If you want to dive down into the technical details on how this works, read up on the [Call Stack](http://en.wikipedia.org/wiki/Call_stack).
I think you're right. The array-to-pointer conversion would only even occur if the operator expected an rvalue operand, but the increment operator expects an lvalue. More specifically, the increment operator expects a *modifiable* lvalue, which an array is not (although I can't find the standard quote that specifically says that an expression denoting an array is a non-modifiable lvalue - I can only find a note at §8.3.4/5).
thanks this helped me understand :)
&gt; What is the difference in the usage of C vs C++? C tends to be use more by libs and low-level mission critical stuff such as kernels and embedded systems. C++ is used for more complex applications like browsers, games, or professional productivity tools. &gt; Can C and C++ programs be interchanged, or are they separate languages? They are separate languages but you can carefully write your code to be compiled as both C and C++ &gt; If I learn C++ would I know C? No. Although some would disagree here. But you could pick up C a lot quicker than if you would start from scratch. 
Thank you!
They are different languages. C++ builds on top of C, adding a ton of features, like classes and templates. In a way, this means that C++ is a "better" C, in another it doesn't. [See this Linus rant \(warning: strong/abusive language\)](http://harmful.cat-v.org/software/c++/linus). In any case, the ways the languages are used are usually very different, and learning C++ won't necessarily teach you *good* C, though I'd argue that it would force you to learn the absolute basics. There are some ways to exchange code written in the two languages, of which I'm not really knowledgeable about. A Google search will probably help you discover more.
Ahhh, I see!
The two languages are closely related with C++ being a direct descendent of C via way of "C with Classes", essentially just a series of additions to C. This was eventually developed further and split off into its own language to become C++. Today, the two have diverged substantially, especially with respect to the situations they tend to be used in, and what is considered "good" or "proper" coding style in each. However, despite this divergence C remains **almost** a strict subset of C++ so it is possible to write C code and (as long as you avoid doing a few things) have it compile without issue using a C++ compiler. The reverse is not true. Short of restricting yourself to the subset of C++ that is also in C, you will not be able to compile C++ code using a C compiler. That being said, modern C++ code looks substantially different than modern C code even though they share a similar past, as the language communities have developed very different philosphies. C++ code will generally use a higher level of abstraction than C code. You will often see C programmers much more willing to get down and dirty, so to speak, working at the bit and byte level, and performing manual memory management (although these can also come up in C++ as well). C tends to be used for very low level projects: firmware, operating systems, embedded software, ect. C++ is generally used at the application level on projects where performance is still desirable, but a higher level of abstraction is appreciated, such as video games and web browsers. Which one you learn depends a lot on what you want to do. If you're interested in getting down close to the hardware, or value a compact and comparatively simple language I would start with C. If you want to get into application development or have no interest in low level software then definitely go with C++.
`c2` is an array, what would you expect `++` to do to it? 
[Indeed.](http://c-faq.com/aryptr/joke.html) 
C++ programmers tend to be embarrassed about their C origins, and what would be the right way to do things in C is often poor style in C++. It has several features to help you avoid making simple mistakes, and adds a few other convenient features. But this leads to one big difference between C and C++ which is that C++ code tends to be more over-engineered than the idiomatic C equivalent would be. The C++ language allows you to specify many details in the language itself, and it seems to be hard to know where to stop. For instance, I don't know if this is a joke or not: http://www.boost.org/doc/libs/1_57_0/libs/geometry/doc/html/geometry/design.html
&gt; cross compilers for microcontrollers of course C++ can't help you with that but your skills still matter very much in contrast to say, python &gt; implicit void* casts implicit casts? tell that to the guy who casts functions in C to void explicitly as a hint to the compiler &gt; variable length arrays you still have alloca. anyway, isn't it considered bad strategy? &gt; designated initializers I really liked it but it's just syntactic sugar. Since I love C too, let's just settle on the evergreen "right tool for the job" phrase. 
Personally, I consider the two to hold a completely different mindset, given from the features both have. C++ focuses on having a very large variety of features, basically having a bunch of features for every case, and then lets you pick what you think will work. I find that it's pretty common that lots of problems can be 'coerced' into using the C++ provided features for most of their usage, which simplifies things, but may lead to a more verbose/ugly solution. C++ also has a mindset of hiding things from, and doing things for the programmer, in many ways as a safety net and in an attempt to make things easier to read. Thus, you get classes, overloads, constructors/destructors, etc. etc. The idea is that you use the language to handle a lot of the small things that you need done so the programmer doesn't have to think about them or even look at them. C focuses on having a fairly small specific set of features - Those which are considered more 'fundamental' and thus allow you to build any extra features you'd like. To that end, for example C doesn't have a 'grow-able' array in it's standard library (C++ does), however it has the features to allow you to implement one fairly easy. This may be more work, but you can fit your usage more to your specific program at hand, which may let you do a more optimal implementation, or a simpler implementation (Or, of course, there's also the option of using something like `glib`, which is a separate library but provides extras similar to the C++ standard library). Unlike C++, C takes the mindset of forcing the programmer to explicitly state what they want, and not hiding virtually anything. Ignoring usage of the preprocessor, which can change the meaning of virtually anything, If you see a statement like `a + b` in C, you *know* that this is just an addition of two integral variables (Say, ints, or pointers, etc..). Likewise, ignoring macros, the statement `foo(2, 3)` is a function call to the function `foo`, with two arguments. It does however mean that some things like files are less safe in C, because in C++ they have a destructor that can automatically close the file for you, vs. C where you have to explicitly call `fclose`. I find that, for most people, C++ approach appeals to them more, however for me, I much refer the C approach. Obviously, with that in mind I'm biased. That said, I do know both, though I know C better.
"C is the assembly for the Unix virtual machine." C++ on his origin, was a C with classes (POO), but It evolved to be more. Some one could say that it's like a kraken trying to touch and reach every programming paradigm. Both have his own strengths and weakness. But on C you could know (and you need to know) exactly what is doing your program. Also, I think that is a good language to learn programming because you learn what is doing exactly your code.
This is a really long answer because there's a lot of nuance in the situation; hopefully you will find some answers within. The TLDR: They are effectively separate languages *as used by their practitioners*, and you won't really know one by learning the other even if some of the knowledge will transfer cleanly. There are subsets of C and C++ that are essentially the same language. Their respective standards groups have compatibility between the languages as an explicit goal, though they are not perfectly synchronized so there tend to be places where new features have not been brought in from the other yet. Many compiler suites provide C and C++ support via single compiler that switches how it works based on compile-time options. So, aside from a couple of assumptions in the type checking and symbol naming, the C-compatible subset of C++ compiles to machine code very much like what you would get by compiling that same code written as C via the C-mode compiler. C has a mountain of legacy code in embedded systems, operating systems, etc. So its standard committee is *very* conservative in how they change the language, and compiler vendors are slow to move to newer versions. It's a very *old* language; all the ideas in C were well-developed in the 60s and the major distinction it has from its predecessors is a static type system and memory model that recognize the shift from word-oriented to byte-oriented addressing in the machines that the developers used. Look and feel and basic feature set were intentionally kept very close to B, which was in turn a mostly syntactic overhaul and simplification of BCPL, which was in itself a subset of *CPL* oriented towards machine-level bootstrapping of the CPL language at the University of Cambridge and University of London. The design of CPL itself started in 1963, based on the ideas in ALGOL 60 but aimed at a larger domain of programming areas. C++ was an attempt to bring some newer ideas in programming languages (type-based abstraction, Simula-style objects, generic programming) to the C language. Because C structures are capable of encoding most compound data structures and can also contain references to code (via function pointers), the features of C++ were prototyped and initially implemented via a preprocessor to a C compiler. The new features just expanded into a particular encoding in C structures. They still follow a similar implementation technique, though modern compilers may find better code for it due to knowing more about the intent. Bjarne Stroustrup, the initial and primary designer of C++, used the design criteria that you shouldn't have to pay a runtime cost for features not used by your program as a guide for how he integrated features into C++ atop of the base C language. He also held compatibility with C as a strongly desired feature. These guides to the development of C++ are probably the source of both its wide acceptance and the sheer weight of books on the "right way" to code in C++. It's very much an "a la carte language", by design, but one must be tasteful about which features are used and how they are used together. Because the extensions of C++ over C focus on abstraction, or the idea of writing programs that hide (hopefully) irrelevant details of how they work from other programs that call them, a programmer that learns C++ first may well feel lost as to how to build things in plain C, as these are precisely the details that are quickly abstracted away. However, highly experienced C++ programmers will most likely have learned exactly how C++ features translate to C (which is practically prerequisite to knowing which features one ought to use in C++ when designing a library or other system from scratch) and will find a shift to programming in C less daunting but perhaps more *irritating* than to the novice C++ programmer. It can be quite frustrating to have powerful, time-saving tools taken away, even if the same ends can be achieved through a manual encoding of the same techniques. On the flip-side, an experienced C programmer will have a leg up on the novice C++ user in understanding the costs and benefits of various C++ features, but may be tempted to avoid hiding the sort of details they are used to working with. Experienced C programmers learn a distrust of opaque code bordering on the neurotic as a survival mechanism, so exploiting features that hide things is very difficult to motivate. This would lead to a rather stilted style of C++ code and grumbling from fully-converted C++ coworkers, though, which is perhaps why many in the C++ camp strongly advocate learning C++ first. One must also keep in mind that although most of the *features* in C++ have been around in programming languages since the late 60s/early 70s, it's taken quite a while to work out how the underlying concepts fit together in the engineering of systems. A lot of early "object-oriented" work, especially once "Object Oriented" became a silver bullet buzzword in the industry, ended up chasing bad analogies and led to poorly designed systems as a result. More recent approaches to designing programs in C++ take advantage of a rising level of understanding among practitioners of both object oriented design as well as alternative approaches such as functional programming and type-generic programming. C++ itself has also advanced at a much faster pace than C (for various reasons it hasn't been used as widely in areas that require really long-term support, like OS kernels, as C has, which makes its practitioners a tad bit less conservative in language extension) and so today's C++ is markedly different in style (if not substance) than that of 10-15 years ago. To wrap it up: both C and C++ are widely used, but the features of C++ beyond C are of the sort that can have a huge effect on the style of programs and what you have to know to understand them at different levels. An intermediate user of either language, unfamiliar with the other, will likely see a typical example of the other as rather foreign. Expertise at either can be both helpful and detrimental towards learning the other, depending on the situation. 
Yeah, so there are lots of different ways to structure the more-or-less equivalent logic. After working through a few of them maybe you decide the one-line while loop doesn't look so complex after all...
if add the following code: p = strtok(NULL, " "); q = strtok(NULL, " "); printf("%s\n", rev(p)); printf("%s", rev(q)); i get Output: FirstToken Segmentation fault
but if i call p = strtok(NULL, " "); it will start off at where q left off right? I need to check the next token without affecting p. i need two pointers. one to the token current token (p) and one to the next token (q). what you just told me defeats the whole purpose of having two pointers since they are essentially pointing to the same place.
You must be missing experience on one or the other. They have similar syntax, and one was based on the other about 30 years ago, and C++ allows the use of the C library (allowing compiling some C as C++).
Sorry, I think you edited to clarify your question after I started replying. I see where your confusion is now. Your pointers would not point to the same thing. For example: char *p; char *q; char s[]="hello world"; p = strtok(s, " "); // p now points to the 'h' in hello q = strtok(NULL, " "); // q now points to the 'w' in world strok is an ancient, bizarre little critter so your confusion is understandable. What a goofy way to implement a function that chops up a string. edit: you changed your question after I started writing a reply again so none of your code was there when I wrote this. 
yeah but p picks up where q left off. THAT is my problem.
`strtok` is behaving exactly as its supposed to, your just using it for the wrong thing. If all you want is to remove right leaning whitespace do it manually. And another thing, you do know that `strtok` writes `\0` terminators after each token right? 
Your code as written doesn't make any sense. THAT is your problem ;) We'll get it sorted. For starters your if statement is useless right now, true or false it takes the same action: print the word pointed to by p. At the end of the function what do you want p and q to point to? Right now either could end up pointing to the last word in the string. 
that and strip the .bsp ending thanks
kinda what silver snurfer said but: printf("/////////////////////////////"); //x20 or whatever for (for loop that goes through list(array of strings i assume?) { printf("// %15s//\n", stringName); //20 - 1(space) - 4(/) } printf("////////////////////////////"); //again kinda new to C and i've been doing java all day, but I'm somewhat certain this will left-align the names though, like in your picture. edit: nvm not an array of strings, sounds like you got it sorted though
Ah I did overlook the space, my bad, but you didn't answer the more important question: what is the goal? Right now you're printing every second word then after the loop is finished you'll have one pointer aimed at the last word in the string and the other will point to nothing. Which pointer is NULL and which one points to the word currently depends on how many words there are in the string. That seems like a useless behavior all around, so I assume that's not what you want. Are you really going to make us *guess* what you want?
okay but what string? and also how would i strip the .bsp ending?
Wtf... that Boost lib is written so straight, but surely has to be trolling... so much code for so little benefit.
dir-&gt;d_name that you had originally, sorry. Also I dont know how to strip the filename :/ Edit: according to stackoverflow it is non-trivial and quite horrible http://stackoverflow.com/questions/2736753/how-to-remove-extension-from-file-name Then again maybe just remove last four chars from each name? Since theyre all bsp. Again dont know how.
yes this is what i needed. i'm never using strtok() again. i understand i didn't choose the best way to go about this but i found it to be the easiest. we had to print the words in a string (not the letters) backwards. so i created a function to reverse the whole string. then i split it up into tokens (words) and reversed them as they are being printed. Example: This is a string. prints: string. a is This 
error: expected '(' before '{' token printf("/////////////////////////////"); for { printf("// %15s//\n", dir-&gt;d_name); } printf("////////////////////////////"); Like this?
Why would writing UI code be any different besides having libraries developed for the specific language? Neither has GUI code in the standard, how could they? Like if I was writing a Win32 program I'd be using the same clunky Win32 API in either language.
What happens if you try `configure` and then `make`?
{ int n1,n2, sum = 0; printf("Enter a number : "); scanf("%d",&amp;n); if ( n % 2 == 0 ) printf(" %d is even number"); else printf(" %d is odd number"); } for (i = n1; i &lt;= n2; i++) printf("i = %d\n", i); if (i % 2 == 0) printf(" ==&gt; Adding %d\n", i); sum = sum + i; } if (i%2=0) printf("sum = %d\n", sum); return 0; can't seem to get it right keep on giving me syntax error i know what syntax error means but i only need the right syntax or an example to the question... 
One trick I learned was add one for each { and subtract one for each }. But generally, creating both the opening and closing at the same time is a great way to limit these problems.
There are various ways how a strictly conforming program can detect if the return-value optimization is performed (aliasing, `longjump`, maybe others). As a result, this optimization does not preserve language semantics and is invalid for C (and would be invalid for C++, too, if not explicitly allowed there).
By default "configure" will build the library for OSX/x86. This simply won't work when building apps for iOS. There are a bunch of other problems too. Like needing ".a" files for armv7 and/or x86. 
Ah! You're trying to cross-compile?
The question you are asking looks like an [operator precedence](http://en.cppreference.com/w/c/language/operator_precedence) one, assuming you are asking if *(p++) is the same as *p++, regardless of pointer type. If that is true, then yes. It isn't a question of the type of pointer, it is simply the fact that ++ always happens before *, unless parenthesis say otherwise. I personally never rely upon precedence this heavily, since it hurts readability. 
Without actually digging into the standard, I'd think not allowing +offsetof() fixed a bug. Edit: or not. Unary plus can apparently be used with things besides literal numbers.
You're going to have to define what you mean by "the same." If you tried to copy a nul-terminated character string using, say, a pointer to int and the above code, it would fail horribly, because checking for zero would only find a case of a int-sized zero (on most platforms, 4 consecutive nul bytes) not a single char-sized nul character. (But on the other hand, it would copy `sizeof(int)` bytes per pass, which is much more efficient than copying a single character at a time, and in most real world implementations of `strcpy()` or `strcat()` you will definitely find something along those lines at the core of the algorithm, after accounting for alignment and remainders of the length modulo `sizeof(int)`.) However if you had two arrays of ints and you wanted to copy from one to the other, stopping on the first zero integer, then the above work work, because the operations on pointers (like dereferencing, postincrement, etc.) are the same regardless of the type being pointed to, with the exception of void. But I don't know why you'd ever want to do that; the code you're referring to is rather specialized to the case of copying nul-terminated strings, so it's rather pointless to talk about what it would do with other types. 
so you're saying, if I didn't mention they were char pointers, you could most likely assume they were?
My copy of the C99 draft says: &gt; More latitude is permitted for constant expressions in initializers. Such a constant expression shall be, or evaluate to, one of the following: &gt; - an arithmetic constant expression, And, later, ... &gt; 8 An arithmetic constant expression shall have arithmetic type and shall only have operands that are integer constants, floating constants, enumeration constants, character constants, and sizeof expressions. Also, &gt; `offsetof(type, member-designator)` which expands to an integer constant expression that has type `size_t`,
You **can** increment a void pointer, in that case the address is only incremented by one, like a char pointer. EDIT: Seem like I was wrong. Thanks for the corrections.
That's one of the problems, yes. It's impossible to compile anything "on" an iPhone. You have to compile it on a Mac running OSX/x86, but target at least two other platforms iOS/x86(simulator) and iOS/armv7.
Your system quite likely already has libraries for doing this kind of thing that take advantage of your hardware better than anything the compiler is going to produce for this kind of code. Vector operations and linear algebra are a fundamental part of scientific applications and 3d graphics so pretty much any system outside of a headless server will have libraries for ripping through this kind of stuff with hardware acceleration. This is a big part of the job of programming: looking up what libraries are available to your program and how to say pretty please with a cherry on top to them. (a perfectly formatted and byte correct cherry at that). Some days I feel I'm less a programmer and more a guy with a higher than average tolerance for reading the manual.
Yeah, and most everything talking about postfix to infix isn't in C so it doesnt really help me.
Being able to translate between different programming languages is a useful skill. The tricky thing with C compared to most other languages is having to free up memory yourself, but for a short-lived program like this, you can cheat and just not worry about it. Example code [here](http://www.codeproject.com/Articles/405361/Converting-Postfix-Expressions-to-Infix) is C#, but he also describes the algorithm in detail. That would be a good starting point.
Absolutely you can, and you should :) Capture and display are completely different jobs. If you want to spin it fast your sampling function should have nothing to do with the timing details of terminals, gui views, or anything else display related. I'm not an arduino or embedded guy but I assume this is a single threaded situation and you're storage limited? Depending on your frequencies of interest you may get by splitting the program's time between sampling and display, but if that's not cutting it you may need to do nothing but sample for as long as you can then communicate the results after. What kind of storage are you working with? Sd card?
Thanks for this. Using a binary search tree actually sounds simpler though in my opinion.. I feel like this algorithm won't be quite as easy to implement in C as it looks in C# 
If `s2` points to an item in a null-terminated sequence, then both of those snippets are the same. However your title seems unrelated , C has various different sorts of pointer. 
Yes, because the loop exits when it finds an element equal to `0`; and strings are commonly stored this way but other data rarely is stored that way.
Like the other guy said, absolutely. Can and should. Sampling and display should be decoupled. In sensor systems, a regular sampling rate is a major factor in how good your system will be. Sample at accurate intervals, and you can deal with the rest later. Instantaneous readings from a sensor are often not really what you want to display to a human anyway. We kinda suck at raw data. Keep a moving average and display that periodically instead. If this is a test/debug setup, absolutely gather however many samples you can in an array and dump them at the end of the test. I've done so many times.
Performance-wise it doesn't really make sense to use BLAS for small (&lt;10) matrices/vectors as they are not optimized for those.
I found this helpful http://c-faq.com/struct/ 
Implement some of these in C without objects, and you will be in for a challenge. http://en.wikipedia.org/wiki/Book:Data_structures
What do you mean with “without objects.?” You are going to have a hard time programming anything in C without using objects.
Can you cast a void pointer to, say, a char pointer to increment it?
Yes, that's possible and legal.
&gt;You are going to have a hard time programming anything in C without using objects. uh...? I think you knew what you wanted to say but somehow you said the inverse.
I think I was very clear in what I said. Here is the definition of the term *object* from ISO 9899:2011§3.15: &gt; ## 3.15 (object) &gt; &gt; 1 region of data storage in the execution environment, the contents of which can represent values &gt; &gt; 2 NOTE When referenced, an object may be interpreted as having a particular type; see 6.3.2.1. Thus, in the program #include &lt;stdio.h&gt; int main() { puts("Hello world"); } You are already using an object—namely, an object of type `char[12]` created by the string literal `"Hello world"`.
Seems to me that the easiest way to convert it into a tree is to use a stack walking from from left to right - push numbers on to the stack as nodes, and when you get an operator, pop the right node and then the left node, and push the operator node onto the stack. Repeat until you use up all the parameters, success is when you have a stack with a single element - the root node. If you wind up with an operator and have only 1 element in the stack, then you know you have a malformed expression with too many operators, or if you have more than 1 element in the stack after you're done with all the arguments, then you have too many operands. Sorry if this isn't much help, rather late where I am right now.
You are right of course. I suppose he was referring to C++ objects or java objects.
strtok does not allow you to have 2 pointers going at once on the same string. Your best bet here is to loop through your source string through using strtok to extract the words and put the words into an array (mallocing memory as you go), then use a for loop to traverse the array and output the data in the reverse order. Based on the comments, you have been struggling with this for several days so heres an example for you to play around with: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; int main() { char data_from_file[] = "The quick brown fox"; process(data_from_file); } int process(char *input_buffer) { char *my_words_array[1000]; char *s; int numwords = 0; int len; int i; printf("\nINPUT: %s", input_buffer); s= strtok(input_buffer, " "); while (s != NULL &amp;&amp; numwords &lt; 999) { len = strlen(s) + 1; my_words_array[numwords] = (char *) malloc(len * sizeof(char)); strncpy(my_words_array[numwords], s, len - 1 ); numwords++; s = strtok(NULL, " "); }; if (numwords &gt; 0) { printf("\nOUTPUT: "); for (i=numwords - 1; i&gt;=0; i--) { printf( "%s ", my_words_array[i]); free(my_words_array[i]); } } else { printf("\n error \n"); } printf("\n"); return 0; } You can go to this site and cut and paste the above into the input field, compile and execute it to see the output: http://www.tutorialspoint.com/compile_c_online.php This code will change: "The quick brown fox" into "fox brown quick The" which I think is what you are trying to get to. 
Maybe adding a few comments and braces will help: /* Behaviour - compare 2 strings and return -1 if left string is &lt; right string, or + 1 if left string is &gt; rights string or 0 if they are the same */ int strcmp(const char *s1, const char *s2) { /* loop while the characters pointed to by s1 and s2 are the same. If they are different the for loop will end. Note we do the if statement inside the loop before we increment the pointer positions on both strings. Also note if the first chars are different we wont even enter the loop (because the char pointed to by *s1 wont equal the char pointed to by *s2) */ for ( ; *s1 == *s2; s1++, s2++) { /* if *s1 is the end of string character then we have hit the end of string 1 without finding any difference between the 2 strings, so return 0 */ if (*s1 == '\0') { return 0; } } /* end for loop */ /* if we fell out the loop it means the characters at *s1 and *s2 are different, so this return statement just tries to point out which string was higher or lower and return a value based on this. Effectively we are just comparing ascii type values so A is lower than B */ return ((*(unsigned char *)s1 &lt; *(unsigned char *)s2) ? -1 : +1); } Note in the return statement we are saying: variable = (condition) ? this value if condition is true : this value if condtion is false so x = (1 ==2) ? 100 : 200; would always set x= 200 because the condition is false. The return in the strcmp above is testing the character at *s1 to the character at *s2, but it looks complex because it is first casting the value on both pointers to (unsigned char *). This is just good defensive coding making sure we are comparing apples to apples. Hopefully this helps you understand a little better. 
The site seems to be down. Here is a google cache version: http://webcache.googleusercontent.com/search?q=cache:UBivok6hWFMJ:c-faq.com/struct/+&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;gl=uk
Will do.
why not use a stack and push/pop values? Look at how forth does it, i think that's way easier to implement. I don't really get the 5 4 + 3 * 2 /" would have to become "((5 + 5) * 3) / 2" though; on rpn that would become 5 4 + = 9, 9 3 * = 27, 27 2 / = 13.5? e: oh oops, i didn't take into account the conversion to infix, a simple stack might not be the right choice for it, sorry for my clumsiness. (it does work however by just putting parenthesis around the expressions you get from the stack and the operator in between. It's not going to be very smart though so it will be very lispy but maybe that's enough and just what you want from the example?)
I didn't know about that data type, I'll be sure to look into them. Thanks!
Depends on the implementation. Glibc on Linux essentially uses mmap() to request an anonymous mapped region. This manipulates some page tables to indicate that the mapping is valid, but that no physical pages are assigned. When the memory is first accessed, *then* the kernel will locate a free physical page, zero it (which it always does for security), and give it to the user. Once it's been written to, the page must either be kept in memory or swapped out. Since Linux zeroes the pages for you, the userspace C library (Glibc) doesn't have to. So no, they don't need to be "touched" in userspace until the application itself writes to them.
I am glad there is at least one person on reddit that can understand me.
Ehem... “object” is a fairly general term. The special thing object oriented languages have is the focus on objects (as opposed to, say, functions); this is explained greatly in the article [execution in the kingdom of nouns](http://steve-yegge.blogspot.de/2006/03/execution-in-kingdom-of-nouns.html). The fact that there are no classes or methods or inheritance in C doesn't mean that C doesn't have objects.
I'm not familiar with this area, but a quick Google search for "matrix library c" gives [this StackOverflow answer](http://stackoverflow.com/questions/4501322/c-libraries-for-mathematical-matrix-operations). If these libraries don't have the required functionality, then sure, write your own and host it. However, bear in mind that just because _you_ can't find it doesn't mean it doesn't exist.
You may want to post a link to the complete Makefile in gist or pastebin. With just the snippet you've provided, it's hard to see what the issue is. Also, it would help to get a copy of the build output.
 if (strcmp(argv[1], " ") == 0) What do you think this line does? Why do you have it as a condition before starting your search? You're probably better off with a while loop rather than a for loop since you don't know in advance how many lines are in the file. fgets will read a line of text, up to some specified maximum size, from a file into a specified buffer. argv[0] contains the name of your program. The remaining argv[] elements contain the arguments passed on the command line, which were separated by spaces. Your problem description states that you only have one command line argument. strcmp() compares two strings and returns 0 if they are identical. Based on this, you want to look at each word (which is its own line of text) in the dictionary file and store it in a buffer, then compare that buffer to the search term which was passed in as a command-line argument. Try rewriting your search function with this, or at least writing some pseudo-code that describes what you'd like to do.
http://playcontrol.net/opensource/LuaHashMap/ maybe? I've never used it, but I came across it doing some Lua stuff, had a similar idea I never followed through with.
Disk based hash tables/btrees okay? http://fallabs.com/kyotocabinet/ and many other options.
If memory management is your top concern, a "flat map" might be the way to go instead of hash table. And it's easy to implement yourself. Just have an array of structures of keys/values, and keep the array sorted by keys. Lookups are O(log n) (binary search to find item), insertions/deletions are O(n) (because you have to move things around, or grow the size of the array which means copying each item). Iteration is very fast: it's cache-friendly (you're just looping over an array), and there's no pointers to chase around. It has very low memory overhead, because a node is just a key and value, no pointers to maintain the data structure. Though you might consider allocating each value, if the value is a large.
I'll look at those tomorrow at work, thanks.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Trie**](https://en.wikipedia.org/wiki/Trie): [](#sfw) --- &gt;In [computer science](https://en.wikipedia.org/wiki/Computer_science), a __trie__, also called __digital tree__ and sometimes __[radix tree](https://en.wikipedia.org/wiki/Radix_tree)__ or __prefix tree__ (as they can be searched by prefixes), is an [ordered tree](https://en.wikipedia.org/wiki/Ordered_tree_data_structure) [data structure](https://en.wikipedia.org/wiki/Data_structure) that is used to store a [dynamic set](https://en.wikipedia.org/wiki/Set_(abstract_data_type\)) or [associative array](https://en.wikipedia.org/wiki/Associative_array) where the keys are usually [strings](https://en.wikipedia.org/wiki/String_(computer_science\)). Unlike a [binary search tree](https://en.wikipedia.org/wiki/Binary_search_tree), no node in the tree stores the key associated with that node; instead, its position in the tree defines the key with which it is associated. All the descendants of a node have a common [prefix](https://en.wikipedia.org/wiki/Prefix) of the string associated with that node, and the root is associated with the [empty string](https://en.wikipedia.org/wiki/String_(computer_science\)). Values are normally not associated with every node, only with leaves and some inner nodes that correspond to keys of interest. For the space-optimized presentation of prefix tree, see [compact prefix tree](https://en.wikipedia.org/wiki/Compact_prefix_tree). &gt;==== &gt;[**Image**](https://i.imgur.com/MBQJfCV.png) [^(i)](https://commons.wikimedia.org/wiki/File:Trie_example.svg) - *A trie for keys "A", "to", "tea", "ted", "ten", "i", "in", and "inn".* --- ^Interesting: [^Trie-sur-Baïse](https://en.wikipedia.org/wiki/Trie-sur-Ba%C3%AFse) ^| [^Trie-Château](https://en.wikipedia.org/wiki/Trie-Ch%C3%A2teau) ^| [^Lalanne-Trie](https://en.wikipedia.org/wiki/Lalanne-Trie) ^| [^Radix ^tree](https://en.wikipedia.org/wiki/Radix_tree) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cr0k67t) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cr0k67t)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Thanks for the feedback. I have two potential plans of action at this point: 1) Use an encoder chip to record the tick marks and record the position every millisecond (seems the easiest/most intuitive) 2) Use a buffer to store the data points. It gets more complex this way because memory is an issue (Uno has about 2kB of memory). We would need to fill a smaller buffer then send them as packets to the CPU as the original buffer clears/overwrites itself with new data. This option wouldn't need any additional hardware.
i tried btrees, waaaay to heavy for what i need to do
Use the variable LDLIBS instead of LDFLAGS. Source: https://ftp.gnu.org/old-gnu/Manuals/make-3.79.1/html_chapter/make_10.html https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html
Thanks. That worked! 
Awesome. Thank you!
There's nothing in the standard C library to do that. You have to use platform specific APIs, but you didn't specify what platform you're using (hint: always do that.) On Windows, you use [`FindFirstFile()`](https://msdn.microsoft.com/en-us/library/windows/desktop/aa364418.aspx) and [`FindNextFile()`](https://msdn.microsoft.com/en-us/library/windows/desktop/aa364428.aspx). On POSIX, you use [`opendir()`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/opendir.html), [`readdir()`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/readdir.html), and [`closedir()`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/closedir.html). Note that the only members of `struct dirent` that are required to exist are the inode number (`d_ino`) and the filename (`d_name`). On some systems there may also be a type field (`d_type`) that allows distinguishing between files and directories without having to [`stat()`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html) the name, but that's not portable.
As OlderThanGif said, it's all done lazily (probably, depending on the platform). You'll most likely have all pages pointing to a single zero page with a copy on write scheme. [http://en.wikipedia.org/wiki/Copy-on-write#Copy-on-write_in_virtual_memory_management](http://en.wikipedia.org/wiki/Copy-on-write#Copy-on-write_in_virtual_memory_management)
What does your data look like? The best choice for a data structure cannot be made without knowing what kind of data you are using.
Can you please define what the term “text file” means in this context? There isn't anything making files containing plain text special and it's going to be a bit tricky to find out which files contain plain text.
Are you sure you actually need a hash-table and that something else wouldn't work? You could always go for the bucket-style hash. You pre-allocate a fairly large array of pointers (Which doesn't ever change size), and your hash indexes this array. Each entry in the table refers to a linked-list of items with that hash. So the look-up plan is to do your hash, then iterate through the linked-list at that location and read/insert/remove/etc. your item. The setup is extremely easy and it can be fairly effective, as if your hash is decent then your linked-lists shouldn't ever get very long. Something like this: struct item { struct item *hash_link; /* stuff */ int key; }; struct item *hash_table[2048] = { NULL }; /* Initialize all of them to NULL */ /* Calculate the hash */ int hash_get(int key) { /* Extremely simple hash alg, just take the lower bits of the key */ return (key % (sizeof(hash_table)/sizeof(hash_table[0]))); } void hash_insert(struct item *i) { int index = hash_get(i-&gt;key); /* Insert onto the beginning of the list */ i-&gt;hash_link = hash_table[index]; hash_table[index] = i; } struct item *hash_index(int key) { int index = hash_get(key); struct item *cur; for (cur = hash_table[index]; cur; cur = cur-&gt;hash_link) if (cur-&gt;key == key) return cur; return NULL; } That's not the greatest code (It only works for `struct item` objects, nothing else), but that's the basic idea, and for a one-off it would be just fine. If you need multiple hash tables you'd probably want to look into using `container_of` to make the hashing stuff generic. I could show you an example if you'd like. Other then that, this should be decently effective for a hash-table if speed isn't a huge concern. Obviously, you have to manage the memory holding the nodes themselves, but in general that's not a huge deal. Just allocate them all separately using `malloc`, and then fall `free` on them when you remove them from the hash_table (Removing is like `hash_index`'s code, but you remove `cur` from the list as well as return it). If you wanted, you could also have the hash table make copies and do the memory management itself. That could simplify things though it would be slower. If you went that route, then you'd just use `malloc` and make a new `struct item` in `hash_insert`, and then call `free` on it when you call `hash_remove`. You'd also want a `hash_empty` function, or something similar, that can loop over the entire hash table for you and free every node in the linked-lists. Edit: Corrected an error, `hash_index` returns a pointer to a `struct item`, not a `struct item` by-value - Very important distinction.
One difference in the two snippets is that the second snippet will increment `p` and `s2` even when `*s2` is 0, while the first one will not.
No, it's not rape!
If you're programming for Unix or Linux, it's usually a bad idea to enforce certain file extensions. The Unix way is to let the user specify any file name and not mess with it. For instance, what TeX does (implicitly adding .tex to files without an extension) is a really shitty idea.
&gt; You should try the following: &gt; &gt; strcat(str, argv[1]); strcat(str, str2); The first of those should be a `strcpy`, not `strcat`. The contents of the array `str` have not been initialized.
I think you're in the wrong sub OP. Perhaps you are looking for /r/csharp?
Hi. I was going to post a somewhat similar question on this sub, but I saw this and thought my question was maybe relevant as part of this thread, instead. How would the following expressions be evaluated differently, considering the order of operations you explained in your response to the OP: For the declaration char *a,*b; 1) while(*a=*(b+*a++)); 2) while(*a=*(b+*a)) a++; (NOTE: use of a single '=' sign is intentional - I'm interested in the boolean result of the assignment, not in a comparision.) I am asking because formulation 1) above has always worked in the past for me in a program often compiled on both Windows Visual Studio and gcc, but has recently (sometime in the last year), started segfaulting when compiled in gcc but still continues to work when compiled on VS. Formulation 2) works properly on both platforms, but I'm not understanding what caused version 1) to stop working on gcc. 
Thanks, i'll try and let you know :)
Aww sheeeeet. You done got told! But seriously, in what world are C and C++ 90% the same? Just because it uses braces doesn't mean they're the same. 
Thanks for your help here! Here's what I'm working with now: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; int main (int argc, char *argv[]) { char *line; FILE *fp; if (argc != 2) { /* printf("Usage: ./read_echo &lt;file&gt;\n");*/ fputs("Usage: ./read_echo &lt;Words&gt;\n",stderr); return 1; } if ((line = (char *) malloc(81)) == NULL) { printf("Couldn't allocate space for line buffer!\n"); return 1; } fp = fopen("/usr/share/dict/words","r"); fgets(line,80,fp); do { fputs("word found! \n", stdout); } while((strcmp(line,argv[1]) == 0)); return 1; return 0; } However, now it's printing out "word found!" even if the word isn't there. Any ideas? 
Would something like this work instead of a while loop? fp = fopen("/usr/share/dict/words","r"); fgets(line,80,fp); if((strcmp(line,argv[1]) == 0)){ fputs("word found! \n", stdout); return 1;} else{ fputs("word not found \n", stdout); return 1; }
Why are you trying to avoid a loop? *You have to have a loop in there somewhere!* Again, right now you're only reading in the first line of the file. You need to read in the *entire* file, one line at a time. 
Have you declared `scanner` before you are using it in `main`? If an undeclared function is used, a C compiler will assume that the return type of the function is `int`.
Ok, thanks. A do while loop would be better than a for loop?
It would help to post something compilable as well. `getline` isn't standard C either, so be explicit about what extensions you are using.
Christ, it was declared as a type char in the header. It was returning pointer to char in the source file though! I need a system. Thanks as always, zifyoip...
Isn't it now though? That's why I'm using it. Edit:Apparently not? I wonder where I got that idea from.
Neither. A plain, simple while loop is what you want. **Again, see my original reply**, where I show you the loop you need. I used `fscanf` instead of `fgets`, but it works roughly the same.
There's a standard C++ function called `getline`. In C, there is no such function (just checked C11 standard to be sure). I think you're using a nonstandard GNU library function.
Yeah, I must have seen it in some hybrid blog, as I don't really touch C++. 
It's in IEEE Std 1003.1, 2013 Edition, so POSIX but not standard C. http://pubs.opengroup.org/onlinepubs/9699919799/functions/getline.html 
While not standard C, `getline()` is now a POSIX C extension, so it's standardized there. http://pubs.opengroup.org/onlinepubs/9699919799/functions/getline.html One thing to note now that you have your first problem sorted: &gt;The application shall ensure that *lineptr is a valid argument that could be passed to the free() function. If *n is non-zero, the application shall ensure that *lineptr either points to an object of size at least *n bytes, or is a null pointer. 
So, like this: while (fscanf(fp, "%63s", line) == 1 ) { if((strcmp(line,argv[1]) == 0)){ fputs("word found! \n", stdout); return 1;} }
Yup, like that.
that must be the problem! it says the first word in the dictionary works, but none after that. I'll take out the return. Thanks!
It might help you understand what's going on if you put some debug print in there. For example: while ( fscanf(fp, "%s", line) == 1 ) { printf("Comparing %s %s\n", line, argv[1]); if ( strcmp(line, argv[1]) == 0 ) { fputs("word found! \n", stdout); return 1; } else { fputs("word not found! \n", stdout); } } I only took out the return in the not found case, so that it will continue to look for a match. Then when it finds a match, that's when it quits.
Excellent.Thank you for the very clear and complete explanation. I wrote that code a very long time ago and only recently ressurected it. I had overlooked the concept of sequence points entirely, but when I traced the segfault to this line, it immediately made my spidey sense for bad code tingle. I just couldn't pinpoint the reason why, and you have answered it perfectly. 
Sockets. Pipes. Mailboxes.
Yes there is, but you will need to be a bit more specific as to what you are trying to do. Are you trying to force the other program to open the file against it's will? Or is the target program something you have developed yourself and you are looking to use a standardized way of communicating between the processes (through sockets, pipes, and mailboxes as /u/playaspec pointed out).
Yes, you're right, I stopped doing that at some point. Probably from laziness in putting up #ifndef catches. I would have continued to if not for this reminder, thanks.
W. Richard Stevens' Unix Network Programming, Vol. 2.
Can you post your whole code? I'm kind of curious
[IPC](https://en.wikipedia.org/wiki/Inter-process_communication)
[This documentation](https://computing.llnl.gov/tutorials/openMP/) helped me get through a number of openMP school projects. You want to take a look at 'data scope attribute clauses'. Basically you need to declare the private variables for each thread like this: #pragma parallel private(var1, var2, ...) Other variables are shared by default! Also, depending on what you need to do, take a look at the *reduction* clause, this might substitute your critical section. Edit: found the [slides](http://www.st.ewi.tudelft.nl/~varbanescu/ASCI_A24.2k12/ASCI_A24_Day2_Part1_OpenMP.pdf) belonging to the openMP lecture I attended as part of a parallel programming course.
I'd use popen to do that, just because you will be able to receive return values of the program you called which allows you to react when something went wrong. Pipes also have more "features" you may like. Just google it.
Shared memory. Memory mapped files. Message queues. Signals. Read these for an extensive coverage of some Interprocess Communication (IPC) methods: * http://beej.us/guide/bgipc/output/html/multipage/index.html * https://docs.freebsd.org/44doc/psd/20.ipctut/paper.pdf * https://docs.freebsd.org/44doc/psd/21.ipc/paper.pdf
yes, you are quite right
You mean like this? if(kast[a] == 1){ const char *dices = " \n O \n \n"; printf("%s"), dices;
Gosh... Didn't see that, thanks for your help with the pointer but the printf was such a silly mistake...
I just tested your code, it seems to work. What is the problem to begin with?
 gradeCnt++; if (grade[c] == STOP_VALUE -1) { break; } instead of if (grade[c] == STOP_VALUE -1) { break; } gradeCnt++; if you stop on the first one, you'll be dividing by 0. And regardless what you set STOP_VALUE to, your count will be 1 short, since you exit the loop before incrementing the count. ---- Edits: ---- 1. Also, though it isn't relevant here, typecasting takes precedence over division, so: (float) gradeSum/gradeCnt would typecast gradeSum to float then divide. Reference: http://en.cppreference.com/w/c/language/operator_precedence 2. printf("\nYou have made the maximum # of entries.\n"); would never print, as the loop would not be entered if c == array size. 
Hm....I'm trying to figure where I went wrong with it accepting 0 as one of the input...Ideally, I'm trying to get it to print ==Data Entry Complete== Grade 1: 50 Grade 2: 25 Grade 3: 25 Grade 4: 30 Grade 5: 0 or something like that Edit: Okay, so it did work, but now I need to figure why "-1" exits instead of just "x". Any explanation? Or some kind of insight that'd help me get a better grasp on it?
I see...So how would I go about including that? You were right, I changed the array size to 10 to test it and it did not print. However, when I took out the gradeCnt++; it just gave a large line of text repeating "Please enter a grade". How would I go about including the maximum # of entries? Would I change the IF if(c &gt; ARRAY_SIZE) { printf("\nYou have made the maximum # of entries.\n"); } ? What would I have to do to go about including the print statement?
Since you're incrementing gradeCntr right after inputting a value, use that to check. The reason why c wouldn't is because it's incremented after the loop. gradeCnt++; if(gradeCnt==ARRAY_SIZE) { printf("\nYou have made the maximum # of entries.\n"); } should do the trick
Hm, so how would I include it? Would I change the scanf? Edit: I would like to know, but I did reread the instructions and it seems that -1 would be an appropriate input for ending the program early.
Yes, a for loop inside the block (curly braces) of another for loop. Think of the outer for loop as putting multiple rows together, whereas the inner for loop builds the actual individual rows.
Nope, you can have a square start at (1,3) and end at (4,6) for example.
Since he basically wrote your homework for you, I imagine so.
&gt; The sides of the rectangle are always parallel to the x and y axes. 
In the example I provided they are parallel too. All this means is that the rectangle (Square) is not rotated at all.
Anyway I tried to fix that [here](http://pastebin.com/8xi2TwtG), but still wrong answer.
But in the input, for this example would be x0 = 1, y0 =3, x = 4... oh damn, u right, I got that.
Well thats because you have a couple problems, this was just the first one. But the solution you provided now doesn't really fix the problem, as the user input is in the form ax1,ay1,ax2,ay2 and you are decoding it ax1, ax2, ay1, ay2. I don't understand why you ware switching x1 and x2 based on which is larger though. You should be doing something like this http://stackoverflow.com/a/306332 
I believe this is undefined behavior. You need a sequence point between the increments for them to apply properly as /u/wgunther suggested.
No problem, cheers.
Actually it is undefined behaviour, meaning anything could happen. (program crash, explode, etc.) The case of a finite number of permitted results is called "unspecified behaviour" (which is not the case here). 
When you say "a whole slew of results" it sounds to me like you are describing a large but finite number of possibilities. Especially combined with "since order of evaluation is not defined", which seems to be implying that the "slew" arises from the lack of definition of order (which is not true). 
A quick note before talking about the program: Most people uses websites like pastebin for posting code. You actually took the time to format your post, so it's less of an issue, but it'd be worth considering in the future, just because this is a decently large piece of code. Also, another note, I'm guessing your include of `strings.h` is a typo. The actual standard library is `string.h`. I was able to modify your program and get it to work. The basis of the problem here is a use-after-free bug created by the stack, which basically just means that you're using a pointer to some memory that you already called `free` on. The situation where this happens is when you call `top` and then `pop`. `top` returns the `data` pointer, but then `pop` calls `free` on this same pointer. All of this happens before you actually use the result of `top`, meaning that when you use that result you're reading a value that you already freed, and thus a use-after-free bug. Fixing the allocation problems isn't to complex for this code, surprisingly. I'm not going to just post my edited code, but I will give you the general idea, which is basically to remove your copyString call and `free(tmp-&gt;data);` line from the stack code. That way, the stack doesn't handle allocation of the `data` supplied to it at all, instead it simply keeps hold of whatever is pushed, and then returns that same pointer on a top. With that modification, you provide a string to `push` (Such as the result of `formats`), and then the stack will return this same string when you call `top`. The advantage here is that by removing the `copyString` and the matching `free`, the stack no longer has to worry about managing the memory pointed to by `data`. Instead, the user of the stack is responsible for managing their own memory. You actually use the stack in the code as though the above was already the case for the most part. For example, the usage of `formats` is correct, `formats` returns an allocated buffer, and then you push that allocated buffer on to the stack to store it. You leak the result of `formats` currently, but if you implement what I'm describing, then that usage of `formats` will actually be right. The only real catch is making sure that all the inputs to `push` are malloc'd strings (There's one case where the string you're pushing isn't a malloc'd string - Use `strdup` for this situation). Then, it's just a matter of calling `free` correctly, which just means calling `free` on every return of `top` *after* you're done using it (So not in `pop`)..
Another way of fixing the problem is to have `pop` both pop and return the pointer to data. I think using `copyString` is a good idea because then the stack structure can fully manage its own memory. Imagine if some entries were string literals and some were malloc'd strings for example. (Your idea is workable of course but the OP's way is less risk of an invalid `free` or a memory leak). 
You might want to revamp your argument parsing. Look into the `getopt` function for how to do easy and painless argument parsing.
Yes, that is what I am trying to do. I can't find the renderer part. I was asking if. someone could point it out of the libpoppler. I looked at ghostscript also. No, worries though. I got someone irl helping me. 
libpoppler looks complicated. Here is the [API of ghostscript](http://www.ghostscript.com/doc/current/API.htm), maybe it's easier to use for you.
others have made great comments, including the use after free problem, and debugging. I hughly recommend looking into debugging, and the various tools (valgrind, cppcheck, lint, gdb, etc). I just want to say that, for the most part, your code looks great! It is well formatted, the variables and functions are well named. The structure is very readable. What you have accomplished well is writing maintainable code. Note that DSMan said you can fix the problem with relative ease -- that's because your code is maintainable. One more, minor, comment: your CopyString() as written could be replaced with strdup()
I also use #defines for storing constants that are used throughout my code. This simplifies changing all the hardcoded values into just one simple value change in a #define, which is used everywhere.
Okay, so what happens if it's declared as a const variable? Don't you get a mov instruction from a memory address, with extra memory allocated to actually store the value at that address?
sure.
I personally like `pop` returning the pointer as well as removing it, IMO it makes problems like this one more obvious. Personally, I disagree. I have a few problems with the stack `malloc`ing it's own copies of the strings. The first is that you don't really avoid invalid free's or memory leaks because you still have to pass back (In `top` or `pop`) a new copy of the string you currently hold. Meaning, you have to allocate a copy when you receive it in `push`, and allocate a copy when you pass it back in `top` or `pop`. If you don't free the copy provided to `push`, or don't free the result of `pop`, then you'll still get memory leaks (Which is virtually the same as my setup, except my setup doesn't require calling `free` when you `push`). Also in your setup, like in OP's code, if you just pass the same copy that the stack is holding back with `top`, then a use-after-free error is extremely easy to do (Just don't make your own copy of the string before you `pop`). On the flip side, if you keep passing copies back, then every time you use `top` you have to pass a new copy of the string, meaning that successive calls to `top` don't require the same pointer. Personally, I think that having the stack manage it's own strings just needlessly complicates the setup and the code for no benefit. If you don't have the stack manage it's own memory, then you can use the same stack code with malloc'd strings, string literals, struct's, etc.. Obviously, pushing a string literal onto a stack with malloc'd strings is an issue, but I wouldn't consider that a huge risk, and it's easy enough to `strdup` them before passing them to the stack, and in either case here you have to know whether or not you're `push`ing a string literal or an allocated string. In your setup, any code that `push`s a string has to keep track of if that string was malloc'd or not: If the string was malloc'd they have to free it, but if it's a literal they don't. So, you really can't mix malloc'd strings and string literals even with your setup, or else after you `push` the string you wouldn't know whether or not to free it. So, with either approach the code itself doesn't really change any besides the usage of `strdup` if you have a string literal, because in both cases you have to keep track. In my case, you just have to add an extra `strdup`, and in your case you have to make sure not to call `free`. But, in this case, an extra advantage of my code is that if I have a stack that's only going to ever contain string literals, I can completely avoid allocating any memory at all - just pass the string literals to `push`, and then get them from `pop` - No `strdup`ing required. This is actually a design point that I feel pretty strongly about. Later today I may write-out some examples.
This method is also used occasionally for patching old code to work with later systems, as is the case with broadcom-wl-dkms (see https://aur.archlinux.org/packages/broadcom-wl-dkms/ )
It depends on the optimization settings, and the usage context. http://stackoverflow.com/questions/27068362/static-const-vs-define-for-efficiency-in-c
It depends how you declare it. In general, your correct in your assumption, but with optimization in special cases the compiler may remove the variable itself, or insert the value in place of the variable. For example, if you declare `static const i = 2` at the top of a file, `gcc` will completely remove `i` and insert 2 in it's place everywhere it's used. In general, the bigger case is cross files. If you declare `const int i = 2` in one file, and then `extern const int i` in a header, the other files making use of `i` will have to read the value from the memory-address that `i` is at. With `#define`, this isn't the case. The big exception to my first point is that taking the address of `i` is a valid operation, and if you do that then the compiler can't remove `i` from the resulting binary. `#define`s aren't really better in this regard though, because you simply just can't take the address of them.
That worked. Thanks! Not sure what got in my head with `##`. I had originally intended to include some questions about VA_ARGS in macros, and c89 doesn't' support that. 
Change your initialisation of `s` to this: char s[23] = "hello\0is this broken?"; Then see if you get a different result for `my_strcat` and `strcat`.
It's useful to remember that C is a very old language, designed when compilers were very simple and resources very constrained. So even if what /u/manystripes said does not apply to current implementations, it is absolutely how early implementations worked, and why the language was designed that way.
You are trying to assign a value to an address that is not write-able. char *stack = "init"; //"init" is stored in read-only memory. Try malloc-ing the memory for the stack, and then memcpy'ing "init" to it.
Everyone is leaving out using defines to give that nasty C syntax a bit more human friendly readability... #define begin { #define end } #define then { int main(char *argv, int argc) begin if ("VB syntax best syntax") then printf(”Winning!"); end return 1; end It's the only way to fly, baby. 
[This section](http://c-faq.com/expr/index.html) of the C FAQ is worth reading.
`const` is in C89. `sprintf` also is (you can use that instead of snprintf in my example, since you calculated the length). 
Can't wait to go thru this! I've been looking for an article on this to get my feet wet for a while - thanks for posting!
It's a pretty ugly use of a `for` loop in general, so I'm not surprised it's confusing. All that bit does (`save = (char *) 0;`) is set `save` to a null pointer. Throughout the iterations of the `for` loop, if the condition `c == ch` never passes (that is, we never find the character we're looking for), then the function will just return this null pointer because `save` will never be updated. 
Fundamental for cross-platform development. You can control which lines get compiled. Example: One version of main() for Apple machines, one version of main() for Windows, one for Linux. In simple terms: If you could not selectively compile, you would get errors on machines with different API's to access OS functionality for thing In real life you'll commonly find this in game development libraries (which make heavy use of native system API's): SDL, Allegro, GLFW, etc. Higher level languages such as Java use these C libraries which in turn use the pre-processor do to this work (LWJGL). 
It means that if the character is not found then a null pointer is returned. The compilation error in your snippet is due to failure to `#include &lt;stdio.h&gt;`. (There are also logic errors as pointed out in /u/danielkza's reply)
Yep! You'd implement say an instruction set for a Z80 based off the specification for the cpu and you've got yourself a z80 emulator :)
It doesn't look like you need any of these values to be double pointers at all. Why not make them `struct node *` instead? Other than the unnecessary indirection, the pointer use looks fine. For Bubble Sort you should review [how the algorithm works](http://en.m.wikipedia.org/wiki/Bubble_sort).
Non-mobile: [how the algorithm works](http://en.wikipedia.org/wiki/Bubble_sort) ^That's ^why ^I'm ^here, ^I ^don't ^judge ^you. ^PM ^/u/xl0 ^if ^I'm ^causing ^any ^trouble. [^WUT?](https://github.com/xl0/LittleHelperRobot/wiki/What's-this-all-about%3F)
Thanks! I've implemented bubblesort before, my main goal at this point is getting the pointers to work correctly. That's why my bubblesort comment has a question mark at the end of it... I'm working on the pointer thing first :) I haven't used pointers in this way, and wanted to be able to do it with the added indirection.
There are also two other errors. When passing a `char*` to `printf` the correct specifier is `%s`, or if you actually just want to print one character, you have to dereference the pointer yourself (as in `printf("%c", *save)`). But if `save` is null that's an invalid operation. The key thing to understand is that the *existence* of a null pointer is fine, but actually *dereferencing* it in any way is undefined behaviour and a programming error.
I've been wondering if it's possible to simulate lower clock frequency as well. I want to make a VM of sorts based off a quite old architecture and processor, so I was hoping to try and emulate its speed even on new hardware 
What's K&amp;W?
%p, like in the error message, would work fine.
Haha I hate you now, just spent the last 3 hours I should have been sleeping implementing my own version.
For starters, scanf requires exact formatting. Your example input contains spaces that you are not considering when you scan.
That looks like it's working fine, aside from telling it to read 4 rows and only giving 3. What's the issue you're having?
You really need to grasp what your problem is and make it clear so we can help you. At the moment all we can see is (seemingly) correctly compiling code and you complaining about something that has to do with the dimensions of your array.
I live to serve.
If you are doing embedded stuff, get yourself a development board with a popular controller on it. They are dirt cheap and you have plenty of resources online. Learning C with a good book is a good start, but it won't help you when you have to fiddle around with a dozen registers to get your serial port running.
I have a decent understanding of imperative programming and a rudimentary understanding of pointers. I have studied C academically in terms of Embedded programming (introductory course) and Real Time Computer Systems (intermediate level course, interrupts, registers, stack, assembly etc) as well as programming micro controllers (specifically, mBed platform [C++] and Raspberry Pi [Python].). I am really looking for a textbook that will take me from a basic knowledge of C programming and embedded systems to having a decent understanding of writing and understanding embedded software.
Currently have Raspberry Pi 2 which I use Python for, but I want to program in C on it. I also have a few mBed platforms which I use the C++ IDE on the mBed website for. I am looking into purchasing a low-level uC to do learning with.
Here's a hint: where are the newlines in your output coming from?
Indeed, because that would only print the address that the pointer corresponds to, without ever dereferencing it.
&gt;Currently have Raspberry Pi 2 which I use Python for, but I want to program in C on it. The raspberry pi isn't great to learn embedded programming, as you are either going through Linux, or dealing with quite complicated bare metal setup. &gt;I also have a few mBed platforms which I use the C++ IDE on the mBed website for. Why not just use some of your mBed platforms? If they are not the "official" mBed, then you can probably program them with a separate IDE, for instance you can program Freescale's boards with [Kinetis Design Studio](http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=KDS_IDE). The skills I suggest you focus on are Interrupts, raw peripheral access (no MBED Libraries), linkers, choosing ROM/RAM targets, boot, and power saving (sleep modes etc). An excellent book I recommend to cover all of these topics is [Making Embedded Systems](http://www.amazon.co.uk/Making-Embedded-Systems-Patterns-Software/dp/1449302149/). If you already know C, or are learning it elsewhere, its an excellent introduction and I certainly wish I had found it when starting out. In another thread you said: &gt;I am really looking for a textbook that will take me from a basic knowledge of C programming and embedded systems to having a decent understanding of writing and understanding embedded software. I believe this really is the book.
This is exactly what I am looking for. I have a Freescale KL-25Z so I think I will take your advice and download KTS and give it a shot. I will definitely look into that book. Could you recommend a book for learning C to complement it? Thank you so much for your advice.
I've thought of that, and there's no apparent reason that it shouldn't be able to work, but I've always thought it wouldn't be as 'accurate' as I'd like. No foundation for that thinking, I just like to overcomplicate things in my head. Guess I should actually get around to doing it and tackle the problems as they come up. 
oops I meant to say K&amp;R
Er. Borland? Why in the world? 
You include header files (.h); you link against libraries.
DAMN! I forgot about the '/0' as the last space of the string.
Hard to say, considering [Microsoft provides compilers](https://visualstudio.com/en-us/products/visual-studio-express-vs.aspx) for free now ...
One of the downsides of K&amp;R is that it hasn't been updated since before the C99 standard. Both C99 and C11 (the current version) have introduced features that can be especially helpful in the context of embedded systems programming. I'm not familiar with any of the introductory books that cover C11, but [Harbison and Steele's](http://www.amazon.com/dp/013089592X/) reference is a great one that covers up through C99. As the title says, it's a *reference*, but you'll really want to have something like this handy to resolve the various odd questions about the weird corners of C syntax and semantics that come up occasionally.
CS50 on EdX/ youtube/ harvard starts with C language. For a good book try the beta LearnCthehardway.com
* You're not incrementing arr, so you're repeatedly dereferencing its first index. That being said, you should be using arr[i] instead of pointer arithmetic since you're accessing the array later on. * 1 and 2 are going to be returned as prime numbers because it skips the for loop and confirms that c == 0, as assigned immediately prior.
Before anything else I gotta give you heck for your function and variable names. If I was marking you'd definitely be losing points there, a function named funk and variables that are all single letters? Not good. Int c isn't even used in main. In funk there are a couple different times when you want to print a number from the array. It's the same job each time, so shouldn't those lines be the same? That'll fix your "11111" problem, then you've got some logic issues in the section that's looking for primes. edit: actually I think the logic is okay, it was just hard to follow the nameless variables.
http://prntscr.com/73vtn4 this shit happens when I use scanf.
IMHO understanding pointers well is like learning math. Beyond the very basic level, just reading more will really not do that much. You need to write code to develop the kind of intuitive understanding that allows you to use them with confidence. I recommend doing lots of tiny projects that use a lot of pointer fiddling. Implement stuff like: - Linked list - Doubly linked list - Binary Tree - Red-Black Tree - Some spatial tree, like an octree - Malloc/Free Also, learn to use valgrind. If you intend to write a lot of low-level stuff in your career, learning it or another similar memory debugger at some point is probably necessary, and learning it now will probably save you a quite a bit of your time by telling you how your data structures are leaking.
gcc nl.c nldemo.c works for me. The common way would be these 3 commands, which produces an executable named nl gcc -Wall -Wextra -c nl.c gcc -Wall -Wextra -c nldemo.c gcc -o nl nldemo.o nl.o 
I fixed it, I think I just didn't copy and paste properly
Hey, thanks for the reply, I'm trying to rearrange any unwritten characters to the start of the array and then start writing after that until the array is full again,
Haha Tnx for the answer, but it was actually a hint for you. Determine for yourself what the value of position and pos should be when rearrange() returns. At what position in line[] are you writing after you wrap around? 
Haha, thanks, I'll look at that and try and get it working myself! A much better way of learning!
That's not a C problem, that's an embedded programming problem. It'd probably be best to talk to your classmates, T/A, or professor to find out exactly what you missed. Anyone posting an answer here will not help you on your journey of learning C or learning embedded programming.
I think this is a conversation you should be having with your instructor, or google.
I see. Sorry for the misunderstanding.
Good code style, for beginner=) You must firstly understan arrays logic. 
not sure how to do it in less than 15 chars, but I got int i;for(i=a&gt;b?a:b;a%i+b%i!=0;i--);return i; which is 45 chars. See if you can shrink that? 
I got 22: int gcd(int a, int b){return b?gcd(b,a%b):a;} it would be nice to get rid of that `return ` keyword...
It's a poorly written problem overall, because it relies on undefined behaviour - the solution omits the word `return` because it's too many letters. There's a recursive solution for the gcd, and given we're after brevity, recursive is the way forwards. My solution is: `b?gcd(b,a%b):a;`, let me break that down: - `?:` is the ternary conditional operator, and it's like an `if/else` statement. The bit before the `?` is the test, the bit between the `?` and the `:` is the `if (true)` bit, and the bit after the `:` is the `false` bit. - `b` is the conditional test, which is the same as the test `if (b != 0)` - `gcd (b, a%b)` finds the gcd of `b` and the remainder of `a / b`, which is part of the recursive solution - Otherwise, the function returns `a` and ends.
Good luck on your C adventures! I started learning C about half a year ago, and I tried starting with K&amp;R, but it was way over my head and I got stuck around chapter 2. Imo, the K&amp;R book, while classic and still a totally valid way to learn C, is becoming more and more outdated. The original version came out in '78 and the 2nd edition in '88. It was the C standard before there even was one, meaning it doesn't necessarily conform to C89/99/11. Also, it's not written very well for beginners, because it's so concise and more of an overview of all the primary features of the language. So.. it's still totally valid to learn from, as tons of people have, but if you find yourself banging your head on a wall with K&amp;R, check out [C Programming: A Modern Approach](http://www.amazon.com/Programming-Modern-Approach-2nd-Edition/dp/0393979504). I'm about 80% through it, and it covers *everything* very well and thoroughly. Each chapter introduces new concepts, with explanations, examples, exercises, and programming projects pertaining to those concepts. If you take your time on each chapter and do (mostly) all the exercises/projects, you'll be surprised at how simple things become over time. I've also been doing /r/dailyprogrammer challenges every week. I'm only good enough to do the easy challenges, but they also help a ton with learning (and can be fun). The best way to get better at coding, is simply to code more things more often and challenge yourself constantly. ...Sorry for the wall of text, I mostly wanted to show you the "bigger and better" version of K&amp;R that was recommended to me. I very highly recommend it.
**C primer plus** is a very good start or **Let us C**. Head First C is very popular book for beginners,but I think it is just coloring book. Books+Video Tutorials+ work :D
Got it, thanks!
Good style indeed!
After memory allocation would f-&gt;x = 320; work as well?
how come it is legal to do: f.y = "hello"; without a malloc?
Because "hello" in this case is a pointer to an array of characters and has an address.
You have the right idea. The syntax for referencing the 'x' field would be: *(*f).x = 320; Or, equivalently (and what most C programmers would write): *f-&gt;x = 320;
```*(f.x)``` is the same as ```*f.x``` which binds to x? 
 struct Foo{ int x[32]; }; struct Foo f; f.x = {32, 23 32 ,32}; then why is this illegal?
Man, what the hell. As far as I can tell, this generates some kind of lookup table for a 6502 emulator that compresses sequences longer than a byte, into bytes. (Hence "base 256".) The clever part is that much of the calculation is done at compile time by using the outcomes of the calculations as enum indexes, which forces the compiler to evaluate the expressions at compile time. (Any modern compiler would have done that regardless.) The smug cleverness of this thing makes me sick. It could have been written in a clear, sensible way without losing any of the "optimizations". This mess tells a really shitty story about what's going on. This kind of code is straight from the 80's, and we've moved on. Compilers work now. Glad I don't have to deal with this kind of stuff any more.
A couple things to talk about here. First, you can't assign arrays, only initialize them. So, the following is valid code: struct Foo f = { {32, 23, 32, 32} }; To be equivalent to your `char*` example, the structure would have been: struct Foo { int *x; }; But you still get an error on assigning. Why is that illegal? It's worth pointing out that while `"hello"` is shorthand for an array, `f.y = { 'h', 'e', 'l', 'l', 'o', '\0' };` is still illegal. The string notation does some "magic" behind the scenes that array notation doesn't do. Honestly, I don't exactly know why this is illegal. I don't think there's any technical reason it could be allowed, but the language doesn't support that notation. **Edit:** I forgot that C99 allows for compound literals, that makes the syntax legal, you just need to add a cast: f.x = (int[]){32, 23, 32, 32};
You can't assign to an array. (You can initialize an array, and you can assign to specific elements in an array, but you can't assign to an array per se). If the `x` in your case were a pointer instead of an array, you *could* do something like: struct Foo { int const *x; }; struct Foo f; f.x = (int []){ 32, 23, 23, 32 }; Which is sort of analogous to assigning to a `char *` with a string literal.
Case in point, here's the cpu part of [Fogleman's NES emulator](https://github.com/fogleman/nes/blob/master/nes/cpu.go) written in Go. You can get close to that result with C. That code is a joy to read. Zero cleverness, maximum transparency. (And hardly any need for comments.)
A pointer needs to point to something before you can use it. Right now `b` is uninitialized, so when you dereference it, you get a seg fault.
thanks
thanks 
That's not what that does, that would only work if `f` was a `struct **`, and x was a normal int. What you mean is `*(f-&gt;x) = 320`.
Yep, you're totally right. This is precisely why I favor the use of parentheses, because sometimes the order of operations is not always immediately obvious. Edit: the classic example that comes to mind is this: *++p; versus *p++;
Isn't there the potential for alignment problems with this approach? Other nits: pointer arithmetic on void*'s isn't allowed and the cast to int pointer is missing the *.
If it's undefined behavior then GCC is perfectly within their rights to do whatever the hell they want in that case.
&gt; because sometimes the order of operations is not always immediately obvious. Though there's absolutely no ambiguity in what you wrote. There's only one possible way to interpret `(*f)-&gt;x`, even if you don't know the operator precedence.
They are saying the ambiguity is `*f-&gt;x`, and they mistakenly thought it was equivalent to `(*f)-&gt;x`, which only serves to back up the point.
They're required to give a diagnostic for constraint violations, and incrementing a `void *` is a constraint violation. 
Always keep the question in mind when trying to complete an assignment. And since you're new to it, a bit of pseudo code might help. 
Ok , I'll keep it in mind, thanks
You're correct that you have to use a for loop to generate your random numbers. Now you have to store these random numbers you're generating into the array. Lets say I defined an array of integer `int arr[10]`. To store the number `7` in the first entry of the array, its `arr[0] = 7`. Now if I want to store the number `4` into the third entry of the array, I use `arr[2] = 4`. And yes, you have the right idea that you store the random numbers in an array, count the numbers of zeros, then print out how much there are. For counting the numbers of zeros, you can either count them *after* you've generated your random number array, or you can do it *while* you're generating the random number array.
Just a note, you say arr[3] for the third entry, but its arr[2]. Obviously you know this since you 0 index the first time, but it may confuse OP.
Yes, good find. I'll change that now, thanks.
It's because you aren't storing the values in your array, you're just printing them. And your syntax for the final print statement, `printf("There are %d zero's\n",z,cnt);`, is incorrect, since you have two arguments at the end, but you're only expecting 1. Also that second for loop is unnecessary. What you can do instead is store the value generated into arr[i], then print and check the value generated using that array entry, eg. for( i = 0; i &lt; MAX; i++ ) { arr[i] = rand(); // check if randomly generated value is zero if( arr[i] == 0 ) cnt++; printf("%d\n", arr[i]); } printf("There are %d zero's\n",cnt); Also, a couple things to keep in mind: - You don't need to compare the array element with `z`, you can just use 0 - `cnt = cnt+1` is the same thing as `cnt++` and `cnt+=1`
Yes now I can see all the zero, and the funny thing is that I didn't figure that 10 was counted as a zero, thank you and thanks to everybody, I hope to help you in future as you have done with me!
I see what you did there with the 'pointers' in the title ;) And for C Programming I usually use an IDE called CodeBlocks, which (if you choose the correct DL file) downloads gcc along with it, so it works splendidly!
char *basic1; int *basic2; long *basic3; 
It's really not even necessary to use Linux, but it would probably be best. I'm currently using Windows and vim in Powershell and compiling with tcc, although I do have gcc installed. If OP would rather stick with a graphical text editor and compile from within it, there is NppExec for Notepad++ and it's fairly easy to set up.
Another advantage of using a virtual machine for learning C is that you can play around with all sorts of dangerous stuff without messing up your own system.
The readme has a lot of info on the instruction set but if you look at the wiki you'll see the full documented instruction set. I wrote a "compiler" in python so that you can write the code then make "executable" programs I'm calling `chip files`. Any ideas on features or instructions I should add? I'd like to build this into something really cool.
First off, there's much better ways of writing your `utbrytning` function. If nothing else, use `strtok` instead of tokenizing yourself. Or use something from the `scanf` family of functions. But that's not the problem. The real problem here is that your loops stop at 99 ... but what if the user only puts in 5 items? The rest of the array holds garbage values, and your code will include those when calculating the one with the highest frequency! After that, your print statement uses `occurance` and `number` backwards.
I like CodeBlocks (installs mingw). Cygwin will have a more linux-y feel. Or there's a Visual C++ community edition (previously express edition). Or you could install mingw on its own. Or the Visual C++ compiler might come standalone with the Windows SDK (no experience here). The Eclipse CDT [claims to work](http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.cdt.doc.user%2Fconcepts%2Fcdt_c_before_you_begin.htm) with all of the above (cygwin, mingw, or VC++), but I haven't used it myself.
https://xkcd.com/138/
[Image](http://imgs.xkcd.com/comics/pointers.png) **Title:** Pointers **Title-text:** Every computer, at the unreachable memory address 0x-1, stores a secret. I found it, and it is that all humans ar-- SEGMENTATION FAULT. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/138#Explanation) **Stats:** This comic has been referenced 63 times, representing 0.0995% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cr7828o)
On Windows I use [Pelles C IDE](http://www.smorgasbordet.com/pellesc/). It is tiny, free, simple, yet feature packed. IMO it is the best C compiler for Windows, 2nd best debugger, and 2nd best assembler. It also has many examples &amp; tutorials to get your started in C programming (console &amp; Windows).
Thanks for commenting, neato mosquito. Can't stay long, just replying for posterity. 
Nope. A pointer is a pointer. The same pointer can refer to stack vs heap at different points in it's lifetime: int *heap = (int *)malloc(sizeof(int)); int stack; int *pointer; pointer = heap; *pointer = ...; pointer = &amp;stack; *pointer = ...;
^ This. I only use VMs for college stuff and other experiments, since it's not uncommon to install a bunch of stuff you're only going to use for, like, a week (sometimes a few hours). Edit: I normally install Lubuntu, since it has all Ubuntu has to offer, minus the heavy GUI and other programs you never gonna use.
C does not have references, and a pointer is a pointer. Moreover, it's not a matter of stack vs. heap. There aren't only two places where a pointer can point. You could have a pointer to a memory-mapped file, to a shared memory segment, to a static variable in .data or .rodata, to a function in .text, or a pointer to a function in a shared library, which depending on your operating system might actually point to a slot in the PLT or an import descriptor in the import table, or an analogous structure. And so on. 
It is easy, you already wrote it right there. t=12 after this not 12.854 blah blah...
There's an absolute ton of stuff that you could do. You could start by allocating your own memory pool so that you can load values to and from memory addresses, or you could limit the clock speed so that it really behaves like its own machine. You could add call and return operations that push or pop the program position onto the stack, which will let you add functions proper. You could upgrade your compiler so that you can integrate data directly into your program file, as other assemblers can. You could also try simulating hardware interrupts so that your machine isn't running at 100% all the time, implementing some virtual memory-mapped I/O registers to get keyboard input and such, or using ncurses and creating a section of video RAM that you can write to in order to put stuff onto the terminal. You should try looking at the specs and documentation for an old home computer or video game console to get a sense of what you can really do. 
Nice! Can you share a link to the VM tutorial?
As said by the other answers: int x = 3 int y = 2 int z = x / y; /* z = 1 */ To go further, you should also read about undefined behaviours. For instance, you should check if y is equal to 0 or, less obviously, if x is equal to INT_MIN and y to -1. To explain the last one, for 8-bit integers, INT_MIN would be -128 and x/y would be 128 which leads to an integer overflow.
&gt; I want the rounded integer. That's exactly what your example gives you, only the rounding mode used is round-towards-zero, which is also commonly known as truncation. Is that the rounding mode that you wanted, or did you want a different mode, such as round-to-nearest? (Note that there are at least a dozen different rounding modes.) If that's what you want, then you need to do the division as floating point division, then perform the rounding explicitly, e.g. #include &lt;math.h&gt; int result = round((double)4139 / 322); // result equals 13 The `round()` function implements round-to-nearest. If you were only going to display the number, you could also just use `printf()` to do the rounding: #include &lt;stdio.h&gt; printf("%.0f\n", (double)4139 / 322); // prints 13 
The second method is correct. The first assumes that there is no padding between the two members in order to ensure each has the proper memory alignment for the target architecture. Since whether or what padding exists differs between processor architectures the first is at best unportable.
I kind of agree, but what exactly does writing from the command line give you? An ide will give the same errors as from the command line and will structure code better and have some useful features. Of course, I still use a text editor (and have been for c for the past year), but if I could go back in time I probably would have started with code blocks or something
I think you're misunderstanding the meaning of this? I haven't taken a look at it yet but I think it's a VM in the JVM sense rather than in the Dosbox or Qemu sense.
If that's the case... cutting out the lower-level hardware stuff, it's still good to be able to implement and manipulate a comprehensive instruction set, work with a memory pool, and extend the feature set of the compiler. Older hardware is very limited and requires you to implement stuff like multiplication, division, and modulo from scratch, though, so maybe looking into something more modern like ARM assembly would be a better idea if the goal is just to create something like the JVM instead of messing with low-level stuff.
By the way, it's good to avoid redundant casts as they clutter up your code and can cause error messages to be surpressed: int * x = malloc( sizeof(int) ); or to remove the possibility of a type mismatch: int * x = malloc( sizeof *x ); 
Writing the code from the command-line doesn't really matter - Text editors like vim and emacs can structure code for you anyway, and they're command-line based. The point more avoiding letting the IDE perform tasks such as compiling your project, or even less then that, letting your IDE do *everything* to the point that you have no idea how the files are being compiled. Specifically if he's going to be doing embedded, he's going to be working with the compiler a lot - Either throwing it some more complex switches, or having a fairly complex compilation process for his programs. If you avoid letting the IDE create your project for you from the get-go and write your own Makefile's to compile your project, you'll have tons more knowledge of how the compiler, linker, etc. all work together - And when you get to embedded and realize you probably don't have a choice but to write your own Makefile's (Or using some other build system that he's configuring by hand), you'll be much better off of you've already done something similar before.
 void *get_basic_pointer(size_t s) { . void *basic_pointer = malloc(s); if (basic_pointer == NULL) { fprintf(stderr, "UNABLE TO ALLOCATE MEMORY FOR %zu SIZE POINTER\n", s); exit(EXIT_FAILURE); } return basic_pointer; }
You can only call `free` on a value that was returned by `malloc` (and friends). `&amp;d` is not such a value. 
interesting. 
without reading the article, I'd guess proto is a struct variable with lots of function pointer members. The #define _(N) proto.N macro is letting you do _(destroy)(...) or _(move)(...) instead of typing proto.destroy and proto.move.
I guess I'm gonna be the guy who comes out and says "why?". There's been a ton of attempts to force an object oriented paradigm onto C, and you could spend time trying to follow anyone's particular attempt. If what you really wanted to learn was OOP you'd use C++ or Java, but if you're specifically interested in learning how OOP could be implemented on top of C please at least invest your time in learning one of the implementations that are [economically not a waste of time](http://stackoverflow.com/research/developer-survey-2015#work-complang) like objective-c.
thanks! Will the memory leak continue after the program has finished execution?
No. All memory the program uses, leaked or not, is reclaimed by the operating system when the program terminates. This is a feature of the operating system though, not C.
Kind of an interesting FYI: *Some* other languages have what's called a garbage collector, and it automatically reclaims ("collects") any leaked memory ("garbage") to be used again, so you don't have to free it yourself like you do in C.
You can do garbage collection in C if you really want to.
I don't know who's joke was worse, your's or /u/fuzzymcchimp 's &gt;&gt;
To understand that, you should split that typedef apart into two typedefs, since that's what the comma does. So you end up with this: typedef struct cell cell; typedef struct cell *list; If you look closely, you will notice that the * in the second typedef should actually go with the struct cell: typedef struct cell * list; So what is this doing? It's defining the type list to be equivalent to a pointer to a struct cell. You could alternatively do the following to get a similar effect, although technically the types are different: typedef struct cell cell; typedef cell* list; In practice though they are identical. 
You're right. I wanted to point it out as a rule of thumb, but perhaps that asking a bit much. 
Welcome to C! It gets better. Eventually all the little oddities just sort of come together and it all clicks.
Could you please put four blanks in front of every line of code so the code comes out readable? Thank you.
Yeah, IMO because of the grammar rules using commas like this can get needlessly confusing very quickly. That's why for the course I TA'd this semester we make the students do a `typedef Node* NodePtr;` so they don't try to do `Node* a, b;` and then can't figure out why it doesn't work.
Not enough info
I'd do a depth-first search, keeping a pointer to the tail of the (initially empty) list and adding each node onto the tail of the list.
Definitely mine. Fuzzymchimps was acually pretty funny.
... which is exactly why putting the asterisk next to the type is wrong. A declaration of the type Node * a; does not say that **a is a Node**\*. It says that **\*a is a Node**. That is to say, if you apply the dereference operator (\*) to **a** you get a Node, which is exactly what happens. So that declaration should be Node *a, b; meaning that both **\*a** and **b** are Nodes (and therefore **a** must be a pointer to a Node). (I'm sorry, this is a pet peeve of mine).
Yeah, there are systems where this is not true: memory will remain leaked until the device is restarted. 
What if I accidentally enter an address that is not part of my program and vital to my computer's os or something?
very interesting :), excellent summary btw
CS50x on edx aswell.
Sweet, checking it out now, thanks man!
The way to read typedefs is to remove the `typedef` keyword and look at the resulting variable declaration: struct cell cell, *list; Hopefully you can see that this is a variable declaration, declaring the variables `cell` and `list`, where `cell` is a `struct cell` and `list` is a `struct cell *`. What `typedef` does is turn a variable declaration into the declaration of type names, where the variable names become the type names: typedef struct cell cell, *list; declares two type names `cell` and `list`, where `cell` is the same as the type `struct cell` and `list` is the same as `struct cell *`. As another example, recall that you can declare a variable of a struct type at the same time you define the struct: struct foo { int a, b, c; } bar; bar.a = 10; bar.b = 5; `bar` is a `struct foo` variable. `typedef` works here as well: typedef struct foo {int a, b, c; } bar; Now `bar` is another name for the type `struct foo`. structs can also be anonymous: struct {int a, b, c; } bar; and you can declare multiple variables: struct {int a, b, c; } bar, *baz; `typedef` works with these as well, causing `bar` and `baz` to be type names, even though the struct type itself is anonymous and can't be written directly. typedef struct {int a, b, c; } bar, *baz; bar b; b.a = 10; baz ptr = &amp;b;
Adding my own contribution for any other newbies that come by koding.com seems to be an awesome resource; Allows you to code on the cloud without downloading a unix/linux OS and gives you tips to get started!
Correct! 
http://home.netcom.com/~tjensen/ptr/pointers.htm //this page is very clear and easy http://cslibrary.stanford.edu/102/ and the resources in the sidebars. If you learn how to manage pointers, structures, memory management, and if you can figure out how to implement a linked list then I think that is a good start for learning C. The K&amp;R is classic, but I got it a year ago and I mostly use it as a reference. If you can manage to learn from it, it is probably the best way to go. 
If you choose to go with K&amp;R, [Steve Summit's class notes](http://www.eskimo.com/~scs/cclass/cclass.html) are a *really* good companion resource, explaining aspects that the authors leave a bit light.
Don't forget to pass an address into `scanf`: scanf("%d", &amp;z[a][b]); Your compiler should at least be giving you a warning about this.
To get the alignment requirements for an object you use `_Alignof`. This is standard C, and it was added in C11.
That's not a C problem. It sounds like the program is still running when you try to recompile it, and the compiler can't overwrite the executable while it's still in use. Restarting everything probably closes your program along the way.
It's easier and a more natural part of the environment. If you want to use the, for instance, native development environment of visual Studio, you might run into issues in regards to C. 
I think the train of thought (not saying this is correct) is: 1. C is a low level language 2. Linux seems like it gets down to the nitty gritty low level parts 3. Learn C using Linux 
I totally agree, macs have gcc so it works just like linux. Windows supports c perfectly well, too. But linux is awesome
Ill go ahead and give my response on why I did it; I was told to, LOL! just heard it was "easier" like i said, I know shit about programming m8, so I figured hell ill listen until I understand whats going on;
thanks for these man, these are great!
Naw man; I got a very hearty lol out of yours. Also /u/TehJohnny: this post was just asking for it :D
What is the main issue with the question. As in.. What are you having difficulty with. We are not here to give you answers, we're here to help you learn. 
What exactly do you have a problem with? The general structure of the program, or the decryption problem itself? If it's the latter: from what I understand, the general idea of what you have to do is roughly: 1. Find a possible match for the crib (for example, "food" may have been encrypted as "abbc", or "gzzy", you may choose either one). 2. Determine a partial decryption function for the crib - which letters map to which letters (so that you can perform the decryption) 3. Print the decrypted messages. Step 1 is probably the hardest part, try and think about how you can solve this problem. keep in mind that a given letter will always map to the same letter, and if there are multiple possible matches for the crib, you can use any of them. 2. is just a question of comparing the crib with its match, 3. is just a question of applying the decryption information from step 2 to the ciphertext and printing it to stdout.
linux is great, and ubuntu is easy. Its a great place to start!
You don't have braces around your else block, so the exit(0) will always be called after the first element is checked.
Yeah, it's working now. Now with the function, I have this: for (int i=0;i&lt;10;i++) { if(a[i]==i) a[i]=i; else a[i]=0; } But it isn't repostioning the numbers, and it isn't filling the unwritten positions with 0
&gt; repositionate The correct term here is 'sort' the array. What /u/cym13 meant was ask user to input one number at a time, keep a counter as to how many numbers were entered and when you hit 10, stop expecting new input. How you take the input does not affect your sorting function.
That's not the problem anymore. Now I have to write the function that sorts the array as in the picture. for (int i=0;i&lt;10;i++) { if(a[i]==i) a[i]=i; else a[i]=0; } It doesn't work, it doesn't sort the array, and doesn't fill the unwritten elements with 0
It won't sort the array, this code will only work when the input given is the same as the output required. I think you need to rethink your approach, the code you have written is not a sorting algorithm
I'll give you some pseducode. You have two arrays, input[] &amp; output[]. You fill in input via the user. This can be done directly, without any need for sorting : for (i = 0; i &lt; count; i++) if i exists in input[] output[i] = i else output[i] = 0 
Windows supports c perfectly well??? I literally don't even know where to begin with how wrong that comment is...
Have you even tried?
The next time I am at a windows I will open the development tools they have and run some programs. DOS was written in C. 
No, that was one of the issues we had, was that we spend the first 2 weeks of the course "reviewing C basics" then jump right in; Which is why im trying to get a head start now; also, we have to do stuff that sounds really weird to me, like tests involving code on PAPER that we have to debug :D
I prefer and write the second. But I have worked at places where the first was preferred. I find the second easier on the eyes for purposes of indentation.
Because dicking around with MinGW/cygwin and dealing with the myriad of library/cross compatibility issues is the epitome of "supports perfectly" 
&gt;Which one do you use The second one. &gt;why? Make the code more readable, in my opinion. But I use the first one when I write Java so...
odd, it sounds like you should be more than prepared for the course if you spend the summer learning. Code on paper is a way to help you 'reason' about code. For example, if you're just using gcc you may not know why a program runs or crashes, but on paper you have to think it through step by step to see what happens. I do something similar on occasion, although many people aren't fans.
I realize this is the C_Programming thread but... I prefer uncuddled as I find it more readable, but Tcl being my go-to language, it requires cuddled-everything (unless you escape the end of the line... bleh).
NO, I don't develop with C! I haven't written a c program longer than, say 100-150 lines (being generous). However, I've taken a bunch of c courses and I look at c code every day. This thread is in context of someone taking a course in C, not someone who is a full-time C-developer. I mean, I'm curious why you would assume that someone is a C developer in a Forum specified for asking questions about the language. What is the thought process there?
I am a C user. I've been using C every day for almost one year (when I took my first c class).
Can you post the code where you're assembling the IP header and you're sending the packet? Without it, it's hard to tell where things are going wrong. Also, just as a heads-up, I think what you're trying to do is a lot easier achieved with a few iptables rules (in case you're running Linux).
&gt;NO, I don't develop with C! I haven't written a c program longer than, say 100-150 lines (being generous). However, I've taken a bunch of c courses and I look at c code every day. or &gt;I am a C user. I've been using C every day for almost one year (when I took my first c class). which is it... also, what is a "C user"? Everyone "uses" C just by having an operating system installed. That doesn't mean that they support C development well. I clearly meant develop in my context of the word "use" Literally nothing you have been saying makes any sense.
http://lmgtfy.com/?q=c+users+group I'm not a C-developer in the sense that I don't contribute to any open source, projects, and I don't work as a C-developer. If you really want a precise self-evaluation, (you asked for it), I would say I am a c student. 
I was googling for your benefit, you seem to be unaware of how to use it.
Ok, sport.
Now, you are just trolling. I'm not going to bother with this anymore.
I use kernel style which combines the both. Functions are done like this: int main() { ; } while switches, structs, loops, conditionals, etc... are done like this switch (i) { case 1: break; } [I learned about it here,](https://www.kernel.org/doc/Documentation/CodingStyle) and thought it made the most elegant code.
Well yes, but the port number is not involved in routing decisions. In fact, there is not even a port number in the IP header.
Agreed, but a sockaddr represents a socket endpoint, not an IP host. An endpoint with port 0 is not valid, so just be sure that the error is not the result of a validation check. 
That document is horrible - "do it this way. Because: K&amp;R. Inconsistent? Too bad, K&amp;R. BTW - these other things are non-K&amp;R because we said so"
thanks m8; which of those 3 would you recommend starting out with?
Just pick one. Do some research or something.
Regardless: a brace means an indent.
Good luck.
&gt; Which one do you use I follow the standard of the codebase, (sometimes industry,) language and platform I am working on. &gt; and why? Because coding style is about communication. If you want to communicate with the largest number of people, speak in the style that most of the people in that community are going to use. Doing anything else unprofessional amateur hour nonsense. ---- You never need to come up with your own "style", basically ever (unless you have written a new language). If you are working in an existing standardized codebase, follow the standard -- might seem obvious but some idiots mess this simple thing up. If you are in a wildly unstandardized codebase with absolutely no norms or doing greenfield development, pick the most popular and well documented existing standard. Every second you spend [bike-shedding](http://en.wikipedia.org/wiki/Parkinson%27s_law_of_triviality) "style" is completely wasted, of NEGATIVE value -- as you just [introduced another standard](https://imgs.xkcd.com/comics/standards.png), and now you have to document it and maintain that documentation. By following an existing standard you avoid all the trivial pointless nonsense, examples and documentation make more sense and are in "your" style, and you generally get the documentation on the style (style guide) and tooling support for free. I personally hate [GNU style](http://en.wikipedia.org/wiki/GNU_coding_standards) (**a lot**), yet when working in a GNU codebase, I use it, and not via some third party tooling to reformat.. I simply adapt. It takes a few days to really get in the flow, but it makes reading the REST of the GNU style codebase less painful once you acclimate. There are old projects that have styles that are very unique (I am thinking of qmail in specific), and in those 
[Original Source](http://xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 1536 times, representing 2.4108% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_crasv8c)
its pretty awesome. i dont like using ide's, its pretty cool to work with makefiles, terminal and a texteditor like textmate. no distractions and it works for me. i've only worked on projects with 10-20 c files and maybe this doesnt scale so well with bigger projects. 
&gt;Perhaps, but the powers that be decided it so and it is the basis of every single line of code in the Linux kernel. ba·sis ˈbāsəs/ noun the underlying support or foundation for an idea, argument, or process. If the basis for every line in the kernel is to satisfy a couple of guys need to obnoxiously format code, Linux is definitely a more interesting project than I ever imagined.
Beauty may be in the eye of the beholder on that particular point, but there's at least one brace style choice that I'd say with some conviction *should not* be done: leaving them out when they're optional. Don't do that. Really, just type the darn things, it doesn't take that long. You don't want to repeat the goto fail thing.
Plus you have the benefit of using their checking scripts to ensure you're doing it correctly. scripts/checkpatch.pl
VMWare Workstation and VirtualBox are not compilers, but virtual machines that allow you to run operating systems in a window. A compiler is usually a piece of software that translates code you write to code that the operating system you use understands. Or even code that the CPU understands. Now, for Windows you might go with Visual Studio C++, however there are some very useful free software alternatives available as well, such as Netbeans and CodeBlocks, the latter allowing you to use any compiler you wish. It also allows you to use MinGW with the GCC compiler (which is by far the most popular on Unix-like systems, closely followed by Clang).
Woah thanks
A little.
That's weird. If anything you could use Linux. But if you're using osx, then xcode could help you out. 
Arrays don't work as loosely in c as it does in python. I would recommend using a linked list of coordinate structs. 
That is correct if you're talking about a TCP or UDP socket. Since this is a raw IP socket, the `rip_output()` function (which doesn't care what's going on in the layers above IP) will handle the data before passing it on. If the `IP_HDRINCL` option is set - which is the default on Linux - the `rip_output()` function will expect the IP header in the first 20+ bytes of the payload and the `sin_addr` member is only used to determine the output interface (`sin_port` member is never consulted, see below). OP also mentioned that his `sendto()` call returned -1 with errno EAFNOSUPPORT, which usually means there is something wrong with the IP header that was passed. An invalid value in `sin_port` with a TCP/UDP socket would have resulted in errno being set to EINVAL. **For those who like details:** The data takes the following path: `sendto() -&gt; sendit() -&gt; sosend() -&gt; rip_usrreq() -&gt; rip_output() -&gt; ip_output() -&gt; L2`. The first three calls are protocol-agnostic and deal with stuff at the socket layer, including copying of data from the userspace to the kernel, and all the IP related stuff happens in the following three calls. The `L2` part depends on the interface, it would be `looutput()` for loopback devices, `ether_output()` for ethernet, etc. and may call further functions. The following are the relevant parts of the `rip_usrreq()` and `rip_output()` functions. int rip_usrreq(struct socket *so, int req, struct mbuf *m, struct mbuf *nam, struct mbuf *control) { struct inpcb *inp = sotoinpcb(so); /* ... */ switch(req) { /* ... */ case PRU_SEND: { u_long dst; if(so-&gt;so_state &amp; SS_ISCONNECTED) { /* ... */ dst = inp-&gt;inp_faddr.s_addr; } else { /* ... */ dst = mtod(nam, struct sockaddr_in*)-&gt;sin_addr.s_addr; } error = rip_output(m, so, dst); m = NULL; break; } /* ... */ } /* ... */ return(error); } int rip_output(struct mbuf *m, struct socket *so, u_long dst) { /* ... */ if((inp-&gt;inp_flags &amp; IP_HDRINCL) == 0) { M_PREPEND(m, sizeof(struct ip), M_WAIT); ip = mtod(m, struct ip*); /* ... */ ip-&gt;ip_src = inp-&gt;inp_laddr; ip-&gt;ip_dst.s_addr = dst; /* ... */ } else { ip = mtod(m, struct ip*); if(ip-&gt;ip_id == 0) ip-&gt;ip_id = htons(ip_id++); opts = NULL; flags |= IP_RAWOUTPUT; ipstat.ips_rawout++; } return(ip_output(m, opts, &amp;inp-&gt;inp_route, flags, inp-&gt;inp_moptions)); } The `ip_output()` function fills out the remaining fields in the IP header (again, depending on the socket options), looks up a route from the routing table (including caching and verification of routes), deals with multicast and broadcast, checks if the packet can be sent on the selected interface, and takes care of fragmentation. I have omitted this function because the code is not really relevant to prove my point. So the bottom line is: if you create a socket with `socket(AF_INET, SOCK_RAW, IPPROTO_RAW)`, the `sin_port` member will be ignored (and the `sin_addr` member will be ignored if you used `connect()` on the socket). The source is from 4.4BSD-Lite, so it may not be exactly the same as in the Linux kernel, but the Socket API and the concepts are the same. Source: TCP/IP Illustrated Volume 2, Wright/Stevens, Pearson Education
strtok() uses hidden state, either a global variable or a local static variable. A function written in this style is called non-reentrant, and that is a very bad thing (usually) because it can't be used easily in multithreaded code. Some C libraries include a strtok_r() function which is reentrant (and thus has no hidden state). getline() is a slightly different kettle of fish. The function itself doesn't have hidden state (probably), but the file descriptor (if you're on an operating system that uses file descriptors) just gets advanced when you read more data. Reading in from a file sequentially and keeping track of what offset you're in into the file is generally regarded at the operating system's job, and so any code implementing getline() sort of functionality won't need any hidden state. (It's also worth keeping in mind that some file descriptors may not be pointing to files at all, and may be infinite in length, and so it wouldn't be possible in general to keep an offset as state)
getline() saves its position because it uses files. Everything that uses files saves position using the builtin seek functionality of files. This isn't something that C provides, it's something that the operating system does natively. Think of files as a cassette tape. Reading or writing to the file causes the tape to move, but it doesn't reset until you manually rewind it. strtok() is special and weird. It uses a static variable buried deep in the standard library. strtok() is evil. Bonus answer: That's a bit of a tough one. The easiest way to build the chunk would be to use strcat() and a malloc'd char array and build the chunk in that, but it isn't as elegant as using the file offset. I did a quick bit of googling, and getting the file offset actually seems to be rather difficult. ~~lseek() apparently can be used to get the offset by lseeking 0 and returning the current offset ([this link](http://cboard.cprogramming.com/linux-programming/103533-file-descriptor-file-position.html))~~ or just use ftell() like a normal person. If you do take this approach, be careful, since readline() leaves the file positon at the end of what it read, where the next call to readline() will begin. EDIT: The byte amount is not useless. getline() does some weird stuff with malloc() behind the scenes, and it needs to "remember" how big of a buffer is malloc'd or else things will explode. It uses the byte amount pointer to keep track of how big an area is malloc'd. You can also use this if you would like to reuse the buffer yourself for some purpose, since you would have no other way of knowing how big the buffer is. Don't forget to free() the buffer after you finish a getline() session, too.
On Windows, use Visual Studio, the C compiler provided by Microsoft. It has it's quirks and is slightly out of date but it's your platforms native compiler.
thanks! man, C really is voodoo (at least to me).
&gt; This is also the reason why you can't read more than 2^64 bytes over a pipe on Linux. I had no idea!!
Very informative and precise, thanks!
**EDIT**: If this is intended to store arbitrary items (via `void*`), `objects` should be a `void**`. *Casting `void*` to `unsigned int` is dangerous, because there are platforms in which `[unsigned] int` is smaller than a pointer.* Is this C or C++? The DynamicArray constructor should be changed to an "init" function: void DynamicArrayInit(DynamicArray *a) { a-&gt;bufferSize = 8; a-&gt;length = 0; a-&gt;objects = malloc(buffersize * sizeof(*a-&gt;objects)); /* You should malloc based on the size of a variable, not a type, so that you only need to change the type in one place. */ } This needs a `typedef` to work in C (unlike in C++): typedef struct { /* variables... */ } DynamicArray; Finally, the `bufferSize` and `length` variables (**EDIT**: and also the `index` parameter of `DynamicArraySpliceOne`) should be `size_t`, not `unsigned int` (`#include &lt;stddef.h&gt;` if necessary).
I see; Also, earlier on, the portion involving: int convertToSecond (struct time amount) { int t = amount.second; t += (amount.minute *60); t += (amount.hour *60 *60); return t; } Is that portion correct? edit: Hm, I assume the scanf() should be right above each printf("%d%d%d", &amp;a.hour, &amp;a.minute, &amp;a.second); statements?
You're almost done with the class and you still don't get that statements go in an order? Srsly?
Your convertToSecond() function looks correct. Your convertToTime() function doesn't. Here's what you have right now: second = amount %60; amount -= second; minute = amount %60 / 60; amount -= minute %60; hour = amount %3600; Do you know what the relative precedence of the division and modulus operators are? Try this instead: second = amount %60; amount -= second; minute = (amount/60) %60; amount -= minute %60; hour = ((amount/60)/60) % 60; Because of integer division, the subtraction lines are unnecessary, so you can also write it like this: second = amount %60; minute = (amount/60) %60; hour = ((amount/60)/60) % 60; As for the scanf statements, no. Two of the lines that I quoted should be **replaced** with calls to scanf instead of printf. The arguments will stay the same.
Nah don't do that. Xcode is nice and all, but that's not the way to go for learning c programming on a windows computer. Just download the free version of microsoft's visual studio, you can learn c programming in that just fine.
Whatever this is, it's not C.
Alright, I replaced the print with scan and now I can input. However, I am now in another situation, where I am trying to figure how to print out all three times. I did a test run, ran fine from your suggestions, and used: 24, 24, and 24. with the second time being: 23, 23, 23. All I get is: 0:0:1 No wait, nevermind I got it. Thank you very much
If you wanna feel cool (and potentially very fast), deal with the steepish learning curve of the text editor Vim. It'll take probably a week or three to become as proficient as your current non-Vim editor, but beyond that point, you'll be much more productive and better off. If you're interested, check out the /r/vim subreddit
Keep track of how many numbers are in the string in your while loop. If p falls between 48 and 57 inclusive, it is a number, else it is something else. [Reference the ASCII chart](http://www.asciitable.com/index/asciifull.gif)
I've been using vim + TCC under Win 8.1 for a while now and they've given me no trouble whatsoever.
What you're looking for is a jagged 2D array that's resizable in both? dimensions? It's hard to tell from the mess of data above. What I don't see if any info on how you plan to *access* the items once they're in the array: a linked list of linked lists is an obvious choice. You could also use a hash of linked lists... dynamic resizing is not a trivial matter (but can be done), so I suggest you think about the bounds of your problem: what does it actually need to do? Think in terms of access patterns. Are you reading+writing arbitrary elements individually? Are they unique? Is order important? Think less in terms of "well I could do all this stuff in Python" and more in terms of the actual structure of the problem and you'll be rewarded. Fun fact: Python is written in C.
The second style makes matching of braces much much easier because the symmetry is obvious on visual inspection. It's less of a problem with a good editor, but man... in reality though you'll be conforming to the codebase you're in. The worst possible thing is to mix styles.
You can use MinGW or Cygwin. Add compiler to the system path. If you are using an IDE, configure compiler with it.
Your declaration `const char *ret` declared a *pointer to const char.* The pointer itself is not constant, the value pointed to is. To get a const pointer to char, write char *const ret
The C language has been carefully constructed so that one pass over the source code is sufficient to parse C code. This especially means that the source code cannot reference tthings it doesn't know about. Except for function calls (where the compiler basically guesses), you are not allowed to reference things that haven't been declared yet. Contrary to your statement, lifting this requirement is complicated as some syntax can only be parsed when the type of an identifier is known. For instance, consider this statement: foo = (*bar)(baz); Depending on the what `bar` is, this could be... * When `bar` is a variable, a call to the function pointed to by `bar` with argument `baz`, the result is assigned to `foo`. * When `bar` is a type, a cast of `baz` to type `*bar`. In your case, things get even more complicated due to scoping rules. If the compiler sees `Node` inside the `struct` declaration, it doesn't know if `Node` is a reference to a type declared inside the `struct` or a reference to a global type. This is something very hard to resolve. The extra effort required to support using undeclared identifiers is in general too complex for this little bit of convenience.
Yeah, I kinda misunderstood what you wrote. Carry on.
Thanks. Well it's not impossible, but it would increase compilation time and introduce a lot of bugs in the compiler at first :P
Thanks very much!
Hey, thanks very much for the suggestions, that's a lot of help! I'll look into both the subredit and the book =)
No problem, glad it's working now. I guess frustration will always be part of learning C ;) Out of curiosity, what tools (editor/ide etc.) do you use? Because this is a textbook problem where debuggers come in very handy.
Visual Studio is free for everyone, not just students.
Get yourself a compiler, compile the code and fiddle around until it works. You're not providing nearly enough information for me to help you any further though.
read it backwards: `char const *ret;` ret is a pointer to a const char `const char *ret;` same thing (putting const before char is an exception to the rule) `char * const ret;` ret is a const pointer to char `char const * const ret;` ret is a const pointer to const char
What do you mean it doesn't work, does it throw an error, or does it not compile? Where in the code are you calling free, is it one particular call to free, or a part that gets called over and over?
Quick and dirty: Read the signature file (Using fread(), making sure when you call fopen() to use the 'b' flag so it works on Windows) into one uint8_t array. Load the other file into another array the same way. Now, standard C is interesting in that while the function for searching a string for a character (strchr()) has a duplicate for searching raw bytes (memchr()), there's no such equivalent for strstr(). If you're on a linux or BSD OS, you can use memmem(). If you don't have that option, you have to do the search yourself. Which is probably the point of the exercise... memchr() and memcmp() will be very useful. Find the first byte in the search array that's the same as the first byte in the signature, use memcmp() from there to see if there's a match, repeat as needed. EDIT: A more advanced version might bypass stdio completely and use mmap(), and possibly a fancy search algorithm like BMH or KMP.
does it compile for you, I can't get it to compile for me. What compiler are you using? are the files saved as MyData.h or myData.h?
Do you have access to a mac or Linux os? 
Make sure to only allow an input to be so big, so you can avoid buffer overflow attacks. 
in your main function you are including them as myData.h that could be the source of some problem
Also getting 5 warnings and 2 errors on compilation with gcc. The errors are here if you want to look at them: https://gist.github.com/d7dede876ded3a60dd7a Visual Studio must be giving some warnings at least. I think it showed build messages in a box at the bottom of the screen. Can you try to find it and see what it says?
This is really nice.
Just like const integers, const pointers can be assigned to when they're declared. It makes sense for the same reason: `const int foo` wouldn't be much use if you could never assign it a value. The assumption is that when you declare the variable, whether an integer or a pointer, you know what value it should have.
Got excited for a moment until I saw it doesn't work in Windows :)
cool that fixed it, how did I not notice !!
They're functionally equivalent. Depending on how clever the compiler is, there might be a speed difference but it could swing either way. The largest difference is in what the function signature suggests: that #2 might change the contents of the points. Add a const and you're golden. E: fwiw, you can probably tickle your compiler to output assembly code, that'll show you exactly how different the resulting programs are.
is it better style to use the pass by reference function, then?
&gt;However, there's an even more fundamental problem with what you're trying to do. You simply can't write portable code with vector instructions without also writing a bunch of code to check whether the system you're running on supports vector instructions. Do you mean that ABI compatibility is hard to uphold if you don't specifically compile it on every target machine? That makes sense when I think about it.
I have to admit, I've never used gdb and this made me want to look at it.
GDB brings back bad memories with Bomb Lab. But if anyone wants to learn GDB, I think you can find some bombs lying around. 
Note that we couldn't really find the issue for you with info you provided. Ideally, you'd provide the simplest possible example that compiles and shows the problem. The (un)surprising side-effect is that it's likely you'll solve the issue while creating that example.
It's not an ABI issue; it's an instruction set issue. Except in very specific circumstances, you don't know the hardware your code will be running on. When you turn on `-msse2`, for example, you're giving GCC the goahead to optimize using the SSE2 vector instruction set; you can also use builtins to do manual vector computations. SSE2 was introduced in 2001 and quickly became ubiquitous, so there's probably no issue with that. However, if you instead use `-mavx` or the AVX builtins, your code might build and run on your Xeon dev machine but then crash with an illegal opcode exception on the i3 it's used on. And that's not even considering deploying from an Intel to an AMD or vice versa. Bottom line, do your research and be careful.
I vote for "Love it". But the reality is that it isn't used a lot anymore. I haven't used it at all over the last decade of so. But knowing asm can help you when debugging.
It generates code for the architecture *the compiler* is running on; do you never plan to deploy on or move to any other machines? And if not, why are you worried about portability?
Somewhere in between love and hate. If you can do something in plain C, you almost always should. It's portable, it's easier to understand and debug... it's just better. But there are times when you don't have a choice; you *must* do some things with assembly. I see a lot of this compared to most programmers since I work on embedded systems. In order to do some things on the hardware, I have to use assembly instructions that have no way to do them in plain C. For example, a lot of hardware twiddling requires me to do a `CSYNC` or `SSYNC` to synchronize all writes to the core or the system. DMA requires me to flush or invalidate cache so that the correct data can be read/written from RAM. And so on. There are 3 ways I could do this: * I could use compiler extensions. The compiler for this processor includes extensions like `ssync()`, `flush(void* address)`, etc. This is good because the compiler understands what you're doing, so it can be smart about it; if it sees something that triggers a bug in the processor, it will adjust the output code to compensate (which usually just means adding no-op instructions). * Use inline assembly. This is our preferred option. GCC has support for this processor, and there's an entire toolchain for using it, but the primitives that the proprietary compiler supports aren't present. Inline assembly, however, works the same. * Use out of line assembly... in other words, create a separate .asm file and put assembly in there. That means it has to be a separate function that you call, which is needless overhead for some things (such as a single `CSYNC` instruction). It's also less flexible, since you can't take advantage of the power of the `asm` statement to write code for you. In plain assembly, you have to choose for yourself what registers hold what values. Using inline assembly, you can say "Pick something that I'll call register %0, and make sure that the value of `foo` gets put there". It's much simpler than having to write your own code for function entry and exit (setting up/tearing down stack frames, saving registers, etc.). So given those options, I prefer the middle ground. That said, compiler intrinsics are pretty nice, and there are strong arguments in favor of using them. Out of line assembly, on the other hand, should be reserved for times when it's really the best or only way (such as writing code that manipulates the stack, such as interrupt handlers or context switches).
They will behave very differently - the second function is using the pt2 parameter for both points. ;)
Yes. For best performance, pass a constant pointer. Just change the first line of the function definition to this: struct rect makerect_byref(const struct point *pt1, const struct point *pt2){
You'll love this then. https://github.com/longld/peda
You read 6 bytes for the status message, but it's usually only 5 bytes long (You're also not checking to see if it's +OK). Do you think it could be filling in that last byte with the first one of the file size?
How do you know the server is responding to your request correctly? Are you stepping through the code to be sure the part you identified is really the trouble spot?
What do you mean by this comment: "//Because we receive a 32-bit unsigned integer, it is at most 10 chars (2^32-1)"?
Should this line "tempBuf[strlen(tempBuf)-1] = 0; //Remove \n" be adding a '/0' null terminator instead of a 0? never tried replacing a '/0' with a 0, so im not sure if that works like expected or not. *from looking around, this appears to be ok, but I would question whether this is good practice.
'\0' and 0 end up being the same. I like to use the character literal when working with chars as a style thing, but it's not required.
&gt;How do you know the server is responding to your request correctly? I know because the server prints on screen the size of the requested file in host byte order before converting and sending it. Also, the specifications say to test our client (and then our server) with the provided server (client): the both provided client and server were tested to see if they properly work (running the client against the server) and they do. &gt;Are you stepping through the code to be sure the part you identified is really the trouble spot? I debugged the program and went throught the function calls: Recv(sockFD, (void *)&amp;dummy, sizeof(uint32_t), 0); No matter what, it saves into `dummy` a wrong number. I was able to follow the calls up until `recv(..)` was called, but then the debugger doesn't allow me to step inside the function (anyway I assume `recv` is working properly since it's part of the socket API ).
I don't think so because debugging shows that `dummy` is storing 0 up until the call to `Recv` is performed.
What textbook/resources are you using in the course? I'm interested in learning more about network programming in C
Right now, to simplify the process (and to make sure it compiles in GCC) I've made this. The issue is that when a node has two children, it goes to the that node's left child and then find's that left node's furtherest right ancestor, it then replaces the value of the original node with that ancestor's value, but never ends up deleting that ancestor or freeing it's memory. the code looks like this (it compiles on gcc and is a lot easier to look at) My code: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //Structures typedef struct Node{ void *dataPtr; struct Node *left; struct Node *right; }node; typedef struct Product { int ProductCode; char ProductName[30]; int QuantityOnHand; double ProductCost; double ProductRetail; char ProductLocationCode[7]; }product; //functions int compareID(void *ptr1, void *ptr2) { int temp; if (((product *)ptr1)-&gt;ProductCode &gt; ((product *)ptr2)-&gt;ProductCode) temp = 1; else if (((product *)ptr1)-&gt;ProductCode &lt; ((product *)ptr2)-&gt;ProductCode) temp = -1; else temp = 0; return temp; } void insert(node ** root, node** val, int(*f)(void*,void*)){ if (!(*root)) { //initalize a temporary node node *temp = NULL; temp = (node *)malloc(sizeof(node)); //make both right and left nodes for temp to be NULL temp-&gt;left = NULL; temp-&gt;right = NULL; temp-&gt;dataPtr = (*val)-&gt;dataPtr;//store value you were looking for in temp *root = temp;// root is now the temporary node return;//end of function. } int result = f((*root)-&gt;dataPtr, (*val)-&gt;dataPtr); if (result == 1) {//if the value is less than the current root node, go to the left connecting node insert(&amp;(*root)-&gt;left, &amp;(*val), f); } else if (result == -1) {//if the value is more than the current root node, go to the right connecting node insert(&amp;(*root)-&gt;right, &amp;(*val), f); } } struct Node* deleteNode(struct Node *root, void *ptr, int(*cptr)(void*, void*)) { struct Node *temp; if (cptr(ptr, root-&gt;dataPtr) == 0) { if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)//no children { free(root); return NULL; } if (root-&gt;left != NULL &amp;&amp; root-&gt;right == NULL)//left child { temp = root-&gt;left; free(root); return temp; } if (root-&gt;left == NULL &amp;&amp; root-&gt;right != NULL)//right child { temp = root-&gt;right; free(root); return temp; } else //two children { struct Node* pred = root-&gt;left;//go left one of the node you're trying to delete while (pred-&gt;right != NULL){//now get further right ancestor of that node pred = pred-&gt;right; } root-&gt;dataPtr = pred-&gt;dataPtr; //make the original node the value of that right ancestor return pred;//return that ancestor to delete it } } else { int val = cptr(ptr, root-&gt;dataPtr); if (val &lt; 0) { root-&gt;left = deleteNode(root-&gt;left, ptr, cptr); return root; } else { root-&gt;right = deleteNode(root-&gt;right, ptr, cptr); return root; } } } void readData(struct Node** vptr, FILE *fp){ product* ptr = (product *)malloc(sizeof(product)); if (fp == stdin){ printf("Enter Product Code: "); fscanf(fp, "%d", &amp;(ptr-&gt;ProductCode)); fflush(stdin); printf("Enter Name: "); fscanf(fp, "%30[^\n]", ptr-&gt;ProductName); fflush(stdin); printf("Enter Quantity: "); fscanf(fp, "%d", &amp;(ptr-&gt;QuantityOnHand)); printf("Enter Cost: "); fscanf(fp, "%lf", &amp;(ptr-&gt;ProductCost)); fflush(stdin); ptr-&gt;ProductRetail = (ptr-&gt;ProductCost / 0.7); printf("Enter Location: "); fscanf(fp, "%6[^\n]", &amp;(ptr-&gt;ProductLocationCode)); fflush(stdin); } else{ fscanf(fp, "%d %29[^\n] %d %lf %6[^\n]", &amp;(ptr-&gt;ProductCode), ptr-&gt;ProductName, &amp;ptr-&gt;QuantityOnHand, &amp;ptr-&gt;ProductCost, &amp;ptr-&gt;ProductLocationCode); ptr-&gt;ProductRetail = (ptr-&gt;ProductCost / 0.7); } (*vptr)-&gt;dataPtr = ptr; } int main() { int i = 0; struct Node *newNode, *temp; struct Node *root = NULL; int(*compPtr)(void *, void *) = compareID; for(i; i &lt; 3; i++){ newNode = (struct Node *)malloc(sizeof(struct Node)); newNode-&gt;left = newNode-&gt;right = NULL;// missing this operation. readData(&amp;newNode, stdin); // this function call was missing. insert(&amp;root, &amp;newNode, compPtr); } temp = (struct Node *)malloc(sizeof(struct Node)); temp-&gt;dataPtr = malloc(sizeof(struct Product)); printf("enter the product ID to delete : "); fflush(stdin); scanf("%d", &amp;((struct Product *)temp-&gt;dataPtr)-&gt;ProductCode); deleteNode(root, temp-&gt;dataPtr, compPtr); free(temp-&gt;dataPtr); free(temp); return 0; } Why is this ancestor node not being freed from memory? What should I change in order to make sure it is deleted?
Unix Network Programming Vol 1 by Stevens is pretty much the Bible on the subject. It's somewhat dated, but you'll learn things in that book you won't find anywhere else. I recommend getting the second edition used off Amazon. It was ridiculously cheap the last time I picked up a copy.
Its amazing and super useful! For a lot of things it is not possible to use a high-level language like C at all, and asm is required. Inline assembly allows you to keep the clarity of C with the power of assembly.
call me old fashioned
No thank you. Unless you provide a simple link to a website and the code is ompletely blob free, I won't even think of it. Something as important as low-level development does require a certain degree of security, even inside a network. Besides, you're talking about C++ and C#, neither of which are C.
No advertisement please. Also, this is not about C.
That depends. What is your ratio of insertions and deletions to lookups? What does your data look like?
This subreddit is for programming in C only. Please keep this in mind when asking the next question and if you can, edit out the C++ parts.
`status`should be fine because if you look at its definition is: char status[STATUS_MSG_SIZE+1] = {0}; And `STATUS_MSG_SIZE` is 6. Also when I fill it through `Recv`: Recv(sockFD, status, STATUS_MSG_SIZE, 0); //Get the status STATUS_MSG_SIZE is passed as how many bytes to read, so I see no way in which status could have another character different from \0 as terminating character. Also the status is printed after the `Recv`so I can check what's being printed. &gt;The server sends 9 bytes: '+OK\r\nABCD' The server can't do that. Each sequence of bytes (status message, file size, bytes composing the file) are sent through separate `Send`calls from the server, so I know that if I'm receiving a status message it will be at most 6 chars.
Right, what I said.
Sorry, my bad. The documentation on my system was wrong. I just double checked with the standard, and it says the the length modifier `l` has no effect on the `f` formatting directive.
No, that's not what you said. You set “free() is not obligated to...,” which implies that it could do that. `free()` is a function, it can't modify its arguments, it cannot set the pointer to `NULL`.
I'll give you a hint. You should be looking at the return value from fread. Also, you should create a file of only a byte or two and step through your code in a debugger. 
The purpose of the small file is so you can step through your code in the debugger and see what happens when you get to the end. 
&gt; I'll give you a hint. You should be looking at the return value from fread. Try using "man fread" in a shell. 
First off, this kind of image resizing is often problematic and can result in some interesting image artifacts, but if you just need a simple algorithm... Well, we know you'll need nested loops with bounds that are the dimension of the resulting matrix: int data[8][4]; for ( int i = 0; i &lt; 8/2; i++ ) for ( int j = 0; j &lt; 4/2; j++ ) ; // Do the averaging. Now, to do the averaging, you'll need another pair of nested loops. The bounds on these get more interesting: for ( int k = i * 2; k &lt; (i + 1) * 2; k++ ) for ( int l = j * 2; l &lt; (j + 1) * 2; l++ ) sum += data[k][l]; result[i][j] = sum / (2 * 2);
Thanks for all the responses everyone. Ya hate was too strong of a word! It's cool to hear some more practical applications and how others have worked with it. I feel once I develop my programming knowledge more I'm going to look back on this class and realize why it was important to learn. I'm going dive into it and really try to get something out of it. Thanks again.
Put 4 spaces before each line of your code and reddit will format it properly.
Thanks for code, but I need loop for unspecific factor. Gonna try to modify it.
Thanks, that did work :) for (i = 0; i &lt; newWidth; i++) { for (j = 0; j &lt; newHeight; j++) { for (k = i * resize; k &lt; (i + 1) * resize; k++ ) { for (l = j * resize; l &lt; (j + 1) * resize; l++ ) { sum += tab[k][l]; } } newTab[i][j] = sum / (resize * resize); sum = 0; } }
A splay tree has no balancing requirements. Instead, the tree is rearranged so the element accessed last ends up on top on each access. If you frequently access similar elements, the tree adapts to your access pattern. On the other hand, each access modifies the tree so it's a bit slower to access a splay tree under optimal conditions.
I believe that `ebp + 2` isn't memory which your program "owns", because it never requested it. So when you try to access it to print it out, the memory manager can say essentially "access refused" and segfault, but it's not required to do this. I could be wrong though - I don't know any assembly so I don't know what you're doing in that line. I assume you're filling `ebp` with a pointer to memory that your program owns, though. If you're not filling it with that, then any attempt to access the memory in `ebp` with or without adding 2 will be using an initialised variable, and the computer is allowed to segfault on that.
Depends on lookup patterns in your data. Edit: If you just care about insert and delete speed, though, that's not an unreasonable order (note that most documentation on splay trees includes splaying a new node to the root; I don't think that's strictly necessary but doing so might change things).
You should also look at skip lists.
I had not heard of it yet, thanks for the tip.
Being fluent at assembly code is mandatory for being a good programmer. Certain problems can only be solved with assembly language, and debugging can only be done in assembly language. So yes, it is something you should *buy into* eventually, but probably not when you're first learning programming. However, due note that I learned C and ASM at the same time many years ago as my first languages, so it is certainly doable. I didn't find it difficult at all really, but it's not like I can erase my memory, learn Java/JavaScript, and compare which was more difficult.
Behold, a great snippet on C and const behavior: http://en.wikipedia.org/wiki/Const_(computer_programming)#C_convention
Your right about the inline assembly, that's the only way that I've found to get ebp, which should allow access to that memory right?
Also, to more directly answer the title question: different compilers and different operating systems / kernels handle memory management differently, and memory can depend on the state of the computer at runtime. So maybe you got lucky on your Mac, but maybe if you reboot it, you might get a segfault when you turn it on again - the fact that it segfaults on any computer is generally indicative that there's memory corruption somewhere. In general, it's a *good* thing if the segfault happens, because it tells you that something went wrong.
You should check out [cppcheck](https://en.wikipedia.org/wiki/Cppcheck), I may not be the best for everything but I don't know of any better general-purpose static code analysis that is open-source (GPL).
Thanks! I'll have a look.
You're right. What i'm trying to do is display the last arguments passed into a recursive function. I was going off this stack overflow answer: http://stackoverflow.com/questions/26967446/print-the-function-arguments-in-recursive-function
[Coverity](http://www.coverity.com/).
Yeah, C really doesn't want you to do that - C is sometimes called "portable assembler", because it abstracts the different assembly languages, while still being very close to the machine terms of how computers work. Using inline assembler makes your program only work on that very specific assembler language, and playing with the stack trace and whatnot assumes a very specific memory layout - it's not surprising that Mac OS X and Linux are handling things differently. Your Mac box is probably 64-bit too, and while the -m32 option should help a bit, it probably doesn't do the whole job of making 64-bit instructions and layout identical to 32-bit. If you want a recursive function to know what arguments the original one was called with, I'd just pass them as additional parameters at the start, and keep passing them down the chain. If you want to keep a record of every set of parameters, write them out into an array somewhere. You're essentially trying to read them from the stack trace like an emulated array here, so I'd just make my life simpler and save them in a format of my own choosing.
&gt;That's not how socket streams work. Datagrams, yes, but streams appear as a single stream of bytes to the client that is read from as much as requested no matter if the server writes a byte at a time or a megabyte. Didn't know that, noted! Thanks!
Dunno about Windows, but it's likely available as a package in most linux distributions. clang-analyzer in arch.
&gt; apparently const pointers have to be assigned a value when they are declared Assignment and initialization are different things, even if they both use the `=` sign. The distinction matters more in C++ than C, but C programmers should still be aware of it. `char * const ret3 = &amp;b;` is initialization, _not_ assignment.
The value of your pointer doesn't change. It still points to the address of g. Only the contents of g are changed in your code. 
 char g = 'u'; char t = 'q'; char const *ptrToConst = &amp;g; char * const constPtr = &amp;g; ptrToConst = &amp;t; Then how come this works?
You're changing `g`, which is of type `char`. This is perfectly legal. When you point a pointer-to-constant at a variable, the variable doesn't magically gain `const` semantics; you just get a constant view to the variable. Try changing the value through `ptrToConst`; you'll find you can't, which is exactly as you would expect.
The pointers are declared differently and so mean different things. See the top answer from [this question on stackoverflow](http://stackoverflow.com/questions/10091825/constant-pointer-vs-pointer-on-a-constant-value).
`ptrToConst` is a pointer to a constant value; you cannot change the value through the pointer. But you can change the address that the pointer points to! If you want an immutable pointer to an immutable value, try `char const *const ptrToConst`.
I don't really know what you mean with "make it work the way we want it to". Please explain what you want to achieve. `char const *ptrToConst = &amp;g` means that you are declaring a "read-only" pointer: you cannot change the pointed-to variable through the pointer. This will error: `*ptrToConst = 'A';`. But you *can* point the pointer to a different address, because you never said that the pointer *itself* is immutable!
A pointer only stores the address (or in other terms: a pointer always points to a memory location). Trying to assign 'a' to a 'char *' doesn't work because 'a' does not reside in memory. When you first do char *ptrToConst = &amp;g; You're assigning the memory location of variable 'g' to 'ptrToConst'. This means that the line *ptrToConst = 'a'; Is the same as assigning 'a' to variable 'g'. Try printing 'g' after assigning 'a' to '*ptrToConst' and you'll see it'll print 'a', too.
thanks I've figured it out now :)
Is there a reason I'm missing why you can't use the debugger? You could just set a breakpoint in the recursive function and inspect the values of the last call directly. If for some reason you wanted to take this scenic route of reverse engineering the stack you can do that very well in the debugger too. It'll show you the value of any register or display any range of the stack you're interested in. All you have to do is ask it. If you can't use a debugger the task just got a lot more interesting and we want to hear all the dirty details of this register sniffing code you're deploying on a linux server ;)
Oh, it's not used to protect `g`, it's used to protect `g` from changes via `ptrToConst`. It would protect you from `*ptrToConst = 'r';` so that you can pass ptrToConst to a function and be reasonably able to expect that `g` won't change, but that's it. And of course the function might cast the pointer to `(char *)` (or have a memory related bug..).
Although not a static code analyzer but I quite like [flawfinder](http://www.dwheeler.com/flawfinder/) because it is quite simple to run.
Same problem. What you need is something like this: struct rect_pointers makerect_pointers( struct point *pt1, struct point *pt2){ struct rect_pointers temp; temp.pt1 = pt1; temp.pt2 = pt2; return temp; } and then call it like this: struct rect_pointers abc = makerect_pointers(&amp;point1, &amp;point2);
I know i'm late to the game, but it may help to read the variable declaration backwards: A pointer to a const character. As someone mentioned, to make it immutable: char const * const: A const pointer to a const char.
`'a'` is a character literal. Character literals have type `int`. Assuming you're using an implementation that uses ASCII (which it is safe to assume that you are), `'a'` is the same as the integer literal 97. Anywhere that you wrote `'a'` in your program, it's as if you'd written `97`. char *ptr = (char *)97; This is a request to convert the integer 97 into a pointer to char. The standard says that whether this is possible or not is implementation defined. On the common implementations you're likely to encounter today, this is defined(*). So you've created a pointer to char that points to address 97. But how do you know there's anything valid at address 97? You don't, and on most operating systems, the lowest page in memory is explicitly unmapped to catch segfaults, so it's virtually guaranteed that this will segfault. Even if it didn't, it would be nonsense. You can't form a pointer to a random address like that. I think what you were probably going for was `char *ptr = &amp;'a';` but this is explicitly illegal and would have failed to compile. You can't take the address of a character literal (or an integer literal), you can only take the address of a named variable, i.e. an lvalue. In other words, `'a'` does not reserve any storage space for a variable. It's just a number, one which is used as part of a larger expression. For example, if you wrote `printf("%d\n", 10 + 20);` there's no storage allocated for the 10 or the 20, and you can't take their addresses. (In fact the compiler will almost certainly perform constant folding such that the values 10 and 20 don't even exist anywhere.) (*) Note however that doing so is often a mistake. Most compilers will warn you if you try to do this without a cast. Putting a cast there like you've done silences the warning, but that doesn't mean the behavior is correct. It's still just as broken as ever, except now there's no warning. Your third example is just straight up undefined behavior. Any attempt to access an uninitialized variable is undefined behavior. For pointers this includes both accessing the pointer value itself as well as dereferencing it: int i; printf("%d\n", i); // undefined behavior int *ptr; printf("%p\n", ptr); // undefined behavior printf("%d\n", *ptr); // undefined behavior 
http://www.cs.usfca.edu/~galles/visualization/Algorithms.html http://rosulek.github.io/vamonos/demos/index.html http://algs4.cs.princeton.edu/code/ http://interactivepython.org/runestone/static/pythonds/index.html
awesome! thanks!!
`(*pt1).x` or `pt1-&gt;x`
Why do you want to do that?
It's also a good idea to use parentheses when dereferencing so that it is clear what you intend to dereference. You might want to increment a pointer and get the value: *x++, or you might want to increment the value pointed to: (*x)++. With the first, you can easily confuse someone who doesn't have operator precedence memorized, so you use *(x++).
You need backslashes in front of the asterisks. Markdown is swallowing them.
Right, it's based on the concept of "Never Trust Input".
There is no guarantee that the binary representation of 0 is only zero bits. &gt;6.2.6 Representations of types: &gt;5: Certain object representations need not represent a value of the object type. A better example is the [B5000/B6500](http://en.wikipedia.org/wiki/Burroughs_large_systems#Tagged_architecture) with 51-bit words, where the last bits stored metadata like read-only flags and so on.
Cool! Thanks for the education. I love learning about older systems that don't follow the same conventions as modern machines. It's interesting history, and it's taught me a lot about alternative approaches, and why things today are done the way they're done.
&gt; Option 2: Maybe you don't need to read so many bytes. Can you determine the response by looking at the first 5 bytes? What about the first 1 byte? Then you can decide what to do next, which might mean reading some extra bytes to complete the segment of the response you're currently reading. (Think of this like the file size... you can't read the whole response until you know the file's size, because you wouldn't know how many bytes to read. So maybe the same is true for the status code. Maybe you can't read the whole status code until you know how long you're expecting it to be.) So basically I adopted Option 2, where I read the first byte, if it's a - then we have an error (6 bytes), otherwise it will be an OK (5 bytes). Now, of course, the file size is retrieved correctly and everything matches, but I found out this other error (look at the last lines of the output): ./client 127.0.0.1 1234 Enter a filename to fetch (at most 26 characters): Specification.pdf retVal of STATUS: 4, should be 4 Received status: +OK retVal of dummy: 4, should be 4 Received file size: 16466 retVal of input_file: 16466, should be 16466 Enter a filename to fetch (at most 26 characters): Specification.pdf retVal of STATUS: 4, should be 4 Received status: +OK retVal of dummy: 4, should be 4 Received file size: 16466 retVal of input_file: 16466, should be 16466 Enter a filename to fetch (at most 26 characters): manual.html retVal of STATUS: 4, should be 4 Received status: +OK retVal of dummy: 4, should be 4 Received file size: 65864 retVal of input_file: 65864, should be 65864 Enter a filename to fetch (at most 26 characters): Specification.pdf retVal of STATUS: 4, should be 4 Received status: +OK retVal of dummy: 4, should be 4 Received file size: 16466 retVal of input_file: 1024, should be 16466 Enter a filename to fetch (at most 26 characters): QUIT When I receive the stream of bytes of input_file it is wrong, so how should I interpret this? I don't see in my code any other possible error which leads to wrong reading too much or not enough bytes. Should I interpret this as "Server couldn't send everything in one shot, so I have to do another `Recv` "? I don't believe that's the reason, because as I learnt from this discussion, with TCP it's a continuous flow of bytes, so if I say: &gt;Read `size` bytes It should keep reading `size` bytes, provided that there are so many bytes to read (but the server should send correctly). So I don't understand what's the issue now... Anyway, here's the updated code, for reference: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include "sockwrap.h" #define FILE_NAME 31 #define STATUS_MSG_OK 5 #define STATUS_MSG_ERR 6 //Because we receive a 32-bit unsigned integer, it is at most 10 chars (2^32-1) const char* prog_name; //This is needed by the sockwrap.h typedef struct sockaddr_in sockaddr_in; int main(int argc, char const *argv[]){ int sockFD, retVal; sockaddr_in saddr; char getFile[FILE_NAME+1] = {0},tempBuf[FILE_NAME+1-5] = {0}; char status[STATUS_MSG_ERR+1] = {0}; char input_file_name[FILE_NAME+1-5] = {0}; uint32_t size=0,dummy=0; FILE *fp; //For creating the requested file void *input_file; if(argc != 3){ printf("Syntax: &lt;ip_address&gt; &lt;port_number&gt;\n"); return -1; } //STEP 1: Declare and assign sin_family, sin_port and sadrr.sin_addr saddr.sin_family = AF_INET; saddr.sin_port = htons(atoi(argv[2])); inet_aton(argv[1],&amp;saddr.sin_addr); //Step 2: Get the socket sockFD = Socket(saddr.sin_family, SOCK_STREAM, IPPROTO_TCP); //Step 3: Ask for connection to server Connect(sockFD, (struct sockaddr *) &amp;saddr, sizeof(saddr)); while(1){ strncpy(getFile, "GET", sizeof("GET")); printf("Enter a filename to fetch (at most %d characters): ",FILE_NAME-5); fgets(tempBuf, FILE_NAME-5+1, stdin); //Since fgets includes also the newline char, we remove it from the string tempBuf[strlen(tempBuf)-1] = 0; //Remove \n strncat(tempBuf, "\r\n", sizeof("\r\n")); if(strncmp(tempBuf, "QUIT\r\n", FILE_NAME) == 0) break; strncat(getFile, tempBuf, strlen(tempBuf)); Send(sockFD, getFile, strlen(getFile), 0); /* ** We need to understand which status we are receiving, because if we receive ** +OK\r\n it's 5 bytes and we have to read the exact amount, otherwise we will read ** bytes regarding other data. This is due to how TCP stream works: even if, on the ** server-side, you make 3 Send, what is really sent is a UNIQUE STREAM. It's up ** to the client to "format" properly the byte flow. */ retVal=Recv(sockFD, status, 1, 0); //Get the first byte of the status if(strncmp(status,"-",strlen("-")) == 0){ retVal=Recv(sockFD, &amp;status[1], STATUS_MSG_ERR-1, 0); //Save -ERR\r\n printf("retVal of STATUS: %d, should be %d\n", retVal,STATUS_MSG_ERR-1); } else { //Save +OK\r\n retVal=Recv(sockFD, &amp;status[1], STATUS_MSG_OK-1, 0); printf("retVal of STATUS: %d, should be %d\n", retVal,STATUS_MSG_OK-1); } printf("Received status: %s\n", status); if(strncmp("-ERR\r\n", status,STATUS_MSG_ERR) == 0 ) return -2; retVal=Recv(sockFD, (void *)&amp;dummy, sizeof(uint32_t), 0); //Get the file size printf("retVal of dummy: %d, should be %lu\n", retVal,sizeof(uint32_t)); size = ntohl(dummy); //Convert from (N)etwork byte order (TO) (H)ost byte order (L)ong printf("Received file size: %u\n", size); input_file = malloc(size); if(input_file == NULL){ //NULL can also be due to 0 memory allocation printf("Error in allocating memory\n"); return -3; } retVal=Recv(sockFD, input_file, size, 0); printf("retVal of input_file: %d, should be %d\n", retVal,size); strncpy(input_file_name, "down_", strlen("down_")); strncat(input_file_name, tempBuf, strlen(tempBuf)-2); //-2 -&gt; remove \r\n fp = fopen(input_file_name, "wb"); if(fp == NULL){ printf("Error in opening file\n"); return -4; } if(fwrite(input_file, 1, size, fp) != size){ printf("Error in fwrite\n"); return -5; } //Close, free, reset all the memory and vars fclose(fp); memset(getFile,0,sizeof(char)*(FILE_NAME+1)); memset(tempBuf,0,sizeof(char)*(FILE_NAME+1-5)); memset(status,0,sizeof(char)*(STATUS_MSG_ERR+1)); memset(input_file_name,0,sizeof(char)*(FILE_NAME+1-5)); size=0; dummy = 0; free(input_file); } Close(sockFD); return 0; } 
&gt; Should I interpret this as "Server couldn't send everything in one shot, so I have to do another `Recv`"? I don't believe that's the reason, because as I learnt from this discussion, with TCP it's a continuous flow of bytes, so if I say: &gt; Read `size` bytes &gt; It should keep reading `size` bytes, provided that there are so many bytes to read (but the server should send correctly). Ah, but I mentioned this in [an earlier comment](http://www.reddit.com/r/C_Programming/comments/36e5i0/network_programming_is_driving_me_crazy/crecl55). Look at various manuals for the `recv()` function. All of them say the same thing. [Windows](https://msdn.microsoft.com/en-us/library/windows/desktop/ms740121\(v=vs.85\).aspx): &gt; For connection-oriented sockets (type SOCK_STREAM for example), calling recv will return as much data as is currently available—up to the size of the buffer specified. [Mac OS X](https://developer.apple.com/library/ios/documentation/System/Conceptual/ManPages_iPhoneOS/man2/recv.2.html): &gt; The receive calls normally return any data available, up to the requested amount, rather than waiting for receipt of the full amount requested [Linux (section 2)](http://linux.die.net/man/2/recv): &gt; The receive calls normally return any data available, up to the requested amount, rather than waiting for receipt of the full amount requested. So all of them say they'll return **up to** the amount you requested. They might return less! This is partly because of the design of TCP. It's byte-oriented. Even when the server sends the `+OK\r\n` message, it doesn't have to send all 5 bytes at once. It's totally allowed to split that into 5 messages of 1 byte each. So maybe when you call `recv`, you genuinely haven't received all of the data yet. Also, there is buffering in the kernel. Maybe it doesn't have enough buffer space to hold all of the data it's receiving; it might need you to `recv` some data in order to make room for it to get more data from the network. So yes, you *must* check the return value of `recv` to find out how many bytes you *actually* received. If it's fewer than you expected, you have to call `recv` again, adjusting your parameters as needed to write the data to the correct place. The `send()` function works exactly the same way. If you ask to send 100MB, the kernel almost certainly doesn't have enough buffer for that. So it's going to accept as much as it can, maybe a few dozen kilobytes, and tell you how many bytes it accepted. If it didn't accept your whole data to send, you need to call `send` again, adjusting your parameters to point to the remainder of the data and the amount remaining. This is true even if you're just sending 2 bytes! That's why you were given `Readn` and `Writen` helper functions. But those only work if you know you're supposed to receive *exactly* that many bytes. If there's a possibility that you could need to receive less, it's not helpful.
Deitel's "C How to Program" is pretty good. It's what I use.
What about apue: http://poincare.matf.bg.ac.rs/~ivana//courses/ps/sistemi_knjige/pomocno/apue.pdf
Reading the linux kernel is a bald move, right? EDIT: I'm not a pro either but I would arrange the steps into a list. * arhcitectural level: firm understanding of pointers, memory map, how the stack works (you can find resources everywhere) * C part 1: syntax of C, what you can do with it, what it is capable of and [beyond](http://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c) * standard library: because it exists on almost every platform and you don't want to repeat yourself * C part 2: what you really get when you compile your program. [tip of the iceberg](http://www.slideshare.net/olvemaudal/deep-c) * Structuring a C program: you can go with ye olde structs &amp; static functions or using the OO approach
 while(*s++ = *s2++) ;
The value at address 2 should be 1 (the address of b). I am not sure about your performance cost question. But if you're wondering if it is more costly to double-reference pointers than single-reference, than yes. To update address 0 you could type `*b = 33` or a double-reference `**c = 33`. For your final question (z): z holds the address of the malloc (2^30), and *z points to the memory you have allocated (and can use). When you do `*z = 99` z still holds the address of the malloc (2^30), but now that memory holds the value of 99. q will contain the address of z (0), so *q will be the value 2^30.
 int a = 32; int * b = &amp;a; int * c = &amp;b; First off, c should be of type `int**` because it contains a pointer to a pointer to an int. &gt; is the value at address 2 stored as a value of 1 or 0? It would be a 1, because you're assigning the address of b (which is 1) to variable c. b = malloc(sizeof(int)); *b = 45; then the value at b is not 0 but 45. No. When you call `malloc()`, you will receive a pointer to space on the heap. So b will be some arbitrary value like 0x1000. After the second line, b will still be the same, but the memory at location 0x1000 will contain the number 45. int * q = &amp;z; Again, this should be `int**`. In any case, it will hold the value of the address of z, which is 0. I'm not sure what magic you're expecting to happen, but in these examples the compiler will do exactly what you're telling it to.
thanks :)
&gt; All of the frames are random-access . Of course you will need a pointer to access any variable whose name is not in scope, but scope is a different thing to stack frames. Yes, I know, which is why I have the parenthetical. &gt; Stack frames are optional anyway I think it's still a good conceptual view.
It always seemed daunting and hard to get into for me... Any tips on where/how to start?
I suggest you mess around with GDB and see how simple programs work in memory. It will give you a lot of clarity. 
Here's a [website](http://hackaday.com/2012/12/24/how-to-write-your-own-minesweeper-solver/) that tells you how to make a minesweeper solver. If that doesn't help, please share more detail. 
Thanks a lot for answering, I have already lost hope for being noticed here! But... Uhm.. The thing is, my aim isn't to create a minesweeper solver, I'm quite sure it would be easier to download it, my aim is to learn how to programm in C by creating a minesweeper solver. I had seen the link you posted but the author made it in Java, which is not really my point. But hey, man, thanks for answering anyway! 
Understood. Will this be your first project? If so, it's a worthy goal, but might prove discouraging as a first. There is no shame in creating small programs that do very little in someone else's eyes. Main thing is to learn C in small bites, creating small programs that do dumb little things. As your expertise grows, you will naturally consider adding some features to one of you minor efforts, and one day it's become something much larger and a bit impressive. Then entertain more seriously your worthy goal: the minesweeper solver. At that time, you might find the code ideas pouring out of you faster than you can type. That's how it happened for me. And like you say -- perhaps it's really not about the minesweeper solver at all, but just working with ideas to learn C. In this case, any dumb little idea will do: a program that tells the current time and date. Now, put it in a nice GUI. Now, add a full calendar display....last month, this month, next month, side by side. Add buttons that let the user view the calendar 5 years into the future -- or back. It sounds trivial, until you start to code it. Any little thing will do. You'd be surprised how far the idea of 'adding features' will take you. All the complexity you need to learn will arrive, but in your own, manageable steps, and according to your growing capabilities. 
I got the issue and was able to solve the exercise properly! In the next days I'll develop the server also!
You're right. 
Oh, you seem to be so much right... Since I have been programming for around 5 years already, I thought that I could just learn how to programm in C in like 1 week. I suppose that you are right that it is completely something different and I shouldn't just start with such a project. Thank you for opening my eyes, I will start with that "future-adding" method of yours!
&gt; Sure, you can only push and pop to the top of the stack but that is really only done at the beginning and end of function calls, and always done in order so this isn't a big deal. You still have random access reads and writes due to the magic of offsets. Unless you're particularly insane and use alloca(). It allocates memory on the stack that is automatically deallocated when the function returns. Did I mention that it's terrible and you should never use it?
The call stack isn't actually a 'stack' in the abstract sense, which is probably where you're getting tripped-up. The call-stack is (in general, literally) an array of bytes combined with a pointer into this array we call the 'stack-pointer'. The stack-pointer tells us where the top of the stack is (So it starts at the beginning of our array when our program starts). Since, as we know, we can easily take a pointer to an array and add an offset to get a pointer to a different location in the array, the 'stack' is random access - We have a pointer to it, and we can use offsets into this array via the stack-pointer and access any piece that we want to at any time. You can access 'stack-pointer + 4', access 'stack-pointer + 8', and then access 'stack-pointer + 4' again with no problem. This shouldn't be surprising because that's how arrays are, they're random access. When you call a function, you first adjust the stack-pointer so that it points to the new 'top' of the array. Thus, when a function is called, it in general decides "I'm going to use 16 bytes of stack space", save the stack-pointer somewhere, increments the stack-pointer by 16, and then uses the saved stack-pointer + offsets to access any of the bytes it's making use of. So, if it needs that 16 bytes for ints `a`, `b`, `c`, `d`, then it can use 'saved-stack-pointer + 4' to access `b`, or add 8 to access `c` instead. Obviously, because we're just doing offsets into wherever the stack-pointer tells us, we can access any spot we want, we don't have to do it sequentially. The key is that, by incrementing the stack-pointer by the amount we're making use of, when we call a function it will also use the stack-pointer, and start writing to the array right after the last byte we used (So, if we stopped at byte 16, it would start at byte 17). That function also increments the stack-pointer by how much it uses, so called functions start writing to the stack right at the end of where all the other functions wrote to the stack. When a function returns, it decrements the stack-pointer back to what it was originally, so when the function we returned too calls another function, the stack-pointer is in the correct place. As you can see, it acts like a 'stack' in the sense that, when you call a function, it starts writing to the 'top' of the stack (Like you would with a stack). But it doesn't act like a stack in the sense that you can access any part of the stack you want at any given time.
Thank you for the thorough reply. I think I must have misinterpreted what the book was saying, and this explanation makes sense.
You can use fscanf before the for loop to get the values into separate variables.
Are you talking about a toolkit to create GUI programs? Gtk+ comes to mind.
Well, it is not about creating GUI per se. What do I need is something that can, uhm, get content of an window, to be exact, get content of a Windows' minesweeper's window or maybe force a mouse click. I am sure that it could be easily done using AutoHotkey, but I am looking for something similar that would work "inside" of C (let's say a library).
suggesting vim to a user who is confused between a compiler and a VM?
&gt; in assembly the programmer had to manually allocate memory on the stack? Not really. If you're using a frame pointer, any memory allocated on the stack is automatically freed in the function epilogue when the saved value of the stack pointer is popped off the stack. If you're not using a frame pointer, you have to be sure to adjust the stack pointer by adding to it in the epilogue the same amount you subtracted in the prologue (modulo any pushes for saved values.) &gt; Why doesn't C give us that capability? [`alloca()`](https://www.freebsd.org/cgi/man.cgi?query=alloca) is a nonstandard function that can be used to allocate a chunk of stack memory. Its use is generally discouraged, as the stack is of limited size and isn't meant for bulk allocation. If you don't know the size of something, you shouldn't be allocating it on the stack, because you can't be sure its size won't be large, and that it won't blow out the stack. C99 also has VLAs (variable length arrays), which work similarly, but the same caveats apply. It's generally accepted that VLAs were a misfeature that should be avoided. &gt; Do values on the stack have addresses that we can examine Of course they do. int x; printf("%p\n", &amp;x); &gt; As in, if something is on the stack, it has an address, but C only knows the relative address of the variable. No. Variables on the stack are referenced as relative offsets to the stack pointer or frame pointer, but that SP/FP register always contains an actual address. You wouldn't be able to access the variable otherwise.
Ok, I will have to meditate on this for a few hours
When the OS starts a program, it sets up the programs stack-space and gives the address of the stack to the program - The stack stays the same size for the life of the program and you can't request more space (generally). If you attempt to write past the end of the stack that's called a 'stack overflow' and general it results in your program crashing. Thus, you don't have to allocate stack space like you do heap space - The OS already gives you space and you just start reading/write to it. There's no difference from `malloc` allocated memory and stack memory in this regard, you can get an address to either and store it in a pointer all the same - They both exist in the same memory space. The compiler will frequently refer to locations on the stack via an offset, but that's purely because it's faster then storing pointers to all the variables and then using those - By using an offset you can use a single pointer to the bottom of the stack, and then combine it with an offset to access any variable that you've placed on it. Using an offset in this sense is no different then allocating an array on the heap and using the notation `p[n]` to access members of it. I think you're misunderstanding how exactly 'allocating on the stack' works. Like noted, the stack space is already pre-defined by the OS. "Allocating" on the stack is nothing more then deciding "these four bytes are where I'm going to keep my `int`". It's not like allocating heap space where you have to ask the OS for it, you already have the memory for the stack and it's just a matter of deciding where to place things in it. In this regard, the compiler takes care of actually managing the stack such that every variable that needs stack space gets proper space on the stack. It's worth noting that in lots of cases, the compiler can skip the stack and just keep a variable in a register the entire time (Or even just get rid of the variable completely). Because of cases like these, there's no advantage to requiring the programmer to manually allocate stack space for variables, because there's a chance those variables don't need stack space anyway. C doesn't really give any guarantees on the contents of the actual stack, for the reason that the compiler handles it for you.
http://jroweboy.github.io/c/asm/2015/01/26/when-is-main-not-a-function.html I'm sorry, I was lazy, I just saved the code to my computer and started talking about it with a friend... And he suggested reddit might like it too. But I found it!
&gt;&gt; in assembly the programmer had to manually allocate memory on the stack? &gt; Not really Yes really. When you set up a stack frame in a function's prologue, it generally *only* sets up the frame pointer, stack pointer, and return address. If you want to then store some data on the stack, you have to adjust the stack pointer to be correct. Depending on the processor, there may be instructions that adjust the stack pointer and write to memory at the same time, like `PUSH $eax` or `[SP--] = R0`. On processors with a more limited set of instructions, you may have to separately change the stack pointer and write to the memory you just reserved.
But that's not really "allocating" - the memory is already allocated.
`clang` should compile this fine, at least. For a one-off piece of code that this mostly appears to be, it's not that bad. It does stink that it needs extensions to do it this way, because the code itself is pretty cleanly done. Without the extensions it be much more annoying to read, and slower as well.
&gt; gcc at least others not tried, nicely builds this into a hello world thing The compiler doesn't matter; what matters is that you're using x86_64 Linux (and only that specific combination), not that you're using gcc. If you were using gcc on x86 Linux, or gcc on Windows or OS X, or gcc on ARM or Sparc or whatever, this will fail hard. 
With some assembly knowledge you could probably actually writes a bunch of macros that look like assembly code and dump out machine code byte-by-byte. Label's wouldn't be easy or clean, but you could probably make it kinda work if you're careful (It would be much easier with something like ARM or MIPS rather then x86, but oh well): #define EAX 0 #define ECX 1 #define EDX 2 #define EBX 3 #define MOVL_IMM_REG(src, dest) 0xB8 + (dest), (src) &amp; 0xFF, ((src) &gt;&gt; 8) &amp; 0xFF, ((src) &gt;&gt; 16) &amp; 0xFF, ((src) &gt;&gt; 24) &amp; 0xFF #define INT(imm) 0xCd, (imm) &amp; 0xFF const char main[] = { MOVL_IMM_REG(1, EAX), /* exit() syscall number */ MOVL_IMM_REG(0, EBX), /* exit code */ INT(0x80) }; Note, the above is untested (And probably doesn't work without some tweaking). Obviously, you should never do this and it's not really practical for more complex assembly anyway. Edit: Wow, I'm honestly shocked this untested code works without modification now that I've gotten a chance to try it.
Thanks, that was a good read. I got the feeling something like this was happening, but using const for force it out of .data into read-only was really sharp of him!
Yes and no. Allocations can be subdivided. This is what malloc does internally. It allocates a large region of heap from the kernel (say 1MB at a time), and then subdivides that to give you your small allocations of 4 bytes or however much you asked for. Or let's say you implement a queue or memory pool or something similar, using a fixed-size array to store everything. You allocate memory using malloc to hold the fixed-size array, but then to use any memory inside your queue/memorypool, you have to allocate an element of it. Different layers of abstraction. The task's stack is no different. Yes, from the kernel's point of view, it's allocated a 64KB region of memory that it intends for you to use as your stack, and that's all it cares about. But inside your program, that stack is divided into frames, and a frame has to allocate space on the stack so that when it calls a function and a new stack frame is pushed, it will end up in the right place. Technically, this does mean that a leaf function (one that doesn't call any other functions) can get away with not changing the stack pointer, or maybe not even setting up a stack frame (depending on the platform; on some this is slower, or difficult, or just plain incorrect). But that's the exception, not the rule.
That's weird. On amd64? How did you invoke the compiler?
Hm... that's weird. I don't understand why the rodata segment is executable.
&gt; I continued to search and search some more until I found a very obvious and simple solution on a stack overflow post that I’ve lost the url to sadly. All I have to do is declare the main function as const Changing it to const char main[] = { was all I needed to do to get it in the right section, so lets try compiling again. From the original article posted above, stack overflow might have the answer why this works. 
That's really weird. `rodata` should really not be executable.
The only purpose why `.rodata` exists is so there's a segment that is neither writeable nor executable. It's silly that this segment is executable, totally defeats the security purpose.
Ok what is a register in this sense? is is a register part of a heap? I mean I know a register is a special memory area where you put special information.
Historically, you placed non-writeable data into the `text` section, together with the code. Some platforms, like Windows, still do this. `rodata` was invented to have a separation between read-only code and read-only data so the latter can be made non-executable. Executable read-only data can still have problems, as there might be bugs were a pointer to data is accidentally being jumped to.
What is "&amp;&amp;" doing here? I didn't realize it had a second use besides a logical AND.
thank you, I will meditate on this
I should have probably clarified that I was talking about the js0n parser as a whole, not just the specific extension shown in the title. Like in the SO post, the js0n code also uses the `&amp;&amp;` address-of-label extension to create a jump table to a bunch of simple routines inside of a function using `goto`. While `gcc` and `clang` can do some optimization similar to this if you use `static` functions instead of the `goto` routines, I can't picture it being as optimal because the functions don't have access to all the variables in the original parser function except if you pass them (And it would be harder for `gcc` and `clang` to turn it into a direct `jmp` to and back). You could probably do a big `switch` with conditional `goto`'s, but I'm fairly certain `gcc` still wouldn't produce as good of code as this can.
A small (somewhat useless) piece of information about `register`: You can't take the address of `register` variables. With this in mind, while the compiler probably will probably ignore it anyway, it will keep you from doing things that would force the compiler to place the value on the stack (Which essentially boils down to taking the address of the variable, since you can't take the address of a register, obviously). With that in mind though, it's still basically useless. The chances that you really need to be concerned if your variable is placed into a register or not are pretty low to begin with, and if you play by the rules the compiler will do it anyway.
The output on the left is address of each instruction. From a quick glance, this seems to explain stack frames clearly enough: http://eli.thegreenplace.net/2011/02/04/where-the-top-of-the-stack-is-on-x86/ Bear in mind, though, that the examples in the above are in Intel syntax, where the order of instruction operands are reversed (or normal imo :p). In other words: Intel syntax: mov eax,0xff AT&amp;T syntax: mov $0xff,%eax 
&gt;My question is what is the output on the left ```0x0000000100000f50```, is this the address of the stack? I believe it could be the memory location of the instruction (Since instructions are stored in memory). And it looks like the instructions have different sizes - by looking at the address and next address you can work out how big an instruction is. Some processors have fixed instruction sizes, like MIPS, others vary depending on the instruction, like x86. &gt;And what is the destination of ```push %rbp```? Just the top of the stack? Yes, push will put its operand on to the top of the stack
It's not relevant here, but whatever,it's not like there's more than four posts a day in this sub. Your question has been answered but for other learners reading this I'm gonna take the time to say C and Assembly have nothing to do with each other. Neither does C and Linux. The exact same C code produces totally different assembly on different computers. Even on the same computer actually. C and assembly are in no way the same thing and they do not have a 1 to 1 relationship. Imagine you verbally told a story about a beautiful princess to two of your friends. Now ask them to draw the princess. They're not going to draw the same thing. C is the verbal story, the compiler is your friends making different drawings of the same story. The exact same C code that says "get the address of this" will be translated into totally different addresses depending on the compiler you use, the options you run it with, the processor you tell it target, and the OS that's running on that processor. Some computers pass function arguments on the stack, others pass them in registers. These are called calling conventions and have nothing to do with C. **The C code is identical either way**. That byte of information you think you're pointing to in your C code may actually be in the ram of your computer like you think it is, or it might be in a virtual memory page on disk, or in a register in the cpu etc. The physical reality of computers and memory is not "known to c". This is a major source of misunderstanding with beginners and a source of vulnerabilities even with professional programmers. You're not making "'a c program". C is an illusion. C is a made up playground where you can describe in an abstract way what you'd like to have happen, then ask a compiler to generate a program it thinks might accomplish what you wanted on the specific architecture and OS you told it to target. Obviously you're taking the steps to close the loop and learn about the real program you're generating with your abstract c instructions to compiler, but I see way too many questions (and answers) here that don't recognize what they're really doing. 
interesting. My understanding is that if you have highly portable c code, you could compile and run it on any computer with the appropriate c compiler (c99 etc). However, the same executable will not be able to run on computers with different specs / operating systems. I found this quote from the wiki page on c: &gt;The origin of C is closely tied to the development of the Unix operating system, originally implemented in assembly language on a PDP-7 by Ritchie and Thompson, incorporating several ideas from colleagues. Eventually they decided to port the operating system to a PDP-11. The original PDP-11 version of Unix was developed in assembly language. The developers were considering to rewrite the system using the B language, Thompson's simplified version of BCPL.[14] However B's inability to take advantage of some of the PDP-11's features, notably byte addressability, led to C. Furthermore, gcc has -S built in from which you can get the assembly code generated from your program. Is the ./a.out program generated directly from the source code or from the assembly code? I mean, supposing that it generates the executable from the assembly, that suggests that at least the gcc has strong connections to assembly. The fact that this happens suggests that the gcc generates assembly from the source code, and from the assembly code, it generates the executables. Having said that, is it possible to implement a c compiler that skips directly fro m assembly into an executable? I may be completely wrong about what I am saying, I am still struggling to get an elementary understanding on this subject.
Look at this http://courses.cs.washington.edu/courses/cse378/97au/help/compilation.html
But for gcc, is the c code passed into assembly as an intermediary state? 
again I'm not a compiler programmer by any means. All my experience is llvm, I've never looked under good of gcc so hopefully someone else will jump in but thinking logically if there was a direct relationship between c statements and assembly instructions it would be impossible for gcc to have optimization levels, and I know it does, so I'm gonna just say it *must* change c instructions into an even more abstract, mathematical concept of things computers can do so it can calculate different ideas for loops and logic flows and score them mathematically before it goes back the other way and starts making it's optimized assembly code.
While your statement that writing C in no way dictates assembly code, I have for years maintained that if I cannot reasonably guess how an un-optimized fragment of my code will compile into assembly (and thus have some idea of its worst-case runtime) then I have not sufficiently considered the design. Optimizing compilers are amazing, and they have all kinds of tricks, but I think first-order knowledge of the resulting assembly is precisely what's missing from people who come from high-level languages: they unwittingly write slow/awkward code because they don't know any better.
The optimizations generally looks for patterns, make increasing levels of assumptions, and make tradeoffs. A fully un-optimized program would do things like initialize unused variables. For optimized code, the tradeoffs are usually code size vs speed. Loop unrolling is a perfect example.
I don't know, ***is*** it possible to *translate* C/C++ into any other higher language? Isn't it more so that you can access libraries written in C/C++ from pretty much any other higher level language like C#, Java or Python? 
edited 
It's probably homework.
Because the printf is outside of the loop?
Don't just say that the code "doesn't work", tell us exactly what happens. Anyway, the `printf` call should probably be inside the for loop.
Your printf is not inside of a loop. It will only print once with whatever index is in i , which is 14.
Should've double checked that, derp. Thanks for pointing that out.
Arrays don't really have a related 'size' to them, they only do if you keep track. So, presumably the array sent to `insert` is already big enough to handle `N + 1` items, and the code calling `insert` will have to increment the size of the array that it sent to `insert` as `N` to account for the fact that they just added another item to that array. In other words, `insert` doesn't have to worry about changing the size of the array, the code calling `insert` on the other hand has to make sure it has space for `N + 1` items inside the array, and then keep track of how many items are actually inside it.
Actually, `i` will have the value 15 after the loop and the index will be outside of the array. Depending on your architecture and alignment that means the value that is printed out is that of x, since that happens to be behind the array.
Yeah you are right, of course *i* is being incremented before *i &lt; x* is checked, so of course i is 15 outside of the loop. 
First, your posted code doesn't work. You have more then a few spelling mistakes unfortunately. Personally, I think that writing a separate function to calc the average would be a bit more trouble then it would be worth. It's easy enough to integrate the average calculation into your existing code. Declare a `float` variable for your average. You'll calculate a new average every time you loop through a row, so make-sure to set `average` to zero at the start of that loop. Then, when you loop through the `COLUMN` entries, keep adding those values to the current `average` and divide by two. Successive adding and dividing by two is a valid way to calculate the average, it gives you the same as if you added them all together at once and divide by the number of numbers. When your 'COLUMN' loop is done, `average` will contain the average for that row, and you can just print it out as well as use an `if` to determine the `passing` status. Sending a row to a function to do that average isn't much more complex, I could explain it if you need, but in general I would consider it more trouble then it's worth in this case unless you want a generic 'average' function to use.
Could you put your code here or on something like pastebin? It would make it a lot easier to help you.
I put the code on pastebin as requested. /u/2ns910mrso9 http://pastebin.com/D9Zz0WZ8
Thanks for this!!! 
I'm surprised you're not getting a segfault at this line in addToFront: strcpy(newNode-&gt;word, theWord); You're copying a string into a pointer that doesn't point to anything yet because it hasn't been initialized.
Please post your code, threads should not work the way you described.
I had a quick look and it seems like you're passing the same pointer to each of your threads, so they will be accessing the same data. Also I'm seeing a lot of this: ` aux=pointer + (1 + N * sizeof(int));`. I haven't checked but are you sure you need `n * sizeof(int)` instead of just `n `there? 
Yes. If an error is possible, but in practice just doesn't really happen, it's safe to ignore. I'd focus on handling errors well rather than just handling all possible errors.
I'm a big fan of *never* checking memory allocations (on a Unix operating system). If a memory allocation fails, there's really only one sensible course of action: crash. On more obscure operating systems, dereferencing a null pointer may do something other than crash, in which case you'd want to catch a failed malloc() and explicitly crash.
C and C++ are different all know that Also tutorial has opengl graphics in it with source code at the down. Plz check it there if you haven't 
I may be wrong, but couldn't just not checking memory allocations lead to obscure behaviour, not necessarily a crash, and so much confusion as to why your program is behaving weirdly? And on top of that, because you don't really know what your program's going to do, couldn't it end up doing something you really don't want, bad for security?
It also depends on the life of the function parameters. If the parameters are well known to be within bounds, you can use an assertion that only compiles in debug code. Otherwise, you may be wasting time checking for errors.
calling srand seems to fix it. You don't have to multiply by sizeof as much as you do, [read this](http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/BitOp/pointer.html). Your shmem size is `6*sizeof(int)` = 24 bytes, but you use memory at `aux = pointer + (1 + NUM_THREADS * sizeof(int));` with `aux` being an `int*`, that makes it point to `pointer + 20` which is 80 bytes offset from your shared memory. It only works because shmget rounds up to PAGE_SIZE (4096).
Specifically on Linux, malloc never fails due to a lack of memory. The kernel will allocate more virtual address space to the process but until that space is actually accessed, will not be backed by actual memory. In an OOM situation the OOM killer will be invoked and the allocating process will either have its virtual allocation filled by scavenged memory or be itself terminated.
THANKS a lot. But why did you define the main like that ? it must be like ' main (void) ' right ?
Your strlen() call needs to be after you set the string (ie fgets() ). You're calling it before, on an uninitialized string, which gives an invalid value and may cause an out of bounds memory read.
Thanks, It's working now!
Yes, if you actually get a `NULL` from a `malloc` and then try to access it in C, you’ve invoked undefined behavior per the language standard. The compiler could have generated code sth your program checks for the the situation (ha), or goes on with its life as usual, or accidentally stars the robot rebellion. If it crashes right away, you’re quite lucky.
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct node { int data; struct node *next; } Node; void addToFront( Node ** headPtr, int newData) { Node* newNode = malloc(sizeof(Node)); newNode-&gt;data = newData; newNode-&gt;next = *headPtr; *headPtr = newNode; } void removeFromFront(Node** headPtr) { if ( *headPtr == NULL ) return; Node* toRemove = *headPtr; *headPtr = (*headPtr)-&gt;next; free(toRemove); } void printAll(Node* front) { printf("List: "); Node *curr = front; while ( curr != NULL ) { printf("%d ", curr-&gt;data); curr = curr-&gt;next; } printf("\n"); } void delete(int toRemove, Node ** headPtr) { Node *curr = *headPtr; Node *prev = NULL; while ( curr-&gt;data != toRemove ) { prev = curr; curr = curr-&gt;next; } if (prev != NULL) { prev-&gt;next = curr-&gt;next; curr-&gt;next = NULL; } else { *headPtr = (*headPtr)-&gt;next; } free(curr); } int main(void) { Node *myList = NULL; addToFront(&amp;myList,42); addToFront(&amp;myList,32); addToFront(&amp;myList,12); addToFront(&amp;myList,92); printAll(myList); delete(92,&amp;myList); printAll(myList); delete(32,&amp;myList); printAll(myList); }
If you are out of address space crashing is a sensible response
But the compiler can elide references to that NULL pointer (to non-`volatile`), even if you make them explicit—according to the language, it’s allowed to optimize as if `NULL` dereferences do not occur. That means that the crash could happen well after the allocation failure, possibly after you do some other stuff that shouldn’t’ve happened. It’s like reading a password, doing the stuff the password should’ve guarded, and *then* checking that the password was correct. [Editing: Also, C/C++ are not intended *only* for use on systems with virtual memory, or where there are tons of process/user protections in place; they’re also intended for building software that provides such things, or operating in modes/environments where those things aren’t possible. If you’re in kernel mode and something returns `NULL`, you damn well better handle it properly.]
The problem with out of memory error paths is that they are incredibly difficult to write correctly, and nearly as difficult to test. The anount of stuff you can do while unable to allocate memory is severly limited, even writing to a file is likely to fail, even if you aren't calling printf or the like because if you can't allocate memory it's reasonably likely the OS can't either so almost anything you try to do will probably fail. If you have no OS then you probably have to deal with allocation failures, but you also probably have some infrastructure for doing so, and a lot more options. If you are writting a library that deals with malloc fails you had better have tests for tjat cover every single instance of malloc, because if you don't it's almost certain that your out of memory handling is broken. One of the libdbus developers has a blog post about how hard it is to properly deal with malloc failures (libdbus does) and they basically say it's not worth doing unless absolutely necessary.
Cleaning up usually requires memory allocation. Edit; I agree for most difficult to deal with errors, but memory sllocation failure is rare on most desktop/server/phone OSs, rare enough that if it happens probably have a bug, and difficult enough to do right that there is good chance your attemp to clean up will fail. Better is to make sure crashing will lose very little data, that way you are protectong against crashong bugs too.
Not everyone knows that, especially with people like you saying stuff like "Tutorial in C/C++ ...". It just confuses more the people that don't there is a big difference between C and C++. Pick one! It is either a tutorial for C or C++.
Here's [a diff](http://pastebin.com/mkxJUZ5a) that might be of some help. It's search_list_add that I think is the culprit.
what bad habits might you pick up from K&amp;R? I always hear it referred to scripture.
As someone who started out with Java in it's 1.0/1.1 days, and then switched over to C: do not worry too much about memory management. Yes you have to be more careful, yes eventually you'll have to manage some memory yourself, but it's a bit overblown and not hard at all. Certainly in C it comes down to understanding how stuff works, and what is exactly happening, and more importantly - what is not happening "automatically". Array boundary checks are a prime example - you won't get some fancy outofboundsexception, you'll just be writing somewhere in memory you did not intend. I don't really have any resources for these things - I figured things out mostly on my own by trial and error with various small programs. The most important thing in C is imho knowing how memory is organized. This is not really "managing memory" - but more knowing what memory addresses are, how arrays are represented in memory, wrapping your head around pointers for the first time, understanding what the stack and heap is, and what their purpose is. I'm not really talking about C++, where these things also apply, but a lot of things you would have to do in C are frowned upon in C++ (pointer magic etc)
Learn pointers. Pointers are a thing that seems to break some people's brains. If you get a good understanding of pointers (and pointer-pointers, etc), then everything else should be relatively easy. Learn the difference between the stack and the heap (and static allocation). In Java, every object is allocated on the heap. But heap allocation in Java is cheaper than in C, because the garbage collector can move things around. If something is on the stack, then you can't return a pointer to it (but the language will let you!) because that memory gets freed and reused when the function returns. If something is on the heap (allocated with malloc() and friends), it needs to eventually be freed(). And it must not be used after it's freed. If you're on Linux or OSX, test your programs under valgrind and it will catch many memory errors. Expect to make a few, especially at first. Remember, just because something works, doesn't mean it is correct. In many cases, accessing recently freed memory will mostly work, and only crash occasionally. Valgrind is great for catching most of these types of errors, because it prints an error even when the code might have not crashed. But it can only warn you about the code that's run under it, it's not a static analyzer.
Using `fgetc()` you're implementing your own parsing. This can work fine and shouldn't be a pain to use so long as you define a proper interface to your input parsing function. However it's unnecessary. The C standard library already comes with facilities to parse input for basic types like ints. The function you want is one of the [`scanf()` functions](http://en.cppreference.com/w/c/io/fscanf). #include &lt;stdio.h&gt; int main() { int i; int return_value; while (1 == (return_value = scanf("%d", &amp;i))) { printf("You input the number: %d\n", i); } if (EOF == return_value) { printf("End of input.\n"); } else if (0 == return_value) { printf("There was an input error while attempting to read a number.\n"); } }
Read a line at a time, then use sscanf() or strtol().
Sorry, I didn't mean to break any rules. I am just trying to use all outlets to get some honest feedback from the development community. I also listed some common languages and said "more" so, yes it does support C. The website is not yet live but we are working on getting it done and up by the end of the month. You can always go to YouTube directly and search for Global Dev. 
The stack doesn't always stay the same size during the execution of the program. If the stack space gets filled up, and the total stack size is less then the RLIMIT_STACK (usually 8 MB), then stack is expanded to accommodate the new function frame..
Would this be better for wrapping it around? else if (stext[i] + n &gt; 'z') { stext[i]=stext[i] + n - 25; }
I was avoiding that detail, since as far as the standard is concerned it's just an implementation detail, but yes the stack technically changes size. The OS will dynamically allocate new pages for the stack as you attempt to write to the new pages. From the program's perspective though, the stack never switches to being smaller/larger, and while there are some syscall stuff you can do to request the stack to be made larger or smaller that's not standard C (Though on Linux I don't believe you can make the stack any larger them 8 MB generally because of where it's located in the memory-layout). But to note, on Linux, you can already write on the stack up till RLIMIT_STACK, you don't ever need to request more stack space because the kernel will just give it to you as you start using it.
&gt; yeah I want it to wrap around but I am not sure how I could do that Then you copied an earlier part of the code from somewhere without understanding what it does because you've already done it once. 
Is this a single-core system? 
No. It's an Intel Core i3 Sandy Bridge these are dual-core and hypherthreated. The described program gets never more than 25% of total CPU usage.
Fair enough. IMO, It's actually kind-of cool. First of all, you need some knowledge going on before we start writing the function. It's important to recognize how arrays in C are laid out in memory, which is called [row-major order](http://en.wikipedia.org/wiki/Row-major_order). The basic idea is that, with C, if you have this array: 20 30 40 25 35 45 Then it's actually stored as a one-dimensional array (Like everything is, memory is linear) in this order: 20 30 40 25 35 45 As you probably noticed, it goes in the order of 'everything in the first row, then everything in the second row, etc...'. This is important to note. For example, you could do this: int arr[3][3] = { { 20, 30, 40 }, { 25, 35, 45 } }; int *ptr = &amp;arr[0][0]; ptr[3] = 26; That would set the '25' entry to equal '26' instead. it works because we take the address of the first element of the array, and then access 3 past that entry. Since the multi-dimensional array is stored in row-major format, '25' is the 4th entry. Why is this important. It means you can actually (easily) get the address to entire rows. Simply only use one index to the array variable. For example: int *ptr = arr[1]; The address of `arr[1]` is the address of '25'. Thus, `ptr` points at the array `25, 35, 45`, or in other words it points at the second row of `int` values. If you instead wanted a pointer to the first row, you could use `arr[0]` instead and it would work the same way. row-major order lets this happen because it means all the entries of every row are stored in order. If you think of it in terms of the one-dimensional array, `arr[1]` gives us a pointer to '25', where as `arr[0]` gives us a pointer to '20'. Add to that ptr gives us the next values stored after those, which are the values following them in their row. All this means is that you can easy get a one-dimensional array of a row in the multi-dimensional array, and then pass that to any function expecting an array. So, let's write our simple average function that takes an array: float average(int *arr, int len) { float avg = arr[0]; int i; for (i = 1; i &lt; len; i++) avg = (avg + (float)arr[i]) / 2; return avg; } That just does a simple floating-point average of an array of integers `len` entries long. The array is passed as a pointer (Though you could equivalently write the declaration like this: `float average(int arr[], int len)`, it doesn't actually make a difference, the pointer and empty `[]` mean the same thing for function arguments). We do the average by simply looping through every entry in the array, doing a 'running average' until we reach the end of the numbers. We can call it to get the average of any row of our above array like this: float row1avg = average(arr[0], 3); float row2avg = average(arr[1], 3); In your code, you would just use `input` instead of `arr`, and pass the row of `input` into the `average` function, with the return value being the average of that row of input.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Row-major order**](https://en.wikipedia.org/wiki/Row-major%20order): [](#sfw) --- &gt; &gt;In computing, __row-major order__ and __column-major order__ describe methods for arranging multidimensional [arrays](https://en.wikipedia.org/wiki/Array_data_structure) in linear storage such as [memory](https://en.wikipedia.org/wiki/RAM). &gt;The difference is simply that in row-major order, consecutive elements of the rows of the array are contiguous in memory; in column-major order, consecutive elements of the columns are contiguous. &gt;Array layout is critical for correctly passing arrays between programs written in different languages. It is also important for performance when traversing an array because accessing array elements that are contiguous in memory is usually faster than accessing elements which are not, due to [caching](https://en.wikipedia.org/wiki/Cache_(computing\)). In some media such as tape or [flash memory](https://en.wikipedia.org/wiki/Flash_memory), accessing sequentially is [orders of magnitude](https://en.wikipedia.org/wiki/Order_of_magnitude) faster than nonsequential access. &gt; --- ^Interesting: [^Array ^data ^structure](https://en.wikipedia.org/wiki/Array_data_structure) ^| [^Template ^Numerical ^Toolkit](https://en.wikipedia.org/wiki/Template_Numerical_Toolkit) ^| [^In-place ^matrix ^transposition](https://en.wikipedia.org/wiki/In-place_matrix_transposition) ^| [^Transpose](https://en.wikipedia.org/wiki/Transpose) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+crmjdqq) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+crmjdqq)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Wow! Thank you very much for this great insight.
to prevent it you can set sane limits either with ulimit or system wide with limits.conf. Bsd does these things ~~standard~~ out of the box and i don't get why linux doesn't.
What “does not work?” That's not an error description. What output do you expect and what do you receive instead. For your problem: Where do you set the variable `i`? What is the content of `i` at the point where you compare `ftext[i]` to `96`?
Use the shunting yard algorithm. It's simpler. Wikipedia has a complete description.
I don't think there is any difference beyond the cover letter between N1570 and ISO 9899:2011.
Your system is slow because it swaps like mad, not because your process gets high priority (it doesn't). Swapping takes time and when parts of the windowing system are swapped out you get an unresponsive user interface. I removed my swap partition to solve this problem.
I chose 96 so it would exclude other special characters. I tried a slight variation of the code with: http://pastebin.com/pau5xJk7 Teh output was: Please enter the text to be flipped: dakka dakka 12 flipped ## akka 12## Preflip ##dakka dakka 12## so it was closer but still a failure working on your suggestion as well for the algorithm on paper
Report when you find something! What I'm suggesting is that your comparison is the wrong way round.
This project has a fair amount of what I would consider major errors: * None of the header files guards * A linked list is not the right structure to hold a string!!!! If the string has to be of variable size, use a `malloc`ed buffer, and `realloc` it as you need. *Anything* but a linked list with one entry per char. As you've probably realized with your `ptr-&gt;next-&gt;next-&gt;next-&gt;next` code, it's very inconvient, and it's also very slow and not very memory efficent. * You treats arrays as though they are one entry longer then you declared them. `char buf[0]` is not valid AFAIK, and you could just as easily just declare a single char and take the address of it instead of declaring an array in this instance. Also, strings need to have the null terminator at the end, so `char tag[4]` can only validly hold a string of length 3 inside. * You shouldn't call `read` with a buffer size of 1, it's just going to be very slow. You're better off using a buffer size of say, 4096 (4K), checking the size report from `read`, and then adding the entire blob of read characters from the buffer into your big string. if you want to read `char`'s one byte at a time, try using something like `fgetc`, where you can use the `FILE` standard interface, which will do buffering for you. * Make sure your code is consistant in styling and general guidlines. Overall it's good, but there are some places where it get's a bit ugly. Also, in some places you cast the results of `malloc`, in others you don't. In general casting the result of `malloc` is considered a no-no for C, though others may disagree with me on that. * Your code appears to only work with a specefic set of strings that you provide to the log function for the log-level. You should probably just use an `enum` to provide integer values for your choices, pass that `enum` into your write-log, and use the `enum` value to index an array to get the correct strings from. You'll probably find this cleans up the code a lot as a bonus. That said, please don't be discouraged by my analysis - Everybody has stuff to learn, and every project has stuff to fix. I'm pointing these things out in the hope that you'll learn from them and that they'll be helpful to you.
I need to make sure that neither stext[a] or stext[b] is a number. If a is a number but b is not I need to leave b where it is but I need to put b somewhere else as it needs to be swapped, so then wouldn't I be ok to skip b not increment it and move on to the next set of letters so a new a but the same b as it was not a number. Please let me know if this is going down the right path or not. 
It's better, but still wrong. Where did you get the number 25 from? Think about what happens if stext[i] is 'z' and n is 1. What do you expect to get, and what does your calculation actually return. This also won't handle any upper case letters. It's up to you whether or not that's an issue.
See http://stackoverflow.com/questions/81656/where-do-i-find-the-current-c-or-c-standard-documents/ 
Well you did really I wasn't thinking from the right perspective on the problem, your suggestions did lead me to look at it in the right way. So while you didn't directly help you helped me get going on the right path. 
[C99 = N1256](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf) is the [SUSv4 POSIX Standard](https://en.wikipedia.org/wiki/Single_UNIX_Specification#2008:_POSIX:2008) language, NOT C12.
Well I'm new , yes i know that the macros which start from E are used by error.h but it slipped off from my mind as i'm not frequent .I'll try to fix all of them point by point Thanks a lot for descriptive review :) Cheers @FUZxxi 
No i'm not at all discouraged,that was great review i'll try to work on all points.Thanks @DSMan195276
Made some changes int b, c, d,sumap=0, sumai=0, maxp=a[0], minp=a[0], maxi=a[0], mini=a[0],i; srand(time(NULL)); for(i=0; i&lt;x; i++) { b= 1+ rand()%100; a[i]=b; printf("%i\t", a[i]); if(a[i]%2==0) { sumap+=a[i]; if(a[i]&gt;maxp) { maxp=a[i]; } if(a[i]&lt;minp) { minp=a[i]; } } if(a[i]%2!=0) { sumai+=a[i]; if(a[i]&gt;maxi) { maxi=a[i]; } if(a[i]&lt;mini) { mini=a[i]; } } } 
what?
Didn't know you could pre order it . . .
Something doesn't need to be *the* standard to be *a* standard. The word standard can mean something well-defined that can be use as a measure, and not just the "default" or most common pattern or construction. C11 comes from the same group that wrote previous versions and is indeed the latest official specification of the language.
Can anyone help me with simple equation without brackets? I'm stuck at the beginning :/
Does the document at the back of The C Programming Language, ANSI C, Second Edition (a.k.a. K&amp;R) count?
Well, you initialise it to a[0] (before a[0] is initialised even!), either initialise to first odd/even, or to INT_MIN, INT_MAX. You can also just use `else` instead of `if(a[i]%2!=0)`.
https://raw.githubusercontent.com/pragma-/pbot/master/modules/n1570.txt
Generally, you should not use variables of type `float` as `double` is to `float` as `int` is to `short` with respect to size expansion, that is, the machine does computations with `double` precision and rounds them down to `float` precision when writing the result. You should generally only use `float` variables if the space improvement is significant or if the loss of precision is negible. You should not use `long` by default as `int` is still the native integer type. Use `long` where you would use `long` otherwise. `main` always returns an `int`, declaring `main` to return a `long` is undefined behaviour.
Thanks you, this is exactly what I was looking for.
In my personal opinion (and this really is a matter of opinion): 1. Use fixed size integers wherever possible, except: * Use a size_t if you're describing the size of an object. * Use an intptr_t if you're converting to/from pointers * Use the type that an external API tells you to use (i.e., return an int from main) 2. Use a [u]int32_t for any number that will never get near a billion 3. Use a [u]int64_t for any number that will get near a billion 4. Use unsigned types in counters and cases where you need defined overflow behavior. 5. Otherwise, use signed types
General rule of thumb: using float when dealing graphics, since your human eye won't be able to see the difference. Use double with scientific computing, or anywhere precision actually matters. That's regardless of the platform. On x64 you'll have better performance with single precision, depending on what you're doing and how you're doing it. For example, my student intern's raytracer is 17% faster when switched to single precision mode (compile-time switch). Theoretically you can see up to a 100% speedup with single precision, since twice as many floats can be packed into a single x64 SSE register (SIMD) -- though compilers generally don't emit packed SSE instructions without help (intrinsics). Technically the same SIMD situation would apply to integers, but it's unusual to be using SIMD for lots of integer operations, so 32-bit integers are practically never going to be faster than 64-bit integers on x64. When it comes to integers, pick the size that suits the expected range of values, as others are saying. I use int64_t and uint64_t when I explicitly require a 64-bit int. Beware that `long` on Windows is still only 32 bits wide on x64. (Yes, it's stupid.) 
&gt; the machine does computations with double precision and rounds them down to float precision when writing the result. This isn't true on x64, where the old x87 instructions are no longer any practical use. Example: [sqrtss](http://x86.renejeschke.de/html/file_module_x86_id_301.html) vs. [sqrtsd](http://x86.renejeschke.de/html/file_module_x86_id_300.html) 
Where I work, we're either dealing with single board computers or network stuff. So the size of the integral types are limited to valid values.
In theory `int` is the native type, although some 64-bit systems still have `int` 32-bit.
There's definitely no reason to restrict your data types to "only" longs and doubles. By using the native size of the compiler I think you'll get the most consistent speed across platforms, but it might or might not be faster than using a smaller fixed size. On some machines, the memory bus can load multiple addresses in parallel, but again... that's all machine+compiler-dependent. My guess is that since these differences will typically be negligible for general-purpose programming, if you needed these incremental improvements enough that it was worth coding in a target-optimized way, you'd already know. If you happen to have a critical section of code that's doing heavy-duty stream processing it might be worth considering this again.
&gt; so 32-bit integers are practically never going to be faster than 64-bit integers on x64. Not quite. Notice that a 32-bit integer takes half as much space as a 64-bit integer, leading to improved cache usage.
&gt; So a 64bit machine deals with 64bit chunks as the minimum size. For this reason it is best to use int which tells the compiler to use the native size for the target CPU. This is not what `int` means. It is larger than (or equal in range to) a `short`, and smaller than (or equal in range to) a `long`, and capable of storing at least 0..65535 when unsigned. That's all. In practice, on x64 on all major platforms, `int` is 4 bytes, i.e. 32 bits, *not* 64 bits.
I thought I would comment the above code so you can understand it better. The key thing to remember is it includes a lot of conditionals, basically if were on Linux include this file, if were on Windows include this file. The reason is that sleeping requires some intervention from the OS and thus each OS provides a different method for achieving this. Any line beginning with a # is a pre-processor directive, basically instructions to the compiler. If we're on Linux the pre-processor recognises this and only includes the unistd.h header. #ifdef _gnu_linux__ //If Linux #include &lt;unistd.h&gt; //Use linux header that contains usleep #endif #ifdef _WIN32 //If Windows #include &lt;windows.h&gt; //Use Windows header that contains Sleep #endif #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; void mySleep(int sleepMs) { #ifdef __gnu_linux__ //Make sure we use the correct function usleep(sleepMs * 1000); // usleep takes sleep time in us (1 millionth of a second) #endif #ifdef _WIN32 Sleep(sleepMs); #endif } int main() { time_t seconds; seconds = time(NULL); int delay = 1000; while(1) { printf("Hours since January 1, 1970 = %ld\n", seconds/3600); mySleep(delay); } system("pause"); } 
I'd have to look at the standard, but I believe what C specifies is that the result should be the same as if it were computed with more precision and then converted, not how it's implemented.
&gt; I'd have to look at the standard, but I believe what C specifies is that the result should be the same as if it were computed with more precision and then converted, not how it's implemented. When you use a `float` as an operand to an arithmetic operator, it's converted into a `double`. This is not being undone until something forces a conversion back to `float`, like you assigning the result to a variable of type `float`. Thus, this expression: float a; /* ... */ float b = a * a * a; may have a different result then float a; /* ... */ b = a * a; b *= a; because in the latter case, the intermediate result is rounded to `float` while it's kept as a double former case.
Just a tip, instead of: system("pause"); use: getchar(); There is multiple reasons to use getchar() and it probably doesn't matter for you right now, but you might as well make it a habit.
This is usually so (at least AFAIK) you can have a type of each width. char = 8, short = 16, int = 32, long(Unix)/long long(Windows) = 64. I may be wrong.
Ah yes, I missed that one. I got confused because of the argument promotion rules where `float` arguments are promoted to `double`.
C is a great language to do something like this in. Not because it is the easiest language to do it in, but because it will teach you about what goes on that other languages do automatically for you. 
I see why you've opted for the slideshow format, however, it's quite large on my screen (1080p) which makes the flow of information slightly jarring.
A few things that might be misleading or confusing: &gt; C++ has mostly been superseded by Java This is liable to start a flame war. Regardless of the merits of C++ vs C, C++ is a very different beast from both Java and C. With similar zero-cost abstraction, native compilation, and deterministic memory management, C++ is very well suited to low-level projects that would otherwise use C. &gt; Duck typing/Weak typing vs Static typing It's very easy to confuse Duck (or dynamic) typing with weak or static typing. In fact, most computer scientists use two spectrums to roughly define typing systems: weak-strong and static-dynamic. Variables in Python and Ruby are dynamic, but the values themselves are very strongly typed, i.e. values will rarely change type unless the programmer specifies so. C, interestingly enough, is often categorized as a weakly typed language: it allows values to be reinterpreted, often in unsafe ways. For example `int x = 10; float y; memcpy(&amp;y, &amp;x, sizeof(float));` copies the memory contained in `x` bit-for-bit as a float without any type conversion. Finally, you really should give a basic primer on structs. As minimalistic C is, a basic understanding of creating new data types is indispensable in developing software in the language.
On the technical mistakes, shouldn't you copy instead of assign the string after mallocing space? (Slide 38) 
Dang, I should have remembered floats get trucated. Yep, that description of pointers is clearer. I'll use that :) Oooohhhhh, I was fuzzy on that before, thanks for clearing that up :D
&gt; In c a literal string is a const char * It's actually only const in C++. The memory backing it can't be modified, but the type doesn't reflect that in C.
&gt; Don't perform those computations. Or, if you need to, that's a compelling reason to use a signed integer. You often don't know when you're going to perform such computations and sometimes you try to do so and they silently return wrong results because you forgot that the type was unsigned. It's often not easy to see which computations may involve negative numbers (for example, see the loop I postet). The compiler can some times warn you about this but that doesn't always happen. &gt; In your example of the age, how often do we care that the difference between a 30 year old and a 35 year old is technically -5 years? Usually we only care about the absolute value of the difference, which doesn't require negative numbers. Of course a signed difference is super useful. For example, we could switch on that signed difference to do different things depending on that age difference. This is so important that C has a special case in the `-` operator: subtracting two pointers yields a (signed) `ptrdiff_t`, whereas the numeric type for pointers is an `uintptr_t`. &gt; There's a well established C idiom for this: [...] Problem solved. That's horrible code which wouldn't get through code-review (if I were to do it) because it perverts the conventions of a for-loop and because it's not valid C89. Again, I didn't say it's not possible to write that loop, I just said it's going to look uggly and the obvious way doesn't work, which is something the programmer needs to recognize. &gt; Depending on what you mean by "fail" this isn't true: When a TCP socket is closed gracefully write operations will succeed and write 0 bytes, which signals end of stream. That's a fair point. I forgot about that case. &gt; The domain of ages is strictly positive, why would you choose a type that can uselessly represent negative values to hold it? I've already explained it in the parent comment: An age itself may not be negative but computations you do on ages may involve negative values, so it's a good idea to make these computations possible. &gt; It's the same (and even more compelling) for sizes. size_t is unsigned, and yet I see C/C++ code where people use int instead constantly. POSIX has `ssize_t` for precisely that reason.
Ahh, you're right. That was silly of me.
&gt;you forgot that the type was unsigned I don't really see how this is a convincing argument. I could equally make an argument against signed types by saying that you might overflow them and invoke UB instead of well-defined behaviour because you forgot you were using a signed type. If a programmer is incapable of comprehending the program and types at play it indicates either poor code or a poor programmer. &gt;This is so important that C has a special case in the - operator: subtracting two pointers yields a (signed) `ptrdiff_t` Which, as far as I'm concerned, is a flaw in C: What happens when you try and get the distance between two pointers which are further apart than `PTRDIFF_MAX`? &gt;If an array is so large (greater than `PTRDIFF_MAX` elements, but less than `SIZE_MAX` bytes), that the difference between two pointers may not be representable as `std::ptrdiff_t`, the result of subtracting two such pointers is undefined. Wonderful. &gt;it perverts the conventions of a for-loop Then refactor it into a `while` loop. &gt;it's not valid C89 What year is it? &gt;POSIX has `ssize_t` for precisely that reason. Which, unlike `size_t` cannot represent all sizes. Adding signedness to a nice, neat, unsigned guarantee just makes it messy: `size_t` can represent any size, `ssize_t` can't. Pointers can point anywhere in memory (being at least conceptually of unsigned type `uintptr_t`) but the difference between them, being signed, can't represent the difference between arbitrary pointers. Ultimately, when it comes to sizes, using signed types involves a lot of "*that will never happen*", and the history of programming is so littered with examples of things that would "*never happen*" but somehow did that you'd think people would know better.
That code is incorrect since x should be an `int *`. Just make y an `int *` and set it equal to x. int *x = malloc(sizeof(int)); int *y = x; *x = 5; /* *y also equals 5 */
oh yeah good point ! :)
The error means that your program is linked against the shared/dynamic version of the libgcc runtime library, but that library cannot be located by the operating system when the executable is run. The operating system uses PATH (among other things) to locate dynamic libraries, and generally speaking this problem should be solved by putting the directory that contains that DLL in the PATH. (It can also be solved by putting the DLL in the same directory as the executable, but obviously that would be stupid in this case because you'd have to be constantly making copies of it for every project.) Is that directory in your PATH? If so, you should check the value of PATH that Eclipse is using when it runs the program, because it could be modifying the PATH and removing essential components. (Remember that environment variables are inherited from parent to child.) If not, you need to modify your PATH and re-start Eclipse. You can also link against the static version of that library by adding `-static-libgcc` to your link command. 
How would I do that? I've done it before, but I've always had the location of the file and the PATH it needed to be added to
I'm giving this post an upvote for visibility and also adding some of my own thoughts. I'd keep the mentions of game programming out. Saying "this is good for game programming" is playing with fire, especially with beginners. Game programming isn't a language thing; it's a framework thing. Python isn't good for game programming. C++ isn't good for game programming. Java isn't good for game programming. SDL is, CryEngine is, and ProprietaryScriptLangForACommercialProduct is. I'd recommend something along these lines: Many of the features that C++ offers are provided by other languages in a less complicated way which makes it easier to take advantage of those features. C++ does have its uses, but it isn't a good idea to try to learn it early on until you fully understand its use case. The second part could use a bit of polish, but I think that this is overall more fair and accurate. Telling people "learn C good, learn C++ bad" is always a hard task since it's difficult to explain why understanding C (which makes you understand the machine) is important but C++ is not, even though C++ is the "bigger" (misinterpreted as better) language.
Something to look at to help make these very polished, but apparently it is actually [Very Very Bad Practice to typedef a struct (second answer)](https://stackoverflow.com/questions/252780/why-should-we-typedef-a-struct-so-often-in-c). I'm not 100% familiar with the rationale, but it might be worth addressing. Excellent slides!
I would very much prefer to read a normal text. I actually couldn't provide any feedback because I couldn't stand trying to read through it in such an unnatural format. Slides are for public presentations where multiple listeners far from the screen need something to look at that collects and reinforces what the speaker said in the last minute. 
Slide 17 memory leak. You malloc memory and then throw it away. images *cats = malloc(sizeof(cat_image) * NUMBER_OF_CATS_ON_IMGUR); cats = get_all_teh_images_on_imgur(); // now, we can actually get the images process_images(cats); As others have pointed out, memory leaks on your resize_str in the other slides as well. As for your C++ slide, I would not recommend... having it. Arguably, if you program in modern C++ (no raw pointers, stuff typically on the stack, RAII), you produce programs that are infinitely easier to reason about than similar ones in C. Case in point, while I don't know if C++ would have helped you, in every slide that you malloc memory, you have a memory leak. Another nit point, interpreted v compiled aren't necessary language features, more of implementation details. See [1](http://en.wikipedia.org/wiki/Ch_%28computer_programming%29), [2](http://cython.org/). 
&gt; If so, you should check the value of PATH that Eclipse is using when it runs the program, because it could be modifying the PATH and removing essential components. 
what is a string builder object?
Java strings are immutable. So to efficiently build a large string from multiple parts, without constantly allocating new strings, you have string builders. It allows you to append a large amount of strings in one buffer, and to preallocate the necessary space. Without a string builder, you'd have to allocate a new immutable string each time you append two strings.
It's not just Java. C# has Stringbuilder, as does many other languages.
It's not just Java. C# has Stringbuilder, as does many other languages.
Thanks! I'll be sure to correct those points.
Thanks! :D
haha, thanks :D
Obligatory do not ever ever ever ever ever ever use gets(). It has no acceptable uses under any possible circumstances. `fgets(s, sizeof s, stdin);` is what you want instead of `gets(s);` (Actually, your compiler should be giving you a warning if you ever try to use `gets`) Your program definitely gives output. You only have two errors beyond `gets`: (1) your for loop should be testing for `&lt;`, not `&lt;=`; and (2) you should be printing spaces between each number. Beyond that, it works well, though. Why do you think it's not producing output? Where are you looking for the output?
&gt; Do you think the math curriculum should be redone to go straight into using a calculator and Excel to "solve problems"? We have so many great tools to calculate water pressure, electrical current, distances, etc. Let's just drop those low level details and get straight to SOLVING PROBLEMS! WOOOOO! Math isn't taught at the lowest level. The first thing a pre-schooler learns is counting (which uses integers and addition by 1). They probably don't even know what a number is. They don't learn learn the concept of integers, decimals, fractions or imaginary numbers. Also, a calculator isn't a form of higher level math. It's automation of lower level math. People learn in terms of language. A baby doesn't learn the alphabet first, then learn all the different phonics of the English language. They say words, and learn from the reactions of people around them. They map the abstract concept of a word to the physical world. You could try to teach a baby language at a low level, but they wouldn't learn. Once they do learn to speak, they can appreciate how language works at a low level, but that's not what should be taught first. &gt; You just seem upset that the student cannot skip straight to producing web pages, graphics, sounds, network connections, database connections, etc That's not the problem. The problem is that C - as a low level language - looks like machine code. Ruby looks like math. Math is a form of logic. And thinking logically (as we agreed) is the important part of programming. An advanced programmer will be able to think like a machine, because they have learned how machines operate. A beginner doesn't need to think that way (at least, not immediately). &gt; The garbage collector isn't magic and has a real cost associated with it. Yes, but a beginner, who's writing a simple script to count the occurrences of a word in a text file, doesn't care. They don't care that, under the hood, a string concatenation takes multiple operations. They are simple operations that can be automated, rather than explicitly spelled out. If Ruby does a good enough job of it, why should they care?
I've just run it myself and it's worked. Your code lacks some newline characters and repeats the last number twice though. But it works. You may want to define your string size with a constant defined with #define. It's more convenient.
When I try to read the file it gives me the error for null. the file name is nums.dat, but it does not seem to find it. 
Why don't you post a screenshot of that error, there shouldn't be an issue opening that file if it exists.
the error is just the one I have written in the code if the file cant be opened. 
I think the problem here is that high level languages highly resemble logic blocks used in algorithms and have zero resemblance to a computer program. Low level languages highly resemble computer programs and have zero resemblance to the logic blocks used in algorithms. You guys haven't agreed on which discipline's fundamentals you're talking about.
I'm a little unsure what you're getting at here. &gt; I was wondering if I could have a Data union that includes different data types of the same size (i.e. a char array, a float, etc.) Remember if multiple datatypes need to be put into a stack, you'd have to create a stack for each data type, since a union only allows a single datatype to be used. You basically answered your question yourself. From my point of view, I am not sure why I'd use a generic stack (although I am sure there are some reasons), but yes. You should be good!
A common problem I've found on Visual Studio, although may apply to other IDEs: If you're on a network drive and you start the programme without debugging, it starts in a default location, not in the folder with your data file. If this is the case try running with the debugger so that your IDE runs the programme and can do relative paths for you.
I implemented a stack well enough, but the fact that I can use it with only one data type (e.g. `int`) bugged me - I was just thinking if there was a simple-ish way to write it to be able to contain multiple different data types (e.g. an `int` and a `char *`)
&gt; Math isn't taught at the lowest level. The first thing a pre-schooler learns is counting (which uses integers and addition by 1). They probably don't even know what a number is. They don't learn learn the concept of integers, decimals, fractions or imaginary numbers. Neither is C the lowest level of programming. It blows way past transistors, memory state, and kernel development. Every compiler is custom built to emit machine instructions of a given architecture. The C/C++ standard libraries are cross-platform and allow high level development. &gt; Also, a calculator isn't a form of higher level math. It's automation of lower level math. Then Ruby isn't a higher level of programming. It's automation of lower level programming. :3 (Oh, for crying out loud, I'm kidding, people. Don't rage downvote.) My point is that as people move into more advanced aspects of mathematics, they indeed start taking advantage of tools and automating the mundane aspects to achieve more output. Professionals don't hand-calculate the sin of 47 degrees, but they certainly understand what goes into that if a technical aspect called for it (or a modified version thereof). &gt; Yes, but a beginner, who's writing a simple script to count the occurrences of a word in a text file, doesn't care. They don't care that, under the hood, a string concatenation takes multiple operations. They are simple operations that can be automated, rather than explicitly spelled out. If Ruby does a good enough job of it, why should they care? If a beginner knows from the outset he or she will be living in high level languages (web development, script language backend development, etc.), fine, they can learn using high level languages. I was never opposed to that. I only oppose your opposition to learning C as a first language if someone so chooses. There is great value in doing so, and it does not hinder the person's potential one bit.
Unions serve 2 purposes I can think of off the top of my head: 1) Allows for strongly-typing variant data types. 2) Allows for fixed size framing of the variant data types. The first is more a convenience to avoid casts; the second can be critical to certain types of loosely-coupled communication schemes.
I'm trying to make is so that when \t is read from the file, I can replace the output with something else. In the code above it should be when \t is read from the file the code will output "there is a tab!".
Yes, thank you for not devolving into an Internet rage monster of the depths. =]