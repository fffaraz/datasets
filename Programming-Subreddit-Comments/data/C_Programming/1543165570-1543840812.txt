a and &amp;a have the same value but different types. `a` is an array of 6 ints. `a` passed to a function decays to a pointer to its first element. So the decayed type of `a` is `int&amp;` `&amp;a` has type `int (*)[6]` - pointer to array of 6 int Use `a` for your program.
I may be wrong on this, but since you've declared your array functions as void arrayFunc(int *p, int n); It takes a pointer. Now, *a* is not a pointer, it's an array. So what you should be doing is calling the function with an actual pointer, like this: int a[]= {5,4,3,6,7,8}; arrayFunc(&amp;a[0], 6); If you don't like this and want to actually pass an array, then you should declare your array function as void arrayFunc(int p[6], int n); Got it? So `&amp;a[0]` gives you a pointer to the first element in an array. But you can also just pass the array itself. C will let you pass an array as a pointer, but I remember reading that this was not recommended and if you compile with `-Wall -pedantic`, your compiler may give you shit about it. Maybe try it out?
`a` is an array, not a pointer.
&gt; Second call is passing a pointer to the address of the first index of the array. ** This 2nd sentence isn't correct. `&amp;a` is the address of the array. Not a pointer to a pointer; there is no pointer to point to.
Yeah "new". As in circa 1978 for the first edition and 1989 for this one, IIRC. New as in New Testament if you wish.
You can do either of int main(int argc, char *argv[]) { int size = 99; // get this from the user.. int array[size]; for(size_t i = 0; i &lt; size; ++i) { array[i] = 0; // set to whatever } } Or int main(int argc, char *argv[]) { int size = 99; // get this from the user.. int *array = malloc(99 * sizeof(int)); for(size_t i = 0; i &lt; size; ++i) { array[i] = 0; // set to whatever } } The latter is more robust, because you can cause a stack overflow with a large *variable-length array* as in the first example. 
Actually both the outputs are same .
It depends on who is going to use your library. You could keep your earlier return status convention by having the functions you just wrote set their result through a pointer passed into the function. That would allow the function itself to return an error code. &amp;#x200B; &lt;p class='example'&gt; int foo(int param, int *result){ *result = param; return SUCCESS; } int result=0; error_val = foo(12, &amp;result); &lt;/p&gt;
My understanding is passing a to the function devolves to a pointer (*a) to the address of the first element of the array (i.e. &amp;a[0]). &amp;a is the address to the address of a[0] (i.e. **a). 
`a` does decay, but that doesn't mean that somewhere there's a pointer pointing at a[0] `&amp;a`, when a is an array, is the address of the array. 
If you were in `arrayFunc`, then yes you could take the address of p. This is a local variable in the function; it's address is not related to the address of `a`
Thanks for the thorough review, you have a good eye. All solid points and I’ll try to address them (you’ve motivated me to make the VM bullet-proof!), the only one I don’t understand is #5. How is it possible to cause numeric overflow in the stack? Re: (1), I stripped out the sanity tests for registry-related stuff because it was tedious to write error-handling for all of the instructions. I guess it was a sign that the validation should have gone outside the instructions, since it was common to all of them.
I taught myself C from a borrowed copy of the pre-ANSI K&amp;R. When I bought my own copy, it was the ANSI version. My son is now using my copy for his college C class.
Interesting. So it's a matter of context: Consider this:- char arrayA[10]; char *arrayB; &amp;arrayA[0] and &amp;arrayB[0] both have type char *. But &amp;arrayA has type char (*)[10] while &amp;arrayB has type char ** - the address of the pointer. For arrayA, these point to the same address - but for arrayB, they do not! 
You can accomplish most tasks with almost any modern programming language. C is a tool like any other language and there are situations where it is the best option, and there are times when another language is a better choice. In C you will have to code a lot of things for yourself where other languages have libraries available. The advantage to this is you can modify the algorithms to work more efficiently for the specific task you have in mind, whereas with a prebuilt library you work with the functions as they come. It's not the scale of the program that defines whether C is a good fit but what it will be doing that matters.
Does yours have an index entry for squirrel on page 78? The first edition did.
I tried that but it didn't seem to work.
I tried this using a variable for example n. And I got segmentation fault 11 in the program.
I'd probably choose C++ for large scale projects if it is not on a low level, it just gives you more tools that you might or might not use while being able to generate code that runs just as fast. I only use C when i have to go low level where C++ is not available or with really really limited resources where i need to keep an eye on everything. My experience with C and C++ is a bit different i usually can find a library that does what i want - but they are harder to find and not as well documented as i would like. I think this is the big point where C has to catch up, making libraries easy to find and easy to use by good documentation and not just some shitty automated doxygen site, which is better than nothing but having this makes most people lazy and not write a well written document with nice examples. I think this is where python really shines making things accessible by proving lots of good documentation and examples. But especially for big projects (i guess you have to define big first) C++ is a great choice because it will run fast. Nothing worse than finishing a big project and noticing that it lacks performance and wishing you could redo it all in C++ but now that you've produced all that code there's no going back. 
Yes, because the ints that make up `a` are right there. There's just 10 ints in a row in the stack frame for the function. But the ints that b points at are somewhere else. There is a real pointer in the stack frame. And that pointer can point to 10 integers (on the heap say, if b was initialised with a call to malloc)
&gt; For a quick concrete program, is C well suited ? What do you mean by quick? Concrete? C can be used for anything, but it tends to take longer to set up things that higher level languages take for granted. Creating complex systems requires more leg work. Making them secure, even more so. &gt; Why doesn't it have a lot of libraries such as in Python ? It does. It has a huge amount of libraries, there's just not as many centralized repositories nor is there as much consensus on best practices. `pip` makes things really easy insofar as Python libraries are concerned. The closest thing in C is a package manager in a Linux repository, and those vary from distribution to distribution. Part of the problem is that C gives you so much control most people end up making their own solutions in order to ensure that they eek out as much performance as possible. In order to find what you need you'll have to do some serious research, but sometimes it's just easier to make something you know will work. &gt; Will I have to code all that by myself ? If you're working in pure C, then likely yes. You may not realize it but you're in an excellent position with the languages you know. It's not uncommon for people to lay a quick foundation in Python, to get a working prototype up, that they can then later extend in C or C++ in order to achieve some performance gains. The important thing to understand is how to profile your Python to know where you need to write some lower level code. Please let me know if I haven't been clear or if you have more questions.
I understand perfectly but I really don't like C++. I prefer C
Yep, that's a picture of a book all right.
Yep, you are cool all right
Actually C Code, that header is supposed to confuse you. Also, have you looked at the code? It's purposely full of bugs, and incorrect syntax example: menu(;) This numM(is){bad 1. case Dog: 2. string(pupper); 3. break; 4. case Cat: 5. return meow; 6. numM(); 7. break; 8. case Cow: 9. game(hmm); Well anyways I'll probably just ask for this post to be deleted since no one is interested and think is a "trap" lmao. 
Correct and Incorrect. But very well, I'll remember this isn't the place to find this stuff. A lot of people who are trying to learn C go on this reddit and I figured this would be a fun challenge to work on, but I guess its some sort of trap?
You don't notice the printf statements either? I don't think your in a position to differentiate between C and C++ code. Almost all of the syntax is in C. Theres actually a line of Java syntax in there as well to confuse you. 
Excellent. Finally making sense to me now. Thank you! 
We get lots of requests for help with homework from people, who want us to solve problems for them. That's why we are very suspicious. If you have an idea like above, provide the solution with it. That way we'll know you are not trying to dupe us and beginners can verify their results. 
Very well, I will add the output
mine says it's "Based on Draft Proposed ANSI C"
Not the output. The code :)
High Five !, Data Oriented Development
I have a deitel book "How to program - C". Would you guys compare it please? Should I switch to this book ? I'm learning arrays atm. 
HAHHAHAHA, wow, I returned my copy to the library last semester, I really enjoyed
That was sharp. Demonstration, if you allow: int a[6]; printf("a + 1 = %p\n", a + 1); printf("&amp;a + 1 = %p\n", &amp;a + 1); printf("&amp;a[6] = %p\n", &amp;a[6]); a + 1 = 0xbfbfe970 &amp;a + 1 = 0xbfbfe984 &amp;a[6] = 0xbfbfe984 The hex number is not important, depends on system, but it's visible that although a and &amp;a are the same numerically, type is not.
put the game code into a function. then in main have a while loop that calls the game function, and asks if the user wants to play again. If the users response is no, exit the loop with break and end the program.
If you are a newbie go with deitel 
ty for your response i also thought about that but the while loops are diferent is it still possible to do that?
While loops work similarly to for loop, they just don't have a variable declaration or incrementationn built in. They require you to initialise the variable before the loop, and update the variable inside the loop. Any for loop can be implemented as a while loop and vice versa. For example: &amp;#x200B; for(int i = 0; i &lt; 10, i++){} &amp;#x200B; would become &amp;#x200B; int i = 0; while(i&lt;10){ i++; } &amp;#x200B; For your game you can create a variable and set it to 1, and have a while loop that checks if the value is 1. Then when you ask the payer if they want to play again if the answer is no you can update the variable to 0, and the loop will end.
Yes. Thank you!
We called that edition "The Old Testament". The above is "The New Testament".
I mean, I absolutely don't get why anybody would be interested in this. It's uninteresting, broken code that is pure cancer due to its lack of formatting, comments, and correctness.
Reading it right now. Amazing book and I love the mentions of the old way if defining functions. History lessons like that always amaze me as I'm quite new, still, to the world of software development.
Then welcome to the brotherhood 
in the base there isn't a lot of change if you talk about changes like scanf_s etc. , anyone can learn this things with a little effort. This book is not for the people give me all of your information. We read it for the enjoy. Programming books shouldn't teach us technologies they should teach us how we should think and this book do that really good. I really missed good old days.
Correct me if I'm wrong, but I believe C does not allow you to create arrays with a variable amount of members, so the first example shouldn't be compileable ?
Post your code along with what a description of what you're trying to do. No offense, but this sounds like a "do my homework for me" type of question.
Ah, yes. You can't spell "krusty" without K and R. Here's my copy (same edition) with some other essentials from that time period. https://i.imgur.com/xhRuwAi.jpg It's one of less than 15 books I keep on the shelf over my desk instead of in the library. (For anyone wondering about this strange collection, I write DOS games in addition to my day job.) Some say it's the only C book you'll ever need. I do recommend that if you're new to C that you read it cover to cover, even it not all of it makes total sense. It will start to gel when you're coding, then you can refer back to it. Once you've read it, though, I suggest you immediately read [21st Century C](https://smile.amazon.com/21st-Century-Tips-New-School/dp/1491903899/ref=sr_1_1?ie=UTF8&amp;qid=1543187364&amp;sr=8-1&amp;keywords=21+century+C) by Ben Klemens. I wish I had done that initially, it could have saved me a lot of pain. Klemens goes into a lot of detail about the things you do and do not need to care about when writing C _now_, rather than when the K&amp;R was written. And beyond the bare information, it's actually a pretty entertaining read. Keep both books near you when you code, they're invaluable.
I just log errors to a user specified file if it was entered, or stderr.
Thanks for letting us about Synacor Challenge, it looks quite interesting! I've just implemented my own version of VM: [vm.c](https://github.com/sphynx/c/blob/master/synacor-challenge/vm.c) I'm also learning C last couple of weeks, so would be glad to hear any feedback :) BTW, I'm also enjoying doing [Crypto challenges](http://cryptopals.com/) in C, check them out if you haven't, they are quite cool. &amp;#x200B; &amp;#x200B;
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [sphynx/c/.../**vm.c** (master → 026e6e1)](https://github.com/sphynx/c/blob/026e6e1ed881feaa0b59fa18b56137fea5885dac/synacor-challenge/vm.c) ---- 
Wow, that's a nice and thorough review, many points apply to my version as well :) Thank you!
Your fscanf needs to be fscanf(fileptr, "%s%d%d", Info\[i\].name, &amp;Info\[i\].id,&amp; Info\[i\].grade);
[My first edition](https://i.imgur.com/RPBrUGz.jpg) along with a second edition The Elements of Programming Style, another Kernighan book that still has some relevanant words of wisdom. Both bought new when in college. If you give a quick look at [the contents of Elements on wikipedia](https://en.wikipedia.org/wiki/The_Elements_of_Programming_Style#Lessons) you can see it offers some solid advice coming from a time decades before the invention of many of today's languages. If you want to complete what I consider the Kernighan trifecta also pick up a copy of [The Practice of Programming](https://amazon.com/Practice-Programming-Addison-Wesley-Professional-Computing/dp/020161586X) The practice is a bit newer being penned in 1999 while C and Elements were published in 78 and 74. True to Kernighan's concise style, all three books are very short and to the point. 
Thank you for sharing!
The Elements of Programming Style, by Brian W. Kernighan and P. J. Plauger, is a study of programming style, advocating the notion that computer programs should be written not only to satisfy the compiler or personal programming "style", but also for "readability" by humans, specifically software maintenance engineers, programmers and technical writers. It was originally published in 1974.
Are you trying to teach C or are you trying to teach C++? The two languages are quite different and treating them as the same is a futile endeavour. 
Well, the class is Intro to C but we’ve been using mostly c++ programs with a few C programs sprinkled in to emphasize certain aspects of both languages. 
That is a really weird way of teaching either language. The way you actually write programs differs extremely between the two languages and teaching both at the same time is a really bad idea. I strongly recommend you to stick to one of C and C++ for the time being and to get yourself a good book on the subject. Then, work through the book and do all the exercises. This step is crucial to your success. You might as well not read the book if you don't do any exercises.
Oh yeah? I bought one used without ANSI, says `Based on Draft-Proposed ANSI C`
Made me laugh.
TAoCP is more a general computer science Bible. This is the C Bible.
Mine says page 131. The book cost $22.50 copyright 1978 but I didn't buy it till 1985.
Mine doesn't. Mine has nothing about Ansi at all. Purchased in 1985, first edition.
I once had a project where we had to use lists to store PGM (I think?) files in memory instead of an array, which would actually have made sense.
If you need the crossplatform support - then yes, you need autotools. If not - then not.
Well now I'm just curioua to see it. Could you link a pic or smth?
It's not a tutorial per se, but maybe some live examples might be helpful. Hackerrank is pretty neat: https://www.hackerrank.com/domains/c
Thank you
https://imgur.com/a/6ReOPyI
The `%d` format specifier is for `int` or anything promoted to it in the process of passing varargs. `test` is a `double`, and should use `%f`; you’re exhibiting undefined behavior.
Same, I've got a little Log module that I include in the rest of the libraries' source code to do that...
The project says word by word to search for code on the internet and come up with a solution, i was able to do a simple linear predictor, beyond that i'm lost
I hope your professor fails you. You couldnt even post a "Do my homework pls" thread on the right subreddit.
&gt; the only one I don’t understand is #5. How is it possible to cause numeric overflow in the stack? Well, this is going to get more than a little tedious. Here's `stack_push()`: // STACK_GROWTH_MULTIPLIER: 2 // stack-&gt;num_elements, stack-&gt;capacity: size_t objects StackOpStatus stack_push(unsigned short value) { if (stack-&gt;num_elements == stack-&gt;capacity) { size_t new_capacity = STACK_GROWTH_MULTIPLIER * stack-&gt;capacity; stack-&gt;elements = realloc(stack-&gt;elements, new_capacity * sizeof *(stack-&gt;elements)); if (stack-&gt;elements == NULL) { return StackOverflowError; } stack-&gt;capacity = new_capacity; } stack-&gt;elements[stack-&gt;num_elements++] = value; return StackOpSuccess; } The first thing to note is that the VM's instruction set is complete enough that you can call `stack_push()` an arbitrary number of times via a single push instruction and conditional branching. The second thing to note is that 32-bit systems commonly have a size_t that's 32 bits wide. Moreover, many 32-bit systems happily service dynamic requests for 2GB of memory (on POSIX systems, this is usually a result of generous defaults for process limits or misconceptions about which limits do what, such as about the usefulness of RLIMIT_DATA with an `mmap()`-backed allocator). On such a system, with the usual 16-bit unsigned shorts, an allocation of 2GB, or 2147483648 bytes, represents a `stack-&gt;capacity` value of 2147483648 / sizeof(unsigned short) == 1073741824. To show that `stack-&gt;capacity` can become 1073741824, consider that its initial value is INITIAL_CAPACITY, or 8, and that 1073741824 == 8 * 2^27. With `stack-&gt;capacity` set to 1073741824 and the stack fully populated, the next call to `stack_push()` will set `new_capacity` to 2 * 1073741824 == 2147483648, and this will cause a `realloc()` request for 2147483648 * 2 == 4294967296 == (size_t)0 bytes (because 4294967296 undergoes a 2**32 modular reduction on the system in question). What happens with `realloc(stack-&gt;elements, 0)` depends on the allocator and its configuration. Some allocators will return NULL (with or without freeing the memory pointed to by `stack-&gt;elements`), and then you're fine. But other allocators will return a pointer you're not supposed to use for an object access, and typically this will be a pointer to a small object. `stack-&gt;elements[stack-&gt;num_elements++] = value` is then the first instance of memory corruption, with `stack-&gt;num_elements` still set to 1073741824. Subsequent pushes will continue the corruption. &gt;Re: #1, I stripped out the sanity tests for registry-related stuff because it was tedious to write error-handling for all of the instructions. I guess it was a sign that the validation should have gone outside the instructions, since it was common to all of them. Yes, it's easier to centralize the sanity checks within `set_reg()`. Otherwise, you'll be dealing with convoluted headaches like `in()`, where `read_input_char()` can return a large unsigned short on systems with a signed char. If you know that the registers have sane values, it's easy to skim through a whole lot of code with assurances.
You can utilize any pointer ya see but ya better not point out the boundaryyy
My old mentor lent me his original copy, purely so I could copy the notes he wrote in his (things he’d figured out, after going back to x section). Super helpful. My ANSI version is filled with similar.
Start your project using what you've learned from class, then post your code when you hit a wall. To approach the project, you need to: 1. Use proper syntax for a C program, and make sure it compiles. Make a simple Hello World project for this. 2. Modify your program to take a user input. scanf() might help you with this. Learn what scanf does by reading the man pages. (Ie `man scanf` in the terminal) 3. Save that input as a variable, and perform the appropriate computations. 4. Display the output to the user in some way. print() is good for this. Read the man pages to figure out how to use printf. 5. Repeat the whole process until the savings reaches the value you've indicated. This is probably best done by wrapping all of the logic above in a while loop, that uses a comparison operator (ie &gt;= or something) Honestly, the best way to learn to program is to figure out how to do each of these steps yourself, using your curriculum as guidance. Look at examples your teacher provides you, and extrapolate. Use the steps above as a guide. Make sure the code compiles and does what you expect it to do before moving onto the next step.
i've not actually downvoted you, but please read https://idownvotedbecau.se/noattempt/.
I love this.
&gt; global variables, if left undefined when declared, have a default value of 0 That is not true. Only static variables default to 0, the scope doesn't matter.
H/t to /u/FUZxxl for introducing me to that site. :-) 
I pondered this problem for years before coming up with my current solution. I decided I didn't want to tinker with the Standard C Library's error handling, so created my own, which mimics it. I created a small number of error-handling routines in my C library (all in one file) that set an exception code (0 or -1) and message supplied by the caller, which are the other library functions. I have a global variable which holds a `struct` that contains the code, flags, and message, the latter of which is allocated from the heap by the exception functions. These functions can save an errno message via `strerror()` or a custom message from a library routine that can be a simple string, or be built with `vasprintf()`. So if a library routine needs to return an exception, it does this (for example): `return emsg(-1,"...exception message...");`, which sets a message and returns -1 to the caller. Then the caller (your main program) can "bail out" by calling another function called `excep()` to print the stored exception message to standard error and return a non-zero code to the shell, similar to `perror()`. This has worked well for me. Now I always write my library routines to use the exception-handling functions so it's all done in one place (like the Standard C Library functions). Then a program using a library function can for example, print a warning and continue, print an error message and stop (both via the `excep()` function), or simply ignore an exception. It decides what the severity of the exception is and what action to take.
You haven't given us much to go on. What does the data look like? If it's a raw time series, I would suggest treating it as audio, and using [FLAC](https://xiph.org/flac/index.html).
I understand. I'm sorry.
&gt; Correct me if I'm wrong So-called "variable-length arrays" were introduced in C99, but made optional in C11. Some C implementations may never have implemented them at all.
This is an unhelpful and misleading answer for a multitude of reasons. First, the term "static" and the keyword `static` are so overloaded in C programming that a beginner won't even know where to begin unpacking your remark — it's only comprehensible to people who already know what it means. Second, you strongly give off the (incorrect) impression that OP's belief about global initialization is wrong. You are right — it has nothing to do with scope and everything to do with storage duration — but, seeing as how *every global variable has static storage duration* ^(or thread-local, which is initialized the same as static, but even this is not something OP has likely encountered yet), I think it is safe to skip the pedantry, since it doesn't help OP, who doesn't know what storage duration is at this point in their education.
I'm going to take your word for it. Mine has been in a box in the basement for about four years, so I probably misremembered the page number.
 terr_line[strlen(terr_line)] = \0; or, since you know the size. terr_line[size] = \0; I can’t remember if the compiler will have issues with the null byte not being surrounded by apostrophes, but if you run into trouble try ‘\0’ instead. Same format for the second string.
Thanks a lot! I had to use '\\0' but it's working fine, now I have to debug the rest!
So, what this is doing is telling the compiler that you want to chop off the last character in the c-string and terminate it there. For example, you have the string `|'f'|'o'|'o'|'.'|'t'|'x'|'t'|'\n'|'\0'|` or `foo.txt\n` This will take your input and place the null byte at the strlen position, changing the string to be `|'f'|'o'|'o'|'.'|'t'|'x'|'t'|'\0'|` I'm sure someone else can explain it better, but that's the basic idea.
Good luck!
Hi there, it is very hard for us to figure out what you mean. C is a programing language and there are atleast 100 solutions for a problem like the one you formulated. I would like to help you, but you have to elaborate your problem a bit so i can understand what you are supposed to do. Are you supposed to work with c alone or are you working in some form of a framework? &amp;#x200B; greetings gespel
What industry ?
Everything here in the US is nothing but Python, Java, Json, C#. Even that new game engine by Amazon is being converted to Python. The open source community is quickly replacing many subsystems with Python. The banks are switching to it on top of multiple articles claiming C/C++ will be dead in the next 5 years. From I am seeing Python is clearly on its way to being king of the languages. Personally I am a C/C++ guy but I have accepted I will probably never land a programming gig ever.
Well, *size* already is your variable. Works perfectly fine for me.
Most compilers you'd use (GCC, clang) support them. The Linux kernel has recently been [purged of most VLA uses](https://www.phoronix.com/scan.php?page=news_item&amp;px=Linux-Kills-The-VLA) because they do have some downsides.
Actually i am not a newbie to the world of computer science. I have learned c when i was in high school just because of my personal interest on computers. I know the computers are becoming much much fasters day by day but i don't think that progress on hardware can close the difference of memory usage and the speed, between c and python. Yes i know the hardware technology developed so much and so speedly but also our programs are becoming much larger. So i believe that the usage percentage of c will go down year by year but for the dead day we have a long time
Just a comment regarding HackerRank: while I don't disagree that it may be useful as a repository of modest-sized C programming solutions to various challenges, the nature of that site often encourages "clever" or "as short as possible" solutions. These "clever" solutions will not always be the most idiomatic, nor the best learning examples. So don't get too frustrated if you find the code you see there difficult to understand.
I apologize if I came off as discouraging. I only meant sitting here at my desk having been programming for 4 years working as a Citrix engineer seeing only Python jobs out there focusing on that type of job might not wise. I am hardheaded and refuse to jump on the Python boat. But nor do I rely on my programming skills for a salary. So I can afford to be hard headed. Right now I would say the highest languages in demand is Python, Java and C#. I am also a little bitter. I struggled with C++ for years. The light turns on and poof suddenly C &amp; C++ are no longer desirable. Lmao. Such is life I guess.
This situation is sad bur true. Unfortunately you are right
Have you tried to do any debugging at all?
I'm afraid my C knowledge is too low to know where to start.... My debugging was the printf in the function to see if the problem is with regex or with the passing of the string.
Your function returns an integer, and you're trying to handle that as a string, which is undefined behaviour. You should really look at enabling warnings on your compiler and fixing them. Here's what I get if I try to compile that code above after adding a few headers: &amp;#x200B; gcc -g -Wall -pedantic -std=c99 foo.c -o foo foo.c: In function ‘regit\_int’: foo.c:19:12: warning: return makes integer from pointer without a cast \[-Wint-conversion\] return buf; \^\~\~ foo.c:19:12: warning: function returns address of local variable \[-Wreturn-local-addr\] foo.c:23:12: warning: return makes integer from pointer without a cast \[-Wint-conversion\] return NULL; \^\~\~\~ foo.c: In function ‘main’: foo.c:29:12: warning: format ‘%s’ expects argument of type ‘char \*’, but argument 2 has type ‘int’ \[-Wformat=\] printf("%s\\n",regit\_int(argv\[1\])); \^ &amp;#x200B; There's a few ways to fix these problems, one way is to change your function to return a pointer to a character, e.g. &amp;#x200B; char \*regit\_int(char inputdata\[\]) &amp;#x200B; You'll get another warning if you do this on its own though, as you're now passing locally assigned memory back to main, and that's not guaranteed to be there still. So you could either allocate some memory yourself using \`malloc\` and make sure to free it afterwards, or you could change your buffer to be static, e.g. \`static char buf\[30\];\`. That's not ideal though as it's not threadsafe. &amp;#x200B; The other option is to give the function an address to write to and the length of that buffer instead, and have \`buf\` in main, like how \`strncpy\` works, which is probably what I'd do. &amp;#x200B; Also you should check if what matches your regex will fit in to your buffer, and if \`argv\[1\]\` has been provided at all by checking the value of \`argc\`. &amp;#x200B;
Thanks. &amp;#x200B; The int thing, yes. Stupid me. This was from when I was directly trying to convert to integer and then return the integer. I am not that worried about wether or not the match fits into the buf, since at the end it will only be numbers up to 10000. If I want to cast that to an int, do I have to trim buf down to the actual number of characters?
The problem is, that you are trying to return a variable that is local to the regit_it function and is cleared from stack when the function exits. Common way to avoid this is to pass a char* - a memory address - to which you can write your result. This is also how strncpy works. int regit_int(char inputdata[], char* buf) And you don't event have to change the strncpy call. Then you can use it from main as such: char buf[30]; regit_int(argv[1], buf); printf("%s\n", buf); 
&gt;If I want to cast that to an int, do I have to trim buf down to the actual number of characters? No, there is no need to do that. Example ([source](http://www.cplusplus.com/reference/cstdlib/atoi/)): /* atoi example */ #include &lt;stdio.h&gt; /* printf, fgets */ #include &lt;stdlib.h&gt; /* atoi */ int main () { int i; char buffer[256]; printf ("Enter a number: "); fgets (buffer, 256, stdin); i = atoi (buffer); printf ("The value entered is %d. Its double is %d.\n",i,i*2); return 0; } The above code lets the user input a string of characters and passes the buffer array, which always has 256 elements, directly to the `atoi` function without trimming. 
I've just noticed another problem. Your regex isn't capturing anything, so if you're expecting to just extract the digits in the string then that's not going to work properly. You should capture the digits in brackets, then use `rm[1]` instead of `rm[0]`.
&gt; Citrix engineer Ouch. I picked up Citrix Multiuser 2.0 and it was really cool, but too early for the time. Shame the winframe stuff is still hella expensive. 
Have it look further down the decision tree. You play a simulated "you" -- so, if the computer picks A, what are the possible human responses? Then what would be the computer response? You can then look for the optimal move by choosing the one with the most wins. 
The industry is always full of change, and making the same mistakes. I fully expect in a few years there will be a move for total cloud convergence, followed years later by a zero day that hits not one but all the providers and basically all information everywhere is compromised, and a push to move things back, or another generation that reduces the size, and allows people to run full data centres on the desktop or smaller form-factor. So many things need 'cloud scale' as people are using single threaded languages that can't scale, so you cheat and spawn thousands of VM's to run 'threads' having to use queue servers to do IPC etc... All this has happened before, and all this will happen again. 
Agreed. I suspect it will fail. The industry will once again pretend to care about security and wait for market trends.
It's what i did when i tell it (him) to check if 3 coins are aligned, i play each columns as "me", then it's searching if it can do a connect 4, if it does, i tell him to play the columns where it saw a "future" connect 4 ! &amp;#x200B; But with your answer, well, i am going to need to tell him to check for multiples cases to see a further possible win xD
I like xenserver myself. Not sure why don’t like VMware much.
licensing is a PITA. And their blocking 3rd party extensions... I've deployed the Oracle version of Xen for a project to kneecap a VM to comply with licensing. It felt very rough around the edges, but you could see the orchestration there. Foolishly I've been using Qemu since the 0.8 days, and just loved it's CLI aspect. I should have been hoping on the 'let me create yet another tool to tell Qemu to do stuff', and built a disaster area like openstack. Maybe it's not too late.
Well, I am trying to learn a lot more about hardware programming and gaps are pissing me off. Plus the seriously lacking documentation from the open source community sucks balls.
Reddit isn't here to do your homework. What have you tried? Why do you think it's working or not working?
The output after the 2nd `memmove` is [12344](http://cpp.sh/8zimj)
 &gt; thought it will be 4 bytes from position array[1] which will be 1,2,3,4 so the output after second memmove will be 1,2,3,4,4 but it is same as output after previous memmove. Why? It's not. I just built and ran your code and after the second `memmove` it output `12344` as you expect it to.
Actually ran it on codeblocks and it showed 11234. Used gcc on linux and it showed 12344 i guess codeblocks messed it up.
Not a homework question. Codeblocks gone wrong i guess.
You click on the link I gave you and read the documentation. If you're on Linux or BSD, you can install the correct library from your OS vendor's package repository and use it directly. If not, you may have to install it yourself.
I give it a go! Thank you very much
Have a look at [minimax algorithm](https://en.m.wikipedia.org/wiki/Minimax) 
Non-Mobile link: https://en.wikipedia.org/wiki/Minimax *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^224302
Once you've got the hang of Minimax, a more advanced algorithm to try out is [Monte Carlo tree search](https://en.wikipedia.org/wiki/Monte_Carlo_tree_search). Rather than stop at an arbitrary depth and score the board, the AI plays out millions of games choosing random moves for each player, randomly sampling the space of all possible games. Then it picks the move where it's most likely to win. What's really nice about this algorithm is that you don't need to invent a board scoring algorithm. The AI only needs to know the rules and it figures out the strategy all on its own. I used this [in my own Connect 4 game](https://github.com/skeeto/connect4).
It's not going to be a piece of cake, but i'll try it out ! To tell him to not play some columns, i did this solution (in a smaller way, but the idea was the same, i think !). Thanks c:
Thanks
I mean, I teach an intro to C class two times a year and there were very few conceptual problems with using only C. What I found to work really well is to focus on solving open-ended exercises that all involve writing programs whose exact specifications are up to the student to make up. I see the main thing you need to teach in making student try to come up with solutions themselves instead of expecting every last thing to be solvable by rote-memorisation of approaches taught in the coursework. Every single exercise was posed in a way that a clear solution could not be inferred just from the problem description; you always had to think and make decisions as to what you think would best solve the problem.
I had heard (but cannot confirm) that Microsoft's compiler didn't support them.
Data structures for sure as you need to build those yourself for your specific needs. Other markets are game engines, language development, compilers, databases, GUI toolkits, device drivers. Here are some projects to explore: * https://github.com/rby90/Project-Based-Tutorials-in-C * https://github.com/karan/Projects * https://github.com/cstack/db_tutorial * https://github.com/aleksandar-todorovic/awesome-c 
The compiler will allocate 4 characters for the provided string, with a[3] being the NULL terminator. As for accessing a[4] it is dependent on the system, but most likely it will cause an error as you’re accessing memory the process isn’t allowed. Some systems will allow you to access the memory, but it will not belong to the string. 
Everyone learns differently. However, I find it very difficult to learn a programming language without an end-goal that I'm trying to solve. So, why did you learn a language to begin with?
Alright will do! These are great, thanks!!
So its technically wrong to write b[3] in this case since we must store the NULL terminator? 
&gt; However, I am still not familiar with the functionality of this library I would start by looking at the documentation for the relevant functions for my specific platform. Here's the relevant man (manual) pages for Linux: http://man7.org/linux/man-pages/man3/opendir.3.html http://man7.org/linux/man-pages/man3/closedir.3.html http://man7.org/linux/man-pages/man3/readdir.3.html &gt; I am not sure how to implement the recursion. Think about it. You need to write a function that lists a directory's contents and then calls itself recursively on any directories it contains. void recursive_directory_print(char* path) { for( /* devise some loop that iterates through a directory's contents */ ) { printf( /* print file/directory name */ ); if( /* file is directory */ ) { // call function recursively recursive_directory_print( /* sub-directory path */ ); } } }
I read that it’s very close to the metal and a language of kernel development, so I thought “cool I can mess with the Linux kernel!” And I got started. So maybe mess with a tiny kernel or something? I dunno. I’ve always been an advanced computer user and it seemed that doing a relatively low level language was the next thing to do after Python! Python just made it so easy it didn’t feel like I wasn’t doing any programming at all. 
`'\0'` is correct (it is exactly equivalent to `0`), but you want to use `len`, not `size`.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/askprogramming] [Help in data structures and algorithms.](https://www.reddit.com/r/AskProgramming/comments/a0n2au/help_in_data_structures_and_algorithms/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
No, reading b[3] is undefined behavior, the compiler will only assign memory for 3 characters. However if you do this, then b[3] will be the null termination character: char b[] = "aaa"; 
The "Grand Unified Theory of Pointers and Arrays" may have been part of the language the Standard was written to describe, but doesn't really fit the language it actually defines. For example, given `int foo[5][8], bar[4][10];`, the Grand Unified Theory would suggest that a function like void printIntMatrix(int *dat, int rows, int cols) { for (int i=0; i&lt;rows; i++) { for (j=0; j&lt;cols; j++) printf("%10d ", *dat++); printf("\n"); } } should be able to process all 40 elements of either array without difficulty. Both the Standard and the Grand Unified Theory imply that after `dat` has been incremented `x` times, `*dat` will be equivalent to `foo[0][x], but the Standard adds a requirement that storage accessed via `foo[y][x]` be within `foo[y]`, and does nothing to exempt `((int*)foo)[x]` from the consequent requirement that storage accessed thereby be within `foo[0]`. Under C99, the code could be written as something like: void printIntMatrix(int *dat, int rows, int cols) { typedef int arr2d[rows][cols]; arr2d *arr = (arr2d*)dat; for (int i=0; i&lt;rows; i++) { dat = arr[i]; for (j=0; j&lt;cols; j++) printf("%10d ", *dat++); printf("\n"); } } but such a construct seem a bit clunkier than the earlier version and would also need additional code (not included above) if it had to treat the row-element case as a no-op, and the zero-column case as an indication to print `rows` blank lines, while the original function would behave in such fashion naturally without any special checks. 
That is incorrect! `b` is declared to be 3 characters long and no 4th character is allocated.
I would suggest you use `char *b = "aaa";` instead. This way you don't have to worry about supplying the correct size. &amp;#x200B; To answer your question directly, reading b\[3\] will give you `'\0'` most likely but it could also corrupt another variable in your stack or cause your string to not be null terminated if some other variable is allocated on the byte that would be your string's null terminator.
You would need to write char b\[4\] = "aaa" for the compiler to null terminate it as there is no space left for a null terminator in your specific case. It would be crazy for a compiler to do what it wants and allocate an extra byte of memory just to NULL terminate b. Thankfully the C compiler allows you to do: `char b[] = "aaa"` And in this case the compiler will allocate 4 bytes of memory and terminate it with NULL.
Yes I did use len, 'prog_name[len]='\0''
Even better, `const char *b = "aaa";` so that you can prevent accidental modification of a read-only string, or `char b[] = "aaa";` if you do want to modify the string (but not append to it).
&gt; I believe the C standard says access 1 index beyond your allocated memory is considered defined behavior, meaning it is legal to do without the risk of a segfault. An expression that points to one element past the last element of an array can be used in pointer arithmetic involving that array, but you cannot dereference it.
We're looking for maintainers on [HTML Tidy](https://github.com/htacg/tidy-html5). Come get your feet wet.
That sounds like a great idea, and I just found a book about that! Thank you :)
Thank you, updated my reply. I got that in my head when I was skimming over a Stack Overflow answer
Is it dangerous to reand and or write to b[3] on a modern Windows machine?
Thank you. 
You need to pass arquivo as an argument, or make it global. Read up on scope in C
So it depends completely on the compiler... and on my compiler it did indeed allocate \*\*4\*\* characters, the last being a NULL terminator. This is completely system dependent.
Function's return type is 'int' in the function declaration and 'void' in the function's definition.
yes you're right, i changed it but still the code does not work, could you show me how can i make the function work? 
Pass the pointer to your file as a parameter to your function
could you provide the code example?
The Art of Programming?
While I don't have any tutorials to recommend, I'd suggest that embedded systems are a lot of fun. If code to running on a typical computer will need to interact with an operating system, but on most embedded controllers the only code that will be running once the system starts up will be the code you wrote yourself, possibly augmented with a small amount of code supplied by the hardware vendor to configure a few things. On a typical controller, if one were to wire a two-wire red/green LED with a series resistor between two pins marked PA2 and PA3, one could then use a program like: #include &lt;vendorSuppliedHeaderFileNameHere.h&gt; // Will typically include &lt;stdint.h&gt; or equivalent uint32_t phase; void zonk(uint32_t n) // Wait some length of time roughly proportional to n { while(n--) PORTA-&gt;PSOR = 0; } void led_red(void) // Make LED glow red by driving PA2 high and PA3 low { PORTA-&gt;PSOR = (1&lt;&lt;2); PORTA-&gt;PCOR = (1&lt;&lt;3); } void led_green(void) // Make LED glow red by driving PA2 high and PA3 low { PORTA-&gt;PCOR = (1&lt;&lt;2); PORTA-&gt;PSOR = (1&lt;&lt;3); } void led_off(void) // Turn off LED by driving PA2 and PA3 low { PORTA-&gt;PCOR = (1&lt;&lt;2); PORTA-&gt;PCOR = (1&lt;&lt;3); } void main(void) { SIM-&gt;SCGEN5 |= SIM_SCGEN5_PORTA; // Look in the data sheet for register details PORTA-&gt;PCR[2] = 0x0000100; PORTA-&gt;PCR[3] = 0x0000100; PORTA-&gt;PDDR |= (1 &lt;&lt; 2) | (1 &lt;&lt; 3); // Set bits 2-3 to outputs while(1) { for (int i=0; i&lt;5; i++) { led_red(); zonk(1000000); led_off(); zonk(1000000); } for (int i=0; i&lt;10; i++) { led_green(); zonk(1000000); led_off(); zonk(1000000); } for (int i=0; i&lt;7; i++) { led_red(); zonk(1000000); led_off(); zonk(1000000); } zonk(5000000); } } to cause the LED to flash repeatedly in a pattern of five red, ten green, seven red, pause. While real programs should set up some better means of controlling the blink rate instead of hoping a do-nothing loop runs at the desired speed, embedded systems make it possible to build devices that can do just about anything, and represent one of the few purposes for which C is still the best language. 
Great! For future reference, it is customary to use `'\0'` (as you did) when dealing with characters even though it is exactly equivalent to a plain `0`, just like it is customary to use `NULL` when dealing with pointers (although that is a little more complicated, because `NULL` is not necessarily a plain `0`, but a plain `0` can be used wherever `NULL` is used).
The fact that the compiler only assigns 3 characters is something you shouldn't rely on. It may happen for a particular situation with a particular compiler in a particular time of the day.
Its important to understand why your code dont work. You need to understand about C scope. How global scope and scope inside a function works.
Thanks a lot for the info !
You're correct. The reason why my compiler was allocating 4 bytes is because the memory is 32-bit erasable, so it had to allocate four bytes. This isn't a way I usually define strings.
I absolutely agree with you, that looks like fun! I thoroughly enjoyed the idea that I can control hardware with code directly like that! I may try to get into that if I can get my hands on some microcontrollers :D A few questions if you don't mind! Are PORTA, PSOR , and PCOR basically the pointers to where the controller is checking for the values of the LEDs? As in checks for those values to think "OK is this supposed to be off or on?". Also, how would I input the code here? Do you know of any resources for this sort of thing and getting started? 
i have a different idea, someone spends 10 seconds showing the code, and i spend 1 minute to copy on my code, and i move on. If i do it your way it would take days
It's good to build against musl-c if you're truly interested in portability and want to be sure your code isn't using any gnu lib-c-isms. When I get the chance I'm porting some C projects from github/travis over to sr.ht because their CI system offers alpine linux and freebsd as build platforms.
While I always value choice, the musl-libc people made some rather questionable design choices in their implementation that make me wonder if they actually understood why the libc was designed as it is.
That makes a lot of sense! Thank you for the thorough explanation! I’m definitely going to go this route, it makes a lot of sense to me. Thanks again!
Discussion from a few days ago: https://www.reddit.com/r/linux/comments/a00ino/thought_on_musllibc
The deeper you want to get in to algorithms, the more complex math you'll need, as the study and design of algorithms often requires the ability to express them in complex mathematical terms. You can get a book like "Algorithms in C" by Sedgewick and get through most of the examples and code without understanding the math behind them. That may be a good place to get your feet wet. But ultimately you'll need math. For that I would suggest "Concrete Mathematics", which assumed a certain level of math to begin with, but nothing you can't figure out along the way with a little googling.
An important thing to note if you're using gcc and/or clang is that the optimizer is incompatible with many vendor-supplied header files, because the authors seem to have been more interested in what the Standard requires, than in what would be necessary for compatibility with existing code. A typical vendor header file (including the actual files supplied for use with Kinetis chips) will define `PORTA` as something like `((PORT_Type *)PORTA_BASE)` without using a `volatile` qualifier. Historically, compilers used to treat integer-to-pointer casts as a sign that something is going on that they won't understand, and thus refrain from trying to optimize accesses through them. Both gcc and clang, however, are prone to take a sequence like: PORTA-&gt;PTOR = 1 &lt;&lt; 2; PORTA-&gt;PTOR = 1 &lt;&lt; 3; and decide that since they're both operating upon the same address, the effect of the first write will be negated by the second, and the code can thus be made more efficient if the first write is eliminated. Although such behavior is allowed by the Standard, that doesn't mean that it doesn't make the optimizers needlessly and dangerously unsuitable for use with embedded systems code. I would thus highly recommend that whenever you use clang or gcc, you disable optimizations unless or until the authors become interested in doing what's necessary to make things actually work. 
yes please elaborate 
There really aren't strings in C. If you were to think of this as "declaring an array of char, size 3, and then initializing it with an automatic array of three 'a' characters" it would be obvious that there is no nul terminator there.
kek
I discussed musl's implementation of `posix_spawn` in [this thread](https://www.reddit.com/r/C_Programming/comments/9hrh2h/spawn_of_satan/e6e1qgm/). I faintly remember some other rather questionable things, but not in enough detail to link them.
I dont know man. The guy that coded SQLite talks about that book when explaining how the inner structure of databases looks like. To be specific he mentioned the book when he talked about the B-Trees the database uses to store information.
I found Hacker Rank to be helpful because it gives you problems to solve that you may not have had a reason to solve in your own projects. You'll have an easier time implementing an algorithm explained on a Wikipedia page if you are familiar with the math.
You've never read it, then? That explains why you don't get your own joke.
Train a neural network with backpropagation or use reinforcement learning to play itself and build a model.
Probably has to do with Jesus and the crappy neural network he used with me.
&gt; DOS games What are you using for audio? Libraries, or self written stuff? 32bit? or 16bit? Just wondering in general about the state of MS-DOS
That's a nice one too LoL
See. People will never know whether I am joking or I am truly that stupid. 
The other guy is right. Passing by pointer or reference does not exist as a concept in C
Are you sure fp isn't null?
You need to check feof and ferror if you get a bill. 
I don't think so. This is my main method. int main(int argc, char** argv) { FILE* fp = fopen("t.txt", "r"); if(fp==NULL) { printf("Error.\n"); exit(0); } readFile(fp); return 0; } 
&gt; There is a difference In what way are they different? You're dereferencing the same point in memory there.
fp is a file stream. So when you run fprintf() you write to the stream, and the current location is updated to be after the write. Then you read from the stream from that location. I would expect fscanf() to return EOF, which I think means &amp;c would not be altered. There are also lots of tricky buffer and caching issues but I think your problem is more fundamental. Basically, this is a very odd pattern and I would strongly advise you to remove the fscanf() line. You know what the value should be, you don't need to read it back in. If you want to verify that the file is written correctly, do it after the program ends.
The most common reason you'd use a C++ compiler for C is Microsoft, unfortunately. I think their toolchains still don't do compliant C99, but they've added a bit beyond C89 since their 2013 release. It sounds silly to stick with an unsuitable compiler in today's age, but people do things like that. 
More importantly you can't guarantee what the OP initially proposed, which is the content of memory beyond what you've assigned. So if you want at least 4 chars you need to ask for at least 4 chars. If you end up with more than that it's not going to matter much.
NUL character, just one L.
That's true. I find hackerrank to be useful. But most people advice to try codechef or SPOJ. Is it true? 
I've just compiled and ran your code (using the main you posted in another comment) and it worked as expected. Are you running your program in the same directory as `t.txt`? As `fp` isn't NULL the file must exist, but I suspect you're opening a different `t.txt` to the one you think you're opening, and that one has nothing in.
Please never post pictures of text.
Alright, i'll edit the post then
Thank you very much.
This is still in Codeblocks? Are you able to determine the complete GCC command-line it's executing?
Upvoted
Not seen with clang 3.4.1 or gcc 6.4.0
As i have only tested with gcc and not clang and even mentioned in the post it happens with gcc 8.0x and above.
No offense intended, just a report from the backseat.
Np. No offence taken :-)
http://pubs.opengroup.org/onlinepubs/9699919799/
OK, so as far as I can tell this _is_ a GCC bug. I certainly can't see any UB in that code, so it should behave the same under all optimization levels. A slightly more minimal test case is just: char s[] = "12345"; memmove(s + 1, s, 4); /* 11234 */ memmove(s + 1, s, 4); /* 11123 */ memmove(s + 1, s, 4); /* 11112 */ puts(s); This should print out `11112`, but with `-O1` and above it prints out `11123`. That is, in _this_ case it actually requires three `memmove`s before hitting the problem. Nice find! 
Well cant say nice find for a bug heh. So should i write a bug report is it the only option here.
Do you need to read the whole file before any processing can happen? If so, then yes, you need malloc. Do you need to parse the file chunk at a time, but each chunk can result in a new record? Yes, you'll need malloc to make the space for that compile-time-unknown number of records. Do you need to simply hunt for the presence of one record in a file? Then no, you don't need malloc. All space can be handled on the stack (assuming small chucnk sizes can be read to be processed, like in your example. )
[Godbolt.org](https://Godbolt.org) suggests it starts happening in gcc 8. Making the declaration for array be: char array[6]={1,2,3,4,5,6}; "fixes" it for me. Using the original array size of 5, but changing the memmove's to move 3 bytes also "fixes" the problem for me. Actually, just changing the second memmove seems to restore expected behavior (when -O is selected). Also changing the memmoves to size 5 when using the above char array of size 6, works for me. &amp;#x200B; However, changing the size 5 char array to int, and memmoving 4\*sizeof(int) also is broken. Again, just increasing the array declaration size by adding one value "fixes" it. So, as a guess, I'd say that it has to do with GCC trying to replace the memmove with a just loading a 4 byte constant (in the case of a char array), or a 4 int value using SSE instructions (when it's an int array). Unless it's somehow UB, it may be a bug has been found. &amp;#x200B; Hmmm. Literally while I've been playing with this on godbolt, the output for GCC x86-64 (trunk) has changed, and now the -O2 option seems to work for it (but not -O). I could be mistaken, but I'm pretty sure the results are different now than from an hour ago (and still "broken" for non-trunk 8.2).
&gt; So should i write a bug report Please do. While optimization bugs aren't too uncommon, they normally just result in suboptimal code, not incorrect code.
As /u/Shadow_Gabriel has said, malloc should be used if the size is unknown at compile time. There are other options, though they might be platform dependent, e.g. a combination of `open`, `fstat` and `mmap`.
Will do. Thanks.
Unable to reproduce with gcc 4.4.7 on RHEL6, gcc 4.8.5 on RHEL 7, gcc 4.9.2 on Debian 8, gcc 7.3.0 on FreeBSD 11, clang 3.4.1 on FreeBSD 10, clang 6.0.0 on FreeBSD 11, clang 6.0.1 on FreeBSD 13.
Unable to reproduce with gcc 4.4.7 on RHEL6, gcc 4.8.5 on RHEL 7, gcc 4.9.2 on Debian 8, gcc 7.3.0 on FreeBSD 11, clang 3.4.1 on FreeBSD 10, clang 6.0.0 on FreeBSD 11, clang 6.0.1 on FreeBSD 13.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Or you could start 'learning' how to code? Or maybeee try to 'understand' it. Additional benefits- heyy! you won't be technically challenged anymore:')
Take a small project and do it in C. That's the only way to refresh your knowledge.
Good answer. Usually, the trick is to find a way to make your program behave more like the third kind.
Well, there is `getline` for this purpose. Doesn't belong into the C standard though, as there is the unwritten rule that the C standard library sans `malloc` et al. must be implementable without dynamic memory allocation so it is possible to use C entirely without dynamic memory allocation.
Seconded.
Even though i have sent them a mail. But don't know how long it will take. Will be glad if you file the bug and post the link to see.
I spent weeks trying to open an account with them until it finally worked. Let me file that bug report for you.
Well that's ironic no?
Please post a link so we can see the response!
`getdelim(..., ' ')` might be convenient.
Try the [Advent of Code](https://adventofcode.com/). This year's edition opens in a few days, but you can get started with problems from previous years.
I have posted the [bug report](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=88223).
It's recognized as “data” because it contains non-printable characters (`\b`).
I am able to reproduce this at `-O1` with my own build of GCC 8.2.0. It must be something really subtle about the specific order of code generation options (`-f`). Replacing `-O1` with a list of each `-f` option it turns on doesn't reproduce the bug. I don't even see the bug at the `-O3` equivalent of this: gcc -faggressive-loop-optimizations -falign-labels \ -fasynchronous-unwind-tables -fauto-inc-dec -fbranch-count-reg \ -fcaller-saves -fcode-hoisting -fcombine-stack-adjustments \ -fcompare-elim -fcprop-registers -fcrossjumping -fcse-follow-jumps \ -fdce -fdefer-pop -fdelete-null-pointer-checks -fdevirtualize \ -fdevirtualize-speculatively -fdse -fearly-inlining \ -fexpensive-optimizations -fforward-propagate \ -ffp-int-builtin-inexact -ffunction-cse -fgcse -fgcse-after-reload \ -fgcse-lm -fguess-branch-probability -fhoist-adjacent-loads \ -fif-conversion -fif-conversion2 -findirect-inlining -finline \ -finline-atomics -finline-functions -finline-functions-called-once \ -finline-small-functions -fipa-bit-cp -fipa-cp -fipa-cp-clone \ -fipa-icf -fipa-icf-functions -fipa-icf-variables -fipa-profile \ -fipa-pure-const -fipa-ra -fipa-reference -fipa-sra -fipa-vrp \ -fira-hoist-pressure -fira-share-save-slots -fira-share-spill-slots \ -fisolate-erroneous-paths-dereference -fivopts -fjump-tables \ -flifetime-dse -floop-interchange -floop-unroll-and-jam -flra-remat \ -fmath-errno -fmove-loop-invariants -fomit-frame-pointer \ -foptimize-sibling-calls -foptimize-strlen -fpartial-inlining \ -fpeel-loops -fpeephole -fpeephole2 -fplt -fpredictive-commoning \ -fprefetch-loop-arrays -fprintf-return-value -freg-struct-return \ -frename-registers -freorder-blocks -freorder-blocks-and-partition \ -freorder-functions -frerun-cse-after-loop -frtti \ -fsched-critical-path-heuristic -fsched-dep-count-heuristic \ -fsched-group-heuristic -fsched-interblock \ -fsched-last-insn-heuristic -fsched-rank-heuristic -fsched-spec \ -fsched-spec-insn-heuristic -fsched-stalled-insns-dep \ -fschedule-fusion -fschedule-insns2 -fshort-enums -fshrink-wrap \ -fshrink-wrap-separate -fsigned-zeros -fsplit-ivs-in-unroller \ -fsplit-loops -fsplit-paths -fsplit-wide-types -fssa-backprop \ -fssa-phiopt -fstdarg-opt -fstore-merging -fstrict-aliasing \ -fstrict-volatile-bitfields -fthread-jumps -fno-threadsafe-statics \ -ftrapping-math -ftree-bit-ccp -ftree-builtin-call-dce -ftree-ccp \ -ftree-ch -ftree-coalesce-vars -ftree-copy-prop -ftree-cselim \ -ftree-dce -ftree-dominator-opts -ftree-dse -ftree-forwprop \ -ftree-fre -ftree-loop-distribute-patterns -ftree-loop-distribution \ -ftree-loop-if-convert -ftree-loop-im -ftree-loop-ivcanon \ -ftree-loop-optimize -ftree-loop-vectorize -ftree-partial-pre \ -ftree-phiprop -ftree-pre -ftree-pta -ftree-reassoc \ -ftree-scev-cprop -ftree-sink -ftree-slp-vectorize -ftree-slsr \ -ftree-sra -ftree-switch-conversion -ftree-tail-merge -ftree-ter \ -ftree-vrp -funswitch-loops -funwind-tables -fvar-tracking \ -fvar-tracking-assignments -fweb \ example.c This is a serious GCC bug, so make sure you report it. 
Does it support C?
I found a pretty similar bug almost two years ago, but it's still not fixed as of GCC 8.2.0: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=79351 I've avoided compound literals since then because I don't trust GCC's code generation for them.
How is your post related to the C programming language?
Do you know how the learning process works in the brain? If no, then how do you know that i'll learn just by studying without code examples? You're not being logical, if you calculate the time to learn all the concept when you just need a part of it, you would see that the best way to help others in coding forums is just showing the code, not sending the person to a book.
Yes it does, as well as Makefiles thanks to the [compilation database](https://www.jetbrains.com/help/clion/2018.3/compilation-database.html) integration.
You're not printing an element. By referencing the list you're referencing the location of the list which is the location of the first element. A list is just a pointer and you aren't dereferencing it
Makes sense.
Basically you can't dereference a void* without casting to something. Forget about the structure, declare a void* data, maloc something to it and try to dereference it, you will get the same error.
There's a difference in notation. 
As an FYI, you can also get a chance to interview with top tech companies by sending them a resume or otherwise applying for a job. I doubt that winning this contest puts you on any sort of fast track because this company’s business is probably just to help source people. If you win they likely just take your resume and add it to the pool of everyone else that has applied through any other means.
Using the name of an array without brackets gives you the address of its first element.
It is definitely some kind of Redundancy Elimination. Interestingly however, it doesn't occur when I turning on `-ftree-fre` separately or with the `-fOPTS` turned on by `-O2`, however the behavior can be observed using `-O1 -ftree-fre`.
`*(int *)t-&gt;data`
Yup got it!! 
Ermm...what do you mean by changing the variable names? Sorry, I'm still confused.
Yikes!
You've haven't replied since then, although the only other comment wasn't really helpful. I could reproduce this bug down to gcc-5.
You are passing money_sale by value to your first to functions. This means the money_sale that is being assigned a new value within those functions is just a local variable. The global variable money_sale is never touched. Look up pass-by-value and pass-by-reference. 
Mircosoft's C compiler is absolute trash, I don't know anyone who uses it. For a very long time it didn't even support the 1999 C standard. But isn't Microsoft going to switch to Apple-backed LLVM-based `clang`?
Basically because you defined a variable with the same name locally (in side the function) it can't see the global one (outside of the function).
You need to get rid of your global variables. They are not needed, and are hiding the compiler errors that would help you fix your problem. 
[Null character](https://www.phoronix.com/scan.php?page=news_item&amp;px=Linux-Kills-The-VLA). Fun fact: *Null* is German for *zero*.
I already deleted the global variables and convert it to local variables, but it's still give 0 for the result. I reworked some of the code: &amp;#x200B; \#include&lt;stdio.h&gt; &amp;#x200B; float LaksaSarawak(float x); float NasiLemak(float y); float total (float a,float b); &amp;#x200B; int main() { float money\_sale; float money\_sale1; float totals; printf("Sub Total of Laksa Sarawak = RM%.2f\\n",LaksaSarawak(money\_sale)); printf("Sub Total of Nasi Lemak = RM%.2f\\n",NasiLemak(money\_sale1)); totals = money\_sale + money\_sale1; printf("Total = RM%.2f\\n",totals); return 0; } &amp;#x200B; float LaksaSarawak(float money\_sale) { int unitSupplied; int quantity\_sell; printf("Laksa Sarawak\\n"); printf("Units supplied :"); scanf("%d",&amp;unitSupplied); printf("Units sold :"); scanf("%d",&amp;quantity\_sell); money\_sale = quantity\_sell \*2.50; return money\_sale; } &amp;#x200B; float NasiLemak(float money\_sale1) { int unitSupplied1; int quantity\_sell1; &amp;#x200B; printf("Nasi Lemak\\n"); printf("Units supplied :"); scanf("%d",&amp;unitSupplied1); printf("Units sold :"); scanf("%d",&amp;quantity\_sell1); money\_sale1 = quantity\_sell1 \*1.50; return money\_sale1; } &amp;#x200B;
What errors and warnings do your compiler report? I see at least three lines that should be triggering uninitialized variable warnings. 
It does not have any errors, it just works. But then, it don't calculate the total.
What warnings does your compiler print out when you compile this code. I promise there are at least 3. 
I am an embedded developer, and this is why I always recommend IAR or Keil for production grade software. Either that, or you need a team of people to vet, maintain, and approve of GCC versions and settings. I am definitely using this thread as an example to management of why you either a) need to get a compiler expert on staff or b) use a professional compiler with instant phone support. I paid about $4k for IAR and got instant support when I found a bug like this.
Nevermind guys, I already got it, thanks for your help! :)
For my current project, I'm using [DJGPP](http://www.delorie.com/djgpp/) and compiling under DOSBox. So 32-bit. I wrote a lot of my own video code, but I use an audio library called Judas. I'm partway through making the work I've done so far into a coherent library called [absu](https://github.com/jaybill/absu). I arbitrarily chose to target DOSBox configured as a typical computer from 1994 (25 years ago) would have been. The hardest part of the process, by far, is finding tools and information and assembling them into a working combination that can be reliably reproduced and debugged. The information _is_ out there, but it's scatter among cached geocities pages and half-broken SimTel mirrors. I also buy a lot of ancient used books from eBay. The good thing is that it's not like this stuff is going to _change_, so once you've figured a given thing out and got it working, you don't have to worry about your code becoming obsolete. Your code is obsolete before you write it.
&gt;I was also surprised to see unaligned 32-bit integer writes used here I've found quite a number of situations where one part of gcc's optimizer will turn a piece of code into something that have the same behavior on the target, but rely upon aspects of target behavior not supported by another part of the optimizer. It sounds like memmove is being optimized to employ chunking optimizations that access storage different ways at different times, while another part of the optimizer assumes that different ways of accessing storage won't interact. I don't know what the development process is for gcc, but I would be dubious of its reliability unless or until there is clear and consistent documentation about what constructs different parts of the optimizer are allowed to produce, and what constructs different parts of the optimizer must be capable of handling, such that upstream parts of the process can be guaranteed not to produce parts that the downstream parts won't be able to handle. 
I understand why libc tries to minimize malloc calls, but fgets() can be better without malloc – just returns the length of the string and tells me whether it has reached the end-of-line. Right now, I have to use my own line reader for serious programs. Don't want a non-C99 dependency.
I would start by making the menu system, but each option does absolutely nothing, except maybe print a message for which option was selected. Run and test that the menu does what you want. Then start working on each menu option one-by-one. 4 is easiest, so start there. Then I'd probably do 1, 2, and then 3. It'll be hard to test 1 until 2 is done, so just do as much as you can. Once you have 1 and 2 working, then do 3.
C is moderately well represented on Github, but lags a bit compared to some. And embedded, I feel, has a bit to do with the reason, because use of Github by embedded programmers is no where near as pervasive as by webdevs. Another reason is that a lot of well-established C libraries and apps already had hosting arrangements and see no need to move to Github or a public site, while on the other hand the barrier to entry for a new project may make the public sites very attractive. 
\#include &lt;stdio.h&gt; \#include &lt;stdlib.h&gt; //main function main() { //array declarations int num\[20\] = { 0 }; int i; //variable declarations int choice = 0, option = 0; while (choice != 5) { printf("Enter 1 to add a number to the array \\n"); printf("Enter 2 to display the numbers entered in the array so far \\n"); printf("Enter 3 to find the average of the numbers entered \\n"); printf("Enter 4 to exit \\n"); scanf\_s("%i", &amp;choice); switch (choice) { case 1: &amp;#x200B; break; case 2: &amp;#x200B; break; case 3: &amp;#x200B; break; case 4: printf("Thank you! \\n"); break; default: printf("Invalid option, please choose again. \\n"); break; }//end switch &amp;#x200B; }//end while }//end main Ok I inserted the while loop to repeat the menu, now I am not sure how to do the rest
A good quality compiler intended for embedded use should focus on compatibility and correctness, and then on the quality of straightforward code generation in places where nothing "weird" is going on. Keil seems good in those regards. Unfortunately, some compiler writers fail to recognize that the Standards are designed to let implementations that are specialized for narrow purposes to behave in ways that would make them unsuitable for most other purposes. They were never intended to describe everything that should be expected of a quality implementation intended for any particular purpose. 
So, a file of 100 lines, with 3 space-separated fields per line? If processing that, I would generally go line by line and avoid allocating at all. Just read in a line, run through it doing what you have to do, then write it back out on stdout. That resembles a routing table, but isn't one I recognize. What do you need to do with it? 
I didn't recognize that. GNU extension from 2008. getline(), getdelim(): Since glibc 2.10: _POSIX_C_SOURCE &gt;= 200809L Before glibc 2.10: _GNU_SOURCE Not something I can usually use, but thanks for pointing it out. `strtok()` is stateful and tricky. 
Youll need paypal if you want me to do your homework.
 Agg[i] = (char*)(malloc(100)); // Max expected string length. Agg[i] = Get(i); It sounds like `Get` is returning a string that you need to copy. In the code above, the memory returned by malloc is lost; the pointer is being overwritten by whatever `Get` returns. To make a copy you need Agg[i] = (char*)(malloc(100)); // Max expected string length. strcpy(Agg[i],Get(i)); Or, better, char *parameter = Get(i); Agg[i] = malloc ( length of parameter + 1 ) strcpy(Agg[i], parameter ) 
Well, you're getting somewhere, but you haven't explained what you're trying to do, and why in C. I'd likely use C; it's a fantastic language. But someone might have written the program you need already, or your situation might demand some other solution. What you appear to have is: @`&lt;IPv4 addr&gt;`/`&lt;IPv4 netmask&gt;` `&lt;IPv4 addr&gt;` `&lt;hex-byte&gt;`/`&lt;hex-byte&gt;`. Is the netmask always /32? That means one IPv4 address. Seems like some kind of abbreviated log. How you work with it depends on what you're trying to do. 
New one for me too. I think I saw the OP's unedited post, the file format was very odd, all in one line. "That's a bit cumbersome to handle".
`@` parses just as well as `\n`. Just isn't so readable. At this point I'm trying to judge the chances of being able to handle the task without allocation other than stack/auto. Reasonably high. I don't claim any great coding expertise, but over the years I've seen a fair number of programs that read data into memory when they didn't necessarily need to do that. And we've probably all seen ones that use far more memory than they would seem to need -- usually without the code available to examine! 
Excellent work. The real message here is DO NOT use a recent version of gcc. Ever. Unless you really really know what you are doing. Which means if you are a gcc dev working and you do commit code to the gcc project then maybe ( only maybe ) you know what you are doing. Everyone else needs to stay away from recent GCC. It is almost entirely a controlled project run by big big corporations now and you should not expect much from it. Just look at IBM and Red Hat and then look at who is really doing the work inside the GCC project and figure out in your head what is really going on in the so called open source world. Money. Big money. Centralized control. That is what is going on. The Linux kernel also. The next steps will be gcc versions that do not work and introduce subtle bugs in ordinary code and you must buy a contract and a supported version from IBM and Red Hat or Oracle or forget it. That is the next step in the money plan. Expect more bugs. Lots of them. Do not expect them to be fixed. Not on open source versions. Just go to LLVM and clang and move now. 
`strdup()` is also worth a check.
Most optimization flags don't do anything unless optimization is enabled in the first place with -O&lt;n&gt;
I agree that RH has a disproportionate amount of power in the GNU/Linux ecosystem, but they do not control GCC, and they never will.
Just focus on 1. Ask the user for a number and store that in the array. You already have the array declared, which is good, but you also need a variable to track how much of it has been used.
You have to use ./a.out | col -b to get rid of the backspace :) If input is not friendly, line\[i-1\] can reach beyond the array and in the 2nd version, p could have random value. Simpler way to switch modes, flag = !flag;
Huh. Did they always use a subscription model? I could have sworn it was a purchase a few years ago.
Thanks a lot! That solved the problem! \o/
Cursed typewriters! Thanks.
Thanks. I won't forget initializing all my variables next time. About !flag: I'm sticking to what's taught in the book up to that point. Otherwise I'd save myself a lot of effort and just use pointers. *s is a million times better than line[i].
It changed about 3 years ago to a subscription model that came with 3 releases a year instead of one, and cheaper access to all tools when you need it.
really ? who does control the gcc project ? 
`#include&lt;stdio.h&gt;` `#define n 3` `int computerPlaysToWin (char board [n][n], int * cRow, int * cCol);` &amp;#x200B; `int main() {` `char board[n][n] = {` `{'?','O','O'},` `{'O','?','?'},` `{'O','?','X'}` `};` `int score;` `int cRow, cCol;` &amp;#x200B; `score = computerPlaysToWin(board, &amp;cRow, &amp;cCol);` `printf("%d\n", score);` `return 0;` `}` &amp;#x200B; `int computerPlaysToWin (char board[n][n], int *cRow, int *cCol){` &amp;#x200B; `int score;` `for (int i = 0; i &lt; n; i++) {` `//for (int j = 0; j &lt; n; j++) {` `if(board[i][0] == 'O'){` `score += 4;` `}` `else{` `score += 1;` `}` `//}` `}` &amp;#x200B; `return score;` `}` &amp;#x200B; Trying to use this code, but a random number gets printed everytime &amp;#x200B;
Have you been coding in another language(s) since? A few years ago I picked up C once again and it made me realize a few things. * Make sure your recollection of the semantics is correct -- probably a quick review of one of the recommended texts. * Turn on all compiler warnings (perhaps `-Wall -Werror -Wextra -Wpedantic`). * I like to use some security mechanisms to remind me, too: `-D_FORTIFY_SOURCE=2 -Wformat-nonliteral -Wformat-security`. * Spend five minutes refreshing yourself on `assert`. * Have some good-quality example code at hand to check for idioms and examples. I already have projects cloned for other reasons. If I need an example or inspiration I look at my own past code, then those. 
That sounds like scaremongering even to a non-expert like me. 
&gt; If the sum is 12 then it means the user/comp has won. That's not how tic-toe-works. . O . O X O X . X Both players have 3 symbols - for a score of 12. Yet neither player has won.
You never assign `score` an initial value, but you add to it. int score = 0;
What's funny is that the published Rationale for C quite specifically says: &gt; **C code can be non-portable**. Although it strove to give programmers the opportunity to write truly portable programs, the C89 Committee did not want to force programmers into writing portably, to preclude the use of C as a “high-level assembler”: the ability to write machine specific code is one of the strengths of C. It is this principle which largely motivates drawing the distinction between strictly conforming program and conforming program (§4). While the authors of the Standard clearly didn't want to require that all implementations behave as "high-level assemblers", it's equally clear that they recognized the legitimacy of using the language in that fashion, and the value of implementations that support such usage. 
I see your point 'script kiddie', but Copy pasting snippets of code from random sources 'might' make your code work, ofcourse. Its just recommended in general to refer legit tutorials, implement lines of code using examples with illustration. (If you're a beginner) 
Good job!!!
I get that, but how do you assign the 4 to O and 1 to X?
Its an array of linked lists. There was some other problems which is why it didn't free properly but I fixed it.
When X plays to a square, put a 1 in that spot. When O plays, but a 4 in that spot. When printing the table, if there's a 1 you print 'X' and if there's a 4 you print 'O'. Oh, and 0 means an empty space, so print `' '`. If you want you can use an enumeration so you can use X and O in your code: typedef enum { E = 0, X = 1, O = 4 } player; void printPlayer(player p) { switch ( p ) { case E: printf(' '); break; case X: printf('X'); break; case O: printf('O'); break; } }
Especially now with microsoft owning github, I can see why popular projects would want to stick around with their own hosting service instead.
But i have to use a 2D array. 
Of course. You should have something like: int board[3][3] = {0}; Then on X's turn, if they played in the center spot you would do something like: board[1][1] = 1; Alternatively, using the `enum`: player board[3][3] = { E }; // ... board[1][1] = X; 
But then you can't put a char in board
Exactly. You wouldn't be putting characters in the board. Or, you could do it that way: char board[3][3] = { '\0' }; // ... board[1][1] = 'X'; Then, when doing the sum you have something like: if ( board[i][j] == 'X' ) sum += 1; else if ( board[i][j] == 'O' ) sum += 4;
I used the second method you mentioned but I get answers like 21 because it calculates for all the Os and X's in the board
Then don't loop over the entire board? Just calculate the sum for one row and check it. Then calculate the sum for another row, etc. Then do the same for the columns, and then the diagonals.
I am doing it for each row, but how do i assign cRow and cCol after the loop? `int computerPlaysToWin (char board[n][n], int *cRow, int *cCol){` &amp;#x200B; `int sum = 0;` `int win;` `for (int i = 0; i &lt; n; i++) {` `if(board[0][i] == 'O'){` `sum = sum + 4;` `}` `else if(board[0][i] == 'X'){` `sum = sum + 1;` `}` `else{` `sum = sum + 0;` `}` `}` `if (sum &gt;= 8) {` `return win = 1 ;` &amp;#x200B; `}` `}`
It's been a source of ever increasing frustration, just as when i ported quake 2, the target was native machines and everyone lost their mind that stuff didn't work on dosbox. I hate the sound library it currently has, as its not really free. They still want royalties on MS-DOS. Although I see that Judas also has HDA support which is the key thing I need The road to djgpp 2.05 was very rough. I still wonder if it was worth it. Although i kind of still prefer to go32 ways of old.. Information can be hard to find at times for sure.
When the algorithm behind malloc allocates memory in response to a bunch of malloc (and free calls), what will be the general utilization ratio? Above 50%? Above 70%? Im talking about the ratio: (received - freed)/allocated over time
It's going to depend on the malloc library being used. You could measure it on your system fairly easily, however. It also depends on how much fragmentation your program makes -- the system can't move your pointers around while they are in use. 
That question makes a lot more sense than my guess at what you were getting at. I think it would vary greatly from program to program and making any decisions based on a single number would be unwise. But, since you're creating your own malloc, you now have the perfect testbed for measuring the ratio for the programs in which your library is used.
That entirely depends on how one implements the library, any alignment done, OS depedencies, etc. This is something that varies not only from algorithm to algorithm, but library to library and implementation to implementation. There's no set value.
Like someone else mentioned, many of the major projects written in C predate github and haven't really moved. And some that did, chose gitlab over github for different reasons. I know we at GNU Wget use gitlab since it has less non-free JavaScript and it supports better CI than github does. Plus, no vendor lock-in. We can self host anytime we want. If you're looking for open source projects to contribute to, I will first recommend GNU Wget. We always need more active programmers. Apart from that, almost all GNU tools are written in C or C++ and would be a good place to look. Another idea would be to look at the list of participating organizations in GSoC. This works great since you can be fairly certain that these projects have a well defined and easy on-boarding process.
So my follow up question would be.. what is an acceptable ratio? 50%? I've been running a few benchmarks using the buddy algorithm and it seems to dip below 50% if I let my benchmarking program ask for anything between 32 and 4Ki bytes. I only reach 75% if I set the lower bound to 512 (i.e. no blocks smaller than 512 bytes will be allocated)
Why exactly?
So I went to settings and then did something that the site said I might need to compile it or something and used the default and when I tried to run it, it just stops where you see the red square. I'm super duper new to C++ so I'd appreciate all the help with this cause I don't seem to know what I did wrong. I have fiddled with game maker before in school for about a year or so but that's as far as my knowledge in programming goes.
Pretty sure that redhat bought Cygnus ages ago.
Llvm/clang gets all that Apple work though. The larger issue is that a lot of this stuff lives and dies via corporate patronage.
Cant see anything and this is a subreddit about C not C++.
Uh, what? Bugs occur in all software projects, some of them don't get fixed for years. Also, GCC's principal maintainers for each area are selected by the GCC steering committee, these people in turn appoint maintainers for an area which are drawn from people who commit to that area frequently. If you expect Clang/LLVM to be less corporate, you're seriously barking up the wrong tree.
You might want to check r/cpp but it looks like maybe the project wasn't setup correctly. It doesn't look like it's finding a compiler 
Your filename is test#1.**c** . Rename it to test#1.cpp, 
 strcpy(inbuf_copy, inbuf); When does strcpy stop copying?
Doesn't it stop copying when it hits a null character?
Oh I see! So do I put a null character at the end of inbuf\_copy then? I am trying that but it doesn't seem to be working. Sorry if this is a dumb question.
The nul character is at the beginning. So you're reading 16 bytes out of inbuf_copy after only putting 1 into it. Forget about `inbuf_copy` altogether and directly print the values in `inbuf`
You do realize this type of crappy low quality posts get you a one way ticket straight to programming hell right?What question? What is the problem with the code? And for the love of god please indent it and try to post as little code as possible.
https://www.tedunangst.com/flak/post/to-errno-or-to-error
my question is that i need to understand what almost everything is referring to. so a little explaining on what does what would help a lot &amp;#x200B;
In the past there have been websites hosting projects that decided to go wild and infect those projects with ads *cough sourceforge cough*. I'm not saying that microsoft will do the same, but I could understand people spending so much time building software, not trusting a company that serves ads as security updates on an OS you spend money on. Don't forget that a lot of open source projects out there provide little to no profit, and it's made by hobbyists.
 ch1 = fscanf(... What does fscanf return?
You're mis-using fscanf by setting the values you are trying to read to the return code from fscanf. Read the man page for fscanf.
Try running in a debugger and it will run ASAP. Like lightning fast ASAP.
I don't find the fact that individual optimizations don't break things surprising. Different optimizations are probably written by different people, and so one person will decide that using a 32-bit load and 32-bit store is better than using four eight-bit loads and four 8-bit stores, and another person will decide that since the Standard doesn't define any means by which overlapping 32-bit loads and stores could occur, it's safe to assume that loads and stores of different addresses will be independent. A similar issue arises if e.g. code uses a 64-bit `long` to read some storage that was last written using that type, writes the same address with the same type using 64-bit `long long`, and then later uses type `long long` to read the storage. Sometimes gcc will decide that because the middle read and write don't change the stored bit pattern in memory, they can be eliminated. Such elision would be safe in the absence of downstream 'aliasing' optimizations, but it can cause downstream "optimization" stages to generate nonsensical code.
1. Format your code 2. The best way to understand is to try to walk thru the code by hand. 1. On a blank page make columns for each variable 2. Starting at the first line of code mentally step thru each line 3. As variables change write down the new value (one line on paper for each line a variable changes on) 4. If you get stuck or want to check your work add a print statement at the point you want to check and print out the variables you want to check. 5. After you have done this for some simple inputs you should start to understand what affects what in the code. 
ok figured that out a bit. any other thoughts on fixing the issue?
well the problem now is that the loop cant break. so it just keeps printing the last integer indefinitely. somehow its not recognizing the End Of File
the fscanf explaination worked tho so thank you very much.
Well, your logic for merging the files doesn't work anyways. You won't get the right output.
ok ill readjust somehow. thanks for your help man &amp;#x200B;
Did you want some other use cases? On Win7, gcc version 8.2.0 (Rev1, Built by MSYS2 project) On RHEL: 3.10.0-862.9.1.el7.x86\_64 / gcc version 4.8.5 20150623 (Red Hat 4.8.5-28) (GCC) testNoOpt.out: 11234 12344 testYesOpt.out: 11234 12344 I used the following flags on RHEL: `gcc -std=gnu99 -O2` &amp;#x200B;
[http://lmgtfy.com/?q=circular+buffer+c+library](http://lmgtfy.com/?q=circular+buffer+c+library)
After starting another compiler project, I decided that I wanted a library to simplify strings. I looked around and saw a few, but I had some issues with some of them, and I like making things on my own, so here we are. Let me know if you guys have any criticisms or suggestions
So... standard library std::string? 
But not C++
...I still don't get the hype. When I was learning C, I was told how pointers are super hard yadda yadda and now I feel like they're overhyped. Sure, you'll pull your hair out on bigger projects because they get annoying to manage, but for an intro to C class I don't see why people fail do much. It's literally just an address, which you can do simple arithmetic on
The FSF.
Thanks :)
What's wrong with this subreddit? 
People might want to get a feed of libraries that they can easily look through without most of it being homework posts. "Do one thing and do it well"
That's what int\_fastn\_t\* are for. Stupid name I know.
Wow, you ported Quake 2?
yes, [it was a few years ago when I started](https://virtuallyfun.com/2015/06/02/porting-quake-ii-to-ms-dos-pt1/). It took on a life of it's own, especially once someone 'found' source to the 3dfx drivers, and work went about for native 3DFX support. Since it's direct hardware, there is no support for DOSBox, so people complain about that. Even though there is a Win32 'feature parity' version people refuse to use it. But you know users are strange things. Honestly it was a LOT easier than I thought it was going to be. I think it was a day or two to get null quake building, then removing the dynamic linking support and porting the static quake 2 to DOS. The hard part was the video and how DJGPP treats locking/unlocking memory. Luckily 2.04 to 2.05 made re-adding the DLL support pretty easy, so we have dynamic levels &amp; drivers like the other versions.
Nah, I think they got it.
Implement it yourself. It's not that hard.
Oh, no way! I'm a big fan of your blog! I found it when I was trying to get OS/2 running in QEMU. (long story). Thanks for that work! You saved me days of figuring out the details of that on my own! I recommend that Judas library. It's fairly complete, the code is well writtenw and easy to follow, and the docs are solid. The last version has HDA support for a few other things and is GPL. My code is BSD licensed, so I had to stick to the last non-GPL version (2.09)
Cool, always great to find a fan! I started the blog as a place to keep my notes, and my quest to run Xenix &amp; NetWare on Qemu... Funny how things have changed over the last 10+ years. I need to switch the audio stuff for sure. And integrate it into DooM and other things... Although I've been silly messing with GCC 1.37 + GO32.
16 bit length is too short will guarantee to overflow
Doesn't this just store the address of p in t-&gt;data? I want to **store the address of p in the memory that t-&gt;data is pointing to.** Sorry if this is confusing, this is the start of me trying to implement a circular buffer ..
Rather have nothing on it than that.
Just figured it out, I should declare data and mem as void \*\*
`p` is a label of a memory block holding the address to a memory block with value `1` (its first byte to be exact). `&amp;p` returns an address to block of memory labeled `p` in your code, holding an address to a memory block with value `1` (pointer to pointer). `*p` returns the contents of a memory block labeled `p` in your code, holding the value `1`. `t-&gt;data` is a label of a memory block, where you wish to store an address to some other memory block of unspecified size. Variable is just a label of some allocated memory block. &gt; Doesn't this just store the address of p in t-&gt;data? No, it copies the contents of variable `p`, which is a pointer and holds an address to integer value in memory (`1`). After that, `t-&gt;data` will point to the same memory block as `p`, so `t-&gt;data == p` and `*(t-&gt;data) == 1` same as `*p == 1`. &gt; I want to store the address of p in the memory that t-&gt;data is pointing to. Why would you want that? You've already allocated space for a pointer by instantiating struct in `t`. Then - for some reason - you are putting there an address to a memory block of size 100 bytes and now you want to copy another address there. This doesn't look right. Either copy contents of the memory pointed to by `p` into space pointed to by `t-&gt;data` (that way you can reuse the space `p` is pointing to) or store the pointer in `t-&gt;data` directly instead of creating `p`. &gt; Sorry if this is confusing, this is the start of me trying to implement a circular buffer .. This is not how you implement a circular buffer. You need a structure with a pointer to data and a pointer to next structure instance. For example: ``` struct Element { void *data; struct Element *next; } ``` Then, you are instantiating Elements and connect them in a chain and join the last element with the first: ``` // Pseudocode!!! start = malloc(Element); cur = start; for element in elements { cur-&gt;next = malloc(Element); cur = cur-&gt;next; } cur-&gt;next = start; ``` 
t-&gt;data = &amp;p
And, by the way, this is wrong. void* data means that data can point to any point in memory, and later needs to be cast back into a type. You want to store the address of the memory area you are making. So, you could simply say: t-&gt;data = malloc ... But, you are trying to play with getting memory that someone else has malloced into your queue item. 
&gt;This is not how you implement a circular buffer. You need a structure with a pointer to data and a pointer to next structure instance. I can't do this with a linked list sadly, I have to use a continuous block of memory to store the elements..
In that case, you need an array. It's a continuous block of memory. So, your structure will look something like that: ``` struct CirBuf { int elements[100]; int read_cursor; int write_cursor; }; ``` Then you can just add new element at `CirBuf-&gt;elements[CirBuf-&gt;write_cursor]` and increment `CirBuf-&gt;write_cursor` until you reach full capacity (100), when you reset cursor to 0.
And if I want to store pointers to whatever data instead of integers in the elements, I would do this? struct CirBuf { void *elements[100]; int read_cursor; int write_cursor; }; And the size of the buffer has to be adjustable on creation, so struct CirBuf { void **elements; int read_cursor; int write_cursor; }; And then t-&gt;elements = malloc( ...), and now I have the same problem I started with :D
Totally agree. I just subscribed. Love the idea
This is good, but the buffer has to * have the size adjustable at creation * store pointers to data And this gets me back to the previous problem..
Why did someone cast a downvote? Both are valid points. 16-bit length is particularly odd given that it doesn't save memory on 64-bit machines due to memory alignment. There is a debate between size doubling vs 1.5x increase, but anyway max+1 is not the right choice.
1. You said elements must be stored in continuous memory block. Array of pointers does not conform to that rule as elements are scattered across memory. Only pointers are stored in continuous block. 2. You cannot store elements of unspecified size in a memory block without some sort of framing or external array of pointers to data blocks. 3. Memory allocated dynamically is an array that can be cast to something else. 4. ``` #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(void) { void **elements; elements = (void*)malloc(100 * sizeof(void*)); int i = 1; elements[10] = &amp;i; printf("%d\n", *(int*)elements[10]); return 0; } ```
This sounds like an xy problem: https://mywiki.wooledge.org/XyProblem Also, nitpicking, you might wanna change that struc malloc: https://www.kernel.org/doc/html/v4.10/process/coding-style.html#allocating-memory
Here you say you have it in wav format, but in another subreddit you said it was in csv format. Which format was it originally in?
ha ha ha .. bull sghit ... the Stallman guy does nothing but walk and talk and bullshit.
The FSF is far more than just Richard Stallman.
it is a political ( USA based ) bullshit org that asks for money a lot and seems to have its nose everywhere and not really about software . Made the mistake of doing a donation one year and I get their free whale bullshit emails endlessly now. Still it has bugger all to do with gcc. Just look at the gcc mailists. It is all intel and red hat and ibm all the way. 
k
exactly .. go away 
Having worked at a large tech company, having interviewed with large tech companies, and as a hiring manager at a startup I find this hard to believe because there’s more to getting hired than just how well you can write code. This contest doesn’t even say as much.
[https://github.com/dhess/c-ringbuf](https://github.com/dhess/c-ringbuf)
Honestly I find the parens can be helpful, I mean `*(int*)...`isn’t so bad but c expressions with casts in them can become a mess really, really fast...
I'm partial to antirez's [sds](https://github.com/antirez/sds). I like the way he keeps the string size out of the way using pointer aritmetic and leaves a `char*` compatible type to be passed around.
Try searching for "malloc overhead", i.e. how many additional bytes will be wasted per allocation. Quick search yields https://prog21.dadgum.com/179.html A simple sbrk-based linked-list malloc implementation was described in K&amp;R, with some efficiency analysis if I recall correctly. For a fancier implementation, check musl malloc. Also a reminder, in a typical hosted environment (OS, virtual address space) memory is allocated and freed in units of 4KB, aka pages. This may be important, depending on what you mean by "actually allocated".
Not all projects are targeted toward 64-bit machines. Within the embedded world, 32-bit machines are quite popular, and a 16-bit length would be quite practical. Further, while there are situations where logical strings longer than 65,535 bytes pay be useful, processing such strings efficiently requires that one avoid needless copying, which in turn may require an API that among other things distinguishes the concepts of "append to this string, and expect that further things will be appended to it", and "append to this string, and allocate the target to the exact length". Note that some of the problem here may not be so much the fault of the string design, but rather the weakness of standard-library allocation primitives. If there were a version of `realloc()` that allowed the programmer to indicate how the storage was likely to be used, then it would be possible for that function to handle repeated small expansions efficiently but make the storage following the last expansion available for other purposes after awhile. A bigger issue I have with this library is that I'm not quite clear on the intended use case. A string library that maintains its own memory pool and can share and relocate string fragments within it could offer better storage efficiency on embedded systems than one based on `malloc`, especially in cases where strings would represent the *only* thing requiring dynamic storage. A string library that can accommodate multiple means of storing strings and allow functions to use them interchangeably, could allow the benefits of dynamic allocation when needed with the efficiency of static/automatic buffers. 
I'm not such a great C programmer but.. what's wrong with &lt;string.h&gt;? (I admit I'm missing a function like Plan 9's \[tokenize\]([http://man.cat-v.org/plan\_9/2/getfields](http://man.cat-v.org/plan_9/2/getfields)))
Apparently, the bug has already been fixed as a result of the bug report. Thank you for posting this!
In general, C programming language is not as popular as other programming languages and therefore, this may be one of the major reasons as to why there are not so many conferences that are held concerning C programming language. However, as many other redditors may have noted, programming conferences hardly give learners any ‘magical’ or ‘shortcut’ deals to help them to learn the language and that may be another good reason as to why they shun going to C programming language conferences making them to be as few as they currently are. I may be wrong but these conferences only give guidance and directions only which you can easily get them from other sources without having to attend the c conferences. If you are willing and capable of holding C programming language conferences, why not start creating your own? Finding persons who are interested in going to the same can give you good motivation and you can find them at many programming schools like [Holberton School](https://www.holbertonschool.com). First year students and beginners may show huge interest in going to the conferences better than seasoned programmers who are almost finishing or who have just completed their course. Good luck and I wish you all the best.
Welcome. Thank you too for posting it on the gcc. I have posted the edit.
I'll say this half heartedly (because you probably mean well), but it does feel like avoidance regarding rule 2. Some of the posts smell like a false flag operation from the Rust Evangelism Strikeforce. [This one](https://github.com/lduck11007/c-bool-value) just takes the fscking cake.
You have just one pointer. All the indexes of your array of char pointers point to that single pointer which changes its value with every iteration... This is not black friday dude, you need to allocate memory for each string you want to store.
The apophenia library uses it pretty heavily: [https://github.com/b-k/apophenia](https://github.com/b-k/apophenia) I've not done any development work on the library so I can't comment on the complexity of the approach
This is mainly centered around managing dynamic strings
Thanks, I'll change them when I get onto my laptop. 16 bit length was kind-of a conflicted decision for me, but you're right.
I originally planned on doing that (char *), but switched at some point. I might switch back to it I guess
Please [do not post pictures of code](http://idownvotedbecau.se/imagesofcode). I have removed your post so you can try again with code as text.
 for (int y = 0; y &lt; 6; ++y) { for (int x = 0; x &lt; 8; ++x) { printf(arr[x][y]); printf(" "); } printf("\n"); } 
Thank you for your cooperation. Please put four blanks in front of every line of code so your code appears formatted.
I tried, but when i save the edit it pushes everything back out to the left again?
You can also use the new editor and paste your code inside a code block. (click on the ... icon and choose the left option)
You are saying you need to copy all danes from input\[\] to output\[\] but remove duplicates ?
ahh, thanks a lot :D
Yeah exactly and i actually also need a number to represent the number of times the rider occurred in the data.
it might go something like this: output_len = 0 for i 0 to input_len if dane for j 0 to output_len if name matches output[j].count++ goto skip output[output_len] = input[i] output_len++ skip:
Read again. I can't think of another way to explain it. Here is what you need to do in code. Maybe it will help you reason. /*You allocate memory for each string you want to store so that when your buffer (word) changes the values inside the array don't. You can use strdup but this is more explicit so you understand what I mean. */ wordArray[i] = calloc(strlen(word) + 1, sizeof(char)); memcpy(wordArray[i], word, strlen(word)); &amp;#x200B;
An empty list would essentially be a LinkedList whose head and tail are both null (having no nodes). In your code, you initialize nodeB as a linked list (which makes it a poorly named variable), but in your while( list != NULL) loop, you are attempting to use it as a node. That is where you get your "LinkedList has no member next".
&gt;for (int y = 0; y &lt; 8; ++y) { for (int x = 0; x &lt; 6; ++x) { printf("%f ", arr\[x\]\[y\]); } printf("\\n"); } Thank you so much, this is exactly what I needed. 
Before I can try to explain anything at all, I have a few questions. 1. Do you understand the algorithm that you are trying to use? 2. Do you understand how insertion sort is supposed to work?
WTF IS THIS
Did you confuse this sub with Dropbox? Looks like you uploaded your homework assignment for backup.
Check the return values from `scanf` so you have some idea as to whether they’re actually getting anything or not.
In addition to what u/nerd4code said, try changing `scanf("%s", ben.domain);` to `scanf(" %s", ben.domain);` .
 Of course you need an array of pointers since each string is a pointer. A 2D array of chars (1 byte) is not the same as a 2D array of char pointers (8-4 bytes per pointer). Im out bruh. God bless you, the answer is above, you really need to wrap your head around pointers, arrays and C strings from what I can see.
That's all well and good but I've been told I can't use calloc or malloc
The concept I gave you is still the same, just allocate the memory by declaring a big char array and manage it. If you need anymore help you can. a) Think harder b) Ask the beautiful professor (whenever people need help with projects with weird constraints as yours its mostly school assignments) that came up with this weird assignment to help you.
the error is "cannot open source file sys/socket.h". 
When I ask a stack overflow question I normally get "well it works for me"
my problem with that is. If it's not written by microsoft developer i don't touch because. I know it boils down to a simple syscall. The actual source file for that covers some really high expert functionality, and if i develop for linux from windows platform and have to deal with that syscall wrapper i'd rather code from linux machine to prevent the worst of bugs. A math library i would be okay importing from another include path, it's code i can understand... &amp;#x200B; Looks like my only option is cygwin. Those guys know what they're doing
Well it seems the problem was how I was trying to fill wordArray, not memory allocation. I changed fscanf(fNamePtr, "%s", wordArray[i][j]); to fscanf(fNamePtr, "%s", wordArray[i]); and it works. Thanks for your help. 
We need some more details before we can help you. What does the full source file look like that you're trying to compile? And what exact command do you run when you try to compile the program?
Are you connected to a linux system for cross compilation? Last time I played with that it required the paired system being set up before VS stopped screaming at me.
Another thing: don't cast void pointers, you don't do that in C it's a C++ thing. This is a good read regarding that: https://gustedt.wordpress.com/2014/04/02/dont-use-casts-i/
[https://en.wikipedia.org/wiki/Reading](https://en.wikipedia.org/wiki/Reading)
You specify something that has an unknown effect. In this case set a value of 4 characters to an array of 3. The compilers are free to do anything they want in unspecified situations such as this, such as not placing anything or just make the program play the sound of a train. Sounds like a joke but these situations put responsibility in programmers and allow a simple language with more effective optimisations.
Unlike null pointers, which are genuinely useful, zero-terminated strings are essentially a "mistake". They work better than alternatives in those rare cases where code is going to read each character of a string once, and would have no reason to care about a string's length before it has done so, but that is basically the only thing good about them. If code is going to use zero-terminated strings, the functions that examine strings like `strlen`, `strchr`, and `strcmp` seem useful, and `strcpy` may be okay in cases where the source is a string literal, but how many functions that use strings as destinations are actually designed well? 
1, that's what `++median` does as well, is it not?
Good. So when you are creating an empty list, what will be your head and tail nodes pointing to? Also, have you programmed before in languages other than C? I am asking this to understand if you have issues in using C syntax.
What is the value of median for the `seen_until_median+=count[median];` code on the last loop of each example?
The last iteration will be different. With the for loop, the body won't be executed with median equal to MAX_VALUE. With the while loop, it will be. Similarly for the half_seen term.
I actually just exited out VS when it detected the error. I need to try to compile a sample application to see if it runs.
This code won't compile on Windows directly. You either need to use Cygwin or port it to use Winsockets.
It's a very simple server. I'll post the code in a few. It will work on just about any linux system you try to run it in.
This doesn't seem true as changing the condition in the for loop to `seen_until_median &lt;= half_seen &amp;&amp; median &lt;= MAX_VALUE` does not affect the result
So, on the last loop of \*both\* examples, you are saying the expression is `seen_until_median += count[4]`? I say you test that hypothesis. Or in other words, in the while loop version, does it matter where the `++median` happens in the loop? When does `median++` occur in the for loop?
It is true : http://cpp.sh/5lsdm
Isnt median set to cero in the while lop and set to 1 in the foor loop? Am I missing something?
In your example if I change the `&lt;` condition in the for loop to `&lt;=`, I get equal results. But that is not changing anything in my code.
Let's go through the transformation step-by-step. First, let's just change the name of the loop: int median = 0; int seen_until_median = count[0]; for (; seen_until_median &lt;= half_seen &amp;&amp; median &lt; MAX_VALUE; ) { ++median; seen_until_median = seen_until_median + count[median]; }; Next let's move the declaration of the loop counter: int seen_until_median = count[0]; for (int median = 0; seen_until_median &lt;= half_seen &amp;&amp; median &lt; MAX_VALUE; ) { ++median; seen_until_median = seen_until_median + count[median]; }; And then move the increment of that counter to the end of the body: int seen_until_median = count[0]; for (int median = 0; seen_until_median &lt;= half_seen &amp;&amp; median &lt; MAX_VALUE; ) { seen_until_median = seen_until_median + count[median+1]; ++median; }; And then into the for loop: int seen_until_median = count[0]; for (int median = 0; seen_until_median &lt;= half_seen &amp;&amp; median &lt; MAX_VALUE; ++median) { seen_until_median = seen_until_median + count[median+1]; }; But this still isn't quite what you have: you started the index at 1 instead of 0, so let's do that, too, but subtracting 1 from it everywhere else: int seen_until_median = count[0]; for (int median = 1; seen_until_median &lt;= half_seen &amp;&amp; median - 1 &lt; MAX_VALUE; ++median) { seen_until_median = seen_until_median + count[median]; }; This is identical to your version except for the loop ending condition. And this is where I'm a little bothered. I bet `count` is an array of size `MAX_VALUE`, and it's very likely you're going past the end of that array.
`median++` in the while loop should make the first iteration in both cases should internally call `count[1]` first. Is this not the same thing?
&gt; did you say DJGPP can compile DLLs that work under DOS? YES! I don't know why they don't push it further, but it's a key way in how Quake 2 works, and even though in the porting process I had initially made it all static as part of troubleshooting 'known good' states, we were able to quickly revert the static link to DLL's without any issue. What you want is the build 'DXE' files, which are the dynamic EXE's (DLL's). https://bitbucket.org/neozeed/q2dos/src/114cc570822a3ac164bf421490cf4698a03063d9/xsrc/Makefile.dj?at=master&amp;fileviewer=file-view-default Will give you a quick view into the build processes. Although Quake 2 at this point is a bit 'big' to look at as an 'easy to use example' ... lol
Thank you for your answer. ``` for(median = 0; seen_until_median &lt;= half_seen &amp;&amp; median &lt; MAX_VALUE; ++median){ seen_until_median += count[median+1]; } ``` Seems to do it. But I'm still not sure why.
What does "it doesn't work mean?" Does it compile? Does it segfault? Does it just not create the file? It's difficult to troubleshoot when you don't know what's going on :p
I agree I'm just trying to understand what's the exact difference between while and for loops. Seems so basic. C is confusing.
I would run both versions through a debugger. One isn't doing what you expect, and stepping through will probably tell you what the disconnect is between what you think the code should be doing and what it actually does.
You did not initialize ab. Also, why do you open the file inside the loop?
Since you stated above that on the last loop the value of `count[median]` is different for each loop, that's your answer as to why the results are different. The for loop is not a literal translation of the while loop, as they increment the median variable at different times. &amp;#x200B; A direct translation of the while loop into the for loop isn't as easy as you'd hoped, because your while loop orders the increment of the media variable and it's use in the `count[median]` expression differently. One can fix this by adjusting the condition statement in the for loop to compensate. First, you might want to rewrite the while loop with `++median` as the last line of the loop, and think about how you would make it work that way. Then it should be possible to translate that into the for loop.
Thank you I'm going to do that, I'm just amazed I have never had this doubt before.
I feel the opposite. This subreddit is probably half homework posts, and should have more diversity in order to be a better central resource. It doesn't need to stop question posts like /r/programming, just some diversity. However, I can contribute a post over at /r/clibs, so I will. 
How should windows support some linux api magically? Afaik there is only linux remote development / build possible with wsl or a linux system. So the import of the header files may have been skipped, but can be included 
There is no difference between while loops and for loops (!) You can convert between the 2 forms :- for(init ; test ; update) { body; } init; while(test) { body; update; } Your difference comes from doing the update at the beginning of the body.
I see. Let me put links to the 3 code snippets you shared with us to explain how to go about this. [(A) insertion\_sort](https://pastebin.com/gQeFAneq) [(B) linked\_list.c](https://pastebin.com/5YM5hARm) And (C) the structs typedef struct Node { void *data; struct Node *next; struct Node *prev; } Node; typedef struct LinkedList { Node *head; Node *tail; } LinkedList; 1. In (A) Line 14, you are referring to nodeB but you haven't initialized it as a LinkedList \*. You should do that. 1. Also, the naming is probably wrong. You should call it listB or linkedlistB or something. Node from your code in (C) refers to one node of the list and not the entire list. LinkedList refers to the list. 2. You are right in saying you need to add to list B first and then remove from list A. Otherwise the data will be lost. 1. To add to list B, figure out the value of data of head of list A. 2. Use this data to add a node to list B. (Think on whether you should append or prepend) To understand the compilation errors: 1. "assignment from incompatible pointer type nodeB = nodeB-&gt;head": You are assigning nodeB-&gt;head, which is of type (Node \*) to nodeB, which is of the type (LinkedList \*) on Line 19 of (A) 2. "LinkedList has no member data" and "LinkedList has no member next" : This is because according to (C) LinkedList does not have those members. But you are using them on lines 22 and 26 of (A). You are mixing up data types in your code and hence your naming seems off and hence you are getting errors. Try to go about it slowly. Just decode one line of pseudo code at a time and do not move ahead until you can compile it. And feel free to ask any more questions. 
&gt;Seems so basic That's a sort of unintentional pun. :) But yes, learning new things can be confusing, and even discouraging. But you are close, and thinking about this exercise and why the loops are different will hopefully make it less so. It's one reason why multiple forms of looping are possible in C. Note - there is a way to literally translate a while loop into a for loop (and vice-versa), but the ordering of statements matter, and your ordering isn't quite correct. It's slightly trickier for you because you started with a while loop which, although it works, is in almost exactly the wrong form to translate directly into a for loop. Better to start (imo) by adjusting the while loop so that it still works, but is in the form closest to what a for loop does (which is with the increment as the last statement of the loop). It's doable, just consider what the end case needs to be with that change.
Well, it's not currently flooded with library posts. But libraries are in many ways the measure of the popularity and practicality of a language, so library posts are good, not bad. Put those two things together and I think /r/C_Programming could stand to have more library posts, not fewer. 
As a separate, but related issue, can you tell or show us what the definition of MAX\_VALUE and the `count` array are? ie. how many elements does `count` contain, and is that amount equal to MAX\_VALUE? Because it's unusual for a variable that is used as an index (as median is, into the count array) to start at 1. As another responder indicated, that suggests and off-by-one error and possibly indexing outside of the array (which is a severe error). Rather than initializing `seen_until_median` from `count[0]`, it may be more idiomatic to initialize it to zero, and start the loop with median == 0. And since `median` is simply being used to index, it's also a confusing variable name, and would be better named as a common index variable name, such as `i` or `j`.
&gt;Rust Evangelism Strikeforce For some reason, I can't stop laughing at that phrase. &amp;#x200B;
The H.264 algorithm is quite complicated. I don't think you need to know how it works to effectively use the library.
Looks good. Cool. Don't know why people are downvoting me for asking that. 
&gt; This one just takes the fscking cake. I feel like that one is a joke, as it says in the README: &gt;Q. When will you rewrite it in Rust/Go? &gt;A. After I finish porting it to Haskell Feels like this lib is a joke, esp. since it also says: &gt;Q. Why not use &lt;stdbool.h&gt;? &gt;This is faster.
Apologies if I am extremely uneducated on the topic, but you wrote that your library has a focus on security. Why? Is there something insecure in libpng?
 *How should windows support some linux api magically?* An experienced programmer writes wrappers around windows system calls and a whole lot other stuff. That's what cygwin probably does.
&gt; Is there something insecure in libpng? [It's a complete mess](http://latentcontent.net/2007/12/05/libpng-worst-api-ever/), which enables it to be a [security nightmare](https://www.cvedetails.com/vulnerability-list/vendor_id-7294/Libpng.html).
&gt; but the freaking code doesn't even work when I compile it :/ &gt; I want to make stuff like this (https://imgur.com/a/g7vPhJI) That seems like a very reasonable project. &gt; https://www.codewithc.com/mini-project-in-c-cyber-management-system/ There are no build files in there. Those are the files that give the recipe to compile. Also, this project is for Windows -- you can tell becomes it has lines like this in `config.h`: #include &lt;conio.h&gt; //for doing console input output #include &lt;windows.h&gt; //defines a very large number of Windows specific functions that can be used in C. #include &lt;winsock2.h&gt; // contains functions for socket programmming Those aren't present on Unix/Linux or macOS. 
It is a reasonable project but if the source code is presented *it should work.* Im doing this to learn how can I learn if I dont even know what anything does? Im new to C so I dont know all these details. and I am on windows.
I agree. But you'll want to find something with instructions that compiles, then double back to this one when you have a little experience and can put together the build file (often called "project file(s)" on Windows, I think) yourself. I'd look for something on Github that is known to work on Windows. If you have your compiler already installed, then usually you can clone a Github project and have it compiling in less than a minute. However, I'm not a good candidate to point out such a project because I'm not using Windows right now and am much less familiar with its development environment. 
I assume you want to use a decoder/encoder api? Unfortunately these are pretty terribly documented, but ffmpeg has an examples directory in their GitHub repo worth checking out. These usually expect elementary streams. If you’re working with a muxed stream (e.g. video with audio), you’ll need a demuxer in front as well. What exactly are you trying to do?
sync the library with WINAPI calls to record either a window or a rectangle on the viewport. Combine that with a clever interface design. Post it on my website for a small price and earn passive income.
Would fit better at r/clibs, a recently created sub for c libraries.
Yeah you don’t really need to mess with a codec directly. Just use some compression lib and make sure its license is compatible with commercial use.
It just means that it should work predictably with arbitrary data.
Bro this is not C++. This is C. I can probably help you anyways but for the love of Ritchie please format it correctly, there are some weird whitespaces between newlines.
I posted it there a bit ago. I don't think this sub has an excessive amount of library discussion, though. 
They are using the C++ standard library...
Well they did you use cout...
It’s difficult to learn a whole new concept like memory management just by reading code. You should learn it, and any other language features you don’t understand, by doing tutorials. Then try to make a small project of your own. E.g. a game where the computer guesses what number you have in your head. Build it. Run it. Then come back to this project, and you will have a better chance at understanding it. You’re right, you won’t learn anything by copying code. But you might learn something by reading code and trying your best to understand it. Modify it or fix a bug in it, to test your understanding. Then take what you learn and apply it to your own projects, which can slowly grow in complexity.
I tried to read your badly formatted code OP and it probably has to do with a cout outside the else statement which will always be printed regardless of whether there was a 5 or not. 
what did you do to compile it? You probably did it wrong or you could at least post error messages. Learning how to compile stuff is probably one of your biggest problems right now, no need to go further if you can't get that done. 
How does this compare to `stb-image`?
Please post a minimal complete reproducible example of your problem, correctly formatted for Reddit.
Recursive macros?
 #include &lt;stdio.h&gt; int i; float x; char name[30]; int main(void) { scanf("%3d %5f %s", &amp;i, &amp;x, name); printf("%d\n", i); printf("%f\n", x); printf("%s\n", &amp;name); return 0; } &amp;#x200B;
If you want 1 decimal place, use %5.1f. Also, don't ignore the return value of scanf.
if want name to print a string instead of numbers like in the example: [https://i.imgur.com/5SON9zo.png](https://i.imgur.com/5SON9zo.png) &amp;#x200B;
Better to send error messages to stderr than stdout.
&gt; I question whether windows natively support those 3 headers from a linux app built in functionality standpoint. Then why don't you ask that question on Stack Overflow instead of a completely nondescript "cannot compile this code" without any further details?
No.
Neato burrito. I'm still not finding zlib as an external dependency between either of them as being very neato :|
How did Ritchie steal the spotlight from Thompson? They created Unix together, but Ritchie created C alone.
Well, you don't have braces, `{` and `}`, around your `for` loop, so all that's in the loop is `sum = 0;`.
`a * b` is not squaring. Read about what square is first. 
Sorry for that but I know whats squaring. But I just don't know how to do it in C++.
Do we have put braces around for?
You need braces around the *content* of the loop if it's more than one statement (i.e. the loop controls either a single statement or a block). But that's irrelevant, because there's a lot more that's wrong with your code. I suggest that you use an IDE that automatically indents your code for you, which will help you see its actual structure; and I suggest that you sit down with a piece of paper and “play computer”, i.e. execute the program manually, writing down everything that happens line by line. You will quickly see that your program isn't even close to doing what you want.
No, you need an opening brace after the initialisation section i.e. the bit ending with `)`, and a close brace after the things you want repeated - in this case, it should go after the `sum = sum + ...` part. Of course, you still need to correct the maths in that line: squaring the value of the variable `a` can be represented as `a * a`. (Also, what are you trying to do with the `getch()` line?)
This subreddit is about C, not C++. But that's OK, because your program is C, not C++. The only issue I have with it (apart from it being completely wrong) is the use of the non-standard header `&lt;conio.h&gt;` and the non-standard function `getch()`. You can simply use `getchar()` instead (it is declared in `&lt;stdio.h&gt;`), although that means your program won't register a keypress until you press Enter (at which point `getchar()` will return the first key you pressed).
&gt; (Also, what are you trying to do with the getch() line?) They're working on a Windows machine and need that `getch()` to pause the program when it's done so they have a chance to see its output before the window closes. Unlike `getchar()`, `getch()` is unbuffered.
Ah! Thank you; i'm (obviously) not familiar with C dev on Windows ....
I'll give you a hint: you don't need `b`
...or `sum`.
Hi Sir, i changed the code, now it's much simplier, and the problem still [remains.](https://remains.Now) Now i receive only 1 number, on serial data. 2222222. And the program should write 10 lines, with 5 numbers each, and close the file. The program works for some seconds, and then stops working, and dont close the file and move it to another folder anymore, Sho what should i do? Thanks for any help #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; void write_line (); int ab; int main() { system (" stty -F /dev/ttyUSB0 300 raw -hupcl"); // set baud rate do 300 while (10&gt;1) // loop forever { FILE *file1; file1 = fopen("aquivo.csv", "w+"); // open the csv file ab=10; // counter for how many lines each file while (ab&gt;0) { write_line (file1 ); // this function will print a line on the csv file fprintf(file1,"\n"); // create a break and skip in the line ab=ab-1; } fclose(file1); // when all 10 lines are completed close the file system (" mv -f /home/pc/aquivo.csv /home/pc/public"); // move the file sleep (2); }// loop forever return 0; } ///////////////////////////////////////////////////////////////////////////// void write_line (FILE *f) // file f will be file1 { int a=5;// write 5 numbers each line while (a&gt;0) { char *portname = "/dev/ttyUSB0"; char buf[1]; int fd = open (portname, O_RDWR | O_NOCTTY | O_SYNC); read(fd, buf, 1); // read serial data fprintf( f,"%s",buf); // create the line in the csv file a=a-1; } } &amp;#x200B;
So can you tell me what I need to do now?
You’ll never learn from scratch if you are reading other people’s code. You’ll learn by making your own projects, from scratch.
This is not a C++ subreddit, note that C and C++ are wholly different languages that exist separately. C++ is neither the continuation nor a superset of C. For C++ questions, go over to r/cppquestions
C++ is off topic in this subreddit. Please ask C++ questions in /r/cpp_questions instead.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Reading other people's code is fine and a good habit. But then, you should go and implement the ideas you found there yourself and never copy anything from other people's code.
fair enough, thanks &amp;#x200B;
First of all, you really need to properly indent your code. Use spaces or tabs or whatever but please do it properly. I took a minute or two to do so, and I found a little overview on your part where a line in your code seemed to have wondered off in the comment above it. \`\`\`C \#include &lt;stdio.h&gt; \#include &lt;stdlib.h&gt; \#include &lt;string.h&gt; \#include &lt;fcntl.h&gt; \#include &lt;unistd.h&gt; &amp;#x200B; void write\_line (); &amp;#x200B; int main() { system (" stty -F /dev/ttyUSB0 300 raw -hupcl"); // set baud rate do 300 &amp;#x200B; while (1) { FILE \*file1; file1 = fopen("aquivo.csv", "w+"); // open the csv file int ab = 10; // counter for how many lines each file while (ab &gt; 0) { write\_line (file1); // this function will print a line on the csv file fprintf(file1,"\\n"); // create a break and skip in the line ab--; } fclose(file1); // when all 10 lines are completed close the file system (" mv -f /home/pc/aquivo.csv /home/pc/public"); // move the file sleep (2); } // loop forever return 0; } &amp;#x200B; void write\_line (FILE \*f) { int a = 5; // write 5 numbers each line &amp;#x200B; while (a&gt;0) { char \*portname = "/dev/ttyUSB0"; char buf\[1\]; int fd = open (portname, O\_RDWR | O\_NOCTTY | O\_SYNC); read(fd, buf, 1); // read serial data fprintf( f,"%s",buf); // create the line in the csv file a--; } } \`\`\`
And again, OP says not a single word about this crucial detail in his question. OP should put more effort into his questions, the downvotes turn into upvotes really quickly once you start giving a shit about writing a good question.
HI, i receive continousily on my serial port 252525... I use the C program above, it creates the csv file, and move it, writing: 52525 25252 this for 10 lines... But after 20 seconds, the program stops working, the file on destination folder don't show numbers anymore, only the file. But the serial continues receiving the data fine, what should i do?
I am really really sorry for that. I thought C++ and and Cpp are two different languages. Its kind of my fault but that what my school taught me. But thanks for correcting me :)
CPP is often used as a name for C++ when + signs can't be used for one reason or another. CPP also refers to the C preprocessor, which is the program that resolved include directives and macros. This subreddit however is exclusively about C; C++ is not the same language as C, so C++ posts are off topic.
I [already did](https://www.reddit.com/r/C_Programming/comments/a1fy1m/how_to_make_program_that_print_the_sum_of_squares/eaph8wg/).
This is a C program, though.
It is also a valid C++ program though. What counts is the intent of OP.
i just need a program to detect serial data from arduino, close the csv file when 10 lines are reached, and send it to another folder, could you code this for me? I know that my code is wrong, help me please
My main issue is I've never worked with arduino, so if your problem resides with that, I might not be able to help. However there are still a few isses with the code. For example in your `write_line` function, you call `open` and `read`, but never `close` . This is bad practice. You also write `buf` in your csv file as a string, in this case, you should set `buf[1]` to `'\0'`, as `read` does not null terminate. &amp;#x200B;
I would make the following changes. Please ask if anything is unclear #define MAX_INPUTS 100 #define MAX_NAME_STR_LEN 50 //includes null terminator #define MAX_NATIONALITY_STR_LEN 4 //includes null terminator struct cyclist { char name[MAX_NAME_STR_LEN]; char nationality[MAX_NATIONALITY_STR_LEN]; }; struct dk_cyclist { char name_1[MAX_NAME_STR_LEN]; int count; }; int struct_dk(cyclist *input, dk_cyclist *output) { int new_output_index = 0; //index in output where we are writing to for(int input_index = 0; input_index &lt;= MAX_INPUTS; input_index++) //loop through all possible inputs { if (strncmp(input[input_index].nationality, "DEN", MAX_NATIONALITY_STR_LEN) == 0) //see if nationality is DEN and avoid str len errors { bool is_input_in_output = false; //flag that indicates a duplicate for(int output_index = 0; output_index &lt;= new_output_index; output_index++) //loop through all outputs to the current one { if(strncmp(input[input_index].name, output[output_index].name_1, MAX_NAME_STR_LEN) == 0) //see if names are the same and avoid str len errors { output[output_index].count++; //increase the duplicate count is_input_in_output = true; //set duplicate detection flag break; } } if(false == is_input_in_output) //if not duplicate { snprintf(output[new_output_index].name_1, MAX_NAME_STR_LEN, "%s", input[input_index].name); //write input name to output name, protect against buffer overflow output[new_output_index].count = 1; //set occurance count to 1 new_output_index++; //increase index for next output printf(" %-35s %-5s\n ",output[new_output_index].name_1, input[input_index].nationality); //print new addition } } } return 0; }
Can you please apply my advice, and tell me if it works? I'm curious to know what the issue is
These two articles outline the general ideas behind H.264 pretty well. For the gnarly details, there isn't much you can do besides reading the specification to understand them: * [An Overview of H.264 Advanced Video Coding](https://www.vcodex.com/an-overview-of-h264-advanced-video-coding/) * [H.264 is Magic](https://sidbala.com/h-264-is-magic/)
HI, actually i'll have to get back to the books, i don't know how to code in C, just the very basic, i was just copying parts of code from others, but your advices make sense to me, but i don't know how to write them now, so it'll take some time, when i'll be able to write the code, i'll respond if it works, thanks for now
Really? First sentence from Wikipedia [https://en.wikipedia.org/wiki/Square_(algebra)]: *In mathematics, a square is the result of multiplying a number by itself*. Combine this with what I told you about not needing `b` and you have `a * a`.
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; void write_line (); char *portname = "/dev/ttyUSB0"; int fd = open (portname, O_RDWR | O_NOCTTY | O_SYNC); int main() { system (" stty -F /dev/ttyUSB0 300 raw -hupcl"); // set baud rate do 300 while (1) { FILE *file1; file1 = fopen("aquivo.csv", "w+"); // open the csv file int ab = 10; // counter for how many lines each file while (ab &gt; 0) { write_line (file1); // this function will print a line on the csv file fprintf(file1,"\n"); // create a break and skip in the line ab--; } fclose(file1); // when all 10 lines are completed close the file system (" mv -f /home/pc/aquivo.csv /home/pc/public"); // move the file sleep (2); } // loop forever close(fd); return 0; } void write_line (FILE *f) { int a = 5; // write 5 numbers each line while (a&gt;0) { char buf[1]; buf[1] = 0; read(fd, buf, 1); // read serial data fprintf( f,"%s",buf); // create the line in the csv file a--; } } You should do that, C is awesome, but it has very strict rules. Here is to get out of your jam (if my advice works, I don't have a way to test it atm)
&gt; It is also a valid C++ program Shouldn't they be using `&lt;cstdio&gt;` instead of `&lt;stdio.h&gt;`?
`stdio.h` is legal but deprecated in C++.
Might get more responses if you say roughly what you want done.
Might get more responses if they posted to a C++ sub.
Thank you all guys. This was very helpful.
hi, it does not compile, only when i place "int fd = open (portname, O_RDWR | O_NOCTTY | O_SYNC);" inside the write_line function. And then it compiles, but the problem remains, it works for about 10 seconds, then stops working. What should i do next? 
OMG it works!! You made a grown man almost cry here, thanks a lot Sir, if it wasn't for your help i would lose days or weeks stuck on this, god bless you
Though I am not good at maths but I know that. And by \`a\*b\` I was trying to take square of each number then adding their squares. I even wrote &gt; I don't even know what is happening because it got really confusing. But thanks for the help :)
I am sorry for that.
No need to feel sorry! Just pick the right subreddit next time.
Not exclusively, but it's definitely welcome
I would like to know comparison details as well.
I will. But Thanks.
 OK, maybe I'm just short-sighted in this regard, but do you have an example?
I’m using a pretty old book( teach yourself c in 21 days) and I’m using linux fedora and a program called Geany 
The amount of overhead sadly makes the humor lost on me.
[http://n-gate.com/hackernews/2017/01/](http://n-gate.com/hackernews/2017/01/) Search for "taxi".
https://www.reddit.com/r/programming/comments/a1bs9k/libspng_040_first_stable_release/eapanou/
Change stfptr to stdout or just usr printf() printf("your text here");
I changed all the stdprn’s to stdout and the compilation was successful but when I tried to build it, it failed
Compilation is part of the build process
Yes I just found out I said fprint instead of fprintf thanks anyway
Where is variable page declared ? That might be the problem
I fixed it it’s fine
If this is the first stable release, why doesn't the version begin with a 1?
Yes, it is. 
If each string is going to have a calloc-block's worth of overhead anyway, an additional four bytes is probably not a big deal. If, however, one were designing a string library to use as little storage as practical, a library limited a total of ~65,000 bytes worth of strings could manage a garbage-collected list of strings with a total overhead of 4-5 bytes per RAM string (for strings of even/odd lengths), and a RAM cost of 6 bytes for a ROM-based strings. If many of the strings are going to be fairly short, the difference between 4-5 bytes and 8-11 bytes can be pretty significant. Further, I'm dubious about how often one should work with strings over 65,535 bytes without making some provision for sharing references to identical strings. Such provisions may not be necessary when working with short strings, but become more significant as strings get longer. 
--&gt; /r/C_Homework
One is Turing-complete, and the other isn't.
Just because you can it doesn't mean you should. How is that for a generic platitude? Do you _actually_ know of a use case, or you're talking hypothetically?
Homework is not off topic in this subreddit.
With a C program, a definition for element and a little bit of thinking. 
That depends on what exactly an element is. Are you programming on Windows or on a different operating system?
When you print the `name` you are passing a pointer to a (decayed) point. The `%s` specifier is meant to be used with a `char` pointer. Do this instead: printf("%s\n", name); Any decent environment should have given a warning.
the most complicated parts in C are pointers, the problem if that you want to be good at working with strings you have to understand pointers well. pointers and arrays in think are the most complicated parts
Recursive macros aren't exactly a niche use-case, but sure, I can come up with an example if you give me a few minutes.
this tutorial is very good, i read this last month, and now i'm doing good programs http://www.kciti.edu/wp-content/uploads/2017/07/cprogramming_tutorial.pdf
Okay thanks! 
I think you mean gnutls\_hash\_hd\_t \*hash; gnutls\_hash\_init(&amp;hash,GNUTLS\_DIG\_SHA256); yes but it breaks there &amp;#x200B;
How about zero effort/research code requests? 
Okay, you're very close. You just need to do what I said above and pass a pointer to the array of `struct2`. Your function definitions will need to change from: void initialize_struct2(struct1 arr1[], int v, struct2 arr2[]); int remove_duplicates(struct1 arr1[], struct2 arr2[], int next_per2, int j); to: void initialize_struct2(struct1 arr1[], int v, struct2 *arr2[]); int remove_duplicates(struct1 arr1[], struct2 *arr2[], int next_per2, int j); Before you were only passing a **copy** of `arr2`. You want to pass the **address** of `arr2` so it can be changed. The syntax for accessing elements from `arr2` will also require change from: arr2[next_per2].completed_race++; to: arr2[next_per2]-&gt;completed_race++; or even: (*arr2[next_per2]).completed_race++; &amp;#x200B;
Thanks, i made it work. :D
Your code formatting is broken to the point of illegibility. Please use [pastebin.com](http://pastebin.com) to upload your code in a viewable manner.
Lots of problems in your code at stack overflow. First is gnutls_hash_init() expects it's first argument to be struct hash_hd_st **, but you are passing it a struct hash_hd_st *. Do this instead: gnutls_hash_hd_t dig; gnutls_hash_init (&amp;dig, GNUTLS_DIG_SHA1); The above works because the gnutls_hash_hd_t type is actually struct hash_hd_st *. The below code works for me: $ cat tmp.c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;gnutls/gnutls.h&gt; #include &lt;gnutls/crypto.h&gt; int main(int argc, char *argv[]) { char *ptext = "Hello World!\0"; size_t ptext_len = strlen(ptext); gnutls_hash_hd_t dig; gnutls_hash_init (&amp;dig, GNUTLS_DIG_SHA1); gnutls_hash(dig, (const void *)ptext, ptext_len); unsigned int *otext = calloc(1, gnutls_hash_get_len(GNUTLS_DIG_SHA1)); gnutls_hash_output(dig, (void *)otext); printf("%X\n", *otext); return 0; } $ gcc -lgnutls tmp.c $ ./a.out E6BDF72E $ Though to be honest I don't know enough about the gnutls library to know if I'm using gnutls_hash_output() correctly with that printf(). 
Don't use static memory for passing array between functions. Use malloc.
Element? Are we talking byte, char, line, sentence, paragraph, pixel?
What does functionA look like? void functionB(char array) `array` isn't an array. It is a single character. You can't cast it to a pointer.
Fixed it, please check it again
functionA makes a 2D array from a file and then calls functionB with that array as an argument. https://pastebin.com/eFdyZBrE &gt; array isn't an array. Ah, no it isn't. I've tried array[] but get the same issue.
 void functionA() { // makes array from file functionB(array); } That's not your real code.
Remove the `&amp;` from `&amp;name` in your printf call.
https://pastebin.com/sT933XHg
&gt; But I don't know how to dereference t-&gt;data to get the integer p is pointing to.. *(int*)t-&gt;data doesn't work.. *(int*)(*t-&gt;data) https://ideone.com/eIs7zZ
yes, it was a typo :( thnaks
That wasn't the problem in the other thread.
It is the same. You want to read and store strings inside an array, you can't because you ignore everything that is posted and can't be bothered to think. 
I have done that, this is a different issue.
Then start by realizing a char is far from a pointer and that = is not the same as ==
Frowned upon, but not off topic.
 char wordArray[ROW][COLUMN]; sortArray(wordArray); The prototype of sortArray must be void sortArray(char array[ROW][COLUMN]); or void sortArray(char array[][COLUMN]); You can leave out the size of the left most dimension.
Your code doesn't match your question. You asked how to write to a file. Your code opens a file for write access, then reads from it. Assuming the code represents what you want to do .... open the file for read access instead.
If I understand your issue correctly, and I am not sure I do, the this is what I'd do: 1. Allocate space for your two dimensional array above the option section instead of below it. 2. Add a function parameter for the two dimensional array to all the existing functions that currently print an asterix pattern, and pass the array each time one of these functions is called. 3. Keep `row` and `col` variables in each function and initialize them to zero. 4. For each case of `printf(" ");` replace it with `array[row][col] = ' '; col++;` 5. For each case of `printf("*");` replace it with `array[row][col] = '*'; col++;` 6. For each case of `printf("\n");` replace it with `row++;`
Use the append modestring as the second argument to fopen—"a"
Called fwrite.
I assume you meant `fopen`, not `open`? (The compiler should complain about using `open` like that, at the very least.) `fopen` is the stdc function that returns a `FILE *`, and `FILE *`s are what you use for `fscanf` &amp;al. `open` is a UNIX/POSIX function that returns an `int` file descriptor and uses integer flags, not the (rather more stupid, but whatever) string sort. `fopen` with flag `"w"` (in general use `"wt"`/`"rt"`/`"at"` for any text file I/O, `"wb"`/`"rb"`/`"ab"` for binary) will create file.txt if it doesn’t exist, and truncate it to zero bytes if it does exist. But yeah, like jedwardsol said, you can’t `fscanf` from a file opened in a `"w"` mode. When you’re done writing the file, make sure to `fclose` it; changes might not show up until then or an `fflush`, because small writes are usually buffered by the stdio implementation. (`open` and POSIX things aren’t buffered in user mode, and changes will show up right away, network mountpoints notwithstanding. Buffering may mean that I/O errors don’t show up until close or flush.) If the program terminates normally, stdio should flush things for you, but it’s good practice to balance opens and closes explicitly in case you need to expand the program. This also means that if the program terminates abnormally (e.g., `SIGKILL`, `SIGINT`, `SIGSEGV`) after you finish writing, you’ve saved the file off properly. Make sure to check that any action reliant on outside forces is actually carried out successfully. The `fopen` could fail for any number of reasons. `scanf`s and other reads can fail because of I/O error, EOF, or bogus input. If you have good error handling, the program will tell you what went wrong in these cases; e.g., fPointer = fopen("file.txt", "wt"); if(!fPointer) { fprintf(stderr, "error: unable to open file.txt for writing: %s\n", sterror(errno)); return 1; }
use fprintf (for string) or fwrite (for binary) to write data to file. use append mode ("a" or "ab") file opening to add data to an existing file (at the end). &amp;#x200B;
&gt; write with scanf [scanf/fscanf](https://en.cppreference.com/w/c/io/fscanf) reads from the input stream / file.
Gah such a simple mistake, thanks!
No, that makes no difference since `name` is an array, not a pointer. The reason why the program doesn't print “Jennifer” is simply that that's not what's in the string.
Start by fixing the `scanf()` issue.
did this a while back , i think this was the solution i can remember, there was a flag for open() i think O_APPEND open( file name whatever , whatever flags | O_APPEND , 0644)
why isnt it?
Because it won't compile. And I'm not just saying that because it's incomplete. I could wrap it in `int main() { }` and add the necessary includes and it still wouldn't compile. Please provide a minimal working example.
Now that you've fixed your code: it's working exactly as expected. You should take a closer look at the documentation for `clock()` and the output from `time`.
its called a snippet,
No, there were mistakes in the code which you corrected after my comment.
Just a heads up, I don't think people are going to respond to this well.
wow. ... an extra % who cares i didnt copy and paste my code i manually wrote it out into the reddit post. 
Bro you are asking me to debug your code. People get paid for that stuff. You need to at least pinpoint where the problem happens.
What do you use it for iostream?
 .... i suggest you keep your lecturing to yourself. 
Not sure why nobody has said this yet, it's somewhat worrisome: what you want to do is change the "w" to "w+" which means "write and/or update" - allowing you to modify the data of an existing file. If the file does not already exist then it will be created. Use fseek() to set the offset in the file where you wish to write.
you are using open &amp; f** calls.. so yeah no that wont work. Also you opened the file wrong, check fPointer, and you'll find that it should be null. &gt; Creating and Writing to a Text File &gt; &gt; The WRFILE.C program opens a text file, writes a string to it, and closes the file. &gt; /* WRFILE.C: Create and write to a disk file. */ &gt; #include &lt;stdio.h&gt; &gt; main() &gt; { &gt; FILE *fp; &gt; if( (fp = fopen( "c:\\testfile.asc","w" )) != NULL ) &gt; { &gt; fputs( "Example string", fp ); &gt; fputc( '\n', fp ); &gt; fclose( fp ); &gt; } &gt; else &gt; printf( "error message\n" ); &gt; } &gt; You must include the standard I/O header file ( #include &lt;stdio.h&gt; ) whenever you plan to call input or output functions. It contains essential definitions and prototypes that you need. &gt; The only variable in this program is fp which is declared as a pointer to a FILE. FILE is defined in STDIO.H as a structure of _iobuf type, but we don't need to know the specifics. We will refer to the variable fp as a "FILE pointer." &gt; The first statement combines several operations in one line: &gt; if( (fp = fopen( "c:\\testfile.asc", "w" )) != NULL ) &gt; The fopen function opens a file. It expects two parameters, both of which are literal strings or pointers to strings. You provide the name of the file to be opened and the type (read, write, or append). The six types of files are listed in Table 11.3. &gt; Table 11.3 Disk File Types &gt;ÖÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ· &gt; Type Action &gt; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ &gt; r Open an existing file for reading. &gt; w Create and open a file for writing. Any &gt; existing file is replaced. If the file &gt; doesn't exist, a new file is created. &gt; a Open a file for appending. Data is added &gt; to the end of an existing file or &gt; a new file is created. &gt; r+ Open an existing file for reading and &gt; writing. &gt; w+ Create and open a file for reading and &gt; writing. An existing file is replaced. &gt; a+ Open a file for reading and appending. &gt; Data is added to the end of an &gt; existing file or a new file is created. &gt; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Pretty sure you can improve it: * *nextdata* starts at the start (well, second position), and always iterates through the entire list * *currentdata* restarts at the start, and always iterates through the entire list Watching the animation on [Wikipedia](https://en.wikipedia.org/wiki/Insertion_sort), it appears that *currentdata* merely needs to restart at *nextdata* (**not** at the start: improvement #1) **and** as *nextdata* advances, it appears that everything behind *nextdata* is guaranteed to be sorted, therefore you can stop the inner loop once you cease swapping (improvement #2): You can see your condittion for breaking the inner *while* is only that you've reached the end; the Wikipedia pseudocode shows the condition for breaking the inner loop is that you've reached the end *or* a comparison fails/passes. Finally, after your *compare()* you do a swap, but do not advance; the next loop of the inner *while* immediately does another compare, **but since you haven't advanced** you're comparing the exact same two values again (just in the opposite order, of course). If you perform the swap, you might as well advance *currentdata* straight away and skip this redundant comparison (improvement #3). Note that I haven't fully studied the correctness of your solution or confirmed that it's actually an insertion sort: I've merely focused on the loop break conditions (and their setup). I do have concerns that yours is not correctly an insertion sort: you go "forwards" through your list in both loops, but the Wikipedia pseudocode traverses forwards on the outer loop, and backwards on the inner loop. So having said that, it's possible that my Improvement #1 in particular is NOT applicable for your implementation. But I believe #2 and #3 would still apply.
Add trace code (strategically placed `printf`) to your program to see what is happening. I would start by debugging you read input to verify that the data is being read correctly to start with.
When you compile, do you compile with -Wall? That will make sure it gives you additional warnings that the compiler wont automatically complain about. gcc file.c -o file -Wall Also, as /u/g0jirasan mentioned, when you use scanf you need to use an ampersand. So the proper code for a scanf call would be int num; scanf( "%i", &amp;num ); Also, when posting errors like that, try to post the smallest example possible that reproduces the error you're having. I couldn't compile your code because I don't have structs.h.
The directionality isn't super material to whether or not it's an insertion sort. It's the difference between inserting the smallest values in ascending order, or the largest values in descending order. This wouldn't make a difference in an array, but in a a singly linked list, the only sensible direction is to go largest descending.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
First, you don't need to include &lt;iostream&gt; --- that's for C++ only, C does not use that library. Second, I think you want to use printf ("%s", Akce[cislo_akce].otazka); %c is for single characters, %s is for strings. So when you pass a string to printf with the %c format identifier it will only print the first character. You can prevent this from occurring in the future by turning on advanced warnings when you compile. Use: gcc file.c -o file.out -Wall -Wall stands for warnings: all, and will make the compiler complain about more things.
 #include &lt;stdio.h&gt; int main() { int numTest; char strTest[256]; printf( "Enter a number: " ); scanf( "%i", &amp;numTest ); printf( "Enter a string (Less than 256 characters long): " ); scanf( "%s", strTest ); printf( "\nYou entered:\nNumber: %i\nString: %s\n", numTest, strTest ); return 0; } Scanf is weird, you use an ampersand when you're not using a pointer, no ampersand when you are.
You're not using `clock()` wrong, you just misunderstood what it does. But using `%d` instead of `%f` is a pretty significant mistake which could actually have explained why you didn't get the output you expected.
I thought that might be the case, in which case *currentdata* beginning from the start does make sense. I do believe everything already behind *nextdata* though is guaranteed to be sorted, so I **think** the biggest optimisation is that the inner loop can break once *currentdata* catches up with *nextdata*.
Oh yeah you're absolutely right! As soon as I read that I was like "damn it, of course" lol. I still think he issue lies around his referencing of pointers somewhere. To OP, I would make sure to just go through the code again and pay attention to what is a pointer, what isn't and make sure they are being used correctly. 
....that is using it wrong
I'm agreed on that one. 
Isnt it always going to be stored in the struct of that current node? So np-&gt;fname?
How would it know what the “current node” is? You keep passing the same node to `getContactInfo()`, then you add a new node but immediately forget about it. The usual idiom would be to have `getContactInfo()` allocate and fill in a new `struct ContactInfo`, then have `addContactInfoToList()` append that new struct to the existing list. It is also customary to keep track of the last element that was added to the list so you don't have to walk the entire list the next time around. Also, in `getContactInfo()`, why don't you just `scanf()` directly into the struct?
What he's getting at is you are overwriting the first node in your list every iteration of the loop.
About the scanf, I did that for testing purposes early. New code is here: [https://pastebin.com/1LNc6kPx](https://pastebin.com/1LNc6kPx) " then have addContactInfoToList() append that new struct to the existing list. " Isnt that what I am doing with return ptr-&gt;next; Isnt the next telling it to go to the next node?
I guess I am just confused on how to make it go to the next element of the list
&gt;When the function getContactInfo(root) is called I thought that it is putting to the next node on the return statement There is no return statement on that function. You always pass it the 'root' node, and it's putting the info in the node you pass to it. &amp;#x200B; Typically, one might expect a function called getContactInfo() to not take a ContactInfo node, but allocate and return one instead (or a pointer to one, more specifically). Then the users of that new ContactInfo node can decide what to do with it (such as place it at the end of a list).
Where do you get the idea that because something works makes in correct? Why don't you take a look at the warning given with -Wformat
The address of an array is the address of its initial element, and that is the requirement for the `s` conversion specifier. I can't find anything that says whether the two types are compatible. But regardless, that is not the bug in OP's program.
Try to break it down into subtasks. Can you write a function that returns a new number from the Fibonacci series every time you call it? Hint: use a couple of static variables.
A few general pointers that could improve your coding experience: 1. Use more descriptive names for your variables. in this line: 'int height, width, i, j, M, b, s, k, num = 3, N, spaceEnd, spaceStart, a, width_1, width_2, option;' what is M? How about s? What is the significance of a? It makes it difficult to read your code. Rather use variable names such as row, column, index, length, max_length, min_height, etc. 2. Don't use a return code if you aren't going to return any new information. at the end of the obstacles function you always return 0. You could change the obstacles function to be a void function and leave out the return 0; 3. Only add an input to a function if the function couldn't have known about it otherwise what I mean by this is in this function: 'int obstacles(int N, int i, int s, int a, int width, int j)' The function couldn't know the value of N beforehand. All of the other variables are either derived from N, have a predetermined value, or are used as list iterators Replace this function: int obstacles(int N, int i, int s, int a, int width, int j) { if (N &gt;= 2 &amp;&amp; N &lt;= 10) { s = 2; //Starting s with 2 width = N * 2; //Calculting N * 2 for (i = 1; i &lt;= N; i++) { //Loop for lines for (a = 1; a &lt;= width; a++) { //Loop for spaces depending on the calculation of width printf(" "); } width = width - 2; //Width is being decreased by two every time for (j = 1; j &lt;= s; j++) { //Loop for the asterisks, 2 asterisks are being added in every new line because of s printf("*"); printf(" "); } s = s + 2; //s is being increased by 2 every time printf("\n"); } } return 0; } with: int obstacles2(int N) { if (N &gt;= 2 &amp;&amp; N &lt;= 10) { int s = 2; //set s = 2 int width = N * 2; //Calculte width from N for (int i = 1; i &lt;= N; i++) { //create i as the loop variable/iterator, which should be fine for code written after 1999 for (int a = 1; a &lt;= width; a++) { //create a as the loop variable/iterator printf(" "); } width = width - 2; for (int j = 1; j &lt;= s; j++) { //create j as the loop variable/iterator printf("*"); printf(" "); } s = s + 2; printf("\n"); } } return 0; } 4. Prefer declaring each variable on its own line, and initializing the variable immediately. replace int height, width, i, j, M, b, s, k, num = 3, N, spaceEnd, spaceStart, a, width_1, width_2, option; with int height = 0; int width = 0; int i = 0; int j = 0; int M = 0; int b = 0; int s = 0; int k = 0; int num = 3; int N = 0; int spaceEnd = 0; int spaceStart = 0; int a = 0; int width_1 = 0; int width_2 = 0; int option = 0; 4. Generally don't write comments where you just state that you are setting a variable. I know that some teachers require it, and it won't break your code, but if you can remove these comments: s = 2; //Starting s with 2 width = N * 2; //Calculting N * 2 as they don't actually contribute. We know exactly what 's = 2' means 5. This last one is controversial, but I recommend splitting code over multiple lines if it improves readability. I understand that this doesn't mean that it improves readability for everyone, but I reformatted the provided code below as an example. void obstacles(int N) { if (N &gt;= 2 &amp;&amp; N &lt;= 10) { int s = 2; //set s = 2 int width = N * 2; //Calculte width from N for (int i = 1; i &lt;= N; i++) { //create i as the loop variable/iterator for (int a = 1; a &lt;= width; a++) { //create a as the loop variable/iterator printf(" "); } width = width - 2; for (int j = 1; j &lt;= s; j++) { //create j as the loop variable/iterator printf("*"); printf(" "); } s = s + 2; printf("\n"); } } } int main() { int height, width, i, j, M, b, s, k, num = 3, N, spaceEnd, spaceStart, a, width_1, width_2, option; char** array; printf("Give height board size:"); scanf("%d", &amp;height); printf("Give width board size:"); scanf("%d", &amp;width); while (option != 6) { printf("Option: 1-5, 6 to exit"); scanf("%d", &amp;option); if (option == 1) { printf("Valid values 6 - 20\n"); printf("Size:"); scanf("%d", &amp;N); stairs_flag(N, i, j, b, k, a, num); } else if (option == 2) { printf("Valid values 3 - 15\n"); printf("Size:"); scanf("%d", &amp;N); castle(width_1, spaceStart, spaceEnd, N, i, j, a); } else if (option == 3) { printf("Valid values 3 - 18\n"); printf("Size of N:"); scanf("%d", &amp;N); trap_door(N, width_2, a, i, j); } else if (option == 4) { printf("Valid values of N 3 - 20\n"); printf("Size of N:"); scanf("%d", &amp;N); printf("Valid values of M 6, 8, 10, 12, 14, 16, 18, 20\n"); printf("Size of M"); scanf("%d", &amp;M); platform(N, M, i, b, a); } else if (option == 5) { printf("Valid values 2 - 10\n"); printf("Size of N:"); scanf("%d", &amp;N); obstacles(N, i, s, a, width, j); } } array = (char**)malloc(height * sizeof(char*)); for (i = 0; i &lt; width; i++) { array[i] = (char*)malloc(height * sizeof(char)); } for (i = 0; i &lt; height; i++) { for (j = 0; j &lt; width; j++) { array[i][j] = ' '; } } print_array(array, height, width); free(array); return 0; }
Fibonacci has an elegant recursive solution. The sum upto nth fibonacci is ((n-1)th number + (n-2)th number) Then, you just need to add a special case for the first couple of fibonacci numbers. 
&gt; Fibonacci has an elegant recursive solution. On the contrary, Fibonacci is commonly used as an example of a problem that looks like it could be solved with recursion but shouldn't. It is best solved by iteration.
yea it's -8
Exhausting 32 bits chokes one i7 core for several seconds. One can forget about 64 bit as every next number doubles the time. All while an iterative solution computes thousand digit bigints in an instant. It is used as bad example for a reason.
Thanks I'll try :)
Iostream removed (it was originally written in compilator on friends pc and I just leaved it there) Thanks for advice I'll try :)
https://master.tus.io/files/1413f6483e8707ed896f142725af158b
&gt; The example in the original post was mostly complete Not complete enough. It does not include the typedefs, which are crucial since you are type-punning. For instance, some of the code you've shown us uses a type called `xstr` which is neither defined nor described anywhere else. Right now, all I can tell from what you've posted is that you're leaking memory. And I'm not asking for the complete program. Take your code, remove everything that isn't necessary to demonstrate the problem, and post what remains.
Oops, I meant `xstr_t`... Here: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;stddef.h&gt; #include &lt;string.h&gt; typedef struct { char * val; size_t cap; size_t len; } * _xstr_t; char typedef ** xstr_t; typedef enum { XE_NONE = 0, XE_ALLOC, XE_DUP, XE_NORANGE, XE_OVERFLOW, XE_OTHER } x_error_t; #define ER error = #define X_CHECK_ALLOC(dest) if ((dest).val == NULL) {return XE_ALLOC;} x_error_t xstr_init(xstr_t * dest, size_t size) { _xstr_t str; if (size == SIZE_MAX) return XE_OVERFLOW; str = malloc(sizeof (_xstr_t)); if (size == 0) size = (size_t) 63; str-&gt;val = malloc(size + 1); /* String size + '\0' */ X_CHECK_ALLOC(*str); str-&gt;cap = size; str-&gt;len = 0; *dest = (xstr_t) str; return XE_NONE; } x_error_t xstr_cpy_c(xstr_t dest, char * src) { size_t ssize; _xstr_t _dest; _dest = (_xstr_t) dest; ssize = strlen(src); _dest-&gt;val = strdup(src); X_CHECK_ALLOC(*_dest); puts(_dest-&gt;val); _dest-&gt;len = ssize; _dest-&gt;cap = ssize; return XE_NONE; } int main(void) { xstr_t thing = NULL; x_error_t error; ER xstr_init(&amp;thing, 0); if (error != XE_NONE) return 1; ER xstr_cpy_c(thing, "hello"); if (error != XE_NONE) return 1; puts(*thing); return 0; } 
Why do you expect two "hello" if you are copying it once? BTW, `strdup() ` returns pointer to dynamically allocated memory, so you are overwriting the pointer to block allocated in initialization function, leaking memory. 
Best solved through explicit mathematical formula*
open or fopen ?
When you allocate the structure, you should use sizeof \*str. I think, it's hard to follow.
Holy shit... You're wrong, but you just made me realize what I'm doing wrong `_xstr_t str` should be `_xstr_t * str` Thanks!
Right, I didn't noticed that puts there. Anyway, at a glance your code looks semi-ok (after dereferencing `thing` in second puts). I can't run debugger right now, so maybe you can try?
Figured it out: https://www.reddit.com/r/C_Programming/comments/a1qeku/strdupd_string_is_sometimes_empty_once_caller/earzdn8/
Hmm, didn't think of that, was too busy riding the bugfix-high. Dang now I wanna go back and figure it out but I also need sleep
At school we are using C++ compiler but write in C that's why I'm asking there and not in C++ I just didn't delete Iostream but everything else should be in C
And at that, pointers and arrays aren't all that difficult. The whole language is just very simple overall.
Did you fix it ? I can help. 
I would write it like this: void insertion_sort(LinkedList *the_list, int (*compare)(void *, void *)) { Node *p, **pp, *sorted = NULL, *unsorted = the_list-&gt;head; /* one by one from old list */ while ((p = unsorted) != NULL) { unsorted = p-&gt;next; /* find the place in new list */ for (pp = &amp;sorted; *pp; pp = &amp;(*pp)-&gt;next) if ((*compare)((*pp)-&gt;data, p-&gt;data) &gt; 0) break; /* tuck it in */ p-&gt;next = *pp; *pp = p; } the_list-&gt;head = sorted; } Untested, just to show the idea.
Well explained. Thanks for the share. 
Not correct.
You're right. My bad.
&gt; C won't allow you to do that C won't allow you to do what?
He had recieved the information needed to fix his scanf() several times already so what are you trying to accomplish by saying it again? Depending on his *actual* implementation, which I doubt he's posted, `&amp;name` could very well be the problem for him if he's passing his char array to a function. Even if it's not his problem, it should be fixed. What's your issue?
What exactly have you tried? There are numerous guides to finding averages. 
Are you telling me you do not know how to calculate an average?
there's a context in my post i don't know to get from pointers to the average i want to get the average of sum of temperature / strlen(nwheaters) from the return average and in the main(), i want use weather_average(); that will print the average
is this part: void weather_average(struct weather *average, const struct weather weathers[], size_t nweathers) that i don't understand
how i do that?
Hi, I didn't do the calculation for you but modified the code a little bit to describe what's going on and how you might access the weather variable. One thing to note is that you should really get into the habit of turning warnings on since the compiler will help you a _lot_ with warnings. Basically, you'll need to loop through the averages and then do the calculations. /* You know how many averages you have. You can loop through them this way */ for (i = 0; i &lt; nweathers; i++) { /* Just printing a value to illustrate how to get at it */ printf("The %d temperature was %f\n", i, weathers[i].temperature); } [You can find the whole code here](https://pastebin.com/i8GK1nB3)
Here is an example: struct weather averages; // Not necessary to initialize if you clear it within the function. weather\_average(&amp;averages, weathers, 4); By using &amp;averages you're passing a reference to the variable, rather than the variable itself. This passes a pointer to the variable to the called function. This allows you to manipulate that particular variable's memory space within the function. This is done further in the main function when you are using the ptr variable. Another issue I noticed is you're defining the array as: weather weathers\[\] which will cause a compiler error due to there not being weather type. You will want to change this to: struct weather weathers\[\]
What file name do you type? If you type more than 9 characters plus a newline, the first `fgets()` won't be able to put the whole line in your buffer, causing the observed issues.
Is 11 not enough? myfile.dat is 10 plys newline is 11?
&gt; C won't allow you to do that, If you mean "dereferencing" a pointer in ``sizeof`` for allocation, then you actually can, because ``sizeof`` if a compile-time operation, not runtime.
Don't forget that a NUL terminator has to fit, too. It's generally a good idea to give your buffers a bit more space than strictly necessary so you don't get bitten by issues like this.
Thank you very much Shouldn't be **4** like u/jakeonehalf pointed me since i have 4 arrays inside of **struct weather weathers[]** in this part: weather_average(&amp;average, weathers, 3); Also in the "for loop temperature" should i do this: SumTemp=+weathers[i].temperatures AverageTemp=SumTemp/nweathers 
Thanks
You can also find the size of the array more dynamically like this: `weather_average(&amp;average, weathers, sizeof(weathers)/sizeof(weathers[0]);` How this works: The first sizeof will, at compile time, calculate the size in memory (in bytes) of weathers. Dividing it by weathers[0] will calculate the size of the first structure within the array and then give you a count of the array. NOTE: This will not work when using referenced values because they will be considered a pointer and the sizeof operator will calculate the size of the pointer (rather than the variable being pointed to by the pointer).
You are probably reading illegal memory, most likely going out of bounds on an array or pointer.
Cheers.
Yes, it should be 4 because I can't count! :D
If you're doing the counting, what's the point of a computer, eh?!
The state of this sub is dire.
???
Look at the front page of the subreddit and sort by hot. It looks like you sorted as controversial. All the posts are (no offence) shit tier nonsense like your question.
For the next time: Please do not delete your post after receiving an answer. By doing so, you deny future readers the answer you got and erase the help I gave you. Don't do that please.
http://idownvotedbecau.se/nocode/
\`\*((int\*\*)t-&gt;data) = p\` will make \`t-&gt;data\` equal \`p\`, which ie. \`t-&gt;data\[0\]\` will return \`1\`.
Thanks, the pointer to the average was one of things i wanted to get since I don't fully understand pointers I was going for the: for(i=0; i&lt;nweathers; i++){ SumTemp =+ weathers[i].temperatures; AverageTemp=SumTemp/nweathers; Since the in the function **void weather_average(...)** i had the "size_t nweathers" inside, I thought I didn't have to do the sizeof thing
https://www.purplealienplanet.com/node/20 was quite good.
So, there is a lot you should probably look at more closely here. First question - why are you using a pointer? Can you just return the value or were you given the prototype of the code? If the former, then your function prototype could look something like: ``` struct weather weather_average(const struct weather *weathers, size_t nweathers); ``` (probably would be better form to specify the `weathers` array as a pointer also). Second, if you are required to use a pointer to return the value, you don't have to dynamically allocate space for that variable. Rather than having the code: ``` struct weather variable = weathers[] struct weather *ptr; ptr = &amp;variable; ``` Simply use something like `struct weather avg = {0,0,0};` and then feed the address to the function like so: ``` weather_average(&amp;avg, weathers, (int)(sizeof(weathers)/sizeof(struct weather)); ``` To get at the average, you could then just perform the calculations in a `for` loop like `avg-&gt;temperature += weathers[i].temperature; followed on exit from the loop with a similar operation `avg-&gt;temperature \= nweathers;`. One last suggestion - get rid of `float` and get used to using `double` (unless you are working in really tight spaces); `float` can result in unexpected output due to rounding.
Thanks! 
Will check it out, thanks! 
Seems like you are using some electron editor (Visual Studio Code I think) and it seems it inherits the file descriptors from the parent (the editor).
&gt;First, by convention, `typedef` is always placed first, and `*` is attached to the variable name (`char *str`, not `char* str` or `char * str`). Likewise with `const``: even though it is technically more correct to write `char const *str`, the convention is to write `const char *str`. When I started out, I followed the conventions on both, but I always would get confused on the order of `typedef`, so when I figured out that it can go in either position (like `const`), I switched to the middle. `char *str` is sort-of up for debate, people seem to do all 3, but you're right in that the correct way of doing it is `char *str` instead of `char * str`. &gt;Second, it is generally a bad idea to typedef pointer types. Normally, you'd typedef the struct (`typedef struct foo { } foo;`) and use explicit pointers throughout. There are exceptions to this rule, but this is not one of them. Fair, I'll switch back &gt;Fourth, when defining a macro that is intended to be used as a statement, you should always wrap it in `do { ... } while (0)` so it actually behaves like a statement. Imagine the effect of `if (...) FOO(...); else blah(...);` if `FOO` expands to an `if` statement like `X_CHECK_ALLOC` does. I actually know about this one, I'm not sure why I didn't do it. Thanks for reminding me &gt;Fifth, macros like `ER` that assume that a variable with a specific name is in scope and not used for anything else are a bad idea. I got rid of it before I went to sleep yesterday &gt;Sixth, never put more than one statement on the same line, or put a controlled statement on the same line as its controlling loop or conditional. I usually follow this, but recently I've been trying to figure out how I should do loops. When I originally started out, I did this: if (x) { //stuff } Then I did this: if (x) //stuff And this: if (x) { //stuff //stuff } But at some point I decided that it might be a good idea to avoid no-brace ones, except for same-line ones. You have a good point though, I'll consider it. &gt;Seventh, when allocating memory for a struct or union, the recommended idiom is `p = malloc(sizeof *p)`. It says exactly what you need to say (“allocate enough memory for what p points to”) without repeating yourself and without running the risk of forgetting to change a `malloc()` or `calloc()` call somewhere if you should change your mind about the type of `p`. Alright
Oh, I didn't know that. Thanks. Still, when I run in terminal the same command I get: valgrind --track-fds=yes ./comp.out "/home/shlomi/Desktop/OS Homework 1/file1" "/home/shlomi/Desktop/OS Homework 1/file2" ==17492== Memcheck, a memory error detector ==17492== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==17492== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info ==17492== Command: ./comp.out /home/shlomi/Desktop/OS\ Homework\ 1/file1 /home/shlomi/Desktop/OS\ Homework\ 1/file2 ==17492== The files are equal! ==17492== ==17492== FILE DESCRIPTORS: 3 open at exit. ==17492== Open file descriptor 2: /dev/pts/1 ==17492== &lt;inherited from parent&gt; ==17492== ==17492== Open file descriptor 1: /dev/pts/1 ==17492== &lt;inherited from parent&gt; ==17492== ==17492== Open file descriptor 0: /dev/pts/1 ==17492== &lt;inherited from parent&gt; ==17492== ==17492== ==17492== HEAP SUMMARY: ==17492== in use at exit: 0 bytes in 0 blocks ==17492== total heap usage: 1 allocs, 1 frees, 1,024 bytes allocated ==17492== ==17492== All heap blocks were freed -- no leaks are possible ==17492== ==17492== For counts of detected and suppressed errors, rerun with: -v ==17492== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) Which is better, but I still don't get why it detects open fds.
`sizeof (_xstr_t *)` `sizeof (*str)` It might just be C90, but it won't let me at least. `declaration of anonymous struct must be a definition`
There's a little ebook about it, it's C++ though but still plenty of juicy info that's language-agnostic: http://cosinekitty.com/raytrace/raytrace_ebook.pdf Here's an old series about raytracing: http://www.flipcode.com/archives/Raytracing_Topics_Techniques-Part_1_Introduction.shtml If you want to get down with your bad self and do some GPU raytracing with fragment shaders (not-DXR) ala demoscene style there's some good resources here, which you can also apply to non-GPU raytracing (i.e. modeling with signed distance functions, and tracing/marching against those): http://iquilezles.org/www/index.htm
Strange. That doesn't seem to be related to your program though - `/dev/pts` only contains handles to pseudo-terminals, so this might be caused by your particular terminal emulator/multiplexer, or something in that direction.
Those are standard input, standard output, and standard error descriptors. Nobody bothers to explicitly close them on program exit, as there's no point - any open descriptors will be automatically closed anyways.
A few thoughts from reading your code: 1. When using `printf` (or writing anything to stdout), always flush the buffer when you're done writing to it. Adding a newline character to the end of your print statement automatically does this, but in instances like in the block below, there is no guarantee the print statement will print before the `scanf`. If you wish to print a statement to stdout with no trailing newline character, you should always call `fflush(stdout)` after the print call. &amp;#8203; printf("How many records do you want to add: "); scanf("%d", &amp;userNInput); &amp;#x200B; 2. Fix your indentation, it greatly improves code readability. Sequential lines should not be indented incrementally, rather you should only incrementally indent nested code blocks (i.e. statements that belong inside braces `{}`). &amp;#x200B; 3. To determine where your seg fault is coming from, we need to see your definition of `struct user` to determine how much memory each member of the struct has allocated. Segmentation faults occur from accessing invalid memory, which could be caused by anything ranging from trying to read/write from a NULL pointer, to writing past the end of an allocated buffer. In your case using strings, a likely cause could be not allocating enough space for the maximum length string with enough room for the NULL terminator at the end.
Thanks for the information Didn't know about the **avg={0, 0, 0}** since I didn't learnt it in class, others users also pointed that to me I was thinking this calculation in the "for loops" for the average: for(i=0; i&lt;nweathers; i++){ SumTemp =+ weathers[i].temperatures; AverageTemp=SumTemp/nweathers; After i just need something like this: avg-&gt;AverageTemp; Right? I use mostly floats because I learned that way hahaha, will use doubles now
You missed my point about controlled statements. I mean don't do this: if (error != XE_NONE) return 1; but do this: if (error != XE_NONE) return 1;
If it's a short lived program, who cares as long as you don't run into the limit of how many files can be open at once. For servers and long running programs, if there's any question about the possibility, I just use `lsof` to monitor it.
while (!end) { [code] if(condition) end = false else if (next condition) end = false [elif conditions] } /* end of while*/
do you mean a + dx, a + 2 * dx, ..., a + b * dx? to help we need to be clear on what the end condition looks like. 
no, I mean x in [a, a + dx, a + 2dx, ..., b]
As you have stated and indicated, that functionality can hardly be gotten through object-oriented programming but more with event driven programming where you can get to use the input that a user keys into the system and determining the output and how the software or the application can get to behave as a response to what the user has keyed in. Learning more on how to manipulate a program in order for it to be able to perform the functions that you want it to perform can be easily learnt at a good programming school like [Holberton School](https://www.holbertonschool.com) where they teach full stack software development and application programming. Some of the elements in programming that you can learn to help you stop a program when a user presses a certain key includes using triggers or signal handling or simply regular control signals which are all present in C programming language. Another alternative would be using a while loop which checks the user input for a certain value in order to execute the given command which in your case happens to be the ‘stop’ command. The loop can execute over and over depending on other variables that you can get to specify and that is what is good for using loops in you code. 
 int x; for(x = a; x &lt; b; x+=dx) { foo(x); } if(x &lt; b) { foo(b); }
 int x; for(x = a; x &lt;= b; x+=dx) { foo(x); } if(x &lt; b+dx) { foo(b); }
First of all, `+=`, not `=+` ;) Second, why are you allocating more space for space that you already have access to? And why clutter things up with _two_ temporary variables? The space is provided by the function input `avg`: ``` for(i=0; i&lt;nweathers; i++) { // No need to allocate space here... // SumTemp =+ weathers[i].temperatures; avg-&gt;Temperature += weathers[i].Temperatures; } //Don't need the variable here either // AverageTemp=SumTemp/nweathers; avg-&gt;Temperatures /= nweathers; ``` And one more note - looking over the code it looks like you are coding to C89 standards. Declare you variable with minimal amount of exposure by using the syntax `for (int i=0; i&lt;nweathers; i++)`. Also, you might want to consider posting to SO where you will get an immediate response. This space might be better reserved for deeper discussions that wouldn't be appropriate for SO.
Sorry I didn't know that, I just looked up C++ and I got this subreddit so I assumed this was for all C things or at least that I could get some help.
thanks i didn't know about += and =+, i throught were same didn't know about the **avg** before, only after others users told me what it does i don't know what is "C89 standards", learned this way and i always put **return 0;** 
 for (x = a; (!( x &gt; b &amp;&amp; (x = b, foo(x), 0) )) &amp;&amp; foo(x); x += dx); -- Ok, more seriously. This one is alright: for (x = a, finished = 0; !finished; x += dx) { if (x &gt; b) { finished = 1; x = b; } if (foo(x)) break; } If you really have a thing against `finished`, you can do one of these: for (x = a; ; x+= dx) { if (x &gt; b) { x = b; foo(x); break; } if (foo(x)) break; } Or for (x = a; x &lt;= b; x+= dx) { if (foo(x)) break; } if (x - dx &gt; b) { x = b; foo(x); } Or, a lot less readable but more concise (aka don't do this) for (x = a; x &lt;= b; x+= dx) { if (x &gt; b &amp;&amp; (foo(b), 1)) { x = b; break; } if (foo(x)) break; }
Is it okay to use the same dx every time or should you adjust the interval so that the intervals are as close to each other as possible ?
Sidenote: you must not end the loop until you've read at least one file to the end.
The fundamental issue is that msvc accepts flags with leading slash and clang (and gcc) with a dash, so that the two compilers are not interchangeable. Also the flags are different. Try to create a new project with llvm toolchain targeted. &gt;When trying to compile more complicated programs I run into a lot more problems in Visual Studio which didn't occur in Linux. This may have to do with differences between Linux and Windows.
Something about this looks weird.. First of all, your indention after the loop is lined up with the loop, while it looks like it should be part of the function. Fix that. Second, x isn't a global variable. So your function does what, exactly? We're missing part of the puzzle here. I was about to post my own style, but then I noticed a problem with the loop. If a is smaller than b, it will will never terminate. Lastly, I'd warn you that everyone has their own style, and some people can get a bit ideaological on it. Try to see what works for you. Fix the first and second things I noted and I'll gladly help with the rest. PS. are you a mathematician who for some reason got a coding assignment? I recommend that instead of dealing with two things (the code and the math) take a pen and paper so you'll have a clear prototype in your head first.
You are printing EOF in ReadFile(). The idiom for that kind of loop is int ch; while ((ch = fgetc(fp)) != EOF) putchar(ch); Notice the int. getchar() and company return ints. Valid character 0xFF can look like EOF when stored in a char.
Strangely I get less errors using cmd on windows with LLVM then using Visual Studio with LLVM. Like, I got like 2000 errors compiling in Visual Studio, but only 1 error in cmd. This seems a bit strange to me. How do you create a project with LLVM toolchain targeted?
Hard to say, depends on the code, errors and the configuration ... It's been some time since I worked with Visual Studio and LLVM, so I need to check it myself. I edited my first comment.
This looks like C++. But it compiles: class master{}; class first:public master {}; class second:public master {}; int main() { } If I put it in a file. code.cc and run g++ code.cc it compiles, but doesn't do anything. 
&gt; is this wrong code? Wrong for this sub. Try /r/cplusplus, /r/cpp or /r/cpp_questions. :-)
edit: the master class has get set methods about value of private I want to use these methods
Why did you “make it a C++ file”? What problem does that solve? As for finding the right version of `crypt()`, just copy it from [somewhere else](https://github.com/freebsd/freebsd/blob/master/secure/lib/libcrypt/crypt-des.c).
When it is a .c file I get thousands of errors like: variable "size\_t" is not a type name See screenshot of errors here: [https://i.imgur.com/LIZ51DF.png](https://i.imgur.com/LIZ51DF.png)
Wrong. mergesort has O(n log n) complexity and for linked lists it can be implemented without even requiring temporary storage, as is the case for arrays.
This sounds is more of a general algorithmic question, so please ask in /r/askcomputerscience instead of here as this subreddit is about programming in C only.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
If you can limit yourself to C11, see [https://en.cppreference.com/w/c/language/generic](https://en.cppreference.com/w/c/language/generic). If not, maybe gcc typeof() can help.
I think it will be easier if you use the LLVM Compiler Toolchain extension https://marketplace.visualstudio.com/items?itemName=LLVMExtensions.llvm-toolchain . So, you don't create a normal VS project and switch the toolchain. You use the extension to create a Clang project for you and you add your C files to the project.
&gt;When trying to compile more complicated programs I run into a lot more problems in Visual Studio which didn't occur in Linux. You could try using clang or MinGW on Windows to get a more Linux-like experience. MinGW comes with MSYS, which gives you a minimal unix-like environment. It's usually enough to run reasonable Makefiles.
I believe this is the answer you're looking for: #define mod( T , a , b ) T ## _foo( x ) // this appends "T" to "_mod" like a string #define int_mod( x ) a % b // in the case we call mod(int, a, b) we get int_mod(a, b) // here is an example of where this can go. Rather than doing compile time checks, we can // enforce traits of types using macros. For example, mod only applies to integeres - not // reals! #ifdef double_mod #error "The mod function cannot be applied to the set of real numbers!" #endif Right now I'm working on a language overhaul for C that acts like a modern standard library and relies extensively on these "generic types". The repo is a mess and I don't get much free time to work on it... and it needs a lot of refractoring, but you can find some examples there: - here I'm creating traits -&gt; this is the comparable trait: https://github.com/jamesmeyer1993/LongC/blob/master/traits/comparable.h - here's a generic array: https://github.com/jamesmeyer1993/LongC/blob/master/util/array.h
I installed MinGW gcc &amp; g++ compiler, works fine. I also use some easy custom bash commands tot make compiling and running files less tedious.
Must be it, it always amazes me how crazy complex compilers are and although you can tweak every single screw, they together can give a totally different code. And yet, usually they're astoundingly correct with their code-generation. 
Do you think it is possible to make a macro that doesn't require the data type in the call? mod(10,5 )
For that, you'd have to use _Generic, like in the above answer. The problem with that is it's a catch 22. What comes first - the macro or the function? It scales inward - not outward. The second option is to do everything at runtime, but once again, everything has to be defined beforehand and you enter the realm of long switch statements or function pointers.
I just want to point out the amount of errors doesn't really matter. Depending on the compiler, one error in parsing could create multiple other "errors" which will go away when the first one is solved. It's compiler dependent and doesn't mean the compiler that gives you the fewest errors is better.
&gt; Right now I'm working on a language overhaul for C... I'm curious, why are you doing this? Why not just use some other language?
To be fair, what happens to file descriptors when the program exits is OS dependent, right?
Lol when i ask a question they usually tell me insult me. I just go on there and answer questions when i can so people dont have to deal with that 
Ah yes, that is correct, with one caveat. The traversal of a linked list will often have issues in discontinuous memory, resulting in bad cache coherency and cache misses, unlike an array. Cache is king. 
This sub is for C and not C++. /r/cpp_questions is an appropriate sub
The &lt;&lt; is called the insertion operator and the &gt;&gt; is called the extraction operator. They indicate which data to insert or which variable to extract. You can read more here: [http://www.cplusplus.com/doc/tutorial/basic\_io/](http://www.cplusplus.com/doc/tutorial/basic_io/) 
This sub is for C, not C++
Yeah... sometimes I consider just building everything in Rust. But when I see good projects in C, like Kore I always want to go back. The only thing I'm really trying to do is make good generic type data structures, strings, and a pre-compiler that enforces the implementation of traits and tracks memory allocation. What I'm finding is that once you make one layer of nice, clean, human-readable C code, it becomes really easy to write things like they're higher level.
There’s options but Xcode will get you there: google “Xcode c++ tutorial” and you should find lots of information. Also checkout the C++ subreddits 
I find both of them pretty awful, personally. Tracking what expands into what gives me a headache. But, once again, in yet another language on another project I find myself having to rewrite a bunch of test cases, because I don't like certain aspects of the project and I'd like to change them. (Naming, and in a few places change the functions and args around) I wonder how often library devs realize they made an unfortunate choice in naming or design, but stick with it because they don't want to rewrite 40 unit tests. I expect this will happen a dozen times or so, before even release 1. This time, when I rewrite them I would like to use macros, so the next time I rename a function I might (with luck) just change some macros. Kind of like how one might plug numbers into a spreadsheet to ask "what if" questions, it would be neat to do that with M4. I have that luxury now, because it is in the beginning. Would also like it if I could define a symbol like DONOISY and have code injected that belches out symbol names and pointers to stdout, for debugging. But I don't want to litter up to code with a bunch of that. (But I think m4 might be overkill here) But unit tests a la spreadsheet is what I'm after. Guess I'll find out if this makes a mess. :) 
I agree with you. I was just curious what your ideas were.
I agree with you. I was just curious what your ideas were.
I guess I just feel like in my mind, the language that is "C, but with cleaner syntax, generic types, and better compile-time checks" *is* Rust, and duplicating the work to do it "in C" seems odd to me. How do you envision your overhauled C being different from Rust, and why?
Like, is it possible to add [Hindley-Milner types](https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system) to C? In the limit, as a compiler extension, absolutely. In the C preprocessor? [Technically, since the C preprocessor is Turing complete(ish)](https://stackoverflow.com/questions/3136686/is-the-c99-preprocessor-turing-complete), but I don't know why you'd want to. If you want HM generics, why not just use a language with HM types, e.g. Rust, OCaml, Haskell, F#?
**Hindley–Milner type system** A Hindley–Milner (HM) type system is a classical type system for the lambda calculus with parametric polymorphism. It is also known as Damas–Milner or Damas–Hindley–Milner. It was first described by J. Roger Hindley and later rediscovered by Robin Milner. Luis Damas contributed a close formal analysis and proof of the method in his PhD thesis.Among HM's more notable properties are its completeness and its ability to infer the most general type of a given program without programmer-supplied type annotations or other hints. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
A Hindley–Milner (HM) type system is a classical type system for the lambda calculus with parametric polymorphism. It is also known as Damas–Milner or Damas–Hindley–Milner. It was first described by J. Roger Hindley and later rediscovered by Robin Milner. Luis Damas contributed a close formal analysis and proof of the method in his PhD thesis.
On my second run-through, I actually managed to [port Peter Shirley's C++ tutorial to ANSI C code](https://github.com/paulbatchelor/cray). The code is simple enough that it is quite doable. The challenging part for me was rewriting the parts of code that relied on operator overloading.
Read the man page for fgets.
`fgets` stops reading data when it gets a newline. You can either put `fgets` in a loop or switch to `fread`.
fgets stops reading after a newline so you'll only get one line in the array. You can use fread instead. If you have access to a unix system you can type `man fread` and it will describe the function. It's important to check exit codes, fread for instance returns the number of items actually read which might be less then you expect. When you print the array without taking notice it will start printing garbage at the end for instance.
But the data in the text doesn't have any newline. I thought it was probably because of space or what not but apparently no, the text continues without any space or any newline. I guess I should take `fread` a look?
I would say your original answer (without the edit) was good. Compiler-specific extensions may not be standard and may compile for you but not for someone else with a different compiler. Good answer either ways. :)
Try looking your file through a hex viever. Maybe the file contains `0x00`, which is usually used to terminate a string and thus `printf` would only print until the first `0x00`.
&gt; variable "size_t" is not a type name You didn't include the correct headers. Refer to the documentation to figure out what's missing. For instance, `size_t` is defined in `&lt;stddef.h&gt;`, which is automatically included when you include `&lt;stdio.h&gt;`. When it comes to `des_crypt.c`, you can't treat it like a header (or rather: you can, with a bit of work, but I really don't recommend it). You need to include it in your project as a separate source file. Some of the headers it uses are specific to FreeBSD, but you can replace them with standard headers. Start by removing every header that the compiler says it can't find, as well as the `__FBSDID` line. Then add the following at the top to define some of the non-standard types being used (this code predates the C standard): #include &lt;stdint.h&gt; typedef unsigned char u_char; typedef unsigned long u_long; typedef uint32_t u_int32_t; Also, replace the block of code that starts with the comment “We can't always assume gcc” with *only* the line that says `#define INLINE inline`. You will need definitions for the `ntohl` and `htonl` macros. You can get them as follows: #ifdef _WIN32 #include &lt;winsock.h&gt; #else #include &lt;arpa/inet.h&gt; #endif This should greatly reduce the number of errors you get. I'll be happy to help you with the remaining ones. The result will be a file that compiles and works on Linux and Windows. The final piece of the puzzle is a wrapper that looks exactly like the standard `crypt()` and uses `des_crypt()` to do the job. This only requires about four lines of code; I can help with that once you get `des_crypt.c` to compile. If this is schoolwork, you need to be upfront about where you found this code and about getting help from me to make it work. They won't give you grief about it since it's not what you're graded on; you're being graded on the code that *uses* `des_crypt()`, which you will write yourself. They will however come down on you like a ton of bricks if you try to conceal the origin of the code. You could add a comment at the top that says something like “I asked reddit for advice on how to get my code to work on both Linux and Windows, and /u/a4qbfb suggested that I take this file from the FreeBSD source code, since it does not exist in Windows, and helped me make it compile without errors”.
Look at `BoostPP` which is implemented purely in macros for an example of how to do this. It's not for the feint of heart!
Are you sure? It seems strange that you would have such a large amount of data without a single newline. This looks like a log from a network scanner or IDS, not a FASTA file. Are you by any chance working on Windows and looking at the file in Notepad or some other program that doesn't understand Unix line endings?
Well, it is definitely not that hardcore. I am just a beginner bruh. You want a preview of the text? You can take a look if you would like to
use 'else if'
Perhaps you are viewing it in an editor that only breaks lines on CR+LF?
If I enter the amount as `1.32f` I get the following output: 1.320000 was passed in Amount was greater than 0.50 Amount was greater than 0.25 Amount was greater than 0.10 Amount was greater than 0.05 Amount was greater than 0.01 5 So it looks like it does?
That's great, thank you! 
Wow you are right, it did have an "endline" when I view it on hex viewer. Thanks! You solved my problem
Sure, pastebin?
Why not use 2 seperate macros? Ex. foo_double() and foo_int()
That's fantastic, man, thank you! 
The simple answer is don't ever work with money in floating point. Floating point can't represent all numbers exactly. 0.51 might not be exactly 0.51 and 0.10 might not be exactly 0.10. You want to do this in fixed point. With dollars and cents, the easy way to do that is to represent your amounts in cents, assuming you don't need to ever deal with fractional cents (like for interest calculations), and then use only integer math.
Alright, thank you. So, if I did theoretically take in a float as an input, would it be best to convert it to an int and handle operations from there to avoid this problem?
Sorry I just viewed the text in hex viewer and it actually did have newlines. Sorry making it such a scene
Yes, that would be better, but I wouldn't have the input value in floating point at any stage.
I do it for experimental purposes 
I could, but it's not as smooth 
Remember, computers represent numbers in binary, not in decimal. So what the computer does is use the nearest binary floating point number to represent the decimal you requested, which means no float comparison in decimals is precise. Because of that, every floating point comparison should be in respect to some error, usually with subtraction: (x - 0.51) &lt; 0.00001 Is the "correct" way to do: (x == 0.51) 
Comments: 1) Format your code, or you will be cursed for a thousand years. 2) the `-=` operator is more appropriate here. 3) put an f after your numbers to make them floats. Without the f, they are doubles. Like put `0.51f` 4) ignoring point (2), put a space after your minus signs, as it looks like a negative number rather than a subtraction. &amp;#x200B;
Well, the value should pretty much always be in an integral format or a way of your own choosing, e.g.
Did you used the default Windows Notepad? It only displays a new line if the sequence is `'\r\n'` (`0x0D 0x0A`), but not only `'\n'` (`0x0A`). I think they "fixed" that behaviour in the newer Windows releases, but it's still possible you're using an old version.
Thank you. 
Hmm not quite sure. I think I had updated my Windows but I guess I'll take a look just to make sure. Thanks for the info!
I actually originally was using -=, but removed it for debugging purposes. (I'm new to programming, so I wanted to go back to what I know as a fact works to isolate the problem.) Here's what my current code looks like. If you have any suggestions for how to improve the formatting, or how I name my variables, or.. anything, let me know. I'd appreciate that kind of feedback. I will remember to put f after similar, future operations, thank you for that feedback. int generateChange(int amount); int main(void){ float amount = 0.87; int intAmmount = amount*100; int coins = generateChange(intAmmount); printf("%d coins were needed to give you change.\n",coins); return 0; } int generateChange(int amount){ int coins = 0; while(amount != 0){ if(amount &gt;= 50){ printf("50 cents deducted from %d\n",amount); amount -= 50; coins++; } else if(amount &gt;= 25){ printf("25 cents deducted from %d\n",amount); amount -= 25; coins++; } else if(amount &gt;= 10){ printf("10 cents deducted from %d\n",amount); amount -= 10; coins++; } else if(amount &gt;= 5){ printf("5 cents deducted from %d\n",amount); amount -= 5; coins++; } else if(amount &gt;= 1){ printf("1 cents deducted from %d\n",amount); amount -= 1; coins++; } } return coins; }
format your code when posting here please, remember, the curse is real and lasts 1000 years. You format it for posting by indenting it 4 spaces. notice how the indented code you posted was formatted correctly. Seriously. It's a 1000 years curse. But what about `int intAmmount = amount*100` , amount is a float, converted automatically to int and then multiplied by 100, well that might be zero. Here I would do the multiplication by `100.f` to make sure the entire calculation is done with floats BEFORE turning it into an int.
also don't forget that f, `float amount = 0.87f;`
Thank you.
Thank you for the 100f note. I formatted it properly this time. At first, I had no idea what you meant. Thank you for your assistance. 
And to add to that -- modifying the code to go crazy with your type/attribute system is arguably going to be harder than just converting cleanly to rust.
I may be wrong but i think you do need the decimal before the f. like `100.f` rather than `100f` The importance of this is because the type of 0.87 is `double`, which is a different type than `float`, similar, but not the same, so the compiler will be assuming things and converting things and potentially losing precision (potentially introducing errors), if you want to use floats, use floats, and be specific.
Pretty funny actually, what happens is (float)0.51 turns out to be 0.50999... and then it is indeed the case that the last if amount is .009 which is smaller than .01 
This is nothing against you OP but this question gets asked about 5 times a week. Is this in the FAQ?
&gt; 0.10 might not be exactly 0.10. It actually *can't* be; 0.10 is impossible to express as a binary number using a finite amount of digits.
multiplying a float by 100 won't necessarily fix things. for example, if what you enter as 0.51 is stored as 0.50999 then multiplying by 100 will give 50.999 which converts to an int of 50 (it rounds down). what you want is the *nearest* integer, after multiplying by 100, not rounding down. you can do this by adding 0.5. so 100 * 0.50999 + 0.5 = 50.999 + 0.5 = 51.499 which will round down to 51 as you expect.
You should put this in the original post.
The kernel SHOULD clear them
Oops it should have been after the while. Oh well
I meant "might not be" in the sense of "might not be one of the values you can represent exactly in IEEE 754 floating point but I'm sick and I don't want to expend the mental energy thinking about it." ;) It's best to assume that *anything* you represent in float is not stored precisely.
There are known and expected issues with floating point comparison. For educational purpose I would suggest reading more into this. Floating point representation is not as exact as you initially might expect it to be. `0.51 - 0.50 != 0.01`. Maybe some floating point value isn't even equal to itself `0.51 != 0.51`. Therefore floating point comparisons are always factoring in some tolerance. A common method is this: ```C++ bool approx_equal(const float a, const float b, const float tolerance) { return (fabs(a - b) &lt;= tolerance); } ```
I agree, but that's still implementation dependent, no? I could be wrong, if I am, please correct me :)
Not directly related to your question but you should encapsulate those if blocks into a function that takes amount and the coin value as arguments. There'd be a less repeated code and if you decide to change something later you'll only have to change it on one place. Also, if your goal is to calculate the number of coins needed for exact change your algorithm won't work in all cases. Consider how it would handle the value 0.95
I formatted your code properly for reddit. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct arvore { struct arvore *esq; int num; int rot; struct arvore *dir; }; typedef struct arvore arvore; struct arvore criar() { return NULL; }
I'm not sure what you're trying to do here, but the compiler is correct. You're returning `NULL` which is a `void *` (pointer to void) and your function says you are going to return `struct arvore`. This version of `criar` will compile: struct arvore criar() { arvore my_struct = {0}; return my_struct; } That said, it isn't very useful. 
There is nothing wrong with the typedef. I would use: typedef struct arvore { struct arvore *esq; int num; int rot; struct arvore *dir; } arvore; 
Thank you bro, worked.
 if(n &lt; 0) if (n == INT_MIN) N = INT_MAX; else n = -n; 
That's called the ternary operator. Your code "translates" to if (n &lt; 0) { if (n == INT_MIN) { n = INT_MAX } else { -n; } }
Thank you. Again, sorry for the simplicity of the question, but it's quite a challenge for me to read that as I am right now, unfortunately. The way you wrote it made me understand it fully, thank you so much.
You asked for an English translation of this as well. This line is computing the absolute value of `n`, but with a twist. In 2's complement representation of integers, the most negative number doesn't have an equivalent positive value. For example, the range of an 8-bit number is -128 to 127. So what should `abs(-128)` be? This code makes it 127. Not technically correct, but there isn't a correct answer, and that might be sufficient for the application in question.
Oh, lord, yes. My first summer job as a computer programmer was writing financial loan software. We used floating-point dollars for our calculations, and it was a nightmare. I think we spent a month on the interest round-off problem alone.
Read as a double-precision float, multiply by 100 to get pennies, then round that off. Better yet, read a string and parse it into pennies yourself. Do all your interest calculations in double-precision.
UPDATE: the C client generator has been included in the latest v3.3.4 release: [https://twitter.com/oas\_generator/status/1068772409795207168](https://twitter.com/oas_generator/status/1068772409795207168)
It’s possible in standard C, but easier with GNU extensions. As mentioned there’s C11 `_Generic` as well, but it has drawbacks in some cases. GNUish compilers support `__builtin_types_compatible_p`, which allows you to do something like extern int foo_int(int); extern double foo_double(double); #define foo(x) (__extension__(\ __builtin_choose_expr(\ __builtin_types_compatible_p(__typeof__((__extension__(x))), int), \ foo_int, foo_double)))(x) `__extension__` begins an expression (importantly: - Such an expression can’t be used anywhere unusual without throwing a syntax error—e.g., if it were just a parenthesized group it could be used as function arguments or the condition of an `if`. - Anything inside the `__extension__`ed subexpression can use GNU or later language extensions freely without worrying about the specific language configuration, beyond C-vs.-C++ sorts of things. So if you use `_Bool` in C89 mode, you’ll get no warnings or errors as long as it’s in an `__extension__` group.) `__builtin_choose_expr` selects either the second or third argument according to the value of the first. This is lower-level than `?:`; the type of the expression it yields is identical to the type of whichever value it selects, so the condition must be compile-time-constant. In this case, it’ll come out either as an `int (*)(int)` or `double (*)(double)`. `__typeof__(x)` takes/groups the type of expression `x`. The extra `__extension__` in the above code ensures `x` is actually a normal expression—`typeof` would be perfectly happy just wrapping a type expression. `__builtin_types_compatible_p` checks to see whether the two types are “compatible,” which is [slightly complicated](https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html#index-_005f_005fbuiltin_005ftypes_005fcompatible_005fp). If you need an exact type comparison, you can make both args into pointer types (`__typeof__(x) *`). This'll only work in C; in C++ you’ll have to use templates and/or overloading instead, because `__builtin_choose_expr` is C-only.
If you're wondering _why_ such code might exist (i.e., why not just use `n = -n` and be done with it), consider the fact that in C `-INT_MIN` will invoke undefined behaviour if the absolute value of `INT_MIN` is greater than `INT_MAX`. This is typically the case with machines that use two's complement to represent negative integers.
 man set_escdelay
ncurses, man, that library and I been through some hell together Not sure how it is on OS X but I found termbox a lot easier to manage at least on Linux, it may be worth a look if you are free to use a different library. Sorry I couldn't answer your questions directly, baffled me. :-P
The thing I haven't seen mentioned yet is that you seem to be printing the size of `something`, not anything to do with the file size. If you change the 10000 in that declaration you should see the behaviour change. If you want the amount of text read from the file, look at `strlen()`
Bingo! Thanks, that fixed problem #1.
Cool. Thanks for the info. FWIW, I've been reading [this](http://tldp.org/HOWTO/NCURSES-Programming-HOWTO/index.html), which is a pretty good tutorial on ncurses.
 #include &lt;ctype.h&gt; Functions isalpha() and/or islower() will probably be useful to you.
If you only want characters a through z, or with A through Z attached, and you're reading ASCII strings (which are char* basic strings in C), you're just checking if it's one of the ASCII codes for the characters a through z. Go look up an ASCII table, but the numbers that represent the letters a through z (and A through Z) are all contiguous, so a `char c` is in [a-z] if `c &gt;= 'a' &amp;&amp; c &lt;= 'z'`.
I think google is the right direction. You have two problems 1- How to know if a character is a-z. Google: "how to know if char is letter c" and the first third answer is [this](http://www.cplusplus.com/reference/cctype/isalpha/). 2- How to get rid of invalid characters. You do not need google for this one, just copy the valid characters into a new string.
If it makes you feel any better, the original code is frowned upon because it is difficult to quickly parse.
it was one of my problem sets that I completed 2 months ago for CS50 and got full marks for it. I just wanted to see if I can get it to work on windows, but cross-compiling is such a pain and I am extremely new to this. I tried what you said, and changed it from a .cpp to .c file and here is how the code currently looks: [https://pastebin.com/dBHCHcQC](https://pastebin.com/dBHCHcQC) As for crypt-des.c, here is how it looks: [https://pastebin.com/tfz0niGS](https://pastebin.com/tfz0niGS) In crack.c I get the following errors: [https://pastebin.com/QtNnmkqL](https://pastebin.com/QtNnmkqL) In crypt-des.c I get the following errors: [https://pastebin.com/XX379HJK](https://pastebin.com/XX379HJK) &amp;#x200B;
What I understand that financial software dies is they store money in cent fractions with 4 digits of extra precision. 4.00 would be stored as 4000000.
It depends on encoding which you use. For UTF-8 look at [ICU library](http://site.icu-project.org/home) to skip extra characters. It is also possible to determine “extended grapheme cluster” (EGC) starts by hands, without ICU. Details are described in awesome article [2017, Manish Goregaokar, Let’s Stop Ascribing Meaning to Code Points](https://manishearth.github.io/blog/2017/01/14/stop-ascribing-meaning-to-unicode-code-points/)
&gt; Google: "how to know if char is letter c" and the third answer is this. Surely just `mychar == 'c'` is simpler.
 Always take yer time, one line at a time, and she won't seem that complicated, it's all based on simplicity, whether we talkin software, human bodies, or crafting cookie jars. Lookie, /* read lines, print first 12 Latin lowercases */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; int getaz(char *s, int n) { char accept[] = "abcdefghijklmnopqrstuvwxyz"; int c, i; i = 0; while ((c = getchar()) != '\n' &amp;&amp; c != EOF) if (i &lt; n-1 &amp;&amp; strchr(accept, c) != NULL &amp;&amp; c != '\0') s[i++] = c; s[i] = '\0'; return (c == EOF) ? EOF : i; } main() { char s[13]; while (getaz(s, sizeof s) != EOF) printf("%s\n", s); }
Just a reminder, C doesn't specify that characters are ASCII-encoded, it jist specifies a minimal character set (it's usually ASCII though). If you want to check whether the characters are valid characters in that charset, just use the `ctype.h` functions. If you just want to look whether a string of `char` are valid ASCII, well, look at ASCII. If the highest bit is set, it's not 7-bit-ASCII clean. If you want to check for only ASCII alphanumerics, have a look at the ASCII table and filter anything non-ASCII.
That #2 is funny, I see the same effect, and peeking the tty state, stty reports -icrnl -inlcr, so it must be within curses where CR is forced to LF. wtf? lflags: -icanon -isig -iexten -echo echoe echok echoke -echonl echoctl -echoprt -altwerase -noflsh -tostop -flusho -pendin -nokerninfo -extproc iflags: -istrip -icrnl -inlcr -igncr -ixon -ixoff ixany -imaxbel -ignbrk -brkint -inpck -ignpar -parmrk oflags: opost -onlcr -ocrnl tab0 -onocr -onlret cflags: cread cs8 parenb -parodd hupcl -clocal -cstopb -crtscts -dsrflow -dtrflow -mdmbuf cchars: discard = ^O; dsusp = ^Y; eof = ^D; eol = &lt;undef&gt;; eol2 = ^@; erase = ^H; erase2 = ^H; intr = ^C; kill = ^U; lnext = ^V; min = 1; quit = ^\; reprint = ^R; start = ^Q; status = ^T; stop = ^S; susp = ^Z; time = 0; werase = ^W;
You can even edit the string in place using 2 indices
Sidenote: printf format %a is nice, for double 0.1 you get 0x1.999999999999ap-4. I don't know if %ha is legal for float, like half double.
`nonl()` is needed.
\- not returning anything from Username. does this even compile? \- what you think you want to return from Username is allocated on the stack and so you can't return it anyways.
Alright. So I need to assign the value from username function to a variable username in the main function what do you suggest I do?
You're essentially making a specialized strcpy. How does strcpy do this? Hint: It doesn't return a string.
Only thing I can think of is strcpy(Username(name),username). What is the correct thing?
1. Wouldn't `strncpy()` be better? 2. You aren't returning anything from a function that should return pointer to char.
What is the function signature of strcpy?
Sorry it'll be strcpy(username,Username(name)) but I don't think that was working either
Again, what is the function signature for strcpy?
I'm saying "what is the signature for strcpy?" and you're hearing "Your strcpy is wrong". That's not what I'm saying. Look at the signature for strcpy. How is it different from your Username function? How could your Username function be changed to do what you need? 
What is the encoding of the string? 
“Copy the valid characters into a new string” Wouldn’t work very efficiently because you’d have to search through that string. It would be better to just specify the numerical range and check if your character is in it.
You need to use pointers. You want to create a string outside the function and pass a pointer to that string to your function and use that pointer in your function to populate your string. Look at the fuction signature for strcpy() char* strcpy(char* destination, const char* source); The return pointer is for nesting purposes. 
You need to use pointers. You want to create a string outside the function and pass a pointer to that string to your function and use that pointer in your function to populate your string. Look at the fuction signature for strcpy() char* strcpy(char* destination, const char* source); The return pointer is for nesting purposes.
i think that you can make a return of array username from Username function. In this way, you can assign the first three character of name to another variable "username" in the main function. char* Username(char name[]){ // declare dynamic array of char char *username = new char[40]; // take the three character of name and... // return it return username; } // in the main function you can write the following instruction char *username = Username(name); // now username pointer contains the first three character of array "name" In this way you can use username in the main as you want. If you don't return a value from function Username, you'll see nothing. If you notice, in the function the username array is dynamically allocated in such way you can see the content of array outside the function. If you declare the array in this way "`char username [40]`", it will allocated in a static way. Consequently when you call the function, the array declared in the function will be destroyed at the end of the function. So my suggestion is to use allocate the array in the dynamic way. I've proved this piece of code, and it works. To help i share the piece of code at the "[LINK Git](https://gist.github.com/lucacinelli/b210da5fd24c8df2be59b0a63d5b7329)".... I hope that this will help you!
What you want to do could be single `strlcpy(username, name, 4);` with no additional function. Don't know if this is acceptable.
int change (double price, double given) { return given - price; } Is this what you are searching for?
No, it's not, because you shouldn't use floating point for calculations for involving currency.
Then do you have a better idea?
Not C. No code. Not even an attempt. Just, do my homework.
&gt; We want full optimization ... hence the options are “-W -Wall -O9 -S” I can't find -O9 in the [GCC manual](https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html). I thought `-Ofast` was "full" optimization? Also, another great read regarding undefined behaviour is https://nullprogram.com/blog/2018/07/20/
Why not use protobufs for this?
This is a great blog on it from an LLVM perspective: http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html?m=1
The kernel removes the entire process PCB (Process Control Block) which has all the fd that the program uses. Therefor the kernel (99%) will remove them
r/cpp_domyhomework?
This looks a lot like your program is [*stringly typed*](http://wiki.c2.com/?StringlyTyped): &gt; A riff on strongly typed. Used to describe an implementation that needlessly relies on strings when programmer &amp; refactor friendly options are available. Inputs should be parsed into values (structs, enums, etc.) as soon as they enter the program, and that is, if that input is untrusted, where you do the sanitization.
&gt; char *username = new char[40]; That's not C...
yes of course. But you can replace the initialisation of array by calling the malloc function. It's the same!
You need to make up your mind: are you writing C or C++? Because your *code* is C, but you're using C++ headers (and in one case, both the C and C++ version of the same header). Furthermore, the errors you're getting suggest that you're still trying to compile the code as C++. Also, I don't know where you found that `Z_SOLO` bit at the top, but it has absolutely no effect. Just remove it. In `crypt-des.c`: 1. I don't think you need `&lt;sys/types.h&gt;`. 2. You've made some indentation changes which make it harder for me to follow the code. For instance, lines 656, 660, 668, and 709 are not indented at all, and lines 682-683 were originally just one line. Please don't do that. 3. Move the code you added at the top *below* the copyright statement and license. 4. You were also supposed to remove the comment on line 79 since it contradicts line 80 now that you removed the rest of that block. 5. Starting on line 648 you have a large piece of code that looks like this: if (*setting == _PASSWORD_EFMT1) { /* new style */ } else { /* old style */ } You need to completely remove the first half — everything until the `else`. For simplicity, you can replace the `else` with `if (1)` so you don't have to reindent the rest, i.e.: if (1) { /* old style */ } 
I've updated the two version: C++ and C. Then at the [LINK (Program)](https://gist.github.com/lucacinelli/b210da5fd24c8df2be59b0a63d5b7329), you will find the two version of the same piece of code. The considerations written above remain equally valid. Because the program's semantic is identically for both C and C++.
Sorry, but it is certainly not the case. And yes, the input does get parsed/sanitized as soon as it enters, which it is exactly what raises my question.
always use fixed point for currency, for a simple solution use pence not pounds....
is it possible to have a large RED message on the create post page, something like "Please only post questions about C, C++ questions can be asked at...."
What special meaning does -W -Wall have ? "no warnings, then all of them" ?
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
That's `-w` for no warnings. `-W` is deprecated for `-Wextra` according to the [GCC docs](https://gcc.gnu.org/onlinedocs/gcc-8.1.0/gcc/Warning-Options.html).
So you want an int?
He wants to remove them, do you have any better idea on how to end up with a string that does not have any invalid characters?
`-O3` is the highest optimisation level complying with the standard. `-Ofast` allows the compiler to generate wrong code for certain operations and is not in compliance with the C standard.
lol
Funny thing once on an 68HC16: Not only was NULL pointer used, it was actually indexed with. Special registers were on end of "bank" 0xf, RAM on bank 0, and it was very clumsy to keep reloading bank registers all the time. The compiler (gcc 2) did not support banks very much. Fortunately indexed address -1,x did not access 0:FFFF buf wrapped downward to F:FFFF. Compiler was agreeable and all was fine with simple char \*bregs = NULL; bregs\[-1\] = some\_command;
This is C. Go to Java or some other language if you want generics.
I thought so, thanks. Does `-O9` actually do anything then?
Same as `-O3`.
I don't find it astounding that compilers usually behave in the fashion in a fashion consistent with how simple compilers used to work 100% of the time. Some compiler writers take the attitude that if 100% of compilers had processed a piece of code so consistently that nobody (including the authors of the Standard) thought it worth documenting, any code that relied upon such behavior only worked by happenstance. By that same logic, most of the compilers made by such people only work by happenstance since early phases of the optimizer output code which later stages don't promise to handle in the same fashion as the original. 
That is not an option. Let me know if you have an answer to the question. 
Check if the current character is in the valid range ( 97-122 decimal for lowercase letters ) and if it is append it to the string, otherwise do nothing or append whitespace depending on your needs.
Why not store tags in arrays of different types, and then depending on the size of each array (and, if it is empty, or not), sanitize each element one at a time. &amp;#x200B; You can even derive the specifics of each structure by a string identifier, and calculate the fields needed as goes.
ugh, I need better glasses.
[So do I.](https://github.com/deltabeard/peanut-gb/commit/3d5743e1133d3001a072f3d3bd1d449ca912df5a)
Yep lol.
C has no support for generics. Is as if you were asking "How to use access modifiers in C", there aren't. I can't tell you how to write less crappy code without seeing the code you already have and even then unless this benefits society I doubt anyone will do a free code review for you and make it more readable or less reduntant (if its even possible)
Hallelujah. That fixed problem #2. Thanks! So I just needed to call `nonl()` and `set_escdelay(200)` to fix both problems.
According to the published charter and rationale documents for the C Standards, the Spirit of C includes the principle "Don't prevent the programmer from doing what needs to be done". In situations where the Standard doesn't provide a practical way of doing something [probably because it would make sense on some platforms but not others], there will generally be two means by which a compiler could support it: 1. Define a special syntax for that operation. 2. Process some situations where the Standard would impose no requirements in a fashion consistent with characteristic behaviors documented by the environment. The notion that the Standard was intended to forbid reliance upon upon platform-specific behaviors not mandated thereby, even in code which is only going to be used on platforms that support the behavior, is directly contradicted by the charter and rationale documents. The Standard does not require that implementations be suitable for use with any kind of non-portable programs, but explicitly recognizes that programs can be conforming without being suitable for use with most implementations. A compiler could uphold the Spirit of C without processing all actions in a fashion consistent with environmental behaviors, *provided that it makes clear what constructs it does and does not support, and the purposes for which it is supposed to be suitable*. A compiler that claims to be suitable for low-level programming should document what is required to make use of platform-specific features, preferably using syntax that would also work on implementations that naturally support the behavior. Programs should document requirements, but there's no reason that programmers which substantially benefit from platform-specific behaviors shouldn't use them if they document them.
probably it'll be smth like ```{{{1, 2, 3}, {1, 2, 3}, {1, 2, 3}}, {{4, 5, 6}, {4, 5, 6}, {4, 5, 6}}, {{4, 8, 9}, {4, 8, 9}, {4, 8, 9}}}``` But honestly, I'm not sure that's a good idea. Probably you might change your design. Or make it all dynamic (pointers) and fill from a file. 
Thanks
actually I didn't test it. so I might be wrong 
If you don't care about trashing the string, yes, of course. `char *c2 = str; for (char *c = str; *c; c++) if (*c &gt;= 'a' &amp;&amp; *c &lt;= 'z') *(cp++)=*c; *cp='\0';`
"Cool" is way too vague. What are your interests (i.e. graphics, games, networking, etc)?
One possible way forward is to extract common tags into separate structures, which would allow writing the logic once. Upcasting from a struct field is just a [macro](https://gitlab.com/sifoo/snigl/blob/master/src/snigl/util.h#L17) expansion away.
Honestly, games and something that can get inputs and do something out of them. I only know the very basics though so would that limit me?
Please edit your post and insert four spaces at the beginning of each line.
You already know what the problem is: you're passing the entire file instead of just one line. If you can figure out how to find the length of that line, you can use `addnstr()` instead of `addstr()` to pass only that many characters. There is another issue with your code, though, which is that it never calls `endwin()`. You should *always* call `endwin()` before exiting, unless you exit before calling `initscr()`. But beware that `endwin()` may change `errno`, so you should save and restore it if you want to use `perror()` afterward: `int serrno = errno; endwin(); errno = serrno; perror(...); exit(1)`. A final tip is that you don't need to close files and free memory before exiting. The operating system will take care of it. Oh, and for the love of all that's holy, *stop using [Yoda conditions](https://en.wikipedia.org/wiki/Yoda_conditions)*. (and next time, please add four spaces to *every* line, including those that are already indented)
Build a text-based tic-tac-toe game.
Also, why reading the whole file at once ? Use newwin for the window, scrollok it, and just waddch into it. Let curses do the scrolling.
ok thank you, just used addnstr, and was able to print out the first line, problem is, now it's only the first line, any helpful hints on how to get it to print the following line?
This sounds like "do my homework for me". What do you have so far?
You need to store these strings in some form of dictionary (a hash table, a sorted tree...) with an associated counter. For every record you process, you check if the string is already in the dictionary; if it is, you increment its counter, and if it isn't, you add it with the counter set to 1. The standard C library doesn't have containers, but you can easily find a container library online. Start by searching this sub, as I'm pretty sure someone posted a link to a lightweight container library a few months back.
i'm reading the whole file, so that I can store it's contents into a buffer, which I thought would be easier to use 
If you managed to find the end of the first line, you know where the second line starts. Lather, rinse, repeat.
and for the yoda conditions, i honestly never do that lol, don't even know why I did that right there.
Insert each string into a trie that can hold any value you need and then traverse it when it’s completed and count each unique string
I know the end of line is \`\\n\` however I'm having a hard time printing line by line, i only print the first line.
Is this easy? initscr(); win = newwin(10, 40, 10, 10); scrollok(win, TRUE); while ((c = getc(fp)) != EOF) { waddch(win, c); if (c == '\n') { wrefresh(win); usleep(1000); } } endwin();
Once again: if you managed to find the end of the first line, then you also found the beginning of the next. Just repeat what you did for the first line until you hit the end.
Once you master strings, text-based adventure games (like Colossal Cave or Zork) are easy to write and can be a lot of fun.
Oh, sorry, you do special kind of scrolling.
Oh no, I don't ask for doing my homework. I just need some insights. I'll give you my full code first I guess. #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; int main(int argc,char*argv[]) { int i,j; char something[100]; char field1[100]; char *piece; FILE *file = fopen(argv[1],"r"); while(!feof(file)) { fgets(something,100,file); piece = strtok(something, " "); //I get the string like above here strcpy(field1,piece); } fclose(file); return (0); } I thought of using strcmp and I think it requires a 2D array which also demands for nested for loops. I was stuck on how to pull this off. I don't know how to connect them using code. Am I in the right direction? Any hints? 
Why are you tokenizing the string? Can't you just compare the entire string?
what do you mean special? I'm just about to test what you wrote to see if it's what I needed, any other way you can think of?
Ah the voice of experience!
yeah unfortunately that didn't work, it just flashed the contents of the file on the screen
The string in the text are actually longer then what I pasted above. The first full string in text looks like this: `@64.91.107.21/32` [`128.222.130.81/32`](https://128.222.130.81/32) `0 : 65535 1221 : 1221 0x06/0xF`
A marquee kind of scroll, if I have the right word.
I was able to print out the first line, just printing out only 20 characters, but I didn't find the end of the first line, just printed out specific number of characters.
yeah exactly, I can't figure out how to get it to scroll like that, the above code scrolls only the first line of the content.
mvwdelch and/or mvwinsch on the edges might work.
Gotcha.. Okay, think about the problem this way: you're going to need a structure to keep track of your unique strings. Within a loop, read from the file, and parse your string, then check to see if it's already contained in that structure. If it's already there, continue. If it's not already there, add it to the structure, and increment your counter. Now... As for the *type* of structure... Your goal is to check to see if the string is unique (compared to all the other strings). There are two ways of going about this. One is a good way, and one is a bad way. 1. Make your structure an array, and then check your current value against all other values. This is an absolute crap idea because you'll end making your function run in quadratic time. (Ie, for every entry, you need to check against every other entry) 2. Make your structure a hashtable. Hashtables have linear lookup time (ie they check for values directly without looking at every element in the structure), so you can run your entire loop in linear time. Go with #2. Trust me. To do this, you either need to build your own hashtable implementation, or download a library. 
OK, so how would you go about finding the end of the first line without knowing it in advance?
 struct String { struct String *next; int count; char *str; } &amp;#x200B;
Probably not allowed third party live as this is for a class project.
Then use a hash table. It's one of the simplest containers to implement, and for your purposes, it doesn't matter that it's unordered. You'll need a simple hash function; [FNV](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) is probably the simplest to implement from a textual description.
**Fowler–Noll–Vo hash function** Fowler–Noll–Vo is a non-cryptographic hash function created by Glenn Fowler, Landon Curt Noll, and Kiem-Phong Vo. The basis of the FNV hash algorithm was taken from an idea sent as reviewer comments to the IEEE POSIX P1003.2 committee by Glenn Fowler and Phong Vo in 1991. In a subsequent ballot round, Landon Curt Noll improved on their algorithm. In an email message to Landon, they named it the Fowler/Noll/Vo or FNV hash. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Where the key is the string and the value is the counter. Maybe an array of unique strings as wrll to loop over and index into the hash table to generate your report?
Good bot
Using a LinkedList for this is going to run you O(n^2) time. Far, far, far better to use a hashtable.
Please help this ignorant brain and explain me how it would be better to use a hashtable. Im serious. 
Conway's Game of Life is a good project for beginners: https://en.wikipedia.org/wiki/Conway's_Game_of_Life
**Conway's Game of Life** The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.The game is a zero-player game, meaning that its evolution is determined by its initial state, requiring no further input. One interacts with the Game of Life by creating an initial configuration and observing how it evolves, or, for advanced players, by creating patterns with particular properties. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
You can either generate/load prime numbers when your program starts, or you could use trial division to test if each addend is prime. 
I see.
Yup.... LinkedList: for(do something n times) { compare x with n values in a linked list //linear time } n * n = n^2 HashTable: for(do something n times) { check if x is in the hash table //constant time } n * 1 = n
Separate the data from the process as much possible, int sanitise_phone_number(char *to, char *number); The less the two are coupled, the less complex your software becomes. Start with simple processes operating on simple types, then build up from there as needed.
There are many ways to do this, with different trade-offs for time and storage. If you don't care, the simplest is to type this in your nearest shell :-P sort file | uniq | wc -l
Write a text editor, you gotta use something to write and save your programs, ya know? May as well be something you wrote. :-p
So just to get you started, a horribly inefficient way to do this would be to have your input in variable `a` and then two integers `x` and `y` looping from 0 to `a` and checking if `x`, `y` and `a - x - y` are all prime. Obviously that's not very efficient but it's something.
Let’s be honest, one can just use assembly language to make a good AAA standard game. But that doesn’t mean he should. That means one can achieve anything in any language. C is just another language. A language that can be used to make Operating Systems can surely be used for every project. But the problem is, C is very tough. It is not Object Oriented, thus requiring a lot of variables, and lots of extra lines of codes. One could argue that C supports pointers. But as you had mentioned you also know C++. Therefore, I don’t see the reason of using C in every projects. So it is best to just stick with C++ or Python. Python has a huge set of libraries that meet almost every need. But the libraries are pre-built and give you a limited scope of customizations. Therefore if you want to make projects with custom libraries, then you should try to get better in C++ instead. As it can be compared to an Object Oriented version of C, and still has a lot more to offer. Therefore, based on the three languages you know, C is really not good or necessary for every project. [Holberton School](https://www.holbertonschool.com)
Why do so many people seem to believe that the only way for compilers to perform optimizations is to jump the rails completely if code does anything not mandated by the Standard, rather than recognizing that loose behavioral guarantees could offer programmers most of the benefits of precisely-defined behavior, and yet still allow most of the useful optimizations that could be achieved by allowing "jump the rails" behavior? While "jump the rails" optimizations may be useful in cases where stronger behavioral guarantees would have no value, assumptions based on the premise that a programmer won't do X are only useful if code wouldn't need to do X. If a programmer has to work around the lack of a behavioral guarantee, the costs of such workaround will often be greater than the value of any "optimization" enabled by their absence. 
yes just test with syscall and check return value?
I am trying to figure out a string function to detect the \n in each line of the file which would be the last character in each line. but even then how would I tell my program to move down to the next line
[removed]
I thought of that, but it seems like that would be a pain in the ass to do that in a portable way since it would require a lot of platform specific code. 
Why? SYS\_foo isn't arch dependent
I've answered this question [before](https://stackoverflow.com/a/51680667/417501).
Great article. Definitely worth reading and digesting in full for any C or C++ programmer.
I don't understand. Would't I need to support different architectures calling conventions? This is the part I am concerned with from the syscall man page. &gt;Each architecture ABI has its own requirements on how system call arguments are passed to the kernel. For system calls that have a glibc wrapper (e.g., most system calls), glibc handles the details of copying arguments to the right regis‐ ters in a manner suitable for the architecture. However, when using syscall() to make a system call, the caller might need to handle architecture-dependent details; this requirement is most commonly encountered on certain 32-bit architec‐ tures.
This matters only for very few system calls. `getrandom` is not one of them. Generally, this matters for all system calls that use 64 bit types even on 32 bit architectures, the most common 64 bit type being `off_t`. Most system calls are fine. In the answer I linked I show a way that works without using the `syscall` function.
Okay, so I could just do something like this? #define _GNU_SOURCE #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;sys/types.h&gt; #include &lt;signal.h&gt; int main(int argc, char *argv[]) { int ret; ret = syscall(SYS_getrandom, NULL, 0, 0); if (ret == 0) { printf("SYS_getrandom supported!\n"); } } and it would be portable across x86, x86_64, arm, and powerpc?
Use fscanf in a loop until it returns EOF. Once it returns EOF, check errno to make sure you are at the end of the file and didn't receive a read error.
That is incorrect. Re-read my answer: the system call is supported if it does not fail with `ENOSYS`. So correct would be to check if `errno` is set to `ENOSYS`: errno = 0; syscall(SYS_getrandom, NULL, 0, 0); if (errno != ENOSYS) { printf("SYS_getrandom supported!\n"); } This should work on all architectures.
Great! Thank you, I really appreciate the reply! That is a lot more straight forward than I thought it would be
It worked in some way, they are printed in a weird way like this [https://pastebin.com/pX57cwAN](https://pastebin.com/pX57cwAN). Each line is printed in the end of the previous one.
[There](https://en.wikipedia.org/wiki/Primality_test) you go. 
I guess I'm not entirely understanding how to implement this. This is what I put if(c!=EOF) { fscanf...; c=getchar(); } but it doesn't seem to work.
Well, nobody should just do your homework for you. Paste what you have, where you are stuck, and I can help you walk through it. You've posted this question in a few subreddits now. Clearly you are too lazy to do your homework yourself.
Try [this one](http://fuz.su/~fuz/src/wasteram.c).
Use "while", not if. Make a loop.
&gt; if you use the hash as the index for an array That's pretty much the definition of a hash table, so yeah.
11:59pm EST happens when this comment is 2 hours and 36 minutes old. You can find the live countdown here: https://countle.com/AIKk5H3UT --- I'm a bot, if you want to send feedback, please comment below or send a PM.
Good luck with your homework. You will learn more if you do it yourself. 
Yeah I have been trying to figure this out for a while with my brother who is also taking C, and we are running low on time so I figured this would be the best option. Thanks!
Im just a brooklyn kid with no CS background.
Good start. Now use `sscanf` to get the integers from the string. Or you can tokenize as use `atoi` or whatever, but the former is easiest.
I'll do it for $1500.
My professor assumed everyone had background knowledge not comprehending that it is a mixed class.
He's a doofus because the assignment is poorly structured. You should be asked to write the relevant important bits, that are submitted via a submission tool, compiled into an executable, run inside a harness which reads and writes from redirected file descriptors, and can be tested.
Hi, I forgot to mention that there could be more than 1 cpu time, as such every line may or may not have different numbers of integers, is that still possible with sscanf? Or would it better to use atoi in that case?
Try while(!feof(file)) { Get characters from file stream here. } Now you can copy from the file stream a character at a time and check for any characters you want to divide up the string. 
Sure. Attempt to read a number and check the return value to see if it succeeded.
Don't use `feof` like that. It's an error 90% of the time.
Hello, I decided to try this and made a char[] so I could use strtol, but I was wondering how I could "reset" the char[] once I've reached the end of a line? I would like to reset it for the creation of another processor struct
Some of these are fine (did you try them?). short_test, func, new_char, etc., are all fine. If you're not sure about them, why not just try? Anyway an identifier must: * Begin with an underscore or a letter (uppercase or lowercase) * Optionally followed by a sequence of underscores, letters, and numbers * Must not be a keyword (though it can *include* a keyword) That's it.
There are two or three different things here: 1. Illegal identifiers. These are names the compiler will not recognize such as starting with a digit, containing a dot, etc. These will likely cause a compile error unless you get unlucky and accidentally create some valid expression. 2. Reserved identifiers. These are valid identifiers that are reserved by the language such as reserved words, names beginning in double underscores, etc. 3. Naming style. These are totally up to the developer. There are huge arguments about these between developers, but the most important thing is to be consistent within the file/codebase. 
Dont focus too much on what the compiler allows you to do, the most important thing is to name them in a way that you can tell what is their purpose just by looking at their names. For example, "\_x" might be fine, but what does it actually do? Is it being used as a counter? Then why not name it "counter"?
 /* All we need is love, ya know? :-P */ Don't worry, you may feel dumb, but with people as dumb as me in the world, you got nothin to worry about. But I dunno, sttrcspn, atoi, strspn, should be all ya need out the standard library, but who really needs em anyway? You dun need anything!
"Digits", not "numbers". Numbers can contain some punctuation, most notably the dot.
Note that the C programming language does not know *commands.* There are *statements, expressions,* and *keywords,* but not *commands.* Make sure to always use the correct terms for everything to make it easier to understand what you mean.
Many platforms allow the use of a dollar sign in identifiers. Identifiers beginning with two underscores are reserved for the implementation of the libc, identifiers beginning with an underscore and a capital letter such as `_Alignof` are reserved for future keywords. [POSIX reserves a bunch of other identifiers](http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_02_02) including all identifiers ending in `_t` for itself. Try to avoid using these.
Well, what did you think a hash table was?
Also check if you might get a SIGILL or something like that.
I don't think any operating system raises `SIGSYS` on a bad system call these days. Linux only uses it for **seccomp**(2) when you call a forbidden system call.
Don't forget you can retry the sscanf with different formats until you are satisfied. Or, you could just give it a long format and lots of arguments. The return value tells you how many it got, latter arguments are not changed. Just initialize everything before calling sscanf.
I'm not coming out from the 80's !
It's just his opinion
Oh Lmao. That was his opinion I knew I was wondering if someone could explain why he should say something like that. 
Perhaps he finds it more elegant or somehow less prone to error. In very large functions he may have a good point, but honestly best practice is to write many small functions where multiple returns shouldn't be too hard to track so these things wouldn't really come into play.
C functions can return only one value. This can be dangerous if function returns error status and code does not check it. In other languages, multivalue returns are not dangerous, aside from not assigning all required values, which may crash some interpreted programs. In case of error checking, the same applies as with C. 
I believe some people think there should be minimal exits to make the code easier to understandings, not sure. Sometimes when you get taught things, your given mandatory training-wheels, like, dont use goto's either, and use special string functions to prevent overflows... Judge the code by speed or size, or aesthetics, whatever, its your code... you cant master it until you can justify your own rules. &amp;#x200B;
Using multiple returns can require a bit more thought sometimes, for example if a function opens a file at the start of it, you need to make sure that file is closed before every return. Personally I prefer returning as early as I can as that reduces the overall indentation level and makes it easier for me to read the code, so I'd disagree with your professor here. It would be perfect if C had something like `defer` in Go, where an action is always performed when a function is finished regardless of how it finished.
Understood, thanks
Let the scheduler do its job? Just because two threads happen to be scheduled on the one core _now_ doesn't mean they will in the future.
He means multiple return statements, for example: if (...) { return 42; } else { return (34 &lt;&lt; 1) | 1; }
Got it, thanks
Ah, I get it. That's just pure absurd. 
I've heard of the 1 return statement rule being used in certain safety critical applications (i.e. aerospace applications) to make code more clear/bug free. I've seen arguments made for and against it and I don't really have an alignment either way. Obviously in a normal situation it doesn't matter at all and is just a stupid rule.
Single exit point can be considered a good practice. You always know where procedure ends and you have one place to do cleanups (i.e. closing descriptors, freeing memory). However, it tends to make code more complex and sometimes forces the use of methods, that are not considered a good practice, like "goto" instruction. In my opinion, multiple return points are as dangerous as many other constructs. If you are not careful, especially in C, every line can be dangerous (I'm exaggerating a bit). 
Nope, the OS will choose how it wants to run your program whether you like it or not. Generally, it does makes intelligent choices, so trust in the scheduler.
It's not a matter of just opinion and aesthetics as some of the other answers imply. There are downsides in multiple returning from functions, it's not "dangerous" in itself, but depending on what the function does it could lead to memory leaks, resources allocated (like files opened), etc. Also from a mantainability point of view, it's harder to know what your function returns, and if change the code later you might miss an early return and get a bug. Also, forcing a single return style makes you think more about what the function is doing, if the error handling is correct, etc. Having said that, if your function is simple enough, especially if it doesn't allocate resources (memory, files, etc) it's ok to have multiple returns. Now I suggest you *ask your professor*, he **must** be able to give you at least some of those reasons, and explain to you *why* multiple returns are bad. If he can't explain it to you, or just say it's a better style, you *really* need a better teacher.
That is an operating system question, not a C question. A Unix-like operating system will normally schedule runnable threads¹ on available cores in a round-robin fashion, weighted by their effective priority. A thread is runnable when it is not blocking on I/O or some other resource such as a semaphore or a mutex. Threads normally all have the same priority unless explicitly raised or lowered (either by the user or programmatically), but blocked threads will usually be temporarily given a higher effective priority when unblocked, low-priority threads that are blocking high-priority threads will inherit their priority, and low-priority runnable threads will have their effective priority gradually raised until they run. Once assigned to a core, a thread will run until it makes a system call or a specific amount of time (called a quantum) has passed, whichever comes first, at which point a new scheduling decision is made. Things get a little more complicated on [NUMA](https://en.wikipedia.org/wiki/Non-uniform_memory_access) systems, which include all modern desktop, server and mobile CPUs. A NUMA-aware scheduler may preferentially schedule a thread on the same core that it ran on last, or may try to keep threads running as close to their memory as possible (which requires close cooperation with a NUMA-aware VM system). **TL;DR:** your operating system already does what you want. ____ ¹ in the kernel meaning of the term, which technically does not correspond one-to-one with the C meaning, but they're close enough for practical purposes ² technically *lower*, because the way Unix encodes priorities, a higher priority in the colloquial sense of the term is indicated by a lower number
**Non-uniform memory access** Non-uniform memory access (NUMA) is a computer memory design used in multiprocessing, where the memory access time depends on the memory location relative to the processor. Under NUMA, a processor can access its own local memory faster than non-local memory (memory local to another processor or memory shared between processors). The benefits of NUMA are limited to particular workloads, notably on servers where the data is often associated strongly with certain tasks or users.NUMA architectures logically follow in scaling from symmetric multiprocessing (SMP) architectures. They were developed commercially during the 1990s by Unisys, Convex Computer (later Hewlett-Packard), Honeywell Information Systems Italy (HISI) (later Groupe Bull), Silicon Graphics (later Silicon Graphics International), Sequent Computer Systems (later IBM), Data General (later EMC), and Digital (later Compaq, then HP, now HPE). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt; two processes happen to be scheduled on the one core Multiple processes are never “scheduled on the one core”. A process is either running, runnable, or blocked. A runnable process will not be assigned to a core until it reaches the front of the queue.
This is wrong. - pthreads let’s you set the CPU mask as part of the attributes when starting a thread. - you can use the kernel isolcpus boot time parameter to isolate cores and taskset to pin processes to isolated cores for better tail latency performance. You ca use both of the above for threads and tail latency. 
&gt; Multiple threads are never “scheduled on the one core”. By that I meant "on the one core's runqueue". &gt; A runnable thread will not be assigned to a core until it reaches the front of the queue and goes from runnable to running. That's certainly one way to implement a scheduler, but by no means the only way. Having a single runqueue for an SMP system tends to be suboptimal for a lot of reasons.
This is a Unix question, not a C question. But the short version is: - pthreads let’s you set the CPU mask as part of the attributes when starting a thread. - you can use the kernel isolcpus boot time parameter to isolate cores and taskset to pin processes to isolated cores for better tail latency performance. You ca use both of the above for threads and tail latency. See start_thread() in this file for an example: https://github.com/exablaze-oss/exact-capture/blob/master/src/exact-capture.c
As a bag on the side of this: Loop counters for relatively short loops may be named with single variable names. In which case use i, j, and k. You can consider using x, y, and z instead when looping over actual coordinate components.
C11 allows the use of arbitrary Unicode characters from a number of ranges specified in Annex D. This includes (among many, many other categories) currency symbols, superscripts and subscripts, and cuneiform, so you can write C programs in Sumerian if you like. However, the dollar sign (U0024) and the cent, pound, currency, and yen signs (U00A2-U00A5) are not included. This seems to be intentional since other characters from the same block, such as the diaeresis (U00A8), middle dot (U00B7), and cedilla (U00B8) are explicitly allowed, cf. the original meaning of the phrase “the exception that proves the rule”.
FreeBSD does, and I assume the other BSDs do as well. Try the following: #include &lt;unistd.h&gt; int main(void) { return !!syscall(0); } It uses `ENOSYS` for cases where the syscall exists but is disabled, e.g. `cap_enter(2)` if the kernel was compiled without Capsicum.
confirmed on FreeBSD 10 &amp;#x200B;
Unless you code as if the worst that can happen, happens every time, sooner or later you will be bitten in the behind by the rare worst case scenario. 
Oh yes indeed! Though you could always mask the signal before invoking the system call.
King's book was incredibly difficult to read.