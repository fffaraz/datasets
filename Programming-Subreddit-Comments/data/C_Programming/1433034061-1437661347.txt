Sounds like you're trying to use variant types to hack a sort of generic programming into C. This is extremely dangerous. What you're trying to do is properly called parametric polymorphism. You may have seen it in action in C++, C#, or Java; most modern statically-typed languages have evolved *some* native support for type polymorphism, as programming without is one of the least DRY things you could possibly do. Unfortunately, C is not a modern language, and it unapologetically supports *no* type-safe polymorphism whatsoever. Your options are (1) create everything explicitly and suck up the extra typing; (2) use macros to preprocess a set of tokens into qualified type names for you; or (3) exploit unions, void pointers, varargs, and aliasing to subvert the type system entirely. (1) is the route that is normally taken by C programmers, though (3) is occasionally used and endorsed in the professional community, usually in library solutions -- *cf.* `malloc`, `printf`, `sockaddr`, and others. In general, avoid doing (3) yourself with extreme prejudice. (2) is an alternative solution, but it usually makes for "feature"-rich code that is hard to read and harder to maintain. In short, C is a dumb language; it gives you very little in the way of high-level features, and those who use it tend to like it that way, as they usually want access to low-level implementation details without restrictions or surprises. Not that C doesn't also have its fair share of those, but they are in general well-known, well-documented, and commonly subverted in real-world implementations.
Further info: a good idiom for malloc is to write network_driver = malloc( sizeof *network_driver ); Then you *know* you are mallocing the right amount of space, the only thing you have to watch out for is that you don't forget the `*` ! With the pattern `p = malloc(sizeof(Typename));` it is not immediately obvious whether the right amount of space has been allocated; the reader has to fish around in the code for the declaration of `p` and also this is fragile code because you might later change the type of `p` and overlook making adjustment to this `malloc`. 
Hey, thanks for the reply! I've got all those compiler flags set up. When I malloc the size of the structure, I get slightly different output from Valgrind: http://pastebin.com/MUYfMNN2 There's a lot of other various files, but here's packetdescriptor.h: http://pastebin.com/kaP8NJxG
Sounds about right, since I come from a very high-level language - Python. I understand C's limitations (advantages?) - I was simply playing around to get a feel for what I can and cannot do. I tend to learn a language by, well, playing around. Turns out doing this is *not* as simple as I expected...
The first error, noting you tried to write past an allocated area of memory, essentially means that you're trying to write to a point that's passed the area of memory you allocated. IE. You allocated 20 bytes, but tried to write to the 28th byte. This can happen easily if you either allocate an array to the wrong size, or allocate space for the wrong type of object for the pointer you're using. The second error is probably actually a NULL-pointer dereferece. IE. You had a pointer which had NULL in it and you tried to use it as a valid pointer. This tends to be the case when you have small pointer values like '0x8', or '0x10', etc.. The pointer value isn't exactly '0x0' (Like NULL is) generally because you're trying to access an offset into the pointer instead of the pointer itself. IE. You probably attempted to access 'ptr-&gt;member', where 'ptr' was NULL, and 'member' happened to be 8 bytes from the start of 'ptr', So it adds '0x8' to 'ptr' and then tries to deference it, at which point it seg-faults. As a note, *no* valid memory will ever be allocated between 0 and 4K, so you can be fairly sure any address you attempt to deref in that range is a NULL pointer issue.
/facepalm That was it, I had commented out that block when rewriting parts of the function and forgot to put that in. Thanks for all your help! I'm running into another segfault with another part of the program (line 90), but it's entirely unrelated so if I need help later I'll create another post.
Once your problem is solved, it's generally considered polite to leave your post up so that other people can search for the same problem you had.
Are you sure there are tabs in the file? Some editors replace them with spaces.
suggestion: make it clearer that you only need to free memory when you malloc'd it. That was one of the concepts that confused me a bit when I was new to C, because I hadn't really internalized the difference between dynamic allocation and doing char whatever[59]; another thing maybe worth touching is pointer arithmetic, and possibly even how array[5] is the same as *(array + 5)
Please don't remove your question when it has been answered! This makes your question useless for all future visitors of this thread.
I like it. Have an upvote! (Im learning C atm.)
&gt; People learn in terms of language. A baby doesn't learn the alphabet first, then learn all the different phonics of the English language. To be fair, low-level and high-level languages are equally valid things while the alphabet and the other thing are *not*: the alphabet is something made up by humans (and not all languages have it) but words and phonemes are built-in concepts your brain is born with - see *The Language Instinct*, Pinker. 
Early-on in the book "Introduction to Operating Systems Abstractions" (Ballesteros), you learn the difference between static, automatic, and dynamic by looking at the actual size of the object file (with ls) and size of the individual segments (with nm). I'm sure there's other books teaching in exactly the same way, maybe using Windows equivalents of those tools. 
I honestly don't know. For example, I can just say the package weights 70 pounds. So that's an additional 60 pounds which makes it 3.00 dollars for a total of 13.00 to ship. I don't know what math equation I would need to write to get the computer to understand my logic. 
I wish I had your patience not to just give the answer. Damn I'm a bad teacher.
&gt; (3) exploit unions, void pointers, varargs, and aliasing to subvert the type system entirely. Making it explicit: once you start doing this, it isn't even valid C. Russ Cox: https://news.ycombinator.com/item?id=7647520 
Whether type-punning with unions invokes undefined behavior or not in C99 and C++11/14 is still up for debate (which is a bit hilarious), but C11 explicitly lifted that restriction. That said, the standard's historical stance against type-punning and pointer aliasing is *wrong*. Languages should always be designed first with ease of use in mind, second with ease of implementation, and only third, if at all, with ease of optimization. With pointers (and previously unions), ISO inverted that priority, and it has been a black mark on the standard ever since. A language for writing "close to the hardware", yet we can't do something as trivial as reintepret a bitvector without copying it? Ridiculous and unacceptable, in my opinion.
I wonder if there are lazy streams or generators for concatenation in Java/.Net.
The problem is the order of the linked list. When you allocate memory, you advance the `start` pointer of the block that is being split up (line 44) but you never change it back when blocks are merged. Let me illustrate: When you initialize your heap with 1000B and allocate one block of 200B, you will get this situation: (where HEAP is the location of the initial pool) HEAD = &amp;{ HEAP + 200, 800, 1, &amp;{ HEAP, 200, 0, NULL } } When you call `my_free(HEAP);` in this situation, the two blocks will never be merged because you're only merging with consecutive free blocks, not those that are in front of the block you just free'd. The problem is that your linked list is in reverse order, i.e. the Chunk with the highest start address is in front.
This is a C programming sub. However the following lines are not valid in C: #include &lt;cstdlib&gt; #include &lt;iostream&gt; using namespace std; Those lines look like C++, however your program is not valid in C++ either due to the use of variable-length arrays. Your program is not idiomatic for C++, and you're posting on a C sub, so I am assuming you want to write in C. To achieve that, remove the above three lines, *and make sure you are using a C compiler, not a C++ compiler*. 
&gt; see here for explanation Thanks for your help! I really appreciate it, and I will read the mentioned material. My program compiles, runs, and outputs fine, but it does not do the check and update of the stock items. I did put in prints to see where it is going wrong, and it isnt reading past the first element in the first array for some reason. Widget Corporation Transaction Report as of May 30, 2015 Item Number Amount in Stock 1112 32 1212 15 1241 7 1562 25 1822 106 1900 12 2100 48 How many records do you wish to process? 2 Please enter item number to process 1112 Please enter quantity to process 2 Please enter item number to process 1212 Please enter quantity to process 5 7 1112 2100 1112 2100 1212 2100 0 2100 7 0 32767 1112 32767 1212 32767 0 32767 7 0 0 1112 0 1212 0 0 0 0 0 deep loop Item number 0 and qty of 127371377 new qty -127371377 7 0 0 1112 0 1212 0 0 0 0 0 deep loop Item number 0 and qty of 1 new qty -127371377 7 0 1479047536 1112 1479047536 1212 1479047536 0 1479047536 7 0 32767 1112 32767 1212 32767 0 32767 7 0 -1892260673 1112 -1892260673 1212 -1892260673 0 -1892260673 7 0 32767 1112 32767 1212 32767 0 32767 
I am trying to program in C. I am using netbeans on a Mac , and the first line is inserted as soon as I open a new project. The other 2 lines my professor instructed us to use. I commented the lines out right now, and it still runs. Thanks. still not finding elements that are the same though.
You're overrunning your buffers in multiple places, as I mentioned earlier. This can be seen in the output you just posted: 7 1112 2100 The `2100` comes from `printf("%d\n", item[i]);` when `i == 0`. however `item[0]` ought to be `1112` as can be seen just under the "Item Number / Amount in Stock" line. All of the `0`s and large garbage numbers in the later output also come from buffer overruns. You really do need to fix your problems, not just say "thanks but actually it is fine". It really isn't fine. 
There must be some kind of miscommunication , as those lines cannot be used in C. Try to save your file as ".c" (and not ".cpp" or ".C"), that might fix the compiler issue.
Apart from the other buffer overrun issues people have pointed out, and the fact that you're using C++ statements in your C code, check out this loop while (!feof(file)) { i = 0; fscanf(file, "%d %d", &amp;item[i], &amp;stock[i]); printf("\t%d\t\t%d\n", item[i], stock[i]); i++; }
I'm in my phone so can't look at your code. Some serial interfaces will flip the numbers for transmission and your code might need to do that. So, for example, instead of a packet with 1001111 you could be reading 1111001. Another way of debugging your interface is with an oscilloscope. If you have access to one, you can use it to see what's coming out of the sensor.
Interpreting the bytes as ASCII gives 2 1 5 [sp] 0 1 3 I have no idea if that's of any use though.
Agreed. I program almost full time in C now. The first language I completed a course on was MATLAB but this is only because my engineering school required it before moving on to C (the very next prerequisite for almost every following computer engineering course). MATLAB was a joke; when I first entered the C course I realized what a ride I was in for. I agree with all of your opinion for those aspiring to become software/computer ENGINEERS. A fundamental understanding of architecture/assembly followed by C and the compiler is a great way/order to learn how hardware and software really connect. 
haha I basically just posted what you said, whoops http://www.reddit.com/r/C_Programming/comments/37rk2x/c_an_introduction_for_the_highlevel_programmer/crs9qlp
ASCII would be my guess. Otherwise it's an incredible coincidence.
The problem isn't Windows, it is poorly written *nix programs ported to Windows extremely poorly. *nix dev's do not understand the Windows kernel, file system, or good programming habits for Windows, nor how to build proper installers (if they even bother), thus every *nix port I've ever used sucks and sucks bad. There is no better platform to learn programming than Windows. It has the most well-written and supported free IDE's, compilers, tools, debuggers, and hyper-visor support. VMWare Workstations debugger integration only works on Windows and is by far the greatest piece of debugging software ever created by mankind. Even *nix devs &amp; fanboy's like John Carmack develop all of their software in Windows for these reasons. Malware reverse-engineering, no matter the target platform, takes place exclusively in a Windows environment. Every RE tutorial you read will almost certainly be about using a Windows-based software tool. Hell the satellite OS and software we wrote last year was entirely created and debugged on a Windows 7 box.
Oh. Thanks lol.
No interface will change the order of bits within an octet (?)
Your second scanf should be above the printf that is currently above it. You can't printf("%d", a) until a has been scanned.
Very cool! It worked pretty well on my system!
I ended up using code:blocks and gcc. I didnt get pelles to work so : / (didnt wanna install)
That's pretty funky. For me (Win7) it takes about 7.5 seconds to get to the second batch of `xxxx` vertical stripes (there's another one nearer the start). Not sure how this compares to the intended speed. Also do you have any console height in mind? I'm presuming width 80 is intended. 
You don't appear to be null-terminating each row of `outLine`? That could explain the lines running onto each other.
You need to override stdin because that is setting up the communication between the two programs. You do not need to overwrite stdout, as you are currently doing, because the child program isn't writing to the pipe. On Windows these are two completely different programs. They don't share any variables or any other data aside from the inherited pipes. Thinking of this as forking, in the Unix sense, is really the wrong way to think about it. All that said, is your child hitting an error?
Stack memory goes out of scope at the end of the function.
I see. Is there a way I can convert it to a const char*? Or do I definitely have to use the heap?
Try /r/csharp. In spite of their names, C and C# have almost nothing to do with one another.
How about creating a local string and then passing it into the function? I'm trying not to use Malloc to prevent leaks as the user can close the program at any given moment.
Yes, that works and is a common way to structure things in C!
Thanks a lot. I was really going crazy with this sort of behavior.
This code is more C++ than C - C does not support declaring arrays with non-constant sizes: char mtarget[len+1]; This is allowed in C++, but not in C. 
It worked for me on win7. Pretty cool, I love music visualizers and 64k intros and I am learning C in school right now, so this really made me think about how maybe I could create some of that stuff on my own one day.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Variable-length array**](https://en.wikipedia.org/wiki/Variable-length%20array): [](#sfw) --- &gt; &gt;In [computer programming](https://en.wikipedia.org/wiki/Computer_programming), a __variable-length array__ (or __VLA__) is an [array data structure](https://en.wikipedia.org/wiki/Array_data_structure) of [automatic storage duration](https://en.wikipedia.org/wiki/Automatic_variable) whose length is determined at run time (instead of at compile time). &gt;Programming languages that support VLAs include [Ada](https://en.wikipedia.org/wiki/Ada_(programming_language\)), [Algol 68](https://en.wikipedia.org/wiki/Algol_68) (for non-flexible rows), [APL](https://en.wikipedia.org/wiki/APL_(programming_language\)), [C99](https://en.wikipedia.org/wiki/C99) (although subsequently relegated in [C11](https://en.wikipedia.org/wiki/C11_(C_standard_revision\)) to a conditional feature which implementations are not required to support; on some platforms, could be implemented previously with alloca() or similar functions) and [C#](https://en.wikipedia.org/wiki/C_Sharp_(programming_language\)) (as unsafe-mode stack-allocated arrays), [COBOL](https://en.wikipedia.org/wiki/COBOL), [Fortran 90](https://en.wikipedia.org/wiki/Fortran), [J](https://en.wikipedia.org/wiki/J_(programming_language\)). &gt; --- ^Interesting: [^Ch ^\(computer ^programming)](https://en.wikipedia.org/wiki/Ch_\(computer_programming\)) ^| [^List ^of ^data ^structures](https://en.wikipedia.org/wiki/List_of_data_structures) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+crsyq5j) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+crsyq5j)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Hmm, doesn't work on the OS I made in class.. Anything that has .NET compatibility will be able to compile it
It's not a compile time constant. It's allowed in newer C compilers, but not older ones. ( It's a part of C99 ). For pre-C99, you can do this: char array[16]; But not this: int len=16; char array[len]; As others have pointed out, most new C compilers support this nowadays, but it's only supported officially in C99, and even then it's not required. It's better to just use malloc() and free().
I think by constant he means that its not set at compile time and len is an int variable so it's not constant (like a #define would be).
Same here on OSX.
If you try to beat that compiler at what it does you will lose most of the time. But the compiler just translates the instructions you give it. If you instruct the compiler to generate code that allocates all variables on the heap for absolutely no reason than your code will be slower. Your compiler can't say "Oh heap allocations aren't cheap all modify this code to use the stack!". It's not what you asked for so it's not what you will get.
Thanks, yeah programming this kind of had the same effect on me. If you wanted to create a similar project, start out creating a 'for' loop that repeats 2000 times, and all it does is printf("."); This should give you 2000 dots printed out on the terminal screen. Then nest that for loop in another one that loops about 20 times, you should then see your terminal scroll through thousands of dots very quickly. Then find ways to throw in other characters in the loop ( I chose to use modulus but you could try &lt; and &gt; equations too). The basic concept is, you are using the speed of the cpu to scroll text very quickly, creating a 'flipbook' style of animation when you toss in patterns of ASCII art.
Wow, either there's some kind of technical mishap occurring, or Linux is waaaaay faster than windows when it comes to 'for' loops and printf, lol. In a nutshell, this program prints out patterns of text in calculated intervals, so that while the text scrolls up the screen in the terminal, it makes visuals or seemingly animated displays. It's an optical illusion based on the speed of the cpu. There's a sweet spot though, for if the scroll is too fast (like yours) or too slow (1987 pc's) then it won't have the optical illusion effect.
That's the spirit
Hmm, there must be a difference in how windows is treating the execution if linux and mac are just flying through it. To see the intended result, you could create a text file and save the output to it, then scroll up and down through the text file quickly to create the optical illusion 
Not talking about the logic just yet, your code definitely doesn't work because both `j` and `k` start at zero, not `lower`. Also, you use the variable `i` I assume instead of `j` at one point. And, of course, declare `temp` somewhere. With those changes, I believe the logic checks out., but it's not as clean IMO, because the swap that moves the pivot to the center (Which is basically the most important part of the `partition` function) isn't very obvious from the code. Also, with that said, you only really saved two lines off the end, so gains are somewhat minimal. I would however agree with the fact that you can increment their `i` at the end rather then beginning of the loop and it results in a cleaner setup. I question somewhat why they did it the way they did.
Here, try this out then. It's a very simplified version. The dots should print out slowly like an installation progress bar would appear. If it just prints out all 10 dots instantly, then add a zero to both variables dot and pause, and run again. Continue to add a zero to 'dot' and 'pause' until you can see the dots print out one by one :p #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; long i; long dot = 100000000; long pause = 1000000000; void test(long x) { if(x % dot == 0) { printf("."); } return; } int main() { for(i = 0; i &lt; pause; i++) { test(i); } return 0; } 
Ah, ok. So then it's just a difference in how the OS's are handling the output. In windows it is starting a new line when it reaches the terminal border. If it's just keeping it all on one line, then the equation would have to be modified to "\n" every 2000 characters, or however many characters long your terminal window is. edit : no, not 2000, that's how many characters total in the terminal window, probably like around 100 or so characters per line.
The difference is the Windows console. As I understand it, on Windows, writing to the console involves IPC calls to csrss.exe, and that these are blocking calls: the program makes the IPC call, blocks until csrss updates the console, and then continues execution. This means you get very frequent context switches and processes waiting on each other, and so the program runs slowly. On Unix systems, the output is written using regular file IO. Instead of being kept in a synchronous lockstep with the terminal, the program can fill up a buffer of several kilobytes without interruptions. When the buffer is full then the program does have to wait for more room to be made by the terminal device consuming data from the buffer, but there are far fewer interruptions because the buffer is a lot bigger than the chunks of text written with the Windows console API. One way you can see this is if you compare the time required to run the program with output redirected to a file vs. the normal time. On Windows, running the program normally, with output being displayed in the console, takes many minutes, while running the program with the output redirected to a file takes only a few seconds. On Unix, the execution time is not more than a few seconds either way. On Unix there may still be differences depending on how quickly the terminal empties the buffer vs. how quickly data can be written to the disk drive. --- I'm not actually all that familiar with the Windows console model, so if anyone has a better description of Windows' console behavior please correct me. I'd also be interested in any good references that cover this area.
Alright, thank you very much for answering my questions, you really helped me, have an upvote :)
The problem with this question is that C++ has templates, which makes it possible to write containers that work seamlessly with any type, built-in or user-defined. C does not have that, and so writing generic containers involves working through a lot of tradeoffs. Is the container to be type-safe? If so, then you're probably looking at some ugly, ugly macro layer to stamp out code like a poor man's template system. But maybe you don't need that, and instead you know that you're only going to use this container with built-in types, so you can write a fixed number of implementations without macros. Or maybe you have a specific use case in mind and you don't care about flexibility, and you just write the code for that bespoke situation. That's the problem with finding libraries for data structures in C. It's far less cut and dried than in C++. There's really not that much to implementing a dynamic resizable array, since in C you don't have to worry about overloading operators or being exception safe or any of that stuff. Really the only difficult part is the resize step, and that's actually a lot easier than in C++ because (a) objects don't have constructors or destructors, so they can be managed by a simple `memcpy()`, and (b) you can use `realloc()` which takes care of that `memcpy()` for you if it was necessary. (Sometimes the heap allocator can simply expand your allocation without having to copy anything, which is really nice.) The important part is that when you choose the new size, you should always multiply the previous size by some constant to obtain the new size, rather than adding some constant. This assures the growth follows a geometric series, which is what allows you to achieve O(1) amortized append behavior, rather than O(n). The constant that you multiply by lets you trade off memory waste for performance (i.e. the constant factor in the O(1)). 3/2 is a common choice. Here's a quick example: size_t tokenize(const char *s, const char *delim, char ***tokenarray) { size_t size = 0, capacity = 4, wordlen; const char *begin = s, *end; char **tokens = malloc(capacity * sizeof(char *)); do { begin += strspn(begin, delim); if(!*begin) break; end = strpbrk(begin, delim); wordlen = end ? (size_t)(end - begin) : strlen(begin); if(size == capacity) { capacity = capacity * 3 / 2; tokens = realloc(tokens, capacity * sizeof(char *)); } memcpy(tokens[size] = malloc(wordlen + 1), begin, wordlen); tokens[size++][wordlen] = 0; begin = end; } while(end); *tokenarray = tokens; return size; } This tokenizes a string using the given set of delimiters, creating an array of strings containing each token. The array starts out with capacity 4, and is resized as necessary. It's meant to be used as e.g. const char *str = "The quick brown fox jumps over the lazy dog.\n"; char **tokens; size_t numtok; numtok = tokenize(str, " .\n", &amp;tokens); for(size_t i = 0; i &lt; numtok; i++) { printf("got &lt;%s&gt;\n", tokens[i]); } ... for(size_t i = 0; i &lt; numtok; i++) { free(tokens[i]); } free(tokens); Anyway, that's just an example of how the implementation of the dynamic array can be very simple, and completely nestled within the implementation of the tokenizing algorithm.
The C99 standard says that it is optional for compiler makers. Not everything in the standards is mandatory.
Tried. Not working :(
You can look at the Wikipedia page linked earlier. C99 explicitly made variable length array support optional. I'm sorry it doesn't fit in to your world view. I didn't write the standard.
I'm looking at the draft and it doesn't say anything about them being an optional component. Furthermore, the wiki link doesn't say C99 made them optional, but that C11 did. https://en.wikipedia.org/wiki/C11_%28C_standard_revision%29#Optional_features 
Read the wikipedia article linked above. C99 (although subsequently relegated in C11 to a conditional feature which implementations are not required to support;[2][3][4] on some platform 
Does this realloc everytime an element is pushed in?
Like I said, I'm not keen on Windows programming, but I'm pretty sure pipes work on it the same way that they do on unix systems. You get a pair of file descriptors/handles, linked so that anything written to the first is read from the second, but it's a one way thing. You can't read from the writing end or vis versa (On unix, if you do need bidirectional pipes, there's `socketpair()`). So that's why your setting the child's standard input to the write end looked odd. Same for standard output. So, I *think* you're trying to get the child process to display stdout to the same location as the parent process (The terminal in most cases). You probably should be setting the child's stdout to the parent's stdout. Maybe that's the default if you don't explicitly set hStdOutput? I don't know. That way the parent writes to the write end of the pipe, the child reads it because the read end of the pipe has been set to be its standard input, and then it writes stuff on standard output that goes back to the terminal. 
well, on linux i gather the average terminal window is 80 by 25 characters, but it all depends, and there's no reliable portable way of determining this. however, you really should make use of that fflush( stdout ) call.
 #include &lt;stdio.h&gt; int main(void) { printf("$%15.3f\n",300.0); printf("$%-15.3f\n",300.0); return 0; } 
TLDR: no. Looking at 'stb\_\_sb_push(a,v)': #define stb_sb_push(a,v) (stb__sbmaybegrow(a,1), (a)[stb__sbn(a)++] = (v)) It evaluates 'stb\_\_sbmaybegrow(a, 1)' and then pushes the item onto the buffer. 'stb\_\_sbmaybegrow(a, n)' is defined as #define stb__sbmaybegrow(a,n) (stb__sbneedgrow(a,(n)) ? stb__sbgrow(a,n) : 0) which calls 'stb\_\_sbgrow(a, n)' only if 'stb\_\_sbneedgrow(a, n)' evaluates to true. 'stb\_\_sbneedgrow(a,n)' is defined as: #define stb__sbneedgrow(a,n) ((a)==0 || stb__sbn(a)+(n) &gt;= stb__sbm(a)) which evaluates to true if a is NULL, or the required size of the stretchy buffer stb__sbn(a) + (n) is greater than or equal to the capacity of the buffer stb__sbm(a)
Yes, this better explains kinda what I was thinking. Essentially windows is refreshing the terminal screen after each argument is processed, whereas the UNIX systems were processing the output first and then printing the entire output at once.
Yes I just found the windows terminal to be 80 by 25 as well. I haven't learned the fflush( stout ) call yet. But will look into it...
I assume you'd recommend the MIT license?
Excuse my ignorance, but what is wrong with GPL? A lot of popular open source projects are licensed under it.
A growth factor of 2 seems like a bit much for the typical string use case, unless you think people will use it to represent arbitrary data.
A growth factor of 2 is actually quite suboptimal as it does not allow the string to ever reuse previously used memory regions. If I recall correctly, the optimal growth-pattern was Fibonacci-growth (i.e. 1, 1, 2, 3, 5, 8, 13, 21, ...).
[dafuq?](http://i2.kym-cdn.com/photos/images/facebook/000/289/314/be3.php)
A memory leak occurs when memory is allocated but not freed when it is no longer in use. The issue is not memory not getting freed when the program is closed. It is known that the memory is no longer needed at that point. The issue is that some memory does not get freed every time the program performs some task, but the program continues running. https://en.wikipedia.org/wiki/Memory_leak
What did I just read?
Sounds like Windows handles have their version of the unix `FD_CLOEXEC` flag turned on by default, so you have toggle the inheritability of a handle when you do want the child to be able to use it. I *think* the 0 clears the inheritable flag; it would have to be `HANDLE_FLAG_INHERIT` too to set it . There looks like there's something in the `SECURITY_ATTRIBUTES` struct passed to `CreatePipe()` that can control it too.
Nothing's wrong with it, if you want to ensure the maximum openness and freedom of your code using it. 
99% of libraries *don't* use the GPL but you complain the one time it happens? Who cares? More open source apps then, there is no drawback.
I usually use glib's [GString](https://developer.gnome.org/glib/stable/glib-Strings.html). It's LGPL instead of GPL, and has been around for a long time now.
`++1` should be `++i`
The return statement in the while loop exits the main function. What was it supposed to do? 
To exit a while loop you can use the break statement. I would advise you to use a debugger to observe the behavior of your program, it will help you find algorithmic errors.
If it does nothing after typing in the number, that means it never reaches the outer if-else, otherwise you would see it print something. That means it is getting to the internal return statement and the program ends. Check your while condition and the values you are setting your variables to, and see if they make sense
I think I suffer from tunnel vision here, because before writing this program in c, I have written a strucure chart where the conditions and values like that have been working, thus i can't find any mistake and am sitting in front of this for hours ...
The microsoft visual studio debugger couldn't find any error...
If (rest=0) will not check if rest is zero. It will load the value 0 in your variable called rest. I think what you want to do is if (rest==0). That will check for equality between variable content and the given value.
It is not going to find errors for you, merely help you understand what is actually happening to your variables. In particular if you look at Teiler for a few iterations of the while and for loops, you should notice something.
Looks pretty cool! Couple of things - first you really shouldn't name your variables as single letters - it makes the code much harder to read and you fall into silly traps that are easily avoided. For example, the reason your random numbers are coming out wrong is line 34 - you're telling it to get a random number between 0 and the lowest number (l), and then add the range of numbers you wanted (a). You wanted to write: x = (rand() % a) + l; even better (you'd need to change your declarations at the top to match these new names): number = (rand() % range) + lower; which means "let x be a random number between 0 and the range (a), plus the lowest (l)". It's a bit weird because it's not how humans work out random numbers, but there you go. Your second bug, the "???" is because you are using uninitialised memory. Your char s[100] variable is full of 100 bytes of literally any value (could be a number, a letter, a space, a symbol, a fire-breathing dragon, a non-printing character, the list goes on). You then copy the user-entered filename in, which occupies the first few bytes. The rest is still garbage, so the memory might look like: TheAvengingKneeva90a80gh^&amp;$Â£usaih_g89+3p2(hae;gsadg ... C only knows when a string ends if it ends with a NUL byte* - this is written '\0'. So, once you've written your name in there you need to write a NUL byte at the end of the name. An easy way to do this, if you're not too worried about performance (and really, with 100 bytes, you don't need to!), is to just initialise the whole memory to NUL. So, let's change line 6 to: char s[100] = { '\0' }; Here we say "I'd like 100 characters, each set to '\0' (NUL)". That way, when you enter your name, the rest of the string is still filled with NULs. So, the memory will look like this (0 here means NUL, not the digit zero): TheAvengingKnee00000000000000000000000000000000 When you call fopen() with this value in memory, it knows as soon as it hits the first '\0' (shown as 0 above, remember!) that the string is finished. Thus, your file will just be named "TheAvengingKnee". \* - So how comes the string ends at all? Well, remember I told you each character/byte** could be ANY value at all? That includes '\0'. So it ends whenever it happens by chance to find a random '\0' in amongst the memory! ** - Characters are 1-byte when using C (unless you use Unicode, in which case it all gets very crazy!) Anyways, hope that helps! (EDIT: Forgot to finish typing the whole post before posting. Durr.) 
Remember if you want to use the string functions, then you need to include their prototypes, which are in `string.h`. That's what's causing your error about `strlen`.
The indentation is due to my bad reddit formatting, sorry about that. Unfortunately, even with the added braces I still get only the 1 as result. I'm becoming exasperated with this. Some user has pointed out something is wrong with the divider, but I can't seem to find it 
It's a homework assignment. Relax.
Among other things, your issue is: else rest=0; break; You should think about that. The 'break' will always execute, and that's not what you want. Add some braces there. As others have said, add lots of prints. Add a printf at every single line if you have to that details exactly what's being evaluated and what the results are. You'll find it. Thank about how you'd work it out by hand, then think about what the computer is doing differently than what you would do by hand. 
tried the char s[100] = { '\0' }; it did not work, it still adds a ? after the file name. 
Damn. See /u/Jack126guy's comment, looks like fgets is eating the newline character as well. Not invalid memory this time! What you'll want to do here then, is to iterate through each character of the string, changing the first newline you see into a '\0'. Give that a go (you'll need a loop!) but if you get stuck I'll show you how I'd write it :)
Can I simply put a printf before every line without braces? Or do I have to consider some punctuation? As a beginner I have never used print statements for debugging
Thanks a lot guys for your great responses. Sorry that it took so long for me to answer but it took some time to digest all the information that was given here and let's not talk about all the googling I had to do.. The books on C I read so far used linked lists as examples for ADTs most of the time and especially with reference to databases. While I see the advantage of easy deletion and insertion, the not existing random acces always bothered me and recently read about cache misses because of the segmented nature of linked lists. Creating an array with realloc capabilities to get the sequential order of memory and the ability to increase their size dynamically was what I wanted, a vector. I'm telling you this so you know where I come from and probably some of the knowledge you try to teach me may be lost on me for now. **@geocar** So you're saying whlie the implementation of an vector is trivial it's hard to generalize it to fit every use case without introducing bugs/leaks? I thought about using *_Generic* to determine the type and work my way up form there what, after some thinking, is equivalent to 'determine type -&gt; *magic* -&gt; generic vector'... And as Rhomboid already said, it would end up with lots of macros which puts the usage of _Generic itself in question. I understand why you don't recommend vector libraries but doesn't inventing the wheel over and over again introduce unnecessary bugs, readability and maintenance problems (or at least redundancy)? Maybe I try to make C something that it is not but I can't imagine professionals using the language without the capabilities for reusability in mind. While I can see the reason for embedded platforms I can't see it for well established architectures like for example x86. Also this is not a rant against C. I just want to understand the techniques and mindset it is used to create readable, maintainable and hopefully reusable code. **@Rhomboid** Thanks for your thorough response. Could you elaborate on your point that multiplying the former size of a buffer by a constant results in constant time for appending? Also, amortized means average case in this context, doesn't it? I understand that at a certain point the growth of the multiplication is faster than by adding a constant, so you need less reallocations for a bigger buffer size in the long run. But doesn't that mean, depending on the initial buffer size and constant you multiply/add by, your 'amortized append behavior' is worse for vectors under a certain size?
That sounds interesting indeed. I haven't thought so far about nested vectors and its implications.. I would appreciate if you shared the link to your implementation :)
don't worry about wrong habits in the beginning or criticisms of learning resources too much. when you're starting out, it's more important that you learn concepts at all, the rest is fine tuning which you'll naturally pick up over time. So don't worry about learning wrong and just try to code as much as possible. 
What makes you think rewriting the tool in C will help? What kind of data conversion is it doing? C is great, but if you have it working in python there may not be much benefit to translating it to a different language. You can write high performance code in just about any language. 
Wow, good catch. This fixes it. https://github.com/rmccullagh/smartstring/commit/d8fbb12a831c4a23dc5b1340d89954c462b99b8f
https://github.com/libobject/libobject This is the initial version. It has strings, doubles, arrays, and maps. Take a look at the src/object.h for the C data structues. There is garbage collection in the initial implementation yet because I haven't integrated my current version with libobject but I do have a initial implementation if you're interested but it isn't on GitHub yet. The hard part about the GC is that for every object created, it needs to be pushed onto a stack somewhere in order to keep track of all objects. As is, I can free each object i create manually but once I start creating some complex nested data structures it gets difficult to manage.
The problem I see with that is that allocations are expensive, so if I'm reallocating per append, it will decrease performance.
K&amp;R is one of the best programming book ever written. It _is_ outdated, but the explanations are clear an concise. Plus the exercises are challenging and deal with a wide range ot topics. I'd use it together with something more recent, like "C, a modern approach" or using the [GNU C library](https://www.gnu.org/software/libc/) as a reference of modern practices.
Ok, I tried looking better at the docs and set up my code properly, but still no luck. I put the updated code in the original post
Then maybe you should try initializing it. Think for yourself. 
Learn C the hard way is fine however there needs to be more there. I recommend Head first C.
You don't need to reallocste per append, what I mean is that instead of doubling the size each time you should multiply it with 1.615 = (1+sqrt(5))/2
You can't use GPL code in a lot of environments, such as on game consoles or on iOS because of some of the restrictions placed by it (section 6). Also for a library, especially a small one, it really isn't a very sensible license IMO. EDIT: Worth noting since other people are suggesting LGPL, the LGPL has the same restriction for this.
Well, there is the drawback that you limit the platforms it can run on. Releasing source code isn't the only requirement of the GPL, the user also needs to be able to freely modify and use the modified version instead. That means iOS is off limits, and game consoles are off limits, among others.
C Programming: A Modern Approach 
http://www.iso-9899.info/wiki/Books
http://gyazo.com/2c2d41818ea6f3f1c981a1acc54e74f7 This is a screenshot of the chart that works perfectly fine, Eingabe/ Ausgabe = Input/Output and Ja/Nein is Yes/No Hope it helps ! And thanks for your help in advance.
Yeah, I can speak German. And border is spelled without an a; let me check.
oops embarassing...
In your diagram, you set `divider` and `rest` inside the `for`-loop whereas you set them outside the loop in your C code. There is a difference between these two as you might see. Also, as others said, `break` is used to abort a loop, not `return` and you need to fix the braces around the `if` statements. In C, in code like this: if (predicate) do_a; do_b; do_c; only statement `do_a` is conditionally executed. Place braces to execute more than one statement conditionally: if (predicate) { do_a; do_b; do_c; }
Can you show me how the code looks like right now? I have problems imagining what you mean.
The code that prints output is *outside* the `for`-loop and thus runs once. In your diagram, it's *inside* the `for`-loop. Why is there a deviation from your diagram? Notice that indentation is meaningless to the compiler, it ignores how much white space you place.
 int main() { int x, Obergrenze, Teiler, Rest; printf("geben sie eine obergrenze ein:\n"); scanf("%d\n", &amp;Obergrenze); for (x = 1,Teiler = 2, Rest = 1; x &lt;= Obergrenze; x++) { while (Teiler &lt;= x / 2){ if (x % Teiler == 0){ Rest = 0; break; } else { Teiler = Teiler + 1; } } if (Rest == 0){ printf("keine primzahl"); } else{ printf("Ausgabe:%d\n", x); } } return 0; } Sorry for the delay, i just wrote another program which is working just to console myself, how weird. Uhm, but I couldn't find the file of the last things i changed but I guess they are wrong too. So what i meant is that my Divider(Teiler) doesn't count up because the while loop doesn't start. Also I feel like the second "if else" is, as you pointed out, is outside the for-loop. 
&gt; whlie the implementation of an vector is trivial it's hard to generalize it to fit every use case without introducing bugs/leaks? That's exactly right: At least in C. It's a bit easier in C++. &gt; doesn't inventing the wheel over and over again introduce unnecessary bugs, readability and maintenance problems (or at least redundancy)? No. In fact, consider the [number](http://www.ultrawheel.com/ultra-wheels.cfm?id=1140) of [companies](http://www.pepboys.com/tires/) that actually *do* reinvent the wheel: Even when it comes to wheels it's *always* worth re-evaluating it from the perspective of the problem you actually have rather than the problem you *think* you have. &gt; I can't imagine professionals using the language without the capabilities for reusability in mind. Professionals *do* attempt to create reusable components: When they identify a problem-solution pair, they try to make the solution *as generic as possible* in the hopes it will fit other similar problems. That doesn't mean they're right, and even if they are: It doesn't mean that a "vector" is such a component. To me, it's just a pointer and a length. I already know the layout in memory and I see no point in wasting cycles allocating memory and copying things around so that I can write Java or Python with a C compiler.
&gt; Also, amortized means average case in this context, doesn't it? This is of course false. The cost of reallocating a buffer includes a copy, and there's no way to copy a buffer without visiting every byte.
Thanks a lot !!! That helped i cannot believe it, now it gives out 1 2 3 no primary number (up to 10) when you type in 10 I only have to fix the while now. So glad thanks for your help again!
Does this work?
Funny you mention that book, I bought it a few weeks ago and am about 50 pages into it! I had to take a break from it during exams but plan to dive back into it shortly.
Now I understood what you meant, it is working fine now. So apparently i had to assign divisor and rest after the for loop and not in the same braces of the for loop, I didn't realize that makes a difference! Thanks you really helped.
I'm happy that I could help you. See, the first statement in the loop header is the loop initialization, executed once before the loop.
I completely agree, clean code is a priority for me. My philosophy is I should be able to pick up any project that I have not worked on in months/years and be able to relearn its functionality quickly through documentation. If I cannot do that I consider it a failure. Even for school assignments that I will most likely never look at again, I'll always document every function, make a readme, keep my formatting consistent (and clean of course), and push it to my github. As for the bare-bones OS, the entire purpose of the project would be the learning aspect. Researching different methods to accomplish the same task is essentially my main goal so I can have a deeper understanding of not just how an OS as a whole works, but the pros/cons of different details within it. Proper documentation of a large project like this is also something I'm trying to get out of it. For learning hardware/device concepts, what would you recommend for self teaching the right way? Or should I put that on hold until some job trains me in it? I'm a decent self-learner but in most cases always like to have an experienced human resource.
&gt; For learning hardware/device concepts, what would you recommend for self teaching the right way? I don't really know. Obviously some kind of a mentor thing would be good but how do you find a mentor who has the time to teach? Maybe someone else can answer that and I'd be interested in hearing the community's thoughts too. Speaking of community, getting involved with embedded-oriented communities is probably a good way.
Actually, in a console application, you usually want to `scanf` a `\n` explicitly so the program doesn't try to parse the trailing newline as a number in the next `scanf` call.
I'd consider Python and C completely different. I'd first suggest enrolling in a school that provides a C or C++ class. Learning C++ will benefit your learning of C more than Python would have. If that isn't an option, then I would suggest thinking about how Python internally implements Arrays and then try to learn about pointers and memory allocation and build your own dynamic array in C.
It wasn't very clear to me, that is why I asked.
I definitely wasn't prepared of a link to *actual* tires and rims :D I looked over C++ Templates and found it easy to read and surprising to learn that nowadays the disadvantages are negligible expect for longer compile-time, if I understood correctly. Unfortunately the debate C++ vs. C is fought so vigorously it is impossible for somebody not proficient in both languages to filter out the bias from the facts. As a beginner in programming in general C seems the way to go for me though. C++ gives great abstractions and an ever growing expansion to their standard library but for now I think sticking with one language and learning the fundamentals is more important, or at least that's where I put emphasize on. That is where your point of correctly identifing the problem comes into play. Abstractions will blind you from the real problem if you don't know what's going on behind the curtain. I'm sure (not based on actual knowledge) abstratctions can greatly contribute to maintainability and readability of large code bases, what doesn't concern me for now though. Sorry for the long reply again, but I jumped languages for a long time because people told me that the language I'm learning won't get me a job anywhere and rather learn X. Without ever considering that the principles behind a language/feature is the integral part of programming and the syntax just a way to express your ideas, I stumbled along and gave up because it didn't make any sense to me at all and drained all the fun for programming I had until recently. Our opinions may differ on some of the above written but I greatly appreciate the time you took to explain your position to me.
 #include &lt;stdio.h&gt; int main(){ int x, border, divisor, rest; printf("please insert a border:\n"); scanf("%d", &amp; border); for(x = 2; x &lt;= border; x++){ divisor = 2; rest = 1; while(divisor &lt;= x / 2){ if(x % divisor == 0){ rest = 0; break; } divisor++; } if(rest == 0){ } else{ printf("primary number:%d\n", x); } } return 0; } I ran your code through [my](http://trippler.no/wpcms/?page_id=71) code formater to make it more readable
&gt;y school sadly uses Java as its goto language for almost every class but I always find myself using C instead and telling the professor to deal with it. wow you're so cool. Really though: an attitude like that means you'd be a shit employee. So stop it.
He's paying for his education, not the other way around. I see no reason he shouldn't be allowed to tailor it to the things he wants to use professionally. Java is a totally different animal, and spending a lot of time with it would be a waste of his time. You could probably argue he should look at going somewhere that's not a java school, but as a senior, why bother now?
I didn't mean for my words to sound douchey, but as /u/r_smart said, it does not benefit me for what I want to do! And in every case I'll tell the professor I'm going to do it in C for my own beneficial learning and they've been more than okay with it every time.
How do you know what to comment/ how to comment? I just feel like I end up writing: this does this and this other thing does this other thing. The end. 
There are 3 possible ways I have, in decreasing order of preference: 1. Pass a pointer to a string buffer and a length as parameters to your function, use those to return your string (using strncpy to make sure you don't overflow your buffer). 2. Allocate the returned string using malloc and have the caller be responsible for freeing it. 3. Return a pointer to a static buffer. This is the least preferred option as it is not thread-safe.
The most common way is to pass a pointer to a buffer into the function and have it write into that. For example: char *func(char *buf, size_t len) { strncpy(buf, "the string to return", len); buf[len-1] = '\0'; // strncpy doesn't guarantee null termination // returning the pointer is optional, but many of the standard // library functions do this to make chaining calls together easier return buf; } Another common way is to have the function allocate memory for the string and return that. For example: char *func(void) { char* str = malloc(64); // note: make sure to allocate enough strcpy(str, "the string to return"); return str; } The second function is nice as it allows you to return strings of any length while the first function is limited to the size of the passed in buffer. Care must be taken, though, to make sure that any allocated memory is later freed. If all you want is to return a constant string literal you can do it like so: const char *func(void) { return "this is a string literal"; } Just make sure you don't try to modify or free this pointer. (Note the const on the return value.)
For point one, are you meaning a pointer to a pointer, and to allocate into that space? (Basically making malloc over again.) char *foo; myfun( &amp;foo, 10 ); ... void myfun ( char **ps, size_t len ) { *ps = malloc( len ); } Or passing it an already allocated block, and then using the length to fill it, effectively making your own strncpy? char buf[ BUFSIZ ]; myfun( buf, BUFSIZ ); ... void myfun( char *b, size_t len ) { for( size_t i = 0; i &lt; len; i++ ) b[ i ] = 'a' + (len % 26); // do stuff } Your wording is odd.
Not casting returns from malloc (and other void *'s)
He means your second example. A slight enhancement to this is to have the function provide a second out parameter that can be used to inform the caller how much memory is needed. For example: void myfun( char * b, size_t len, size_t * len_needed ) { // Store len characters of the answer in *b // If len_needed != NULL, store number of characters needed for a full answer in *len_needed } This allows the caller to choose how the buffer gets allocated. E.g. the caller could use a statically sized buffer allocated on the stack: // Only need so many characters in this use case. char s[MAX_LEN]; myfun(s, MAX_LEN, NULL); Or a dynamically allocated heap buffer, completely managed by the caller: int len_needed; char * b; myfun(NULL, 0, &amp;len_needed); b = (char *) malloc(len_needed); myfun(b, len_needed, NULL); ... free(b); The choice is left to the caller. Note, though, that this kind of usage assumes calling the function is on the cheap side. (Or at least that there's a fast path through the function when called with a 0 input length.)
Variable length arrays.
Another way is to have a string pool... It works much like #3, but can be thread safe and solves some other problems. Something like this: #define StringPoolSize 64 #define StringPoolMaxChars 256 int StringPoolCounter = 0; char StringPoolBuffer[StringPoolSize][StringPoolMaxChars]; char * GetPooledString(void) { char * String; GetMutexLock(StringPoolMutex); String = StringPoolBuffer[StringPoolCounter++]; if(StringPoolCounter &gt;= StringPoolSize) StringPoolCounter = 0; ReleaseMutexLock(StringPoolMutex); return(String); } You'd of course need to replace GetMutexLock()/ReleaseMutexLock() with your platform's mutex lock/unlock functions, and create a global init function to set it up. This approach has some pitfalls and obvious drawbacks like any of the others, but the pool Size and MaxChars can be tweaked to better fit the intended use, so you don't have problems with it rolling over too soon, etc. I find that it's a good fit when you have code where you'd really rather just have C++'s std::string, but instead need to use C for whatever reason, and it doesn't make sense to have the calling function manage the memory. It should be used with care, however. Strings have always felt like an afterthought in C, which might be the simple truth. I do enjoy being able to very simply and efficiently iterate through each char in a string, though. That process can be quite a bit heavier in some of the newer languages.
No name mangling. Looking at C code, you have IMHO a much better feel of what's really going on. C++ has stuff like operator overloading that means you have to learn the style of the specific library you are working with to a much greater degree than C. Just creating a new object on the stack can call a boatload of constructors which you aren't even aware of. Having to look at errors from templated code is a pain. Small mistakes explode into pages and pages of unreadable junk. 
Not a C feature strictly speaking, but maybe it is... Depends on how you look at it. C tends to put me in a mind set of writing simpler code. And I think it does that to other people too. I also find C code easier to read (considering, of course, only the pieces of code I've looked at). I think that's because other people tend to do the above as well. Anyway, this is a very subjective kind of thing. I can't really say that this is a feature of C. I believe this has more to do with how *I* program than anything. However, sometimes we forget to consider the kinds of "moods" different languages put us in, and I think this sort of issue affects me a lot.
The complete lack of C++ streams! Sorry, but they're just retarded... There's a reason that C#, Obj-C, Java, etc. went a different way on that. Also, C *can* be a lot easier to read and understand... Don't have to dig through 10 source files of something that's all abstracted to hell, just to see how something is done. I do prefer OOP though, just not the over-abstraction insanity that some people use it for.
Designated initializers.
IOCCC entries of course
Yes, that's obvious, and what many people do. The problem is when you deal with other people's code that uses iostream nonsense.
Well, sure, if you start the capacity at a silly value like&amp;nbsp;1. That's why you don't start the capacity at&amp;nbsp;1.
Agreed, at first I kept trying to use IOStream for opening files but it was such a pain in the ass I just used the FILE mechanism (I'm not sure what this is officially called) and it's a whole lot easier to use.
printf. std::cout is such a joke.
If you could maybe help me out I'd be really grateful
&gt;Also, C can be a lot easier to read and understand... Don't have to dig through 10 source files of something that's all abstracted to hell, just to see how something is done. The point of abstractions is that you don't have to see how something is done to read and understand the code using it. Do you pop open the Linux/glibc source to read and understand code that uses `fork`?
He's right, OPs post is off-topic here. I just removed it.
&gt; He's paying for his education, not the other way around. "I'm the customer so I know what's right!!!" I imagine people on English courses choose what books they want to read, right? "I only want to read spot the dog this semester, plz. I think it'll be most useful to me overall". To me it looks like he's deliberately closing his horizons to a different experience because he thinks he knows best, but imo he clearly doesn't, because he doesn't even know how to find a job in C. (pro-tip: the question has been asked a lot, you can google it. The answer is "spam companies and recruiters" like the rest of us). Being so arrogant and thinking you know best when you're literally a newbie is a recipe for disaster. The fact of the matter is programming in Java, or Python, or even Haskell (infact especially Haskell) **will make you a better C programmer** as you can appreciate what it does well and what it doesn't, and you can learn ideas that are common idioms in other languages. (e.g. for haskell the extreme reliance on immutable state to avoid large classes of bugs). I've been writing C drivers for ~10 years now and the shittest programmers I've worked with are like this guy. "I'm a C programmer and a C programmer ONLY". e.g. When they use Python, which is now also required as part of the job, they write terrible [C-in-Python](http://blog.codinghorror.com/you-can-write-fortran-in-any-language/). But it even shows in the C they write. They don't learn anything. They "learnt C" before they started here and that's all they know. They're writing the same crappy C they wrote 10 years ago. The best programmer I work with (and myself, naturally, as I'm literally amazing), are well versed in many different paradigms and idioms and use those ideas to influence the code we worth with. Being a good programmer is universal, and the more stuff you learn, the better you'll be. It's easy to be a shit C programmer, by only staying with C. It's hard to be a good programmer, but you do that by learning and experiencing as much programming as you can, especially in other languages. 
&gt; I do prefer OOP though, just not the over-abstraction insanity that some people use it for. I also prefer OOP thats why i write C with "Classes" with _new and _free for each one, not sure if its a good way to write correct C code but it works for me.
Like I said (and you conveniently excluded from the quote), people going nuts with over-abstraction is the problem.
Templates don't really have anything to do with OO. Classes are one part of the C++ type system that can be parameterized, but they're no more special than functions or structs (which are just classes anyway) in that regard.
That's a feature of C++ and not C... In C you either declare a larger array that you need or use malloc and realloc... C++ has vector etc.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Variable-length array**](https://en.wikipedia.org/wiki/Variable-length%20array): [](#sfw) --- &gt; &gt;In [computer programming](https://en.wikipedia.org/wiki/Computer_programming), a __variable-length array__ (or __VLA__) is an [array data structure](https://en.wikipedia.org/wiki/Array_data_structure) of [automatic storage duration](https://en.wikipedia.org/wiki/Automatic_variable) whose length is determined at run time (instead of at compile time). &gt;Programming languages that support VLAs include [Ada](https://en.wikipedia.org/wiki/Ada_(programming_language\)), [Algol 68](https://en.wikipedia.org/wiki/Algol_68) (for non-flexible rows), [APL](https://en.wikipedia.org/wiki/APL_(programming_language\)), [C99](https://en.wikipedia.org/wiki/C99) (although subsequently relegated in [C11](https://en.wikipedia.org/wiki/C11_(C_standard_revision\)) to a conditional feature which implementations are not required to support; on some platforms, could be implemented previously with alloca() or similar functions) and [C#](https://en.wikipedia.org/wiki/C_Sharp_(programming_language\)) (as unsafe-mode stack-allocated arrays), [COBOL](https://en.wikipedia.org/wiki/COBOL), [Fortran 90](https://en.wikipedia.org/wiki/Fortran), [J](https://en.wikipedia.org/wiki/J_(programming_language\)). &gt; --- ^Interesting: [^Ch ^\(computer ^programming)](https://en.wikipedia.org/wiki/Ch_\(computer_programming\)) ^| [^List ^of ^data ^structures](https://en.wikipedia.org/wiki/List_of_data_structures) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+crwcipk) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+crwcipk)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
quick question. I am kind of having the opposite problem. I am by no means a competent C programmer, but I have a certificate in programming which included 2 C courses (not bird courses, maybe not too hard either), but now I am learning micro-controllers and stuff which involves C-code. I am kind of thinking it would have been just as easy if I had started microcontrollers without any prior experience. Do you have any tips of getting better?
Bonus points if "main" is some const array or something wacky that gets dropped into .text and still does this.
&gt; Do you pop open the Linux/glibc source to read and understand code that uses fork? The nice thing about `fork()` is that very good documentation about how exactly it works exists. The same thing cannot be said about most abstractions people program in their own code. Using a well-established standard function is one thing, reading code that uses custom abstractions with spotty documentation and idiosyncratic behaviour is another.
Having myfun() allocate the buffer is explicitly avoided by the approach - and for good reason. It means management of memory isn't shared by two separate modules. That makes tracking down memory bugs easier. And there's nothing that says the first call to myfun() has to actually construct the string - it just has to determine its length.
simpler? I dare you, no... double-dare you, to start reading some C GTK code...
Sure, you're not the first one to tell me it's terrible. I imagine it is. There are other C related stuff that have a bad reputation. For example, many GNU projects have an awful (afaik) source code. The one that I saw and remember disliking was bash. I remember reading that the BSD and plan9 people despised GNU stuff *a lot* because of exactly that issue.
From what I've read, C++ streams are supposed to be both type safe and (statically) customizable, which you can't say about printf and friends (I don't know about Java stuff though). If you have a good C compiler, like I imagine most C coders do, you'll be warned of a bad printf call (in which the format string and the types don't match), but if you don't then you won't and UB will start creeping into your code. Also, you can't really customize printf to print your own types. You can make ostream instances (e.g. std::cout) work with your own types by overloading the &lt;&lt; operator taking an ostream&amp; and your type. This lets you customize ostream instances to work with your own types in a static way (e.g. non late binding, non dynamic, at compile time, not at runtime, ...). You can even throw templates in the middle. Since invoking the &lt;&lt; operator on an ostream is just a regular type checked function call, you also get type safety. Those 2 properties, afaik, are major motivations behind the streams stuff in C++. *If* you want those properties or not is another story. Bjarne thought they were worth having and gave his attempt to satisfy them in an I/O set of facilities. Personally, I'd like the type safety, but the customization (in the way provided by streams) I don't find that important. I rely on the compiler to tell me about bad printf calls, which is not as good as "real type safety", but it's often good enough.
Code with less abstraction usually doesn't have the problem that you have to wade through layers of abstraction to find out where a certain artifact comes from.
Cool. I'm looking forward to the results.
Great! Looking forward to sharing them here. 
It's just verbose, filled with repetitive boilerplate, and more error prone. I'm not sure that's better. 
its the worst thing I have ever seen. 
http://www.reddit.com/r/C_Programming/comments/249cmt/resources_that_have_influenced_me_as_a_c/ 
If you think C code is full of boilerplate then you are doing it wrong. In fact my experience is that C code has less boilerplate than Java or C++ code as there are less useless layers of abstraction.
Please elaborate!
@/u/Poddster I use java regularly for personal projects. I'm not deliberately avoiding other languages because of biased, I just like the idea of practicing data structures in C for memory allocation practice. I'm also entering an internship learning all different kinds of languages. This entire thread is blown out of proportion by assumptions based on one sentence.
I've switched to [vala](https://wiki.gnome.org/Projects/Vala) for that stuff
You're pretty much spot on - copy the string over to `bufferArray`. As far as the return value is concerned, to use your example, how would the caller know if the word was found or not. You can go with any approach here. 1. Return the pointer to the string if the word was found, and `NULL` if it wasn't. 2. Return an int value that has one value for "*found*" and another for "*not-found*". The cool thing about C is that it does exactly what you tell it to do, nothing more and nothing less. That's also the disadvantage of C :)
It is for an Assignment and I am supposed to do it where I return a string and compare it with a "literal string" in a different function, otherwise I would normally just do it how you suggested above. Thank you for your help, I think I understand this a lot more! have a good one. 
C++ does not have VLAs. It's a C99 feature that so far hasn't been accepted into C++.
It's difficult to explain. I'm going to try, but lower your expectations. I bet much of it is wrong, and I also believe much of what I'm going to say is significantly personal. I find it very difficult to talk about why I prefer language X over language Y. No feature of C on its own is exceptionally good. In other languages, that's not really true. For example, people love their templates and classes in C++. These standing out features have a reason to be so: they can be *very good* tools for problem solving. In C, you don't really have "standing out features" like that. In C, then, to make something which is useful to your project, you have to find a way to combine these primitive building blocks of the language. However, this isn't about or unique to C, because even in languages with standing out features you still gotta do that. The *thing* is that in C the building blocks you use are pretty general and primitive (some people call C a low level language because of that), and this allows you to implement a great deal of programming techniques (that doesn't mean it'll be easy to do so, however). And this goes back to what /u/wild-pointer said originally: &gt; In contrast, in C++, just because it is possible to express some invariants (e.g. with inheritance, templates, etc) there's always a nagging feeling that you should do it properly. This can be great sometimes to catch certain errors early, but it's also possible that the assumed invariants are wrong and you end up throwing it all away (or more commonly, continue fighting and molding the problem domain to fit your type hierarchy). So because the language offers you the means to an end, you feel inclined to use it. Even more so, you feel inclined to use it "properly" to avoid many the pitfalls involved while at the same time taking advantage of some extra benefits that are possible with a bit of an extra effort (as for example, taught in the several books on C++ good programming practices [Meyer's, Sutter's, Alexandrescu's, ...]). So you end up thinking about the problem "just" so you can *fight* to make it fit the solution the language gives you instead of thinking about the problem to come up with a fit solution (it won't be perfect, and it can end up being worse, but I believe it's possible to do better). If you ever have heard of the saying "solution looking for a problem", it's a fit in here. And, just to be clear, this isn't to be confused with Turing Completeness. C Isn't "more Turing complete" or anything like that. Any computational problem you can solve with a C program, you can solve with any other general purpose language out there. I'm talking about the means C offers you to achieve that problem solution. However, take all of this with care. Again, this is just a shot I'm giving a explaining what I think about languages, and I'm terrible at it.
Well put! I mean, every now and then when writing in C I start to feel the pain and think that I could solve this or that in python, bash or awk (or any modern language) in two lines and start to wonder why I'm reinventing the wheel. C isn't always the right tool for the job, and that's fine. I feel that C isn't a language that should be used in isolation, and that it works great in combination with other languages. I wouldn't write a GUI toolkit in C, but I might write the "engine" in C, which could then be configured with a DSL. Like others have said, almost any other language have ffi bindings to C, but often you don't even need that. Handle the interactive and asynchronous parts in a high level language, and run it as a separate process and communicate over a pipe.
The GNU tools are wonderful from a user perspective, but, yeah, the code is usually a big, ugly mess.
Even though the two code segments (I wouldn't call them statements. The first segment is actually three statements.) are semantically equivalent, I would advise against using the second. The very fact that you had to ask is a huge red flag. Although you now know the answer, anyone who reads your code will have to look this up, maybe even you if you come back after some time. Besides, there is very little benefit to the second statement: writing shorter code rarely produces more efficient executables, and usually just makes your code more confusing to read.
argv[1] is already a char pointer. int main( int argc, char *argv[] ) So you don't need the &amp; operator. 
&gt; If you think C code is full of boilerplate then you are doing it wrong. Checking the return values of functions is "*doing it wrong*"? Structuring the code to ensure clean up gets called is "*doing it wrong*"? These are both things that are eliminated by C++'s abstractions.
of course. but this is because the original `foobuf` variable is NOT const which is what I am saying. just returning it as const says nothing about what happened before hand with it... your example still allows writes from multiple threads to a static variable. something which shouldn't be done without locking
&gt; Checking the return values of functions is "doing it wrong"? I don't see how that's boilerplate. Outside of trivial examples, my code usually reacts differently to many possible errors. I think exceptions are misused in C++ and Java because the way they are used encourages the programmer to sweep errors under the rug and not deal with them in a sensible manner. In the BASIC days it was `ON ERROR RESUME NEXT`, today it's just passing through all received exceptions, crashing the application if the slightest thing goes wrong. &gt; Structuring the code to ensure clean up gets called is "doing it wrong"? You are right that it requires discipline to free your resources in C but destructors aren't a very good solution in my opinion because they hide behaviour from the user. When you destroy an object in C++, it's hard to know exactly what happened as the destructor may do arbitrary things. I prefer to have deallocation be a dumb operation, requiring me to call a cleanup function instead when I need to clean things up. There are indeed ways to improve clean-up boilerplate, for instance, I believe Go's `defer` statements are very useful and versatile but because C lacks an exception system, I don't see how they can be accurately ported over to C as they wouldn't run when you jump over them with `setjmp` and `longjmp`.
Huh, TIL. I was taught ANSI C in school and have just been using that (I'm not working in programming or anything, I'm an elec. eng student). Is there a need for them in C++ though? I understand std::vector is an object and hence allocated on the heap, would there be a noticeable difference having variable length arrays on the stack?
It would depend on the precedence of the * and ++ operators. \*(ptr++) is quite different to (\*ptr)++.
That's true, but in this case, the operator precedence causes the pointers to be incremented, not the pointed to values. *p++ = *s++ Is exactly the same as: *p = *s; p++;s++; 
This question is slightly off-topic as it's about complexity analysis, not C programming, even though you use C syntax.
Please indent each line of code with four spaces so the code appears in a mono-space font. It's super hard to read otherwise.
Yes, there are sometimes reasons to want to put things on the stack, but it's true that `vector` is sufficient for the majority of uses of VLAs. VLAs also have some problems so the C++ committee has been resistant to them, but some work has been going on to address the need for stack allocation. For example, see [`dynarray`](http://stackoverflow.com/a/19111606/365496).
This comment is also technically off-topic.
You right, my bad. I'll open this thread in a 'better fitting' subreddit, if still someone can help me here it woukd still be great.
I can't really understand most of the code but that was really fun to read through!
you mean for the second one?
When you have a lot of stuff to compile.
But not on every platform apparently. Though that tidbit gets left out constantly.
Microsoft and the C standard don't play very well together. Fire up a VM running Linux or a BSD and work in it.
0x80000000 is a mask consisting of the most significant bit (MSB) of a 32 bit integer set and all other bits cleared. Using with it bitwise-and is therefore checking if the MSB is set. The loops keep left shifting the value, placing each bit of the desired fields (exponent and significand) into the MSB. The loops then convert them to characters for display. The same applies to 0x00400000, which is really a more stupid way of writing `(1&lt;&lt;22)`. When used with bitwise-and, it extracts the value of the 22nd bit, which is [the uppermost bit of the fraction](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d2/Float_example.svg/800px-Float_example.svg.png). Again bit-shifting is used in the loop to extract all the other 23 bits of that field. 0x000000ff is a bitmask that selects the lower 8 bits of the value. It's extracting the exponent field, which has been shifted right by 23 bits, putting the 8 bits of the field in the lowest position. The mask is necessary to remove everything to the left of the exponent, which in this case is just the sign field, but since this person is using signed integers, all those bits will can 1s due to sign extension. By the way, this code is pretty awful, and I wouldn't advise using it as a learning source. A left shift on a signed integer with a negative value invokes undefined behavior, as does shifting a 1 into the MSB of a signed integer (i.e. going from positive to negative), and a right shift on a signed integer with a negative value invokes implementation-defined behavior. All of the integer operations need to be done with unsigned integers. And reading a member of a union that wasn't the last member written (i.e. writing to `myFloat-&gt;f` and then reading from `myFloat-&gt;i`) is also undefined behavior, but some compilers let you get away with it, but it's not a good idea to rely on that. In any case, this code displays a complete lack of understanding of the rules of C. 
I installed Ubuntu to a Hyper-V VM. It's all good. I'm just curious why that flag isn't default. Seems like whatever gets you to the "C Standard" should be on, and you should have to actively deviate from the norm. I'll sign up so you get the referral though, no harm in that.
 // anagram.c #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main () { char F[40]; char S[40]; int i; int sizeF; int sizeS; printf("Enter first word: "); scanf("%s", F); printf("Enter Second word: "); scanf("%s", S); sizeF = strlen(F); sizeS = strlen(S); for (i=0; i&lt;sizeF; i++) { printf("%s\n", *(F+0)); } return 0; } and into the terminal I had: cd Documents gcc -o anagram anagram.c warning: format â%sâ expects argument of type âchar *â, but argument 2 has type âintâ [-Wformat] ./anagram Enter first word: Hello Enter Second word: World Segmentation fault (core dumped) My code isn't even nearly finished, I also tested it without a for loop and just a printf statement but still doesnt work.
No, I'm only new to programming and I don't know what it means.
changed it to %d... wow It has numbers now which will be good enough for what I'm doing but just for curiousity... How do I make it print individual letters instead of numbers?
In C, a character is the ASCII code (or whatever character encoding is used on your platform; though EBCDIC is virtually extinct) while in most higher level programming languages, it is a single character string. Big difference.
My perspective on the use of C over other languages is that while C is a good cross platform language, it's lowest common dominator material. Java, Python are much high level languages which give greater programmer productivity, a very useful aspect for a software-as-a-service orientated company. Secondly, what advantages are there in choosing C over Java, C++. For stuff like android, Java makes a lot of sense as android is to a large degree platform independent / platform details are abstracted away. The choice between C and C++ can become even more ridiculous. Take GCC for example, it was a large open source C project which ended up having a home-brewed object system and garbage collection added in later. GCC has since moved to C++. If you believe your C project is going to grow so large as to require reinventing language features from other languages *and* there is a language out there with them (C++), why not pick C++ from the start? If you're going to pick C over C++, what precisely do you gain? Nothing. Virtually all valid C source is valid C++ source, and C and C++ are easy enough to mix in a project. You lose templates, generic algorithms etc. Some of the complaints of C++ such as the abuse of operator overloading, exceptions are going to be handled through code review and coding standards rendering them pointless, since any large project is going to have code review+standards anyway. TL;DR: Chose the right tool for the job. C is often not the right tool. 
Wow, interesting, I'm surprised that Java is not their de facto language instead. But in your opinion, is Python still "hot" now after all the years?
One thing I didn't touch on was dealing with legacy issues. There's been occasional calls[1] for the linux kernel to be written in C++. When you do have a large existing project written in C[2], the man-effort in ensuring that the transition to C++ doesn't break anything, decisions on use and acceptability of language features, developer knowledge of C++, can be so much that staying with C is the correct socio-logical, productivity orientated decision. Not necessarily the correct technological decision but the cost of changing is unjustifiable. There's also personal bias in tool choice. Consider writing a OS kernel from scratch. Bill Gates back in the 90's has approached you and your kernel team[3], opened his wallet regarding salaries and cost of developing a new OS kernel, and is letting you run the show. All technical decisions are yours, the big-wigs just want results. Between you and your team, you're clocking in a number of man decades in OS design. Your less worried about language choice, you want to build the best. You set out the architecture, how APIs should be designed, etc. You reach for a tool to write this and *BOOM*. You've picked C. Was this a conscious choice? Were the benefits of language X over language Y weighed properly given (lack of) knowledge of language Y over X? If your developers are building a product, can they build it to last without major changes, i.e. without breaking backwards compatibility. Can they build this with their existing knowledge or with their relative lack of knowledge with language Y? Or was this choice deliberate? You inspected the compilers, the language and came to the decision that C++ is the bad choice as microsoft's toolchain at the time was inferior to their C toolchain[4]. The code produced from use the advantageous language features is inferior. Overheads are unacceptable for other features. So C is the choice. Well, C++ could be choice, but the compiler team down the corridor is promising X/Y/Z that you need in a few months. Are you going to write an OS kernel against compiler features that don't exist? Technical decisions are yours, results are for the big-wigs who can be/are surprising technical. So like the God of Abraham and Isaac you proclaim: "THE KERNEL INTERFACES SHALL BE WRITTEN FOR THE STYLE OF C, ALL OTHER KERNEL INTERFACING LANGUAGES SHALL BE SECOND CLASS CITIZENS". "AS THE KERNEL INTERFACES ARE WRITTEN IN C, SO SHALL THE INTERNALS BE WRITTEN IN C." An thus the tribes of hardware driver developers spake only C for fear of being branded heretics. But, BeOS was written in C++, Apple's Mach kernel is partially written in C++. The choice of language for low-level software is going to be informed by the writer's personal bias in language choice. Legacy software interface issues play a part (One of itaniums greatest contributions was as solid C++ ABI), toolchain issues play a part. Sometimes the "lesser" choice is correct, other times when toolchain, engineer, engineer productivity, API design align, C++ is the obvious superior choice. And for a lot of cases, today it is the superior choice. (Aside, this post is mostly about C vs. C++) [1] This is being *stupidly* generous in counting. [2] Notionally, this can be applied to any project regarding language changes. [3] I'm heavily paraphrasing, but to my knowledge, this is how the windows NT kernel was developed. [4] Take this as fiction, I wish to illustrate the engineer's choice of "use the superior tool, despite absolute inferior results today *or* use the inferior tool and produce superior results today". 10 Years later and MS don't support C99, but they do have a decent C++ toolchain. 
Thanks for great insight!!! I enjoy listening to perspective of someone who has been around in the industry for quite some time way before me :) I kinda like C and start reading Neovim's documentation to hopefully can contribute something someday. I'm also fascinated by a lot of languages and technologies, but since I want to work at Google, I'm narrowing down to a more relevant subset to get in. :)
&gt; ending with a null byte (eight zeros in binary). CHAR_BITS zeros, in binary... (C can work on non 8-bits-per-addressable-unit machines)
Very very informative and entertaining :) thanks a lot for sharing your thought. Just one more thing I want to ask from your experience, do you see/estimate a major shortage of C/C++ developers in a foreseeable future because everything else is easier and more attractive/practical to young developers and because schools are leaning toward Python (not even Java) ? 
Done. However I did not add my e-mail, so I'd appreciate it if you could post the results in this sub as soon as they are ready to be published.
Thank you, sir! :)
Interesting, I'll have to read more about it. Thanks for explaining man.
If the header is the same but you need to link different libraries depending on the target, that's the makefile's job. If you need to include different-but-equivalent headers but for different targets, that should be done by including only the correct search paths, which is the job of the makefile. The only time I've seen something that looks like this done in the header (correctly) is when you need to write a unified header that builds on multiple hosts; has nothing to do with different targets and everything to do with differentiated hosts and toolchains.
Thanks, I didn't think of a shared header, but seems a nice idea; it should work like an interface in OOP
The linker doesn't care about what header files you include. It doesn't even know! That's why when you link against a library you have to pass `-lsomething` to the linker command line. Some platforms (like Plan 9) have compiler extensions so the linker can figure out what library you want to use depending on the headers you include but that's not standard C.
The fact that the pointer is placed on the stack won't make it invalid. The fact that, when popping a pointer from the stack (which happens when the current block ends) will free that pointer, will.
You can use a [function pointer](http://www.cprogramming.com/tutorial/function-pointers.html).
I usually don't bother saying this, but please try Google first...
Whoops! Sorry! Its my first time on Reddit :(
Thank you for formatting it! It should be return(tt*t). Im sorry! Its my first time using Reddit :P
Oh and its 4*(p%5) 
No worries lol. Just go up and edit your post to familiarize yourself with the formatting. 
Thanks!
No problem. Please edit your original post to include the right piece of code. Put some effort into the presentation of the post and people should be able to help you soon.
It's not really a C topic per se. But yeah, I hear you. (As an aside, I wish there were a subreddit for general programming discussion. I might make one.) Just as an anecdote, I've never actually used strict UML for any purpose whatsoever. I've used pseudo-UML in flow charts and whatnot while prototyping and planning. I've used it for homework assignments. There's a standardized language definition for UML and I think that's actually kind of crazy. I know that there are some code generation tools which you can use UML in conjunction with, but I don't know what they are, and I've never actually met a person that uses them. I wouldn't mind using UML. But most tools are shit. The only one I've ever used and truly appreciated for diagramming was Microsoft Visio, but again, that wasn't really strict UML, it was just for object and logic diagrams and stuff.
The only time is when I used it to design a hierarchical state machine for a pretty complicated system. The machine diagram translated nicely into the boost::statechart library. I know that's c++ but there are c statechart libraries as well.
&gt; /r/programming is a reddit for discussion and news about computer programming Am I missing something?
Can't open posting on /r/programming ( can only share links ) .
I'll assume you've read this: http://www.di.unipi.it/~nids/docs/longjump_try_trow_catch.html
You can edit your posts after you wrote them, just click edit.
Ooh. Well, there's /r/coding, too. Eh, no: same problem: no self posts.
IMO creating a diagram in UMLis more complicated and time-consuming than just writing the goddamn code/pseudocode (just calling the functions, not necessarily implementing the functions). On the other hand: UML is for users, as documentation of what is supposed to happen, and as a handholding for the implementor, but not necessarily to generate code. CASE tools are very expensive, and the only use I've seen for them yet is to generate CRUD code from a database model. 
* [What a C programmer should know about memory](http://marek.vavrusa.com/c/memory/2015/02/20/memory/). * [Modern C](http://icube-icps.unistra.fr/img_auth.php/d/db/ModernC.pdf) to work your way to more advanced topics. * [Handmade Hero](https://handmadehero.org/) (in C++, but written like C) to see a real application being developed. * Learn the basics assembly programming and how to interface it with C (calling conventions, etc.). Use a disassembler to study what your compiler emits. * Learn how to use threading, and, more importantly, how thread synchronization works. * Learn [how to leverage function pointers](http://nullprogram.com/blog/2014/10/21/). Sorry, I don't have a links for all of these, since I don't know where you'd learn it online. 
I'd hope not 
Thanks. I just checked and one of my friends has 21st century C. Will read this one soon.
Thanks for the link. 
Thanks. 
I forgot to mention, but I was assuming that this is by default something I had to read along with any other example based books. I am already going through it.
This isn't /r/java, go there if you want to be butthurt.
&gt; It would be very interesting to see a presentation or attend a workshop on something like JPL's code for a space system, These people usually do talk about their code and its design, but they don't talk about it from the perspective of the language, they talk about software design and the language is not really in the focus. Or have you ever seen a mason discuss the peculiarities of his trowel when he talks about a house he built?
Other languages are either poorly designed, new, and/or used by people who are designers and not developers. These conferences are typically circle-jerks of "new" patterns of code people have "invented" to make their code look "cooler". I always viewed conferences as a way for the "elites" in the computer science industry to preach to us how we should all code their way since it's "best". C is an incredibly small and simple language that has existed for an extremely long time. There is really nothing to talk about.
Ha, post your SO thread to reddit for a bunch of free karma on SO
So basically "C is the one true god, and anything that adds additional features is poorly designed because it isn't explained in K&amp;R." Intel syntax master race.
&gt; So basically "C is the one true god, and anything that adds additional features is poorly designed because it isn't explained in K&amp;R." There are lots of cool languages out there, but yes, most are poorly designed. Take JavaScript for example. It's own creators know it was poorly designed. That's why there are 6 versions of it with more planned. Java is the same as well. C has had almost no changes since it's invention, mostly small syntaxual ones. Sure the standard library has had some updates over the decades and what have you, but those are not language changes.
I'm sorry to say I don't have a great answer to this. Oddly, I learned C++ in HS and later C in college, so I went backwards and didn't really learn from a book. My biggest problems are usually with GCC/target-specific stuff, which means I go to the GCC reference manual or library manpages (there are actually manpages for most of the stdlib/posix functions... type "man pthread_create" or "man printf", it works!).
Eh?
&gt; Intel syntax master race. Actually, I like AT&amp;T-syntax more. Yes, we exist.
&gt; have "invented" to make their code look "cooler". I always viewed conferences as a way for the "elites" in the computer science industry to preach to us how we should all code their way since it's "best". &gt; C is an incredibly small and simple language that has existed for an extremely long time. There is really nothing to talk about. Dude C is used in most hardware platforms and new hardware is developed everyday, how would there be nothing to talk about? Especially with the new IoT trend going on right now. You're not going to put fucking Java or Python on a dedicated controller for real time data processing of sensors or to control some motors. 
TIL
I downvoted your comment for supporting Satan's Syntax! :p
Explain.
C is the language of choice to write device drivers and stuff like that. It's very useful for direct interaction with hardware and firmware programming, too.
Sure. So how does that translate into a software conference about the C language?
I like your idea, but it hides possible heap allocation, making it necessary to have a destroy-function in either case. I guess a benefit with your approach would be higher performance though (as calls to free and malloc are expensive in comparison to normal stack deallocation).
The `break` statement only works within a loop or a switch case. If you want to exit the program, the POSIX way to do so is to call `exit(1)`, where the `1` is the return code of the program. I don't know if this will work on Windows, FWIW.
http://imgur.com/0vQroTI This is the error message I want it to printf that message and do nothing else
You could always put a `static inline` implementation of the `destroy` function in the header that does a check, so the compiler can optimize out the call if it's unnecessary. Something like this: /* In header */ static inline smart_string_destroy(SmartString *s) { if (s-&gt;is_alloced) smart_string_destroy_real(s); } And generally speaking, it's basically a rule in C that it's always better to avoid heap allocation if you can.
On reddit, indent each line in a block of code with an extra four spaces. Enclose `inline keywords` with backticks \`like this\`. One thing you will need to get used to in C is that typing is very strict, and must be defined for every value you work with. Your example would need to be modified to define the `power1` and `power2` parameters as `int` types: void forward(int msecs, int power1, int power2) You would then be able to call it as you describe.
Why are you even bothering with **fp**? Just use **stdin** sizeof( char ) will always equal one. **stdin** is line buffered, you shouldn't really be using **fread** on it. 
Since this appears it may be timing sensitive, why not use a macro? It'll put the code inline as if you pasted it each time thus minimising function overhead at the expense of code size: #define forward100ms do{motor[motorB] = 100; motor[motorC] = 100; wait1Msec(100);}while(0) And call a s you mentioned //code //code forward100ms; //code If you want to use parameters, you can do that, too #define forward(ms) do{motor[motorB] = 100; motor[motorC] = 100; wait1Msec(ms);}while(0) And call as `forward(100);` The parameter names are treated like search and replace, not variables, so if you did `forward(1+2+3);` since we named parameter 1 `ms` , the compiler is actually replacing all instances of ms with literally `1+2+3` for that #definition
 Thank you so much!
This only pertains to macros (#define), not functions... Since its multiple statements you need to group them together for some instances, such as If (true) forward(100); else something(); If `foward ` was simply curly braces if would translate to If (true) {motor[motorB] = 100; motor[motorC] = 100; wait1Msec(100);}; else something(); See that semicolon after the close curly? That breaks the if/else statement, so we do a hack, a dummy `do` loop which technically is wrapping multiple statements in a single statement block that `if` sees as 1 statement thus an end semicolon is harmless to an `else` Without brackets its even worse: If (true) motor[motorB] = 100; motor[motorC] = 100; wait1Msec(100); else something(); Only the first `motor[...` Bit is evaluated with `if`, and the rest always run with `else` completely detached from the `if`. 
there are 2 different structures with while: while(condition) { statements } This will check the condition **before** executing the statements. So if the condition is false from the beginning, the statements will not be executed. do { statements } while(condition) This will execute first the statements and **after** that check the condition. So if the condition is false from the beginning, the statements will be executed only once (it's only after this first execution that the condition is checked and the program knows it is false) I don't understand why /u/EkriirkE uses `do { } while(0)` instead of just `{ }`, as the latter is more clean and does the same Also I am not fond of using macro's for anything else than constants as it is difficult to debug and may produce some nasty side effects if not handled properly (the preprocessor is not smart it just replaces text, not looking at syntax or anything) Just use methods, as they are perfect for this: it is even recommended in a lot of respected refactoring books.
That stuff right there is exactly why macro's should not define functions. We already got functions for that. But the while(0) is valid (learned something there :) ), but does not cover all possible replacements. E.g. having a fastforward(100) method would also give problems
Macros &amp; abuse thereof are just a matter of personal preference ;) And I say again, especially when dealing in embedded, function calls can be expensive vs "unrolling" the functionality itself inline Can't say off the top of my head, but I think the preprocessor goes by whole contiguous words, not just any ol' contains (forward != fastforward)
I am confused since your code worked for me. What are the system specifics?
In embedded, I can understand indeed.
I haven't seen a UML diagram since I left Uni. My impression was that it's only use is for the business higher-ups to put on slides to woo other business people. Of course none of them can actually read it but that's not the point.
Sorry, I'm using &gt;| not |
OP, I think you need to get a good book on C that will explain all this, or at least take some free online courses. It's a very basic question that you shouldn't need to ask - it indicates that you haven't done enough learning just yet. There are several online C courses that are free and tailored for beginners.
But my premature optimization!?! &gt; By declaring a function inline, you can direct GCC to make calls to that function faster. One way GCC can achieve this is to integrate that function's code into the code for its callers. This makes execution faster by eliminating the function-call overhead; Even if it is ignored, it looks like it can be useful for diagnostic output as to whether it was inlined: &gt; Using -Winline warns when a function marked inline could not be substituted, and gives the reason for the failure. It's fun, because there are so many different hints and attributes. How about force_inline? That one broke xf86-video-intel on gcc 5.1 https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65873 http://cgit.freedesktop.org/xorg/driver/xf86-video-intel/commit/?id=9b9643171359194478ab9f7126012b659d2ae7a1
OK, I understand now. Thank you for taking the time to explain to me!
Thanks for your reply! I didn't really understand the do vs. while before. I'll leave y'all to argue now.
It does seem easier to read, I'll give you that.
Method considered. However, the function seems easier. This may be more useful in another case than the one I am currently looking at. Thank you regardless!
I definitely agree that it was probably wrong to post here, and that I have yet to do much learning. Apologies for that. However, I simply need a quick fix for a problem that I have been unable to troubleshoot by simply googling(namely because I didn't know the name of what I was looking for). I plan on dedicating more time to C as soon as Finals are done. Thank you for your tolerance!
We were all beginners once, and there's nothing wrong with that. I just wanted to suggest that a book might make it easier for you than stumbling around not knowing how to get started. Just about any introductory book on C would be helpful for you. Good luck!
Yes, I am definitely planning on getting one after I get through the free resources. Thank you!
I get the same output as I would to the file except this time it would be in the terminal console instead of the piped output text file.
Also, ```&gt;|``` is actually the same as ```&gt;``` except it forces the shell to overwrite the existing text file which ```&gt;``` cannot.
Don't do this. Abusing the preprocessor is not a good suggestion to new programmers and even if this was timing sensitive an inline function would be the most correct answer.
Can you send us the entire program?
When the correct answer has already been given, the only things that remain are the answers for the sake of entertainment. It's the whole reason [ioccc](http://www.ioccc.org/) exists.
http://www.reddit.com/r/C_Programming/comments/39eq5d/fread_problems/cs32zov I figured out what my code was actually doing, so now I'm trying to figure out how to convert all the argv[] into a string.
Oh shit, I forgot about that
Had to look this up, since I've never seen it. They're only different if the `noclobber` option is set, which it isn't by default. So for most people, `&gt;` does the same thing as `&gt;|`. http://www.gnu.org/software/bash/manual/html_node/Redirections.html#Redirecting-Output
No. Its a bad idea. Uninitialized memory is not random, just unknown. There are much better ways of getting memory that is closer to random.
Despite people commonly saying that uninitialized variables contain random values, they aren't actually all that random. All pages that you get from the operating system are always zeroed, so it's not like you're going to be seeing bytes from some past run or from some other program. If your program is deterministic then the uninitialized data will also be deterministic (modulo things like address space layout randomization.) That said, the technique was used in OpenSSL at one point. There was a [famous case](http://www.links.org/?p=327) in Debian about seven years ago where someone commented out a line that referenced uninitialized memory to shut up a static analysis tool without understanding the purpose of the code, leading to OpenSSL on Debian generating very weak and guessable keys for a period of approximately two years until it was discovered. It was a very embarrassing situation. In any case, you should absolutely not do this in any code you write. Use a quality PRNG seeded from `/dev/urandom` (Unix) or `CryptGenRandom()` (Windows). Don't try to make up some scheme on your own. 
It's probably because of how my university has set up our accounts. I haven't really configured the scripts to suit my preferences.
That depends on the platform. In post-16bit windows or unix-like this may be true. In embedded (no os) this is not necessarily true.
Thanks for the link to the paper!
Thank you so much! :D 
That's what I am doing doing right now, using rank 0 that is. It is not necessary for my program's correctness to have the entering rank be explicitly "special" versus hard coded rank 0... It would just be a slight optimization. Sounds like a bit of a headache for what it would give me. Thanks for the responses folks! 
OpenSSL did that but they made a huge effort to make it at least pseudo-random by using many other non-deterministic sources when using that memory.
In printf, try `x,y,answer` instead of `&amp;x,&amp;y,&amp;answer`
Post your input [and output]. Also format the code in your post properly.
This is the sort of question that makes me crazy. Put a printf after scanf are x and y ok? Are they ok in in the function. Printf is free. Add a few and figure out what is wrong. How do you think we learned to program before the Internet? Oh yeah, and hey kids get off my lawn...
No. It's a stunningly bad idea. Many CRTs and some CPUs zero that memory for you. The distribution is bad. It can be periodic. It can be the same every boot. Et cetera.
As others have noted, it's very bad idea in general. Is it ever OK to do it? The question to ask is this: What bad things will happen to your application if you got the same "random" number every time? Edit: clarity
I bet it read the data into a buffer and then cast it to struct. (Or read into a union of struct) where the struct had the same layout as the file header.
Also, the return value of givemepower() should be double, not int. Otherwise, the result will be truncated to INT_MAX (I think?) and the fractional part lost. Actually, I'm not sure what happens when you try to convert a double &gt; INT_MAX to an int. Also, what compiler are you using and with what flags? I'm surprised that it doesn't spit out a warning about the printf specifier not matching the argument types. If you're using any kind of Unix, you should always give -Wall to your compiler!
Whatever. You still shouldn't delete your post.
Going via file seems circuitous. Why not use funopen() and create a FILE* backed by the argv?
Yeah, you're definitely putting the cart before the horse there. Get everything working before you try to optimize, ESPECIALLY with parallel programming.
Sorry for the unorganized post, I edited it. I made the changes and it didn't give me the right value, but I found the problem to be the %f in the scanf command (it is supposed to be %lf, silly me) Thanks for your help!
The givemepower function is declared as an int but returns a double. A function supposed to return the type it is declared as.
Agreed. Back in the Windows 3.1 era, uninitialized memory in DOS provided a pretty interesting way to get 'somewhat' random variable, for mild amuzement only. Drawbacks included always getting the same number in a session, but a new variable the next day, whathaveyou. 
`funopen()` is not portable. Better use the POSIX function `open_memstream()`.
Well, I'm just practising my C skills. Doesn't hurt :P
I see. It's just a bit unusual. Anyway, here's how you could proceed: 1. compute how long the resulting string is going to be 2. allocate that much memory with `malloc` 3. one by one, copy the contents of `argv` into the buffer you just allocated.
It's going to be a bitch to copy from a terminal window.
Can someone elaborate this trick a bit more? I didn't get why the timestamp of filter_data would be corrupted, if it contains a re-used memory location.
This was a great read. I'm glad the author mentioned how running this in debug vs release would make a difference. I've seen so many little bugs creep up in release that are not able to be reproduced in debug due to this type of oversight.
Oh I see, that's actually pretty smart. Can we use the similar technique in high level languages though? Or is it a result of direct memory management in C?
No, they *point* to the same thing but they are two separate variables that have different addresses. 
Yep probably so. However I'd imagine a 99 book wouldn't have windows 3.1 as the platform. I'm still looking. I could probably locate it if I can somehow get similar books. Thanks again for looking into this.
Your code is unreadable like this. Making a gist on github.com will surely help!
Do these courses cover C? 
Very cool!! Thanks again man -- I can't wait to try this out... there goes the weekend, lol
You need to understand that a pointer variable is a variable like any other. It exists at a particular location, and that location stores a value. This is just like an `int`, for example; `int` variables exist at particular locations, and those locations contain a particular `int` value. The thing that's different about pointers is that the value represents _another_ location. What a pointer "points at" is determined by _the value_ of the pointer. So you can have multiple pointer variables which store the same value, just like you can have multiple `int` variables which all store the value `10`. When two pointer variables have the same value, it means they "point at" the same location. In your example, the locations of the variables `b` and `c` are different, but their value is the same. Printing the value of `b` will show the same thing as printing the value of `c`: printf("%p == %p\n", b, c); But printing out the location of `b` will show something different from printing the location of `c`: printf("%p != %p\n", &amp;b, &amp;c);
Please indent each line of code with four blanks so the code appears in a mono-space font. Please also consider uploading your code to a paste service of choice. It's completely unreadable right now.
Every variable has a location in memory, and that location is a simple number. Pointers are just variables which hold memory addresses (as simple numbers) of other variables. Idk if you already wrapped your head around pointers or not, but it helped me a lot to think of them as *"memory address variables"*
Thank you for using a paste service. I'm going to remove your other post in a second.
dw i already deleted it
SDL is a C library, there are no "C++ concepts" in the library. And if you decide you want to beyond SDL's 2D api and use OpenGL, that too is C library with no "C++ concepts". SDL provides you with a set of functions and a couple C structures (or pointers to internal library structures) to work with, how you use them is up to you.
Why do you do printf("%c", 196); when you could also simply do printf("\304"); ? A sequence of the form `\###` where `###` are three octal digits is an escape sequence for the character with the octal code `###`. `304` is 196 in octal.
while this is true, the standard specifies that an `unsigned long int` can at least stores integers in the range from 0 to 2^(32)-1.
This is great! I'll take a good look at it and hopefully it'll help clear some things up. Thanks for the link :)
As I've never seriously worked with C++, my answer might be a bit biased, but I didn't ever have problems working in C. You might want to tackle some problems differently from the way you would approach them in C++ though.
&gt; you can write c++ in c but it's not pretty, certainly if you want to add more advanced things. How did you come to that impression?
it's a neat read but again, i wouldn't do it that way to be honest. You'd be better off using c++ instead i think instead of remaking the whole lot. It's not needed for most of the things and personally i think just doing it the c-way (with just plain structures) is way more intuitive. 
C++ is mostly an extension to C, as is Objective C. C# is an entirely different language.
If you want to start with C programming, don't do so on Windows as the C environment on Windows is horribly outdated and tricky to set up.
If you know Java, C# will be very straightforward for you, they are very similar languages. 
yes i can see why they come in handy, it's just that using c for these things is imho just too complicated to justify it's use. Function pointers in a struct are way easier to use/implement/grasp and are used very much in some generic structs (say a compressor struct which implements several compression algorithms which has function pointers for open, write, read and close). I think however people should not make things harder then they should, the kiss principle works out pretty fine mostly. So if you really need all the c++ things, just use c++. If not, it's best to not think about a c++ way to much while doing c.
Use Linux. The compiler is preinstalled and the environment is much nicer to work in.
None of my Linux installations came with a compiler preinstalled. Still, I do agree that programming is easier on Linux.
That's weird. What distribution did you use? The program `cc` (the C compiler) in the implementation `gcc` (the GNU C compiler) is pre-installed on all distributions I know.
I've used Ubuntu and Debian. I think it may actually be just G++ that wasn't preinstalled, since I work with C++. **EDIT**: [~~Ubuntu Forums thread in which it is implied GCC is not installed by default~~ or maybe it is](http://ubuntuforums.org/showthread.php?t=2159230)
Gcc was installed. Lol
Thanks. This was the answer I was trying to elicit. Tossing a coin now if I'm really married to C89 and instead simply use C99 stdint integral types. Sigh.
No one bothers to point him at **limits.h**? randomlink https://en.wikibooks.org/wiki/C_Programming/C_Reference/limits.h
there are like ~100 languages that borrow from `C` in a lot of ways.
Yes; most operating systems were. Doesn't mean that it's the most convenient system to program on.
&gt;use basic C with the constraints of the C++ compiler ???? Use a C compiler to compile C, and use a C++ compiler to compile C++.
That's true, only it isn't portable. That is specific to my system by way of concrete example. Apologies that I wasn't explicit about that. Had sizeof(unsigned long) == 8, I would be asking if it was guaranteed to accept values 0 to 2^64 - 1.
Java is a very OO (object oriented) language and Python also supports OO programming. Not trying to sound harsh, but if you are unfamiliar with this term, I'm somewhat suspicious that you don't know these languages very well yet and perhaps your time would be better spent going more in depth with them rather than adding yet another language.
I didn't found another way to draw those graphics ?
No. You are doubling down on wrong. You learn C this way. Most C code is valid C++. You can compile C style C++ easily. You are literally wrong about everything. In fact, the differences yiu are going to bring up about divergences dont matter to a learner. Youre doing the typical braggart thing where you pull some obscure feature no one in the early cycles of learning like OP is will never encounter to "prove" this distinctionâwhen you're really just trying to show off instead of helping a learner. Casting pointers and avoiding C++ keywords and otherwise writing C is great for understanding and used in many curricula. Edit: /\*this is perfectly valid c++\*/ \#include &lt;stdio.h&gt; int main ( void ) { printf("hello, idiot.\n"); return(0); }
&gt;Most C code is valid C++. All C code is valid C. You can compile C easily with a C compiler. Nothing is learned about C by using the wrong compiler. You might learn about the differences between C and C++, however if you don't know what correct C and C++ are in the first place then you won't know whether you're seeing a difference between C and C++, or a mistake in your code. Adding to all this, trial-and-error via a compiler is the worst possible way to learn C or C++. This is because you don't know if you are seeing undefined behaviour or not. Re your edit: so what do you gain by compiling that with a C++ compiler? 
explain, please.
[Wikipedia:](https://en.wikipedia.org/wiki/C_Sharp_\(programming_language\)#Syntax) &gt;The core syntax of C# language is similar to that of other C-style languages such as C, C++ and Java. In particular: &gt;Semicolons are used to denote the end of a statement. &gt;Curly brackets are used to group statements. Statements are commonly grouped into methods (functions), methods into classes, and classes into namespaces. &gt;Variables are assigned using an equals sign, but compared using two consecutive equals signs. &gt;Square brackets are used with arrays, both to declare them and to get a value at a given index in one of them. Sample FORTRAN code: &gt;C AREA OF A TRIANGLE WITH A STANDARD SQUARE ROOT FUNCTION &gt;C INPUT - TAPE READER UNIT 5, INTEGER INPUT &gt;C OUTPUT - LINE PRINTER UNIT 6, REAL OUTPUT &gt;C INPUT ERROR DISPLAY ERROR OUTPUT CODE 1 IN JOB CONTROL LISTING &gt; READ INPUT TAPE 5, 501, IA, IB, IC &gt; 501 FORMAT (3I5) &gt;C IA, IB, AND IC MAY NOT BE NEGATIVE &gt;C FURTHERMORE, THE SUM OF TWO SIDES OF A TRIANGLE &gt;C IS GREATER THAN THE THIRD SIDE, SO WE CHECK FOR THAT, TOO &gt;IF (IA) 777, 777, 701 &gt;701 IF (IB) 777, 777, 702 &gt; 702 IF (IC) 777, 777, 703 &gt; 703 IF (IA+IB-IC) 777,777,704 &gt; 704 IF (IA+IC-IB) 777,777,705 &gt; 705 IF (IB+IC-IA) 777,777,799 &gt; 777 STOP 1 &gt;C USING HERON'S FORMULA WE CALCULATE THE &gt;C AREA OF THE TRIANGLE &gt; 799 S = FLOATF (IA + IB + IC) / 2.0 &gt; AREA = SQRT( S * (S - FLOATF(IA)) * (S - FLOATF(IB)) * &gt; + (S - FLOATF(IC))) &gt; WRITE OUTPUT TAPE 6, 601, IA, IB, IC, AREA &gt; 601 FORMAT (4H A= ,I5,5H B= ,I5,5H C= ,I5,8H AREA= ,F10.2, &gt; + 13H SQUARE UNITS) &gt; STOP &gt; END If that honestly looks more like C than C# does to you, we're never going to agree about much else.
&gt;What are OO languages? Object Oriented. 
&gt;They are completely different languages. This is flatly *WRONG*. They are closely related. Both C++ and Objective C are direct descendants of C.
&gt;you start to get into things where some of the extra restrictions of the C++ compiler remind you of what's going on a little more. No you don't. Show some code that is actually of pedagogical value to compile with the two different compilers .
Syntax is moot when comparing similarities between languages. The interesting point is paradigm and language features; C has much more concepts in common with FORTRAN than with C#. FORTRAN is not equal to C either, it's different in quite a few ways (mostly in regards to array indexing and argument passing semantics). Yet these two are much closer to one-another than C# is to any of these two. In a similar way, Estonian is not a cousin of German even though both use the same alphabet, the same diacritics and similar spelling.
Are you on an OS that has no graphics? Generally you'd draw the graphics in a graphics program and save them to a file. Back in your program you'd open that file and display the graphic. That takes a few lines of code instead of 200.
&gt;Syntax is moot. Whatever. You're not going to let this go, so it's a pointless argument. If you'd like to share all of your criteria for what makes a language similar to you before I bother replying again, I might try. &gt;Paradigm So, because I can use lambdas in C++14 its more like Haskell than C++03?
That random page might be misleading, but the standard isn't. My point was that there is a header file that covers everything he's looking for.
I just wanted to say that this was a refreshingly (mostly) unbiased summary of these languages. Nice job!
I don't know how to do that =( I'm literally on the first steps of C.
Re: memory management, you're better off pre-allocating for performance anyway. If you use an entity-based system, just allocate a large number of entities up front, and then free it when the program closes. Ideally just one malloc, one free -- extremely simple.
Thank you!
I never said it was undefined behaviour, I just said it's something that you should avoid doing. There are times I have used it, like when writing a linked list, the implementation of which was entirely hidden from the client code.
So is that kind of C++ something that is best for a beginner?
Hi. There are a bunch of issues. 1. You should check the return value of fscanf. 2. You don't initialize or increment 'i' yet use it, but you do increment 'c'. 3. You should fclose the file after the read loop. 4. Why don't you want to add numbers from the file if the numbers are between l and h? 5. Consider using a "while (1)" loop to read and break if EOF returned from fscanf. 6. Your loop to count duplicates is going to way over count potentially. But, because you only save numbers now when the bounds l and h are extended, there will be no duplicates. Assume you fix that problem. The for example, assume the number 3 is repeated 4 times (3 3 3 3). The last 3 will not match anything. The third 3 will match the last. The second 3 will match the third and fourth. Finally the first 3 will match the next set of 3s. Total count will be 1+2+3=6, but there are only 3 duplicates. What you should do is read all the numbers into an array. Then sort the array (quick sort or bubble sort or...). The loop through the array once more to find the lowest number, highest number, and while you are at it, duplicates. Duplicates are easy to detect, as if the current number matches the prior one, it's a duplicate. Sorted makes it easy.
They are a bit, they all mean something but you are right I could definitely improve. 
if this is for school, a teacher will appreciate descriptive variable names and functions, ie: int numDuplicates; int numTotalCount; int doSomethingJustBecause(char * theThingToDo) etc... depending on the school of thought your teacher comes from, you might get docked for using generic names. from the unix philosophy: "The Unix philosophy emphasizes building short, simple, clear, modular, and extensible code that can be easily maintained and repurposed by developers other than its creators." more at: http://www.linfo.org/unix_philosophy.html also: "Naming The careful selection of names is very important to understanding. Cryptic names of components, modules, classes, functions, arguments, exceptions and variables can lead to confusion about the role that these components play. Good naming is fundamental to good design, because source code represents the most detailed version of our design. Compare and contrast the ease with which the following statements can be understood: out(p(f(v), 2) + 1); print(power(fibonacci(argument), 2) + 1); There are common naming recommendations. Modules, components and classes are typically nouns (e.g. Molecule, BlackHole, DNASequence). Functions and methods are typically verbs (e.g. spliceGeneSequence, calculateOrbit). Boolean functions and methods are typically expressed as questions about properties (e.g. isStable, running, containsAtom). Naming also relates to the use of capitalisation and delimiters, which can help a reader to quickly determine if something is a function, variable or class. Common guidelines for C and Java include: Constants should be capitalised: PI, MAXIMUM_VALUE. Class names should start with an initial capital with the first letter of subsequent words capitalised (this is called Camel Case): Molecule, BlackHole, DNASequence. Functions should start with a lower-case letter with the first letter of subsequent words capitalised: spliceGeneSequence, calculateOrbit." more at: http://software.ac.uk/resources/guides/writing-readable-source-code pedantic for sure, but all easily explainable code is :)
C# may have started as a Java knockoff, but it pretty quickly advanced to being its own language with some pretty nice ideas in it. Without the constraints of backward-compatibility that Java had, it was able to evolve a lot faster. It's also not stuck to Windows, and is getting less tied to Windows all the time.
And it's right for C to behave the way it does, and for C++ to behave differently. It's reasonable to write code that compiles as both C and C++ in some circumstances, such as when you need to interface between the two languages, but that may end up departing from the standard way to write in either language. Trying to take advantage of C++'s additional typing rules without the additional features of C++ that go along with them is really not a great way to learn C the way C ought to be used, and it's certainly not a great way to learn the way C++ ought to be used. Since the "C compiler" and "C++ compiler" are often just different aspects of the same toolchain, there's really *no* reason to start someone off writing C-like code compiled with the C++ compiler.
If you're going to be writing C++, it's best to just start off with simple programs that are fully on-board with the features C++ has beyond C. Not all of them at once, of course, but pulling in the C standard library and memory management stuff would really be a step backward instead of a real simplification.
That isn't code.
I am not seeing i incremented. That could be the immediate problem if its just not printing.
There are no urgent question on this subreddit. If your question is urgent, you should have asked when there was still enough time. Your emergency is not our problem.
You would best learn to use python. It has many math capabilities and it is one of the easier languages to dive in: http://www.learnpython.org/ will teach the basics https://www.python.org/ provides a windows installer to install python After python is installed, use any editor to create a python file (mostly those files are given a name ending on ".py") and then you can run it on the commandline using "python &lt;filename&gt;".
You're trying to move to fast. You need to slow yourself down a bit, write some small code, encounter some bugs, and learn from that. If you think you're going to somehow write perfect code from the get go, you're in for a bad time. Get in the mud. &gt; I've already bumped into an episode where he uses classes to define some sprites. Then you know how to invoke the relevant points of SDL. Instead of looking at the C++ codes and classes, look at what you want to design and use what is available to you. For animation and sprites, you probably can pull this off with a no frills struct and a couple auxiliary functions in a dedicated file that you include. Just don't try to make a mime of a class or you'll make a mess. &gt; Is this all I have to be concerned about? Or are there other C++ concepts that I'd have to try to mess around with to get working in C. The biggest thing you have to be concerned about is that you're fretting. Start small, then slowly build on that scaffolding. Build in a manner that is natural for the tool you have, and you will make a solution that is clean and easy to follow.
This is a subreddit for C, not C#. They are completely different languages. Post on /r/learnprogramming, but nobody is going to be able to read your boss's mind. 
Oh oops. I'll move it, thanks. Honestly I was just wondering if there was some part of what he asked that I wasnt understanding, but I'll ask there.
You didnt have to be this mean, but i understand
I did have a quick course on c, but i can basically only do forÂ´s. Besides, it was over 2 years ago, i dont really remember. Thanks for your help, but i think i ll just skip this...
Why would you *not* want to use the C99 `int32_t` types? They're *much* easier to work with and guarantee exactly the portability you want.
Judicious [use of function pointers on structs](http://nullprogram.com/blog/2014/10/21/) can get you the important parts of OOP, [like polymorphism](https://fgiesen.wordpress.com/2011/11/21/buffer-centric-io/). That's been proven viable enough to build huge, complex operating system kernels. I wouldn't want build a whole project around a homebrew OOP system in C -- especially when lot of complex macros are involved, as often seems to be the case for these things. I don't remember how *21st Century C* approaches it. 
Quake 3 was written in C and is freely available. You should also look into [COM](https://en.wikipedia.org/wiki/Component_Object_Model), it's a pretty cool way of implementing objects regardless of the underlying language.
I liked it. I compiled it as Win32 console app in MSVC, watched the characters dance and sway. You might really like this guy's [stuff](http://benryves.com/products/). In particular I mean [ASCII Madness](http://benryves.com/products/asciimadness) and ASCII Madness II. It's free and he gives the source code too. 
C is C, don't try to make it object oriented. Also, you plan to *start* this project in a year? No way, start today. A year from now you'll have already learned all the good stuff you're going to learn from it and moved on to better ideas with those new skills in your pocket. I wrote a 3d engine for a game in the early 90s when I was about 15. The basics are incredibly simple and you absolutely can start them today. Day one stuff: - Make a struct that represents a 2d point. - Make another. - Make a function that draws a line between them. - Make a third point. - Use your line function to connect all three points. - You just drew your first poly. - Expand your line drawing function into a triangle drawing function. - Teach it to fill in the triangle. - Add a color value to your point struct - now you can have your triangle function shade as it fills.
Oh man, I think i know this one! Author was Steve Rimmer or something like that.... let me do a search ...back soon... EDIT: Yea, (based on 1. fun read and 2. covers many formats) I think you may mean [Steve Rimmer's 'Bitmapped Graphics'](http://www.amazon.com/Bit-mapped-Graphics-Steven-William-Rimmer/dp/0830635580/) That's **not** the cover I remember, but that's the book -- covers Gif, BMP... all the main ones *known in that era*. I used to have it, and from it I 1st learned Gif encoding/decoding. He had a kinda bizarre and fun writing style that not everyone liked -- "the code doesn't fit the text" my friend complained(lol). But we both agreed it was an outstanding code source in its day. EDIT2: I think [this](http://www.abebooks.com/servlet/BookDetailsPL?bi=12951225020&amp;searchurl=isbn%3D0830642080) was the version I had. But [this one](http://www.amazon.com/Supercharged-Bitmapped-Graphics-Book-Disk/dp/0830637885) may be better. 
Yep, yep, yep! You got it, man. Did the cover look like this: http://s.ecrater.com/stores/9409/4d8bba36aad2e_9409f.jpg ?? I did a google search for that cover and that is exactly what I remembered. Unfortunately I can't read the cover. But is that the cover you remember too?
Yep just ordered it from Amazon! I'm pretty sure this is it though I can't find a more detailed cover of it like the one I shown above. Thanks a lot for your help! I knew someone had to know! I can't believe I picked this up at a bargain bookstore and somehow it got lost. I think I threw it away by accident.
I blew up that Gif and it says "Windows BitMapped Graphics". Steve Rimmer definitely had a book by that name, but I have been unable to confirm that the cover in your image matches any version (after a short net search) 
Hi wanted to make sure you saw [this - with image](http://www.bonanza.com/listings/Windows-Bitmapped-Graphics-Book-By-Steve-Rimmer-First-Editio/30473351) (Note: Website is slow to load) Definitely "Windows BitMapped Graphics" Steve Rimmer --- even cheaper on Amazon if used is ok. Anyway, I think the Windows version is just the same algorithms re-packaged for Windows coding, so -- you probly won't miss much. 
Ah I see it is a first edition. Okay yeah I got it ordered with my prime. It's coming Wednesday I'll let you know if it is the first edition like that picture. 
My intro to computer science teacher flat out told us that it's a bad practice, don't do it.
&gt; C is C, don't try to make it object oriented. Ehem, many of the things we have in C++ (classes, inheritance, virtual functions started out as design patterns in C. It's absolutely possible to write C code in an object-oriented fashion and many large projects like the Linux kernel prove that it can be done without much headache.
I'm surprised that no one has mentioned [GObject](https://en.wikipedia.org/wiki/GObject) yet. It's what GTK uses for objects. It's viable in the sense that lots of people have done it, all of GTK is built on top of it, etc. The basic idea is you have a struct named my_struct, and a bunch of functions named my_struct_foo() that take a my_struct* as their first argument. If you need inheritance, you make the first field of the struct be whatever it is you're inheriting from. If you need virtual dispatch, well look at GObject does for that, that gets more complicated. Is it a good idea? I'm not convinced. You have C++, which is looking a lot nicer nowadays now that C++11 and C++14 are out. One thing from C++ that I really miss in C is RAII. That removes a lot of "goto"s for me. And then you use that with smart pointers, that removes a lot of manual memory allocation. You also have Rust, which looks very interesting to me. And there's other things like Go, that look less interesting to me, but are popular right now. If C++ looks too complicated, then just don't use what you don't need. Lots of projects, for example, compile with the option to disable exceptions. You don't have to write any templates if you don't want to. You don't have to set up complicated multiple-inheritance class hierarchies.
&gt;Yes; there's even a language constructed specifically to shoot yourself in the foot, it's called PHP. That the *old* PHP (4.x). The new PHP shoots your foot for you.
It's free, so you'll loose nothing by trying it. If you get through a couple of chapters and decide it's not for you, no one's gonna ram it down your throat and you can just move on. C is a great language in my opinion, and the main reason I learned was through simple enjoyment. If you have a passion, you'll accrue knowledge without even realizing. As for your cyber security aspirations, I would view that as a separate topic. There's no one language that's best for it. Again, start looking at different stuff and see if you enjoy it, if not, reconsider your options. Check out Christof Paar's Introduction to Cryptography on YouTube first, that's as good a starting point as any in my opinion.
As a side track, all the C you really need to get started in the field is taught in The Art of Exploitation. If you haven't heard of it, it's a security/hacking book that is brilliant. C is a really small language and quite easy to learn. So you don't really need a lot more than an introduction and some Googling skills. **Edit:** I misspelled the title.
I did C in one module in college, so I didn't come at LCTHW with a complete blank slate, but suffice it to say my C was as rusty as the handrails on the Titanic. However, I personally found LCTHW jumps around quite a lot - I found it hard to establish a rhythm to the lessons, and felt like I had to learn something and put a pin in it for the next couple of chapters until it became relevant again. I didn't get a real sense of progression. Contrasting this to the K&amp;R C book (I had the ANSI C edition), the lessons build up well and you're using most of the previous aspects that you've learned in subsequent chapters. It even goes through some of the C standard library functions and shows you how to code them (sometimes in a simplified fashion). I would personally recommend this over LCTHW.
The art of exploitation is an absolutely fantastic book. The C introduction it gives, blended with the low level dissemination in order to understand the exploitation portion makes it such a great learning tool. I read the book thoroughly a while back, but it wasn't until two years later that I actually had to write some C, and I realized I could pick it up as if I knew it fluently already. It was pretty whacky. 
http://www.amazon.com/The-Programming-Language-Brian-Kernighan/dp/0131103628 is still the 'go to' book. If you want some deep understanding, I also strongly recommend http://www.amazon.com/Expert-Programming-Peter-van-Linden/dp/0131774298 for digging into *exactly* what is defined and undefined behaviour, and how things work. ...if, you have your heart set on C. It's a great language, but it's not really terribly practical these days. Relatively few people use it for any significant purpose (and to be fair; those purposes are *very significant*, but they are few). C++ security and exploit techniques are similar, and very much more applicable. (see, for example https://code.facebook.com/posts/498597036962415/under-the-hood-building-moments/) You may well be better off with a copy of http://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996, which is an excellent C++ book that covers both the new modern features, and what to/not to use them for and http://www.amazon.com/Mastering-CMake-Ken-Martin/dp/1930934319, which is a book about how to use a proper cross platform build system. I continue to recommend people not bother with LCTHW. Its extremely opinionated, and the opinions in it are not ones you want to have. Unfortunately. 
Do you think that The C Book (publications.gbdirect.co.uk/c_book/) would be good enough for picking up C?
You seem to misunderstand how TCP sockets work. Reading from a socket can totally just return a single byte, even if the client sent more than that - you need to continue reading from the socket in a loop until you have all the data you expect (for a HTTP request, that would be a double \r\n). 
I'm not the OP, but thanks for that reminder. I keep forgetting that. 
See [here](http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_02_02) for the full list of all reserved names.
The value of b starts as undefined; however, b has an address on the stack. &amp;b points to the address of b. You can show the value of b (ignoring optimization). That is, you can see the data in memory at an address that it knows. Then you assign to b the address of a. b is a pointer that has an address on the stack, whose value is the address of an integer on the stack. Then you assign to b an address on the heap. b is a pointer that has an address on the stack, whose value is the address of an integer on the heap. Edit: some clarification.
You are correct, I believe I have fixed that (see branch develop). I'm still getting a segfault but I think thats from reading the mime types.
After pushing some changes, I'm now segfaulting because in get_mime_type on line 144: &gt; for (int i=0; mime_types[i][0] != NULL; i++) { It doesn't appear to have anything in the variable mime_types even though it was loaded with data successfully in load_mime_types.
You mean load_mime_types I think. And that function works. If you print out the contents of mime_types right after you can see everything was loaded correctly. The problem is that for some reason, mime_types isn't accessible from a thread, which I can't figure out...
You should always compile with warnings enabled. Add -Wall -Wextra to your CFLAGS in the Makefile. Doing this should cause the compiler to point out the fact that mime_types declaration is wrong.
Thanks for the tip. What is the correct way to declare it?
The way it's currently written, the compiler is assuming you meant to make the array only 1 element long. So when load_mime_types tries to load more than 1 type, it is writing past the end of the array. I would do something like: #define MAX_MIME_TYPES 64 char *mime_types[MAX_MIME_TYPES][2]; Then make sure that load_mime_types never loads more than MAX_MIME_TYPES types. If you don't like the idea of having a fixed upper bound on the number of types, you can also dynamically allocate mime_types with malloc/realloc inside of load_mime_types. EDIT: It also appears that load_mime_types is assigning the token variable directly. Since token is local to load_mime_types, as soon as the function returns, those values are no longer valid. I would simply replace them with a strdup(token) instead.
Thanks. I implemented that but I'm still experiencing the same issue I described in the edited OP.
Yeah, sorry, I added an edit to my previous comment. I believe the issue is related to the fact that the token variable is local to load_mime_types. So instead of assigning the mime_types values from token directly, assign strdup(token) instead.
First of all, I think you're right. I find myself in a frustrating pattern where I always bite more than I can chew. Small steps is a very important thing, and I will work hard to focus on the little things one at a time. &gt; Instead of looking at the C++ codes and classes, look at what you want to design and use what is available to you. I see the advice you're giving me, but I'm unsure what I want to design. Do you mean for every tutorial I do, spend some time trying to figure out how I would implement the new concept in my own project and see if I can make something work without creating some class that ends up being a disaster? Thanks for your response.
Hint: Don't use identifiers that begin with an underscore. Such identifiers are reserved for internal use by the C standard library.
Thanks for the insight :)
You might also want to have a look into the LAPACK routines for how to do this matrix stuff efficiently.
`goto` can be used to enhance program structure. Some times it's just the right tool for the job.
I would debate putting the function pointers in the struct at all. I think a lot of that is my programming methodology personally. That said, I could function pointers in the struct being useful because it would let you in a way imitate virtual functions. For example, we have an actor struct, which is used to represent characters on screen. The movement function it points to could be things like move_user(), move_random(), move_follow(), move_pattern(), move_still(), et alia. This would be nice I guess since when it comes time to move the actors you wouldn't need a switch-case deal, but could just invoke the member. I guess you could do this as well by declaring the functions, storing pointers to them in an array, having an int or something in the struct for which to choose, and then indexing to invoke it or something. This is a fun thought exercize, and there are definitely ups and downs to any solution (that arrays one could get really messy really fast). **EDIT**: Sorry for rambling.
Thanks for your comment. Its really helpful :)
Please put for blanks in front of every line of code so the source code appears in a mono space font. You can edit your post to add the blanks.
Probably best to code up something. Try this : https://en.m.wikipedia.org/wiki/Conway's_Soldiers Write a program that takes a target row and column as command line arguments, then works out a move set for reaching it. When it has found a correct series of moves, print them out.
What does the position do? 
Lots of possibilities, do you have a specific situation in mind? 
http://www.reddit.com/r/programming/comments/2nqrsr/cc_tip_how_to_loop_through_multidimensional/ tl;dr: If you're optimizing for a hot loop, you'll get different performance whether you use a 2-dimensional array or a 1-dimensional array, even though they conceptually are the same, and you can further optimize by doing your own invariant hoisting.
i mean, I know how to draw graphics on a screen programatically, but I could I say, have an image of a board of chess and manipulate the pieces so that they move to the correct location on the board? 
So probably what you'd want to do is make a graphic of an empty board then also make graphics of each chess piece on a transparent background. Open yourself a window you can draw to, load all your images up from the graphics files you made, then you tell it to draw the board image to the window, and next tell it to draw the chess piece over top of it. You can move the piece around by repeating this process in a short loop where you increment the x,y co-ordinates that tell it where to draw the chess piece in the window. Something like: for (i=0; i &lt; 15; i++) // draw 15 times to make a short animation { rook.x++; // rook will move horizontally 1 pixel per frame draw board graphic to window draw rook graphic to window at location rook.x, rook.y wait 30 ms } A small graphic you draw over the background like that is called a "sprite". That term should help you find a lot more info.
I do not understand what you are saying. But you can dynamically allocate multidimensional arrays in C with a single call to *alloc.
So kind of you to explain how. I had to figure it out for myself. #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; int main(void) { srand(0); size_t row_size = rand() % 100; size_t col_size = rand() % 100; int (*matrix)[row_size]; printf("Row size is %zu\n", row_size); printf("Col size is %zu\n", col_size); matrix = malloc(row_size * col_size * sizeof(int)); printf("Matrix is at %p\n", matrix); printf("Matrix[1] is at %p\n", matrix[1]); printf("Matrix[1][1] is %d\n", matrix[1][1]); return 0; } I'm shocked to see that that compiles. Shocked! I was sure that C doesn't allow dynamically-sized arrays like that, and certainly not multidimensional ones. Hang on, compile with `-ansi -pedantic`: warning: ISO C90 forbids variable length array 'matrix' [-Wvla] Right, it's actually using a GCC extension (even when I compile with `-std=c89`). So no, C *doesn't* let you do this kind of thing... not if you want to be portable.
From the article, probly not, right? But still, I'd like to see some [BCPL code](https://en.wikipedia.org/wiki/BCPL#Examples) and take an objective look for similarity. 
I'm not sure if this will help you but may be you should have a look at this: http://coderbyte.com/CodingArea/Challenges/
Sadly, C has not seen the same adoption of newer standards that C++ and other languages have. Sure, if you use GCC like many people do it works fine. But a lot of compilers for embedded and other less common platforms still don't support C99 fully, or at all. That's partly what makes C so popular and enduring. If you're creating a new processor, it's fairly simple to write a compiler that compiles C89/90. It's a bit harder to support C99, and a lot harder to support C++. But we need to be fair here and recognize that in the lowest common denominator, C does not have features like this. If you intend to write truly portable, reusable code, such as this matrix library, you can't rely on newer features like VLAs.
cs50.harvard.edu Start with PSET 1 Go up to PSET 6 (last C assignment) PSETS 1,2,3 are really beginner level, but they also introduce valgrind and gdb
The while loop condition is always not equal to zero. There is no break that will exit the loop.
So why am I not getting an error for declaring a variable with the same name multiple times? 
The buffer "dies" at the end of the outer loop. But that doesn't mean that its contents are zeroed out. Similarly, when the buffer array in declared its contents are not initialized to zero. Basically, the buffer array is allocated at the same position in the stack each time around the outer loop. It just so happens this way. The C standard doesn't guarantee that it will get allocated at the same place. The first time around it gets filled with your string. The subsequent times around the loop, you're basically getting the contents from the first loop. 
When the block completes, the variable is forgotten. Then, the condition is tested. In this case, it passes and we execute the block. The declarations do not collide because it has nothing to collide with. Edit: the syntax for while is: while ( _expression_ ) _statement_
Ohh, ok, now I understand. So what would be the best practice to avoid this? Initializing the buffer at the start of the loop like char buffer[40] = ""; won't work. So I'm guessing the best way to handle this is with malloc and free? Also, if so, should I use calloc instead of malloc? EDIT: It wasn't working because of me forgetting the \n at the end of the printf. It actually does work 
What exactly are you trying to do? You have a print statement inside an infinite loop - it's going to constantly print something. If you use malloc that doesn't change anything. Malloc is used for dynamic memory allocation, and in this case you aren't dynamically allocating memory - you're just creating a string 40 characters long. When a variable goes out of scope/is destroyed/gets deallocated, all that means is that the memory is being freed up so that it can be used by other programs. It isn't being "deleted". The fact that the string you put in memory is still technically there after the variable goes out of scope is okay, because the memory has been freed. If any other program needs that memory, it can just write over it. Memory doesn't constantly need to be set to 0 when it's not being used anymore. If you dynamically allocate memory for a variable and that variable actually needs to start at 0 (as in, it needs to be 0 initially, at least under certain circumstances) then you could use calloc. But most of the time, you will always put information *into* a variable before using the information in the variable (like using it for calculations, or printing it to the screen, etc.)
Initializing the buffer to the empty string will set the first element to 0 but leave the subsequent elements with their existing state. If you read in a new character into the first element, the zero will be overwritten and now your string may not be null terminated. You also have the possibility of overflowing your array because you're not bounds checking. Will your buffer be null terminated once it's read in the entire string? It depends on whether the sender sent the null terminator. From the discussions so far, it sounds like you are. But relying on the sender to null terminate your string is bad practice. This is the way security holes are born. Edit: everything Edit again: Ohh, I'm wrong. Initializing the array to the empty string will set all elements to 0.
Oh, and the biggest mistake, which I didn't look for the first time: you don't check for NULL when allocating anything! If `malloc` or `matrix_alloc` ever return NULL, you immediately dereference it, which will crash the process/system. This is *very important*. If you're making a reusable library, you can't assume what systems I might want to run this on, or what matrix sizes I want. It's entirely plausible that I have a 1000000x1 matrix and a 1x1000000 matrix (which take up 8MB total), but if I try to multiply them I end up with a 1000000x1000000 matrix that requires 4 TERABYTES. Clearly, that allocation is going to fail, and your library needs to be prepared for that. Crashing is not an acceptable response. (For that matter, you should check for overflow when multiplying the row and column sizes together, before you even bother calling malloc. 1000000^2 is 1 trillion, which overflows on a 32-bit machine, so there's no point even calling `malloc`. But if you don't check for overflow, you'll just get a result of 3567587328, which is a valid 32-bit number, and on some machine might actually allocate successfully even though it's too small to hold the matrix.)
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 18. [**Powers of matrices**](https://en.wikipedia.org/wiki/Matrix_multiplication#Powers_of_matrices) of article [**Matrix multiplication**](https://en.wikipedia.org/wiki/Matrix%20multiplication): [](#sfw) --- &gt; &gt;Square matrices can be multiplied by themselves repeatedly in the same way as ordinary numbers, because they always have the same number of rows and columns. This repeated multiplication can be described as a __power of the matrix__, a special case of the ordinary matrix product. On the contrary, *rectangular* matrices do not have the same number of rows and columns so they can *never* be raised to a power. An *n* Ã *n* matrix __A__ raised to a positive integer *k* is defined as &gt;&gt; &gt;and the following identities hold, where *Î»* is a scalar: &gt; &gt;* __Zero power:__ &gt;&gt; &gt;* __Scalar multiplication:__ &gt;&gt; &gt;* __Determinant:__ &gt;&gt; &gt;The naive computation of matrix powers is to multiply *k* times the matrix __A__ to the result, starting with the identity matrix just like the scalar case. This can be improved using [exponentiation by squaring](https://en.wikipedia.org/wiki/Exponentiation_by_squaring), a method commonly used for scalars. For [diagonalizable matrices](https://en.wikipedia.org/wiki/Diagonalizable_matrices), an even better method is to use the [eigenvalue decomposition](https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix) of __A__. Another method based on the [CayleyâHamilton theorem](https://en.wikipedia.org/wiki/Cayley%E2%80%93Hamilton_theorem) finds an identity using the matrices' [characteristic polynomial](https://en.wikipedia.org/wiki/Characteristic_polynomial), producing a more effective equation for __A__^*k* in which a *scalar* is raised to the required power, rather than an entire *matrix*. &gt;A special case is the power of a [diagonal matrix](https://en.wikipedia.org/wiki/Diagonal_matrix). Since the product of diagonal matrices amounts to simply multiplying corresponding diagonal elements together, the power *k* of a diagonal matrix __A__ will have entries raised to the power. Explicitly; &gt;&gt; &gt;meaning it is easy to raise a diagonal matrix to a power. When raising an arbitrary matrix (not necessarily a diagonal matrix) to a power, it is often helpful to exploit this property by [diagonalizing](https://en.wikipedia.org/wiki/Diagonalizable_matrix) the matrix first. &gt; --- ^Relevant: [^Matrix ^multiplication ^algorithm](https://en.wikipedia.org/wiki/Matrix_multiplication_algorithm) ^| [^Min-plus ^matrix ^multiplication](https://en.wikipedia.org/wiki/Min-plus_matrix_multiplication) ^| [^Strassen ^algorithm](https://en.wikipedia.org/wiki/Strassen_algorithm) ^| [^Cannon's ^algorithm](https://en.wikipedia.org/wiki/Cannon%27s_algorithm) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+csc90uq) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+csc90uq)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](/r/autowikibot/wiki/index) ^| [^Mods](/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Call ^Me](/r/autowikibot/comments/1ux484/ask_wikibot/)
Remember to always initialize variables to 0 when you create them, it'll help you from making some common mistakes. For example `char fulltext[1000];` is not initialized, so when you later call `strcat(fulltext, text);` we will get undefined behavior. After `scanf(" %100[0-9a-zA-Z %&amp;@#!+:_-$^*=&gt;&lt;\"]",&amp;text);` try placing a `printf("length=%u\n", strlen(text));` and this might give you a clue as to what is happening with your code.
So, upon doing this, spaces, or complete blank entries return nothing, entering any sort of text gives me the length of what was entered. 
Zed Shaw has a [webbook](http://c.learncodethehardway.org/book/) that's free called Learn C the Hard Way. It's worth a look but it may be too basic for your needs.
&gt; Ohh, I'm wrong. Initializing the array to the empty string will set all elements to 0. In particular, if an array doesn't have all of its elements in the initialization list, the rest of the elements are initialized to 0. int a[5] = {1}; will set `a[1]` through `a[4]` to 0.
So the following `%02X` formatting works as intended!
You seem to not understand what null termination is. The null terminator is used to mark where the end of a string is *that is stored in memory*. There are no null terminators in an input stream. Instead, when inputting a string, the characters are stored in memory, and then *after input has finished*, a null terminator is stored in memory so that future accesses to that memory can see where the end is. Your real question appears to be: &gt; How do I prompt the user for text and be able to detect if nothing was entered? To answer that: use the `fgets` function. This inputs a *line*. The definition of a line is: some number of characters (possibly zero) followed by an *end-of-line* character (also known as *new-line*). Note that `scanf` with `%s` is not suitable, because that only reads a *word* (a non-zero amount of characters followed by whitespace). The `fgets` function (unlike most input functions) stores the newline character at the end of the stored string. This is so you can distinguish between the end of line being read, and the line being too long for the buffer. Here is an example with exception handling: char line[100]; if ( !fgets(line, sizeof line, stdin) ) printf("The input stream was closed\n"); else if ( line[0] == '\n' ) printf("They entered a blank line\n"); else if ( line[strlen(line)-1] == '\n' ) printf("They entered a line of length %zu\n", strlen(line)-1); else printf("They entered more than 99 characters - remainder of line remains in the input stream to be read next time"); 
You are using scanf incorrectly: &gt; scanf(" %100[0-9a-zA-Z %&amp;@#!+:_-$^*=&gt;&lt;\"]",&amp;text); Firstly, the leading space means *skip any amount of whitespace*. So if the person presses Enter then scanf keeps reading. It doesn't stop reading until at least one non-whitespace character is entered. You should have noticed this while testing your code. Next using `-` inside `%[` is implementation-defined. Standard C only requires that characters and `^` for inversion be supported. This isn't a regular expression. The argument should be `text`, not `&amp;text`: it needs to have type `char *`. Finally, you never check the return value of `scanf`. The `%[` specifier will fail if it does not match something. When scanf fails, nothing is stored in the output buffer; so you will go on to call `strcat` and `strlen` with whatever was left over in the buffer from the previous time. You should *always* check the return value of `scanf` and take action if it was not what you expected. In this case I would recommend not using the complicated `%[` expression. Instead, read a line with `fgets` and then check to see if the line contains any unwanted characters. 
I'd just set the first element to the null terminator '\0'. Also, as mentioned previously you should make sure you don't read past the end of your array. Edit: In case I wasn't clear: buffer[0] = '\0'; Edit2: I'd avoid dynamic memory (malloc, calloc, free, etc) unless you were hoping to read in an unlimited number of characters. Also, char buffer[40] = ""; will actually work by doing the same thing as my first edit. Edit3: Also remember to null terminate after the read loop
I'd use a loop to print out the hex value of each character in the string but potential spoiler: the first character may be a carriage return ie '\r'. Also if you're using scanf, it returns the number of characters read.
That's not correct. For instance, on a machine with a 12 bit `char`, `uint8_t` is a special type with size `1`, 8 value bits and 4 padding bits and a total range of values that is less than that of an `unsigned char`.
nope, &amp;&amp; cheks the left condition first, n&gt;0 fails, ptrbuffer is not incremented
I'm interested in the malloc part. Let's say I were hoping to read an unknown and probably big number of characters. What would the course of action be then? Using a malloc at the beginning to initialize the array with an arbitrary number, then checking the array length in the do while and using realloc if I get close to max?
yes
You're reading strings in a wrong way: you pass &amp;StudentName[50] to scanf; you should pass StudentName, which is a pointer to the first character (equivalently, you can pass &amp;StudentName[0]). As you're doing it now, you put the string starting beyond the end of the variable, not in the beginning. That's not the cause of the error you're reporting, however. For what you want to do, you should perform the sum (Sum=Sum+Grade or whatever) *after* doing the check to see if it is a valid number.
I know this has nothing to do with the question but what is with the ridiculous amount of white space? And why do you take `argc` and `argv` if you don't even use them?
But if I need the number to be a float how can it be a char at the same time?
You use two different variables: `char c` to read the char, and `float Average` to get the average value.
Well, that is the signature for main. 
Operator precedence. You're decrementing the pointer, not the character. Try `(*lives)--:`
This. I would never have thought of precedence in this matter. This is beautiful. Thank you very much!
Yes, I tested it, and it worked now due to the precedence. Thank you very much!
No problem!
I don't believe even C11 has that feature yet. It's standard C++, and a GNU extension to C.
Oh, then I'll have to read into it. I got it from 21st century C where it wasn't declared as an extension.
I'm seeing a problem here, but I don't know if it's *the* problem: when guaranteeing that the new number isn't already in the array, you should go with `j` from `0` to `i`, not to `5`. Otherwise, you will always change the new number (because it's always equals to itself).
are you talking about if (random == a[i]) { a[i] = rand() % 5; } it prints out: 2 0 2 3 1 
Can you describe to me your algorithm/strategy in plain English?
Well if it's embedded you have a good amount of studying to do, its practically a new world of programming. I'm hesitant to just list a bunch of things to study here, but definitly look into interrupts, if you know what micro they are using d/l the datasheet and start reading. 
I finally found the problem: you should reassign `a[i]`, not `a[j]` (you can remove the `random` variable and use `a[i]` exclusively as well); otherwise, you may change the j-th number to a number that, while being different from the i-th one, is equal to a number at a different position. Furthermore, when you find that two numbers are equal and change the current number (as I've told you in the first paragraph of this comment), you should reset `j` to `0` again, because the new number might be equal to a number from earlier on.
I got the book (see my EDIT) based on /u/flaccidicus ' remarkably strong recommendation. I really like it. But now I understand your sentiment. 1st off, this is NOT a book I would recommend for learning C. The book has plenty of C, and C-look-alike-psuedo code, but this is all merely applied to his overall topic of the book, and not presented for the purpose of learning C, no way. 2nd - he moves quickly into computer architecture and then assembly language and whew! Although a rich source of information on *the topic* - this is not gonna help you learn C too much. I could say more -- but simply, now I get your thoughts on it. EDIT: I'm a buffoon. All this (above) text applies to 'Hacking: The Art of Exploitation, 2nd Edition' and Not to the OP's book "Learn C the Hard Way" that you are addressing, too. But I'll leave the text here for those that might be considering getting 'Hacking: The Art of Exploitation, 2nd Edition', and to reveal my buffoonery. EDIT2: I didn't think [Learn C the Hard Way](http://c.learncodethehardway.org/book/) was too hot either, but at least it's free. ["An IDE, or "Integrated Development Environment" will turn you stupid."](http://c.learncodethehardway.org/book/ex0.html) ... yea, OK. Hey, wait -- perhaps my years of IDE usage was root cause of my mispost?.... aww snap!
Thanks for this intro - love the book!
Ok, i'm intrigued. Why you say that? 
What do you know, that did the trick. The program is working perfectly now. Thanks u/shinmai_rookie!
&gt; parse a variable as a pointer in a function. It should be: "*pass* a pointer to a variable to a function". The word "[parse](https://en.wikipedia.org/wiki/Parsing)" means something entirely different: to convert strings into structured data. Also, it's often helpful to turn the warnings on when compiling (e.g. `-Wall` flag in gcc or clang). Here's what clang has to say about your code: warning: format specifies type 'int' but the argument has type 'char *' [-Wformat] printf("%i", lives); ~~ ^~~~~ %s warning: expression result unused [-Wunused-value] *lives--; ^~~~~~~~
should I call it every iteration?
or atoi(); 
Yes, printing it every iteration will be as fast as any other way to do it. Standard C file I/O operations will typically be buffered (either line-buffered or block-buffered), so there's effectively no performance penalty to doing many calls to `printf`. (Note: this would not be true if you were using unbuffered system calls such as Unix's `write` system call. Stick to `printf`/`fprintf` and you'll be fine)
This is a great idea! And thanks for the head start, too. I'll tackle this problem and see if I can mess around with other situations I might run into in the future. Thanks, /u/Hellenas !
Wouldn't it be better to buffer it in RAM and only write to file every so often? I'd think 4 billion write calls would slow things down considerably. 
Yeah, I'd hope that printf() just calls fprintf() with 'stdout' as the first argument. Edit: Downvote? 
whatever you do I/O wise, printf or whatever, it will be dwarfed by testing all the way to k; for (t = 2; t &lt;= k; ++t) { try testing up to k^.5, it will make a big difference.
&gt;do you know how to do square roots? With integers, it isn't to hard using bit wise operators for what I've seen. Thanks for the idea, it should help a lot. When I saw you're initial post I thought `k/2` would be enough.
We can go [even further](https://en.wikipedia.org/wiki/Primality_test). tldr: test if k is divisible by numbers only in the form of 6x+1 or 6x-1. (i.e.) for (t = 5; t * t &lt;= k; t += 6) { if (k % t == 0 || k % (t + 2) == 0) { goto exit; } printf("%ld\n", k); exit:; } This allows you to increment **t** by **6** each iteration, rather than **1** so you'll see some major improvements in speed. Also note that the condition is **t * t &lt;= k** and not **t &lt;= sqrt(k)** (even though they will produce the same outcome) because the square root function takes longer to compute than **t * t**. This can drastically cut down on the amount of iterations you perform in your inner loop and save you a lot of time for larger numbers. EDIT: because **t** starts at **5** in this new loop, you'll have to manually check for cases where **k** is less than 5 (such as 2 or 3).
I think I figured it out. I didn't even need bit-shifting. #include &lt;stdio.h&gt; int main(void) { unsigned long k, t; for (k = 2; k &lt;= 100; ++k) { unsigned long x = 1; // the new variable that stores the square root of k while (x * x &lt;= k) x++; for (t = 2; t &lt;= --x; ++t) { // decrement x because the computation // leaves x 1 higher than it should be if (!(k % t) &amp;&amp; t != k) { goto exit; } } printf("%ld\n", k); exit:; } return 0; } Very simple compared to my assumptions. After checking how many times `t` iterates for every prime found it is significantly less than `k / 2`. I know you're asleep but I needed to post this somewhere.
Take the C introduction of that book with a grain of salt. It offers a basic overview of the most essential aspects of C but doesn't get into details about the "gotchas" of the language such as undefined or implementation-defined behavior. K&amp;R is probably a better recommendation.
He's probably talking about that it's easy to shoot yourself in the foot with C (i.e. critical mistakes such as buffer overflows). In my opinion, there is some truth in it. In C, the programmer has the responsibility to write secure code and the language doesn't protect you from your own stupidity. While this can be seen as a security risk, the relatively low abstraction of C could be seen as a security advantage.
I've several years of experience in C now, but thanks.
Wow, thats great. Never heard that before and it's so spot on (for C) its ridiculous.
Normally I would but for the c class I am taking the teacher was specific that it must be done the other way. 
It's true that C++ has a bunch of features that hurt (screw reference passing!) readability (and other properties of your code) but OTOH C is also not adopting certain features that would be *really really* good to have, and not hurt readability (or even improve it). Basically C is just at a stand-still and it does not look like it will ever evolve to embrace any of the great new things that you can now (or soon) get in other languages. For example const refs (good for performance &amp; safety, make your code more predictable), modules (make your code faster to compile, easier to manage and your compilation process less brittle,) ADTs (can help avoid nullpointer issues,) the various crop of "smart pointers" and move semantics that can express ownership etc, as they are present in rust and C++ (these can allow you to make resource management easier without sacrificing performance), operator overloading (e.g. for vectors which allow you to take a 40-line mess of pointer gargling and turn it into a 1-line expression that succintly mirrors the mathematical model it is implementing), dependent types, ..., making less stuff UB, etc So seeing how C++ is charging ahead with many of these things, it's not really that hard to understand why companies such as e.g. microsoft are rather neglecting C and building their libraries and infrastructure on top of C++. Being stagnant is IMO not really that preferrable over being a kitchen-sink.
You start at the first position in the list and try to free the position before the first, which is probably where the majority of the issue is coming from. Basically, "p" is first and you try to go and free "p-&gt;prev" which is undefined and *might not* have a NULL value.
A couple of answers on StackOverflow * http://stackoverflow.com/questions/15055065/o-rdwr-on-named-pipes-with-poll * http://stackoverflow.com/questions/6247300/named-pipe-creation
If you've never used them, you might as well take the time to do it for this! No better way to learn than to crash and burn a few times!
const refs? How about const int * const ? How does this not achieve the same thing? Modules? are we now talking about the linker because there are many different forms of "modules": 1) object files : only recompiled when needed. 2) Archive files are statically linkable libraries. 3) Shared-object files and dlls. I don't see how any of this is missing. I'm not arguing against using C++ when there's a need: I think a mix of C and C++ is probably the right way to go in most projects that choose one or the other, but I think you're overstating the value of some of the new "features" without considering their costs (such as increased verbosity of code for borrow checking/lifetime management, awkward implementations to work around borrow/move semantics, a tendency to over-design/over-complicate interfaces): nothing comes for free, ever.
Modules in the C++ sense. They're not directly related to what kind of end-product you get (.o, .ar, .so, ...)
Try `uint8_t`, if you're on a computer that has `stdint.h`. It just makes it more obvious you're talking about an 8-bit number, that way. If your computer doesn't have `stdint.h`, you could do a `typedef uint8 unsigned char`.
Well that's where I'm a bit confused. In C or C++ a module would be a pre-compiled object, archive, or shared object and a corresponding header. As best I can tell, "modules" support would just be a change in the way this packaging is done? Since we already have incremental compilation and linking I don't see what that buys in a language like C. Certainly if we were to design it all over again, packaging this stuff makes sense... but perhaps I haven't worked on a project where the lack of this is some sort of crippling problem that demands a solution.
That's how I would do it, personally. That's basically doing what a higher-level language's `String` type does, anyway. size_t buffer_capacity = 40; char *buffer = malloc(buffer_capacity); while(1) { ssize_t n = 0; /* read() returns an ssize_t, not an int */ size_t i = 0; for(;;++i) { n = read(clientSocketFD, buffer + i, 1); if (n == 0) break; if (buffer[i] == '\0') break; if (i == buffer_capacity) { size_t new_capacity = buffer_capacity * 3 / 2; char *tmp = realloc(buffer, new_capacity); if (tmp == NULL) { perror(NULL); exit(EXIT_FAILURE); } else { buffer = tmp; buffer_capacity = new_capacity; } } } buffer[i] = '\0'; printf("%s\n", buffer); }
The things you're doing with cpp directives now, you can still do with e.g. the way C++ modules work if you chose to do so. It's just a change that allows things to be better/safer/easier by default. It's a huge change, but it doesn't have to happen in a way that breaks compatibility with anything. Well, C++ has not quite proven this yet, but maybe it will in 2017. And yeah, namespaces are another one of those things there is really no excuse for that they are not in C. They make everything better, they are easy to implement without breaking compatibility with anything, ABI-wise they are unproblematic, and it would be pretty easy to provide some sort of pre-processor that converts namespace-code into namespaceless-code and vice versa when compatibility with e.g. an old compiler calls for it. They also have zero performance impact and don't make the compiler more complex.
This isn't C programming related. What you're looking for is a [unix domain socket](https://troydhanson.github.io/misc/Unix_domain_sockets.html) however like the name suggests: It's for unix (and unix-like) systems only. On Windows, you can use TCP sockets on localhost with the [SIO_LOOPBACK_FAST_PATH ioctl](https://msdn.microsoft.com/en-us/library/windows/desktop/jj841212\(v=vs.85\).aspx) for achieve much of the same effects (but notably: not the existence of a node in the file-namespace). 
* In `remove_task()` you aren't updating `p-&gt;next-&gt;prev`. Similarly in `insert_task()` you don't always initialize the `prev` field. This is the source of your problems. Really, there's no reason to maintain this as a doubly-linked list since you're never traversing it backwards except to peek backwards as you're freeing it. But since you don't maintain the `prev` pointers correctly, you end up crashing (double-free, etc.). * You have an off-by-one error in `read_input()`. It should be `i &gt;= max_len` and the realloc should include a `+ 1`. Otherwise you'll write a NUL past the end of the buffer at the end. * In `change_category()` you copy a new category into the old allocation without checking its size. 
ZDS appears to be a vendor compiler for a specific embedded platform, which unfortunately means you may not get all the fancy features that the general purpose compilers get due to their popularity. The error is telling you that you should not print a char *pointer* using `%i`. You should be printing `*lives` instead!
His criticism of erlang (and high-level languages in general) is that they "spent easily 2+ man/months dealing with a crash in the Erlang VM"? By the same logic, an OS vender could say they should design their own processors, because this one time they wasted some resources determining a bug was actually a faulty chip. That's a ridiculous proposition, bugs happen and higher-level language implementations will have them too. For every encounter of such a bug in a widely used abstraction layer, maybe a hundred memory leaks, null dereferences and buffer overflows are prevented. And his comment about the ubiquity of the ABI is moot. If you had an OS written in language X, of course the ABI for language X would be universal on the platform. Nails also have a more ubiquitous interface than screws, nuts or rivets, doesn't mean you should restrict yourself to a hammer.
Expect ~200M primes and a ~2GB file for primes to 2^32 - 1 (ULONG_MAX). You might want to change printf("%ld\n", k); to printf("%lu\n", k); (print long unsigned) before final run so that half your numbers aren't printed in negative values. Good luck with everything. 
Pointers can be null, references can't. 
There's a difference between restricting oneself to a language and recognizing that it's the right tool more often than people might think. By the same token, why would one always use screws when oftentimes a nail would suffice. Each language has tradeoffs, and blindly dismissing C due to the tired mantra that it's unsafe/unmaintainable is a mistake. The stability, simplicity, and cross-platform compatibility are advantages that are often overlooked... at least that's what I took away from the article.
It's not that sneaky, but the trick is to not re-invent link-list implementations every time. Encapsulate as much as possible. Write functions like list_push_front(), list_push_back(), list_pop_front(), list_pop_back() etc etc... you can inline them and lose zero performance, at the same time avoiding silly mistakes.
Oooh, yes. I know what you mean. Inside the gameloop(). Yes, I am already doing that in the actual code. I forgot to add the dereference when writing it here on Reddit. Thanks for pointing it out, though. I thought you meant printing the value of the char inside the main function. Yes, the IDE itself isn't that worthwile, in my vague opinion. For some reason, the "watchlist" of variables is broken, and the editing seems pretty much like a text editor. We are using an old version, but still.
Câs standard type system does not rule out programs that the standard (and common practice) considers meaningless, e.g., programs that write off the end of a buffer. 
I think this will fix your issue!
Spot on descriptions!
&gt; why use a non oop language when doing oop? When I see articles like this or projects that use these kinds of techniques, I always assume that it's from a hobbiest who gets off on seeing how far he can push C into non-C territory. As long as that's the case, I find it interesting in a geeky kind of way. But I doubt very much that anyone in their right mind could say with a straight face that this kind of stuff belongs in production code.
So... he's reinventing classes and calling them namespaces?
I heard that it is a good practice to leave one space before the percent sign "%" inside the scanf crap. 
Surely google must have returned a few suggestions...
I'm sure xcode includes everything you would need to write GUIs with iOS's own special API, but there are also graphical toolkits such as gtk+, Qt, wxwidgets, etc. which provide cross-platform solutions
Xcode is the right tool for making apps that run on your Mac. Have you studied any object oriented programming languages yet? You'll want to have at least a basic understanding of that and the MVC design pattern. You can write most of your program's own functions in C if you want but all your interactions with the operating system and GUI layer will be through object oriented code.
Thank you . This was the answer I was looking for. Btw I did start dabbling here and there with obj-c . 
Thanks, do you have a link to the msdn article?
Look up thenewbostons C tutorials on Youtube. Bucky is hilarious!! https://www.youtube.com/playlist?list=PL6gx4Cwl9DGAKIXv8Yr6nhGJ9Vlcjyymq The later episodes in his tutorials are very useful
This subreddit is for discussing C, not C#. Your post is off-topic and should be posted elsewhere. 
A legitimate question. What the author was really asking was "What is C well suited for?" C is not well suited for: * GUI programming (GTK for a modern UI? really?) * Mobile programming (I double dare you to call the native APIs) * Web back-end programming Namely, not for greenfield programming of anything that's not close to the metal.
Love it - thanks.
Yeah, the ++ changes the pointer after the while is false.
The while(\*cue++) is checking the value *then* incrementing. You're not passing the value, you're just incrementing after the check. If you want to walk the array until you hit a null you should increment before checking: while(\*++cue)
what's the difference between '\0' in an array, and the one that terminates it? Why is =='\0' a viable flag for the end of a string then?
 Consider the traditional implementation of strcpy: char *strcpy(char *dest, const char *src) { char *save = dest; while(*dest++ = *src++); return save; }
Because you want to copy the first null and then quit, not just quit at the null.
*post*increment.
Just to add: The nul character is by definition what makes a string a string. An array of char does not necessarily mean you have or want a string. Neither does having one of those be 0.
Christ, there's so much misinformation here. The reason the assert passes is because after the while loop cue points to 'd' (the value of the expression in the while test is the one before the increment happened). If you dont get it, look up post increment, the C precedence table, and put a printf of *cue in the while loop body.
You're talking about how the integer i in the callback will always start from 0 making it really poor for iterating thru my buffer right? That makes sense I feel pretty dumb now for not realizing that. Thank you for helping. :]
I'm a bit confused I may have just misread when I did man fread or one of the other functions I used. The file "recorded.raw" is 882kb when I run my compiled code it prints out items written being 220500 which I took as 220500 elements which I multiply by the size of a float giving me 882000 meaning 882kb in the buffer? Could it be that I allocated my memory wrong as opposed to reading data into the buffer wrong? Either way a buffer overflow is no good so I'll start looking into it right now. Thank you for the help! :]
Oh I get it lol. That's another dumb mistake on my part I even put two printfs above fread differentiating bytes and elements. So I just need to make it: items_written = fread(buffer, sizeof(float), (bufsize / 4), fileptr); I had to double check what I was putting in bufsize and what fread was expecting. Thanks. 
&gt; it made the code blow up because you always need to wrap around %DELTA t in this fashion: I don't get it. What's wrong with the code snippet? &gt; starts a clock from 0 to x and activates the switch case function with the certain states of the traffic light. I don't understand what you're trying to do. 
okay, sorry guys. i think i explained it too complicated. no, but i need more then y-x because I have 4 states. So basically i need to monitor the clock somehow and when a certain clock time is true, the state switches. so like 0-20 seconds = red 21-23 seconds = red/yellow 24-34 seconds = green 35-37 seconds = yellow time back to 0; repeat. so: I'm trying a switch case for this function, but i look for a simpler solution then difftime(). or a way to implement difftime() in a neat way. 
Well, if you wanted to control a real traffic light, you couldn't do it with a userspace program. At the very least you'd need a real time kernel with bounded scheduling latencies, and control over when/if your thread gets preempted. But I don't suppose that's what you're asking. 
It's perfectly possible to program this in C, the question is how.
How bout VNC + voice chat? Probably want to set up a clean, non admin account or a VM for this. Unless you're the type of coding buddy who likes to have people hang out among your dirty laundry.
Probably something like [Koding](http://koding.com) might work for you but I think it's not free if you want to team up with someone
Oh I don't care that you're asking for help. I just think his assignment sucks. Here's a hint: You can't use switch switch statement for this one. At least not in the way you're thinking. 
I've been coding together with an (mostly) online buddy of mine the last few weeks. We are using voice chat (Tox, Mumble, Skype, Teamspeak, some SIP, voice plugin for xmpp, whatever you like) for communication. For the code share, we are using a 5$ digital ocean VPS and share a tmux session :). Ssh works fine, but I love to use mosh. In the tmux session we have some windows with an editor (vim), one for compiling and running/testing and some more for random scribbles. It does require good communication, because you can both issue commands at the same time and insert stuff. For us it works out really great!
You might be looking for this https://codepad.remoteinterview.io/ Beware if you have an infinite loop it will not compile the code :(
What would be *for* modern UI then?
This article isn't of any value. It both fails to explain heap sort and has completely uncommented and unreadable source code. Blog spam is not welcome here.
Thank you so much for the kind words and honest feedback. I haven't looked into 'safe' programming much, if at all, so Im assuming that strncpy and fgets place limits on how much is copied. I will look into it tomorrow morning! Since each computer has different sizes for chars and into the only way to guarantee a byte is used would be to have a uint8_t? Is there another method you can point me in the direction of to assure I use the memory size I want? 
That's exactly it for strncpy and fgets, most functions like these have a 'n' counterpart (sprintf -&gt; snprintf for example). The type 'char' is always one signed byte, that's not computer or system dependant. I think you may be confused by encodings where one character isn't stored in a 'char' but often in a widder type (and quite frankly I've always found that 'char' was a really bad type name for representing a byte). However, my remark wasn't about not using uint8_t, you definitely can, but in that case you have to either import &lt;stdint.h&gt;, either define it (typedef unsigned char uint8_t;).
EXIT_FAILURE and EXIT_SUCCESS are values to be returned by the program (either by exit() or from return in main()). If you will be returning the value back to the shell from a function, then EXIT_FAILURE and EXIT_SUCCESS are okay. Otherwise, you can choose whatever is good for the program.
This is a pretty handy tool, thanks for sharing :)
Exact width types (e.g. uint8_t) are not required by the C standard, but minimum width types (e.g. uint_least8_t and uint_fast8_t) are, and are defined in stdint.h. If you are using a POSIX compliant implementation then the exact width types are required (except 64 bit width, which is only required if the implementation supports an exact 64 bit width data type). 
&gt; The type 'char' is always one signed byte Afraid not. 'char' can be either signed or unsigned, it's not specified by the standard. Most compilers allow you to choose; for example see -fsigned-char and -funsigned-char [GCC options](https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html). Be explicit and use 'signed char' or 'unsigned char' (or int8_t/uint8_t). And the width of 'char' may not be a byte. It is at least 8 bits wide, but may be more. The only thing we know for sure is that *sizeof(char) == 1*, *sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long)*, and the minimum widths: 8 bits for char, 16 for short and int, and 32 bits for long. I have used a 16-bit DSP where the minimum addressable memory width was 16 bits. On that platform, *sizeof(char) == sizeof(short) == sizeof(int) == 1* (16 bits) and *sizeof(long)==2* (32 bits). A little unusual, but perfectly legal by the standard. 
&gt; Replacing strcpy, scanf by safer conterparties such as strncpy Beware, [**strncpy is not a safer counterpart**](https://randomascii.wordpress.com/2013/04/03/stop-using-strncpy-already/). It's even less safe because it doesn't NUL-terminate reliably. And speaking of strcpy, it's involved in a bug in line 75: new-&gt;text = calloc(strlen(text), sizeof(char)); // ... strcpy(new-&gt;text, text); 
Just use an `int` for your error code return types. That's the convention people expect and its guaranteed to be at least 16-bits. Going with something smaller won't make your program run any faster or use less memory. Using something unusual like `uint8_t` for this purpose is just confusing. 
Great code. Just a few comments: * On line 77: Remember that the or operator is evaluated from left to right so `(!new-&gt;text || !new)` will evaluate `new-&gt;text` before testing if `new` is `NULL`. * Consider what should be done if memory allocation fails. `malloc()` actually failing is a very unusual occurrence with modern hardware and operating systems and in most cases it means the program will not work at all. Typically I `assert()` that memory allocation works so my code fails quickly and in a way that allows me to debug it. record *new = calloc(1, sizeof(record)); assert(new != NULL); new-&gt;text = calloc(strlen(text), sizeof(char)); assert(new-&gt;text != NULL); * You could allocate your record node *and* its contents in one command if you declared `text` as a zero length array like: struct record { struct record *next; char text[0]; } Then allocate it with something like: struct record *new = malloc(sizeof (*new) + strlen(text) + 1); * Iterating over your linked list is probably better done with `for` than `while`. `while` forces you to split up temporary variable declaration &amp; initialization, continuation condition, and increment across multiple lines. `for()` would allow you to do it all on one line -- I think this is much more readable: if (header != NULL) printf("Category %s\n", header-&gt;text); int i = 1; for (struct record *cur = header-&gt;next; *cur != NULL; cur = cur-&gt;next) printf("Item %d: %s\n", i++, cur-&gt;text); I could go on but most of my other nitpicks have already been mentioned in this thread.
A safe function is OpenBSD's `strlcpy` but because a certain Mr. Drepper decided to be a dick-head, it isn't included in the Linux libc.
thats the point. I'm modifying the string, not making a copy of it. 
Well, you're not modifying anything, either. How can `source[i] = source[i];` possibly modify anything?
why do i need to pass a pointer to a pointer? I dont plan on using a copy, just modifying the string itself. EDIT: the approach is to iterate over the string, and copying the contents. When it reaches the index, it will skip and fill the index with the next character. 
Do you understand the approach I'm taking for this problem?
Fixed. And in the `if` condition, change `i != index` to `i &gt; index`, because you don't need to copy a string into itself when it's exactly the same (and before `index` it's exactly the same).
I get your point, but I'm trying to make it as less complicated as possible. I may change it though. Thats for the tips. Ill be sure to note against the use of string literals. The function however is a helper for another function that modifies string arrays. So its not a big thing.
But that looks very cryptic, which is what I'm trying to minimize. 
It's not cryptic at all. Put comments in if you don't understand it. You don't need to do anything before the character you want to skip. What's the point of copying the same character over top of itself? It's a waste of CPU cycles. if s is not null and the passed index is less than the length of the string while s[ l ] is not the nul character, walk through the string copy the next character over top of this one That's all there is to it.
How did you setup tmux? Could you share your config/startup script for it? I'd really like to get that setup for my friend and I.
You effectively do. You should spend less time calling people buddy and being argumentative and *listen* more carefully.
Your capacity to listen and your certainty are going to be two huge drag for your computing career...
line 14 should come after line 11, otherwise the original string is unmodified: if (i != index) { *scopy = source[i]; scopy++; } 
d is converted to a size_t in the expression `d &lt;= (TOTAL_ELEMENTS-2)`, and the expression evaluates falsely when `d == -1`. Two issues here. The - in OS_HP-UX_print is not a valid character for an identifier, and there is an execution path where num is referenced when it is uninitialised (in such a scenario the return value of scanf is less than 1). If &lt;stdio.h&gt; were included, it would be 1. continue jumps to the tail of the do statement. stdout is probably fully-buffered or line-buffered. `#a` takes a literally, `g(a)` expands g and a. default is mis-spelled, if it were spelled correctly, either of the three cases could be triggered depending upon the charset. With ASCII, it should print NONE. If &lt;stdlib.h&gt; were included, it may fail if malloc returns a null pointer. Might skip this one. Might be 1.0, might not be 1.0. Should compare within an interval. , is used as a separator for initialiser values in that context. Yes. 4321 It's Duff's vibrator\b\b\b\b\b\b\b\bdevice and it's trying to accomplish premature ejaculation\b\b\b\b\b\b\b\b\b\b\boptimisation! ;-) I'd just test it like this. #include &lt;assert.h&gt; ... unsigned i; for (i = 0; i &lt; UINT_MAX-1; i++) assert(count_bits_correct(i) == CountBits(i)); assert(count_bits_correct(UINT_MAX) == CountBits(UINT_MAX)); The first function has zero parameters and the second has an unspecified number of parameters. Both calls to printf have undefined behaviour. Any output or no output, will do. There's no attempt to produce output and an `int *` isn't an `int[80]`. b's uninitalised. This has the same problem as the first call to printf three questions ago. Instead of printf pretending a double is an int, it pretends a size_t is an int. In any case, sizeof arr == sizeof (int *). --- Might try more later. There's some good puzzles, but I'm sure I'm seeing more issues with the code than the author. I've liked the first one the most so far, it took me a while to think of the answer. Here's one I thought of: unsigned short a = 5; unsigned long c = 8; What is the type of `a &lt;&lt; c`? There's two possibilities. :-) 
C is an awesome language. If there had been no C, there wouldn't have existed C++, Java, C# and all other "MODERN" languages.. As for what can be created in C, there is a simple example like this http://www.wincodebits.in/2015/04/library-management-system.html
C11, of course. Though the changes aren't huge compared to 89, there's some very useful new stuff.
Do you have any book recommendations for that? I have prior C++ experience so I'll be fine even if it's not an 'absolute' beginner's book. Also, just how many of today's open source projects are in C11 compared to the other previous standards? Will learning C11 make me unable to understand older code? 
I'll add to this by saying that the oldest standard is invariably the most widely used and supported. Learn C89, then learn C99 _and_ C11. C isn't an overly expansive language, and the standard library is relatively simple. You'll benefit from being able to write C that's compatible with every compiler, as well as taking advantage of newer features when they're available.
I'd check out Learn C the Hard Way and 21st Century C. 
Wtf? Who downvoted you? This advice is exactly correct
Not OP, but I appreciate this advice. I'm going to save this post for reference, just in case I forget.
I recommend [C Primer Plus](http://www.amazon.com/C-Primer-Plus-Developers-Library/dp/0321928423/ref=pd_cp_14_3?ie=UTF8&amp;refRID=1B2PP2QEE7BX52P9CM68). It gives a overview of ANSI C/C99/C11 and its differences. Sometimes a bit wordy but at the end you will have enough working knowledge to work through any C code. If you're on windows don't use the MSVC as its support for C is severly lacking. Use [Pelles C](http://www.smorgasbordet.com/pellesc/) instead (most [C11](https://en.wikipedia.org/wiki/C11_%28C_standard_revision%29) compatible compiler afaik but haven't had any problems with the gcc port so far either). C11 doesn't fundamentally change the language so don't worry about it. Although I'm a bit sad that we won't see threads.h in glibc supported for another 10 years probably (guess because it's optional..). Also [C A reference Manual](http://www.amazon.com/Reference-Manual-Samuel-P-Harbison/dp/013089592X/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1435497107&amp;sr=1-1&amp;keywords=c+a+reference+manual)(C99) is a great book after you got the basics down but not necessary. 
 **C Primer Plus (6th Edition) (Developer's Library)** |||| --:|:--|:-- Current|$44.61|Amazon (New) High|$46.34|Amazon (New) Low|$38.44|Amazon (New) ||$44.79|(30 Day Average) [Price History Chart and Sales Rank](http://i.imgur.com/nhMPSm7.png) **C: A Reference Manual (5th Edition)** |||| --:|:--|:-- Current|$44.96|Amazon (New) High|$48.92|Amazon (New) Low|$35.48|Amazon (New) ||$45.38|(30 Day Average) [Price History Chart and Sales Rank](http://i.imgur.com/s2lmDxQ.png) | [FAQ](http://www.reddit.com/r/PriceZombie/wiki/index) 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**C11 (C standard revision)**](https://en.wikipedia.org/wiki/C11%20%28C%20standard%20revision%29): [](#sfw) --- &gt;__C11__ (formerly __C1X__) is an informal name for ___ISO/IEC 9899:2011___, the current [standard](https://en.wikipedia.org/wiki/Open_standard) for the [C programming language](https://en.wikipedia.org/wiki/C_(programming_language\)). It replaces the previous C standard, informally known as [C99](https://en.wikipedia.org/wiki/C99). This new version mainly standardizes features that have already been supported by common contemporary compilers, and includes a detailed memory model to better support multiple [threads](https://en.wikipedia.org/wiki/Thread_(computer_science\)) of execution. Due to delayed availability of conforming C99 implementations, C11 makes certain features optional, to make it easier to comply with the core language standard. &gt; --- ^Relevant: [^C ^\(programming ^language)](https://en.wikipedia.org/wiki/C_\(programming_language\)) ^| [^C++ ^Technical ^Report ^1](https://en.wikipedia.org/wiki/C%2B%2B_Technical_Report_1) ^| [^ANSI ^C](https://en.wikipedia.org/wiki/ANSI_C) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cslddag) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cslddag)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](/r/autowikibot/wiki/index) ^| [^Mods](/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Call ^Me](/r/autowikibot/comments/1ux484/ask_wikibot/)
Here is how I'd do it: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; char * rcn(char *s, size_t len, size_t i) { for (char *dst = s, *src = s, *skip = s + i, *end = s + len + 1; src != end; src++) if (src != skip) *dst++ = *src; return s; } int main(int argc, char *argv[]) { char *t = strdup("THIS IS A TEST!"); printf("%s\n", rcn(t,strlen(t), 10)); } 
8-month C beginner here. There are less differences between standards than you would think. C99 mostly added some conveniences, and C11 added some more advanced modern things for multi-threading. Just learn any version of C (K&amp;R was written before C89, and tons of people learned/are learning from it), and be sure to be aware of the differences later on. You can easily list all the differences on a single piece of paper, so it isn't a big deal which you learn from.
Concur. It depends on your programming environment, but in my case, doing C programming for the U.S. Navy, the code I maintain has to work on HP-UX, Solaris, Linux, Windows, and (on thankfully, *thankfully* rare occasions, and for a loose meaning of "work") *VMS* (curses be upon it). Old versions of the operating systems, running old versions of the compilers. I look upon the cool new C features and weep, then go back to coding to C89 and finding out the hard way what features are supported in common as compiler extensions.
this book is pretty good but it's work in progress http://icube-icps.unistra.fr/img_auth.php/d/db/ModernC.pdf
No, not really. The "C convention" is to remove as many letters as possible from names, giving us `atoi`, `strcpy`, and `tmpnam`, as well as Unix system calls like `creat` and `fcntl`. Now, you're probably right that many pieces of software written in C use snake case as their naming convention. But others don't. (X11, OpenGL, MS Windows, just to name a few off the top of my head) Moreover, *I don't care*. You will never hear me say, "This naming convention is total crap, but thank goodness they used snake case instead of camel case [or vice versa]." It's just not an important issue.
I can see both sides of the argument. In C, you could use the same logic to insist on verb-noun. In order to keep a large API sensible, you wouldn't have a function like `apiMoveLeg`; you'd have `apiPersonMoveLeg`, since a `Leg` belongs to a `Person`, and you're operating on the `Person` object rather than the `Leg` itself. So with the noun-verb convention, it gets kind of messy because all of your nouns get stacked together at the front: `apiPersonLegMove`. (And I admit, that can be a downside, especially if your nouns nest very deeply.) But I stand by my original argument. I really don't care how it sounds if I read it aloud as English. When I'm coding, whether it's C or C++ or Java, I'm using an IDE with autocompletion. If I start typing `apiPerson` (maybe followed by a `.` in C++ or Java), I'll get a list of autocompletions that start with `leg` or `arm`. Since I know I want to operate on a Leg, I type `leg` and then I get autocompletions that I can look through for an appropriate verb. With the verb-noun strategy, *I have to know the verb I need*. "Hmm, I know it's not `get`... is it `move`, or `lift`, or `step`? Maybe it's `move`. Oh geez, there are a hundred possible things I could `move` on a `Person`! I still have to scroll through this whole list to find out if this was the right verb." It's ludicrous, right?
I guess [n1570.pdf](http://www.compsci.hunter.cuny.edu/~sweiss/resources/c11standard.pdf) ends up next to you. just kidding. :)
As long as it's consistent!
Ah, my bad
5.1 has been available for a while. Did TDM just get around to building it?
If you're interested in getting stronger type checking from C, you can always wrap your types in single-member structs. It's implementation-defined whether this will add any padding to the end of the type's representation, but the standard guarantees that you can cast a pointer to a struct to a pointer to its first member, so there will never be padding at the front. It's definitely a bit more syntax-heavy to deal with structs instead of plain scalar values, but it shouldn't add any computational overhead aside from possibly padding.
For those that work on embedded systems such as PIC, Arduino, AVR, etc. Can you get away with doing C99? I know for 8051 the Kiel C compiler remains restricted to C89/ANSI. For some reason Visual C++ will never support C99 fully, so the [safest choice still seems to be C89.](http://herbsutter.com/2012/05/03/reader-qa-what-about-vc-and-c99/) 
Google "Learn C the Hard Way" by Zed Shaw. It's is available now as a free web book.
The biggest mental change for me was to stop generalizing and thinking in objects. In hindsight that was counterproductive for C++ as well, but with a smaller penalty. Write your code in such a way that it only does what you need it to do, and nothing more. Don't try to be clever, anticipate different types or future change. Good old KISS principle. The Book that gets most recommended here after [K&amp;R](https://en.wikipedia.org/wiki/The_C_Programming_Language) is [21st Century C](http://shop.oreilly.com/product/0636920033677.do). 
I don't know. Many C textbooks contain many small errors that make clear that the author has little clue about programming in C.
And why not fail early (in case the pointer is only copied into a data-structure) and `assert` that your input parameters are correct.
You might want to review the APIs of some popular C libraries to pick up on common idioms: - zlib - libjpeg - libpng - libcurl These might not necessarily represent the height of good design, but they do represent the height of success, in that they have all been adopted very widely and are used by thousands of projects.
What's wrong with error-checking? It's good defensive programming. It avoids future headaches and lets your program keep running in the face of mistakes or faults or runtime out-of-memory conditions. There's already a standard error value, EINVAL, for invalid parameters.
If you're going to write C, you should at least understand WHY the errno stuff is such a shitbag of fail, rather than trying to emulate C++, which was my point.
Haven't read it, but I have yet to find a single book that describes building a properly organized and modular software system in C. The language is too old, and has given rise to too many different viable solutions to the same problems.
IAR Workbench supports C89, C99, C11, some awesome C-extensions, and Embedded C++. If I had to do embedded programming in any other environment than IAR's software I'd quit my job and work elsewhere.
If a person passes a NULL pointer to a function (where that function absolutely required a non-NULL parameter), there's generally nothing that can be done. You don't want your program to "keep running in the face of mistakes", you want it to *stop*. In most cases the most elegant thing your program would be able to do is spit out a user-friendly error message before blowing up, but either way you want it to blow up. Not to mention that there's no way to determine whether any given pointer is valid anyway, so checking whether input pointers are NULL is a partial solution at best, and nothing that offers anything close to a degree of safety. Look at it this way: let's say you've got a function like this: void foo(double *d) { .... *d .... } So we dereference `d` at some point. Then, on a typical modern machine, there is some value of `d` that can be passed in that will trigger undefined behavior. You can throw in a NULL check up at the top and return an error code if you want, but I still have billions of choices of `d` that will trigger UB, and you can't detect all of them. So at the *end of the day*, this function will have to be documented with "if `d` is not a valid pointer to double, there is undefined behavior", and so what did your NULL check really accomplish?
I'm sorry for the somewhat late reply. We use the default configuration that comes with the latest ubuntu LTS. We both just fire up tmux attach (or -d if we want to irritate the other guy :D) and are ready to go. For us it works fine out-of-the-box like that. One thing I want to look into is setting up a config that will start with a few windows and give them proper names, but given that downtime is a very rare thing on this VPS and I'm lazy... ;).
Thanks for replying. Same error. Assert does not fail.
You're right, but you're also so so wrong. Yes, proving program correctness at runtime is impossible, and protecting against malicious attacks is even more impossible. Someone could pass in a pointer that's non-null but isn't valid (points to unmapped memory, isn't suitably aligned, etc.), either by mistake, or by hardware error (flipped bit in memory), or maliciously, and there's nothing you can do to detect it before it crashes. But those aren't the flaws or attacks I'm worried about. I'm worried about "what happens when the user of my library allocates something, doesn't check if the allocation succeeded, and calls my function with that null pointer". Or any other kind of null pointer mistake, like freeing something (and setting the pointer to null, which helps with debugging *exactly this kind of thing*!) and later mistakenly trying to operate on it. &gt; You don't want your program to "keep running in the face of mistakes", you want it to stop. No, I don't want it to stop! I develop for embedded hardware. We don't have the ability to recover from a null pointer. Our only recourse is to reboot the whole system. Our software gets used in emergency telephones, among other things. Is *this* what you want your emergency telephone to do when it doesn't have enough memory to establish a connection to a redundant server? Or would you rather it run a bunch of functions that indicate that a NULL pointer ended up somewhere it wasn't expected, return an error, and continue operating? Your definition of "blow up" is a lot more extreme than mine. An assert and some logging is fine. Crashing the entire task or system is not.
C is just as useful now as it was before. The more important question to ask probably is when C is profitable to use.
Ok, where do you think C is more profitable for use?
Anything embedded, driver, firmware, or robotics based. Basically, when you're down at the hardware-software interface, it's still the only game in town (except assembly).
It's still useful for everything it was when it was first standardized in 1989. It is, however, particularly useful for low level coding, resource constrained environments, performance critical applications, and the like.
Another idea is to make a malloc macro, e.g. #define MALLOC(ptr, N) do { if ( !((ptr) = malloc((N) * sizeof *(ptr))) ) fprintf(stderr, "malloc failure\n"); exit(EXIT_FAILURE); } while (0) 
Anything that needs performance. When youre developing something which is performance critical (such as anything to do with an OS or embedded system), ease of development almost goes out the window. It becomes all about performance, and C is the closest you can realistically get to assembly language. Look at literally anything which is performance critical, and you will probably see C doing most of the work. However, for application programming, I dont think you should pick C.
Damn, now I just want to and program in C all night.
A pointer can point to a region of memory that is read-only. This will allow you to read the pointer and null-check it, but when you try and write to it... bam! I have no idea how this is happening to you, but if you can null-check it and then get a segfault when writing, it's in read-only memory somehow. If you can run the program under gdb, you might be able to use gdb's "info address" command to see what segment the variable is in. [You want it to be in .data or .bss](http://stackoverflow.com/questions/1909953/regarding-the-bss-segment-and-data-segment-in-unix), if it's in .text that's read-only memory.
Our company's product has at its core a huge amount of scientific code to do graph analyses of various types - that code is implemented as C modules to build and access purpose-made data structures, and exposed via ruby ffi for testing purposes.
C.. - is a small language, you can understand nearly its entire syntax in a short period of time - it generates small, efficient executables - it's the measuring stick for application performance - it's portable, you can compile standard C code on nearly any platform - the code generated from it is predictable and easy to optimize - it has one of the most canonical ABIs, and many higher level languages include it as part of their foreign function interface So basically, for embedded projects it makes a lot of sense. If you need absolute speed, it's a good choice. And if you want to write code, compile it once, and use it in Python, Java, D, C++, Rust, Haskell, Erlang, Ruby, Crystal, Matlab, etc, etc etc... then it's your only choice.
Why isnt C useful for application programming?
microcontrollers
Many features which aren't in C (object orientation, good, easy to use GUI libraries, inheritance etc.) are invaluable for application programming.
C is kind of a "Do it yourself" language. It does not have a library the size of Java's, or C#'s or really any modern language. It does not abstract you from the innards like higher languages do, so you'll find that you often have to reinvent the wheel to do simple things which is natively supported in newer languages. This is extremely tedious when all you want to do is create a simple, performance uncritical app quickly. Using C it may take months, whereas using a language like Java, it may take just a couple of weeks. Just a quick example, in C there is no String class. Imagine trying to write all your code using character arrays, it will get annoying quickly if all you want to do is quickly push out some mobile app.
You hit the nail so squarely on the head my friend.
Nice in-depth comment! &gt; enforcement of invariants that I cannot guarantee while the program is still in development (mostly Rust, Go to some extend) I'm not sure exactly what you mean. Can you elaborate/give an example?
Go with C++. Threading in C is going to have very little real life use. 
pthread (and C11 thread) are different things from libuv. While libuv supports using threads too, that isn't what it is about. However, for standard C threads, you can read some [here](http://en.cppreference.com/w/c/thread).
Pthreads for concurrency, OpenMP for parallelism.
It's excellent for writing the compilers and interpreters for all those higher level languages :-)
Except, you know, everything that C++ does ...
Internet of Things is a lot of full computers and less microcontrollers tho. Things like the raspberry pi that can run python or mono or java.
Yeah I've never learnt C++ and I don't intend to. But if you're working in the applications field (especially on the Microsoft ecosystem) I can imagine it would be unavoidable.
That's not enough. You usually want to use a sequence like this: long value; int errno_backup; char *endptr; errno_backup = errno; errno = 0; value = strtol(ptr, &amp;endptr, 10); if (errno || *ptr == '\0' || *endptr != '\0') /* error condition here */ errno = errno_backup;
Some BSD functions like `strlcpy` or the `err` family of functions would be nice. A way to access the argument vector outside of `main` would be nice. A set of functions that can do arithmetic with overflow detection would be quite useful. 
Just as PHP is unavoidable when you are developing web services.
I disagree. Someone has to write and maintain all of those 802.15.4 radio stacks and TCP/IP stacks. 
Never better. Sign up for Jack Ganssle's "The Embedded Muse" - http://www.ganssle.com/tem-subunsub.html He is always expounding on the state of the industry. I think embedded will continue to grow. The eight bit CPU is slowly going away, but it's being replaced by Cortex CPUs that are crazy powerful and equally interesting to work on. 
An snprintf that returns something logical. Returning how long the string would be if it hadn't been truncated is rarely helpful.
The raspberry pi is what, 50 bucks? I can get an embedded CPU for less than a dollar. There's no comparison between the two. Everything you own has tons of CPUs in it. How many do you think are in your phone? Your car? Your iWatchAMaThingy? How many CPUs do you think are in your shoes, blinking the lights in just the right way? The truth is embedded is everywhere. Not every product needs a raspberry pi. Some things need a CPU that can sleep 99.99% of the time while sipping energy. We're down to the nano amp range. That's insane. Try that with your Pi! :) I see connected devices growing. There will be gateways. Those will be the Pis or equivalent. The devices themselves will be much lower power, sipping energy and just waking up when they need to, doing what needs to be done, and going right back to sleep. 
Actually, most compilers are "bootstrapped" and written in their own languages these days. 
Jobs will be plenty. However I see languages used change. When I started we did 8051 and assembly. Then c,c++. Now I see embedded products using javascript in embedded browsers. However, i'm now in the high-spec embedded marked, think of dual core 1Ghz MIPS with 512+MB RAM. 
&gt; Sign up for Jack Ganssle's "The Embedded Muse" - http://www.ganssle.com/tem-subunsub.html Already subbed. :) I enjoy it very much. It's just that lately more layers of abstraction seem to be added and I'm not yet bored with working with barebones systems. :P
Truly portable apps are not hard to write at all given that your target platforms are well-defined so you can define a hardware/os abstraction layer. Planning and knowledge about your target platform is absolutely critical, but hard? Not really. I've written embedded software this way for a number of years, which ran on m86k, ARM (various versions), 386 embedded, MIPS on a number of different proprietary OS's - or even bare-metal. We were also able to run this software on Linux and Windows too which made debugging a LOT easier, and added the ability to mock various peripherals like magstripe and chipcard readers, thermal printers, serial communication, modems, ... Porting to a new platform could in best case scenario's (read: stable, capable and well documented platform) be done in a week, in a state that it could be sent off to our tester. Worst case we had was 7 months, mostly due to buggy libraries, incorrect or missing documentation, buggy hardware and a buggy C compiler. For stuff like that, C is a clear winner. C++ would have been impossible to use, since a lot of these platforms didn't even have a C++ compiler - and the ones who did were pretty horrible.
If you want to learn multi-threaded programming, the native threading system for your platform is the best place to start. Threads, like processes and file handles, are part of your operating system, and that's the best way to learn them. This is the beauty of using C -- you can interact with your OS and hardware without adulteration. So learn pthreads if your on a POSIX operating system like Linux. Learn the Windows threading APIs if you're on windows. Then after you understand what threads are and how they affect your system, then you can worry about introducing abstractions like OpenMP and libuv. 
Why would pthreads not be for parallelism? OpenMP creates and uses pthreads for you.
PThreads is for parallelism. They are to openMP what assembly is to C. They form the base of most threading implementations. I would personally recommend you learn both, like everything abstracted, the base will give you better control, the abstraction will be easier to write.
Valid point. My embedded days are behind me, but the last 'embedded' system they asked me to write software on was a 433Mhz ARM with 64Mb RAM and 1Gb of flash running Linux - which didn't really feel embedded anymore. They even considered writing it in Python... But these days, you would be stupid not to pick some dirt-cheap ARM on which you can run a full-blown modern OS instead of proprietary unstable crap - performance is cheap these days. The contrast with even only 10 years ago however is amazing. No more having to hand-optimize a CRC32 algorithm in M86k ASM without using tables, making sure it all fits in 128kb for code+data+ram.
in the "olden days" when you were supposed to do the buffer size checking up front the pattern was something like p = buff; p += sprintf(blah...); p += sprintf(blah2...); etc. Now that sprintf is *bad*, using snprintf is a lot more clunky. 
That hadn't occurred to me, I sez sheepishly. That's a good answer.
But as the OP was asking -- its not suitable for "learning multithreading". I agree, its a fine shortcut if you are just striding through arrays.
The same thing it's always been useful for: OS development.
The majority of IoT devices will be microcontrollers. Few will use processors as large as those on the Pi or cell phone.
&gt;Actually, most compilers are "bootstrapped" and written in their own languages these days. Citation?
&gt;due to leaps in hardware, computation has evolved much beyond the world C was invented in, This kind of "just throw a bigger processor/system at the problem" thinking need to die in a fire.
If you don't *care* if there are additional non-numeric characters after the parsed integer, then you can pass NULL as the endptr. Of course, you typically will want to check, since this is also how you can find out if parsing stopped earlier than you expected. Also, you often don't give a rip what errno used to be, so you can also skip saving the old value. I'm not clear on why you're treating `*ptr == '\0'` as an error, either. If you're checking for "no digits found" I'd use `ptr == endptr`. Of course, that's often not an error, per se. Your code apears to expect the whole string is just a decimal integer to parse (with possible leading spaces). Finally, if you really wanted to make it look bad, you could have also specifically checked for underflow &amp; overflow. 
Dramatic much? Sure, worst case it can be 10-12 lines of error checking, but a) it's seldom worst case, and b) that's still at most 1/2 page, assuming you define "page" as 80x24. If I need to do a crapton of simple numeric parsing, and the error handling is going to be the same for most or all of it, and I need more than just the simplest error checking, I'll typically encapsulate that logic in a function. I'm not sure if there's a version of that function that would be both simpler than the current functions while still being worth standardizing. Maybe. If so, I'm still not sure the added convenience would be worth the cost of expanding the surface area of the standard library with overlapping functionality. 
In the case where you have actually checked the buffer size will fit the produced string, there's no reason not to use `sprintf`. The same can be said of `strcat`. Or heck, even the "evil" `strcpy` -- though if you've already done the size checking you already know how big the "from" string is, so I suggest using `memcpy` or `memmove` instead. However, the most generic and reliable way to check the buffer size is to do the conversion, which is *why* `snprintf` works the way it does. Personally, I think the check/allocate/convert idiom is fairly elegant, really. Again, if you are *sure* (i.e., have proved, not just "know") that the produced string will fit in your buffer, you don't need to care about the return value. But ... **are** you sure? *Really*?
Using pthreads for concurrency is like using a tank as a bulldozer. It doesn't scale well either. Libuv gives you concurrency, albeit a spaghetti interface.
Err you need `&amp;p` to not point to the string you are reading from. This is more complete: char *end; errno = 0; value = strtol(p, &amp;end, 0); if (errno != 0 || *end != '\0' || end == str) { /* error */ } However it gets more complicated if you actually want to say what went wrong in logs or error messages. Edit: also much more annoying if the implementation does not return error in the case that no digits were seen and 0 was returned, which is allowed. Edit2: lets not forget this golden piece of shit for strtoul(l): &gt;Negative values are considered valid input and are silently converted to the equivalent unsigned long int value.
&gt; the integer was not within the desired range ERANGE
That doesn't really say much. You can tweak all kinds of settings to affect the size of the output. C++ was originally just a preprocessor / wrapper trick around C, after all.
Minor nits to pick: &gt; * it generates small, efficient executables Efficient perhaps, but no longer small on modern compilers targeting non-embedded systems. Statically linked "Hello world" is around 400k. &gt; * it's portable, you can compile standard C code on nearly any platform Syntax, yes. Library, only if you exclude Windows from "any platform". 
I am familiar with that article. It doesn't change the fact that you _CAN_ use C++ to create "small" executables in some cases. Sometimes, C++ is a better fit for the application and will result in better code. Sometimes it's not. A trivial example is pointless for comparing the two. I use C almost exclusively. I'm an embedded developer with over 10 years experience. I almost never use C++ and frankly am not very fond of it, but that doesn't mean that it has to be huge and bloated. You can write good or bad code in any language. You can write slow, bloated code in any language. Don't throw out a tool just because of a useless, trivial test case like that. Even MISRA has a subset of C++ that's considered safe. I'd take their word over yours that C++ applications can be used in an embedded space, even if it's not my first preference. 
Assuming I could change it without breaking things: * Eliminate the abomination that is `errno`. * Eliminate unnecessary global state by replacing those functions that have it (`strtok` vs `strtok_r`, `localtime` vs `localtime_r`, etc). * Add a `void *` context argument to functions that take function pointers (e.g. `qsort_r`), since these often otherwise require global state. * Add a function for getting a small quantity of high-quality entropy from the system for seeding purposes. This would probably be optional since some platforms (freestanding, embedded) couldn't support it. * Rename `FILE` to something more appropriate, like `stream_t`. * Add Glibc's `x` (exclusive) extension to `fopen()` * Semaphores in stdatomic.h. * Add a countof() macro. 
&gt; If you want that to be an error, you can just check for the leading '-'. So I have to partially re-parse the string myself in order to know whether it was valid? No thanks.
Provide a chunked buffer interface for string building functions.
&gt; `strlcpy` Why is this not already?
It's not in the glibc because drepper thinks it's a bad function (namely, because it âencouragesâ sloppy programming). I don't know enough about the standard comitee to know what their reason is.
Ah yes, Drepper.
Thanks for the reply. I think the essence of what you're talking about is languages treating warnings like errors (because you're an idiot, and can't be trusted with your own code). On the flip side, I wouldn't be the first to point out that C's attitude is more "here's a loaded gun, I'm sure you know how to handle it", but finding a happy medium is tricky.
Is your problem that you need to know if the user entered some junk at the end of the string, after the number? If so, you can tell scanf to read a string after your double by giving it %2s in the same format string, and then examine the return value and contents of the string buffer afterwards. 
thank you. I solved the problem by doing what OldWolf2 advised but it's good to know what I was doing wrong. 
To be fair that was 8 years ago
there is no code. I just have an idea of what it should do.
The way scanf() works, if the user entered "123c,456", scanf() will stick 123 in your double. So you need to be able to figure out if there was junk at the end past the "123". 
thanks, a user pointed me to strchr and this is kind of what i was looking for, but thank you for all the asking.
I don't consider non-numeric characters after a number an error in some cases (and you're doing it wrong, it should be "**endptr != '\0'"). For instance, I might allow suffixes to modify the value of the number, like "34d" for 34 days, or "8k" for 8,192. Again for the case of the empty string---not all cases are in error and it really depends upon the program. About the saving of errno---eh. I personally haven't come across code that relies upon functions leaving errno as 0 and in some cases, I liberally set errno to 0 with no problem.
strncpy which guarantees a null at the end. 
You want something other than `strncpy`, then -- it works exactly as designed. It's really unfortunate that they chose to name it that, since it's really not intended to be a general purpose string copy function at all, rather it's for copying a sequence of characters into a fixed size buffer.
This except for Sublime Text (I'm on Windows).
You can check http://www.codeblocks.org. Create a project using the wizards, edit your code and hit run, quite simple.
nope, didn't work 
This is what I use. Vim is not for beginners though. Beginners should be able to handle simple makefiles. 
Code::Blocks is great for beginners! I recommend it all the time
I use whatever compiler is available on the target system and preferably `ed(1)` for my editor.
 double scanfNUMBER(char* szLU, void* av) ... iErg=scanf(szLU,av); You can't scan into a void pointer because it has no idea what type you are trying to make it be. Compile with warnings on. Also, scanf doesn't return a double, so why are you assigning its return value to a double? I mean I guess you can, but why would you? Why are you recursively calling scanfNUMBER? 
I'm concerned that many will end up "knowing" C without ever understanding what 'linking' means or how '#include' works because the IDE abstracted everything away.
Netbeans: it has grown up a lot the last few years and it even has some neat features that I cannot find in Visual Studio. Eclipse was just not my cup of tea. I also use emacs sometimes.
ed is neat (it's everywhere and no suprises!) but i don't know if you're serious or not. 
I found Code::blocks to be good when I started with C++. It worked on Windows which was good too. (I think it uses Mingw).
This is the best explanation I found so far for how those concepts are different: &gt; In many fields, the words parallel and concurrent are synonyms; not so in programming, where they are used to describe fundamentally different concepts. &gt; &gt;A parallel program is one that uses a multiplicity of computational hardware (e.g., several processor cores) to perform a computation more quickly. The aim is to arrive at the answer earlier, by delegating different parts of the computation to different processors that execute at the same time. &gt; &gt;By contrast, concurrency is a program-structuring technique in which there are multiple threads of control. Conceptually, the threads of control execute âat the same timeâ; that is, the user sees their effects interleaved. Whether they actually execute at the same time or not is an implementation detail; a concurrent program can execute on a single processor through interleaved execution or on multiple physical processors. from the introduction of Simon Marlow, *Parallel and Concurrent Programming in Haskell*
Notepad++/kwrite
I'm a fairly heavy Python user having written C extensions. Was thinking of diving into Haskell (for the 3rd time), but I just can't think of why I would ever want to write production software in it. Don't get me wrong, I've coded in esoteric languages such as Ada because I wanted to ensure robust, resilient software, but I just find myself gravitating back to C, Python. I just haven't found that middle ground because C++ makes me want to vomit.
gvim baby :)
neovim + unix
Vim + Clang + Cmake
Mustard race. 
Not an IDE, actually. Geany (I don't use its IDE-ish features tbh), make files, clang and/or gcc.
&gt; I don't consider non-numeric characters after a number an error in some cases. For instance, I might allow suffixes to modify the value of the number, like "34d" for 34 days, or "8k" for 8,192. Well, it depends on what you're parsing. If you're parsing a network protocol, you probably want to insist that numbers consist of only numbers like the protocol says they should, so that you can raise a parse error otherwise. But since `strtol` is so basic, you have to write your own checks for this, which amounts to partially re-parsing the string yourself every time. It's only a marginal improvement over `atoi`. &gt; and you're doing it wrong, it should be `**endptr != '\0'` Check again. In this scope, it's declared as `char *endptr`, and was passed to `strtol` as `&amp;endptr`.
I mostly use the [Open Watcom compiler](https://github.com/open-watcom/open-watcom-v2) for work on either Windows or Linux. I do use the OW IDE on Windows, but only to control compilation and debugging (the included editor is atrocious). For an editor/IDE, I use [Simply Fortran](http://simplyfortran.com/) on Windows or under WINE on Linux because, well, I'm the primary developer of said software.
Ahh yissss
I don't want to start any debate or argument so please try to avoid that...but...is there any advantage of using editors like Vim and Emacs any more these days? I have used Vim, but I found Sublime Text to be a lot more productive, 'cause of the mouse and better handling of text than the terminal does. I just found ST3 to be a more pleasant and productive editor, and while Vim wasn't that far behind, and I didn't dive deep, I don't understand why somebody would prefer it.
Apparently they are. That was earlier this year, by the way. A couple of our assignments involved familiarizing ourselves with it, gcc, and gdb. Most of the programming assignments were C/C++. The others were very basic assembly for Computer Organization.
gedit on desktop, vi(m) on-the-go CLI to compile In Windows I use MSVC6 or notepad Classic MacOS I use Textedit and MPW
That sounds good actually. My right hand has worse problems than my left...and I use mouse with right. I get ya. I should probably use mouse a lot less then...health above all right!
Atom, a highly featured editor, recently released a 1.0 release, and they have some very usable clang plugins (autocomplete and lint). Makefiles do work fine, but I think a bit of automation on top of them, like AutoConf or CMake, is a good idea. 
to restart it. bad idea for several reasons, how would you do it? code example pls 
&gt; Any recommendation how to begin? First, try to understand what the relevant parts of the code exactly do.
Having at least a vague idea of what you are supposed to do is a good start. Telling us "I need to update a program" could mean literally anything. Look through the requirements you were presumably given, evaluate potential distinct steps for the/each goal, develop an order to then implement those steps. Basic problem solving process. 
Thanks for all your help everybody. :) 
Vim, Make and GCC. Should probably switch to CLANG at some point. 
The best IDE for c programming would be... Any unix-like operating system. 
Everything you listed here can be done with modern compilers anyway. You need C89 standard? Just compile with --std=C89 and it will reject anything related to later standards. clang produces far far superior diagnostic messages than any other compiler which I think is absolutely necessary for a person who is learning C programming. 
back everything up before doing anything.
http://codingfox.com/1-9-how-to-configure-gcc-in-notepad-for-c11/
Your problem is already solved but I'd like to add that learning how to use a debugger is very useful. Assuming you use gcc or clang, here's a gdb tutorial: http://www.unknownroad.com/rtfm/gdbtut/
That certainly would be more unixy ls
Partially. I use `ed(1)` pretty often as it's usually one of the few predictable editors on weird systems plus it doesn't annoy me with weird features.
size_t is too axiomatic to drop. There are 16-bit machines and 64-bit Windows uses 32-bit longs. &gt;The following ideas rely on changes to the language as well... Oh. Hmm, food for thought. Kinda tastes funny though.
Normally, I have npp open plus a command prompt. When I want to compile and run, I do it all from the command line. Same with debugging.
Yeah I know, while I admittedly spent most of my teenage years behind a computer, having my wrists hurt when I'm only 23 has me a bit worried for my future
Why are you working in C?
I know you've gotten help solving your problem, but in the future you could just use valgrind to help you with memory issues. $gcc -g -o test gistfile1.c $ valgrind ./test . ... ==21580== Invalid read of size 1 ==21580== at 0x4C2F122: strlen (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==21580== by 0x4EA8A3B: puts (ioputs.c:36) ==21580== by 0x400868: main (gistfile1.c:57) ==21580== Address 0x13 is not stack'd, malloc'd or (recently) free'd ... It tells you straight away that the issue is with line 57 in your code, after that it's much easier to figure out that you use directoryInfo before checking if it's NULL.
Notepad++ is just a text editor. To run your program you'll need to run it through a separate compiler. Something like MinGW. IDEs like Devc++ have their own compiler built it.
&gt; IDEs like Devc++ have their own compiler built it. That's usually wrong. All IDEs I know call a separate compiler when you want to compile something, the compiler is never builtin.
Note there is another lurking bug in your code. `strncpy` does not guarantee your copy will be NUL terminated. Since you don't modify the argument, you don't need to copy it and can just do this instead: directory = opendir(argv[1]);
Okay, but is someone paying you to do this? Why are they paying someone who doesn't know C to do it?
You want to install MinGW (or you might already have it installed). Add the binary to your PATH system variable. Now you can compile stuff by entering `gcc -Wall -o yourprogram yourinputfile1.c yourinputfile2.c` in the command prompt, it will create yourprogram.exe in the same directory. This is all assuming you're running windows. -Wall just enables some useful errors and warnings. 
I've been using C for about 4 years but probably would have got this a year and a half ago as well (haven't been actively learning a whole lot lately). I don't know much x86 asm by heart so googled and got [this](http://www.jaist.ac.jp/iscenter-new/mpc/altix/altixdata/opt/intel/vtune/doc/users_guide/mergedProjects/analyzer_ec/mergedProjects/reference_olh/mergedProjects/instructions/instruct32_hh/vc118.htm). So the operation causes an exception, which when not handled by the program will cause it to crash. But the real lesson here is don't do unnecessary stuff and just return ` v-&gt;a + v-&gt;b;` if `v-&gt;valid`. Or even better, return true if v-&gt;valid and use a pointer to return the actual value.
Same, but because I'm too lazy to learn vim.
The IDE can ship with a compiler however
I'm assuming they're using C instead of C++ (Or they're on the wrong subreddit) so surely they'd use gcc.
True, not sure why I was thinking cpp, fixed.
DevC++ automatically installs MinGW. You just have to add the compiler path to your environmental variables. 
Yes indeed inspired me to write a simple interpreter. Perl as well, some places have super optimizations.
You could use a tmux session both of you attach to.
I know this is a few days late, but to build on what /I/dumsubfilter said, always build with `-Wall -Werror`. It will tell you exactly what you're doing wrong, except in some odd circumstances.
Yup, that was it. '-lrt' needed to go at the end. Thanks!
Please read at least the entire comment. I recommended the LGPL which was designed to ensure maximum compatibility with the GPL without restricting freedoms to develop your own software with your own license _and_ use the library. There is no need to force people on GPL. Let the people decide themselves about _their_ own software.
For a `size_t`, use `%zu` if you have a C99 compliant standard library, use something like `%lu` with a cast to `unsigned long` otherwise.
Only in a very limited way: enum valid_types { TYPE_INT, TYPE_DOUBLE /*, ... more */ }; struct node { int type; void *ptr; }; void use(struct node *n) { if(n-&gt;type == TYPE_INT) { int i = *((int *)n-&gt;ptr); // ... do something with i ... } else if(n-&gt;type == TYPE_DOUBLE) { double d = *((double *)n-&gt;ptr); // ... do something with d ... } } This can only cope with a fixed set of types that is defined beforehand.
If you want it to handle more types dynamically, you can add a function pointer to a "use" function instead of using `use()` directly. struct node { /* ... */ void (*use)(struct node*); }; and then use it like struct node *n; n = foo_node_alloc(); /* allocate something that "extends" node */ n-&gt;use(n); Here's a more detailed example: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;assert.h&gt; #define NODE_INT 1 #define NODE_FLOAT 2 struct node { int type; void (*use)(struct node*); void (*set)(struct node*, void*); }; struct int_node { struct node _parent_; int value; }; struct float_node { struct node _parent_; float value; }; void int_node_use(struct node *n) { assert(n-&gt;type == NODE_INT); printf("int_node [%p]: %d\n", n, ((struct int_node*)n)-&gt;value); return; } void int_node_set(struct node *n, void *value) { assert(n-&gt;type == NODE_INT); ((struct int_node*)n)-&gt;value = *(int*)value; return; } struct node* int_node_alloc(void) { struct node *n; n = malloc(sizeof(struct int_node)); memset(n, 0, sizeof(struct int_node)); n-&gt;type = NODE_INT; n-&gt;use = int_node_use; n-&gt;set = int_node_set; return(n); } void float_node_use(struct node *n) { assert(n-&gt;type == NODE_FLOAT); printf("float_node [%p]: %.3f\n", n, ((struct float_node*)n)-&gt;value); return; } void float_node_set(struct node *n, void *value) { assert(n-&gt;type == NODE_FLOAT); ((struct float_node*)n)-&gt;value = *(float*)value; return; } struct node* float_node_alloc(void) { struct node *n; n = malloc(sizeof(struct float_node)); memset(n, 0, sizeof(struct float_node)); n-&gt;type = NODE_FLOAT; n-&gt;use = float_node_use; n-&gt;set = float_node_set; return(n); } int main(int argc, char *argv[]) { struct node *n[2]; int i; float f; i = 2; f = 3.14; n[0] = int_node_alloc(); n[0]-&gt;set(n[0], &amp;i); n[1] = float_node_alloc(); n[1]-&gt;set(n[1], &amp;f); for(i = 0; i &lt; (sizeof(n) / sizeof(n[0])); i++) { n[i]-&gt;use(n[i]); } /* free memory */ return(0); } This way you can extend a node to fit arbitrary data types, you just need to follow the example.
Oh, neat idea! A data structure that uses indirect functions like this could have some kind of table for them. Then we can dynamically change the table, even build hierarchies where the upper levels use functions the lower levels provided. Maybe I can use this to control that bread-heating device I invented last week. (Disclaimer: the above is intended as friendly humor, not dripping sarcasm.)
&gt; you can use a union I figured that an answer to a question about casting should probably contain at least one cast. 
Since standard was never mentioned, I will just put here [this article about generic selections in C11](http://www.robertgamble.net/2012/01/c11-generic-selections.html). It might de-clutter the code a bit in the long run.
Use `strptime`from the standard library.
Sadly `strptime` is only part of POSIX, not the C standard library. I don't believe it's available on Windows? (Someone correct me)
[Here's more details](http://redd.it/3ca06k). Basically I'm dereferencing a function that returns `void *` and returning that, but the value returned is always 0 unless I explicitly cast it.
You can't dereference a `void*`. The type `void` is an incomplete type that cannot be completed. You cannot dereference an incomplete type as the compiler doesn't know what to do. Some compilers may allow you to dereference a `void*` with unspecified results although that is not portable.
Crap. Well, is there a workaround I'm missing? Or a better way to do this?
Macros! Macros are the solution. :) I probably won't use `container_of` specifically but thanks for reminding me about 'em, haha
That would be useful if I were dealing with an instance of something, but I'm not, really. I think. Here's what I have in mind: https://www.reddit.com/r/iOSProgramming/comments/3ca06k/is_it_possible_to_cast_to_a_type_only_known_at/cstxnlj
I'm sorry, I don't know objective C.
Ok, thanks let me try that out
You aren't allocating enough memory for sorted (missing sizeof) and it looks like your bracketing is messed up on line 36.
fixed that. Still ran into problems. Got a seg fault. Gonna check where with GDB
Would help if you posted the full code, errors may not be in the block you pasted.
I posted the entire function. Wouldn't that be enough? 
Not necessarily, you could just be allocating/declaring/passing the "sorted" array wrong. for eg sorted is not large enough to hold left + right together (i.e. length &lt; rightlen + leftlen), which can also cause a segfault.
Sorted wasn't passed into the function. It was created in the function. I will post the entire thing though
2 Things: * Check your parens on line 36. That should solve your segfault. * I think `+1` on 29 and 36 is unnecessary? It makes the `memcpy` skip the last element in the array.
No, but length is. Size of sorted depends on what you pass in to length, sorted isn't guaranteed to be the correct size just because you allocate it in the function.
Just noticed in the complete code you posted line 74 has `r` and `l` mixed up. And you fixed the parens I noted above.
yeah. the mixed up r and l caused the seg fault. Its all good now
thanks for the help!
Why not roll it yourself? It's sufficiently simple to do. For an inspiration https://github.com/hroptatyr/dateutils/blob/master/lib/date-core-strpf.c
No, it's not possible. There is no compiler. There is a c compiler for the HP 50g however. Edit: I stand corrected: http://sourceforge.net/projects/tisdcc/ Edit 2: never mind, the project has no files. 
Probably has a toolbar, though
Good thing you don't make the C standard.
`blk` is an *automatic variable.* That means, it is a variable that is created when `create_blocks` begins and is destroyed when `create_blocks` ends. Returning a pointer to an automatic variable is not a good idea as the variable is already destroyed by the time you access it. Consider doing one of the following things: * Create `blk` in the function that calls `count_blocks` and pass a pointer to `blk` as an argument to `count_blocks`. * Allocate `blk` with `malloc` just as K&amp;R says.
&gt; What would you use in place of errno? Explicit return codes, and attaching error information to objects (e.g. FILE's `ferror()`) when there is one. `errno` was designed in a time before multi-threading, and some acrobatics had to be done to preserve it, such as it typically being implemented as macro+function to fetch and dereference a thread-local value. &gt; Use thread local storage. Occasional TLS lookup isn't a big deal, but TLS is costly in this situation because it's being accessed again and again for each individual comparison. &gt; This shouldn't be part of the libc but rather of POSIX. That's fair. It's annoying at the moment not having a standardized, portable interface for doing this. It's already lead to security vulnerabilities. &gt; For what? There are few cases where such a macro is useful. I've literally written this from scratch 30-40 times at this point because it's so handy. #define countof(a) (sizeof(a) / sizeof(0[a])) And later, float data[] = { /* ... */ }; // ... for (int i = 0; i &lt; countof(data); i++) { // ... } 
You need to Malloc blk as well. Write a destroy function to free. (Ibelieve blk will be block **blk)
Have the destroy function on my list already. That's what I plan to do right after that pointer is working.
Oh I see. So I'll rewrite it to void create_blocks(block* blk) do a malloc(sizeof(block) * CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE); and then go from there, right?
&gt; Am I doing the math wrong? No, I am. I forgot how to count.
Ok, thanks. Will try that now.
&gt; In real software, this idiom is found in OpenSSLâs source code. And the quality of the OpenSSL source code is regarded ratherâ¦ controversial.
Your `bubbleSort` function will never do anything at all, because you initialize `ptr1` to&amp;nbsp;`0` and then immediately test whether `ptr1 == NULL` (which will always be true, of course) and then return.
Oh, I'm terribly sorry I didn't notice that issue before. Out of habit I adviced you to use a simple pointer and to allocate a continuous memory segment. What I failed to mention is, that you can't address your structs in the `blk[i][j][k]` way anymore, but you rather have to calculate the offset in the continuous segment. The calculation is quite straightforward in two dimensions, you just imagine all your stacked blocks: |00|01|02| |10|11|12| and put them in a row: |00|01|02|10|11|12| In three dimensions, its essentially the same, only the row is much longer. I leave the index calculation to you as an exercise ;) The other way, using the naÃ¯ve indexing scheme like you do in your loop, you have to use a multidimensional array. The drawback of this approach is a) a much more complicated pointer type (this may be why you might want to avoid it) and b) memory efficiency (the cause everyone else might avoid it). In three dimensions, you'd have a `block ***blk`, allocated by the likes of: size_t i, j; if ((blk = malloc(CHUNK_SIZE * sizeof(block **)) == NULL) return NULL for (i = 0; i &lt; CHUNK_SIZE; i++) { if ((blk[i] = malloc(CHUNK_SIZE * sizeof(block *)) == NULL) { /* free all already allocated blocks here */ return NULL; } for (j = 0; j &lt; CHUNK_SIZE; j++) { if ((blk[i][j] == malloc(CHUNK_SIZE * sizeof(block)) == NULL) { /* free all already allocated blocks here */ return NULL; } } } Please don't crucify me, if I have errors in the code above, I did not test this. As you see, memory management becomes quite a bit more complicated, as you have to do a similar dance if you free the memory. Edit: formatting
This is an easy lapidary comment to make on Reddit, but OpenSSL's source code is not âregarded ratherâ¦ controversialâ because of this construct or because of constructs such as this one. It is regarded as controversial because of a number of concrete, definite issues, many of which have already been solved either in OpenSSL itself or in forks such as LibreSSL or BoringSSL. The issues are idiosyncratic and inconsistent indentation, preservation of support for obsolete compilation platforms that developers do not in fact have access to for testing, inconsistency in the encoding of error indicators in function results, and absence of checks for success at the call sites for functions that can fail. Some of the remaining failings of OpenSSL in this respect are illustrated in the patches that fix them here: https://mta.openssl.org/pipermail/openssl-bugs-mod/2015-June/000000.html One clever use of the C language, wrapped into a macro as it should be, for the laudable purpose of checking the code's consistency at compile-time, does not make OpenSSL's source code controversial, quite the contrary. The only reproach that can be made is that a comment would have been useful (but on the other hand, â1?e:(type)0â is a C idiom, albeit an advanced one, and the reader could be expected to know about it).
Two things I'd recommend doing. * Keep your arrays flat. * Separate allocation and initialisation. I decided to write an initialisation function for this. Note that it differs from the original, in that the x coordinate varies fastest, rather than the z coordinate. void block_init(block *p, int xn, int yn, int zn, double size) { int i; for (i = 0; i &lt; xn*yn*zn; i++) { p[i].x = i % xn; p[i].y = i/xn % yn; p[i].z = i / xn / yn; p[i].renderSize = size; } } If you know you only need 1 grid and you know its dimensions before the program's interpretation, you can allocate the storage without malloc, then perform the initialisation afterward. static block grid[XLEN * YLEN * ZLEN]; block_init(grid, XLEN, YLEN, ZLEN, 1.0); But it's a simple task with malloc too. block *p; if ((p = malloc(XLEN*YLEN*ZLEN * sizeof *p)) != NULL) block_init(p, XLEN, YLEN, ZLEN, 1.0); It's fairly simple to convert back and forth between (x, y, z) and an index. `x + y*XLEN + z*XLEN*YLEN` will give you the index, and the method for retrieving x, y, and z from an index is listed in block_init. This brings forth another consideration though. Since you can easily convert between an index and (x, y, z), is it necessary to store those coordinates in each element? If not, what you've written could easily be replaced by the following. static double grid[XLEN * YLEN * ZLEN]; int i; for (i = 0; i &lt; XLEN*YLEN*ZLEN; i++) grid[i] = 1.0; 
You can't access a point `blk` like that. `blk` is a pointer to block. `blk[i]` is already dereferenced then, i.e. it is a block. You need to cast `blk` if you want to access it like that (as I said in my post), which is doable since you know the size at compile time. So you can say `block (*blkArray)[CHUCK_SIZE][CHUCK_SIZE] = (block(*))[CHUCK_SIZE][CHUNK_SIZE] blk` Then you can access `blkArray` like a three dimensional array. Alternatively, you could just collect this pointer from `malloc` (it returns a `void*` so it'll convert without a cast) `block (*blk)[CHUNK_SIZE][CHUNK_SIZE] = malloc(...)` if you just return a `block*` you'll have to do the cast on the calling code. Anyway, I think it's probably best to take a more object oriented approach to this, and just have your initialize return an opaque pointer to a struct, and control all accesses with functions (e.g. `block_getCord(x,y,z)`). At the very least typedef this type `typedef struct block (*block)[CHUNK_SIZE][CHUNK_SIZE]`. Then you can do stuff like a reasonable human. #include &lt;stdlib.h&gt; typedef int (*tdint)[10][10]; int (*function1())[10][10] { // this is pretty terrible int (*blah)[10][10] = malloc(10*10*10*sizeof(int)); return blah; } tdint function2() { tdint blah = malloc(10*10*10*sizeof(int)); return blah; } int main() { int (*array1)[10][10] = function1(); tdint array2 = function2(); } 
No, you didn't fix it. You made it worse. Now it has undefined behaviorâyou are attempting to read the value of `ptr1` without it ever having been assigned a value. You're attempting to read the value of an uninitialized variable, which results in undefined behavior, which means you have absolutely no guarantees about the behavior of any part of your program.
What did I get into here. Ok at least I learn more about pointers now. I'll see what I can do here. Thank you.
Noted and hopefully learned my lesson about pointers in this case. Thank you.
Thank you, that explains a lot. Although your coordinate calculation doesn't work in the function above I got it working now with a more costly loop. I'll have to figure out how to get that more effective. About your calculation: let's say I want coordinate x: 1, y: 2, z: 3 with a XLEN = YLEN = ZLEN = 16 or just CHUNK_SIZE The way you put it would give me: `x = 1 % 16` which is 1, `y = 2 / 16 % 16` which is 0.125, `z = 3 / 16 / 16` which is 0.01171875. So I just made it a bit more complicated like you said the index of a given coordinate is simple: `1 + 2 * 16 + 3 * 16 * 16 = 801` so I built three for-loops, to loop through x, y &amp; z and access the index with that calculation and initialize the coordinates with that. If I'm correct, that should be working: x = (i % (CHUNK_SIZE * CHUNK_SIZE)) % CHUNK_SIZE; y = ((i % (CHUNK_SIZE * CHUNK_SIZE)) - (i % (CHUNK_SIZE * CHUNK_SIZE)) % CHUNK_SIZE) / CHUNK_SIZE; z = (i - (i % (CHUNK_SIZE * CHUNK_SIZE))) / (CHUNK_SIZE * CHUNK_SIZE); I don't know if there is an easier way for this, but with that I could go back to a single loop I think. Will try to experiment with this. 
That worked out pretty good for me. The code looks very clean now and very understandable.
It all depends on what you are trying to accomplish. Any more details on what you will be using this linked list for? In general, linked lists shouldn't require you to be copying object data around though.
It is going to be the basis of a simple JSON library. It will be replaced for something faster or will be modified to be faster. The concept remains. Is it a good idea to make copies of data to be stored in a data structure and return a copy of the copy when accessed. Sending and receiving copies of data might be only useful in a very primitive database like data structure.
To convert 801 back to (1, 2, 3), it would be x = 801 % 16 y = 801/16 % 16 z = 801 / 16 / 16 assert(x == 1 &amp;&amp; y == 2 &amp;&amp; z == 3); What you've written seems to produce the same results, but I can't wrap my head around it just now. :-P I noticed you used different values for i in your calculation for x, y, z. The indices 1, 2, and 3 correspond to the coordinates (1, 0, 0), (2, 0, 0), and (3, 0, 0), respectively.
&gt; set by passing and assigning a pointer to a memory location. I am wondering whether I should copy the object the pointer being passed to be used in the new node into a new location. This wording is confusing as to what you're trying to do, but you might want to take a look at the [FreeBSD](http://linux.die.net/man/3/queue) implementations or how the [linux kernel](http://kernelnewbies.org/FAQ/LinkedLists) does this.
You're welcome. The fractional part is always discarded from integer divisions in C. So if you have `15 / 4`, the result is 3 rather than 3.75 (the result of `15.0 / 4`).
I should not live off assumptions, good to know.
Should I post the code?
Yes ! There is no "correct way", but it might help flag any errors you have
no hating please https://github.com/TheRedPepper/DeltaLib
Or you could just program in C++.
The only way is to use macro and to actually declare a whole new type that you will be able to use. Not really practical. Why not void* anyway ?
... also known as [intrusive lists](https://web.archive.org/web/20140523074810/http://www.altdevblogaday.com/2011/12/06/intrusive-lists) *edit: typo*
Thanks, I didn't know the correct term.
Then you are adding two integers, not two pointers
If you are thinking of pointers as some sort of glorified integer... stop doing that right now. It will only lead you to misconceptions. 
If you're going to do such a thing, at least use intptr_t or uintptr_t instead.
Then you get a `ptrdiff_t` with value `-6`, and I'd assume you could add it to other pointers to go back 6 elements.
I've written a few setups like this, though it wasn't designed exactly the same. They definitely can be fairly convenient, though I much prefer using `container_of` intrusive setups when I can (Though, these are generally cases where you can't). Generally speaking, you implement your code by using statement-expressions in macros, where as my implementation I use `static inline` functions in the headers. IMO, it's a bit cleaner because it doesn't use any extensions and everything doesn't have to be in a macro on the same line (or extended line). `static` functions won't be exported, so it's safe to put them in headers even if it's not always ideal. Of course, like your code, it does result in code duplication. Generally this doesn't matter for the simple types being created though, because you'd want to inline their code anyway because it's generally short and inlining can really allow the compiler to improve the code. Also worth pointing out, you can really improve your WITH and similar statements using a bit of complex macro's to essentially define new statements like WITH and FOREACH. You can get a good overview of the idea [here](http://www.chiark.greenend.org.uk/~sgtatham/mp/), which is where I first learned about it. Personally I do like the use of it as long as it's use is fairly self-explanatory and not *everywhere*. My hobby OS includes a [using](https://github.com/DSMan195276/protura/blob/master/include/protura/stddef.h#L61) statement, which is essentially your 'WITH' statement, but allows a statement block (And an 'else' block in the event the statements fails. For each, an 'else' block to run if a file can't be opened). [Here's](https://github.com/DSMan195276/protura/blob/8a528de005528b7b3e602ba1f8db0f891e288af0/arch/x86/drivers/keyboard.c#L117) a simple spinlock 'using' statement being used - Note that spinlocks can't fail, so it doesn't have the 'else' block. For 'foreach', you can make them act like actual 'for' loops, which is what I do (And a technique used a lot in the Linux kernel code, among others). [This](https://github.com/DSMan195276/protura/blob/57041493e7d4052cf2f5fa963a2507113d843cc7/include/protura/list.h#L206) is how I defined a foreach for my generic intrusive 'list' setup (Almost identical to the Linux Kernel's intrusive list setup), and [here](https://github.com/DSMan195276/protura/blob/57041493e7d4052cf2f5fa963a2507113d843cc7/arch/x86/kernel/scheduler.c#L126) is it being used to iterate over all the items in a list. More [complex](https://github.com/DSMan195276/cmips/blob/master/include/common/rbtree.h#L163) foreach statements can be achieved using the macro statement stuff from above to allow declaring variables within the scope of the for loop. The advantage that they offer to just using, say, two nested 'for' loops is that you can make 'break' and 'continue' work as expected. The disadvantage is obviously complexity.
The typedef macros (eg HAC_VEC_T_NEW) are unfortunately needed because the types `struct {int a;}` and `struct {int a;}` are not compatible. As for void pointers, they create space and time overhead and lose type information, and taking the data size into account adds complexity. In most cases I would agree these disadvantages are outweighed by debugging and encapsulation benefits.
Duodecember 5th, obviously.
Uh oh, didn't see it was a link to your code actually, I thought you were asking a question. OK, then we agree, it's either void pointers or macro. I will look into your solution, it's always interesting to see how someone managed to write this kind of stuff, even if extremely frequent.
Could the use of `container_of` also be obtained by casting a `struct {node node; data data;}` to a `struct {node node;}`?
Kinda - Normally if you were going to do that, you would have `struct thing {struct node; struct stuff; };`, and then cast a `struct thing *` to `struct node *`, but what you did is the same idea. You cast a pointer to the struct as a pointer to the first element. `container_of` is basically a better version of that, because `container_of` allows you to place the `node` element anywhere you want in the structure, and then `container_of` figures out the correct offset to get the right pointer back. The *big* advantage here is that it allows you to use multiple `node` type things inside of your struct. For example, in my linked-list example, by using `container_of` you can have your node contain multiple `list_entry` struct's, and thus be included into multiple lists. I could also have it contain an `rbtree_node` struct, and have it be in an rb-tree as well - And anything else I want. This doesn't work if you do casting based on the first element, because it limits you to picking one, and only one, thing to use in your struct.
I believe the [linux kernel](http://kernelnewbies.org/FAQ/LinkedLists) implementation follows this as well.
Fascinating. I read all 3 parts and now I'm late for work. 
And thus this post is off-topic and I removed it right now.
rewrite it in perl or python? Any reason it needs to be in C? This is solvable in C, of course, just, you could do it much easier on a higher level language.
string.h includes a function for splitting strings called strtok(). You can use it to replace some of the code in your split function.
The first half of your post is just micro-optimization which , IMHO, is not relevant to a C beginner. Focus on writing clear code which works, and worry about minutiae later. You seem to be unaware that non-antique compilers will optimize this code along the lines that you suggest anyway. 
approximately 100k lines per csv.
http://search.cpan.org/~adamk/Parse-CSV/lib/Parse/CSV.pm Literally 10 lines of code and that perl module. You're just parsing the CSV file and outputting things in a slightly different column order. You don't need to understand how the C code works. Just make a perl script that for a given input, outputs the same output.
The combination of **fgets** and **sscanf** seems like a much better choice here.
Or if you really need it to run very fast because you run it every minute or something like that.
You can make a program to sort a large array of numbers or strings. Create a array of random numbers by using rand(). Create a new thread if array is larger than a predefined number and split the numbers between them. You want to recall the sort method in the current thread with the half of the numbers (recursive). Start sorting if the array in this thread is smaller than the predefined number, if not continue creating new threads and splitting. When the thread you created has finished sorting and and the current thread is also done with sorting, merge these results using threads. In the end the main thread will have the result of the array fully sorted. Note: i did this in C++11 using std::thread, std::vector, std::sort and std::inplace_merge, but it can be done using pure C and pthreads. 
Think about a user facing thread that takes commands and a processing thread that continuously does something but is configurable by the user thread. Pretty common scenario.
Something like tbb? https://www.threadingbuildingblocks.org/
Can you tell me about your OpenCL benchmark? I've been using clFFT to bench things (and then compare with FFTW on the CPU), but that's just one perspective.
It's a program that calculates the fused multiply accumulate single-precision floating-point performance of CL devices. It generates a couple of random matrices on the CPU that are used as the inputs for the kernel, then it runs and times the CPU kernel, the CL kernel, and compares the outputs from both. It lets you know the maximum real-world performance of your hardware and CL implementation combined. I'm still working on it, it's nowhere near being ready to show off, but it does adequately show the difference between running code on the CPU using threads, and running it on CL devices. Among other things, it shows how to initialize and use CL platforms and devices, how to load a kernel from a file, compile it, and link it into a CL program. All of the interesting boilerplate is in cl_common.c. I'm still working on a clean, object oriented way of creating multiple benchmarks that can be added to a list and executed at runtime. I'd like to be able to benchmark integer and double FP performance as well.
A hash cracker for reversing hashes. The type commonly used for storing passwords.
Hey! I've done something with the mandelbrot fractal a few years ago, I have an archive on Github of old stuff: https://github.com/fredmorcos/archive/tree/master/Projects Look for "mandelbrot", there are a few versions of it and one of them is using pthreads. Also, if you're interested as well, look for parallel_matrix_ops and you can find a multi-process matrix multiplication using shared memory.
If you're interested in pthreads, you might also like OpenMP, which adds "#pragma"s to parallelize loops and other stuff. It also works on Windows, unlike pthreads. OpenMP is also (IMHO) simpler to program, and really allows for some interesting features.
So don't subtract pointers unless they point to elements of the same array object. There's no good reason to extend that to a rule that you should avoid subtracting pointers in general. A concrete example: I've had cases where I have a pointer to an object, I know the object is an element of a particular array, and I need the index. Subtracting the address of the 0th element of the array from the pointer gives me the index. The alternative would be a loop that compares the pointer for equality to the address of each element of the array (something I've done when I'm not 100% sure it's an element of the array).
No, the typical alternative is to pass the array alongside offsets into it. 
OK; most of that code is for the parsing of the commas, etc, i.e. splitting the lines up into fields. Then it repeatedly read five lines (into the buffers allocated into the buff5 array) and then repeats the same set of code five times, looking for a different field/line from the five lines, each time. Below is the first set of code, looking for the line with "Top" in it, commented to explain what it is doing; // find the line (of the five) containing the string "Top" for (i=0;i&lt;5;i++) if (strstr(buff5[i],"Top")) break; // Note that at this point i contains the index of the line of // the string containing the word "Top" - or if it wasn't found, the variable i will // be set to 5. The buff5 array only has 5 things in it, and // they are indexed from 0 to 4. If i is 5, bad things will // happen so we better hope we found it. This code isn't not very well // written. // split the line into items n=strspl(buff5[i],delim,item); // The code assumes that there were 10 items, hence the last // item will be number 9 and will have the last item and the // newline, this gets rid of the newline. cp=strchr(item[9],'\n'); *cp='\0'; // copy the 9th/last item to vtop strcpy(vtop,item[9]); Once it has found all five of the things it needs it just prints them to the output file. It repeats the sequence of "read 5 lines, look for Top, look for Late, look for Window, look for Correct, look for Time, print out one line" until it can't read another set of five lines. 
I disagree. The audience for C code is not (or at least should not be) people who don't know C. Certainly there's a cost in using obscure features, but one can go too far in "dumbing down" code.
&gt; I am wondering if the variable must be locked before reading it even if the second thread is not writing to the variable in any way? No, but you have to be absolutely, positively sure that the other thread isn't actually writing to the variable at the same time. Unless you use a mutex, you likely aren't. Also, it's totally possible for the compiler to optimize away the variable read since it assumes the value hasn't changed. The 'volatile' keyword makes the program take into account that the data can change between accesses. 
Put code in paste bin or ideone. Maybe we can identify what's going wrong. 
What value does it print? And what do you think it should be?
I expect you're suffering from the low resolution of the hardware timer then. Gettimeofday may claim to give microsecond resolution but PC hardware ticks less frequently. If this is PC hardware, and you need this resolution then you'll need to look at the timestamp counter (rdtsc instruction) If it isn't PC hardware then it may have a higher resolution clock.
I think I understand what your saying, but why would the value inside of thread 1 be correct while the same variable outside of that thread is wrong?
I hadn't noticed you were printing it in the other loop. I'd break in the debugger and/or take a look at the disassembly to make sure the compiler hasn't messed something up. 
It really depends on the platform. As an embedded developer, I use volatile _a lot_. I also don't use CPUs that have a concept of threads..... so there's that. Volatile has its uses. It's not sufficient in and of itself, but it often helps.
Also: https://www.kernel.org/doc/Documentation/volatile-considered-harmful.txt
I don't think that's a nitpick at all. Those will be much better than how I have it now.
Are you asking to pay someone to do an assignment for you? Also, what are you paying?
Hey, better than 99% of the posts here where they want us to do their homework for free...
right man, i just need it done i cant stress over this any longer lol.. ive spent like over 14 hours on this and seen someone do it in 30 minutes and i was like whaaaaaaaat!!! lol :'(
You should see if the PM of Singapore is around. He supposedly had a good solver :) (although I believe it was in Java). I've seen this as a popular small program to write but, haven't thought much about it...until now. I would think you need to complete this under a certain time restriction or algorithmic complexity. Are there any other details about the assignment? Or is it you're having trouble wielding C as a language to complete this? And this dough you speak, is it of deep dish variety or thin crust?
thanks man :)
Your program doesn't print any error messages. So what error are you seeing?
I have saved this program under the filename "program.exe". So when I build and run this program in IDE, an error message pops up showing program.exe has stopped working.
I guarantee you that if you just copy and paste this code off of google, you will 100% get caught and marked for plagiarism. Don't do it, hand in the code you already have and take the low mark. Then study study and study.
You can't allocate large arrays on the stack. The stack is for small, temporary allocations, not bulk storage. Trying to allocate a million `long`s on the stack is causing a stack overflow. Either allocate that memory dynamically (with `malloc()` or `calloc()`) or give the variable static storage duration (either by declaring it at global scope or at function scope with the `static` storage class specifier.)
Here is a basic outline of how a Sudoku solver works: **variables** The solver maintains a *backtrack stack,* each layer of the stack contains the number you tried last and the coordinates of the cell where you placed that number. **algorithm** The algorithm is a classic [backtracking algorithm](https://en.wikipedia.org/wiki/Backtracking): 1. start with a Sudoku puzzle 2. if the puzzle is violating one of the Sudoku rules (for instance, a number appears twice in a column), return âno solutionâ 2. if all numbers are filled in, return that solution. 3. try to fill in the free slots in all possible ways. For each way to fill one of the slots: 4. put the slot you filled in on the stack 5. call this algorithm recursively. 6. If the call resulted in a solution, return that solution. Otherwise: 7. undo the change done by popping from the stack and emptying that cell 8. try the next way to fill in a cell. 9. if you tried all ways without finding a solution, return âno solutionâ
I'm not too familiar with Cython, but it seems like you should be doing something like this. cdef blah(): cdef: double **A ... double *p A = &lt;double **&gt; malloc(sizeof(double *) * N) p = &lt;double *&gt; malloc(sizeof(double) * N * N) if A == NULL or p == NULL: free(A) free(p) ... for i in range(N): A[i] = &amp;p[i * N] ... dgesvd(A, N, N, ...) free(A[0]) free(A) ... 
I want to add that Devc++ is a terrible IDE. At least get something like Qtcreator (no need to use the qt stuff) when you want to use an ide. Invoking the compiler manually when learning is often good, but a lot easier if you use linux or another unix system
The address of a double * is of type double **: double a = 5.0; double * a_ptr = &amp;a; double ** a_dptr = &amp;a_ptr; &gt; A_p = &lt;double *&gt; malloc(sizeof(double) * N) U_p = &lt;double *&gt; malloc(sizeof(double) * N) VT_p = &lt;double *&gt; malloc(sizeof(double) * N) A_p , U_p and VT_p are all pointers. You can use: malloc(sizeof(double*)) &gt; free(A_p) free(U_p) free(VT_p) You may want to consider using the stack. 
thanks for the help :).. hey i have a question do you know how i could change a struct to an array?
I'm not sure what you mean.
&gt; You have to tell the compiler about functions in advance (except main()), or the compiler will bitch and whine that you didn't tell it. :P Correction: You have to tell the compiler about functions before you use them and that only since C99. `main()` is no exception: By defining `main()`, you tell the compiler about `main()`. The same is valid for any other function, too. If you were to use `main()` before defining it, you had to declare it too. In C89, the situation is different. If the function returns an `int` and all its arguments obey K&amp;R-rules (i.e. no argument smaller than `int` and no arguments of type `float`), then you don't need to declare the function because the compiler assumes an undeclared function returns an `int`. If the function returns something else but its arguments obey K&amp;R-rules, an old-style definition (i.e. without a prototype, like `int main();`) suffices but no type checking on the arguments can be done. Only in the case that the argument list is not K&amp;R-compliant you need to specify a proper prototype. &gt; (A variable inside a function can't be seen outside the function, so that doesn't make it into the symbol table.) Not necessarily. For instance, `clang` generates symbols for variables with `static` storage duration even if they are local.
I don't think there's any way to do this with `__VA_ARGS__`. The way this is usually done is with a set of macros, one of which starts the struct, one that ends it, and one that defines each element.
I can see using two macros, but that means wrapping each argument in a macroâ¦ which isn't much less work that just typing it out myself. Hmmm. Thanks anyway!
If you need a more powerful preprocessor, use `m4`; this preprocessor is available on all Unix systems.
Will do!
If you can use C++ instead of C, there's some metaprogramming techniques that might do what you want. You might even be able to just use a `std::tuple`, depending on what you need.
Yeah, I saw that. Looking for one that works limitlessly, but thanks!
Variadic macros are meant to pass variadic parameters, not generate an arbitrary amount of code in preprocessing.
im trying to make this function (currently declared before main) into something without a struct. should i just make this a function and pass it around as an int? struct Board { int values[81]; //Stores board values bool isFixedValue[81]; //Keeps track of what numbers can be modified bool isPossibleValue[81][9]; //decides what values are possible for certain square int coordinates; };
Why do you want to get rid of the struct?
because im not too familiar with it and i think this is what is messing up my code. 
To be fair there is a [pthread lib for windows](http://sourceware.org/pthreads-win32/). But OpenMP is probably the easiest way to do as it requires way less code to parallelize it.
Step back and ask why are you worried about heap fragmentation? Are you really worried? If so, do you have any evidence it is causing problems? Or is this an academic exercise? To answer your questions though .. The first cast is okay. The list setup in the loop is wrong. By doing out+1+I you're working with list_head sized arithmetic but you want list_body. I'd add another variable of type list_body* for doing that walk.
The aim seems to be a modernization of [plan9](https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs).
One place to start would be to use zero length arrays for the data portion of the node like: struct node { struct node *next; char data[0]; }; Then allocate the node and data in one contiguous block. But if you're really worried about fragmentation then you should choose another way of storing the data. Try allocating contiguous blocks and reallocating them as it needs to grow.
Yeah, it seems like a vector would be the best way to store this, and they're fairly simple to implement.
From the website &gt; Harvey is an effort to get the Plan 9 code working with gcc and clang.
As I've played with Plan 9 in the past, I'd absolutely love to see its concept in fresh code! My biggest problem was that the Plan 9 ecosystem was its own little world, that kind of hampered its usability for me. Perhaps this could change now?
IMO you shouldn't worry about heap fragmentation. I've you really have to worry about it, then it might be a hint that a linked list might be not the best data structure.
You can use [gist](https://gist.github.com/) to post your code so someone can look at it.
Thank you! :)
Link to my code. https://gist.github.com/anonymous/4411857b05c789718aa5/revisions
How does your soduku file look like? You are never reading any file since you have commented out getBoard() inside main(). Also why do you put the function signature inside your main/other functions? I would suggest you either use header file to have all these function signatures or do it on top of your .cpp file If your are using C++ why don't you use classes? it will make it a lot easier. You could have used Board, square, row, column and box classes. Please describe what kind of problems you are having and how are you supposed to solve this task? 
The point of specifying the types is so you can display the same type in different ways. Knowing the type is an integer does not tell you if they want the number printed in decimal form, scientific notation, hexadecimal, binary, etc.
I'm guessing you're on a 64-bit platform. Because `x` is a pointer (and *not* an array), `sizeof(x)` is the size of a pointer. On a 64-bit platform, `sizeof(x)` should be 8, regardless of how short or long the string is that `x` is pointing at. You probably want to use `strlen(x)` (the length of the string pointer to by `x`) instead of `sizeof(x)` (the size of the pointer).
Yep that's gotta be what it is! In my notes, the only example we get is: buf[500]; write(fd, buf, sizeof(buf)); In this case buf is the size of the entire char array? And not just the size of a pointer to the first element? Why would buf[500] be different than buf = "500charactersofstuff...." ?
The type of `buf` is array-of-500-`char`s. Therefore, `sizeof(buf)` is `500*sizeof(char)`. The type of `x` in your code is pointer-to-`char`. That is not the same as array-of-`char`. Pointers and arrays are not the same thing.
The problem is that numpy arrays and Cython memory views are one big contiguous block of memory, whereas `dgesvd` requires you to pass you a pointer-to-pointer. You have the correct idea that you need to access the `double *` value corresponding to each row, and save it as the corresponding value in `A_p`, `U_p`, and `VT_p`, but you are not doing it right. For example, after `A_p = &lt;double *&gt; malloc...` line, you assign `A_p` `N` times in the loop. All of that is equivalent to just one statement: `A_p = &amp;A[N-1, 0]`. You discard previous assignments and also have a memory leak because the pointers returned by `malloc` are not accessible to you anymore. Instead, you should do the following: cdef blah(): cdef: double[:] S double[:,:] A, U, VT double **A_p, **U_p, **VT_p U = np.zeros((N,N)) VT = np.zeros((N,N)) A = np.zeros((N,N)) S = np.zeros(N) # You can also use "sizeof(double *)" below. A_p = &lt;double **&gt; malloc(sizeof(A_p[0]) * N) U_p = &lt;double **&gt; malloc(sizeof(U_p[0]) * N) VT_p = &lt;double **&gt; malloc(sizeof(VT_p[0]) * N) for i in range(N): A_p[i] = &lt;double *&gt;&amp;A[i, 0] U_p[i] = &lt;double *&gt;&amp;U[i, 0] VT_p[i] = &lt;double *&gt;&amp;VT[i, 0] dgesvd(A_p, N, N, &amp;S[0], U_p, VT_p) free(A_p) free(U_p) free(VT_p) Note that I changed the type of `A_p` etc., changed the assignments in the loop, and the way `dgesvd` is called. I did not test the above code, but did test it using a simpler, equivalent code that calls an external C function (that I wrote) that takes a `double **`.
Then why is your source code written in C++? Feel free to ask any questions about C code in this subreddit but your code is written in C++ and as such off-topic.
Okay, I take that back. I thought there was evidence of you engaging in sockpuppeting but it seems like I misread it.
So far the macros I am using (which are very similar to the one's in my link.) work. I will continue to experiment and possibly update if something breaks 
That's great! IoT is up and rising and a lot of people are looking into it, searching for articles on how to start, opinions, platform questions etc. Drop me and email and we'll look into it.
&gt; Someone on the mailing list was "amazed" that you would say that. Oh! Popcorn time! Can you send me a link to the corresponding mailing list archive?
You should use include guards on header files (Obviously not all header file need them, but it's good practice to use them on all header files). File: Parrot/src/parrot.h, I did not look at the whole project. For an explanation why you should use them: https://en.wikipedia.org/wiki/Include_guard
sizeof(numbers) is 8: what is numbers? It is a pointer to ints. A pointer itself is an int. The size of the numbers pointer, is 8. That's why you get that. Unfortunately, you can't simply get the size of your array. The way I go about it, is I keep element zero, numbers[0] to be the size of the array. And whenever I add or remove something to the array I will update numbers[0] to reflect that. But there is no simple .size() that you can use in C. Sorry! (Also, sorry for this terrible formatting, I'm new to reddit!)
In the future, when you ask these questions, you need to provide the source of the program and the command you ran that produced the error. Also, to get messages in English, you can prepend `LC_ALL=C` to your command to temporarily change the locale setting, e.g. LC_ALL=C gcc foo.c ... 
Thanks for the info guys! So how would I go about keeping track of the size? Should I just use a struct and increment an associated counter variable every time an element is added to the array?
Well, first of all, C&amp;nbsp;and Vim are two completely different, independent things. Neither one of them requires or relies on the other, and you aren't going to find anything about "learning C using Vim." Now, have you read the list of resources in the sidebar?
&gt; fail. (should be five(void) Not anymore. I think C99 altered the rule such that in a function *definition* (not declaration), an empty parameter list denotes that the function takes no arguments instead of an unspecified number of arbitrary arguments.
Don't try to learn C *quickly;* try to learn it *throughly.* C is a language with many subtle aspects, learning it *quickly* is not going to get you anywhere.
Why do you think it is bad that `a += b;` gives a warning? The warning seems correct to me. The result of the addition may be out of range for `char`, causing implementation-defined behaviour. I'd argue that adding plain chars is bad style, they're meant to represent actual characters. There would be a better data type for whatever you are trying to do (perhaps `uint8_t`). 
I mentioned not having access to a pc at this time, so no, I have not had the chance to look at the side bar. I know vim and c are not reliant on each other. One being the ide, the other the language.
&gt; I mentioned not having access to a pc at this time, so no, I have not had the chance to look at the side bar. What does that have to do with reading the sidebar? All mobile apps have the option to show the sidebar. Learn how to use your app or use a real browser. https://imgur.com/a/kgwuy#4
I understand retention can be a issue when learning certain programming languages quickly. I have no need to retain this information, I am simply trying to do this so I can help the wife. Her professor does not teach very well, and I am trying to help by being able to give her a different perspective and understanding, as limited as it may be. But thank you for the suggestions. I will check them out as soon as I can get to my laptop.
Well, that's new to me haha. I just got this phone today. The reddit is fun app didn't have that in 4.2. 
Baloney. The image I linked is 2&amp;nbsp;years old.
Well then, if thats the case, I've never seen that. 
Where at?
I think this is it: https://github.com/morrisonbrett/1991-golf-handicapper-for-windows-3.0
First of all, please understand that in C, capitalization and punctuation matter. I assume the two examples actually look like this: main() { return 0; } and int main() { return 0; } Now to your questions: The second of these two is what you should use. `int` is the *return type* of `main()`, there is a rule that you can leave out the return type if it is `int` which the first variant uses. This rule however is deprecated and was removed in the newest revision of the C language. `make` is a program that helps you compile projects. You can specify compilation options and how to compile the project in a `Makefile` and `make` will automatically invoke the compiler for you. For simple tasks, it is sufficient to use `cc`, the C compiler (`gcc` is an implementation of `cc`). Don't try to write Makefiles until you have understood the process of compiling a C program, it's just distracting.
I would recommend C Programming A Modern Approach. It is expensive but the content its very good, covers from basic to intermediate level. At the end of each chapter there are questions with answers, similar to your question, exercices and ideas of projects to practice. If you can find it with a friend or in a library I personally find it better than Learn C the Hard Way.
**Edit:** Obviously I can't read... While I agree with /u/FUZxxl that it might be distracting at the beginning, I'd recommend you to familiarize yourself with the compilation process soon and use make thereafter. I haven't seen an answer to your question about make vs. gcc yet, so I'll tackle that. Make is a build automation tool, which in turn calls the c compiler, which in your case seems to be gcc. It automates all the boring stuff, like checking if a file was modified since the last build and therefore has to be compiled again. This might not be useful for you yet, as I guess you don't have that many source files for a single program at the beginning, but the use of make may also make the compiler call more convenient. For example: make vs gcc -std=c11 -Wall -Wextra -Wpedantic -o test test.c given a Makefile with contens like test: test.c gcc -std=c11 -Wall -Wextra -Wpedantic -o test test.c Please be aware that this is an extremely simplistic Makefile and doesn't follow *any* of the best practices for using make.
Do you know about the I/O functions of the standard library? If not, you may want to [read the documentation.](http://en.cppreference.com/w/c/io)
OK. In the `uint8_t` example that's a dumb warning and should probably be considered a bug.
Others have answered your question thoroughly, so I just wanted to ask if you have looked into CS50 on edx? It's an awesome introduction to C.
Maybe something like: while(true) { // your code printf("Press any key to break the loop\n"); scanf("%s", &amp;str1); if (&amp;str1 ==! NULL) { break; } } 
My advice, don't use an infinite loop. Your while should be conditional. That's what it's there for. The while evaluates on each iteration anyway, so why introduce a second evaluation? Your way is bad practice . BTW blocking code sucks. Better to test periodically and do something useful in the interim..
The concept is fine, the actual code isn't. Assuming *str1* is a character pointer, the **scanf** is incorrect. scanf( "%s", str1 ); This is still going to block the loop, and it will sit there waiting for you to hit enter. Assuming *str1* is a character pointer, this will never be NULL, so this test would never work, even if the correct test was used: if( &amp;str1 ==! NULL ) It would be: if( str1 != NULL ) However, *str1* will never be NULL. Or maybe you were trying to dereference it to check the first character for nul.
"Let Us C" is a terrible and very out-of-date book by Y Kanetkar, who has also written equally terrible and out-of-date books on C++. Unfortunately these books are still widely used in colleges in India. Avoid at all costs. For a list of decent C books see here: http://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list
Good Point
Couldn't find those. I do have the .EXE. Doesn't run on Windows 10 using Windows 95 emulation. Need to find a Windows 3.0 VM to try it on.
Been working through this book from beginning to end (kind of slowly, not even every day) for the last 8 months or so, and I'm almost through it (I'm on chapter 21 atm). It goes into the perfect level of detail without being too boring, and all the exercises/projects are really good practice. You should really take your time with each chapter and absorb as much as you can. It's even a pretty good reference manual. Also, you should check out /r/dailyprogrammer if you have some spare time and just wanna practice with some simple challenges. They have an easy, intermediate, and hard challenge come out every week. I started out doing only the easy challenges, but I've been able to do more and more intermediates as time goes on, and hopefully I can do a hard one by the end of the year. :P
It is just an overview of coding, right? Not specifically about C. I enrolled and will see how it goes.
Yes, though while it's an introduction to programming in general, the majority of the class is done in C. If you only want to do the C parts, that's definitely an option. I did that at first, but went back and did pset0 just to have it done. If this year is the same as last (and I believe it is) you could skip to pset1 to start with C. The lectures are really helpful and informative, as are the walkthroughs for each pset. Let me know if you proceed with the class and if you need anything while doing so!
By .txt I guess you mean writing ASCII data with fprint and then parsing with fscanf. But I don't know what you mean by .dat versus .bin. Usually, you'll want to save files as pure text. It's easier and safer to work with because you don't need to worry about architecture specificities. For instance, if you write an (int) to a file, the writing application could be working with integers of, say, four bytes while the reading architecture could be working with integers of eight bytes. Endeanness is also an issue. You'll want to work with "binary" data when you are savings lots of native stuff. Imagine a .zip file encoded as sequence of ASCII numbers. It would lose the point of the compression. Also you might not want your data to be easily editable, like you're writing a game and you don't want to make it so easier for the player to edit the character file and chat. You might be interested him checking something called marshalling. It's simply saving native data types to a file in standardized ways. I can't recall of any right now as I'm on mobile, but there are libraries for that in many languages, including C and C++.
txt is text bin is binary dat is more often than not also binary The extension should indicate what type of information it contains and that's it. You could as well save binary data in a txt but someone will probably get mad at you for that. Edit: also, the extension is merely in the name, means a file doesn't need an extension. You could also rename the file to another extension or omit it - that doesn't change the contents.
All three of them are just file extensions that don't really tell you anything about the format (except that a txt file would probably be human-readable). What you need to do is think of a format to save your data in the file. Should it be human-readable? Is it just for output or input as well? If it's just for output it's probably enough to just use `fprintf()` to write your data in an arbitrary human-readable fashion, interpretation and fault-tolerance is handled by the (human) reader. If your format is for input and output, your application has to be fault-tolerant as well, especially if your file format is human-readable (e.g. dealing with syntax errors, white spaces and all that stuff). This is probably what you think of when you say txt file. If you don't need human-readability and you only have a limited number of types to save to the file (e.g. one kind of struct) it's probably enough to just write a 4-byte value indicating the number of structs in the file and then writing the structs using something like `fwrite()`. To parse this file, simply use `fread()` to first get the number of structs and then read the structs from the file. You can call this a bin or dat file, but the truth is those extensions just mean the file is in a binary format. There is no formal definition for the format of the data inside of a bin/dat file.
&gt; Data marshalling can actually be done without libraries in C Well, you can do anything without libraries in C... but since there's already an estabelished and tested library for that, why not give it a try?
It sounds like what you actually want is Python
Are you sure you understand the concept of pointers? And how they interact with arrays? Well firstly, you have the types of the parameters the wrong way round. The main function signature should actually be: `int main (int argc, char *argv[]); // how argv is presented is up for debate` The first parameter, `argc`, is the number of arguments passed into the executable when it is run and `argv` is an array of those arguments as strings. In C strings are represented as an array of chars, so `argv` is an array of array of chars. So why isn't the second parameter declared as an array of array of chars e.g. `char argv[][]`? Well... It can. But it also can be represented as `char *argv[]` or 'char `**argv`. In C an array is actually a pointer to the first element in an array and the syntax `arr[1]` is actually just syntactic sugar for `*(arr + 1)`, which is a pointer to the memory location one after the one pointed to by `arr` (the pointer to the first pointer in the array); So really you can represent an array as a pointer, or an array of array of something as a pointer to pointer of something. Hence `argv[][]`, `*argv[]` and `**argv` are equivalent. As to why you don't use a pointer for the first argument is because there is no point as it is an int.
`scanf()` requires pointers because you're modifying the value of a variable that is external to the function (the one you're passing as an argument), have you heard or read about passing parameters by reference?
&gt; which IIRC is itself null-terminated? That might not be right; I can't remember. You are correct. From the C99 spec: &gt; 5.1.2.2.1 Program startup &gt; &gt; [...] &gt; &gt; * argv[argc] shall be a null pointer. So, technically, you don't even need to know argc. 
Simple problem; imple solution: char input[20] = ""; while (!input[0]) { ... } I'm assuming you want to be able to accept muli-character input. (If not, this still works. This code only depends on the first character variable.) Initialize the first character of your input to a null character (i.e. 0). As soon as input of any sort is put into the variable (a return character, the first letter of a string), `!input[0]` will no longer evaluate as true. Edit: I'm also assuming you know how to take input and put it in variables. Let me know if I'm wrong.
I second what /u/acwaters said. I'll add on to this: C is "code", not "scripts". This sounds pedantic, but it's a fundamental difference: scripts tend to be "write it then run it", loose typing, higher-level abstraction for thinking about the problem. "Code" tends to be "write it, compile it, run it". I'm being kind of loose with "script" vs "code", but that's my take on it. In all fairness, you will want a decent understanding of C before tackling this. You could possibly short-cut the end game by using popen() to run command line utilities for SNMP. It's uglier and less proper than using C libraries for the job, but it may be more intuitive for you the developer. Just realize that this will likely be trowaway code. If your boss' goal is for you to learn C by tackling a big task, then by all means go for it. You'll have to progress through a few levels (beginning with newbie) before you have a good final product. If your boss' goal is to have the job done, then picking another language is likely your best bet. Even if you're on Windows, there are still decent scripting languages.
No, well, yes. References, like int&amp;, are a C++ feature. With &amp; you get the pointer (to the memory) of a variable. By reference is passing a pointer, by value is passing the dereferenced pointer. 
Ya if you read carefully you will see I did not say both languages are exactly the same times infinity + 1. I said if you know one it's impossible not to know the other enough to help with **entry level homework**. OP would have to be a complete moron to see code with `printf("Hello World!");` and not think "*Well I guess that's how it's done in C, they don't use cout!*". The rest of your syntaxual examples would easily be solved by glancing at the compiler/linker errors.
stdint.h defints `uint8_t` as an `unsigned char`. A warning/error for one is the same for both.
&gt; So why isn't the second parameter declared as an array of array of chars e.g. `char argv[][]`? Well... It can. But it also can be represented as `char *argv[]` or 'char `**argv`. No. `char argv[][]` is illegal as the type of an argument to a function! Pointer decay goes only "one level deep," so that is not the same as `char **argv` or `char *argv[]`. http://c-faq.com/aryptr/pass2dary.html You cannot use `char argv[][]` as the type of an argument to a functionâyou need to specify the size of the second dimension of the array. You could specify `char argv[][3]`, for example, which is equivalent (in a function declaration) to `char (*argv)[3]`, which means "pointer-to-array-of-3-`char`s." But that is *not* the same type as "pointer-to-pointer-to-`char`." &gt; In C an array is actually a pointer to the first element in an array No. Arrays and pointers are not the same. When the name of an array is used *as a value*, then it *decays* to a pointer, but the array itself is not a pointer. https://www.reddit.com/r/learnprogramming/wiki/faq_c#wiki_is_there_a_difference_between_arrays_and_pointers.3F http://c-faq.com/aryptr/index.html &gt; So really you can represent an array as a pointer, or an array of array of something as a pointer to pointer of something. Hence `argv[][]`, `*argv[]` and `**argv` are equivalent. Again, this is not true. Pointer decay goes only "one level deep."
int main( int argc, char* argv[] ) {} is fairly classic. The second parameter makes sense because a "char \*" is idiomatically a "string" though there's no such thing as strings-as-a-data-type in C. Thus it reads very naturally as "a count of how many string arguments followed by an array of that many string arguments". char ** could literally be a pointer to a char * so the [] notation tells people "and there's another pointer after the first pointer".
&gt; argument value(s) huh TIL, I always thought it was "argument vector" It might also be helpful to mention that arrays decay to pointers when passed as arguments to a function i.e. char array[]; --&gt; char* array; char *argv[]; --&gt; char** argv;
wine can work on windows 3.1 mode
Eh, "values" is how I mentally interpreted it; "vector" makes a bit more sense, though, doesn't it? Edit: Actually looked it up and you're right. How have I never bothered to learn what that stands for?
As far as compiler flags of gcc are concerned, `-std=c90`, `-std=c89` and `-ansi` all have the same outcome. Where does it say, gcc's documentation is using C90? I've never seen it, they always referred to it as either C89 or ANSI C.
True, but if you replace "null-terminated string", "pointer", and "array" with "*", your sentence "a pointer to an array of null-terminated strings" would be written as `char ***argv`. One too many. It's really just "array of null-terminated strings". 
Is that C11? It covers ANSI C. Not much has changed in the core language since then though, it doesn't teach anything that's a bad idea in modern C I don't think
&gt; It covers ANSI C Actual ANSI C is C11. But I thought about the first revision of K&amp;R which didn't include C89 because it's from the 70s. Googled and found that the second revision covers C89, I only knew the first one. My bad.
&gt;Actual ANSI C is C11 Nope, ANSI C is C89/90 https://en.wikipedia.org/wiki/ANSI_C And yeah the first edition ofc uses the old style function decleration syntax which means no parameter type checking. C11 is ISO (ISO/IEC 9899:2011) https://en.wikipedia.org/wiki/C11_%28C_standard_revision%29
If you know the exact format for the JSON data you will be receiving (and it doesn't change drastically) you can probably hack together a few loops to parse it into an array, or the like, and then printf it all out nice and formatted. But, as Aransentin said, a JSON parsing library is probably your best (and easiest) option if using exerternal libraries is a possibility in your specific situation. 
web developments and whatevers we wants :-)
[Wikipedia explains it better than I could.](https://en.wikipedia.org/wiki/C_programming_language#Uses)
C can make anything. It is inside your coffeemaker, your TV, every Satellite orbiting Earth, your automobile, cellphone, hard drive, heat/AC thermostat in your house. It is, however, not in your carpet.
But it's in the machines that make the carpet!
We from SmartCarpetâ¢ would like to disagree with your statement.
There are a number of things wrong with this program. The `add()` method does not allocate memory. It uses an instance of a variable on the stack, that once it gets out of scope is invalid, and the memory it points to is going to be reused the next time you call a function. You'll need to `malloc` to avoid this problem. You'll also probably need a `create` method so your initial object is also allocated - allowing you to implement a generic cleanup method `free`ing all the members.
&gt; Hello, im quite noob in C, I came from Python If you've never coded in a language like C, you're going to to have a very hard time parsing text yourself. It's back to the basics here and you will shoot yourself in the foot, not to mention stuff like UTF8 encoding. Your best option for writing it in C would be to use an existing library mentioned in this thread. Also, the date conversion might be a bit trickier than you'd expect :) The problem searching for strings and looking for quotes etc is that JSON is very flexible. Maybe now your text will look the way it looks now, but upgrade the software generating those log-lines and suddenly fields might be mixed up, whitespaces added, ... And not to mention escaped quotes. How are you going to handle `"this is a \"quoted\" string"`?
And another is json-c in github. Used, deployed and mature.
Is this a homework assignment? You need to learn how to use malloc() and free(). 