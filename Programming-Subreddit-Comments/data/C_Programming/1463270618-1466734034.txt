I'm on my phone so hopefully I can get these ideas across well enough :) You're on the right track. For initializing a last member with a NULL `stct_medium` you could add one more member like `{.stct_medium=NULL, .stct_speed=0}`, which fits the pattern you're already using. A convention I see a lot more often that's a little more concise, though potentially confusing, is to rely on the fact that any unspecified structure members will be set to 0, meaning if you just write `{null}` for the last member then the first element (`stct_medium`) will explicitly be set to null and all others (in this case just the speed) will be set to 0. Also, instead of having a loop counter you can use some pointer arithmetic to implement something that looks like an iterator in your loop, something like this: `for (medium_speed *m = medium_speeds; m-&gt;stct_medium; ++m) ...` Finally, in your structure definition you can let `stct_medium` just be a `char *` and not worry about specifying a particular size. Feel free to ask more questions. I'm enjoying this and if anything is lacking in clarity I'm open to grabbing my lappy to write up something less confined by my phone :)
I just changed a few things in the code from your imgur link: http://i.imgur.com/E0ZSSEA.png +/u/CompileBot C #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; int main(void) { pid_t pid; char line[256]; while (fgets(line, sizeof(line), stdin)) { pid = fork(); if (pid == 0) { char *args[] = {line, NULL}; line[strcspn(line, "\n")] = '\0'; execvp(line, args); exit(EXIT_FAILURE); } else if (pid &lt; 0) { perror("Failed to fork"); exit(EXIT_FAILURE); } wait(NULL); } return 0; } Input: date uname id ls
It works for me and for CompileBot. Did you copy and paste it? What input are you typing? What system are you on?
CYGWIN_NT-10.0 im using a txt file to store the data, and I have std as the txtfile using windows
yay removed the stackdumb and exes and compiled it again, it works. ALthough, it still doesnt work to execute other programs
in the text filea re just lines of commands to execute other programs such as ./hello ./hello1 ./hello2 and each hello's have different outputs. Later on i will use pipe to test it out with maths
You mentioned that this is for a web page. In that case if you are using CGI/fastcgi just print to the output stream. No reason to copy the strings at all.
Thanks for taking the time to respond. This does seem too complex for a response to an absolute beginner level question, but can be something to work towards. Had to do `char * stct_medium` in the structure definition to eliminate a warning about missing braces when I added `{.stct_medium = NULL, .stct_speed = 0}`. Think I'll need to spend more time getting my head 'round pointer arithmetic later, so I'll leave this working example as-is. (edit removed now uneeded include of string.h) +/u/CompileBot C #include &lt;stdio.h&gt; int main() { int loop_count; /* * * Complex table set-up * */ const char tablerow[] = "+---------------+----------+"; typedef struct medium_speed_stct { char * stct_medium; float stct_speed; } medium_speed; medium_speed medium_speeds[] = { {.stct_medium = "Carbon Dioxide", .stct_speed = 258.0}, {.stct_medium = "Air", .stct_speed = 331.5}, {.stct_medium = "Helium", .stct_speed = 972.0}, {.stct_medium = "Hydrogen", .stct_speed = 1270.0}, {.stct_medium = NULL, .stct_speed = 0} }; puts(tablerow); printf("|%14s\t| %7s |\n", "Medium", "Speed"); puts(tablerow); for (loop_count = 0; medium_speeds[loop_count].stct_medium != NULL; loop_count++) { printf("|%14s\t| %7.2f |\n", medium_speeds[loop_count].stct_medium, medium_speeds[loop_count].stct_speed); puts(tablerow); } return (0); } 
`Deviation` and `StdDeviation` should be declared where first used 
`x[y]` is always `*(x+y)`. Your formula for `a[i][j]` is incorrect, the one you gave for `b[i][j]` is the right one. I'm not exactly sure what you mean by "difference between the two notations"; but the two differences between your two cases are: * The second one uses dynamic allocation * The second one allocates a *jagged array* whereas the first one allocates a *contiguous array*. In case you are unaware, you can use dynamic allocation to allocate a contiguous array: int (*p)[20] = malloc( sizeof(int[10][20]) ); 
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;err.h&gt; #include &lt;sys/wait.h&gt; int main() { char line[256]; pid_t cpid; while (fgets(line, sizeof line, stdin)) { cpid = fork(); if (cpid == -1) err(1, "fork"); if (!cpid) { line[strcspn(line, "\r\n")] = '\0'; execvp(line, (char *[]){line, NULL}); err(1, "execvp"); } if (wait(NULL) == -1) err(1, "wait"); } } 
Probably due to invalid unicode character encoding settings in your terminal. When using UTF-8 the following should print a unicode snowman. #include &lt;stdio.h&gt; int main() { printf("\xE2\x98\x83\n"); } ☃
I have multiple files (main.c, tree.c and prints.c with their headers file) to work on and when i use o3 it gives me a lot of error/warnings :\ normally with -o this doesnt happen. For example it warn me about multiple definition of functions, indeed i have the prototype in .h files and the function in .c files
What operating system are your programming for? What is your character encoding and locale?
If OP is on Windows, he might need to use UTF-16.
True, though the apples might be a hint.
Can you show us your whole program? How do you compile the program? Are you using Visual Studio?
aghh, ive decided to skip it - it was more of a visual thing and nothing to do with functionality 
Okay. Using non-ASCII characters can be finicky due to encoding issues. 
This code is written in C++, not C. Please ask C++ questions in one of the subreddits listed in the sidebar. I removed your post.
It's okay. Just remember that C is not C++ and vice versa.
Check out the value printf returns - which is usually just discarded. It gives the number of characters printed. So you set up a variable for the table width, call it tw, then after you've printf'd what you need to print inside the table and gotten back the number of characters printed (say "nc"), then you just print tw-nc more spaces (one at a time, in a loop), then the table delimiter character.
Probably you want to be using an `else if` (and put the numCheck check first, before the number check). I can't be certain because you didn't actually post your code, though. I know because the code you posted could never compile. The only way to provide thorough answers is if you post your actual code, not you paraphrasing your code.
~~You could scan two values at a time and delete the inner loop. Something like `scanf("%f %f", &amp;temps[i][0], &amp;temps[i][1]);` might work for your needs.~~ Though looking at your example, it likely doesn't. You seem to have had it right already for scanning a column of 6 values, mostly. Try &amp;temps[i][j] instead, and check you are getting the values by printing them e.g.: for(i=0;i&lt;3;i++) { printf("%.2f %.2f\n", temps[i][0], temps[i][1]); }
What do you think the value of `num` will be if you enter letters? If you look at the documentation for [`scanf`](http://linux.die.net/man/3/scanf), the value will only be modified if the input matches the format specifier you entered. You can find out whether the user entered a valid double by looking at the return value of `scanf`.
Why not use ncurses?
Interesting link, I've only skipped around a little bit so far. I threw together some test code as a little exercise (along with enums, function pointers is the sort of thing I've rarely used): #include &lt;stdio.h&gt; typedef enum Boolean { true=1, false=0 } bool; bool getbool(bool); void getbool_retval(bool, bool(*)(bool)); int main(void) { getbool_retval(true, &amp;getbool); getbool_retval(false, &amp;getbool); return 0; } bool getbool(bool bit) { printf("getbool bit is %u\n", bit); return bit; } void getbool_retval(bool basebit, bool (*callback)(bool)) { printf("getbool retval is %u\n", callback(basebit)); }
What is the property of diagonal elements regarding the indices i and j in the chartable? Same questions rephrased: Can you find any relation between the indices of the diagonal elements of the chartable?
I cant seem to understand your question, But all i know is that for a diagonal it is in the array as follows chartable[0][0],[1][1],[2][2],[3][3] That way if i fill these with letters it should replace them but I need to do that using a string instead of filling it automatically.
I've made this function but its printing everything wrong void replacediagonal(char chartable[4][4]) { int i,j; char string[4]="PSUT"; for(i=0;i&lt;4;i++) { for(j=0;j&lt;4;j++) { chartable[i][j]=string[i]; } } for(i=0;i&lt;4;i++) { for(j=0;j&lt;4;j++) { printf("%c ",chartable[i][j]); } printf("\n"); } } Heres my output: http://prntscr.com/b4gtaq 
Nvrm, doing this has fixed it for(i=0,j=0;i&lt;4,j&lt;4;i++,j++) { chartable[i][j]=string[i]; }
Ok i've done it but how do i print the letters in a diagonal shape from right to left Heres my code to print the diagonal letters: for(i=0,j=3;i&lt;4,j&gt;=0;i++,j--) { printf("%c\n",chartable[i][j]); } Heres how my output looks like: http://prntscr.com/b4h1j0 It should look something like this: http://prntscr.com/b4gwa7 
Start with your current printing loop. Add an additional check to the body of that loop so you only print out certain characters. For example, if you only wanted to print the first column, you could do: for(i=0;i&lt;4;i++) { for(j=0;j&lt;4;j++) { if( j == 0 ) { printf("%c",chartable[i][j]); } else { printf(" "); } } printf("\n"); } Since you want the diagonal, you need to come up with a condition that's only true for the elements you want. What are the indices of each of the characters you want to print? Do you see a pattern there?
Take a look at the comment below this, ive printed the 2nd diagonal but i need to make it in a diagonal shape 4x4 like the picture.
Taking a look at this doc, which has an incomplete code sample in it might help you out. Notice that the author is recording a start and end time and then using subtraction to time the function. I don't know much about C, and definitely don't know what is going on under the hood but even with this simple example: struct tms buf; times(&amp;buf); // definitely contains all zeros here // Busy work here... (arithmetic in a large loop) times(&amp;buf); // definitely has non-zero values here printf("%jd", buf.tms_utime) // Contains a non-zero value. http://pubs.opengroup.org/onlinepubs/9699919799/functions/times.html Edit: Code formatting. See what happens when you call it twice. :)
Um... is it compulsory to use a loop at all? chartable[0][0] = 'P'; chartable[1][1] = 'S'; chartable[2][2] = 'U'; chartable[3][3] = 'T';
To reduce a fraction, you need to divide both the numerator and the denominator by their greatest common divisor (gcd). Google "Euclidean algorithm" -- that'll find the gcd for you. There is no loop. The failure of `if (d==0 || b==0)` ensures that d != 0 &amp;&amp; b != 0, so the explicit test in `else if ( b != 0 || d != 0)` is always true and therefore pointless. Your calculation for the first multiplication case is wrong -- e.g., 1/5 * 1/5 is 1/25, not 1/5. There's a great deal of redundancy throughout the code that you'll probably eliminate once you have your Euclidean algorithm in play. When dividing fractions, `c` also mustn't be zero -- e.g., 1/3 / 0/5 is invalid. math.h isn't needed in the above code.
In addition to what FeelTheEmailMistake says, I would create a struct rational , and operate on it. It'll be cleaner in the end, an example: struct rational { int n; int d; } struct rational rational_add(struct rational a, struct rational b) { assert(a.d == 0 &amp;&amp; b.d == 0); struct rational result = { a.n * b.d + b.n * a.d, a.d * b.d }; return result; } In such a small application it might not be worth it, but I'd do it anyway for clarity.
 typedef struct { char first[8]; /* 0 */ char initial[2]; /* 1 */ char last[10]; /* 2 */ char street[17]; /* 3 */ char city[12]; /* 4 */ char state[3]; /* 5 */ char zip[6]; /* 6 */ int age[3]; /* 7 */ char sex[2]; /* 8 */ int tenure[2]; /* 9 */ double salary[6]; /* 10 */ }Payroll; /* 0 1 2 3 4 5 6 7 8 9 10 */ printf("%s %s %s %s %s %s %s %d %s %d %f\n", company[i].first, company[i].initial, company[i].last, company[i].street, company[i].city, company[i].state, company[i].zip, company[i].age, company[i].sex, company[i].tenure, company[i].salary); Match up the arguments Name | printf Arg | Struct type ---|---|---- first| string| char array initial| string| char array last| string| char array street| string| char array city| string| char array state| string| char array zip| string| char array age| decimal | int array sex| string| char array tenure| decimal| char array double | float| float array A char array, if \0 terminated can be handled as a string, entries 0-6 and 8 inclusive are OK As for 7, 9, 10. An array is the incorrect type for a numeric specifier. And besides, Sure, all the provided first names fit in 8 characters, but why would a person have 6 salaries?
ok. Thanks for the info.I fixed it
Thank you for being so patient. Really is the bread and butter of this sub.
I was attempting to manually remove the newline character from the character count so I would end up with an accurate number of characters. reading up on strtok now...
What have you tried? Don't ask us to do your homework please.
Try `strcspn`: string1[strcspn(string1, '\n')] = '\0'; This does the right thing.
That's exactly why I always put curly braces, even if it's a simple small statement. It saves a lot of headaches later on. =P
strtok is marked deprecated in favor of strep
What's your question here? How to create a queue?
That method of removing a newline is unsafe. Consider: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char b[256]; unsigned long n = -1; fgets(b, sizeof b, stdin); b[strlen(b) - 1] = '\0'; printf("%lx %s\n", n, b); return 0; } Then: $ printf "test\n" | ./prog ffffffff test $ printf "\0test\n" | ./prog ffffff i.e., it can write to b[-1].
You need a [loop](http://www.cprogramming.com/tutorial/c/lesson3.html). In this case, I would suggest using a `do...while` loop to check if the input is option 3.
Wrap the main program in a while(true) {} loop, which will keep prompting the user until they select the exit option Further advice: Don't just make the else condition a catch-all exit. You specified that people should press 3 to exit, so that's what the program should accept. If they type 12 for instance, tell them the input was not understood and give them a chance to try again.
Hmm I don't get it, can you explain a little? Explain it in the else if (a == 2) statement. 
hmm I got it. I am trying the loop thing but cannot get hold of it can you explain with a example? ------ sorry for the trouble 
A loop does things multiple times. You want to do things multiple times. Take all the code you want to repeat (so printing the menu and doing something based on the input), and put it inside a loop. The link I posted describes the different types of loops in C. Since you definitely want to run your code once, and maybe want to run it again, I suggest a `do ... while` loop. 
I will try and if I cannot get it to work. I will get back to you! thanks for the help tho :)
I think you mean strsep. Either way, they're pretty similar unless you care about empty tokens or you're writing a library. 
He wants library function that will do it, i guess that he meant
A friend told about something about bubblesort or something so I could sort out the array elements and then I could find the most frequent number, but I'm pretty sure my professor didn't say anything about this during the class so I don't think that's how I'm supposed to work it out
Bubble sort is sorting array in ascending order, i think that isnt usefull pretty much
Nice, gj 
It does give you some interesting properties, like grouping the numbers (you end up with 1,2,3,3,3,4,4,5,5,5...). This makes the counting algorithm easier, but overall I'm pretty sure it's adding additional overhead.
I would probably use a hashmap for (int x : array){ If (hashmap.containsKey(int x)) //increment value else //insert with value 1 } sorry for the crappy pseudo-code
that sounds like it would cut a word in half and that isn't what I want to do, I want the number of words halved so the sentence is a first half and last half but all the words are complete words. 
how I trim the newline character is irrelevant, that part of the code works as intended.
would I count the spaces as the ascii character or a 0 (considering it's being loaded into an array)? 
As an array of characters is a string, you'd most likely just check if the char being looked at is equal to `' '`. You could compare ascii numbers I suppose, but it would be easier to work out what your code is doing if you revisit the program later if you compare actual characters.
Sort the array, then count how often each element appears. Take the one that appears most often.
I have never heard of the 'Selection Sort' algorithm, so thank you for showing me another way I can learn how to do it. This code was taken directly from the book, where it described this as the 'Bubble Sort' algorithm. The only thing I changed was entering the values in manually, as opposed to randomly generating the values, because it was easier to follow when stepping through the code. I guess my real question was whether or not a condition could be made, such that it would acknowledge the smallest value, while organizing the rest, while still incorporating 'didSwap' as a flag for optimization. But the issue I was seeing was that this program (what the book calls bubble sort) was supposed to execute multiple swaps within a single iteration, which it was, except for the case when the smallest number was already on the top of the list. As said, 'didSwap is only useful to know whether your array is sorted or not, and nothing else', which is true, but it does not provide the correct information when the smallest number is atop the list. It simply stops sorting leaving everything as it was. Since I can't break an iteration and just jump to the next element, I guess I can't really incorporate the flag(didSwap) . Thank you for your response. Sorry for being difficult :D
seeing as how the array size is a max of 254 characters, there is a potential for a lot of blank characters if I count all of them, how do I stop at the entered string length?
It appears that gdt.flags is taking up a full byte, and as a result gdt.upper_limit is also given its own byte. http://ideone.com/eLdzXj
Just to make thinks clear, I really don't recommend this kind of bit madness, but well, I too played with them on the past. You can't just sum the total of bits :D Byte is still the smallest unit of data the computer can process and will always round up to a multiple of bytes, any bitfield you have **per variable/struct or whatever you have**. So not necessarily in this order, your pc at time to assign memory for your gdt struct it will be like (sum of bytes are inside ()): static struct __attribute__((packed)) { unsigned lower_limit : 16; //You want 16 bits for this? //Fine, I like that number. //It will be 2bytes (2) unsigned lower_base : 16; // 2 bytes (4) unsigned mid_base : 8; // 1 byte (5) struct __attribute__((packed)) { unsigned accessed : 1; unsigned rw : 1; unsigned direction : 1; unsigned execution : 1; unsigned _garbage : 1; unsigned priviledge : 2; unsigned present : 1; } access; //8bits for this struct? //Fine, you got 1byte (6) unsigned upper_limit : 4; //4bits for this variable? //wth, I can't work with 4bits //It will be 1byte, man. (7) struct __attribute__((packed)) { unsigned __garbage : 2; unsigned size : 1; unsigned granularity : 1; } flags; //4bits for this struct? //again? //1byte! (8) unsigned upper_base : 8; //1byte (9) } gdt; And there you have your 9bytes. I hope I made it clear.
[Fixed](http://ideone.com/NLevSG). Unfortunately, it doesn't look as pretty as I wanted it to, but its nothing compared to code that works. You've no idea how many hours of potentially debugging triple faults you probably saved me. I should have known that it would round up to a byte, because as you said a byte is the smallest unit of data, I just assumed that the inner struct would be inlined into the parent struct (if that was possible). 
wouldn't this be the same: double *array[N] = malloc(blah);
This is quite useful http://img.blog.csdn.net/20130710135832062
Output from valgrind: ==9675== Bad permissions for mapped region at address 0x4024000 ==9675== at 0x400CE3: main (shm.c:77) Line 77 is: sprintf(shm_base, "%s", "OK"); Try commenting out that line and see what happens. There are some other issues, but this should point you in the right direction.
You are correct. The call to mmap in the child process needs PROT_WRITE. As for other issues, I only skimmed your program but I assume you want the parent to do something with the shared memory after the child finishes. If so, you need wait() or waitpid(). 
Program: A pointer to the array of pointers for "realMatrix" structures needs you to give it the amount of memory that can hold a 2D array of double matrices. Kernel: Okay, don't spend it one place kiddo. Other programmer later: What the fuck? Edit: factual error
Not sure if anyone's mentioned this, but you can make that `printf` statement more reasonable in column length by doing something like this: printf("Hello " \ "World!\n"); You can use a `\` to continue strings on more than one line. I might have the syntax a little wrong, but I'm pretty sure that would work.
Is this meant to be a tutorial? If so it shouldn't be posted as a question (flair), more so you should be using something like [gist](https://gist.github.com). The examples should be better documented too and progressively get more complex. If this is a question I have no idea what the question is.
You appear to be shadow banned. Please talk to the admins to rectify this issue.
Why does it require sqlite3? You can just bundle the SQLite3 amalgamation with the project and be done with it, compile it right in.
No it's not a tutorial at all. I need to complete the code. If I have a text say, "Hello everyone, how are you doing?" and the length of this string is bigger than the limit that the code sets, I wanna know how can I dot it in fragments like, "Hello everyone, h" "ow are you doing?" but only use one queue.
ubuntu :/ still thnx and I've fixed just a couple of days ago
The most standard way would be to use a library. It's tedious code to write and get correct. Libraries also make it consistent among applications. There are GNU libraries for this: http://www.gnu.org/software/libc/manual/html_node/Parsing-Program-Arguments.html
Linux, which means I like to use `unistd.h` and get as much POSIX as possible
thank you :) I will check this soon, seems reasonable :) 
Well.. the complete test is if there's no more char after you passed it and the word who contains that char starts with the unique remain char before it, you really know, you can't transform a into b
"separate lines" ? So.. can we assume it's a text file?
I am intimately familiar with the man pages (both at kernel.org and opengroup.org). I can always look up what I need to know, but it takes time. I think this kind of tool would be extremely useful, to just quickly explain a format string. So for example: $ printf-explainer "%s" print a null-terminated string $ printf-explainer "%lld" print an int64_t $ printf-explainer "%2.3f" print a double with minimum width 2 and 3 digits after the decimal place` There should be an option to use concrete types on the current platform (uint64_t), and an option to use abstract types (long unsigned integer) minimum length, precision, $d notation for positional args, etc ...
Can you be a little more precise in your question? What exactly do you not understand? Where are you stuck?
Talk about analysis paralysis.
In order for us to best help you, I would suggest you first learn how to reddit, so your question becomes formatted correctly. Then let us know how you are reading the data in the file (e.g. providing the properly formatted source code), as we would base help we provide on this.
I'd say the argument that "char* p, q, r, s;" is unclear isn't really valid (at least not anywhere I've been), as any coder I know would frown at declaring variables on the same line like this.
&gt;any coder I know would frown at declaring variables on the same line like this. \#NotAllCoders In all seriousness though, I see declarations like this every day at work. Yay legacy code.
 if(dec==add) You haven't initialized `add` at this point, so this comparison is invalid. Each operation has a similar error.
What do you want that line to do?
As a general warning: The suffix `_t` is reserved by POSIX for system types. I recommend not to use it for your own things.
If you're willing to change the parameters of the problem, sure. If the user enters "a", "s", "m", or "d" you could do this: if(dec=='a') Instead of if(dec==add) 
You can initialize like so: add = 'a'; // Sets 'add' to ASCII value of 'a' I suggest you go through a tutorial or two before diving into a small project like this. You need to understand how pointers work before using functions like scanf. This is a decent tutorial you can try out: http://www.cprogramming.com/tutorial/c-tutorial.html
Right, a char holds 1 byte of data, or 8 bits. You can store an ASCII character in one since ASCII only requires 8 bits. If you wanted to store "add", you'll need to use a C-string a.k.a. an char pointer, like so: char *add = "add"; And to compare this string to another, you'll need to use functions like strncmp. Simply using "==" won't work since it'll compare the pointer address.
As a general retort, my code may follow whatever conventions I (and/or my team as appropriate) wish my code to follow.
You can ignore standards all you want. Just don't complain when it doesn't compile anymore due to you violating the standard. This is a large problem: Imagine you finish the project and don't use it for five years. Then you want to use it again but it doesn't compile anymore because you violated the standard. Now you need to understand and fix your program just because you where that thick-headed in the beginning. Don't write code that violates standards, it doesn't pay off at all.
C doesn't have a string type, what you use are arrays of chars that end in a zero (null terminator character '\0'), the function they linked will compare each letter until it hits that null terminator, it will return you a value that tells you the result of the comparison (those values are in that strcmp link). I would read about arrays and memory layouts in C if you're really serious about learning this. I am sure there are plenty of us who are willing to answer some questions.
ISO 9899:2011 would be great, ISO 9945 would be great too.
&gt;I just don't get why type casts are bad Because they're all the same thing: a bunch of bytes. Don't try to convert bytes to bytes. I recommend you use `stdint.h`. &gt;I stopped trying things like that because I heard it was insecure Yup, don't mess around with pointers. Security isn't the main concern though. it's just that `int` type variables have a *limit*. Their maximum value is about 2.1 billions. Now if you're programming for systems with less than 2.1 GB of memory, fine. But what if I wanted to use it? I have 32GB. Your type casting *won't work*. Pointers are 8 bytes wide (64 bits), while `int` is a data type that is 4 bytes wide (32 bits). So, to conclude, just **never ever cast any kind of pointer to an int`**. If you however need to (which is extremely unlikely since pointers are automatically cast to something else when you perform arithmetic operations on them) cast your pointers to a more "common" data type, you should use the `uint64_t` data type, defined in `&lt;stdint.h&gt;`. **EDIT**: Bonus: As stated before, all data types are the same thing: a bunch of bytes. You can compare `char`s like they were `int`s: char a,b; if (a == b) write(1, "They're equal!", strlen("They're equal!")); It'll just compare their **ascii** value (go to your terminal and type `man ascii`)
https://github.com/google/sanitizers
Have you tried a debugger (e.g., `gdb`) and stepping through the program? 
Working with BIOS/UEFI
I think you left out some of the code. hashFunction1 and hashFunction2 aren't defined anywhere. Also, the prototype for nextWord (line#7) of your main.c is missing a semicolon at the end. Usually the way I start a problem like this is to compile it with full debugging symbols (compiler option `-ggdb3` ) and then run the program in the GNU debugger, gdb ( `gdb ./program` or if it takes arguments `gdb --args ./program --some-option` ). You can then type `r` to run the program, or set a breakpoint at a function like main first with `br main` and then run it, etc.. You step through the code when it reaches a breakpoint (program is still running technically) either with `step`, `stepi`, `next`, or `nexti`. If/when it does crash, the debug symbols should at least give you a line number or something so you can tell where it's crashing. You can even look at the value of local arguments/variables (when you're at the breakpoint and actually stepping through the code of a running program) with commands like `i loc` and `i var`, if the values haven't been optimized out. If they have, removing optimizations with the compiler flags `-O0` or `-O1` can (usually) fix that. gdb is one of these programs with a fairly steep learning curve, but it's incredibly useful once you pick up some of the basics. 
Is it covered under `-Wall`? Or are they separate? Edit: On further reading it seems to be a non-zero cost, does anyone have experience with it and performance penalties?
If possible please include a ref to where _POSIX_ actually reserves this, and not just for uint* and int* types.
I don't understand what the program is supposed to do. Could you explain?
[removed]
The objective of this project is the development of two programs together implement a simulator of a SMSs system among multiple users . The first program is the server . This program manages the entire service SMSs carrying out two main functions: (i ) authenticate users ; and ( Ii ) re- route the messages you receive from each user for the user destination of these messages . In this context , this program is the center of all SMSs system that works only when the server is running. The second program to be built is the customer. this program It is run by each user to start your session in the SMS 's service. After authentication is made ​​by communicating with the server , the user becomes have available various services that we will detail below, but go the idea of ​​being possible to send messages ( SMSs ) to users who are online. All SMS 's system is to run on a single computer. this means say that the communications system that implements are communications between programs running on the same computer.
ahh, just realised do you mean a pre-ansi C version or a bibliophile 1978 version?
The copy I have says ©1978, not sure what you mean.
Assigning `link1-&gt;key` does not make a copy of `key`: It causes `link1-&gt;key` to point to the same data as `key`. Obviously `link1-&gt;key` is not `const` but `key` is and since they point to the same data making changes to `link1-&gt;key` would affect `key` as well, violating constness. The right thing to do is to use `strcopy`. However, doing so requires `link1-&gt;key` to already point to some allocated memory and it seems you are not currently doing so.
&gt; replacing with strcpy(link1-&gt;key, key); causes core dump Well of course it does, because `link1-&gt;key` is uninitialized garbage, so you're asking `strcpy()` to write somewhere randomly, invoking undefined behavior. `link1-&gt;key` has to actually point somewhere valid (such as a buffer that you allocated to have sufficient storage for the string and its null terminator) before you can use `strcpy()`. What you're doing in the original version without `strcpy()` causes sharing of the key between the caller and the hash map. Maybe that's what you want, maybe not. (Probably not.) That's because you're taking a pointer to a key and then storing a copy of that same pointer in the hash map. But you never actually duplicated the key anywhere. If the caller changes it, your hash map is now hopelessly corrupt. For example, consider a usage like this: char line[64], key[64]; int value; while(fgets(line, sizeof(line), some_input_file)) { if(sscanf(line, "%s %d", key, &amp;value) == 2) { hashMapPut(some_map, key, value); } } This is a very common way of reading a bunch of key/value pairs from a text file and putting them into your hash map data structure. But this reuses the same buffer to store every key. That's usually fine, because there is an expectation that the data structure will make a copy of the key, and it's not the job of the caller to worry about that. Your code does not do that, so this example will fail horribly. The caller would have to worry about allocating a separate buffer for each key, and then deallocating them when everything is done. That's usually the job of the container. So just writing `link1-&gt;key = key` is bad, and it has absolutely nothing to do with the warning that you're getting. The warning is just saying that you were passed a pointer to a block of memory that you said you were not going to modify, but now you're forming a modifiable pointer to that block of memory. That's the kind of thing that usually leads to a mistake, which is why the compiler warns you about it. But as long as you don't actually try to modify that buffer, then you're not doing anything wrong. ("not doing anything wrong" in terms of const correctness, not in terms of key sharing.) To fix the warning use a cast, or better, make the pointer const in the map data structure, since you shouldn't be modifying keys there anyway. So you need to fix the key sharing, but you can't do that just by adding a `strcpy()`. (If that's what you got from reading SO, you need to read more carefully.) You have to understand the lifetimes of all of these buffers. You'd need to allocate a buffer to store the key, copy the key into that buffer, and then remember to free that buffer in whatever function is responsible for removing an entry from the hash table. 
Great Discussion. Keep Going on. http://knowledgeofindia.com/rivers-of-india/
Does anyone know what happened on December 15th, 2015?
i guess he didnt heard for gdb and breakpoints, otherwise this is 2 min discovery where is segfault
It's definitely not covered under `-Wall` on either. It's not a compile time feature but a run-time. Has an associated cost where the runtime is validating the behavior of various operations. AFAIK, it's not for production use. It's meant for development and testing only.
Story time! I took a class on programming in C in high school. I had already been programming for a long while, so I often took the assignments and ran with them, going well beyond what was required. So even though most of the class was just review, i still learned a lot. When the class was covering switch statements, the assignment was to create a point-of-sale system: the user selects an item from a menu and inputs a quantity, the program calculates the total plus tax. I decided to give my program an administrative feature, so the manager could go in and change the prices and tax rate. So far, so good. But you don't want *anybody* changing the prices, so the feature had to be password protected. And I wanted that password to be hidden as the user typed. So, what to do? I found out that `getch()` will read a single character *without echoing it to the screen*. Perfect! So I read in the password character-by-character into a string, compared that to the built-in password, and done! It worked perfectly, until I did some testing. Every wrong password I tried didn't match, as I had hoped. I even tried the correct password with a bunch of garbage at the end, to make sure that failed, too. Which it did. And then when I entered the correct password, it let me in! Perfect ... but what's this? Now the item prices are all messed up! How did that happen? I discovered my first buffer overflow. I never checked the user didn't enter too many characters, so when I entered the correct password with some garbage, it went outside the buffer and overwrote other things on the stack. Including the prices for the items, *the exact thing I was trying to keep protected*. I never experimented with trying to poke in specific prices using the buffer overflow -- I did enough tests to verify that what I typed changed the values in interesting ways and left it at that (and then fixed the overflow error). That would have been fun, though.
Yeah i've read the docs man thanks, but like when it says the apr_pool_t, it just says the standard pool type? what is the standard pool type?
Which would make any identifier starting with to[a-z] for example reserved as well if ctype.h is included, or E[A-Z] if errno.h is, which is quite amusing. Oh, and never use an underscore prefix. It's worth nothing that _many_ well known and well used libraries take these reservations with a grain of salt. 
Thanks for taking the time to reply, very constructive. ; )
(Note: that's a long video, some timestamps would have been helpful.) &gt; He then declares and initializes an integer variable int x = 2 He's doing some pseudo-C that ignores variable types. In proper C, if 2 represents an address, this should actually be declared as `int *x = 2;`. And then when you do `printf("%d", *x);` you get what he's talking about. &gt; What does this refer to: (*(&amp;(&amp;(&amp;(*(*(*x))))))) Meh, ignore this, because he came up with an example on the fly that ended up trying to take the address of an rvalue, which you can't do logically. You can take the address of a variable, you can't take the address of a number. It's a meaningless operation. That's really all there is to it. &gt; Then he says main calls another function, called task(), and places it underneath main, which is what I would expect as the stack at least typically grows downwards I think. But then he removes the frame underneath main and explicitly states, "actually let's say it's above main, because that's more likely where it would be stored" and puts it back into place above main, closer to higher memory addresses I couldn't find this spot very quickly, so I'm just speaking off the cuff here. On some machines, the stack grows upward. On some machines, it grows downward. It doesn't matter unless you're writing assembly, which you aren't. It sounds like he got confused on which convention he wanted to show and flopped it around confusingly. &gt; In general, to be honest I find the lecture rather confusing than anything else, he seems to be uncertain himself on various things he says. I'm just wondering I mean I'm a beginner and he's a professor, the video has 300k views and like 98% thumbs up, people are praising it everywhere. He's a very good teacher, from the few parts I watched. But he's also a bit sloppy, and I think that's where you got confused. Try to stick to the broader concepts that he's teaching, then pick up the details he's leaving out later.
CWEB is my literate tool of choice: I love it. And I'm pleasantly surprised to see a post here! Nice work! I'd love to see more developers embrace literate tools, but I can barely get my peers to comment code effectively as it is :)
I haven't watched this video but if your description is accurate it sounds terrible. Treating pointers as glorified integers leads to misconceptions.
I've removed your comment as it is not a submission to the contest.
http://www.apachetutor.org/dev/pools
I don't think he was contradicting himself while talking about the stack. He just said 'up there' and 'down there' but never mentioned higher or lower memory addresses. Actually, his drawing is consistent with a stack growing towards lower memory addresses. He said that the text segment is 'up there' (it's at lower addresses) and let his stack grow towards this area, therefore the stack grows upwards, which in his drawing means towards lower memory addresses. The example with pointers seems to be sort of nonsense, though. It's at very least confusing. I think he came up with that on the fly and didn't really think about it before his lesson. While I don't think this guy is a bad teacher at all, I also believe that this &gt;I'm just wondering I mean I'm a beginner and he's a professor, the video has 300k views and like 98% thumbs up, people are praising it everywhere. doesn't necessarily say anything. There are a lot of videos of respectable universities which really aren't that good but get hyped because of the name. Post 'Free Lectures from Stanford' in /r/programming and it would have 5000 upvotes and people praising it, even if it was some sort of troll video spreading nonsense, guaranteed. Also, a lot of people need teachers who are sort of enthusiastic and motivating or have a relaxed atmosphere and score that higher than strict technical accuracy. 
I don't think I get it. It seems like very thorough documentation to me. Almost like text book level documentation.
Output: 512 { 0 e [^source](http://ideone.com/RmFwJv) ^| [^info](http://www.reddit.com/r/CompileBot/wiki) ^| [^git](https://github.com/renfredxh/compilebot) ^| [^report](http://www.reddit.com/message/compose?to=compilebot&amp;subject=Report%20Abuse&amp;message=--report%20https%3A//www.reddit.com/r/C_Programming/comments/4k6zl7/macro_definitions_of_functions_in_the_standard/d3cn9tl%20Include%20your%20reason%20for%20reporting%20here.) 
7.1.4p1: &gt; Any invocation of a library function that is implemented as a macro shall expand to code that evaluates each of its arguments exactly once, fully protected by parentheses where necessary, so it is generally safe to use arbitrary expressions as arguments. +/u/CompileBot C #include &lt;stdio.h&gt; #include &lt;ctype.h&gt; #define myislower(c) ((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'z') int main(void) { const char *cp; cp = "h{ello}"; printf("%d\t", islower(*cp++)); printf("%c\n", *cp); cp = "h{ello}"; printf("%d\t", myislower(*cp++)); /* (('h') &gt;= 'a' &amp;&amp; ('{') &lt;= 'z') */ printf("%c\n", *cp); return 0; } 
Output: 512 { 0 e [^source](http://ideone.com/q8vNZM) ^| [^info](http://www.reddit.com/r/CompileBot/wiki) ^| [^git](https://github.com/renfredxh/compilebot) ^| [^report](http://www.reddit.com/message/compose?to=compilebot&amp;subject=Report%20Abuse&amp;message=--report%20https%3A//www.reddit.com/r/C_Programming/comments/4k6zl7/macro_definitions_of_functions_in_the_standard/d3cnt6w%20Include%20your%20reason%20for%20reporting%20here.) 
That threw me for a sec. I didn't know glibc's islower() can return a nonzero value other than 1, even though it's allowed to do so. *BSD libc returns 1. +/u/CompileBot C #include &lt;stdio.h&gt; #include &lt;ctype.h&gt; #define myislower(c) ((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'z') int main(void) { const char *cp; cp = "h{ello}"; printf("%d\t", !!islower(*cp++)); printf("%c\n", *cp); cp = "h{ello}"; printf("%d\t", !!myislower(*cp++)); printf("%c\n", *cp); return 0; } 
Thank you. "Evaluating each of it's arguments exactly once", didn't register with me the until I walked through your example.
Not only for a novice documentation is required. A project without documentation is doomed to fail.
A linked list would waste quite a lot of memory. I assume you use a 64-bit processor, so pointers will be 8 bytes in size. For a singly linked list you need one pointer for every character you store, resulting in 9 bytes of memory per character instead of just one when using an array of chars. When using a doubly linked list you need 17 bytes of memory fore very character, 16 bytes for the two pointers and 1 for the character. Maybe use a dynamically allocated array (use malloc()) and make it big enough to hold any string that will occur. If at some later point it is still too small, you can still use realloc() to make the array bigger.
I think it could reduce maintaince a lot - promoting more code reuse and clarity as to what in the world is going on. For simple or self explanatory code (depending on the project, usually the majority) I guess you wouldn't have to do much on the documentation side of things, although of course "simple or self explanatory" may be different to each developer, and you always have laziness...
[removed]
This is tangential to your question, but a [trie](https://en.wikipedia.org/wiki/Trie) is a practical example of storing a string across a linked-list type of structure. I personally prefer tries to hash tables when my keys are always NUL-terminated strings.
This guys is like software version of Donald Trump.
You should not nest X times where X is large. As a rule of thumb, if you need more than 3 levels in nesting, you should be factoring code into units better.
One thing C lets you do that is more difficult in higher level languages is actually know/control the exact layout of a data structure in memory. This makes it easy, for example, to keep arrays of structures aligned to cache line boundaries. CPU cache behavior is *very* significant for performance. It wouldn't surprise me if higher level languages also sneak more conditionals behind the scenes (e.g. for keeping track of run time type info in a dynamic language), which may hurt branch prediction performance. That sort of thing might generally be done through pointers to dispatch tables (like C++) though. I don't know. It's hard to get a handle on these things, but if [the Debian benchmark game](http://benchmarksgame.alioth.debian.org/u64q/which-programs-are-fastest.html) is at all representative, higher level compiled languages seem to be 1-4x slower than C, and higher level dynamic languages are anywhere from 1-100x slower, depending on what the program needs to do. In general, I'd expect higher level compiled languages to outperform C at some point, but it seems compiler technology isn't quite there yet.
The code you wrote should work just fine. What's the problem?
I'm sorry that I cannot address unspecified constraints. Perhaps you could show us the actual code instead of something that has the important parts removed?
Did not know that, thanks
So you are sure there is no way around actually computing the n^7 arrays? Well, then there are still possibilities (e.g. you can use some sort of carry logic), but the seven nested loops are probably as it can get.
In this case, use the carry approach I discussed in my previous comment. Are you sure there is no other way than guessing each number? Sounds like an awfully inefficient algorithm.
That's because integers can only hold values that large. And I'm not sure what you try to achieve with that `sizeof`. Do you know what `sizeof` does?
What goal are you trying to achieve by guessing the user input? Couldn't you just take the user input directly?
&gt;a lot of the syntax has changed For example? I've been working through K&amp;R and I don't seem to have any issues with syntax thus far
I come from a gamedev background, and have worked on many performance-sensitive projects outside of gamedev, and it just feels like I have more control over exactly what's going on with the machine running my code. This allows me to really push the performance of my project and optimize it for speed and responsiveness. One of the recurring situations in performance-sensitive projects involves updating many objects in a realtime fashion, and I can fine-tune how their data structures are organized and how extraneous data is accessed, and how exactly inner loops are executing. These situations can yield the largest performance hits when they generate many cache misses and having fine control over the code allows me to get them running at top speed by maximizing cache coherency. The optimized end result and the original naive rough draft are like night and day, in terms of performance. 
Your idea to implement a function to handle element length saved me a lot of trouble, thanks!
Spolsky is always spot on about things. 
Have you read the error messages? You should be able to sort out the 1^st one on your own main.c:2: error: expected ‘;’, ‘,’ or ‘)’ before ‘c’ int main(int arg c, char* argv[]) The `expected` part isn't totally obvious, but `before 'c'` is a giveaway. For the 2^nd, you need to pass a pointer to scanf so it knows where to put the integer it read. Since you're doing this in a function, the function `userInput` should take a pointer to an integer, which can then be passed to scanf. 
To check if calloc failed, you will need to use `if (a == NULL)`. You will also need to declare `a` as a pointer, instead of an `int`, so that it can hold the pointer returned by `calloc`.
&gt; In general, I'd expect higher level compiled languages to outperform C at some point, but it seems compiler technology isn't quite there yet. What? How? If you can do the ridiculous job of having a compiler of higher level language than C output a code closer of **the most efficient architecture's machine code** for a particular job, than an C compiler can output, you could do it more easier from C. You can have is (and it's already a reality for a long time) high level algorithms which are so so fast to code in a higher level language than C such the efficiency loss is so minimal that you can live with it. I would like to be corrected if I'm wrong in some point.
Would it look something like this? #include "my.h" int main(int argc, char* argv[]) { int i, *a, count, user_input; FILE* p; p = fopen("r",argv[i]); fscanf(p,"%d",&amp;count); a = (int*)(calloc(count,sizeof(int))); if (a == NULL) { printf("Error:Calloc failed.\n"); } if(p==NULL) { printf("Error: cannot read file.\n"); return; } 
Should have mentioned the "native widgets" part in the title, that seems like the feature that distinguishes it existing stuff like Gtk.
Yes, you have the right idea.
Pretty impressive, IMO. There is some documentation in the file "buildnotes". To build the example "controlgallery" run make EXAMPLE=controlgallery then just run it ./out/controlgallery
Thank you for your help! I have one more question.. I just got this compile error main.c:(.text+0xda): undefined reference to `oddeven_sort' collect2: ld returned 1 exit status and when I try to compile my sort function I get sort.c:(.text+0x7e): undefined reference to `swap' sort.c:(.text+0xf4): undefined reference to `swap' Here is the code for sort #include "my.h" void oddeven_sort(int x[], int size) { int sort = 0, i; while (!sort) { sort = 1; for(i = 1;i &lt; size-1;i += 2) { if (x[i] &gt; x[i+1]) { swap(&amp;x[i], &amp;x[i+1]); sort = 0; } } for (i = 0;i &lt; size - 1;i += 2) { if (x[i] &gt; x[i + 1]) { swap(&amp;x[i], &amp;x[i + 1]); sort = 0; } } } } and heres the code for swap #include "my.h" void swap(int * x, int * y) { int t; t = *x; *x = *y; *y = t; } Would I have to call these functions in "my.h"? 
You have to pass a pointer to `scanf`. `scanf` is being called in `userInput`, but the value has to get back to `main` somehow (maybe .. you don't show how `userInput` is used). So you can either do void userInput(int *user_input, int a[]) { scanf("%d",user_input) } or int userInput(int a[]) { int user_input; scanf("%d",&amp;user_input) return(user_input); } 
hmm.. I did this and am still receiving compile errors. Here is my my.h #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; void swap(int * x, int * y); void oddeven_sort(int x[], int size); int main(int argc, char* argv[]);
Try compiling everything with one command; eg, gcc sort.c main.c [put any other .c files you have here...] -o myprogram ...where "myprogram" is replaced with whatever name you want the compiled program to have.
lmao.. I got another compile error main.c: In function ‘main’: main.c:8: warning: incompatible implicit declaration of built-in function ‘calloc’ main.c:25: error: too few arguments to function ‘oddeven_sort’ main.c: In function ‘userInput’: main.c:32: warning: comparison between pointer and integer main.c:36: error: array subscript is not an integer I'm going to give you some gold for all your help. This has been a real bitch and I appreciate your time
Would you please not remove your posts after receiving an answer? That's really shitty.
I answer questions so they are useful for future readers. Deleting your question removes that use. This rule exists in many other places, too, such as Stack Overflow.
Hyperbole. From a brief look, this project has a small, simple, idiomatic API with good examples and a well organized header file that any non-novice GUI programmer could get started with in no time.
Unfortunately it isn't completely simple to avoid, e.g. `qsort` does virtual calls.
In addition to everything that has already been mentioned the ability to write inline assembly allows complete control over exactly what the processor is doing, intrinsic X don't cut it sometimes and nothing lets you squeeze more performance out of your cou than Assembly. 
LoL. Very nice.
&gt; Joel Spolsky: "The three things I would tell people to learn are economics, writing and C programming."
Why did you post your [previous question](https://www.reddit.com/r/C_Programming/comments/4k9p4v/oddeven_sort/) again?
I had a different question.
Are you getting any compiler warnings/errors when compiling with `-Wall` and `-Werror`? Right off the bat I can tell you that your arguments in `fopen` are swapped. The first argument is the filename and the second is the mode. Also `fopen` comes from `stdio.h` which you have not included. I would suggest testing small sections of your code, and then putting each section together to form your program. `printf` is your friend in debugging. Right after you attempt to open a file you should check if it was successful: #include &lt;stdio.h&gt; int main(int argc, char* argv[]){ FILE *fp; fp = fopen("file.txt", "r"); if(fp == NULL){ printf("File not found"); // Exit the program return -1; } printf("File found! Continuing"); // Continue the program return 0; } 
Now would be a good time to familiarize yourself with gdb. With a debugger it would be trivial to see exactly where and what is causing you to segfault. A backtrace of the stack would be a good starting point.
You can do it. Linux is usually a little easier just because of the package manager that is pre-installed with your distro. If you need a new tool (like, let's say, valgrind), it's just one command and about 5 seconds away. I know there *are* package managers for OS X, but I haven't kept up to date on how well they work, how many packages they support, how well they're maintained, etc.
Should check for ESRCH on the kill call to see if the pid actually exists (could probably remove the %4 check then).
The gcc debugger needs some massaging to get working on OSX, but other than that it works pretty well.
I consider the primary concern, when optimising time, to be the consideration given to the choice of data structures, and the growth rates of the processes that operate on those data structures. Beyond that there are plenty of other factors, and should only be considered secondarily IMO. The optimal language depends upon the compilers you have available and how well they translate source code to the host you wish to run your software on. The optimal method of reading or writing from disks/networks/etc depends upon buffering methods used by operating systems and the quality of their drivers/libraries as well as the speed of the networks and disks. The considerations go on and they become meaningful only in certain cases, where time is important and where a bottleneck has been pinpointed ... With that said, C does give you a larger degree of responsibility in comparison to a language like Python. It is unclear to the programmer, the growth rate of a head insert v.s. a tail insert of one value to a list in Python, one simply writes `lst.insert(0, value)` or `lst.append(value)`. However, in a programming language like C, it is the responsibility of the programmer to implement these procedures themselves. So in that regard you may consider it a trade-off; you have to write more software, but in exchange you have more control over the structure of your data at a lower level. (Although in the case of C, this responsibility could very well be passed to an external library, so it is not necessarily a given, it depends largely on the programmer.)
You don't need Linux to run valgrind. Edit: http://valgrind.org/info/platforms.html
My personal preference for those conditional checks would be to make it explicit what you're checking for. So while (str[i] != '\0') ... if (getuid() != 0) ... if (n == 0) ... instead of while (str[i]) ... if (getuid()) ... if (!n) ... I doesn't take long to work out what your version does, but having to think about it at all sort of pulls me out of the flow of the program. And the compiler most likely optimizes all of that away, so it shouldn't make a difference in the end result anyway. And I'm not crazy about GNU brace style, but let's not have that discussion.
I'm a believer in learning to program on the system you actually use, whatever that may be. We don't make programs for no reason. We program to make the computer do things that are useful to us. If you learn to program on your OS you'll be able to make things you can actually use in your daily life or share with your friends. I believe that makes it far easier to think of good project ideas and find the motivation to stick with them than it would be slogging through purely academic exercises on a foreign OS. Getting familiar with Linux is another skill you should definitely pick up at some point, but for the reasons mentioned above I don't agree with the people who think you should do both things at the same time.
You do not need VM and Linux. I like clang much better, but if you need to use gcc you can on OS X, needs a little tweaking, you can google it. I program C on Mac without any problem. Your teacher probably think all of you are on Windows, which in that case you are better of launching VM, but on OS X, no. It's Unix, and much better OS than Linux.
https://en.wikipedia.org/wiki/Literate_programming (CWEB, used in this post) http://www-cs-faculty.stanford.edu/~uno/cweb.html
In 'main' you do: n = (my_rand() % 3); if(n == 0) { ... } but then you go on to do: else if(n == 0) { ... } else if(n == 0) { ... } My guess is that you intended to check n against '1' and then '2' in those 'else if' clauses, not against zero again (which won't do anything as the first 'if' will catch it) Fun/funny project though, I like it!
I meant vagrant
clang however is perfectly fine as a C compiler.
brew is as good as apt
Thanks for the links!
Not sure if its GCC lol... I assumed it was because I was typing "gcc" when compiling things
Clang compiles faster and better messages. 
Its not even for a course, since its AP Compsci, we were working in java, but since I had some prior experience in C, my teacher recommended that I get more practice (completely unrelated to what we were doing in class)
It isn't all, but package management is huge deal. It makes getting all build dependencies, and built compatibility, easy. Seconds vs days.
Hijacking a bit here but I see a lot of people here recommending OP to eschew Windows for C programming. As someone just getting started with C can anyone help explain why writing C on Windows is that bad
I've not spent time with it. I purely going on what others have said, including those who work on homebrew. Sounds much better than Windows but not as good as most GNU/Linux distros. GNU/Linux has floors but less than others. And it is free, fast and I can read any source I want.
Ok. Your choice. I used both Linux and OS X. So you should disclaim your first post with "I've not spent time with it. I purely going on what others have said". It was obvious for me, but not enough for others. With all those years spent in Linux community I think I developed eye for spotting evangelists. ;)
 I'm still looking up tutorials on how to use/understand gdb. I'll update my question once I find out. Edit: I actually just found it Program received signal SIGSEGV, Segmentation fault. __isoc99_fscanf (stream=0x0, format=0x4009ca "%d") at isoc99_fscanf.c:31 31 _IO_acquire_lock_clear_flags2 (stream); not exactly sure what the hell this means
Windows C compiler is essentially stuck in the 90's. You have to use the C++ compiler if you want to use something more modern.
If it's not for your class, keep using Clang (disguised as gcc) on Mac. Installing a VM will only complicate things and will get you nothing more than another system to worry about.
GCC 6's messages are actually pretty clang like!
GCC has been available on MacOS since [1993 with GCC 1.37](http://macgui.com/downloads/?file_id=17363). Of course there was that whole boycott of the look and feel thing, but GCC has been around.
I did try and convey that, but I've added it. And I do think GNU/Linux is the best development platform. Among with other bests. The reasons are: A) The package management B) Being the first class platform for most/all those packages. C) All the source D) Being a Unix OS X has 1/3 of that. 
Cool! Thanks. Can I enroll if im in high school?
I'm not convinced that's your exact code, as it looks incomplete and you seem to have an extra closing brace `}` in main between the `if` that checks the file `p` opened and the `else` following it. Further, the code includes a file "my.h" which we do not have access to, and thus we can't compile and test your program ourselves.
And the C++ compiler will compile C code or no?
that extra closing brace may have been a typo when I was copy and pasting everything over. I have been coding in pico and saving each function on another server and tried to put it all together for my thread. Here is my.h #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdbool.h&gt; void swap(int * x, int * y); void oddeven_sort(int x[], int size); int main(int argc, char* argv[]); 
Yes. It's open and online. No pre-requisites. I did it and got a certificate from it I put on my resume.
That's true, but I certainly wish I had started with them
Thanks, after fixing that brace and compiling I'm getting further warnings. Your `return` statements should actually return something in non-void functions. e.g. main is an int function, which should return an int, so your return at the end of main should be `return 0;` at least. At the top of main, you have: int main(int argc, char* argv[]) { int i, *a, count, user_input; FILE* p; //p = fopen("r",argv[i]); corrected as follows: p = fopen(argv[i],"r");// manual page for fopen says it wants path then mode as arguments. You define your `int i` then immediately fopen `argv[i]`, but `i` doesn't seem to have a value yet. Further, if the program is run with no arguments, it shouldn't be trying the fopen at all. In your function `userInput`, you have: `scanf("%d",user_input);`, I think this needs to be `scanf("%d",&amp;user_input);`. Try fixing these then seeing if it still segfaults.
A) as I said you have just as good package managment on OS X, it's just that you haven't tried it B) That is true, but exclusivity is not true. Linux Binary can be and is executable on other systems, so your point won't stand on firm ground here. C)/D) are true, but nothing special there. The thing is Linux is "server" OS. Desktop community is most vocal and now majority but if you take a deep dive into OS and concepts behind it's code you will think of Linux differently. When i got know with OS theory and Kernel development I saw it. I am not bashing Linux (at lost not in these posts), there are far far superior OS like Illumos, FreeBSD. For desktop I think OS X is unbeatable, it is de facto UNIX for desktop! Every to it's own, tastes are different, but you are giving some pretty narrow and sharp statements about some areas which you seem to be unexperienced with. I mean, do not get me wrong, I use Linux (mostly as server, days of desktop usage are behind me), I am very well aware of it's good sides and bad sides, and I am looking at this OS comparison from fairly objective technical perspective. It's not like OS X is perfect, hell no, far from that, but I really think it is best way to have UNIX on desktop since I do not have to make any sacrifice! I get latest and best both from open source and from proprietary/industry standard software. 90% of open source code that runs on linux you can run on OS X. If something is exclusive to linux I run it in Container, or some light vm depends. I learned UNIX on Linux, I started with Linux long time ago. After I learned enough (using gentoo and CRUX and Arch) I moved to FreeBSD. And after 8 years of using those I switched my main rig to OS X. (before I had iMac which I used mostly for non-dev stuff, but 6 months ago I bought Macbook and ditched my old desktop linux/bsd machine). So that's my story just to convince you that I am not trying to force my opinion, just to tell my side of story, that I think I tried enough of everything, and that my opinion is trying to be as objective as possible.
I thought that you needed Cygwin or MinGW to use GCC on Windows.
Mac should be fine for C.
Ahh, gotcha. Though soon it will actually become part of Windows, as Ubuntu will be able to run alongside Windows in userspace.
Like everyone else said, you obviously don't need linux to learn C. However, it's not a bad idea. My first foray into linux was in my college's C programming / UNIX class. Wasn't required, but installing it and forcing myself to work in it, caused me to get a lot out of the class. And I would have to say, in hindsight, that little bit of curiosity had almost as much of an impact on my career as deciding to major in CS.
This area is definitely not my forte, but wouldn't introducing a simple nop sled to the string make this much more reliable?
Yes, the pre-built binary works. Seems like my toolchain sets things up differently from yours.
Possibly. But still, everything depends on the toolchain making the same decisions as OPs.
&gt; Of course there was that whole boycott of the look and feel thing Quae?
That and MSVC doesn't implement large chunks of the C standard. I definitely second the recommendation of cygwin, is sidesteps a good number of the problems of windows and gives you a pretty neat linux/unix-ish environment.
Good luck! Making a shell is hard, as in, really really hard.
Your question reminded me of something I was reading yesterday in the [Gnu C Reference Manual](http://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Statements-and-Declarations-in-Expressions), regarding usage of a compound statement inside a macro: #include &lt;stdio.h&gt; #include &lt;ctype.h&gt; #define myislower(c) ({ int _c=c; (_c) &gt;= 'a' &amp;&amp; (_c) &lt;= 'z'; }) int main(void) { const char *cp; cp = "h{ello}"; printf("%d\t", !!islower(*cp++)); printf("%c\n", *cp); cp = "h{ello}"; printf("%d\t", myislower(*cp++)); /* (('h') &gt;= 'a' &amp;&amp; ('{') &lt;= 'z') */ printf("%c\n", *cp); return 0; }
I like to demonstrate differences in memory layout with pictures: [without malloc](http://i.imgur.com/BEDGMM2.png) [with malloc](http://i.imgur.com/AtHL1bX.png)
There's also a neat tool included in the radare2 framework can disassemble straight from hex. $ rasm2 -d 'wut&gt;\xf6\x86\x04\x08\xb0\x04\x31\xdb\xb9\xe0\x86\x04\x08\x31\xd2\xb2\x0e\xcd\x80\xb0\x01\xcd\x80' test byte [esi + 0x4b00804], 0x31 fstp xword [ecx + 0x80486e0] xor edx, edx mov dl, 0xe int 0x80 mov al, 1 int 0x80 
If you want to allow any type of pointer, use `void*`. `base_address` should probably be `void*`. You should probably not use `ptrdiff_t` -- it *is* the type of the expression `a-b` when `a` and `b` are pointers, but how often do you actually need that? The OSX kernel uses it only *3* times, and only once was it used in the correct way to represent and store the distance between two pointers. `uint8_t*` is appropriate in computing adler32 because it is a bytewise algorithm. Your memory copy implementation has a lot of issues: The first is a style point: `offset` is redundant. If the programmer meant `pointer + offset` they would write that. A pointer has a size, so: void *buf; char *c = buf; short *h = buf; int *i = buf; long long*j = buf; creates four variables that all point to the same area in memory. `x=*c` will load a byte, and `*c=x` will *store* a byte, while `x=*j` will load eight bytes, and `*j=x` will *store* eight bytes. If a programmer wants to refer to the four-byte quantities called integers, they might use `i[0]` for the first one and `i[1]` for the second one. `(&amp;i[1]) - (&amp;i[0])` is a `ptrdiff_t` but it is *one* because the distance is measured in the same type as the pointer. The way you wrote `mem_write_buf()`, the offset is always in *bytes* which might be very confusing! If you remove it, and let the programmer specify the destination address, you'll note: static void mem_write_buf(void* dst, void* src, size_t buf_len); is almost same signature as `memcpy()` and `memmove()`, which are faster than your implementation. They also marks `src` as constant, which tells the compiler than its contents won't change after calling the routine, and so they do not need to be reloaded (if they are in registers). Really you should just use `memcpy()` or `memmove()`. If they're not available, there are still better things you could be doing than trying to reimplement them. If you insist on using the offset argument, keeping it in bytes, you should consider naming it `offset_in_bytes` so that other programmers reading the headers will know what to expect. 
This is a primitive encapsulation mechanism that allows for simpler logic and more compact code. At the time C was created, many high level languages were pass-by-reference. This meant that often lots of temporary variables were created to preserve values. For example, if I pass an int into a function and manipulate this int in the function - what if I want to preserve the original copy of the int? In a pass-by-reference language there would be extra bookkeeping. Not in C, in C you just pass the int in directly and a local copy is made, the function runs and my original int is preserved. However if you do want to manipulate the original copy of the int, just pass a pointer to the int to your function, the pointer is what gets copied and it refers to the same memory location as the original int.
The customary introductory program; as written in an "anti-pattern" textbook. :-D
You could, but it would not be terribly efficient. However you could write a small utility library, that if designed carefully could be used in many other programs. For example (adjust "primitive" types as necessary to more C99/11 friendly types): struct vector { int max; // maximum number of items data can hold int len; // current number of items in data void **data; // storage for items }; along with some utility functions that handle calls to malloc(), realloc(), and free() internally you could end up with something that lets you just append a single char or an entire substring to your vector. Plus a function to extract a '\0' terminated (char *) out of vector for when you are ready to use functions expecting a C-string.
Those sizes depend on the hardware. They each have a minimum defined by the standard: for long is 4bytes and long long is 8bytes (minimum for int is actually 2bytes.) Since they are both 8 bytes on your machine they are indeed exactly the same in this case.
https://en.wikipedia.org/wiki/C_data_types A `long int` is **at least** 4 bytes. A `long long int` is **at least** 8 bytes. Historically, you would only use a `long long int` if you really needed that data range, because it would most likely be slower on a 32 (or 16!) bit processor. Now that more processors (most likely including yours) are in fact 64 bits, the computer can deal with 64-bit integers just as easily (maybe more easily) than 32-bit, so the compiler may use a 64-bit integer anyway.
&gt; If yes, whats the point of long versus long long? The point is that not everybody is using the same platform you are. On a different platform, they might be different sizes. The standard doesn't say what size these types must be, it only gives a minimum. A long must be able to support at least 32 bits worth of data, so on your particular platform a long is longer than required, which is why there is no need for a long long on your platform. That isn't always the case. Edit: to elaborate a bit, the general practice on Unix systems is for long to be the native machine word width. So if you're compiling for 32 bit mode, long will be 4 bytes, and if you're compiling for 64 bit mode long will be 8 bytes. In both cases long long will be 8 bytes. (Again, this is just in the context of modern Unix systems, it does not apply to other platforms.) So if you want a value that tracks the machine word size across different architectures, use long, and if you want something that's 64 bits, use long long. On windows, long is always 32 bits even on 64 bit platforms, so you have to use something else (like size_t or ptrdiff_t) if you want an integer type that tracks the machine word size. 
I clicked it because I'm a moderator and my duty is to read every single post in order to make sure that it is not off topic. I'm sorry for trying to increase OP's chances at getting an answer.
https://en.wikipedia.org/wiki/64-bit_computing#64-bit_data_models
Btw, the first 4 bytes are an address pointer, so your disassembly isn't quite right. It just does a write() and then an exit().
I've made it this far without that valuable lesson. Who knows where life will take me now 
No problem :) for future reference, a quick Google search of the library's documentation should be able to answer questions like this in the future. Good luck to you!
If you're not worried about exact layout in memory, but about maximum value, it's potentially better for the compiler if you're clear about that. Between them, `char`, `int`, `long`, and `long long` have the same range constraints that the `&lt;stdint.h&gt;` types do, but are free to be larger as well. While it's pretty contrived, if the system is slower at dealing with 4 byte integers than 8 byte integers, but you used `int32_t` instead of `long`, then the compiler isn't free to store them as 8 bytes, possibly affect speed and alignment for the processor. The `&lt;stdint.h&gt;` types are for portable declaration of the memory size of your type, but the base integer types are the portable way of declaring the range you intend to hold. Not guaranteeing much is generally a good thing - it gives the compiler more freedom to optimise your code.
Got it!
C primer plus by Prata 5th or 6th Ed (your choice). Deitel &amp; Deitel 7th. Then go back and read K&amp;R. You'll understand the elegance of the language afterwards. 
newsyslog, logrotate, etc., will do it for you or provide implementation ideas if you insist on doing it yourself.
Linux personalty on the newer 10 inside track can run GCC as well.
 Deque *stack1 = malloc(sizeof(struct Deque)); dequeNew(stack1); [...] Deque *queue1 = malloc(sizeof(struct Deque)); dequeNew(queue1); For starters, it seems you want Deque *stack1 = dequeNew(); [...] Deque *queue1 = dequeNew(); 
What operating system?
Have you tried running a debugger? Why do you pass an argument to `dequeNew()` even though the function is declared not to take any arguments? It's a bit difficult to help with just this tiny fragment. I suspect the error lies somewhere else. Can you make a reproducable example we can actually compile?
Your account appears to be shadow banned. Please talk to the moderators to rectify this issue.
Noted. K&amp;R seems good enough, honestly. There really hasn't been that much that's changed. C99 gave me // and variable arg macros. Everything else was just sort of meh. Nothing in C11 jumps off the page. Old dog I guess. K&amp;R to ANSI was a bit of big deal though. No more forgetting the length parameter on a copy() call and having the code forge ahead with whatever was on the stack. :P I had to laugh when /u/FUZxxl announced the contest prizes of first edition K&amp;R and Elements of Programming style. Elements was my very first programming textbook and 1st ed. K&amp;R followed soon after. Both still sit on my shelf 40 years later. Great books and great prizes. Just reading the table of contents of [Elements of Programming Style](https://en.wikipedia.org/wiki/The_Elements_of_Programming_Style#Lessons) will make you a better person.
What os? What version of fuse did you download and install? Fuse tends to not have frozen api levels...
Using latest Arch-linux, fuse installed by my package manager at version 2.9.6-1, but I also downloaded the source from github (commit 284710d) and build and installed it from there.
&gt; that means that I'll have to cast to uint8_t for arithmetic, am I correct? That the function takes `void*` allows you to pass any type without casting. There's absolutely no requirement that you use the same type in the caller and the callee -- such nonsense was popularised by C++: void *base; char *x = base; memcpy(x + 40, d, 32);
If you're developing for unix, then the unix way to would be to have your program just log to stderr and completely delegate the work of log management to a different program.
If you have a decimal like 4.257, and you want to truncate it to one decimal place, like 4.2, multiply by 10.0 (or a hundred, for two digits, or a thousand, for three), cast to integer, then divide by 10.0 (or whatever) again. If you want to round to the nearest tenth, multiply by 10 (or whatever), add 0.5, cast to integer, then divide by 10.0 (or whatever) again. This sends 4.257 -&gt; 42.57 -&gt; 43.07 -&gt; 43 -&gt; 4.3 but it sends 4.247 -&gt; 42.47 -&gt; 42.97 -&gt; 42 -&gt; 4.2. If you want to print a decimal, you can use %.1f instead of %f to print only tenths, %.2f to print to hundredths, etc. There's a way to do it with cin and cout, too. You just use std::cout &lt;&lt; std::fixed; std::cout &lt;&lt; std::setprecision(2); std::cout &lt;&lt; f; and it will print your number truncated to the number of digits you want.
Will do, thank you again:)
What do you mean?
Sorry, C++ is off topic in this subreddit. Please ask in /r/cpp_questions or elsewhere. I removed your post.
If you want to do it yourself, a very straightforward way is to incorporate the date into your file naming. If each day isn't granular enough, you can add the hour, and so on until your files are manageable sizes.
Including fuse3/fuse.h indeed solved my problem that I had in my post. So thank you for that. May I ask how you found out in which version feature X got added? Just browsing the source code? Reading changelogs? Because now I have the next problem, apparently I supply too few arguments to the filler function. Oh well, I will look around some more tomorrow, maybe I will find my mistake. 
&gt; I've seen a lot of large game engine have sprawling systems with path management, access control, and creating and destroying files but never actual seen these end up being used. I would like to be mindful of what is and isn't required (it can always be added later). Your best bet is to only write the program that needs to be written. If you need more, you can write it, but if you needed less, in addition to wasting the time creating it, you're also wasting time removing it. Need a routine to read a file? Write a routine to read a file: struct chunk { void *data; size_t len; }; struct chunk read_file(const char *filename); If you need only part of the file, why not split the file into multiple parts? There's nothing that says that your release version of `read_file()` can't be reading from a zipfile, or an [in-memory filesystem embedded in your executable](http://www.linuxjournal.com/content/embedding-file-executable-aka-hello-world-version-5967). These problems can be solved later, if all you need is a bunch of files. &gt; One definite question is that I'm not really sure about a good type for the file position marker. This isn't going to affect whether the game is fun or not, and if you get it wrong, it'll take you only a few seconds to change it anyway. &gt; Move away from synchronous read/writes by default in favor of asynchronous. What are you trying to accomplish? If you want to do something while you're reading and processing assets, just kick off another thread. Your game isn't going to have a 100k threads, and even if it does, that's still going to take [less than a second](https://www.reddit.com/r/programming/comments/a4n7s/stackless_python_outperforms_googles_go/c0ftumi).
Are you looking for the DLL [here](http://digital.ni.com/public.nsf/allkb/A3663DE39D6A2C5A86257204005C11CA)?
Even if it is not the reason, I'd still recommend using write(3) function.
https://www.reddit.com/r/C_Programming/comments/4isjlm/new_programmer_counting_characters_in_an_array/ One of my many posts. I'll take Elements of Programming Style please! Thank you. 
In case anyone is not thrilled by clicking around to find that there is no link to the source code, [here it is.](https://github.com/jmcnamara/libxlsxwriter)
Any idea if this library is supported in python?
&gt; My question is actually quite simple: is there anything in the C Standard (and C++ Standard) that guarantees such behavior? Yes, the C and C++ standards both say &gt; Each subsequent instance of the function-like macro name followed by a ( as the next preprocessing token introduces the sequence of preprocessing tokens that is replaced by the replacement list in the definition So the preprocessor will not expand `macro`, but only `macro(` Your example fails if you write something like class macro { public: int arg; macro(int i) : arg(i) {} ~macro() {} }; #define macro(m) printf("%d\n", (m)-&gt;arg); int main(void) { macro m = macro(6); // contrived example, but compiles if the #define is not present macro(&amp;m); return 0; }
If you want an unsigned integer type that tracks the native machine word size, use `size_t` or `uintptr_t`. If you want a signed integer type that tracks the native machine word size, use `ptrdiff_t`. As far as float vs double, that's a far more complicated decision, which requires taking numerous things into account, so it's not just something you can decide based on the hardware. Even if the hardware supports both, there may not be a clear answer (e.g. you may need the extra precision for certain algorithms to be numerically stable.) 
No school like the old school.
 int a,b,c,d; if ( 4 != fscanf(fp, "%d %d %d %d", &amp;a, &amp;b, &amp;c, &amp;d) ) ...error handling...
 int a = 1, b= 2, c; c= a+b; printf("%d\n", c); 
well you could have: struct { int a, b; } one; although not sure if that's what you mean.
thxxxx, btw i wanna see if i got the idea straight, theres a code: while(fread(buf,1,2,file)==2) does it mean, while reading the file, when theres == 2 bytes, store first byte into buf[0], and second into buf[1]?
Yes (assuming 1,2 are in the right order, I never remember which)
Best language ever - it overlay on hardware abstraction and assembly so well that it simply cannot be replaced.
Please try to give your post a useful title in the future. "Beginner here, looking for some help please ;_;" is not a useful title.
"High level" is relative. Compared to "old" C, this is high level. But compared to some other languages, like C++, C is **really** low level. Most of the time, unlike in other languages, you're working on **raw bytes and system calls**, sometimes including assembly code.
It can be attributed to both, but I would argue that C makes it much more work to write completely unreadable code. The language itself doesn't have very many actual language constructs, which reduces the overall challenge of reading a piece of C code. Even badly written C code can still be read by a C programmer with a little effort, because at the end of the day you're not going to end-up seeing something new - it all boils down to the same small set of functionality that anybody who's been working in C for a little while knows. The above can't really be said about very many other languages (Obviously, there are exceptions, C isn't the only one like that). That's simply because they tend to take the different approach of having lots of language constructs rather then a few, in the hope that you pick the best language construct to express your code. In some cases this can be an advantage, but it can also be a big disadvantage if you use a bunch of obscure constructs that the people reading your code don't recognize. Now, macros are probably the one exception. Ideally a program's readability shouldn't be hampered by macros - and if it is those macros should be reconsidered. Obviously though, not all programs are ideal. Still, I'd say the majority of programs I've read don't have very many 'gotcha' macros in them: There's simply nobody who use macros to do stupid things like replace the plus sign with the minus sign. There are cases where things like that happen, but they tend to be few and far between. This is especially true if the programmers are diligent about their macros and keep them consistent.
You're going to have to explain your problem better... Also, post code you have so far on the problem so we can see what you've tried
You will have to be more specific. Are dP and dp going to be just two data points or formulas? Are you looking for one of them? If yes, which one? Anyways first step would be to separate your variables.
As a non-professional programmer the tooling around the language helps me immensely to write better code, that is also easier to understand. It also helped me a lot while learning the language by explaining my mistakes to me with its output. C&amp;P the output into google and you will usually get a thorough explanation of why and how to fix it. I wish I had the level of tools at hand in my field of expertise. Programmers really do not know how lucky they are.
`intmax_t` and `uintmax_t` are specified by the C standard as being the largest integer types. For technical reasons it turns out that some compilers actually don't follow this specification; for example on typical installations of gcc, `intmax_t` is 64-bit, but there is `__int128` which is 128-bit.
&gt; If you want an unsigned integer type that tracks the native machine word size, use size_t or uintptr_t. If you want a signed integer type that tracks the native machine word size, use ptrdiff_t. This is not accurate. `size_t` represents a type large enough to store the size of any object, which may be larger than the native word size. For example on CPUs which have 16-bit word size, one possible setup included a 32-bit `size_t`. 
Encapsulation is always a good idea imo. Your code looks perfectly fine to me. 
Once you know C, you can write C in any language!
It looks okay. Stylistically, I'd name things from Most specific to least specific. ie, getBootState() Would be: bootStateGet(); This has another advantage that it's easier to sort your symbols and find functions related to a certain module. Not everyone agrees with this, but I tend to prefer it. 
I'm not super familiar with c practices, but I was under the impression that global variables are to be avoided. Can someone explain the rational behind something like this?
Regardless of language it's a good idea to avoid them. You isolate as much possible, which is good for human readers and good practice in a threaded world and means if you suddenly find you need two of what was a single concept, you are ready. If need be, bundle up into context structure/object always given. I don't always get to live up to this.....
Great question. IMO, getters and setters are really just an attempt to abstract behavior -- points that you can change the implementation without forcing everything to recompile. Your implementation seems to satisfy that well enough. But, beware that the getters and setters aren't themselves too coupled to an implementation. As others have said, continue naming them in terms of expected behavior from the perspective of the caller, as if the caller knows nothing about the implementation. 
Basically, i need to calculate this. Its not really differentiating an equation or a polynomial per se but rather a rate of change kinda way. https://en.m.wikipedia.org/wiki/Bulk_modulus http://www.engineeringtoolbox.com/bulk-modulus-elasticity-d_585.html 
That article has near-zero applicability to C. Every single thing it suggests as a replacement is not built-in to the language since it suggests a bunch of OO concepts. Getters and setters are the only way to encapsulate within C, so these methods are actually the way to emulate OO behavior in a language that doesn't support it.
I don't think he's upset. He's more surprised that it does.
So this what is called a differential equation. You have some value you want (bulk modulous) which is defined in terms of some variable, and a derivative of something with respect to that variable. The general process to solving these can range from super simple to very complicated, and the process of solving these equations is called numerical integration. Note that you *still* haven't told us explicitly what you have to do. Please think about what it is you are tying to solve, and what the problem actually is, I am having a hard time understanding what it is you are trying to do. Below is my attempt based on what I think you meant. To solve this equation, you need a few things. One is a set of initial conditions for density and pressure (or pressure and bulk modulous). The next is some sort of relation between pressure and density. Without this relation (called an equation of state) you cannot numerically approximate the derivative term. If you think about it a little bit this makes sense. If I give you two values for the pressure and density, how could you determine the rate of change without a relation? Once you have said relation, try implementing [Euler's method](https://en.wikipedia.org/wiki/Euler_method), the simplest of the forward time step methods.
[Comma operator](https://en.wikipedia.org/wiki/Comma_operator).
Generally there are 2 approaches that you can follow: 1. Writing the same function multiple times. C does not have function overloading, but you can fake it with macros. Write a macro that checks the type of the argument and calls the appropriate function. 1. Polymorphism, generally through pointers-to-functions. See the standard C function `qsort` for a good example of how to set up a polymorphic function in C.
&gt; What I was trying to accomplish here is to stop other translation units accessing the state struct by using static Why? If other translation units can access the state directly, then the compiler will use more efficient instructions. &gt; I wanted to get out of using globals This still is a global, it just doesn't have a globally-accessible name. You can: * Pass the `struct states` around all of your functions * Use dynamic variables (not portable) * Use a global variable I would just use a long and unlikely-to-collide global variable. You can then use macros to access it, which will give you the ability to extend your API in the future if you discover it needs to be more complicated, but still be (a) efficient and (b) easy to debug until then.
Function overloading is usually implemented by internally adding the parameter types to the function name (name mangling).
&gt; I wanted to get out of using globals to be honest but was unsure of how to accomplish that in C. Don't use globals, and pass in pointers to the structs. Then your code will be a lot more easily testable, and perhaps reusable (but reusability shouldn't be your first goal, I'd say). Even if you have a "singleton" struct that will be used, it's still nice to pass it as a parameter rather than rely on global state. You should always try to express as much as possible in the signature of a function. 
You have to be careful with this pattern though, otherwise you end up with a God object https://en.wikipedia.org/wiki/God_object that people just keep sticking stuff into. Sometimes it is just neater to have a few different global variables for things.
**[God object](https://en.wikipedia.org/wiki/God_object)** --- &gt;In object-oriented programming, a god object is an object that knows too much or does too much. The god object is an example of an anti-pattern. A common programming technique is to separate a large problem into several smaller problems (a divide and conquer strategy) and create solutions for each of them. Once the smaller problems are solved, the big problem as a whole has been solved. Therefore a given object for a small problem need only know about itself. Likewise, there is only one set of problems an object needs to solve: its own problems. In contrast, a program that employs a god object does not follow this approach. Most of such a program's overall functionality is coded into a single "all-knowing" object, which maintains most of the information about the entire program, and also provides most of the methods for manipulating this data. Because this object holds so much data and requires so many methods, its role in the program becomes god-like (all-knowing and all-encompassing). Instead of program objects communicating among themselves directly, the other objects within the program rely on the single god object for most of their information and interaction. Since this object is tightly coupled to (referenced by) so much of the other code, maintenance becomes more difficult than it would be in a more evenly divided programming design. Changes made to the object for the benefit of one routine can have unintended effects on other unrelated routines. A god object is the object-oriented analogue of failing to use subroutines in procedural programming languages, or of using far too many global variables to store state information. Whereas creating a god object is typically considered bad programming practice, this technique is occasionally used for tight programming environments (such as microcontrollers), where the performance increase and centralization of control are more important than maintainability and programming elegance. --- ^I ^am ^a ^bot. ^Please ^contact ^[/u/GregMartinez](https://www.reddit.com/user/GregMartinez) ^with ^any ^questions ^or ^feedback.
C doesn't have classes or methods. It is not an object oriented language. It is also typically discouraged to use global variables, so having getters or setters are not really needed.
Seems a getting/setter would make sense here if you had to wrap the access around a mutex lock. I'd probably consider a bitmap of to represent these states, and use bitwise operators to check and set them.
Yer generic is really cool. Compile time selection by type.
Please, don't use `uint8_t` unless you need a type with exactly 8 bit that has exactly the range from 0 to 255. If you want the least addressable type, use `char` or `unsigned char`. Do not use any of the `uintXX_t` and `intXX_t` types unless you are sure that you need a type of exactly that range.
If your program ever needs to run on platforms where a byte is not eight bit, `uint8_t` won't be available and your functions fail. There is also a semantic argument: You mean a buffer of *bytes,* not a buffer of *octets.* Only when you absolutely need the latter you should use a fixed-size type. And if you need to frequently convert between `int8_t` and `char` or `uint32_t` and `unsigned`, you are doing something terribly wrong. The other argument is that the builtin types int/long/short/long long are suitable for what the machine can do. The fixed-size types are some times (especially on weird micro-controllers) unsuitable and slow. For example, MSP430X has a native 20 bit type but no 32 bit type. If you use platform specific types like `size_t` and `uintptr_t`, the code is going to use the 20 bit ALU and will be fast. If you use `uint32_t`, it's going to be emulated and slow. C has generic types so you can write code that doesn't depend on what the machine can do. If you need hard guarantees for minimum type sizes, at least use `uint32least_t` and such so the computer can pick a larger type if needed. For example, some processors only have a 36 bit type. If you write code that uses an `uint32_t`, it either doesn't compile or is going to be horribly slow as the compiler must zero-out the upper four bit after every operation. Lastly, using generic types makes your code grow with the platform. If you use a `long` for your offsets, it's going to be a 32 bit type on 32 bit platforms and possibly a larger type on 64 bit and future platforms. Fixed size types don't grow like that.
Please add some more explanation to your question. A link to the code is nice (and encouraged) but without an explanation what the problem and error message is it's a bit tedious to answer the question. Try to make it as easy as possible to give an answer. Show that you put effort into your question!
&gt; Anyways so in my experience make doesn't support something else than gcc That's nonsense. make doesn't care one bit what compiler you use. It's a generic tool, it doesn't know or care what programs you tell it to execute. It's certainly possible to write a makefile that assumes gcc, but that's the fault of whoever wrote the makefile, not of the tool itself. Most well-written makefiles are parameterized so that you can override any pertinent variables, e.g. `make CC=clang`, where CC is the traditional name used for the variable that stores the name of the C compiler to invoke. 
I wouldn't use gottos.
Are there any other significant differences between gcc and clang then ?
K edited.
Might be that you are using strmp instead of strcmp. I'm assuming strmp is a typo. You should be getting a symbol undefined error though. No idea what compiler you are using... is this some kind of website to learn C?
Agreed. We have both disproven the statement that "you don't encapsulate in C" - it can be done, and it is not uncommon to do so. 
It can be hard to follow gotos, especially with names that are hard to understand at first glance (such as xy and ab). If you have learned about functions you should try to separate the code into functions instead. Sometimes you would also use loops instead of gotos. If you haven't gotten that far yet, don't worry, it's easy to get overwhelmed by trying to follow everyone's advice. Just try to focus on one thing at a time.
If it's one of your first programs it's Ok, try to use longer more identificable variable and label names. In the future you might want to use loops as they make the code easier to read to other programmers. Both of these are required to write good and sustainable code, in "little" examples or one use programs it doesn't matter that much but in the future will. I recommend you to try to do it even if it doesn't matter as it is a good practice.
I never said that it can't be done. I said that it should not be done. Also: How have I provided a mean of encapsulation?
http://pastebin.com/FmPNPjbk I added some comments, good luck with learning and you may want to check /r/learnprogramming
Cmake creates make file ( or visual studio project or others ) from a file you supply it. It's used one step before make so you don't have to write makefile by hand. Other advantages it gives are like figuring out linker flags and compiler flags for you, figure out if the correct version of a package is present ( eg if you need at least boost 1.50 cmake can find that out). It's going to be helpful if you learn cmake especially once you get more advanced and want to distribute your software to others.
Personally, I find most of clang's warnings and errors easier to interpret than gcc's
Ok people so is there any clang irc channel I can rely on if I have some questions ?
A more logical comparison would be autotools and cmake, or make and ninja. Otherwise it's like comparing apples and lettuce (yep, cause oranges is still a fruit ;) ) 
Stop using make directly and learn how to use autotools.
Since it's not mentioned on the sidebar i've enjoyed "21st century C"
On second thought let me try what you just suggested.
Yes, globals are never a good idea when you don't really need to. I would do #include &lt;stdio.h&gt; void function(char* sel) { scanf(" %c", sel); } int main(void) { char sel; function(&amp;sel); printf("Caracter: %c\n", sel); return 0; }
Thanks! This is what I needed!
Guys I'm not some noob. I got this far as pointers and linked lists. I was just trying to figure out what was wrong.
K&amp;R although I recommend you have some previous experience before reading.
Got it! Thanks for the explanation.
To quote from the standard: &gt; 7.21.6.3 The printf function &gt; &gt; Synopsis &gt; &gt; #include &lt;stdio.h&gt; &gt; int printf(const char * restrict format, ...); &gt; &gt; Description &gt; &gt; The printf function is equivalent to fprintf with the argument stdout interposed &gt; before the arguments to printf. In other words, `printf(...)` is just a more convenient way of writing `fprintf(stdout, ...)`. `fprintf()` is the more general form, because it can output to any stream, whereas `printf()` can only output to the `stdout` stream. 
The biggest issue (once the program starts working) is the use of `gets()` -- or `scanf("%s", ...)` in the original program, which is just as bad. Eventually you'll want to learn how to constrain the input to the size of the buffer. It unlikely matters for this program, but if you start distributing programs, it becomes important. It looks like excellent progress for 3 days, though. You've got some functions happening, some control structures, etc.
Okey got it. I have just completed till functions atm. I will keep your points in my mind thanks! :) Tho I am really interested on how to constrain the input.
ok. I'm not trying to argue here. But I'm programming EXACTLY how I was taught. Something is wrong with my syntax that is all.
Like /u/gastropner says, if you don't understand this you can't say you are that good at C programming. And if this is the way you have been taught C there is a whole other problem. I'm not trying to be a dick to you, I just don't like the attitude you have towards us.
If I understand your problem correctly, you have a `main.c` with something like: #define DHT_TIM 2 #include "dht11.h" And your problem is that `main.c` sees `DHT_TIM_CNT` as `TCNT2` but `dht11.c` sees it as `TCNT1`. If this is correct, then you do indeed have a "scope" problem as macro definitions are only visible inside the translation unit where they are defined. If you want all source files to see the same value for `DHT_TIM` then you either need to define it inside every source file or you need to tell the compiler to define it for you. I don't know what compiler you are using, but gcc, clang, and most others will allow you to pass a flag similar to `-DDHT_TIM=2` which will make all source files behave as if the very first line is `#define DHT_TIM 2`.
Apologies accepted. Posts like these are usually disliked on this subreddit since there are many C newbies who ask really basic questions. These are often downvoted, as is yours.
`dht11.h` uses the `#ifndef` code posted in the OP. `main.c` defines `DHT_TIM` macro, `#define DHT_TIM 2`.
&gt;Your "main program file", if it includes dht11.h as shown and then does #define DHT_TIM 2 then you should get an error about macro redeclaration. Yes, I receive a warning (not an error). My compiler is gcc. `main.c` has `#include "dht11.h` and `#define DHT_TIM 2`. `dht11.h` has the `#ifndef`code bit posted in the OP. `dht11.c` uses the `DHT_TIM_CNT` macro, which is formatted by `dht11.h`.
&gt;And your problem is that main.c sees DHT_TIM_CNT as TCNT2 but dht11.c sees it as TCNT1. I'm not exactly sure what `main.c` sees for `DHT_TIM_CNT`. It is only used in `dht11.c` library source and it sees `DHT_TIM_CNT` as `TCNT1`. I would like to avoid using compiler flags, if that's possible. &gt;If this is correct, then you do indeed have a "scope" problem as macro definitions are only visible inside the translation unit where they are defined. Does the `dht11.c` see the macros defined in `dht11.h`, because it has an include `#include "dht11.h"`?
Is there any other convenient way to perform conditional formatting from `main.c` that affects `dht11.c` without including any additional files to `dht11.c`? I want to keep the library as universal as possible.
Not with macros, you have to do it with code. Every .c file is separate until they are linked together after compilation.
It is possible. For a detailed discussion on how to do it, refer to [Understanding Bit-fields in C](http://opensourceforu.com/2012/01/joy-of-programming-understanding-bit-fields-c/). Also, you'll have to use **structure** instead of **union**. To understand why, refer to [this](http://stackoverflow.com/questions/346536/difference-between-a-structure-and-a-union-in-c). EDIT: Alright, I'll have to agree with /u/FUZxxl that you *may* use union and embed a **structure** within it to get it to work. But that's overkill IMHO. After all, you're using bit-fields to minimize memory footprint, aren't you? Anyway, below code should get the job done. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; /* Little Endianess */ struct FP { unsigned m : 23; /* Mantissa */ unsigned e : 8; /* Exponent */ unsigned s : 1; /* Sign */ } *fp; int main() { float f = 22.5542F; fp = (struct FP *)&amp;f; printf("%u %u %u\n", fp-&gt;s, fp-&gt;e, fp-&gt;m); return 0; } Tested it on x86_64 GNU/Linux with gcc 4.8.4. Verified it with [IEEE 754 converter](http://www.h-schmidt.net/FloatConverter/IEEE754.html). Agree with what /u/FUZxxl mentioned below. Corrected &amp; faster (relatively) version is as below - #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; /* Little Endianess */ union floatbits { float f; struct { unsigned m : 23; /* Mantissa */ unsigned e : 8; /* Exponent */ unsigned s : 1; /* Sign bit */ } bits; }; int main(void) { union floatbits fb; fb.f = 22.5542F; printf("%u %u %u\n", fb.bits.s, fb.bits.e, fb.bits.m); return 0; }
I agree with you on strict aliasing front. This was just a quick demo. But good advice nonetheless.
I've been looking for people to study with for a while, but nobody really ever wants to study in C ("oh it's too hard to use in an interview" it really isn't if you're actually comfortable with memory management, which IMO is key to being a developer). But I'd be way below your level cause I mostly only know DS and some algs, haven't done enough system programming and OS dev. :/
I have a vague memory that the bits in a bitfield are not defined to be implemented in a specific order, so it might be compiler specific whether it works.
Bresenham's circle algorithm, also called [midpoint circle algorithm](https://en.wikipedia.org/wiki/Midpoint_circle_algorithm). The idea is to use x^2 + y^2 = r^2 instead of sqrt(x^2 + y^2) = r to avoid the square root. There's even a way to eliminate all floating-point calculations, so it only uses integers.
One page per item? Yeah, no.
Whatever compiler is available, `nano(1)` or `ed(1)`, no tool, custom scripts.
I'll start with my environment. I'm currently on automotive embedded project, so most of environment is mandatory. * GreenHills compiler + GreenHills MULTI debugger (would not recommend) * Sublime Text editor; project prescribes ancient version of Visual Studio * MISRA checker is executed on each build * Manual unit testing (no framework), Testwell CTC++ code coverage * Manual integration testing because customer tools cannot be automated All in all it's a quite painful experience with long modify-compile-test round times and inefficient prevention of bugs in code, but that's embedded automotive for you.
Which is why I said “assuming the bitfield puts the bits and pieces into the right places.”
gcc, cygwin, gvim. "make test' for unit testing although the majority of testing is another person running test scripts on the finished product Don't do code analysis or code coverage (don't even know what that is TBH) 
Bitfields generally aren't very portable as the standard imposes almost no constraints on how they are implemented.
There's assuming its in the right place, then theres assuming because it worked that it will work on all compilers and all hardware
Ochams razor: If it was possible to do portably, I would have provided code that would do that. Not even the arrangement of the components in an IEEE 754 float is standardized.
Luckily I only have to target desktop and server machines running on x86/x86_64, so I don't have to deal with any embedded or mobile nonsense. ;) I do all my development on Linux using Sublime Text (vim if I'm working remote) and gcc, but I like to make sure everything builds cleanly in gcc, clang, mingw, and msvc; that way I can build a version for each platform using that platform's default compiler. Debugging is usually gdb and valgrind, Visual Studio on Windows, but honestly I often resort to printf-style debugging. For testing I have a custom header and shell script that gets run by make test. For Windows stuff I run the tests in wine and eventually in several VMs running different versions of Windows. For OS X I remote into my Mac mini and compile/test there.
vim, gcc or clang, gnu make, Unix.
Have you used ed?
It's pretty strange. It's modal like vim, but doesn't (imo) feel as smooth. It's main draw is that it is on nearly any system, since it's required by POSIX compliant systems. It's also useful when you pipe in commands from stdin. Beyond that I haven't put enough time into it to figure out how to efficiently use it...
Oh, don't worry about the "level" thing. The interviewers may ask questions from a broad range of CS topics anyway including OS (and kernel in some cases - depending on the position), particularly if you're interviewing for an systems/embedded/data-storage company, irrespective of the candidate's knowledge on the subject. However, those usually come during the onsite/face-to-face rounds after the candidate has cleared the coding challenge over phone. And the coding challenge, with very exceptions, consist primarily of "DS and some algs". Like you mentioned, you've good knowledge of data structures and algorithms. We are pretty much on the same boat then. In fact am pretty weak with algorithms myself. So, do you wanna give it a shot? After all, we all have gotta start somewhere.
What you want to make sure is that this book is covering C99 and not C89. The newest version of C is C11 but C99 is good enough because without getting too nitpicky basically C11 just added standardized threading and atomicity to what C99 already specified. TL;DR: C11 &gt; C99 &gt; C89
gcc/clang, vim + gdb, depends on project
You might want to read [21st Century C](http://www.amazon.com/21st-Century-Tips-New-School/dp/1491903899/ref=as_li_ss_tl?ie=UTF8&amp;qid=1464532007&amp;sr=8-1&amp;keywords=21st+century+c&amp;linkCode=ll1&amp;tag=reddit--20&amp;linkId=6888207eba394a1e9f66df9c54c7cf0b) in addition to the book you have, but honestly any book published after 1990 is probably fine.
Actually now that you said embedded, I remembered I have a bit of experience working with ARM chips (which use C, like the LPC11xx series) and FPGAs like the ones used at universities, so I'm not completely in the dark on that stuff, but I'm more familiar from an electrical perspective with the ARM chips. And yeah, I'm pretty weak with algs too, mostly just familiar with some random ones here and there, but I'm a math guy so I'm happy to learn more :D Given that, I'm still on board if you're up for it! I'll message you!
That's actually what I'll probably end up doing, go to the library. I always forget that the library is a great resource for coding books. Shame on me. It's walking distance from my apartment, too.
I still kinda stick to the convention of declaring variables first in a function as was dictated by C89. If my list of declarations starts getting confusing, there's a good chance that I'm trying to cram too much stuff into one function and should probably rethink the design. Of course I don't treat it as a hard rule though.
If you want to actively ensure it, you can compile with `-Wpedantic`.
I'm pretty sure it's as simple as not using any of the GNU compiler extensions.
Awesome! Let's get started then. I'll PM you the details.
Interesting, may I ask why you prefer Atom? I took a look at it and I didn't find it bad but I also didn't see any real advantages over other text editors or anything which would make me want to use it. What do you like about it most?
I'm sure there are a lot of text editors that would do just as good as Atom but I personally like the many plugins available. It is also lightweight and loads fast. Even Notepad would be better than the editor that ships with Keil uVision. For some reason all the embedded text editors look and feel like they were made in the eighties. 
I code mostly on a mac (then move my code to a linux server for actual execution ... scientific computing can lead to very long run times). I use: * Atom * clang * lldb * mpicc * make * git * homebrew
I mean I don't want come across as facetious but a pen and paper are also text editors it doesn't mean they are the most efficient option. If you wanna fix a typo remotely sure but as a main editor is kind of putting yourself through a lot of unproductivity burden.
* GNU screen + vim. * I prefer clang to gcc during development. * scan-build for static analysis. * "valgrind --tool=callgrind" + kcachegrind for statistical profiling. * valgrind for leak detection but I've heard [Google sanitizers](https://github.com/google/sanitizers) are better.
This question is not related to C programming. Please ask elsewhere or construct a relationship to the C programming language.
If the machine has Nano, odds are it has VI or VIM for that matter.
* Any text editor (Geany, Nedit, Joe, Vim, Notepad++, ...). * No IDE, never ever, unless someone holds a gun to my head (and it has to be loaded). * No debugger, ever (well, 1994 must have been the last time I used one). printf/RS/LED/scope debugging. * gcc, or the manufacturer's crappy compiler if needed by the target. Makefiles. * Unit test &amp; code coverage : whatever is imposed by the client if there is a client; else nothing. * Extra : a bit of valgrind sometimes.
Also use a non-broken compiler (i.e. not gcc).
Not CLI, but TUI.
vim, cscope, gcc, gnu make, gdb, valgrind, autotools, libtool.
gcc has some weird quirky behaviour, like allowing arithmetic on `void*`. My comment wasn't 100% serious though.
Surely I'm not the only one who uses Windows? * Windows 10 * Intel compiler * Sublime * nmake * Occasionally Intel's profiling tools inside Visual Studio * Catch for unit testing * mingw so that I can have grep, etc Honestly I have very few issues with windows, but maybe I've just been lucky to never encounter a library that I couldn't fairly easily get working.
linux/Mac OS : - gcc/clang with Qt Creator Windows: - gcc/msvc compilers with Qt Creator
Using field width specifiers should prevent the buffer overflow issues with scanf, but why don't you _always_ use them. Specifically, in two places you use %[a-zA-Z0-9] to read input into car, which is an array of 2 chars. This means the max field width should be 1 (leaving 1 for the terminating nul). I think you should change them to %1[a-zA-Z0-9]. Also, the code as given won't compile - so it's hard to say anything conclusive about it. Why is normal_play_format an array? You don't do meaningful indexed access to it. It seem like two separate char*'s would be more straightforward. As you already said, better variable names could make this a lot more readable. E.g. scanf returns the number of successful assignments performed. You store these results in flag_s and flag_input. Neither name is particularly descriptive and they both seem so wildly different and you treat flag_input as if it's a bool. I also think restricting yourself to one declaration per line would improve readability. 
* CMake, compiling to Make. * CLion, Sublime text for smaller things. GDB by terminal to debug. * Dr. Memory. * We've an in-house unit-testing framework called PlanckUnit. * OS X for environment. I'm an embedded systems developer.
 * Using `a-z` in a format string is *implementation-defined*. You seem to be assuming that it is a shortcut for `abcdefghijklmnopqrstuvwxyz` but that is not guaranteed; if you observe such behaviour you are at the whim of whatever scanf implementation you are using. * `if (*car != '\n' || !flag_input)` reads uninitialized variable `car[0]` if input failed; you should check `flag_input` before reading `car`; and specifically, check `flag_input != 2` in case the first one succeeded and the second didn't * Use of `clear_buffer()` cannot work for all cases (sometimes your scanf leaves `\n` in the buffer and sometimes it consumes it, with no way that this function can know) * `sscanf(play_str, normal_play_format[0], play_row, play_col_c, car);` causes buffer overflow for some input strings (there is no limiter on the length read into `car`). Same problem on subsequent sscanf Really.... it's going to be easier not to `scanf` here. 
scanf is ok for input, but difficult to validate properly. So some folks assert that it should never be used, taking a general guideline and turning it into a maxim. *Never* using scanf is pedantic. Avoiding scanf when possible is a good guideline.
* GCC and clang * Emacs, gdb * Aggressive warning flags, clang static analyzer, valgrind. Occasional vain attempts to get more rigorous tools like frama-c to work * lcov and gcov * Python for all glue, build system (waf), unit testing, etc
I do. But I often use cygwin.
I haven't set it up with package manager yet, but you can clone the source [from github](https://github.com/ThomasGerstenberg/serial_monitor) into your plugins folder. It's not fully tested with all platforms and ST versions, but is known to work with ST3 and windows and OSX (Linux probably does work, but I haven't tested with it yet :) ). ST2 probably also works
Please try to give future questions a better title. “Intro to C... fml” is a useless title. That said, what have you tried? Where are you stuck? You can't just dump your homework in here and expect us to do it.
Also OP, if you hate your class so much, why not drop it? No sense in going through something you hate if it's not required for your major.
Break up the problem: How do you take user input? How do you manipulate numerical data? How do you print output? How you would repeat each of these for 100 faculty?
I'd have to agree. I looked at your website. Very impressive. 
This is 32 bit assembly. You need to compile it into a 32 bit program. Pass `-m32` to the compiler to do that. Doing system calls works slightly different in 64 bit mode and the instructions would be different, too.
Does it work if you use `mov` instead of `pop`? The compiler might have inserted some stackframe shenanigans, so that just popping won't work. Also, if you compile to 64-bit, the calling convention avoids using the stack, so stuff would be in registers instead.
What you are doing seems to be a fine way to learn but you don't need assembly to write a system call. You can learn a ton (albeit different things from what you are doing here) by actually writing a system call. Create a vm and install linux on it then follow a tutorial for adding system calls.
You’re thinking about your assembly bits wrong, and you wrote a 32-bit system call that you’re apparently building on a 64-bit system. I assume you’re targeting GCC/Clang; use `-m32` to generate 32-bit output. The compiler doesn’t care or know about what you do in an `__asm__` block (use the kind with the underscores for reasons; `#define asm __asm__` if you must) unless you tell it explicitly, and you’re not doing that at all. If you use a register, you might overwrite something the compiler expected to stay constant, or the compiler might overwrite something you expected to stay constant. Moreover, if you break up into multiple asm statements, in between them the compiler can do anything—fill, spill, kill, whatever it wants as long as the overall effects look right from its perspective. So to fix this, first you’ll want to guard everything with platform and ISA checks so you don’t accidentally build wrong and bork something. You do this via preprocessor `#if` and `#ifdef` statements. Platform: #ifdef __linux__ // Linux things here #elif defined(_MSC_VER) || defined(__WINNT__) //etc. #else # error "unrecognized target platform" #endif (Because every platform has its own library and system call ABI[s].) Architectures (all existing x86): #ifdef __i386__ // 32-bit x86 here #elif defined(__x32__) &amp;&amp; !defined(__MIC__) // 32-in-64-bit x86 here #elif defined(__x86_64__) &amp;&amp; !defined(__MIC__) // 64-bit x86 non-Phi here #elif defined(__MIC__) // 64-bit MIC here (mostly the same as x86-64, probably will be for syscalls) #else # error "unrecognized target architecture" #endif // There may be a MIC32 ABI; I haven’t encountered it in the wild yet. Obviously, only include what you feel like targeting for starters. Note that this will also tell readers exactly what you’re targeting, so you can post more questions easily \^_\^. Now, you need to construct your `__asm__` statement. See [here](https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html) or the corresponding page in your local infopages for more—it works very differently from the old Microsoft or Borland compilers in this regard, which looks like what you expected maybe? (`asm` is a nonstandard C extension; every compiler can do its own thing.) The compiler can (and should, when possible) marshall things into/out of registers for you, and you should never touch the stack (i.e., *do not* leave the stack in a state that differs from how you found it, and make no expectations about its initial state) unless you’re fully ready to deal with the ABI and compiler peculiarities that arise thereafter. For a 32-bit system call, every input and output is in a register, so *the only thing in your `__asm__` string should be `int 0x80`* or whatever system call mechanism you’re using. Everything else should be left up to the compiler. __attribute__((__warn_unused_result__)) ssize_t my_write(int fd, void *buf, size_t size) { register int out; assert(!!buf); // or whatever checks you can run here do { register int ebx_fd __asm__("ebx") = fd; __asm__ __volatile__("int 0x80" : "=a"(out) : "0"(4), "r"(ebx_fd), "c"(buf), "d"(size) : "memory", "cc"); } while(0); return out; } Some notes on this: • The return type is not `int`, AFAIK, it’s an `ssize_t` which is &lt;0 if there’s an error and ≥0 (written size) otherwise. • The glibc `write` includes the `warn_unused_result` attribute to nag people who don’t check the returned length, which is usually a good thing to nag about. You’ll probably want this `__inline__` too if you’re actually using it, and if you trust yourself not to pass `NULL` as the buffer you might want `__nonnull__` also. Both of these should probably be version-checked to make sure the compiler supports them. • General format for a normal-ish `__asm__` is __asm__("CODE" : OUTPUTS : INPUTS : CLOBBERS) `__asm__ goto` follows sliightly different rules and is a newer feature, whereas `__asm__` has existed since GCC’s inception AFAIK. • The outputs I entered include only EAX (`"a"`, with `"="` denoting assignment to rather than from). If EDI, ESI, or one of the input regs is clobbered, mark it in outputs or clobbers. For example, if EDX might not still be `size` after the call, you’ll want to change the two sections to : "=a"(out), "+d"(size) : "0"(4), "r"(ebx_fd), "c"(buf) which will mark `size`-in-EDX as modified rather than input-only. Since you aren’t using EDI or ESI otherwise, you can either add them as outputs (`"D"` or `"S"`) or clobbers (named normally, `"edi"` or `"esi"`) if they’re borked by the syscall. You can’t include something in the clobbers if it appears in input/output. • Clobbers here must include `"memory"` because the kernel writes to `buf`, and `"cc"` since the kernel probably doesn’t save/restore flags perfectly. • EBX is a damn mess on 32-bit x86. It’s untouchable per ABI if you’re in `-fpic` mode (points to the current module’s table) and normal callee-save if not. That means that, if you include code in a DLL, you can run into a compiler error if you try to use `"b"` as an input or output, or try to clobber `"ebx"`. Doing the `register __asm__` trick above is the best way I’ve found to use EBX cleanly, within the compiler’s knowledge, and without inducing translation or internal errors. (Tread very carefully if you do otherwise, easy to confuse or ICE the compiler.) It tells the compiler to create a variable pinned to EBX, and matches it to `"r"` in the `__asm__` statement; since it must already be in EBX, the register chosen for that will be EBX. You can do this with any general register (maybe others too, I don’t recall), and depending on the compiler version it may guarantee that a `register __asm__` variable is in its declared register for any `__asm__` statement, although I’d just do the `"r"` trick to make sure anyway. • The `0` in the first input specifier refers to argument 0, `"=a"`, and tells the compiler to use the same operand as for that output. You can’t generally specify the same register both as an input and output because the compiler will try to allocate it twice; this lets you reuse the register with the compiler’s blessing. • Most 32-bit x86 Linux systems now use a special call page at the top of the virtual address space that invokes a system call in a fashion appropriate for the ISA. Might use `int 0x80`, might use `lcall`, might use `syscall`, might use `sysenter`. `int 0x80` is just the oldest and most-guaranteed method of doing it. Other systems do completely different things, depending. AFAIK x86-64, MIC, and x32 should all use the same (non-32-bit) methodology on Linux based on `syscall`, although their user-mode ABIs may differ somewhat. General notes: • If you use a register at all, try to tell the compiler about it. Don’t just include moves or pushes or pops or whatever; the compiler is better at arranging things, and in fact has huge swaths of its source code devoted to picking the right layout for variables ’n sech. You don’t know better than it, generally speaking, and in inlining situations you can see surprising transforms applied. • Do not assume a lack of optimization. As mentioned, ICC will optimize inside your `__asm__` if it can; by default, it handles assembly internally, but try `__asm__(".if 0\ncpuid\n.endif");` out at the global scope to force it to write to an intermediate assembly file. GNUish linkers can do LTO also, so even once the code is generated in an object file it can dump something completely different into the output binary. • Do not refer to registers by name if you have a choice; refer to them either by number (e.g., `%0` here would expand to `%eax`) or label (newer feature; you can put `[name]"=a"(out)` and use `%[name]`). Label if possible, because it lets you do more than 9 things and is easier to read or rearrange; number if you’re worried about compatibility or just spitting some quick code. If you refer to a register explicitly, make sure you specify its size (brackets around 64-bit-only things): %b0 AL CL DL BL [* BPL SIL DIL R8L–R15L] %h0 AH CH DH BH %w0 AX CX DX BX SP BP SI DI [R8W–R15W] %k0 EAX ECX EDX EBX ESP EBP ESI EDI [R8D–R15D] [%q0 RAX RCX RDX RBX RSP RBP RSI RDI R8–R15] Similarly, `%b[label]` for labeled variants. The infopages/above link give you a full list per arch. • The code you pass `__asm__` is a format string, like with `printf`, only its output goes into your code’s intermediate `.s` file. (Try `gcc -S` and you’ll see it in the output.) If you want to include a percent (e.g., for `%xmm0`) you’ll need a doubled percent sign (`%%xmm0`). If you want a line break or tab or whatever, you’ll have to include `\n` or `\r`. Make use of literal concatenation in this case: __asm__( "line 1\n" "line 2\n" "line 3"); • Not all parts of the `__asm__` statement work normally concatenation-wise on all compilers. Older GNU compilers will not accept (e.g.) `"=""a"` as an output specifier or `"e""ax"` as a clobber, although code is always concatenated normally AFAICT; if you’re generating the former with a macro, you’ll have to stringize after building the full specifier. In other words, macro 1 puts =a together and passes it through a reducer to macro 2, which stringizes to token `"=a"`; for clobbers, macro 1 token pastes `e` and `ax` togehter (hopefully without hitting any macros named `e` or `ax` in the interim) and then macro 2 stringizes to `"eax"`. Newer compilers ~generally don’t care, but don’t rely on it.
NP, this is one of my favorite kinds of sub-C programming, &amp; always reassuring to see that there are still people out there who gaf what’s under the “comfortable” parts of the software stack.
Thanks for the interesting response; I didn't know that. I still don't understand size_t/ssize_t very well. Do you know of any online resources that can give me a correct and explicit explanation of these data types?
The correct answer is to read the standard (look for a document called N1570). `size_t` is the type of the `sizeof` operator's result, cf. ISO 9899:2011 §7.19 ¶2. It is the type you should use to describe the size of objects; stuff like buffer lengths or indices are common usages. Typically, it's the same type as `uintptr_t` but that doesn't have to be the case (e.g. on segmented architectures like 8086 in real mode where uintptr_t is a 32 bit type and size_t is a 16 bit type). 
That makes sense, thanks for the response and your time. Are there benefits to using size_t to represent buffer length or indices as opposed to just using another unsigned data type? What is the purpose of size_t if there already exists data types to accomplish these tasks?
I think I understand you now. Thanks for your time.
No, you can't do that. There is nothing that guarantees that size_t and long long are the same size, and that's also not how promotions work at all. If you want to print a size_t, use the appropriate format specifier (i.e. `%zu`) or cast it to some other type for which you have a format specifier available and that you know is wide enough to hold all the possible size_t values. The integer promotions are only about converting types that are narrower than int to int. You should really read the standard for the full rules. This is covered in &amp;sect;6.3.1.1. But in essence, whenever you use a value in an arithmetic expression, the promotions apply. For example, adding two chars results in an int, not a char, because the chars get promoted to int before the addition happens. This does not apply to types wider than int, so it's irrelevant for the situation you're asking about. There's another related topic called the usual arithmetic conversions (&amp;sect;6.3.1.8) which is concerned with finding a common compatible type. For example, if you try to add long and unsigned int, what's the result type? The result is very tricky and subtle, as it depends on the widths of the types, which means it's platform dependent. This is where people can get tripped up, so you should definitely read that section of the standard. And unlike the integer promotions which are always value-preserving, these conversions can result in outcomes where the values are changed. Be careful that you understand that this does not mean that some type will automatically convert to a wider type if an operation calls for a value that would not fit. That's not what is happening at all. This decision is not made at runtime, and it does not consider the actual values of the variables at all. It is purely about the types of the two operands.
Yes, and most of the 32-bit instructions zero out the top 32 bits—unlike the 16-to-32-bit transition, where affecting AX leaves the top 16 bits alone—so something like `add eax, 4` is really a 64-bit operation mod 2^32. The 64-bit instructions are also another byte longer in the general case (that prefix kludge I mentioned, called “REX” = “register extension”, plus the later VEX, EVEX, and MVEX prefixes), so you should stick to 32-bit when you can. The exceptions to this are `push`, `pop`, `lea`, stuff that deals with pointers where it would be silly to force a 32-bit default.
It's not *lying* per se, it was just communicated here incorrectly. Here's what the manual actually says: &gt; *On systems using the GNU C Library*, this will be unsigned int or unsigned long int. 
gcc/clang/mingw, Emacs, GNU make, gdb, valgrind, Linux, Cygwin occasionally, perf (gprof is useless). I rely on gcc's warnings and sanitizers for static analysis. 
I am a win developer mostly. But I use MinGW and Bash so, you could say my actual development environment is bastardized nix.
How is Intel's compiler? I use MinGW64, but I'd like to use Intels... it's so damn expensive though.
Each variable has its own unique address. But you can't really say any more than that. How the memory will be laid out depends on countless details. Variables defined at function scope have automatic lifetime, whereas variables declared at file scope have static lifetime, and the way the two allocations work is quite different. And even just speaking of automatic lifetime (i.e. things on the stack), there are all kinds of factors that come into play that can affect the layout, such as padding to keep the stack pointer aligned, extra space required for spill slots, and so on. And these all depend on the platform (which includes the calling convention and ABI), the compiler, the compiler options used, the version of the compiler, etc. 
If you read down to where he talks about intptr_t and uintptr_t he says that's it's "possible" for two pointers to the same object, when cast as integers, not be the same integer. This would defeat a hash table since identical objects must hash to identical values. He speculates about circumstances under which this could occur, and it's possible that you might even want to consider them point to different objects under those scenarios anyway - i.e. so maybe not a problem. Also, should be ok to cast to and from intptr_t or uintptr_t.
* tcc * nvi + brain * compiler, gprof, valgrind * C, diff, xxd for analysing binary files, ... * usually make for building. mupdf, nvi, and tr -d '\r' for reading documentation, specs, etc.
Sorry but I don't watch this show :/
The size of the variable depends on its type. It could be anything from one byte to all the available memory (e.g. a large array.) 
you are saying each adress my char A,int B,Char C wil store 0x1000 A 0x1001 B 0x1002 C 
No, because that would mean that `sizeof(short) == 1`, and that's impossible unless you're using some really bizarre platform. The standard doesn't say what `sizeof(short)` is, but it does specify that `SHRT_MAX` must be equal to or greater than 32767 and `SHRT_MIN` is equal to or less than -32767. On systems that use two's complement and have `CHAR_BIT` equal to 8 (which is most of them), that means that `sizeof(short)` must be at least 2. It is equal to 2 on most common platforms. But even if I know the value of `sizeof(short)` on whatever platform you're using, I still couldn't tell you the layout. There is nothing that says they have to be laid out in memory in the order they were declared. Moreover, there could be arbitrary amounts of padding in between any two variables. As I said originally, the only thing that you can conclude is that they will have unique addresses. Nothing more than that can be determined. 
Please give your question a meaningful title. “About C Progrramming” is not a meaningful title.
mention some books sir please
Oof. That's a lot of complaints. We're compiling for Blackfin using VisualDSP++. It claims to be an IDE, but for editing it's just a dumb text editor; it has no source indexing or autocomplete. If you're connected to JTAG and have symbols loaded, it can use that to go to the definition of a function, but that's it, and there's no "go back to previous cursor" ability. The debugger is similar, all floating windows that you can dock, although I suppose most visual debuggers look similar. I have some complaints about it (namely that when the compiler optimizes variables to be kept in registers, the debugger loses the ability to show that variable by name; you have to stare at the disassembly yourself and reverse-engineer what register it's being kept in) but it's otherwise mostly competent.
Thanks for the reply.
My mistake, I should have noticed that.
`void *` array? You might struggle to get decent alignment in memory though.
I'm really happy with it. I'm in computational physics (when the OP said professional I took it lightly, I'm a grad student) so what I do is very heavy on tight compute loops. It's easily worthwhile in terms of speed boosts but as a student I get a free license. I went and ran some tests for you. On a nice little program that does matrix decomposition I got the following results (Cholesky decomposition of a 1500x1500 matrix on my i7-4720HQ laptop, averaged over 3 runs each, variation between runs was on the order of 0.01s anyway): Intel 16.0.1.146 (2015): No optimisation (/Od): 5.33s Optimisation (/O2, /O3): 0.25s MSVC 19.00.23506 (2015): No optimisation (/Od): 3.10s Optimisation (/O2): 0.52s GCC 4.9.3 from MinGW: No optimisation (-O0): 4.14s Optimisation (-O3): 1.64s Another advantage is better coverage of C99, MSVC still doesn't even support variable sized arrays, I don't know about GCC, I never use it. It's also really nice to have access to Intel's BLAS/LAPACK, even the single thread implementations in there are orders of magnitude better that the best parallel implementations that I can write (although I'm admittedly fairly new to writing in parallel). I also mentioned the profiling tools in my original comment, they have more control than those built into Visual Studio and anecdotally seem to give more consistent results. Hope the information is interesting to you.
1. Whether a CPU is 16-bits or 32-bits depends upon your view of the CPU. To a hardware designer, the Motorola 68000 is a 16-bit CPU as it has a 16-bit data bus to memory. To a programmer however, it's a 32-bit CPU as it can deal with 32-bits at a time. The 68020 had a 32-bit data bus, but the 68008 had an 8-bit data bus. Inside all three, however, is a 32-bit CPU. 2. Systems today (with a few very rare exceptions) are byte-addressable. Each address points to only 8-bits of data. Sure, some CPUs, on some operating systems, with some compilers, will store 8 bits in 2 bytes, some 4 bytes, others 1 byte.
Find yourself a sparse matrix structure to use. OpenCV has one, but you might find something more to your liking elsewhere. Instantiate a sparse matrix for each data type, and write into those. You'll have to do multiple lookups to find your data which will impact execution time, but you should see a drastic reduction in memory usage
You will need the type tag regardless, unless you know this information from some other context. A common solution for situations like this is to have a struct which contains the common header information (type in your case), followed by however much memory is required. For example, using a c99 flexible array member: struct table_element { char type; char mem[]; }; You then malloc each struct with the appropriate size, say, `sizeof(struct table_element) + sizeof(double)`. You can cast mem to the appropriate type based on the type tag, but you have to be careful to do all your allocation, accesses, and casts correctly, since the type system can no longer help you. If you don't want to rely on c99, you can simply omit the mem field entirely and access the data at (table_element_ptr + 1).
Thanks for the input.
Very interesting :) I am into computer graphics so also quite math heavy. Thanks for the info. Will have to see if I too can wrangle a student license from them.
http://www.gdal.org
Hey! You just encountered a "scope problem". Basically, the `sel` variable is *out of scope* for the `function` function. There are several solutions: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; static char sel; void function (); int main (void) { function (); return 0; } void function () { scanf("%c",&amp;sel); } In this solution, we moved the `sel` variable outside of main, and added the `static` keyword. It means that this variable will be accessible *everywhere in this file*. Let's have a look at the second solution: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void function (); int main (void) { char sel; function (&amp;sel); return 0; } void function (char *sel) { scanf("%c", sel); } This solution would be the most common one, yet I recommend you stay away from it right now unless you know about pointer. in `main`, we added `&amp;sel` in the `function()` function call. it means we're providing `function` with a copy of `sel`'s address in memory. Notice how we removed `&amp;` in `scanf`. As you learn, you will understand the second solution. Don't worry, we've all been through pointers :) I recommend you stick with the first solution as for now. Good luck and have fun learning C!
 **Programming in C (Developer's Library)** |||| --:|:--|:-- Current|&amp;#163;18.63|Amazon UK (3rd Party New) High|&amp;#163;74.49|Amazon UK (3rd Party New) Low|&amp;#163;17.00|Amazon UK (3rd Party New) |Average|&amp;#163;66.49|30 Day [Price History Chart and Sales Rank](http://i.imgur.com/ai6ihWs.png) | [FAQ](http://www.reddit.com/r/PriceZombie/wiki/index) 
`getline` updates the characters in the array it is given. What is happening is that `getline` actually sees `s` as a block of memory, the same block that `main` sees, and so when it changes values in that block `main` can see those changes as well.
The thing to note here is that `line` in `main()` and `s` in `getline()` refer to the same memory address. So when `s` is modified in `getline()`, the contents of `line` are also updated. This concept is sometimes (somewhat incorrectly) called [pass by reference](http://denniskubes.com/2012/08/20/is-c-pass-by-value-or-reference/). It's also how functions like `scanf()` return data to the calling function.
If its the case you only need some distance calculation the use the haversine formula like shown here http://www.movable-type.co.uk/scripts/latlong.html No need for a library, since you never know if its tailored for you platform when running in embedded environments. If its more complex stuff ... well gdal like /u/shunbit said. 
I like the new design, it now feels better to my eye. However, you can only barely read the "tab link", e. g. the "comments" next to the title. [Picture](https://puu.sh/peaNn/36f613045f.png). Also the space between the "reddit title" and the content looks kinda unusual.. I don't really mind, but i think the space can be better used for the actual content/post.
tldr arrays are implied pointers
To elaborate, a quick'n'dirty way to seed the random number generator is to call srand(time(NULL)); once early in the program. This seeds the random number generator with the current time which should be different each time you run the program if you don't do that too quickly.
Is C the right tool for this? Maybe you should be doing this in a SQL database, and let it worry about accessing all the data when it can't fit in memory all at once.
`rand` and `srand` seem like black magic until you see how trivial their implementation is: unsigned random; void srand(unsigned seed) { random = seed; } int rand() { // These numbers differ from implementation to implementation random = random * 214013 + 2531011; return random &lt;&lt; 1 &gt;&gt; 17; } 
Here's a comment : https://www.reddit.com/r/C_Programming/comments/49uscc/arrays_of_bitfields_function_arrays_and_other/d0v2uqm This is my first real C program, a top-down curses shooter: https://gitlab.com/RobertCochran/poundshot Retrospective: The Good * I finally had a version that worked (this is probably rewrite 3 or 4, I can't remember). * It played fairly well. Was decently well regarded among my friends. * Up to that point, was the first game I actually completed. The Bad * Everything I listed at the bottom of the README (I put the program up so that some friends who were learning C for an event we were going to had a starting point to play with). I was not particularly good at C (or good programming practice!) and it shows. * The game is pretty bland - no powerups, no different enemies. * There is a point where the enemies start moving too fast and meaningful play becomes near impossible. Getting much higher than a certain point scorewise (IIRC, somewhere in the 4k - 8k range) is impossible. But hey! I did it! And that's worth quite a lot in my opinion. If I manage to win the book, would like *Elements of Programming Style*, please.
You are correct, the C standard has nothing to say about common data structures/algorithms. The C++ standard, however, provides a rich standard library in this regard. For C, there are a lot of options, including just rolling your own specific to your needs. Here are some in no particular order, and this is by no means comprehensive: * [GLib](https://developer.gnome.org/glib/stable/) (Gnome Lib, not to be confused with glibc, the GNU libc runtime.) * [APR - Apache Portable Runtime](https://apr.apache.org/) * [Gnulib - The GNU Portability Library](http://www.gnu.org/software/gnulib/) * [SGLIB - A Simple Generic Library for C](http://sglib.sourceforge.net/) * [GDSL - The Generic Data Structures Library](http://home.gna.org/gdsl/) * [AT&amp;T Software Tools](http://www.research.att.com/software_tools?fbid=lth8OHtryYT) *Edit: Formatting*
I don't think OP really knows what pointers are.
&gt; Why/how would the standard define data structures? I'm thinking similar to how C++ provides stack, queue, etc. implementations in the standard library 
&gt;For global constants I usually use code like this: &gt; enum { DEVICE_NONE , DEVICE_PRINTER , DEVICE_DEBUGGING , DEVICE_PINPAD , DEVICE_SCREEN , DEVICE_TCP , NUM_DEVICES }; This is a weird use of commas. &gt; typedef unsigned char DEVICE_ID; From the Linux Style Guide &gt;Lots of people think that typedefs "help readability". Not so. They are useful only for: (a) totally opaque objects (where the typedef is actively used to _hide_ what the object is). Example: "pte_t" etc. opaque objects that you can only access using the proper accessor functions. NOTE! Opaqueness and "accessor functions" are not good in themselves. The reason we have them for things like pte_t etc. is that there really is absolutely _zero_ portably accessible information there. (b) Clear integer types, where the abstraction _helps_ avoid confusion whether it is "int" or "long". u8/u16/u32 are perfectly fine typedefs, although they fit into category (d) better than here. NOTE! Again - there needs to be a _reason_ for this. If something is "unsigned long", then there's no reason to do typedef unsigned long myflags_t; but if there is a clear reason for why it under certain circumstances might be an "unsigned int" and under other configurations might be "unsigned long", then by all means go ahead and use a typedef. (c) when you use sparse to literally create a _new_ type for type-checking. (d) New types which are identical to standard C99 types, in certain exceptional circumstances. Although it would only take a short amount of time for the eyes and brain to become accustomed to the standard types like 'uint32_t', some people object to their use anyway. Therefore, the Linux-specific 'u8/u16/u32/u64' types and their signed equivalents which are identical to standard types are permitted -- although they are not mandatory in new code of your own. When editing existing code which already uses one or the other set of types, you should conform to the existing choices in that code. (e) Types safe for use in userspace. In certain structures which are visible to userspace, we cannot require C99 types and cannot use the 'u32' form above. Thus, we use __u32 and similar types in all structures which are shared with userspace. Maybe there are other cases too, but the rule should basically be to NEVER EVER use a typedef unless you can clearly match one of those rules. &gt;So I am contemplating using a convention like `DEVICE_ID_T` , i.e. ending in `_T` distinguishes type names from enumerators. 
If you don't use a debugger when one is available I would struggle to call you anything but a novice.
Implement your own! It will be a great programming experience.
Yes, that's a "compound statement" according to the Standard.
"Stack" and "Heap" in C are not "data structures", they are attributes of the machine on which the program is running. "Stack" = place where local variables are placed "Heap" = allocated memory This is different from a "stack" implementation in C++.....
I tend not to start a debugger until I've exhausted what I can do with `printf()` and the like
Need to code block this - Reddit is formatting it and doing a terrible job
yeah, super safe
If you use a debugger then you don't need printf. You can use it to see what a variable's value is and you don't need to wait for your program to recompile if you want to see the value of a different variable elsewhere in the code.
AAAAGGGHHH but if you load the core dump file into GDB along with the executable, you literally have to type "where" and it will tell you the exact line number the program faulted on. A segfault debug session typically looks like this for me, assuming I'm debugging a Linux device booted via NFS: $ cp /srv/nfs/core.1234 . $ arm-custom-thingy-gdb /srv/nfs/usr/bin/myprogram core.1234 (gdb) $ set sysroot /srv/nfs (gdb) $ where &lt; Insert stack trace telling you exactly where things went pear-shaped&gt; It's the greatest damned thing in the world. Watching people debug segfaults with printfs makes me stabby. edit to not sound like such a dick: this always takes a non-trivial amount of work to get going. You may have to run gdbserver on the target and debug it from your host. There is a fairly steep learning curve. It requires learning new things. But it absolutely worth the time up front to get it running, and to save watching someone "accidentally" commit code with printf's on every other line. I mean, printf("%d\n", __LINE__); serious_business(); printf("%d\n", __LINE__); drives me to drinking. Edit 2: I just realized I do embedded cross-compiled stuff, where setting up and running gdb is often very hard, so I answered that way out of habit. I always do it anyway, because printf debugging is for animals. If you are compiling on your target, for your target, and you have a native gdb, why wouldn't you use it? WHY? I SHAKE MY FISTS AT THE HEAVENS
It's absolutely essential. Don't forego your debugger, it's incredibly naïve to not use it.
I've also been in horrid situations where a printf has VERY different buffering characteristics than __MY_CUSTOM_DBG_PRINT__("here"), or in microcontroller land, writing directly to device registers... Debuggers are much better at showing you what's happening NOW, instead of "when my OS decides to finally poop this out onto my terminal at 115 kbps."
As a game developer I, and my programmer coworkers, use the debugger 999 out of a 1000 runs of the game. Only artists, designers, and QA run without a debugger...even then a good percentage of them do. I also use a debugger for even my simplest one off command line tools. My debugger is my most important tool. I don't care about anything else on a new platform/hardware until I work out how I can work a debugger into it. Being proficient with a debugger is also important to me when interviewing candidates.
[µnit](https://github.com/nemequ/munit) and [squash](https://github.com/quixdb/squash) are two very interesting projects. The former is a small unit testing framework and the latter a compression abstraction library with dozens of backends including Brotli! I personally like GLib and the related very much: - JSON-GLib - libsoup a HTTP client/server library supporting websockets - GIO provide nice I/O abstraction including sockets, streams and async tasks That you like GNOME or not, it's built upon high quality, decoupled and introspectable C libraries. All of this is available in Python, JavaScript and Vala :) More here: https://git.gnome.org/browse/
Everyone uses a debugger.
For almost any situation, you will likely spend less time in a debugger that introducing `printf` everywhere. If you use GNU/Linux, compile with `-mdebug` and launch your program with [Nemiver](https://wiki.gnome.org/Apps/Nemiver), it's a very nice gdb UI. 
To add more, since C has a purely lexical scope, you can use it to hide variables: int f () { { int i; i = 0; // permitted :) } i = 0; // forbidden, i is not declared in this scope }
Much more readable! #include &lt;stdio.h&gt; main() { puts("hello world"); } Though, you might still want to have a shot at the headers.
While this is correct, [stacks](https://en.wikipedia.org/wiki/Stack_\(abstract_data_type\)) and [heaps](https://en.wikipedia.org/wiki/Heap_\(data_structure\)) are also data structures, even though *the* heap is not *a* heap.
As a naive child, I swore by printf debugging; I was a moron 
Do you have any previous programming experience, or is C the first programming language you're learning? When tackling a problem like this it can help to map out very roughly which steps are involved in this process. Is there some way to divide the problem into smaller pieces which are easier to solve, or which can be solved independently? Here's one way to do it: CSV is a simple textual format where each line represents a record. Before worrying about XML you could try to figure out how to read in a single record from one line of the CSV. The second step is to output XML from a record. This is independent from how you parse a record from CSV. If you want you can also do this step first. You could pretending that you've already parsed one record and feed a test record to the XML output procedure. Once you know how to read a single record from a CSV line and output it in XML it's easy to do it for many records. Do you know how many fields there are and how they are named? Sometimes the first line of a CSV contains the names of the record fields. If this is the case, parsing the record structure from one line of CSV is yet another step that you can solve independently from parsing CSV and outputting XML.
I think the padding between submissions is too large. Perhaps make it half as large?
Any details on that? What is the output supposed to look like? If you don't have to deal with weird input (e.g. characters that need to be escaped) it's quite easy to build something that works in 90% of the cases. However, I would use a shell script for that.
I have never heard of the "C++ Institute" on the list, any worth to getting their certification?
Right, I just wanted to be clear for OP that, if someone is talking about the "stack" or "heap" in C, they probably are not talking about a library that implements a stack or a heap.
Thanks for the reply. I ended up going with something similar to this.
good joke tbh fam iunno why people downvote it
&gt; start doing embedded I have no idea what that's supposed to mean.
&gt; This is a weird use of commas. I can't remember the name of this convention, but it's somewhat related to Yoda conditions. You know, like this: if (fooThing == NULL || quuxOtherThing == NULL || bob == NULL) if ( NULL == fooThing || NULL == quuxOtherThing || NULL == bob) // more readable; the repetitive parts are aligned so that the differences stand out In enums, the comma is the unimportant, repetitive part of the line, so it should be made as similar across lines as possible. Plus, when you add a new element at the end, you would normally have to add a comma to the previous line; that adds an unnecessary change to that line. Putting the comma at the front avoids that problem. (Fortunately, C doesn't care about an extra comma after the last element [or at least my compilers don't]. Not all languages or grammars are so lenient, though.)
Cheers for this, it's a good read just for the mathematics alone.
I really like this design. It looks just like programming in C feels (minus the elusive memory corruption bugs, of course.) Edit: one thing I'd like is for links I've already visited to be a markedly different color from ones I haven't yet.
My mistake, you're right, it's effectively `-g`.
Hmm I thought I took care of that, thank you for pointing this out. It should be fixed soon.
Can you please be more vague about what you are asking?
Here's the formal syntax for it: selection-statement: if ( expression ) statement statement: labeled-statement compound-statement expression-statement selection-statement iteration-statement jump-statement compound-statement: { block-item-list_opt } // _opt means optional Here's how we can derive your construct: if ( expression ) statement if ( expression ) compound-statement if ( expression ) { block-item-list_opt } if ( expression ) { } 
Looks nice but the scrunched up text is bit hard on my old eyes. Too many years trying to read the type on top of punch cards. I see someone else thinks it's easier on the eyes so no worries -- I'll just give it a little zoom.
In the trivial case, you need to add "-static" to the linker flags; if you're lucky, it may be as simple as running `make LDFLAGS=-static`. I don't know anything about the utility itself, so I can't really comment on specifics for this particular application.
I am old enough that this seems newfangled. I remember when support for this was spotty. I also remember turning ansi flags on and off to support code that didn't declare function arguments.
Aren't they void ?
`foo` and `bar` are functions returning void that takes a pointer to a function returning int taking int. `baz` is a function returning void taking a function from `int` to `int`, an `int` and another function from `int` to `int`.
That's sounds better. Nice examples you have there.
&gt; `baz` is invalid because after the second argument, y becomes an identifier that shadows its previous meaning as a typedef, and it cannot be reused a second time. That's exactly what gcc reports: error: redefinition of parameter ‘y’ void baz(int (y), int y, int (y)); ^ note: previous definition of ‘y’ was here void baz(int (y), int y, int (y)); ^ But 3.7.1 states: &gt; An identifier declared as a typedef name shall not be redeclared as a parameter. So technically, the compiler should already complain about the second parameter. Your reasoning about `foo` and `bar` is correct. Good job :)
Thanks!
Looks great. my only suggestion, change the font for comments. screenshot of how it looks on my desktop: https://imgur.com/ukMmNAZ.jpg
Here goes: Generally, an argument declared like a function is interpreted as a pointer to a function of that type. `foo` is a function that takes a pointer to function of unspecified argument types returning `int` as an argument returning `void`. The inner `x` has no significance in this declaration. After the `typedef` of `x` the similar looking `bar` is a function of a pointer to a function of one `int` argument returning `int`, returning `void`. The difference from `foo` is that for this declaration `x` is a type. For `baz`, my guess is that the first and third arguments are identical: `int (*)(int)`, and the second argument which is an `int` and happens to be named the same as the type alias `y` does not affect the other argument types. In C89 I don't think the `y` in the argument list shadows the global `typedef` `y`, but I could be wrong. I've never seen anything like that in real code. In summary: void foo(int (*)()); void bar(int (*)(int)); void baz(int (*)(int), int, int (*)(int))); // or maybe void baz(int (*)(int), int, int (*)());
By default, arguments are passed by value, which means when the function is called, it creates *new* variables "a" and "b", with values of the function arguments. These variables cease to exist when the function returns. For functions that modify only a single variable and have no other return value, you can use something like: /* makes input uppercase */ input = uppercase(input); But in your case the best option is to use pointers, as u/liillliillliiii suggested. A pointer refers to the address (location in memory) of a variable, and when you dereference that pointer to access or modify the variable, you're actually manipulating the data stored there, rather than making a copy.
Would if(a != b) { *a ^= *b; *b ^= *a; *a ^= *b; } work?
&gt; which could happen if he uses pointers, and he kind of has to in this case. I prefer a macro that takes the type for swapping variables(as opposed to passing pointers to a function). For such a simple operation I've found it the most robust. And I never use swap in a way that sees any downsides to macros. Edit: This is in regards to temp variable swapping. Not xor swapping which I don't use.
No, `void` is just the return type. For example, the type of `void f(float, double);` would be `void(float, double)`.
Future-proof yourself by learning several languages. The most important thing is your ability to learn, comprehend, and adapt to new situations. Never put all your eggs in one basket, as the saying goes. I have never exclusively used C for a particular project. I have used various languages in different situations so solve a variety of problems: ladder logic, web development, embedded programming, and mathematics. C has played a role In all of these areas. C is a widely used language and will continue to be so for the foreseeable future. Search for job postings on various job boards to see where knowledge of and experience with C is required or an asset.
C has a massive existing codebase, it is probably fairly safe. That said, I wouldn't bet my future on a single language, regardless of the language. From http://norvig.com/21-days.html &gt; Learn at least a half dozen programming languages. Include one language that emphasizes class abstractions (like Java or C++), one that emphasizes functional abstraction (like Lisp or ML or Haskell), one that supports syntactic abstraction (like Lisp), one that supports declarative specifications (like Prolog or C++ templates), and one that emphasizes parallelism (like Clojure or Go). 
Awesome! Just in time for summer! forsure signing up for this. 
You're right, my bad. Thanks for pointing it out!
my eyes my eyes are burning while your trick is blazing fast (and quite clever), try to run it with one of the variables equal to 0 (not NULL) or equal to the other.
Yeah, that'd work. But at that point you might as well go with a temp variable to avoid a branch anyway.
You're going to have to show us the code that writes out this binary file so that we can see if things line up between the two. Does the writer write out an initial test value the same way the reader reads an initial test value? What is the size of the value as written? It may just be offset by some number of bytes. But first of all, your first "test" fread is odd, because it loads an amount of data appropriate for an *int* into a *double*. On modern desktop PCs, ints are often 32-bits and doubles are often 64-bits. They also have different formats and it doesn't really make sense to read something of one type as though it were another type unless you have a very good idea of what you're doing. 
What I'd like to see is the code you've written to write your struct to the file, but the logic of your read loop seems off to me - Are you really wanting to loop repeatedly, reading entire arrays of points at once?
First, you should probably typedef your struct first and then declare your array of structs in a separate statements, which would make your code a little clearer, eg: typedef struct coords_s { double xCoordinate; double yCoordinate; } coords_s; coords_s *points; size_t points_sz = numPoints * sizeof(coords_s); points = malloc(points_sz); Second, the man for fread states that the second argument is the size of the single element your want to read, and the third argument is the number of elements. With the typedef and the declaration above, you can use `fread()` this way: while(!feof(f)) { fread(points, sizeof(coords_s), numPoints, f); } fclose(f); Also, note that `points` is a pointer to struct type, which means that you can just pass it as is (without the need to use `&amp;`) to `fread()`. One final note - this will only work if you create your file and then read it on the same type of hardware (i.e. this code is not really portable), as the code doesn't take into consideration the endianness of the machine it's running on. In addition, floating point numbers are not that suitable for binary storage/transmission in an endian-agnostic way as far as I understand it. The general consensus seems to be to send those as ASCII. For integer types, you can use `htons()` / `htonl()` and `ntohs()` / `ntohl()` functions to convert from host to network byte order and back. Hope that helps!
You need to show the code that calls this function, because what you pass matters. I suspect that you wrote something like this: char *str[10]; getString(str); If that's the case, then this is invalid because you're writing to an uninitialized pointer. `str` is an array of ten pointers, but they are uninitialized. They don't point to anywhere meaningful; no memory has been allocated. The pointer you pass to `scanf()` has to point to a valid block of memory, which the function will fill in with data. `str[0]` is not that. You need to actually allocate memory somewhere to hold the string before you can call `scanf()` to populate that memory. `str[0] = "lol"` works but that is something completely different. That is assigning the pointer at slot 0 of the array of pointers to point to the string `"lol"`, which is a buffer of memory somewhere that's been statically allocated and pre-initialized with those three characters and the null terminator. That's not comparable to what `scanf()` does. It's the difference between assigning a pointer and dereferencing a pointer to modify what it points to. 
Sure C is still the primary language for embedded system development. Also stuff like the Linux kernel, Windows drivers are still written in C. If you also pick up C++ that's good enough.
Don't use feof in a loop condition
 a = 12; b = 12; a ^= b; /* a = 0, b = 12 */ b ^= a; /* a = 0, b = 12 */ a ^= b; /* a = 12, b = 12 */ Wait. Your trick does work.
This helped me figure out the problem! There was no memory allocated for my array of strings! 
&gt; From my perspective this code is correct, as a Ctrl is is an Updater... that is, its first member at offset zero is itself an Updater, so the struct is polymorphic. Can't you simply pass `&amp;this-&gt;ctrl.updater` then?
Yes, I could do that... sorry, it's been a while since my head was immersed in C. However I recall that I wanted to use the object polymorphically which is precluded there. But thank you for reminding me. The reason is I'm using C11 + `-fms-extensions` (including plan9 stuff) which is supposed to make just these sorts of things possible. Sadly I think clang is not acknowledging these situations in full... Maybe I'm just trying to fit a square peg into a round hole...
Use a cast or explicitly pass a pointer to the first structure member.
To answer my own question why using `feof()` in a while loop is not a good idea - this [answer on StackOverflow](http://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong) is probably the best explanation and generally it boils down to the fact that when dealing with open files, one should attempt the operation first and see if it fails, as opposed to check if an operation will fail, and then try. 
Wrong. As the C standard states, C1x §6.7.2.1.13: "A pointer to a structure object, suitably converted, points to its initial member ... and vice versa. There may be unnamed padding within a structure object, but not at its beginning."
I'm sorry, but this question is off topic in this subreddit. /r/C_Programming is about C and C only. You might be able to get more help in /r/asm.
You might want to fix the errors in your explanations. For example, `double` might not be a 64 bit floating point number. You pretend it always is.
Thanks there is a bug, I will correct it
Check the one you think you use the most then
That's one of my favourite things about C: Do it yourself, do not expect things to be easy, just do it, without caring about how long it will take. Not only you will get the job done, but you will *always* learn something. Now fire up your editor and implement those data structures!
But I development on Windows and OS X equally. There isn't one that I use more.
No, you don't understand. I know how to use `vi`. I just hate having to change modes all the time.
*on*
Okay, thanks for clarifying. Just wanted to make sure.
I'm also in embedded firmware land (but not automotive), so I sympathize. There are two halves to consider. One is that automotive software isn't going away; it will only get bigger and more complicated as ECUs become more sophisticated, cars get more gadgets, etc. So if you're comfortable staying in that field, you're set. If you want to get away from automotive but stay on the same level (embedded, PICs, microprocessors, firmware... whatever words you want to use to describe what you like) you're still fine, as there's lots and lots of it to be found if you look for it. As for the language, C isn't going anywhere. There won't be a substitute for it for those kinds of tasks for at least two decades. For one, a lot of embedded compilers simply don't support anything other than non-standard C (some don't even have C++). If you're writing software that needs to run on those chips, and those are the compilers you're stuck working with, then you have no choice but to keep using C. Suppose that one or more alternatives like Rust or Go catch on, and *all* the companies with proprietary processors that have proprietary compilers start implementing compilers for those languages. You'd still have legacy software to deal with; it takes a lot of time and effort to reimplement all that existing C code as new Rust or Go code. This is why we still have COBOL many decades after it was abandoned for new development, only C is hugely more widespread. But with that said, yes, you still need to think about your own career. Get good at C, yes, but also study and work on self-improvement, including teaching yourself other languages even if you don't need them for work. You may find ways to use them there, or you may learn concepts and techniques that you can apply in C. Even if you don't, you'll at least feel better that you're vaguely keeping up with the larger industry and trying to stay relevant, for when you do eventually start looking for a new job.
It mostly depends on what you mean by "set." And your compiler. Wiki "constant folding" for the most common optimizations done by most compilers.
Thanks.
Why do you need a wrapper function? Can't you just write the callback to take `void *` so that it inherently has the correct type? This is relatively common, in the sense that historically people would tend to be lax about passing around incompatible pointer types. But it's certainly not something I'd make a habit out of. It's not so much about anticipating future platforms, it's about running afoul of the compiler's optimizer, which is allowed to assume UB never happens and can arbitrarily mangle your code if it does. And those kind of problems are *the worst* to debug. 
Differences in stuff like that probably gets optimized away by the compiler, but if it's just an int or something, then pointers will be slightly slower. It likely won't matter, though.
Thanks.
Didn't you see the remarks about UB? What are your thoughts on those? Me, I'm not sure it's worth the risk... From what I understand a pointer to a struct and a void pointer are not always guaranteed to have the same structure... so you can seriously stuff things up this way, apparently. That's my limited understanding, anyway.
Ah yes, sorry!
Thank you u/shinmai_rookie. Here is my updated code: void addfloat(float a[10], float b[10], float c[10]); int main() { float array1[10]={1,2,3,4,5,6,7,8,9,10}; float array2[10]={2,3,4,5,6,7,8,9,0,1}; float array3[10]; int i; addfloat(array1,array2,array3); printf("Here are the values of the three arrays.\n\n"); printf("First Array: %.0f\n\n", array1); printf("Second Array: %.0f\n\n", array2); printf("Third Array: %.0f\n", array3); getchar(); return 0; } void addfloat(float a[10], float b[10], float c[10]) { int i; for (i=0;i&lt;10;i++) c[i]=a[i]+b[i]; } My output still doesn't look right though. It looks like this: Here are the values of the three arrays. First Array: 0 Second Array: 0 Third Array: 0 
The third argument to memcpy (sizeof int) seems wrong. Maybe provide a little more context about what you're trying to do and we could make better suggestions. As to your original q. My experience is that often implementations use the same representations for all pointers - allowing you to get away with various pointer casting shenanigans. But, one possible way this fails is with function pointers. I.e. function pointers might have a very different representation than other pointers.
Yeah, I see. You can't print the whole array like that. You have to use a loop to get and print each element of the arrays.
Thanks for writing out your solution rather than just deleting your post
Getting closer I think. =\ Now I'd doing: printf("Here are the values of the three arrays.\n\n"); for (i=0; i &lt; (sizeof (array1) /sizeof (array1[0]));i++) { printf("First Array: %.0f\n\n", array1); } for (i=0; i &lt; (sizeof (array2) /sizeof (array2[0]));i++) { printf("Second Array: %.0f\n\n", array2); } for (i=0; i &lt; (sizeof (array3) /sizeof (array3[0]));i++) { printf("Third Array: %.0f\n\n", array3); } But the output looks like this. Here are the values of the three arrays. First Array: 0 First Array: 0 First Array: 0 First Array: 0 First Array: 0 First Array: 0 First Array: 0 First Array: 0 First Array: 0 First Array: 0 Second Array: 0 Second Array: 0 Second Array: 0 Second Array: 0 Second Array: 0 Second Array: 0 Second Array: 0 Second Array: 0 Second Array: 0 Second Array: 0 Third Array: 0 Third Array: 0 Third Array: 0 Third Array: 0 Third Array: 0 Third Array: 0 Third Array: 0 Third Array: 0 Third Array: 0 Third Array: 0 I cant understand why all of the elements are showing up as 0s. 
Thanks.
code for you: #import &lt;Foundation/Foundation.h&gt; #define N 10 void sum(float a[], float b[], float c[], float m) { for (int i = 0; i &lt; m; i ++) { c[i] = b[i] + a[i]; } } int main(int argc, const char * argv[]) { @autoreleasepool { float array1[N]={1,2,3,4,5,6,7,8,9,10}; float array2[N]={2,3,4,5,6,7,8,9,0,1}; float array3[N]; sum(array1, array2, array3, N); for (int k=0; k&lt;N; k++) printf("%f\n",array3[k]); } return 0; } 
No problem! I hate when people do that.
What is limiting the array size? Is their just no index data type that can go that large for this device, or is it a compiler limitation?
I see it now. I forgot the index. Thank you for the second set of eyes! 
Not reliably or portably. Change your design.
why as per my knowledge memory layout(heap,stack,static/gloabl,code segment) so my static variable will store in static block in memory layout....if I declared static gloabl or static local varible inside function it will store it in same location right(in memory layout)?
Can you explain the attribute? Is it in the standard?
The closest thing you can do, which is not reliable or portable, is to fill the upper few bytes of stack with a sentinel value--say, A5A5 or DEADBEEF. Then, in your main program logic, you check to make sure your sentinel is intact. This will only tell you that you've smashed your stack, and only if you do it a little bit...
Why do you have 3 loops to print 3 different arrays? Wouldn't it be much nicer if you wrote a function like `void print_array(float x[10]);` with the loop inside it, and you simply call that function 3 times?
One way is to not use unbounded recursion or dynamic stack allocation. Use malloc for variable-length arrays and other things. Then, you can use a feature such as gcc's or clang's -fstack-usage and analyze what the worst-case stack usage is, and just make sure you have enough stack available to your program. If your program has its own stack space, rather than being a library which is invoked by the stack of another program, you can guarantee that stack is not overrun in that way. If you're sure you'll have x amount of stack, and you'll only use some portion of that, then you're golden. If you're doing unbounded recursion that might grow off the end of the stack within your own lifetime, stop using so much memory unless you absolutely can't help it.
The above stuff is correct. In fact `Bar` has type `int` (a stronger condition than merely having the same size), and so on. Like most things in C it is this way because that's how pre-standard compilers did it, and then they didn't want to break backward compatibility. Other languages have to deal with it. 
In arbitrary order (add IMHO to all points :) ): * in post listing, keyboard focus is not visible * #header background-color doesn't fit with the logo, * .selected and .tabmenu .selected don't combine well, it's difficult to read the text (for deuteranopes it's even worse) * the contrast balance between content and sidebar is wrong, i.e. currently the sidebar grabs your attention, whereas it either should be equal or less-prominent. * the light sr-header-area, dark header-bottom-left, light content and dark buttons on content don't work well together * padding on .link is unbalanced, due to .buttons (padding: 12px 12px 6px 8px and min-height removed, looks bit better), however things would still look mis-aligned because of combination the separating lines and vote buttons. * a and visited tags are too uniform with the background (e.g. see the links in formatting help) * I do like the side-bar text layout (except the too big margin on left for bullet points, uses up space with no gain) * overall, there doesn't seem to be a clear vision of the whole, but looks like an accumulation of tweaks For the color-scheme/fonts/whole I would pick something iconic for C and use that. e.g. K&amp;R [1](https://upload.wikimedia.org/wikipedia/commons/thumb/9/95/The_C_Programming_Language%2C_First_Edition_Cover_%282%29.svg/800px-The_C_Programming_Language%2C_First_Edition_Cover_%282%29.svg.png) or [2](http://66.media.tumblr.com/324af4c8167c794ea8cfe97c08926fe9/tumblr_inline_nu32ysmvON1tbt8rv_400.png). Notice the colors, borders used and the font. Where the logo could be the C red stamp - or snoo somehow mixed with it.
Basically , C++ is directed for object and C no . Who learns one, learns the other 
That is an oddly phrased question, and the answer is mostly useless. What are you really trying to ask?
You can start [here](https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B)
This is correct, the micro has very little memory. However, the 32K limit with the space(auto_psv) attribute in my solution was a result of a compiler limitation.
C++ and C used to be quite common languages, before the rise of Java and Python. C++ was derived from C, like almost every other language. They therefore share the same syntax, approximately. There are reasons to prefer C, and reasons to prefer C++. I myself prefer C for different reasons: - UNIX influence: After using UNIX systems for a while, you can only get into C programming. - Low level: C is "low level", compared to most languages at least. It provides the right amount of abstraction between my code and the machine, providing raw byte control, inline assembly, and even direct system calls. - DIY: I mostly program for fun. C *is* fun. You have to do everything yourself, even though there are libraries out there I prefer to make my own libs. But there are reasons to like C++: - Gigantic standard lib: You don't have to implement your own data structures, they are already available, and intuitive! - Object Oriented Programming: praised by programmers working on large projects, OOP offers a compact way to build your programs, similar to using Legos. - Abstraction: you can forget about pointers, except if you're working on low level projects (C++ can do that too, but not in the same way as C). References will save you from segfaults most of the time. I myself, as I said, prefer C. It's up to you to decide what is better :)
It looks like a gcc attribute, so no its not in the C standard but it is a standard gcc feature I believe 
`var` is guaranteed not to be an `int`; it's an `enum Foo` which is its own type. `int` and `enum Foo` are both integer types so there is implicit conversion between them, and the `enum Foo` must be able to represent all of the enumerators. 
Ahh I see. What kind of microcontrollers are you using? Also won't grabbing the elements of the array from flash everytime be extremely slow? 
PIC24FJ128GA202. It is extremely slow, but for this particular device it isn't really a problem. We've had some issues bootloading units in the field over WiFi recently, so I'm essentially creating a push-button bootloader that we can load a couple of hex files into for when WiFi connectivity is an issue. 
You need to loop through and print each element out individually. You are still trying to print the array as a whole (`array`) when actually you want a specific value of an array `array[i]`. Make a `for` loop that looks like this: `for (i=0; i&lt;10; i++)`, and print out each element. Remember you can print a *single* float like so: `float test = 0.5f; printf("%.0f\n", test);` EDIT: Also, `sizeof` in C gets the number of bytes of the passed variable/type, but what you want is the maximum length of the array. Unfortunately there is no way to dynamically get this information, so you'll need to just remember it or use a `define` if you know what those are.
stack overflow
That's a great idea, thank you! 
Got it, thank you for the advice. 
Thank you for your answer! A follow-up question if you don't mind: How would one then go about designing say an allocation function that returns a status code and stores the resulting pointer in an out parameter, like that: alloc_status_t alloc(void **out); Given this, any user of alloc() would have to convert their T pointer to a void pointer if T /= void, just to be safe. Is there any other way?
Unfortunately I can't think of any way to pass a generic reference to a pointer that you could do anything meaningful with (according to the standard). But you basically want to return two values, right? There's very little language support for that. One alternative is to switch the order of the arguments, i.e. `void *alloc(alloc_status_t *);`, or you could return a `struct` containing both values. With a `struct` it might be a little less likely that one forgets to check the status since it's right there with the pointer. But it's maybe a little less convenient.
This is exactly the type of thing I was looking for. Thank you very much!
You really shouldn't approach the languages this way. Although C++ was born as extensions to C and has similar syntax, they've both evolved in different ways, and are now separate languages, as much as German and English are. You should learn them as separate languages, and not try to learn both by only learning the differences. For instance, C has a `for` keyword, but so do Lisp, Fortran, and Basic. You need to just learn it fresh in each language.
I don't think your interpretation is correct because of the following: enum SmallEnum { SmallOne = 1, SmallTwo = 2, }; enum BigEnum { BigOne = 1, BigMax = LONG_MAX, }; On LP64, sizeof(int) == 4 sizeof(long) == 8 sizeof(enum SmallEnum) == 4 sizeof(enum BigEnum) == 8 sizeof(SmallOne) == 4 sizeof(BigOne) == 4 sizeof(SmallTwo) == 4 sizeof(BigMax) == 8 In the Big case, the size of the enumeration constant needs to be able to hold the value, which is larger than int in this case. (You could also imagine a huge enum with a number of constants exceeding INT_MAX to force long values.) I'm not sure how to parse the text of the specification with this though.
References are a huge PITA as they make it very hard to see where a variable is getting modified. I rarely have problems with segfaults and if I do, the solution is usually self-evident and easy to find. In the cases where it is isn't, I don't think references would have made this any easier (as these cases typically involve complex webs of structures that point to each other).
Ah, thank you for explaining that. 
okay here static int globalvar where it will store? static int localvar where it will strore? memorylayour(heap,stack,datsegment,code segment) all static will store in data segemnt so thn why i cant acces statci int localvar in other program??
I was trying to get it to do this for binary files :) while(fgets(line, sizeof(line), f)) { //get line from file if(i &lt; numPoints) { //if i is less than the number of points in the file Points[i].xCoordinate = strtod(line, &amp;pEnd); //split and then convert string to double and assign to xCordinate in Points struct Points[i].yCoordinate = strtod(pEnd, NULL); //split and then convert string to double and assign to yCoordinate in Points struct i++; //increment (counter variable) } }
Thank you! That does help quite a bit :) I'm still quite new to programming so I'm not really sure what you mean by endianness (I did google it though lol)?/How would I make it portable?/What would I need to read/learn in order to make it portable?
Why not run it and find out?
oh yes,i will thnk you
okay thhnk u
thk u
[Image](http://imgs.xkcd.com/comics/wisdom_of_the_ancients.png) [Mobile](https://m.xkcd.com/979/) **Title:** Wisdom of the Ancients **Title-text:** All long help threads should have a sticky globally\-editable post at the top saying 'DEAR PEOPLE FROM THE FUTURE\: Here's what we've figured out so far \.\.\.' [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/979#Explanation) **Stats:** This comic has been referenced 1329 times, representing 1.1681% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d40r83c)
okay thk u Rhomboid
BSD and OS X. 
&gt; In addition, we derived a sloppiness metric (`DKLUDGE`) by using fgrep to count in the code the number of "kludge" words that may indicate problems in the code (`FIXME`, `XXX`, `TODO`, `BUGBUG`, and swearwords that cannot be reproduced in this paper). Hahahaha... nice!
Use `sprintf()`. (Or, in general, `snprintf()`, although for something like this you may not need buffer length management.) 
That's just some code. There's no question.
&gt; I'm unsure if I'm correctly allocating memory for the double pointer array member "correctly" doesn't really have a fixed meaning. It depends on what you're going to do with this later. You've allocated an array of pointers and initialized each of them to the null pointer. That's reasonable, I suppose, if you don't know yet what you're going to store. But you haven't actually allocated any memory for strings yet, just pointers. There are a variety of ways of using this struct, some of which are correct and some are wrong: SmartArray *sa = createSmartArray(10); sa.array[0] = "foo"; // okay strcpy(sa.array[0], "foo"); // BAD - undefined behavior (null pointer dereference) sa.array[0] = malloc(4); strcpy(sa.array[0], "foo"); // okay Also, you never initialize the `size` or `capacity` members, so anything you do with this struct in the future will almost certainly be incorrect (e.g. if you start adding strings you won't know when the array needs to be resized because that requires `size` and `capacity` to be correct.) And don't repeat the initialization procedure twice in both clauses of the `if` statement. Write that once, using a variable that has been set to either `length` or `DEFAULT_INIT_LEN`. (Hint: `capacity`.) 
If mallic fails to allocate the memory you asked for then it returns NULL. If it returns NULL it is illegal to read or write from the pointer. Therefore you must check that the returned value isn't NULL before trying to use it
Which is bullshit, look I patched a driver in 4.3 BSD in 2011, so does that make all of 4.3 valid for 2011? no. It's bad methodology. klocs are meaningless. platforms, number of drivers? subsystems? internal interfaces, external interfaces are more relevant than a patch that was placed in 1990 for a 1983 OS.
You should check whether the malloc() for 'smarty' fails BEFORE dereferencing it ( or doing anything else, really ). Best practices is to check for NULL immediately after the malloc. You can't use "-&gt;" until after you've checked that it isn't NULL. Also, as a side note, in practice, malloc() almost never returns NULL.
my gloablvarible and localvarible where it will stroe in memory layout?
As they are not initialized, they will be stored in [.bss section](https://en.wikipedia.org/wiki/.bss). 
`static` means in both cases that the variable is in `static` storage, in the case of a global variable with internal linkage and in the case of a local variable with no linkage. Using the same word makes very much sense.
Yes, for the first one. For later ones, before returning you need to free what you already allocated, or else you'll be leaking memory. (On a modern PC this all seems trivial, with gobs and gobs of memory. But on embedded systems with only a few meg, and required to stay functional as much as possible rather than crashing, this is mandatory. You can easily run out of memory, so checking for malloc failure is critical. And freeing memory is critical as well; maybe *this* allocation failed, but other processes in the system may also want to allocate memory, and you leaking memory just because *you* failed would interfere with those other processes.)
Could you elaborate a little?
Okay so I wrote a function to free memory that I think it correct. This is it: SmartArray *destroySmartArray(SmartArray *smarty) { free(smarty-&gt;array); free(smarty); return NULL; } Is there anyway I can test for memory leaks? I've always been taught to avoid them but never to check for them in my programs.
&gt; community driven If that means "we add all the features people want," then no, that's not how I like my libraries. Feature creep causes overly complicated interfaces and imprenetable code. I prefer if someone puts a lot of thought into a library and only adds a minimum interface of functionality that is actually needed. &gt; There is no math min or max functions, seems very basic to me Why do you need such a function? That's about as redundant as having an add() or subtract() function. Just write a &lt; b ? a : b where you need a minimum or roll out a macro if you feel fancy (not that such a macro should be part of any library). Similarly, there is no need for iterators or generic data structures. I rarely have a need for either and if I need a complicated data structure I'm going to roll out my own anyway as the implementation in the library is likely not suitable for my purpose. 
Why do you want that?
Just attempting to run the code as a program instead of having to go through the devc++ compile &amp; run, does it matter why though?
Thank you, that's actually extremely helpful
Hey, you helped me in the last thread. You're seriously my hero today! Anyway, I'm not very comfortable with realloc. Would a statement like the one below expand the size of the array while retaining the data already in the array? Also is there a risk of memory leakage? smarty-&gt;array = realloc(smarty-&gt;array, sizeof(char*) * length);
`realloc()` will either expand the buffer in place, or it will allocate a new buffer, copy over all the data from the old buffer, and free the old buffer. Either way, the result is a new buffer with the specified size. If it fails, it returns NULL and the old buffer is still allocated and valid at the old address, with the old size. The potential leak is if it fails and you didn't save a copy of the original pointer value, which would mean you have no way of freeing it. 
Use valgrind, which is generally a great tool for debugging - and it has very nice memory leak information too.
static inside a function and static outside a function mean different things
So, took me a while to get through the whole thing. Two biggest potential issues I saw with the methodology were: 1) Usage of mean file age as a proxy for time when the code under inspection should be attributed to. I will presume (since no further information was given, unless I missed such) that they used the file mtime (last time it was modified). This is problematic for several reasons, including the fact that something like adding a new license header to the top of all the files alters the mtime with no code change to the affected source file. There are related problems, like fixing a single typo noticed by a user in a seldom-seen error message brings the whole file under the "new" umbrella. That said, they needed a usable proxy, and mtime is easy. A more accurate examination could be performed for the shorter period of development for which revision control was in use, by looking at the actual diffs and attributing only the changed code to the commit time. 2) They postulate that the number of comments, and total number of characters contained therein should positively correlate with subjective code quality and readability. While I think we are a few years from "comments considered harmful", I have seen an increase in the last few years in the mindset that good code should need minimal commenting, and that due to the risk in comments getting out of sync with code over time (or the temptation to be "clever" enough that the code really needs comments) that generally comment usage should be restricted to explaining the rationale behind a routine, rather than the what of it. This could actually be a case where the "self corrective" forces they discuss in other places are at work: developers are learning that over-commenting can be a bad thing. Generally, a very interesting study though. The SLOC variations from release to release definitely surprised me.
&gt; Also, he's malloc'ing in every iteration in what I'm guessing is his hot loop. No fucking wonder the C perf is shit. I don't think that this is the main reason: he mallocs blocks of 1024 bytes, that ain't too bad. But he says: &gt; If isLetter is pointlessly slow, isn't the same thing true of putc(3) and getc(3)? But I think there is a clear difference. Both programs are written in a character-oriented way because the problem is described in terms of characters. This is not true. I don't read Haskell, but this: -- | Write a block to stdio with line breaks. writeBlock :: Block -&gt; IO () writeBlock (Block name txt) = do putChar '&gt;' B.putStrLn name mapM_ B.putStrLn $ splitEvery 60 txt with a `putStrLn` does not look "character-oriented" but like a `printf` or a `fwrite`. So, if I replace this: for (i = 0; i &lt; ptr-&gt;len; i++) { if (cpos++ == 60) { my_putc ('\n',stdout); cpos = 1; } my_putc (ptr-&gt;text[i], stdout); } by some `fwrite` to write lines of 60 characters at a time as he does in Haskell, I win 30% of execution time. OK, my solution written in 2-minutes takes 6 more lines than his, but well, -30%... 
&gt; I wrote the inner loop of the C to operate on a linked list of blocks because it looked like a faster and simpler choice than copying the whole string into a new buffer twice the size every time it overflowed (on average this algorithm copies each character once or twice; see Knuth for details). I might have considered reading or writing the characters in reverse order rather than doing the in-memory reverse in a separate function, but profiling didn't show that as a significant time sink. Overall, getting decent performance out of the C is going to take about the same amount of work as writing the code in the first place. But that is precisely this weird chained 1024-characters blocks structure that makes using `fwrite` (a bit) harder ! &gt; The obvious optimisation would use fread(3) and fwrite(3) to read and write characters in blocks instead of one at a time, but that would require significant changes to the code; extra bookkeeping to deal with the start of the next sequence (signalled by a "&gt;" character) when it is found half way through a block, and to insert newlines similarly. BTW, the input (FASTA format) is also line-based, not character-based. Same as for the output. And the `getContents` I see in the Haskell version does not look at all character-based either...
pdf or website
how it differ?
As you stated, the problem is that a single NL can be obtained from cmd_line in two ways: cmd_line =&gt; NL, cmd_line = pipes io_mods bkg NL =&gt; args io_mods bkg NL =&gt; io_mods bkg NL =&gt; bkg NL =&gt; NL, meaning that your grammar is ambiguous. To solve this, you must remove one of the alternatives, either by removing the NL rule from cmd_line, or by forcing args to produce at least one WORD. I think the second solution is better, because it keeps the simple rule for newlines, and use the more complex one for real command lines. As an alternative solution, you should consider using flex to recognize sequences of newlines as a single token NL, which simplifies the parser keeping that problem in the scanner. 
That is an implementation detail, but typically, yes. Both end up in *static storage* which is the important term.
sorry if I am asking again and again ---------------- |stack | ------------------ |Heap | ------------------ |data segment | ------------------ |code segment | ----------------- *If My static int globalvar,static int loacalvar is stroing in data segment block right? *So How Data Segement will come to know oh this variable is Related to Static int Gloabl Varibale, this varible is related to static int local variable * actually interviewer asked why I can't access static local variable out side of the function like in other function _____________
The data segment doesn't know that. The symbol table knows. When the compiler generates assembly, it's generating assembly like this for every variable in static storage: .data global_variable: .int 0 local_variable: .int 0 This allocates four bytes of storage for each for `global_variable` and `local_variable` and makes the symbols `global_variable` and `local_variable` point to the beginning of the two memory regions. When the compiler wants to refer to the variable, it uses the symbol name. During linking, the symbol name is resolved into the address of the variable by the linker. For example, the function int example(void) { return global_variable; } is compiled into assembly like this on x86: .text example: mov global_variable,%eax ret I hope this answers your question. Please put some more effort into spelling. You won't get any jobs with catastrophic spelling like yours. Also try to write correct and complete sentences. It is very hard to understand what you want because your grammar is so horribly broken.
Where I will get this stuff(I mean Material and I am not into computer science background,I am holding Electronics And Communication degree) Please suggest me 
&gt; ctually interviewer asked why I can't access static local variable out side of the function like in other function That's because of C's *scoping* and *linkage* rules. A local variable declared `static` is in static storage (i.e. it is created at the beginning of the program and destroyed on program termination), has block scope (i.e. from where it is declared to the end of the block it is declared in) and no linkage (i.e. if you use the same variable name elsewhere, it refers to a separate entity). Because of the last property, you can only access the variable from inside the function as every other mention of the variable name refers to another variable, including if you declare a variable of the same name outside of a function.
okay I got it now,thank you FUZxxl,Please suggest some Material for reading(I am into Embedded side)
where bist du?
To get a job in Germany, you need the following things: * Be proficient in German * Have a permit to work in Germany (you can get one if your job pays more than €49600 a year or for various other reasons) * Be skilled enough for a German company to hire you. I think the most difficult parts are going to be 1 and 3. With your current skill level, I'm not sure if you are going to have a chance. You need to learn a lot.
http://reddit.com http://blog.fefe.de http://heise.de
Immer gerne doch. Viel Spaß beim programmieren, ich hoffe, du findest was.
ja
I like gcc just because it is quick and doesn't hold your hand that much. You write in any text editor you like and then point the compiler to your file. No IDE involved. I think you will learn faster that way. MinGW is the way to go on Windows: http://www.mingw.org/ 
You can also typedef an incomplete struct to get the same result. typedef struct _mytype mytype; struct _mytype { mytype *foo; };
You're not actually calling any function that would output anything.
Maybe it's integer overflow.
Please refrain from posting [the same question](https://www.reddit.com/r/C_Programming/comments/4nas5j/a_simple_euler_programme_not_giving_output/) twice. If you have a follow-up question, ask it in a comment to the original question or at least highlight what the difference is.
thanks !! i got the answer 
Since I like maths, C programming, and have nothing to program right now, let me submit my program: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char **argv) { int a; int b; int temp; int sum; while (b != 4000000) { temp = b; b += a; a = temp; if (!(b % 2)) sum += b; } printf("%d", sum); return (EXIT_SUCCESS); } There are no differences, except for the `if` statement. And also, something that I never want to see ever again: **MAIN RETURNS AN INTEGER. DO NOT USE "VOID MAIN" ANYMORE BUT "INT MAIN"**
If you want to make your code portable, in my opinion, the best way to do that would be to store the data as ASCII. With regards to what to read or learn about portability, I guess the easiest way might be to google for books or articles on writing portable C code. I just ran the search and it came up with an article: http://www.informit.com/articles/article.aspx?p=1620206 - which would be a brief introduction to issues with portability in the C code and might give you ideas on what to explore more. Also, as an example (although I haven't read it myself) - Writing Portable Code book from https://www.nostarch.com/wpc.htm
Great explanation, thanks
Why do you hate capital letters and periods? 
It doesn't seem like you're using your pipes at all, other than duplicating the stdin and stdout. You have to read and write data to your pipes. How do you want to redirect I/O?
Maybe you didn't initialize sum to zero to begin with?
Yup, but my piping is working fine. the Trouble I am having is the io redirection, example: where i would want to store the output of a program into a file.
Ok so in this example it's like I'm running process1 | process2 in the terminal. int main (int argc, char *argv[]) { int my_pipe[2]; pid_t proc1, proc2; pipe(my_pipe); if (!(proc1 = fork())) { dup2(my_pipe[1], STDOUT_FILENO); close(my_pipe[1]); close(my_pipe[0]); execlp("process1", "process1", NULL); } if (!(proc2 = fork())) { dup2(my_pipe[0], STDIN_FILENO); close(my_pipe[1]); close(my_pipe[0]); execlp("process2", "process2", NULL); } close(my_pipe[1]); close(my_pipe[0]); waitpid(proc1, NULL, 0); waitpid(proc2, NULL, 0); return 0; } of course I skipped checking for return values from each system call here, but you shouldn't do that on your code. This is just an example of how piping from one process to another works :P You can build on that in order to do it like you wanted in your code above, with piping through more than 2 processes every time.
ah I see. I just followed a pseudo code made by my lecturer , and the piping seemed to work just fine. Still unsure on how to perform the &lt; and &gt; :/
That's easy. Instead of piping my_pipe[0] to STDIN_FILENO, you dup2() it to your file's file descriptor. That's for '&gt;'. The reverse goes for '&lt;'.
when u mention file descriptor, is it something like this? in = open("input.txt", O_RDONLY); out = open("output.txt", O_WRONLY | O_TRUNC | O_CREAT, S_IRUSR | S_IRGRP | S_IWGRP | S_IWUSR);
Exactly.
While I use the convention you defend, it's true that writing \* just before the variable helps when declaring more than one variable in the same line, as all of them take \* before them: int \*a, \*b; It's a matter of taste, of course.
Because * is added to to variable name to indicate a pointer, not to the type in the declaration. This is s a subtle point but clear when you talk about compound declarations like: int *foo, bar, baz. If you now wanted to make baz a pointer, you change the variable name, not the declaration. So in that way the '*' is bound to the variable name. The altrnative would make sense if the pointer took affect on each of the variables like: int* foo, bar, baz;
Yeah. Moreover, I think it's a little clearer---int *foo says that foo is a pointer that, when dereferenced, yields an int. I just find that a little more conceptually meaningful than int* foo, as in foo is a pointer of int* type.
C doesn't let you create a pointer to void (remember, the create pointer operator is &amp;, not *). Instead, C lets you create a variable which, if deferenced, would yield a void. The declaration says "deference identifier to get void". You're not doing anything to void, you're derefencing "identifier", so the operator is closest to the entity that it acts upon. That's the way it's intended, anyway. Not that it matters much in practice. For what it's worth, it's more common in C++ to put the asterisk next to the type. The declaration syntax in C has been controversial since C was created and most newer languages do things completely differently to avoid the horrible problems in C when you get to function pointers and other multi-layered types.
&gt; you'll need to have separate treatments in your function for each type that is accepted. I was hoping that wouldn't be the case.
This is helpful, thanks.
can I speak to you over skype?
The compiler just builds in the switch. There is no way around it. Other languages just hide it. 
http://www.tutorialspoint.com/cprogramming/c_file_io.htm good examples.
Someone just bumped this 21-year-old thread. And there's some good stuff in there.
Giving a Gcc specific answer here. You can use typeof operator to use the type of an existing variable much like 'auto' in c++11. You can use this coupled with feature of anonymous functions you can write a generic macro for summing an array. Below is my initial shot at it. Though this assumes that type you have used works with += operator. But that limitation can be easily overcome: #include &lt;stdio.h&gt; #define SUM(_ARR_,_ARRLEN_) ({ \ size_t index; \ typeof((_ARR_)[0]) sum_arr[1]={}; \ for (index = 0; index &lt; (_ARRLEN_); ++index) \ sum_arr[0] += (_ARR_)[index]; \ sum_arr[0]; \ }) #define ARRAY_SIZE(_ARR_) (sizeof(_ARR_)/sizeof(_ARR_[0])) int main() { double darr[] = {1.0,2.0,3.0}, dsum; int iarr[] = {1.0,2.0,3.0}, isum; /* sum double array */ dsum = SUM(darr, ARRAY_SIZE(darr)); printf("%f\n", dsum); /* sum int array */ isum = SUM(darr, ARRAY_SIZE(iarr)); printf("%d\n", isum); return 0; } 
actually it was bcoz of my while condition. i should have used lesser than 4 million.
looks reasonable to me.
Okay -- the code snippet you posted looks fine but if you want to extend it you may make your sorting routines proper functions that take an array of void *, a size of each item, and maybe a callback (function pointer) that can properly compare each of your items. qsort() actually does this. Your print array might take a callback that returns a string representation of your type. I think this would be more extensible.
One of the other reasons is historical. There were pointers before there was `void` (or anything other than `int`). In B, the predecessor of C, every expression yielded a machine word, which could be treated as an integer or pointer depending on which operators you applied to it. In other words, the *type* of a variable depended only on the value you stored there. In declarations you used `auto` or `extrn` for local or global variables, but there was no `int`, `char`, `volatile`, etc. that we see today. Arrays were called vectors and worked the way many intuitively believe they do in C: the name of a vector _was_ a pointer to a region of memory somewhere else, so for example // globals a { 10 }; arr { 1, 2, 3 }; vec [100] { 0 }; // function definition fn(x) { extrn printf, a, arr, vec; auto i, p, arr2 5; // locals i = 42; i = a + i + arr; p = i; // p is integer p = &amp;arr; // p is vector p[1] = 10; p[2] = arr; // p[2] == 1, &amp;arr == { 1, 10, 1 } p = vec; // no automatic decay, just assignment like any other p[0] = 13; p = arr2; // same here, local array ... } translated to C would be roughly int a = 10; int arr[] = { 1, 2, 3 }; int vec_hidden[100] = { 0 }, *vec = &amp;vec_hidden[0]; int fn(int x) { int I, *p, arr2_hidden[5], *arr2 = &amp;arr2_hidden[0]; i = 42; i = a + i + arr[0]; p = i; // illegal p = arr; // decays p[1] = 10; p[2] = arr[0]; p = vec; // normal pointer assignment p[0] = 13; p = arr2; ... } C borrowed a lot from B, and when `char` was introduced (and `int` was the default implicit type) it was introduced into the earlier declaration syntax. You might say that *scalar*, *pointer* or *array* is the type of a variable, and `int`, `char` and so on are parameters to the operations. For instance in int a, *p, f(...); char b, *q, g(...); `a` and `b` ara scalars, `p` and `q` are pointers, and `f` and `g` are functions. `int` is what you get when you see the expression `a`, `*q`, or `f(...)`, and similarly for the others except you get a `char`. This was the intention of Dennis Richie that declaration mimics use, and he acknowledged that it was an experiment in language design and isn't without its warts. But that's why people prefer `void *p` over `void* p` in C.
Ehm - you can't just expect fopen to magically know the location of the file? Run the program from the directory where the file is located, and it'll work. Or specify the full path to the file.
And did you fix the matter with the if statement? What error do you get? Does the file exist?
Please put four blanks in front of every line of code so it is readable.
[while feof](http://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong) is always wrong. You need to check the return value of `fgets()` to see if an EOF condition occured during the read and to see how many characters `fgets()` read.
OP is not on UNIX judging by the commands he executes.
What does strcmp() return when the two strings are equal? That is the source of your problem.
And please put four blanks in front of every line of code so the code is readable. Do the same with the input file. Click "edit" to edit your post and do this.
Maybe read the link I provided? Maybe read the documentation for `fgets()`?
&gt; I need to write a function that takes arguments of different types. &gt; Is this form of programming a good practice (I somehow feel that this is not .. recursive functions!)? Well, what you've written are *not functions*. They are macros. They will get duplicated, literally, every time you use them. That will cause large amounts of code bloat, because from the compiler's point of view, it's no different from copy/pasting. You will never be able to make these recursive because they're not functions. If you only need to support a small number of types (like `int`, `double`, and maybe a couple others), then just be explicit. Implement `print_array_int` and `print_array_double`, and that's that. I wouldn't worry about having to write the same `for` loop twice in both of those functions, because they're just too small. It's not worth the time spent trying to do better; you'd just be making it more complicated and wasting time. If you need to support many types, which might even be unknown to you, you should do it the same way the standard library does in functions like `printf` and `qsort`: variable arguments, and/or `void*`.
It's not the *only* standard, although it is the most common one. My company's formatting standard does insist on `void* identifier`. Our standard also doesn't allow declaring multiple pointers in one statement, so we don't have to worry about `void* a, b` being misleading. My personal preference, though, is for `void *a`, precisely to remind myself that when trying to declare multiple pointers, you have to do `void *a, *b`.
We use C everyday for OS and FW level work. In interviews I almost always ask candidates to explain what "volatile" causes a compiler to do and how it changes system behaviors. A good understanding of languages, pros and cons to various choices and knowing what you claim to know about prgramming are the big things.
Usually embedded stuff. Also (embedded) Linux.
It appears that you have been shadow banned. Please talk to the admins to rectify this issue.
We are using the open-source software validation framework Frama-C to prove the correctness of C programs. In my free time, I write UNIX system software in C.
You could get a little bit more flexibility by putting the whole function inside the macro, then running the macro explicitly for each type, eg #define selection_sort(type) \ void selection_sort_ ## type (type arr[], int len) \ { \ ... \ } selection_sort(int); selection_sort(double); int main() { int x[] = { 0, 3 }; selection_sort_int(x, 5); return 0; } Then you can make recursive calls with `selection_sort_ ## type`. However, what happens when the generic macro-based function needs to pass an argument into another function? Eg, to call `sin` vs `sinf` depending on `type`? Possibly with [_Generic](http://www.robertgamble.net/2012/01/c11-generic-selections.html). To write in this style, you might want to consider using another language with explicit template or generics support, or at the very least overloaded functions based on type. In C++, this might look like, template &lt;typename Type&gt; void selection_sort(Type arr[], int len) { ... } int main() { int x[] = { 0, 3 }; selection_sort&lt;int&gt;(x, 5); return 0; }
Real time software/firmware under Linux. Questions: what are the bad uses of malloc/free/memcpy. You would be surprised about how many people don't know how to work with memory. 
thanks 
All day, every day. Embedded systems development. 
I see it.
That's because I have manually approved that one comment.
Or better yet, just #include &lt;stdint.h&gt; and use int64_t in place of long long.
Embedded (Cortex M most of the time) and interfaces to our products in the form of drivers. A big reason for why we use C for embedded is because MIRSA compliance is a horrible pain for C alone, for C++ it would be a nightmare. For personal projects I go with C++ for embedded and C# for desktop applications to interface with my stuff, but I still love using C for my masters courses in computer science. I actually enjoy the very low level perspective C offers/forces. # Interview I actually never interviewed before, but from what I've heard from coworkers one of the best filters is to ask the person to make a hello world in C/C++. That gets rid of a decent chunk of applications right off the bat. Then comes good ole fizz buzz, which drops off another chunk. And then is just a discussion via probing their past projects. In my case, I actually commented about a personal project I was doing (embedded linux board based on a SAM9N12) and we talked about that for the entire interview. Pretty much jumped right over the hello world and fizz buzz stage, but it seemed the person interviewing me genuinely had fun talking about it, which is probably why I got the job.
Used C at my previous role writing a custom BIOS and kernel drivers for specialized hardware, all in the context of a safety-critical system. Typical jobs for C are going to be for embedded, safety critical or OS work. Pretty much anything else it there are better languages for. For interviews, once you get past the basic "can you write hello world and fizzbuzz", check out this blog: http://www.rmbconsulting.us/a-c-test-the-0x10-best-questions-for-would-be-embedded-programmers If you can answer half you're well on your way to entry level work. If your resume says &gt; 1.5 yrs of C experience I expect you to know pretty much everything on there except the nested 'pointer to array of pointer' syntax stuff.
Thanks for all your help!
volatile describes variables that can be changed from outside the program. do i win?
Also: primef() takes an int
Ooo can I have a stab? I like to think I know. Depends on the target, embedded systems have a bit more constraints. On embedded systems in particular memory may become heavily fragmented, reducing the effective storage space. This depends on the free() algorithm and wouldn't normally be a problem in x86/desktop. On 8bit AVR if you're not careful it's possible to have a stack-heap collision if you're not careful. It's possible that you could exhaust heap on the system, by programming error or functions like getline() or other unguarded memory waters. Bad use of memcpy is copying memory outside of bounds, if it doesn't result in a segmentation fault you could copy data from RAM (see heartbleed). If your buffer isn't large enough you could overwrite undefined memory, which could do who knows what. That's off the top of my head, did I get it right? Don't consider myself to have a lot of C practice but those are the things I've encountered/learned.
Do you include the full path? (like `C:\Dev-Cpp\bin`) How do you set the variable? CMD or via the "Environment Variables"-Dialog? If you did it via the dialog, are the variables updated? (Do `echo %PATH%` and look, if there is your path) If not, you could either restart your computer or, for now, do `set PATH=%PATH%;C:\Dev-Cpp\bin` (or where `gcc` is) and you should now be able to access `gcc`, only in that commandline-session. If you did it via the commandline, do it via the [dialog](http://www.computerhope.com/issues/ch000549.htm), and then see the above paragraph.
Thanks.. I had C:Dev-Cpp by accident. Adding the backslash fixed it right up. Drove myself crazy for hours lol.
We use C in the telecom business in real-time embedded systems.
I think it's supposed to tell the compiler to generate code that ensures the variable is read from and written to memory (not a CPU register) every time it is read/written. You would use this, for example, when interacting with a memory-mapped device which is driven by writing bits to specific areas of physical memory. Without `volatile`, the compiler is free to just use a register for these writes, or even optimize it away if the variable doesn't seem to impact the rest of the program.
We use C at work to access different levels of the network stack in userland, on several architecture (none of which is embedded -- they are all powerful processors that draws considerable power), on Linux (and BSD?). The end-game is to suck out every bit of performance possible from these processors. We rewrite some drivers for this paradigm, port the existing stack on new hardware, introduce new features to the stack (protocols), and finally improve interoperability with other networking solutions. As for myself, I am currently porting the stack (or more precisely its configuration) on a new FPGA-like CPU. I wrote a small C test actually a few months ago to triage postulants. There has been a few questions about scoping, static data and static functions, volatile variables, structure packing. An interview follows if the test is passed, to ask about projects and experience.
I think it's just for lazy people, or projects that need to be completed quickly and efficiently. I think C is fit for everything: from website backends to database management, embeded systems, watches, supercalculators, etc., because unlike OOP languages, C tries to *keep it simple*. No objects, no polymorphism, no inheritance, no `iterator` classes (I'm looking at you C++) and other features. While they're nice, they just make the whole thing harder, which is ironic since the goal of abstraction is to make things simpler. tl;dr: too much abstraction kills abstraction
Can't say I've ever thought of using a higher level OOP language in place of C as harder to build some project. C is a nice language and I enjoy using it because it gives you a good understanding if what's going on under the hood, and probably a lot of Stockholm syndrome as I'm in embedded engineering and its either C or assembly. When I want to build some non embedded system though and performance isn't of utmost importance then it wouldn't be my go to language. Use the right tool for the job, don't try and morph the job to fit the tool. 
I try to never make things harder for myself than they ever need to be. Use as many layers of abstraction as possible while still satisfying the system criteria. Sometimes those requirements mean using OOP in say python or c++, because it just needs to be built quickly and do some task. Other times that means writing C and making as efficient as possible. I think the people that tell you you should never use OOP or that you should always use OOP are ideological idiots. I'd rather have a product that works albeit slower than desired than a product only half done because the programmers aren't afforded the tools to do their job. 
I see what youre saying! rather than returning it i just moved the printf scanf for the code into the loop itself and it works flawlessly now. thanks!
Do not post code as images. Images are very hard to debug.
Flops stands for floating point operations per second. Your code doesn't have any floating point numbers.
So what would be a good function to count flops with? Because you need a for loop to get measurable time intervals right?
The compiler needs to know the signature in order to emit the necessary machine instructions to make the call, and since the compiler only runs at compile time... There's really no getting around that, unless you want to skip the compiler and generate machine instructions on the fly yourself. There are some libraries like libffi that do that kind of thing, but generally they are for interfacing different languages, not for making calls within the same language.
Yeah that's kind of what I figured, but I just wondered. It's conceivable that one could write a library that would (while being very compiler specific and other things) be able to build up a correct function call for the right ABI. Didn't think it was likely but just thought I'd ask. Thanks
Thank you for the heads up, had no idea I was shadow banned. Admins were very helpful and lifted. 
I wouldn't say that OOP is being pushed as the one and only way to program by every university, but obviously I can only speak for the one I attend. The introductory sequence, while in C++, does exactly what you do, touching on classes only as structs with functions. The other core programming classes that I've taken go into modules, with a single unit on OOP tacked on for completeness. I haven't done any serious OOP, so I don't really get to complain except to say that OOP encourages programmers to smear their algorithms all over the object hierarchy, which makes it easy to make life really hard for whoever comes in contact with their code later.
OOP is a harmer but not all things are a nail. But somethings are a nail and you should use that hammer for them. I like OOP C but I don't always start out OOP, but when I don't I offten return and refactor to OOP, when I know what is to be done and how. But it does tend to be the top levels of modules that OOP falls out. OOP in C is good because you can have interfaces without any implimentation leaking out. At no/very-little runtime cost.
That's the main threat. No garbage collector here to save you. No free = lost memory = crash all over your system. If you forgot to free, e.g., an array of 128 double (1KB) and that array is malloced once every ms (likely situation on the system I'm working on now), even with 64GB of RAM on your server you would have exhaust your memory in a week. And this system is supposed to be never shut down and work with very strict real time constraints. Now imagine to have some structs which size could also be of some MBs...and that you don't have the whole 64GB for you, but more likely 1/16th of that. BOOM. No, leaks are not good. 
Yeah most of my work in the last year has been embedded or desktop C. Only really had memory leaks on desktop C. Most use cases I've encountered for embedded I free it immediately after its useful, which is a very small point in time. My response before was mostly inspired by having to choose a heap implementation recently
Always happy to help.
That's exactly what libffi is for: at run time you give it the function signature and it constructs the needed calling code on the fly. 
My referred style is pretty rare but I've always been partial to: void * identifier; I see it occasionally but usually people use `*identifier`
Finite elements solver.
As a counter point, the university I attend starts everybody out on Java, so OOP is unavoidable and essentially the only thing taught until you get into higher level courses where C and C++ are used.
Personally, I wouldn't bother counting FLOPs. The difference in execution time between addition and division (both of which are one "FLOP") is quite significant. And then there's the question as to whether the compiler took a* x + b and turned it into either a multiply or an add or a FMA (which does the same thing in one operation). As /u/dragon_wrangler mentioned, there's also the question of non floating-point operations. Moreover, memory access plays a significant role in execution time, often more so than FLOP counting. Briefly put, I've never found an effective way to count FLOPs, and when I did, I didn't find it very useful. Some people do, however. There is the performance model called the 'roofline', so perhaps check that out.
* You've got a buffer overflow in easyppm_read(). Reading a maliciously crafted file can easily lead to code execution (ROP, shell code, etc.). The fix: put a field width specifier on `%s`: `%2s`. Related: if the file has leading whitespace you'll skip right over it. You should just read the first two bytes directly and skip the scanf. * You should pick a open source license and put it in a file called LICENSE. I personally prefer the [public domain](http://unlicense.org/) for these little libraries so that it's easy to drop into a project. Right now no one is permitted to use your library for any purpose. * It looks like you don't support comments in the header (annoying part of the spec, IMHO). GIMP likes to output these, and your library will choke on it, especially since you don't check the return of fscanf. * Don't check the filename extension. That's just annoying. I means I can't ask it to open "/dev/stdin". You're checking the magic bytes anyway so there's no need to be concerned about the filename. It's only there for human convenience. * This is a low priority, but be beware that integer overflow in scanf is undefined behavior. A lot of people avoid it in production code for this reason. A maliciously crafted input file can trigger the overflow. 
Good lord. If you ever find yourself repeating the same few lines over and over like that, it's almost certainly a sign that you're doing something wrong. There is no need for that redundancy. You should only need to ask for input in one place. You're handling the February case with an if-statement, whereas you're handling all the other months with a while loop. That's why there's a difference in behavior. If they entered an invalid February date, you never check the re-entered value. But again, you need to start over from scratch and think up a better structure for how you're doing validation. There should be *one* loop, not twelve little individual loops. And instead of a million if-statements, put the number of days in each month in an array and check against that. This whole function can be done in about a tenth of the number of lines that you have here. Integer literals that start with a leading zero are octal, not decimal. Octal is base 8, so the only valid digits are 0 through 7. 08 is an invalid octal number. Don't use leading zeros. 
* Yeah, easyppm_read() is pretty hacked together, and I'm hoping to improve it to work with files produced by programs other than easyppm (and also to fix the security holes you pointed out). * Good call on the license. I chose MIT after looking into it (some jurisdictions don't seem to recognize the public domain). * You raise a good point about the filename extension. I'll fix that ASAP. Thanks for your input!
Thanks for your input, I'll get right on that!
I'll apologize for how repetitive my code is lol. I'm super new to C, so I'm still learning a lot. If the input of the month needs to be the "mm" format, is there some way to make it so the computer doesn't think I am doing base 8?
Having a leading zero is a property of a string representation of an integer, not a property of an integer. You are not comparing strings, you're comparing integers. Whether the user typed "8" or "08" or "000000008", those strings will all be converted to the same integer eight. It couldn't be any other way because there is only one integer eight, so how could it know which one it came from? The string representation of an integer is not the same as an integer. 
:D Thank you!
You might want to read up on time.h
Dude, thank you SO much. Just fixed that part of the problem. Appreciate that a lot. I just read up on the difference between %i and %d after reading your comment and didn't realize it worked like that. Thanks a lot! 
I like it! Just a couple minor things: * Since it sets all fields in the structure, is `easyppm_read()` intended as a constructor-like function? If so, it might make more sense for it to return a `PPM` instead, which, among other things, eliminates one possible failure. * Passing a `NULL` into most of these functions isn't necessarily an irrecoverable error, and can mostly be handled by essentially doing nothing (like `free()`). Of course then you have to deal with documenting such behavior, but I personally think that would be preferable to the library aborting the program. I guess this depends on how strict you want to be. * `easyppm_clear()` might be better named `easyppm_fill()` to better reflect its full capabilities. * `easyppm_get()` and `easyppm_set()` have NULL checks but no bound checks, which is a bit odd. * A 0 by 0 image isn't necessarily an error, since I might not want any memory attached to the `PPM` yet. * `ppm = NULL` in `easyppm_destroy()` has no effect, since the pointer is local. * For fun, you could provide `easyppm_map()` to compact your loops and standardize iterations over the image. You could potentially save a few bound checks as well. 
&gt; This is a low priority, but be beware that integer overflow in scanf is undefined behavior. A lot of people avoid it in production code for this reason. A maliciously crafted input file can trigger the overflow. There are multiple integer overflows that are higher priority, the four malloc() calls in easyppm_read() and easyppm_create() for starters. Taking one from easyppm_read(): ppm-&gt;image = (PPMBYTE*)malloc(sizeof(*ppm-&gt;image) * width*height); With 32-bit ints and size_ts, we can force the allocation of, say, a 16-byte buffer with, say, a width of 4 and a height of 1073741828: 4 * 1073741828 = 4294967312 = 16 (mod 2^32) Heap corruption then follows. /u/AUD_FOR_IUV should have a think about other arithmetic instances, such as in easyppm_set() and easyppm_get(). 
What's the best way to defend against that?
Yup; `PPM` contains a pointer to a block of tightly-packed, row-major RGB byte triples. 
https://github.com/Pithikos/C-Thread-Pool (Not mine, found it in google)
So that was not that hard ;) Also, why does everyone cast `malloc()` return values? The C standard explicitly says in §3.3.16.1 "Simple assignment" that it's permissible to assign to and from void pointers with qualifiers that are compatible with the other operand without a cast &gt; 3.3.16.1 Simple assignment &gt;Constraints &gt; &gt;One of the following shall hold &gt; &gt; * the left operand has qualified or unqualified arithmetic type and the right has arithmetic type; &gt; &gt; * the left operand has a qualified or unqualified version of a structure or union type compatible with the type of the right; &gt; &gt; * both operands are pointers to qualified or unqualified versions of compatible types, and the type pointed to by the left has all the qualifiers of the type pointed to by the right; &gt; &gt; * **one operand is a pointer to an object or incomplete type and the other is a pointer to a qualified or unqualified version of void, and the type pointed to by the left has all the qualifiers of the type pointed to by the right**; or &gt; &gt; * the left operand is a pointer and the right is a null pointer constant. &gt; &gt;Semantics &gt; &gt;In simple assignment ( = ), **the value of the right operand is converted to the type of the assignment expression** and replaces the value stored in the object designated by the left operand. &gt; &gt;If the value being stored in an object is accessed from another object that overlaps in any way the storage of the first object, then the overlap shall be exact and the two objects shall have qualified or unqualified versions of a compatible type; otherwise the behavior is undefined. (quote from http://port70.net/~nsz/c/c89/c89-draft.html#3.3.16.1; highlights me). 
Because you have to do that in C++ and people don't want to switch their habit if they program in both. At least that's my theory.
Good point. I keep forgetting that you have to have the casts in C++. edit: On the other hand, **if** you're calling `malloc()` directly in C++ you better have a damn good reason
There are bloated safe-integer libraries, but I don't use them, because I can't be bothered auditing them (other people audit them, but that's as reassuring as knowing that other people audit OpenSSL -- the fact it's security-related software doesn't stop problems popping up all the time). For a small library like this, I'd probably assume at least 32-bit ints and size_ts and enforce a reasonable upper limit on width and height, one which won't cause integer overflow for *any* of the malloc() calculations. You already check that width and height are positive, which is a good thing. You should add error-checking for the malloc() calls as well.
I'm a senior-ish c programmer who hasn't really done embedded work (and if we're honest, hasn't touched much c the past couple years), and I knew or could answer all of them except the last couple weird declarations and the __interrupt formalism, but there's no way I would want to work with this dude because I'd always be on edge waiting for the 'gotcha!' 
You're not at risk of depending on cygwin1.dll when you call it by it's Mingw platform tuple name, `x86_64-w64-mingw32-gcc`. I've been running Mingw-w64 this way for years now. Conveniently this is the same gcc prefix on Linux and elsewhere, so your build scripts don't have to change between Cygwin and elsewhere.
In this thread, everyone decides they have a bigger ego than Nigel ;) The questions are fine, as fine as questions like this can be. They tell you if someone has written C before, and if they have done it for an embedded system. This should not be your entire interview. Nigel is a very nice guy who knows his stuff. 
Question 12: &gt; unsigned int a = 6; &gt; int b = -20; &gt; (a+b &gt; 6) ? puts(“&gt; 6”) : puts(“&lt;= 6”); &gt; &gt; This question tests whether you understand the integer promotion rules in C – an area that I find is very poorly understood by many developers. Usual arithmetic conversions, not integer promotions. No integer promotions occur in the given code. &gt; Anyway, the answer is that this outputs “&gt; 6”. The reason for this is that expressions involving signed and unsigned types have all operands promoted to unsigned types. Not necessarily true. From the standard (6.3.1.8p1): &gt; Otherwise, if the operand that has unsigned integer type has rank greater or equal to the rank of the type of the other operand, then the operand with signed integer type is converted to the type of the operand with unsigned integer type. &gt; **Otherwise, if the type of the operand with signed integer type can represent all of the values of the type of the operand with unsigned integer type, then the operand with unsigned integer type is converted to the type of the operand with signed integer type.** &gt; Otherwise, both operands are converted to the unsigned integer type corresponding to the type of the operand with signed integer type. Question 13: &gt; unsigned int compzero = ~0; This article is aimed at embedded programmers. Note that the integer constant `0` has type int. On an embedded system that uses ones'-complement representation, `~0` may result in a trap representation. If it's not a trap representation, it's a negative zero, but the standard says the following (6.2.6.2p3): &gt; It is unspecified whether these cases actually generate a negative zero or a normal zero, and whether a negative zero becomes a normal zero when stored in an object. That could be problematic. Nobody really discusses that sentence, because it's hard to find a system on which it has practical relevance, but presumably it means the compiler is allowed to ignore the `~` operator altogether and generate a regular, all-bits-zero zero. Even if it generates a negative zero, it gets stored into an unsigned int by value, so `compzero` won't be UINT_MAX. Do either of the following instead: unsigned int compzero = ~0U; unsigned int compzero = -1; 
My biggest gripe is that most of the nuances in the trickier questions shouldn't ever make their way into your code, _because_ they are obscure and hard to interpret. If someone on my team wrote shit like `(a+b &gt; 6) ? puts(“&gt; 6”) : puts(“&lt;= 6”);` or `unsigned int compzero = 0xFFFF;`, it would definitely be a topic in code review. Most of the questions cause headaches because they're written with non-explicit types, lack of proper casting or poor practice in general. 
You can't pass random things to `free()`. The *only* pointers that you can pass to `free()` are those that were obtained from one of `malloc()`, `calloc()`, or `realloc()`. That's it. Those four functions form the core of the free-store management interface, which is colloquially called the heap. `alloca()` has absolutely nothing to do with the heap. It would be like buying groceries at the grocery store and trying to return them to Sears. You can't explicitly free the memory allocated by `alloca()`. Such memory is tied to the current execution frame, i.e. the stack. It is freed automatically when the currently executing function returns. There is no other way to free it. `alloca()` is non-standard and should be avoided. The stack is not meant for bulk, unconstrained allocations. It's a limited resource. If you treat it as if it was the heap, it is very easy to blow out the stack and cause a stack overflow. This error is made much more difficult to debug because the amount of space available on the stack is hard or impossible to predict, because the stack is used to keep track of execution frames. Therefore the amount of available stack space depends on the chain of events (i.e. the call history) leading up to the currently executing function. And generally speaking when you design a function you don't take into account what the call stack leading up to it looks like, because you have no control over that. Using `alloca()` makes it extremely difficult to write safe and robust code. 
And you should also be using static_cast instead of a C-style cast in C++ in that situation. Although that mistake is far less egregious than the one you point out. Basically, they're different enough you that this isn't a reason C programmers should be doing that.
I find it deeply disturbing that this guy incorrectly answered one of his own questions that he claims is most important to him in making hiring decisions. He gives three reasons for using volatile: accessing hardware registers, variables accessed by ISRs, and variables used across multiple threads. The third is [something that doesn't really work](https://software.intel.com/en-us/blogs/2007/11/30/volatile-almost-useless-for-multi-threaded-programming/) and you shouldn't be counting on to make your multi-threaded code behave properly. &gt;If a candidate does not know the answer to this question, they aren’t hired. I consider this the most fundamental question that distinguishes between a ‘C programmer’ and an ‘embedded systems programmer’. Embedded folks deal with hardware, interrupts, RTOSes, and the like. All of these require volatile variables. Failure to understand the concept of volatile will lead to disaster. By this logic, the author should be fired. Just goes to show that *everyone* has at least small gaps in their own knowledge, especially when you get into language minutiae like most of this post.
&gt; And so does static when used in an array function argument, but you didn't seem to care about that one. Can you point to an example? Is there a term for this?
Sweet. :)
How have I not heard of this? Is this feature newer than ANSI C? Edit. Seems to have been added in C99
Actually `void foo(int x[10])` means that `foo` expects a pointer to `int`. The `10` has no meaning at all. To try and enforce size 10 you could use `void foo(int (*x)[10])`, but this approach isn't compatible with const-correctness (there's no way to have the function accept both const and non-const arrays). 
Inline in modern compilers from what I understand is a mere very slight hint to the compiler, it does not force the compiler to online the function. And if optimizations are enabled, the compiler should inline such a fu NC regardless if the inline keyword is present. Or am I wrong? 
&gt; Also, why does everyone cast malloc() return values Cargo cult programming. K&amp;R did it, so it must be right. 
Take a look at APR
Do yourself a favour and use a RDBMS
Is there any good sources to better understand pointers? I hate pointer variables
I have posted that report to this subreddit months ago.
So `#define hello 3 * 4 * 5 == 60` will replace every occurrence of hello with true? Or TRUE? Or 1? No. It does evaluate in conditionals though, I agree. But not in the case the article mentions. &gt; Only very recently are compilers starting to diagnose based on this, for a long time gcc and clang just ignored it. The article also argues that using const where applicable also conveys your intentions to other people. By the same logic static should be used for the same reason. &gt; Bitfield layout is implementation-defined, so the author is right to say that they can't be used in portable code. Implementation-defined does not only mean "compiler implementation"-defined. It also means "compiler/platform combinations implementation"-defined. He is still wrong. Also he goes on to talk about the interrupt keyword which is not portable.
Please note, that when subtracted, two pointers must point to elements of the same array object or one past the last element of the array object. This constraint is violated twice in your code by the subtractions of pointers to the first characters of different string objects.
You're compiling using `clang`, right? I just tried it and it seems to be the result of optimizations. Compiling your code with `clang` and either `-O0` or `-O1` gives me the result that you got, but `-O2` gave me the same result as tutorialspoint. Compiling with `gcc` with optimizations gives me (30, -7). As a side note, what got you curious enough to look at these numbers? I remember doing something similar when I was poking `malloc`.
I'm doing exam preparation for my Programming C Course and one of the exercises was to look at a given code and deduct the returning values. I wanted to double check and noticed this discrepancy. You were right about the clang. I added the option "-D CMAKE_C_COMPILER=GCC" in Build|Execution|Deployment -&gt; Make. The code then returned the expected values. EDIT: Thanks for your help u/946336
I thought functions can't accept array arguments in C, and it decays into a pointer to the first element?
It seems to me like the easiest and most portable way to free stack memory is to return from a function. Maybe I'm missing a use-case that your code handles, but why not use an interface like this? typedef void (*callback_ptr)(void *buf, void *data); int call_with_stack_memory(size_t size, callback_ptr callback, void *data) { void *buf = alloca(size); if (buf == NULL) { return -1; } else { callback(buf, data); return 0; } }
The coding style forbids such things. All stack variables are declared at the very beginning of all functions. This is also a necessity, since at some point the code is supposed to be compiled on Visual Studio. And at least the versions I used always were very strict in C mode.
Was not aware of the coding style. But even in the strictest of modes, you are allowed to declare variables at the beginning of scope. Like: if (whatever) { int i; }
I am afraid I cannot follow. int func_native(const char* const __restrict__ string){/*Does something*/} MY_INLINE int func_nns(const char* const __restrict__ nns,size_t nns_length) { ALLOCA_SUPPORT; int tmp_errno; char*string; ALLOCA_MARK; string = alloca(length + 1); memcpy(string,nns,length); string[length] = '\0'; tmp_errno = func_native(string); ALLOCA_FREE; return tmp_errno; } We are already calling `alloca` in the inlined function. Problem is, this is just a simple example. There might be some other inlined stuff within the already inlined function which generates its own strings on the stack. After a while the stack memory might get sparse. Thus I wanna be able to "pop" the `alloca`-allocated stuff when the inline function returns.
 #include &lt;alloca.h&gt; #include &lt;string.h&gt; #define MY_INLINE inline __attribute__((always_inline)) static MY_INLINE void my_alloca(char**x,size_t bytes) { (*x) = alloca(bytes); } int main(void) { const size_t size = 0x1000; char*x; my_alloca(&amp;x,size); memset(x,0,size); return 0; } Even with -O3 this still generates: sub $0x10,%rsp sub $0x1010,%rsp instructions in the machine code (in main). And there are no instructions to restore the stack other than `leaveq`. The space isn't freed automatically in inlined functions, at least I never saw it in the final executable.
I wish we could use Greek characters in C/C++ **code**. Sometimes I really want to be able to name a variable Δx.
I think that's where I remember seeing it from. Figured I'd give some context for how bad Annex K is.
&gt; What is the actual use-case for this? Why do you feel you have to use alloca, instead of malloc? In an algorithm of mine, one iteration with `alloca` scored ~70 cycles. One iteration with `malloc` and `free` scored ~230. That's more than 300% the runtime of the `alloca` variation. And that algorithm already has the stack-rewinding code in it which I posted in the OP. &gt; Better still, why do you have to alloca the arrays inside the loop? Because I process non-NUL-terminated strings whose length I can not predetermine. The code is supposed to be for a library whose use-cases I cannot even predict up to this point. &gt; You allocate the arrays at the top of the loop and free them at the bottom, then allocate new ones in the next iteration. Why not just alloca them once outside the loop, and reuse them over and over inside the loop? Because the processing can be done in inlined functions as well. And as I have shown above, stack memory reserved with `alloca` is not freed upon return - because there really IS not return in inlined functions. And just allocating 128 KiB or more on a fixed basis can be problematic (yet again) with other inlined functions. We got a lot of these. &gt; But in any case, alloca is really not a good function to use. If you're doing few allocations, the savings of using alloca instead of malloc isn't worth the trouble that alloca brings. *looking back to my numbers* I call bullshit. It's damn worth the trouble. &gt; Perspective thing That's a funny one, saying that you didn't have room on the stack for your data. Because you are implying that you have this room on the heap. Now, the way the heap works is that metadata is stored on the same memory that is allocated from the kernel, which is why, even if you acquire full pages from the kernel, you'll never get a pointer aligned to a page address. Even on Windows you can determine the stack size per thread, just as well as on Linux. You can also control the stack size of the main thread via linker options. But apparently adjusting the stack size just a little bit didn't justify the run-time and memory loss you were suffering from allocating memory from the heap ... wait, what? You are effectively telling me that reducing the heap size in favor for the stack, and avoiding: - wasting memory on the metadata - time loss in allocating and searching blocks in the chunk list, both in allocating and freeing memory - ,since you were working in a multi-threaded environment, the lock each thread has to acquire when it needs to allocate memory - independent on whether or not the kernel has to be called for more memory - was not enough incentive for you to figure out how to do that. Sorry, but I am not really impressed by this paragraph of yours. More shocked at how ineffective some programmers are willing to program. Unless, you know, there REALLY was no way to allocate more memory on the stack - and I freely admit that I am not familiar with assembler outside the x86 family. There is no metadata with `alloca`d memory. There is no chunk list. There are no locks. Even describing `malloc` is more complicated than `alloca`s. I honestly don't see the problem.
Well, you didn't make any new matrix anywhere. Presumably if the teacher wants you to make a new matrix, how to do that would have been covered in class?
Expected Output: 70 56 8 8 10 8 Friday Friday 30 18 23 18 Output received: 70 56 8 8 10 8 Friday Friday 30 18 8 OR 18, depending on next line 18 Heres the complete code: #include &lt;stdio.h&gt; int main() { char days[7][10] = {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"}; char *pdays[7] = {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"}; (void) printf("%ld %ld\n", sizeof(days), sizeof(pdays)); (void) printf("%ld %ld\n", sizeof(days + 1), sizeof(pdays + 1)); (void) printf("%ld %ld\n", sizeof(days[1]), sizeof(pdays[1])); (void) printf("%s %s\n", days[4], pdays[4]); (void) printf("%d\n", days[4] - days[1]); (void) printf("%d\n", pdays[4] - pdays[1]); (void) printf("%d\n", &amp;days[2][3] - &amp;days[0][0]); (void) printf("%d\n", &amp;pdays[2][3] - &amp;pdays[0][0]); return 0; }
most of my exams are terrible. This one I find dooable actually. God.. they start in a week..... whish me luck!
Why do you expect a certain output for (void) printf("%d\n", pdays[4] - pdays[1]); The behaviour is undefined as `days[4]` and `pdays[1]` do not point into the same object. Same thing for (void) printf("%d\n", &amp;pdays[2][3] - &amp;pdays[0][0]); The values for `days` are correct.
Is there a rationale why the compiler has all those features but they didn't bother to do such simple things as C99 declaration placement, and C89 passing structs by value? 
&gt;&gt; Better still, why do you have to alloca the arrays inside the loop? &gt; Because I process non-NUL-terminated strings whose length I can not predetermine. Ahh... so in other words, the size of the arrays you want to `alloca` isn't known in advance, and could be arbitrarily large? I guess I got confused by the example code, where the arrays are always 0x4000. But wait, if the arrays could be arbitrarily large, could they be 1MiB? Or 100MiB? If there really is no upper limit, then you *cannot* rely on `alloca`, because no OS that I know of is going to let you have several hundred megabytes on the stack. &gt;&gt; You allocate the arrays at the top of the loop and free them at the bottom, then allocate new ones in the next iteration. Why not just alloca them once outside the loop, and reuse them over and over inside the loop? &gt; Because the processing can be done in inlined functions as well. I don't see what function inlining has to do with this. Consider: void process_string(char* str, size_t len) { /* do stuff */ } int main(void) { char *x; /* allocate x here */ for(i = 0;i &lt; 0x1000000;i++) { /* or maybe allocate x here */ process_string(x, 0x4000); } return 0; } It doesn't matter whether `x` is allocated inside the loop, or out of it, and it doesn't matter whether it's allocated with `alloca` or `malloc`. To call the function, you have to pass a pointer to `x`, and the function won't know care where `x` is allocated. I don't see how it matters whether the function is inlined or not. Unless you mean that the possibly-inlined function will itself be using `alloca`, but again, that's solvable by just allocating a scratch buffer once, instead of `alloca`ing a fresh one every time. &gt;&gt; Why do you feel you have to use alloca, instead of malloc? &gt; In an algorithm of mine, one iteration with alloca scored ~70 cycles. One iteration with malloc and free scored ~230. That's more than 300% the runtime of the alloca variation. Yes, no doubt alloca was faster than malloc. But is that significant, compared to the time to process the data? In your example code, you allocate 144KiB. You can't be processing 144KiB of data in only 70 cycles, so I assume what you measured was a "do nothing" algorithm. But if the time to execute the real algorithm dominates the time spent making and freeing allocations, then it's irrelevant. &gt;&gt; Perspective thing &gt; ... I admit, I didn't give a lot of detail, but that's because I didn't expect you to try to tear me to shreds for trying to offer some advice. You're right, we *could* simply increase the stack size. But if we do that, the stack for that task would be permanently larger, even when that audio codec isn't being used, or worse, when it's not even included in the firmware. Since the stack size is compiled into a library that we don't provide in source form, and the codec is an add-on, the stack size has to be set to a fixed value. So instead of using alloca for scratch buffers, we malloc. But we're not stupid. We malloc *once*, when an encoder/decoder for that codec is created. The scratch buffers are just that: scratch. It doesn't matter what data is left in them from the previous iteration, because it's going to be overwritten anyway. Why would we need to free them and allocate a new one? I was trying to make a point, but you decided to attack me instead of seeing if you could learn something. You wrote &gt; The code is supposed to be for a library whose use-cases I cannot even predict up to this point. and my point is, what happens if one day *I'm* one of those users? I'm on an embedded platform that doesn't have virtual memory or page faults. If you overflow the stack, it doesn't segfault; it just overwrites some other process's memory. So I have a choice: use alloca, and the stack for that task always needs to be big enough to handle the worst case, which is wasteful, or use malloc and everything is simpler and safer. And in most cases, the malloc can be done only once, and/or the allocations aren't frequent enough and the meat of the processing is slow enough that the small overhead of using malloc isn't worth quibbling over. ---- If you don't want my advice, fine. I understand that you may have totally different concerns when implementing this on your target systems than I would on mine. If you *really* don't like my advice, then downvote and move on. But I was careful to ask questions, to make sure that I didn't have any incorrect assumptions, whereas you went out of your way to insult me and my entire team based on almost no understanding whatsoever. That was totally uncalled for. edit: formatting
Oh, so simple and beautiful! Thanks very much, it's working now :DD
Thank you, I solved the problem with the recursion method.
You totally can! Nobody ever seems to know this... The C++ standard explicitly allows for Unicode characters to appear in source code. The actual character set accepted by any compiler is implementation-defined, of course, so it's not *strictly* portable, but both GCC and Clang support the entire (or almost the entire?) BMP, and Clang supports even more (emojis, or so I've heard); GCC has `-fextended-identifiers` for the wacky stuff, but it's experimental and not stable. I'd imagine any reasonably modern compiler would accept at least the European scripts, though I haven't tested MSVC or ICC or any other. But yeah, go crazy with the Greek, Cyrillic, extended Latin, etc. All that should be fair game unless you're using a really obscure or outdated toolchain.
Sorry, this is gonna be a WOT. &gt; Ahh... so in other words, the size of the arrays you want to alloca isn't known in advance, and could be arbitrarily large? I guess I got confused by the example code, where the arrays are always 0x4000. This was done for the sole purpose of illustrating that we now can allocate on the stack and rewind it whenever we want. &gt; But wait, if the arrays could be arbitrarily large, could they be 1MiB? Or 100MiB? If there really is no upper limit, then you cannot rely on alloca, because no OS that I know of is going to let you have several hundred megabytes on the stack. Do you know how hugepage mappings work in Linux? Did you know that you can just assign one of those to a stack thread that you are using instead of the default one (which you then can set to the minimum size)? And before you ask "why would anyone do that" - because, compared to the default memory allocation that is done through pthreads, this is actually quite fast. Some years ago I caused a load average of over 5000 (no pun intended) just by creating threads on a pre-mapped block of memory. A HUGE block of memory. And the funny thing is that even though the LA was just that high, the system was still responsive. When I let pthreads do the stack management for me, I didn't even get over 400. On Windows you are might be right. I have not had the opportunity to benchmark thread creation there, but I will have to one day. The only thing I know about Windows is that it does not let you provide your own stack memory. On Linux I can generate a stack mapping that ALSO does not cause TLB flushes, because we are using hugepages - depending on whether they are available or not. And to check for availability we also have functions. And these mappings may be huge. Or, if we don't like the idea of permanent memory consumption (something that is - yet - unavoidable with the implementation of hugepages) we still just use normal page sizes, take the penalty of page walks, but effectively save memory that might otherwise not have been used. And if it just has been a peak in memory usage, the kernel is free to swap the pages. &gt; It doesn't matter whether x is allocated inside the loop, or out of it, and it doesn't matter whether it's allocated with alloca or malloc. To call the function, you have to pass a pointer to x, and the function won't know care where x is allocated. https://www.reddit.com/r/C_Programming/comments/4o0p04/how_would_one_implement_a_freea_on_x8664/d48s6wf This is actually more of a direct use case there. An inlined function which is supposed to make sure the strings are NUL-terminated, then calling the actual function. This is required quite often, may it be file access, may it be DNS lookup, time parsing ... Now imagine such an inlined function to be called in a loop. Memory reserved by `alloca` is not freed upon returning, and - the most important thing - the programmer might not even be aware of that fact. So he just keeps reserving, and reserving, and reserving ... And why should he know about that behavior of these functions? He's just calling one of them. It's not like he's using a macro, right? It's not like he NEEDS to know what the function does in order for the programmer to program properly. Making sure the string is null-terminated might be the only purpose of such an inlined function. Copying the string to the new buffer is fast. The actual function call may be slow, but if so, that's because we do interaction with the kernel. But the damn memory management is NOT SUPPOSED to be a bottleneck. And in my aforementioned example this is like the HUGEST bottleneck - again, 70 cycles compared to 230. Before you say "well then just let the caller provide its own memory" - that would be possible, but simply overkill, because I also provide functions for multi-platform memory allocations (hugepages). Don't misunderstand me - these functions were DESIGNED having permanent storages in mind, and they also support pure stack-based allocations. But again - why would the programmer - the user of the library - NEED to have to worry about that? What if he just passes NULL instead of an object as a memory sink for us, just to keep things simple? That again leaves us with allocating our own memory. &gt; In your example code, you allocate 144KiB. You can't be processing 144KiB of data in only 70 cycles, so I assume what you measured was a "do nothing" algorithm. Weee, I am quoting myself in the same post: &gt; This was done for the sole purpose of illustrating that we now can allocate on the stack and rewind it whenever we want. Actually I did something in the real implementation, that is, I NUL-terminated a string! And I measured how long the inline function took before the actual call was executed. Now, granted, the string was like four bytes long, nothing elaborate. But, you see, that's the thing. With `malloc` I just have this delay before the actual function was called, while it can be done properly in less than a third of the time. I can expect the user to exercise some caution when they explicitly map memory into the process and use that for their thread stacks. I cannot expect this to happen when they are just calling a function to save/load a file or whatever. &gt; I didn't give a lot of detail, but that's because I didn't expect you to try to tear me to shreds for trying to offer some advice. ? I was perfectly polite and merely expressed my concerns upon your ... let's call it solution of a problem you have encountered in the past. &gt; But if we do that, the stack for that task would be permanently larger, even when that audio codec isn't being used, or worse, when it's not even included in the firmware. The last time I checked Linux mapped virtual addresses to physical frames only if: - the range was marked via `mmap` or `mremap`. - the memory has been accessed. - hugepages are not being used (then, and only then is the mapping actually always kept in memory). Until then, it just wastes virtual memory. Not physical one. That is done when `alloca` actually needs that memory - and then you needed it, and it's therefore not a waste. Oh, and even if you were concerned about that - virtual memory for the stack is allocated en block. That is, there's zero fragmentation, IOW, no virtual memory waste. The same can not be said about the heap on bigger allocations - once a certain threshold is exceeded there, usually an entirely new mapping is created. And on Windows they have a working set of pages to be hold in memory which you can specify. &gt; But we're not stupid. We malloc once, when an encoder/decoder for that codec is created. U-hu? Concerned about memory, but using `malloc` instead of `mmap`? I think I'll rest my case here. &gt; I'm on an embedded platform that doesn't have virtual memory or page faults. In the example you have provided, or is this a new one? If it's the first one, then I still fail to realize why not to make the stack just bigger and the heap smaller. After all, the normal memory layout usually is that the stack is on the edge of the memory, while the heap is on the other side, each growing towards each other. Not using the heap automatically makes the stack bigger on platforms where you don't have memory protection. At least, that's my understanding of the issue. &gt; whereas you went out of your way to insult me and my entire team based on almost no understanding whatsoever. That was totally uncalled for. When did I insult you and your team? Did I call you incompetent? Did I question your ability to figure it out? Read again: &gt; You are effectively telling me that &lt;reasons&gt; was not enough incentive for you to figure out how to do that. I implied unwillingness there, not incompetency. In other words, lazyness. Programmers are lazy, yeah. But if you are lazy you shouldn't think about performance issues in the first place, but rather program in C++ or Java. There I am not even sure you have to worry about such things, almost every object is just put on the heap and are freed when they are not used anymore, and memory is just this abstract thing you don't have to worry about anymore. If I wanted to question your competency I would have done so directly by saying that you probably don't even understand what I am talking about. I didn't. And even yet - if my ruminations on how memory would work in that described setup of yours are wrong - by all means, correct me, because there's always the possibility that you know something that I am not aware of. &gt; If you really don't like my advice, then downvote and move on. I took your advice, and I carefully laid out why I don't agree with it. That's called an argument.
Thank you very much! Recursion is the more interesting solution, but sadly C does not (that I know of) optimize tail recursion.
Maybe I'm missing it but it seems that they've focused on C++ support more than C. 
C++ has both of those features (and they are even more important in C++ than C) 
Hi, I'm a new C student and learning about pointers as well but would a possible solution to OP's problem be a function that takes an array pointer (from the user entered matrix)? Then you could increment each value with a for loop to go through the adjacent memory locations from the passed pointers value. 
Tbh the reason I chose C is mainly because I needed a one-use batch renamer that I could write in about 5 mins, and it's the language I feel most confident with at the time. [The concept was pretty simple; read name, surname and class from textfile, generate new name, rename.] That, and wanting to experiment with unicode characters. You're absolutely right though; the reason someone would choose C over other languages would probably be performance. 
fwiw solved it in the manner I suggested: +/u/CompileBot C #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { int lc1,lc2;/*loop count integers.*/ char temp[]="supercalifragilisticexpialidocious"; int temp_len = strlen(temp); puts(temp); for (lc1=1;lc1&lt;temp_len;lc1++) { putchar(temp[lc1]); for (lc2=1;lc2&lt;lc1;lc2++) { putchar(' '); } putchar(temp[lc1]); putchar('\n'); } return 0; }
Output: supercalifragilisticexpialidocious uu p p e e r r c c a a l l i i f f r r a a g g i i l l i i s s t t i i c c e e x x p p i i a a l l i i d d o o c c i i o o u u s s [^source](http://ideone.com/LJzgaZ) ^| [^info](http://www.reddit.com/r/CompileBot/wiki) ^| [^git](https://github.com/renfredxh/compilebot) ^| [^report](http://www.reddit.com/message/compose?to=compilebot&amp;subject=Report%20Abuse&amp;message=--report%20https%3A//www.reddit.com/r/C_Programming/comments/4o3rwh/want_to_add_a_to_my_printf_after_each_loop/d4a2vug%20Include%20your%20reason%20for%20reporting%20here.) 
Like you, this is a feature I would like in C (Though actually designing such a feature is not as easy as saying "I want it" unfortunately). That said, I don't think this is really a solution. The attribute is not guaranteed to be enforced. The big catch is when you attempt to call a `int x[static 1]` function from another function, which had `int *x` in the parameter list instead. Ideally, a 'nonnull' attribute should force you to check if `x != NULL`, and only allow you to call `foo` if that is the case. This won't though, you can directly pass it `x` and it won't care. IE. This works: int foo(int x[static 1]) { return *x; } int foo2(int *x) { return foo(x); /* Shouldn't be allowed */ } Without such a stipulation, a nonnull attribute isn't very useful. I think it's also worth noting that a 'real' nonnull implementation would allow you to declare individual pointers as nonnull as well: int *nonnull x; This is important because only `nonnull` pointers can be passed to arguments that require `nonnull`. By requiring the `nonnull` attribute, you can make actual guarantees that `NULL` is never passed. As a note Haskell features such a system. By default variables must always contain a value (Hence being 'nonnull'). `NULL` doesn't exist in that context. If you want to gain `NULL` as an option (They call it `Nothing`, but it serves a similar purpose), then you combine your type with the `Maybe` qualifier (Not really a qualifier, it is called a Monad, but a C qualifier is probably the closest C equivalent). Thus `Maybe Integer` means it might be an integer value, or it might be `Nothing`. Handling the `Maybe` qualifier in some way is required before you can pass the contained `Integer` to another function, because `Maybe Integer` and `Integer` are two different types.
&gt; Oh god please not. Features that force me to do something are the worst as they lead to design bugs you cannot work around. Every feature must have an escape hatch that allows you to break invariants when you have a good reason to do so. Ah, but if you think about it, my idea *does* have an escape hatch: Just cast the pointer as nonnull. If you're willing to use the GNU extension `typeof` then a `NONNULL` macro that marks a pointer nonnull could easily be created (Or such a macro could just be included with the `nonnull` feature): #define NONNULL(x) ((typeof(x) nonnull)x) Also worth noting is that it is an addition - old code would not be broken and would function the same. That said, I'm not really suggesting it should be added necessarily. It's a decent idea but still has problems that would have to be worked through. But with some work it could be a fairly nice thing to have.
&gt; So the warning is because it can't be predicted whether the (i = 6) or the (j = 3) sub-expression is first evaluated. No, that's not what the warning is about. Having two assignments to two different variables is fine, and if you had written the following there would be no undefined behavior: k = (i = 6) + (j = 3); The problem is that you're storing to j twice without an intervening sequence point, and that is undefined behavior.
but the binary operator *+* has more priority than the assignment operator (*=*). So shouldn't it calculate *(i = 6) + (j = 3)* before making the assignment? **EDIT:** OK, I think I understood now. Thank you! Just another example to see if I got it right: int a, b, c; a = 5; c = (b = a + 2) - (a = 1); In this case, this can happen: b = 7; a = 1; c = 6; a = 1; b = 3; c = 2; c = 6; b = 7; a = 1; c = 6; a = 1; b = 3; b = 7; c = 6; a = 1; a = 1; c = 2; b = 3; Right?
What does the statement `j = (i = 6) + (j = 3);` mean, in baby steps? Duh, the value of `i = 6` is 6! By the way, I need to remember to actually store the 6 inside `i` **some time later**... Duh, the value of `j = 3` is 3! By the way, I need to remember to actually store the 3 inside `j` **some time later**... Hm, the value of `(i = 6) + (j = 3)` is 9! By the way, I need to remember to actually store the 9 inside `j` **some time later**... `;` **Ah, a sequence point!** Okay let's see, what side effects have queued up so far... shit, `j` appears twice in that list! I'm gonna throw my hands in the air and celebrate undefined behaviour time!
&gt; the binary operator + has more priority than the assignment operator (=) "Precedence" is different from "order of operations". Precedence is part of the grammar, in other words, it clarifies how things are interpreted in the absence of any parentheses. "Order of operations" is what order the operations (math, function calls) are performed in. Assignment is an operation that results in a value, but the actual saving of the value to storage (register or memory) is a side effect, and side effects aren't ordered at all, other than that they must be completed after a sequence point.
&gt; Also, what you’ve made is only kinda a pointer, and it doesn’t have the same properties as a normal pointer Can you elaborate on this? My reading of the C standard indicates that an argument declared like this behaves like an ordinary pointer with the extra invariant that access to the first few elements of the pointee is guaranteed to be possible.
Under the hood, it behaves like a pointer, yes. Above-the-hood, it’s a strange mix of pointer and array, and I generally avoid any array parameters like the plague because it gets confusing for readers quickly. There’s also potentially undefined behavior for access *outside* the array’s bounds (index &lt;0 or &gt;1 in this case), in which case (like any other UB case) the C compiler could very well optimize anything away that tries to use the pointer normally. The only way I can think of to do this safely would be either void f(size_t count, int array[count]); or (the *one* time old-style parameter decls are still necessary): void f(array, count) size_t count; int array[count]; { ... } 
I think all he's saying is that to the average, novice, or crusty C programmer, `int* x` looks like a pointer and `int x[static 1]` doesn't, and that they may be confused as to what this newfangled thing is and what they're supposed to do with it.
A pointer to a Field struct should point to enough memory to hold a Field, not enough memory to hold a pointer to one.
~~Next time tell us what Valgrind said specifically,~~*[edit: it was obſcvr’d moſt cleuerly]* as well as what dialect of C you’re using, what compiler if it’s relevant, and what libraries (e.g., POSIX; Win32; nothing outside ISO?), as well as what the intended behavior and audience will be. What platform(s) are you targeting? What architecture(s), if any? What have you tried? This is like posting “My code has errors. What should I do?” I’ma show you how to do a few things differently in this and next comment, in order code-wise (you’ve already been told about the Valgrind thing, but I’ll aim higher); solely suggestions, take with a grain of whatever mineral you prefer: #`gameoflife.h` • Your include guards are named wrong, look left-over. I also suggest naming them to make their purpose clear, should you want to dump macros at some point; I use something like aalto__game_of_life_h__INCLUDED__ but that might piss C++ programmers off. Either way, `#define` it to 1 not nil, because then you can just use `#if` in informal tests of it. Also, I don’t know why, but half of your empty lines have random spaces on them. Set your editor to delete trailing spaces so you don’t fuck up a line continuation sometime. • Do a C99 check near the top; your `for` loops are C99 code, but nothing documents that or requires it (default for most compilers is C89, no `for(int i;;)` &amp;c.). Something like #if (__STDC_VERSION__+0) &lt; 199901L #error "this requires a C99 compiler/mode" #endif If you’re not allowed to use C99, you’ll have to declare your variables outside the `for` loops, all grouped up at the top of the containing block. • CHAR_DEAD and CHAR_ALIVE are parametric and not terribly descriptive; you should probably do #ifndef FIELD_CHR_DEAD #define FIELD_CHR_DEAD '.' #elif FIELD_CHR_DEAD &lt; 32 || FIELD_CHR_DEAD &gt;= 127 #error "FIELD_CHR_DEAD outside valid range (32 - 127)" #endif // Ditto FIELD_CHR_ALIVE (this assumes ASCII, which is near-universally a safe assumption for stuff like this) which then lets you define the variables at the compiler command-line, which is lovely for Makefiles and a very good habit to get into. E.g., you can gcc -DFIELD_CHR_DEAD=32 etc. etc. in order to set the dead character to a space. (32 could be `"' '"` but that’s more complicated. It’s good to know a little ASCII.) • You have a binary liveness per cell; I suggest including `#include &lt;stdbool.h&gt;` and not bothering with `State`. (—Which should really be `CellState` or something similar if you decide to keep it, since it’s not a `FieldState` or `ProgramState` or anything else…) • Again, `Field` should be `CellField` or `gameoflife_Field` or something. Fields and states and liveness show up all the time in CS. Anyway, you don’t need a pointer-to-arrays-of-pointers. That’s not how two-dimensional arrays work in C itself, unless you need completely different lengths (or nullability) in each row. You have a nice, neat rectangle but you don’t know its size at compile time, so you want a normal pointer in your `struct`. unsigned char *cells; That↑ `unsigned char` is because you don’t even need `CellState` to be a thing w.r.t. this array, hence my recommendation to scrap it. You need to represent one of two possible values in each cell, alive and dead; ⌈log₂ *n*⌉ bits are required to store an *n*-valued constant; therefore only 1 bit is needed per cell. (You’re probably using 32× the memory on most platforms, 16× minimum per standard.) If you use the individual bits of an `unsigned char` instead, you can just bit-magic the cells in and out with very little effort. (Actually, you can do hella optimization here but no reason to go too nuts.) Also, a pointer will have stricter size/alignment requirements and tends to be larger than an `int`, so put that first. In this case it won’t matter since it’s next to a pair of `int`s, but in general sorting with largest/most complicated first allows the compiler to pack your `struct` into the smallest space possible. • You don’t need to say `unsigned int` every time you want an unsigned `int`, because `int` is the default type like everywhere in C, even where it shouldn’t be. It’s fine, but once you’ve been lightly seasoned you’ll be saying just `unsigned` anyway. (Many people `typedef unsigned uint;` or similar, not that I recommend it. There’s also an argument to be made for using `size_t` instead of `unsigned`, since you’re dealing with array lengths, but I’m not going to make it.) • There are various verb pairs you’ll get used to using around de-/allocation and de-/initialization in C. Tends to be `init`/`deinit`; `create`/(`destroy`|`delete`); `setup`/`teardown`; `new`/`delete`; `alloc`/(`free`|`release`). You’re mixing verb groups in your names FWIW. This next crosses over into `gameoflife.c`: • I strongly recommend one of two different memory management strategies here. The more C-like one (I’ll call it MMMethod A) places responsibility for the `Field` structure itself entirely on the caller. This is the usual way of doing things; the caller will do Field field = Field_INIT(width, height); // &lt;- Usually a macro, like #define Field_INIT {0, 0, 0} // or something equally default or Field field; Field_init(&amp;field, width, height); to create the field, then Field_deinit(&amp;field); to destroy it. (This is how C++ does it too.) Only the cell array needs to be allocated/freed here since its size is arbitrarily large and not compile-time-constant (well they are with this driver, but not per API); everything else is fixed-size and fits neatly on the stack. Alternatively (MMMethod B), if you want the entire thing managed in one piece (i.e., guaranteed no invalid structure will ever cross your function’s argument list) and have C99, you can do typedef struct Field { unsigned width, height; unsigned char cells[]; // Trust me on this one } Field; If you have GNU or Microsoft but not C99, you can do `cells[0]`; if not, then use the prior technique instead, because any other kind of array there could induce undefined behavior on newer compilers. Anyway, what MMM. B does is leave an array of unspecified size trailing after your structure; this prevents anyone from declaring their own `Field` because how much space would you allocate?, but you can `malloc` it with the appropriate block of array memory after it and deal with it all in once piece. *(cont’d.)*
&gt; Just to be clear, there are 6 possible execution orders of the 3 assignments: I want to clarify a little further, as your wording could be interpreted as meaning that one of those 6 executions will take place and that `j` will have a value. Assigning to the same variable twice without a sequence between is undefined behaviour. It's quite possible that one of those 6 execution paths you've laid it will happen, but there *are* compilers where `j` will have a completely different value (like 0 or 15), or where the assignment statement is never executed at all, or where the program will crash, or where the compiler will crash before any code is generated.
The valgrind output is in the link he gave.
The size sticks to it to some degree (especially with multidimensional arrays, but that’s beside this point). There are cases where you get undefined behavior for this kind of array that you wouldn’t for a pointer. §6.7.6.3¶7 of C11 (which is what I’m working off of) deals with the array-to-pointerish adjustment. You’re using and presumably familiar with that, but here’s that passage, important part bolded: &gt; If the keyword `static` also appears within the `[` and `]` of the array type derivation, then for each call to the function, the value of the corresponding actual argument **shall provide access to the first element of an array with at least as many elements as specified by the size expression.** You require a size of 1×whatever-object because a size-0 array can’t be declared, which is fine in most cases. Let’s do down-in-the-weeds problems first: `malloc`, `calloc`, and `realloc` accept size 0 (§7.22.3¶1, rel. bolded): &gt; If the size of the space requested is zero, the behavior is implementation-defined: [E]ither a null pointer is returned, or the behavior is as if the size were some nonzero value, except that the returned pointer **shall not be used to access an object.** Given that most C compilers share backends with C++ compilers and C++ requires a unique address from `new T[0]`—not necessarily accessible, or able to contain an entire element of the array—it’s likely that most non-embedded Cs (or rather, their standard libraries) will follow C++’s example for their `malloc`, and indeed that’s what I see on glibc at least, and IIRC MSC does the same. So that’s one valid nonnull pointer that can’t be used with a function parameter array-of-at-least-1. But we don’t need to look that far; basic pointer arithmetic will get us there too. If I do void f(int arr[static 1]); ... int arr[8]; f(arr + 8); That’s a perfectly valid pointer I’ve just constructed (per §6.5.6¶8), but the “shall provide access to the first element” requirement is broken since you can’t access anything at that position without inducing UB. (IIRC there are a few compilers that provide one-before-start non-UB too, in case somebody loops a pointer down to base−1, and that’d be a non-standards-compliant pointer that doesn’t work.) And of course there are entire kinds of types that won’t work for this. E.g., although these are such common kinds of things I’m not going to hunt down chapter and verse, // Pointer I’d like to emulate: void (*fp)() // Attempted parameter-array definition: void func(void arr()[static 1]) // Bork; can’t have array of functions. // Pointer I’d like to emulate: void *p // Attempted parameter-array definition: void func(void arr[static 1]) // Bork; can’t have array of void. // Pointer I’d like to emulate: struct S *p // (I haven’t defined S yet, and may never; yet I can safely use it in pointer types.) // Attempted parameter-array definition: void func(struct S arr[static 1]) // Bork; array element has incomplete type. // Ditto `union`, sometimes ditto `enum` depending on compiler. Additionally, things like `jmpbuf_t`, `va_list`, or `FILE` aren’t defined specifically enough by the standard that they can show up in an array—could run into the “incomplete type”, could run into multidimensional effects, no telling because what’s behind those types is entirely implementation-specific and intentionally opaque. Moving out into things like POSIX—not the standard, but rather important to consider all the same given its near-universal support—you have `mmap`’s `MAP_FAILED`, which is `(void *)-1`, so if you want to apply the array trick to values like that you really can’t do that `static 1` without getting way outside the standard. (Not that the `(void *)-1` isn’t already somewhat outside it.) Stuff like `SIG_ERR`, `SIG_DFL`, or `SIG_IGN` also tend to use odd pointers as a trick to stay out of the ABI’s way (glibc’s use `-1`, `0`, and `1`, respectively). …But then, these are `void` or function pointers, so they can’t possibly be used as elements in an array type anyway. Problems aside, some compilers (e.g., GNU) *will* let you do `[static 0]` to create the kind of pointer that would fall out of flex array reference decay, in which case you *could* stay otherwise within standards bounds FWIW for the specific kinds of pointers that don’t break this trick. Unfortunately ISO forbids 0 there, and given the already-obscure nature of it to begin with, I don’t see all that compelling a case for using it in the wild. It’s neat, but no more neat than using an explicit dereference to the same effect, and the latter has much, much more flexibility.
Thanks for your reply! If I'm understanding you correctly, the scanf works properly for 'value.' If I enter a negative integer the loop ends like I want. I can't get the if-else statement to work for when there is no count.
The other posters have answered why it's not working. I'd like to point out that if you only want positive integers, it may be more appropriate to use an `unsigned int` for `value` instead of `int`. The corresponding format string for scanf is `%u` instead of `%d`.
This is a really excellent explanation :)
Wow, what a great answer! Thank you. In this case, I am not free to name my functions and structs, because the automated tests expect me to use the same names as defined in the header. The code is uploaded to a server, and then tested there. I think they compile it on a flavour of Linux x64, but that wasn't stated. I compile using the GNU toolchain on Darwin and Linux, and Cygwin on Win32.
Also a `do` .. `while` loop would be more appropriate here.
in this particular case, unsigned works just fine. If there was any subtraction going on, you would need to be careful that your unsigned int wouldn't underflow and become an extremely large positive value. unsigned i, j; i = 0, j = 1; printf("%d", i - j); should be whatever the maximum integer is in your environment. 
Y’welcome, hope it helps at all. Figgered you had limitations imposed, but ’s never bad to do it up right for oneself. Programming as an art and all that.
but then, if user entered a negative number, he has a very garbage number to use. and he will not check if the user entered wrong because scanf will return 1. Am I wrong?
I'm seeing bold red text on light gray tabs that doesn't look good at all: http://i.imgur.com/6CCoVXK.png I don't know if that's the way it was intended to look. I would suggest using a dark blue to highlight the active tab: http://i.imgur.com/soxmw2L.png Other than that, everything looks very polished.
&gt; I can't make it run when these two numbers are different What does this mean? It doesn't run at all, or it doesn't provide the output you expect? What kind of error are you getting - runtime, exception, return code, blue screen? Also, post your code.
Need more info
Seems you modeled the problem in the wrong way. Need your code, though, and more info about the error
I can't post the code online because I will get in trouble as this is a project for my university and they are strict. I was hoping on some advice on how to model the problem in general :/
I can't post the code online because I will get in trouble as this is a project for my university and they are strict. I was hoping on some advice on how to model the problem in general :/
A modified snippet would be ok. Without anything, any online tutorial/Wikipedia/stackoverflow article would have the same value as our replies
Why are you asking us? Why aren't you going to your professor or TA for help? That's what they're there for.
I am sorry for not giving enough info and I really appreciate your caring. Everytime the program works, each producer and consumer prints the numbers it produced or consumed. Whenever I run this program with eg 4 producers and 2 consumers, it prints the contents of prod and cons 1, then prod and cons 2 and then only prints the contents of prod 3 and nothing more is printed, without the program exiting, it seems like it is still running.
Debug. Even with some printf. Obviously the producer aren't releasing the empty semaphore. Either they're dead before the time or they're waiting somewhere causing deadlock. Sorry, very difficult to understand concurrency problem without running, fot me at least
Yeah, you're going to have to run it and try to trace through what's happening. I don't see anything obviously wrong with the multithreading aspect of the code. The only thing that's questionable is how many iterations the loops run for. If each loop runs 100 times, and you have 8 producers and 5 consumers, then you'll try to produce 800 numbers but only consume 500 of them. If that happens, the queue would fill up because the consumers are done consuming, and the producers would deadlock because they can't push to the queue. Similarly, if you have more consumers than producers, they'll still be trying to consume numbers but the producers have already stopped producing them.
Definitely a good point. If the program must validate whether the integer entered is positive or negative, then using `int` would be better. If the input is guaranteed to be positive, then `unsigned int` is the way to go. If unsure, I'd probably err on the side of caution and read into a signed value, then copy it to an unsigned type once it's validated. In a larger piece of software, this would signify the "positive-only" constraint to any functions that the data is passed to.
If you have to use APIs or link to libraries you're going to see A LOT MORE C++ on Windows and IOS devices than C. But if all you're doing is writing plug ins for an existing app, using its native app language (whatever that may be) than stick with C. 
Why not both?
What language you learn isn't really important. What is really important is that you learn how to program in several programing paradigms such as object oriented, and procedural. As for embedded systems, depending on what you are doing, knowledge of Verilog or VHDL is probably just as important. 
I believe BSTR uses wide characters so try printing it with %S (capital s).
I'd spend the extra $ and get the newer version. It's worth it. I own, and have read, both.
Really depends on your career path. As an EE you are more likely to use C to deal with MCUs, CPUs, GPU or SoCs. C++ would be more helpful if you are going to be working more in embedded software (drivers, operating systems, etc). In my case (MSEE), I use mostly C and Verilog. However, I still learned C++ and VHDL since I need to use them every now and then. My advise, learn both. But make sure you understand C well.
I would say most of your career you will probably be stuck doing C++. I think C is better but much of the time I'm alone in that and working in C++. But really be a good C++ programmer you should know at least some assembler so you can at least roughly follow how your code compiles. C is a better place to learn that as there is less moving parts as everything is explict. C is can almost be throught of as high level assembler. You will also find, because of want of control, system libraries are in C, and the OS. If you want to debug all the way, you need C even if you wish to be a C++ person. You will find the lower you go the more people prefer C. So learn C++ because you can't escape even if you want to. But also learn C (including reading real C code bases, sqlite, busybox, etc) and learn some assembler, if for nothing else but to be a better C++ programmer.
The adage of 'if you know C, you can learn C++ is somewhat true. The basic syntax is the same, but once you start into the object paradigm then no, C is basically useless. OOP programs are rarely linear and things like instances and inheritance/polymorphism don't exist in the C world. 
It's a good thing that they open-sourced it, but I'm not sure if it's actually relevant, as far as usage/adoption goes.
Exactly, including the ones on the current standard. They could've gone for guidelines of how to use regular language, instead of creating their own. Again, good thing that they open-sourced, but tbh, industry-wise, it's useless.
You should read [this book](https://www.cs.rit.edu/~ats/books/ooc.pdf)
&gt; Is it OK to use size_t everywhere, or should I prefer something like uint64_t? (This code is aimed to run on various 64-bit machines, and maybe some 32-bit. Not on embed hardware) Not only it's OK, it's more explicit and I'd recommend it. &gt; is it OK to return a copy of the data most of the time (for all the new CHFL_* pointers), but a pointer to memory that will be freed if the user delete the corresponding frame? It's up to you!
This. *Learn C and you'll learn the basics of this civilization, learn assembly and you'll learn how it works. But learn to program, and the world will be yours* - me
Yer.... that's not true. OOP in C is pretty common in Unix/Linux world. The example that takes it the furthest is gobject/gtk. But sqlite, wine, wayland, dbus, udev, you name it, is all OOP C, often more minimal than gobject, but still OOP C. I acturally like OOP C the best. Modular and seperates interface and implimentation. There is nothing in C++ you can't do in C, but also the reverse is also true. And a good lowlevel programmers compiled output could basically be the same. Though you'd have to avoid the highlevel C++ stuff for that to be true. Which is abasically what you see where C++ need to be small and fast, like in games. C++ is a much bigger language and includes most of C from 20 years ago. But it could be said to also includes a few other languages too. It is probably the broadest language out there. That it's strength and weakness. It's kind of like quantum physics in that "If you think you know C++, then you don't know C++.". Compiler writers weep. And for a language unsafe, I'm not sure prending to be a high level language is such a good idea. I see a lot of bad C++, and much of the time it's because the developer doesn't understand the compiler is dumb and they don't understand exactly what they have told it to do. And to be fair, it is hard. Though went in doubt, they really should look at the disassemberly. That is a large part of how I learnt.
&gt; Just imagine that one of the functions in your struct has the wrong parameter/return type because one of your coworkers was lazy. In this case, you get a compile error since pointers to functions with different argument types have different types. &gt; There are many other issues with the use of function pointers, like the ability to argue about the maximum required stack size or the ability to guaranty that no recursions may occur ever. If you are in an environment where that is a a serious concern, then yes, it is a problem. However, usually this isn't.
Not everyone will be able to use this, but if it fits your requirements, what's stopping you?
thanks for the advice, what do you mean exactly by understand C well, as in the string handling and memory allocation? otherwise how much different could understanding the basics of C++ be?
Aren't C89 and C90 the same thing? Wikipedia says: &gt; The same standard as C89 was ratified by the International Organization for Standardization as ISO/IEC 9899:1990, with only formatting changes, which is sometimes referred to as C90. Therefore, the terms "C89" and "C90" refer to essentially the same language.
&gt; Modernizes C They modernized C in much the same way as training wheels modernize a bike for racing.
&gt; I find it useful, because the users will be ~~scientific~~ bad programmers, not checking the return code at any time, and just assuming everything always works. You probably know your intended audience better than I, but in C, not checking return codes at any time is simply bad programming. C doesn't really allow you a way to really protect against incorrect programming. (How will you handle if they pass you NULL or invalid pointers for things that were supposed to be valid?) It sounds like your design criteria are planning for failure rather than focusing on the success case.
How many security flaws were caused by out of bound memory access or other problems that are mostly fixed in other languages? 
It's pretty difficult to do that for a compiler as the `free()` matching a `malloc()` may occur anywhere, including in code the compiler hasn't seen.
Okay, if you're doing crypto code in pure python you will have an issue with speed. (~8 seconds to hash 1MB using sha256 instead of around 1/20th of a second). But safe code should be the default, with unsafe code only used in places where it's required for performance. To go on the knife analogy, it would be like if they were given a knife that *for the most part* acts exactly the same as a normal knife, and you can use the normal knife as long as you're very careful not to fuck up (But if you do fuck up it could silently poison the food and kill everyone who touches it).
I mean give it priority over C++ since C is more common for EE jobs. In fact, consider also taking a quick peek at Embedded C (an extension of C) if you really want to focus in MCU based applications.
The previous comments are correct. However, some of the tools listed [here](https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis#C.2C_C.2B.2B) **may** catch **some** of these issues. Clang is listed on there, maybe have a look at the documentation/options for [that](http://clang-analyzer.llvm.org/)?
Good input. I would say however that this... "(a) not the compiler's job" ...is irrelevant, though (b) is directly relevant. C compilers may not do it, but that doesn't make it "not their job". It is conceivably a failing of this particular language, something which, with redesign, could probably be corrected. Look at any managed language. That's _just one_ possible solution to the problem of freeing what you allocate. With Clang's libclang and libtooling capacity to operate on source at different levels, this is closer to reality today than it was 10 years ago... just because it cannot _always_ catch such things does not mean it shouldn't _usually try_ to do so.
Bounds checking is certainly a useful feature to have. 
Good point. I also always forget that Clang is doing all these great things. A compiler that can detect things like out-of-bounds array accesses before runtime would probably save me a lot of time. Could you maybe elaborate on managed languages though? Since I don't really know how garbage collection typically works under the hood (and by extension I'm not sure that you're referring to garbage collection), I get the impression that it's a runtime thing rather than a compile time thing.
Safer version of C? That usually means a slower version of C. And seeing people generally only use C when speed is really important, this seems a little counterintuitive, no?
You really think compilers haven't progressed for decades? /r/rust does this type of checks statically, and that part doesn't make it slower.
Sure - but wouldn't introducing bounds checking still add some overhead, which could be important in embedded/low memory systems? But yes, you are right
I get your point, but I think there is a bit of a logical flaw to that argument. The reason we have so many car crashes is largely because people are talking on their phone or texting and generally not being careful or giving their full time and attention to driving. It's not that driving is inherently super-hard. Taking Heartbleed as an example, the bug boiled down to taking an arbitrary amount of data *from the internet* and stuffing it into a fixed size buffer. It's not *hard* to check whether you're about to try to stuff 15 gallons of crap in a 5 gallon bucket. You just have to actually do so. Failure to validate input data from untrusted sources is a stunning display of carelessness. It's similar to how we get SQL injections. "This data came from the internet, it *must* be safe to give it straight to my database!". Similarly, we *keep* hearing about data breaches where password hashes were stored without being salted. There's nothing rocket science about salting your passwords. It's a basic, easy thing to do. People fail to do it nonetheless. If you are too lazy or incompetent to take basic steps, then you shouldn't be writing security sensitive software. Similarly, I don't think you should be driving if you can't be bothered to put the phone down and drive. It's not the car's fault that you rear-ended the guy in front of you.
&gt; What's wrong with many types? The more precise the types, the more the user is guided into the pit of success. I am selling the API as "Simple to use, only 6 main types". This might be wrong, but I'd like to minimize the number of different types to understand before using the library. I'll have a look at the blog post! &gt; I see. Your solution might be the easiest then. Though another possibility is to define a C struct stub that just has char[BIG_ENOUGH_SIZE] with a static-assert on the C++ side that the struct size is indeed large enough (or exactly sized). Then the user can place it on the stack. Actually, as the C++ class have members for which RAII is important (std::vector and std::unique_ptr mainly), I can not have them place in the stack from C, as C will never insert destructors for me.
Maybe. I'll look if I can remove the logging system by finding a better way to send warnings/messages to the users.
If you are building both on the target system, usage of a test stub could detect the size on the system. Not ideal though, if it's exposed as part of the ABI. That also means that size_t is a bad idea. If you want to know the exact size, you should definitely be explicit about it (e.g. uint32_t or uint64_t).
As FUZxxl implied, there will be cases where this interferes with desired operation, so we cannot make it an error. But I think it is fair to say that for 90+% of use cases, developers want to free what they allocate, symmetrically. Hence this would be ideally implemented as a warning - so you can ignore it if you don't care.
The best time to detect leaks is before you compile. Trace the life of your data through the program until it does. Write and organize your code to make it easier to trace. 
I certainly agree. I just wish they'd go use Java and quit blaming C for their incompetence. Edit: I didn't really capture what I meant with the initial reply. What I was trying to get at, was that I wish people would quit trying to turn C into Java because some people are bad programmers.
Not just difficult, it's equivalent to the halting problem even when the compiler can see everything.
This is a type of [static analysis](https://en.wikipedia.org/wiki/Static_program_analysis), meaning analysis done without running the code (as opposed to dynamic analysis where you do run the code, which is what Leak Sanitizer and Valgrind do). Since you're using Clang, it already has some static analyzers built in. http://clang-analyzer.llvm.org/available_checks.html It looks like the `unix.Malloc` checker is the one you want. Read the manual, and figure out how to run the static analyzer (because I don't know). But as others have pointed out, it will not find *all* errors in your code. It's mathematically provable that no computer algorithm can do that, even under perfect conditions. And conditions usually aren't perfect, because we tend to break our source code into lots of separate files, and today's compilers aren't able to look at all of them at once, so the compiler has fairly limited information.
Yes. Check the manual for your compiler. In GCC, you want `-D` which is a [preprocessor option](https://gcc.gnu.org/onlinedocs/gcc-6.1.0/gcc/Preprocessor-Options.html#Preprocessor-Options).
Adding to the answers given, there's a (quite old) blog post that brings a great explanation about character encoding and Unicode. I'm sure a lot can be added, but this is still a great read. I think you will find it interesting: http://www.joelonsoftware.com/articles/Unicode.html
Finally, a useful answer. Cheers. I know about static analysis, just didn't know that about clang, yet.
C itself knows nothing of OOP. You could torture yourself and pretend to have objects, inheritance and polymorphism etc.. by using structs and pointers... but then you'd lose all the C++ libs (unless you rewrote them for your little experiment) but at the end of the day you would have basically rewritten C++, without all the features. In a learning environment, sure... code away. It's doable as a thesis. Real life... not so much. 
Its a small nit to pick, but why use an OOP library when you can simply use C++ and get standardized, cross platform compatibility with C++? Like I said before... you could torture C into OOP, but it's a layer at best. C++ take all the C goodness and makes it good-er (hahaha) 
If you feel you gain from C++ compatibility. And a lot of core lib developers don't care about non-Linux. Look into the code bases before writing it all off as crazy.
Is that what that big ass update on visual studio was?
No idea.
 clang --analyze *.c Also check out valgrind for memory analysis.
* Start with some comments succinctly describing what the program is supposed to do. * Consider factoring out some of your logic (esp the final loop) into separate fns. E.g. a function that counts path components. Notice how in your loop you're testing !opt_n multiple times on _every_ iteration - code smell. * Better (more descriptive) variable names. E.g. opt_n is a flag, why isn't it a bool with a name like enumerate_paths. * I'm not generally a fan of multiple returns. I think you have way too many. * I'm not huge fan of testing for zero/non-zero like "if (!value_len)". I prefer to be more explicit "if (value_len == 0)". I generally only do "if (foo)" if foo is a bool. Yeah, I know it's a C idiom to leave off the == 0 (or == NULL), but I still think it's clearer to include it. This is probably a holdover from my days of using Pascal. 
This is *quite* good code for someone just learning C. Pat yourself on the back. A few minor notes: * "value" is a horrible variable name. It's kinda like "variable". It doesn't import much, if any information to the reader. * The switch statement processing the getopt values silently returns EXIT_FAILURE without any emitted error message to the console. I would recommend something more along the lines of "Invalid option *opt* encountered", followed by printing the usage (your print_help()) routine. * You are using the trigraph operator (?:) to guard against the possibility of prgname, derived from argv[0], being NULL. According to the standard, if the name is not available, argv[0][0] must be '\0'. (NULL). This is not the same as argv[0] being NULL. Even when the name is unavailable, the standard requires argv[0][0]=='\0', which means a non-NULL argv[0] is required so that it can be dereferenced safely. * Personally, I subscribe to the "use braces ({}) even when optional" school of thought when it comes to if statements. It's just super-easy to forget to add the braces when you edit a second statement under an if guard. That said, this is a debated matter of style, so decide what you want, and just be consistent. * You could consider factoring out the common subexpressions in the if statements in the for loop, i.e. testing "!n" and having an inner if that tests the other two conditions to avoid duplicative tests, but the way it's currently written isn't really a big deal, IMO. Edit: Two addition nits: * strlen() is declared in &lt;string.h&gt;: you need to include that, but you currently aren't. * print_help() has no reason to have external linkage visibility. It could, and should, be declared static. 
I'm sure you read the article, so you saw this part already: &gt; It goes without saying that Microsoft would likely add such support to Visual Studio if the demand manifested.
&gt;1. The usage ptr makes no sense, you cannot have an implicit array of pointers i.e `char *usage = "a" "b" "c"`. Adjacent string literals are concatenated. Your example is equivalent to "abc". 
Oh well that's new to me, apparently due to the 80 char punch card limit back in the early 70's, I would probably nak something like that today though.
It's very handy for things like nicely formatting long strings, including macro arguments in strings, and the printf format macros in inttypes.h
Hello, I'd suggest you have a look at https://github.com/git/git, although its a pretty big project. The code is quite solid and implementation of Makefile and tests too. I also suggest having a look at http://c.learncodethehardway.org/book/ which would be a good reference. 
great read indeed, thanks! Back when I was a little IE6-using kid I remember myself trying to figure out why the hell some emails were in Klingon or whatever, where some others were totally fine.. Now we've become the ones who have to fix it. Scary how time flies. 
&gt; Better (more descriptive) variable names. E.g. opt_n is a flag, why isn't it a bool with a name like enumerate_paths. I thought `opt_n` was clear enough because you can just read the help string in `print_help()`. But you are right, I have renamed it to `enumpaths`. &gt; I'm not generally a fan of multiple returns. I think you have way too many. Originally I had something like this at the end of the `main` function: EXIT: return status; PRINT_HELP_AND_EXIT: print_help(prgname); return status; When I wanted to terminate the program, I would set `status` to `EXIT_SUCCESS`/`EXIT_FAILURE` and use `goto EXIT;`/`goto PRINT_HELP_AND_EXIT;`. Would you prefer this approach? Thanks for your help.
If you just wanted to do this for testing purposes then you could write a wrapper for `malloc()` and `free()`. You could have the wrapper write the pointer and number of bytes from `malloc()` to a file and then have `free()` write then pointer to the same file. Then just search the file for leaks.
Except if you want to do non-trivial things that is.
Just confirmed, you are correct. Been a while since I last used getopt() or read the man page for it. Reading the man page, it doesn't appear that the format of the error is specified. It certainly won't include an explanation of available options, as the original call to getopt() doesn't provide the meaning or a usage string, just the options themselves. For my own style, I would supplement the getopt() output with a call to print_help() prior to exit in the default branch of that switch, but it's not truly needed.
Just wondering, what do you usually use for parsing command line arguments? `getopt()` is nice but way too simple. I'm only using it because it is bundled with MinGW-w64 and I don't want to deal with dependencies on Windows.
Honestly, I don't write a lot of userland code intended for direct use by other people, at least recently. I have used getopt() in the past, but you may wish to check out popt(). It includes a lot of functionality (like the ability to support config files for defaults with command-line overrides) that I ended up hand-rolling in the past.
Very nice examples, thank you very much.
E.g. implementing any data structure involving pointers.
I'm talking about a new systems/embedded programming language called [Rust](https://www.rust-lang.org/), which doesn't sacrifice speed for safety, but has both. The idea that you *have* to be insecure in order to be fast is passe. Just because C has horrible holes, doesn't mean all fast low-level languages have to have them. While 'data structures involving pointers' is meaningless in the context of Rust, as Rust has many types of "pointers", I assure you it is not limited and you can do 'non-trivial' things with it. That's because our methods of static analysis (compilers) have vastly improved. C is old tech.
Here is how most pointer tutorials start out: int a = 1; int *p = &amp;a; // p points to a *p = 2; // a is now 2 Okay, but what's the point of doing that? Why don't we just assign to `a`? In my experience, starting with a problem that can be nicely solved by pointers is far more effective then starting with some pointless toy code. It turns out there are many distinct use cases for pointers. In this video, I show how pointers can be used to simulate call by reference. Wanna try skorbut yourself? https://github.com/fredoverflow/skorbut-release 
Well they are also used with function pointers to implement polymorphism and inheritance. Another use is to pass around large data structures around functions. They are also used to access hardware registers. 
I love this. 
The title suggests that this is part 1 of a series, so the things you mention may very well get covered!
I already use Linux (Arch) I need one for supporting for windows use
Yikes! IMO, gotos are worse than early returns. In my 35 years of programming, I have never needed a single goto. Study [structured programming](https://en.wikipedia.org/wiki/Structured_programming). Please get rid of those goto statements or at the very least put back your early returns. I forgot about that declarator limitation of C89/C90, and I wrote the front end of a C90 C compiler for Samsung in the mid-'90s for one of their (9-bit!) gaming chips. I should have known better but haven't been limited to a C89 compiler since... well, at least C99. Sorry. Put 'em where you gotta put 'em.
As far as I know, you can't link statically with msvcrt.dll using mingw. Your only chance of using the c standard library without the dll clinging on to your program, is to use the cl.exe compiler of microsoft with the /MT switch. You can also use that switch through Visual Studio. If you want to avoid having your program depend on msvcrt whatsoever, then don't use C standard library functions at all. [WinAPI offers a few alternatives to some functions on the C standard lib](https://support.microsoft.com/en-us/kb/99456) but again they are quite few. I've programmed on windows a lot and I even tried writing WinAPI programs that didn't depend at all on the c standard library, so I could give you some pointers: Firstly, don't use the beginthread/beginthreadex API because it calls on the msvcrt before calling WinAPI functions. Instead use CreateThread directly and don't forget to cleanup. Secondly, [it would help to write wrappers for the HeapAlloc API so that you don't get confused in having to type huge function calls every time you want to make a heap allocation that doesn't call msvcrt](https://github.com/Gikoskos/SleepingBarberWin32/blob/master/common.h#L41). At least that's what I did :P . If you want portability you can do stuff like: #ifdef _WIN32 # define malloc(x) HeapAlloc(GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, x) #else # include &lt;stdlib.h&gt; #endif I didn't do that in my github code above because that program wasn't supposed to be portable in the first place. I only used macros so that I wouldn't have to type long-ass function names every time I wanted to malloc or free. Thirdly, [use the strsafe.h API to do your string handling](https://msdn.microsoft.com/en-us/library/windows/desktop/ms647466(v=vs.85\).aspx). Don't include tchar.h or use TEXT()/T()/_T() macros! By default, tchar.h includes string.h/wchar.h automatically and you might forget and end up using a standard library string function by mistake. If you're on mingw include strsafe like this to avoid inline warnings: #undef __CRT__NO_INLINE #include &lt;strsafe.h&gt; For other functions (such as math.h functions) you could either use a third-party specialized library that focuses on that specific API (like math function libraries) or write your own (not recommended). Lastly, everything here obviously breaks portability and it's only if you plan on coding for pure WinAPI. There's really no avoiding in using msvcrt.dll if you want to call standard library functions. Obviously there are other implementations of libc for Windows out there, but most of them are incomplete and personally I wouldn't trust them. If your program doesn't depend on the most complicated libc APIs you can get away by using just WinAPI calls or writing your own functions that mostly do the same thing.
Heh, tough and kind of silly task. This probably won't help you, but you don't *need* a queue or anything. A bunch of forks calling accept() works just fine: https://github.com/teran-mckinney/pzqhttpd/blob/master/pzqhttpd.c
A bunch on forks seems like a great way to get an automatic zero, no questions asked. Multithreading is mentioned pretty explicitly.
Your post got caught in our spam filter. I apologize for the inconvenience. ... auf der Autobahn...
You cannot dereference a `void*`, so `*scancode` is not going to work.
Did you even watch the video?
Nope. I already know what pointers are for.
Thanks for sharing this information. Much appreciated 
I works although cmake is giving problems. P.S. I actually read your blog time to time. This idea came from the freedstanding article
1. Format your code properly. 2. Why can't you debug it or tell us the error?
Better yet, write a C program to just spit out the formatted text. The file is the argument, and all it does is spit out each line with 4 spaces prepended to it.
Definitely not worth the development time. For a standard web app most of the response time will be from the database call(s). There's a reason nobody makes web apps in C, even companies where hundreds of thousands of dollars (possibly millions) could be saved if they rewrote all of their business logic in C. If you really want something faster, try java or clojure or if you have a bunch of concurrent connections try node or elixir/erlang. As Donald Knuth (possibly the greatest programmer of all time) said, "Premature optimization is the root of all evil"...
For the linker error, it looks like you're trying to compile each source file into a separate executable, so the linker is (rightfully) complaining about a missing `main()` in `basiclist.c`. IIRC, in Java you have the freedom to specify the entry point to your program, but in C it's always `main()`. Additionally, &gt;int main () { &gt; return 0; &gt;} isn't going to do anything. Remember to fill that back in if you were just stubbing it out while troubleshooting.
No. Only one file should have a `main` function. Though, you need to link all object files together when making a binary. For example, to make a binary `foo` out of `foo.c`, `bar.c`, and `baz.c`, type cc -c foo.c cc -c bar.c cc -c baz.c cc -o foo foo.o bar.o baz.o or alternatively cc -o foo foo.c bar.c baz.c The invocation might be slightly different on your system.
Usually if you'd benefit from doing it in C, it's because there's some algorithm in the request that's eating up a lot of cycles and typically these get written as extensions to the dynamic language (e.g., many of PHP's extensions). That's not a bad route to go in if you're really trying to speed up a web app. For your case just parsing the request, this isn't something you'll need to do. That said, we typically learn how to do something hard by first doing something easy but unnecessary. I first wrote unnecessary extensions for web apps before later writing necessary fcgi servers in C++.
A gui text editor? UI wise, it is fairly simple if you start with just text editing (no debugger, etc), and can give you a lot of experience with a rope data structure which can be implemented with balanced trees. You can also equipt it with a general zipper for some really good efficiency across most operations. 
You can always read the string one character at a time using getchar() and allocate memory accordingly. Just keep in mind that you need to allocate one more byte for the nul terminator of the string
Well the best intermediate project is usual complicated. I suggest duplicating existing simpile software. I wrote for example cat. Another is a freestanding program or experiment with low level stuff
 char *s = "some string"; Makes `s` point to some place in read only memory. If you try and change it: `*s = '4';` then you will get an error. If you need to change it then use `char *s = strdup("some string");` which allocates the memory in the heap (it just calls malloc). Then you can change parts of the string as you wish.
Check out /r/dailyprogrammer/
Don't take this the wrong way, but with all the websites out there that serve up millions and millions of hits daily with php and python, it's rather egotistical of you to think your needs are greater than theirs. It's more likely that you need to research a robust back end web architecture, rather than the language execution speed. These days, high load websites are not served up by a single server. There are layers of services and hardware involved.
That's a hell of a project for an OS class. The thread scheduling stuff makes sense. The networking stuff kind of makes sense, too. But some of the requirements seem rather pointless; what's the value in adding them? Generating directory listings? Handling user home directories with `~`? This is a big project they've created. Anyway, it sounds like you're not expected to know all of this right away. It says in the assignment, "We will learn some techniques such as semaphores to achieve this in the synchronization lecture." Generally speaking, you need to be asking your professor and TAs for help with this, not us. It seems like the parts you're struggling with are exactly the things this assignment is designed to test you on, which is the stuff you should be learning in class. If you don't feel you have the knowledge to complete this project, that may be their fault for not teaching it well enough. Or maybe they just haven't gotten to that material yet. In any case, ask them for help first. &gt; But how exactly do I implement a queue to accept http requests? Read the man page for the `listen()` socket command. Either that, or you're confused about how the information gets to the worker threads, which is part of the whole multithreading and synchronization thing. In that case, bug your professor and TAs about this, because that's exactly what they're supposed to be teaching you.
Thanks! That makes it very clear :)
Could help me out at github.com/php-ds
This is about the response I expected, so no worries. I guess my question stemmed more from curiosity than anything else; I've seen lots of posts around the internet claiming C simply isn't safe enough for web app development, but they don't really say why. Still, it's good to know that the benefits aren't worth the sacrifice, so thank you for the input!
??? I don't see your problem. Please tell us the debug error.
Have you had a look at http://kore.io I myself am eyeing to check out whats out there to do some experiments with C on web.
Not sure how to fix this specific problem, but I don't use the MSYS terminal at all. I would add the directories with the binaries for MSYS and MinGW into your Path environment variable and then you can use the compiler and those sweet Linux commands in the Command Prompt. This has the added benefit of allowing you to develop outside of those MSYS directories.
...and it's down *for HTTPS* **EDIT:** Ignore me, had HTTPS Everywhere turned on
Don't bother with C unless it becomes an issue. At work, I write a server in Lua (it parses SIP messages, calls a backend system for the business logic) and so far, it's not been an issue. When it does become an issue, I have a working example to base the C code on (that is, after I have exhausted optimizations I can make in the Lua code and there are some I haven't bothered with yet).
That we did [think of](https://github.com/riolet/longs/blob/master/longs.c#L109): //To prevent bobbytabling, we encode the URL char * b64URL = b64encode(longUrl); 
What happens if you spam CTRL Z etc.? I get a similar issue from time to time, when it just sits there, nothing happens. If I hit it with a couple of CTRL Z it "wakes up" again.
Thank you for your kind feedback /u/Name0fTheUser We have fixed the issues you mentioned by introducing basic URL validation.
You have a good memory :)
Consider looking through the archives of this subreddit. This question is asked very often. We have a selection of the most common books on the sidebar.
But wouldn't it at least run the code that is written before these statements?
There is no way to say anything one way or the other without a complete testcase. 
So your post is a little confusing for me, so bear with me if I describe things you are already doing. You are correct that if LAPACK is involved, you must use a 1D array to represent the matrix. Similarly, it is best to do row by row access with B[j*n+i]. This is still true for a block matrix. To generate your full matrix and populate it with a t x t block starting at an index pair (p,q), try something like this: double *A = malloc(sizeof(double)*n*n); // check for malloc error double *block = malloc(sizeof(double)*t*t); //check for error again. Also, this only needs to be allocated once and reused if t is the same in the future for(int i=0; i&lt;t; ++i){ for(int j=0; j&lt;t; ++j){ A[(p+i)*n +(q+j)] = block[i*n +j]; } } So what happens here is that given some starting position for the block we can insert the proper block matrix values into the correct position in A. Again this may not be what you were looking for, I was a little confused about your post. Let me know it this makes sense / was on the mark. Another place to look is a book called numerical recipes, it has all of these algorithms and methods in there (full source) optimized like crazy. 
This looks exactly like what I want, thank you! I agree, thinking about it now the last malloc didn't make too much sense. The reason why I wasn't going to paste together the B matrices (nut to butt, as I wanted to put it, but withheld myself while meeting with my adviser) was because of this matrix structure |B0 B1 B2| |B1 B0 B1| = A |B2 B0 B1| and now that you mention it I'm not sure why we can't just make A as we made these B's! Then we would just call the block matrices similar to calling the block matrix cells, that is A[k*(i+nj)] for the ij-th member of the kth block matrix. I will have to consider doing this instead.
I think I can answer the first question a bit. I've read from somewhere in the past, saying &gt; unsigned int never overflows I will google a bit for it.
That's for convenience so you can use the result as an argument to another function without having to write another statement. Not that doing so is considered good style.
Ah, that makes sense, thank you.
You are right. I found " C - A Reference Manual" has one line about it. &gt;All arithmetic operations on unsigned integer behave according to rules of modular arithmetic modulo 2^n. Thanks for your answer. edit: I do feel strange that these two are treated differently: signed int a = 0xffffffff; a &gt;&gt; 1; and 0xffffffff &gt;&gt; 1
Early versions of C didn't even have `void`, which lends weight to your theory. 
I actually think that the right return value for `strcpy` would be the *number of characters copied*. That way, when appending multiple parts, one is not required to use `strcat` which runs over the string again in search for the null byte.
There's nothing available to help you. You might wanna check your post 
By four versions of array implementation, do you mean display, delete, push and exit? 
I'm sorry if it took a while. I had to upload a couple of photos. No, the different ways of initializing the structure. I was only able to take photos the [first 3 versions](http://imgur.com/a/UxvrI). The 4th one seemed like a combination of 2 and 3.
Idk if I'm wording it correctly. But I don't really get the concept of List ADT through arrays (which is my topic as of now, gonna go to linked list ADT and then cursor based (or was it cursor implementation?). I just want a guide or something regarding ADT in C since I currently do not know OOP (and most, if not all, of the guides in the internet are for OOP). I was hoping that I could get some materials that I could use because I can't find any.
If you mean: printf("%c is %i. \n", encryptedtext[i], encryptedtext[i]); I'm trying to compare the letter and number values of encryptedtext[i] right now, eg, "A is 65". Not trying to compare plaintext vs encryptedtext. If that's your doubt, I should probably have clarified in my question.
Unfortunately that's what my professor requires me to do. :(
since you're using std::string do you need to write plaintext[i].c_str() like you would have needed to if you wanted the whole string printed? (needed or should I'm not sure I don't use String.)
isn't that what you are using when you are defining string variables? I can't say for sure but the pure C way of doing strings would be char *MyWords = "My Words"; int CharCount = 8; // alternativly null terminate the string and you don't need the count for printing. printf("These are my words : %s", 8, MyWords); prints: "These are my words : My Words". 
Well if you can compile it to C then that makes it work on different machines, whereas compiling to assembler might require lots of additional work to port it to a different system. But if you don't care about compatibility then perhaps compiling it to assembly is simpler.
if it just compiles to C, then you're better off just writing it as a C library.
found it and you are correct, that is seriously dumb for a teaching/learning library. 
Perhaps, but I suppose that it keeps the hassle of explaining pointers a little further away, which I can forgive as CS50 is primarily an introduction to computer science not to C programming. But yes, it does cause some confusion
The %d (or &amp;i) part is fine, I'm trying to get the %c one to show up. But I think it's got to do with the ASCII values. Also, haven´t gotten to casting that much yet so I rather avoid it for now but thanks though. 
Hmm, since I don't think the course expects us to use that at this stage, I'll pass for now but thanks, I'm picking up some stuff in this thread anyway.
Oh, I see. Well, yes it must be to do with the ASCII values. When you do `plaintext[i] + key[i]` the value must be going over the ASCII max value. To keep all the values down you'll need to use something like the mod (`%`) operator. I suppose that when you add them and they overflow, the new value is something which you can't see like 0-31.
high level is just marketing jargon, when C came out it was considered "High level" now people use it as the definition of a low level language. its 100% bs. also if its just compiling to C you need to ask your self, does it offer any features (or performance) that other languages do not. At which point I will point to C++, Go and Java and say absolutely not.
Interesting, we haven't gotten to that 8 in the prinft. As far as I knew, the %s would look after the comma, see an int while expecting a string, and it wouldn't compile or whatever. And I don't really know pointers but, on the subject, would you say *MyWords is like cell B2 in Excel for example while "My Words" would be the current cell content? Or is that not what pointers are at all?
You might need to write it like this. its not a set number 8 I just manually counted the string/char * I made in the code. printf(" something : %*.s \n", strlen(MyWords), MyWords); // ironcally I'm pretty sure if strlen can find the length you don't need to give the length manually to printf :) // I just used it here to make it more clear that the number was the string length. - here the * indicates the length to be printed from the MyWords variable. (since a string can be whatever length) - the s is for string, (like c would be for Char, a single character) if you do this with a number it will bad it out in length. but yeah this is for a string/char *(multiple characters.), if you don't give it a length when printing the string needs to end with '\0' so printf knows when its done. PPS: if you saw the other comment regarding string vs char *, that means you where not using the std::string variable and you shouldn't really... you can but the cool old guys don't :D a "char *" value means a character Pointer/address, since this value is only an address to the first letter in your string you need the tricks I mentioned like '\0' null termination or giving printf the number of letters to print. EDIT / Disclaimer : Don't think to hard about what I wrote here, I might have slipped up an given some confusing or misleading info, I just wrote it as a curiosity in case it made something clearer for you.
Thanks but that doesn't work for me for some reason. It will show ^Z every time it gets pressed but the problem persists. 
well I have to disagree, since the 100 lines of code to 5-10 is really just about libraries. as for OOP, theirs allot of things wrong with it, and I tend to avoid it as much as possible. the beauty of C is that its essentially portable assembly, which makes it very fast and a good choice. if you're going for ease of coding I would do python since its very quick and easy to write, otherwise I stick to C 
This is a little problematic unless you do the following: * open the file in append mode * before the `fork()`, do an `fflush()` on the file. * find an upper limit for how long the log messages could be * set the buffer size of the file to something below that limit * either set the stream to line-buffered or do an `fflush()` after every log entry. If you take care of these things, what you want to do should work. The buffer size change is necessary to make sure that each log entry is written in one go instead of possibly being split up. The append mode is needed so the file pointer is automatically adjusted before writing.
you magnificent bastard. I shall read these.