&gt; I have the vision, but I need the talent That's the opening line of every Internet startup horror story ever.
&gt; lines. If you open a file as text, the C standard library translates the host's convention of representing lines of text into lines separated by \n for you and back. AFAIK, that's essentially only true on Windows?
No, *nix systems generally use line feed (LF, or `\n`). MacOS &lt;9 used carriage return (CR, or `\r`).
It's true on many operating systems that are not UNIX variants.
Oh shit, TIL
Yeah, that's true. However, since the vast majority of people are using either Windows or a UNIX variant, calling it "essentially only true on Windows" isn't directly wrong, just a bit simplistic maybe.
My code doesn't require the length to be known.
This is something you'll run into in real life. It's a good exercise. Not going to write the code for you, but here's a way to think about it: you're printing stars and newlines. Once you've printed a row's worth of stars, it's time to print a newline and reset your row counter. Cheers!
Yes, it does. That's what `strlen()` does. The OP isn't very coherent but basically, they are being fed the string one byte (or a few bytes) at a time.
&gt; You may not write NUL bytes into text files. Um. Really?
Ohhh ok. Yes, his post was pretty tough to decipher lol.
&gt; You may not write NUL bytes into text files. ? int main(int argc, char* argv[]) { FILE* f; const char n[] = {'\0', '\0', '\0'}; if ((f = fopen("temp", "w"))) { fwrite(n, sizeof(char), sizeof(n), f); return 0; } return 1; } That inserts 3 NULs into "temp".
Spin locks: http://man7.org/linux/man-pages/man3/pthread_spin_init.3.html and http://man7.org/linux/man-pages/man3/pthread_spin_lock.3.html Sleep locks? Regular `pthread_mutex_FOO()` functions?
I don't know how I missed that! I've been through the pthread man's all day! A "sleep" lock is a system call; one where you know you'll be waiting awhile, so surrender the rest of the threads time slice and give it up to another thread in the system. Imagine you are locking a resource you are pretty sure is 24 hours away, you don't want to spin that long, you want to sleep for it.
Under Unix (including MacOS and Linux), there's no difference. That's because Unix uses linefeed to separate lines in a text file, and so programs written in C (which was developed along with Unix) use a single linefeed to indicate the end of a line. Under Windows, lines are separated by carriage-return-linefeed (CRLF). Rather than force all C programs to behave differently depending on the operating system they're running under, the convention was created that a single linefeed separates lines, and the stdio library is responsible for converting that to/from CRLF as needed. Unfortunately, this will break binary file I/O. To work around that problem, the "wb" and "rb" conventions were invented. These tell stdio not to alter line endings. tl;dr: files opened with "w" or "r" are text files, and line endings are modified as appropriate for the operating systems. Files opened with "wb" or "rb" are binary files, and data is always transmitted exactly.
Why not in C?
Text files may also perform other translations, e.g. trim trailing whitespace on a line, and disallowing non-printing characters.
Here's a paper that you'll probably find very interesting: *A fork() in the road* https://www.microsoft.com/en-us/research/uploads/prod/2019/04/fork-hotos19.pdf &gt; ABSTRACT &gt; The received wisdom suggests that Unix’s unusual combination of fork() and exec() for process creation was an inspired design. In this paper, we argue that fork was a clever hack for machines and programs of the 1970s that has long outlived its usefulness and is now a liability. We catalog the ways in which fork is a terrible abstraction for the modern programmer to use, describe how it compromises OS implementations, and propose alternatives. &gt; As the designers and implementers of operating systems, we should acknowledge that fork’s continued existence as a first-class OS primitive holds back systems research, and deprecate it. As educators, we should teach fork as a historical artifact, and not the first process creation mechanism students encounter
There's a few methods of doing this. If the amount of input strings is not large or you don't need your program to be super optimized (for example - input is taken from a human), a combination of `getline()`, `realloc()` and `strcat()` (`memcpy()` would be faster, but you have to keep track of the offset) should be enough. Another way is to collect input strings in a linked list, recording the total length somewhere on the side, then use it to allocate one large block of memory and copy strings from list into it. If a single c-string is not required (for example you are handling the input data yourself and do not pass it to a function expecting one string), allocating and copying is not needed - just create lookup and slicing functions that know how to move around your linked list. I think Glib had something for dynamic strings. If not, I am sure you can find plenty of libraries to use. It's less fun, but why reinvent the wheel?
Here's my solution. Hope it helps. https://pastebin.com/zUQtBqPj
Text mode replaces lf with crlf, on systems that use crlf for newlines.
I deleted my answer; this one is better.
Questionable design goals aside, C is not the language you're looking for since you don't need instruction cycle efficiency etc. here. I would use Python if you want it to be a desktop application, or HTML5/JavaScript if you want it to be a mobile application. Here's a potential algorithim for your project: Start program Program modes: Settings, topic selection If Settings is selected: //Settings is for setting timers and topics Set timer profiles (a profile has "day type" and "duration" attribute) Topics and Topic webpages (the webpages that represent your topics of study, ex. www.sillycadtutorial.com/2d-drafting/1 [or if all your webpages are local, ~/directory/sillypage.html]) Select timer Select topic (selecting a topic will either open the webpage or display options for webpages to choose from) Timer will play once webpage is loaded. If pause is pressed: stop timer until resume is pressed. If a new topic or webpage is being selected: stop timer until the next webpage is loaded. If timer duration runs out: ????? (kill program? lock program? etc) End program. Mixing webpages and MS word documents is a design flaw unless you want a suite in which the user can place a combination of webpages and documents (.docs, .txts, .pdfs etc.) in a directory (folder) representing a "topic", and when selecting a topic all these options are abstracted into items of this "topic". I recommend you properly design your algorithim/design goals and then start programming. I think there is a common misconception that learning programming magically imparts design skills. This is not true; design skills facilitate natural progress in learning programming. This is because programming is ultimately an art/science of instructing computer systems to perform tasks. If you are unsure of what to "say", you'll never be able to "tell" what to do. Figure out your design specs first. Then the rest will come easy. Also: NEVER say something among the lines of &gt;&gt;I have the vision, but I need the talent. I want no part....This is strictly for me. So many ettiquite rules broken here. First of all, programmers disdain "ideas guy" type of people greatly. Then as if that wasn't bad enough, you come off passive-aggresive with vague and haughty statements like "I want no part in what happens afterwards" and "This is strictly for me". Good luck on your project, cheers.
First off, there aren't strings, there're preprocessor tokens, but more to the point, the preprocessor does to arithmetic evaluation.
I found this program to read dynamic string but it gives SIGTSTP error. Any ideas how to fix this?
The standard defines text files as lines of text. All control characters (except newline) have implementation-defined behaviour
&gt; You can use ftello and fseeko to navigate through them. These aren't in the C standard lib, unlike fgetpos amd fsetpos.
*shouldn't*, as it's implementation defined behaviour what they do with control characters when reading them in and out. From the c spec: 5.2.2 .3 : &gt;Each of these escape sequences shall produce a unique implementation-defined value which can be stored in a single char object. The external representations in a text file need not be identical to the internal representations, and are outside the scope of this International Standard. Forward references: the isprint function (7.4.1.8), the fputc function (7.21.7.3). 7.21.2 Streams &gt; 1. Input and output, whether to or from physical devices such as terminals and tape drives, or whether to or from files supported on structured storage devices, are mapped into logical data streams, whose properties are more uniform than their various inputs and outputs. Two forms of mapping are supported, for text streams and for binary streams. ^270 &gt; 2. A text stream is an ordered sequence of characters composed into lines, each line consisting of zero or more characters plus a terminating new-line character. Whether the last line requires a terminating new-line character is implementation-defined. Characters may have to be added, altered, or deleted on input and output to conform to differing conventions for representing text in the host environment. Thus, there need not be a one-to-one correspondence between the characters in a stream and those in the external representation. Data read in from a ext stream will necessarily compare equal to the data that were earlier written out to that stream only if: the data consist only of printing characters and the control characters horizontal tab and new-line; no new-line character is immediately preceded by space characters; and the last character is a new-line character. Whether space characters that are written out immediately before a new-line character appear when read in is implementation-defined. &gt; 3. A binary stream is an ordered sequence of characters that can transparently record internal data. Data read in from a binary stream shall compare equal to the data that were earlier written out to that stream, under the same implementation. Such a stream may, however, have an implementation-defined number of null characters appended to the end of the stream. &gt; ^270 An implementation need not distinguish between text streams and binary streams. In such an implementation, there need be no new-line characters in a text stream nor any limit to the length of a line.
Wait ... is this an online interview and you're asking Reddit to help you out?
&gt; No, *nix systems generally use line feed (LF, or \n). Please don't use `\n` in that way. `\n` is always a "new line" character. It may or may not have the value of an ASCII line feed, and it certainly does not _mean_ line feed.
Here's the code I have come up with: [https://github.com/abcool/C\_training/blob/master/amazon19-5-19](https://github.com/abcool/C_training/blob/master/amazon19-5-19) Any Ideas on the line with comment problem.
I know you’ve already got an answer, but the way I remember it .. unix used one, Mac used the other. And windows used both. (This is largely historical, Mac is unix now)
I see. Reading the standard, I see that `\n` is defined as "(new line) Moves the active position to the initial position of the next line", so it would just happen to be LF on systems where LF moves the cursor to the start of the next line. I had assumed `\n` just generally meant the line feed characters on C implementations which use ASCII (or something ASCII-compatible). Thanks for the correction :)
I'd be the first to admit that it's nitpicking... but given this whole discussion was about how `\n` _isn't_ just a LF on some systems in certain configurations, I thought it a good idea to mention. What's confusing is that there are many languages where `\n` _is_ defined as "line feed" or "the character with value 10".
Control sequences other than NUL can also surprise, like \^Z.
Ah. TY!
Just use normal POSIX locks (`pthread_mutex_t`). They automatically do the right thing and are tuned for the platform your code runs on. While there are spin locks in POSIX, their use is generally not a good idea as they tend to waste a lot of CPU time unless you know exactly what you are doing.
&gt; most linked list implementations out in the wild are notoriously memory unsafe. The thing to misunderstand here is that nobody really uses macro libraries for linked lists. The common approach is to just stick a `next` pointer somewhere in your structure and write out the code for list operations when you need them.
I've been working on OpenVMS and Z/OS a bit lately. If you have a bank account, your money went through a machine that runs Z/OS. Just because it's not an end-user operating system doesn't mean it's not everywhere. Also, DOS is still quite popular, especially in the educative sector (mostly in India and Pakistan apparently).
And RISC OS uses both, but the other way round!
Sorry, forgot my habit of supporting large files.
I strongly prefer it. It helps me reason about code and occasionally keeps me from doing something stupid.
It's generally a good idea to mark as const what is supposed to be const.
`const` rarely (but sometimes!) helps in catching stupid mistakes like trying to write to the wrong variable, but it often helps with readability, despite the supposed visual clutter. By declaring a variable `const`, you are telling readers of the code (usually a future version of yourself) that this is just a name for some value. Everything non-const is state that the reader will have to keep track of, as it might change during the course of the current scope.
Have read through the replies, thanks a lot guys, will use const from now on.
MISRA C has a rule on pointers and reference should be const if not modified.
Hah, now that I didn’t know. Almost starts to feel like they’re taking the mick.
Pointer to const function arguments are good for communicating an API's behavior. It's a promise that a function will not modify that object. It may also help catch mistakes at compile time. However, understand that this use of const will never help in optimization. Use const for constant, global variables, particularly lookup tables. In practice this has a minor effect on optimization and allows the linker to do a slightly better job laying out the binary image. Generally don't bother using const on local variables. It's visual noise with little benefit. Outside of contrived examples, it never aids optimization, and realistically it doesn't catch any actual, common mistakes. It's also not idiomatic for C: You won't find much C code in practice that uses const on local variables.
Just for anyone wondering, it's a really poorly executed 20-question multiple choice test.
Your "make" executable is not in PATH. Or maybe it has a different name...?
Hmm, typing that says that the path doesn't exist. Should I do a fresh reinstall of codeblocks?
Anything that's read only should be const.
It would be better to uninstall codeblocks and install an IDE that is not a steaming turd
Do not spam.
Any recommendations?
Since it's not specifically called out, I'll point out that passing values as const doesn't convey any meaning to an API consumer (a copy of your data might not be modified). Doing so will hurt newer developers understanding of which consts are important, and in my opinion brings no benefit. Const pass by reference is clearly useful, in that it conveys a function should not modify some data. I think it's very important to get the constness right for static lifetime objects. For local variables, when combined with good naming, could improve the clarity of the code, but it's definitely the most inconsistently enforced.
As others have mentioned, `const` is really helpful in avoiding errors. I'd also like to say that, as an embedded developer working with tiny systems, I believe `const` is really important to avoid extraneous RAM usage. On microcontroller where the program is executed directly from flash, data marked as `const` can also be located in flash. Otherwise, it consumes precious RAM. If an API doesn't properly use `const`, then I either need to dangerously cast away my const data's `const` when calling into the API or first copy it to RAM. For example, let's say I have a data packet that I need to send using a provided API call. The packet can be pre-built because it's always the same, so I declare it like so: `uint8_t const hello_packet[] = {0x55, 0xAA, 'H', 'E', 'L', 'L', 'O', 0x65, 0xE1};` Let's say the API is declared thusly: `send_data(uint8_t *data, size_t data_len);` Assume that `send_data()` doesn't actually modify `data`, but the developer didn't bother to mark it as `const`. Unfortunately, I now have to do one of the following: * remove `const` from `hello_packet`, which means that it will consume 9 bytes of RAM (which might not sound like a lot, but consider that this code might be running on an MSP430 with 256 *bytes* of RAM) * cast away const when calling the API: `send_data((uint8_t *)hello_data, sizeof(hello_data));` This means that I first need to carefully review the implementation of `send_data()` to ensure it doesn't attempt to write to `hello_data`, which would cause a crash. I also need to remember to review any future changes to the API implementation. * temporarily copy `hello_packet` to RAM before calling `send_data()`. While this is possibly better than having `send_data` itself in RAM for the entire lifetime of my program, it's still an extra step and--in extreme cases, or for larger packets--I might not have enough RAM to even do this temporarily. If the API had been the const-correct `send_data(uint8_t const *data, size_t data_len);`, I could have simply called `send_data(hello_data, sizeof(hello_data));` without a dangerous cast or RAM overhead. Please, please, please make your APIs const-correct for us embedded people.
If you're working in embedded, it's essential. Things like precomputed lookup tables you typically don't want to put into RAM, except when it's absolutely critical for speed.
const in C means the object is read-only. Yes, this is incredibly useful. &amp;#x200B; In C++, I suggest you read the C++FAQ on const correctness.
Ah okay. Thanks for the advice Will be saving your reply for future reference.
Check out the Fisher-Yates shuffle for a method to do this.
You have 10 digits you need to generate but only 9 are possible for any given digit. What I would do, then, is store the last digit and picked, and then generate a new number as rand()%9. Then, if this new number is greater than or equal to the last digit, increment it by 1. This will ensure that every digit not picked last has an equal chance of being picked next.
This is not random though? It would lean on higher numbers due to the +1. Efficiency aside, you could store old numbers and check
It would be random because you are choosing between the 9 possible next digits with an equal probability. (rand()%9)
Unless OP means it can't repeat with any of the last digits and he wants to simply randomly permute the digits
Another way you could do it is by adding ***srand(time(NULL));*** before your second for. This way, the generated numbers will be completely random (will use your clock to decide the generated number). Dont forget to add the library: ***#include &lt;time.h&gt;*** on the top of your code (must add for this to work).
Thanks for the tip but I have already done this in an earlier part of the program.
You don't need random numbers - you know exactly what numbers you need, there's nothing random about that at all! What you actually need is a random shuffle or order to your numbers, so lookup a random shuffle algorithm.
Just saying but no rand()%9 does not make an equal probability, it has a (rather strong, cryptographically speaking) bias. Think of it this way: what if rand() returned a number between 0 and 10 (both included)? Then modulo 9 the possible values would be: [0, 1, 2, 3, 4, 5, 6, 7, 8, 0, 1]. You have a sur-representation of 0 and 1. Of course since rand() has 2^32 possible values that bias is smaller than in this example but it's definitely present. The good way to do it modulo N is to restrict yourself to numbers up to the maximum possible multiple of N-1 and to discard any result greater than that so that each number is represented as many times as any other. This is not trivial and it's easy to introduce another bias by miscalculating, having an off-by-one etc. tl;dr: for cryptography don't use rand(), and if using a cryptographically secure pseudo-random number generator don't introduce a bias by using a modulo to restrict yourself to a range.
This just a small part of the assignment I got for class and a part of it is doing this,everything else I have done this was just the only problem thankfully I was able to solve it.
What solution did you end up implementing?
As others have said, you can just shuffle the numbers. If you actually need to generate random numbers though for some obtuse reason, just save the generated numbers in an array, and check whether each number is already present in the array before using it.
There was a problem in the printing of the results due to the shape the assignment needed things to be printed (think the shape of a numpad) so when printing there was a problem with the counter and the solution was to just put i+1 in the end.
for(int i=**0**;i&lt;**9**;i++) { x\[i\]=i; } for(int i=**0**;i&lt;**9**;i++) { j=rand()%**10**; k=x\[i\]; x\[i\]=x\[j\]; x\[j\]=k; }
You don’t want 10 random numbers. You want a random order. Start with numbers 0 to 9. Choose a random index between 0 and 9. Swap that number with the last number (ie: if you got 3, you now have 0,1,2,9,4,5,6,7,8,3). Repeat, but with an index between 0 and 8 (ie: if you pick 7, you now have 0,1,2,9,4,5,6,8,7,9). Rinse. Repeat until you have only one number to choose from (ie, and index between 0 and 0).
In C++ by the way, the argument is much simpler: Always use const when possible, because it allows code to be used both with values, l-value references and r-value references, which means less copying of data needs to happen.
Also possible with a linear congruential generator. I just implemented one yesterday.
&gt;linear congruential generator I don't believe that's guaranteed not to repeat an item.
Of period 10?
Many operating systems allow any file to contain any sequence of bytes of any whole-number length, but those abilities are not universal. Some systems like CP/M pad the lengths of files out to a multiple of the block size (which if I recall is 128 for many CP/M implementations), and other systems could use octet-based storage media but have a `char` type which is larger than an octet. The Standard says nothing about how bits written to a `FILE` are represented in any kind of physical medium, beyond requiring that implementations document whatever they happen to do. Because text files and binary files are required to offer different behavioral guarantees, the storage method that most efficiently accommodates one set of guarantees may not be the most efficient one that matches the other. Suppose, for example, a machine uses EBCDIC and has char/short/int sizes of 9, 18, and 36 bits, but has octet-based storage. Such a machine could process text files by discarding the top bit of each `char` written, and binary files by writing each group of eight `char` values using nine octets. Opening and writing a file as "text" and later opening as binary would likely yield a byte sequence totally unlike the original. Nowadays, the most common difference between text files and binary is that Windows-based systems use a CR+LF pair as a newline indications, while Unix-based systems use a lone LF as an indicator. Some older systems used CR alone as an indicator, but those are far less common today. As far as the Standard is concerned, however, text and binary mode could differ in far more significant ways such as the 8/9-bit packing, but those would seldom matter outside some systems using DSPs (which sometimes have `char` larger than 8 bits).
&gt; MSP430 with 256 bytes of RAM at this point you should be writing assembly by hand, not C.
FYI: [older discussions in this subreddit](https://www.reddit.com/r/C_Programming/comments/7qef1f/cdsa_a_library_of_generic_data_structures_and/) I have also [implemented an intrusive data structure](https://www.reddit.com/r/C_Programming/comments/8djxjx/a_singleheader_generic_intrusive_avl_tree_and/) recently. I came to realize that list is the only data structure that can be done truly intrusively with no compromise. An intrusive binary tree as is implemented in cdsa involves extra pointer arithmetics and function calls and is thus slower. A hash table with dynamic resizing is hard to implemented intrusively because growing the table needs `malloc()`, but calling `malloc()` defeats the goal of intrusive data structure. Even for static hash table like the one is cdsa, being intrusive requires to use chaining, which is usually slower than open addressing.
Yep, you know what numbers you need, populate your array in order, then shuffle.
Not necessarily. I did a non-trivial project targeting an MSP430 with 4K flash and 256 bytes of RAM. The entire codebase was in C except, perhaps (I don't recall offhand), the startup code.
I would recommend QtCreator under MSYS2
A little aside: for pointers, I like this convention: `const int *ptr; int *const ptr;`. I'm guessing one of the reasons you wonder whether you should use `const` is because the binding rules are a bit confusing. Just make sure to do `const type_t` and `*const` and then it will be rather obvious what is going on (as long as you `typedef` appropriately).
IAR Workbench's version of C is really tiny and was specifically designed for tiny environments.
I use const and restrict all of the time whenever possible, but only for optimizations sake.
Off-topic -- C# is not C!
&gt;fputs(message, pFile); Have you tried using other functions like fwrite or fprintf
Oh God. Oh my God. I'm dead serious. I'm just. Wow. I read the first two chapters and my mind is blown away. Is this how Java does it? A method is a function that is attached to a struct? I guess it's more complicated than that. But just wow. From the bottom of my heart. Thank you.
You say no hear/source file relies on another. I'm curious how this matters. If there is common code between the structures, forcing duplication just places an additional burden of maintenance upon you the developer.
Your `message` has no space for the '\0' character which will make `fputs(message, pFile);` read memory you don't own. It's best to declare your literals without the lenght to avoid this kind of bug: char message[] = "Knock Knock, neo\n";
Those functions didn't work but I finally got it working. Thank you for the help though. For those curious: &amp;#x200B; `#include &lt;stdio.h&gt;` `#include &lt;stdlib.h&gt;` `#include &lt;windows.h&gt;` &amp;#x200B; `int main()` `{` `FILE * pFile;` &amp;#x200B; `int i;` `int l;` `int k;` &amp;#x200B; `char textfile[100] = "C:\\Users\\nickr\\ccode\\cprojects\\misc\\test\\yeet";` `char const_textfile[100] = "C:\\Users\\nickr\\ccode\\cprojects\\misc\\test\\yeet";` `char cap[100] = ".txt";` `char filename[10] = "\\wakeup";` `int textnum = 0;` `char new_textfile[100];` `char message[17] = "Knock Knock, neo";` &amp;#x200B; `int filenum = 0;` `char new_dir[100];` `char directory[100] = "C:\\Users\\nickr\\ccode\\cprojects\\misc\\test\\yeet";` `char const_dir[100] = "C:\\Users\\nickr\\ccode\\cprojects\\misc\\test\\yeet";` `char write_dir[100];` &amp;#x200B; &amp;#x200B; `for(i = 0; i &lt;= 20; i++){` `itoa(filenum, new_dir, 10);` `strcat(directory, new_dir);` `CreateDirectory(directory, NULL);` `filenum = atoi(new_dir);` `filenum++;` `strcpy(directory, const_dir);` `}` &amp;#x200B; `for(l = 0; l &lt;= 20; l++){` `itoa(textnum, new_textfile, 10);` `strcat(textfile, new_textfile);` `strcat(textfile, filename);` `strcat(textfile, new_textfile);` `strcat(textfile, cap);` `pFile = fopen(textfile, "w");` `fprintf(pFile, message);` `fclose(pFile);` `textnum = atoi(new_textfile);` `textnum++;` `strcpy(textfile, const_textfile);` &amp;#x200B; `}` &amp;#x200B; `return 0;` `}`
If the job can be done more quickly and easily in C, why use assembly? A bigger question is why people who are writing code to execute on machines with many gigs of RAM and multi-level caches are trying to use C rather than a language that was designed for something closer to their specific purpose? &amp;#x200B; How much RAM and codespace do you think a freestanding implementation requires on the target? I've written C code that would run on targets with 36 bytes of RAM, an 8-level return stack (separate from RAM), and 1024 words of code space (PIC 16C84). C code which is written in a manner mindful of the target will generally be somewhat less efficient than optimal machine code, but many common constructs will end up being precisely the same as handwritten assembly. For example, \`unsigned char i=8; do { PORTB |= 2; PORTB &amp;= \~2; } while(--i);\` will compile to: &amp;#x200B; movlw 8 movwf \_i lp: bsf 6,1 ; Set bit 1 of PORTB bcf 6,1 decfsz \_i,f ; Decrement i; skip next inst. if zero goto lp &amp;#x200B; which is optimal. Even in cases where idiomatic C code would be sub-optimal, such as:\`unsigned i; for (i=0; i&lt;1000; i++) { PORTB |= 4; PORTB \~= 4; }\` could be written in C so as to yield near-optimal machine code: \`unsigned char i,j; i=(1000-1)/256+1; j=1000 &amp; 255; do { do { PORTB |= 4; PORTB &amp;= \~4; } } while(--j); while(--i);\` In most cases, even the former would give acceptable performance, and in such cases it's useful to have the option of writing the code in the more readable fashion.
I don't think \`const\` helps optimizations very much. Perhaps sometimes when combined with \`restrict\`, or for objects of static duration used within the same compilation unit as their definition, but otherwise a \`const\` qualifier doesn't allow a compiler to assume an object won't change, but merely indicates that a particular lvalue won't be used to change it without a cast to remove the \`const\` qualifier.
A point many people don't realize is that the capabilities of bottom-end controllers haven't really changed all that much. What's changed is the range of places where bottom-end controllers can be used. Adjusted for inflation, today's cheapest microcontrollers are more than two orders of magnitude cheaper than the cheapest microcontrollers of 40 years ago, but the RAM and ROM capacities are very close.
hello, if i'm not totaly mistaken you start your program over every time you wan't to enter an action right? Every time your program starts all the variables are reset to their initial value. your instance of the struct costum lacks an initialization btw. To get what you wan't you have to put a loop around your menu while(true){ printf("1. ........ else if(4){ break; // this causes the programm to break out of the loop or call exit has tje same effect ..... in this way you can enter your numbers and the programm remembers them until you enter a 4
That's hard to decipher. How about char path[1000]; for (i = 0; i &lt;= 20; ++i) { snprintf(path, sizeof (path), "%s%d", const_dir, i); CreateDirectory(path, NULL); for (j = 0; j &lt;= 10; ++j) { snprintf(path, sizeof (path), "%s%d\\wakeupneo%d.txt", const_dir, i, j); ... fopen ... fclose } }
Your code is C++, not C. We don't do `std::` here.
Oh my fault, thanks for informing me.
Thanks for the gist sir. Where do I lack some initialization? I'm a newb sorry
Will that help me get the total that I desire?
it's at least a missing step in the right direction. ibwould duggest to learn how to use a debugger as these kind of problems are easily resolved once you step through your programm and observe the variable values. maybe try some learn c books aswell
a good way would be to set all the bytes in acc to zero #include &lt;string.h&gt; .... int main ....{ memset(&amp;acc, 0 sizeof(acc)) ...
I need to print it to a file though
Thank you kind sir
**Problem 1 solved using realloc:** \[Thanks [a4qbfb](https://www.reddit.com/user/a4qbfb/), [kumashiro](https://www.reddit.com/user/kumashiro/)\] char \*cmp=(char \*)malloc(size\*sizeof(char)); while(\*(input+j)!=' '){ cmp = (char \*)realloc(cmp,sizeof(char)\*size); \*(cmp+j)+=\*(input+j); j++; size++; } **Updated code here for problem 2:** Input: Hello what's up s'tahw $ Expected output: s'tahw Generated output: $ [https://github.com/abcool/C\_training/blob/master/amazon19-5-19.c](https://github.com/abcool/C_training/blob/master/amazon19-5-19.c)
Only within the direct context of the protothread though. You can still use switch/case in any functions called by the pt and throughout your application
it needs to be char * p, not int. You need to declare p as a pointer to a char, rather than what you have now which is a pointer to an integer.
Yes p needs to be char \* (size does matter), also the correct for loop stop condition is "\*p != '\\0'" not "p != '\\0'".
Can't find the rate for VT102, but the [VT100 manual](http://bitsavers.trailing-edge.com/pdf/dec/terminal/vt100/EK-VT100-TM-003_VT100_Technical_Manual_Jul82.pdf) says: &gt; The blink rate is about half that of the cursor or about 0.5 Hz. So my guess would be about 1Hz.
Thanks for the reply. May I know why? Isn't a memory address represented as an integer?
Oh thanks for heads up, missed that.
I think you're getting tripped up by the spacing of "int *". Think of it as int* p --&gt; a variable p of type int* (pointer to int) char* p --&gt; a variable p of type char* (pointer to char) While both of these pointer types are indeed represented internally as a number equal in size to an integer, they are represented as different types, both as a way to catch possible bugs at compile time and because they increment differently (a char* will increment by one byte while a 32 bit int* will increment by 4 bytes).
int needs to be char \*. int \*p will point to an integer value. you need to point to a character value. and instead of str\[\] you could have used char \*str = "Hello, World!", then you could have avoided declaring another variable char \*p thus saving some memory and don't forget to free pointers after use otherwise it will result in memory leak.
```c char *input; scanf("%m[^\n]", &amp;input); ``` This looks very fishy to begin with. You’re passing an initialised pointer to a scanf function? And you’re passing it’s address too? I’m not sure why it doesn’t give you any errors but I highly highly suggest switching that out with a read_line() function. ```c char *cmp=(char *)malloc(size*sizeof(char)); while(*(input+j)!=' '){ cmp = (char *)realloc(cmp,sizeof(char)*size); *(cmp+j)+=*(input+j) ; // Problem here. need dynamic assignment of string. j++; size++; } ``` This code seemed very inefficient and I suspect wrong too. I suggest allocating enough memory at the beginning with the malloc (say 32 bytes) and using the realloc inside the while loop just to give the array more memory if it’s full. And then a realloc outside of the while loop to resize the string to the right size. Also you didn’t consider the /0 terminator so cmp won’t be considered as a string but just as an array of characters. Also here *(cmp+j)+=*(input+j); just go like this *(cmp+j)=*(input+j); Also the sizeof(char) is redundant. Now, having said all that. There’s a way of doing what that thing does in one quarter of the time and 1000 times more clearly. Hint: use strtok() The strstr probably gives you problems bc you didn’t use the /0 terminator in cmp
In [*The Apple II circuit description*](https://www.amazon.com/Apple-II-circuit-description/dp/067221959X), page 126, it is said: *"Flashing Text - When DL7 is low and DL6 is high, the signal at B11-11, B13-4, and A10-12 will follow the output of timer B3. B2-11 now alternately inverts or passes noninverted the serial bit stream. This gives us a flashing character at about 2 Hz."*
read\_line() is not a standard library function. So can't use it. codechef/hackerearth compilers etc. I added \\0 to the cmp as size++; reverse(cmp); cmp = (char \*)realloc(cmp,sizeof(char)\*size); \*(cmp+j+1)+='\\0'; //printf("%s",cmp); if (strstr(input,cmp)!=NULL) { // Problem in this printf("%s",cmp); break; }else{ i++; } &amp;#x200B; but still strstr() doesn't work. Any ideas?
Because the first time you assign it, it is an initializer. Try strcpy.
Thanks strcpy helped me use the same variable where i had assigned the 1st value . I could have also declared a new variable there in line 12.
BE CAREFUL. Your buffer needs to be long enough to hold the largest string you plan to put in it. Be careful just copying stuff into buffers. You may get by with it a time or two, but some day it will bite you and you'll overwrite RAM you didn't intend to.
&gt; However, understand that this use of const will never help in optimization. It tells the compiler that any assumptions it made about the value prior to the call are still true after the call.
That's what their code does, except for the bug in the first loop.
Well I simply use, strcpy(name, "XYZW");
In both loops, you stop at 8 instead of stopping at 9. In the second loop, you pick a number between 0 and 8 instead of 0 and 9. Fix those two bugs and you should be fine.
Their existing code *is* Fisher-Yates.
Because your "name" buffer is 3 char + '\0' long and you can't copy in it 5 char + '\0'. And you can't you copy that you need to use strcpy(name, "string");
Oh! Totally missed that.
one last thing can you help me total all the items on the text file that it is stored in?
&gt; You’re passing an uninitialised pointer to a scanf function? They are using the non-standard `m` modifier which tells `scanf()` to allocate memory for the string.
&gt; I think you're getting tripped up by the spacing of "int *". No, that spacing is consistent with how the compiler parses declarations. &gt; int* p --&gt; a variable p of type int* (pointer to int) `int *p` --&gt; `*p` is an `int`.
&gt; don't forget to free pointers Nothing is being allocated, so nothing needs to be freed.
You seem to have misunderstood what line 7 really means. Here it is with spaces in the correct places: 7. char name[] = "Jon"; This is a variable definition with initializer. Most variable declarations and definitions reflect the usage of the variable, but this one uses a special case which was introduced to facilitate the creation of initialized arrays. Here is what it would look like without that special case: 7. char name[4] = "Jon"; This means “create `name` as an array of four `char` and initialize that array with the null-terminated string `"Jon"`”. The version actually used in your program does not specify a length for the array. This tells the compiler to deduce the length from the initializer. In this case, the correct length is 4 (one each for `'J'`, `'o'`, `'n'`, and the implicit `'\0'`). On line 12, you try to assign a new value to `name` using what you incorrectly believe, based on your misunderstanding of line 7, to be a string assignment operator: `[]=`. There is no such operator. You cannot assign to an array in C, except in the context of its definition. If you want to modify the contents of an array after it has been defined and optionally initialized, you must either manipulate its elements directly or use something like `strcpy()` or `memcpy()`: 12. strcpy(name, "haron"); // undefined behavior This is incorrect, though, because `name` was defined as an array of four characters, and you are copying six characters into it. C does not perform any sort of bounds checking, so you are responsible for ensuring that the array is large enough for the data you are copying into it. The simplest solution here is to provide an explicit length when you define `name`: 7. char name[6] = "Jon"; This will ensure that `name` is large enough for `"haron"` (including the implicit terminating `'\0'`).
One point that's often overlooked: C is better at modelling data structures in certain cases. Example: sum types. Without std::variant, you practically have no way to defined sum types in C++, unless you only use POD-types. The boilerplate code required for non-POD sum types becomes unmaintainable. Also noteworthy is the lack of OO and templates, which forces programmers to really think about the problem they are solving. This frees up time wasted by overthinking unnecessary abstractions and creates a more clear and concise codebase. I have yet to see more pleasing code than a well thought out procedural-paradigm project. Also, C compiles faster. Fast compile times are noice.
I meant to write your own read\_line() function... Anyways, here's a simple way of doing what you're trying to do: [https://pastebin.com/vxSccWwF](https://pastebin.com/vxSccWwF)
Every time I look at Code Blocks, I reminds me of Borland C++ 4.0.
First, your code (even the ASCII-only version) assumes a little-endian architecture. Second, what are you actually passing to `ft_putchar()`? Is it a raw Unicode codepoint? A `wchar_t`? Either way, it's almost certainly not what your code assumes, i.e. an array of 1 to 4 `char` reinterpreted as an `int`. The simplest solution is to set the locale to an appropriate UTF-8 locale, use `wchar_t` instead of `int`, and call `wctomb()` or `wcrtomb()` to convert your `wchar_t` to a UTF-8 sequence.
Sure. I understood that.
Unfortunately it's much weaker than that. For the callee, it doesn't guarantee anything about the value: void example1(int *x, const int *y) { int z = *y; *x = 0; /* may change *y due to aliasing */ return *y + z; } void example2(const int *y) { int z = *y; func(); /* may change *y */ return *y + z; } For the caller it also doesn't guarantee the callee doesn't change anything. The following is a perfectly legal program — though certainly ill-advised — that must print "0": #include &lt;stdio.h&gt; void foo(const int *px) { *(int *)px = 0; } int main(void) { int x = 1; foo(&amp;x); printf("%d\n", x); } The object `x` in `main` is not const, so the cast to remove the const and modify the object is legal. So the caller can't make any assumptions about the callee's behavior. The situation changes when `x` is itself const: int main(void) { const int x = 1; foo(&amp;x); printf("%d\n", x); } Now it's undefined behavior for `foo()` to modify `x`, so the compiler can safely assume it doesn't happen. This isn't due to the pointer to const argument but that `x` is itself const. The pointer to const didn't help the optimizer.
I started using it when I was first learning (at work), but I’m uncomfortable on Windows so I installed Cygwin for that sweet clang and vim feeling.
I love when people respond to beginner questions with detail that'll actually help them understand. Nothing worse than the loads of programmers who just trash any newb question. Kudos to you, my man
Oh cool didn’t know that
For the future, consider using \`strncpy\` instead (note the 'n'). It allows you to specify a limit on the number of characters copied, which can help you avoid overrunning the end of the array.
I love this look, though. The aliased, choppy old Windows font with the plain color scheme I find surprisingly readable and absolutely nondistracting.
 A tons of thank you You're a Good person.
that's not true. the compiler will parse both as declaring a variable p of type "int *". there is no way to declare a variable "*p"
What does `c` contain?
The biggest issue is that's not how UTF-8 works. Take some time to study the [UTF-8 Wikipedia article](https://en.wikipedia.org/wiki/UTF-8), especially the first table under the "Description" section. It's an *encoding*, not just the raw code point dumped out of memory as an integer. Fortunately the correct code is actually not that much more complicated than what you've done, but you still shouldn't use a pointer cast to do it. The second issue is that the original `purchar()` is buffered. By using `write(2)` you're bypassing that buffer which can lead to unexpected results. It's also less efficient, which is what buffering is for in the first place. Use `fwrite(3)` instead since that writes to the same buffer that `putchar(3)` would have used. You were directed towards C's widechar functions. This is probably the simplest way to do what you want. Though keep in mind that nowhere in the C standard does it say these functions operate on Unicode code points. An implementation is free to make `wchar_t` an 8-bit integer and not support Unicode — though pretty much any system that supports `write(2)` will also support Unicode in its widechar implementation. Typical C compilers on Windows use 16 bits for widechars, limiting what they can do.
**UTF-8** UTF-8 is a variable width character encoding capable of encoding all 1,112,064 valid code points in Unicode using one to four 8-bit bytes. The encoding is defined by the Unicode Standard, and was originally designed by Ken Thompson and Rob Pike. The name is derived from Unicode (or Universal Coded Character Set) Transformation Format – 8-bit.It was designed for backward compatibility with ASCII. Code points with lower numerical values, which tend to occur more frequently, are encoded using fewer bytes. The first 128 characters of Unicode, which correspond one-to-one with ASCII, are encoded using a single octet with the same binary value as ASCII, so that valid ASCII text is valid UTF-8-encoded Unicode as well. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I spent a long while after this looking further into the matter, and think I have actually come to a working conclusion. (I would appreciate input on this.) I was misunderstanding a lot about UTF-8, but my code was also just silly, in hindsight. My program now accepts an input c, (an int, which could contain either an ASCII value, or a UTF-8 value, of variable width.) void ft_putchar(int c) { unsigned char byte; size_t i; if (ft_isascii(c)) write (1, &amp;c, 1); else { i = 0; byte = (c &gt;&gt; (8 * i) &amp; 0xff); while (((c &gt;&gt; (8 * i) &amp; 0xff) != 0) &amp;&amp; i &lt;= 3) { byte = (c &gt;&gt; (8 * i) &amp; 0xff); i++; } if (byte &lt;= 0x7F) write(1, &amp;c, 1); else if (0xC2 &lt;= byte &amp;&amp; byte &lt;= 0xDF) write(1, &amp;c, 2); else if (0xE0 &lt;= byte &amp;&amp; byte &lt;= 0xEF) write(1, &amp;c, 3); else if (0xF0 &lt;= byte &amp;&amp; byte &lt;= 0xF4) write(1, &amp;c, 4); } } I tried using c &gt;&gt; (8 * i) &amp; 0xff; to access the first byte, but it seems that the bytes are held in reverse-order, and I didn't know of a nicer way to get the last byte, so I just looped through the bytes until either a byte contained no data, or I reached the 4th byte. I'm sorry for any headache I cause with this. I'm not the best at wording my problems, and as a beginner, trying to understand more complex topics, I often find myself VERY confused, and struggle to even find the question to ask.
It is expected to contain a valid UTF-8 value, or ASCII value. (They seem to be the same, due to how UTF-8 did its mapping?) I THINK I fixed the code, but hilariously enough, I don't have a unicode friendly terminal to test it with. void ft_putchar(int c) { unsigned char byte; size_t i; if (ft_isascii(c)) write (1, &amp;c, 1); else { i = 0; byte = (c &gt;&gt; (8 * i) &amp; 0xff); while (((c &gt;&gt; (8 * i) &amp; 0xff) != 0) &amp;&amp; i &lt;= 3) { byte = (c &gt;&gt; (8 * i) &amp; 0xff); i++; } if (byte &lt;= 0x7F) write(1, &amp;c, 1); else if (0xC2 &lt;= byte &amp;&amp; byte &lt;= 0xDF) write(1, &amp;c, 2); else if (0xE0 &lt;= byte &amp;&amp; byte &lt;= 0xEF) write(1, &amp;c, 3); else if (0xF0 &lt;= byte &amp;&amp; byte &lt;= 0xF4) write(1, &amp;c, 4); } }
&gt; It is expected to contain a valid UTF-8 value, or ASCII value. (They seem to be the same, due to how UTF-8 did its mapping?) UTF-8 is a multi-byte encoding of Unicode. Do you mean “valid Unicode codepoint” by chance? If you want to pass UTF-8 encoded data, I wonder why you pass an `int` (which is not a sequence of bytes).
That's still completely bonkers. What you want is this: * your function receives a Unicode codepoint * your function translates this Unicode codepoint into UTF-8 and writes it out Everything else makes very little sense.
How would you go about using the write() function to write the desired output, from a given Unicode codepoint?
Like this: extern int ft_putchar(int c) { size_t len, count; char utf8buf[4]; /* check if c is valid */ if (c &lt; 0 || c &gt; 0x10ffff) { errno = EILSEQ; return (EOF); } /* encode c as UTF-8 */ if (c &lt; 0x80) { utf8buf[0] = c; len = 1; } else if (c &lt; 0x800) { utf8buf[0] = 0xc0 | c &gt;&gt; 6; utf8buf[1] = 0x80 | c &gt;&gt; 0 &amp; 0x3f; len = 2; } else if (c &lt; 0x10000) { utf8buf[0] = 0xe0 | c &gt;&gt; 12; utf8buf[1] = 0x80 | c &gt;&gt; 6 &amp; 0x3f; utf8buf[2] = 0x80 | c &gt;&gt; 0 &amp; 0x3f; len = 3; } else /* if c &lt; 0x110000 */ { utf8buf[0] = 0xf0 | c &gt;&gt; 18; utf8buf[1] = 0x80 | c &gt;&gt; 12 &amp; 0x3f; utf8buf[2] = 0x80 | c &gt;&gt; 6 &amp; 0x3f; utf8buf[3] = 0x80 | c &gt;&gt; 0 &amp; 0x3f; len = 4; } count = fwrite(utf8buf, len, 1, stdout); if (count == 0) return (EOF); return (0); }
&gt; I have the vision, but I need the talent. I want no part in what happens afterwards. This is strictly for me. Pro-tip: Nobody in their right mind will ever voluntarily build anything pitched with this line unless you're paying them a set contracted upon amount, preferably up front.
This is why snprintf and strlcpy are often preferred.
It's far more beautiful than anything I could conjure up. Thank you :)
But it is so much easier to be a douchebag. That way nobody will know that I don't actually know anything
By that you will probably cause some serious bugs when the new string is longer than the original one. On some cases it can affect other variables.
From the point of view of the Standard, any code that interfaces with any functions that aren't in the Standard Library, aren't written in C, or aren't included in the same translation unit as the caller invokes Undefined Behavior. There is no circumstances under which the Standard imposes any requirements about how an implementation processes such programs. Most implementations will document cases in which *they* define the behavior, but from the Standard's point of view the difference between Implementation-Defined Behavior and Undefined Behavior is not whether implementations happen to define the behavior, but whether the Standard would require that all implementations do so.
Now that you have the code basically working, go back and read the reference documentation for every function you call. Learn how the returned value is used to signal an error, and then update your code to detect errors and handle them (usually returning early from the current function, using a return value to signal a failure will be the best strategy).
For next time, please format your code in a readable format.
Ahh shit, here we go again!
Often used for flags, when a single bit suffices. E.g.: #define FLAG_1 1 &lt;&lt; 1 #define FLAG_2 1 &lt;&lt; 2 int flags = FLAG_1 | FLAG_2; Would result in flags having the value 110, and you can test which flags are set: if (flags &amp; FLAG_1) ... ;
Classic writeup on bitwise operations: https://graphics.stanford.edu/~seander/bithacks.html
That's useful. Thanks
That's not a good beginner's resource.
if (flags &amp; FLAG_1) ... ; Is this enough? To this day I always used if ((flags &amp; FLAG_1) == FLAG_1) ....;
The reason you do that is because it allows you to check multiple flags at once.
Yes. if (flags &amp; FLAG_1) do_the_flag_1_thing; if (flags &amp; FLAG_2) do_the_flag_2_thing; /* ...etc */
Are you needing an actual database, or very simple key-value data storage? By which I mean: do you need an actual (relational) database capabilities of multiple tables with defined relationships between them, and the ability to manipulate the data according to said relationships? If you don't, and just need a very simple key-value lookup, and you don't care about rapid searching, then just reading and writing a `struct` to a binary file with `fread()` and `fwrite()` are the "best" choices. (You could also get away with `fscanf()` and `fprintf()`; but that's a bit "messier" and could go terribly wrong.) If you are actually needing/wanting "full" database capabilities, just use [SQLite](https://www.sqlite.org/index.html). It gives you a fully-functional SQL database "engine", in native C; in two files (from the "sqlite-amalgamation-..." file, you need only the `sqlite3.c` and `sqlite3.h` files and you've got all you need). Given this is for a programming basics class... I am almost completely sure that SQLite is overkill for your application, but it doesn't hurt to mention it.
Yep. It's enough to just do: if (flags &amp; FLAG_1) do_flag_1_thing; if (flags &amp; FLAG_2) do_flag_2_thing; etc
What do you mean exactly with the sentence in the parentheses? When he tried to check multiple flags with this operation? So in C every value is considered TRUE, except 0? That’s new to me. But I’m also somewhat new to C, that’s why I’m asking.
It's enough to check for a single flag, but not multiple.
C99 added support for wide characters but it's a bit convoluted. Here's a sample program to copy a UTF-8 encoded text file "character-by-character" (read: "codepoint-by-codepoint"): #include &lt;wchar.h&gt; #include &lt;stdio.h&gt; #include &lt;locale.h&gt; int main(void) { wint_t c; size_t cnt = 0; setlocale(LC_CTYPE,"en-US.UTF-8"); while((c = getwchar()) != WEOF) { cnt++; putwchar(c); } fprintf(stderr,"count=%zu\n",cnt); return 0; } The call to `setlocale()` tells the C runtime we're using UTF_8 (under Linux---please check with your local compiler manual to see what you need to use for `setlocale()`). After this, `getwchar()` and `putwchar()` use Unicode code points.
You seem confused about the `*` operator in C. These three lines are completely equivalent: int *p; int* p; int * p; All three are absolutely identical. All three declare a variable named p to be a pointer to an int. I'd suggest reading more about `*` and how it is a [dereference operator](https://en.wikipedia.org/wiki/Dereference_operator).
Well, "true" is defined as a macro with the value 1 in `stdbool.h`. But any NON-ZERO value is treated as true if it's used in an expression. &amp;#x200B; Here is an example demonstrating what I meant: #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; enum { FLAG1 = 1 &lt;&lt; 0, FLAG2 = 1 &lt;&lt; 1 }; int main(void) { uint32_t test = 0; test |= FLAG1; printf("Has flag 1: %u\n", (test &amp; FLAG1)); printf("Has flag 2: %u\n", (test &amp; FLAG2)); printf("Has flag 1 and 2 (improper check): %u\n", (test &amp; (FLAG1 | FLAG2))); printf("Has flag 1 and 2 (proper check): %u\n", (test &amp; (FLAG1 | FLAG2)) == (FLAG1 | FLAG2)); return 0; } &amp;#x200B; The result of this is: &amp;#x200B; &gt;Has flag 1: 1 &gt; &gt;Has flag 2: 0 &gt; &gt;Has flag 1 and 2 (improper check): 1 &gt; &gt;Has flag 1 and 2 (proper check): 0 &amp;#x200B; So as you can see, if you try checking for more than one flag at once without comparing to the mask you'll get an invalid result.
Do you have a more specific question? As per the name, they apply the logical operations between the individual bits of the operands. So, if you understand the logical operations, these examples should hopefully make sense: You can set bit 3: val |= 1 &lt;&lt; 3; or you can set a group of 4 bits starting at bit 3: val |= 0xF &lt;&lt; 3; You can clear it: val &amp;= ~(1 &lt;&lt; 3); You can toggle it: val ^= 1 &lt;&lt; 3; This kind of thing is very common if you're reading/writing memory-mapped hardware registers, for example, where bit 3 might correspond to enabling or disabling a certain feature in your hardware.
I am not a fan anymore. Maybe back in 1992, the cleaner UI makes it a much more enjoyable experience in CLion and modern Visual Studio.
No, I am not confused. The `*` operator modifies the name, not the type.
The `*` operator modifies the name, not the type. This is why `int *p, q;` defines `p` as a pointer to `int` but `q` as an `int`.
Why would you expect "|" to mean AND in "(FLAG1 | FLAG2)? Read it as "OR" and it is correct. OR fits the pattern of "&amp;&amp;" and "||" for booleans as well. It's weird mistake to assume "|" should mean AND.
You are absolutely, categorically wrong. * C11 section 6.5.2.2 (function calls) para 7: passing an expression as an argument to a function is equivalent to assigning that expression to an operand of the same type as the corresponding parameter. * C11 section 6.5.16.1 (simple assignment) para 1: assigning an expression of qualified type to an operand of less-qualified type is a constraint violation. * C11 section 6.7.3 (type qualifiers) para 6: modifying an object of const-qualified type through a cast to a non-const-qualified type invokes undefined behavior.
I don't recall any early microcomputer architectures that would behave that way. Minicomputers perhaps, but not micros. Got any examples?
I've spent hours looking into this already years ago. I'm willing to bet US$1000 that I'm right if you want to take me up on it. &gt; C11 section 6.5.2.2 Doesn't really mean anything here since we're just talking about pointer to const. All it's saying is that passing `int *` to a function that accepts `const int *` is the same as the assignment here: int *y = 0; const int *x; x = y; &gt; C11 section 6.5.16.1 Doesn't apply since there's a cast. &gt; C11 section 6.7.3 `x` isn't const-qualfied, so this doesn't apply.
It is not a mistake. The result of `a | b` is a number where every bit that is set in `a` **or** `b` is set, which means that all the bits that are set in `a` **and** the bits that are set in `b` are set. If this bothers you, you can rewrite the condition as `(test &amp; FLAG1) &amp;&amp; (test &amp; FLAG2)`.
k
[Go here](https://web.njit.edu/~rlopes/Mod13.2.pdf) page 11. Ack and Watchdog timer for the Motorola 68000 microprocessor.
That looks like C#, not C. Try /r/csharp or /r/learnprogramming instead.
You are definitely confused. Don't take my word for it, check page 36 of [the standard](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf) which says: &gt; A pointer type may be derived from a function type, an object type, or an incomplete type, called the referenced type.Apointer type describes an object whose value provides a reference to an entity of the referenced type. A pointer type derived from the referenced type T is sometimes called ‘‘pointer to T’’. The construction of a pointer type from a referenced type is called ‘‘pointer type derivation’’. Doing this: int *p; Is to say "Create a variable called p of type pointer that points to an integer."
The microprocessor had provision to wait for an acknowledgment, but to what extent was that exploited by early 68000-based microcomputers (as opposed to workstations)? Machines like the Macintosh, Amiga, and Atari ST ran the processor slow enough that DRAM wait states weren't an issue. Sometimes CPU operations would have to wait for other traffic on the bus (most typically video data), but on early machines in those lines the entire address space would be affected by such delays.
Also page 78 of the same standard I linked in my other comment: &gt; 6.5.3.2 Address and indirection operators &gt; Constraints &gt; 1 The operand of the unary &amp; operator shall be either a function designator, the result of a &gt; [] or unary * operator, or an lvalue that designates an object that is not a bit-field and is &gt; not declared with the register storage-class specifier. &gt; 2 The operand of the unary * operator shall have pointer type.
I don't know how Macs and Amigas, etc. did things but every machine I designed always had an ack come back cause ... every reason you're supposed to do that.
Valgrind does much more than leak detection like using unassigned memory and unallocated memory, not to mention all the other tools. What I prefer about valgrind is that it complains about actual problems, not theoretical ones.
`(flags &amp; FLAG_1)` can differ from `((flags &amp; FLAG_1) == FLAG_1)` if `FLAG_1` has 2 or more bits enabled. But if it only has a single bit enabled, the two are identical.
&gt; A method is a function that is attached to a struct? I guess it's more complicated than that. Depends, a non-virtual function is even simpler, it's not attached to a struct at all it just recieves it as it's first argument and the language just adds some syntactic sugar. Virtual functions are typically stored desperately from the structure and the caller has to know the type and lookup the right one, but after that it's again just some syntactic sugar to hide passing the structure.
Possible. Popular libs are available in C. Most of the learning material is for Python though, so you'd be better off discarding C.
It's *possible* of course, but why? If you don't have portability or runtime environment constraints precluding it, I'd stick to a higher level language like Python for this, and maybe use C modules for performance-critical stuff. C is not the most expressive language for these kinds of domains.
If you want to spend lots of quality time dealing with low-level issues, sure, but it's probably not the best choice unless you have a good reason for it. Why not Python?
Good grief. You couldn't type this out?
Im trying to get my ideas together before typing it just to demonstrate to you guys
 I don't know, I hate this font
Just use C++ and std::string. Why bother with strcpy?
Type out your code, and give an explanation of what you're trying to do. If you must include a diagram (I rather like diagrams, actually) -- then explain what the heck things are. I'm sure I can rationalize myself into "ah yes, this works" or "hmmm, no, that's wrong" -- but unless I have any idea of what you actually intend to do, my opinion will be worth bupkis.
You couldn't rotate this?
Char name and char letter will only hold a single char.
I love C, C++, and fortran, but python is the better choice at this moment for ML,Deep learning, etc... Unless you doing some extremely time critical things, Id start with python. Infact, I did a paper in grad school comparing the computing time of Pythons numpy library vs native fortran, C, and Java (as a joke) and python's scientific libraries beat them hands down. Now if you start multithreading those (except for java) Im sure they'd beat python-numpy but for the ease of it, it's worth looking at python first
Python is the king for ML and AI right now. The main libs are all written in ASM and C, but the interface to them is using Python. You will be renting space from Google Compute or AWS to do it since it's way cheaper than using your own hardware. They've also got everything set up for you already as well: I highly recommend https://www.fast.ai for learning about machine learning.
I don't think I've had code on paper since the 90s...
possible, yes. good choice, no.
No, I am not confused. The text you quote describes the type system and is not relevant to this discussion. You need to look at how declarators are defined in section 6.7.6. The `*` is part of the declarator, not the type, so `int *p` means “define `p` so that `*p` is of type `int`”. BTW, I don't know what version you have, but in C11, the text you quote is on page 42. You should site the section and paragraph (in this case, 6.2.5 paragraph 20) instead of the page number.
I'm exactly doing this for my job. In the research phase, the algorithm is developed in Python using TensorFlow. After that, I rewrite it in C using cuDNN and other libraries. ML in C is not a good choice at all, but inevitable in my case due to some constraints. * It will be combined with existing vision applications, so it should provide a simple and clean interface with least side-effects. * It will run *with* existing vision applications, so it should be light in *memory* and computation. * For industrial use, it should be under *full* control in *every* detail (not full in practical, but as much as possible). I just only imitate a very small subset of the huge framework, but lots of things fall under my control. (license check, multi-thread usage, event scheduling, etc.) Again, this is not recommended for a research purpose.
Thanks for the reply. Just had a "mind fuzz" where if for an array of ints, if every int were 4 bytes how would adding 1 to a pointer point to the next int? But you specifying that pointer arithmetic having nothing to do with memory addresses clears it up for me. Thank you.
Happy belated as well :)
Numpy is a bunch of fast maths, written in C, with python bindings. A good implementation in C (numpy), verses a poor implementation in C will have a pretty predictable outcome.
Why? It's not a bloated, js-pumped website like most people build nowadays, but the information isn't anything particularly complicated.
Very possible. The darknet is wrote entirely with C.
Of course. What has happened to the world where people started to think that there are things you CAN'T do in C?
This.
I'm a newbie, but since array starts at *0* shouldn't it be *n* chars (*n-1+1* for the null) char name[3] = "Jon" 012\0 At least that was the understanding I had about arrays.
There is nothing wrong with simply grounding /DTACK on a system where all devices are fast enough to respond without wait states. Later microcomputers ran fast enough to require variable number of wait states based upon whether an access was in the same column of DRAM as the previous one or was in cache, but earlier microcomputers ran processors slow enough that RAM could keep up.
Isn't the darknet written in HTML as every site?
That doesn't work as per my question. If I enter Hello what's up olleH$ it should print olleH but it prints Hello. Your logic has some problem. After reading your logic I find that you are going to first space then storing word after first space which is not the requirement. My requirement is : Algo Reverse\_Picker(String) while string reaches ${ pick first word and check whether it's reverse is present is present in the string. If found print the reverse. break the loop and exit else go to next word and find whether it's reverse is present is present in the string. If found print the reverse. break the loop and exit else go to next word and find whether it's reverse is present is present in the string. ..................... .......................... and so on } if reached dollar and not found any such word then print $
The CNN darknet... one with the yolov3
Lol
I can tell you right now one video won't take you from beginner to expert in *any* language. Not even one that's three and a half hours long.
The size of the array still needs to be 4. char name[4]; name[0] = 'J'; name[1] = 'o'; name[2] = 'n'; name[3] = '\0';
Did people downvote me because they thought I was trolling?
That should be the reason
Dear i donot mean that you can be expert by watching just one video..i mean that if you watch then it can only build your [basic. No](https://basic.No) one can be a programmer by watching just videos.but you can be if you work hard and do more [practice.So](https://practice.So), stop calling me spammer dear!
&gt; Dear i donot mean that you can be expert by watching just one video..i mean that if you watch then it can only build your basic. No one can be a programmer by watching just videos.but you can be if you work hard and do more practice.So, stop calling me spammer dear! Amazing how much worse your command of English is here compared to the other post I linked to. It's also amazing how you thought you could literally copy and paste a post and not get caught.
No, never use strncpy! In case if overflow, the output is NOT TERMINATED! The (sadly nonstandard) strlcpy function doesn't have this problem.
Floating point operations are not perfect representations of their decimal counterparts, due to rounding. The reason the double is giving you a smaller error is because it has a higher degree of precision than a float. (It literally has *double* the bytes). Note that the # of bytes in a float is machine-dependent, so you can not assume consistency across implementations. When dealing with floating point values, I would strongly advise against checks in which two computed values equal each other. If you must, you'll probably want to truncate the decimal at some point, or check to see if a value is within a particular range of another value.
This is fully explained at https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
I don't need of copy and past.I don't care what you say. so please i don't want to talk you more..
The thing about floating point numbers is not only that they have limited accuracy, but that they're stored in base 2. This means that they can indeed yield perfectly correct results, but only for numbers which have a limited number of decimal places in base 2. Your 4.05 is a number with only two decimal places but only in base 10. In base 2 it gets converted to a representation that has an infinite amount of decimal places and thus when converted back to base 10 ends up as something like 4.05000019073486328125, which means everything you'll do with that number won't yield what you think it should when you think in base 10.
If you don't want us to provide criticism and share skepticism regarding the content you post, leave because you are not welcome.
How about the onlineGDB ?
Oh sorry, I thought it had to print the reversed word, that is easily fixable tho and I think that seen how I did it you can figure out a way of doing it yourself. Also, looking for the dollar sign at the end of the phrase and for the last space is conceptually the same thing, in both cases you get the last word that needs to be reversed. For what matters, you can completely disregard the dollar sign as “marking character” and just treat it as “character that needs to be thrown away” and still get a perfectly valid solution
Tried your code ( [https://pastebin.com/5UG94gBA](https://pastebin.com/5UG94gBA) ) in codechef.com/ide **Input:** Hello what's olleH up$ **Expected output:** olleH **Your program's output:** $ Your logic is not working. Please use online compilers only like [codechef.com/ide](https://codechef.com/ide) or [https://code.hackerearth.com/](https://code.hackerearth.com/) etc.
What about it? At it's core, it's just another compiler and just another machine. It's likely truncating the decimal. Don't expect code to perform identically across multiple platforms unless the functionality is explicitly defined as part of the C standard.
I don't know why you're getting errors, and I haven't done any Win32 development since the 1990s, but I'm pretty sure you want to use FILE\_FLAG\_OVERLAPPED to do async I/O. That may be why your app is freezing.
Shall we discuss the fact you're advertising the algorithm with the words "worst case"?
Talking about the worst-case time complexity of am algorithm isn't exactly uncommon though... It would've been kind of useless if they had said it has an O(n) best-case time complexity.
Aha I'm aware of that. It's just interesting to see this wording
What would you recommend though? Not mentioning the time complexity in the title? Or just mentioning average or best-case complexity and not worst-case complexity because you don't like the words "worst-case"?
Oh no it's perfectly fine this way. It wasn't critical or anything, just a useless comment with the depth of a mud pond to point out the wording was funny. I had a "break" from CS in general to focus on chemistry, and the papers published *generally* avoid putting the bad stuff in the titles. Hence my reaction
What I mean is that this is some very advanced material. Not suitable for beginners who have never used bitwise operations before.
And what would happen if there was a failure and your read or write never went through and there never was an ack? That's how airplanes fall from the sky.
Right, but it was also to prove a point that someone in my class made that python was useless and that matlab was the only way to do machine learning. I agree it was a silly paper tho.
It sounds like your classmate may [only know matlab](https://www.commscope.com/Blog/If-Your-Only-Tool-Is-a-Hammer/).
Lmao hes just being specific on the complexity, its not advertising.
ML is possible with Charles Babbage's difference engine.
On reddit, put 4 spaces before text to have it code-formatted. Don't use `\`` unless you're inserting **inline** code
How is this video C related?
And the rest of Zain4u's comments that weren't stolen from reddit were stolen Quora. Example: * [stolen](http://archive.is/ka3d0), [original](http://archive.is/7mn1k)
`scanf` stops processing input just before the first character that cannot be accepted by the remaining format string. Its return value will tell you how many format specifiers were successfully completed.
[Here is a discussion](https://docs.microsoft.com/en-us/windows/desktop/fileio/synchronous-and-asynchronous-i-o#synchronous-and-asynchronous-io-considerations) on this topic.
Poor experimental design serves to disprove your point rather than to make it.
You can try something like this: `int a = 0;` `char b;` `scanf("%d", &amp;a);` `scanf(" %c", &amp;b);` `printf("%d %c", a,b);` If you input "5", then "x", the result will be "5 x". If you input just "x", the result will be "0 x", because the first scanf will fail and no input will have been consumed. &amp;#x200B; The whitespace in " %c" is there so that the newline between the scans will be consumed if the first one succeeds.
And if you enter: 3.14159 then the output will be: 3 . since the `.` is the first character that cannot be consumed by `%d`.
Do not spam.
We are doing exams on paper in Croatia
Please use 4 spaces to highlight code. The backtick variant in entirely unreadable.
You’ve done sillier things Stannis...
Really, thats what it was
You are right. I didn't find the Code Block tool in Fancy Pants (although I'm pretty sure I've used it before), and didn't bother switching to markdown.
The original version of this algorithm is written in C.
You can probably generalize the linear, quadratic, triangle, square, cube and tetrahedral number predictors into one algorithm that checks if the numbers can be fit by a polynomial of degree 3.
But those python libraries are written using the C API, if I'm not mistaken?
&gt;What has happened to the world where people started to think that there are things you CAN'T do in C? C can't fix my relationships
Actually, no. His difference engine lacked critical components. His theoretical analytical engine however...
What. The. Fuck. Is this the way the universe shows me how little I know?
But it’s not bad stuff in the title. It’s saying this algorithm guarantees *at least* this level of performance.
C is for *Can*. It *can* fix your relationships! You just have to BELIEVE. Just dive into some crazy C projects that are awesome looking when you post screenshots on social medias, and share around about it different places so you gather a huge following of people who like shiny stuff, and you won't care about relationships anymore. Relationships problem fixed! C Can.
So is most software. The video does not link to the source, though.
It actually does. Read its YouTube description.
you can use gets(). add void gets(char \*); prototype above main() to avoid warnings.
No genius in the community to help on this? It's long been stuck!
It's the way the universe show you how little I know.
I'll look into it, thanks.
Ohh I thought that the reversed word was always gonna be the last one
I don't mind the paper/diagrams, it could be rotated though. The contact struct needs a next pointer to get to the next contact in the list of "a"-contacts.
Most systems are reliant upon the fact that if a memory request is set up with certain timing, the memory *will* respond within a specific length of time. While some possible failure modes that could prevent that from happening might be detected using /DTACK, most wouldn't. If the worst-case time for all memory systems was within the default length of time for a system with /DTACK strapped low, I don't think using /DTACK would offer a reliability improvement that couldn't be obtained more cheaply other ways.
Honest question: Isn’t strncpy good enough if you copy N characters to an array of N+1 bytes, and set the last byte to NULL? I see why strlcpy is better, but sometimes people would rather use the standard stuff.
This may be a baseless rumor, but I’ve heard you can do anything with C
If the source is known always to be shorter than the destination, then `strcpy` is just as good as `strncpy`. So `strncpy` is no improvement. If you want to reliably terminate it yourself after using `strncpy`, then you probably have a wrapper function. What, then, is the advantage of using "standard stuff"? You might as well hand-code the whole "wrapper" function and not bother with `strncpy`. If I misunderstood your point, could you show some example code that illustrates your point please?
If that was the case it would be hardcoded and too easy.
Do you think this bug only happens on 32-bit computing system ? Because I just told my brother about this, he executed the code and the result he got was exactly d = 0.000000000. I'm using 32-bit OS while my brother uses 64-bit.
`gets` is long-since deprecated and a thorough menace of a function.
I guess I’m just wondering why strncpy is still being taught. Is it just because strlcpy isn’t available on all systems? The use case is unknown source length and known destination size.
Thank you very much! You are all very helpful.
Yep, 32 / 64 get different results (gcc = 7.3.1): ``` &gt; gcc -m32 test.c ;and echo 4.05 9 5 | ./a.out Please enter input a, b, c: d = -0.000003814697266 False.⏎ jamesr@james-ubook ~&gt; gcc -m64 test.c ;and echo 4.05 9 5 | ./a.out Please enter input a, b, c: d = 0.000000000000000 ``` Even converting to doubles leaves the bug in. This stackoverlow explains why: https://stackoverflow.com/questions/10808601/different-behaviour-or-sqrt-when-compiled-with-64-or-32-bits ``` &gt; gcc -m64 -mfpmath=387 test.c ;and echo 4.05 9 5 | ./a.out Please enter input a, b, c: d = 0.000000000000004 False.⏎ jamesr@james-ubook ~&gt; gcc -m64 test.c ;and echo 4.05 9 5 | ./a.out Please enter input a, b, c: d = 0.000000000000000 ```
&gt; I don't need of copy and past.I don't care what you say. so please i don't want to talk you more.. That's real fucking neato.
[https://pastebin.com/BvwuPivZ](https://pastebin.com/BvwuPivZ) There you go again....
There is literally no way for anyone to give you a yes or no answer. For x86 specifically (which is a more important piece of information than the address width) the bit-ness of the OS is quasi-irrelevant—it’s what subset of hardware on the chip your program is using, which is usually handled by compilers as an ABI variant. (But they can configure which they use independently of the OS.) If you’re using the x87 FPU, then everything gets promoted to `long double` on the way into the FPU stack and (usually) truncated/rounded to `double`/`float` on the way out. Usually 32-bit code uses the x87 unless it’s told it can rely on there being something less unpleasant to use. If you’re using SSE (an example of something less unpleasant) but not SSE2, then 32-bit floats will use the XMM registers and SSE instructions (which typically work on exactly-32-bit operands, although IIRC chips are theoretically allowed to work in wider formats internally) but 64- and 80+-bit floats will use the x87. If you use SSE2 or any of the newer extensions (e.g., AVX, AVX2, AVX512\*), then both 32- and 64-bit floats use XMM/YMM/ZMM and only 80+-bit floats will use the x87. Usually 64-bit code uses SSE2, so if your brother was using SSE2 and you were using x87, the difference in precision could’ve truncated things differently. But again, none of this is specified by the C standard; there’s a handwavy minimum precision &amp; exponent range set up by the standard, and that’s all you get. Floating-point numbers are fuzz around some center point, so you’ll have to work with them quite a bit more defensively than you would with integers. Rather than testing `d == 0`, it’ll have to be `fabs(d) &lt; EPSILON` for some acceptable `EPSILON`.
lmfao [https://pastebin.com/BvwuPivZ](https://pastebin.com/BvwuPivZ)
strncpy is still being taught because instructors didn't read the documentation, or didn't understand the problems. This is quite common. The same issue also applies to other standard C library functions including * atoi, atol * scanf * tmpnam * strtok * longjmp * [signal](https://wiki.sei.cmu.edu/confluence/display/c/SIG34-C.+Do+not+call+signal()+from+within+interruptible+signal+handlers) * fflush(stdin) There are other useless or dangerous library functions whose uselessness or dangerousness is better known: * gets * brk (nit: this is POSIX but not portable C)
I don't see what's so advanced about it. Sure, *some* of these are pretty involved, but there are plenty that are only a couple of small understandable operations.
Thanks for the tips and explanation!
OP might find it interesting to read Douglas R. Hofstadter's book ]Fluid Concepts and Creative Analogies](https://en.wikipedia.org/wiki/Fluid_Concepts_and_Creative_Analogies), especially chapter 1. Or Marsha Meredith's related [Ph.D thesis](https://www.researchgate.net/publication/34025447_Seek-whence_a_model_of_pattern_perception).
You can use Newton polynomials to extrapolate, this will always work assuming the sequence of `n` terms is a polynomial of degree `n-1`. It uses the forward finite difference `D(x(n)) = x(n+1) - x(n)` to get successive "derivatives" and then you simply "integrate" (summ) those. If you did calculus this should strike you very similar to the Taylor series approx. However easiest is to just query OEIS :^)
&gt; I cannot find any example that I understand of what a conditional variable is or how to solve this problem. Condition variables let your thread wait until something happens, and then unblock it. So your thread could wait on a CV that is signaled when it has a job to do. I'd probably use some kind of thread-safe FIFO to decouple the producer and consumer threads in this case, but I don't know what the constraints are on your design. The top answer here has correct code for blocking on and signaling pthread condition varables: https://stackoverflow.com/questions/20772476/when-to-use-pthread-condition-variables
Yeah I think I suggested the same thing last time
It can be generalized to any nth degree polynomial, see my answer below. eg: say you have:` x(k) = 1, 3, 6, 10...` Assume the answer is a polynomial and compute the forward differences: x_1(k) = 2 3 4 Computing 2nd order forward differences x_2(k) = 1 1 Computing 3rd order forward differences: x_3(k) = 0 Like with derivatives/integrals: summation (integration) cancels the finite difference (derivative): sum(x_3(k) for k in 0..n) = x_2(n+1) - x_2(0) So by repeated summation: x_2(k) = 1, x_1(k) = k+2, and finally x(k) = (k+1)(k+2)/2 We only actually needed 3 terms, not 4, to get the right answer because x_3(k) = 0.
Processors would wait for dtack. So you would hang without one. That's why dtack on some systems, certainly not all, was grounded. I am unaware of any engineer that would seriously consider grounding dtack in any production environment. That can only be a hobbyist thing.
Timing has everything to do with knowing when an operation on an asynchronous memory is complete, because asynchronous memories provide no other indication. One may look disdainfully at asynchronous memory designs, but they formed the basis of 99% of twentieth-century home computers (there might be some obscure exceptions, but I know of none).
Instead of re-using threads, consider just joining your threads and starting new ones as needed.
I thought about that, but unfortunately join() only returns when all 4 threads are done, rather than when the first thread is done. The threads do not have balanced work-loads!
Ah, I see. In this case, you can consider a design where instead of having a single thread that gives out work, each thread serves itself with the code section to give out work being guarded by a lock. Once all work has been given out, the threads terminate themselves.
Thanks! I need to re-read that last one a few more times; it describes perfectly what I want to do.
I'll look into all of those, thanks. (My last calculus class finished in 1992, but I'm watching 3Blue1Brown videos as a refresher.)
That actually sounds like an idea that would work. So each thread uses a critical section to "ask" for the next work, and main() just joins onto all of the threads until every last one is complete. I think that will work, I'll have to try it when I get home from work!
My advice is to go through the exercises in “Automate the boring stuff with Python”. This is most likely not a problem you should solve with C (although you technically could) People are not likely to “sign up” to develop your app for you. The book I mentioned would take you maybe a month max and would leave you in a position to automate web browsers and desktop applications like Word and Excel. It would also make or possible for you to manipulate files on the local disk if you want to do something like open PDFs to study from. Most importantly it would teach you what challenges exist when you are programming. Saying you “have the vision” only means something if you also have a general understanding of what goes into creating something.
I like [json-c](https://github.com/json-c/json-c). It works well for my purposes.
You are totally clueless.
Yeah, that sounds like a good idea!
AS this IS factoring, test an AI, and have the AI predict 612 Commandments because you give it the first one. I DARE YOU. #S
If you are allowed enough predictions, I suppose you'd eventually prove to be prophetic.
This subreddit is about programming in C, not Javascript.
This is cool - but what does it have to do with C programming?
I was confused.
Considering Watson has one chance, far be it from me because law IS correct. Hence, the mathematics. And the axiom must be correct once, the maxim must be correct once, and the concept must be correct once. And the science must be correct once: falsifiable proof IS robust, and requires the mathematics. Can you imagine the 'Countdown to Midnight' and Armageddon incorrect against one second? Millions: lives depending against one second require verifiable standards. Against a testless community, the AI-led state IS doomed against evil men and witches. And sorcerers--a DC guy, I AM.
I wrote one called [pdjson](https://github.com/skeeto/pdjson).
I'm new to C, so besides the problem I'm trying to solve (some great ideas in the responses), I'm also fishing for comments on how to improve my code: I should do this, I could do that, ... those sorts of things.
I don't know about good, but I usually just use cJSON because it's easy to embed directly in a project - just a header and source file.
Wat
Well considering the ALT, I want law correct one time, and that is it.
I still use scanf() a lot in my internal tools for calculating quick stuff, here's a quick hack + example usage that will get scanf() handling mistaken inputs: #define clearbuffer(x) int c;while((c=getchar())!='\n'&amp;&amp;c!=EOF); while(1) { uint64_t input; printf("Number: "); if (scanf("%llu", &amp;input) == 1) { printf("The number is: %llu\n", input); } clearbuffer(); }
You need to malloc(sizeof(int) * 4)
If you are already decent and in C, is suggest picking c++ or c#. You’ll want to be decent in JavaScript. I wouldn’t worry about the smaller languages. You need to be good at something. Pick it and stop worrying about which one is the best.
You're not 'too old' for C, in fact C is a decade older than you. If you want to learn C definitely do so and you'll get a strong CS foundation, use it to learn how to solve problems, automate tasks etc. Python and Java are also good to learn (or at the very least throw on your resume) As for the newer languages you mentioned Rust and GoLang, they still have some time before they're adopted by industry. Go is getting attention mainly because of the large company backing it. Rust is interesting because it could take the role of C in the future but until it gets a standard specification like C has, I doubt industry is ready to adopt it. IMO better to get a strong foundation over CS and be able to quickly learn new technologies when required instead of chasing the new thing - who knows whats going to last and whats not. Hopefully, I answered what you're asking :)
Instead of moving the array pointer, it’d be much easier to put for (i = 0; i &lt; 4; i++) { array[i] = readonly[i]; } Rule of thumb: don’t declare variables midfunction, do it all up top first and add to the list as you go.
`int* readonly = {1,2,3,4};` is invalid code. If you don't see an error message then change your compiler settings until you do get an error message. The code should be `const int readonly[] = { 1, 2, 3, 4 };`. Also you don't malloc enough space, the argument to malloc is the number of bytes, not the number of array elements you will store in there.
Definitely, could I get some resources on how to build stable and secure C? and what blogs have best practice updates. I would just work with Python as well to help broaden the job market for me and provide simpler methods to glue a system together. I know enough Java to land a junior C# or Java position, I just need to work on the algo's and Leetcode myself to death. I know for a fact that if I focus on building secure C, then all other languages will be purely a syntactical issue. Obviously I will work on something like C then inevitably a recruiter will reach out for a Java position, but what can you do? I have Javascript and React so I guess that is what could make me money in the beginning, but I care more about refining my trade to have a unique competency. Really, this has nothing to do with money but I just enjoy the community of programming as well as the challenge that a language like C brings out!
This is bad advice, the srand should only be called once in the program. Typically it uses the number of seconds on the clock, so: * it will restart the same random sequence since the program runs in under a second. * in some applications this can lead to a security flaw as the program may be launched multiple times in the same second; or an attacker can set the system clock to a desired value and then launch the program.
I'm a fan of the book [21st century C](https://www.amazon.com/21st-Century-Tips-New-School/dp/1449327141) it has a lot of focus on things that other books don't seem to focus on like using libraries and makefiles - stuff like that. [C notes for professionals](https://books.goalkicker.com/CBook/) is a nice reference for writing C its also a free PDF so nice to just have. I don't really look at programming blogs too much but a lot of the posts on the subreddit are from blogs you could probably sort by highest of all time to look at the good ones. Personally, I learned a lot of algorithms and data structures by taking python standard libraries and writing them in C and its been helpful to use some of them in my personal projects.
&gt; Am I too old to get involved with C for a career? lol hell no You should pick up an Arduino (or knock-off). They are dirt cheap ($10 - $20) and a great way to learn circuit design, C &amp; C++ programming, and the types of techniques that can aid your career as a mathematician. Arduino's main IDE uses a C++ compiler, but you can "code C" using it as well. IAR Workbench is free and has an amazing C compiler for embedded systems. If you're interested in simple circuit design, Eagle is a free (and cheap paid $15/month) PCB design software environment, Sparkfun has great intro tutorials for it. In a little over 2 years, I went from not knowing anything about electrical engineering &amp; hardware programming, to manufacturing PCB circuit boards at OSH Park and building complex circuits &amp; systems for use in commercial systems. When I started I didn't even know what capacitors or MOSFET's were, now I use them regularly without having to think about it. You're never too old to learn new stuff (I am 35), and it's **crazy** how much free information, free learning, and free/affordable software is out there. Between YouTube video guides, websites, Wikipedia, and Reddit, you can pretty much teach yourself anything at home, in your free time. https://www.arduino.cc https://www.iar.com/iar-embedded-workbench/ https://learn.sparkfun.com/tutorials/using-eagle-schematic/all https://oshpark.com
Cool, I will definitely note this down. So, the embedded job market just looks for skills not an EE or CpE next to your college?
What kind of job your program does? You can give a look to OpenMP which basically provides annotations to make a simple serial program run in multiple threads.
Thank you for sharing :)
What's the use of word = strtok(NULL, " "); ?
Big O notation is generally accepted to mean worst case run time. Omega notation would be for best case.
in Q.1) when I try using only string\_input it prints olleH only what ever the case may be.
Please clarify the four questions. Also thanks for the solution. I didn't knew about strtok() function. C book I am referring doesn't mention it. It solved a great headache.
We've already made the choice to look at your post. This isn't a Telltale game, make it so that helping you requires minimal effort for best results.
Also how to write clean code like yours. like using char c\[strlen(input)\] , if(){return 0;}. Trimming down code lines etc. Any coding practices you follow, books etc. ?
i used JSMN on ARM microcontroller [https://zserge.com/jsmn.html](https://zserge.com/jsmn.html)
You are not too old. Dennis Ritchie, the creator of C, was around 32 at the time of creating the language.
I've used jansson and it's pretty good. Only needed the basics though so it may lack some features I'm not aware of.
One open source project I've worked with has used [yajl](https://lloyd.github.io/yajl/) for the past 10 years. There was a recent attempt to convert it to [Jansson](http://www.digip.org/jansson/), however this had to be aborted as Jansson could not be made to work with the externally-generated JSON data. JSON leaves some things implementation-defined, and yajl, but not Jansson, was flexible enough to deal with that.
ArduinoJson. Its not quite limited to arduino as the name suggests.. It is quite easily as applicable to other platforms.. And pretty exhaustive documentation.
I respect you for doing Win32 systems programming.
What does it mean for a machine to 'use' C? People use C to write programs for embedded devices, but what actually runs on the device is machine code.
Many, if not most, Operating Systems are written in C. Small, fast, system programs that you never see or interact with (the programs that run your keyboard, network card, drives, memory, file systems, mouse, monitor, etc...) are almost all, always written in C. Almost everything that is "close to the metal", meaning related to the actual, physical hardware of a system is written in C. In addition, many programs that need to be very fast are written in C. This could be anything from simulations to games to control systems for airliners. But also window managers, graphics compositors, so many other things, are often written in C.
3D printers. That's my job to make it work as good as it can with as little memory used as possible.
I'm using this right now for a project that I'll be releasing soon.
For example, does a microwave have any C programming in it?
Nope, just machine code. But when the developers were writing the code, they were probably writing in C.
Having written a lot of MT code, this is the answer I would also give.
That's certainly what I've used when programming microwave ovens, regular ovens too.
Some of the things I've programmed using C: Laboratory equipment, radios, appliances, tractors, trains, motion detectors, lights. security systems.
Your android phone. Running linux which is written in C. If that's what you mean.
The rover Curiosity.
Most. Washing machines, your car, mobile phones. If your credit card have a chip, its core was written in C. Your mouse. Your USB flash device. It would be hard for me to think of any semi advanced electrical device that don’t run anything compiled from C.
If it has a micro controller or micro processor on it, there most likely some aspect of the code on it written in C
digital electronic devices, for example.
I work writing firmware for payment terminals - you know those Pinpads where you do payments at shops. Ours are all written in C.
Q.1) Because of how strtok() works. Strtok doesn’t leave the string untouched but it puts a ‘\0’ in the place of the first token it encounters when called. Using string_input directly will give you problems when further on using strstr() Q.2) No, it shouldn’t. Arrays are numbered from 0 to n, therefore the ‘$’ sign is at n - 1, not n. Q.3) it keeps looking for other spaces in string_input_copy. NULL is used bc strtok keeps the position of the last occurrence of the token, so by using NULL, it will just keep on looking from there, giving you a new word at each run. Q.4) yea, you should. I simply forgot to do it as I wrote that code in 15 minutes I wrote this code very very quickly just to show you how it works, you can probably tweak it to make it more efficient and make it run faster
Aircraft navigation systems, flight controls, and communication systems. And I know you specified machines, but be aware C underpins other languages as well: check out cpython, which is the reference implementation of Python.
If it has a computer, it uses C and/or C++ and/or Objective C. Your Windows computer, your Mac, your Linux computer, your TV, your stereo, your microwave, your phone, your router, your smart watch, everything. The USB cable you connect to your iPhone has a microprocessor in it, and it runs C. C is the language that all the other languages are written in.
&gt;This is purely out of curiosity Sounds a bit like homework ;) Your query has been answered elsewhere, so here's a follow-up question yourself: What do you as a programming language? How would you describe one? Do you know the difference between source code and compiled code (for those languages that are intended to be compiled)
To clarify, the microwave was programmed in C, but the C code was translated into the microwave's native machine language before being installed in the microwave's chips. All C code is translated to the processor's native machine code before being executed, and very few devices actually have a C compiler installed. The C is compiled by some other machine and then uploaded to the device in the factory.
Your operating system and everything you use that contains an operating system including those that don't.
And the homework questions these days seem exceedingly simple and trivially google-able. Yet OP is here ...
Holy cow. So much stuff. I can just tell you about some of the stuff that I've worked on. Your car. Just the stereo system alone has at least two chips (microcontroller and DSP) both running software written in C. Air traffic control systems. Tons of components written in C. Everything from the radar processors to the displays the controllers are looking at, plus everything in between - racks and racks of systems all interconnected running software primarily developed in C.
I've also used this library.
In the automotive sector there is a heavy push to move away from writing C code by hand and instead use an environment like Simulink to generate the C code automatically from a graphical model. The C code produced from these environments can be fairly obtuse to a human reader, so in the end you're treating it in much the same way you'd treat the assembly code that comes out of your compiler. It's there, but you only really dig into it when things are going wrong you can't debug at the higher level.
cprogramming.com has always been decent, ever since I first encountered it back in the late 90s as a kid.
I know people get upset when I reccommend K&amp;R the C programming language but I genuinely believe it's the best run down of C without being super bloated like most other text. It isn't made for complete beginners but if you know enough about C to use loops then you know enough to get through K&amp;R. It also has some of the best C exercise problems I've ever seen in text which are really important if you want to be any good at writing C (so don't skip the exercises)
Some people read poetry to get inspired. I read a random chapter from k&amp;r... I also don't have many hobbies.
Thanks, looks like something for me, tutorials and practises. I will try that
Thanks, have to look that up!
If you want to build gcc in a Windows environment, you will probably need something like https://www.cygwin.com/ or http://www.mingw.org/. The new "Windows Subsystem for Linux" should be able to run a Linux gcc binary, but I don't know if it is capable of easily building it from source. It also wouldn't be hard to run a VM with a lightweight Linux distribution and do your development on that. If you want to work with gcc in particular you may have an easier time using an actual Linux environment. If you just want to compile C programs on Windows you can also use Visual Studio.
gcc is a horrible compiler to try to use to learn about how compilers work, for several reasons. You would be far better off starting by trying to understand a simpler compiler. There are several books on designing and writing compilers that might be a decent place to start. Building gcc on Windows is not a trivial exercise. I am of the opinion that UNIX/Linux-based systems are superior environments for learning to code in C. I certainly find the POSIX and similar interfaces less daunting than the Windows APIs. My personal preference is for FreeBSD, but some Linux variant is not a bad choice.
Thanks for your precious time and advice
Yes, you'll have a far better time building GCC in WSL or Linux. In that environment it's actually a very straightforward process: run the configure script, then make. In Windows you'd have to use something like msys and it would be a real mess.
If you're math literate, you should try a language like Haskell. Functional languages don't deal with state, which might be your issue. What school are you attending?
I've never tried or had a need to build GCC on windows so I can't help you there, but I don't think a massive 30-year-old codebase is a good place to start if you're trying to learn how to write a compiler. Why not get some good books/other learning material on it and start from the basics? And yes, Linux is probably a better choice unless you specifically need to develop for Windows.
Take a look at Mingw. Getting GCC up on Windows is a significant task. You could look at a compatibility layer like Cygwin, but then you're using a porting layer, which then you might as well go back to UNIX/Linux.
Tip: You might be interested in the "strict-ansi" branch. It's tidied up, though I do make breaking changes on that branch from time to time. There are enough people using the master branch directly that I'm careful to leave things be.
Thanks for the tip. I’ll be switching soon as im interested in strict compatibility
C17 and C18 are the same thing, just that nobody quite agrees on the nickname yet. It's really just to clarify some issues with C11, so there's nothing to really "upgrade" to. Unless you're a C compiler writer, you can basically ignore it.
Why? I don't think C17/C18 (the latest standard) introduced anything new vs C11 for non language lawyers, but as a general rule, unless you actually *need* some new language feature and/or they significantly improve the language (a la C++11/14), you should favor more stable, widely supported version of the language.
I admire your enthusiasm. I would also recommend K&amp;R if you're looking for a book. But if you want a more involved learning experience why not check out online courses from top universities like Stanford, Harvard and MIT? [Like these courses](https://www.edx.org/learn/c-programming)
&gt; gcc is a horrible compiler to try to use to learn about how compilers work I don't disagree, but I'm curious about what reasons exactly make it horrible for this. I guess it's extremely complex, but is there anything else?
I'm glad i finally have enthusiasm for something, hated school always because i knew that don't want to do anything where i need information what i get from shcool, then i tried using c++ with unity and made some shitty project games to learn basics and i realised that i like programming. I have to check those courses out, thanks! We don't have courses like that in Finland yet.
Glad to hear you've found something you like. Keep at it, learning programming is not a very easy task, but keep at it. It also helps a lot if you actually like it. You're going to do great things my friend.
The way I've heard it, for years the GCC devs deliberately tried to make the GCC codebase difficult to understand because they didn't want other projects to be able to build on it in ways that they didn't approve of.
Not OP, but gcc is not just a C compiler, but a compiling platform (gcc = GNU Compiler Collection), meaning one would need to understand much of its underlying infrastructure to make sense of it. It's also highly portable, which would require knowledge of multiple ASM languages and the differences between them to make sense of it.
One page of K&amp;R per service day. Maybe slip it inside a magazine of some kind :)
White collar corporate jobs that rely on government assistance like aerospace &amp; military can only ever hire graduates with degrees (by regulation). They are not allowed to hire degree-less individuals irregardless of their skillset. Those jobs are high paying, but boring and projects move along a snails pace. Private sector companies will hire anyone they think can earn them a dollar, they've never looked at my education history (none). I show up with a long list of projects I've designed and manufactured, complete with pictures and videos, and I am hired/contracted. I mostly do prototyping and design now, it's fast paced, fun, and I am constantly learning new things.
Maybe start with a different language and a guide? I have been following [Robert Nystrom's book](https://craftinginterpreters.com) for some time now.
*Reading this thread while compiling with -std=c89*
sweet, any chance I could get a short list to get me started? I am going to go out and get an arduino and start pushing out some small projects. I am thinking a gyroscopic sensor mixed with AR would be a decent portfolio piece. Ya give meh hope.
You can benchmark a number of JSON implementations on [miloyip/nativejson-benchmark](https://github.com/miloyip/nativejson-benchmark). I authored [JSON support for facil.io](http://facil.io/0.7.x/fiobj_json) and I'm currently working on [a single header library that will include a JSON parser and soft-types](https://github.com/boazsegev/facil.io/blob/763532bf10330038056cb93cf963f0a74879db6f/lib/facil/fio-stl.h). Even though the benchmark runs a slower, older, facil.io version, I think you will find it impressive enough. You will also notice that string conformance is better than some other C options. Besides allowing for some non-standard JSON options (comments, dangling C-style commas, etc'), the soft-types (`FIOBJ`) offer a real advantage. These types include Arrays, Hash Maps, dynamic Strings, etc'. Everything you need both for JSON and for general use. The Hash Maps are collisions and attack resistant, which makes it safer to process unknown data (as long as it's NUL terminated). The current version (0.7.x) is used in the iodine Ruby server, so it get's decent use. The only issue that requires attention / reconsideration is [the floating point conversion function](https://github.com/boazsegev/facil.io/blob/763532bf10330038056cb93cf963f0a74879db6f/lib/facil/fio-stl.h#L2425-L2426) (which I'm quietly (re)writing). This issue is true for many libraries. Depending on your compiler and system, the `strtod` has a nasty (and useless) habit of calling `strlen`. Not only is it a performance hog for big payloads, it's also exposing the application to possible out-of-bounds access if the input data isn't NUL terminated.
And besides being C++, it's very [**slow**](http://facil.io/0.7.x/json_performance.html).
&gt;many programs that need to be very fast are written in C. This could be anything from simulations to games to control systems for airliners. Chemist here. Unfortunately this statement is getting more and more invalid with time. I use programming to run molecular simulations. While I'm exclusively using C with inline assembly, and sometimes FORTRAN (my profs use it for everything), I'm the only one to do so. The entirety of my classmates - ALL of them, with no exception, all use Python and MATLAB. The "programs that need to be fast" are all getting ported to those fancy new languages. It makes sense, as Python is *fast as fuck boi*. But I just don't want to make the switch. I started studying computer science with C, I got all my experience with C, and even when I dropped out to study chem - I still used C. **I will use C until my death**. My profs are doing the same thing: they started using FORTRAN, they still use FORTRAN, and they will use FORTRAN until their death. The world is changing, and new programmers are being taught new techniques. Will we see the death of C? **Never.** But the days of hardcoding your own stuff are gone for good. Python WILL dominate the programming scene.
What do you think “upgrading” to a new standard involves?
Isn't Curiosity running on VxWorks too?
&gt; It makes sense, as Python is fast as fuck boi. haha... modern CPUs are fast as fuck, Python itself is a slow, interpreted language. The high-performance routines are likely written in C or C++. But that's the thing about performance - 98% of code isn't performance critical, and most CPU-intensive applications spend 90% of their time in a handful of functions, so in a resource unconstrained environment, only that code *needs* to be native.
I know it isn't easy and that is maybe one of the reasons why i like it. Thanks for nice words and suggestions!
Few have suggested that, have to check it out, thanks.
No prob, good luck!
Probably figuring out why the code doesn't compile anymore.
I learned from memorizing functions and small programs until I could write a full program on my own. I taught myself, too. I can attest to it being one of the easier and more effective methods because I was a dumb 13 year old when I started, so if it wasn’t easy, I wasn’t learning. As for material to study, memorize, and practice, I’ve found that the most informative and well written material is not always the most effective learning material. Literally speaking, you could read and memorize the C standard — it’s well written, thorough, and informative. Practically speaking, it’s probably best to pick up a book or a bunch of articles and guides implemented in C on a specific topic that you’re interested in. I started with graphics programming. What are your interests? Maybe I could help find you some material. Best of luck. Cheers.
Well i have made some basic projects in unity with C++ and i have liked making games (very very simple games), problem is that i would like to learn about C as i mentioned i will need that when i start in that school.
Yes, and VxWorks uses mostly C
I thought Unity was scripted in C#. Anyway, unfortunately most c graphics libraries rely on a lot of boilerplate code (code that you need just to set up the environment to display something). On the bright side, a lot of this is cross platform and more or less rinse and repeatable — allowing you to focus on programming once you do get your environment set up. I can vouch for SDL. It’s widely used, relatively simple, and fast. There are many good tutorials for SDL out there, both video-based and text-based (you can find them both on YouTube and in independent articles). Would you like me to point you to some articles and videos for C SDL?
Here’s the C reference card: https://users.ece.utexas.edu/~adnan/c-refcard.pdf Trust me, you’ll need it.
It is huge. It is old. It is not just a simple C compiler. gcc stands for gnu compiler collection. It compiles [C, C++, Objective-C, Objective-C++, Fortran, Ada, D, G, and BRIG (HSAIL)](https://gcc.gnu.org/onlinedocs/gcc/G_002b_002b-and-GCC.html) to [these many architectures](https://gcc.gnu.org/backends.html) on almost any platform you, your father, and your grand father have ever heard of, which makes for the most horrid #ifdef soup humanity have ever dreamed of. Don't even start me on the autohell blackmagic that actually compiles it.
You never set `i` to an valid address/pointer, so the `*i = 4` invokes undefined behaviour, where everything can happen: The program continues normally, the program corrupts sliently, crash, etc.
You are trying to dereference a pointer you haven't initialized to point at anything.
I worked with FORTRAN today, though I at least use C99 and C++03 too. If it weren't for sun/ibm compilers I'd use C++14 :(
&gt; Yet OP is here ... They get a tailored answer that won't show up in the plagiarism filter ;)
I've seen a lot of code examples out there doing the same and they work fine. I found the solution though. I had to change TDM-GCC 4.9.2 64-bit Release to TDM-GCC 4.9.2 64-bit Profiling. Looks like it was the ide.
What means does e.g. a 27C256 (32Kx8 EPROM), 41256 (256x1 DRAM), or 61256 (32Kx8 SRAM) offer to indicate when a memory operation is done, beyond a guarantee that cycles will complete sometime within a period of time which is based upon the speed grade? If one wants to trap invalid addresses, what advantage is there to hanging the processor on /DTACK and using a watchdog to trigger /BERR, rather than simply triggering /BERR directly?
No, no, no. If you saw any other examples that looked like this, *they were wrong*. Your fix isn't actually fixing anything, it's only masking the behavior. The most frustrating thing about undefined behavior is that sometimes the behavior is exactly what you wanted in the first place. Making the problem go away doesn't mean the problem doesn't exist, it means that it'll come back to bite you another day.
The code you have here doesn’t and cannot “work fine”. You’re accessing a pointer that points somewhere random.
Oh, meant c#. That was few monts ago before my finals and I used visual studio so many times at start I was confused of which language I used. Thanks a lot for those linkss, going to check those out at home!
&gt; The new "Windows Subsystem for Linux" should be able to run a Linux gcc binary, but I don't know if it is capable of easily building it from source. It's basically a GNU userland running on top of a Linux emulation layer. It can do anything a regular Linux machine can do.
That shouldn't happen, unless the code was buggy to begin with.
Or because code relied upon what the authors of the Standard call "popular extensions" to make the language suitable for their intended purposes, but the current compiler assumes that code won't make use of such extensions and thus does not support them. The Standard does not require that any particular implementation be usable as a "high-level assembler", but the authors have explicitly stated that they did not wish to preclude the use of the language in that fashion when targeting implementations that are suitable for that purpose.
You most certainly, absolutely cannot. The reason why has to do with how pointers actually work: https://en.wikipedia.org/wiki/Pointer_(computer_programming)
Here’s code that will do what you want, by the way: ‘int foo; int * foo_ptr = &amp;foo; *foo_ptr = 4; [etc]’
 int *i; int p = 4; i = &amp;p; printf('i = %d", *i);
GCC even warns: jag_N.c: In function ‘main’: jag_N.c:6:4: warning: ‘i’ is used uninitialized in this function [-Wuninitialized] *i = 4; ~~~^~~ And when trying to execute: jag_N.c:6:4: runtime error: store to null pointer of type 'int' ASAN:DEADLYSIGNAL ================================================================= ==9430==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x55932f41bc12 bp 0x7ffd31964410 sp 0x7ffd31964400 T0) ==9430==The signal is caused by a WRITE memory access. ==9430==Hint: address points to the zero page. #0 0x55932f41bc11 in main (/tmp/a.out+0xc11) #1 0x7f6bccd56b96 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b96) #2 0x55932f41bac9 in _start (/tmp/a.out+0xac9) AddressSanitizer can not provide additional info. SUMMARY: AddressSanitizer: SEGV (/tmp/a.out+0xc11) in main ==9430==ABORTING
How I haven't seen that when googling C tutorials, I see how useful it is
Ouch!!! I did not know that... TIL moment!!! Wow... it really really is slow... &amp;#x200B; Thank you for the information.. :-)
Alternatively you can alloc memory for your pointer: ```c int *i; i = (int*) malloc(sizeof(int)); *i = 5; printf("i = %d", *i); ```
C17 and C18 are the same thing, and they only fix very minor details in C11. Clang and GCC export an option for that, but in IDEs like Xcode those fixes are enabled behind the C11 standard label.
I prefer C18 myself to distinguish it from C++17.
&gt; many programs that need to be very fast are written in C. This could be anything from simulations to games to control systems for airliners. Chemist here. Unfortunately this statement is getting more and more invalid with time. And python interpreter is written in ...? Is python then just a nice scripting language top of ....?
Your point is invalid. C is not taught. Python is taught. It doesn't matter what your Python implementation is made from.
Note that timer in question was an analog circuit which used two resistors and a capacitor to control the blink frequency. Unlike some devices where an "approximately 2Hz" blink is on for exactly 16 frames and off for exactly 16 frames, each each frame duration could be computed within 0.001%, the blink rate in question was controlled by the values of two resistors and a capacitor, and could thus vary by a few percent between one machine and the next.
cJSON looks great, but I couldn't adopt it when I needed a JSON solution. The cJSON data structure [appears to use nested linked lists](https://github.com/DaveGamble/cJSON#data-structure) and incurs a high look-up cost for key-value pairs. This make cJSON [wonderful for linear JSON consumption and "pass-through" implementations, but sub-par for JSON output, lookup and manipulation](http://facil.io/0.7.x/json_performance.html). In contrast, the solution I ended up with uses actual reference-counted soft-typed objects that behave as expected (Arrays are actual arrays, not linked lists, Hash Maps are actual hash maps, etc'). I might be biased in favor of [facil.io](http://facil.io/0.7.x/fiobj_json), but that's my 2¢.
Perhaps it is invalid. You can use python until some extent. But if you want to master it, you most likely want to know how interpreter really works. For that you need to learn C. But I agree with you. For regular python developer there is no absolute need to know for example how pointer arithmetics works. But if you want to develop yourself further, you should know it.
C was invented to give programmers *control* over what a machine was doing. In many cases, this made it possible for a *simple* compiler generate more efficient machine code than would be possible with *comparably-simple* compilers for other languages, because programmers would know what operations were needed to accomplish what needed to be done, and could help compilers avoid redundant calculations. C was never designed to maximize the quality of code that could be generated by a more sophisticated compiler. The Standard tries to facilitate optimization by allowing implementations specialized for purposes not involving low-level programming to take away the sort of control that made the language uniquely powerful for low-level programming tasks, but it fails to provide any useful guidance about how low-level programming tasks should be accommodated by compilers and programmers.
Languages like Python and Javascript can be interpreted, or they can be processed by implementations that include just-in-time compilers. A just-in-time compiler can mitigate the performance costs of what would seem like expensive parts of a language. For example, given code to index elements numerically from one object, add 1.0, and write the results to another object, a Javascript implementation might process the code a few times with the interpreter, realize that every time the function is called the objects seem to be arrays with nothing in them but floating-point values, and then generate machine code for the function that will check whether its arguments identify "simple" floating-point arrays and either process them efficiently as such or fall back to running the interpreter if it's passed something else. Many JITted languages give implementations the flexibility they need to make optimizations a C compiler can't. They may not have caught up with C yet, but they will. The one field C will remain useful is the one that some compiler writers likes to pretend doesn't exist--in producing low-level code that does things compilers can't be expected to understand.
There's a reason I said *I don't know about good*. But it works well enough I haven't been motivated to find or write another no-external-dependency-needed replacement.
GCC switched to C++ around 2010 or shortly after. Most of the code is written in what’s considered the C subset of C++. Clang is also written in C++, as well as the LLVM backend. https://lwn.net/Articles/542457/ You can check out TinyCC which is a C compiler written in C. The codebase is smaller and easier to grok.
How about int i;
The standard python runtime most people use is still purely interpreted, isn't it? I know about implementations like PyPy, but I haven't had enough need for performance-optimized python to know much about why it hasn't really caught on. &gt; Many JITted languages give implementations the flexibility they need to make optimizations a C compiler can't. But the high-level, dynamic nature of these languages also means there's a mandatory overhead in validating that the optimizing assumptions still hold up (to say nothing of requiring a pretty heavyweight runtime and up-front CPU power to do all the optimization). I'm not knowledgeable enough about the guts of JIT engines to know exactly how significant the runtime overhead is, but I suspect that things like WebAssembly and compiled native modules are going to stay relevant for the performance-critical parts of high-level code, especially with single-thread performance growing more and more stagnant as we reach the physical limits of what we can do with semiconductors.
 [https://www.xkcd.com/378/](https://www.xkcd.com/378/) But I agree, no real need to upgrade.
That's really clever. Good job, if it's yours. Hint: The magic ingredient is octal.
I don't know what's been done with Python, but node.js does pretty well with Javascript, which would seem like it would be even less amenable to optimization. Given something like: &amp;#x200B; void addFloats(float \*p1, float \*p2, int n) { for (int i=0; i&lt;n; i++) p1\[i\] += p2\[i\]; } &amp;#x200B; a C compiler must determine each time the function is called whether it can be safely and usefully vectorized, without anywhere to keep track of such things. A language which was actually designed for high-performance computation would allow for the possibility that \`p1\` and \`p2\` might be equal or identify disjoint portions of arrays, without having to allow for the possibility that they might identify overlapping parts of the same array.
what was your problem with the AC part, do you need some help?
I'd honestly find an explicit array of octal or hexadecimal values to be a lot clearer.
Isn't K&amp;R outdated? Honest question
That's not reddit, that's the URLs themselves.
Not really, no. Not much has changed to become outdated.
Jansson.
IMO this is a silly tack to take. You should use whatever language you're most productive in, and while that may be c, I doubt that's c + inline assembly, and it could very well be python or matlab, especially if the ecosystem is better.
Don't credit cards use java?
Oh, so I was misled then! Thanks for the clarification :D
Ehhh The architecture/language stuff is afaik actually nicely polymorphically pluggable. Unfortunately, it *still* has awful ifdef soup, which arguably makes it even worse!
As others have mentioned, you *can* build gcc, but it is not a good place to learn how to make your own interpreter or compiler. *EVEN IF* its code were clean, it wouldn't be a good place to start, because it still has millions of lines of code, handling all sorts of edge cases you shouldn't begin to think about. I would recommend taking a look at the book [crafting interpreters](https://craftinginterpreters.com/). The first half is targeted at java, but you can write it in c fairly easily, and it's designed pedagogically to give you an introduction to the principles. Also check out the dragon book if you have the money/know where to find textbooks.
No. `char name[3]` means that `name` has 3 elements. There is no n-1 here, only when indexing. So if you declare `char name[3]`, then it's illegal to access `name[3]` as an expression.
I'm new to this so I'm not exactly sure what's the differences between original version and "ansi c" version and "ansi c" version is only that I can find on sale. As student I don't have too much money to spare so I would like to purchase right one because at least here in finland I cannot find used one and new paperbag version cost like 50 euros. So which version you would recommend?
Ansi C. It's the standard we use now (some slight deviations). The original has some syntax that's no longer used.
Oh thanks! Going to try find used one because it's expensive around there because just one place which has it in stock
Ad silly as it sounds, I'm most productive in C+in-line assembly. The entirety of my Github is in that spicy mix of low-level programming. Some are ceoss platform ljke my molecular dynamics simulator, and some are linux-only using platform specific features. Now don't get me wrong, I do use Python and Matlab. Especially for lab reports with Matplotlib. But for my actual programming, I use C. I am familiar with C. I know how it works. I can't be mord productive with any other language.
We do that too
Thanks
Ok thanks for the info
Ok noted thank you for the answer
I'll be the black sheep here, and recommend *C Programming: A Modern Approach* (2nd edition) by K.N. King. It's the book that succesfully got me through my C course at uni. It covers everything about C in detail with many examples and exercises with solutions, and is updated to include all the relevant changes in C99. Unlike K&amp;R, it's meant for teaching how to program to a complete beginner, and doesn't assume you already have an idea on how programming works. I was actually disappointed by K&amp;R. I expected a course on how to learn programming with C, but it was more like a reference on C's syntax and features, with minimal explanations (it's ~200 pages compared to the other's ~500). Also the pages are visually ugly and messy, with a font that looks like that of a typewriter. I suggest downloading a PDF of both books, take a look at some sections and buy the one that you like the most.
It's extreme complexity is the foremost reason. It has been heavily optimized both for its own performance, and to generate fast code. This obfuscates the core nature of the operation of a compiler to a student attempting to learn the theory of compilation for the first time. Studying code that does things like automatic vectorization (where possible) of the algorithm may seem almost wholly unrelated to the underlying problem to the unitiated student. Additionally, gcc is built with the aid of the autotools suite, intended for a broad range of portability, including to obsolete platforms of no current relevance. This litters the codebase with macros and conditional compilation guards that makes reading its code in a naive fashion a frustrating, if not futile, exercise. To add to that, gcc has been under essentially continuous development since 1987. Coding styles and contributors have come and gone in that time. It is not the product of a single mind thinking clearly about the problem in a cohesive and consistent fashion. Toy, or teaching compilers are far more likely to use a cohesive design and consistent code style.
I'm late to answering, but I figure I'd say what I've done in the past. This really boils down to the design of your application. I like to take a Qt approach and define a top level structure akin to Qt's 'Ui' object where you can access *anything* from your application. Just create a struct with fields for every Gtk object you plan on using, then pass a pointer to that struct to the callbacks. Another approach you could take is to write a wrapper function that takes variables arguments: void wrapper_connect(GObject *parent, ...); Then create a va_list and pass that to g_signal_connect. This would either need to have format specifiers like printf, or a final NULL argument to define the end of the parameters. In the callback you'd then need to sort out what's in the va_list, which can be a hassle. I often find the first approach suits my needs and provides the cleanest solution.
That's sounds good, better to look both up fist and buy then whichever fits better for me. Thanks for help!
I don't mean to be "that guy" but this code doesn't do what you think it does......You need to put parentheses in your #defines: `#define FLAG_1 (1&lt;&lt;1)` Instead of: `#define FLAG_1 1&lt;&lt;1` &amp;#x200B; When you look at the line: `if (flags &amp; FLAG_1)` This really looks like: `if (flags &amp; 1&lt;&lt;1)` Which the compiler sees as: `if ((flags &amp; 1) &lt;&lt;1)` &amp;#x200B; I have been burned by this too many times for it not to be ingrained in my head. (Also: [https://xkcd.com/386/](https://xkcd.com/386/))
That's SIM cards I believe
Wait I'm stupid it's just a redundant sign declaration which can be repeated. Whoops.
You are saying that i = +8 As apposed to saying i = -8
Yeah thanks, I realize that now and feel very stupid. I should probably get some sleep.
Have you tried using an integer, since integers are what you use for indexing operations?
I use bash as my IDE, it has all the best plugins. But, perhaps VS Code?
Atom
Just for some extra context, the `+` here is a unary (only has one operand) operator, equivalent to int i = +(+(+(+(+(+(8)))))); The reason it doesn't work when you take away the spaces is related to tokenization, but basically it's looking for a different operator ++++++(8) - in the same way that `++i` is different from `+i`
I don't think that exists.
GNU Emacs does all of this, provided you install the backends yourself : 1 and 2 : Code navigation and refactoring will be handled by any kind of tagger. GNU global, for instance, but there are others. You can also have "naive" renaming and navigation OOTB. 3 : GDB will handle the debugging part, and there is a very good interface to it in Emacs. 4 : One of the most mature and time-tested piece of software there is. You won't have trouble finding people and resources to help you turn it into the perfect C IDE. 5 : It is awesome, no worries.
VS Code seems to comply with your requirements. It’s kinda nice also to have one IDE for multiple languages (Python, C, etc...)
Thanks for your comment! Actually a just download VS Code and the C/C++ extenstion 6 minutes ago, and it does feel good. But - it doesn't seem to have a reliable rename feature (only basic text-replace). Do you know if it does have this feature?
I think you'll have trouble finding an IDE that meets all of those requirements. Many C programmers don't use an IDE at all, or rather use a set of tools to accomplish the same functionality. For example, I use vim as my text editor. For what it's worth, vim does have code navigation features, auto complete, is mature, and generally awesome. That's just out of the box. Plugins are available to do the other things you're asking for. It's what I would recommend if you're serious about programming. Just be aware that it'll take a long time to learn before you see any benefit. You may also want to consider why you want these features. For example, I rarely use a debugger. When I do, I get along just fine using GDB from the command-line.
Pretty sure it does yeah, check this out: https://code.visualstudio.com/docs/editor/refactoring You need to open the entire folder IIRC
Vim &gt; Integrated refactoring features (such as reliably rename a function &gt; across all source-files) Rename the function at the definition, compile to populate the quickfix list with the resulting errors, then do a substitution on every error line using `:cdo`. :s/\&lt;old_name\&gt;/new_name/ :make :cdo %s//new_name/g &gt; Integrated code navigation features (such as jump to function definition) Use ctags. Universal/exuberant ctags has a `-R` option that makes building a tags file trivial: $ ctags -R Then in Vim use `CTRL-[` to jump to definitions. It keeps a tag stack, and you can jump between things comfortably. &gt; Integrated GUI debugger I just run GDB in the terminal, so I don't know what debugger integration options are available. &gt; Mature with a large number of users Yup. &gt; Generally awesome Yup.
If you’re on Windows check Pelles C. It has excellent documentation of itself and the C standard library.
I think QTCreator might fit? It has some refactoring, jump to definition, integrated debugging etc... I switch between it, vim and Vs code depending on the task and QT is definitely the nicest debugging experience.
Actually the bitwise shift operator has higher precedence than bitwise AND, so this isn't true.
Vim includes a builtin plugin for gdb. ''':packadd termdebug :Termdebug executable-binary-name-here '''
Nah man, getting these ambiguous semantics understood is pretty useful. It means the difference between spending 10 minutes on a bug or several days on a bug.
Sounds like you’re looking for something like CLion. It’s really great, but will make you use cmake, and it is paid. However it has student license and stuff, so if you’re a student, it’s free. Got great refactoring tools. Otherwise, maybe see if eclipse has a C plugin. Or just use VScode.
I haven't worked with binary files in C for a long time, so take this with a grain of salt. After briefly looking over it, it looks like you are using text mode in fopen(), change "r" to "rb" to use read/binary mode. Also, you're outputting to stdout, but you should be using fopen(...,"wb"). Replace string functions (strcpy() and strlen()) with binary functions since the string functions will automatically stop at any '\\0' character. You can use memcpy() instead of strcpy(), and there is no direct replacement for strlen() so you need to use the return value of fread() to determine the length of the file. Consider reading the file in blocks with fread() instead of one character at a time with fgetc(), same goes with fwrite() instead of printf("%c",...)
I really like CLion. It’s not free software (and my work bought it for me) but I think there’s a way to get it for free for open source development. The debugger isn’t amazing, but refactoring/analysis/built-in linting is better than any IDE I’ve used, and its built around CMake based so you’re not stuck with some IDE-specific project system.
The primary purpose of my life is that CLion becomes free. I'm coming from the world of PyCharm and Intellij IDEA - couldn't ask for a better programming experience. A shame that it's paid :\
VS Code does it for me very well. I have Vim keybindings and a pluggin for generating code snippets (something similar to cvim, but with less options). It also has a GDB integrated console which can be configured through a .json. Haven’t used it yet, so cannot recommend it yet.
It seems I must have some fundamental misunderstanding about either how working with pointers works, or something related here, because I can't for the life of me figure out what's wrong with this program. :( Any advice?
`current-&gt;next = &amp;(struct Queue) {.value = i, .next = NULL};` This is not allocating a new instance of Queue. I believe this is just creating a temporary value on the stack that will get clobbered when it goes out of scope. You want to do something like this: `struct Queue * new_element = malloc(sizeof(struct Queue)); new_element-&gt;next = whatever; new_element-&gt;next = NULL; current-&gt;next = new_element; `
I apologize....you are correct.....Still don't like the macro without the parens
&gt; current-&gt;next = &amp;(struct Queue) {.value = i, .next = NULL}; Okay but I don't even get there, do I? I get stuck in the `while` loop before that. And the initial `struct Queue* head;` in line 11 did get declared 'normally'. Does that not work either? I mean the: struct Queue* head; ... head &amp;(struct Queue) {.value = 1, .next = NULL};
&gt; The reason it doesn't work when you take away the spaces is https://en.wikipedia.org/wiki/Maximal_munch
**Maximal munch** In computer programming and computer science, "maximal munch" or "longest match" is the principle that when creating some construct, as much of the available input as possible should be consumed. The earliest known use of this term is by R.G.G. Cattell in his PhD thesis on automatic derivation of code generators for compilers. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Yeah, I agree with that. Precedence can burn you and it's good practice to just use the parens regardless.
Yeah, but part of why it’s so high quality is that it is paid. A lot of times developers want everything to be free, which I get, but people have to make a living. Well, they have a 30 day free trial if that helps.
It doesn't get stuck in the while loop the first time for me, because the anonymous object you've created is in scope for the whole function. &gt; And when I edit lines 33 and 34 to: struct Queue new_node = {.value = i, .next = NULL}; current-&gt;next = &amp;new_node; it still doesn't work for me. This is just a different way to write the same bug. You are not creating an object in memory that will persist after new_node goes out of scope, new_node will turn into random garbage.
New band name? :)
&gt;This is just a different way to write the same bug. You are not creating an object in memory that will persist after new_node goes out of scope, new_node will turn into random garbage. Huh... okay. But struct Queue* new_node = malloc(sizeof(struct Queue)); new_node-&gt;value = i; new_node-&gt;next = NULL; **would** persist after going out of scope?
Yup. If you just do `struct Queue new_node` it temporarily creates it on your thread's stack and it will cease to exist when it's not in scope. Malloc will reserve a chunk of memory somewhere that will persist until you free() the pointer or the OS cleans up your process.
That's great to know, thanks! Got any pointers (pun intended) on where to learn more about these memory aspects? Seems like I'm missing some rather fundamental understanding about memory allocation and what does what here.
This subreddit is for C, not C++. That being said, for every letter in the string "norwich", the loop subtracts 2 from. Chars are stored as integers, so if you pull up an ASCII table, you'll be able to find the new IV. By looking up each value, subtracting 2 from it, and reencoding that into a char again. Or you could just copy and paste that loop into a separate file and print the results.
Oh, I’m sorry. But that worked like a charm. Man, I don’t see anything in my text that states to do anything like that. How the hell was I supposed to figure that out?
The spaces between the `+` are important here. Also, `++` can only be applied to lvalues, not constants.
Functions v(f)printf are documented to “likely to alter the state of arg “ (va_list). Therefore to safely use in consecutive calls one must either va_end+va_start before second usage, or do a va_copy.
In the old calling convention, where args are passed all all in stack, va\_list can be just a pointer to that list. Little state. Passing first few args in registers requires more elaborate va\_list.
Xcode does almost all of this
&gt;Also, `++` can only be applied to lvalues, not constants. While that is true, it's not relevant here. If it weren't for the spaces, it would be parsed as `(++(++(++8)))`, and then rejected. The syntax itself has no concept of lvalues. As far as the grammar is concerned, both literals and identifiers are `unary-expression`s.
Because no two pluses are directly next to each other, they are all separates by spaces. If every 2 were smooshed together then they would be.
I didn't spot the spaces, makes sense.
I didn't spot the spaces, makes sense.
Every five seconds, someone on reddit asks this question. Every 10 seconds, someone replies with the same answers.
It would parse correctly and then be rejected for semantic reasons (8 is not a modifiable lvalue) .
1 and 2: `C-s` or `C-r` for serach within the file, `M-x rgrep` for search within the project or various projects, `M-x imenu` (all the functions in the file). `M-x ggtags-mode`, `M-.` to jump in `M-`, to jump back 3: `M-x gdb` 4: r/emacs 5: agree!!! don´t forget org-mode to GTD, magit and others
It's very relevant, it's why the compiler would reject it!
On the first version, you pass 2 format specifiers and 2 arguments. Then you call vprintf which will extract 2 arguments , then you call vfprintf to extract 2 more arguments for a total of 4 extracted. But there were only 2 in the list , so this is obviously undefined behaviour. To fix it you could call va_end then va_start again. I think your va_copy version is correct but unnecessarily complicated (va_copy is mainly useful in functions that take a va_list and so you can't call va_start).
In C, all values have a [storage duration](http://www.iso-9899.info/wiki/Storage_Duration) that determines how long they're kept in memory. 1. Local variables have *automatic* storage duration, and last until the end of the function they're declared in. 2. Global variables (and local variables declared with the `static` keyword) have *static* storage duration, and last until the end of the program. 3. Values allocated with `malloc` and similar functions have *allocated* storage duration, and last until you call `free` to release their memory.
The weird thing is it's worked on Windows for years though!
Bingo. I learned about this from the [Some dark corners of C](https://docs.google.com/presentation/d/1h49gY3TSiayLMXYmRMaAEMl05FaJ-Z6jDOWOz3EsqqQ/preview) presentation, in which he does `z = y+++x;` (which is valid) and `z = y+++++x;` (which isn't).
[6 stages of debugging](https://i.redd.it/ovmasg0cbqm01.jpg) You'll probably find that one system has `va_list` typedef for a pointer type, and the other has it typedef for an array type (which effectively does pass-by-reference) .
This subreddit exists to discuss the C programming language. Please redirect your question to r/Python, or perhaps a more general ( r/devops or r/programming ) since your question is about best practices that go beyond a given language.
&gt;I use bash as my IDE ~~Real programmers use butterflies~~
My mind just bent haha
That's what they said
C isn't really like that. Hardly anything is added, and even when it is, [you don't necessarily want to use it]: &gt; Despite more than a decade since the original proposal and nearly ten years since the ratification of ISO/IEC TR 24731-1:2007, and almost five years since the introduction of the Bounds checking interfaces into the C standard, no viable conforming implementations has emerged. The APIs continue to be controversial and requests for implementation continue to be rejected by implementers. &gt; The design of the Bounds checking interfaces, though well-intentioned, suffers from far too many problems to correct. Using the APIs has been seen to lead to worse quality, less secure software than relying on established approaches or modern technologies. More effective and less intrusive approaches have become commonplace and are often preferred by users and security experts alike. &gt; Therefore, we propose that Annex K be either removed from the next revision of the C standard, or deprecated and then removed. C doesn't really get more strict, so if you want better quality code, you crank up the settings on your toolchains and you use external tools to catch other things. If you want more features or performance, you start narrowing down your many library options (see /r/clibs). Maybe [pthreads](https://locklessinc.com/articles/pthreads_on_windows/) or [Concurrency Kit](http://concurrencykit.org/). ANSI C (C89 or C90) is the latest that Microsoft officially supports, and I've been using it for a couple of recent projects where Win32 is a secondary target. It's only the tiniest bit less convenient to use than `-std=c99`, which I'd otherwise have used.
&gt; "like modern chemists who don't want to reinvent the wheel". You're not reinventing the wheel. You're using libraries!
414request quoted some text and said it wasn't relevant, when in fact the quoted text is the main point
Maybe the Windows programs used to be 32bit so they were using the stack exclusively to pass the arguments and you transitioned to 64bit Linux where some of the arguments are stored in the registers?
Both are 64-bit OS's and GCC compilations (x64).
You mean the [32-bit Win32 calling convention](https://en.wikipedia.org/wiki/X86_calling_conventions#List_of_x86_calling_conventions). )?
As long as Python is an interpreted language, it'll never replace FORTRAN or C/C++ as the go-to for massively parallel simulators, or production-level quantum chem software. Sure you'll see it a lot in research code and it's really easy to teach but as long as monoliths like Gaussian, GAMESS, gromacs, LAMMPS etc exist and are actively contributed to, I don't see the need for C/C++/FORTRAN going away. Hell research python code that needs speed end up using Cython anyway. Or Pythran, which is p great. Though if any blazing fast language is gonna start replacing shit my bet is on Julia. Though I do love a good bit of C and will also probably use it for a long time.
http://icube-icps.unistra.fr/img_auth.php/d/db/ModernC.pdf
&gt; I usually compile my C code with a C++ compiler This is me in the future writing to me in the past: _please don't do that!_ The alternative is to use a C compiler to compile your C code, a C++ compiler to compile your C++ code and then a linker to join the two modules together. This ends up being less hassle (due to [less typecasts, ergo less keystrokes](https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc) and so forth). The anonymous object is a compound literal; it's got automatic storage duration (as opposed to the _allocated_ storage duration in the `malloc`-based code below), so you're right to pick on it. Undefined behaviour is undefined behaviour. &gt; it will cease to exist when it's not in scope I think you confuse _storage duration_ with _scope_ here... easily fixed: scope is visibility of the identifier, where-as storage duration is object lifetime. When you call a function, the storage duration of any objects local to the caller persists, where-as the _scope_... well, that temporarily terminates (you can't necessarily see variables local to the caller from within the callee, right?)... Below that I see another one from u/Snarwin... &gt; all values have a storage duration No, objects have storage duration. Values... eh... I think maybe this was a typo for _variables_ (which are essentially just _named objects_). &gt; Values allocated with malloc ... same deal there; `malloc` doesn't allocate _values_, but it can allocate _objects_. That which `malloc` returns, of course, is a _value_, which happens to point at an _object_ (or not, when things go wrong). &gt; It seems I must have some fundamental misunderstanding about either how working with pointers works, or something related here, because I can't for the life of me figure out what's wrong with this program. :( &gt; Any advice? Yes, do not conflate storage duration with pointers. `malloc` happens to use pointers, but that doesn't mean all pointers are returned by `malloc` (there are multiple uses for pointers, only kinda one for `malloc`). Consider the following: int a = 0; int *b = &amp;a; *b = 42; printf("%d\n", a); // what does this print? Now you should be able to get how just about every function in standard C makes changes to the objects _pointed at_ by the arguments you pass into them. For example `scanf`... or `strcpy`, the latter of which should look something like: char *strcpy(char * restrict s1, /* so many pointers here! */ const char * restrict s2) { size_t x = 0; do { s1[x] = s2[x]; } while (s1[x++]); return s1; } Finally, if you can write modules of code that _fit in with the rest of C_, this makes it easier for other C programmers... because then those C programmers don't have to relearn so much to use your modules.
The power electronic part was failing like the zero crossing detection circuit output was high always.
cdecl. That was the word, thanks.
That link is 404ing too.
[web.archive.org](https://web.archive.org) has it archived, here is a link from 2017. [http://web.archive.org/web/20170329080336/http://icube-icps.unistra.fr/img\_auth.php/d/db/ModernC.pdf](http://web.archive.org/web/20170329080336/http://icube-icps.unistra.fr/img_auth.php/d/db/ModernC.pdf)
Worked for me.
[this works](http://icube-icps.unistra.fr/img_auth.php/d/db/ModernC.pdf)
Awesome, wayback machine saving the day again!
See Sea C? Si!
Worked for me as well, check/flush/change your DNS maybe
Thank you!
so OK, you have some lucky here, the moc3041 is a device to help your chip control the AC part and have already included the zcd. Check the circuit on fig14 or fig15. [https://www.onsemi.com/pub/Collateral/MOC3043M-D.pdf](https://www.onsemi.com/pub/Collateral/MOC3043M-D.pdf) If for other reason need to know the timing of the mains voltage [https://www.onsemi.com/pub/Collateral/FOD814-D.PDF](https://www.onsemi.com/pub/Collateral/FOD814-D.PDF) probably need to do an algorithm get precise timing
Its O(n) you just traverse it by going through all the next pointers until you have hit the end (i.e next is NULL)
And just like that it's back up again! What a miracle!!
Is the implementation for that function kept in a .c file, or a separate pre-compiled library?
In a .c file
You need to add that .c file to the list of source files to compile.
Oh alright, Thank you. How can I capture the return value of this function from main? It just says return(SUCCESS\_ALLOC);
What does the code that calls `mat2all` currently look like?
if(mat2all((void\*\*\*)matrixA,(unsigned char)row1,(unsigned char)col1,sizeof(unsigned char),RAND\_INIT)){}
Heaven forbid, in this day and age, we should still run into *linker errors* that are solved by reading the compilers manual for 20-30 minutes... can you imagine what your team leader would've told you to do in the mid 1990s if you asked this question? [Clue](https://stackoverflow.com/search?q=undefined+reference)...
Please never do anything like this in real projects.
Code?
It returns SUCCESS\_ALLOC or ERROR\_ALLOC depending on if it was successful or not. I would say just check that the return value == SUCCESS\_ALLOC and assume failure if not. Chances are what you've posted below works fine and I'm guessing it's because SUCCESS\_ALLOC is a positive value and ERROR\_ALLOC is 0. I could be wrong though.
The link does work for me.
I don't have, I have to overflow whatever there is in behind
pass str as a pointer
How are you inputting the data?
You're not `fopen()`ing the file, and your variable names are also messed up (your FILE\* variable is called myFILE, but you're using myFile in the while loop). FYI, C has an existing function called `tolower()` in the ctypes.h header that converts upper case chars to lower case.
Not allowed to use tolower(). Didn’t copy actual code I have opened it using fopen() and am consistent with variable names. Sorry about this.
That's odd. I copypasted your code, added fopen() and fixed the variable names and it works. Can you elaborate on the "doesn't seem to have any effect" part?
Data from CSV is printed out throughout the program, still in upper case funnily enough...
Your function is needlessly verbose. char *to_lower(char *str) { size_t i; for (i=0; i&lt;strlen(str); ++i) if (is_alpha(str[i])) str[i] |= (1&lt;&lt;6); return (str); }
The only thing I can think of is maybe you're missing a lowerString call somewhere? Because this works (prints a csv line by line with everything converted to lower case): int main(void) { char str[1024]; FILE* myFile = fopen("test.csv", "r"); while(fgets(str, sizeof(str), myFile) != NULL) { lowerString(str); printf("%s\n", str); } fclose(myFile); }
This is purely a visual change that won't fix OP's problem.
Are you trying to write to the file? If so, you need to say myFile = fopen("file.csv", "r+") Or alternatively, you could just make a new file altogether. I recommend reading and writing to the file one character at a time, since 1. It will be easier to code, 2. it will support line lengths longer than 1024 bytes, and 3. your problem doesn't require anymore than a single character at a time. You can do this with getc() or fgetc().
Not trying to write, just need to convert to lower case then put through a tokeniser function.
This is an excellent example of how to write unreadable, unmaintainable code. Don't do this.
Unreadable? Unmaintainable? It's literally just shifting the lower/uppercase bit. It's as clean as it gets
you're right, rusty with C. return str from the lowercase function at the end.
Yeah yours is much better than adding 32
Adding 32 implies performing math. Setting the lowercase bit implies setting the lowercase bit. Both do the same thing, one does maths and one explicitly uses a feature of ASCII
While bitshifting is the most efficient way to lower or upper ascii values, this is obviously meant as a basic exercise with files, loops, and strings. I don't think bitshifting is on OPs mind at this point.
Python is a great language for scientific computing
But I don't like it and don't need to learn it more than uni requires me to.
I’m talking about researchers not undergrads
Hey mate, my fault found a bunch of strcmp that required upper case lettering. Thank you so much for your help!
Exactly, yours makes it much clearer
Setting aside the fact you were talking about neither, only about the language itself: None of the researchers where I study use Python. They exclusively use FORTRAN.
All good! It happens The longer you program, the more little tricks you pick up. Doing that, and stepping through it in a debugger are two things you can always do to see what's going on if you don't quite understand it.
I think for big simulations that makes sense. If you don’t need that performance then python is the best choice. I work in gravitational wave interferometry and I don’t like python much, but I use it because everyone else does and collaboration &gt;&gt;&gt; personal preferences
Actually learning bit shifting at the moment, however don't want to over complicate my assignment!
You might be able to use something else to input such characters, like `echo -e '1234567890ab\xFA\x10' | ./prog` (in Linux/bash). Note that ASCII just defines 0x00 to 0x7F, so there is no correct 0xFA chracter. (Also, 0x10 is line-feed, or "enter"). The "trick" is to just input the raw bytes you want to input using some other tool (here `echo`)
Thanks, this worked!
Please post your actual code including the code that prints out the text.
1&lt;&lt;5
Probably because the compiler inserts 8 bytes of padding after EIP and EBP are pushed to ensure 16-byte alignment?
why is 16 byte alignment necessary? I thought that because it is 32-bit then only 4-byte alignment is necessary
Memory is always padded for alignment reasons.
oh how interesting. How can I view the memory bus size?
Sometimes it is useful to have a larger alignment than the processor word, like when you perform SIMD operations on the stack (e.g. 128-bit SIMD load/store operations on x86 are much faster when aligned to the 16-byte boundary).
If it is 32-bit, I’m pretty sure your buffer is already 4-byte aligned so you shouldn’t be seeing any padding. If there are other locals, the compiler could place those between your array and EBP/EIP. The best way to see what the compiler is doing in this case is to take a look at the disassembly. Try using objdump -M intel -Dj .text &lt;path_to_bin&gt; and post the output.
You have to read your processor's and/or motherboard's datasheet.
Yes we used that moc 3021 as a Opto-isolator to-adjust the triac firing angle but for getting the zero crossing we had to build another circuit and give the input of that to the micro controller so that it would start a high priority interrupt service routine to adjust the firing angle.Didn't know about this chip moc-3041, would definitely use this to improve that part.
Thanks a lot !
On Linux, use the `nproc` utility. On FreeBSD and OS X, use `sysctl hw.ncpu`. There is no POSIX way to do this. Also check out the `lstopo` utility. To pin threads, use `sched_setaffinity` on Linux and `pthread_attr_setaffinity_np` on FreeBSD. No idea for the others.
You can in general not make any assumptions about how the compiler lays out the stack frame.
Also, kern.sched.topology\_spec sysctl shows the detected CPU topology on FreeBSD. In XML :/
There is no portable anything along these lines, because the standardization bodies are decades behind. The most you can do is break out `#if`s for each OS, and fall back to I-hope-the-kernel-scheduler-is-sane if you don’t recognize the OS. In addition to what’s been said, Linux also has libnuma, and the Intel CPUID instructions on newer processors will read out what cores and threads are tied to which caches, which is one of the more important aspects of things. /proc/cpuinfo may also tell you which threads are on which cores, although it may be totally different depending on which architecture the kernel’s running on, which really limits its potential usefulness. You might be able to find cores/threads using sysfs as well. There are like three different (mostly incompatible) ways of dealing with large numbers of processors or NUMA things on Windows, none especially satisfactory. If you actually have to do large-scale parallel programming where which thread you’re on matters, Windows is probably not a good idea.
&gt; There are like three different (mostly incompatible) ways of dealing with large numbers of processors or NUMA things on Windows, none especially satisfactory. If you actually have to do large-scale parallel programming where which thread you’re on matters, Windows is probably not a good idea. I actually have Windows figured out, I am working on porting my code to Linux (Amazon Linux 2)!
Hey thanks for spending time and reaching out. Your comment was very helpful. For anyone else out there you might want to check out these links [Beej's Guide to Network Programming](http://beej.us/guide/bgnet/html/single/bgnet.html) [http://www.linuxhowtos.org/C\_C++/socket.htm](http://www.linuxhowtos.org/C_C++/socket.htm) or if you are in a hurry, you can download the project from here [here](https://www.youtube.com/watch?v=12F3GBw28Lg) . Thank you again for your help.
Also, to make it more readable, you could do something like: str[i] = str[i] - 'A' + 'a' or str[i] += 'a'-'A'
Are you counting return E-/R-/IP and (assuming no `-fomit-frame-pointer`) saved E-/R-/BP as part of your stack frame? And as mentioned elsewhere, stack alignment is pretty common, although on x86 it’s only strictly necessary in a function that uses aligned SSE stuff.
 // Modified from libcxx std::thread::hardware_concurrency() to make it C compatible! #if defined(__unix__) || (defined(__APPLE__) &amp;&amp; defined(__MACH__)) # include &lt;sys/param.h&gt; # if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__) || defined(__APPLE__) # include &lt;sys/sysctl.h&gt; # endif #endif // defined(__unix__) || (defined(__APPLE__) &amp;&amp; defined(__MACH__)) #if defined(__unix__) || (defined(__APPLE__) &amp;&amp; defined(__MACH__)) || defined(__CloudABI__) || defined(__Fuchsia__) || defined(__wasi__) # include &lt;unistd.h&gt; #endif // defined(__unix__) || (defined(__APPLE__) &amp;&amp; defined(__MACH__)) || defined(__CloudABI__) || defined(__Fuchsia__) || defined(__wasi__) #if defined(__NetBSD__) #pragma weak pthread_create // Do not create libpthread dependency #endif #if defined(_WIN32) #include &lt;windows.h&gt; #endif unsigned thread_count() { #if defined(CTL_HW) &amp;&amp; defined(HW_NCPU) unsigned n; int mib[2] = {CTL_HW, HW_NCPU}; size_t s = sizeof(n); sysctl(mib, 2, &amp;n, &amp;s, 0, 0); return n; #elif defined(_SC_NPROCESSORS_ONLN) long result = sysconf(_SC_NPROCESSORS_ONLN); if (result &lt; 0) return 0; return (unsigned)result; #elif defined(_WIN32) SYSTEM_INFO info; GetSystemInfo(&amp;info); return info.dwNumberOfProcessors; #else #warning hardware_concurrency not yet implemented return 0; #endif }
 void iterateForward(ListNode *node) { return node-&gt;next; } ListNode *node_ptr; while (node_ptr == NULL) { // Do something with your node node_ptr = iterateForward(node_ptr); } I'm assuming your list is already populated. I think editing and pulling is pretty straightforward, and deleting is an exercise for you.
I have a simple function for getting thread count on macOS, Linux and Windows. It’s [here](https://github.com/VKoskiv/c-ray/blob/9cd414ee93a49e2ba7696b0af1be5bee8acb259a/src/utils/multiplatform.c#L34) in the platform code for my renderer.
`lscpu` is able to gather these information. If I were you I'd open the source code and study it for Linux. To handle portability, write seperate source files for each OS and a single header file, include appropriate source code in compile time.
Shouldn't the loop's condition be `node_ptr != NULL`?
Yup, my mistake
VSCode all the way
if you're just programming for basic experience before you get into your code school, you don't need to pressurize yourself into learning in-depth. get a working knowledge of your basic programming elements (data types, conditional statements and loops, arrays, pointers etc etc). any decent book or even a video tutorial is good enough for this. then focus on trying to solve programming excercises yourself. really try and focus on the logic behind the problems, and condition yourself to think like a computer. it's gonna give you a major head start when you get to learning the real applicable stuff.
So the parts of the date are stored as strings in the struct. You can try to replace the seperated parts of the date with an integer array with three elements so you can iterate through the array and use the strtok loop as you want to. Or you can try to use pointer arithmetics to access the elements single elements of the struct
https://youtu.be/X8l_9Ap2BO8
If you are looping over a string, you may do this: char *str = “Example”; for (char *ptr = str; *ptr != '\0'; ptr++) { do_stuff(ptr); } This works because ptr begins at the first spot, ends when hitting the null character, and moves to the next one by incrementing by one. For a linked list, it looks like this: node *my_list; for (node *ptr = my_list; ptr != NULL; ptr = ptr-&gt;next) { do_stuff(ptr); } Because looping ends with NULL, and is incremented by changing from the current node to the next one.
Use strptime(3) if on a Unix-like OS. You’ll have to provide it with a string describing the format you expect the date to be in. Check the man for more information.
Try this: https://www.eskimo.com/~scs/cclass/krnotes/top.html
No cheating; [only for checking your answers](https://clc-wiki.net/wiki/K&amp;R2_solutions).
I would definitely have a more modern C text to accompany K&amp;R. Best practices have changed in the last 30-odd years and the style of code you find in K&amp;R is no longer considered idiomatic.
What he said. 21st Century C is good.
I'm sure you are very close to my original question .... My main constraint for this question is a say void*( this is just an example I have 0 idea how this is implemented) might change between architecture's and there may be no tight understanding on how it works between Arch's because all this is handeled by the compiler I would have to place my trust on it that it didn't do anything crazy .. and it would be untestable since your rolling out code which is different between architecture's and compilers and different versions of the same compiler ... But if you had a VM you could test the implementation of the vm for individual Arch's and makes the reasoning about the code little better... And execution of code more consistent . Does what I'm saying make sense ... I'm still a noob in low level code so apologize if I said anything crynge
Sorry if this is a bad place to post this, but I just finished my first larger C program, and it'd be great if I could get feedback on it. It's a simple tic-tac-toe game for the terminal. It works on linux, but I don't think it should be too hard to get running on windows. It's mainly the code I'd like feedback on, though. In what ways can I improve, etc. Thanks!
Comments: &gt; #define SIZE 3 Consider using better definitions. Size is a very common variable to be defined like this. Alternatively, mark it as static const int instead of as a define. In draw_board, consider taking the board as a const param. This gives you some code security because if anything changes it, you'll get a compiler error. In draw_board: consider not using system. I realize it's easy for now, but there are libraries potentially worth using (Ncurses, for example). In draw_board: &gt; for (int i = 0, n = 0; i &lt; SIZE; i++) You increment n, but what's the point? In place: Realizing something is bad and dealing with it properly are two separate issues. If you can't write secure code in simple programs, you'll never manage it in larger programs. TL/DR: scanf takes minimal effort to use. &gt; int col = (posinput[1] - '0') - 1; You don't verify that anything is entered. check scanfs return, also sanitize input. Part of learning means writing good clean correct code, and input checking is a simple thing to do. Potential idea: create a function called ParseInput which takes as a parameter a const char* of the player's input. Have this function return an x and a y (as a struct, if you like). This function should verify the length, then split it as needed, then call parse_number to parse the number, returning something like -1 if parse_number failed, or even 0. parse_number would take as input the x and y after you split them (call them separately). &gt; int pos = col + row * SIZE; I think your math is wrong here. if I provide 1,3, you'll get: 1+(3*3) 1+9=10 &gt; if (pos &gt;= 0 &amp;&amp; pos &lt; SIZE * SIZE) Conditionals like this can easily be written as: if (pos &lt;= 0 || pos &gt;= SIZE * SIZE) Then you can simply avoid an entire block and bail out early. This is just the inverse of the statement you had above. In check: This kind of hard-coding is messy, hard to read and even more likely to be wrong. Just use a loop, don't get clever. In main: Your check for player could simply be written as: player = (player == 'x'?'o':'x'); consider returning from main as well. Thoughts: What happens if no one wins but the board is full? HTh,
Thanks! &gt;In draw_board: &gt; for (int i = 0, n = 0; i &lt; SIZE; i++) You increment n, but what's the point? It's kind of confusing, but I using it because I'm not using a 2d array, so I need a variable that will go up to 8, but every 3 columns, and I want to print a newline. It just seemed to fix the problem. &gt;Realizing something is bad and dealing with it properly are two separate issues. If you can't write secure code in simple programs, you'll never manage it in larger programs. TL/DR: scanf takes minimal effort to use. True, I could've taken the time to make it secure, but since this is just a small program I wrote to practice, I couldn't really be bothered. I know I'm lazy, but I wanted to just get a program finished before worrying about security stuff. Thanks for the tips below, though! &gt;int pos = col + row * SIZE; I think your math is wrong here. if I provide 1,3, you'll get: 1+(3*3) 1+9=10 if (pos &gt;= 0 &amp;&amp; pos &lt; SIZE * SIZE) When I convert the chars to ints, I -1 from them, so if you entered 1,3, it would come back as 0,2, 0+(2*3) should be 6, which should be the correct index in the array. If you enter anything larger than 3,3 (2,2), it should be rejected. &gt;Your check for player could simply be written as: player = (player == 'x'?'o':'x') Thanks, this is really helpful, I always forget about the conditional operator! Thanks for the tips. I'll take the checking/security into consideration for the next program I write, or I'll continue to try to improve tic-tac-toe!
For a first piece of serious code, this is pretty good. Well done. 25: Use enum rather than `define` to define constants. This allows the debugger to see their value, which is convenient when debugging larger programs. 28: when function parameters can be const, make them const. That communicates to the caller that the called function won't modify the input. That makes it simpler to reason about code. In the case of this line, you should write `void draw_board(const char board[])`. 58: It's better to separate user interaction from the manipulation of the data structures. In this case that means moving the user interaction out of place() into another function. There are several reasons for this, but the most important one is that this allows unit testing. That, by the way, is a thing you should look into. 89: This code works OK. You could experiment though with making it shorter by factoring out the check in the if into a function that looks like this: #include &lt;assert.h&gt; // ... bool win(const char b[], const char p, int first, int stride) { int i; assert(first &gt;= 0); assert((first + SIZE * stride) &lt; (SIZE*SIZE)); assert(stride &gt; 0); for (i = 0; i &lt; SIZE; ++i) { if (p != b[first]) { return false; } first += stride; } return true; } Then check gets a bit simpler: bool check(const char b[], char p) { return // check rows win(b, p, 0, 1) || win(b, p, 3, 1) || win(b, p, 6, 1) || // check columns win(b, p, 0, 3) || win(b, p, 1, 3) || win(b, p, 2, 3) || // check diagonals win(b, p, 0, 4) || win(b, p, 2, 2); }
I thought that if a parameter is const, the argument you pass in also has to be const. I suppose not, then. I was actually thinking about seperating the user input in "place" into another function, since it seems like it's doing to much. Thanks for the feedback!
This method is incredibly efficient. Using bitwise operations is usually faster on most CPUs
\-, o and x could be handled symbolically until i/o happens. Would be easier to change them into emojis, for example. Not that it matters, but ... Also the player flipping would then be player = !player.
I remember Pelles C being a good windows-based IDE.
Try out emacs with lsp and ccls language server
Every five seconds, someone on reddit asks this question. Every 10 seconds, someone on reddit responds with the same answers.
Code:Block’s is fairly good. That said, I just use Cygwin/tcsh on Windows... if you’re W10, the WSL might be with exploring?
1. Post code as text, not images. 2. You never reset `c` after the first loop, so it won't refill `blank` for the second string.
The error message is pretty complete. You have a function that doesn't match the prototype of your function pointer. You either need to leave out the logFile parameter, or change the definition of the compareGear() pointer.
Sorry, quite new to function pointers. How would it work without the logFile parameter?
A nice extension might be making the size of board dynamic, which would then require something a bit more complicated for your check function. As in, not hard coding the 8 checks.
Working through K&amp;R ANSI C right now. In your opinion, are the styles and idioms that are used in modern C easy to learn after having done K&amp;R?
Your compareGear pointer doesn't have a FILE* parameter. The error couldn't be more clear.
Yes. A good example is a near-total lack of discussion of things like buffer overflows and other problems caused by naive design principles. Things like bounds checking are barely mentioned (if at all) but are absolutely crucial to real-world usage of C today. A worse omission is all the advances in tooling since the late 70's. Learning manual memory management sucks at the best of times but things like Address Sanitizer and Valgrind make tracking down memory problems effortless. Compilers are phenomenally good so you can write far less terse code than K&amp;R shows and still get performant output.
When I added it the compiler asked for two more parameters I didn’t put in before...
[Ivor Horton's Beginning C](http://www.mosaic-industries.com/embedded-systems/_media/c-ide-software-development/learning-c-programming-language/beginning-c-5th-edition-ivor-horton.pdf) is a good alternative, imo.
Then post that too
Personally I would say try making your own small program and look up ways to achieve what you desire gets the job done faster. And goes for the book only for the very technical detail of the function and structure behind data types
What book would you recommend for a high schooler like me who is seriously committed in trying to learn?
My reply was the point, that’s how I learned C, I didn’t uses any book except online documentation and stack overflow
[https://intranet.icube.unistra.fr/img\_auth.php/d/db/ModernC.pdf](https://intranet.icube.unistra.fr/img_auth.php/d/db/ModernC.pdf) &amp;#x200B; On Firefox desktop I get a 404, but on firefox mobile (android) I can download it, what browser are you using?
K. N. King, "C programming a modern approach" is excellent. Lots of examples (generally interesting), very clearly written and covers up to C99 (the last important C update for the time being).
Learn C the hard way is a good intro to really learn the language. I always recommend the hard way series.
I second xamac's suggestion. Here's the PDF of the book https://drive.google.com/file/d/1sUWfB8K37kkRq3CYMBeEj7Y-iglY6TmV/view?usp=sharing
that one used to be bad at c but somewhat redemption because valgrind. i don't know if zed shaw revised it but this is not actually a good suggestion if the former holds true.
Error printAdventure.c:37:59: error: too few arguments to function call, expected 3, have 1 mapArray[x][y].compareGear = &amp;compareHands(logFile); Header void compareHead(Player*, Treasure*, FILE* logFile); void compareChest(Player*, Treasure*, FILE* logFile); void compareLegs(Player*, Treasure*, FILE* logFile); void compareHands(Player*, Treasure*, FILE* logFile);
How can we work without code? Show us the faulty code and explain what you've tried and what the results were.
Ok I'll ask him to send it to me Thanks :)
I updated the post with the code
It looks like the type of `Treasure.compareGear` only wants the 2-parameter version, not the 3-parameter version you're inputting into.
Sharing this because I require feedback. I'm a 3rd year chemistry undergrad who dropped out of computer science years ago. I still carry programming in my heart and hopefully in a few years will have a Ph.D in theoretical/computational chemistry. **But that's only a dream for now.** A lot of stuff isn't in yet: - Thermostats - Barostats - Looping universe - Full atom type DB (going with AMBER values) - Better file format ----- I actually went to nearby labs and surprisingly one of them actually wanted to take me in for a quick "talk" which turned into a 2hr session of helping me out. But alas, FORTRAN and static analysis is their trade. They could only help me out to a certain extent. I now turn to **you**, actual programmers, to try and point out the fuckery in my bowl of spaghetti. Cheers!
Sorry to say but it's still quite unreadable. Please put it in a "Code" block. I know, Reddit does not make it obvious at first. Also why isn't your friend here himself? He could just make a throwaway account. Would save you the trouble of dealing with some grumpy programmers ;-)
It's ok, thank you for letting me now. I'll edit that now
C strings need to be terminated with a null character, which takes up one position in your `comm` string. Your program can thus only work if you input exactly one character and press enter. If you input any more than that (like a space and then a different character), you end up with an invalid string that has no terminator and cannot be safely treated as a string, that is printed via `printf` and so forth. Meanwhile the `gets_s` function itself will notice and throw up some kind of error flag in the background. Use a single char instead, and read that via `scanf` or something.
Can you look into this [https://pastebin.com/7PpxwpQK](https://pastebin.com/7PpxwpQK). What's wrong in the logic? It prints all instead of tenure&gt;=3.
I don't have a background in chemistry and I am not advanced enough to optimize others people code but the picture of lilith coming from a programming community triggers me .
Yep, 17 myself and I’ve been programming for 2 and something years now. Started with C++ as that teaches us in school and took a bigger project for myself. Build a small, command line password manager that has some basic encryption and hashing. Then I did some web development, a mobile app, some Python etc etc. I found out I really like programming, and stuck with C and embedded stuff on some Infineon boards from my older brother. I learned pretty much everything online and just got the basics of algorithmic thinking from my professor. Learning like this is great for practical stuff, but the problem is that you might end up with some holes regarding your knowledge so be careful to read everything and don’t skimp out on the details.
Aha. Evangelion had a deep impact (no pun intended) on me and made me the emotionally resilient person I am. I don't remember why I put a Lilith pic, but I'm not removing it 😁
Hm i don’t wanna be „that“ guy, but this is a c not a cpp subreddit ;) Anyway your code looks reasonable small. Maybe I can help you. Would you mind to be a little bit more explicit about what behavior you expect and about the actual results you get ? Error messages and stuff are helpful to find out if it’s a programming error or a logical error.
At a first glance I found an error in your while condition where you check for input validity. The first condition will always evaluate for true. You check if „A != 0 OR A != 1“ and you have three cases in this simplified example. 1. A is 0 (false || true) = true 2. A is 1 (true || false) = true 3. A is neither 0 or 1 (true || true) = true This always yields true and thus you always stay in the loop.
Maybe I'm just an idiot, but I'd suggest not using a bunch of domain specific abbreviations in the description of what a thing is. "MD simulator" what am I simulating? Maryland? I don't know what the thing is yet. If you tell me it's about Maryland up front, then you can say MD later and it's cool. I'm still looking at your code, but my first question is whether there was a rationale for using fprintf with stdout explictly vs just calling printf. Also, your program appears to exit with an error if called with invalid arguments, but it doesn't make any attempt to provide a message that it's bad arguments, or show a correct usage example.
He calls s_get with an length parameter. I am not a cpp developer but the documentation says that it will read n-1 = 1 char and add a null terminator as a second char. Shouldn’t this work just fine and the remainder of the input is just ignored in this code ?
Firefox desktop
See those are exactly concerns I had. I originally wanted the program to output such messages (I mean, all of them do) but I was faced with a dillema: the program's job is to simulate if possible. Is it its job to tell the user how to use it? Eventually, I settled with a detailed explanation of the arguments in `README.md`, and a program that simply failed if it doesn't have the right arguments. This kind of dillema is everywhere in my program: should the program do a task for the user - or should it do its job and let the user sort the issues out ? Originally, on simulation failure, it was outputting a specific message (ex. "Failed to perform vector multiplication due to blahblahblah"), but I settled on using `__LINE__ ` and `__FILE__` instead, and leave the programmer to troubleshooting. As I don't interract with programmers at all, I have no insight as to how others work, what practices are considered right/wrong, etc... ------ For the `fprintf(stderr, ...)`, it is a residue of the way the program used to output simulation data. It simply dumped it on `stdout`, and I was piping it to an output file or `column`/other UNIX tools to exclusively use the data I wanted. Naturally, the errors had nothing to do with the simulation output (which at the time only consisted of vector coordinates), so I separated error prints and simulation prints by specifying `stderr`. I do concede that in its current state there is no need for the expicity `stderr`, other than specifying it's an error. Should I change the print statements?
Molecular Dynamics, most likely.
How is something like this going to compete with existing options? I don't know much about the field of MD simulations, but I know GROMACS has been under active development for decades. I completed my Ph.D. in molecular biology within the last year, and had a significant computational aspect to my project. It was an easy lesson to learn that in science, one shouldn't try to re-invent the wheel.
Oh it's definitely not going to compete with anything. I would not have any actual work rely on a platform that is not "approved" by general academic consensus unless it is the point of the work. It's just a fancy project I pursue in my free time that can enlighten my resume ~~and secure much needed internships~~
And this is the best use of your free time? Since you've met with a PI, it sounds like an opportunity to do real research. If you publish before you finish your undergrad, you'll be able to write your ticket into any graduate program you want.
I mean I never really felt like it was that much of a deal. My self-confidence was always low but to be honest it never really sounded like this basic piece of software was enough to secure a grad program. I'll be looking deeper into this, thanks.
Read the _new_ ANSI version. C hasn’t changed much since 1999
You might be right. I was reading Microsoft's documentation, which is (unsurprisingly) rather vague regarding the length parameter. &gt; If buffer is NULL or sizeInCharacters is less than or equal to zero, or if the buffer is too small to contain the input line and null terminator, these functions invoke an invalid parameter handler, as described in Parameter Validation. If execution is allowed to continue, these functions return NULL and set errno to ERANGE. At any rate, this is an inefficient way to read a single character that introduces way too much room for error with no benefit whatsoever in this case.
In this case, the compiler is complaining about the `&amp;compareHands(logFile);` (on the right side of the assignment) The code you've written is trying to assign the **result** of calling `compareHands(logFile)` to `mapArray[x][y].compareGear`. This would only work if your `compareHands` function was a function which took in a `FILE *` and returned a function pointer of the appropriate type. The error you're getting is telling you that `compareHands` needs to be called with more arguments (specifically with a `Player *` and `Treasure *` *in addition to* a `FILE *`), but in this case you don't want to call the function at all. Instead, you just want to get a pointer to the function which you were correctly doing before as ``` mapArray[x][y].compareGear = &amp;compareHands; ``` The issue now though is that the type of your `mapArray` is (something like): ``` void (*mapArray[100][100])(struct Player *, struct Treasure *) ``` which means it holds pointers to functions which return `void` and take in one `struct Player *` and one `struct Treasure *` as arguments. BUT, your `compareHands` function does not take in two parameters but rather three. Hence the types don't match. What you probably want to do is change your declaration of `mapArray` to be something like `` void (*mapArray[100][100])(struct Player *, struct Treasure *, FILE *) ``` Hope this helps!
C Primer Plus is a good book.
If you're planning on supporting Unicode at all, you need to use Unicode's case conversion/floding tables from the UCD. if you go that path, don't even bother with the text UCD, use the XML version. it's actually parsable unlike the former.
&gt; (I mean, all of them do) Let this be a guide. There is a thing called the Principle of Least Surprise. Generally speaking, your program should work in ways that don't *surprise* the user. That is, it should work "like they all do". Detailed usage is best in your github page and maybe a man page if you wanted to offer one, but a short "Error, you're not using me right. See the github page for usage examples." is way better than the program just exiting and making non-programming user go read the source code to discover that the line number it cites as the reason it exited was about args, so maybe they were using it wrong. &gt; leave the programmer to troubleshooting. Don't assume that all users will be programmers. Also, don't assume that all future runtime errors will be caused by program defects that must be fixed by a programmer. Some sort of idea about what happened is useful. Line numbers also change as code evolves, so if you have someone who has an old version of the code even them telling you what line number isn't very useful diagnostically. The fprintf thing isn't a big deal. It's atypical, but not really hurting anything.
/r/unexpectedhumaninstrumentality /r/unexpectedlilith /r/unexpectedthirdimpact
I'm out of the loop, could you explain or link me to something for an explanation?
minor clarification but for accuracy's sake, it would be returning a **pointer to the result of the comparHands(logFile)** function that's being assigned. great explanation
Separate your #include statements with at least one line of whitespace separating *your* included code vs C standard library code. Your filenames should go in "quotes", not &lt;angle brackets&gt;. a la: 8 #include &lt;text.h&gt; 9 #include &lt;util.h&gt; 10 #include &lt;vec3d.h&gt; 11 #include &lt;universe.h&gt; 12 #include &lt;bond.h&gt; 13 #include &lt;stdio.h&gt; Not like that. But like: 8 #include &lt;stdio.h&gt; 9 10 #include "text.h" 11 #include "util.h" 12 #include "vec3d.h" 13 #include "universe.h" 14 #include "bond.h"
 char outpath[strlen(args-&gt;out_path)+32]; According to your Makefile, you are trying to target C89. The above example uses a variable length array, which is a C99 feature. You must pick your target, know it, and not use features outside of that.
The picture displayed on Reddit next to my link is my Github profile picture. It's a screenshot from *Neon Genesis Evangelion* depicting an entity known as Lilith.
Try on mobile, the version that web archive has archived it's from feb 2017 and the last is from feb 2018.
Stop worrying about anything else, and go read about FILE pointers and look at examples. $ ./ammonium -i ../examples/dihydrogen.nh4 -o dihydrogen_results Simulation started (2 particles, 1000000.000 ps with 1.000 ps steps) Simulation ended (2000000 iterations rendered in 3 seconds, 666666.000000FPS) Segmentation fault (core dumped) Reading symbols from ammonium...done. (gdb) core-file ammonium.core [New LWP 100755] Core was generated by `./ammonium -i ../examples/dihydrogen.nh4 -o dihydrogen_results'. Program terminated with signal SIGSEGV, Segmentation fault. #0 0x000000080039754d in free () from /lib/libc.so.7 (gdb) bt #0 0x000000080039754d in free () from /lib/libc.so.7 #1 0x00000000002037fe in universe_clean (universe=0x7fffffffe970) at universe.c:148 #2 0x0000000000202c11 in main (argc=5, argv=0x7fffffffea38) at main.c:37 Let's see what's going on where gdb says the problem is: 145 /* Free allocated memory */ 146 free(universe-&gt;particle); 147 free(universe-&gt;output_file_csv); 148 free(universe-&gt;output_file_xyz); Free... the output file? Don't you mean fclose() - more research. No.. that's done at line 139. We're freeing a thing, after we fclosed it? It's declared normally... universe.h: FILE *output_file_xyz; Then I see: 46 /* Allocate memory for .xyz file pointers */ 47 if ((universe-&gt;output_file_xyz = malloc((universe-&gt;part_nb)*sizeof(FILE*))) == NULL) What in tarnation? From the man page for fopen: &gt; RETURN VALUES &gt; Upon successful completion fopen(), fdopen() and freopen() return a FILE &gt; pointer. Otherwise, NULL is returned and the global variable errno is &gt; set to indicate the error. &gt; It returns a pointer. You don't allocate RAM for it like you're trying to. The operating system allocates whatever RAM it needs to keep track of the file state, and manages that RAM. It gives you a pointer, basically to use as a handle to refer back to the open file. You just assign it. FILE * foo = fopen(...); *read/write file* fclose(foo); That's it. Don't try to malloc or free anything about it. You malloc'd a region of RAM the size of a file pointer, and assigned it to a file pointer. Then you assigned over that (losing the original value you had set, and leaking the RAM) by calling fopen. That's the OS's RAM being pointed to. Then you closed the file, and the OS cleaned up the resourced it allocated for that file. Then you tried to "free" the OSs RAM, which doesn't belong to you, so that segfaults.
hey check out c primer plus :) it's good for what you are because the author takes time to talk about things and make it really easy. the book is more verbose because of it but this is what you want, right?
As a follow-up, I confirmed the fix. ./ammonium -i ../examples/dihydrogen.nh4 -o dihydrogen_results_test Simulation started (2 particles, 1000000.000 ps with 1.000 ps steps) Simulation ended (2000000 iterations rendered in 3 seconds, 666666.000000FPS) (No crash.) --- universe.c.orig 2019-05-26 18:55:56.638335000 -0400 +++ universe.c 2019-05-26 18:57:06.838952000 -0400 @@ -39,14 +39,6 @@ if ((universe-&gt;particle = malloc((universe-&gt;part_nb)*sizeof(t_particle))) == NULL) return (retstr(NULL, TEXT_MALLOC_FAILURE, __FILE__, __LINE__)); - /* Allocate memory for .csv file pointers */ - if ((universe-&gt;output_file_csv = malloc((universe-&gt;part_nb)*sizeof(FILE*))) == NULL) - return (retstr(NULL, TEXT_MALLOC_FAILURE, __FILE__, __LINE__)); - - /* Allocate memory for .xyz file pointers */ - if ((universe-&gt;output_file_xyz = malloc((universe-&gt;part_nb)*sizeof(FILE*))) == NULL) - return (retstr(NULL, TEXT_MALLOC_FAILURE, __FILE__, __LINE__)); - for (i=0; i&lt;(universe-&gt;part_nb); ++i) { /* Initialize the .csv files */ @@ -144,8 +136,6 @@ /* Free allocated memory */ free(universe-&gt;particle); - free(universe-&gt;output_file_csv); - free(universe-&gt;output_file_xyz); }
vec3d.h declares e_0, e_x, ey, and ez. As near as I can tell, that's the only time ey and ez are ever mentioned. vec3d.c actually defines and uses e_y and e_z. (Note the different name.) Also, the vec3d.h declaration should be qualified with 'extern'.
"Programming in C" by Stephen Kochan is pretty good. Years ago, I learned C in a college course using Herbert Schildt's book "C: The Complete Reference", and I thinks it's pretty good too for learning C. As a reference book, also check out "C in a Nutshell" by Peter Prinz.
Check out HOOMD. I've used it extensively. Its great and well written if you want to learn about building MD or Monte Carlo software that runs on HPC.
Every five seconds, someone on reddit asks this question. Every 10 seconds, someone replies with the same answers.
Every five seconds, someone on reddit asks this question. Every 10 seconds, someone replies with the same answers.
Is this using C or C-sharp?
What format does the file need to be in? You can make it in xml and that will give design constraints that must be followed.
currently it is just a .txt file.
I usually spend my time on public transport reading, listening to podcasts, or just people watching. This made me come to realise that so many commuters have their eyes glued to their tiny screens playing mobile games or watching dramas (which is fine), but it really irks me when they can't take their attention off the screen while walking and it causes them to be SO spatially unaware. So I guess I'm curious too, am I the only one who gets annoyed by how common this is?!
But does it have to be?
yes it does :/
The easiest solution is to change the file format. Json or xml would be easiest. If it has to be a text file, look into regular expressions. A simple regex... assuming the format is fixed...will give you what you need
Then you need to create search functions. You'll need to pull each line out of the file, determine what it is by your search algorithm and then convert the text to value based on which line you pulled in.
I'm not sure about Windows 10, but on Windows 7 I use MinGW. http://www.mingw.org/ With MinGW you can compile from the command line. Or use an IDE like CodeLite or Pelles. You can also just use Notepad++ as an editor on Windows and execute the compiler from within Notepad++ https://bitsnapper.com/notepad-plus-plus-to-powerful-multi-language-ide/
Do you have control over the format of the input file? If so, consider converting it to something where there are lots of parsing tools available, as u/FluffyNevin suggests. If not, figure out what the structure of the file is. Then, build a parser. Depending on the structure, you might be able to do it easily with regex functions. But don't make it overly easy. Be aware of edge cases, like escaped characters and quoted strings.
Well, the down side is riddling your code with macros. What's the upside? Types in C are typically straight forward and short. If you want to use this feature of C++, then make a style guide for a subset of C++ and enforce it. Alternatively, preprocess with something more sophisticated than the CPP. Still, this is clever, and neat.
I think others have mentioned the `SIZE` being defined as a static constant rather than a `#define`. That is the biggest stand out issue for me. Other than that the code is actually pretty clean, and for a first larger C program. I especially like that you're commenting is not excessive, but is still descriptive enough to make the code readable to an outsider, so kudos for that.
I'm sorry, I don't frequent programming subreddits or even reddit in general. Any link to one of those questions with answers would help me. Thanks.
What does this even buy you in well-written C, at the cost of weakening type safety and introducing your own personal C syntax? C++ can get pretty verbose with its fully qualified templates but I can’t really think of when this would meaningfully improve readability in C.
no
I wasn't the nicest about the code review, so don't feel bad. Mostly I'm trying to drill a few things home; code correctness is just one of them. It's easy to jump from "I just want to get this done so I don't need security" to "I just need to get this huge corporate app done so who cares about input checking and security." It's something you should be thinking about and using religiously. Small program or no, once security considerations are something you do automatically, it won't be a question anymore and you'll write it as a matter of habbit. That's what I'm really trying to push you into. It's easy to overlook, it's easy to say "I'll come back and add this later," and in reality part of any project is finishing the thing and getting it out the door. Perhaps find a happy medium and settle somewhere in the middle; 50% is better than 0%. My comment about the naming was simply that you could have named it something like SquareCount, etc. Something that explains what it is apart from simply size. Don't get too stuck on variable naming, but try to name it things that make sense to you. Otherwise as was already said, this is a good first attempt and you'll clearly keep getting better from here. You also have the fact that you took the comments in stride, examined each of them and determined how you could apply them going for you; a lot of people get fairly offended and it makes code reviews sticky.
http://icube-icps.unistra.fr/img_auth.php/d/db/ModernC.pdf
I don't see a use for this. First off, it's a macro and macros should be used sparingly. Using a macro for something like this just seems silly to me, it's not worth the work when it goes wrong and you have to debug the thing, or even remove it and take out the 200 times you used it. I'm sure there are pitfalls here and it's not going to be fun. You need to weight the risk of pitfalls with the utility of the macro. I honestly don't see any utility, so in my opinion this is all risk. Second, it doesn't make much sense for C. The auto keyword in C++ is great, no one wants to type things like `std::vector&lt;std::string&gt;::iterator it{lst.begin()}`. It's redundant since you know the begin member function returns an interator and it makes your code harder to refactor if you have to change the type of `lst`. There, `auto it{lst.begin()}` makes a whole lot of sense. Or things like `auto o = std::make_unique&lt;Position&gt;()`. The type is already stated in the right side of the expression, it just doesn't make any sense to state it in the left side. But in C, it makes little sense. You don't have nested types like this typically, you don't have templates and things that make just stating a type a 60 character affair. I don't think of a time when I thought "damn, this type name is just too long" in C. I've never found myself wanting an auto or var keyword in C. Finally, it doesn't looks like a declaration. It declares a variable but it's a function-like macro. This hides the declaration and makes the code harder to read. This might be okay if the declaration is horribly complicated and this were used sparingly, but using the macro all over the place is, I think, going to have a negative impact on code readability. That said, you made me realize I can do something that I didn't realize before: you can declare an instance to an anonymous struct member using typeof. Not sure where I would ever need this, but... neat! #include &lt;stdio.h&gt; struct outer { struct { int i; } in; int j; }; int main() { typeof(((struct outer){}).in) i; i.i = 10; printf("%d\n", i.i); }
Well the biggest downside is that if you are already using gcc/clang they have `__auto_type` which is literally the same as C++ auto.
I've seen this exact comment several times before lol
Thanks!
This is really just an unfortunate coincidence that has been baked into the language's grammar for backwards compatibility reasons. Multi-line pointer declarations are not C's strong point, and you shouldn't use them for this reason. In actuality the `*` operator modifies the *type*, not the name. For example, if you want to allocate memory for a dynamically sized character array you write `(char *)malloc(N)` rather than `(char) *malloc(N)`. If you tried to use `(char) * malloc(N)` you would have a memory leak in your program because you are essentially discarding the result of malloc.
Yeah, I'm building a custom translator that allows UFCS-like object function calls and an infer keyword, among other things. So these would look like: infer i = 6; var::fun(1); And become INFER(i,6); fun(var,1); After translation. Thanks for your input, I just made it because it wasn't hard and just wanted to check to see if there were edge cases where it might error.
I'm writing a translator for some features I wish C had. Among these are a infer keyword and object call function syntax. Under the translator, infer a = 3; &amp;a::add(1); Would become INFER(a,3); add(&amp;a,1); Also I think macro based generic types can get pretty long.
Well crap. Thanks for letting me know it exists.
Yeah, I think I feel what you're getting at. My personal feeling is that everyone's better C got it wrong. Instead of strict typing, we should've embraced weak typing (type equivalency by structure). The only language to get that right is Go. Unfortunately, Go is a bizarre and niche language with many strange design choices that render it impractical for general purpose programming. So I too feel as though a true and minimalist successor to C is begging to exist. Or it's just me.
Thanks, I understand. I'll probably try to make the tic-tac-toe game more safe, then. I've been adding/changing a few things. I added a draw condition, split up the place function, into another function called get_pos, which gets input from the user, calculates the position in the array and returns it. I'll probably add some more checking to it.
I agree that type checkers where you have to write out the type of every intermediate value is bad. However, instead of structural typing, I believe in moving in the direction of Hindley-Milner-style typed languages like Haskell and Rust, where you don't have to specify types as long as the compiler is able to infer them (and in non-ambiguous situations it always can).
What is the type of b ?
I use whenever I can: `#define var __auto_type` `#define let const __auto_type` It does make source look cleaner because variable names align vertically since var and let are the same number of characters. It forces initialization at declaration, which is a good thing. The potential problem I have sometimes run into is initializing with an int but intending the variable to be used as a double. Then -Wfloat-conversion helps point these out.
You can use this, but it's going to infuriate other programmers you work with. Also watch out for unintended consequences, like `'x'` being of type `int`.
The auto keyword is useful in C++ because the type of a variable is so often clear from the RHS (e.g. make_unique). But that is true much less often in C++.
Damn you've been reporting problems all night. If I end up publishing my work, which I probably will, I have to fix them. You've been a great help, thanks a lot for your unexpectedly thorough review
And every 1 second someone replies complaining about new people trying to learn. I like the Handmade Hero series, a livestreamed long running series where the host makes a game, although it's technically c++ he uses a restricted subset of it that is very close to C (I think the only cpp specific feature he uses is function overloading) Knuth has a series of books called The Art of Computer Programming, which while not directly about C are regarded as a great resource. (I have only read a small part of them) But really one of the biggest things is putting in the hours of hands-on learning. Make stupid little utilities or throwaway projects to learn concepts. Things like "read in a file and print only what comes after a colon on each line" or "generate a random number that corresponds to the range of 2d6 dice" And if you have problems that you can't solve, go hunting on google (but be prepared to read 50 sites until you find the one that clicks with you.) If you're not a beginner and were just looking for changes in the language sorry for wasting your time.
:-) You caught me on a day where I was in the mood to dig into a more thorough review than a casual glance. Your Makefile also has some issues, I had to fix some things to even get it to compile on my system. I made quick and dirty hacks to it rather than trying to sit down and write a proper makefile from scratch. One thing to keep in mind is that the system compiler isn't called gcc on every computer. (FreeBSD, where I did most of my review, moved to the clang compiler a few years ago as the default/only installed compiler by default. I have both gcc 7 and gcc 8 also installed, but one of them is installed as 'gcc7' (for the actual executable name) and one as 'gcc8'. It's a good practice to check to see if the environment variable "CC" is set, and use whatever it's set to if the answer is yes. That does mean avoiding compiler specific flags if you really want to be portable, but clang is designed to mostly support all the gcc flags. I'm glad the review was useful; you're more than welcome.
You cannot modify values in-place, unless the length is exactly the same. If it's a one parameter per line, just read them, compare with what you want and when you find the line to modify, parse it, change value and render. All other lines just write without parsing. Of course, do not write to the same file! Use temporary file and when everything is processed, rename it... maybe after making a backup of the original file... just in case. Backups are always a good thing.
I was speaking specifically and *only* about declarations. In declarations, operators such as `*` and `[]` modify the declarator, not the type. The general rule is that “declaration mirrors use”, hence `int foo[]` instead of `int[] foo`, or `int (*foo)(char, size_t)` instead of `int *(char, size_t) foo` or something like that.
By default, gcc aligns stack frames on 16-byte boundaries. Look up the `-mpreferred-stack-boundary` option in the documentation.
[Here](http://lmgtfy.com/?iie=1&amp;q=learn+modern+c)
There is no C99 version of K&amp;R.
Does it have to be that format exactly, or does it just have to be readable / editable with a text editor? If the latter, use something like [Jansson](http://www.digip.org/jansson/) or [libucl](https://github.com/vstakhov/libucl).
Stephen Kochan wrote a lot of C related books. They usually are good.
My suggestion would be to stick to K&amp;R and search for the terms, ask for clarifications when you hit a wall, etc.
&gt; Second, it doesn't make much sense for C. It makes a *lot* of sense for C. It lets you write type-agnostic function-like macros, for one.
I don't think anyone can really help you with the task, with as little information as you gave. On your specific C issue, it seems that the macro MAX is already defined, maybe in some of the LightSpeed C headers. You may be able to work around that by guarding the with #ifndef MAX #define MAX ..... #endif #ifndef MIN #define MIN ..... #endif but I am not sure how you'far you;ll be able to go.
Its a bit difficult since im pretty sure the only way to recompile the program is through an emulator....unless there's some other way? Sorry, would I be changing the first 5 lines to these 6 lines instead?
Apparently he asked this same question 5 days ago on StackOverflow; I found that post when I googled for "SLQconvert". It contains a bit more info and a link to a ZIP file with the source code on Zippyshare. [link](https://stackoverflow.com/questions/56248054/recompiling-lightspeed-c-program-from-the-80s)
Yup, thats all here too, its in the pastebin file. Can't link zip files on reddit.
Solved it [https://github.com/abcool/C\_training/blob/master/c-e.c](https://github.com/abcool/C_training/blob/master/c-e.c)
Please do not link to illegal copies of copyrighted material. [The book](http://knking.com/books/c2/index.html) is still in print and should be bought from the publisher.
What method are you using to integrate the equations of motion?
Numerical integration. Basically, every timestep, the vectors get updated: /* Perform at each timestep*/ a = F/m; v += a*timestep; pos += v*timestep; The accuracy is therefore directly related to the timestep. However, the smaller the timestep, the longer it'll take to render the simulation.
&gt;And every 1 second someone replies complaining about new people trying to learn. The complaint is about people not using search.
No problem. Enjoy the book!
Ah okay. There are some nice methods that tend to be used often in Molecular Dynamics called symplectic integrators. The most common for MD is the [Verlet integrator](https://en.m.wikipedia.org/wiki/Verlet_integration) (and it's variants). You want to use a symplectic integrator for a physical system because it works better for long-term behaviours. Non-symplectic integrators will drift very quickly (relative to symplectic integrators) and have a very large error. Verlet integrators are also time reversible. This is important in a few different ways but simply-put it guarantees conservation of energy. A nice book on Monte Carlo and Molecular Dynamics is Understanding Molecular Simulation: From Algorithms To Applications by Frenkel and Smit.
Desktop link: https://en.wikipedia.org/wiki/Verlet_integration *** ^^/r/HelperBot_ ^^Downvote ^^to ^^remove. ^^Counter: ^^259906
Today I learned... thanks for pointing that out.
Honestly auto should just be implemented in C as an extension at this point.
int*, easiest way to test is with a dummy function void static inline test_type(void** p){} It should give a compiler error telling you the type you passed it is wrong, and also what that type is.
&gt; Json or xml would be easiest. Erm, are you sure? Equals separated pairs would be simpler I imagine.
Eh, the variable declarations being at the beginning are an ANSI C/C89/C90 coding thing, while having them on a separate indenting tab... I think the author is a bit inventive, but at the same time I'm kinda liking it from a "keep the variable declarations clearly separate from the actual function logic" point of view.
IMHO it would be easier to understand program logic and implement it anew in another language. C is pretty unforgiving!
 Depends on the library I imagine. Import directly to xml, or json, and then handle as an object. That's the easy way...
That's a bit much IMO (never seen it before). I tend to use a blank line after a block of declarations.
This is the way I've done it for over 40 years. Although I too leave a blank line separator.
Who knows why you'd choose to do that rather than using the standard tolower() function while you already need to include ctype for isalpha. Half of readability is in the naming. tolower is obvious enough for anyone. Plus it's standard, and if the OS has a wacky ascii implementation it will still work.
While I've never seen this particular style, a similar style was used for K&amp;R C code. Back when the declarations for function arguments were placed right before the function's block, these used to not be indented: char * strchr(s, c) char *s; { while (*s) if (*s == c) return (s); return (NULL); } However, this sort of indentation was never done for local variables.
&gt;you can declare an instance to an anonymous struct member using typeof Whoa, that's really cool! I'm not sure I need that anywhere but it is definitely neat to see that it's possible. Thanks for sharing that. But one question I have. Are you sure you didn't mean *nested* struct member instead of anonymous struct member? The reason I ask is because the inner struct appears to have the explicit name `in`, making it non-anonymous. All the same, it's a neat trick!
I think I saw two #include "misc.h" in the header files I looked at. So maybe #ifndef NULL #define NULL 0L #endif #ifndef MISC_H #define TRUE 1 #define FALSE 0 #define MAX.... #define MIN..... #define ABS.... #endif
`__auto_type` is newer IIRC (GCC 4.9+), whereas `typeof` is good back to pre-3.0.
It looks like an adoption of the K&amp;R style, where the types of the parameters were listed outside the parens, but before the curly brace. I don't like this because I thought it was K&amp;R style parameters. It's confusing.
&gt; `#define NULL 0L` *(visceral shudder)*
You can't seek a pipe. If you checked the return value you'd see that it's actually giving you an error, which is why it appears to do nothing. The good news is that you can do this without seeking. You don't even need to look at the values you're reading, and it doesn't matter what you write to the pipe. The semaphore count is instead *the number of available non-blocking reads*.
Oh I am so stupid. I thought that I needed to do it exactly like the pseudocode I had but if I implement the wait to just read from the pipe and the signal to write to the pipe it seems to work! Thanks!
I think that there was a compile option to include headers only once. It may be that... I may be wrong, thought, last time I used LightSpeed C was 30 years ago...
That's just the cycle of life :D
Use a terminal multiplexer like screen or tmux.
This isn't a programming issue as much as it is a sysadmin issue. When you push the process to background, it doesn't stop the output of the process. If you're pausing the process, like ctrl+z, then its obvious why nothing is happening until you run fg or bg. If it is a programming issue, use gdb or make some printf/puts statements (its not best practice, but it'll give you feedback). You can always make a logging mechanism to keep track of the process while it runs which would actually be ideal.
I found the book that is extreme useful to me. &amp;#x200B; [https://doc.lagout.org/security/Hackers%20Delight.pdf](https://doc.lagout.org/security/Hackers%20Delight.pdf)
&gt; This isn't a programming issue as much as it is a sysadmin issue. Signal's can be handled in C though...
What I can see immediately: ``` int n=0,flag=1,choice,q,accessionNo; char *bt,*an; struct book *b = (struct book *)malloc(n * sizeof(struct book)); ``` You set `n = 0` and then allocate _ZERO_ bytes of memory for `struct book *b`.
 b[*n-1].title This doesn't point to a valid memory. You'll need to allocate some memory and store its address there.
Yes, that's what I meant. A nested struct without a struct tag.
If you don't understand what I said, don't bother, there is next to zero chances for you to succeed there. I will look a bit more into it, but I promise nothing. Let me rephrase your problem, to make sure I understood it correctly: 1) You want to convert files from a format called "Kurzweil K250" to "Sound Designer 1" Where a the "Kurzweil K250" files ? How are they named ? Do you have a sample with *both* a "Kurzweil K250" file and the corresponding "Sound Designer 1" ? 2) There used to be a program to convert those files, called "QLSconvert". This program used to run on Macs. Do you know what Macs did it run on? What System version? Did you use it yourself? 3) I installed an emulator with System 6 (never done that), and was able to launch QLS convert. There is reference to "qls" and "sd" files. I suspect that "Kurzweil K250" are the "qls" files and "sd" are "Sound Designer 1". Is this right ? 4) When launching the tool, I can open the files, using "File &gt; Convert from QLS format..." Is this the right command ? I get asked the "expansion style". What is this? Is it important? 5) I I select a file, I get "sound is not compressed" and "can't seek to sample" Is this the error you face? Then, the key question Why do you think this has to do with this 24/32 bits? If you think it is an emulator issue (which I DON'T BELIEVE), maybe you should try to find someone with access to a old Mac to try to see if the code works? For me, the most probable problem would be that your files are in the wrong format (ie: on a format that is too recent for QLSconvert to handle). Btw, how did you get the source code? Can't the people that gave it to you help you?
True, but your question isn't code related at all. Your asking from a systems admin PoV, not a programmers perspective. TBH, its not really clear what your going after here. Technically most of the OS, shells, and utils are all in C, but I don't see how this specifically relates to C at all. Running a shell command to run a process in the background isn't C.
Ah sorry, I'll try to re-word it: https://www.thegeekstuff.com/2012/03/catch-signals-sample-c-code/ If I use the code from those tuts in my program, will I be able to stop using "nohup" to run my program? Like.... can I programmatically ignore hangup's within C?
Of course you can. Unsure if you should, though. You can also try to pipe your program into "tee" and "tail -f" the resulting file.
Signals are handled by the kernel. You're making a request to the kernel to fulfill a particular request, i.e. when you call a program like pkill -SIGx &lt;process&gt;, its not guaranteed to do that particular action unless you have permission to do so and even then the intended action may not occur. Most of the kernel is black boxed to prevent meddling with other processes and done to help automate particular executions and prevent others. In a microcontroller, yeah, you could probably do this, but I doubt in the OS. I know that anything is possible when it comes to this type of stuff, but the kernel does its best to prevent it. According to the article, you're only catching the response of the signal which the kernel let's you do. Seeing as blocking a signal could be malicious or harmful, I highly doubt it. According to the docs, you can block a signal during sensitive operations, but its only temporary. No matter what, a root process will always be able to send a signal to a user space process to terminate it somehow. Even if the process is run as daemon or root, the kernel can still effectively send a signal to kill it. I'm just making my best educated guess here with what I do know.
You can catch and ignore SIGHUP, and as a quick and dirty solution, that might work. The more complete solution is to create a daemon. https://stackoverflow.com/questions/17954432/creating-a-daemon-in-linux
Learning screen is a game changer for people with long-running processes
Running on GDB wouldn't work very well, if it's a compute problem. I believe it would have too much overhead.
Does your compute process use libc buffering in its output stream? I believe that libc will set the output stream to fully buffered if it’s attached to a file. (nohup.out). If you have access to the code, try setting stdout to line buffered or unbuffered.
you can force output by fflush(stdout). You can also force linux to commit output to a permanent harddrive. I forgot how that worked tough, it was by some syscall.
u/AltruisticVariation: **Do not delete your posts once you get an answer.** It robs other people of learning, and it's incredibly rude to those that answered. We didn't write my responses just to help you. We wrote them so that everyone could learn. By deleting your post you've effectively deleted all of our comments.
I know but I realized the question was pointless and stupid and the answer you gave was not even to the original question (how can I keep reading from a pipe - which obviously is not possible and entirely stupid) but rather to how I could implement the semaphore. Maybe if the title was different the post would be more helpful to others. Thanks for the suggestion however.
Yeah, I also found out that __auto_type a1 = (int[]){1,2}; __typeof__((int[]){1,2}) a2 = (int[]){1,2}; Have different results, a1 is an int* and can be reassigned a different address, and a2 is a proper fixed address array int[2] type from what I've tested.
&gt;Is there a better way to run my process/job so I can both compute but also get the screen output? To see the output in the same console: progname &amp; To save the output to a file you can inspect at any time: progname &gt;foo.txt &amp; To do both of the above at once: progname |tee foo.txt &amp;
`(myFile = EOF)` is an obvious mistake &gt;After running the program with the debugger I get a compilation error/ This is not possible. You can't start the debugger until after compilation succeeds with no errors.
He said in the question by doing `make` (which, if there's no makefile, I think does `gcc foo.c` perhaps with some default cflags)
`(int[]){1,2}` is not a valid initializer for an array (in Standard C). I see gcc has an extension to allow it though...
Hey The source code was recently published on the yahoo k250 user group page, I had asked the user (aburgwedel) who had uploaded the soundfiles to also upload the source code for QLSconvert as he had got it from a guy named Bill Gardner, who wrote the program in the 80s. Unfortunately and hilariously it seems noone knows (or wants to) fix the program to make it work properly. Yes, the resource forks are missing, heres the conversation Bill sent to aburgwedel: [https://pastebin.com/9djuYFMS](https://pastebin.com/9djuYFMS) Everything up to 5) is how far I have reached as well. Using the export program packed into the zip file I've shared, you can export the .sd file to your desktop and you'll see that it's only 2kb, so there is some corruption happening somewhere in the program. I was told by aburgwedel that the program runs in 24-bit addressing...however... It's true, that that might not be the problem at all, but all the emulators run with 32-bit addressing, so he figured that was were the corruption was happening when converting the soundfiles to .sd format. I thought I'd try to crack it myself knowing no C code, but this is as far as I've got. I figured if it were possible to re-compile the program from scratch, we might be able to run it on the emulator. Browsing the k250 yahoo user group, it seems a few people tried the program, but they were using the functionality of transferring the soundfiles to the k250 itself and not using the convert to .sd function. So, its possible noone has tried it that im aware of.
`getc()` will never return a value larger than `UCHAR_MAX`, so you don't need to test for it. It will either return a value in the range of `unsigned char`, or `EOF`, which is "a negative integral constant expression." The latter is why it's important you use an `int` rather than `unsigned char` to receive the result.
Next to your typedef of Cell_Type why not #define CELL_TYPE_MAX. Also, going by the name, Cell_Type, I'd expect it to enumerate the different kinds of cells. Why isn't it an enum or at least use an enum to define constants for its possible values. If you go that route, you can do something like: enum Cell_Types { cell_type_illegal, cell_type_1, cell_type_2, ... cell_type_limit, }; You could still use: typedef unsigned char Cell_Type; And just use the enum constants along with it. And then you could: return (input &gt; 0 &amp;&amp; input &lt; cell_type_limit) ? input : '\0';
Thank you.
Arguably, just `Cell` would have been a better name. It's isn't an enum, it's the type for the cells in the Brainfuck "memory tape". Basically defining how large of a number each cell can hold.
Jesus fucking christ.
Or, you know, just use _Generic.
Yeah and both __auto_type and typeof are C extensions as well. From the offset I specified the two main C compilers that aren't msvc which have a wealth of mostly compatible extensions.
When you capitalize a word randomly, it becomes unclear whether it's a proper noun or not. What is Signal, for instance? Is it an app? Ignore Signal's what? What's with the extra apostrophe? Apostrophes are, generally speaking, for contraction and possession, not plurals. You can always send stdout and sterr to a file, like so: process &gt; /tmp/process.out 2&gt;&amp;1
I've seen it before (and in fact still do it myself) and it's tidy for C90, however if you transition to modern style where variables should not be declared until the point of initialization then it can get a bit inconsistent. Now I tend to use normal indentation for variables being declared at point of use; but still use this style for the rare cases of declaring at the top.
as /u/ericonr said, use screen or tmux to be able to disconnect and make the HUP a non-issue. My vote is for screen, based on a back to back comparison I did a few years ago, screen annoyed me less, and I thought it had fewer annoyances. YMMV. I'm guessing you're running on a lovely system with ext3 or ext4 as the filesystem on the partition you're trying to write your nohup.out to. Output to *console* usually has pretty small buffer limits in place, such that your output shows in the screen in a reasonable fashion without you explicitly having to flush stdout/stderr for that to happen. When you send it to nohup, rather than being written to the console devices, it's "just" going to a log file, and a different buffering strategy is used. Different OSs and filesystems, and system memory amounts, and... lots of things, can affect exactly how much buffering happens. ext3 and ext4, unless it's changed since I tested, are *lazy as fuck* in actually pushing buffered, pending writes to disk to the actual disk. As long as the system has plenty of RAM available to just grow the buffer ever bigger, it will happily do so (until you go to do something like shutdown the computer, where we have to collapse and sync all outstanding writes). The rationale for this is that you might *never* need to actually write that data. What if you fseek back to the beginning of your output file and truncate it to 0 bytes and then close it? We would've wasted all that effort by those poor disks that could have been used for some more worthy program that *really* needed to write to disk (and disk bandwidth and seek latency are finite resources affected by other IO and queue depth). (Your computer grinding to a halt when you save and quit from vim, which forces an actual sync is one example of when you have to pay back all that deferred work.) XFS, which was written for mainframes originally, which are generally always under real load, takes a "we might as well work on getting this shit written *write the fuck now*, we could be busier soon". Completely different buffering and write coalescing strategy (just fucking write it, basically). I'm pretty sure you're not running the filesystem of the gods (ZFS, clearly) which I will avoid delving into the behavior of here, in the interest of time. You can likely force output to show up in the nohup.out either by typing "sync", which should make ext[34] get off its fat ass and do some work for a living, or by piping the actual output to "tee" before backgrounding the whole thing with nohup. If you hadn't guessed it, pipes tend to be buffered yet again differently, and way less than files, generally. (You'd get an output file with actual output from whatever you told tee to send it too, and an empty nohup.out to throw away.) You can sidestep all of this jiggery pokery by using screen or tmux, so you can detach and reattach your console without a HUP ever being sent. *Yes* you *could* install a signal handler to catch and ignore the "HUP" signal. This doesn't keep your stdout and stderr (and stdin) streams that were being multiplexed over your SSH session from being invalidated when you disconnect. Doesn't really buy you anything. As others have mentioned, you could also use a logging engine, or even just naively open a file and print to it with fprintf, and flush the output stream from time to time (use a logging engine). As an additional aside, the file size shown by ls, is generally simply not updated until the file is closed. More work deferral. m_time and size are generally both lies while the file remains open, although that is less universally true across systems. Hopefully that answers your questions.
You're getting downvotes but I kind of agree: this is a very heavy program with Mac GUI elements and Sound Designer (?) support, that really should be stripped down to the basics: "what is the format of a Kurzweil K250 soundfile", write a brief spec, and then implement it as something like a command-line program, SoX plugin, etc.
Could you perhaps make the user input non-blocking and also create a pipe for the networking thread to write to in an error condition? Then your main thread could select() or poll() on both descriptors and act accordingly when there's activity.
*Please feel free to correct me if I’m wrong about any of the below information:* It’s been a little while since I’ve done some multi-threading so what I have to say may or may not be of use, but I’ll try anyway. If I’m not mistaken, calling exit() in a thread, will end the whole process. You can specify a function for cleaning things up and to be run just before exiting. If you use atexit() and pass it the function for cleaning up, your program will run that function before quitting. Note: Using _exit() is a more barbaric way of exiting and will bypass any atexit() cleanup functions you specified. I’m not sure if this answers at least part of your question or any of it at all, but I hope it helps!
Huh, so `__typeof__` is more precise. Sorta frustrating—it’s easy enough to contort your expressions to loosen or decay the type, but it’s not easy to cinch the type down. E.g., you could do #define let(a, b) \ __const__ __typeof__((b)+0) (a) = (b) to decay `b` from array to pointer (or eliminate a `volatile` or `const` qualifier, or promote to ≥integer), but you have to do something like #define let(a, b)let__0((__COUNTER__,a,b)) #define let__0(t_args)let__1(let__2)t_args #define let__1(x)x #define let__2(i, a, b)\ struct let__struct_##i { \ __typeof__(b) value; \ } (a) = {b} and then use `.value` whenever you mention whatever `a` was, in order to even involve the full array type.
I think this is probably the right answer. There’s `msync` to ensure mmapped data is synced, `sync` and `syncfs` to sync metadata globally or for an FD, `fsync` to sync an FD’s data, `fdatasync` to flush all of an FD’s data except less-important metadata, `bdflush` (Linux) to kick the kernel buffer daemon in various ways, and sometimes SCSI or ioctl commands to flush ≥1 hardware layer’s data. But it’s only possible to force the kernel to flush data from its own buffers—whether it actually makes it all the way to the disk is not something the kernel can really determine in some cases or guarantee in most. The data could get intercepted by a hypervisor and buffered, or sent over the network and buffered there, or a disk drive could buffer the data before writing it, or a drive with flash cache could write it days later.
If it’s at all possible to pick a different means of blocking so it takes a timeout, I would do that. E.g., most of the select/poll/etc. things at least have a variant that takes a timeout. Alternatively, if you’re select/poll/etc.ing, create a spare `pipe` solely intended to interrupt things and have whatever threads concerned include the read end of that pipe in their read set; write into the pipe to end their block. If you want to go the signal route, then usually it’s not at all safe to do anything other than set a flag in the handler and return; it’s a control transition tighter than anything the C compiler can safely reason about, and too low-level to be specified fully by ISO, IEEE, X/Open, etc.. Often a syscall will return `EINTR` if a signal interrupts it; sometimes that behavior needs to be configured or flagged-for specially. If that’s not the case, you may be able to return control to your own code by setting the target-architecture-specific PC/IP field referenced by the `extra` handler parameter to something reasonable (probably an assembly-language cleanup-and-jump routine) upon return from the handler. If your worker threads would otherwise not be touching anything outside of one-step syscall or global variable wrapper, it’s ~basically ~safe to use higher-level stuff for thread cleanup, but that’s not at all a spec-compatible or portable thing to do. If you want the main thread not to die when you signal other thread(s), you need to make sure the workers have their signal masks set to allow only a single type of signal (e.g., `SIGUSR1` or `SIGRTMIN`), and the main thread masked to ignore that signal but accept most others. This will prevent the main thread from autolyzing. If you need to be able to interrupt just one thread, or just one group of threads, then you either need them to be “listening” to different unmasked signals, or you need their handler to check some global hear-ye structure to see if they can ignore the signal. If you’re using something like select/poll, you may be able to use a `p`- variant of it like `pselect` or `ppoll`. These allow you to atomically unmask a specific signal for the duration of the blocking call, then return the signal to a masked state afterwards. This will treat the signal(s) being un- and re-masked sorta like an FD, and only accept them during the blocking operation in question; mask management otherwise needs to be done *very* carefully to ensure you don’t encounter a race condition if a signal’s sent. (I.e., you don’t want to miss the signal, and you don’t want it to arrive when you’re not ready for it unless it’s just setting a `sigatomic_t` flag to 1.) It is safe to call things like `abort`, `exit`, `_Exit`, etc. to exit from any thread, but multithreading may interact poorly with `atexit` and similar handlers if you need to clean up anything before exiting. It’s better to have the workers clean up their own crap, then exit so the main thread can join all of the workers, then the main thread cleans up and `main` returns cleanly to its caller. If you ever need to expand behavior to include cleanup (e.g., using `mmap`ped temp files, or running more than one batch of workers at once or in sequence), it’s much easier to have a clean, minimally-jumpy control flow where you’re only cleaning up at one site per resource.
Nice reply. I'm just getting into C and it's helpful to read explanations like these, because C is so different in the required thought process to achieve something than most big OO programing languages
You could periodically check If there has been user input (in very short intervals). The error messages could be stored in a queue so the main thread can access them. If the user hasn't input something you could print the error message.
In the "this line is getting error" you're trying to put a two-element *array of* pointers to functions into an element of the array, which can hold a pointer to function. (Not only that, you're putting it in element [2], which is beyond the end of the array) You could write `fptr[0] = add; fptr[1] = mul;`
As said, you do miss resources forks. This is a pain, but not a showstopper: they are present in the executable, so they could be re-extracted with a resource decompiler. Not trivial 30 years later, but possible. More seriously you are missing the Fitter.h header file, that seems to contain the Options struct (at least). This is more serious. It may be possible to reverse-guess its content. However, I suspect that this may not be the only missing file. I will give it a shot tonight. The biggest issue is that I do not think it is a 24 bits issue, so I don’t expect the code to actually work. I suspect that the files are either corrupted or from a different version. In my opinion, the best course of action would be to extract the code and do a separate conversion tool for mac/windows/linux. This can only be attempted if I get a pair of working qls+sd file for testing.
You might want to think about this a different way - using 3 threads. Think of the main thread as the “thread manager” and the networking and input as “worker threads”. Now the main thread can block, waiting for a signal from either worker and can cleanup stuff should anything go wrong.
Yeah, user aburgwedel had mentioned that might be the best way to do it, to use a resource decompiler. I had found: [https://evolutioninteractive.com/rezycle/rezycle.html](https://evolutioninteractive.com/rezycle/rezycle.html) (this is mac, not sure if useful) Im not sure what the fitter.h file is, I looked it up online and didn't find anything of the sort. There is a fit.h I think somewhere within lightspeed itself, not sure if related. I emailed Bill from the page you linked so maybe he can shed a bit more light on the mess. Unfortunately everything I've shared is all. From the yahoo user group. Except for the actual QLSconvert .mbn file (which is the one already in the emulator that you're running) [https://pastebin.com/utwkUN82](https://pastebin.com/utwkUN82) By extract the code, you mean extract from this file yes? Interesting, I can pass that information off to aburgwedel as I have his email address, he was sure it was a 24-bit problem. I can send you his email address too if you like, he knows way more than me on this. He's also working on this but hasn't had much luck either. By working sd file, you mean any working sd file? Or paired specifically with the k250 soundfile? Not sure anyone has actually even tried the conversion to sd.
Why do you need the children ordered in that way?
It's for an assignment. I need a way to swap everything to the left of the root with everything to the right of the root if that makes sense
Wrong sub :) C != C++
Oh my bad, new to Reddit
No worries. It happens very often here :D
You should be able to figure out which elements of the array correspond to which positions in the heap, and from that, you can decide how to rearrange the elements of the array so that the two sub-trees are swapped.
int (*fptr[2])(int, int)= {add, mul};/*its working*/ its not possible in one shot i can pass address like above?
Also, its possible I have the wrong Lightspeed C. The version I packed into the dsk file is 3.0.1. I assumed it was that version since Bill never mentioned which version he used
It's an array, you cannot assign into it. memcpy could work, or make it a struct. Third option (beware when the unnamed array goes out of scope) int (**fntab)(int, int); fntab = (int (*[])(int, int)) { add, mul };
This is awesome for someone of his age, congratulations! Fun exercise, the following snippet of his `if (miners &gt; 0) { gold = gold + miners; }` can just be written `gold += miners;`, see if he can realize why :o) Keep up the great work!
In the end, are you getting the benefit from threads that you desire? Would it be simpler to use a regular event loop, with select or equivalent ?
I have updated the code still issue is there. Kindly check.
Did someone already mention setlinebuf(stdout);
This is hard to read without formatting.
Reformatted, because Reddit does not support the ```[language] syntax: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;sys/time.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #define true 1 #define false 0 ///////////////////////////// //Define your variables ///////////////////////////// int health = 100; int your_mine = 1; int gold = 0; int gold_coins = 0; int robots = 0; int mine_lvl = 1; int miners = 0; int playing = 1; int progress = 0; int enemy_robots = 0; int enemydam = 0; int yourrobotsdam = 0; int battle_robot = 0; int regen_activated = false; int g; double timer; ///////////////////////////// //Define your strings ///////////////////////////// char name[80]; char option[80]; ///////////////////////////// //Define your functions ///////////////////////////// void raid(void); void battle(void); double seconds(void); int main(void) { srand (time(0)); printf("====================\n"); printf("| Gold mines |\n"); printf("+------------------+\n"); printf("| By neo |\n"); printf("====================\n\n"); printf("What is your name? "); fgets(name, 80, stdin); name[strcspn(name, "\n")]=0; printf("====================\n"); printf("Hello, %s\n", name); timer = seconds(); while ( playing ) { printf("====================\n"); printf("\n\n\n\n\n"); printf("Mission: raid 5 bases\n"); printf("Progress: %d\n\n", progress); printf("You have %d gold\n", gold); printf("You have %d SUPER BATTLE ROBOT\n", battle_robot); printf("You have %d robots\n", robots); printf("You have %d miners\n", miners); printf("Your base health is %d\n\n", health); printf("What do you want to do?\n\n"); printf(" 1.mine\n 2.worker ($20)\n 3.robot ($50)\n 4.raid\n 5.super battle robot ($1000)\n"); printf(" 6.fix\n 7.help\n 8.quit\n"); fgets(option, 80, stdin); option[strcspn(option, "\n")]=0; g = atoi(option); printf("====================\n"); if (miners &gt; 0) { gold = gold + miners; } switch(g) { case 1: gold++; continue; case 2: if (gold &gt;= 20) { if (miners &gt;= 50) { printf("\n"); printf(" =================================================\n"); printf(" | NOTICE: Your maximum amount of workers is 50. |\n"); printf(" =================================================\n\n"); continue; } else { gold = gold - 20; miners++; } } continue; case 3: if (gold &gt;= 50) { gold = gold - 50; robots++; } continue; case 4: raid(); break; case 5: if (gold &gt;= 1000) { if (battle_robot &gt;= 5) { printf("\n"); printf(" ===========================================================\n"); printf(" | NOTICE:Your maximum amount of super battle robots is 5. |\n"); printf(" ===========================================================\n\n"); continue; } else { printf("You got a SUPER BATTLE ROBOT!!!\n"); battle_robot++; gold = gold - 1000; } } continue; case 6: if (gold &gt;= 500) { if (miners &gt; 0) { gold = gold + miners; } gold = gold - 1000; health = health + 20; } continue; case 7: printf("\n 1.mine\n 2.worker ($20)\n 3.robot($50)\n 4.raid\n 5.super battle robot($1000)\n"); printf(" 6.fix\n 7.help\n 8.quit\n"); continue; case 8: return 0; continue; default: if (miners &gt; 0) { gold = gold - miners; } continue; } if (progress &gt;= 5) { printf("Yes! You completed your mission to destroy 5 bases!\n"); timer = seconds()-timer; int min = ((int)timer) / 60; int sec = ((int)timer) % 60; timer -= (min*60)-sec; int ms = (int)timer*1000; printf("New world record: %d:%d.%d\n\n", min, sec, ms); exit(0); } } return 0; } void raid (void) { enemy_robots = rand() % (10+(10*progress)) + (10+(10*progress)); printf("You face a base with %d robots!\n", enemy_robots); battle(); } void battle(void) { int base_damage = 5; while (robots &gt; 0) { enemydam = rand() % 10 + 1; yourrobotsdam = rand() % 5 + 1; sleep(2); printf("\nYour robots: %d\n", robots); printf("\nYour super battle robots: %d\n", battle_robot); printf("\n"); if (enemy_robots &lt; 0) enemy_robots = 0; printf("Enemies robots: %d\n", enemy_robots); enemy_robots = enemy_robots - yourrobotsdam; if (enemy_robots &lt; 0) enemy_robots = 0; robots = robots - enemydam; printf("\n"); sleep(2); if (enemy_robots &lt;= 0) { progress++; printf("Yes! you destroyed one of your enemy base!\n"); printf("You got 10 peices of gold.\n\n"); gold = gold + 10; sleep(5); return; } if (battle_robot &lt; 0) battle_robot = 0; if (robots &lt; 0) robots = 0; if (battle_robot &lt;= 0 &amp;&amp; robots &lt;= 0) { printf("Oh-no! Your robots are now a giant pile of junk!"); base_damage = base_damage + enemydam*5; printf("Your base lost %d health!\n", base_damage); health = health - base_damage; sleep(5); return; } if (battle_robot != 0) { enemy_robots = enemy_robots - (rand() % 10 + 1)*battle_robot; battle_robot--; continue; } } if (health &lt;= 0) { printf("Oh-no! Your base has been destroyed! You lose!\n\n"); exit(0); } } double seconds(){ struct timeval t; gettimeofday(&amp;t, NULL); return (t.tv_sec+(t.tv_usec/1000000.0)); }
&gt; I've tried looking into `pthread_kill()`, but that doesn't work because you can't do it on the main thread. The obvious solution is to do the blocked waiting on a separate thread that is not the main thread. You could also send yourself (and handle) a signal. This interrupts pending system calls and give the main thread a chance to stop waiting.
I don't understand why they still don't support GitHub Markdown, tabbing code is so annoying.
Reddit does support the ``` syntax, but unfortunately only in the redesign, not the old design.
Thanks for noticing me, this is pretty much a TIL for me.
It looks fine on my screen. Did you disable Javascript? Reddit has supported markdown in the editor for quite some time.
Hell dude this even inspires ME! May I suggest showing him some of handmade hero?
http://www.backerstreet.com/rec/rec.htm Maybe this might help?
https://libzip.org/
&gt;asking how to make your own decompression software to zipbomb your machine This is a whole new level we're reaching
Getting rid of the ‘if’ as well? That sounds like an anti-pattern
[How to ask a good question](https://stackoverflow.com/help/how-to-ask)
It would only change behavior if `miners` can be negative for some reason. Otherwise the `if` is just preventing the addition of zero; a noop.
Many, many C programmers do not recommend LCTHW because it lacks thorough explanations needed for beginners.
Not sure about that chief. If miners can equal zero it's perfectly acceptable to simple add miners to gold.
Does it REALLY need to be in C? You can easily do this with Unix commands and bash.
&gt;easily I can't remember a single tar command. Maybe `-xvf` to decompress tar.gz files
Here's a screenshot: https://imgur.com/a/251XBKm
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/PqfNpvP.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme)^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20ep5lq8e)
Genuinely curious, are you reacting this way because you agree or disagree with what /u/deleveld is doing?
I'm just wondering how does he know that C is supposedly fast if he doesn't have experience with other languages.. sounds to me like bias/quick internet research. limiting yourself to one language is limiting your future to such language, i hope he can make web apps in c if he's planning on at least gathering web development experience in the future.
It is, but declare it as static int (*const FPTR[])(int, int) = {add, mul}; `static` because you only ever need one copy of `FPTR` and it can be filled in entirely at link time. `const` because you don’t want to change it. The `static` and `const` put this array into almost the same class of object as a string literal.
&gt; i hope he can make web apps **uhhh**
Handmade Hero is an excellent resource. The author details the nitty gritty of game development.
its quite a fundamental area of knowledge today, wheter you like it or not, that's reality.
I'll just put this bluntly: Web development is not even programming. If you want more details, feel free to ask.
I'm just going to pretend you didn't say that. :|
Pretend away.
If he likes C he may like Go as well.
It's likely not possible to do something like this directly or with the syntax you imagine. One hack you could try is to make use of the `offsetof` macro to compute the start of the desired field in the structure and then use pointer arithmetic: var = offsetof(structure, age); /* auxillary function, assumes the field has type int */ static int *mkmember(struct foo *structure, size_t var) { return (void *)structure + var; } ... /* access structure.age through var */ *mkmember(structure, var) = foo; Note that this does not take care of different types. You must make sure that the types match.
I may not be seeing the bigger picture here but I don't think that would work in this case because I need to order a vector of structures using its attributes and the user can choose which attribute he wants to use as a parameter to order them. Since most of them are integers, I wanted to make a single function that would work for all integers attributes. Do you have any tips?
This reminds me of the time I was in 6th grade. We have had a Computer Science teacher who taught Programming and made me very passionate of it. I began making small games as a hobby. My teacher has found out of my hobby and greatly supported me. We would meet privately and we would make programs together. Very fun times. But, after 6th grade the teacher left the town. I have got a grumpy teacher replacing her, so my passion got extinguished. All respect to your son and continue supporting him in his passion.
This would work perfectly for that. Why do you think this doesn't work?
You're right, I was thinking in calling that function before calling the function to order the structure but that doesn't make sense. Gonna give that a try. Thanks
It would easier to find answers if you actually have a specific question. If you want to do something with an STM32 or whatever, a good place to start would be to buy an eval board for the chip you're looking at, download the STM32 SDK for your part, and start from the example code they provide.
&gt; Basically where should I look for information regarding programming hardware (more advanced than arduino) in C/C++ &gt; &gt; That was the question, my bad for being long winded. I'll have a look into some evaluation boards and see where I get to.
Awesome! This is so cool, I love hearing about kids getting into programming from gaming. Have you discussed programming this with an OO outlook? How does he fare with OO concepts?
I have fixed the error but still getting error - &gt; free(): double free detected in tcache 2: Any Ideas? I have updated the code at github. ./a.out Choose an option from below menu: 1. Add book information 2. Display book information 3. List all the books of an author 4. List the title of specified book 5. List count of books in library 6. List book ordered by accession number 7. Exit 1 Enter accession number 234 Enter Title of the book Rollings Enter Book Author J.K Rollings Enter price of the book 205.60 Choose an option from below menu: 1. Add book information 2. Display book information 3. List all the books of an author 4. List the title of specified book 5. List count of books in library 6. List book ordered by accession number 7. Exit 7 free(): double free detected in tcache 2 Aborted (core dumped)
&gt; Reddit does support the ``` syntax, but unfortunately only in the redesign, not the old design. (From my [comment above](https://www.reddit.com/r/C_Programming/comments/btxap4/battlec_by_neo_age_11/ep4ex5s/))
 if(1) while(TRUE) do_stuff_forever(); if is not a loop.
If I understand correctly, this means as soon as it gets the value 1 the if-statement starts and just goes on without stopping because it is now trapped in the while statement?
I can tell you the main resource professional firmware engineers use: stack overflow and google. There's not that much domain-specific programming knowledge you need to program bare-metal microcontrollers. If you understand what an interrupt and a memory-mapped register is, you're most of the way there on the fundamentals. Try to understand the basics of the peripherals you commonly find on microcontrollers - timers, GPIOs, SPI/I2C/UART serial buses, DMA controllers, analog &lt;-&gt; digital converters, etc. The best resource will likely your processor's reference manual and your microcontroller vendor's example code; from there, figure out problems as they actually arise.
Lmao, Are you doing DOA in unimelb
Yes. The OS will take care of all open resources like files, pipes, memory, sockets, mutex's, etc.
"Yes, a "memory leak" is simply memory that a process no longer has a reference to, and thus can no longer free. The OS still keeps track of all the memory allocated to a process, and will free it when that process terminates. In the vast majority of cases the OS will free the memory - as is the case with normal "flavors" of Windows, Linux, Solaris, etc. However it is important to note that in specialized environments such as various Real-Time Operating Systems the memory may not be freed when the program is terminated." https://stackoverflow.com/a/2975844/10992286
The if isn't trapped in anything, it's simply a branch. If the condition you give the if-statement is true, which the above always is cuz 1 evualates to true, it will execute the code in the if. In this case that's a while loop. This while loop's block will execute forever because the condition is always true.
That makes sense. Thanks!
&gt; The problem is the loop stops when I release the button (because the value isn't 1 anymore), but I want the stopwatch to go on and stop when I press the button again So enter the loop when you get the first event, and exit the loop when you get the second event. This is *really* basic stuff - I think you need to brush up a bit more on C’s flow control mechanisms before going to the internet with questions.
Yes, that's what the OS is for. However, it is worth freeing the memory yourself. You can also write your own "garbage collector" which is basically a system that keeps track of all your allocations and frees them when asked to (typically, when the program stops execution)
&gt; Reddit does support the ``` syntax, but unfortunately only in the redesign, not the old design. Oh. That explains it. Shame the new design is so horrible in every other respect.
Yes, as everyone else said, but free()ing is not hard and there are tools that help with it. Forgetting to free() won’t bite you until it does, like on embedded.
Sorry for asking.
You referenced an 'if-loop'. What do you mean by this? It's something I've heard beginner programmers say, but I've never seen it in any tutorial or helpful answer. In any case, I think I understand the problem. You want to measure the time between two button-presses, but instead it's measuring the duration of one button-press. Is this correct? If it is, I've written some pseudocode that should get you on track: timing = false forever { if (timing) { update zsec, sec, min if (button is pressed) { // second command you mentioned timing = false } } else { if (button is released) { // third command you mentioned timing = true } } write to the LCD screen } This is not the only way of solving the problem, and may not the best; but it should work when translated to actual C code. Also, just for clarification, can you tell me what the functions `startStopwatch1`, `setStopwatch1` and `getStopwatch1` each do? And what, precisely, is `zsec` measuring?
No, the internet is just one way to get input for your programs. We can agree that html/css is not though.
How does HM typing affect compile times? I don't know a thing about HM implementations. In general, I don't think anyone working in good faith and in the (weakly typed) spirit of C will find a need for type inference. Most anything that isn't a primitive will probably be automatically convertible to `void *` which will be convertible to any pointer type. When you do away with the unnecessary strict typing and just let the language reflect the machine model, beauty rings. The cost, of course, is that the compiler will not assist you when you pass an incompatible argument. But frankly, is this error really worth eliminating..? With POD data, the erroneous argument will either crash the program, give nonsense output (in the case of automatic coercion of primitives, which is one thing C is too liberal with!), or work as intended. It will be caught almost immediately.. There is the case of passing a structurally equivalent object that doesn't implement the interface the function expects, which can be a sneaky error. There are a few solutions for this, but C's solution is to not couple data with functions.
They do, only on the redesign, only reason it's only on the redesign? probably to push people to use it.
1. startStopwatch1 - starts a stopwatch within my microcontroller 2. setStopwatch1 - gives the stopwatch a value which I can set (e.g. 100 milliseconds) 3. getStopwatch1 - asks for how many milliseconds have passed since I started the stopwatch 4. stopStopwatch1 - stops a running stopwatch And zsec just means (1/10) of a second. Because I want my stopwatch to display mm:sec.zsec (minute, seconds, 100 milliseconds). My problem is that my commands only give me a 1 as output once and as soon as I release the button it returns a zero and so my if-condition doesn't get executed because it only gets executed when it gets a 1. So I want my if-condition to get executed as soon as it gets a 1 and after that even if the value is 0 again it shouldn't stop. It should stop when I press the button again and the value is 1 again.
Yes, but I wouldn't rely on it. First, it's bad practice. Except in very small test programs, I always make sure to free when I'm finished. It's really a pain and one of the most challenging aspects of C programming is memory management. Misread the docs for one function and you could leave a pointer dangling. It just takes a lot of vigilance. But second, there's no guarantee that ever OS will free the memory. Yes, on Linux, Windows and OS X it will free the memory when you're finished, but these are not the only operating systems around. There are a ton of embedded operating systems that might act differently, and if your code is ever run on an embedded system, that might cause a memory leak. Such memory leaks can be difficult to find as well, you might have an application running for a year before it fails at random, and at that point you've probably forgotten quite a lot about the code. Vigilance now will save major headaches later. Similarly, if you ever take code from a small one-off program and integrate it into a larger program, you might leak memory. I remember one program that calculated the antenna geometry for certain RF bands or something, I didn't understand it really but it output a big table. It was originally a command line program and no memory was freed, it didn't need to since the program exited immediately after that memory was used. However, later on it was integrated into another program but they neglected to free memory. This was in the 90s and those few KB added up over time because the program it was integrated into ran 24/7 and computers were really short on memory then. I think this computer only had 32MB of memory, most of which was taken by Linux and the X server. Just understand that it's not "right." A modern desktop OS absolutely will release all memory when you exit the program, but understand the limits and pitfalls.
Exactly! He takes the time to explain a lot of things, when he spoke of endianness my mind exploded to pieces haha
The redesign is horrible, I was on it for like 5 months before I just switched back out of frustration.
You need to do something like this: while (true) { while (poll_button_events() != button_pressed) { // do nothing while we busy-wait for event, maybe go to sleep } while (poll_button_events() != button_pressed) { do_stopwatch_stuff(); } finish_up_stopwatch_stuff(); // probably? }
Check out r/embedded. We discuss about embedded systems all the time and what you are describing seems to be an embedded system. &amp;#x200B; We have a wiki that mentions some resources as well. [https://us.reddit.com/r/embedded/wiki/index](https://us.reddit.com/r/embedded/wiki/index) You can check that and/or make a post there.
Thank you for your very interesting response! :-) &gt; This error is always caught immediately. I don't think this is correct. When converting non-compatible types to one-another by going through `void *`, AFAIK we enter undefined behaviour territory. Which, in my humble opinion, is significantly worse than raising it as an exception using some exception handling mechanism, which again is worse than passing it on as an explicit result data-type, which again is worse than catching these errors at compile-time to make it absolutely impossible that they ever occur. &gt; C's solution is to not couple data with functions, which happens to be both simple and elegant. In this, C enters slightly the realm of functional programming. The fact that it does not support first-class closures however, is clunky and leads to unelegant implementations. &gt; My general feeling about higher level language design is that some academic came up with a theoretically interesting language model and decided to make everyone learn it and write the proper tooling to make it practical to use, even though the status quo was both elegant and simple. After having hands-on experience with about fifteen different programming languages being imperative, object-oriented, functional, declarative and logic-based in nature, I can honestly say that (a) there is no perfect language, and (b) the more languages you know, the better you will become at approaching problems from different angles. The tools you use have a great effect on thinking. While complexity does not generally increase productivity, _abstractions_ (using the definition that Dijkstra coined in his Turing award speech) do and therefore are a very useful and important tool. Tangentially, building (non-leaky) abstractions in C is very difficult because of its (lack of) memory management and (lack of) polymorphism. I wholeheartedly recommend trying to tinker with as many different kinds of languages as possible. Don't be a blub programmer! :-) Wonderful to converse with you; have a nice evening over there!
I was on it for a day before I switched back.
&gt; How does HM typing affect compile times? I don't know a thing about HM implementations. Ah, I wanted to give you a proper answer to that as well: In theory, doing Hindley-Milner type inference can take exponential time. In practice, it is near-linear. [See this StackExchange answer for more info](https://cs.stackexchange.com/a/6619/53697).
&gt; a "memory leak" is simply memory that a process no longer has a reference to, and thus can no longer free. There are two types of memory leaks: memory still referenced by the program (and thus can be freed if desired), and memory not referenced (and thus can't be freed by the program). The second type is a *real* leak and the harmful type. The first type is called "[still reachable](https://stackoverflow.com/questions/3840582/still-reachable-leak-detected-by-valgrind/3857638#3857638)" by valgrind. LeakSanitizer classifies both types as leaks. It is a good practice to avoid both types of memory leaks.
The earliest versions of Mac OS would use the upper bits of a handle's master pointer as flags, since the 68000 would ignore everything beyond the bottom 24 bits. Some programs for the Mac would check the characteristics of a handle by examining those bits rather than using the OS call for the purpose (which in later version of the OS would get the information elsewhere). That's what 24 bits vs 32 bits usually means there. A more common issue for Macintosh code is that compilers generally allowed "int" to be configured as either 16 bits or 32 bits, and some programs required that setting to be one way or the other (code designed to be portable would use "short" for 16 bit values and "long" for 32-bit values, thus generally avoiding the need for most code to care about the size of "int" except when using variadic or non-prototyped functions). That wouldn't usually be called a 24-bit vs 32-bit issue, however.
While technically C++ this might help you: http://www.cplusplus.com/doc/tutorial/control/
Ok, I'm back from the trenches. Oh, the memories. There are a few files which are not used by the code, so in fact Fitter.h is not used. I was able to compile the app, but alas, I cannot link it, as it looks like the Pack.lib is needed. Unfortunately, library files were resources, so the content of this was lost. [Here is a screenshot of the resulting project and errors, if you are interested in reproducing it](https://imgur.com/a/lJGTW3C). Note: you need to reproduce the code segments (drag &amp; drop the files to create separate segments of less than 32K). We can work around the lack of resource file for data, as the can be extracted from the app, but the lack of Pack.lib is quite a hard stop. I'm looking if I missed something.
By working sd file, I was hoping to have both a qls file AND a sd file that matches AND that can go throught the current version of QLS Convert. That would have enabled me to try to port the conversion code, and see if I can get that same sd file from the code (looking into the file data, and following the algorithms). That said, by reading a bit the code around, it looks to me that the easiest conversion would be directly qls -&gt; wav. I may try to reverse engineer the files a some point. My worry is that the qls files present in the disk dump are not readable by the code (they are not readable by the QLS convert binary) because they ar ein a different version of the format, in which case the task would be next to imposible I'll sleep on it and think about it. I haven't given up yet :-) edit: on the resource decompiling, there are [standard tools that can do that](https://www.unix.com/man-page/osx/1/DeRez)
It only supports markdown on the new design, a lot of people have stuck with the older style because overall it looks and works better.
I'd actually like to know why you make this claim? I'm a student web developer and I do write code (Python, PHP, and JavaScript) so I'm not entirely sure how that wouldn't be programming.
If converting to `void*` is undefined territory, then the majority of the C standard library is non-standard :P
Download the datasheet for the CPU on the Arduino. Download IAR Workbench (free). There are lots of tutorials and examples inside IAR and Arduino for interfacing directly with the hardware.
Oh thats good news about Fitter.h! I just got word back from Bill (that was fast) he says he can look into it as well...since you're way beyond the point I reached, his new email is: billg@wavearts.com I've said to him this is as far as we have got, but the Pack.lib is missing. Maybe he'll have an idea about this.... I'll look into it too now
Oh well hell, if you can go directly to WAV thats even better. I had thought about that too. There is a program called "awave studio" that opens most soundfiles in HEX, but alas it didnt work. Awave however does support Sound Designer 1 files, so that was going to be my route for sd-&gt;wav. I think Alex Burgwedel might know (no guarentee) about the format of the soundfiles themselves (sent you his email) since he was the one that uploaded them. Oh, that Derez program, as well as SADerez is in Think C version 6.0. I saw it in there when I tried it out.
Why must C be used for one program and Python be used for the other?
Good question The main program has already been written in C, and this is an addition. Python has the libraries we need to make our lives 10 times easier, and there isn't a widely accepted C library that suits our needs
Use your operating systems built-in API for inter-process communication. Or just create files and read/write to them.
how to use unx command can yo tell me please?
If the kid is learning C now, he's gonna be going places! Good on you for getting your son started early!
You could try embedding the python interpreter in your C code.
Aside from the fact that at some point every web app interacts with C code, and the machines that pass packets around the internet are coded in C, and the firmware on the chips that run your networking cards are written in C - It isn't a fundamental area of knowledge. It's a fundamental area of employability. Which I can tell you I doubt this kid is going to have to worry about. I'd be more concerned he learns good social skills than javascript....
Unless the constraint that miners is always greater than zero changes. We don't know what grand vision neo has for version 2.0.
Nlohmann json. This is for C programming
You can search github for json parsers. JSON for modern C++ seems like a popular one. [https://github.com/nlohmann/json](https://github.com/nlohmann/json) You can check out other ones too and see which ones will work for your project.
sorry, i assumed yall would do booth. my b
Thank you.
Boost also has a parser. Here is an example of using boost: [https://gist.github.com/voges/2c2e9cb1e73d10c1acd27e664554c3f9](https://gist.github.com/voges/2c2e9cb1e73d10c1acd27e664554c3f9) Use google instead of youtube when looking for these resources.
C\_programming is a subreddit for C language. There are other subreddits for C++, such as /r/cpp or even more appropriate /r/learncpp where this would be more relevant
For almost every modern PC/Server operating system, "yes". In some specialist/minimalist operating systems for specific platforms/architectures (you'd know if you were using them) the answer becomes "it depends". In freestanding mode, consult the documentation because there are no guarantees.
[https://www.reddit.com/r/cpp\_questions/](https://www.reddit.com/r/cpp_questions/) is more active
Handmade hero is great, but he's probably not yet at a level where he would be able to tackle it. I'd say wait a year or two, and then.
&gt; it is worth freeing the memory yourself Disagree. Slows down your program for no discernible gain.
There are attempts to do just that. Zig and odin come to mind.
That is not what I mean. What I mean is: converting from a `struct foo *` to a `void *` and then to a `struct bar *` is almost always undefined territory.
this is extremely cool and amazing honestly. i would like to point out some improvements though. first of all, globals. i don't really be THAT guy, but yeah. second, make sure he's well versed in the standard library. the defines for true &amp; false are completely unnecessary with the existence of stdbool.h. thanks for sharing.
&gt;If possible, the data won't be a simple string to stdout but a data set (i.e. an array from info I guess). You will have to serialize it anyway. Choose whatever you like (ProtoBuf, JSON, ASN.1, your own format, ...) and the transport will be a matter of personal preference and need. IP sockets, Unix sockets, stdin/stdout, system IPC (including higher level, like DBus), message queue, static file, quantum entanglement, ...
Well, the standards folks aren't keen on the weakly typed spirit of C. When you have advocates of strong typing writing the spec for C, yeah, you're going to see a strange number of portable "undefined" behavior.
There are two difference processes here one for C and the other for Python. So you should make them can communicate with other by using IPC (Inter-Process Communication) to send and receive message and data.
Yes, but OS will take effort to recovery memory and it will affect with another application is running. The best way is that you should manage by yourself.
In terms of finding repeating numbers in a array, I’d suggest running a merge sort and during the merge process, if a comparison come back equal, stamp those 2 element. Questions like this should be posted on r/algorithms or stackoverflow. Hope this helps.
Thank you very much for the quick answer! I'm gonna read something on the topic, I have never used a "merge sort" algo, but sounds like the tool that I need for this problem. Also wasnt aware of the existence of that sub, I'm gonna check it right now :) Sorry if the post was offtopic and thank you again for the tip! Have a nice day
You noticed he was 11, right? More important to have fun. Even if he had read online C is fast, what does it matter if that gets him excited? Its bad enough as an adult putting up with the endless drone of "learn this to get jobs". It's so dull. Programming is pure creation, and a joy. Let him learn that. The rest follows.
What if bar is the first element in foo? I believehe standard guarantees that there is no padding before the first element, and this is how "inheritance" in C can be done..
Why would one corrupt such an innocent soul ?
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
and a whole bunch of C-likes
I think they meant programming should be more back-end-focused, whereas web development deals with UI/UX design more than logic. In this sense, web development isn't programming as much as C programming is "programming". And frankly, I'm with him on this one.
I doubt freeing unused memory will incur performance problems for 99.9% of C programs, and in the rare case it does, the programmer should know that's an exception not the rule. Also there are gains in freeing unused memory: * the user of your program won't eventually run out of memory on his machine * users may be reluctant in choosing to use your program because it doesn't free memory(even if they don't realise that the program is doing this, they'll notice that after running a while, your program starts to slow down their machine), so freeing memory gets your program more use, which I assume is a good thing most of the time. However, I'm curious to know why you say that freeing memory slows down your program, so it'd be nice to hear your reasons.
are you familiar with allocating memmroy with the `malloc()` family of functions? if not, i think reading up on it may help.
Operating systems do not allow you to have more than a few 10000 fille descriptors open at the same time. Setting yourself a sane upper limit and just allocating that many file descriptors sounds like a fine approach. If you want to have a solution that is technically elegant, dynamically reallocate your array if it gets too small. Or use linked lists.
You can use linked list
realloc is my bff
In your nested for-do-while-for loop, &gt;j=i+1 You are checking on elements not iterated by i yet, you should check all but skip i==j element. &gt;if ( a[i] != b[j] ) &gt;{ &gt; c[i]=a[i]; &gt; conta++; &gt;} This has logical error(s). &gt;while (a[i]==b[j]); The do-while condition is getting b[N] which is out of bounds because j exit the loop when j == N. Actually you can start with putting inputs in array a and leaving b empty. Go through array a. If the element cannot be found in array b, put it in array b and increment count (your conta).
realloc just strikes me as something that runs the risk of making things too complicated, which could lead to memory leaks because it isn't as "clean" as allocating the memory when you need it, and then when you are done with it, freeing it. If you need more, just allocate again. I just outright avoid it, so I'm curious as to why you are so fond of it.
Realloc does exactly that though. But it has the benefit of expanding if the new size is in the block or a contiguous block. Having to malloc, copy, and free an array to expand it is redundant of realloc. I
&gt; Operating systems do not allow you to have more than a few 10000 fille descriptors open at the same time. `ulimit -n` on my OS says 131072. *In theory*, OS may allow to open a crazy number of files at the same time.
Perfectly valid, but it's generally a good rule of thumb to code in expected ways, so other engineers immediately understand what you were doing. If you're going to defy conventions, you should have a good reason, and document accordingly. When I use empty loops, I keep the brackets like so: while ( *foo++ = *bar++ ) { ; }
Could also simply use built-in `qsort`, then iterate through the sorted array checking adjacent values. Because the second part has linear complexity, the overall algorithm is still O(nlogn).
And in theory C is not Turing complete. Do you want to write theoretical or practical programs?
Isn't file descriptor something like FILE\* ? &amp;#x200B; Use \`FILE\* fdArray\[\] = NULL;\` and do \`fdArray = realloc(fdArray, newFdCount \* sizeof(fdArray\[0\]));\` when you need more space.
&gt;But it has the benefit of expanding if the new size is in the block or a contiguous block. How often are you doing this? I'm not saying it doesn't have it's place, but you labeled it as a "bff" which makes me think you are using it all the time.
If you don't touch the upper parts before they are needed, straight malloc of os\_limit pointers wouldn't be that expensive. Virtual memory, not there yet.
A lot of my projects involve growable arrays. It's really the only thing I use it for, but usually only thing I malloc is arrays.
&gt; And in theory C is not Turing complete. Pretty sure this is wrong, but if it is right I would like to read about it ... can you provide a link?
&gt; the thing I'm unhappy about is the 255 You get an upvote just for that. Any engineer should get nervous every time they see an arbitrary fixed-size buffer. I think this is a Unix thing, not a C thing, but `sysconf(_SC_OPEN_MAX)` will give you the actual maximum number of open file descriptors your program can have. I'm sure there's a Windows equivalent. Given that value, you could use malloc() to create a buffer with enough pointers. Another approach would be to define a data structure that hold all of the fd-specific information (that char * pointer would be only one piece of information) and then manage a linked list of such structures.
Basically, a C program is finite and the amount of memory it can access (both direct and through files) is finite, too. A machine that can access but a finite amount of storage is not capable of emulating all Turing machines.
I don't think that makes C turing incomplete I think that makes the machine the C program is running on turing incomplete because theoretically C could be compiled to a machine with infinite memory
Correct! That is the single case I can think of (besides foo or bar being an e. g. typedef'd alias of one another) that warrants the 'almost'.
I only just recently had a case where this was actually the nicest way to write something. I was iterating over an array and passing every other element to a function, where the function would give back the number by which to increment the pointer. Something like this: for (i = 0; i &lt; maxlen; i += dosomething(i));
The assumption of "a few 10000" can be wrong. It is good to avoid such unnecessary assumptions. Meanwhile, declaring an array of `fd[30000]` is a waste of stack space 99.99% of time. Realloc() only takes a few more lines. OP should do that instead.
A C program cannot address an infinite amount of memory: * every object has a finite size bounded by `SIZE_MAX` * every object has a distinct address * addresses survive being converted to `uintptr_t` and back * the type `uintptr_t` has a finite range * thus the amount of objects is limited to the maximum of `uintptr_t` * thus the size of the memory of a C program is limited to `SIZE_MAX` times `uintptr_t` bytes * which have a finite size, `CHAR_BIT` bits, too Similarly, since C programs have a finite length in source code representation, you can only store a finite amount of information in the instruction pointer.
I've seen some compilers written in C which intentionally never free memory. Combined with a custom first-fit memory allocator, you can get a discernible performance increase because the program spends essentially no time in allocation or deallocation routines.
For `realloc` to really work well, it would need to know about the likely future lifetime of the block as well as whether it would be expanded again or shrunk. Unfortunately, even though a programmer who uses `realloc` may be able to predict such things pretty well, there's no way to convey such information to the implementation.
One could define a Turing-complete subset of C which does not allow the use of any arithmetic operators or I/O on character-type values produced by inspecting the underlying representations of pointers. Since any program written in that subset would be a valid C program, the language as a whole would be Turing-complete.
Well, it's perfectly valid C, but I think the best practice here is to follow the conventions and idioms of the existing code in your codebase. If your code already uses constructs like that everywhere, go for it. If it doesn't, it just reduces readability. I would just stick to the more common convention of putting the main functionality of the loop is in the body unless there's a good reason to break it.
C is definitely Turing complete. The standard is whether it can emulate a Turing machine, not whether it has infinite memory. Nothing in the real world has infinite memory.
The simplest, but not most efficient, is to populate a map. Duplicate entries overwrite prior ones. If you cannot #include myhash.h, then use qsort() and fill the 2nd array with any element not seen in 1st sorted array. You are not interested in the location of the values, so a stable merge sort is not required. For a stable merge sort, you need to edit the qsort() comparison callback to return an index.
I use a vector struct quite a lot, it's just like the c++ variant; reallocing to double the previous size when the limit is reached. And if i'm done with it i have a function which reallocs a final time to the final size if needed (most of the time it's not). So i guess the bff is shared haha
Every implementation of the C language is unable to emulate some Turing machines. Some languages, like Brainfuck, are truely Turing complete.
That would not be a proper subset as it has less constraints than the original language. It's only a subset if every program in the subset does the exact same thing in C.
A file descriptor over here is an int, the FILE structure adds some buffer handling i believe. See fcntl.h for the lower level handling.
I have updated the code and implemented Display book information but when I choose option 1. Add book information and add a book and then choose option 2. Display book information to display entered information all I get is either empty, null or 0.0000. Why?
I might be missing something, but default malloc, copy, and free doesn't really have that either though?